<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4019 - in	branches/avidemux_2.5_branch_gruntster/avidemux: .	ADM_coreImage/include ADM_coreImage/src ADM_filter ADM_video	ADM_videoFilter plugins/ADM_videoFilters	plugins/ADM_videoFilters/BlendRemover plugins/ADM_videoFilters/Delta	plugins/ADM_videoFilters/Denoise plugins/ADM_videoFilters/DropOut	plugins/ADM_videoFilters/Pulldown
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4019%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%20.%0A%09ADM_coreImage/include%20ADM_coreImage/src%20ADM_filter%20ADM_video%0A%09ADM_videoFilter%20plugins/ADM_videoFilters%0A%09plugins/ADM_videoFilters/BlendRemover%20plugins/ADM_videoFilters/Delta%0A%09plugins/ADM_videoFilters/Denoise%20plugins/ADM_videoFilters/DropOut%0A%09plugins/ADM_videoFilters/Pulldown&In-Reply-To=%3C200805041705.m44H5oLS001799%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001277.html">
   <LINK REL="Next"  HREF="001279.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4019 - in	branches/avidemux_2.5_branch_gruntster/avidemux: .	ADM_coreImage/include ADM_coreImage/src ADM_filter ADM_video	ADM_videoFilter plugins/ADM_videoFilters	plugins/ADM_videoFilters/BlendRemover plugins/ADM_videoFilters/Delta	plugins/ADM_videoFilters/Denoise plugins/ADM_videoFilters/DropOut	plugins/ADM_videoFilters/Pulldown</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4019%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%20.%0A%09ADM_coreImage/include%20ADM_coreImage/src%20ADM_filter%20ADM_video%0A%09ADM_videoFilter%20plugins/ADM_videoFilters%0A%09plugins/ADM_videoFilters/BlendRemover%20plugins/ADM_videoFilters/Delta%0A%09plugins/ADM_videoFilters/Denoise%20plugins/ADM_videoFilters/DropOut%0A%09plugins/ADM_videoFilters/Pulldown&In-Reply-To=%3C200805041705.m44H5oLS001799%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4019 - in	branches/avidemux_2.5_branch_gruntster/avidemux: .	ADM_coreImage/include ADM_coreImage/src ADM_filter ADM_video	ADM_videoFilter plugins/ADM_videoFilters	plugins/ADM_videoFilters/BlendRemover plugins/ADM_videoFilters/Delta	plugins/ADM_videoFilters/Denoise plugins/ADM_videoFilters/DropOut	plugins/ADM_videoFilters/Pulldown">mean at mail.berlios.de
       </A><BR>
    <I>Sun May  4 19:05:50 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001277.html">[Avidemux-svn-commit] r4018 - in	branches/avidemux_2.5_branch_gruntster: . cmake
</A></li>
        <LI>Next message: <A HREF="001279.html">[Avidemux-svn-commit] r4020 - in	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog:	. resources
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1278">[ date ]</a>
              <a href="thread.html#1278">[ thread ]</a>
              <a href="subject.html#1278">[ subject ]</a>
              <a href="author.html#1278">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-05-04 19:05:41 +0200 (Sun, 04 May 2008)
New Revision: 4019

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_interlaced.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_mmxMacros.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_vidFieldUtil.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_interlaceUtil.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_vidFieldUtil.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Delta/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Delta/ADM_vidDelta.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Delta/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Denoise/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Denoise/ADM_vidDenoise.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Denoise/ADM_vidDenoise.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Denoise/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DropOut/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DropOut/ADM_vidDropOut.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DropOut/ADM_vidDropOut.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DropOut/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Pulldown/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Pulldown/ADM_vidPulldown.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Pulldown/ADM_vidPulldown.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Pulldown/CMakeLists.txt
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/mmx_macros.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDelta.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.h
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDeintASM.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSeparateField.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSoften.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidStabilize.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSwapFields.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSwapSmart.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidHardIvtcRemoval.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt
Log:
[Merge]


Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_interlaced.h (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_interlaced.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,3 @@
+
+
+uint32_t      ADMVideo_interlaceCount( uint8_t *src ,uint32_t w, uint32_t h);

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_mmxMacros.h (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/mmx_macros.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/mmx_macros.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_mmxMacros.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,706 @@
+/*	mmx.h
+
+	MultiMedia eXtensions GCC interface library for IA32.
+
+	To use this library, simply include this header file
+	and compile with GCC.  You MUST have inlining enabled
+	in order for mmx_ok() to work; this can be done by
+	simply using -O on the GCC command line.
+
+	Compiling with -DMMX_TRACE will cause detailed trace
+	output to be sent to stderr for each mmx operation.
+	This adds lots of code, and obviously slows execution to
+	a crawl, but can be very useful for debugging.
+
+	THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY
+	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
+	LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+	AND FITNESS FOR ANY PARTICULAR PURPOSE.
+
+	1997-99 by H. Dietz and R. Fisher
+
+ Notes:
+	It appears that the latest gas has the pand problem fixed, therefore
+	  I'll undefine BROKEN_PAND by default.
+*/
+
+#ifndef _MMX_H
+#define _MMX_H
+
+
+/*	Warning:  at this writing, the version of GAS packaged
+	with most Linux distributions does not handle the
+	parallel AND operation mnemonic correctly.  If the
+	symbol BROKEN_PAND is defined, a slower alternative
+	coding will be used.  If execution of mmxtest results
+	in an illegal instruction fault, define this symbol.
+*/
+#undef	BROKEN_PAND
+
+
+/*	The type of an value that fits in an MMX register
+	(note that long long constant values MUST be suffixed
+	 by LL and unsigned long long values by ULL, lest
+	 they be truncated by the compiler)
+*/
+typedef	union {
+	long long		q;	/* Quadword (64-bit) value */
+	unsigned long long	uq;	/* Unsigned Quadword */
+	int			d[2];	/* 2 Doubleword (32-bit) values */
+	unsigned int		ud[2];	/* 2 Unsigned Doubleword */
+	short			w[4];	/* 4 Word (16-bit) values */
+	unsigned short		uw[4];	/* 4 Unsigned Word */
+	char			b[8];	/* 8 Byte (8-bit) values */
+	unsigned char		ub[8];	/* 8 Unsigned Byte */
+	float			s[2];	/* Single-precision (32-bit) value */
+} __attribute__ ((aligned (8))) mmx_t;	/* On an 8-byte (64-bit) boundary */
+
+
+
+/*	Function to test if multimedia instructions are supported...
+*/
+inline extern int
+mm_support(void)
+{
+	/* Returns 1 if MMX instructions are supported,
+	   3 if Cyrix MMX and Extended MMX instructions are supported
+	   5 if AMD MMX and 3DNow! instructions are supported
+	   0 if hardware does not support any of these
+	*/
+	register int rval = 0;
+
+	__asm__ __volatile__ (
+		/* See if CPUID instruction is supported ... */
+		/* ... Get copies of EFLAGS into eax and ecx */
+		&quot;pushf\n\t&quot;
+		&quot;popl %%eax\n\t&quot;
+		&quot;movl %%eax, %%ecx\n\t&quot;
+
+		/* ... Toggle the ID bit in one copy and store */
+		/*     to the EFLAGS reg */
+		&quot;xorl $0x200000, %%eax\n\t&quot;
+		&quot;push %%eax\n\t&quot;
+		&quot;popf\n\t&quot;
+
+		/* ... Get the (hopefully modified) EFLAGS */
+		&quot;pushf\n\t&quot;
+		&quot;popl %%eax\n\t&quot;
+
+		/* ... Compare and test result */
+		&quot;xorl %%eax, %%ecx\n\t&quot;
+		&quot;testl $0x200000, %%ecx\n\t&quot;
+		&quot;jz NotSupported1\n\t&quot;		/* CPUID not supported */
+
+
+		/* Get standard CPUID information, and
+		       go to a specific vendor section */
+		&quot;movl $0, %%eax\n\t&quot;
+		&quot;cpuid\n\t&quot;
+
+		/* Check for Intel */
+		&quot;cmpl $0x756e6547, %%ebx\n\t&quot;
+		&quot;jne TryAMD\n\t&quot;
+		&quot;cmpl $0x49656e69, %%edx\n\t&quot;
+		&quot;jne TryAMD\n\t&quot;
+		&quot;cmpl $0x6c65746e, %%ecx\n&quot;
+		&quot;jne TryAMD\n\t&quot;
+		&quot;jmp Intel\n\t&quot;
+
+		/* Check for AMD */
+		&quot;\nTryAMD:\n\t&quot;
+		&quot;cmpl $0x68747541, %%ebx\n\t&quot;
+		&quot;jne TryCyrix\n\t&quot;
+		&quot;cmpl $0x69746e65, %%edx\n\t&quot;
+		&quot;jne TryCyrix\n\t&quot;
+		&quot;cmpl $0x444d4163, %%ecx\n&quot;
+		&quot;jne TryCyrix\n\t&quot;
+		&quot;jmp AMD\n\t&quot;
+
+		/* Check for Cyrix */
+		&quot;\nTryCyrix:\n\t&quot;
+		&quot;cmpl $0x69727943, %%ebx\n\t&quot;
+		&quot;jne NotSupported2\n\t&quot;
+		&quot;cmpl $0x736e4978, %%edx\n\t&quot;
+		&quot;jne NotSupported3\n\t&quot;
+		&quot;cmpl $0x64616574, %%ecx\n\t&quot;
+		&quot;jne NotSupported4\n\t&quot;
+		/* Drop through to Cyrix... */
+
+
+		/* Cyrix Section */
+		/* See if extended CPUID level 80000001 is supported */
+		/* The value of CPUID/80000001 for the 6x86MX is undefined
+		   according to the Cyrix CPU Detection Guide (Preliminary
+		   Rev. 1.01 table 1), so we'll check the value of eax for
+		   CPUID/0 to see if standard CPUID level 2 is supported.
+		   According to the table, the only CPU which supports level
+		   2 is also the only one which supports extended CPUID levels.
+		*/
+		&quot;cmpl $0x2, %%eax\n\t&quot;
+		&quot;jne MMXtest\n\t&quot;	/* Use standard CPUID instead */
+
+		/* Extended CPUID supported (in theory), so get extended
+		   features */
+		&quot;movl $0x80000001, %%eax\n\t&quot;
+		&quot;cpuid\n\t&quot;
+		&quot;testl $0x00800000, %%eax\n\t&quot;	/* Test for MMX */
+		&quot;jz NotSupported5\n\t&quot;		/* MMX not supported */
+		&quot;testl $0x01000000, %%eax\n\t&quot;	/* Test for Ext'd MMX */
+		&quot;jnz EMMXSupported\n\t&quot;
+		&quot;movl $1, %0:\n\n\t&quot;		/* MMX Supported */
+		&quot;jmp Return\n\n&quot;
+		&quot;EMMXSupported:\n\t&quot;
+		&quot;movl $3, %0:\n\n\t&quot;		/* EMMX and MMX Supported */
+		&quot;jmp Return\n\t&quot;
+
+
+		/* AMD Section */
+		&quot;AMD:\n\t&quot;
+
+		/* See if extended CPUID is supported */
+		&quot;movl $0x80000000, %%eax\n\t&quot;
+		&quot;cpuid\n\t&quot;
+		&quot;cmpl $0x80000000, %%eax\n\t&quot;
+		&quot;jl MMXtest\n\t&quot;	/* Use standard CPUID instead */
+
+		/* Extended CPUID supported, so get extended features */
+		&quot;movl $0x80000001, %%eax\n\t&quot;
+		&quot;cpuid\n\t&quot;
+		&quot;testl $0x00800000, %%edx\n\t&quot;	/* Test for MMX */
+		&quot;jz NotSupported6\n\t&quot;		/* MMX not supported */
+		&quot;testl $0x80000000, %%edx\n\t&quot;	/* Test for 3DNow! */
+		&quot;jnz ThreeDNowSupported\n\t&quot;
+		&quot;movl $1, %0:\n\n\t&quot;		/* MMX Supported */
+		&quot;jmp Return\n\n&quot;
+		&quot;ThreeDNowSupported:\n\t&quot;
+		&quot;movl $5, %0:\n\n\t&quot;		/* 3DNow! and MMX Supported */
+		&quot;jmp Return\n\t&quot;
+
+
+		/* Intel Section */
+		&quot;Intel:\n\t&quot;
+
+		/* Check for MMX */
+		&quot;MMXtest:\n\t&quot;
+		&quot;movl $1, %%eax\n\t&quot;
+		&quot;cpuid\n\t&quot;
+		&quot;testl $0x00800000, %%edx\n\t&quot;	/* Test for MMX */
+		&quot;jz NotSupported7\n\t&quot;		/* MMX Not supported */
+		&quot;movl $1, %0:\n\n\t&quot;		/* MMX Supported */
+		&quot;jmp Return\n\t&quot;
+
+		/* Nothing supported */
+		&quot;\nNotSupported1:\n\t&quot;
+		&quot;#movl $101, %0:\n\n\t&quot;
+		&quot;\nNotSupported2:\n\t&quot;
+		&quot;#movl $102, %0:\n\n\t&quot;
+		&quot;\nNotSupported3:\n\t&quot;
+		&quot;#movl $103, %0:\n\n\t&quot;
+		&quot;\nNotSupported4:\n\t&quot;
+		&quot;#movl $104, %0:\n\n\t&quot;
+		&quot;\nNotSupported5:\n\t&quot;
+		&quot;#movl $105, %0:\n\n\t&quot;
+		&quot;\nNotSupported6:\n\t&quot;
+		&quot;#movl $106, %0:\n\n\t&quot;
+		&quot;\nNotSupported7:\n\t&quot;
+		&quot;#movl $107, %0:\n\n\t&quot;
+		&quot;movl $0, %0:\n\n\t&quot;
+
+		&quot;Return:\n\t&quot;
+		: &quot;=a&quot; (rval)
+		: /* no input */
+		: &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;
+	);
+
+	/* Return */
+	return(rval);
+}
+
+/*	Function to test if mmx instructions are supported...
+*/
+inline extern int
+mmx_ok(void)
+{
+	/* Returns 1 if MMX instructions are supported, 0 otherwise */
+	return ( mm_support() &amp; 0x1 );
+}
+
+
+/*	Helper functions for the instruction macros that follow...
+	(note that memory-to-register, m2r, instructions are nearly
+	 as efficient as register-to-register, r2r, instructions;
+	 however, memory-to-memory instructions are really simulated
+	 as a convenience, and are only 1/3 as efficient)
+*/
+#ifdef	MMX_TRACE
+
+/*	Include the stuff for printing a trace to stderr...
+*/
+
+#include &lt;stdio.h&gt;
+
+#define	mmx_i2r(op, imm, reg) \
+	{ \
+		mmx_t mmx_trace; \
+		mmx_trace.uq = (imm); \
+		printf(#op &quot;_i2r(&quot; #imm &quot;=0x%08x%08x, &quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+		__asm__ __volatile__ (&quot;movq %%&quot; #reg &quot;, %0&quot; \
+				      : &quot;=X&quot; (mmx_trace) \
+				      : /* nothing */ ); \
+		printf(#reg &quot;=0x%08x%08x) =&gt; &quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+		__asm__ __volatile__ (#op &quot; %0, %%&quot; #reg \
+				      : /* nothing */ \
+				      : &quot;X&quot; (imm)); \
+		__asm__ __volatile__ (&quot;movq %%&quot; #reg &quot;, %0&quot; \
+				      : &quot;=X&quot; (mmx_trace) \
+				      : /* nothing */ ); \
+		printf(#reg &quot;=0x%08x%08x\n&quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+	}
+
+#define	mmx_m2r(op, mem, reg) \
+	{ \
+		mmx_t mmx_trace; \
+		mmx_trace = (mem); \
+		printf(#op &quot;_m2r(&quot; #mem &quot;=0x%08x%08x, &quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+		__asm__ __volatile__ (&quot;movq %%&quot; #reg &quot;, %0&quot; \
+				      : &quot;=X&quot; (mmx_trace) \
+				      : /* nothing */ ); \
+		printf(#reg &quot;=0x%08x%08x) =&gt; &quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+		__asm__ __volatile__ (#op &quot; %0, %%&quot; #reg \
+				      : /* nothing */ \
+				      : &quot;X&quot; (mem)); \
+		__asm__ __volatile__ (&quot;movq %%&quot; #reg &quot;, %0&quot; \
+				      : &quot;=X&quot; (mmx_trace) \
+				      : /* nothing */ ); \
+		printf(#reg &quot;=0x%08x%08x\n&quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+	}
+
+#define	mmx_r2m(op, reg, mem) \
+	{ \
+		mmx_t mmx_trace; \
+		__asm__ __volatile__ (&quot;movq %%&quot; #reg &quot;, %0&quot; \
+				      : &quot;=X&quot; (mmx_trace) \
+				      : /* nothing */ ); \
+		printf(#op &quot;_r2m(&quot; #reg &quot;=0x%08x%08x, &quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+		mmx_trace = (mem); \
+		printf(#mem &quot;=0x%08x%08x) =&gt; &quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+		__asm__ __volatile__ (#op &quot; %%&quot; #reg &quot;, %0&quot; \
+				      : &quot;=X&quot; (mem) \
+				      : /* nothing */ ); \
+		mmx_trace = (mem); \
+		printf(#mem &quot;=0x%08x%08x\n&quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+	}
+
+#define	mmx_r2r(op, regs, regd) \
+	{ \
+		mmx_t mmx_trace; \
+		__asm__ __volatile__ (&quot;movq %%&quot; #regs &quot;, %0&quot; \
+				      : &quot;=X&quot; (mmx_trace) \
+				      : /* nothing */ ); \
+		printf(#op &quot;_r2r(&quot; #regs &quot;=0x%08x%08x, &quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+		__asm__ __volatile__ (&quot;movq %%&quot; #regd &quot;, %0&quot; \
+				      : &quot;=X&quot; (mmx_trace) \
+				      : /* nothing */ ); \
+		printf(#regd &quot;=0x%08x%08x) =&gt; &quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+		__asm__ __volatile__ (#op &quot; %&quot; #regs &quot;, %&quot; #regd); \
+		__asm__ __volatile__ (&quot;movq %%&quot; #regd &quot;, %0&quot; \
+				      : &quot;=X&quot; (mmx_trace) \
+				      : /* nothing */ ); \
+		printf(#regd &quot;=0x%08x%08x\n&quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+	}
+
+#define	mmx_m2m(op, mems, memd) \
+	{ \
+		mmx_t mmx_trace; \
+		mmx_trace = (mems); \
+		printf(#op &quot;_m2m(&quot; #mems &quot;=0x%08x%08x, &quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+		mmx_trace = (memd); \
+		printf(#memd &quot;=0x%08x%08x) =&gt; &quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+		__asm__ __volatile__ (&quot;movq %0, %%mm0\n\t&quot; \
+				      #op &quot; %1, %%mm0\n\t&quot; \
+				      &quot;movq %%mm0, %0&quot; \
+				      : &quot;=X&quot; (memd) \
+				      : &quot;X&quot; (mems)); \
+		mmx_trace = (memd); \
+		printf(#memd &quot;=0x%08x%08x\n&quot;, \
+			mmx_trace.d[1], mmx_trace.d[0]); \
+	}
+
+#else
+
+/*	These macros are a lot simpler without the tracing...
+*/
+
+#define	mmx_i2r(op, imm, reg) \
+	__asm__ __volatile__ (#op &quot; %0, %%&quot; #reg \
+			      : /* nothing */ \
+			      : &quot;X&quot; (imm) )
+
+#define	mmx_m2r(op, mem, reg) \
+	__asm__ __volatile__ (#op &quot; %0, %%&quot; #reg \
+			      : /* nothing */ \
+			      : &quot;X&quot; (mem))
+
+#define	mmx_r2m(op, reg, mem) \
+	__asm__ __volatile__ (#op &quot; %%&quot; #reg &quot;, %0&quot; \
+			      : &quot;=X&quot; (mem) \
+			      : /* nothing */ )
+
+#define	mmx_r2r(op, regs, regd) \
+	__asm__ __volatile__ (#op &quot; %&quot; #regs &quot;, %&quot; #regd)
+
+#define	mmx_m2m(op, mems, memd) \
+	__asm__ __volatile__ (&quot;movq %0, %%mm0\n\t&quot; \
+			      #op &quot; %1, %%mm0\n\t&quot; \
+			      &quot;movq %%mm0, %0&quot; \
+			      : &quot;=X&quot; (memd) \
+			      : &quot;X&quot; (mems))
+
+#endif
+
+
+/*	1x64 MOVe Quadword
+	(this is both a load and a store...
+	 in fact, it is the only way to store)
+*/
+#define	movq_m2r(var, reg)	mmx_m2r(movq, var, reg)
+#define	movq_r2m(reg, var)	mmx_r2m(movq, reg, var)
+#define	movq_r2r(regs, regd)	mmx_r2r(movq, regs, regd)
+#define	movq(vars, vard) \
+	__asm__ __volatile__ (&quot;movq %1, %%mm0\n\t&quot; \
+			      &quot;movq %%mm0, %0&quot; \
+			      : &quot;=X&quot; (vard) \
+			      : &quot;X&quot; (vars))
+
+
+/*	1x32 MOVe Doubleword
+	(like movq, this is both load and store...
+	 but is most useful for moving things between
+	 mmx registers and ordinary registers)
+*/
+#define	movd_m2r(var, reg)	mmx_m2r(movd, var, reg)
+#define	movd_r2m(reg, var)	mmx_r2m(movd, reg, var)
+#define	movd_r2r(regs, regd)	mmx_r2r(movd, regs, regd)
+#define	movd(vars, vard) \
+	__asm__ __volatile__ (&quot;movd %1, %%mm0\n\t&quot; \
+			      &quot;movd %%mm0, %0&quot; \
+			      : &quot;=X&quot; (vard) \
+			      : &quot;X&quot; (vars))
+
+
+/*	2x32, 4x16, and 8x8 Parallel ADDs
+*/
+#define	paddd_m2r(var, reg)	mmx_m2r(paddd, var, reg)
+#define	paddd_r2r(regs, regd)	mmx_r2r(paddd, regs, regd)
+#define	paddd(vars, vard)	mmx_m2m(paddd, vars, vard)
+
+#define	paddw_m2r(var, reg)	mmx_m2r(paddw, var, reg)
+#define	paddw_r2r(regs, regd)	mmx_r2r(paddw, regs, regd)
+#define	paddw(vars, vard)	mmx_m2m(paddw, vars, vard)
+
+#define	paddb_m2r(var, reg)	mmx_m2r(paddb, var, reg)
+#define	paddb_r2r(regs, regd)	mmx_r2r(paddb, regs, regd)
+#define	paddb(vars, vard)	mmx_m2m(paddb, vars, vard)
+
+
+/*	4x16 and 8x8 Parallel ADDs using Saturation arithmetic
+*/
+#define	paddsw_m2r(var, reg)	mmx_m2r(paddsw, var, reg)
+#define	paddsw_r2r(regs, regd)	mmx_r2r(paddsw, regs, regd)
+#define	paddsw(vars, vard)	mmx_m2m(paddsw, vars, vard)
+
+#define	paddsb_m2r(var, reg)	mmx_m2r(paddsb, var, reg)
+#define	paddsb_r2r(regs, regd)	mmx_r2r(paddsb, regs, regd)
+#define	paddsb(vars, vard)	mmx_m2m(paddsb, vars, vard)
+
+
+/*	4x16 and 8x8 Parallel ADDs using Unsigned Saturation arithmetic
+*/
+#define	paddusw_m2r(var, reg)	mmx_m2r(paddusw, var, reg)
+#define	paddusw_r2r(regs, regd)	mmx_r2r(paddusw, regs, regd)
+#define	paddusw(vars, vard)	mmx_m2m(paddusw, vars, vard)
+
+#define	paddusb_m2r(var, reg)	mmx_m2r(paddusb, var, reg)
+#define	paddusb_r2r(regs, regd)	mmx_r2r(paddusb, regs, regd)
+#define	paddusb(vars, vard)	mmx_m2m(paddusb, vars, vard)
+
+
+/*	2x32, 4x16, and 8x8 Parallel SUBs
+*/
+#define	psubd_m2r(var, reg)	mmx_m2r(psubd, var, reg)
+#define	psubd_r2r(regs, regd)	mmx_r2r(psubd, regs, regd)
+#define	psubd(vars, vard)	mmx_m2m(psubd, vars, vard)
+
+#define	psubw_m2r(var, reg)	mmx_m2r(psubw, var, reg)
+#define	psubw_r2r(regs, regd)	mmx_r2r(psubw, regs, regd)
+#define	psubw(vars, vard)	mmx_m2m(psubw, vars, vard)
+
+#define	psubb_m2r(var, reg)	mmx_m2r(psubb, var, reg)
+#define	psubb_r2r(regs, regd)	mmx_r2r(psubb, regs, regd)
+#define	psubb(vars, vard)	mmx_m2m(psubb, vars, vard)
+
+
+/*	4x16 and 8x8 Parallel SUBs using Saturation arithmetic
+*/
+#define	psubsw_m2r(var, reg)	mmx_m2r(psubsw, var, reg)
+#define	psubsw_r2r(regs, regd)	mmx_r2r(psubsw, regs, regd)
+#define	psubsw(vars, vard)	mmx_m2m(psubsw, vars, vard)
+
+#define	psubsb_m2r(var, reg)	mmx_m2r(psubsb, var, reg)
+#define	psubsb_r2r(regs, regd)	mmx_r2r(psubsb, regs, regd)
+#define	psubsb(vars, vard)	mmx_m2m(psubsb, vars, vard)
+
+
+/*	4x16 and 8x8 Parallel SUBs using Unsigned Saturation arithmetic
+*/
+#define	psubusw_m2r(var, reg)	mmx_m2r(psubusw, var, reg)
+#define	psubusw_r2r(regs, regd)	mmx_r2r(psubusw, regs, regd)
+#define	psubusw(vars, vard)	mmx_m2m(psubusw, vars, vard)
+
+#define	psubusb_m2r(var, reg)	mmx_m2r(psubusb, var, reg)
+#define	psubusb_r2r(regs, regd)	mmx_r2r(psubusb, regs, regd)
+#define	psubusb(vars, vard)	mmx_m2m(psubusb, vars, vard)
+
+
+/*	4x16 Parallel MULs giving Low 4x16 portions of results
+*/
+#define	pmullw_m2r(var, reg)	mmx_m2r(pmullw, var, reg)
+#define	pmullw_r2r(regs, regd)	mmx_r2r(pmullw, regs, regd)
+#define	pmullw(vars, vard)	mmx_m2m(pmullw, vars, vard)
+
+
+/*	4x16 Parallel MULs giving High 4x16 portions of results
+*/
+#define	pmulhw_m2r(var, reg)	mmx_m2r(pmulhw, var, reg)
+#define	pmulhw_r2r(regs, regd)	mmx_r2r(pmulhw, regs, regd)
+#define	pmulhw(vars, vard)	mmx_m2m(pmulhw, vars, vard)
+
+
+/*	4x16-&gt;2x32 Parallel Mul-ADD
+	(muls like pmullw, then adds adjacent 16-bit fields
+	 in the multiply result to make the final 2x32 result)
+*/
+#define	pmaddwd_m2r(var, reg)	mmx_m2r(pmaddwd, var, reg)
+#define	pmaddwd_r2r(regs, regd)	mmx_r2r(pmaddwd, regs, regd)
+#define	pmaddwd(vars, vard)	mmx_m2m(pmaddwd, vars, vard)
+
+
+/*	1x64 bitwise AND
+*/
+#ifdef	BROKEN_PAND
+#define	pand_m2r(var, reg) \
+	{ \
+		mmx_m2r(pandn, (mmx_t) -1LL, reg); \
+		mmx_m2r(pandn, var, reg); \
+	}
+#define	pand_r2r(regs, regd) \
+	{ \
+		mmx_m2r(pandn, (mmx_t) -1LL, regd); \
+		mmx_r2r(pandn, regs, regd) \
+	}
+#define	pand(vars, vard) \
+	{ \
+		movq_m2r(vard, mm0); \
+		mmx_m2r(pandn, (mmx_t) -1LL, mm0); \
+		mmx_m2r(pandn, vars, mm0); \
+		movq_r2m(mm0, vard); \
+	}
+#else
+#define	pand_m2r(var, reg)	mmx_m2r(pand, var, reg)
+#define	pand_r2r(regs, regd)	mmx_r2r(pand, regs, regd)
+#define	pand(vars, vard)	mmx_m2m(pand, vars, vard)
+#endif
+
+
+/*	1x64 bitwise AND with Not the destination
+*/
+#define	pandn_m2r(var, reg)	mmx_m2r(pandn, var, reg)
+#define	pandn_r2r(regs, regd)	mmx_r2r(pandn, regs, regd)
+#define	pandn(vars, vard)	mmx_m2m(pandn, vars, vard)
+
+
+/*	1x64 bitwise OR
+*/
+#define	por_m2r(var, reg)	mmx_m2r(por, var, reg)
+#define	por_r2r(regs, regd)	mmx_r2r(por, regs, regd)
+#define	por(vars, vard)	mmx_m2m(por, vars, vard)
+
+
+/*	1x64 bitwise eXclusive OR
+*/
+#define	pxor_m2r(var, reg)	mmx_m2r(pxor, var, reg)
+#define	pxor_r2r(regs, regd)	mmx_r2r(pxor, regs, regd)
+#define	pxor(vars, vard)	mmx_m2m(pxor, vars, vard)
+
+
+/*	2x32, 4x16, and 8x8 Parallel CoMPare for EQuality
+	(resulting fields are either 0 or -1)
+*/
+#define	pcmpeqd_m2r(var, reg)	mmx_m2r(pcmpeqd, var, reg)
+#define	pcmpeqd_r2r(regs, regd)	mmx_r2r(pcmpeqd, regs, regd)
+#define	pcmpeqd(vars, vard)	mmx_m2m(pcmpeqd, vars, vard)
+
+#define	pcmpeqw_m2r(var, reg)	mmx_m2r(pcmpeqw, var, reg)
+#define	pcmpeqw_r2r(regs, regd)	mmx_r2r(pcmpeqw, regs, regd)
+#define	pcmpeqw(vars, vard)	mmx_m2m(pcmpeqw, vars, vard)
+
+#define	pcmpeqb_m2r(var, reg)	mmx_m2r(pcmpeqb, var, reg)
+#define	pcmpeqb_r2r(regs, regd)	mmx_r2r(pcmpeqb, regs, regd)
+#define	pcmpeqb(vars, vard)	mmx_m2m(pcmpeqb, vars, vard)
+
+
+/*	2x32, 4x16, and 8x8 Parallel CoMPare for Greater Than
+	(resulting fields are either 0 or -1)
+*/
+#define	pcmpgtd_m2r(var, reg)	mmx_m2r(pcmpgtd, var, reg)
+#define	pcmpgtd_r2r(regs, regd)	mmx_r2r(pcmpgtd, regs, regd)
+#define	pcmpgtd(vars, vard)	mmx_m2m(pcmpgtd, vars, vard)
+
+#define	pcmpgtw_m2r(var, reg)	mmx_m2r(pcmpgtw, var, reg)
+#define	pcmpgtw_r2r(regs, regd)	mmx_r2r(pcmpgtw, regs, regd)
+#define	pcmpgtw(vars, vard)	mmx_m2m(pcmpgtw, vars, vard)
+
+#define	pcmpgtb_m2r(var, reg)	mmx_m2r(pcmpgtb, var, reg)
+#define	pcmpgtb_r2r(regs, regd)	mmx_r2r(pcmpgtb, regs, regd)
+#define	pcmpgtb(vars, vard)	mmx_m2m(pcmpgtb, vars, vard)
+
+
+/*	1x64, 2x32, and 4x16 Parallel Shift Left Logical
+*/
+#define	psllq_i2r(imm, reg)	mmx_i2r(psllq, imm, reg)
+#define	psllq_m2r(var, reg)	mmx_m2r(psllq, var, reg)
+#define	psllq_r2r(regs, regd)	mmx_r2r(psllq, regs, regd)
+#define	psllq(vars, vard)	mmx_m2m(psllq, vars, vard)
+
+#define	pslld_i2r(imm, reg)	mmx_i2r(pslld, imm, reg)
+#define	pslld_m2r(var, reg)	mmx_m2r(pslld, var, reg)
+#define	pslld_r2r(regs, regd)	mmx_r2r(pslld, regs, regd)
+#define	pslld(vars, vard)	mmx_m2m(pslld, vars, vard)
+
+#define	psllw_i2r(imm, reg)	mmx_i2r(psllw, imm, reg)
+#define	psllw_m2r(var, reg)	mmx_m2r(psllw, var, reg)
+#define	psllw_r2r(regs, regd)	mmx_r2r(psllw, regs, regd)
+#define	psllw(vars, vard)	mmx_m2m(psllw, vars, vard)
+
+
+/*	1x64, 2x32, and 4x16 Parallel Shift Right Logical
+*/
+#define	psrlq_i2r(imm, reg)	mmx_i2r(psrlq, imm, reg)
+#define	psrlq_m2r(var, reg)	mmx_m2r(psrlq, var, reg)
+#define	psrlq_r2r(regs, regd)	mmx_r2r(psrlq, regs, regd)
+#define	psrlq(vars, vard)	mmx_m2m(psrlq, vars, vard)
+
+#define	psrld_i2r(imm, reg)	mmx_i2r(psrld, imm, reg)
+#define	psrld_m2r(var, reg)	mmx_m2r(psrld, var, reg)
+#define	psrld_r2r(regs, regd)	mmx_r2r(psrld, regs, regd)
+#define	psrld(vars, vard)	mmx_m2m(psrld, vars, vard)
+
+#define	psrlw_i2r(imm, reg)	mmx_i2r(psrlw, imm, reg)
+#define	psrlw_m2r(var, reg)	mmx_m2r(psrlw, var, reg)
+#define	psrlw_r2r(regs, regd)	mmx_r2r(psrlw, regs, regd)
+#define	psrlw(vars, vard)	mmx_m2m(psrlw, vars, vard)
+
+
+/*	2x32 and 4x16 Parallel Shift Right Arithmetic
+*/
+#define	psrad_i2r(imm, reg)	mmx_i2r(psrad, imm, reg)
+#define	psrad_m2r(var, reg)	mmx_m2r(psrad, var, reg)
+#define	psrad_r2r(regs, regd)	mmx_r2r(psrad, regs, regd)
+#define	psrad(vars, vard)	mmx_m2m(psrad, vars, vard)
+
+#define	psraw_i2r(imm, reg)	mmx_i2r(psraw, imm, reg)
+#define	psraw_m2r(var, reg)	mmx_m2r(psraw, var, reg)
+#define	psraw_r2r(regs, regd)	mmx_r2r(psraw, regs, regd)
+#define	psraw(vars, vard)	mmx_m2m(psraw, vars, vard)
+
+
+/*	2x32-&gt;4x16 and 4x16-&gt;8x8 PACK and Signed Saturate
+	(packs source and dest fields into dest in that order)
+*/
+#define	packssdw_m2r(var, reg)	mmx_m2r(packssdw, var, reg)
+#define	packssdw_r2r(regs, regd) mmx_r2r(packssdw, regs, regd)
+#define	packssdw(vars, vard)	mmx_m2m(packssdw, vars, vard)
+
+#define	packsswb_m2r(var, reg)	mmx_m2r(packsswb, var, reg)
+#define	packsswb_r2r(regs, regd) mmx_r2r(packsswb, regs, regd)
+#define	packsswb(vars, vard)	mmx_m2m(packsswb, vars, vard)
+
+
+/*	4x16-&gt;8x8 PACK and Unsigned Saturate
+	(packs source and dest fields into dest in that order)
+*/
+#define	packuswb_m2r(var, reg)	mmx_m2r(packuswb, var, reg)
+#define	packuswb_r2r(regs, regd) mmx_r2r(packuswb, regs, regd)
+#define	packuswb(vars, vard)	mmx_m2m(packuswb, vars, vard)
+
+
+/*	2x32-&gt;1x64, 4x16-&gt;2x32, and 8x8-&gt;4x16 UNPaCK Low
+	(interleaves low half of dest with low half of source
+	 as padding in each result field)
+*/
+#define	punpckldq_m2r(var, reg)	mmx_m2r(punpckldq, var, reg)
+#define	punpckldq_r2r(regs, regd) mmx_r2r(punpckldq, regs, regd)
+#define	punpckldq(vars, vard)	mmx_m2m(punpckldq, vars, vard)
+
+#define	punpcklwd_m2r(var, reg)	mmx_m2r(punpcklwd, var, reg)
+#define	punpcklwd_r2r(regs, regd) mmx_r2r(punpcklwd, regs, regd)
+#define	punpcklwd(vars, vard)	mmx_m2m(punpcklwd, vars, vard)
+
+#define	punpcklbw_m2r(var, reg)	mmx_m2r(punpcklbw, var, reg)
+#define	punpcklbw_r2r(regs, regd) mmx_r2r(punpcklbw, regs, regd)
+#define	punpcklbw(vars, vard)	mmx_m2m(punpcklbw, vars, vard)
+
+
+/*	2x32-&gt;1x64, 4x16-&gt;2x32, and 8x8-&gt;4x16 UNPaCK High
+	(interleaves high half of dest with high half of source
+	 as padding in each result field)
+*/
+#define	punpckhdq_m2r(var, reg)	mmx_m2r(punpckhdq, var, reg)
+#define	punpckhdq_r2r(regs, regd) mmx_r2r(punpckhdq, regs, regd)
+#define	punpckhdq(vars, vard)	mmx_m2m(punpckhdq, vars, vard)
+
+#define	punpckhwd_m2r(var, reg)	mmx_m2r(punpckhwd, var, reg)
+#define	punpckhwd_r2r(regs, regd) mmx_r2r(punpckhwd, regs, regd)
+#define	punpckhwd(vars, vard)	mmx_m2m(punpckhwd, vars, vard)
+
+#define	punpckhbw_m2r(var, reg)	mmx_m2r(punpckhbw, var, reg)
+#define	punpckhbw_r2r(regs, regd) mmx_r2r(punpckhbw, regs, regd)
+#define	punpckhbw(vars, vard)	mmx_m2m(punpckhbw, vars, vard)
+
+
+/*	Empty MMx State
+	(used to clean-up when going from mmx to float use
+	 of the registers that are shared by both; note that
+	 there is no float-to-mmx operation needed, because
+	 only the float tag word info is corruptible)
+*/
+#ifdef	MMX_TRACE
+
+#define	emms() \
+	{ \
+		printf(&quot;emms()\n&quot;); \
+		__asm__ __volatile__ (&quot;emms&quot;); \
+	}
+
+#else
+
+#define	emms()			__asm__ __volatile__ (&quot;emms&quot;)
+
+#endif
+
+#endif
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_vidFieldUtil.h (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_vidFieldUtil.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,12 @@
+/*
+	Some useful functions to manipulate fields
+
+
+*/
+
+void vidFieldDecimate(uint8_t *src,uint8_t *target, uint32_t linessrc, uint32_t width);
+void vidFieldKeepOdd(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target);
+void vidFieldKeepEven(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target);
+void vidFieldMerge(uint32_t w,uint32_t h,uint8_t *src,uint8_t *src2,uint8_t *target);
+uint8_t vidFielStack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target);
+uint8_t vidFielUnStack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target);

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_interlaceUtil.cpp (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_interlaceUtil.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,225 @@
+/***************************************************************************
+                          ADM_interlaced.cpp  -  description
+                             -------------------
+
+	This piece of code count how many interlaced part we detected in the frame
+	The method is from smartdeinterlacer
+	Works only on luma (as chroma is 2:2 downsampled)
+
+    begin                : Wed Dec 18 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+Benchmark:
+		ASM 3-version 	: 20 ms
+		C Version 		: 25 ms
+Skip factor=2
+
+		ASM 3-version 	: 7 ms
+		C Version 		: 8 ms
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+
+//#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_videoFilter.h&quot;
+//#include &quot;ADM_video/ADM_vidCommonFilter.h&quot;
+
+//#define MMX_TRACE
+#warning remove mmxmacro and debug asm
+//#define ASM_ILACING
+
+
+#include &quot;ADM_mmxMacros.h&quot;
+
+
+
+
+#define SKIP_FACTOR 2   // 2^SKIPFACTOR=SKIP_LINEAR+1
+#define SKIP_LINEAR   3
+
+ #define MATCH_THRESH (60*60)
+ #define QMATCH_THRESH ((uint64_t)(MATCH_THRESH&gt;&gt;2))
+
+
+/*
+	This macro compute the number of pixel where c-p * c-n &gt; threshold and add the result to mm7
+	There will be an overflow if more than 50 % of the video is like that but we can safely assume
+		that would be rare
+
+		mm0 contains 4 bytes of c
+		mm1 contains 4 bytes of p
+		mm2 contains 4 bytes of n
+*/
+
+#if defined(ADM_CPU_X86) &amp;&amp; defined(ASM_ILACING)
+
+static uint32_t      ADMVideo_interlaceCount_MMX( uint8_t *src ,uint32_t w, uint32_t h);
+static uint8_t *_l_p=NULL;
+static uint8_t *_l_c=NULL;
+static uint8_t *_l_n=NULL;
+
+static int64_t _l_h;
+
+static mmx_t _lthresh,_added,_total,_lwrd;
+static mmx_t _l255;
+static mmx_t _l0;
+
+#define COMPUTE \
+punpcklbw_r2r(mm5,mm0);  /*c  expand 4 bytes -&gt; 4 word */ \
+punpcklbw_r2r(mm5,mm1);  /*p*/ \
+punpcklbw_r2r(mm5,mm2); /* n*/ \
+movq_r2r(mm0,mm3);		/* mm3 also c*/ \
+psubw_r2r(mm1,mm0) ; /* mm0=mm0-mm1 =  c-p*/ \
+psubw_r2r(mm2,mm3) ; /* mm3=mm3-mm2 =  c-n*/ \
+psraw_i2r(1,mm0); /* to protect from overflow*/ \
+psraw_i2r(1,mm3);\
+pmullw_r2r(mm0,mm3); /* mm3=(c-p)*(c-n) / 4;*/ \
+pcmpgtw_r2r(mm4,mm3); /* keep only &gt; size*/ \
+psrlw_i2r(15,mm3); 	/* keep only one bit*/ \
+pmaddwd_r2r(mm3,mm3);\
+movq_r2r(mm3,mm0);\
+psrlq_i2r(32,mm0);\
+paddw_r2r(mm3,mm0); /* we got the total of match in mm0*/ \
+pand_r2r(mm6,mm0); /* and we keep the last word*/ \
+paddd_r2r(mm0,mm7);
+
+
+#endif
+static uint32_t      ADMVideo_interlaceCount_C( uint8_t *src ,uint32_t w, uint32_t h);
+/*
+	Returns the # of interlacing effects on 1/4 of the image
+*/
+
+uint32_t      ADMVideo_interlaceCount( uint8_t *src ,uint32_t w, uint32_t h)
+{
+#if defined(ADM_CPU_X86) &amp;&amp; defined(ASM_ILACING)  
+        if(CpuCaps::hasMMX())
+                return ADMVideo_interlaceCount_MMX(src,w,h);
+        else
+#endif
+        return ADMVideo_interlaceCount_C(src,w,h);
+
+}
+
+#if defined(ADM_CPU_X86) &amp;&amp; defined(ASM_ILACING)  
+uint32_t      ADMVideo_interlaceCount_MMX( uint8_t *src ,uint32_t w, uint32_t h)
+{
+uint32_t m=0,y,x;
+
+_total.uq=0LL;
+//_l255.uq=0xffffffffffffffffLL;
+//_l0.uq=0LL;
+_lwrd.uq=0xffffLL;
+uint32_t stride=w*SKIP_LINEAR;
+	_l_p=src;
+	_l_c=src+w;
+	_l_n=src+w+w;
+	_l_h=w;
+	_lthresh.uq=QMATCH_THRESH+(QMATCH_THRESH&lt;&lt;16)+
+				(QMATCH_THRESH&lt;&lt;32)+(QMATCH_THRESH&lt;&lt;48);
+
+movq_m2r(_lwrd,mm6);
+movq_m2r(_lthresh,mm4);
+pxor_r2r(mm5,mm5);
+pxor_r2r(mm7,mm7);
+
+	for(y=h&gt;&gt;SKIP_FACTOR;  y &gt;2 ; y--)
+		{
+			__asm__ __volatile__(
+                                &quot;push &quot;REG_bx&quot;\n\t&quot;
+				&quot;mov &quot;Mangle(_l_c)&quot;,	&quot;REG_ax&quot;\n\t&quot;
+				&quot;mov &quot;Mangle(_l_p)&quot;,	&quot;REG_bx&quot;\n\t&quot;
+				&quot;mov &quot;Mangle(_l_n)&quot;,	&quot;REG_cx&quot;\n\t&quot;
+				&quot;mov &quot;Mangle(_l_h)&quot;,	&quot;REG_dx&quot;\n\t&quot;
+				&quot;8: \n\t&quot;
+				&quot;movd (&quot;REG_ax&quot;),	%%mm0\n\t&quot;
+				&quot;movd (&quot;REG_bx&quot;),	%%mm1\n\t&quot;
+				&quot;movd (&quot;REG_cx&quot;),	%%mm2\n\t&quot;
+				:
+				:
+				: &quot;eax&quot;,  &quot;ecx&quot;, &quot;edx&quot;
+				);
+				COMPUTE
+
+			__asm__ __volatile__(
+				&quot;add $4,		&quot;REG_ax&quot;\n\t&quot;
+				&quot;add $4	,	&quot;REG_bx&quot;\n\t&quot;
+				&quot;add $4,		&quot;REG_cx&quot;\n\t&quot;
+				&quot;sub $1,		&quot;REG_dx&quot;\n\t&quot;
+				&quot;jnz 		8b\n\t&quot;
+                                &quot;pop &quot;REG_bx&quot;\n\t&quot;
+				:
+				:
+				: &quot;eax&quot;, &quot;ecx&quot;, &quot;edx&quot;
+				);
+
+
+				_l_p+=(1+SKIP_LINEAR)*w;
+				_l_c+=(1+SKIP_LINEAR)*w;
+				_l_n+=(1+SKIP_LINEAR)*w;
+
+
+		}
+		// retrieve mm7 containg the total
+
+		__asm__ __volatile__(
+		&quot;mov 	$&quot;Mangle(_total)&quot;,		&quot;REG_ax&quot;\n\t&quot;
+		&quot;movd 	%%mm7,	(&quot;REG_ax&quot;)\n\t&quot;
+		&quot;emms\n\t&quot;
+		:
+		:
+		: &quot;eax&quot;
+		);
+		m=(uint32_t)_total.uw[0];
+
+                 return m;
+}
+#endif
+// C version
+uint32_t      ADMVideo_interlaceCount_C( uint8_t *src ,uint32_t w, uint32_t h)
+{
+uint32_t m=0,y,x;
+
+			uint8_t *p,*n,*c;
+			int j;
+			c=src + w;
+			n=src + w+w;
+			p=src ;
+
+
+			for(y=h&gt;&gt;SKIP_FACTOR;  y &gt;2 ; y--)
+					{
+           				for(x=w;x&gt;0;x--)
+								{
+								j=(int)*p-(int)*c;
+								j*=(int)*n-(int)*c;
+							//	printf(&quot;p %d c %d  n %d j %d\n&quot;,*p,*c,*n , j);
+                             					if(  j &gt;MATCH_THRESH)
+								{
+								m++;
+							//	*c=*p=*n=0xff;
+								}
+
+										p++;c++;n++;
+								}
+								p+=(SKIP_LINEAR)*w;
+								c+=(SKIP_LINEAR)*w;
+								n+=(SKIP_LINEAR)*w;
+
+					}
+
+                 return m;
+}
+
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_vidFieldUtil.cpp (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_vidFieldUtil.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,194 @@
+/***************************************************************************
+                          ADM_vidFieldUtil.h  -  description
+                             -------------------
+
+Some functions to manipulate fields
+
+    begin                : Sun Apr 11 2003
+    copyright            : (C) 2003 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+
+
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_videoFilter.h&quot;
+#include &quot;ADM_vidFieldUtil.h&quot;
+
+
+void vidFieldDecimate(uint8_t *src,uint8_t *target, uint32_t linessrc, uint32_t width)
+{
+	linessrc&gt;&gt;=1;
+	for(;linessrc&gt;0;linessrc--)
+		{
+			memcpy(target,src,width);
+			target+=width;
+			src+=width*2;
+		}
+
+
+}
+
+void vidFieldKeepOdd(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
+{
+
+		uint32_t page=w*h;
+
+ 		vidFieldDecimate(src+w,target,h*2,w);
+
+		src+=page*2;
+		target+=page;
+		vidFieldDecimate(src+(w&gt;&gt;1),target,h,w&gt;&gt;1);
+
+		src+=page&gt;&gt;1;
+		target+=page&gt;&gt;2;
+		vidFieldDecimate(src+(w&gt;&gt;1),target,h,w&gt;&gt;1);
+}
+void vidFieldKeepEven(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
+{
+	uint32_t page=w*h;
+
+		vidFieldDecimate(src,target,h*2,w);
+
+		src+=page*2;
+		target+=page;
+		vidFieldDecimate(src,target,h,w&gt;&gt;1);
+
+		src+=page&gt;&gt;1;
+		target+=page&gt;&gt;2;
+		vidFieldDecimate(src,target,h,w&gt;&gt;1);
+}
+//
+//
+//
+static void stack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
+{
+uint8_t *dst1,*dst2;
+	dst1=target;
+	dst2=target+((w*h)&gt;&gt;1);	
+	
+	for(uint32_t y=h&gt;&gt;1;y&gt;0;y--)
+	{
+		memcpy(dst1,src,w);
+		memcpy(dst2,src+w,w);
+		src+=2*w;
+		dst1+=w;
+		dst2+=w;
+	}
+	
+}
+//
+//
+//
+static void unstack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
+{
+uint8_t *dst,*src1,*src2;
+        src1=src;
+        src2=src+((w*h)&gt;&gt;1); 
+        dst=target;
+        for(uint32_t y=h&gt;&gt;1;y&gt;0;y--)
+        {
+                memcpy(dst,src1,w);
+                memcpy(dst+w,src2,w);
+                dst+=2*w;
+                src1+=w;
+                src2+=w;
+        }
+        
+}
+
+//
+//	Put field 1 on top of field2
+//
+uint8_t vidFielStack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
+{
+uint8_t *d,*s;
+//uint32_t y;
+
+// interleave Y
+uint32_t page=w*h;
+	d=target;
+	s=src;
+	
+	stack(w,h,s,d);
+	
+	d=target+page;
+	s=src+page;
+	stack(w&gt;&gt;1,h&gt;&gt;1,s,d);
+	
+	d=target+((page*5)&gt;&gt;2);
+	s=src+((page*5)&gt;&gt;2);
+	stack(w&gt;&gt;1,h&gt;&gt;1,s,d);
+	
+	return 1;
+}
+//
+//      Put field 1 on top of field2
+//
+uint8_t vidFielUnStack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
+{
+uint8_t *d,*s;
+//uint32_t y;
+
+// interleave Y
+uint32_t page=w*h;
+        d=target;
+        s=src;
+        
+        unstack(w,h,s,d);
+        
+        d=target+page;
+        s=src+page;
+        unstack(w&gt;&gt;1,h&gt;&gt;1,s,d);
+        
+        d=target+((page*5)&gt;&gt;2);
+        s=src+((page*5)&gt;&gt;2);
+        unstack(w&gt;&gt;1,h&gt;&gt;1,s,d);
+        
+        return 1;
+}
+	
+
+void vidFieldMerge(uint32_t w,uint32_t h,uint8_t *src,uint8_t *src2,uint8_t *target)
+{
+uint8_t *d,*s,*s2;
+//uint32_t y;
+
+// interleave Y
+
+	d=target;
+	s=src;
+	s2=src2;
+	for(uint32_t y=h&gt;&gt;1;y&gt;0;y--)
+	{
+		memcpy(d,s,w);
+		memcpy(d+w,s2,w);
+		s+=w;
+		s2+=w;
+		d+=w*2;
+	}
+	//
+	d=target+(w*h);
+	s=src+((w*h)&gt;&gt;1);
+	s2=src2+((w*h)&gt;&gt;1);
+	for(uint32_t y=h&gt;&gt;1;y&gt;0;y--)
+	{
+		memcpy(d,s,w&gt;&gt;1);
+		memcpy(d+(w&gt;&gt;1),s2,w&gt;&gt;1);
+		s+=w&gt;&gt;1;
+		s2+=w&gt;&gt;1;
+		d+=w;
+	}
+
+}
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/CMakeLists.txt	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/CMakeLists.txt	2008-05-04 17:05:41 UTC (rev 4019)
@@ -11,6 +11,8 @@
         ADM_rgb.cpp
         ADM_pp.cpp
         ADM_print.cpp
+        ADM_vidFieldUtil.cpp
+        ADM_interlaceUtil.cpp
 )
 
 ADD_LIBRARY(ADM_coreImage SHARED ${ADM_coreImage_SRCS})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -59,7 +59,6 @@
     REGISTERX(VF_INTERLACING, &quot;tdeint&quot;,QT_TR_NOOP(&quot;TDeint&quot;),QT_TR_NOOP(&quot;Motion adaptative deinterlacer by Tritical.&quot;),VF_TDEINT,1,tdeint_create,tdeint_script);
     REGISTERX(VF_INTERLACING, &quot;lavcppdeint&quot;,QT_TR_NOOP(&quot;libavcodec deinterlacer&quot;),QT_TR_NOOP(&quot;All FFmpeg deinterlace filters (bicubic, median, ...).&quot;),VF_LAVPP_DEINT,1,lavppdeint_create,lavppdeint_script);
 	
-	REGISTERX(VF_INTERLACING, &quot;pulldown&quot;,QT_TR_NOOP(&quot;Pulldown&quot;),QT_TR_NOOP(&quot;Convert 24 fps to 30 fps by repeating fields.&quot;),VF_PULLDOWN,1,pulldown_create,pulldown_script);	
     REGISTERX(VF_INTERLACING, &quot;palfieldshift&quot;,QT_TR_NOOP(&quot;PAL field shift&quot;),QT_TR_NOOP(&quot;Shift fields by one. Useful for some PAL movies.&quot;),VF_PALSHIFT,1,addPALShift_create,addPALShift_script);	
 	REGISTERX(VF_INTERLACING, &quot;palsmart&quot;,QT_TR_NOOP(&quot;PAL smart&quot;),QT_TR_NOOP(&quot;Smartly revert non constant PAL field shift.&quot;),VF_TELECIDE,1,telecide_create,telecide_script);
 
@@ -67,7 +66,6 @@
         
         
 	
-	REGISTERX(VF_INTERLACING, &quot;drop&quot;,QT_TR_NOOP(&quot;Drop&quot;),QT_TR_NOOP(&quot;Drop damaged fields (e.g. from VHS capture).&quot;),VF_DROPOUT,1,dropout_create,dropout_script);
 	REGISTERX(VF_INTERLACING, &quot;swapfields&quot;,QT_TR_NOOP(&quot;Swap fields&quot;),QT_TR_NOOP(&quot;Swap top and bottom fields.&quot;),VF_SWAPFIELDS,1,swapfield_create,swapfield_script);
 	REGISTERX(VF_INTERLACING, &quot;smartswapfield&quot;,QT_TR_NOOP(&quot;Smart swap fields&quot;),QT_TR_NOOP(&quot;Smartly swap fields. Needed when field order changes.&quot;),VF_SMARTSWAPFIELDS,1,swapsmart_create,swapsmart_script);
 
@@ -91,7 +89,7 @@
     REGISTERX(VF_COLORS, &quot;chromashift&quot;,QT_TR_NOOP(&quot;Chroma shift&quot;),QT_TR_NOOP(&quot;Shift chroma U/V to fix badly synced luma/chroma.&quot;),VF_CHROMASHIFT,1,create_chromashift,chromashift_script);
 
    
-    REGISTERX(VF_COLORS, &quot;delta&quot;,QT_TR_NOOP(&quot;Luma delta&quot;),QT_TR_NOOP(&quot;Difference between current and previous picture.&quot;),VF_DELTA,1,delta_create,delta_script);
+    
     REGISTERX(VF_COLORS, &quot;coloryuv&quot;,QT_TR_NOOP(&quot;Avisynth ColorYUV&quot;),QT_TR_NOOP(&quot;Alter colors (auto white balance etc...). Ported from Avisynth.&quot;),VF_COLOR_YUV,1,coloryuv_create,coloryuv_script);
 
     
@@ -99,7 +97,7 @@
 	
 	REGISTERX(VF_NOISE, &quot;fluxsmooth&quot;,QT_TR_NOOP(&quot;FluxSmooth&quot;),QT_TR_NOOP(&quot;Spatio-temporal cleaner by Ross Thomas.&quot;),VF_FLUXSMOOTH,1,fluxsmooth_create,fluxsmooth_script);
 
-	REGISTERX(VF_NOISE, &quot;denoise&quot;,QT_TR_NOOP(&quot;Denoise&quot;),QT_TR_NOOP(&quot;Port of Transcode DNR.&quot;),VF_DENOISE,1,denoise_create,denoise_script);
+	
 	REGISTERX(VF_NOISE, &quot;stabilize&quot;,QT_TR_NOOP(&quot;Stabilize&quot;),QT_TR_NOOP(&quot;Light denoiser.&quot;),VF_STABILIZE,1,stabilize_create,stabilize_script);
     REGISTERX(VF_NOISE, &quot;cnr2&quot;,QT_TR_NOOP(&quot;Cnr2&quot;),QT_TR_NOOP(&quot;Chroma noise reduction filter by MarcFD/Tritical.&quot;),VF_CNR2,1,cnr2_create,cnr2_script);	
 
@@ -129,7 +127,7 @@
 
         //*********************
  
-    REGISTERX(VF_MISC, &quot;hardivtcremove&quot;,QT_TR_NOOP(&quot;Hard pulldown removal&quot;),QT_TR_NOOP(&quot;Remove IVTC that has been analog captured or resized.&quot;),VF_HARDIVTC,1,hardivtc_create,hardivtc_script);
+   
     REGISTERX(VF_MISC, &quot;whirl&quot;,QT_TR_NOOP(&quot;Whirl&quot;),QT_TR_NOOP(&quot;Useless whirlwind effect.&quot;),VF_WHIRL,1,whirl_create,whirl_script);
     REGISTERX(VF_MISC, &quot;mosaic&quot;,QT_TR_NOOP(&quot;Mosaic&quot;),QT_TR_NOOP(&quot;Split the picture into tiny thumbnails.&quot;),VF_MOSAIC,1,     mosaic_create,mosaic_script);
     REGISTERX(VF_MISC, &quot;mpdelogo&quot;,QT_TR_NOOP(&quot;MPlayer delogo&quot;),QT_TR_NOOP(&quot;Blend a logo by interpolating its surrounding box.&quot;),VF_MPDELOGO,1,mpdelogo_create,mpdelogo_script);

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,224 +0,0 @@
-/***************************************************************************
-                          ADM_interlaced.cpp  -  description
-                             -------------------
-
-	This piece of code count how many interlaced part we detected in the frame
-	The method is from smartdeinterlacer
-	Works only on luma (as chroma is 2:2 downsampled)
-
-    begin                : Wed Dec 18 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-Benchmark:
-		ASM 3-version 	: 20 ms
-		C Version 		: 25 ms
-Skip factor=2
-
-		ASM 3-version 	: 7 ms
-		C Version 		: 8 ms
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_video/ADM_vidCommonFilter.h&quot;
-
-//#define MMX_TRACE
-#define ASM_ILACING
-
-
-#include &quot;mmx_macros.h&quot;
-
-
-
-
-#define SKIP_FACTOR 2   // 2^SKIPFACTOR=SKIP_LINEAR+1
-#define SKIP_LINEAR   3
-
- #define MATCH_THRESH (60*60)
- #define QMATCH_THRESH ((uint64_t)(MATCH_THRESH&gt;&gt;2))
-
-
-/*
-	This macro compute the number of pixel where c-p * c-n &gt; threshold and add the result to mm7
-	There will be an overflow if more than 50 % of the video is like that but we can safely assume
-		that would be rare
-
-		mm0 contains 4 bytes of c
-		mm1 contains 4 bytes of p
-		mm2 contains 4 bytes of n
-*/
-
-#if defined(ADM_CPU_X86) &amp;&amp; defined(ASM_ILACING)
-
-static uint32_t      ADMVideo_interlaceCount_MMX( uint8_t *src ,uint32_t w, uint32_t h);
-static uint8_t *_l_p=NULL;
-static uint8_t *_l_c=NULL;
-static uint8_t *_l_n=NULL;
-
-static int64_t _l_h;
-
-static mmx_t _lthresh,_added,_total,_lwrd;
-static mmx_t _l255;
-static mmx_t _l0;
-
-#define COMPUTE \
-punpcklbw_r2r(mm5,mm0);  /*c  expand 4 bytes -&gt; 4 word */ \
-punpcklbw_r2r(mm5,mm1);  /*p*/ \
-punpcklbw_r2r(mm5,mm2); /* n*/ \
-movq_r2r(mm0,mm3);		/* mm3 also c*/ \
-psubw_r2r(mm1,mm0) ; /* mm0=mm0-mm1 =  c-p*/ \
-psubw_r2r(mm2,mm3) ; /* mm3=mm3-mm2 =  c-n*/ \
-psraw_i2r(1,mm0); /* to protect from overflow*/ \
-psraw_i2r(1,mm3);\
-pmullw_r2r(mm0,mm3); /* mm3=(c-p)*(c-n) / 4;*/ \
-pcmpgtw_r2r(mm4,mm3); /* keep only &gt; size*/ \
-psrlw_i2r(15,mm3); 	/* keep only one bit*/ \
-pmaddwd_r2r(mm3,mm3);\
-movq_r2r(mm3,mm0);\
-psrlq_i2r(32,mm0);\
-paddw_r2r(mm3,mm0); /* we got the total of match in mm0*/ \
-pand_r2r(mm6,mm0); /* and we keep the last word*/ \
-paddd_r2r(mm0,mm7);
-
-
-#endif
-static uint32_t      ADMVideo_interlaceCount_C( uint8_t *src ,uint32_t w, uint32_t h);
-/*
-	Returns the # of interlacing effects on 1/4 of the image
-*/
-
-uint32_t      ADMVideo_interlaceCount( uint8_t *src ,uint32_t w, uint32_t h)
-{
-#if defined(ADM_CPU_X86) &amp;&amp; defined(ASM_ILACING)  
-        if(CpuCaps::hasMMX())
-                return ADMVideo_interlaceCount_MMX(src,w,h);
-        else
-#endif
-        return ADMVideo_interlaceCount_C(src,w,h);
-
-}
-
-#if defined(ADM_CPU_X86) &amp;&amp; defined(ASM_ILACING)  
-uint32_t      ADMVideo_interlaceCount_MMX( uint8_t *src ,uint32_t w, uint32_t h)
-{
-uint32_t m=0,y,x;
-
-_total.uq=0LL;
-//_l255.uq=0xffffffffffffffffLL;
-//_l0.uq=0LL;
-_lwrd.uq=0xffffLL;
-uint32_t stride=w*SKIP_LINEAR;
-	_l_p=src;
-	_l_c=src+w;
-	_l_n=src+w+w;
-	_l_h=w;
-	_lthresh.uq=QMATCH_THRESH+(QMATCH_THRESH&lt;&lt;16)+
-				(QMATCH_THRESH&lt;&lt;32)+(QMATCH_THRESH&lt;&lt;48);
-
-movq_m2r(_lwrd,mm6);
-movq_m2r(_lthresh,mm4);
-pxor_r2r(mm5,mm5);
-pxor_r2r(mm7,mm7);
-
-	for(y=h&gt;&gt;SKIP_FACTOR;  y &gt;2 ; y--)
-		{
-			__asm__ __volatile__(
-                                &quot;push &quot;REG_bx&quot;\n\t&quot;
-				&quot;mov &quot;Mangle(_l_c)&quot;,	&quot;REG_ax&quot;\n\t&quot;
-				&quot;mov &quot;Mangle(_l_p)&quot;,	&quot;REG_bx&quot;\n\t&quot;
-				&quot;mov &quot;Mangle(_l_n)&quot;,	&quot;REG_cx&quot;\n\t&quot;
-				&quot;mov &quot;Mangle(_l_h)&quot;,	&quot;REG_dx&quot;\n\t&quot;
-				&quot;8: \n\t&quot;
-				&quot;movd (&quot;REG_ax&quot;),	%%mm0\n\t&quot;
-				&quot;movd (&quot;REG_bx&quot;),	%%mm1\n\t&quot;
-				&quot;movd (&quot;REG_cx&quot;),	%%mm2\n\t&quot;
-				:
-				:
-				: &quot;eax&quot;,  &quot;ecx&quot;, &quot;edx&quot;
-				);
-				COMPUTE
-
-			__asm__ __volatile__(
-				&quot;add $4,		&quot;REG_ax&quot;\n\t&quot;
-				&quot;add $4	,	&quot;REG_bx&quot;\n\t&quot;
-				&quot;add $4,		&quot;REG_cx&quot;\n\t&quot;
-				&quot;sub $1,		&quot;REG_dx&quot;\n\t&quot;
-				&quot;jnz 		8b\n\t&quot;
-                                &quot;pop &quot;REG_bx&quot;\n\t&quot;
-				:
-				:
-				: &quot;eax&quot;, &quot;ecx&quot;, &quot;edx&quot;
-				);
-
-
-				_l_p+=(1+SKIP_LINEAR)*w;
-				_l_c+=(1+SKIP_LINEAR)*w;
-				_l_n+=(1+SKIP_LINEAR)*w;
-
-
-		}
-		// retrieve mm7 containg the total
-
-		__asm__ __volatile__(
-		&quot;mov 	$&quot;Mangle(_total)&quot;,		&quot;REG_ax&quot;\n\t&quot;
-		&quot;movd 	%%mm7,	(&quot;REG_ax&quot;)\n\t&quot;
-		&quot;emms\n\t&quot;
-		:
-		:
-		: &quot;eax&quot;
-		);
-		m=(uint32_t)_total.uw[0];
-
-                 return m;
-}
-#endif
-// C version
-uint32_t      ADMVideo_interlaceCount_C( uint8_t *src ,uint32_t w, uint32_t h)
-{
-uint32_t m=0,y,x;
-
-			uint8_t *p,*n,*c;
-			int j;
-			c=src + w;
-			n=src + w+w;
-			p=src ;
-
-
-			for(y=h&gt;&gt;SKIP_FACTOR;  y &gt;2 ; y--)
-					{
-           				for(x=w;x&gt;0;x--)
-								{
-								j=(int)*p-(int)*c;
-								j*=(int)*n-(int)*c;
-							//	printf(&quot;p %d c %d  n %d j %d\n&quot;,*p,*c,*n , j);
-                             					if(  j &gt;MATCH_THRESH)
-								{
-								m++;
-							//	*c=*p=*n=0xff;
-								}
-
-										p++;c++;n++;
-								}
-								p+=(SKIP_LINEAR)*w;
-								c+=(SKIP_LINEAR)*w;
-								n+=(SKIP_LINEAR)*w;
-
-					}
-
-                 return m;
-}
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_interlaced.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,3 +0,0 @@
-
-
-uint32_t      ADMVideo_interlaceCount( uint8_t *src ,uint32_t w, uint32_t h);

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,194 +0,0 @@
-/***************************************************************************
-                          ADM_vidFieldUtil.h  -  description
-                             -------------------
-
-Some functions to manipulate fields
-
-    begin                : Sun Apr 11 2003
-    copyright            : (C) 2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_video/ADM_vidFieldUtil.h&quot;
-
-
-void vidFieldDecimate(uint8_t *src,uint8_t *target, uint32_t linessrc, uint32_t width)
-{
-	linessrc&gt;&gt;=1;
-	for(;linessrc&gt;0;linessrc--)
-		{
-			memcpy(target,src,width);
-			target+=width;
-			src+=width*2;
-		}
-
-
-}
-
-void vidFieldKeepOdd(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
-{
-
-		uint32_t page=w*h;
-
- 		vidFieldDecimate(src+w,target,h*2,w);
-
-		src+=page*2;
-		target+=page;
-		vidFieldDecimate(src+(w&gt;&gt;1),target,h,w&gt;&gt;1);
-
-		src+=page&gt;&gt;1;
-		target+=page&gt;&gt;2;
-		vidFieldDecimate(src+(w&gt;&gt;1),target,h,w&gt;&gt;1);
-}
-void vidFieldKeepEven(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
-{
-	uint32_t page=w*h;
-
-		vidFieldDecimate(src,target,h*2,w);
-
-		src+=page*2;
-		target+=page;
-		vidFieldDecimate(src,target,h,w&gt;&gt;1);
-
-		src+=page&gt;&gt;1;
-		target+=page&gt;&gt;2;
-		vidFieldDecimate(src,target,h,w&gt;&gt;1);
-}
-//
-//
-//
-static void stack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
-{
-uint8_t *dst1,*dst2;
-	dst1=target;
-	dst2=target+((w*h)&gt;&gt;1);	
-	
-	for(uint32_t y=h&gt;&gt;1;y&gt;0;y--)
-	{
-		memcpy(dst1,src,w);
-		memcpy(dst2,src+w,w);
-		src+=2*w;
-		dst1+=w;
-		dst2+=w;
-	}
-	
-}
-//
-//
-//
-static void unstack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
-{
-uint8_t *dst,*src1,*src2;
-        src1=src;
-        src2=src+((w*h)&gt;&gt;1); 
-        dst=target;
-        for(uint32_t y=h&gt;&gt;1;y&gt;0;y--)
-        {
-                memcpy(dst,src1,w);
-                memcpy(dst+w,src2,w);
-                dst+=2*w;
-                src1+=w;
-                src2+=w;
-        }
-        
-}
-
-//
-//	Put field 1 on top of field2
-//
-uint8_t vidFielStack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
-{
-uint8_t *d,*s;
-//uint32_t y;
-
-// interleave Y
-uint32_t page=w*h;
-	d=target;
-	s=src;
-	
-	stack(w,h,s,d);
-	
-	d=target+page;
-	s=src+page;
-	stack(w&gt;&gt;1,h&gt;&gt;1,s,d);
-	
-	d=target+((page*5)&gt;&gt;2);
-	s=src+((page*5)&gt;&gt;2);
-	stack(w&gt;&gt;1,h&gt;&gt;1,s,d);
-	
-	return 1;
-}
-//
-//      Put field 1 on top of field2
-//
-uint8_t vidFielUnStack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target)
-{
-uint8_t *d,*s;
-//uint32_t y;
-
-// interleave Y
-uint32_t page=w*h;
-        d=target;
-        s=src;
-        
-        unstack(w,h,s,d);
-        
-        d=target+page;
-        s=src+page;
-        unstack(w&gt;&gt;1,h&gt;&gt;1,s,d);
-        
-        d=target+((page*5)&gt;&gt;2);
-        s=src+((page*5)&gt;&gt;2);
-        unstack(w&gt;&gt;1,h&gt;&gt;1,s,d);
-        
-        return 1;
-}
-	
-
-void vidFieldMerge(uint32_t w,uint32_t h,uint8_t *src,uint8_t *src2,uint8_t *target)
-{
-uint8_t *d,*s,*s2;
-//uint32_t y;
-
-// interleave Y
-
-	d=target;
-	s=src;
-	s2=src2;
-	for(uint32_t y=h&gt;&gt;1;y&gt;0;y--)
-	{
-		memcpy(d,s,w);
-		memcpy(d+w,s2,w);
-		s+=w;
-		s2+=w;
-		d+=w*2;
-	}
-	//
-	d=target+(w*h);
-	s=src+((w*h)&gt;&gt;1);
-	s2=src2+((w*h)&gt;&gt;1);
-	for(uint32_t y=h&gt;&gt;1;y&gt;0;y--)
-	{
-		memcpy(d,s,w&gt;&gt;1);
-		memcpy(d+(w&gt;&gt;1),s2,w&gt;&gt;1);
-		s+=w&gt;&gt;1;
-		s2+=w&gt;&gt;1;
-		d+=w;
-	}
-
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUtil.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,12 +0,0 @@
-/*
-	Some useful functions to manipulate fields
-
-
-*/
-
-void vidFieldDecimate(uint8_t *src,uint8_t *target, uint32_t linessrc, uint32_t width);
-void vidFieldKeepOdd(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target);
-void vidFieldKeepEven(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target);
-void vidFieldMerge(uint32_t w,uint32_t h,uint8_t *src,uint8_t *src2,uint8_t *target);
-uint8_t vidFielStack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target);
-uint8_t vidFielUnStack(uint32_t w,uint32_t h,uint8_t *src,uint8_t *target);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt	2008-05-04 17:05:41 UTC (rev 4019)
@@ -3,10 +3,8 @@
 ADM_vidFieldUnblend.cpp  
 ADM_vidPartial.cpp    
 ADM_vidColorYuv.cpp   
-ADM_vidFieldUtil.cpp     
 ADM_vidRaw.cpp        
 ADM_vidFont.cpp
-ADM_interlaced.cpp       
 ADM_vidMPdelogo.cpp      
 ADM_vidClean.cpp        
 ADM_vidEqualizer.cpp  

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/mmx_macros.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/mmx_macros.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/mmx_macros.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,706 +0,0 @@
-/*	mmx.h
-
-	MultiMedia eXtensions GCC interface library for IA32.
-
-	To use this library, simply include this header file
-	and compile with GCC.  You MUST have inlining enabled
-	in order for mmx_ok() to work; this can be done by
-	simply using -O on the GCC command line.
-
-	Compiling with -DMMX_TRACE will cause detailed trace
-	output to be sent to stderr for each mmx operation.
-	This adds lots of code, and obviously slows execution to
-	a crawl, but can be very useful for debugging.
-
-	THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY
-	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
-	LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-	AND FITNESS FOR ANY PARTICULAR PURPOSE.
-
-	1997-99 by H. Dietz and R. Fisher
-
- Notes:
-	It appears that the latest gas has the pand problem fixed, therefore
-	  I'll undefine BROKEN_PAND by default.
-*/
-
-#ifndef _MMX_H
-#define _MMX_H
-
-
-/*	Warning:  at this writing, the version of GAS packaged
-	with most Linux distributions does not handle the
-	parallel AND operation mnemonic correctly.  If the
-	symbol BROKEN_PAND is defined, a slower alternative
-	coding will be used.  If execution of mmxtest results
-	in an illegal instruction fault, define this symbol.
-*/
-#undef	BROKEN_PAND
-
-
-/*	The type of an value that fits in an MMX register
-	(note that long long constant values MUST be suffixed
-	 by LL and unsigned long long values by ULL, lest
-	 they be truncated by the compiler)
-*/
-typedef	union {
-	long long		q;	/* Quadword (64-bit) value */
-	unsigned long long	uq;	/* Unsigned Quadword */
-	int			d[2];	/* 2 Doubleword (32-bit) values */
-	unsigned int		ud[2];	/* 2 Unsigned Doubleword */
-	short			w[4];	/* 4 Word (16-bit) values */
-	unsigned short		uw[4];	/* 4 Unsigned Word */
-	char			b[8];	/* 8 Byte (8-bit) values */
-	unsigned char		ub[8];	/* 8 Unsigned Byte */
-	float			s[2];	/* Single-precision (32-bit) value */
-} __attribute__ ((aligned (8))) mmx_t;	/* On an 8-byte (64-bit) boundary */
-
-
-
-/*	Function to test if multimedia instructions are supported...
-*/
-inline extern int
-mm_support(void)
-{
-	/* Returns 1 if MMX instructions are supported,
-	   3 if Cyrix MMX and Extended MMX instructions are supported
-	   5 if AMD MMX and 3DNow! instructions are supported
-	   0 if hardware does not support any of these
-	*/
-	register int rval = 0;
-
-	__asm__ __volatile__ (
-		/* See if CPUID instruction is supported ... */
-		/* ... Get copies of EFLAGS into eax and ecx */
-		&quot;pushf\n\t&quot;
-		&quot;popl %%eax\n\t&quot;
-		&quot;movl %%eax, %%ecx\n\t&quot;
-
-		/* ... Toggle the ID bit in one copy and store */
-		/*     to the EFLAGS reg */
-		&quot;xorl $0x200000, %%eax\n\t&quot;
-		&quot;push %%eax\n\t&quot;
-		&quot;popf\n\t&quot;
-
-		/* ... Get the (hopefully modified) EFLAGS */
-		&quot;pushf\n\t&quot;
-		&quot;popl %%eax\n\t&quot;
-
-		/* ... Compare and test result */
-		&quot;xorl %%eax, %%ecx\n\t&quot;
-		&quot;testl $0x200000, %%ecx\n\t&quot;
-		&quot;jz NotSupported1\n\t&quot;		/* CPUID not supported */
-
-
-		/* Get standard CPUID information, and
-		       go to a specific vendor section */
-		&quot;movl $0, %%eax\n\t&quot;
-		&quot;cpuid\n\t&quot;
-
-		/* Check for Intel */
-		&quot;cmpl $0x756e6547, %%ebx\n\t&quot;
-		&quot;jne TryAMD\n\t&quot;
-		&quot;cmpl $0x49656e69, %%edx\n\t&quot;
-		&quot;jne TryAMD\n\t&quot;
-		&quot;cmpl $0x6c65746e, %%ecx\n&quot;
-		&quot;jne TryAMD\n\t&quot;
-		&quot;jmp Intel\n\t&quot;
-
-		/* Check for AMD */
-		&quot;\nTryAMD:\n\t&quot;
-		&quot;cmpl $0x68747541, %%ebx\n\t&quot;
-		&quot;jne TryCyrix\n\t&quot;
-		&quot;cmpl $0x69746e65, %%edx\n\t&quot;
-		&quot;jne TryCyrix\n\t&quot;
-		&quot;cmpl $0x444d4163, %%ecx\n&quot;
-		&quot;jne TryCyrix\n\t&quot;
-		&quot;jmp AMD\n\t&quot;
-
-		/* Check for Cyrix */
-		&quot;\nTryCyrix:\n\t&quot;
-		&quot;cmpl $0x69727943, %%ebx\n\t&quot;
-		&quot;jne NotSupported2\n\t&quot;
-		&quot;cmpl $0x736e4978, %%edx\n\t&quot;
-		&quot;jne NotSupported3\n\t&quot;
-		&quot;cmpl $0x64616574, %%ecx\n\t&quot;
-		&quot;jne NotSupported4\n\t&quot;
-		/* Drop through to Cyrix... */
-
-
-		/* Cyrix Section */
-		/* See if extended CPUID level 80000001 is supported */
-		/* The value of CPUID/80000001 for the 6x86MX is undefined
-		   according to the Cyrix CPU Detection Guide (Preliminary
-		   Rev. 1.01 table 1), so we'll check the value of eax for
-		   CPUID/0 to see if standard CPUID level 2 is supported.
-		   According to the table, the only CPU which supports level
-		   2 is also the only one which supports extended CPUID levels.
-		*/
-		&quot;cmpl $0x2, %%eax\n\t&quot;
-		&quot;jne MMXtest\n\t&quot;	/* Use standard CPUID instead */
-
-		/* Extended CPUID supported (in theory), so get extended
-		   features */
-		&quot;movl $0x80000001, %%eax\n\t&quot;
-		&quot;cpuid\n\t&quot;
-		&quot;testl $0x00800000, %%eax\n\t&quot;	/* Test for MMX */
-		&quot;jz NotSupported5\n\t&quot;		/* MMX not supported */
-		&quot;testl $0x01000000, %%eax\n\t&quot;	/* Test for Ext'd MMX */
-		&quot;jnz EMMXSupported\n\t&quot;
-		&quot;movl $1, %0:\n\n\t&quot;		/* MMX Supported */
-		&quot;jmp Return\n\n&quot;
-		&quot;EMMXSupported:\n\t&quot;
-		&quot;movl $3, %0:\n\n\t&quot;		/* EMMX and MMX Supported */
-		&quot;jmp Return\n\t&quot;
-
-
-		/* AMD Section */
-		&quot;AMD:\n\t&quot;
-
-		/* See if extended CPUID is supported */
-		&quot;movl $0x80000000, %%eax\n\t&quot;
-		&quot;cpuid\n\t&quot;
-		&quot;cmpl $0x80000000, %%eax\n\t&quot;
-		&quot;jl MMXtest\n\t&quot;	/* Use standard CPUID instead */
-
-		/* Extended CPUID supported, so get extended features */
-		&quot;movl $0x80000001, %%eax\n\t&quot;
-		&quot;cpuid\n\t&quot;
-		&quot;testl $0x00800000, %%edx\n\t&quot;	/* Test for MMX */
-		&quot;jz NotSupported6\n\t&quot;		/* MMX not supported */
-		&quot;testl $0x80000000, %%edx\n\t&quot;	/* Test for 3DNow! */
-		&quot;jnz ThreeDNowSupported\n\t&quot;
-		&quot;movl $1, %0:\n\n\t&quot;		/* MMX Supported */
-		&quot;jmp Return\n\n&quot;
-		&quot;ThreeDNowSupported:\n\t&quot;
-		&quot;movl $5, %0:\n\n\t&quot;		/* 3DNow! and MMX Supported */
-		&quot;jmp Return\n\t&quot;
-
-
-		/* Intel Section */
-		&quot;Intel:\n\t&quot;
-
-		/* Check for MMX */
-		&quot;MMXtest:\n\t&quot;
-		&quot;movl $1, %%eax\n\t&quot;
-		&quot;cpuid\n\t&quot;
-		&quot;testl $0x00800000, %%edx\n\t&quot;	/* Test for MMX */
-		&quot;jz NotSupported7\n\t&quot;		/* MMX Not supported */
-		&quot;movl $1, %0:\n\n\t&quot;		/* MMX Supported */
-		&quot;jmp Return\n\t&quot;
-
-		/* Nothing supported */
-		&quot;\nNotSupported1:\n\t&quot;
-		&quot;#movl $101, %0:\n\n\t&quot;
-		&quot;\nNotSupported2:\n\t&quot;
-		&quot;#movl $102, %0:\n\n\t&quot;
-		&quot;\nNotSupported3:\n\t&quot;
-		&quot;#movl $103, %0:\n\n\t&quot;
-		&quot;\nNotSupported4:\n\t&quot;
-		&quot;#movl $104, %0:\n\n\t&quot;
-		&quot;\nNotSupported5:\n\t&quot;
-		&quot;#movl $105, %0:\n\n\t&quot;
-		&quot;\nNotSupported6:\n\t&quot;
-		&quot;#movl $106, %0:\n\n\t&quot;
-		&quot;\nNotSupported7:\n\t&quot;
-		&quot;#movl $107, %0:\n\n\t&quot;
-		&quot;movl $0, %0:\n\n\t&quot;
-
-		&quot;Return:\n\t&quot;
-		: &quot;=a&quot; (rval)
-		: /* no input */
-		: &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;
-	);
-
-	/* Return */
-	return(rval);
-}
-
-/*	Function to test if mmx instructions are supported...
-*/
-inline extern int
-mmx_ok(void)
-{
-	/* Returns 1 if MMX instructions are supported, 0 otherwise */
-	return ( mm_support() &amp; 0x1 );
-}
-
-
-/*	Helper functions for the instruction macros that follow...
-	(note that memory-to-register, m2r, instructions are nearly
-	 as efficient as register-to-register, r2r, instructions;
-	 however, memory-to-memory instructions are really simulated
-	 as a convenience, and are only 1/3 as efficient)
-*/
-#ifdef	MMX_TRACE
-
-/*	Include the stuff for printing a trace to stderr...
-*/
-
-#include &lt;stdio.h&gt;
-
-#define	mmx_i2r(op, imm, reg) \
-	{ \
-		mmx_t mmx_trace; \
-		mmx_trace.uq = (imm); \
-		printf(#op &quot;_i2r(&quot; #imm &quot;=0x%08x%08x, &quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-		__asm__ __volatile__ (&quot;movq %%&quot; #reg &quot;, %0&quot; \
-				      : &quot;=X&quot; (mmx_trace) \
-				      : /* nothing */ ); \
-		printf(#reg &quot;=0x%08x%08x) =&gt; &quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-		__asm__ __volatile__ (#op &quot; %0, %%&quot; #reg \
-				      : /* nothing */ \
-				      : &quot;X&quot; (imm)); \
-		__asm__ __volatile__ (&quot;movq %%&quot; #reg &quot;, %0&quot; \
-				      : &quot;=X&quot; (mmx_trace) \
-				      : /* nothing */ ); \
-		printf(#reg &quot;=0x%08x%08x\n&quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-	}
-
-#define	mmx_m2r(op, mem, reg) \
-	{ \
-		mmx_t mmx_trace; \
-		mmx_trace = (mem); \
-		printf(#op &quot;_m2r(&quot; #mem &quot;=0x%08x%08x, &quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-		__asm__ __volatile__ (&quot;movq %%&quot; #reg &quot;, %0&quot; \
-				      : &quot;=X&quot; (mmx_trace) \
-				      : /* nothing */ ); \
-		printf(#reg &quot;=0x%08x%08x) =&gt; &quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-		__asm__ __volatile__ (#op &quot; %0, %%&quot; #reg \
-				      : /* nothing */ \
-				      : &quot;X&quot; (mem)); \
-		__asm__ __volatile__ (&quot;movq %%&quot; #reg &quot;, %0&quot; \
-				      : &quot;=X&quot; (mmx_trace) \
-				      : /* nothing */ ); \
-		printf(#reg &quot;=0x%08x%08x\n&quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-	}
-
-#define	mmx_r2m(op, reg, mem) \
-	{ \
-		mmx_t mmx_trace; \
-		__asm__ __volatile__ (&quot;movq %%&quot; #reg &quot;, %0&quot; \
-				      : &quot;=X&quot; (mmx_trace) \
-				      : /* nothing */ ); \
-		printf(#op &quot;_r2m(&quot; #reg &quot;=0x%08x%08x, &quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-		mmx_trace = (mem); \
-		printf(#mem &quot;=0x%08x%08x) =&gt; &quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-		__asm__ __volatile__ (#op &quot; %%&quot; #reg &quot;, %0&quot; \
-				      : &quot;=X&quot; (mem) \
-				      : /* nothing */ ); \
-		mmx_trace = (mem); \
-		printf(#mem &quot;=0x%08x%08x\n&quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-	}
-
-#define	mmx_r2r(op, regs, regd) \
-	{ \
-		mmx_t mmx_trace; \
-		__asm__ __volatile__ (&quot;movq %%&quot; #regs &quot;, %0&quot; \
-				      : &quot;=X&quot; (mmx_trace) \
-				      : /* nothing */ ); \
-		printf(#op &quot;_r2r(&quot; #regs &quot;=0x%08x%08x, &quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-		__asm__ __volatile__ (&quot;movq %%&quot; #regd &quot;, %0&quot; \
-				      : &quot;=X&quot; (mmx_trace) \
-				      : /* nothing */ ); \
-		printf(#regd &quot;=0x%08x%08x) =&gt; &quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-		__asm__ __volatile__ (#op &quot; %&quot; #regs &quot;, %&quot; #regd); \
-		__asm__ __volatile__ (&quot;movq %%&quot; #regd &quot;, %0&quot; \
-				      : &quot;=X&quot; (mmx_trace) \
-				      : /* nothing */ ); \
-		printf(#regd &quot;=0x%08x%08x\n&quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-	}
-
-#define	mmx_m2m(op, mems, memd) \
-	{ \
-		mmx_t mmx_trace; \
-		mmx_trace = (mems); \
-		printf(#op &quot;_m2m(&quot; #mems &quot;=0x%08x%08x, &quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-		mmx_trace = (memd); \
-		printf(#memd &quot;=0x%08x%08x) =&gt; &quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-		__asm__ __volatile__ (&quot;movq %0, %%mm0\n\t&quot; \
-				      #op &quot; %1, %%mm0\n\t&quot; \
-				      &quot;movq %%mm0, %0&quot; \
-				      : &quot;=X&quot; (memd) \
-				      : &quot;X&quot; (mems)); \
-		mmx_trace = (memd); \
-		printf(#memd &quot;=0x%08x%08x\n&quot;, \
-			mmx_trace.d[1], mmx_trace.d[0]); \
-	}
-
-#else
-
-/*	These macros are a lot simpler without the tracing...
-*/
-
-#define	mmx_i2r(op, imm, reg) \
-	__asm__ __volatile__ (#op &quot; %0, %%&quot; #reg \
-			      : /* nothing */ \
-			      : &quot;X&quot; (imm) )
-
-#define	mmx_m2r(op, mem, reg) \
-	__asm__ __volatile__ (#op &quot; %0, %%&quot; #reg \
-			      : /* nothing */ \
-			      : &quot;X&quot; (mem))
-
-#define	mmx_r2m(op, reg, mem) \
-	__asm__ __volatile__ (#op &quot; %%&quot; #reg &quot;, %0&quot; \
-			      : &quot;=X&quot; (mem) \
-			      : /* nothing */ )
-
-#define	mmx_r2r(op, regs, regd) \
-	__asm__ __volatile__ (#op &quot; %&quot; #regs &quot;, %&quot; #regd)
-
-#define	mmx_m2m(op, mems, memd) \
-	__asm__ __volatile__ (&quot;movq %0, %%mm0\n\t&quot; \
-			      #op &quot; %1, %%mm0\n\t&quot; \
-			      &quot;movq %%mm0, %0&quot; \
-			      : &quot;=X&quot; (memd) \
-			      : &quot;X&quot; (mems))
-
-#endif
-
-
-/*	1x64 MOVe Quadword
-	(this is both a load and a store...
-	 in fact, it is the only way to store)
-*/
-#define	movq_m2r(var, reg)	mmx_m2r(movq, var, reg)
-#define	movq_r2m(reg, var)	mmx_r2m(movq, reg, var)
-#define	movq_r2r(regs, regd)	mmx_r2r(movq, regs, regd)
-#define	movq(vars, vard) \
-	__asm__ __volatile__ (&quot;movq %1, %%mm0\n\t&quot; \
-			      &quot;movq %%mm0, %0&quot; \
-			      : &quot;=X&quot; (vard) \
-			      : &quot;X&quot; (vars))
-
-
-/*	1x32 MOVe Doubleword
-	(like movq, this is both load and store...
-	 but is most useful for moving things between
-	 mmx registers and ordinary registers)
-*/
-#define	movd_m2r(var, reg)	mmx_m2r(movd, var, reg)
-#define	movd_r2m(reg, var)	mmx_r2m(movd, reg, var)
-#define	movd_r2r(regs, regd)	mmx_r2r(movd, regs, regd)
-#define	movd(vars, vard) \
-	__asm__ __volatile__ (&quot;movd %1, %%mm0\n\t&quot; \
-			      &quot;movd %%mm0, %0&quot; \
-			      : &quot;=X&quot; (vard) \
-			      : &quot;X&quot; (vars))
-
-
-/*	2x32, 4x16, and 8x8 Parallel ADDs
-*/
-#define	paddd_m2r(var, reg)	mmx_m2r(paddd, var, reg)
-#define	paddd_r2r(regs, regd)	mmx_r2r(paddd, regs, regd)
-#define	paddd(vars, vard)	mmx_m2m(paddd, vars, vard)
-
-#define	paddw_m2r(var, reg)	mmx_m2r(paddw, var, reg)
-#define	paddw_r2r(regs, regd)	mmx_r2r(paddw, regs, regd)
-#define	paddw(vars, vard)	mmx_m2m(paddw, vars, vard)
-
-#define	paddb_m2r(var, reg)	mmx_m2r(paddb, var, reg)
-#define	paddb_r2r(regs, regd)	mmx_r2r(paddb, regs, regd)
-#define	paddb(vars, vard)	mmx_m2m(paddb, vars, vard)
-
-
-/*	4x16 and 8x8 Parallel ADDs using Saturation arithmetic
-*/
-#define	paddsw_m2r(var, reg)	mmx_m2r(paddsw, var, reg)
-#define	paddsw_r2r(regs, regd)	mmx_r2r(paddsw, regs, regd)
-#define	paddsw(vars, vard)	mmx_m2m(paddsw, vars, vard)
-
-#define	paddsb_m2r(var, reg)	mmx_m2r(paddsb, var, reg)
-#define	paddsb_r2r(regs, regd)	mmx_r2r(paddsb, regs, regd)
-#define	paddsb(vars, vard)	mmx_m2m(paddsb, vars, vard)
-
-
-/*	4x16 and 8x8 Parallel ADDs using Unsigned Saturation arithmetic
-*/
-#define	paddusw_m2r(var, reg)	mmx_m2r(paddusw, var, reg)
-#define	paddusw_r2r(regs, regd)	mmx_r2r(paddusw, regs, regd)
-#define	paddusw(vars, vard)	mmx_m2m(paddusw, vars, vard)
-
-#define	paddusb_m2r(var, reg)	mmx_m2r(paddusb, var, reg)
-#define	paddusb_r2r(regs, regd)	mmx_r2r(paddusb, regs, regd)
-#define	paddusb(vars, vard)	mmx_m2m(paddusb, vars, vard)
-
-
-/*	2x32, 4x16, and 8x8 Parallel SUBs
-*/
-#define	psubd_m2r(var, reg)	mmx_m2r(psubd, var, reg)
-#define	psubd_r2r(regs, regd)	mmx_r2r(psubd, regs, regd)
-#define	psubd(vars, vard)	mmx_m2m(psubd, vars, vard)
-
-#define	psubw_m2r(var, reg)	mmx_m2r(psubw, var, reg)
-#define	psubw_r2r(regs, regd)	mmx_r2r(psubw, regs, regd)
-#define	psubw(vars, vard)	mmx_m2m(psubw, vars, vard)
-
-#define	psubb_m2r(var, reg)	mmx_m2r(psubb, var, reg)
-#define	psubb_r2r(regs, regd)	mmx_r2r(psubb, regs, regd)
-#define	psubb(vars, vard)	mmx_m2m(psubb, vars, vard)
-
-
-/*	4x16 and 8x8 Parallel SUBs using Saturation arithmetic
-*/
-#define	psubsw_m2r(var, reg)	mmx_m2r(psubsw, var, reg)
-#define	psubsw_r2r(regs, regd)	mmx_r2r(psubsw, regs, regd)
-#define	psubsw(vars, vard)	mmx_m2m(psubsw, vars, vard)
-
-#define	psubsb_m2r(var, reg)	mmx_m2r(psubsb, var, reg)
-#define	psubsb_r2r(regs, regd)	mmx_r2r(psubsb, regs, regd)
-#define	psubsb(vars, vard)	mmx_m2m(psubsb, vars, vard)
-
-
-/*	4x16 and 8x8 Parallel SUBs using Unsigned Saturation arithmetic
-*/
-#define	psubusw_m2r(var, reg)	mmx_m2r(psubusw, var, reg)
-#define	psubusw_r2r(regs, regd)	mmx_r2r(psubusw, regs, regd)
-#define	psubusw(vars, vard)	mmx_m2m(psubusw, vars, vard)
-
-#define	psubusb_m2r(var, reg)	mmx_m2r(psubusb, var, reg)
-#define	psubusb_r2r(regs, regd)	mmx_r2r(psubusb, regs, regd)
-#define	psubusb(vars, vard)	mmx_m2m(psubusb, vars, vard)
-
-
-/*	4x16 Parallel MULs giving Low 4x16 portions of results
-*/
-#define	pmullw_m2r(var, reg)	mmx_m2r(pmullw, var, reg)
-#define	pmullw_r2r(regs, regd)	mmx_r2r(pmullw, regs, regd)
-#define	pmullw(vars, vard)	mmx_m2m(pmullw, vars, vard)
-
-
-/*	4x16 Parallel MULs giving High 4x16 portions of results
-*/
-#define	pmulhw_m2r(var, reg)	mmx_m2r(pmulhw, var, reg)
-#define	pmulhw_r2r(regs, regd)	mmx_r2r(pmulhw, regs, regd)
-#define	pmulhw(vars, vard)	mmx_m2m(pmulhw, vars, vard)
-
-
-/*	4x16-&gt;2x32 Parallel Mul-ADD
-	(muls like pmullw, then adds adjacent 16-bit fields
-	 in the multiply result to make the final 2x32 result)
-*/
-#define	pmaddwd_m2r(var, reg)	mmx_m2r(pmaddwd, var, reg)
-#define	pmaddwd_r2r(regs, regd)	mmx_r2r(pmaddwd, regs, regd)
-#define	pmaddwd(vars, vard)	mmx_m2m(pmaddwd, vars, vard)
-
-
-/*	1x64 bitwise AND
-*/
-#ifdef	BROKEN_PAND
-#define	pand_m2r(var, reg) \
-	{ \
-		mmx_m2r(pandn, (mmx_t) -1LL, reg); \
-		mmx_m2r(pandn, var, reg); \
-	}
-#define	pand_r2r(regs, regd) \
-	{ \
-		mmx_m2r(pandn, (mmx_t) -1LL, regd); \
-		mmx_r2r(pandn, regs, regd) \
-	}
-#define	pand(vars, vard) \
-	{ \
-		movq_m2r(vard, mm0); \
-		mmx_m2r(pandn, (mmx_t) -1LL, mm0); \
-		mmx_m2r(pandn, vars, mm0); \
-		movq_r2m(mm0, vard); \
-	}
-#else
-#define	pand_m2r(var, reg)	mmx_m2r(pand, var, reg)
-#define	pand_r2r(regs, regd)	mmx_r2r(pand, regs, regd)
-#define	pand(vars, vard)	mmx_m2m(pand, vars, vard)
-#endif
-
-
-/*	1x64 bitwise AND with Not the destination
-*/
-#define	pandn_m2r(var, reg)	mmx_m2r(pandn, var, reg)
-#define	pandn_r2r(regs, regd)	mmx_r2r(pandn, regs, regd)
-#define	pandn(vars, vard)	mmx_m2m(pandn, vars, vard)
-
-
-/*	1x64 bitwise OR
-*/
-#define	por_m2r(var, reg)	mmx_m2r(por, var, reg)
-#define	por_r2r(regs, regd)	mmx_r2r(por, regs, regd)
-#define	por(vars, vard)	mmx_m2m(por, vars, vard)
-
-
-/*	1x64 bitwise eXclusive OR
-*/
-#define	pxor_m2r(var, reg)	mmx_m2r(pxor, var, reg)
-#define	pxor_r2r(regs, regd)	mmx_r2r(pxor, regs, regd)
-#define	pxor(vars, vard)	mmx_m2m(pxor, vars, vard)
-
-
-/*	2x32, 4x16, and 8x8 Parallel CoMPare for EQuality
-	(resulting fields are either 0 or -1)
-*/
-#define	pcmpeqd_m2r(var, reg)	mmx_m2r(pcmpeqd, var, reg)
-#define	pcmpeqd_r2r(regs, regd)	mmx_r2r(pcmpeqd, regs, regd)
-#define	pcmpeqd(vars, vard)	mmx_m2m(pcmpeqd, vars, vard)
-
-#define	pcmpeqw_m2r(var, reg)	mmx_m2r(pcmpeqw, var, reg)
-#define	pcmpeqw_r2r(regs, regd)	mmx_r2r(pcmpeqw, regs, regd)
-#define	pcmpeqw(vars, vard)	mmx_m2m(pcmpeqw, vars, vard)
-
-#define	pcmpeqb_m2r(var, reg)	mmx_m2r(pcmpeqb, var, reg)
-#define	pcmpeqb_r2r(regs, regd)	mmx_r2r(pcmpeqb, regs, regd)
-#define	pcmpeqb(vars, vard)	mmx_m2m(pcmpeqb, vars, vard)
-
-
-/*	2x32, 4x16, and 8x8 Parallel CoMPare for Greater Than
-	(resulting fields are either 0 or -1)
-*/
-#define	pcmpgtd_m2r(var, reg)	mmx_m2r(pcmpgtd, var, reg)
-#define	pcmpgtd_r2r(regs, regd)	mmx_r2r(pcmpgtd, regs, regd)
-#define	pcmpgtd(vars, vard)	mmx_m2m(pcmpgtd, vars, vard)
-
-#define	pcmpgtw_m2r(var, reg)	mmx_m2r(pcmpgtw, var, reg)
-#define	pcmpgtw_r2r(regs, regd)	mmx_r2r(pcmpgtw, regs, regd)
-#define	pcmpgtw(vars, vard)	mmx_m2m(pcmpgtw, vars, vard)
-
-#define	pcmpgtb_m2r(var, reg)	mmx_m2r(pcmpgtb, var, reg)
-#define	pcmpgtb_r2r(regs, regd)	mmx_r2r(pcmpgtb, regs, regd)
-#define	pcmpgtb(vars, vard)	mmx_m2m(pcmpgtb, vars, vard)
-
-
-/*	1x64, 2x32, and 4x16 Parallel Shift Left Logical
-*/
-#define	psllq_i2r(imm, reg)	mmx_i2r(psllq, imm, reg)
-#define	psllq_m2r(var, reg)	mmx_m2r(psllq, var, reg)
-#define	psllq_r2r(regs, regd)	mmx_r2r(psllq, regs, regd)
-#define	psllq(vars, vard)	mmx_m2m(psllq, vars, vard)
-
-#define	pslld_i2r(imm, reg)	mmx_i2r(pslld, imm, reg)
-#define	pslld_m2r(var, reg)	mmx_m2r(pslld, var, reg)
-#define	pslld_r2r(regs, regd)	mmx_r2r(pslld, regs, regd)
-#define	pslld(vars, vard)	mmx_m2m(pslld, vars, vard)
-
-#define	psllw_i2r(imm, reg)	mmx_i2r(psllw, imm, reg)
-#define	psllw_m2r(var, reg)	mmx_m2r(psllw, var, reg)
-#define	psllw_r2r(regs, regd)	mmx_r2r(psllw, regs, regd)
-#define	psllw(vars, vard)	mmx_m2m(psllw, vars, vard)
-
-
-/*	1x64, 2x32, and 4x16 Parallel Shift Right Logical
-*/
-#define	psrlq_i2r(imm, reg)	mmx_i2r(psrlq, imm, reg)
-#define	psrlq_m2r(var, reg)	mmx_m2r(psrlq, var, reg)
-#define	psrlq_r2r(regs, regd)	mmx_r2r(psrlq, regs, regd)
-#define	psrlq(vars, vard)	mmx_m2m(psrlq, vars, vard)
-
-#define	psrld_i2r(imm, reg)	mmx_i2r(psrld, imm, reg)
-#define	psrld_m2r(var, reg)	mmx_m2r(psrld, var, reg)
-#define	psrld_r2r(regs, regd)	mmx_r2r(psrld, regs, regd)
-#define	psrld(vars, vard)	mmx_m2m(psrld, vars, vard)
-
-#define	psrlw_i2r(imm, reg)	mmx_i2r(psrlw, imm, reg)
-#define	psrlw_m2r(var, reg)	mmx_m2r(psrlw, var, reg)
-#define	psrlw_r2r(regs, regd)	mmx_r2r(psrlw, regs, regd)
-#define	psrlw(vars, vard)	mmx_m2m(psrlw, vars, vard)
-
-
-/*	2x32 and 4x16 Parallel Shift Right Arithmetic
-*/
-#define	psrad_i2r(imm, reg)	mmx_i2r(psrad, imm, reg)
-#define	psrad_m2r(var, reg)	mmx_m2r(psrad, var, reg)
-#define	psrad_r2r(regs, regd)	mmx_r2r(psrad, regs, regd)
-#define	psrad(vars, vard)	mmx_m2m(psrad, vars, vard)
-
-#define	psraw_i2r(imm, reg)	mmx_i2r(psraw, imm, reg)
-#define	psraw_m2r(var, reg)	mmx_m2r(psraw, var, reg)
-#define	psraw_r2r(regs, regd)	mmx_r2r(psraw, regs, regd)
-#define	psraw(vars, vard)	mmx_m2m(psraw, vars, vard)
-
-
-/*	2x32-&gt;4x16 and 4x16-&gt;8x8 PACK and Signed Saturate
-	(packs source and dest fields into dest in that order)
-*/
-#define	packssdw_m2r(var, reg)	mmx_m2r(packssdw, var, reg)
-#define	packssdw_r2r(regs, regd) mmx_r2r(packssdw, regs, regd)
-#define	packssdw(vars, vard)	mmx_m2m(packssdw, vars, vard)
-
-#define	packsswb_m2r(var, reg)	mmx_m2r(packsswb, var, reg)
-#define	packsswb_r2r(regs, regd) mmx_r2r(packsswb, regs, regd)
-#define	packsswb(vars, vard)	mmx_m2m(packsswb, vars, vard)
-
-
-/*	4x16-&gt;8x8 PACK and Unsigned Saturate
-	(packs source and dest fields into dest in that order)
-*/
-#define	packuswb_m2r(var, reg)	mmx_m2r(packuswb, var, reg)
-#define	packuswb_r2r(regs, regd) mmx_r2r(packuswb, regs, regd)
-#define	packuswb(vars, vard)	mmx_m2m(packuswb, vars, vard)
-
-
-/*	2x32-&gt;1x64, 4x16-&gt;2x32, and 8x8-&gt;4x16 UNPaCK Low
-	(interleaves low half of dest with low half of source
-	 as padding in each result field)
-*/
-#define	punpckldq_m2r(var, reg)	mmx_m2r(punpckldq, var, reg)
-#define	punpckldq_r2r(regs, regd) mmx_r2r(punpckldq, regs, regd)
-#define	punpckldq(vars, vard)	mmx_m2m(punpckldq, vars, vard)
-
-#define	punpcklwd_m2r(var, reg)	mmx_m2r(punpcklwd, var, reg)
-#define	punpcklwd_r2r(regs, regd) mmx_r2r(punpcklwd, regs, regd)
-#define	punpcklwd(vars, vard)	mmx_m2m(punpcklwd, vars, vard)
-
-#define	punpcklbw_m2r(var, reg)	mmx_m2r(punpcklbw, var, reg)
-#define	punpcklbw_r2r(regs, regd) mmx_r2r(punpcklbw, regs, regd)
-#define	punpcklbw(vars, vard)	mmx_m2m(punpcklbw, vars, vard)
-
-
-/*	2x32-&gt;1x64, 4x16-&gt;2x32, and 8x8-&gt;4x16 UNPaCK High
-	(interleaves high half of dest with high half of source
-	 as padding in each result field)
-*/
-#define	punpckhdq_m2r(var, reg)	mmx_m2r(punpckhdq, var, reg)
-#define	punpckhdq_r2r(regs, regd) mmx_r2r(punpckhdq, regs, regd)
-#define	punpckhdq(vars, vard)	mmx_m2m(punpckhdq, vars, vard)
-
-#define	punpckhwd_m2r(var, reg)	mmx_m2r(punpckhwd, var, reg)
-#define	punpckhwd_r2r(regs, regd) mmx_r2r(punpckhwd, regs, regd)
-#define	punpckhwd(vars, vard)	mmx_m2m(punpckhwd, vars, vard)
-
-#define	punpckhbw_m2r(var, reg)	mmx_m2r(punpckhbw, var, reg)
-#define	punpckhbw_r2r(regs, regd) mmx_r2r(punpckhbw, regs, regd)
-#define	punpckhbw(vars, vard)	mmx_m2m(punpckhbw, vars, vard)
-
-
-/*	Empty MMx State
-	(used to clean-up when going from mmx to float use
-	 of the registers that are shared by both; note that
-	 there is no float-to-mmx operation needed, because
-	 only the float tag word info is corruptible)
-*/
-#ifdef	MMX_TRACE
-
-#define	emms() \
-	{ \
-		printf(&quot;emms()\n&quot;); \
-		__asm__ __volatile__ (&quot;emms&quot;); \
-	}
-
-#else
-
-#define	emms()			__asm__ __volatile__ (&quot;emms&quot;)
-
-#endif
-
-#endif
-

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDeintASM.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDeintASM.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDeintASM.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -28,7 +28,7 @@
 #ifdef ADM_CPU_X86
 //	#define DEBUG_DEINT 1
 //	#define MMX_TRACE 1
-	#include &quot;ADM_video/mmx_macros.h&quot;
+	#include &quot;ADM_mmxMacros.h&quot;
 
  void myDeintASM(void);
 

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDelta.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDelta.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDelta.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,138 +0,0 @@
-//
-//      Try to detect blended image
-//      Mean (C) 2005
-//      GPL v2.0
-//
-
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-//#include &quot;ADM_vidCNR2_param.h&quot;
-
-//#define SUBST 1
-
-class vidDelta:public AVDMGenericVideoStream
-{
-
-protected:
-  virtual char *printConf (void);
-  VideoCache *vidCache;
-
-
-public:
-
-                        vidDelta (AVDMGenericVideoStream * in, CONFcouple * setup);
-        virtual         ~vidDelta ();
-  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
-					 ADMImage * data, uint32_t * flags);
-  uint8_t configure (AVDMGenericVideoStream * instream);
-  virtual uint8_t getCoupledConf (CONFcouple ** couples);
-
-};
-
-static FILTER_PARAM delta_template =
-  { 0 };
-
-BUILD_CREATE (delta_create, vidDelta);
-SCRIPT_CREATE (delta_script, vidDelta, delta_template);
-
-
-/*************************************/
-uint8_t vidDelta::configure (AVDMGenericVideoStream * in)
-{
-        return 1;
-}
-/*************************************/
-char *vidDelta::printConf (void)
-{
-  static char buf[50];
-  sprintf ((char *) buf, &quot; Delta&quot;);
-  return buf;
-}
-/*************************************/
-vidDelta::vidDelta (AVDMGenericVideoStream * in, CONFcouple * couples)
-{
-
-  _in = in;
-  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
-  _info.encoding = 1;
-  vidCache = new VideoCache (4, in);
-  
-  
-}
-//____________________________________________________________________
-vidDelta::~vidDelta ()
-{
-
-  delete vidCache;
-  vidCache = NULL;
-
-}
-
-//______________________________________________________________
-uint8_t vidDelta::getFrameNumberNoAlloc (uint32_t frame,
-				uint32_t * len,
-				ADMImage * data, uint32_t * flags)
-{
-int w,h,page;
-ADMImage *cur,*prev,*next;
-        w=_info.width;
-        h=_info.height;
-        page=w*h;
-  if(frame&gt;= _info.nb_frames) return 0;
-  if(!frame || frame&gt;=_info.nb_frames-1)
-  {
-        memset(YPLANE(data),0,page);
-        memset(UPLANE(data),128,page&gt;&gt;2);
-        memset(VPLANE(data),128,page&gt;&gt;2);
-        return 1;
-  }
-  cur=vidCache-&gt;getImage (frame);
-  prev=vidCache-&gt;getImage (frame-1);
-  next=vidCache-&gt;getImage (frame+1);
-  // No chroma
-        memset(UPLANE(data),128,page&gt;&gt;2);
-        memset(VPLANE(data),128,page&gt;&gt;2);
-
-   uint8_t *c=YPLANE(cur);
-   uint8_t *p=YPLANE(prev);
-   uint8_t *n=YPLANE(next);
-   uint8_t *out=YPLANE(data);
-#define SAME_THRESH 32
-   int a,b,d,cp,cn,e;
-   for(int y=0;y&lt;h;y++)
-        for(int x=0;x&lt;w;x++)
-        {
-                a=*c++;
-                b=*p++;
-                e=*n++;
-                cp=abs(a-b);
-                cn=abs(a-e);
-                // Cp is the != between current and previous
-                // cn is the != between current and next
-                // We try to spo frames that are blended betwwen next &amp; previous
-                
-                if(cp&gt;SAME_THRESH &amp;&amp; cn &gt; SAME_THRESH &amp;&amp; abs(cp-cn) &lt; 128) *out++=255;//(cp+cn)/2;
-                        else *out++=0;
-        }
-
-
-  vidCache-&gt;unlockAll ();
-  return 1;
-}
-
-/*************************************/
-uint8_t vidDelta::getCoupledConf (CONFcouple ** couples)
-{
-
-  *couples=NULL;
-  return 1;
-}
-
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,387 +0,0 @@
-/***************************************************************************
-                          ADM_vidDenoise.cpp  -  description
-                             -------------------
-    begin                : Mon Nov 25 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-    
-    Denoiser inspired from DNR in transcode
-    Ported to YV12 and simplified
-    
-   Original code  Copyright (C) Gerhard Monzel - November 2001
- 
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_vidDenoise.h&quot;
-
-
-#include &quot;DIA_factory.h&quot;
-
-static FILTER_PARAM denoiseParam={5,{&quot;lumaLock&quot;,&quot;lumaThreshold&quot;,&quot;chromaLock&quot;,&quot;chromaThreshold&quot;,
-					&quot;sceneChange&quot;}};
-
-
-SCRIPT_CREATE(denoise_script,ADMVideoDenoise,denoiseParam);
-
-uint8_t distMatrix[256][256];
-uint32_t fixMul[16];
-
-//static uint8_t matrixReady=0;
-//static uint8_t doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb);
-
-BUILD_CREATE(denoise_create,ADMVideoDenoise);
-char *ADMVideoDenoise::printConf( void )
-{
- 	static char buf[50];
-
-  ADM_assert(_param); 	
- 	sprintf((char *)buf,&quot; Denoise : Lum :%02ld/:%02ld / Chm :%02ld/%02ld&quot;,
-  								_param-&gt;lumaLock,
-          				_param-&gt;lumaThreshold,
-              		_param-&gt;chromaLock,
-                	_param-&gt;chromaThreshold);
-        return buf;
-}
-void buildDistMatrix( void );
-void buildDistMatrix( void )
-{
-int d;	
-	for(uint32_t y=255;y&gt;0;y--)
-	for(uint32_t x=255;x&gt;0;x--)
-	{
-		  d=x-y;
-		  if(d&lt;0) d=-d;
-		  distMatrix[x][y]=d;
-		
-	}
-
-	 for(int i=1;i&lt;16;i++)
-                        {
-                                        fixMul[i]=(1&lt;&lt;16)/i;
-                        }
-
-}
-
-//_______________________________________________________________
-
-ADMVideoDenoise::ADMVideoDenoise(
-									AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-
-  	_in=in;		
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  			 	
-    uint32_t page;
-    
-  _info.encoding=1;
-  
-  page= _in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height;
-  
-//  _uncompressed=new uint8_t [page];
-  _uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-  ADM_assert(_uncompressed);
-  
- // _locked=new uint8_t [page];
-  _locked=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-  ADM_assert(_locked);
- 
-//	_lockcount=new uint8_t [page];
-
-
-  
-   _lockcount=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-  memset(YPLANE(_lockcount),0,page);  
-  memset(UPLANE(_lockcount),0,page&gt;&gt;2);  
-  memset(VPLANE(_lockcount),0,page&gt;&gt;2);  
-        
-  _param=NULL;
-  
-  if(couples)
-  	{
-			_param=NEW(NOISE_PARAM);
-			GET(lumaLock);
-			GET(lumaThreshold);
-			GET(chromaLock);
-			GET(chromaThreshold);
-			GET(sceneChange);
-		 }
-	else
-		{
-			  #define XXX 1
-			  _param=NEW(NOISE_PARAM);
-			  _param-&gt;lumaLock=  4*XXX;
-			  _param-&gt;lumaThreshold= 10*XXX;
-			  _param-&gt;chromaLock=  8*XXX;
-			  _param-&gt;chromaThreshold= 16*XXX;
-        _param-&gt;sceneChange=  30*XXX;
-			}
-  	  _lastFrame=0xfffffff0;	
-}
-
-
-uint8_t	ADMVideoDenoise::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(5);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-	CSET(lumaLock);
-	CSET(lumaThreshold);
-	CSET(chromaLock);
-	CSET(chromaThreshold);
-	CSET(sceneChange);
-
-	return 1;
-
-}
-ADMVideoDenoise::~ADMVideoDenoise()
-{
- 	
-	delete  _uncompressed;
- 	delete  _locked;
-  	delete  _lockcount;
-  DELETE(_param);
-  
-  _uncompressed=_locked=_lockcount=NULL;
-}
-
-//
-//	Remove y and v just keep U and expand it
-//
-uint8_t ADMVideoDenoise::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-   //uint32_t x,w;
-  	uint32_t page; 
-   		ADM_assert(_param);
-		if(frame&gt;= _info.nb_frames) return 0;
-								
-			
-       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-		
-		page=_info.width*_info.height;  
-		*len=(page*3)&gt;&gt;1;           
-
-	if((_lastFrame+1)!=frame) // async jump
-	{
-			// just copy it 
-			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(data),UPLANE(_uncompressed),page&gt;&gt;2);
-			memcpy(VPLANE(data),VPLANE(_uncompressed),page&gt;&gt;2);
-			
-			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page&gt;&gt;2);
-			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page&gt;&gt;2);
-			
-			_lastFrame=frame;
-			return 1;
-	}          
-	_lastFrame=frame;
-          
-          // copy chroma for now
-        
-         
-          
-          //
-          //uint32_t count=0;
-          //uint32_t cell=page*4; // size of luma
-          uint8_t *in,*out,*lock,*nb;
-          uint8_t *uin,*uout,*ulock,*unb;
-          uint8_t *vin,*vout,*vlock,*vnb;
-          
-          
-          //uint32_t d;
-          // init all
-          
-          // luma
-          nb=YPLANE(_lockcount);
-          lock=YPLANE(_locked);
-          in=YPLANE(_uncompressed);
-          out=YPLANE(data);
-          // u
-          unb=UPLANE(_lockcount);
-          ulock=UPLANE(_locked);
-          uin=UPLANE(_uncompressed);
-          uout=UPLANE(data);
-          // v
-          vnb=VPLANE(_lockcount);
-          vlock=VPLANE(_locked);
-          vin=VPLANE(_uncompressed);
-          vout=VPLANE(data);
-          
-          
-          uint32_t xx,yy/*,dl*/,du,dv;
-          uint32_t locked=0;
-          for(yy=_info.height&gt;&gt;1;yy&gt;0;yy--)
-          {
-	          for(xx=_info.width&gt;&gt;1;xx&gt;0;xx--)          
-  	        {
-			du=distMatrix[*uin][*ulock];	
-			dv=distMatrix[*vin][*vlock];		
-						
-			// if chroma is locked , we try to lock luma
-			if( (du&lt;_param-&gt;chromaLock)
-				 &amp;&amp; (dv&lt;_param-&gt;chromaLock))
-			 {  
-				*uout=*ulock;
- 				*vout=*vlock;
-
-#define PIX(z) 		doOnePix(in+z,out+z,lock+z,nb+z) 
-				locked+=PIX(0)+	PIX(1)+ PIX(_info.width)+PIX(_info.width+1);
-			}
-			else
-			 // if chroma is blended, we blend luma
-#undef PIX								  
-#define PIX(z) 		doBlend(in+z,out+z,lock+z,nb+z)									 
-				if( (du&lt;_param-&gt;chromaThreshold)
-					 &amp;&amp; (dv&lt;_param-&gt;chromaThreshold))
-				{
-			 		PIX(0);
-				    	PIX(1);
-				     	PIX(_info.width);
-				     	PIX(_info.width+1);	
-				      *uout=*ulock=(*uin+*uin)&gt;&gt;1;
- 					*vout=*vlock=(*vin+*vin)&gt;&gt;1;
-				}
-#undef PIX											
-										
-			else
-			{
-#define PIX(z) *(out+z)=*(lock+z)=*(in+z);*(nb+z)=0			
-											
-				PIX(0);
-				PIX(1);
-				PIX(_info.width);
-				PIX(_info.width+1);		
-				*uout=*ulock=*uin;
- 				*vout=*vlock=*vin;
-				
-#undef PIX		
-			}
-								  
-											                        				                        
-			uin++;uout++;ulock++;unb++;   
-			vin++;vout++;vlock++;vnb++;   
-			in++;out++;lock++;nb++;   
-			in++;out++;lock++;nb++;   
-							
-		}
-            // 
-            in+=_info.width;
-            out+=_info.width;
-            lock+=_info.width;
-            nb+=_info.width;            						
-	};
-          
-          if(locked&gt;((page*3)&gt;&gt;2)) // if more than 75% pixel not locked -&gt; scene change
-          {
-			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(data),UPLANE(_uncompressed),page&gt;&gt;2);
-			memcpy(VPLANE(data),VPLANE(_uncompressed),page&gt;&gt;2);
-			
-			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page&gt;&gt;2);
-			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page&gt;&gt;2);
-	}
-      data-&gt;copyInfo(_uncompressed);  
-      return 1;
-}
-
-//
-//	0 copy
-//  1 lock
-//  2 threshold
-//
-uint8_t ADMVideoDenoise::doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
-{
-unsigned int d;
-		d=distMatrix[*(in)][*(lock)]; 
-		if(d&lt;_param-&gt;lumaLock)         
-		{								                
-			if(*(nb)&gt;30)  // out of scope -&gt; copy new                   
-			{  	// too much copy -&gt;                              
-				*(nb)=0;                       
-				*(out)=(*(in)+*(lock))&gt;&gt;1;
-				*(lock)=*(out);    	
-				return DN_COPY;      
-			}                                 
-			else                               
-			{                                   
-				*(out)=*(lock);		
-				*nb += 1; // *(nb)++;	
-				return DN_LOCK;		
-			}                  
-		}                     
-		else if(d&lt; _param-&gt;lumaThreshold) 
-			{                                  
-				 *(nb)=0;                           
-				*(out)=(*(in)+*(lock))&gt;&gt;1;	
-				return DN_BLEND;
-			}
-			else   // too big delta
-			{    
-				 *(nb)=0; 
-				*(out)=*(in);	  
-				*(lock)=*(in);    
-				return DN_COPY;
-			}                     
-					                           
-			ADM_assert(0);
-			return 0;
-
-}
-uint8_t ADMVideoDenoise::doBlend(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
-{
-unsigned int d;
-		   d=distMatrix[*(in)][*(lock)]; 
-		   *nb=0;
-		   
-			if(d&lt;_param-&gt;lumaThreshold)         
-			{
-					*(out)=(*(in)+*(lock))&gt;&gt;1;					
-			}
-			else
-			*out=*in;
-			return 0;
-	
-}
-
-
-uint8_t ADMVideoDenoise::configure(AVDMGenericVideoStream * instream)
-{
-  UNUSED_ARG(instream);
-  
-#define PX(x) &amp;(_param-&gt;x)
-  
-    diaElemUInteger   lumaLock(PX(lumaLock),QT_TR_NOOP(&quot;_Luma lock:&quot;),0,255);
-    diaElemUInteger   chromaLock(PX(chromaLock),QT_TR_NOOP(&quot;C_hroma lock:&quot;),0,255);
-    diaElemUInteger   lumaThreshold(PX(lumaThreshold),QT_TR_NOOP(&quot;L_uma threshold:&quot;),0,255);
-    diaElemUInteger   chromaThreshold(PX(chromaThreshold),QT_TR_NOOP(&quot;Ch_roma threshold:&quot;),0,255);
-    
-    diaElemUInteger   sceneChange(PX(sceneChange),QT_TR_NOOP(&quot;_Scene change:&quot;),0,100);
-    
-    
-    
-       diaElem *elems[5]={&amp;lumaLock,&amp;chromaLock,&amp;lumaThreshold,&amp;chromaThreshold,&amp;sceneChange};
-  
-   return diaFactoryRun(QT_TR_NOOP(&quot;Denoise&quot;),5,elems);
-}
-
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,55 +0,0 @@
-/***************************************************************************
-                          ADM_vidDenoise.h  -  description
-                             -------------------
-    begin                : Mon Nov 25 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
- #define DN_COPY 3
- #define DN_LOCK 0
- #define DN_BLEND 1
-  
- typedef struct
- {
-	  uint32_t lumaThreshold,lumaLock;
-	  uint32_t chromaThreshold,chromaLock;
-	  uint32_t sceneChange;
-	}NOISE_PARAM;
- 
-  class  ADMVideoDenoise:public AVDMGenericVideoStream
- {
-
- protected:
-
-      					ADMImage	*_locked;
-        				ADMImage	*_lockcount;
-   			virtual 	char 		*printConf(void);
-        				NOISE_PARAM	*_param;
-        				uint32_t	_lastFrame;
-        				uint8_t 	doOnePix(uint8_t *in,uint8_t *out,
-        							uint8_t *lock,uint8_t *nb);
-         				uint8_t 	doBlend(uint8_t *in,uint8_t *out,
-        							uint8_t *lock,uint8_t *nb);
-
- public:
-
-
-							ADMVideoDenoise(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  			virtual 			~ADMVideoDenoise();
-		        virtual uint8_t 		getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          								ADMImage *data,uint32_t *flags);
-			virtual uint8_t 		configure( AVDMGenericVideoStream *instream) ;
-
-			virtual uint8_t			getCoupledConf( CONFcouple **couples);
- }     ;
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,212 +0,0 @@
-/***************************************************************************
-                          ADM_vidDropOut.cpp  -  description
-                             -------------------
-    begin                : Mon Oct 7 2002
-    copyright            : (C) 2002 by Ron Reithoffer 
-    email                : &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">ron.reithoffer at chello.at</A>&gt;
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_vidDropOut.h&quot;
-#include &quot;DIA_factory.h&quot;
-
-static FILTER_PARAM dropParam={1,{&quot;threshold&quot;}};
-
-
-SCRIPT_CREATE(dropout_script,ADMVideoDropOut,dropParam);
-
-
-//extern uint8_t distMatrix[256][256];
-extern uint32_t fixMul[16];
-
-BUILD_CREATE(dropout_create,ADMVideoDropOut);
-//_______________________________________________________________
- 
-
-char  *ADMVideoDropOut::printConf(void)
-{
-	static char buf[50];
-
- 	sprintf((char *)buf,&quot; DropOut :%ld&quot;,*_param);
-        return buf;
-}
-uint8_t  GUI_getIntegerValue(int *valye, int min, int max, char *title);	
-uint8_t ADMVideoDropOut::configure(AVDMGenericVideoStream *instream)
-{
-	_in=instream;
-        
-         diaElemUInteger chroma(_param,QT_TR_NOOP(&quot;DropOut Threshold&quot;),1,255);    
-         diaElem *elems[]={&amp;chroma};
-  
-    return diaFactoryRun(QT_TR_NOOP(&quot;Drop Out&quot;),sizeof(elems)/sizeof(diaElem *),elems);
-}
-ADMVideoDropOut::~ADMVideoDropOut()
-{
-	DELETE(_param);
-	delete vidCache;
-	vidCache=NULL;
-}
-
-//--------------------------------------------------------	
-ADMVideoDropOut::ADMVideoDropOut(AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-  
-	_in=in;
-  	_info.encoding=1;
-	if(couples)
-	{
-  		_param=NEW( uint32_t);
-		couples-&gt;getCouple((char *)&quot;threshold&quot;,(uint32_t *)_param);
-	}
-	else
-	{
-		_param=NEW( uint32_t);
-		*_param=30;
-	}
-	vidCache=new VideoCache(4,_in);
-	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-	
- 
-}
-
-uint8_t	ADMVideoDropOut::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(1);
-			(*couples)-&gt;setCouple((char *)&quot;threshold&quot;,(*_param));
-			return 1;
-
-}
-
-//                     1
-//		Get in range in 121 + coeff matrix
-//                     1
-//
-// If the value is too far away we ignore it
-// else we blend
-
-uint8_t ADMVideoDropOut::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-UNUSED_ARG(flags);
-
-uint32_t uvlen;
-uint32_t dlen,dflags;
-
-ADMImage	*_next;
-ADMImage	*_previous;
-ADMImage	*_current;
-
-	//		printf(&quot;\n DropOut : %lu\n&quot;,frame);
-
-
-
-
-			uvlen=    _info.width*_info.height;
-			*len=uvlen+(uvlen&gt;&gt;1);
-			  if(frame&gt; _info.nb_frames-1) return 0;
-			if(!frame || (frame==_info.nb_frames-1))
-			{
-				_current=vidCache-&gt;getImage(frame);
-				if(!_current) return 0;
-				memcpy(YPLANE(data),YPLANE(_current),uvlen);
-				memcpy(UPLANE(data),UPLANE(_current),uvlen&gt;&gt;2);
-				memcpy(VPLANE(data),VPLANE(_current),uvlen&gt;&gt;2);
-				vidCache-&gt;unlockAll();
-				return 1;
-			}
-			
-		_current=vidCache-&gt;getImage(frame);
-		_previous=vidCache-&gt;getImage(frame-1);
-		_next=vidCache-&gt;getImage(frame+1);
-		if(!_current || !_previous || !_next)
-		{
-			vidCache-&gt;unlockAll();
-			 return 0;	
-		}
-           	// for u &amp; v , no action -&gt; copy it as is
-           	memcpy(UPLANE(data),UPLANE(_current),uvlen&gt;&gt;2);
-		memcpy(VPLANE(data),VPLANE(_current),uvlen&gt;&gt;2);
-
-             uint8_t *inprev,*innext,*incur,*zout;
-
-              inprev=YPLANE(_previous)+1+_info.width;
-              innext=YPLANE(_next)+1+_info.width;
-              incur =YPLANE(_current)+1+_info.width;
-
-              zout=YPLANE(data)+_info.width+1;
-
-              int32_t c0,c1,c2,c3; //,_nextPix,_currPix,_prevPix,cc;
-
-              for(uint32_t y= _info.height-2;y&gt;2;y--)
-              	{
-		  c0=0;
-		  c1=0;
-		  c2=0;
-		  c3=0;
-
-	  	inprev=YPLANE(_previous)	+1+y*_info.width;
-              	innext=YPLANE(_next)		+1+y*_info.width;;
-              	incur =YPLANE(_current)	+1+y*_info.width;;
-
-			// look if the field is more different temporarily than spacially
-
-			    for(uint32_t x= _info.width-1;x&gt;1;x--)
-        		      	{
-
-						c0+=(abs(((*inprev))-( *incur    ))^2);
-						c1+=(abs(((*inprev))-( *innext   ))^2)&lt;&lt;1;
-						c0+=(abs(((*incur ))-( *innext   ))^2);
-
-
-						c2+=(abs(((    *(incur-_info.width*2) ))-( *(incur            )   ))^2)   ;
-						c3+=(abs(((    *(incur-_info.width*2) ))-( *(incur+_info.width*2)   ))^2)&lt;&lt;1;
-						c2+=(abs(((    *(incur            ) ))-( *(incur+_info.width*2)   ))^2)   ;
-
-
-						incur++;
-						innext++;
-						inprev++;
-				}
-
-		// If yes, replace the line by an average of next/previous image
-		inprev=YPLANE(_previous)	+y*_info.width;
-              	innext=YPLANE(_next)		+y*_info.width;;
-              	incur =YPLANE(_current)		+y*_info.width;;
-		zout=YPLANE(data)		+y*_info.width;
-
-		if (c1&lt;c0 &amp;&amp;c3&lt;c2)
-		{
-		    for(uint32_t x= _info.width;x&gt;0;x--)
-       			      	{
-					*zout= ((*(inprev))+(*(innext)))&gt;&gt;1 ;
-					zout++;
-					innext++;
-					inprev++;
-				}
-		}
-		else
-			memcpy(zout,incur,_info.width);
-	}
-	data-&gt;copyInfo(_current);
-	vidCache-&gt;unlockAll();
-return 1;
-}
-
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,40 +0,0 @@
-/***************************************************************************
-                          ADM_vidDropOut.h  -  description
-                             -------------------
-    begin                : Mon Oct 7 2002
-    copyright            : (C) 2002 by mean
-    email                : RON
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef __DROPOUT__
-#define __DROPOUT__   
- 
-class  ADMVideoDropOut:public AVDMGenericVideoStream
- {
-
- protected:
-
-        virtual char 				*printConf(void) ;
-						VideoCache	*vidCache;
-	 uint32_t				*_param;
- public:
- 					
-  						ADMVideoDropOut(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  						~ADMVideoDropOut();
-		      virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
-			virtual uint8_t getCoupledConf( CONFcouple **couples);
-
- }     ;
- 
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,170 +0,0 @@
-/***************************************************************************
-                       Pulldown : Duplicate frame fields to convert
-		       	24 fps to 30 fps movie
-
-			1 2 3 4       1  2  3  4  4
-			1 2 3 4 --&gt; 1  2  2  3  4
-
-
-    begin                : Thu Mar 21 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_video/ADM_vidFieldUtil.h&quot;
-#include &quot;ADM_vidPulldown.h&quot;
-#include &quot;ADM_video/ADM_interlaced.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-
-static FILTER_PARAM swapParam={0,{&quot;&quot;}};
-SCRIPT_CREATE(pulldown_script,ADMVideoPullDown,swapParam);
-BUILD_CREATE(pulldown_create,ADMVideoPullDown);
-
-char *ADMVideoPullDown::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf,&quot; Pulldown&quot;);
-        return buf;
-}
-//_______________________________________________________________
-ADMVideoPullDown::ADMVideoPullDown(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-	_info.fps1000=(_info.fps1000*5)/4;
-	_info.nb_frames=(_info.nb_frames*5)/4;
-	for(uint32_t i=0;i&lt;5;i++)
-	{
-		_uncompressed[i]=new ADMImage(_info.width,_info.height);
-	}
-	_cacheStart=0xfffffff;
-}
-// ___ destructor_____________
-ADMVideoPullDown::~ADMVideoPullDown()
-{
-	for(uint32_t i=0;i&lt;5;i++)
-	{
- 		delete  _uncompressed[i];
-	}
-}
-
-
-uint8_t ADMVideoPullDown::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//static Image in,out;
-			if(frame&gt;=_info.nb_frames)
-			{
-				printf(&quot;out of bound frame (%lu / %lu)\n&quot;,frame,_info.nb_frames);
-				return 0;
-			}
-
-		uint32_t w=_info.width;
-		uint32_t h=_info.height;
-		uint32_t page=w*h;
-		uint32_t i;
-
-		uint32_t target;
-		uint32_t loop=0;
-
-		*len=(page*3)&gt;&gt;1;
-
-cont:
-
-		target=frame-((frame)%5);
-		// got it ?
-		if(_cacheStart==target)
-		{
-			uint32_t index;
-
-			aprintf(&quot;Filter: It is in cache...(cachestart=%lu)\n&quot;,_cacheStart);
-			index=frame%5;
-			aprintf(&quot;getting %lu)\n&quot;,index);
-			memcpy(YPLANE(data),YPLANE(_uncompressed[index]),page);
-			memcpy(UPLANE(data),UPLANE(_uncompressed[index]),page&gt;&gt;2);
-			memcpy(VPLANE(data),VPLANE(_uncompressed[index]),page&gt;&gt;2);
-			*flags=0;			
-			return 1;
-		}
-		else
-		{
-			aprintf(&quot;Not in cache...\n&quot;);
-		}
-		// Else ask the 5 corresponding frame
-		_cacheStart=target;
-		target=(target*4)/5;
-
-		uint32_t dflags,dlen;
-#define GET_FRAME(x,y) if(!_in-&gt;getFrameNumberNoAlloc(x, &amp;dlen,_uncompressed[y],&amp;dflags)) \
- {\
-				 	 	printf(&quot;Cannot get frame %lu\n&quot;,x);\
-					 	return 0;     \
-				 }
-
-		GET_FRAME(target+0,0);
-		GET_FRAME(target+1,1);
-		GET_FRAME(target+2,3);
-		GET_FRAME(target+3,4);
-		// copy chroma 1-&gt;2
-		memcpy(UPLANE(_uncompressed[2]),UPLANE(_uncompressed[1]),page&gt;&gt;2);
-		memcpy(VPLANE(_uncompressed[2]),VPLANE(_uncompressed[1]),page&gt;&gt;2);
-#define COPY_FIELD \
-		for(uint32_t y=0;y&lt;_info.height&gt;&gt;1;y++) \
-		{ \
-			memcpy(out,in,_info.width); \
-			in+=_info.width&lt;&lt;1; \
-			out+=_info.width&lt;&lt;1; \
-		}
-
-		// now we merge 1 &amp; 3 into 2
-
-		uint8_t *in,*out;
-		in=YPLANE(_uncompressed[1]);
-		out=YPLANE(_uncompressed[2]);
-		COPY_FIELD;
-
-
-		// merge 3-&gt;2
-		//
-		//	0 1 x 2 3
-		//      0 1 x 2 3
-		//
-		//  0 1 1 2 3
-		//  0 1 X 2 3
-		in=YPLANE(_uncompressed[3])+w;
-		out=YPLANE(_uncompressed[2])+w;
-		COPY_FIELD;
-		//  0 1 1 2 3
-		//  0 1 2 2 3
-		in=YPLANE(_uncompressed[4])+w;
-		out=YPLANE(_uncompressed[3])+w;
-		//  0 1 1 2 3
-		//  0 1 2 3 3
-		COPY_FIELD;
-		goto cont;
-		return 1;
-}
-
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,24 +0,0 @@
-#ifndef VID_PDW_
-#define VID_PDW_
-
- class  ADMVideoPullDown:public AVDMGenericVideoStream
- {
-
- protected:
-
-				ADMImage	*_uncompressed[5];
-     		virtual 	char 		*printConf(void);
-				uint32_t	_cacheStart;
-
- public:
-
-
-  				ADMVideoPullDown(  AVDMGenericVideoStream *in,CONFcouple *setup);
-
-  	virtual 		~ADMVideoPullDown();
-	virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          								ADMImage *data,uint32_t *flags);
-	virtual uint8_t configure( AVDMGenericVideoStream *instream) {return 1;};
-
- }     ;
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSeparateField.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSeparateField.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSeparateField.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -24,7 +24,7 @@
 
 
 #include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_video/ADM_vidFieldUtil.h&quot;
+#include &quot;ADM_vidFieldUtil.h&quot;
 #include &quot;ADM_vidSeparateField.h&quot;
 
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSoften.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSoften.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSoften.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -30,8 +30,29 @@
 #include &quot;DIA_factory.h&quot;
 
 static FILTER_PARAM softParam={3,{&quot;radius&quot;,&quot;luma&quot;,&quot;chroma&quot;}};
+static uint8_t distMatrix[256][256];
+static uint32_t fixMul[16];
+static bool distMatrixDone=false;
 
+static void buildDistMatrix( void )
+{
+int d;  
+    for(uint32_t y=255;y&gt;0;y--)
+    for(uint32_t x=255;x&gt;0;x--)
+    {
+          d=x-y;
+          if(d&lt;0) d=-d;
+          distMatrix[x][y]=d;
+        
+    }
 
+     for(int i=1;i&lt;16;i++)
+                        {
+                                        fixMul[i]=(1&lt;&lt;16)/i;
+                        }
+
+}
+
 SCRIPT_CREATE(soften_script,ADMVideoMaskedSoften,softParam);
 BUILD_CREATE(soften_create,ADMVideoMaskedSoften);
 
@@ -84,7 +105,11 @@
 
  ADMVideoMaskedSoften::ADMVideoMaskedSoften( AVDMGenericVideoStream *in,CONFcouple *couples)
 {
-		
+		if(distMatrixDone==false)
+        {
+            buildDistMatrix();
+            distMatrixDone=true;
+        }
 		_uncompressed=NULL;
 		_in=in;
 		ADM_assert(in);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidStabilize.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidStabilize.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidStabilize.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -29,13 +29,31 @@
 
 
 SCRIPT_CREATE(stabilize_script,ADMVideoStabilize,stabParam);
-extern uint8_t distMatrix[256][256];
-extern uint32_t fixMul[16];
-
 BUILD_CREATE(stabilize_create,ADMVideoStabilize);
 
+static uint8_t distMatrix[256][256];
+static uint32_t fixMul[16];
+static bool distMatrixDone=false;
 
+static void buildDistMatrix( void )
+{
+int d;  
+    for(uint32_t y=255;y&gt;0;y--)
+    for(uint32_t x=255;x&gt;0;x--)
+    {
+          d=x-y;
+          if(d&lt;0) d=-d;
+          distMatrix[x][y]=d;
+        
+    }
 
+     for(int i=1;i&lt;16;i++)
+                        {
+                                        fixMul[i]=(1&lt;&lt;16)/i;
+                        }
+
+}
+
 char 	*ADMVideoStabilize::printConf(void)
 {
   static char buf[50];
@@ -58,6 +76,11 @@
 //--------------------------------------------------------	
 ADMVideoStabilize::ADMVideoStabilize(AVDMGenericVideoStream *in,CONFcouple *couples)
 {
+if(distMatrixDone==false)
+        {
+            buildDistMatrix();
+            distMatrixDone=true;
+        }
   //uint32_t frame;
   _uncompressed=NULL;
   _in=in;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSwapFields.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSwapFields.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSwapFields.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -22,7 +22,7 @@
 
 
 #include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_video/ADM_vidFieldUtil.h&quot;
+#include &quot;ADM_vidFieldUtil.h&quot;
 #include &quot;ADM_vidSwapFields.h&quot;
 
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSwapSmart.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSwapSmart.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidSwapSmart.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -23,7 +23,7 @@
 
 #include &quot;ADM_videoFilter.h&quot;
 #include &quot;ADM_vidSwapSmart.h&quot;
-#include &quot;ADM_video/ADM_interlaced.h&quot;
+#include &quot;ADM_interlaced.h&quot;
 
 #include &quot;ADM_osSupport/ADM_debugID.h&quot;
 #define MODULE_NAME MODULE_FILTER

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt	2008-05-04 17:05:41 UTC (rev 4019)
@@ -1,13 +1,12 @@
 SET(ADM_videoFilter_SRCS 
 	ADM_lavpp_deint.cpp      ADM_vidFields.cpp           
-	ADM_vidPulldown.cpp       ADM_vidSwapSmart.cpp
+	ADM_vidSwapSmart.cpp
 	ADM_vidDeintASM.cpp         ADM_vidMosaic.cpp
 	ADM_vidASS.cpp           ADM_vidDeinterlace.cpp      ADM_vidFlux.cpp             
-	ADM_vidDenoise.cpp          
 	ADM_vidRotate.cpp         ADM_vidWhirl.cpp
 	ADM_vidMSharpen.cpp
 	ADM_vidSeparateField.cpp  
-	ADM_vidBSmear.cpp        ADM_vidDropOut.cpp          ADM_vidKernelDeint.cpp      ADM_vidMsmooth.cpp
+	ADM_vidBSmear.cpp        ADM_vidKernelDeint.cpp      ADM_vidMsmooth.cpp
 	ADM_vidSoften.cpp
 	ADM_vidPalShift.cpp
 	ADM_vidStabilize.cpp
@@ -27,7 +26,6 @@
 	ADM_vidCrop.cpp
 	ADM_vidEq2.cpp
 	ADM_vidContrast.cpp
-	ADM_vidDelta.cpp
 	ADM_vidAsharp.cpp
 	ADM_vidVobsub.cpp
 	ADM_vidVobSubRender.cpp
@@ -44,4 +42,4 @@
 	ADD_SOURCE_CFLAGS(ADM_vidSRT.cpp &quot;${FREETYPE2_CFLAGS}&quot;)
 	ADD_SOURCE_CFLAGS(ADM_vidSRTload.cpp &quot;${FREETYPE2_CFLAGS}&quot; &quot;-I${LIBICONV_INCLUDE_DIR}&quot;)
 	ADD_SOURCE_CFLAGS(ADM_vidSRTRender.cpp &quot;${FREETYPE2_CFLAGS}&quot;)
-ENDIF (USE_FREETYPE)
\ No newline at end of file
+ENDIF (USE_FREETYPE)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -61,7 +61,6 @@
 extern void filterCleanUp( void );
 extern void register_Encoders( void )  ;
 
-extern void  buildDistMatrix( void );
 extern void initScaleTab( void );
 extern uint8_t initGUI( void );
 extern void destroyGUI(void);
@@ -275,7 +274,6 @@
     AVDM_audioInit();
 #endif
 
-    buildDistMatrix();
     initScaleTab();
 
     if(SpidermonkeyInit() == true)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidHardIvtcRemoval.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidHardIvtcRemoval.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidHardIvtcRemoval.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -62,13 +62,12 @@
     { 4,&quot;threshold&quot;,&quot;show&quot;,&quot;noise&quot;,&quot;identical&quot;};
 
 VF_DEFINE_FILTER ( vidHardPDRemoval,field_unblend_template,
-                   unblend,
-                   QT_TR_NOOP ( &quot;Unblend&quot; ),
+                   hardivtcremove,
+                   QT_TR_NOOP ( &quot;&quot;Hard pulldown removal&quot;&quot; ),
                    1,
-                   VF_COLORS,
-                   QT_TR_NOOP ( &quot;Try to unblend fields.&quot; ) );
+                   VF_ITERLACING,
+                   QT_TR_NOOP ( &quot;Remove IVTC that has been analog captured or resized.&quot;) );
 
-
 //*************************************
 uint8_t vidHardPDRemoval::configure (AVDMGenericVideoStream * in)
 {

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt	2008-05-04 17:05:41 UTC (rev 4019)
@@ -17,4 +17,8 @@
 ADD_SUBDIRECTORY(TemporalCleaner)
 #ADD_SUBDIRECTORY(Unblend)
 ADD_SUBDIRECTORY(VerticalFlip)
-ADD_SUBDIRECTORY(Yadif)
\ No newline at end of file
+ADD_SUBDIRECTORY(Yadif)
+ADD_SUBDIRECTORY(Pulldown)
+ADD_SUBDIRECTORY(Denoise)
+ADD_SUBDIRECTORY(Delta)
+ADD_SUBDIRECTORY(DropOut)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Delta/ADM_vidDelta.cpp (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDelta.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDelta.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Delta/ADM_vidDelta.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,138 @@
+//
+//      Try to detect blended image
+//      Mean (C) 2005
+//      GPL v2.0
+//
+
+
+#include &quot;ADM_default.h&quot;
+
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#define aprintf(...) {}
+
+
+class vidDelta:public AVDMGenericVideoStream
+{
+
+protected:
+  virtual char *printConf (void);
+  VideoCache *vidCache;
+
+
+public:
+
+                        vidDelta (AVDMGenericVideoStream * in, CONFcouple * setup);
+        virtual         ~vidDelta ();
+  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
+					 ADMImage * data, uint32_t * flags);
+  uint8_t configure (AVDMGenericVideoStream * instream);
+  virtual uint8_t getCoupledConf (CONFcouple ** couples);
+
+};
+
+static FILTER_PARAM delta_template =
+  { 0 };
+
+//********** Register chunk ************
+
+VF_DEFINE_FILTER(vidDelta,delta_template,
+                delta,
+                QT_TR_NOOP(&quot;Luma delta&quot;),
+                1,
+                VF_COLORS,
+                QT_TR_NOOP(&quot;Difference between current and previous picture.&quot;));
+//********** Register chunk ************
+
+/*************************************/
+uint8_t vidDelta::configure (AVDMGenericVideoStream * in)
+{
+        return 1;
+}
+/*************************************/
+char *vidDelta::printConf (void)
+{
+  static char buf[50];
+  sprintf ((char *) buf, &quot; Delta&quot;);
+  return buf;
+}
+/*************************************/
+vidDelta::vidDelta (AVDMGenericVideoStream * in, CONFcouple * couples)
+{
+
+  _in = in;
+  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
+  _info.encoding = 1;
+  vidCache = new VideoCache (4, in);
+  
+  
+}
+//____________________________________________________________________
+vidDelta::~vidDelta ()
+{
+
+  delete vidCache;
+  vidCache = NULL;
+
+}
+
+//______________________________________________________________
+uint8_t vidDelta::getFrameNumberNoAlloc (uint32_t frame,
+				uint32_t * len,
+				ADMImage * data, uint32_t * flags)
+{
+int w,h,page;
+ADMImage *cur,*prev,*next;
+        w=_info.width;
+        h=_info.height;
+        page=w*h;
+  if(frame&gt;= _info.nb_frames) return 0;
+  if(!frame || frame&gt;=_info.nb_frames-1)
+  {
+        memset(YPLANE(data),0,page);
+        memset(UPLANE(data),128,page&gt;&gt;2);
+        memset(VPLANE(data),128,page&gt;&gt;2);
+        return 1;
+  }
+  cur=vidCache-&gt;getImage (frame);
+  prev=vidCache-&gt;getImage (frame-1);
+  next=vidCache-&gt;getImage (frame+1);
+  // No chroma
+        memset(UPLANE(data),128,page&gt;&gt;2);
+        memset(VPLANE(data),128,page&gt;&gt;2);
+
+   uint8_t *c=YPLANE(cur);
+   uint8_t *p=YPLANE(prev);
+   uint8_t *n=YPLANE(next);
+   uint8_t *out=YPLANE(data);
+#define SAME_THRESH 32
+   int a,b,d,cp,cn,e;
+   for(int y=0;y&lt;h;y++)
+        for(int x=0;x&lt;w;x++)
+        {
+                a=*c++;
+                b=*p++;
+                e=*n++;
+                cp=abs(a-b);
+                cn=abs(a-e);
+                // Cp is the != between current and previous
+                // cn is the != between current and next
+                // We try to spo frames that are blended betwwen next &amp; previous
+                
+                if(cp&gt;SAME_THRESH &amp;&amp; cn &gt; SAME_THRESH &amp;&amp; abs(cp-cn) &lt; 128) *out++=255;//(cp+cn)/2;
+                        else *out++=0;
+        }
+
+
+  vidCache-&gt;unlockAll ();
+  return 1;
+}
+
+/*************************************/
+uint8_t vidDelta::getCoupledConf (CONFcouple ** couples)
+{
+
+  *couples=NULL;
+  return 1;
+}
+
+// EOF

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Delta/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Delta/CMakeLists.txt	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Delta/CMakeLists.txt	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_Delta_SRCS ADM_vidDelta.cpp)
+
+ADD_LIBRARY(ADM_vf_Delta SHARED ${ADM_vf_Delta_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_Delta)
+INSTALL_VIDEOFILTER(ADM_vf_Delta)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Denoise/ADM_vidDenoise.cpp (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Denoise/ADM_vidDenoise.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,399 @@
+/***************************************************************************
+                          ADM_vidDenoise.cpp  -  description
+                             -------------------
+    begin                : Mon Nov 25 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+    
+    Denoiser inspired from DNR in transcode
+    Ported to YV12 and simplified
+    
+   Original code  Copyright (C) Gerhard Monzel - November 2001
+ 
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;ADM_vidDenoise.h&quot;
+
+
+#include &quot;DIA_factory.h&quot;
+
+static FILTER_PARAM denoiseParam={5,{&quot;lumaLock&quot;,&quot;lumaThreshold&quot;,&quot;chromaLock&quot;,&quot;chromaThreshold&quot;,
+					&quot;sceneChange&quot;}};
+
+//********** Register chunk ************
+
+VF_DEFINE_FILTER(ADMVideoDenoise,denoiseParam,
+                denoise,
+                QT_TR_NOOP(&quot;Denoise&quot;),
+                1,
+                VF_NOISE,
+                QT_TR_NOOP(&quot;Port of Transcode DNR.&quot;));
+//********** Register chunk ************
+
+
+//static uint8_t matrixReady=0;
+//static uint8_t doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb);
+
+
+char *ADMVideoDenoise::printConf( void )
+{
+ 	static char buf[50];
+
+  ADM_assert(_param); 	
+ 	sprintf((char *)buf,&quot; Denoise : Lum :%02ld/:%02ld / Chm :%02ld/%02ld&quot;,
+  								_param-&gt;lumaLock,
+          				_param-&gt;lumaThreshold,
+              		_param-&gt;chromaLock,
+                	_param-&gt;chromaThreshold);
+        return buf;
+}
+static uint8_t distMatrix[256][256];
+static uint32_t fixMul[16];
+static bool distMatrixDone=false;
+
+static void buildDistMatrix( void )
+{
+int d;	
+	for(uint32_t y=255;y&gt;0;y--)
+	for(uint32_t x=255;x&gt;0;x--)
+	{
+		  d=x-y;
+		  if(d&lt;0) d=-d;
+		  distMatrix[x][y]=d;
+		
+	}
+
+	 for(int i=1;i&lt;16;i++)
+                        {
+                                        fixMul[i]=(1&lt;&lt;16)/i;
+                        }
+
+}
+
+//_______________________________________________________________
+
+ADMVideoDenoise::ADMVideoDenoise(
+									AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+    if(distMatrixDone==false)
+    {
+        buildDistMatrix();
+        distMatrixDone=true;
+    }
+  	_in=in;		
+   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  			 	
+    uint32_t page;
+    
+  _info.encoding=1;
+  
+  page= _in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height;
+  
+//  _uncompressed=new uint8_t [page];
+  _uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+  ADM_assert(_uncompressed);
+  
+ // _locked=new uint8_t [page];
+  _locked=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+  ADM_assert(_locked);
+ 
+//	_lockcount=new uint8_t [page];
+
+
+  
+   _lockcount=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+  memset(YPLANE(_lockcount),0,page);  
+  memset(UPLANE(_lockcount),0,page&gt;&gt;2);  
+  memset(VPLANE(_lockcount),0,page&gt;&gt;2);  
+        
+  _param=NULL;
+  
+  if(couples)
+  	{
+			_param=NEW(NOISE_PARAM);
+			GET(lumaLock);
+			GET(lumaThreshold);
+			GET(chromaLock);
+			GET(chromaThreshold);
+			GET(sceneChange);
+		 }
+	else
+		{
+			  #define XXX 1
+			  _param=NEW(NOISE_PARAM);
+			  _param-&gt;lumaLock=  4*XXX;
+			  _param-&gt;lumaThreshold= 10*XXX;
+			  _param-&gt;chromaLock=  8*XXX;
+			  _param-&gt;chromaThreshold= 16*XXX;
+        _param-&gt;sceneChange=  30*XXX;
+			}
+  	  _lastFrame=0xfffffff0;	
+}
+
+
+uint8_t	ADMVideoDenoise::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(5);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+	CSET(lumaLock);
+	CSET(lumaThreshold);
+	CSET(chromaLock);
+	CSET(chromaThreshold);
+	CSET(sceneChange);
+
+	return 1;
+
+}
+ADMVideoDenoise::~ADMVideoDenoise()
+{
+ 	
+	delete  _uncompressed;
+ 	delete  _locked;
+  	delete  _lockcount;
+  DELETE(_param);
+  
+  _uncompressed=_locked=_lockcount=NULL;
+}
+
+//
+//	Remove y and v just keep U and expand it
+//
+uint8_t ADMVideoDenoise::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+   //uint32_t x,w;
+  	uint32_t page; 
+   		ADM_assert(_param);
+		if(frame&gt;= _info.nb_frames) return 0;
+								
+			
+       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+
+		
+		page=_info.width*_info.height;  
+		*len=(page*3)&gt;&gt;1;           
+
+	if((_lastFrame+1)!=frame) // async jump
+	{
+			// just copy it 
+			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(data),UPLANE(_uncompressed),page&gt;&gt;2);
+			memcpy(VPLANE(data),VPLANE(_uncompressed),page&gt;&gt;2);
+			
+			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page&gt;&gt;2);
+			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page&gt;&gt;2);
+			
+			_lastFrame=frame;
+			return 1;
+	}          
+	_lastFrame=frame;
+          
+          // copy chroma for now
+        
+         
+          
+          //
+          //uint32_t count=0;
+          //uint32_t cell=page*4; // size of luma
+          uint8_t *in,*out,*lock,*nb;
+          uint8_t *uin,*uout,*ulock,*unb;
+          uint8_t *vin,*vout,*vlock,*vnb;
+          
+          
+          //uint32_t d;
+          // init all
+          
+          // luma
+          nb=YPLANE(_lockcount);
+          lock=YPLANE(_locked);
+          in=YPLANE(_uncompressed);
+          out=YPLANE(data);
+          // u
+          unb=UPLANE(_lockcount);
+          ulock=UPLANE(_locked);
+          uin=UPLANE(_uncompressed);
+          uout=UPLANE(data);
+          // v
+          vnb=VPLANE(_lockcount);
+          vlock=VPLANE(_locked);
+          vin=VPLANE(_uncompressed);
+          vout=VPLANE(data);
+          
+          
+          uint32_t xx,yy/*,dl*/,du,dv;
+          uint32_t locked=0;
+          for(yy=_info.height&gt;&gt;1;yy&gt;0;yy--)
+          {
+	          for(xx=_info.width&gt;&gt;1;xx&gt;0;xx--)          
+  	        {
+			du=distMatrix[*uin][*ulock];	
+			dv=distMatrix[*vin][*vlock];		
+						
+			// if chroma is locked , we try to lock luma
+			if( (du&lt;_param-&gt;chromaLock)
+				 &amp;&amp; (dv&lt;_param-&gt;chromaLock))
+			 {  
+				*uout=*ulock;
+ 				*vout=*vlock;
+
+#define PIX(z) 		doOnePix(in+z,out+z,lock+z,nb+z) 
+				locked+=PIX(0)+	PIX(1)+ PIX(_info.width)+PIX(_info.width+1);
+			}
+			else
+			 // if chroma is blended, we blend luma
+#undef PIX								  
+#define PIX(z) 		doBlend(in+z,out+z,lock+z,nb+z)									 
+				if( (du&lt;_param-&gt;chromaThreshold)
+					 &amp;&amp; (dv&lt;_param-&gt;chromaThreshold))
+				{
+			 		PIX(0);
+				    	PIX(1);
+				     	PIX(_info.width);
+				     	PIX(_info.width+1);	
+				      *uout=*ulock=(*uin+*uin)&gt;&gt;1;
+ 					*vout=*vlock=(*vin+*vin)&gt;&gt;1;
+				}
+#undef PIX											
+										
+			else
+			{
+#define PIX(z) *(out+z)=*(lock+z)=*(in+z);*(nb+z)=0			
+											
+				PIX(0);
+				PIX(1);
+				PIX(_info.width);
+				PIX(_info.width+1);		
+				*uout=*ulock=*uin;
+ 				*vout=*vlock=*vin;
+				
+#undef PIX		
+			}
+								  
+											                        				                        
+			uin++;uout++;ulock++;unb++;   
+			vin++;vout++;vlock++;vnb++;   
+			in++;out++;lock++;nb++;   
+			in++;out++;lock++;nb++;   
+							
+		}
+            // 
+            in+=_info.width;
+            out+=_info.width;
+            lock+=_info.width;
+            nb+=_info.width;            						
+	};
+          
+          if(locked&gt;((page*3)&gt;&gt;2)) // if more than 75% pixel not locked -&gt; scene change
+          {
+			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(data),UPLANE(_uncompressed),page&gt;&gt;2);
+			memcpy(VPLANE(data),VPLANE(_uncompressed),page&gt;&gt;2);
+			
+			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page&gt;&gt;2);
+			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page&gt;&gt;2);
+	}
+      data-&gt;copyInfo(_uncompressed);  
+      return 1;
+}
+
+//
+//	0 copy
+//  1 lock
+//  2 threshold
+//
+uint8_t ADMVideoDenoise::doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
+{
+unsigned int d;
+		d=distMatrix[*(in)][*(lock)]; 
+		if(d&lt;_param-&gt;lumaLock)         
+		{								                
+			if(*(nb)&gt;30)  // out of scope -&gt; copy new                   
+			{  	// too much copy -&gt;                              
+				*(nb)=0;                       
+				*(out)=(*(in)+*(lock))&gt;&gt;1;
+				*(lock)=*(out);    	
+				return DN_COPY;      
+			}                                 
+			else                               
+			{                                   
+				*(out)=*(lock);		
+				*nb += 1; // *(nb)++;	
+				return DN_LOCK;		
+			}                  
+		}                     
+		else if(d&lt; _param-&gt;lumaThreshold) 
+			{                                  
+				 *(nb)=0;                           
+				*(out)=(*(in)+*(lock))&gt;&gt;1;	
+				return DN_BLEND;
+			}
+			else   // too big delta
+			{    
+				 *(nb)=0; 
+				*(out)=*(in);	  
+				*(lock)=*(in);    
+				return DN_COPY;
+			}                     
+					                           
+			ADM_assert(0);
+			return 0;
+
+}
+uint8_t ADMVideoDenoise::doBlend(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
+{
+unsigned int d;
+		   d=distMatrix[*(in)][*(lock)]; 
+		   *nb=0;
+		   
+			if(d&lt;_param-&gt;lumaThreshold)         
+			{
+					*(out)=(*(in)+*(lock))&gt;&gt;1;					
+			}
+			else
+			*out=*in;
+			return 0;
+	
+}
+
+
+uint8_t ADMVideoDenoise::configure(AVDMGenericVideoStream * instream)
+{
+  UNUSED_ARG(instream);
+  
+#define PX(x) &amp;(_param-&gt;x)
+  
+    diaElemUInteger   lumaLock(PX(lumaLock),QT_TR_NOOP(&quot;_Luma lock:&quot;),0,255);
+    diaElemUInteger   chromaLock(PX(chromaLock),QT_TR_NOOP(&quot;C_hroma lock:&quot;),0,255);
+    diaElemUInteger   lumaThreshold(PX(lumaThreshold),QT_TR_NOOP(&quot;L_uma threshold:&quot;),0,255);
+    diaElemUInteger   chromaThreshold(PX(chromaThreshold),QT_TR_NOOP(&quot;Ch_roma threshold:&quot;),0,255);
+    
+    diaElemUInteger   sceneChange(PX(sceneChange),QT_TR_NOOP(&quot;_Scene change:&quot;),0,100);
+    
+    
+    
+       diaElem *elems[5]={&amp;lumaLock,&amp;chromaLock,&amp;lumaThreshold,&amp;chromaThreshold,&amp;sceneChange};
+  
+   return diaFactoryRun(QT_TR_NOOP(&quot;Denoise&quot;),5,elems);
+}
+
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Denoise/ADM_vidDenoise.h (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDenoise.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Denoise/ADM_vidDenoise.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,55 @@
+/***************************************************************************
+                          ADM_vidDenoise.h  -  description
+                             -------------------
+    begin                : Mon Nov 25 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ #define DN_COPY 3
+ #define DN_LOCK 0
+ #define DN_BLEND 1
+  
+ typedef struct
+ {
+	  uint32_t lumaThreshold,lumaLock;
+	  uint32_t chromaThreshold,chromaLock;
+	  uint32_t sceneChange;
+	}NOISE_PARAM;
+ 
+  class  ADMVideoDenoise:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+      					ADMImage	*_locked;
+        				ADMImage	*_lockcount;
+   			virtual 	char 		*printConf(void);
+        				NOISE_PARAM	*_param;
+        				uint32_t	_lastFrame;
+        				uint8_t 	doOnePix(uint8_t *in,uint8_t *out,
+        							uint8_t *lock,uint8_t *nb);
+         				uint8_t 	doBlend(uint8_t *in,uint8_t *out,
+        							uint8_t *lock,uint8_t *nb);
+
+ public:
+
+
+							ADMVideoDenoise(  AVDMGenericVideoStream *in,CONFcouple *setup);
+  			virtual 			~ADMVideoDenoise();
+		        virtual uint8_t 		getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          								ADMImage *data,uint32_t *flags);
+			virtual uint8_t 		configure( AVDMGenericVideoStream *instream) ;
+
+			virtual uint8_t			getCoupledConf( CONFcouple **couples);
+ }     ;
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Denoise/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Denoise/CMakeLists.txt	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Denoise/CMakeLists.txt	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_Denoise_SRCS ADM_vidDenoise.cpp)
+
+ADD_LIBRARY(ADM_vf_Denoise SHARED ${ADM_vf_Denoise_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_Denoise)
+INSTALL_VIDEOFILTER(ADM_vf_Denoise)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DropOut/ADM_vidDropOut.cpp (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DropOut/ADM_vidDropOut.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,216 @@
+/***************************************************************************
+                          ADM_vidDropOut.cpp  -  description
+                             -------------------
+    begin                : Mon Oct 7 2002
+    copyright            : (C) 2002 by Ron Reithoffer 
+    email                : &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">ron.reithoffer at chello.at</A>&gt;
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;ADM_vidDropOut.h&quot;
+#include &quot;DIA_factory.h&quot;
+#define aprintf(...) {}
+static FILTER_PARAM dropParam={1,{&quot;threshold&quot;}};
+
+//********** Register chunk ************
+
+VF_DEFINE_FILTER(ADMVideoDropOut,dropParam,
+                drop,
+                QT_TR_NOOP(&quot;Drop&quot;),
+                1,
+                VF_INTERLACING,
+                QT_TR_NOOP(&quot;Drop damaged fields (e.g. from VHS capture).&quot;));
+//********** Register chunk ************
+
+//extern uint8_t distMatrix[256][256];
+//extern uint32_t fixMul[16];
+
+//_______________________________________________________________
+ 
+
+char  *ADMVideoDropOut::printConf(void)
+{
+	static char buf[50];
+
+ 	sprintf((char *)buf,&quot; DropOut :%ld&quot;,*_param);
+        return buf;
+}
+uint8_t  GUI_getIntegerValue(int *valye, int min, int max, char *title);	
+uint8_t ADMVideoDropOut::configure(AVDMGenericVideoStream *instream)
+{
+	_in=instream;
+        
+         diaElemUInteger chroma(_param,QT_TR_NOOP(&quot;DropOut Threshold&quot;),1,255);    
+         diaElem *elems[]={&amp;chroma};
+  
+    return diaFactoryRun(QT_TR_NOOP(&quot;Drop Out&quot;),sizeof(elems)/sizeof(diaElem *),elems);
+}
+ADMVideoDropOut::~ADMVideoDropOut()
+{
+	DELETE(_param);
+	delete vidCache;
+	vidCache=NULL;
+}
+
+//--------------------------------------------------------	
+ADMVideoDropOut::ADMVideoDropOut(AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+  
+	_in=in;
+  	_info.encoding=1;
+	if(couples)
+	{
+  		_param=NEW( uint32_t);
+		couples-&gt;getCouple((char *)&quot;threshold&quot;,(uint32_t *)_param);
+	}
+	else
+	{
+		_param=NEW( uint32_t);
+		*_param=30;
+	}
+	vidCache=new VideoCache(4,_in);
+	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
+	
+ 
+}
+
+uint8_t	ADMVideoDropOut::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(1);
+			(*couples)-&gt;setCouple((char *)&quot;threshold&quot;,(*_param));
+			return 1;
+
+}
+
+//                     1
+//		Get in range in 121 + coeff matrix
+//                     1
+//
+// If the value is too far away we ignore it
+// else we blend
+
+uint8_t ADMVideoDropOut::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+UNUSED_ARG(flags);
+
+uint32_t uvlen;
+uint32_t dlen,dflags;
+
+ADMImage	*_next;
+ADMImage	*_previous;
+ADMImage	*_current;
+
+	//		printf(&quot;\n DropOut : %lu\n&quot;,frame);
+
+
+
+
+			uvlen=    _info.width*_info.height;
+			*len=uvlen+(uvlen&gt;&gt;1);
+			  if(frame&gt; _info.nb_frames-1) return 0;
+			if(!frame || (frame==_info.nb_frames-1))
+			{
+				_current=vidCache-&gt;getImage(frame);
+				if(!_current) return 0;
+				memcpy(YPLANE(data),YPLANE(_current),uvlen);
+				memcpy(UPLANE(data),UPLANE(_current),uvlen&gt;&gt;2);
+				memcpy(VPLANE(data),VPLANE(_current),uvlen&gt;&gt;2);
+				vidCache-&gt;unlockAll();
+				return 1;
+			}
+			
+		_current=vidCache-&gt;getImage(frame);
+		_previous=vidCache-&gt;getImage(frame-1);
+		_next=vidCache-&gt;getImage(frame+1);
+		if(!_current || !_previous || !_next)
+		{
+			vidCache-&gt;unlockAll();
+			 return 0;	
+		}
+           	// for u &amp; v , no action -&gt; copy it as is
+           	memcpy(UPLANE(data),UPLANE(_current),uvlen&gt;&gt;2);
+		memcpy(VPLANE(data),VPLANE(_current),uvlen&gt;&gt;2);
+
+             uint8_t *inprev,*innext,*incur,*zout;
+
+              inprev=YPLANE(_previous)+1+_info.width;
+              innext=YPLANE(_next)+1+_info.width;
+              incur =YPLANE(_current)+1+_info.width;
+
+              zout=YPLANE(data)+_info.width+1;
+
+              int32_t c0,c1,c2,c3; //,_nextPix,_currPix,_prevPix,cc;
+
+              for(uint32_t y= _info.height-2;y&gt;2;y--)
+              	{
+		  c0=0;
+		  c1=0;
+		  c2=0;
+		  c3=0;
+
+	  	inprev=YPLANE(_previous)	+1+y*_info.width;
+              	innext=YPLANE(_next)		+1+y*_info.width;;
+              	incur =YPLANE(_current)	+1+y*_info.width;;
+
+			// look if the field is more different temporarily than spacially
+
+			    for(uint32_t x= _info.width-1;x&gt;1;x--)
+        		      	{
+
+						c0+=(abs(((*inprev))-( *incur    ))^2);
+						c1+=(abs(((*inprev))-( *innext   ))^2)&lt;&lt;1;
+						c0+=(abs(((*incur ))-( *innext   ))^2);
+
+
+						c2+=(abs(((    *(incur-_info.width*2) ))-( *(incur            )   ))^2)   ;
+						c3+=(abs(((    *(incur-_info.width*2) ))-( *(incur+_info.width*2)   ))^2)&lt;&lt;1;
+						c2+=(abs(((    *(incur            ) ))-( *(incur+_info.width*2)   ))^2)   ;
+
+
+						incur++;
+						innext++;
+						inprev++;
+				}
+
+		// If yes, replace the line by an average of next/previous image
+		inprev=YPLANE(_previous)	+y*_info.width;
+              	innext=YPLANE(_next)		+y*_info.width;;
+              	incur =YPLANE(_current)		+y*_info.width;;
+		zout=YPLANE(data)		+y*_info.width;
+
+		if (c1&lt;c0 &amp;&amp;c3&lt;c2)
+		{
+		    for(uint32_t x= _info.width;x&gt;0;x--)
+       			      	{
+					*zout= ((*(inprev))+(*(innext)))&gt;&gt;1 ;
+					zout++;
+					innext++;
+					inprev++;
+				}
+		}
+		else
+			memcpy(zout,incur,_info.width);
+	}
+	data-&gt;copyInfo(_current);
+	vidCache-&gt;unlockAll();
+return 1;
+}
+
+
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DropOut/ADM_vidDropOut.h (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDropOut.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DropOut/ADM_vidDropOut.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,40 @@
+/***************************************************************************
+                          ADM_vidDropOut.h  -  description
+                             -------------------
+    begin                : Mon Oct 7 2002
+    copyright            : (C) 2002 by mean
+    email                : RON
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef __DROPOUT__
+#define __DROPOUT__   
+ 
+class  ADMVideoDropOut:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+        virtual char 				*printConf(void) ;
+						VideoCache	*vidCache;
+	 uint32_t				*_param;
+ public:
+ 					
+  						ADMVideoDropOut(  AVDMGenericVideoStream *in,CONFcouple *setup);
+  						~ADMVideoDropOut();
+		      virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          									ADMImage *data,uint32_t *flags);
+
+			virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
+			virtual uint8_t getCoupledConf( CONFcouple **couples);
+
+ }     ;
+ 
+#endif

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DropOut/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DropOut/CMakeLists.txt	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DropOut/CMakeLists.txt	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_dropOut_SRCS ADM_vidDropOut.cpp)
+
+ADD_LIBRARY(ADM_vf_dropOut SHARED ${ADM_vf_dropOut_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_dropOut)
+INSTALL_VIDEOFILTER(ADM_vf_dropOut)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Pulldown/ADM_vidPulldown.cpp (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.cpp	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Pulldown/ADM_vidPulldown.cpp	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,175 @@
+/***************************************************************************
+                       Pulldown : Duplicate frame fields to convert
+		       	24 fps to 30 fps movie
+
+			1 2 3 4       1  2  3  4  4
+			1 2 3 4 --&gt; 1  2  2  3  4
+
+
+    begin                : Thu Mar 21 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;ADM_vidFieldUtil.h&quot;
+#include &quot;ADM_interlaced.h&quot;
+#include &quot;ADM_vidPulldown.h&quot;
+
+#define aprintf(...) {}
+
+
+static FILTER_PARAM swapParam={0,{&quot;&quot;}};
+//********** Register chunk ************
+
+VF_DEFINE_FILTER(ADMVideoPullDown,swapParam,
+                pulldown,
+                QT_TR_NOOP(&quot;Pulldown&quot;),
+                1,
+                VF_INTERLACING,
+                QT_TR_NOOP(&quot;Convert 24 fps to 30 fps by repeating fields.&quot;));
+//********** Register chunk ************
+
+char *ADMVideoPullDown::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf,&quot; Pulldown&quot;);
+        return buf;
+}
+//_______________________________________________________________
+ADMVideoPullDown::ADMVideoPullDown(
+									AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+UNUSED_ARG(setup);
+  	_in=in;
+   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
+	_info.fps1000=(_info.fps1000*5)/4;
+	_info.nb_frames=(_info.nb_frames*5)/4;
+	for(uint32_t i=0;i&lt;5;i++)
+	{
+		_uncompressed[i]=new ADMImage(_info.width,_info.height);
+	}
+	_cacheStart=0xfffffff;
+}
+// ___ destructor_____________
+ADMVideoPullDown::~ADMVideoPullDown()
+{
+	for(uint32_t i=0;i&lt;5;i++)
+	{
+ 		delete  _uncompressed[i];
+	}
+}
+
+
+uint8_t ADMVideoPullDown::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+//static Image in,out;
+			if(frame&gt;=_info.nb_frames)
+			{
+				printf(&quot;out of bound frame (%lu / %lu)\n&quot;,frame,_info.nb_frames);
+				return 0;
+			}
+
+		uint32_t w=_info.width;
+		uint32_t h=_info.height;
+		uint32_t page=w*h;
+		uint32_t i;
+
+		uint32_t target;
+		uint32_t loop=0;
+
+		*len=(page*3)&gt;&gt;1;
+
+cont:
+
+		target=frame-((frame)%5);
+		// got it ?
+		if(_cacheStart==target)
+		{
+			uint32_t index;
+
+			aprintf(&quot;Filter: It is in cache...(cachestart=%lu)\n&quot;,_cacheStart);
+			index=frame%5;
+			aprintf(&quot;getting %lu)\n&quot;,index);
+			memcpy(YPLANE(data),YPLANE(_uncompressed[index]),page);
+			memcpy(UPLANE(data),UPLANE(_uncompressed[index]),page&gt;&gt;2);
+			memcpy(VPLANE(data),VPLANE(_uncompressed[index]),page&gt;&gt;2);
+			*flags=0;			
+			return 1;
+		}
+		else
+		{
+			aprintf(&quot;Not in cache...\n&quot;);
+		}
+		// Else ask the 5 corresponding frame
+		_cacheStart=target;
+		target=(target*4)/5;
+
+		uint32_t dflags,dlen;
+#define GET_FRAME(x,y) if(!_in-&gt;getFrameNumberNoAlloc(x, &amp;dlen,_uncompressed[y],&amp;dflags)) \
+ {\
+				 	 	printf(&quot;Cannot get frame %lu\n&quot;,x);\
+					 	return 0;     \
+				 }
+
+		GET_FRAME(target+0,0);
+		GET_FRAME(target+1,1);
+		GET_FRAME(target+2,3);
+		GET_FRAME(target+3,4);
+		// copy chroma 1-&gt;2
+		memcpy(UPLANE(_uncompressed[2]),UPLANE(_uncompressed[1]),page&gt;&gt;2);
+		memcpy(VPLANE(_uncompressed[2]),VPLANE(_uncompressed[1]),page&gt;&gt;2);
+#define COPY_FIELD \
+		for(uint32_t y=0;y&lt;_info.height&gt;&gt;1;y++) \
+		{ \
+			memcpy(out,in,_info.width); \
+			in+=_info.width&lt;&lt;1; \
+			out+=_info.width&lt;&lt;1; \
+		}
+
+		// now we merge 1 &amp; 3 into 2
+
+		uint8_t *in,*out;
+		in=YPLANE(_uncompressed[1]);
+		out=YPLANE(_uncompressed[2]);
+		COPY_FIELD;
+
+
+		// merge 3-&gt;2
+		//
+		//	0 1 x 2 3
+		//      0 1 x 2 3
+		//
+		//  0 1 1 2 3
+		//  0 1 X 2 3
+		in=YPLANE(_uncompressed[3])+w;
+		out=YPLANE(_uncompressed[2])+w;
+		COPY_FIELD;
+		//  0 1 1 2 3
+		//  0 1 2 2 3
+		in=YPLANE(_uncompressed[4])+w;
+		out=YPLANE(_uncompressed[3])+w;
+		//  0 1 1 2 3
+		//  0 1 2 3 3
+		COPY_FIELD;
+		goto cont;
+		return 1;
+}
+
+
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Pulldown/ADM_vidPulldown.h (from rev 4018, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidPulldown.h	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Pulldown/ADM_vidPulldown.h	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,24 @@
+#ifndef VID_PDW_
+#define VID_PDW_
+
+ class  ADMVideoPullDown:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+				ADMImage	*_uncompressed[5];
+     		virtual 	char 		*printConf(void);
+				uint32_t	_cacheStart;
+
+ public:
+
+
+  				ADMVideoPullDown(  AVDMGenericVideoStream *in,CONFcouple *setup);
+
+  	virtual 		~ADMVideoPullDown();
+	virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          								ADMImage *data,uint32_t *flags);
+	virtual uint8_t configure( AVDMGenericVideoStream *instream) {return 1;};
+
+ }     ;
+#endif

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Pulldown/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Pulldown/CMakeLists.txt	2008-05-03 17:13:20 UTC (rev 4018)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Pulldown/CMakeLists.txt	2008-05-04 17:05:41 UTC (rev 4019)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_Pulldown_SRCS ADM_vidPulldown.cpp)
+
+ADD_LIBRARY(ADM_vf_Pulldown SHARED ${ADM_vf_Pulldown_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_Pulldown)
+INSTALL_VIDEOFILTER(ADM_vf_Pulldown)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001277.html">[Avidemux-svn-commit] r4018 - in	branches/avidemux_2.5_branch_gruntster: . cmake
</A></li>
	<LI>Next message: <A HREF="001279.html">[Avidemux-svn-commit] r4020 - in	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog:	. resources
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1278">[ date ]</a>
              <a href="thread.html#1278">[ thread ]</a>
              <a href="subject.html#1278">[ subject ]</a>
              <a href="author.html#1278">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
