<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4068 - in	branches/avidemux_2.5_branch_gruntster: . avidemux	avidemux/ADM_filter avidemux/ADM_userInterfaces/ADM_commonUI	avidemux/ADM_video avidemux/ADM_videoFilter	avidemux/plugins/ADM_videoFilters	avidemux/plugins/ADM_videoFilters/Rotate	avidemux/plugins/ADM_videoFilters/Srt	avidemux/plugins/ADM_videoFilters/Srt/gtk	avidemux/plugins/ADM_videoFilters/Srt/qt4	avidemux/plugins/ADM_videoFilters/Tdeint cmake
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4068%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster%3A%20.%20avidemux%0A%09avidemux/ADM_filter%20avidemux/ADM_userInterfaces/ADM_commonUI%0A%09avidemux/ADM_video%20avidemux/ADM_videoFilter%0A%09avidemux/plugins/ADM_videoFilters%0A%09avidemux/plugins/ADM_videoFilters/Rotate%0A%09avidemux/plugins/ADM_videoFilters/Srt%0A%09avidemux/plugins/ADM_videoFilters/Srt/gtk%0A%09avidemux/plugins/ADM_videoFilters/Srt/qt4%0A%09avidemux/plugins/ADM_videoFilters/Tdeint%20cmake&In-Reply-To=%3C200805271941.m4RJfuru004096%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001324.html">
   <LINK REL="Next"  HREF="001326.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4068 - in	branches/avidemux_2.5_branch_gruntster: . avidemux	avidemux/ADM_filter avidemux/ADM_userInterfaces/ADM_commonUI	avidemux/ADM_video avidemux/ADM_videoFilter	avidemux/plugins/ADM_videoFilters	avidemux/plugins/ADM_videoFilters/Rotate	avidemux/plugins/ADM_videoFilters/Srt	avidemux/plugins/ADM_videoFilters/Srt/gtk	avidemux/plugins/ADM_videoFilters/Srt/qt4	avidemux/plugins/ADM_videoFilters/Tdeint cmake</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4068%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster%3A%20.%20avidemux%0A%09avidemux/ADM_filter%20avidemux/ADM_userInterfaces/ADM_commonUI%0A%09avidemux/ADM_video%20avidemux/ADM_videoFilter%0A%09avidemux/plugins/ADM_videoFilters%0A%09avidemux/plugins/ADM_videoFilters/Rotate%0A%09avidemux/plugins/ADM_videoFilters/Srt%0A%09avidemux/plugins/ADM_videoFilters/Srt/gtk%0A%09avidemux/plugins/ADM_videoFilters/Srt/qt4%0A%09avidemux/plugins/ADM_videoFilters/Tdeint%20cmake&In-Reply-To=%3C200805271941.m4RJfuru004096%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4068 - in	branches/avidemux_2.5_branch_gruntster: . avidemux	avidemux/ADM_filter avidemux/ADM_userInterfaces/ADM_commonUI	avidemux/ADM_video avidemux/ADM_videoFilter	avidemux/plugins/ADM_videoFilters	avidemux/plugins/ADM_videoFilters/Rotate	avidemux/plugins/ADM_videoFilters/Srt	avidemux/plugins/ADM_videoFilters/Srt/gtk	avidemux/plugins/ADM_videoFilters/Srt/qt4	avidemux/plugins/ADM_videoFilters/Tdeint cmake">mean at mail.berlios.de
       </A><BR>
    <I>Tue May 27 21:41:56 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001324.html">[Avidemux-svn-commit] r4067 - in	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_filter	ADM_videoFilter plugins/ADM_videoFilters	plugins/ADM_videoFilters/ASharp plugins/ADM_videoFilters/ASharp/gtk	plugins/ADM_videoFilters/ASharp/qt4	plugins/ADM_videoFilters/Contrast	plugins/ADM_videoFilters/Contrast/gtk	plugins/ADM_videoFilters/Contrast/qt4 plugins/ADM_videoFilters/Crop	plugins/ADM_videoFilters/Crop/gtk plugins/ADM_videoFilters/Crop/qt4	plugins/ADM_videoFilters/Eq2 plugins/ADM_videoFilters/Eq2/gtk	plugins/ADM_videoFilters/Eq2/qt4 plugins/ADM_videoFilters/Hue	plugins/ADM_videoFilters/Hue/gtk plugins/ADM_videoFilters/Hue/qt4
</A></li>
        <LI>Next message: <A HREF="001326.html">[Avidemux-svn-commit] r4069 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_UIs/ADM_GTK/include ADM_UIs/ADM_GTK/src	ADM_UIs/ADM_QT4/include ADM_UIs/ADM_QT4/src	ADM_coreImage/include ADM_filter ADM_libraries	ADM_libraries/ADM_libass ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_commonUI ADM_videoFilter	plugins/ADM_videoFilters plugins/ADM_videoFilters/Animated	plugins/ADM_videoFilters/Ass plugins/ADM_videoFilters/Ass/ADM_libass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1325">[ date ]</a>
              <a href="thread.html#1325">[ thread ]</a>
              <a href="subject.html#1325">[ subject ]</a>
              <a href="author.html#1325">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-05-27 21:41:54 +0200 (Tue, 27 May 2008)
New Revision: 4068

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Rotate/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Rotate/ADM_vidRotate.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Rotate/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidFont.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidFont.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/DIA_flySrtPos.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/DIA_flySrtPos.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/ADM_vidTDeint_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/ADM_vidTdeint.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/ADM_vidTdeint_util.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/DIA_tdeint.cpp
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckFreeType.cmake
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_tdeint.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidRotate.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTDeint_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint_util.txt
Modified:
   branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRT.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRT.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRTRender.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRTload.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/DIA_srt.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/gtk/DIA_srt.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/qt4/Q_srt.h
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckMiscLibs.cmake
Log:
[Merge] Filters/flyDialog


Modified: branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,3 +1,5 @@
+
+PROJECT(&quot;Avidemux_2.5&quot;)
 MESSAGE(&quot;#####################################&quot;)
 MESSAGE(&quot;Configure Started&quot;)
 MESSAGE(&quot;#####################################&quot;)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -5,7 +5,7 @@
                           Usually it is to be avoided and better to use dynamic filter.
 
                              -------------------
-    
+
     copyright            : (C) 2008 by mean
     email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
  ***************************************************************************/
@@ -38,41 +38,34 @@
 
 void registerVideoFilters( void )
 {
-printf(&quot;\n Registering Filters\n&quot;);
-printf(  &quot;*********************\n&quot;);
+printf(&quot;\n Registering Internal Filters\n&quot;);
+printf(  &quot;******************************\n&quot;);
 
-//ko -- ko -- ko -- ko ko --ko -ko
-	
-  
-REGISTERX(VF_TRANSFORM, &quot;rotate&quot;,QT_TR_NOOP(&quot;Rotate&quot;),QT_TR_NOOP(&quot;Rotate the picture by 90, 180 or 270 degrees.&quot;),VF_ROTATE,1,rotate_create,rotate_script);
-REGISTERX(VF_INTERLACING, &quot;tdeint&quot;,QT_TR_NOOP(&quot;TDeint&quot;),QT_TR_NOOP(&quot;Motion adaptative deinterlacer by Tritical.&quot;),VF_TDEINT,1,tdeint_create,tdeint_script);
-
-
 REGISTERX(VF_MISC, &quot;animatedmenu&quot;,QT_TR_NOOP(&quot;Animated Menu&quot;), QT_TR_NOOP(&quot;Create a video made of 6 mini windows, very useful to do DVD menus.&quot;),
         VF_ANIMATED,1,animated_create,animated_script);
-    
-#if 0  
-#ifdef USE_FREETYPE   
-	REGISTERX(VF_SUBTITLE, &quot;subtitle&quot;,QT_TR_NOOP(&quot;Subtitler&quot;),QT_TR_NOOP(&quot;Add srt/sub subtitles to the picture.&quot;),VF_SUBTILE,1,subtitle_create,subtitle_script);
-// Ass can be moved &amp; linked to libass	
+
+#if 0
+#ifdef USE_FREETYPE
+
+// Ass can be moved &amp; linked to libass
 	REGISTERX(VF_SUBTITLE, &quot;ass&quot;,QT_TR_NOOP(&quot;ASS&quot;),QT_TR_NOOP(&quot;Add ASS/SSA subtitles to the picture.&quot;),VF_ASS,1,ass_create,ass_script);
 #endif
-#endif	
+#endif
 
         REGISTERX(VF_SUBTITLE,&quot;vobsub&quot;,QT_TR_NOOP(&quot;VobSub&quot;),QT_TR_NOOP(&quot;Embed VobSub subtitles into picture.&quot;),VF_VOBSUB,1,vobsub_create,vobsub_script);
         REGISTERX(VF_SUBTITLE,&quot;dvbsub&quot;,QT_TR_NOOP(&quot;DVB sub&quot;),QT_TR_NOOP(&quot;Embed DVB-T subtitle.&quot;),VF_DVBSUB,1,dvbsub_create,dvbsub_script);
         //*********************
-#if 0        
+#if 0
 	REGISTERX(VF_MISC, &quot;computeaverage&quot;,QT_TR_NOOP(&quot;Compute Average&quot;),QT_TR_NOOP(&quot;Compute average luma value for each pixel throughout all frames, and save to file&quot;),VF_COMPUTEAVERAGE,1,computeaverage_create,computeaverage_script);
 	REGISTERX(VF_MISC, &quot;threshold&quot;,QT_TR_NOOP(&quot;Threshold&quot;),QT_TR_NOOP(&quot;Force too-bright/too-dim pixels to 0 and the rest to 255 or vice-versa&quot;),VF_THRESHOLD,1,threshold_create,threshold_script);
 	//REGISTERX(&quot;particlelist&quot;,QT_TR_NOOP(&quot;Particle List&quot;),QT_TR_NOOP(&quot;Identify 'particles' (groups of pixels)&quot;),VF_PARTICLELIST,1,particle_create,particle_script);
 	//REGISTERX(&quot;eraser&quot;,QT_TR_NOOP(&quot;Eraser&quot;),QT_TR_NOOP(&quot;\&quot;Erase\&quot; arbitrary areas of each frame&quot;),VF_ERASER,1,eraser_create,eraser_script);
 	//REGISTERX(&quot;swissarmyknife&quot;,QT_TR_NOOP(&quot;Swiss Army Knife&quot;),QT_TR_NOOP(&quot;Apply operation like P'=P*A, P-A, P+A, etc. using a convolution, rolling average, image from file, or constant&quot;),VF_SWISSARMYKNIFE,1,swissarmyknife_create,swissarmyknife_script);
 #endif
-// Misc filter, internal only        
+// Misc filter, internal only
 	REGISTERX(VF_MISC,&quot;partial&quot;,QT_TR_NOOP(&quot;Partial&quot;),&quot;&quot;,VF_PARTIAL,0,partial_create,partial_script);
  printf(&quot;\n&quot;);
-}		
+}
 
 
 // EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt	2008-05-27 19:41:54 UTC (rev 4068)
@@ -16,7 +16,6 @@
 DIA_builtin.cpp       
 DIA_lavDecoder.cpp  
 DIA_requant.cpp   
-DIA_tdeint.cpp     
 DIA_animated.cpp      
 DIA_ocr.cpp             
 DIA_tsSub.cpp        

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,67 +0,0 @@
-/***************************************************************************
-                       FlyDialog for Subtitles
-    copyright            : (C) 2007 Mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#ifdef USE_FREETYPE
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &lt;math.h&gt;
-#include &quot;ADM_default.h&quot;
-//#include &quot;ADM_colorspace/ADM_rgb.h&quot;
-#include &quot;ADM_image.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-class ADMfont;
-//#include &quot;ADM_video/ADM_vidFont.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
-
-#include &quot;DIA_flyDialog.h&quot;
-#include &quot;DIA_flySrtPos.h&quot;
-/*********  COMMON PART *********/
-uint8_t    flySrtPos::process(void)
-{
-  uint32_t h;
-        // First copy Y
-        memcpy(_yuvBufferOut-&gt;data,_yuvBuffer-&gt;data,(_w*_h));
-        // then shift u
-        memcpy(UPLANE(_yuvBufferOut),UPLANE(_yuvBuffer),(_w*_h)/4);
-        memcpy(VPLANE(_yuvBufferOut),VPLANE(_yuvBuffer),(_w*_h)/4);
-        // Mark 
-        h=param.fontSize;
-        if(h&gt;8) h-=4;
-  
-        for(uint32_t line=0;line&lt;SRT_MAX_LINE;line++)
-        {
-                uint8_t *src=YPLANE(_yuvBufferOut)+(param.position+line*param.fontSize)*_w;
-  
-                for(uint32_t y=0;y&lt;h;y+=2)
-                {
-                        memset(src,255,_w);
-                        src+=2*_w;
-                }
-        }
-        return 1;
-}
-uint8_t    flySrtPos::update(void)
-{
-    download();
-    process();
-	copyYuvFinalToRgb();
-    display();
-}
-#endif
-//EOF
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.h	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.h	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,25 +0,0 @@
-
-
-#ifndef FLY_SRTPOS_H
-#define FLY_SRTPOS_H
-typedef struct
-{
-    uint32_t fontSize;
-    uint32_t position;
-}SRT_POS_PARAM;
-
-class flySrtPos : public ADM_flyDialog
-{
-  
-  public:
-   SRT_POS_PARAM  param;
-  public:
-   uint8_t    process(void);
-   uint8_t    download(void);
-   uint8_t    upload(void);
-   uint8_t    update(void);
-   flySrtPos (uint32_t width,uint32_t height,AVDMGenericVideoStream *in,
-                                    void *canvas, void *slider) : ADM_flyDialog(width, height,in,canvas, slider,1,RESIZE_AUTO) {};
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_tdeint.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_tdeint.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_tdeint.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,118 +0,0 @@
-//
-// C++ Implementation: ADM_vidForcedPP
-//
-// Description: 
-//
-//	Force postprocessing assuming constant quant &amp; image type
-//	Uselefull on some badly authored DVD for example
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#include &lt;math.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-
-
-#include &quot;DIA_factory.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidTDeint_param.h&quot;
-/**
-      \fn DIA_tdeint
-      \brief Dialog for tdeint filter
-*/
-
-uint8_t  DIA_tdeint(TDEINT_PARAM *param)
-{
-         
-         
-diaMenuEntry meField[]={
-  {0,QT_TR_NOOP(&quot;Auto (might not work)&quot;)},
-  {2,QT_TR_NOOP(&quot;Top field first&quot;)},
-  {1,QT_TR_NOOP(&quot;Bottom field first&quot;)}
-};       
-
-diaMenuEntry meInterpolate[]={
-  {0,QT_TR_NOOP(&quot;Auto (might not work)&quot;)},
-  {2,QT_TR_NOOP(&quot;Bottom field (keep top)&quot;)},
-  {1,QT_TR_NOOP(&quot;Top field (keep bottom)&quot;)}
-};       
-
-
-diaMenuEntry meType[]={
-  {0,QT_TR_NOOP(&quot;Cubic interpolation&quot;)},
-  {1,QT_TR_NOOP(&quot;Modified ELA&quot;)},
-  {2,QT_TR_NOOP(&quot;Kernel interpolation&quot;)},
-  {3,QT_TR_NOOP(&quot;Modified ELA-2&quot;)},
-  
-};       
-
-diaMenuEntry meMnt[]={
-  {0,QT_TR_NOOP(&quot;4 fields check&quot;)},
-  {1,QT_TR_NOOP(&quot;5 fields check&quot;)},
-  {2,QT_TR_NOOP(&quot;4 fields check (no avg)&quot;)},
-  {3,QT_TR_NOOP(&quot;5 fields check (no avg)&quot;)},
-  
-};       
-
-
-diaMenuEntry meLink[]={
-  {0,QT_TR_NOOP(&quot;No link&quot;)},
-  {1,QT_TR_NOOP(&quot;Full link&quot;)},
-  {2,QT_TR_NOOP(&quot;Y to UV&quot;)},
-  {3,QT_TR_NOOP(&quot;UV to Y&quot;)}
-};     
-
-diaMenuEntry meAP[]={
-  {0,QT_TR_NOOP(&quot;0&quot;)},
-  {1,QT_TR_NOOP(&quot;1&quot;)},
-  {2,QT_TR_NOOP(&quot;2&quot;)}
-};     
-#define PX(x) &amp;(param-&gt;x)
-      uint32_t order=param-&gt;order+1;
-      uint32_t field=param-&gt;field+1;
-      
-      
-      diaElemMenu     menuFieldOrder(&amp;(order),QT_TR_NOOP(&quot;_Field order:&quot;),3,meField);
-      diaElemMenu     menuInterpolaye(&amp;(field),QT_TR_NOOP(&quot;_Interpolate:&quot;),3,meInterpolate);
-      
-      diaElemMenu     menuType(PX(type),QT_TR_NOOP(&quot;_Type:&quot;),4,meType);
-      diaElemMenu     menuMnt(PX(mtnmode),QT_TR_NOOP(&quot;_MntMode:&quot;),4,meMnt);
-      diaElemMenu     menuLink(PX(link),QT_TR_NOOP(&quot;_Link:&quot;),4,meLink);
-      diaElemMenu     menuAP(PX(APType),QT_TR_NOOP(&quot;_AP type:&quot;),3,meAP);
-
-      // Toggle
-      diaElemToggle    toggleUseChroma(PX(chroma),QT_TR_NOOP(&quot;Use ch_roma to evalute&quot;));
-      diaElemToggle    toggleTryWeave(PX(tryWeave),QT_TR_NOOP(&quot;Try _weave&quot;));
-      diaElemToggle    toggleDenoise(PX(denoise),QT_TR_NOOP(&quot;_Denoise&quot;));
-      diaElemToggle    toggleSharp(PX(sharp),QT_TR_NOOP(&quot;_Sharp&quot;));
-      diaElemToggle    toggleEvaluteAll(PX(full),QT_TR_NOOP(&quot;_Evalute all frames&quot;));
-      
-      // int
-      diaElemUInteger  intMotionLuma(PX(mthreshL),QT_TR_NOOP(&quot;Motion threshold, l_uma:&quot;),0,255);
-      diaElemUInteger  intMotionChroma(PX(mthreshC),QT_TR_NOOP(&quot;Motion threshold, c_hroma:&quot;),0,255);
-      diaElemUInteger  intAreaCombing(PX(cthresh),QT_TR_NOOP(&quot;Area com_bing threshold:&quot;),0,255);
-      diaElemUInteger  intCombed(PX(MI),QT_TR_NOOP(&quot;Combe_d threshold:&quot;),0,255);
-      diaElemInteger   intArtefact(PX(AP),QT_TR_NOOP(&quot;Artefact _protection threshold:&quot;),-1,255);
-      diaElemToggle    intDebug(PX(debug),QT_TR_NOOP(&quot;Debug:&quot;));
-
-         diaElem *diaRC[]={&amp;menuFieldOrder,&amp;menuInterpolaye,&amp;menuType,&amp;menuMnt,&amp;menuLink,&amp;menuAP,
-                            &amp;toggleUseChroma,&amp;toggleTryWeave,&amp;toggleDenoise,&amp;toggleSharp,&amp;toggleEvaluteAll,
-                            &amp;intMotionLuma,&amp;intMotionChroma,&amp;intAreaCombing,&amp;intCombed,&amp;intArtefact,&amp;intDebug
-                  };
-
-        
-         
-        if( diaFactoryRun(QT_TR_NOOP(&quot;TDeint&quot;),17,diaRC))
-	{
-           param-&gt;order=(int)order-1;
-           param-&gt;field=(int)field-1;
-          return 1;
-        }
-         return 0;
-}
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,220 +0,0 @@
-/***************************************************************************
-                          ADM_vidFont.cpp  -  description
-                             -------------------
-    begin                : Sun Dec 15 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;config.h&quot;
-
-#ifdef USE_FREETYPE
-
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_vidFont.h&quot;
-
-static    FT_Library   	library;   		/* handle to library     */
-static    int 			initialized=0; 	// 0 No init at all, 1 engine inited
-
-ADMfont::ADMfont ( void )
-{	
-	_faceAllocated=0;
-	_use2bytes=0;
-	_hold=0;
-	_value=0;
-
-}
-
-/**
-	Deallocate font allocated stuff
-*/
- ADMfont::~ADMfont( )
-{
-	
-	if(_faceAllocated)
-	{
-		//
-		FT_Done_Face(_face);
-		_faceAllocated=0;
-
-	}
-}
-
-
-int ADMfont::initFreeType( char *fontname )
-{
-int error;
-
-	printf(&quot;\n ** Initializing FreeType **\n&quot;);
-	if(initialized==0)
-	{
-
-    		error = FT_Init_FreeType( &amp;library );
-    		if ( error )
-    		{
-			  printf(&quot;\n Error Initializing Free Type (%d)\n&quot;,error);
-			  return 0;
-		  }
-		initialized=1;
-	}
-  	error = FT_New_Face( library,
-                         fontname,
-                         0,
-                         &amp;_face );
-    	if ( error == FT_Err_Unknown_File_Format )
-    	{
-   	   	printf(&quot;\n Error unknown font format (%d)\n&quot;,error);
-			  return 0;
-
-    	}
-    	else if ( error )
-    	{
-     		printf(&quot;\n Error unknown error (font %d)\n&quot;,error);
-		 return 0;
-    	}
-	_faceAllocated=1;
-
-	error = FT_Set_Pixel_Sizes(
-              _face,   /* handle to face object            */
-              0,      /* pixel_width                      */
-              16 );   /* pixel_height                     */
-
-	printf(&quot;\n **  FreeType Initialized **\n&quot;);
-	_hold=0;
-   	return 1;
-}
-//____________________________________________________
-int ADMfont::fontSetCharSet (char *charset)
-{
-	printf(&quot;OBSOLETE*********\n&quot;);
-	return 1;
-}
-//---------------------------------
-int ADMfont::fontSetSize ( int size)
-{
-int error;
-	if(!_faceAllocated)
-		{
-				printf(&quot;\n not initialized&quot;);
-				return 0;
-		}
-	   error = FT_Set_Pixel_Sizes(
-              _face,   /* handle to face object            */
-              0,      /* pixel_width                      */
-              size );   /* pixel_height                     */
-
-	return 1;
-}
-//____________________________________________________
-
-int ADMfont::fontDraw(char *target, int  c, int prevchar,int stride, int size,int *ww)
-{
-
-
-			if(!_faceAllocated)
-			{
-				printf(&quot;No face!\n&quot;); 
-				return 0;
-			}
-FT_GlyphSlot  slot = _face-&gt;glyph;  // a small shortcut
-int  glyph_index,glyph_prev;
-int error;
-FT_Vector delta;
-int kern;
-	
-	//printf(&quot;FONT: rendering %d %c\n&quot;,c,c);
-	*ww=0;	
-/* Ugly patch t avoid some display problem */	
-#if 0
-        if(c=='\'') c='&quot;';
-        if(prevchar=='\'') prevchar='&quot;';
-#endif
-/* Ugly patch t avoid some display problem */
-	glyph_index = FT_Get_Char_Index( _face, c );
-	if(prevchar)
-		glyph_prev=FT_Get_Char_Index( _face, prevchar );
-		
-   	error = FT_Load_Glyph(
-        		   _face,          /* handle to face object */
-        		     glyph_index,   /* glyph index           */
-        		      0 );  /* load flags, see below */
-	if(error)
-	{	
-		printf(&quot;Loadglyph error\n&quot;);
-	 	return 0;
-	}
-
-	error = FT_Render_Glyph(
-			slot,      /* glyph slot  */
-			ft_render_mode_normal);    /* render mode */
-
-      	if(error)
-	{
-		printf(&quot;RenderGlyph error&quot;);
-	 	return 0;
-	 }
-
-       // now, draw to our target surface
-       // inspired from MPlayer font rendering
-
-	FT_Bitmap *bitmap=&amp;(slot-&gt;bitmap);
-	int heigh;
-	int srow=0;
-
-		
-	heigh=bitmap-&gt;rows;
-	target+=stride*(size-slot-&gt;bitmap_top);
-	
-	int correction;
-// If kerning is available from freetype
-#ifdef FT_FACE_FLAG_KERNING
-	if(prevchar &amp;&amp; FT_HAS_KERNING( _face ))
-	{		
-		FT_Get_Kerning( _face,glyph_prev, glyph_index, 0 /*FT_KERNING_DEFAULT*/, &amp;delta );	
-		correction=delta.x/64;
-	}
-	else
-#endif	
-		correction=0;
-	target+=correction;
-	
-	target+=slot-&gt;bitmap_left;
-	//target+=(slot-&gt;bitmap_top)*stride;
-	for (int h = heigh; h&gt;0 ; h-- )
-	{						
-	    for (int w =0;w&lt; bitmap-&gt;width;  w++ )
-	    {
-		if(bitmap-&gt;buffer[srow+w])
-			    *(target+w) = bitmap-&gt;buffer[srow+w];
-		    
-	     }  
-		 target+=stride;
-		 srow+=bitmap-&gt;pitch ;		
-	}
-	
-	// Now advance cursor
-	int advance=0;//correction;
-	*ww=bitmap-&gt;width;	
-	advance+=slot-&gt;advance.x/64;
-	
-	
-// 	printf(&quot;FONT: Width %d, adance:%d\n&quot;,bitmap-&gt;width,advance);
-//  	printf(&quot;FONT:cur :%c next :%c\n&quot;,c,prevchar);
-//  	printf(&quot;FONT:cur :%d next :%d\n&quot;,glyph_index,glyph_prev);
-//  	printf(&quot;FONT:Raw: %d kerning:%d kerning :%d \n&quot;,*ww,delta.x,delta.y);
-		
-	
-//	FT_Done_Glyph(glyph_index); Mem leak ?
-	*ww=advance;
-	return 1;
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.h	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.h	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,53 +0,0 @@
-/***************************************************************************
-                          ADM_vidFont.h  -  description
-                             -------------------
-    begin                : Sun Dec 15 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #ifdef USE_FREETYPE
-#undef free
-#undef alloc
-#undef realloc
-#ifdef HAVE_UNISTD_H
-// avoid warnings due to different definition of this in freetype headers
-#define WE_DO_HAVE_UNISTD_H
-#undef HAVE_UNISTD_H
-#endif
- #include &lt;ft2build.h&gt;
- #include FT_FREETYPE_H
-#ifdef WE_DO_HAVE_UNISTD_H
-#undef HAVE_UNISTD_H
-#define HAVE_UNISTD_H
-#endif
-
- class ADMfont
- {
- private:
- 		  
-		   FT_Face    _face;
-		   int			_faceAllocated;
-		   uint8_t		_use2bytes;
-		   uint8_t		_hold;
-		   int			_value;
- public :
-		ADMfont(void );
-		~ADMfont();
-
-	int initFreeType( char *fontname );
-	int fontDraw(char *target, int c,int prevchar, int stride, int size,int *ww);
-	int fontSetSize ( int size);
-	int fontSetCharSet (char *code);
-
-};
-
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,8 +1,6 @@
 SET(ADM_video_SRCS 
-#ADM_vidFieldUnblend.cpp  
 ADM_vidPartial.cpp    
 ADM_vidRaw.cpp        
-ADM_vidFont.cpp
 ADM_vidNull.cpp)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_video ${ADM_video_SRCS})
@@ -12,3 +10,4 @@
 ENDIF (USE_FREETYPE)
 
 ADD_CFLAGS_ALL_TARGETS(ADM_video &quot;-I../ADM_inputs&quot;)
+#ADM_vidFieldUnblend.cpp  

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,242 +0,0 @@
-/***************************************************************************
-                          ADM_vidChromaShift.cpp  -  description
-                             -------------------
-	Try to remove the blue-to-theleft &amp; red to the right effect by shifting chroma
-
-    begin                : Sun Aug 14 2003
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_default.h&quot;
-
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_vidChromaShift.h&quot;
-
-
-
-static FILTER_PARAM cshiftParam={2,{&quot;u&quot;,&quot;v&quot;}};
-
-
-SCRIPT_CREATE(chromashift_script,ADMVideoChromaShift,cshiftParam);
-BUILD_CREATE(create_chromashift,ADMVideoChromaShift);
-
-char *ADMVideoChromaShift::printConf( void )
-{
- 	static char buf[50];
-
- 	snprintf((char *)buf,50,&quot; Chroma shift U:%d  V:%d&quot;,
-            _param-&gt;u,_param-&gt;v);
-        return buf;
-}
-
-ADMVideoChromaShift::ADMVideoChromaShift(  AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
- 	_in=in;		
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  		
-	 _param=NEW(CHROMASHIFT_PARAM);
-		if(couples)
-		{
-				GET(u);
-				GET(v);
-		}
-			else
-		{	// default parameter
-				_param-&gt;u=0;
-				_param-&gt;v=0;
-		}
-
-	_uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-	ADM_assert(_uncompressed);
-	_info.encoding=1;
-}
-
-
-uint8_t	ADMVideoChromaShift::getCoupledConf( CONFcouple **couples)
-{
-
-		ADM_assert(_param);
-		*couples=new CONFcouple(2);
-		CSET(u);
-		CSET(v);
-		return 1;
-
-}
-
-ADMVideoChromaShift::~ADMVideoChromaShift()
-{
-	if(_uncompressed)
- 		delete _uncompressed;
-	_uncompressed=NULL;
-	DELETE(_param);
-
-}
-uint8_t ADMVideoChromaShift::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-		if(frame&gt;= _info.nb_frames) return 0;
-		ADM_assert(_param);									
-								
-		// read uncompressed frame
-       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-		// copy luma as it is left untouched
-		uint32_t w=_info.width;
-		uint32_t h=_info.height;
-//		uint8_t *in,*out;
-		uint32_t page;
-
-		page=(w*h);
-
-		memcpy(YPLANE(data),YPLANE(_uncompressed),page);
-
-		if(!_param-&gt;u)
-			{
-				memcpy(UPLANE(data),UPLANE(_uncompressed),page&gt;&gt;2);
-			}
-		else
-			{
-				shift(UPLANE(data),UPLANE(_uncompressed),w&gt;&gt;1,h&gt;&gt;1,_param-&gt;u);
-			}
-		if(!_param-&gt;v)
-			{
-				memcpy(VPLANE(data),VPLANE(_uncompressed),page&gt;&gt;2);
-			}
-		else
-			{
-				shift(VPLANE(data),VPLANE(_uncompressed),w&gt;&gt;1,h&gt;&gt;1,_param-&gt;v);
-			}
-		if(_param-&gt;u)
-			fixup(YPLANE(data),w,h,_param-&gt;u*2);
-		if(_param-&gt;v)
-			fixup(YPLANE(data),w,h,_param-&gt;v*2);
-		  data-&gt;copyInfo(_uncompressed);
-      return 1;
-}
-/*
-	Black out the area were we don't have a valid chroma color
-
-*/
-uint8_t ADMVideoChromaShift::fixup(uint8_t *target,uint32_t width, uint32_t height,int32_t val)
-{
-uint32_t line,page;
-uint8_t *zero;
-uint8_t *zerochroma;
-/*
-	If val is &gt;0
-		Source  ++++++++
-		Target   __++++++
-*/
-	page=(width*height)&gt;&gt;2;
-	if(val&gt;0)
-		{
-			line=val;
-			zero=target;
-			zerochroma=target+width*height;
-			for(uint32_t h=height;h&gt;0;h--)
-			{
-				memset(zero,0,val);
-				zero+=width;
-			}
-			val&gt;&gt;=1;
-			for(uint32_t h=height&gt;&gt;1;h&gt;0;h--)
-			{
-				memset(zerochroma,128,val);
-				memset(zerochroma+page,128,val);
-				zerochroma+=width&gt;&gt;1;
-			}
-		}
-/*
-	if val is &lt;0
-		Source ++++++
-		Target  ++++__
-
-*/
-
-		else
-		{
-			val=-val;
-
-			zero=target+width-val;
-			zerochroma=target+width*height;
-			zerochroma+=(width-val)/2;
-
-			for(uint32_t h=height;h&gt;0;h--)
-			{
-				memset(zero,0,val);
-				zero+=width;
-			}
-
-			val&gt;&gt;=1;
-			for(uint32_t h=height&gt;&gt;1;h&gt;0;h--)
-			{
-				memset(zerochroma,128,val);
-				memset(zerochroma+page,128,val);
-				zerochroma+=width&gt;&gt;1;
-			}
-		}
-}
-uint8_t ADMVideoChromaShift::shift(uint8_t *target,uint8_t *source, uint32_t width, uint32_t height,int32_t val)
-{
-uint32_t line;
-
-/*
-	If val is &gt;0
-		Source  ++++++++
-		Target   __++++++
-*/
-	if(val&gt;0)
-		{
-			line=width-val;
-			target+=val;
-			for(uint32_t h=height;h&gt;0;h--)
-			{
-			memcpy(target,source,line);
-			target+=width;
-			source+=width;
-			}
-		}
-/*
-	if val is &lt;0
-		Source ++++++
-		Target  ++++__
-
-*/
-
-		else
-		{
-			val=-val;
-			line=width-val;
-			source+=val;
-
-			for(uint32_t h=height;h&gt;0;h--)
-			{
-			memcpy(target,source,line);
-			target+=width;
-			source+=width;
-			}
-		}
-	return 1;
-}
-uint8_t DIA_getChromaShift( AVDMGenericVideoStream *instream,CHROMASHIFT_PARAM    *param );
-uint8_t ADMVideoChromaShift::configure( AVDMGenericVideoStream *instream)
-
-{
-    return DIA_getChromaShift(instream,_param);
-
-}
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift.h	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift.h	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,50 +0,0 @@
-/***************************************************************************
-                          ADM_vidChromaShift.h  -  description
-                             -------------------
-
-	Shift chroma to the left or to the right
-
-    begin                : Wed Aug 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef CHROMASHIFT_
-#define CHROMASHIFT_
-
-#include &quot;ADM_vidChromaShift_param.h&quot;
- class  ADMVideoChromaShift:public AVDMGenericVideoStream
- {
-
- protected:
-
-
-            virtual 	char               *printConf(void);
-                        CHROMASHIFT_PARAM *_param;
-
- public:
-                        ADMVideoChromaShift(  AVDMGenericVideoStream *in,CONFcouple *setup);
-      virtual           ~ADMVideoChromaShift();
-      virtual uint8_t   getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                              ADMImage *data,uint32_t *flags);
-      virtual uint8_t   configure( AVDMGenericVideoStream *instream);
-      virtual uint8_t   getCoupledConf( CONFcouple **couples);
-
-      static	uint8_t shift(uint8_t *target,uint8_t *source,
-                                                      uint32_t width, uint32_t height,
-                                                      int32_t val);
-      static uint8_t    fixup(uint8_t *target,uint32_t width, uint32_t height,int32_t val);
-
- }     ;
-
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift_param.h	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChromaShift_param.h	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,30 +0,0 @@
-/***************************************************************************
-                          ADM_vidChromaShift.h  -  description
-                             -------------------
-
-	Shift chroma to the left or to the right
-
-    begin                : Wed Aug 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef CHROMASHIFT_PARAM_
-#define CHROMASHIFT_PARAM_
-
-typedef struct CHROMASHIFT_PARAM
-{
-      int32_t u;
-      int32_t v;
-}CHROMASHIFT_PARAM;
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidRotate.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidRotate.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidRotate.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,277 +0,0 @@
-/***************************************************************************
-                          ADM_vidRotate.cpp  -  description
-                             -------------------
-    begin                : Sat Jan 8 2003
-    copyright            : (C) 2003 by Tracy Harton
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">tracy at amphibious.org</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_assert.h&quot;
-        
-#include &quot;DIA_factory.h&quot;
-
-typedef struct ROTATE_PARAM
-{
-  uint32_t width;
-  uint32_t height;
-  uint32_t angle;
-}ROTATE_PARAM;
-
-class  ADMVideoRotate:public AVDMGenericVideoStream
-{
-
- protected:
-  virtual char                  *printConf(void);
-  ROTATE_PARAM                  *_param;
-
- public:
-                  ADMVideoRotate(AVDMGenericVideoStream *in, CONFcouple *setup);
-  virtual         ~ADMVideoRotate();
-  virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
-  virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data,uint32_t *flags);
-  virtual uint8_t	getCoupledConf( CONFcouple **couples)				;
- }     ;
-
-static FILTER_PARAM rotpParam={3,{&quot;width&quot;,&quot;height&quot;,&quot;angle&quot;}};
-
-
-SCRIPT_CREATE(rotate_script,ADMVideoRotate,rotpParam);
-BUILD_CREATE(rotate_create,ADMVideoRotate);
-
-static void do_rotate(ADMImage *source,ADMImage *target,uint32_t angle);
-
-char *ADMVideoRotate::printConf( void )
-{
-  static char buf[50];
- 	
-  sprintf((char *)buf,&quot; Rotate %u degrees&quot;, _param-&gt;angle);
-  return buf;
-}
-
-ADMVideoRotate::ADMVideoRotate(AVDMGenericVideoStream *in, CONFcouple *couples)
-{
-  _in=in;		
-
-  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info)); 
-  _info.encoding=1;
-
- // _uncompressed=new uint8_t [3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height];
- 
-
-  if(couples)
-  {
-   	 _param=NEW(ROTATE_PARAM);
-	GET(width);
-	GET(height);
-	GET(angle);
-	_info.width=_param-&gt;width;
-	_info.height=_param-&gt;height;
-
-  }
-  else
-  {
-    _param = NEW( ROTATE_PARAM);
-    printf(&quot;New Angle 0.0\n&quot;);
-    _param-&gt;angle = 0;
-    _param-&gt;width = _info.width;
-    _param-&gt;height = _info.height;
-  }
- _uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-  printf(&quot;New Rotate %ld %ld %f\n&quot;, _info.width, _info.height, _param-&gt;angle);
-  ADM_assert(_uncompressed);    	  	
-
-}
-
-
-
-uint8_t	ADMVideoRotate::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(3);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-			CSET(width);
-			CSET(height);
-			CSET(angle);
-
-			return 1;
-
-}
-
-
-ADMVideoRotate::~ADMVideoRotate()
-{
- 	delete  _uncompressed;
-	_uncompressed=NULL;
-	DELETE(_param);
-}
-uint8_t ADMVideoRotate::getFrameNumberNoAlloc(uint32_t frame,
-                                              uint32_t *len,
-                                              ADMImage *data,
-                                              uint32_t *flags)
-{
- if(frame&gt;= _info.nb_frames) return 0;
-								
-  // read uncompressed frame
-  if(!_in-&gt;getFrameNumberNoAlloc(frame, len, _uncompressed, flags)) return 0;
-
-  
-  do_rotate(_uncompressed,data,_param-&gt;angle);
-
-  //printf(&quot;%ld,%ld\n&quot;, _info.width, _info.height);
-
-  *flags=_uncompressed-&gt;flags;
-  *len= (_info.width * _info.height) + ((_info.width * _info.height) / 2);
-   data-&gt;copyInfo(_uncompressed);	
-  return 1;
-}
-
-void do_rotate(ADMImage *source,ADMImage *target,uint32_t angle)
-{
-uint8_t *in;
-uint32_t in_w,in_h;
-
-in=source-&gt;data;
-in_w=source-&gt;_width;
-in_h=source-&gt;_height;
-
-uint32_t x, y;
-uint32_t u_offset = (in_w * in_h);
-uint32_t v_offset = u_offset + (in_w/2 * in_h/2);
-uint32_t in_sub_w = in_w/2;
-uint32_t in_sub_h = in_h/2;
-uint32_t out_sub_w, out_sub_h;
-
-uint8_t *out=target-&gt;data;
-uint32_t *out_w=&amp;(target-&gt;_width);
-uint32_t *out_h=&amp;(target-&gt;_height);
-
-ADM_assert(in_w*in_h==(*out_w)*(*out_h));
-
-// In general, for 0 &lt;= i &lt; width and 0 &lt;= j &lt; height, the pixel (x + i, y + j) is colored with red value 
-// red value   rgb_buf[(j * rowstride) + (i * 3) + 0], 
-// green value rgb_buf[(j * rowstride) + (i * 3) + 1], 
-// blue value  rgb_buf[(j * rowstride) + (i * 3) + 2].
-
-        switch(angle)
-        {
-        case 0:
-                *out_w = in_w;
-                *out_h = in_h;
-                out_sub_w = *out_w/2;
-                out_sub_h = *out_h/2;
-            
-                for(x = 0; x &lt; *out_w; x++)
-                for(y = 0; y &lt; *out_h; y++)
-                    *(out + (*out_w * y) + x) = *(in + (in_w * y) + x);
-            
-                for(x = 0; x &lt; out_sub_w; x++)
-                for(y = 0; y &lt; out_sub_h; y++)
-                {
-                    *(out + u_offset + (out_sub_w * y) + x) = *(in + u_offset + (in_sub_w * y) + x);
-                    *(out + v_offset + (out_sub_w * y) + x) = *(in + v_offset + (in_sub_w * y) + x);
-                }
-                break;
-        case 90:
-        {
-            *out_w = in_h;
-            *out_h = in_w;
-            out_sub_w = *out_w/2;
-            out_sub_h = *out_h/2;
-        
-            for(x = 0; x &lt; *out_w; x++)
-            for(y = 0; y &lt; *out_h; y++)
-                *(out + (*out_w * y) + x) = *(in + (in_w * (in_h-x-1)) + y);
-        
-            for(x = 0; x &lt; out_sub_w; x++)
-            for(y = 0; y &lt; out_sub_h; y++)
-            {
-                *(out + u_offset + (out_sub_w * y) + x) = *(in + u_offset + (in_sub_w * (in_sub_h-x-1)) + y);
-                *(out + v_offset + (out_sub_w * y) + x) = *(in + v_offset + (in_sub_w * (in_sub_h-x-1)) + y);
-            }
-        }
-        break;
-        case 180:
-        {
-            *out_w = in_w;
-            *out_h = in_h;
-            out_sub_w = *out_w/2;
-            out_sub_h = *out_h/2;
-        
-            for(x = 0; x &lt; *out_w; x++)
-            for(y = 0; y &lt; *out_h; y++)
-                *(out + (*out_w * y) + x) = *(in + (in_w * (in_h-y-1)) + in_w-x-1);
-        
-        
-            for(x = 0; x &lt; out_sub_w; x++)
-            for(y = 0; y &lt; out_sub_h; y++)
-                {
-                *(out + u_offset + (out_sub_w * y) + x) = *(in + u_offset + (in_sub_w * (in_sub_h-y-1)) + in_sub_w-x-1);
-                *(out + v_offset + (out_sub_w * y) + x) = *(in + v_offset + (in_sub_w * (in_sub_h-y-1)) + in_sub_w-x-1);
-                }
-        }
-            break;
-        case 270:
-        {
-            *out_w = in_h;
-            *out_h = in_w;
-            out_sub_w = *out_w/2;
-            out_sub_h = *out_h/2;
-        
-            for(x = 0; x &lt; *out_w; x++)
-            for(y = 0; y &lt; *out_h; y++)
-                *(out + (*out_w * y) + x) = *(in + (in_w * x) + (in_w-y-1));
-        
-            for(x = 0; x &lt; out_sub_w; x++)
-            for(y = 0; y &lt; out_sub_h; y++)
-            {
-                *(out + u_offset + (out_sub_w * y) + x) = *(in + u_offset + (in_sub_w * x) + (in_sub_w-y-1));
-                *(out + v_offset + (out_sub_w * y) + x) = *(in + v_offset + (in_sub_w * x) + (in_sub_w-y-1));
-            }
-        }
-        break;
-        default:
-            ADM_assert(0);
-        }
-}
-uint8_t ADMVideoRotate::configure( AVDMGenericVideoStream *instream)
-{
-  uint8_t r;
-  
-  diaMenuEntry rotateValues[]={
-      {0,QT_TR_NOOP(&quot;None&quot;),QT_TR_NOOP(&quot;None&quot;)},
-      {90,QT_TR_NOOP(&quot;90 degrees&quot;),QT_TR_NOOP(&quot;90&#176;&quot;)},
-      {180,QT_TR_NOOP(&quot;180 degrees&quot;),QT_TR_NOOP(&quot;180&#176;&quot;)},
-      {270,QT_TR_NOOP(&quot;270 degrees&quot;),QT_TR_NOOP(&quot;270&#176;&quot;)}
-  };
-  diaElemMenu     rotate(&amp;(_param-&gt;angle),QT_TR_NOOP(&quot;_Angle:&quot;),4,rotateValues,NULL);
-  diaElem *allWidgets[]={&amp;rotate};
-  if( !diaFactoryRun(QT_TR_NOOP(&quot;Rotate&quot;),1,allWidgets)) return 0;
-  
-  uint32_t w,h;
-  w=_in-&gt;getInfo()-&gt;width;
-  h=_in-&gt;getInfo()-&gt;height;
-  if((_param-&gt;angle%180)==90)
-  {
-    _info.width=_param-&gt;width=h;
-    _info.height=_param-&gt;height=w;
-  }else
-  {
-      _info.width=_param-&gt;width=w;
-      _info.height=_param-&gt;height=h;
-  }
-  return 1;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTDeint_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTDeint_param.h	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTDeint_param.h	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,314 +0,0 @@
-#ifndef ADM_VID_TDEINT_PARAM_H
-#define ADM_VID_TDEINT_PARAM_H
-typedef struct TDEINT_PARAM
-{
-    
-/*  mode:
-  
-      Sets the mode of operation.  Modes -2 and -1 require progressive input.
-
-         -2 - double height using modified ELA
-         -1 - double height using modified ELA-2
-          0 - same rate output
-          1 - double rate output (bobbing)
-
-      default -  0  (int)  &gt;&gt;&gt;&gt;&gt;&gt;&gt;FOR AVIDEMUX ONLY 0 IS SUPPORTED &lt;&lt;&lt;&lt;
-*/
-	int32_t mode; //int
-	
-/*
-      Sets the field order of the video.
-
-        -1 - use parity from AviSynth
-         0 - bottom field first (bff)
-         1 - top field first (tff)
-     
-      default -  -1  (int)
-      */
-	int32_t order; // int
-
-
-/*
-      When in mode 0, this sets the field to be interpolated (i.e. the other field is kept as 
-      is and this field will be constructed).  When in mode 1 this setting does nothing.
-
-        -1 - will set field to 1 if hints = false or 0 if hints is set to true
-         0 - interpolate top field (keep bottom field)
-         1 - interpolate bottom field (keep top field)
-  
-      default -  -1  (int)
-
-*/
-	int32_t field; //int
-/*
-   mthreshL/mthreshC:
-
-      The motion thresholds for luma and chroma (mthreshL for luma, mthreshC for chroma). If
-      the difference between two pixels is less then this value they are declared static.
-      Smaller values will reduce residual combing, larger values will decrease flicker and
-      increase the accuracy of field construction in static areas.  The spatially corresponding
-      parts of the luma and chroma planes are linked (if link != 0), so mthreshC and mthreshL 
-      may be somewhat interconnected.  Setting both values to 0 or below will disable motion 
-      adaptation (i.e. every pixel will be declared moving) allowing for a dumb bob.
-
-      default - mthreshL - 6  (int)
-                mthreshC - 6
-
-
-		*/
-	uint32_t mthreshL,mthreshC; //int
-/*
-	 map:
-
-      Displays an output map instead of the deinterlaced frame.  There are three possible
-      options.  **Note: the maps will not be displayed if the current frame is not being 
-      deinterlaced due to overrides, hints, full=false, or tryWeave=true.
-
-      **AP post-processing is currently not taken into account when using map = 1 or 2.
-
-         0 - no map
-         1 - value (binary) map.  This will output a frame in which all the pixels
-             have one of the following values (indicating how the frame is to be
-             constructed):
-                 0   (use pixel from current frame)
-                 51  (use pixel from previous frame)
-                 102 (use pixel from next frame)
-                 153 (use average of curr/next)
-                 204 (use average of curr/prev)
-                 255 (interpolate pixel)
-         2 - merged map.  This will output a frame in which all the static parts of the 
-             frame (values 0, 51, 102, 153, and 204 from map=1) have been constructed 
-             as they would appear in the deinterlaced frame, and the pixels that are to be 
-             interpolated are marked in white.
-
-      default - 0  (int)
-*/
-	uint32_t map; //int
-	/*
-	   type:
-
-      Sets the type of interpolation to use.  Cubic is the fastest, modified ELA and ELA2 will give
-      smoother, less &quot;jaggy&quot;, edges and are the slowest (ELA2 is faster), and kernel interpolation 
-      will cause significantly less flickering then cubic or ela when interpolation gets used in 
-      almost static areas.  Modified ELA/ELA2 works best with anime/cartoon type material... it is not
-      that great with real life sources (sometimes it is, test for yourself).
-
-         0 - cubic interpolation
-         1 - modified ELA interpolation
-         2 - kernel interpolation (can be normal or sharp, controlled by the sharp setting)
-         3 - modified ELA-2 interpolation
-
-      default - 2  (int)
-      */
-	uint32_t type; //
-/*
-	  debug:
-
-      Will enable debug output, which for each frame will list the values of order, field, 
-      mthreshL, mthreshC, and type if the frame is being deinterlaced.  If the frame is
-      not being deinterlaced (due to user overrides, hints, or full=false) it will simply 
-      say the frame is not being deinterlaced and list the specific reason. If the output
-      frame is weaved, then debug output will report which field the current field was
-      weaved with (PREV or NEXT).
-
-      default - false  (bool)
-      */
-	uint32_t debug; // int
-	/*
- mtnmode:
-
-      Controls whether a 4 field motion check or a 5 field motion check is used.  5 field 
-      will prevent more artifacts and can deal with duplicate interlaced frames, however
-      it is quite a bit slower then the 4 field motion check.  Modes 2 and 3 are like 0 and
-      1 except that in areas where an average of the prev and next field would have been
-      used in mode 0 or 1, the pixel value from the most similar field (computed via field 
-      differencing) is used instead (i.e. no averages are used).
-
-         0 - 4 field check
-         1 - 5 field check
-         2 - 4 field check (no averages, replace with most similar field)
-         3 - 5 field check (no averages, replace with most similar field)
-
-      default - 1  (int)
-*/
-	uint32_t mtnmode;
-/*
-   sharp:
-
-      Controls whether the sharp or normal kernel is used when using kernel interpolation (type
-      = 2).  The sharp kernel includes more pixels and produces a sharper result, but is
-      slightly slower.
- 
-         true - use sharp kernel
-         false - use normal kernel
-
-      default - true  (bool)
-*/
-	uint32_t sharp;
-	/*
-	  full:
-
-      If full is set to true, then all frames are processed as usual.  If full=false, all frames
-      are first checked to see if they are combed.  If a frame isn't combed then it is returned 
-      as is.  If a frame is combed then it is processed as usual.  The parameters that effect 
-      combed frame detection are cthresh, chroma, blockx, blocky, and MI.  Full=false allows 
-      TDeint to be an ivtc post-processor without the need for hints.
-
-         true - normal processing
-         false - check all input frames for combing first
-  
-      default - true  (bool)
-      */
-	uint32_t full;
-	/*
- cthresh:
-
-      Area combing threshold used for combed frame detection.  It is like dthresh or dthreshold
-      in telecide() and fielddeinterlace().  This essentially controls how &quot;strong&quot; or &quot;visible&quot;
-      combing must be to be detected.  Good values are from 6 to 12, if you know your source has 
-      a lot of combed frames set this towards the low end (6-7), if you know your source has
-      very few combed frames set this higher (10-12).  Going much lower then 5 to 6 or much 
-      higher then 12 is not recommended.
-
-      default - 6  (int)
-*/
-	uint32_t cthresh;
-/*
-   blockx -
-
-      Sets the x-axis size of the window used during combed frame detection.  This has to do with 
-      the size of the area in which MI number of pixels are required to be detected as combed for 
-      a frame to be declared combed.  See the MI parameter description for more info.  Possible 
-      values are any number that is a power of 2 starting at 4 and going to 2048 (i.e. 4, 8, 16, 
-      32, ... 2048).
-
-      Default:  16  (int)
-*/
-	uint32_t blockx;
-/*
-   blocky -
-
-      Sets the y-axis size of the window used during combed frame detection.  This has to do with 
-      the size of the area in which MI number of pixels are required to be detected as combed for 
-      a frame to be declared combed.  See the MI parameter description for more info.  Possible 
-      values are any number that is a power of 2 starting at 4 and going to 2048 (i.e. 4, 8, 16, 
-      32, ... 2048).
-
-      Default:  16  (int)
-*/
-	uint32_t blocky;
- /* 
-   chroma:
-
-      Includes chroma combing in the decision about whether a frame is combed.  Only use this if
-      you have one of those weird sources where the chroma can be temporally separated from the luma
-      (i.e. the chroma moves but the luma doesn't in a field).  Otherwise it will just end up 
-      screwing up the decision most of the time.
-
-         true - include chroma combing
-         false - don't
- 
-      default - false  (bool)
-      */
-	uint32_t chroma;
-/*
-	 MI:
-
-      # of combed pixels inside any of the blockx by blocky sized blocks on the frame for the 
-      frame to be considered combed.  While cthresh controls how &quot;visible&quot; or &quot;strong&quot; the combing 
-      must be, this setting controls how much combing there must be in any localized area (a 
-      blockx by blocky sized window) on the frame.  Min setting = 0, max setting = blockx x blocky
-      (at which point no frames will ever be detected as combed).
-
-      default - 64  (int)
-*/
-	uint32_t MI;
-/*
-   tryWeave:
-
-      If set to true, when TDeint deinterlaces a frame it will first calculate which field
-      (PREV or NEXT) is most similar to the current field.  It will then weave this field
-      to create a new frame and check this new frame for combing.  If the new frame is not
-      combed, then it returns it. If it is, then it deinterlaces using the usual per-pixel
-      motion adaptation.  Basically, this setting allows TDeint to try to use per-field
-      motion adaptation instead of per-pixel motion adaptation where possible.
-
-      default - false  (bool)
-*/
-	uint32_t tryWeave;
-  /* 
-   link:
-
-      Controls how the three planes (YUV) are linked during comb map creation. Possible
-      settings:
-
-        0 - no linking
-        1 - Full linking (each plane to every other)
-        2 - Y to UV (luma to chroma)
-        3 - UV to Y (chroma to luma)
-
-      default - 2  (int)
-*/
-	uint32_t link;
-/*
-   denoise:
-
-      Controls whether the comb map is denoised or not.  True enables denoising, false disables.
-
-      default - true  (bool)
-*/
-	uint32_t denoise;
-/*
-   AP:
-
-      Artifact protection threshold.  If AP is set to a value greater than or equal to 0, then
-      before outputting a deinterlaced frame TDeint will scan all weaved pixels to see if any
-      create a value greater then AP.  Any pixels that do will be interpolated.  Use this to
-      help prevent very obvious motion adaptive related artifacts, a large value is recommended
-      (25+, or as large as removes the artifacts that can be seen during full-speed playback) as 
-      smaller values will destroy the benefits of motion adaptivity in static, detailed areas.
-      The AP metric is the same as the cthresh metric so the scale is 0-255... at zero everything
-      but completely flat areas will be detected as combing, at 255 nothing will be detected.
-      Using AP will slow down processing. Set AP to a value less then 0 or greater than
-      254 to disable.
-
-      default - -1 (disabled)  (int)
-
-*/
-	int32_t AP;
-	/*
-   APType
-
-      When AP post-processing is being used (AP is set &gt;= 0 and &lt; 255), APType controls whether
-      the motion of surrounding pixels should be taken into account.  There are 3 possible 
-      settings:
-
-        0 = Don't take surrounding motion into account.  If a weaved pixel creates a value that
-            exceeds the AP threshold then it will be interpolated.
-
-        1 = If a weaved pixel creates a value that exceeds the AP threshold and at least half of
-            pixels in a 5x5 window centered on that pixel were detected as moving, then that
-            pixel will be interpolated.
-
-        2 = Exactly like 1, except instead of 1/2 only 1/3 of the pixels in the surrounding 5x5 
-            window must have been detected as moving.
-
-      Modes 1 and 2 provide a way to catch more artifacts (low AP values) without completely 
-      sacrificing static areas.
-
-
-      default -  1  (int)
-         */
-	uint32_t APType;
-
-}TDEINT_PARAM;
-#endif
-//EOF
-
-
-
-
-
-
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,835 +0,0 @@
-
-/***************************************************************************
-                         
-        Tdeint
-
-    copyright            : Tritical, ported to avidemux by mean
-   <A HREF="http://bengal.missouri.edu/~kes25c/">http://bengal.missouri.edu/~kes25c/</A>
- ***************************************************************************/
-/*
-**                TDeinterlace v1.0b4 for AviSynth 2.5.x
-**
-**   TDeinterlace is a bi-directionally motion adaptive deinterlacer.
-**   It also uses a couple modified forms of ela interpolation which 
-**   help to reduce &quot;jaggy&quot; edges in places where interpolation must 
-**   be used. TDeinterlace currently supports YV12 and YUY2 colorspaces.
-**   
-**   Copyright (C) 2004-2005 Kevin Stone
-**
-**   This program is free software; you can redistribute it and/or modify
-**   it under the terms of the GNU General Public License as published by
-**   the Free Software Foundation; either version 2 of the License, or
-**   (at your option) any later version.
-**
-**   This program is distributed in the hope that it will be useful,
-**   but WITHOUT ANY WARRANTY; without even the implied warranty of
-**   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**   GNU General Public License for more details.
-**
-**   You should have received a copy of the GNU General Public License
-**   along with this program; if not, write to the Free Software
-**   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &lt;math.h&gt;
-
-
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-#include &quot;DIA_factory.h&quot;
-
-
-#define min MIN
-#define max MAX
-
-#define MIN(a,b) a&lt;b ? a : b
-#define MAX(a,b) b&lt;a ? a : b
-#define child_GetParity(x) 0 //FIXME!!
-
-#define OutputDebugString(img,y,text) drawString(img, 0, y, text)
-
-
-#include &quot;ADM_vidTDeint_param.h&quot;
-#define PRM(x) x
-class vidTDeint:public AVDMGenericVideoStream
-{
-
-protected:
-virtual char          *printConf (void);
-VideoCache            *vidCache;
-ADMImage              *rebuild,*scratch,*scratch2;
-TDEINT_PARAM          *_param;
-/* Will go to param */
-int mode, order, field, ovrDefault, type, mtnmode;
-	int mthreshL, mthreshC, map, cthresh, MI, link;
-	int countOvr, nfrms, nfrms2, orderS, fieldS;
-	int mthreshLS, mthreshCS, typeS, cthresh6, AP;
-	int xhalf, yhalf, xshift, yshift, blockx, blocky;
-	int mntmode;
-	
-	int *input, *cArray, APType;
-	unsigned int passHint;
-	unsigned long accumN, accumP;
-	bool debug, sharp, hints, full, chroma;
-	bool autoFO, useClip2, tryWeave, denoise;
-	const char* ovr;
-	char buf[120];
-/* Will go to param */
-void  copyFrame(ADMImage *dst,ADMImage *src);
-
-unsigned char         cubicInt(unsigned char p1, unsigned char p2, unsigned char p3,unsigned char p4);
-void  copyForUpsize(ADMImage *dst, ADMImage *src, int np);
-void  setMaskForUpsize(ADMImage *msk, int np);
-void  createMotionMapYV12(ADMImage *prv2, ADMImage *prv, 
-	                       ADMImage *src, ADMImage *nxt, ADMImage *nxt2, ADMImage *mask, int n);
-void  createMotionMap2YV12(ADMImage *prv2, ADMImage *prv, 
-	                       ADMImage *src, ADMImage *nxt, ADMImage *nxt2, ADMImage *mask, int n)	;
-void  linkFULL_YV12(ADMImage *mask) ;	
-void  linkYtoUV_YV12(ADMImage *mask)  ;                                               
-void  linkUVtoY_YV12(ADMImage *mask) ;
-void  denoiseYV12(ADMImage *mask) ;
-bool  checkCombedYV12(ADMImage *src) ;
-void  subtractFieldsYV12(ADMImage *prv, ADMImage *src, ADMImage *nxt) ;
-void  mapColorsYV12(ADMImage *dst, ADMImage *mask);
-void  mapMergeYV12(ADMImage *dst, ADMImage *mask, 
-		ADMImage *prv, ADMImage *src, ADMImage *nxt);
-void  cubicDeintYV12(ADMImage *dst, ADMImage *mask, 
-		ADMImage *prv, ADMImage *src, ADMImage *nxt);
-void  ELADeintYV12(ADMImage *dst, ADMImage *mask, 
-		ADMImage *prv, ADMImage *src, ADMImage *nxt);
-void  kernelDeintYV12(ADMImage *dst, ADMImage *mask, 
-		ADMImage *prv, ADMImage *src, ADMImage *nxt);
-void  smartELADeintYV12(ADMImage *dst, ADMImage *mask, 
-		ADMImage *prv, ADMImage *src, ADMImage *nxt);
-void  createWeaveFrameYV12(ADMImage *dst, ADMImage *prv, 
-		ADMImage *src, ADMImage *nxt);
-int  getHint(ADMImage *src, unsigned int &amp;storeHint, int &amp;hintField);
-void putHint(ADMImage *src, unsigned int hint, int fieldt);
-void apPostCheck(ADMImage *dst, ADMImage *mask);
-void reset(void);
-public:
-
-                        vidTDeint (AVDMGenericVideoStream * in, CONFcouple * setup);
-        virtual         ~vidTDeint ();
-virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
-                                        ADMImage * data, uint32_t * flags);
-uint8_t configure (AVDMGenericVideoStream * instream);
-virtual uint8_t getCoupledConf (CONFcouple ** couples);
-
-};
-
-static FILTER_PARAM tdeint_template =
-  { 21,
-&quot;mode&quot;,
-&quot;order&quot;,
-&quot;field&quot;,
-&quot;mthreshL&quot;,
-&quot;mthreshC&quot;,
-&quot;map&quot;,
-&quot;type&quot;,
-&quot;debug&quot;,
-&quot;mtnmode&quot;,
-&quot;sharp&quot;,
-&quot;full&quot;,
-&quot;cthresh&quot;,
-&quot;blockx&quot;,
-&quot;blocky&quot;,
-&quot;chroma&quot;,
-&quot;MI&quot;,
-&quot;tryWeave&quot;,
-&quot;link&quot;,
-&quot;denoise&quot;,
-&quot;AP&quot;,
-&quot;APType&quot;
-
-  };
-
-BUILD_CREATE (tdeint_create, vidTDeint);
-SCRIPT_CREATE (tdeint_script, vidTDeint, tdeint_template);
-
-
-
-#include &quot;ADM_vidTdeint_util.txt&quot;
-extern uint8_t  DIA_tdeint(TDEINT_PARAM *param);
-//*************************************
-uint8_t vidTDeint::configure (AVDMGenericVideoStream * in)
-{
-uint8_t r;
-        r= DIA_tdeint(_param);
-        if(r) reset();
-        return r;
-}
-/*************************************/
-char *vidTDeint::printConf (void)
-{
-  static char buf[50];
-  sprintf ((char *) buf, &quot; Tritical TDeint&quot;);
-  return buf;
-}
-
-#define MAX_BLOCKS 50
-/*************************************/
-vidTDeint::vidTDeint (AVDMGenericVideoStream * in, CONFcouple * couples)
-{
-
-  _in = in;
-  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
-  _info.encoding = 1;
-  vidCache = new VideoCache (10, in);
-  _uncompressed=new ADMImage(_info.width,_info.height);
-  scratch=new ADMImage(_info.width,_info.height);
-  scratch2=new ADMImage(_info.width,_info.height);
-
-  	input = cArray = NULL;
-  _param=new TDEINT_PARAM;
-  if(!couples)
-  {
-  
-                _param-&gt;mode=0;
-                _param-&gt;order=-1;
-                _param-&gt;field=-1;
-                _param-&gt;mthreshL=6;
-                _param-&gt;mthreshC=6;
-                _param-&gt;map=0;
-                _param-&gt;type=2;
-                _param-&gt;debug=0;
-                _param-&gt;mtnmode=1;
-                _param-&gt;sharp=1;
-                _param-&gt;full=1;
-                _param-&gt;cthresh=6;
-                _param-&gt;blockx=16;
-                _param-&gt;blocky=16;
-                _param-&gt;chroma=0;
-                _param-&gt;MI=64;
-                _param-&gt;tryWeave=false;
-                _param-&gt;link=2;
-                _param-&gt;denoise=true;
-                _param-&gt;AP=254;
-                _param-&gt;APType=1;
-  }
-  else
-  {
-                GET(mode);
-                GET(order);
-                GET(field);
-                GET(mthreshL);
-                GET(mthreshC);
-                GET(map);
-                GET(type);
-                GET(debug);
-                GET(mtnmode);
-                GET(sharp);
-                GET(full);
-                GET(cthresh);
-                GET(blockx);
-                GET(blocky);
-                GET(chroma);
-                GET(MI);
-                GET(tryWeave);
-                GET(link);
-                GET(denoise);
-                GET(AP);
-                GET(APType);
-
-  
-  
-  }
-
-    order=1;
-    orderS=1;
-    mode=0;
-    field=0;
-    fieldS=0;
-    mthreshL=6;
-    mthreshLS=6;
-    mthreshC=6;
-    mthreshCS=6;
-    map=0;
-    ovrDefault=0;
-    type=2; // kernel deint
-    debug=true;
-    mntmode=1;
-    mtnmode=1;
-    sharp=true;
-    hints=false;
-    full=false;
-    cthresh=12;
-    ovr=NULL;
-    input=NULL;
-    blocky=16;
-    blockx=16;
-    chroma=false;
-    MI=64;
-    tryWeave=false;
-    link=2;
-    AP=254;
-    APType=254;
-    
-    reset();
-
-}
-void vidTDeint::reset (void)
-{
-
-#define CLONE(x) x=_param-&gt;x
-CLONE(mode);
-CLONE(order);
-CLONE(field);
-CLONE(mthreshL);
-CLONE(mthreshC);
-CLONE(map);
-CLONE(type);
-CLONE(debug);
-CLONE(mtnmode);
-CLONE(sharp);
-CLONE(full);
-CLONE(cthresh);
-CLONE(blockx);
-CLONE(blocky);
-CLONE(chroma);
-CLONE(MI);
-CLONE(tryWeave);
-CLONE(link);
-CLONE(denoise);
-CLONE(AP);
-CLONE(APType);
-
-orderS=order;
-fieldS=field;
-mthreshLS=  mthreshL;
-mthreshCS=mthreshC;
-
-
-         xhalf = blockx &gt;&gt; 1;
-        yhalf = blocky &gt;&gt; 1;
-        xshift = blockx == 4 ? 2 : blockx == 8 ? 3 : blockx == 16 ? 4 : blockx == 32 ? 5 :
-                blockx == 64 ? 6 : blockx == 128 ? 7 : blockx == 256 ? 8 : blockx == 512 ? 9 : 
-                blockx == 1024 ? 10 : 11;
-        yshift = blocky == 4 ? 2 : blocky == 8 ? 3 : blocky == 16 ? 4 : blocky == 32 ? 5 :
-                blocky == 64 ? 6 : blocky == 128 ? 7 : blocky == 256 ? 8 : blocky == 512 ? 9 : 
-                blocky == 1024 ? 10 : 11;
-        if (((!full &amp;&amp; mode == 0) || tryWeave) &amp;&amp; mode &gt;= 0)
-        {
-        int sz;
-        
-        sz=(((_info.width+xhalf)&gt;&gt;xshift)+1)*(((_info.height+yhalf)&gt;&gt;yshift)+1)*4;
-                if(cArray) delete [] cArray;
-                cArray = new int[sz];;
-                
-        }
-        
-        nfrms = nfrms2 = _info.nb_frames - 1;
-        accumP = accumN = 0;
-        cthresh6 = cthresh * 6;
-        passHint = 0xFFFFFFFF;
-        autoFO = false;
-        if (order == -1) autoFO = true;
-#if 0
-        if (mode &lt; 0) 
-        {
-                _info.height *= 2;
-                field = 1;
-        }
-        
-        if (mode == 1)
-        {
-                vi.num_frames *= 2;
-                nfrms2 = vi.num_frames - 1;
-                vi.SetFPS(vi.fps_numerator*2, vi.fps_denominator);
-        }
-        else
-#endif   
-        if (field == -1 &amp;&amp; mode!=1)
-        {
-                // telecide matches off the bottom field so we want field=0 in that case.
-                // tfm can match off top or bottom, but it will indicate which in its hints
-                // and field is adjusted appropriately then... so we use field=0 by default
-                // if hints=true.  Otherwise, if hints=false, we default to field = 1.
-                if (hints) field = 0;
-                else field = 1;
-        }
-        orderS = order; 
-        fieldS = field; 
-        mthreshLS = mthreshL; 
-        mthreshCS = mthreshC;
-        typeS = type;
-#if 0
-        if (debug)
-        {
-                sprintf(buf,&quot;TDeint:  %s (%s) by tritical\n&quot;, &quot;B4&quot;, &quot;08 2005&quot;);
-                OutputDebugString(buf);
-                sprintf(buf,&quot;TDeint:  mode = %d (%s)\n&quot;, mode, mode == 0 ? &quot;normal - same rate&quot; : 
-                                mode == 1 ? &quot;bob - double rate&quot; : mode == -2 ? &quot;upsize - ELA&quot; : &quot;upsize - ELA-2&quot;);
-                OutputDebugString(buf);
-        }
-#endif
-}
-//____________________________________________________________________
-vidTDeint::~vidTDeint ()
-{
-
-  delete vidCache;
-  vidCache = NULL;
-  delete _uncompressed;
-  _uncompressed=NULL;
-  delete scratch;
-  scratch=NULL;
-  delete scratch2;
-  scratch2=NULL;
-  if(cArray) delete [] cArray;
-  cArray=NULL;
-}
-
-
-
-
-
-
-uint8_t vidTDeint::getCoupledConf (CONFcouple ** couples)
-{
-
-  ADM_assert (_param);
-  *couples = new CONFcouple (21);
-#undef CSET
-#define CSET(x)  (*couples)-&gt;setCouple(#x,(_param-&gt;x))
-CSET(mode);
-CSET(order);
-CSET(field);
-CSET(mthreshL);
-CSET(mthreshC);
-CSET(map);
-CSET(type);
-CSET(debug);
-CSET(mtnmode);
-CSET(sharp);
-CSET(full);
-CSET(cthresh);
-CSET(blockx);
-CSET(blocky);
-CSET(chroma);
-CSET(MI);
-CSET(tryWeave);
-CSET(link);
-CSET(denoise);
-CSET(AP);
-CSET(APType);
-
-  return 1;
-}
-
-//***************************************************
-uint8_t vidTDeint::getFrameNumberNoAlloc (uint32_t n,
-                                uint32_t * len,
-                                ADMImage * data, uint32_t * flags)
-{
-
-	int nfrms=_info.nb_frames;
-	ADMImage *srcP,*srcN,*src,*final,*display;
-        float distMerged, distN,distP,distM,distR,skip=0;
-        char txt[255];
-
-        if(n&gt;= _info.nb_frames) return 0;
-        if(n&lt;1 || n&gt;_info.nb_frames-3 )
-        {
-                skip=1;
-        }
-        
-        
-        if(skip)
-        {
-                data-&gt;duplicate(vidCache-&gt;getImage(n));
-                vidCache-&gt;unlockAll();
-                return 1;
-        }
-      
-	if (mode &lt; 0)
-	{
-		//PVideoFrame src2up = child-&gt;GetFrame(n, env);
-		//mask2up=new ADMImage(_info.width,_info.height);
-		ADMImage *src2up;
-		src2up=vidCache-&gt;getImage(n);
-		ADMImage *msk2up=scratch;
-		if(!src2up) return 0;
-		//PVideoFrame dst2up = env-&gt;NewVideoFrame(vi);
-		//PVideoFrame msk2up = env-&gt;NewVideoFrame(vi);
-		copyForUpsize(data, src2up, 3);
-		setMaskForUpsize(msk2up, 3);
-		if (mode == -2) smartELADeintYV12(data, msk2up, data, data, data);
-		else if (mode == -1) ELADeintYV12(data, msk2up, data, data, data);
-		//return dst2up;
-		//delete mask2up;
-		vidCache-&gt;unlockAll();
-		return 1;
-	}
-	if (mode == 1)
-	{
-		if (autoFO) PRM(order) = child_GetParity(n&gt;&gt;1) ? 1 : 0;
-		if (n&amp;1) PRM(field) = PRM(order) == 1 ? 0 : 1;
-		else PRM(field) = PRM(order);
-		n &gt;&gt;= 1;
-	}
-	else if (autoFO) PRM(order) = child_GetParity(n) ? 1 : 0;
-	//PVideoFrame prv2, prv, nxt, nxt2, dst, mask;
-	//PVideoFrame src = child-&gt;GetFrame(n, env);
-	src=vidCache-&gt;getImage(n);
-	if(!src)
-	{
-        vidCache-&gt;unlockAll();
-        return 0;	
-	}
-	ADMImage *prv2,*prv,*nxt,*nxt2,*dst,*mask;
-	bool found = false, fieldOVR = false;
-	int x, hintField = -1;
-	passHint = 0xFFFFFFFF;
-	if (input != NULL &amp;&amp; *ovr)
-	{
-		if (mode != 1) 
-		{
-			PRM(field) = PRM(fieldS); 
-			if (!autoFO) PRM(order) = PRM(orderS);
-		}
-		PRM(mthreshL) = PRM(mthreshLS);
-		mthreshC = mthreshCS;
-		type = typeS;
-		for (x=0; x&lt;countOvr; x+=4)
-		{
-			if (n &gt;= input[x+1] &amp;&amp; n &lt;= input[x+2])
-			{
-				if (input[x] == 45 &amp;&amp; mode != 1) // -
-				{
-					if (debug)
-					{
-						sprintf(buf,&quot;TD fr %d:  not deinterlacing\n&quot;, n);
-						OutputDebugString(data,0,buf);
-					}
-					data-&gt;duplicate(src);
-					vidCache-&gt;unlockAll();
-					return 1;
-					//return src;
-				}
-				else if (input[x] == 43 &amp;&amp; mode != 1) found = true;  // +
-				else if (input[x] == 102 &amp;&amp; mode != 1) { field = input[x+3]; fieldOVR = true; } // f
-				else if (input[x] == 111 &amp;&amp; mode != 1) PRM(order) = input[x+3]; // o
-				else if (input[x] == 108) mthreshL = input[x+3]; // l
-				else if (input[x] == 99) mthreshC = input[x+3]; // c
-				else if (input[x] == 116) type = input[x+3]; // t
-			}
-		}
-		if (!found &amp;&amp; ovrDefault == 1 &amp;&amp; mode != 1)
-		{
-			if (debug)
-			{
-				sprintf(buf,&quot;TD fr %d:  not deinterlacing\n&quot;, n);
-				OutputDebugString(data,0,buf);
-			}
-			data-&gt;duplicate(src);
-			vidCache-&gt;unlockAll();
-			return 1;
-			//return src;
-		}
-	}
-	if (mode == 0 &amp;&amp; hints &amp;&amp; vidTDeint::getHint(src, passHint, hintField) == 0 &amp;&amp; !found) 
-	{
-		if (debug)
-		{
-			sprintf(buf,&quot;TD fr %d:  not deinterlacing (HINTS)\n&quot;, n);
-			OutputDebugString(data,0,buf);
-		}
-		data-&gt;duplicate(src);
-			vidCache-&gt;unlockAll();
-			return 1;
-			//return src;
-	}
-	if (mode == 0 &amp;&amp; !full &amp;&amp; !found)
-	{
-		if (!checkCombedYV12(src))
-		{
-			if (debug)
-			{
-				sprintf(buf,&quot;TD fr %d:  not deinterlacing (full = false)\n&quot;, n);
-				OutputDebugString(data,0,buf);
-			}
-			data-&gt;duplicate(src);
-			vidCache-&gt;unlockAll();
-			return 1;
-			//return src;
-		}
-	}
-	if (!fieldOVR &amp;&amp; hintField &gt;= 0)
-	{
-		int tempf = field;
-		field = hintField;
-		hintField = tempf;
-	}
-	//if (!useClip2)
-	{
-		prv2 = vidCache-&gt;getImage(n&gt;1 ? n-2 : n&gt;0 ? n-1 : 0);//child-&gt;GetFrame(n&gt;1 ? n-2 : n&gt;0 ? n-1 : 0, env);
-		prv = vidCache-&gt;getImage(n&gt;0 ? n-1 : 0); //child-&gt;GetFrame(n&gt;0 ? n-1 : 0, env);
-		nxt = vidCache-&gt;getImage(n&lt;nfrms ? n+1: nfrms); //child-&gt;GetFrame(n&lt;nfrms ? n+1 : nfrms, env);
-		nxt2 = vidCache-&gt;getImage(n&lt;nfrms-1 ? n+2 : n&lt;nfrms ? n+1 : nfrms); //child-&gt;GetFrame(n&lt;nfrms-1 ? n+2 : n&lt;nfrms ? n+1 : nfrms, env);
-	}
-	
-	//dst = env-&gt;NewVideoFrame(vi);
-	dst=data;
-	if (type == 2 || mtnmode &gt; 1 || tryWeave) 
-	{
-		subtractFieldsYV12(prv, src, nxt);
-		if (debug)
-		{
-			sprintf(buf, &quot;TD fr %d:  accumP = %u  &quot;, n, accumP);
-			OutputDebugString(data,2,buf);
-			sprintf(buf, &quot;accumN = %u\n&quot;, accumN);
-			OutputDebugString(data,3,buf);
-		}
-	}
-	if (tryWeave &amp;&amp; (mode != 0 || full || found || (field^PRM(order) &amp;&amp; accumP &gt; accumN) || 
-			(!(field^PRM(order)) &amp;&amp; accumN &gt; accumP)))
-	{
-		createWeaveFrameYV12(dst, prv, src, nxt);
-		if (!checkCombedYV12(dst))
-		{
-			if (debug)
-			{
-				sprintf(buf,&quot;TD  fr %d:  weaved with %s (tryWeave)\n&quot;, n, 
-					field^PRM(order) ? (accumP &lt;= accumN ? &quot;CURR&quot; : &quot;NEXT&quot;) : 
-					(accumN &lt;= accumP ? &quot;CURR&quot; : &quot;PREV&quot;));
-				OutputDebugString(data,2,buf);
-			}
-			if (hintField &gt;= 0 &amp;&amp; !fieldOVR) field = hintField;
-			vidCache-&gt;unlockAll();
-			return 1;//dst;
-		}
-	}
-	mask =scratch2 ; // env-&gt;NewVideoFrame(vi);
-	if (mthreshL &lt;= 0 &amp;&amp; mthreshC &lt;= 0) setMaskForUpsize(mask, 3);
-	else if (mtnmode == 0 || mtnmode == 2) createMotionMapYV12(prv2, prv, src, nxt, nxt2, mask, n);
-	else if (mtnmode == 1 || mtnmode == 3) createMotionMap2YV12(prv2, prv, src, nxt, nxt2, mask, n);
-	else {ADM_assert(0);}
-	if (denoise) denoiseYV12(mask);
-	if (link == 1) linkFULL_YV12(mask);
-	else if (link == 2) linkYtoUV_YV12(mask);
-	else if (link == 3) linkUVtoY_YV12(mask);
-	else if (link != 0) {ADM_assert(0);}//env-&gt;ThrowError(&quot;TDeint:  an unknown error occured (link)!&quot;);
-	if (map == 1) mapColorsYV12(dst, mask);
-	else if (map == 2) mapMergeYV12(dst, mask, prv, src, nxt);
-	else if (type == 0) cubicDeintYV12(dst, mask, prv, src, nxt);
-	else if (type == 1) smartELADeintYV12(dst, mask, prv, src, nxt);
-	else if (type == 2) kernelDeintYV12(dst, mask, prv, src, nxt);
-	else if (type == 3) ELADeintYV12(dst, mask, prv, src, nxt);
-	else {ADM_assert(0);}//env-&gt;ThrowError(&quot;TDeint:  an unknown error occured!&quot;);
-	if (AP &gt;= 0 &amp;&amp; AP &lt; 255 &amp;&amp; map == 0) apPostCheck(dst, mask);
-	if (!(passHint&amp;0xFFFFFF00)) vidTDeint::putHint(dst, passHint, field);
-	if (debug)
-	{
-		sprintf(buf,&quot;TD  fr %d:  field = %s  order = %s\n&quot;, n, 
-			field == 1 ? &quot;bottom&quot; : &quot;top&quot;, PRM(order) == 1 ? &quot;tff&quot; : &quot;bff&quot;);
-		OutputDebugString(data,3,buf);
-		sprintf(buf,&quot;TD  fr %d:  mthreshL = %d  \n&quot;,n,mthreshL);
-		OutputDebugString(data,4,buf);
-		sprintf(buf,&quot;mthreshC = %d  type = %d\n&quot;, mthreshC, type);
-		OutputDebugString(data,5,buf);
-	}
-	if (hintField &gt;= 0 &amp;&amp; !fieldOVR) field = hintField;
-	vidCache-&gt;unlockAll();
-	return 1;
-	//return dst;
-}
-
-//********************************************************************************************
-//********************************************************************************************
-//********************************************************************************************
-//********************************************************************************************
-//********************************************************************************************
-//********************************************************************************************
-
-#if 0
-AVSValue __cdecl Create_TDeinterlace(AVSValue args, void* user_data, IScriptEnvironment* env)
-{
-	int mode = 0;
-	int order = -1;
-	int field = -1;
-	int mthreshL = 6;
-	int mthreshC = 6;
-	int map = 0;
-	char* ovr = &quot;&quot;;
-	int ovrDefault = 0;
-	int type = 2;
-	bool debug = false;
-	int mtnmode = 1;
-	bool sharp = true;
-	bool hints = false;
-	bool full = true;
-	int cthresh = 6;
-	bool chroma = false;
-	int MI = 64;
-	bool tryWeave = false;
-	int link = 2;
-	bool denoise = true;
-	int AP = -1;
-	int blockx = 16, blocky = 16;
-	int APType = 1;
-	if (args[0].IsClip())
-	{
-		unsigned int temp;
-		int tfieldHint;
-		if (!args[13].IsBool() &amp;&amp;
-			TDeinterlace::getHint(args[0].AsClip()-&gt;GetFrame(0,env), temp, tfieldHint) != -1)
-			hints = true;
-	}
-	PClip v;
-	if (args[14].IsClip())
-	{
-		v = args[14].AsClip();
-		try
-		{ 
-			v = env-&gt;Invoke(&quot;InternalCache&quot;, v).AsClip();
-			v-&gt;SetCacheHints(CACHE_RANGE, 4);
-		} 
-		catch (IScriptEnvironment::NotFound) {  }
-	}
-    return new TDeinterlace(args[0].AsClip(),args[1].AsInt(mode),args[2].AsInt(order),
-		args[3].AsInt(field),args[4].AsInt(mthreshL),args[5].AsInt(mthreshC),args[6].AsInt(map),
-		args[7].AsString(ovr),args[8].AsInt(ovrDefault),args[9].AsInt(type),args[10].AsBool(debug),
-		args[11].AsInt(mtnmode),args[12].AsBool(sharp),args[13].AsBool(hints),args[14].IsClip() ? v : NULL,
-		args[15].AsBool(full),args[16].AsInt(cthresh),args[17].AsBool(chroma),args[18].AsInt(MI),
-		args[19].AsBool(tryWeave),args[20].AsInt(link),args[21].AsBool(denoise),args[22].AsInt(AP),
-		args[23].AsInt(blockx),args[24].AsInt(blocky),args[25].AsInt(APType),env);
-}
-
-extern &quot;C&quot; __declspec(dllexport) const char* __stdcall AvisynthPluginInit2(IScriptEnvironment* env) 
-{
-    env-&gt;AddFunction(&quot;TDeint&quot;, &quot;c[mode]i[order]i[field]i[mthreshL]i[mthreshC]i[map]i[ovr]s[ovrDefault]i&quot; \
-		                       &quot;[type]i[debug]b[mtnmode]i[sharp]b[hints]b[clip2]c[full]b[cthresh]i&quot; \
-							   &quot;[chroma]b[MI]i[tryWeave]b[link]i[denoise]b[AP]i[blockx]i[blocky]i[APType]i&quot;, 
-							   Create_TDeinterlace, 0);
-	return 0;
-}
-TDeinterlace::TDeinterlace(PClip _child, int _mode, int _order, int _field, int _mthreshL, 
-	int _mthreshC, int _map, const char* _ovr, int _ovrDefault, int _type, bool _debug, 
-	int _mtnmode, bool _sharp, bool _hints, PClip _clip2, bool _full, int _cthresh, 
-	bool _chroma, int _MI, bool _tryWeave, int _link, bool _denoise, int _AP, 
-	int _blockx, int _blocky, int _APType, IScriptEnvironment* env) :
-GenericVideoFilter(_child), mode(_mode), order(_order), field(_field), mthreshL(_mthreshL), 
-	mthreshC(_mthreshC), map(_map), ovr(_ovr), ovrDefault(_ovrDefault), type(_type), 
-	debug(_debug), mtnmode(_mtnmode), sharp(_sharp), hints(_hints), clip2(_clip2), full(_full),
-	cthresh(_cthresh), chroma(_chroma), MI(_MI), tryWeave(_tryWeave), link(_link), 
-	denoise(_denoise), AP(_AP), blockx(_blockx), blocky(_blocky), APType(_APType)
-{
-	int z, w, q, b, i, track, count;
-	char linein[81];
-	char *linep;
-	FILE *f = NULL;         ***** order mode field map type mntmode 
-	input = cArray = NULL;
-	if (!vi.IsYV12() &amp;&amp; !vi.IsYUY2()) 
-		env-&gt;ThrowError(&quot;TDeint:  YV12 and YUY2 data only!&quot;);
-	if (mode != 0 &amp;&amp; mode != 1 &amp;&amp; mode != -1 &amp;&amp; mode != -2)
-		env-&gt;ThrowError(&quot;TDeint:  mode must be set to -2, -1, 0, or 1!&quot;);
-	if (order != 0 &amp;&amp; order != 1 &amp;&amp; order != -1)
-		env-&gt;ThrowError(&quot;TDeint:  order must be set to 0, 1, or -1!&quot;);
-	if (field != 0 &amp;&amp; field != 1 &amp;&amp; field != -1)
-		env-&gt;ThrowError(&quot;TDeint:  field must be set to 0, 1, or -1!&quot;);
-	if (map &lt; 0 || map &gt; 2)
-		env-&gt;ThrowError(&quot;TDeint:  map option must be set to 0, 1, or 2!&quot;);
-	if (ovrDefault != 0 &amp;&amp; ovrDefault != 1)
-		env-&gt;ThrowError(&quot;TDeint:  ovrDefault must be set to either 0 or 1!&quot;);
-	if (type != 0 &amp;&amp; type != 1 &amp;&amp; type != 2 &amp;&amp; type != 3)
-		env-&gt;ThrowError(&quot;TDeint:  type must be set to either 0, 1, 2, or 3!&quot;);
-	if (mtnmode &lt; 0 || mtnmode &gt; 3)
-		env-&gt;ThrowError(&quot;TDeint:  mtnmode must be set to either 0, 1, 2, or 3!&quot;);
-	if (vi.height&amp;1 || vi.width&amp;1)
-		env-&gt;ThrowError(&quot;TDeint:  width and height must be multiples of 2!&quot;);
-	if (link &lt; 0 || link &gt; 3)
-		env-&gt;ThrowError(&quot;TDeint:  link must be set to 0, 1, 2, or 3!&quot;);
-	if (blockx != 4 &amp;&amp; blockx != 8 &amp;&amp; blockx != 16 &amp;&amp; blockx != 32 &amp;&amp; blockx != 64 &amp;&amp; 
-		blockx != 128 &amp;&amp; blockx != 256 &amp;&amp; blockx != 512 &amp;&amp; blockx != 1024 &amp;&amp; blockx != 2048)
-		env-&gt;ThrowError(&quot;TDeint:  illegal blockx size!&quot;);
-	if (blocky != 4 &amp;&amp; blocky != 8 &amp;&amp; blocky != 16 &amp;&amp; blocky != 32 &amp;&amp; blocky != 64 &amp;&amp; 
-		blocky != 128 &amp;&amp; blocky != 256 &amp;&amp; blocky != 512 &amp;&amp; blocky != 1024 &amp;&amp; blocky != 2048)
-		env-&gt;ThrowError(&quot;TDeint:  illegal blocky size!&quot;);
-	if (APType &lt; 0 || APType &gt; 2)
-		env-&gt;ThrowError(&quot;TDeint:  APType must be set to 0, 1, or 2!&quot;);
-	child-&gt;SetCacheHints(CACHE_RANGE, 4);
-	//useClip2 = false;
-	if ((hints || !full) &amp;&amp; mode == 0 &amp;&amp; clip2)
-	{
-		const VideoInfo&amp; vi1 = clip2-&gt;GetVideoInfo();
-		if (vi1.height != vi.height || vi1.width != vi.width)
-			env-&gt;ThrowError(&quot;TDeint:  width and height of clip2 must equal that of the input clip!&quot;);
-		if (!vi1.IsYV12() &amp;&amp; !vi1.IsYUY2())
-			env-&gt;ThrowError(&quot;TDeint:  YV12 and YUY2 data only (clip2)!&quot;);
-		if ((vi.IsYV12() &amp;&amp; vi1.IsYUY2()) || (vi.IsYUY2() &amp;&amp; vi1.IsYV12()))
-			env-&gt;ThrowError(&quot;TDeint:  colorspace of clip2 doesn't match that of the input clip!&quot;);
-		if (vi.num_frames != vi1.num_frames)
-			env-&gt;ThrowError(&quot;TDeint:  number of frames in clip2 doesn't match that of the input clip!&quot;);
-		useClip2 = true;
-	}
-	xhalf = blockx &gt;&gt; 1;
-	yhalf = blocky &gt;&gt; 1;
-	xshift = blockx == 4 ? 2 : blockx == 8 ? 3 : blockx == 16 ? 4 : blockx == 32 ? 5 :
-		blockx == 64 ? 6 : blockx == 128 ? 7 : blockx == 256 ? 8 : blockx == 512 ? 9 : 
-		blockx == 1024 ? 10 : 11;
-	yshift = blocky == 4 ? 2 : blocky == 8 ? 3 : blocky == 16 ? 4 : blocky == 32 ? 5 :
-		blocky == 64 ? 6 : blocky == 128 ? 7 : blocky == 256 ? 8 : blocky == 512 ? 9 : 
-		blocky == 1024 ? 10 : 11;
-	if (((!full &amp;&amp; mode == 0) || tryWeave) &amp;&amp; mode &gt;= 0)
-	{
-		cArray = (int *)_aligned_malloc((((vi.width+xhalf)&gt;&gt;xshift)+1)*(((vi.height+yhalf)&gt;&gt;yshift)+1)*4*sizeof(int), 32);
-		if (cArray == NULL) env-&gt;ThrowError(&quot;TDeint:  malloc failure!&quot;);
-	}
-	if (vi.IsYUY2())
-	{
-		xhalf *= 2;
-		++xshift;
-	}
-	vi.SetFieldBased(false);
-	nfrms = nfrms2 = vi.num_frames - 1;
-	accumP = accumN = 0;
-	cthresh6 = cthresh * 6;
-	passHint = 0xFFFFFFFF;
-	autoFO = false;
-	if (mode &lt; 0) 
-	{
-		vi.height *= 2;
-		field = 1;
-	}
-	if (order == -1) autoFO = true;
-	if (mode == 1)
-	{
-		vi.num_frames *= 2;
-		nfrms2 = vi.num_frames - 1;
-		vi.SetFPS(vi.fps_numerator*2, vi.fps_denominator);
-	}
-	else if (field == -1)
-	{
-		// telecide matches off the bottom field so we want field=0 in that case.
-		// tfm can match off top or bottom, but it will indicate which in its hints
-		// and field is adjusted appropriately then... so we use field=0 by default
-		// if hints=true.  Otherwise, if hints=false, we default to field = 1.
-		if (hints) field = 0;
-		else field = 1;
-	}
-	orderS = order; 
-	PRM(fieldS) = PRM(field); 
-	mthreshLS = mthreshL; 
-	mthreshCS = mthreshC;
-	typeS = type;
-	if (debug)
-	{
-		sprintf(buf,&quot;TDeint:  %s (%s) by tritical\n&quot;, VERSION, DATE);
-		OutputDebugString(buf);
-		sprintf(buf,&quot;TDeint:  mode = %d (%s)\n&quot;, mode, mode == 0 ? &quot;normal - same rate&quot; : 
-				mode == 1 ? &quot;bob - double rate&quot; : mode == -2 ? &quot;upsize - ELA&quot; : &quot;upsize - ELA-2&quot;);
-		OutputDebugString(buf);
-	}
-	
-noovrexit:
-	_asm emms;
-}
-#endif
-
-        //EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint_util.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint_util.txt	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint_util.txt	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,3144 +0,0 @@
-
-
- unsigned char vidTDeint::cubicInt(unsigned char p1, unsigned char p2, unsigned char p3, 
-	unsigned char p4)
-{
-	int temp = (int)((19*(p2+p3)-3*(p1+p4)+16)&gt;&gt;5);
-	if (temp&gt;255) temp = 255; 
-	else if (temp&lt;0) temp = 0;
-	return (unsigned char)temp;
-}
-
-void vidTDeint::createMotionMapYV12(ADMImage *prv2, ADMImage *prv, 
-	ADMImage *src, ADMImage *nxt, ADMImage *nxt2, ADMImage *mask, int n)
-{
-	const unsigned char *prv2pY = prv2-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *prv2pV = prv2-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *prv2pU = prv2-&gt;GetReadPtr(PLANAR_U);
-	int prv2_pitchY = prv2-&gt;GetPitch(PLANAR_Y);
-	int prv2_pitchUV = prv2-&gt;GetPitch(PLANAR_V);
-	prv2pY += prv2_pitchY*(2-PRM(field));
-	prv2pV += prv2_pitchUV*(2-PRM(field));
-	prv2pU += prv2_pitchUV*(2-PRM(field));
-	prv2_pitchY *= 2;
-	prv2_pitchUV *= 2;
-	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
-	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
-	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
-	prvpY += prv_pitchY*(2-PRM(field));
-	prvpV += prv_pitchUV*(2-PRM(field));
-	prvpU += prv_pitchUV*(2-PRM(field));
-	const unsigned char *prvppY = prvpY - prv_pitchY;
-	const unsigned char *prvppV = prvpV - prv_pitchUV;
-	const unsigned char *prvppU = prvpU - prv_pitchUV;
-	const unsigned char *prvpnY = prvpY + prv_pitchY;
-	const unsigned char *prvpnV = prvpV + prv_pitchUV;
-	const unsigned char *prvpnU = prvpU + prv_pitchUV;
-	prv_pitchY *= 2;
-	prv_pitchUV *= 2;
-	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
-	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
-	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
-	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
-	int HeightY = src-&gt;GetHeight(PLANAR_Y);
-	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
-	int HeightUV = src-&gt;GetHeight(PLANAR_V);
-	srcpY += src_pitchY*(2-PRM(field));
-	srcpV += src_pitchUV*(2-PRM(field));
-	srcpU += src_pitchUV*(2-PRM(field));
-	const unsigned char *srcppY = srcpY - src_pitchY;
-	const unsigned char *srcppV = srcpV - src_pitchUV;
-	const unsigned char *srcppU = srcpU - src_pitchUV;
-	const unsigned char *srcpnY = srcpY + src_pitchY;
-	const unsigned char *srcpnV = srcpV + src_pitchUV;
-	const unsigned char *srcpnU = srcpU + src_pitchUV;
-	src_pitchY *= 2;
-	src_pitchUV *= 2;
-	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
-	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
-	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
-	nxtpY += nxt_pitchY*(2-PRM(field));
-	nxtpV += nxt_pitchUV*(2-PRM(field));
-	nxtpU += nxt_pitchUV*(2-PRM(field));
-	const unsigned char *nxtppY = nxtpY - nxt_pitchY;
-	const unsigned char *nxtppV = nxtpV - nxt_pitchUV;
-	const unsigned char *nxtppU = nxtpU - nxt_pitchUV;
-	const unsigned char *nxtpnY = nxtpY + nxt_pitchY;
-	const unsigned char *nxtpnV = nxtpV + nxt_pitchUV;
-	const unsigned char *nxtpnU = nxtpU + nxt_pitchUV;
-	nxt_pitchY *= 2;
-	nxt_pitchUV *= 2;
-	const unsigned char *nxt2pY = nxt2-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *nxt2pV = nxt2-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *nxt2pU = nxt2-&gt;GetReadPtr(PLANAR_U);
-	int nxt2_pitchY = nxt2-&gt;GetPitch(PLANAR_Y);
-	int nxt2_pitchUV = nxt2-&gt;GetPitch(PLANAR_V);
-	nxt2pY += nxt2_pitchY*(2-PRM(field));
-	nxt2pV += nxt2_pitchUV*(2-PRM(field));
-	nxt2pU += nxt2_pitchUV*(2-PRM(field));
-	nxt2_pitchY *= 2;
-	nxt2_pitchUV *= 2;
-	unsigned char *maskwY = mask-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *maskwV = mask-&gt;GetWritePtr(PLANAR_V);
-	unsigned char *maskwU = mask-&gt;GetWritePtr(PLANAR_U);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	memset(maskwY,10,mask_pitchY*HeightY);
-	memset(maskwU,10,mask_pitchUV*HeightUV);
-	memset(maskwV,10,mask_pitchUV*HeightUV);
-	maskwY += mask_pitchY*(2-PRM(field));
-	maskwV += mask_pitchUV*(2-PRM(field));
-	maskwU += mask_pitchUV*(2-PRM(field));
-	mask_pitchY *= 2;
-	mask_pitchUV *= 2;
-	int x, y;
-	unsigned char val1;
-	bool t1, t2, t3, t4, t5, t6, t7;
-	if (PRM(field)^PRM(order))
-	{
-		val1 = PRM(mntmode) &gt; 1 ? (accumP &lt;= accumN ? 10 : 30) : 40;
-		if (n &lt;= 1 || n &gt;= nfrms-1)
-		{
-			for (y=1; y&lt;HeightY-1; y+=2)
-			{
-				for (x=0; x&lt;WidthY; ++x)
-				{
-					t1 = n == 0 ? false : (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
-					t2 = n == 0 ? false : (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t3 = n == nfrms ? false : (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
-					t4 = n == nfrms ? false : (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
-					t5 = n == 0 ? false : (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
-					t6 = n == nfrms ? false : (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
-					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpY[x] - nxt2pY[x]) &lt; mthreshL);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwY[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwY[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwY[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwY[x] = 30;
-					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
-					else if (abs(nxtpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(nxtpY[x]-srcpnY[x])&lt;4) maskwY[x] = 130;
-					else maskwY[x] = 60;
-				}
-				prvppY += prv_pitchY;
-				prvpY += prv_pitchY;
-				prvpnY += prv_pitchY;
-				srcppY += src_pitchY;
-				srcpY += src_pitchY;
-				srcpnY += src_pitchY;
-				nxtppY += nxt_pitchY;
-				nxtpY += nxt_pitchY;
-				nxtpnY += nxt_pitchY;
-				nxt2pY += nxt2_pitchY;
-				maskwY += mask_pitchY;
-			}
-			for (y=1; y&lt;HeightUV-1; y+=2)
-			{
-				for (x=0; x&lt;WidthUV; ++x)
-				{
-					t1 = n == 0 ? false : (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
-					t2 = n == 0 ? false : (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t3 = n == nfrms ? false : (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
-					t4 = n == nfrms ? false : (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
-					t5 = n == 0 ? false : (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
-					t6 = n == nfrms ? false : (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
-					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpV[x] - nxt2pV[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwV[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwV[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwV[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwV[x] = 30;
-					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
-					else if (abs(nxtpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(nxtpV[x]-srcpnV[x])&lt;4) maskwV[x] = 130;
-					else maskwV[x] = 60;
-					t1 = n == 0 ? false : (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
-					t2 = n == 0 ? false : (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t3 = n == nfrms ? false : (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
-					t4 = n == nfrms ? false : (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
-					t5 = n == 0 ? false : (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
-					t6 = n == nfrms ? false : (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
-					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpU[x] - nxt2pU[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwU[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwU[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwU[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwU[x] = 30;
-					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
-					else if (abs(nxtpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(nxtpU[x]-srcpnU[x])&lt;4) maskwU[x] = 130;
-					else maskwU[x] = 60;
-				}
-				prvppV += prv_pitchUV;
-				prvpV += prv_pitchUV;
-				prvpnV += prv_pitchUV;
-				prvppU += prv_pitchUV;
-				prvpU += prv_pitchUV;
-				prvpnU += prv_pitchUV;
-				srcppV += src_pitchUV;
-				srcpV += src_pitchUV;
-				srcpnV += src_pitchUV;
-				srcppU += src_pitchUV;
-				srcpU += src_pitchUV;
-				srcpnU += src_pitchUV;
-				nxtppV += nxt_pitchUV;
-				nxtpV += nxt_pitchUV;
-				nxtpnV += nxt_pitchUV;
-				nxtppU += nxt_pitchUV;
-				nxtpU += nxt_pitchUV;
-				nxtpnU += nxt_pitchUV;
-				nxt2pV += nxt2_pitchUV;
-				nxt2pU += nxt2_pitchUV;
-				maskwV += mask_pitchUV;
-				maskwU += mask_pitchUV;
-			}
-		}
-		else
-		{
-			for (y=1; y&lt;HeightY-1; y+=2)
-			{
-				for (x=0; x&lt;WidthY; ++x)
-				{
-					t1 = (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
-					t2 = (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t3 = (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
-					t4 = (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
-					t5 = (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
-					t6 = (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
-					t7 = (abs(nxtpY[x] - nxt2pY[x]) &lt; mthreshL);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwY[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwY[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwY[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwY[x] = 30;
-					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
-					else if (abs(nxtpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(nxtpY[x]-srcpnY[x])&lt;4) maskwY[x] = 130;
-					else maskwY[x] = 60;
-				}
-				prvppY += prv_pitchY;
-				prvpY += prv_pitchY;
-				prvpnY += prv_pitchY;
-				srcppY += src_pitchY;
-				srcpY += src_pitchY;
-				srcpnY += src_pitchY;
-				nxtppY += nxt_pitchY;
-				nxtpY += nxt_pitchY;
-				nxtpnY += nxt_pitchY;
-				nxt2pY += nxt2_pitchY;
-				maskwY += mask_pitchY;
-			}
-			for (y=1; y&lt;HeightUV-1; y+=2)
-			{
-				for (x=0; x&lt;WidthUV; ++x)
-				{
-					t1 = (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
-					t2 = (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t3 = (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
-					t4 = (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
-					t5 = (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
-					t6 = (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
-					t7 = (abs(nxtpV[x] - nxt2pV[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwV[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwV[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwV[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwV[x] = 30;
-					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
-					else if (abs(nxtpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(nxtpV[x]-srcpnV[x])&lt;4) maskwV[x] = 130;
-					else maskwV[x] = 60;
-					t1 = (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
-					t2 = (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t3 = (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
-					t4 = (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
-					t5 = (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
-					t6 = (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
-					t7 = (abs(nxtpU[x] - nxt2pU[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwU[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwU[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwU[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwU[x] = 30;
-					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
-					else if (abs(nxtpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(nxtpU[x]-srcpnU[x])&lt;4) maskwU[x] = 130;
-					else maskwU[x] = 60;
-				}
-				prvppV += prv_pitchUV;
-				prvpV += prv_pitchUV;
-				prvpnV += prv_pitchUV;
-				prvppU += prv_pitchUV;
-				prvpU += prv_pitchUV;
-				prvpnU += prv_pitchUV;
-				srcppV += src_pitchUV;
-				srcpV += src_pitchUV;
-				srcpnV += src_pitchUV;
-				srcppU += src_pitchUV;
-				srcpU += src_pitchUV;
-				srcpnU += src_pitchUV;
-				nxtppV += nxt_pitchUV;
-				nxtpV += nxt_pitchUV;
-				nxtpnV += nxt_pitchUV;
-				nxtppU += nxt_pitchUV;
-				nxtpU += nxt_pitchUV;
-				nxtpnU += nxt_pitchUV;
-				nxt2pV += nxt2_pitchUV;
-				nxt2pU += nxt2_pitchUV;
-				maskwV += mask_pitchUV;
-				maskwU += mask_pitchUV;
-			}
-		}
-	}
-	else
-	{
-		val1 = PRM(mntmode) &gt; 1 ? (accumP &lt; accumN ? 20 : 10) : 50;
-		if (n &lt;= 1 || n &gt;= nfrms-1)
-		{
-			for (y=1; y&lt;HeightY-1; y+=2)
-			{
-				for (x=0; x&lt;WidthY; ++x)
-				{
-					t1 = n == 0 ? false : (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
-					t2 = n == 0 ? false : (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t3 = n == nfrms ? false : (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
-					t4 = n == nfrms ? false : (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
-					t5 = n &lt;= 1 ? false : (abs(prvpY[x] - prv2pY[x]) &lt; mthreshL);
-					t6 = n == 0 ? false : (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
-					t7 = n == nfrms ? false : (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwY[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwY[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwY[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwY[x] = 10;
-					else if (abs(prvpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(prvpY[x]-srcpnY[x])&lt;4) maskwY[x] = 120;
-					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
-					else maskwY[x] = 60;
-				}
-				prv2pY += prv2_pitchY;
-				prvppY += prv_pitchY;
-				prvpY += prv_pitchY;
-				prvpnY += prv_pitchY;
-				srcppY += src_pitchY;
-				srcpY += src_pitchY;
-				srcpnY += src_pitchY;
-				nxtppY += nxt_pitchY;
-				nxtpY += nxt_pitchY;
-				nxtpnY += nxt_pitchY;
-				maskwY += mask_pitchY;
-			}
-			for (y=1; y&lt;HeightUV-1; y+=2)
-			{
-				for (x=0; x&lt;WidthUV; ++x)
-				{
-					t1 = n == 0 ? false : (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
-					t2 = n == 0 ? false : (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t3 = n == nfrms ? false : (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
-					t4 = n == nfrms ? false : (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
-					t5 = n &lt;= 1 ? false : (abs(prvpV[x] - prv2pV[x]) &lt; mthreshC);
-					t6 = n == 0 ? false : (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
-					t7 = n == nfrms ? false : (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwV[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwV[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwV[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwV[x] = 10;
-					else if (abs(prvpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(prvpV[x]-srcpnV[x])&lt;4) maskwV[x] = 120;
-					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
-					else maskwV[x] = 60;
-					t1 = n == 0 ? false : (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
-					t2 = n == 0 ? false : (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t3 = n == nfrms ? false : (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
-					t4 = n == nfrms ? false : (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
-					t5 = n &lt;= 1 ? false : (abs(prvpU[x] - prv2pU[x]) &lt; mthreshC);
-					t6 = n == 0 ? false : (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
-					t7 = n == nfrms ? false : (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwU[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwU[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwU[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwU[x] = 10;
-					else if (abs(prvpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(prvpU[x]-srcpnU[x])&lt;4) maskwU[x] = 120;
-					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
-					else maskwU[x] = 60;
-				}
-				prv2pV += prv2_pitchUV;
-				prv2pU += prv2_pitchUV;
-				prvppV += prv_pitchUV;
-				prvpV += prv_pitchUV;
-				prvpnV += prv_pitchUV;
-				prvppU += prv_pitchUV;
-				prvpU += prv_pitchUV;
-				prvpnU += prv_pitchUV;
-				srcppV += src_pitchUV;
-				srcpV += src_pitchUV;
-				srcpnV += src_pitchUV;
-				srcppU += src_pitchUV;
-				srcpU += src_pitchUV;
-				srcpnU += src_pitchUV;
-				nxtppV += nxt_pitchUV;
-				nxtpV += nxt_pitchUV;
-				nxtpnV += nxt_pitchUV;
-				nxtppU += nxt_pitchUV;
-				nxtpU += nxt_pitchUV;
-				nxtpnU += nxt_pitchUV;
-				maskwV += mask_pitchUV;
-				maskwU += mask_pitchUV;
-			}
-		}
-		else
-		{
-			for (y=1; y&lt;HeightY-1; y+=2)
-			{
-				for (x=0; x&lt;WidthY; ++x)
-				{
-					t1 = (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
-					t2 = (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t3 = (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
-					t4 = (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
-					t5 = (abs(prvpY[x] - prv2pY[x]) &lt; mthreshL);
-					t6 = (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
-					t7 = (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwY[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwY[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwY[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwY[x] = 10;
-					else if (abs(prvpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(prvpY[x]-srcpnY[x])&lt;4) maskwY[x] = 120;
-					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
-					else maskwY[x] = 60;
-				}
-				prv2pY += prv2_pitchY;
-				prvppY += prv_pitchY;
-				prvpY += prv_pitchY;
-				prvpnY += prv_pitchY;
-				srcppY += src_pitchY;
-				srcpY += src_pitchY;
-				srcpnY += src_pitchY;
-				nxtppY += nxt_pitchY;
-				nxtpY += nxt_pitchY;
-				nxtpnY += nxt_pitchY;
-				maskwY += mask_pitchY;
-			}
-			for (y=1; y&lt;HeightUV-1; y+=2)
-			{
-				for (x=0; x&lt;WidthUV; ++x)
-				{
-					t1 = (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
-					t2 = (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t3 = (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
-					t4 = (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
-					t5 = (abs(prvpV[x] - prv2pV[x]) &lt; mthreshC);
-					t6 = (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
-					t7 = (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwV[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwV[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwV[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwV[x] = 10;
-					else if (abs(prvpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(prvpV[x]-srcpnV[x])&lt;4) maskwV[x] = 120;
-					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
-					else maskwV[x] = 60;
-					t1 = (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
-					t2 = (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t3 = (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
-					t4 = (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
-					t5 = (abs(prvpU[x] - prv2pU[x]) &lt; mthreshC);
-					t6 = (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
-					t7 = (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
-						maskwU[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwU[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwU[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwU[x] = 10;
-					else if (abs(prvpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(prvpU[x]-srcpnU[x])&lt;4) maskwU[x] = 120;
-					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
-					else maskwU[x] = 60;
-				}
-				prv2pV += prv2_pitchUV;
-				prv2pU += prv2_pitchUV;
-				prvppV += prv_pitchUV;
-				prvpV += prv_pitchUV;
-				prvpnV += prv_pitchUV;
-				prvppU += prv_pitchUV;
-				prvpU += prv_pitchUV;
-				prvpnU += prv_pitchUV;
-				srcppV += src_pitchUV;
-				srcpV += src_pitchUV;
-				srcpnV += src_pitchUV;
-				srcppU += src_pitchUV;
-				srcpU += src_pitchUV;
-				srcpnU += src_pitchUV;
-				nxtppV += nxt_pitchUV;
-				nxtpV += nxt_pitchUV;
-				nxtpnV += nxt_pitchUV;
-				nxtppU += nxt_pitchUV;
-				nxtpU += nxt_pitchUV;
-				nxtpnU += nxt_pitchUV;
-				maskwV += mask_pitchUV;
-				maskwU += mask_pitchUV;
-			}
-		}
-	}
-}
-
-void vidTDeint::createMotionMap2YV12(ADMImage *prv2, ADMImage *prv, 
-	ADMImage *src, ADMImage *nxt, ADMImage *nxt2, ADMImage *mask, int n)
-{
-	const unsigned char *prv2pY = prv2-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *prv2pV = prv2-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *prv2pU = prv2-&gt;GetReadPtr(PLANAR_U);
-	int prv2_pitchY = prv2-&gt;GetPitch(PLANAR_Y);
-	int prv2_pitchUV = prv2-&gt;GetPitch(PLANAR_V);
-	prv2pY += prv2_pitchY*(2-PRM(field));
-	prv2pV += prv2_pitchUV*(2-PRM(field));
-	prv2pU += prv2_pitchUV*(2-PRM(field));
-	const unsigned char *prv2ppY = prv2pY - prv2_pitchY;
-	const unsigned char *prv2ppV = prv2pV - prv2_pitchUV;
-	const unsigned char *prv2ppU = prv2pU - prv2_pitchUV;
-	const unsigned char *prv2pnY = prv2pY + prv2_pitchY;
-	const unsigned char *prv2pnV = prv2pV + prv2_pitchUV;
-	const unsigned char *prv2pnU = prv2pU + prv2_pitchUV;
-	prv2_pitchY *= 2;
-	prv2_pitchUV *= 2;
-	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
-	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
-	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
-	prvpY += prv_pitchY*(2-PRM(field));
-	prvpV += prv_pitchUV*(2-PRM(field));
-	prvpU += prv_pitchUV*(2-PRM(field));
-	const unsigned char *prvppY = prvpY - prv_pitchY;
-	const unsigned char *prvppV = prvpV - prv_pitchUV;
-	const unsigned char *prvppU = prvpU - prv_pitchUV;
-	const unsigned char *prvpnY = prvpY + prv_pitchY;
-	const unsigned char *prvpnV = prvpV + prv_pitchUV;
-	const unsigned char *prvpnU = prvpU + prv_pitchUV;
-	prv_pitchY *= 2;
-	prv_pitchUV *= 2;
-	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
-	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
-	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
-	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
-	int HeightY = src-&gt;GetHeight(PLANAR_Y);
-	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
-	int HeightUV = src-&gt;GetHeight(PLANAR_V);
-	srcpY += src_pitchY*(2-PRM(field));
-	srcpV += src_pitchUV*(2-PRM(field));
-	srcpU += src_pitchUV*(2-PRM(field));
-	const unsigned char *srcppY = srcpY - src_pitchY;
-	const unsigned char *srcppV = srcpV - src_pitchUV;
-	const unsigned char *srcppU = srcpU - src_pitchUV;
-	const unsigned char *srcpnY = srcpY + src_pitchY;
-	const unsigned char *srcpnV = srcpV + src_pitchUV;
-	const unsigned char *srcpnU = srcpU + src_pitchUV;
-	src_pitchY *= 2;
-	src_pitchUV *= 2;
-	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
-	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
-	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
-	nxtpY += nxt_pitchY*(2-PRM(field));
-	nxtpV += nxt_pitchUV*(2-PRM(field));
-	nxtpU += nxt_pitchUV*(2-PRM(field));
-	const unsigned char *nxtppY = nxtpY - nxt_pitchY;
-	const unsigned char *nxtppV = nxtpV - nxt_pitchUV;
-	const unsigned char *nxtppU = nxtpU - nxt_pitchUV;
-	const unsigned char *nxtpnY = nxtpY + nxt_pitchY;
-	const unsigned char *nxtpnV = nxtpV + nxt_pitchUV;
-	const unsigned char *nxtpnU = nxtpU + nxt_pitchUV;
-	nxt_pitchY *= 2;
-	nxt_pitchUV *= 2;
-	const unsigned char *nxt2pY = nxt2-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *nxt2pV = nxt2-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *nxt2pU = nxt2-&gt;GetReadPtr(PLANAR_U);
-	int nxt2_pitchY = nxt2-&gt;GetPitch(PLANAR_Y);
-	int nxt2_pitchUV = nxt2-&gt;GetPitch(PLANAR_V);
-	nxt2pY += nxt2_pitchY*(2-PRM(field));
-	nxt2pV += nxt2_pitchUV*(2-PRM(field));
-	nxt2pU += nxt2_pitchUV*(2-PRM(field));
-	const unsigned char *nxt2ppY = nxt2pY - nxt2_pitchY;
-	const unsigned char *nxt2ppV = nxt2pV - nxt2_pitchUV;
-	const unsigned char *nxt2ppU = nxt2pU - nxt2_pitchUV;
-	const unsigned char *nxt2pnY = nxt2pY + nxt2_pitchY;
-	const unsigned char *nxt2pnV = nxt2pV + nxt2_pitchUV;
-	const unsigned char *nxt2pnU = nxt2pU + nxt2_pitchUV;
-	nxt2_pitchY *= 2;
-	nxt2_pitchUV *= 2;
-	unsigned char *maskwY = mask-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *maskwV = mask-&gt;GetWritePtr(PLANAR_V);
-	unsigned char *maskwU = mask-&gt;GetWritePtr(PLANAR_U);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	memset(maskwY,10,mask_pitchY*HeightY);
-	memset(maskwU,10,mask_pitchUV*HeightUV);
-	memset(maskwV,10,mask_pitchUV*HeightUV);
-	maskwY += mask_pitchY*(2-PRM(field));
-	maskwV += mask_pitchUV*(2-PRM(field));
-	maskwU += mask_pitchUV*(2-PRM(field));
-	mask_pitchY *= 2;
-	mask_pitchUV *= 2;
-	int x, y;
-	unsigned char val1;
-	bool t1, t2, t3, t4, t5, t6, t7, t8, t9, t10;
-	bool t11, t12, t13, t14, t15, t16, t17, t18, t19;
-	if (PRM(field)^PRM(order))
-	{
-		val1 = PRM(mntmode) &gt; 1 ? (accumP &lt;= accumN ? 10 : 30) : 40;
-		if (n &lt;= 1 || n &gt;= nfrms-1)
-		{
-			for (y=1; y&lt;HeightY-1; y+=2)
-			{
-				for (x=0; x&lt;WidthY; ++x)
-				{
-					t1 = n == 0 ? false : (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
-					t2 = n == 0 ? false : (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t3 = n == nfrms ? false : (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
-					t4 = n == nfrms ? false : (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
-					t5 = n == 0 ? false : (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
-					t6 = n == nfrms ? false : (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
-					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpY[x] - nxt2pY[x]) &lt; mthreshL);
-					t8 = n &lt;= 1 ? false : (abs(prvppY[x] - prv2ppY[x]) &lt; mthreshL);
-					t9 = n &lt;= 1 ? false : (abs(prvpnY[x] - prv2pnY[x]) &lt; mthreshL);
-					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppY[x] - nxt2ppY[x]) &lt; mthreshL);
-					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnY[x] - nxt2pnY[x]) &lt; mthreshL);
-					t12 = (abs(srcppY[x] - prv2ppY[x]) &lt; mthreshL);
-					t13 = (abs(srcpnY[x] - prv2pnY[x]) &lt; mthreshL);
-					t14 = (abs(nxtppY[x] - prvppY[x]) &lt; mthreshL);
-					t15 = (abs(nxtpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t16 = (abs(nxt2ppY[x] - srcppY[x]) &lt; mthreshL);
-					t17 = (abs(nxt2pnY[x] - srcpnY[x]) &lt; mthreshL);
-					t18 = (abs(nxtpY[x] - prvpY[x]) &lt; mthreshL);
-					t19 = (abs(nxt2pY[x] - srcpY[x]) &lt; mthreshL);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwY[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwY[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwY[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwY[x] = 30;
-					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
-					else if (abs(nxtpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(nxtpY[x]-srcpnY[x])&lt;4) maskwY[x] = 130;
-					else maskwY[x] = 60;
-				}
-				prv2ppY += prv2_pitchY;
-				prv2pY += prv2_pitchY;
-				prv2pnY += prv2_pitchY;
-				prvppY += prv_pitchY;
-				prvpY += prv_pitchY;
-				prvpnY += prv_pitchY;
-				srcppY += src_pitchY;
-				srcpY += src_pitchY;
-				srcpnY += src_pitchY;
-				nxtppY += nxt_pitchY;
-				nxtpY += nxt_pitchY;
-				nxtpnY += nxt_pitchY;
-				nxt2ppY += nxt2_pitchY;
-				nxt2pY += nxt2_pitchY;
-				nxt2pnY += nxt2_pitchY;
-				maskwY += mask_pitchY;
-			}
-			for (y=1; y&lt;HeightUV-1; y+=2)
-			{
-				for (x=0; x&lt;WidthUV; ++x)
-				{
-					t1 = n == 0 ? false : (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
-					t2 = n == 0 ? false : (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t3 = n == nfrms ? false : (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
-					t4 = n == nfrms ? false : (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
-					t5 = n == 0 ? false : (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
-					t6 = n == nfrms ? false : (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
-					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpV[x] - nxt2pV[x]) &lt; mthreshC);
-					t8 = n &lt;= 1 ? false : (abs(prvppV[x] - prv2ppV[x]) &lt; mthreshC);
-					t9 = n &lt;= 1 ? false : (abs(prvpnV[x] - prv2pnV[x]) &lt; mthreshC);
-					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppV[x] - nxt2ppV[x]) &lt; mthreshC);
-					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnV[x] - nxt2pnV[x]) &lt; mthreshC);
-					t12 = (abs(srcppV[x] - prv2ppV[x]) &lt; mthreshC);
-					t13 = (abs(srcpnV[x] - prv2pnV[x]) &lt; mthreshC);
-					t14 = (abs(nxtppV[x] - prvppV[x]) &lt; mthreshC);
-					t15 = (abs(nxtpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t16 = (abs(nxt2ppV[x] - srcppV[x]) &lt; mthreshC);
-					t17 = (abs(nxt2pnV[x] - srcpnV[x]) &lt; mthreshC);
-					t18 = (abs(nxtpV[x] - prvpV[x]) &lt; mthreshC);
-					t19 = (abs(nxt2pV[x] - srcpV[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwV[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwV[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwV[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwV[x] = 30;
-					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
-					else if (abs(nxtpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(nxtpV[x]-srcpnV[x])&lt;4) maskwV[x] = 130;
-					else maskwV[x] = 60;
-					t1 = n == 0 ? false : (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
-					t2 = n == 0 ? false : (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t3 = n == nfrms ? false : (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
-					t4 = n == nfrms ? false : (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
-					t5 = n == 0 ? false : (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
-					t6 = n == nfrms ? false : (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
-					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpU[x] - nxt2pU[x]) &lt; mthreshC);
-					t8 = n &lt;= 1 ? false : (abs(prvppU[x] - prv2ppU[x]) &lt; mthreshC);
-					t9 = n &lt;= 1 ? false : (abs(prvpnU[x] - prv2pnU[x]) &lt; mthreshC);
-					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppU[x] - nxt2ppU[x]) &lt; mthreshC);
-					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnU[x] - nxt2pnU[x]) &lt; mthreshC);
-					t12 = (abs(srcppU[x] - prv2ppU[x]) &lt; mthreshC);
-					t13 = (abs(srcpnU[x] - prv2pnU[x]) &lt; mthreshC);
-					t14 = (abs(nxtppU[x] - prvppU[x]) &lt; mthreshC);
-					t15 = (abs(nxtpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t16 = (abs(nxt2ppU[x] - srcppU[x]) &lt; mthreshC);
-					t17 = (abs(nxt2pnU[x] - srcpnU[x]) &lt; mthreshC);
-					t18 = (abs(nxtpU[x] - prvpU[x]) &lt; mthreshC);
-					t19 = (abs(nxt2pU[x] - srcpU[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwU[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwU[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwU[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwU[x] = 30;
-					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
-					else if (abs(nxtpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(nxtpU[x]-srcpnU[x])&lt;4) maskwU[x] = 130;
-					else maskwU[x] = 60;
-				}
-				prv2ppV += prv2_pitchUV;
-				prv2pV += prv2_pitchUV;
-				prv2pnV += prv2_pitchUV;
-				prv2ppU += prv2_pitchUV;
-				prv2pU += prv2_pitchUV;
-				prv2pnU += prv2_pitchUV;
-				prvppV += prv_pitchUV;
-				prvpV += prv_pitchUV;
-				prvpnV += prv_pitchUV;
-				prvppU += prv_pitchUV;
-				prvpU += prv_pitchUV;
-				prvpnU += prv_pitchUV;
-				srcppV += src_pitchUV;
-				srcpV += src_pitchUV;
-				srcpnV += src_pitchUV;
-				srcppU += src_pitchUV;
-				srcpU += src_pitchUV;
-				srcpnU += src_pitchUV;
-				nxtppV += nxt_pitchUV;
-				nxtpV += nxt_pitchUV;
-				nxtpnV += nxt_pitchUV;
-				nxtppU += nxt_pitchUV;
-				nxtpU += nxt_pitchUV;
-				nxtpnU += nxt_pitchUV;
-				nxt2ppV += nxt2_pitchUV;
-				nxt2pV += nxt2_pitchUV;
-				nxt2pnV += nxt2_pitchUV;
-				nxt2ppU += nxt2_pitchUV;
-				nxt2pU += nxt2_pitchUV;
-				nxt2pnU += nxt2_pitchUV;
-				maskwV += mask_pitchUV;
-				maskwU += mask_pitchUV;
-			}
-		}
-		else
-		{
-			for (y=1; y&lt;HeightY-1; y+=2)
-			{
-				for (x=0; x&lt;WidthY; ++x)
-				{
-					t1 = (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
-					t2 = (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t3 = (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
-					t4 = (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
-					t5 = (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
-					t6 = (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
-					t7 = (abs(nxtpY[x] - nxt2pY[x]) &lt; mthreshL);
-					t8 = (abs(prvppY[x] - prv2ppY[x]) &lt; mthreshL);
-					t9 = (abs(prvpnY[x] - prv2pnY[x]) &lt; mthreshL);
-					t10 = (abs(nxtppY[x] - nxt2ppY[x]) &lt; mthreshL);
-					t11 = (abs(nxtpnY[x] - nxt2pnY[x]) &lt; mthreshL);
-					t12 = (abs(srcppY[x] - prv2ppY[x]) &lt; mthreshL);
-					t13 = (abs(srcpnY[x] - prv2pnY[x]) &lt; mthreshL);
-					t14 = (abs(nxtppY[x] - prvppY[x]) &lt; mthreshL);
-					t15 = (abs(nxtpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t16 = (abs(nxt2ppY[x] - srcppY[x]) &lt; mthreshL);
-					t17 = (abs(nxt2pnY[x] - srcpnY[x]) &lt; mthreshL);
-					t18 = (abs(nxtpY[x] - prvpY[x]) &lt; mthreshL);
-					t19 = (abs(nxt2pY[x] - srcpY[x]) &lt; mthreshL);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwY[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwY[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwY[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwY[x] = 30;
-					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
-					else if (abs(nxtpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(nxtpY[x]-srcpnY[x])&lt;4) maskwY[x] = 130;
-					else maskwY[x] = 60;
-				}
-				prv2ppY += prv2_pitchY;
-				prv2pY += prv2_pitchY;
-				prv2pnY += prv2_pitchY;
-				prvppY += prv_pitchY;
-				prvpY += prv_pitchY;
-				prvpnY += prv_pitchY;
-				srcppY += src_pitchY;
-				srcpY += src_pitchY;
-				srcpnY += src_pitchY;
-				nxtppY += nxt_pitchY;
-				nxtpY += nxt_pitchY;
-				nxtpnY += nxt_pitchY;
-				nxt2ppY += nxt2_pitchY;
-				nxt2pY += nxt2_pitchY;
-				nxt2pnY += nxt2_pitchY;
-				maskwY += mask_pitchY;
-			}
-			for (y=1; y&lt;HeightUV-1; y+=2)
-			{
-				for (x=0; x&lt;WidthUV; ++x)
-				{
-					t1 = (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
-					t2 = (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t3 = (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
-					t4 = (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
-					t5 = (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
-					t6 = (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
-					t7 = (abs(nxtpV[x] - nxt2pV[x]) &lt; mthreshC);
-					t8 = (abs(prvppV[x] - prv2ppV[x]) &lt; mthreshC);
-					t9 = (abs(prvpnV[x] - prv2pnV[x]) &lt; mthreshC);
-					t10 = (abs(nxtppV[x] - nxt2ppV[x]) &lt; mthreshC);
-					t11 = (abs(nxtpnV[x] - nxt2pnV[x]) &lt; mthreshC);
-					t12 = (abs(srcppV[x] - prv2ppV[x]) &lt; mthreshC);
-					t13 = (abs(srcpnV[x] - prv2pnV[x]) &lt; mthreshC);
-					t14 = (abs(nxtppV[x] - prvppV[x]) &lt; mthreshC);
-					t15 = (abs(nxtpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t16 = (abs(nxt2ppV[x] - srcppV[x]) &lt; mthreshC);
-					t17 = (abs(nxt2pnV[x] - srcpnV[x]) &lt; mthreshC);
-					t18 = (abs(nxtpV[x] - prvpV[x]) &lt; mthreshC);
-					t19 = (abs(nxt2pV[x] - srcpV[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwV[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwV[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwV[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwV[x] = 30;
-					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
-					else if (abs(nxtpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(nxtpV[x]-srcpnV[x])&lt;4) maskwV[x] = 130;
-					else maskwV[x] = 60;
-					t1 = (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
-					t2 = (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t3 = (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
-					t4 = (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
-					t5 = (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
-					t6 = (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
-					t7 = (abs(nxtpU[x] - nxt2pU[x]) &lt; mthreshC);
-					t8 = (abs(prvppU[x] - prv2ppU[x]) &lt; mthreshC);
-					t9 = (abs(prvpnU[x] - prv2pnU[x]) &lt; mthreshC);
-					t10 = (abs(nxtppU[x] - nxt2ppU[x]) &lt; mthreshC);
-					t11 = (abs(nxtpnU[x] - nxt2pnU[x]) &lt; mthreshC);
-					t12 = (abs(srcppU[x] - prv2ppU[x]) &lt; mthreshC);
-					t13 = (abs(srcpnU[x] - prv2pnU[x]) &lt; mthreshC);
-					t14 = (abs(nxtppU[x] - prvppU[x]) &lt; mthreshC);
-					t15 = (abs(nxtpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t16 = (abs(nxt2ppU[x] - srcppU[x]) &lt; mthreshC);
-					t17 = (abs(nxt2pnU[x] - srcpnU[x]) &lt; mthreshC);
-					t18 = (abs(nxtpU[x] - prvpU[x]) &lt; mthreshC);
-					t19 = (abs(nxt2pU[x] - srcpU[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwU[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwU[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwU[x] = 10;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwU[x] = 30;
-					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
-					else if (abs(nxtpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(nxtpU[x]-srcpnU[x])&lt;4) maskwU[x] = 130;
-					else maskwU[x] = 60;
-				}
-				prv2ppV += prv2_pitchUV;
-				prv2pV += prv2_pitchUV;
-				prv2pnV += prv2_pitchUV;
-				prv2ppU += prv2_pitchUV;
-				prv2pU += prv2_pitchUV;
-				prv2pnU += prv2_pitchUV;
-				prvppV += prv_pitchUV;
-				prvpV += prv_pitchUV;
-				prvpnV += prv_pitchUV;
-				prvppU += prv_pitchUV;
-				prvpU += prv_pitchUV;
-				prvpnU += prv_pitchUV;
-				srcppV += src_pitchUV;
-				srcpV += src_pitchUV;
-				srcpnV += src_pitchUV;
-				srcppU += src_pitchUV;
-				srcpU += src_pitchUV;
-				srcpnU += src_pitchUV;
-				nxtppV += nxt_pitchUV;
-				nxtpV += nxt_pitchUV;
-				nxtpnV += nxt_pitchUV;
-				nxtppU += nxt_pitchUV;
-				nxtpU += nxt_pitchUV;
-				nxtpnU += nxt_pitchUV;
-				nxt2ppV += nxt2_pitchUV;
-				nxt2pV += nxt2_pitchUV;
-				nxt2pnV += nxt2_pitchUV;
-				nxt2ppU += nxt2_pitchUV;
-				nxt2pU += nxt2_pitchUV;
-				nxt2pnU += nxt2_pitchUV;
-				maskwV += mask_pitchUV;
-				maskwU += mask_pitchUV;
-			}
-		}
-	}
-	else
-	{
-		val1 = PRM(mntmode) &gt; 1 ? (accumP &lt; accumN ? 20 : 10) : 50;
-		if (n &lt;= 1 || n &gt;= nfrms-1)
-		{
-			for (y=1; y&lt;HeightY-1; y+=2)
-			{
-				for (x=0; x&lt;WidthY; ++x)
-				{
-					t1 = n == 0 ? false : (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
-					t2 = n == 0 ? false : (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t3 = n == nfrms ? false : (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
-					t4 = n == nfrms ? false : (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
-					t5 = n &lt;= 1 ? false : (abs(prvpY[x] - prv2pY[x]) &lt; mthreshL);
-					t6 = n == 0 ? false : (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
-					t7 = n == nfrms ? false : (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
-					t8 = n &lt;= 1 ? false : (abs(prvppY[x] - prv2ppY[x]) &lt; mthreshL);
-					t9 = n &lt;= 1 ? false : (abs(prvpnY[x] - prv2pnY[x]) &lt; mthreshL);
-					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppY[x] - nxt2ppY[x]) &lt; mthreshL);
-					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnY[x] - nxt2pnY[x]) &lt; mthreshL);
-					t12 = (abs(srcppY[x] - prv2ppY[x]) &lt; mthreshL);
-					t13 = (abs(srcpnY[x] - prv2pnY[x]) &lt; mthreshL);
-					t14 = (abs(nxtppY[x] - prvppY[x]) &lt; mthreshL);
-					t15 = (abs(nxtpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t16 = (abs(nxt2ppY[x] - srcppY[x]) &lt; mthreshL);
-					t17 = (abs(nxt2pnY[x] - srcpnY[x]) &lt; mthreshL);
-					t18 = (abs(srcpY[x] - prv2pY[x]) &lt; mthreshL);
-					t19 = (abs(nxtpY[x] - prvpY[x]) &lt; mthreshL);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwY[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwY[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwY[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwY[x] = 10;
-					else if (abs(prvpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(prvpY[x]-srcpnY[x])&lt;4) maskwY[x] = 120;
-					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
-					else maskwY[x] = 60;
-				}
-				prv2ppY += prv2_pitchY;
-				prv2pY += prv2_pitchY;
-				prv2pnY += prv2_pitchY;
-				prvppY += prv_pitchY;
-				prvpY += prv_pitchY;
-				prvpnY += prv_pitchY;
-				srcppY += src_pitchY;
-				srcpY += src_pitchY;
-				srcpnY += src_pitchY;
-				nxtppY += nxt_pitchY;
-				nxtpY += nxt_pitchY;
-				nxtpnY += nxt_pitchY;
-				nxt2ppY += nxt2_pitchY;
-				nxt2pY += nxt2_pitchY;
-				nxt2pnY += nxt2_pitchY;
-				maskwY += mask_pitchY;
-			}
-			for (y=1; y&lt;HeightUV-1; y+=2)
-			{
-				for (x=0; x&lt;WidthUV; ++x)
-				{
-					t1 = n == 0 ? false : (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
-					t2 = n == 0 ? false : (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t3 = n == nfrms ? false : (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
-					t4 = n == nfrms ? false : (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
-					t5 = n &lt;= 1 ? false : (abs(prvpV[x] - prv2pV[x]) &lt; mthreshC);
-					t6 = n == 0 ? false : (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
-					t7 = n == nfrms ? false : (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
-					t8 = n &lt;= 1 ? false : (abs(prvppV[x] - prv2ppV[x]) &lt; mthreshC);
-					t9 = n &lt;= 1 ? false : (abs(prvpnV[x] - prv2pnV[x]) &lt; mthreshC);
-					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppV[x] - nxt2ppV[x]) &lt; mthreshC);
-					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnV[x] - nxt2pnV[x]) &lt; mthreshC);
-					t12 = (abs(srcppV[x] - prv2ppV[x]) &lt; mthreshC);
-					t13 = (abs(srcpnV[x] - prv2pnV[x]) &lt; mthreshC);
-					t14 = (abs(nxtppV[x] - prvppV[x]) &lt; mthreshC);
-					t15 = (abs(nxtpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t16 = (abs(nxt2ppV[x] - srcppV[x]) &lt; mthreshC);
-					t17 = (abs(nxt2pnV[x] - srcpnV[x]) &lt; mthreshC);
-					t18 = (abs(srcpV[x] - prv2pV[x]) &lt; mthreshC);
-					t19 = (abs(nxtpV[x] - prvpV[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwV[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwV[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwV[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwV[x] = 10;
-					else if (abs(prvpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(prvpV[x]-srcpnV[x])&lt;4) maskwV[x] = 120;
-					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
-					else maskwV[x] = 60;
-					t1 = n == 0 ? false : (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
-					t2 = n == 0 ? false : (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t3 = n == nfrms ? false : (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
-					t4 = n == nfrms ? false : (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
-					t5 = n &lt;= 1 ? false : (abs(prvpU[x] - prv2pU[x]) &lt; mthreshC);
-					t6 = n == 0 ? false : (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
-					t7 = n == nfrms ? false : (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
-					t8 = n &lt;= 1 ? false : (abs(prvppU[x] - prv2ppU[x]) &lt; mthreshC);
-					t9 = n &lt;= 1 ? false : (abs(prvpnU[x] - prv2pnU[x]) &lt; mthreshC);
-					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppU[x] - nxt2ppU[x]) &lt; mthreshC);
-					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnU[x] - nxt2pnU[x]) &lt; mthreshC);
-					t12 = (abs(srcppU[x] - prv2ppU[x]) &lt; mthreshC);
-					t13 = (abs(srcpnU[x] - prv2pnU[x]) &lt; mthreshC);
-					t14 = (abs(nxtppU[x] - prvppU[x]) &lt; mthreshC);
-					t15 = (abs(nxtpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t16 = (abs(nxt2ppU[x] - srcppU[x]) &lt; mthreshC);
-					t17 = (abs(nxt2pnU[x] - srcpnU[x]) &lt; mthreshC);
-					t18 = (abs(srcpU[x] - prv2pU[x]) &lt; mthreshC);
-					t19 = (abs(nxtpU[x] - prvpU[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwU[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwU[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwU[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwU[x] = 10;
-					else if (abs(prvpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(prvpU[x]-srcpnU[x])&lt;4) maskwU[x] = 120;
-					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
-					else maskwU[x] = 60;
-				}
-				prv2ppV += prv2_pitchUV;
-				prv2pV += prv2_pitchUV;
-				prv2pnV += prv2_pitchUV;
-				prv2ppU += prv2_pitchUV;
-				prv2pU += prv2_pitchUV;
-				prv2pnU += prv2_pitchUV;
-				prvppV += prv_pitchUV;
-				prvpV += prv_pitchUV;
-				prvpnV += prv_pitchUV;
-				prvppU += prv_pitchUV;
-				prvpU += prv_pitchUV;
-				prvpnU += prv_pitchUV;
-				srcppV += src_pitchUV;
-				srcpV += src_pitchUV;
-				srcpnV += src_pitchUV;
-				srcppU += src_pitchUV;
-				srcpU += src_pitchUV;
-				srcpnU += src_pitchUV;
-				nxtppV += nxt_pitchUV;
-				nxtpV += nxt_pitchUV;
-				nxtpnV += nxt_pitchUV;
-				nxtppU += nxt_pitchUV;
-				nxtpU += nxt_pitchUV;
-				nxtpnU += nxt_pitchUV;
-				nxt2ppV += nxt2_pitchUV;
-				nxt2pV += nxt2_pitchUV;
-				nxt2pnV += nxt2_pitchUV;
-				nxt2ppU += nxt2_pitchUV;
-				nxt2pU += nxt2_pitchUV;
-				nxt2pnU += nxt2_pitchUV;
-				maskwV += mask_pitchUV;
-				maskwU += mask_pitchUV;
-			}
-		}
-		else
-		{
-			for (y=1; y&lt;HeightY-1; y+=2)
-			{
-				for (x=0; x&lt;WidthY; ++x)
-				{
-					t1 = (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
-					t2 = (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t3 = (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
-					t4 = (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
-					t5 = (abs(prvpY[x] - prv2pY[x]) &lt; mthreshL);
-					t6 = (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
-					t7 = (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
-					t8 = (abs(prvppY[x] - prv2ppY[x]) &lt; mthreshL);
-					t9 = (abs(prvpnY[x] - prv2pnY[x]) &lt; mthreshL);
-					t10 = (abs(nxtppY[x] - nxt2ppY[x]) &lt; mthreshL);
-					t11 = (abs(nxtpnY[x] - nxt2pnY[x]) &lt; mthreshL);
-					t12 = (abs(srcppY[x] - prv2ppY[x]) &lt; mthreshL);
-					t13 = (abs(srcpnY[x] - prv2pnY[x]) &lt; mthreshL);
-					t14 = (abs(nxtppY[x] - prvppY[x]) &lt; mthreshL);
-					t15 = (abs(nxtpnY[x] - prvpnY[x]) &lt; mthreshL);
-					t16 = (abs(nxt2ppY[x] - srcppY[x]) &lt; mthreshL);
-					t17 = (abs(nxt2pnY[x] - srcpnY[x]) &lt; mthreshL);
-					t18 = (abs(srcpY[x] - prv2pY[x]) &lt; mthreshL);
-					t19 = (abs(nxtpY[x] - prvpY[x]) &lt; mthreshL);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwY[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwY[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwY[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwY[x] = 10;
-					else if (abs(prvpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(prvpY[x]-srcpnY[x])&lt;4) maskwY[x] = 120;
-					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
-					else maskwY[x] = 60;
-				}
-				prv2ppY += prv2_pitchY;
-				prv2pY += prv2_pitchY;
-				prv2pnY += prv2_pitchY;
-				prvppY += prv_pitchY;
-				prvpY += prv_pitchY;
-				prvpnY += prv_pitchY;
-				srcppY += src_pitchY;
-				srcpY += src_pitchY;
-				srcpnY += src_pitchY;
-				nxtppY += nxt_pitchY;
-				nxtpY += nxt_pitchY;
-				nxtpnY += nxt_pitchY;
-				nxt2ppY += nxt2_pitchY;
-				nxt2pY += nxt2_pitchY;
-				nxt2pnY += nxt2_pitchY;
-				maskwY += mask_pitchY;
-			}
-			for (y=1; y&lt;HeightUV-1; y+=2)
-			{
-				for (x=0; x&lt;WidthUV; ++x)
-				{
-					t1 = (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
-					t2 = (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t3 = (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
-					t4 = (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
-					t5 = (abs(prvpV[x] - prv2pV[x]) &lt; mthreshC);
-					t6 = (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
-					t7 = (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
-					t8 = (abs(prvppV[x] - prv2ppV[x]) &lt; mthreshC);
-					t9 = (abs(prvpnV[x] - prv2pnV[x]) &lt; mthreshC);
-					t10 = (abs(nxtppV[x] - nxt2ppV[x]) &lt; mthreshC);
-					t11 = (abs(nxtpnV[x] - nxt2pnV[x]) &lt; mthreshC);
-					t12 = (abs(srcppV[x] - prv2ppV[x]) &lt; mthreshC);
-					t13 = (abs(srcpnV[x] - prv2pnV[x]) &lt; mthreshC);
-					t14 = (abs(nxtppV[x] - prvppV[x]) &lt; mthreshC);
-					t15 = (abs(nxtpnV[x] - prvpnV[x]) &lt; mthreshC);
-					t16 = (abs(nxt2ppV[x] - srcppV[x]) &lt; mthreshC);
-					t17 = (abs(nxt2pnV[x] - srcpnV[x]) &lt; mthreshC);
-					t18 = (abs(srcpV[x] - prv2pV[x]) &lt; mthreshC);
-					t19 = (abs(nxtpV[x] - prvpV[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwV[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwV[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwV[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwV[x] = 10;
-					else if (abs(prvpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(prvpV[x]-srcpnV[x])&lt;4) maskwV[x] = 120;
-					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
-					else maskwV[x] = 60;
-					t1 = (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
-					t2 = (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t3 = (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
-					t4 = (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
-					t5 = (abs(prvpU[x] - prv2pU[x]) &lt; mthreshC);
-					t6 = (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
-					t7 = (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
-					t8 = (abs(prvppU[x] - prv2ppU[x]) &lt; mthreshC);
-					t9 = (abs(prvpnU[x] - prv2pnU[x]) &lt; mthreshC);
-					t10 = (abs(nxtppU[x] - nxt2ppU[x]) &lt; mthreshC);
-					t11 = (abs(nxtpnU[x] - nxt2pnU[x]) &lt; mthreshC);
-					t12 = (abs(srcppU[x] - prv2ppU[x]) &lt; mthreshC);
-					t13 = (abs(srcpnU[x] - prv2pnU[x]) &lt; mthreshC);
-					t14 = (abs(nxtppU[x] - prvppU[x]) &lt; mthreshC);
-					t15 = (abs(nxtpnU[x] - prvpnU[x]) &lt; mthreshC);
-					t16 = (abs(nxt2ppU[x] - srcppU[x]) &lt; mthreshC);
-					t17 = (abs(nxt2pnU[x] - srcpnU[x]) &lt; mthreshC);
-					t18 = (abs(srcpU[x] - prv2pU[x]) &lt; mthreshC);
-					t19 = (abs(nxtpU[x] - prvpU[x]) &lt; mthreshC);
-					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
-							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
-							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
-							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
-						maskwU[x] = val1;
-					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwU[x] = val1;
-					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwU[x] = 20;
-					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwU[x] = 10;
-					else if (abs(prvpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(prvpU[x]-srcpnU[x])&lt;4) maskwU[x] = 120;
-					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
-					else maskwU[x] = 60;
-				}
-				prv2ppV += prv2_pitchUV;
-				prv2pV += prv2_pitchUV;
-				prv2pnV += prv2_pitchUV;
-				prv2ppU += prv2_pitchUV;
-				prv2pU += prv2_pitchUV;
-				prv2pnU += prv2_pitchUV;
-				prvppV += prv_pitchUV;
-				prvpV += prv_pitchUV;
-				prvpnV += prv_pitchUV;
-				prvppU += prv_pitchUV;
-				prvpU += prv_pitchUV;
-				prvpnU += prv_pitchUV;
-				srcppV += src_pitchUV;
-				srcpV += src_pitchUV;
-				srcpnV += src_pitchUV;
-				srcppU += src_pitchUV;
-				srcpU += src_pitchUV;
-				srcpnU += src_pitchUV;
-				nxtppV += nxt_pitchUV;
-				nxtpV += nxt_pitchUV;
-				nxtpnV += nxt_pitchUV;
-				nxtppU += nxt_pitchUV;
-				nxtpU += nxt_pitchUV;
-				nxtpnU += nxt_pitchUV;
-				nxt2ppV += nxt2_pitchUV;
-				nxt2pV += nxt2_pitchUV;
-				nxt2pnV += nxt2_pitchUV;
-				nxt2ppU += nxt2_pitchUV;
-				nxt2pU += nxt2_pitchUV;
-				nxt2pnU += nxt2_pitchUV;
-				maskwV += mask_pitchUV;
-				maskwU += mask_pitchUV;
-			}
-		}
-	}
-}
-
-void vidTDeint::linkFULL_YV12(ADMImage *mask) 
-{
-	unsigned char *maskpY = mask-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *maskpV = mask-&gt;GetWritePtr(PLANAR_V);
-	unsigned char *maskpU = mask-&gt;GetWritePtr(PLANAR_U);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchY2 = mask_pitchY&lt;&lt;1;
-	int mask_pitchY4 = mask_pitchY&lt;&lt;2;
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	int mask_pitchUV2 = mask_pitchUV&lt;&lt;1;
-	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
-	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
-	maskpY += mask_pitchY*PRM(field);
-	maskpV += mask_pitchUV*PRM(field);
-	maskpU += mask_pitchUV*PRM(field);
-	unsigned char *maskpnY = maskpY + mask_pitchY2;
-	int x, y;
-	for (y=PRM(field); y&lt;HeightUV; y+=2)
-	{
-		for (x=0; x&lt;WidthUV; ++x)
-		{
-			if (((((unsigned short*)maskpY)[x] == (unsigned short)0x3C3C) &amp;&amp; 
-				 (((unsigned short*)maskpnY)[x] == (unsigned short)0x3C3C)) ||
-				maskpV[x] == 0x3C || maskpU[x] == 0x3C)
-			{
-				((unsigned short*)maskpY)[x] = (unsigned short) 0x3C3C;
-				((unsigned short*)maskpnY)[x] = (unsigned short) 0x3C3C;
-				maskpV[x] = maskpU[x] = 0x3C;
-			}
-		}
-		maskpY += mask_pitchY4;
-		maskpnY += mask_pitchY4;
-		maskpV += mask_pitchUV2;
-		maskpU += mask_pitchUV2;
-	}
-}
-
-void vidTDeint::linkYtoUV_YV12(ADMImage *mask) 
-{
-	unsigned char *maskpY = mask-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *maskpV = mask-&gt;GetWritePtr(PLANAR_V);
-	unsigned char *maskpU = mask-&gt;GetWritePtr(PLANAR_U);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchY2 = mask_pitchY&lt;&lt;1;
-	int mask_pitchY4 = mask_pitchY&lt;&lt;2;
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	int mask_pitchUV2 = mask_pitchUV&lt;&lt;1;
-	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
-	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
-	maskpY += mask_pitchY*PRM(field);
-	maskpV += mask_pitchUV*PRM(field);
-	maskpU += mask_pitchUV*PRM(field);
-	unsigned char *maskpnY = maskpY + mask_pitchY2;
-	int x, y;
-	for (y=PRM(field); y&lt;HeightUV; y+=2)
-	{
-		for (x=0; x&lt;WidthUV; ++x)
-		{
-			if (((unsigned short*)maskpY)[x] == (unsigned short)0x3C3C &amp;&amp; 
-				((unsigned short*)maskpnY)[x] == (unsigned short)0x3C3C)
-			{
-				maskpV[x] = maskpU[x] = 0x3C;
-			}
-		}
-		maskpY += mask_pitchY4;
-		maskpnY += mask_pitchY4;
-		maskpV += mask_pitchUV2;
-		maskpU += mask_pitchUV2;
-	}
-}
-
-void vidTDeint::linkUVtoY_YV12(ADMImage *mask) 
-{
-	unsigned char *maskpY = mask-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *maskpV = mask-&gt;GetWritePtr(PLANAR_V);
-	unsigned char *maskpU = mask-&gt;GetWritePtr(PLANAR_U);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchY2 = mask_pitchY&lt;&lt;1;
-	int mask_pitchY4 = mask_pitchY&lt;&lt;2;
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	int mask_pitchUV2 = mask_pitchUV&lt;&lt;1;
-	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
-	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
-	maskpY += mask_pitchY*PRM(field);
-	maskpV += mask_pitchUV*PRM(field);
-	maskpU += mask_pitchUV*PRM(field);
-	unsigned char *maskpnY = maskpY + mask_pitchY2;
-	int x, y;
-	for (y=PRM(field); y&lt;HeightUV; y+=2)
-	{
-		for (x=0; x&lt;WidthUV; ++x)
-		{
-			if (maskpV[x] == 0x3C || maskpU[x] == 0x3C)
-			{
-				((unsigned short*)maskpY)[x] = (unsigned short) 0x3C3C;
-				((unsigned short*)maskpnY)[x] = (unsigned short) 0x3C3C;
-			}
-		}
-		maskpY += mask_pitchY4;
-		maskpnY += mask_pitchY4;
-		maskpV += mask_pitchUV2;
-		maskpU += mask_pitchUV2;
-	}
-}
-
-void vidTDeint::denoiseYV12(ADMImage *mask) 
-{
-	unsigned char *maskpY = mask-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *maskpV = mask-&gt;GetWritePtr(PLANAR_V);
-	unsigned char *maskpU = mask-&gt;GetWritePtr(PLANAR_U);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchY2 = mask_pitchY&lt;&lt;1;
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	int mask_pitchUV2 = mask_pitchUV&lt;&lt;1;
-	int HeightY = mask-&gt;GetHeight(PLANAR_Y);
-	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
-	int WidthY = mask-&gt;GetRowSize(PLANAR_Y);
-	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
-	maskpY += mask_pitchY*(2+PRM(field));
-	maskpV += mask_pitchUV*(2+PRM(field));
-	maskpU += mask_pitchUV*(2+PRM(field));
-	unsigned char *maskppY = maskpY - mask_pitchY2;
-	unsigned char *maskppV = maskpV - mask_pitchUV2;
-	unsigned char *maskppU = maskpU - mask_pitchUV2;
-	unsigned char *maskpnY = maskpY + mask_pitchY2;
-	unsigned char *maskpnV = maskpV + mask_pitchUV2;
-	unsigned char *maskpnU = maskpU + mask_pitchUV2;
-	int sum, xhi, v, x, y;
-	for (y=2; y&lt;HeightY-2; y+=2)
-	{
-		for (x=1; x&lt;WidthY-1; ++x)
-		{
-			if (maskpY[x] == 0x3C)
-			{
-				for (sum=0,v=x-1,xhi=x+2; v&lt;xhi &amp;&amp; sum&lt;2; ++v)
-				{
-					if (maskppY[v] == 0x3C) ++sum;
-					if (maskpY[v] == 0x3C) ++sum;
-					if (maskpnY[v] == 0x3C) ++sum;
-				}
-				if (sum &lt; 2) maskpY[x] = (maskpY[x-1] == maskpY[x+1]) ? maskpY[x-1] :
-								(maskppY[x] == maskpnY[x]) ? maskppY[x] : maskpY[x-1];
-			}
-		}
-		maskppY += mask_pitchY2;
-		maskpY += mask_pitchY2;
-		maskpnY += mask_pitchY2;
-	}
-	for (y=2; y&lt;HeightUV-2; y+=2)
-	{
-		for (x=1; x&lt;WidthUV-1; ++x)
-		{
-			if (maskpV[x] == 0x3C)
-			{
-				for (sum=0,v=x-1,xhi=x+2; v&lt;xhi &amp;&amp; sum&lt;2; ++v)
-				{
-					if (maskppV[v] == 0x3C) ++sum;
-					if (maskpV[v] == 0x3C) ++sum;
-					if (maskpnV[v] == 0x3C) ++sum;
-				}
-				if (sum &lt; 2) maskpV[x] = (maskpV[x-1] == maskpV[x+1]) ? maskpV[x-1] :
-								(maskppV[x] == maskpnV[x]) ? maskppV[x] : maskpV[x-1];
-			}
-			if (maskpU[x] == 0x3C)
-			{
-				for (sum=0,v=x-1,xhi=x+2; v&lt;xhi &amp;&amp; sum&lt;2; ++v)
-				{
-					if (maskppU[v] == 0x3C) ++sum;
-					if (maskpU[v] == 0x3C) ++sum;
-					if (maskpnU[v] == 0x3C) ++sum;
-				}
-				if (sum &lt; 2) maskpU[x] = (maskpU[x-1] == maskpU[x+1]) ? maskpU[x-1] :
-								(maskppU[x] == maskpnU[x]) ? maskppU[x] : maskpU[x-1];
-			}
-		}
-		maskppV += mask_pitchUV2;
-		maskpV += mask_pitchUV2;
-		maskpnV += mask_pitchUV2;
-		maskppU += mask_pitchUV2;
-		maskpU += mask_pitchUV2;
-		maskpnU += mask_pitchUV2;
-	}
-}
-
-bool vidTDeint::checkCombedYV12(ADMImage *src) 
-{
-	ADMImage *cmask = scratch;
-	const unsigned char *srcp, *srcpp, *srcppp, *srcpn, *srcpnn;
-	unsigned char *cmkp, *cmkpp, *cmkpn, *cmkpV, *cmkpU;
-	unsigned char *cmkpnn, *cmkppV, *cmkppU, *cmkpnV, *cmkpnU;
-	int cmk_pitch, src_pitch, Width, Height,  box1, box2;
-	ADM_PLANE plane;
-	int xblocks, yblocks, xblocks4, arraysize, cmk_pitchUV;
-	int x, y, b, sFirst, sSecond, temp1, temp2;
-	for (b=chroma ? 3 : 1; b&gt;0; --b)
-	{
-		if (b == 3) plane = PLANAR_U;
-		else if (b == 2) plane = PLANAR_V;
-		else plane = PLANAR_Y;
-		srcp = src-&gt;GetReadPtr(plane);
-		src_pitch = src-&gt;GetPitch(plane);
-		Width = src-&gt;GetRowSize(plane);
-		Height = src-&gt;GetHeight(plane);
-		srcpp = srcp - src_pitch;
-		srcppp = srcpp - src_pitch;
-		srcpn = srcp + src_pitch;
-		srcpnn = srcpn + src_pitch;
-		cmkp = cmask-&gt;GetWritePtr(plane);
-		cmk_pitch = cmask-&gt;GetPitch(plane);
-		memset(cmkp,0,Height*cmk_pitch);
-		for (x=0; x&lt;Width; ++x)
-		{
-			sFirst = srcp[x] - srcpn[x];
-			if (sFirst &gt; cthresh || sFirst &lt; -cthresh)
-			{
-				sFirst = abs(srcpnn[x]+(srcp[x]&lt;&lt;2)+srcpnn[x]-(3*(srcpn[x]+srcpn[x])));
-				if (sFirst &gt; cthresh6) cmkp[x] = 0x3C;
-			}
-		}
-		srcppp += src_pitch;
-		srcpp += src_pitch;
-		srcp += src_pitch;
-		srcpn += src_pitch;
-		srcpnn += src_pitch;
-		cmkp += cmk_pitch;
-		for (x=0; x&lt;Width; ++x)
-		{
-			sFirst = srcp[x] - srcpp[x];
-			sSecond = srcp[x] - srcpn[x];
-			if ((sFirst &gt; cthresh &amp;&amp; sSecond &gt; cthresh) || (sFirst &lt; -cthresh &amp;&amp; sSecond &lt; -cthresh))
-			{
-				sFirst = abs(srcpnn[x]+(srcp[x]&lt;&lt;2)+srcpnn[x]-(3*(srcpp[x]+srcpn[x])));
-				if (sFirst &gt; cthresh6) cmkp[x] = 0x3C;
-			}
-		}
-		srcppp += src_pitch;
-		srcpp += src_pitch;
-		srcp += src_pitch;
-		srcpn += src_pitch;
-		srcpnn += src_pitch;
-		cmkp += cmk_pitch;
-		for (y=2; y&lt;Height-2; ++y)
-		{
-			for (x=0; x&lt;Width; ++x)
-			{
-				sFirst = srcp[x] - srcpp[x];
-				sSecond = srcp[x] - srcpn[x];
-				if ((sFirst &gt; cthresh &amp;&amp; sSecond &gt; cthresh) || (sFirst &lt; -cthresh &amp;&amp; sSecond &lt; -cthresh))
-				{
-					sFirst = abs(srcppp[x]+(srcp[x]&lt;&lt;2)+srcpnn[x]-(3*(srcpp[x]+srcpn[x])));
-					if (sFirst &gt; cthresh6) cmkp[x] = 0x3C;
-				}	
-			}
-			srcppp += src_pitch;
-			srcpp += src_pitch;
-			srcp += src_pitch;
-			srcpn += src_pitch;
-			srcpnn += src_pitch;
-			cmkp += cmk_pitch;
-		}
-		for (x=0; x&lt;Width; ++x)
-		{
-			sFirst = srcp[x] - srcpp[x];
-			sSecond = srcp[x] - srcpn[x];
-			if ((sFirst &gt; cthresh &amp;&amp; sSecond &gt; cthresh) || (sFirst &lt; -cthresh &amp;&amp; sSecond &lt; -cthresh))
-			{
-				sFirst = abs(srcppp[x]+(srcp[x]&lt;&lt;2)+srcppp[x]-(3*(srcpp[x]+srcpn[x])));
-				if (sFirst &gt; cthresh6) cmkp[x] = 0x3C;
-			}
-		}
-		srcppp += src_pitch;
-		srcpp += src_pitch;
-		srcp += src_pitch;
-		srcpn += src_pitch;
-		srcpnn += src_pitch;
-		cmkp += cmk_pitch;
-		for (x=0; x&lt;Width; ++x)
-		{
-			sFirst = srcp[x] - srcpp[x];
-			if (sFirst &gt; cthresh || sFirst &lt; -cthresh)
-			{
-				sFirst = abs(srcppp[x]+(srcp[x]&lt;&lt;2)+srcppp[x]-(3*(srcpp[x]+srcpp[x])));
-				if (sFirst &gt; cthresh6) cmkp[x] = 0x3C;
-			}
-		}
-	}
-	if (chroma) 
-	{
-		cmkp = cmask-&gt;GetWritePtr(PLANAR_Y);
-		cmkpU = cmask-&gt;GetWritePtr(PLANAR_U);
-		cmkpV = cmask-&gt;GetWritePtr(PLANAR_V);
-		Width = cmask-&gt;GetRowSize(PLANAR_V);
-		Height = cmask-&gt;GetHeight(PLANAR_V);
-		cmk_pitch = cmask-&gt;GetPitch(PLANAR_Y);
-		cmk_pitchUV = cmask-&gt;GetPitch(PLANAR_V);
-		cmkpp = cmkp - cmk_pitch;
-		cmkpn = cmkp + cmk_pitch;
-		cmkpnn = cmkpn + cmk_pitch;
-		cmkppU = cmkpU - cmk_pitchUV;
-		cmkpnU = cmkpU + cmk_pitchUV;
-		cmkppV = cmkpV - cmk_pitchUV;
-		cmkpnV = cmkpV + cmk_pitchUV;
-		cmk_pitch &lt;&lt;= 1;
-		for (y=1; y&lt;Height-1; ++y)
-		{
-			cmkpp += cmk_pitch;
-			cmkp += cmk_pitch;
-			cmkpn += cmk_pitch;
-			cmkpnn += cmk_pitch;
-			cmkppV += cmk_pitchUV;
-			cmkpV += cmk_pitchUV;
-			cmkpnV += cmk_pitchUV;
-			cmkppU += cmk_pitchUV;
-			cmkpU += cmk_pitchUV;
-			cmkpnU += cmk_pitchUV;
-			for (x=1; x&lt;Width-1; ++x)
-			{
-				if ((cmkpV[x] == 0x3C &amp;&amp; (cmkpV[x-1] == 0x3C || cmkpV[x+1] == 0x3C ||
-					 cmkppV[x-1] == 0x3C || cmkppV[x] == 0x3C || cmkppV[x+1] == 0x3C ||
-					 cmkpnV[x-1] == 0x3C || cmkpnV[x] == 0x3C || cmkpnV[x+1] == 0x3C)) || 
-					(cmkpU[x] == 0x3C &amp;&amp; (cmkpU[x-1] == 0x3C || cmkpU[x+1] == 0x3C ||
-					 cmkppU[x-1] == 0x3C || cmkppU[x] == 0x3C || cmkppU[x+1] == 0x3C ||
-					 cmkpnU[x-1] == 0x3C || cmkpnU[x] == 0x3C || cmkpnU[x+1] == 0x3C)))
-				{
-					((unsigned short*)cmkp)[x] = (unsigned short) 0x3C3C;
-					((unsigned short*)cmkpn)[x] = (unsigned short) 0x3C3C;
-					if (y&amp;1) ((unsigned short*)cmkpp)[x] = (unsigned short) 0x3C3C;
-					else ((unsigned short*)cmkpnn)[x] = (unsigned short) 0x3C3C;
-				}
-			}
-		}
-	}
-	cmk_pitch = cmask-&gt;GetPitch(PLANAR_Y);
-	cmkp = cmask-&gt;GetWritePtr(PLANAR_Y) + cmk_pitch;
-	cmkpp = cmkp - cmk_pitch;
-	cmkpn = cmkp + cmk_pitch;
-	Width = cmask-&gt;GetRowSize(PLANAR_Y);
-	Height = cmask-&gt;GetHeight(PLANAR_Y);
-	xblocks = ((Width+xhalf)&gt;&gt;xshift) + 1;
-	xblocks4 = xblocks&lt;&lt;2;
-	yblocks = ((Height+yhalf)&gt;&gt;yshift) + 1;
-	arraysize = (xblocks*yblocks)&lt;&lt;2;
-	memset(cArray,0,arraysize*sizeof(int));
-	for (y=1; y&lt;Height-1; ++y)
-	{
-		temp1 = (y&gt;&gt;yshift)*xblocks4;
-		temp2 = ((y+yhalf)&gt;&gt;yshift)*xblocks4;
-		for (x=0; x&lt;Width; ++x)
-		{
-			if (cmkpp[x] == 0x3C &amp;&amp; cmkp[x] == 0x3C &amp;&amp; cmkpn[x] == 0x3C)
-			{
-				box1 = (x&gt;&gt;xshift)&lt;&lt;2;
-				box2 = ((x+xhalf)&gt;&gt;xshift)&lt;&lt;2;
-				++cArray[temp1+box1+0];
-				++cArray[temp1+box2+1];
-				++cArray[temp2+box1+2];
-				++cArray[temp2+box2+3];
-			}
-		}
-		cmkpp += cmk_pitch;
-		cmkp += cmk_pitch;
-		cmkpn += cmk_pitch;
-	}
-	for (x=0; x&lt;arraysize; ++x)
-	{
-		if (cArray[x] &gt; MI) return true;
-	}
-	return false;
-}
-
-void vidTDeint::subtractFieldsYV12(ADMImage *prv, ADMImage *src, ADMImage *nxt) 
-{
-	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
-	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
-	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
-	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
-	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
-	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
-	int WidthY = src-&gt;GetRowSize(PLANAR_Y)-8;
-	int HeightY = src-&gt;GetHeight(PLANAR_Y);
-	int WidthUV = src-&gt;GetRowSize(PLANAR_V)-4;
-	int HeightUV = src-&gt;GetHeight(PLANAR_V);
-	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
-	const unsigned char *prvpfY, *prvnfY, *nxtpfY, *nxtnfY;
-	const unsigned char *prvpfU, *prvnfU, *nxtpfU, *nxtnfU;
-	const unsigned char *prvpfV, *prvnfV, *nxtpfV, *nxtnfV;
-	const unsigned char *curpfY, *curfY, *curnfY;
-	const unsigned char *curpfU, *curfU, *curnfU;
-	const unsigned char *curpfV, *curfV, *curnfV;
-	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
-	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
-	int prvf_pitchY, prvf_pitchUV;
-	int curf_pitchY, curf_pitchUV;
-	int nxtf_pitchY, nxtf_pitchUV;
-	int x, y, temp, temp2;
-	accumP = accumN = 0;
-	if (PRM(field)^PRM(order))
-	{
-		prvf_pitchY = src_pitchY&lt;&lt;1;
-		prvf_pitchUV = src_pitchUV&lt;&lt;1;
-		curf_pitchY = src_pitchY&lt;&lt;1;
-		curf_pitchUV = src_pitchUV&lt;&lt;1;
-		nxtf_pitchY = nxt_pitchY&lt;&lt;1;
-		nxtf_pitchUV = nxt_pitchUV&lt;&lt;1;
-		prvpfY = srcpY + ((PRM(field) == 1 ? 1 : 2)*src_pitchY);
-		prvpfU = srcpU + ((PRM(field) == 1 ? 1 : 2)*src_pitchUV);
-		prvpfV = srcpV + ((PRM(field) == 1 ? 1 : 2)*src_pitchUV);
-		curfY = srcpY + ((3-PRM(field))*src_pitchY);
-		curfU = srcpU + ((3-PRM(field))*src_pitchUV);
-		curfV = srcpV + ((3-PRM(field))*src_pitchUV);
-		nxtpfY = nxtpY + ((PRM(field) == 1 ? 1 : 2)*nxt_pitchY);
-		nxtpfU = nxtpU + ((PRM(field) == 1 ? 1 : 2)*nxt_pitchUV);
-		nxtpfV = nxtpV + ((PRM(field) == 1 ? 1 : 2)*nxt_pitchUV);
-	}
-	else
-	{
-		prvf_pitchY = prv_pitchY&lt;&lt;1;
-		prvf_pitchUV = prv_pitchUV&lt;&lt;1;
-		curf_pitchY = src_pitchY&lt;&lt;1;
-		curf_pitchUV = src_pitchUV&lt;&lt;1;
-		nxtf_pitchY = src_pitchY&lt;&lt;1;
-		nxtf_pitchUV = src_pitchUV&lt;&lt;1;
-		prvpfY = prvpY + ((PRM(field) == 1 ? 1 : 2)*prv_pitchY);
-		prvpfU = prvpU + ((PRM(field) == 1 ? 1 : 2)*prv_pitchUV);
-		prvpfV = prvpV + ((PRM(field) == 1 ? 1 : 2)*prv_pitchUV);
-		curfY = srcpY + ((3-PRM(field))*src_pitchY);
-		curfU = srcpU + ((3-PRM(field))*src_pitchUV);
-		curfV = srcpV + ((3-PRM(field))*src_pitchUV);
-		nxtpfY = srcpY + ((PRM(field) == 1 ? 1 : 2)*src_pitchY);
-		nxtpfU = srcpU + ((PRM(field) == 1 ? 1 : 2)*src_pitchUV);
-		nxtpfV = srcpV + ((PRM(field) == 1 ? 1 : 2)*src_pitchUV);
-	}
-	prvnfY = prvpfY + prvf_pitchY;
-	prvnfU = prvpfU + prvf_pitchUV;
-	prvnfV = prvpfV + prvf_pitchUV;
-	curpfY = curfY - curf_pitchY;
-	curpfU = curfU - curf_pitchUV;
-	curpfV = curfV - curf_pitchUV;
-	curnfY = curfY + curf_pitchY;
-	curnfU = curfU + curf_pitchUV;
-	curnfV = curfV + curf_pitchUV;
-	nxtnfY = nxtpfY + nxtf_pitchY;
-	nxtnfU = nxtpfU + nxtf_pitchUV;
-	nxtnfV = nxtpfV + nxtf_pitchUV;
-	for (y=2; y&lt;HeightY-2; y+=2)
-	{
-		for (x=8; x&lt;WidthY; ++x)
-		{
-			if (abs(prvpfY[x]-nxtpfY[x]) &gt; 3 || abs(prvnfY[x]-nxtnfY[x]) &gt; 3)
-			{
-				temp = (curpfY[x]+(curfY[x]&lt;&lt;2)+curnfY[x]);
-				temp2 = abs(3*(prvpfY[x]+prvnfY[x])-temp);
-				if (temp2 &gt; 23) accumP += temp2;
-				temp2 = abs(3*(nxtpfY[x]+nxtnfY[x])-temp);
-				if (temp2 &gt; 23) accumN += temp2;
-			}
-		}
-		prvpfY += prvf_pitchY;
-		prvnfY += prvf_pitchY;
-		curpfY += curf_pitchY;
-		curfY += curf_pitchY;
-		curnfY += curf_pitchY;
-		nxtpfY += nxtf_pitchY;
-		nxtnfY += nxtf_pitchY;
-	}
-	for (y=2; y&lt;HeightUV-2; y+=2)
-	{
-		for (x=4; x&lt;WidthUV; ++x)
-		{
-			if (abs(prvpfU[x]-nxtpfU[x]) &gt; 3 || abs(prvnfU[x]-nxtnfU[x]) &gt; 3)
-			{
-				temp = (curpfU[x]+(curfU[x]&lt;&lt;2)+curnfU[x]);
-				temp2 = abs(3*(prvpfU[x]+prvnfU[x])-temp);
-				if (temp2 &gt; 23) accumP += temp2;
-				temp2 = abs(3*(nxtpfU[x]+nxtnfU[x])-temp);
-				if (temp2 &gt; 23) accumN += temp2;
-			}
-			if (abs(prvpfV[x]-nxtpfV[x]) &gt; 3 || abs(prvnfV[x]-nxtnfV[x]) &gt; 3)
-			{
-				temp = (curpfV[x]+(curfV[x]&lt;&lt;2)+curnfV[x]);
-				temp2 = abs(3*(prvpfV[x]+prvnfV[x])-temp);
-				if (temp2 &gt; 23) accumP += temp2;
-				temp2 = abs(3*(nxtpfV[x]+nxtnfV[x])-temp);
-				if (temp2 &gt; 23) accumN += temp2;
-			}
-		}
-		prvpfU += prvf_pitchUV;
-		prvnfU += prvf_pitchUV;
-		prvpfV += prvf_pitchUV;
-		prvnfV += prvf_pitchUV;
-		curpfU += curf_pitchUV;
-		curfU += curf_pitchUV;
-		curnfU += curf_pitchUV;
-		curpfV += curf_pitchUV;
-		curfV += curf_pitchUV;
-		curnfV += curf_pitchUV;
-		nxtpfU += nxtf_pitchUV;
-		nxtnfU += nxtf_pitchUV;
-		nxtpfV += nxtf_pitchUV;
-		nxtnfV += nxtf_pitchUV;
-	}
-}
-
-void vidTDeint::mapColorsYV12(ADMImage *dst, ADMImage *mask)
-{
-	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	int HeightY = mask-&gt;GetHeight(PLANAR_Y);
-	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
-	int WidthY = mask-&gt;GetRowSize(PLANAR_Y);
-	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
-	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
-	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
-	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
-	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
-	int x, y;
-	for (y=0; y&lt;HeightY; ++y)
-	{
-		for (x=0; x&lt;WidthY; ++x)
-		{
-			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = 0;
-			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = 51;
-			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = 102;
-			else if (maskpY[x] == 40) dstpY[x] = 153;
-			else if (maskpY[x] == 50) dstpY[x] = 204;
-			else if (maskpY[x] == 60) dstpY[x] = 255;
-		}
-		maskpY += mask_pitchY;
-		dstpY += dst_pitchY;
-	}
-	for (y=0; y&lt;HeightUV; ++y)
-	{
-		for (x=0; x&lt;WidthUV; ++x)
-		{
-			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = 0;
-			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = 51;
-			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = 102;
-			else if (maskpV[x] == 40) dstpV[x] = 153;
-			else if (maskpV[x] == 50) dstpV[x] = 204;
-			else if (maskpV[x] == 60) dstpV[x] = 255;
-			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = 0;
-			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = 51;
-			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = 102;
-			else if (maskpU[x] == 40) dstpU[x] = 153;
-			else if (maskpU[x] == 50) dstpU[x] = 204;
-			else if (maskpU[x] == 60) dstpU[x] = 255;
-		}
-		maskpV += mask_pitchUV;
-		maskpU += mask_pitchUV;
-		dstpV += dst_pitchUV;
-		dstpU += dst_pitchUV;
-	}
-}
-
-void vidTDeint::mapMergeYV12(ADMImage *dst, ADMImage *mask, 
-		ADMImage *prv, ADMImage *src, ADMImage *nxt)
-{
-	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	int HeightY = mask-&gt;GetHeight(PLANAR_Y);
-	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
-	int WidthY = mask-&gt;GetRowSize(PLANAR_Y);
-	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
-	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
-	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
-	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
-	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
-	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
-	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
-	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
-	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
-	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
-	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
-	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
-	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
-	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
-	int x, y;
-	for (y=0; y&lt;HeightY; ++y)
-	{
-		for (x=0; x&lt;WidthY; ++x)
-		{
-			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = srcpY[x];
-			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = prvpY[x];
-			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = nxtpY[x];
-			else if (maskpY[x] == 40) dstpY[x] = (srcpY[x]+nxtpY[x]+1)&gt;&gt;1;
-			else if (maskpY[x] == 50) dstpY[x] = (srcpY[x]+prvpY[x]+1)&gt;&gt;1;
-			else if (maskpY[x] == 60) dstpY[x] = 255;
-		}
-		prvpY += prv_pitchY;
-		srcpY += src_pitchY;
-		nxtpY += nxt_pitchY;
-		maskpY += mask_pitchY;
-		dstpY += dst_pitchY;
-	}
-	for (y=0; y&lt;HeightUV; ++y)
-	{
-		for (x=0; x&lt;WidthUV; ++x)
-		{
-			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = srcpV[x];
-			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = prvpV[x];
-			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = nxtpV[x];
-			else if (maskpV[x] == 40) dstpV[x] = (srcpV[x]+nxtpV[x]+1)&gt;&gt;1;
-			else if (maskpV[x] == 50) dstpV[x] = (srcpV[x]+prvpV[x]+1)&gt;&gt;1;
-			else if (maskpV[x] == 60) dstpV[x] = 255;
-			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = srcpU[x];
-			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = prvpU[x];
-			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = nxtpU[x];
-			else if (maskpU[x] == 40) dstpU[x] = (srcpU[x]+nxtpU[x]+1)&gt;&gt;1;
-			else if (maskpU[x] == 50) dstpU[x] = (srcpU[x]+prvpU[x]+1)&gt;&gt;1;
-			else if (maskpU[x] == 60) dstpU[x] = 255;
-		}
-		prvpV += prv_pitchUV;
-		prvpU += prv_pitchUV;
-		srcpV += src_pitchUV;
-		srcpU += src_pitchUV;
-		nxtpV += nxt_pitchUV;
-		nxtpU += nxt_pitchUV;
-		maskpV += mask_pitchUV;
-		maskpU += mask_pitchUV;
-		dstpV += dst_pitchUV;
-		dstpU += dst_pitchUV;
-	}
-}
-
-void vidTDeint::cubicDeintYV12(ADMImage *dst, ADMImage *mask, 
-		ADMImage *prv, ADMImage *src, ADMImage *nxt)
-{
-	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
-	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
-	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
-	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
-	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
-	int src_pitchY2 = src_pitchY&lt;&lt;1;
-	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
-	int src_pitchUV2 = src_pitchUV&lt;&lt;1;
-	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
-	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
-	int HeightY = src-&gt;GetHeight(PLANAR_Y);
-	int HeightUV = src-&gt;GetHeight(PLANAR_V);
-	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
-	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
-	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
-	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
-	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
-	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
-	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
-	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	const unsigned char *srcppY = srcpY - src_pitchY;
-	const unsigned char *srcpppY = srcppY - src_pitchY2;
-	const unsigned char *srcpnY = srcpY + src_pitchY;
-	const unsigned char *srcpnnY = srcpnY + src_pitchY2;
-	const unsigned char *srcppV = srcpV - src_pitchUV;
-	const unsigned char *srcpppV = srcppV - src_pitchUV2;
-	const unsigned char *srcpnV = srcpV + src_pitchUV;
-	const unsigned char *srcpnnV = srcpnV + src_pitchUV2;
-	const unsigned char *srcppU = srcpU - src_pitchUV;
-	const unsigned char *srcpppU = srcppU - src_pitchUV2;
-	const unsigned char *srcpnU = srcpU + src_pitchUV;
-	const unsigned char *srcpnnU = srcpnU + src_pitchUV2;
-	int x, y;
-	for (y=0; y&lt;HeightY; ++y)
-	{
-		for (x=0; x&lt;WidthY; ++x)
-		{
-			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = srcpY[x];
-			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = prvpY[x];
-			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = nxtpY[x];
-			else if (maskpY[x] == 40) dstpY[x] = (srcpY[x]+nxtpY[x]+1)&gt;&gt;1;
-			else if (maskpY[x] == 50) dstpY[x] = (srcpY[x]+prvpY[x]+1)&gt;&gt;1;
-			else if (maskpY[x] == 60)
-			{
-				if (y&lt;3 || y&gt;HeightY-4) dstpY[x] = (srcpnY[x]+srcppY[x]+1)&gt;&gt;1;
-				else dstpY[x] = cubicInt(srcpppY[x],srcppY[x],srcpnY[x],srcpnnY[x]);
-			}
-		}
-		prvpY += prv_pitchY;
-		srcpppY += src_pitchY;
-		srcppY += src_pitchY;
-		srcpY += src_pitchY;
-		srcpnY += src_pitchY;
-		srcpnnY += src_pitchY;
-		nxtpY += nxt_pitchY;
-		maskpY += mask_pitchY;
-		dstpY += dst_pitchY;
-	}
-	for (y=0; y&lt;HeightUV; ++y)
-	{
-		for (x=0; x&lt;WidthUV; ++x)
-		{
-			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = srcpV[x];
-			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = prvpV[x];
-			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = nxtpV[x];
-			else if (maskpV[x] == 40) dstpV[x] = (srcpV[x]+nxtpV[x]+1)&gt;&gt;1;
-			else if (maskpV[x] == 50) dstpV[x] = (srcpV[x]+prvpV[x]+1)&gt;&gt;1;
-			else if (maskpV[x] == 60)
-			{
-				if (y&lt;3 || y&gt;HeightUV-4) dstpV[x] = (srcpnV[x]+srcppV[x]+1)&gt;&gt;1;
-				else dstpV[x] = cubicInt(srcpppV[x],srcppV[x],srcpnV[x],srcpnnV[x]);
-			}
-			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = srcpU[x];
-			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = prvpU[x];
-			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = nxtpU[x];
-			else if (maskpU[x] == 40) dstpU[x] = (srcpU[x]+nxtpU[x]+1)&gt;&gt;1;
-			else if (maskpU[x] == 50) dstpU[x] = (srcpU[x]+prvpU[x]+1)&gt;&gt;1;
-			else if (maskpU[x] == 60)
-			{
-				if (y&lt;3 || y&gt;HeightUV-4) dstpU[x] = (srcpnU[x]+srcppU[x]+1)&gt;&gt;1;
-				else dstpU[x] = cubicInt(srcpppU[x],srcppU[x],srcpnU[x],srcpnnU[x]);
-			}
-		}
-		prvpV += prv_pitchUV;
-		prvpU += prv_pitchUV;
-		srcpppV += src_pitchUV;
-		srcppV += src_pitchUV;
-		srcpV += src_pitchUV;
-		srcpnV += src_pitchUV;
-		srcpnnV += src_pitchUV;
-		srcpppU += src_pitchUV;
-		srcppU += src_pitchUV;
-		srcpU += src_pitchUV;
-		srcpnU += src_pitchUV;
-		srcpnnU += src_pitchUV;
-		nxtpV += nxt_pitchUV;
-		nxtpU += nxt_pitchUV;
-		maskpV += mask_pitchUV;
-		maskpU += mask_pitchUV;
-		dstpV += dst_pitchUV;
-		dstpU += dst_pitchUV;
-	}
-}
-
-void vidTDeint::ELADeintYV12(ADMImage *dst, ADMImage *mask, 
-		ADMImage *prv, ADMImage *src, ADMImage *nxt)
-{
-	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
-	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
-	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
-	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
-	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
-	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
-	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
-	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
-	int HeightY = src-&gt;GetHeight(PLANAR_Y);
-	int HeightUV = src-&gt;GetHeight(PLANAR_V);
-	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
-	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
-	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
-	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
-	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
-	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
-	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
-	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	const unsigned char *srcppY = srcpY - src_pitchY;
-	const unsigned char *srcpnY = srcpY + src_pitchY;
-	const unsigned char *srcppV = srcpV - src_pitchUV;
-	const unsigned char *srcpnV = srcpV + src_pitchUV;
-	const unsigned char *srcppU = srcpU - src_pitchUV;
-	const unsigned char *srcpnU = srcpU + src_pitchUV;
-	int x, y, u, val, stop, temp1, temp2, min, minf, maxf, s1, s2;
-	for (y=0; y&lt;HeightY; ++y)
-	{
-		for (x=0; x&lt;WidthY; ++x)
-		{
-			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = srcpY[x];
-			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = prvpY[x];
-			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = nxtpY[x];
-			else if (maskpY[x] == 40) dstpY[x] = (srcpY[x]+nxtpY[x]+1)&gt;&gt;1;
-			else if (maskpY[x] == 50) dstpY[x] = (srcpY[x]+prvpY[x]+1)&gt;&gt;1;
-			else if (maskpY[x] == 60)
-			{
-				if (x &lt; 2 || x &gt; WidthY-3 || (abs(srcppY[x]-srcpnY[x]) &lt; 10 &amp;&amp;
-					abs(srcppY[x-2]-srcppY[x+2]) &lt; 10 &amp;&amp; abs(srcpnY[x-2]-srcpnY[x+2]) &lt; 10))
-				{
-					dstpY[x] = (srcppY[x]+srcpnY[x]+1)&gt;&gt;1;
-				}
-				else
-				{
-					stop = min(x-1,min(8,WidthY-2-x));
-					minf = min(srcppY[x],srcpnY[x])-2;
-					maxf = max(srcppY[x],srcpnY[x])+2;
-					val = (srcppY[x]+srcpnY[x]+1)&gt;&gt;1;
-					for (min=450, u=0; u&lt;=stop; ++u)
-					{
-						s1 = srcppY[x+(u&gt;&gt;1)]+srcppY[x+((u+1)&gt;&gt;1)];
-						s2 = srcpnY[x-(u&gt;&gt;1)]+srcpnY[x-((u+1)&gt;&gt;1)];
-						temp1 = abs(s1-s2) + abs(srcppY[x-1]-srcpnY[x-1-u]) + 
-							(abs(srcppY[x]-srcpnY[x-u])&lt;&lt;1) + abs(srcppY[x+1]-srcpnY[x+1-u]) +
-							abs(srcpnY[x-1]-srcppY[x-1+u]) + (abs(srcpnY[x]-srcppY[x+u])&lt;&lt;1) + 
-							abs(srcpnY[x+1]-srcppY[x+1+u]);
-						temp2 = (s1+s2+2)&gt;&gt;2;
-						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
-						{
-							min = temp1;
-							val = temp2;
-						}
-						s1 = srcppY[x-(u&gt;&gt;1)]+srcppY[x-((u+1)&gt;&gt;1)];
-						s2 = srcpnY[x+(u&gt;&gt;1)]+srcpnY[x+((u+1)&gt;&gt;1)];
-						temp1 = abs(s1-s2) + abs(srcppY[x-1]-srcpnY[x-1+u]) + 
-							(abs(srcppY[x]-srcpnY[x+u])&lt;&lt;1) + abs(srcppY[x+1]-srcpnY[x+1+u])+
-							abs(srcpnY[x-1]-srcppY[x-1-u]) + (abs(srcpnY[x]-srcppY[x-u])&lt;&lt;1) +
-							abs(srcpnY[x+1]-srcppY[x+1-u]);
-						temp2 = (s1+s2+2)&gt;&gt;2;
-						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
-						{
-							min = temp1;
-							val = temp2;
-						}
-					}
-					dstpY[x] = val;
-				}
-			}
-		}
-		prvpY += prv_pitchY;
-		srcppY += src_pitchY;
-		srcpY += src_pitchY;
-		srcpnY += src_pitchY;
-		nxtpY += nxt_pitchY;
-		maskpY += mask_pitchY;
-		dstpY += dst_pitchY;
-	}
-	for (y=0; y&lt;HeightUV; ++y)
-	{
-		for (x=0; x&lt;WidthUV; ++x)
-		{
-			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = srcpV[x];
-			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = prvpV[x];
-			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = nxtpV[x];
-			else if (maskpV[x] == 40) dstpV[x] = (srcpV[x]+nxtpV[x]+1)&gt;&gt;1;
-			else if (maskpV[x] == 50) dstpV[x] = (srcpV[x]+prvpV[x]+1)&gt;&gt;1;
-			else if (maskpV[x] == 60)
-			{
-				if (x &lt; 2 || x &gt; WidthUV-3 || (abs(srcppV[x]-srcpnV[x]) &lt; 10 &amp;&amp;
-					abs(srcppV[x-2]-srcppV[x+2]) &lt; 10 &amp;&amp; abs(srcpnV[x-2]-srcpnV[x+2]) &lt; 10)) 
-				{
-					dstpV[x] = (srcppV[x]+srcpnV[x]+1)&gt;&gt;1;
-				}
-				else
-				{
-					stop = min(x-1,min(4,WidthUV-2-x));
-					minf = min(srcppV[x],srcpnV[x])-2;
-					maxf = max(srcppV[x],srcpnV[x])+2;
-					val = (srcppV[x]+srcpnV[x]+1)&gt;&gt;1;
-					for (min=450, u=0; u&lt;=stop; ++u) 
-					{
-						s1 = srcppV[x+(u&gt;&gt;1)]+srcppV[x+((u+1)&gt;&gt;1)];
-						s2 = srcpnV[x-(u&gt;&gt;1)]+srcpnV[x-((u+1)&gt;&gt;1)];
-						temp1 = abs(s1-s2) + abs(srcppV[x-1]-srcpnV[x-1-u]) +
-							(abs(srcppV[x]-srcpnV[x-u])&lt;&lt;1) + abs(srcppV[x+1]-srcpnV[x+1-u]) +
-							abs(srcpnV[x-1]-srcppV[x-1+u]) + (abs(srcpnV[x]-srcppV[x+u])&lt;&lt;1) +
-							abs(srcpnV[x+1]-srcppV[x+1+u]);
-						temp2 = (s1+s2+2)&gt;&gt;2;
-						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
-						{
-							min = temp1;
-							val = temp2;
-						}
-						s1 = srcppV[x-(u&gt;&gt;1)]+srcppV[x-((u+1)&gt;&gt;1)];
-						s2 = srcpnV[x+(u&gt;&gt;1)]+srcpnV[x+((u+1)&gt;&gt;1)];
-						temp1 = abs(s1-s2) + abs(srcppV[x-1]-srcpnV[x-1+u]) + 
-							(abs(srcppV[x]-srcpnV[x+u])&lt;&lt;1) + abs(srcppV[x+1]-srcpnV[x+1+u]) +
-							abs(srcpnV[x-1]-srcppV[x-1-u]) + (abs(srcpnV[x]-srcppV[x-u])&lt;&lt;1) + 
-							abs(srcpnV[x+1]-srcppV[x+1-u]);
-						temp2 = (s1+s2+2)&gt;&gt;2;
-						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
-						{
-							min = temp1;
-							val = temp2;
-						}
-					}
-					dstpV[x] = val;
-				}
-			}
-			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = srcpU[x];
-			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = prvpU[x];
-			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = nxtpU[x];
-			else if (maskpU[x] == 40) dstpU[x] = (srcpU[x]+nxtpU[x]+1)&gt;&gt;1;
-			else if (maskpU[x] == 50) dstpU[x] = (srcpU[x]+prvpU[x]+1)&gt;&gt;1;
-			else if (maskpU[x] == 60)
-			{
-				if (x &lt; 2 || x &gt; WidthUV-3 || (abs(srcppU[x]-srcpnU[x]) &lt; 10 &amp;&amp;
-					abs(srcppU[x-2]-srcppU[x+2]) &lt; 10 &amp;&amp; abs(srcpnU[x-2]-srcpnU[x+2]) &lt; 10)) 
-				{
-					dstpU[x] = (srcppU[x]+srcpnU[x]+1)&gt;&gt;1;
-				}
-				else
-				{
-					stop = min(x-1,min(4,WidthUV-2-x));
-					minf = min(srcppU[x],srcpnU[x])-2;
-					maxf = max(srcppU[x],srcpnU[x])+2;
-					val = (srcppU[x]+srcpnU[x]+1)&gt;&gt;1;
-					for (min=450, u=0; u&lt;=stop; ++u) 
-					{
-						s1 = srcppU[x+(u&gt;&gt;1)]+srcppU[x+((u+1)&gt;&gt;1)];
-						s2 = srcpnU[x-(u&gt;&gt;1)]+srcpnU[x-((u+1)&gt;&gt;1)];
-						temp1 = abs(s1-s2) + abs(srcppU[x-1]-srcpnU[x-1-u]) +
-							(abs(srcppU[x]-srcpnU[x-u])&lt;&lt;1) + abs(srcppU[x+1]-srcpnU[x+1-u]) +
-							abs(srcpnU[x-1]-srcppU[x-1+u]) + (abs(srcpnU[x]-srcppU[x+u])&lt;&lt;1) +
-							abs(srcpnU[x+1]-srcppU[x+1+u]);
-						temp2 = (s1+s2+2)&gt;&gt;2;
-						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
-						{
-							min = temp1;
-							val = temp2;
-						}
-						s1 = srcppU[x-(u&gt;&gt;1)]+srcppU[x-((u+1)&gt;&gt;1)];
-						s2 = srcpnU[x+(u&gt;&gt;1)]+srcpnU[x+((u+1)&gt;&gt;1)];
-						temp1 = abs(s1-s2) + abs(srcppU[x-1]-srcpnU[x-1+u]) + 
-							(abs(srcppU[x]-srcpnU[x+u])&lt;&lt;1) + abs(srcppU[x+1]-srcpnU[x+1+u]) +
-							abs(srcpnU[x-1]-srcppU[x-1-u]) + (abs(srcpnU[x]-srcppU[x-u])&lt;&lt;1) +
-							abs(srcpnU[x+1]-srcppU[x+1-u]);
-						temp2 = (s1+s2+2)&gt;&gt;2;
-						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
-						{
-							min = temp1;
-							val = temp2;
-						}
-					}
-					dstpU[x] = val;
-				}
-			}
-		}
-		prvpV += prv_pitchUV;
-		prvpU += prv_pitchUV;
-		srcppV += src_pitchUV;
-		srcpV += src_pitchUV;
-		srcpnV += src_pitchUV;
-		srcppU += src_pitchUV;
-		srcpU += src_pitchUV;
-		srcpnU += src_pitchUV;
-		nxtpV += nxt_pitchUV;
-		nxtpU += nxt_pitchUV;
-		maskpV += mask_pitchUV;
-		maskpU += mask_pitchUV;
-		dstpV += dst_pitchUV;
-		dstpU += dst_pitchUV;
-	}
-}
-
-void vidTDeint::kernelDeintYV12(ADMImage *dst, ADMImage *mask, 
-		ADMImage *prv, ADMImage *src, ADMImage *nxt)
-{
-	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
-	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
-	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
-	int prv_pitchY2 = prv_pitchY&lt;&lt;1;
-	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
-	int prv_pitchUV2 = prv_pitchUV&lt;&lt;1;
-	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
-	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
-	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
-	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
-	int src_pitchY2 = src_pitchY&lt;&lt;1;
-	int src_pitchUV2 = src_pitchUV&lt;&lt;1;
-	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
-	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
-	int HeightY = src-&gt;GetHeight(PLANAR_Y);
-	int HeightUV = src-&gt;GetHeight(PLANAR_V);
-	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
-	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
-	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
-	int nxt_pitchY2 = nxt_pitchY&lt;&lt;1;
-	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
-	int nxt_pitchUV2 = nxt_pitchUV&lt;&lt;1;
-	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
-	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
-	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
-	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
-	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
-	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	const unsigned char *srcppY = srcpY - src_pitchY;
-	const unsigned char *srcppU = srcpU - src_pitchUV;
-	const unsigned char *srcppV = srcpV - src_pitchUV;
-	const unsigned char *srcpppY = srcppY - src_pitchY2;
-	const unsigned char *srcpppU = srcppU - src_pitchUV2;
-	const unsigned char *srcpppV = srcppV - src_pitchUV2;
-	const unsigned char *srcpnY = srcpY + src_pitchY;
-	const unsigned char *srcpnU = srcpU + src_pitchUV;
-	const unsigned char *srcpnV = srcpV + src_pitchUV;
-	const unsigned char *srcpnnY = srcpnY + src_pitchY2;
-	const unsigned char *srcpnnU = srcpnU + src_pitchUV2;
-	const unsigned char *srcpnnV = srcpnV + src_pitchUV2;
-	const unsigned char *kercY, *kerpY, *kerppY, *kernY, *kernnY;
-	const unsigned char *kercU, *kerpU, *kerppU, *kernU, *kernnU;
-	const unsigned char *kercV, *kerpV, *kerppV, *kernV, *kernnV;
-	int ker_pitchY, ker_pitchUV, x, y, temp;
-	if (accumP &lt;= accumN)
-	{
-		if (PRM(field)^PRM(order))
-		{
-			ker_pitchY = src_pitchY;
-			ker_pitchUV = src_pitchUV;
-			kerppY = srcpY - (src_pitchY2&lt;&lt;1);
-			kerppU = srcpU - (src_pitchUV2&lt;&lt;1);
-			kerppV = srcpV - (src_pitchUV2&lt;&lt;1);
-			kerpY = srcpY - src_pitchY2;
-			kerpU = srcpU - src_pitchUV2;
-			kerpV = srcpV - src_pitchUV2;
-			kercY = srcpY;
-			kercU = srcpU;
-			kercV = srcpV;
-			kernY = srcpY + src_pitchY2;
-			kernU = srcpU + src_pitchUV2;
-			kernV = srcpV + src_pitchUV2;
-			kernnY = srcpY + (src_pitchY2&lt;&lt;1);
-			kernnU = srcpU + (src_pitchUV2&lt;&lt;1);
-			kernnV = srcpV + (src_pitchUV2&lt;&lt;1);
-		}
-		else
-		{
-			ker_pitchY = prv_pitchY;
-			ker_pitchUV = prv_pitchUV;
-			kerppY = prvpY - (prv_pitchY2&lt;&lt;1);
-			kerppU = prvpU - (prv_pitchUV2&lt;&lt;1);
-			kerppV = prvpV - (prv_pitchUV2&lt;&lt;1);
-			kerpY = prvpY - prv_pitchY2;
-			kerpU = prvpU - prv_pitchUV2;
-			kerpV = prvpV - prv_pitchUV2;
-			kercY = prvpY;
-			kercU = prvpU;
-			kercV = prvpV;
-			kernY = prvpY + prv_pitchY2;
-			kernU = prvpU + prv_pitchUV2;
-			kernV = prvpV + prv_pitchUV2;
-			kernnY = prvpY + (prv_pitchY2&lt;&lt;1);
-			kernnU = prvpU + (prv_pitchUV2&lt;&lt;1);
-			kernnV = prvpV + (prv_pitchUV2&lt;&lt;1);
-		}
-	}
-	else
-	{
-		if (PRM(field)^PRM(order))
-		{
-			ker_pitchY = nxt_pitchY;
-			ker_pitchUV = nxt_pitchUV;
-			kerppY = nxtpY - (nxt_pitchY2&lt;&lt;1);
-			kerppU = nxtpU - (nxt_pitchUV2&lt;&lt;1);
-			kerppV = nxtpV - (nxt_pitchUV2&lt;&lt;1);
-			kerpY = nxtpY - nxt_pitchY2;
-			kerpU = nxtpU - nxt_pitchUV2;
-			kerpV = nxtpV - nxt_pitchUV2;
-			kercY = nxtpY;
-			kercU = nxtpU;
-			kercV = nxtpV;
-			kernY = nxtpY + nxt_pitchY2;
-			kernU = nxtpU + nxt_pitchUV2;
-			kernV = nxtpV + nxt_pitchUV2;
-			kernnY = nxtpY + (nxt_pitchY2&lt;&lt;1);
-			kernnU = nxtpU + (nxt_pitchUV2&lt;&lt;1);
-			kernnV = nxtpV + (nxt_pitchUV2&lt;&lt;1);
-		}
-		else
-		{
-			ker_pitchY = src_pitchY;
-			ker_pitchUV = src_pitchUV;
-			kerppY = srcpY - (src_pitchY2&lt;&lt;1);
-			kerppU = srcpU - (src_pitchUV2&lt;&lt;1);
-			kerppV = srcpV - (src_pitchUV2&lt;&lt;1);
-			kerpY = srcpY - src_pitchY2;
-			kerpU = srcpU - src_pitchUV2;
-			kerpV = srcpV - src_pitchUV2;
-			kercY = srcpY;
-			kercU = srcpU;
-			kercV = srcpV;
-			kernY = srcpY + src_pitchY2;
-			kernU = srcpU + src_pitchUV2;
-			kernV = srcpV + src_pitchUV2;
-			kernnY = srcpY + (src_pitchY2&lt;&lt;1);
-			kernnU = srcpU + (src_pitchUV2&lt;&lt;1);
-			kernnV = srcpV + (src_pitchUV2&lt;&lt;1);
-		}
-	}
-	for (y=0; y&lt;HeightY; ++y)
-	{
-		for (x=0; x&lt;WidthY; ++x)
-		{
-			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = srcpY[x];
-			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = prvpY[x];
-			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = nxtpY[x];
-			else if (maskpY[x] == 40) dstpY[x] = (srcpY[x]+nxtpY[x]+1)&gt;&gt;1;
-			else if (maskpY[x] == 50) dstpY[x] = (srcpY[x]+prvpY[x]+1)&gt;&gt;1;
-			else if (maskpY[x] == 60)
-			{
-				if (sharp &amp;&amp; y&gt;3 &amp;&amp; y&lt;HeightY-4)
-				{
-					temp = (int)((0.526*(srcppY[x]+srcpnY[x]) + 
-								  0.170*(kercY[x]) - 
-								  0.116*(kerpY[x]+kernY[x]) - 
-								  0.026*(srcpppY[x]+srcpnnY[x]) + 
-								  0.031*(kerppY[x] + kernnY[x])) + 0.5f);
-					if (temp &gt; 255) dstpY[x] = 255;
-					else if (temp &lt; 0) dstpY[x] = 0;
-					else dstpY[x] = temp;
-				}
-				else if (y&gt;1 &amp;&amp; y&lt;HeightY-2)
-				{
-					temp = (((srcppY[x]+srcpnY[x])&lt;&lt;3)+
-							(kercY[x]&lt;&lt;1)-(kerpY[x]+kernY[x])+8) &gt;&gt; 4;
-					if (temp &gt; 255) dstpY[x] = 255;
-					else if (temp &lt; 0) dstpY[x] = 0;
-					else dstpY[x] = temp;
-				}
-				else dstpY[x] = (srcpnY[x]+srcppY[x]+1)&gt;&gt;1;
-			}
-		}
-		prvpY += prv_pitchY;
-		srcpppY += src_pitchY;
-		srcppY += src_pitchY;
-		srcpY += src_pitchY;
-		srcpnY += src_pitchY;
-		srcpnnY += src_pitchY;
-		kerppY += ker_pitchY;
-		kerpY += ker_pitchY;
-		kercY += ker_pitchY;
-		kernY += ker_pitchY;
-		kernnY += ker_pitchY;
-		nxtpY += nxt_pitchY;
-		maskpY += mask_pitchY;
-		dstpY += dst_pitchY;
-	}
-	for (y=0; y&lt;HeightUV; ++y)
-	{
-		for (x=0; x&lt;WidthUV; ++x)
-		{
-			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = srcpU[x];
-			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = prvpU[x];
-			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = nxtpU[x];
-			else if (maskpU[x] == 40) dstpU[x] = (srcpU[x]+nxtpU[x]+1)&gt;&gt;1;
-			else if (maskpU[x] == 50) dstpU[x] = (srcpU[x]+prvpU[x]+1)&gt;&gt;1;
-			else if (maskpU[x] == 60)
-			{
-				if (sharp &amp;&amp; y&gt;3 &amp;&amp; y&lt;HeightUV-4)
-				{
-					temp = (int)((0.526*(srcppU[x]+srcpnU[x]) + 
-								  0.170*(kercU[x]) - 
-								  0.116*(kerpU[x]+kernU[x]) - 
-								  0.026*(srcpppU[x]+srcpnnU[x]) + 
-								  0.031*(kerppU[x] + kernnU[x])) + 0.5f);
-					if (temp &gt; 255) dstpU[x] = 255;
-					else if (temp &lt; 0) dstpU[x] = 0;
-					else dstpU[x] = temp;
-				}
-				else if (y&gt;1 &amp;&amp; y&lt;HeightUV-2)
-				{
-					temp = (((srcppU[x]+srcpnU[x])&lt;&lt;3)+
-							(kercU[x]&lt;&lt;1)-(kerpU[x]+kernU[x])+8) &gt;&gt; 4;
-					if (temp &gt; 255) dstpU[x] = 255;
-					else if (temp &lt; 0) dstpU[x] = 0;
-					else dstpU[x] = temp;
-				}
-				else dstpU[x] = (srcpnU[x]+srcppU[x]+1)&gt;&gt;1;
-			}
-			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = srcpV[x];
-			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = prvpV[x];
-			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = nxtpV[x];
-			else if (maskpV[x] == 40) dstpV[x] = (srcpV[x]+nxtpV[x]+1)&gt;&gt;1;
-			else if (maskpV[x] == 50) dstpV[x] = (srcpV[x]+prvpV[x]+1)&gt;&gt;1;
-			else if (maskpV[x] == 60)
-			{
-				if (sharp &amp;&amp; y&gt;3 &amp;&amp; y&lt;HeightUV-4)
-				{
-					temp = (int)((0.526*(srcppV[x]+srcpnV[x]) + 
-								  0.170*(kercV[x]) - 
-								  0.116*(kerpV[x]+kernV[x]) - 
-								  0.026*(srcpppV[x]+srcpnnV[x]) + 
-								  0.031*(kerppV[x] + kernnV[x])) + 0.5f);
-					if (temp &gt; 255) dstpV[x] = 255;
-					else if (temp &lt; 0) dstpV[x] = 0;
-					else dstpV[x] = temp;
-				}
-				else if (y&gt;1 &amp;&amp; y&lt;HeightUV-2)
-				{
-					temp = (((srcppV[x]+srcpnV[x])&lt;&lt;3)+
-							(kercV[x]&lt;&lt;1)-(kerpV[x]+kernV[x])+8) &gt;&gt; 4;
-					if (temp &gt; 255) dstpV[x] = 255;
-					else if (temp &lt; 0) dstpV[x] = 0;
-					else dstpV[x] = temp;
-				}
-				else dstpV[x] = (srcpnV[x]+srcppV[x]+1)&gt;&gt;1;
-			}
-
-		}
-		prvpU += prv_pitchUV;
-		prvpV += prv_pitchUV;
-		srcpppU += src_pitchUV;
-		srcpppV += src_pitchUV;
-		srcppU += src_pitchUV;
-		srcppV += src_pitchUV;
-		srcpU += src_pitchUV;
-		srcpV += src_pitchUV;
-		srcpnU += src_pitchUV;
-		srcpnV += src_pitchUV;
-		srcpnnU += src_pitchUV;
-		srcpnnV += src_pitchUV;
-		kerppU += ker_pitchUV;
-		kerppV += ker_pitchUV;
-		kerpU += ker_pitchUV;
-		kerpV += ker_pitchUV;
-		kercU += ker_pitchUV;
-		kercV += ker_pitchUV;
-		kernU += ker_pitchUV;
-		kernV += ker_pitchUV;
-		kernnU += ker_pitchUV;
-		kernnV += ker_pitchUV;
-		nxtpU += nxt_pitchUV;
-		nxtpV += nxt_pitchUV;
-		maskpU += mask_pitchUV;
-		maskpV += mask_pitchUV;
-		dstpU += dst_pitchUV;
-		dstpV += dst_pitchUV;
-	}
-}
-
-void vidTDeint::smartELADeintYV12(ADMImage *dst, ADMImage *mask, 
-		ADMImage *prv, ADMImage *src, ADMImage *nxt)
-{
-	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
-	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
-	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
-	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
-	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
-	int src_pitchY2 = src_pitchY&lt;&lt;1;
-	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
-	int src_pitchUV2 = src_pitchUV&lt;&lt;1;
-	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
-	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
-	int HeightY = src-&gt;GetHeight(PLANAR_Y);
-	int HeightUV = src-&gt;GetHeight(PLANAR_V);
-	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
-	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
-	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
-	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
-	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
-	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
-	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
-	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
-	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
-	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
-	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
-	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
-	const unsigned char *srcppY = srcpY - src_pitchY;
-	const unsigned char *srcpppY = srcppY - src_pitchY2;
-	const unsigned char *srcpnY = srcpY + src_pitchY;
-	const unsigned char *srcpnnY = srcpnY + src_pitchY2;
-	const unsigned char *srcppV = srcpV - src_pitchUV;
-	const unsigned char *srcpppV = srcppV - src_pitchUV2;
-	const unsigned char *srcpnV = srcpV + src_pitchUV;
-	const unsigned char *srcpnnV = srcpnV + src_pitchUV2;
-	const unsigned char *srcppU = srcpU - src_pitchUV;
-	const unsigned char *srcpppU = srcppU - src_pitchUV2;
-	const unsigned char *srcpnU = srcpU + src_pitchUV;
-	const unsigned char *srcpnnU = srcpnU + src_pitchUV2;
-	int x, y, Iy1, Iy2, Iye, Ix1, Ix2, edgeS1, edgeS2;
-	int sum, sumsq, temp, temp1, temp2, minN, maxN;
-	double dir1, dir2, dir, dirF;
-	for (y=0; y&lt;HeightY; ++y)
-	{
-		for (x=0; x&lt;WidthY; ++x)
-		{
-			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = srcpY[x];
-			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = prvpY[x];
-			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = nxtpY[x];
-			else if (maskpY[x] == 40) dstpY[x] = (srcpY[x]+nxtpY[x]+1)&gt;&gt;1;
-			else if (maskpY[x] == 50) dstpY[x] = (srcpY[x]+prvpY[x]+1)&gt;&gt;1;
-			else if (maskpY[x] == 60)
-			{
-				if (y&gt;2 &amp;&amp; y&lt;HeightY-3 &amp;&amp; x&gt;3 &amp;&amp; x&lt;WidthY-4)
-				{
-					Iy1 = srcpppY[x-1]+srcpppY[x]+srcpppY[x]+srcpppY[x+1]-srcpnY[x-1]-srcpnY[x]-srcpnY[x]-srcpnY[x+1];
-					Iy2 = srcppY[x-1]+srcppY[x]+srcppY[x]+srcppY[x+1]-srcpnnY[x-1]-srcpnnY[x]-srcpnnY[x]-srcpnnY[x+1];
-					Ix1 = srcpppY[x+1]+srcppY[x+1]+srcppY[x+1]+srcpnY[x+1]-srcpppY[x-1]-srcppY[x-1]-srcppY[x-1]-srcpnY[x-1];
-					Ix2 = srcppY[x+1]+srcpnY[x+1]+srcpnY[x+1]+srcpnnY[x+1]-srcppY[x-1]-srcpnY[x-1]-srcpnY[x-1]-srcpnnY[x-1];
-					edgeS1 = Ix1*Ix1 + Iy1*Iy1;
-					edgeS2 = Ix2*Ix2 + Iy2*Iy2;
-					if (edgeS1 &lt; 1600 &amp;&amp; edgeS2 &lt; 1600) 
-					{
-						dstpY[x] = (srcppY[x]+srcpnY[x]+1)&gt;&gt;1;
-						continue;
-					}
-					if (abs(srcppY[x]-srcpnY[x]) &lt; 10 &amp;&amp; (edgeS1 &lt; 1600 || edgeS2 &lt; 1600))
-					{
-						dstpY[x] = (srcppY[x]+srcpnY[x]+1)&gt;&gt;1;
-						continue;
-					}
-					sum = srcppY[x-1] + srcppY[x] + srcppY[x+1] + srcpnY[x-1] + srcpnY[x] + srcpnY[x+1];
-					sumsq = srcppY[x-1]*srcppY[x-1] + srcppY[x]*srcppY[x] + srcppY[x+1]*srcppY[x+1] +
-							srcpnY[x-1]*srcpnY[x-1] + srcpnY[x]*srcpnY[x] + srcpnY[x+1]*srcpnY[x+1];
-					if ((6*sumsq - sum*sum) &lt; 432)
-					{
-						dstpY[x] = (srcppY[x]+srcpnY[x]+1)&gt;&gt;1;
-						continue;
-					}
-					if (Ix1 == 0) dir1 = 3.1415926;
-					else
-					{
-						dir1 = atan(Iy1/(Ix1*2.0f)) + 1.5707963;
-						if (Iy1 &gt;= 0) { if (Ix1 &lt; 0) dir1 += 3.1415927; }
-						else { if (Ix1 &gt;= 0) dir1 += 3.1415927; }
-						if (dir1 &gt;= 3.1415927) dir1 -= 3.1415927;
-					}
-					if (Ix2 == 0) dir2 = 3.1415926;
-					else 
-					{
-						dir2 = atan(Iy2/(Ix2*2.0f)) + 1.5707963;
-						if (Iy2 &gt;= 0) { if (Ix2 &lt; 0) dir2 += 3.1415927; }
-						else { if (Ix2 &gt;= 0) dir2 += 3.1415927; }
-						if (dir2 &gt;= 3.1415927) dir2 -= 3.1415927;
-					}
-					if (fabs(dir1-dir2) &lt; 0.5)
-					{
-						if (edgeS1 &gt;= 3600 &amp;&amp; edgeS2 &gt;= 3600) dir = (dir1 + dir2) * 0.5f;
-						else dir = edgeS1 &gt;= edgeS2 ? dir1 : dir2;
-					}
-					else
-					{
-						if (edgeS1 &gt;= 5000 &amp;&amp; edgeS2 &gt;= 5000)
-						{
-							Iye = srcppY[x-1]+srcppY[x]+srcppY[x]+srcppY[x+1]-srcpnY[x-1]-srcpnY[x]-srcpnY[x]-srcpnY[x+1];
-							if ((Iy1*Iye &gt; 0) &amp;&amp; (Iy2*Iye &lt; 0)) dir = dir1;
-							else if ((Iy1*Iye &lt; 0) &amp;&amp; (Iy2*Iye &gt; 0)) dir = dir2;
-							else
-							{
-								if (abs(Iye-Iy1) &lt;= abs(Iye-Iy2)) dir = dir1;
-								else dir = dir2;
-							}
-						}
-						else dir = edgeS1 &gt;= edgeS2 ? dir1 : dir2;
-					}
-					dirF = 0.5f/tan(dir);
-					if (dirF &gt;= 0.0f)
-					{
-						if (dirF &gt;= 0.5f)
-						{
-							if (dirF &gt;= 1.0f)
-							{
-								if (dirF &gt;= 1.5f)
-								{
-									if (dirF &gt;= 2.0f)
-									{
-										if (dirF &lt;= 2.50f)
-										{
-											temp1 = srcppY[x+4];
-											temp2 = srcpnY[x-4];
-											temp = (srcppY[x+4]+srcpnY[x-4]+1)&gt;&gt;1;
-										}
-										else 
-										{
-											temp1 = temp2 = srcpnY[x];
-											temp = cubicInt(srcpppY[x],srcppY[x],srcpnY[x],srcpnnY[x]);
-										}
-									}
-									else 
-									{
-										temp1 = (int)((dirF-1.5f)*(srcppY[x+4]) + (2.0f-dirF)*(srcppY[x+3]) + 0.5f);
-										temp2 = (int)((dirF-1.5f)*(srcpnY[x-4]) + (2.0f-dirF)*(srcpnY[x-3]) + 0.5f);
-										temp = (int)((dirF-1.5f)*(srcppY[x+4]+srcpnY[x-4]) + (2.0f-dirF)*(srcppY[x+3]+srcpnY[x-3]) + 0.5f);
-									}
-								}
-								else 
-								{
-									temp1 = (int)((dirF-1.0f)*(srcppY[x+3]) + (1.5f-dirF)*(srcppY[x+2]) + 0.5f);
-									temp2 = (int)((dirF-1.0f)*(srcpnY[x-3]) + (1.5f-dirF)*(srcpnY[x-2]) + 0.5f);
-									temp = (int)((dirF-1.0f)*(srcppY[x+3]+srcpnY[x-3]) + (1.5f-dirF)*(srcppY[x+2]+srcpnY[x-2]) + 0.5f);
-								}
-							}
-							else 
-							{
-								temp1 = (int)((dirF-0.5f)*(srcppY[x+2]) + (1.0f-dirF)*(srcppY[x+1]) + 0.5f);
-								temp2 = (int)((dirF-0.5f)*(srcpnY[x-2]) + (1.0f-dirF)*(srcpnY[x-1]) + 0.5f);
-								temp = (int)((dirF-0.5f)*(srcppY[x+2]+srcpnY[x-2]) + (1.0f-dirF)*(srcppY[x+1]+srcpnY[x-1]) + 0.5f);
-							}
-						}
-						else 
-						{
-							temp1 = (int)(dirF*(srcppY[x+1]) + (0.5f-dirF)*(srcppY[x]) + 0.5f);
-							temp2 = (int)(dirF*(srcpnY[x-1]) + (0.5f-dirF)*(srcpnY[x]) + 0.5f);
-							temp = (int)(dirF*(srcppY[x+1]+srcpnY[x-1]) + (0.5f-dirF)*(srcppY[x]+srcpnY[x]) + 0.5f);
-						}
-					}
-					else
-					{
-						if (dirF &lt;= -0.5f)
-						{
-							if (dirF &lt;= -1.0f)
-							{
-								if (dirF &lt;= -1.5f)
-								{
-									if (dirF &lt;= -2.0f)
-									{
-										if (dirF &gt;= -2.50f) 
-										{
-											temp1 = srcppY[x-4];
-											temp2 = srcpnY[x+4];
-											temp = (srcppY[x-4]+srcpnY[x+4]+1)&gt;&gt;1;
-										}
-										else 
-										{
-											temp1 = temp2 = srcpnY[x];
-											temp = cubicInt(srcpppY[x],srcppY[x],srcpnY[x],srcpnnY[x]);
-										}
-									}
-									else
-									{
-										temp1 = (int)((-dirF-1.5f)*(srcppY[x-4]) + (2.0f+dirF)*(srcppY[x-3]) + 0.5f);
-										temp2 = (int)((-dirF-1.5f)*(srcpnY[x+4]) + (2.0f+dirF)*(srcpnY[x+3]) + 0.5f);
-										temp = (int)((-dirF-1.5f)*(srcppY[x-4]+srcpnY[x+4]) + (2.0f+dirF)*(srcppY[x-3]+srcpnY[x+3]) + 0.5f);
-									}
-								}
-								else 
-								{
-									temp1 = (int)((-dirF-1.0f)*(srcppY[x-3]) + (1.5f+dirF)*(srcppY[x-2]) + 0.5f);
-									temp2 = (int)((-dirF-1.0f)*(srcpnY[x+3]) + (1.5f+dirF)*(srcpnY[x+2]) + 0.5f);
-									temp = (int)((-dirF-1.0f)*(srcppY[x-3]+srcpnY[x+3]) + (1.5f+dirF)*(srcppY[x-2]+srcpnY[x+2]) + 0.5f);
-								}
-							}
-							else 
-							{
-								temp1 = (int)((-dirF-0.5f)*(srcppY[x-2]) + (1.0f+dirF)*(srcppY[x-1]) + 0.5f);
-								temp2 = (int)((-dirF-0.5f)*(srcpnY[x+2]) + (1.0f+dirF)*(srcpnY[x+1]) + 0.5f);
-								temp = (int)((-dirF-0.5f)*(srcppY[x-2]+srcpnY[x+2]) + (1.0f+dirF)*(srcppY[x-1]+srcpnY[x+1]) + 0.5f);
-							}
-						}
-						else 
-						{
-							temp1 = (int)((-dirF)*(srcppY[x-1]) + (0.5f+dirF)*(srcppY[x]) + 0.5f);
-							temp2 = (int)((-dirF)*(srcpnY[x+1]) + (0.5f+dirF)*(srcpnY[x]) + 0.5f);
-							temp = (int)((-dirF)*(srcppY[x-1]+srcpnY[x+1]) + (0.5f+dirF)*(srcppY[x]+srcpnY[x]) + 0.5f);
-						}
-					}
-					maxN = max(srcppY[x],srcpnY[x]) + 25;
-					minN = min(srcppY[x],srcpnY[x]) - 25;
-					if (abs(temp1-temp2) &gt; 20 || abs(srcppY[x]+srcpnY[x]-temp-temp) &gt; 60 || temp &lt; minN || temp &gt; maxN)
-					{
-						temp = cubicInt(srcpppY[x],srcppY[x],srcpnY[x],srcpnnY[x]);
-					}
-					if (temp &gt; 255) temp = 255;
-					else if (temp &lt; 0) temp = 0;
-					dstpY[x] = temp;
-				}
-				else
-				{
-					if (y&lt;3 || y&gt;HeightY-4) dstpY[x] = (srcpnY[x]+srcppY[x]+1)&gt;&gt;1;
-					else dstpY[x] = cubicInt(srcpppY[x],srcppY[x],srcpnY[x],srcpnnY[x]);
-				}
-			}
-		}
-		prvpY += prv_pitchY;
-		srcpppY += src_pitchY;
-		srcppY += src_pitchY;
-		srcpY += src_pitchY;
-		srcpnY += src_pitchY;
-		srcpnnY += src_pitchY;
-		nxtpY += nxt_pitchY;
-		maskpY += mask_pitchY;
-		dstpY += dst_pitchY;
-	}
-	for (y=0; y&lt;HeightUV; ++y)
-	{
-		for (x=0; x&lt;WidthUV; ++x)
-		{
-			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = srcpV[x];
-			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = prvpV[x];
-			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = nxtpV[x];
-			else if (maskpV[x] == 40) dstpV[x] = (srcpV[x]+nxtpV[x]+1)&gt;&gt;1;
-			else if (maskpV[x] == 50) dstpV[x] = (srcpV[x]+prvpV[x]+1)&gt;&gt;1;
-			else if (maskpV[x] == 60)
-			{
-				if (y&lt;3 || y&gt;HeightUV-4) dstpV[x] = (srcpnV[x]+srcppV[x]+1)&gt;&gt;1;
-				else dstpV[x] = cubicInt(srcpppV[x],srcppV[x],srcpnV[x],srcpnnV[x]);
-			}
-			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = srcpU[x];
-			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = prvpU[x];
-			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = nxtpU[x];
-			else if (maskpU[x] == 40) dstpU[x] = (srcpU[x]+nxtpU[x]+1)&gt;&gt;1;
-			else if (maskpU[x] == 50) dstpU[x] = (srcpU[x]+prvpU[x]+1)&gt;&gt;1;
-			else if (maskpU[x] == 60)
-			{
-				if (y&lt;3 || y&gt;HeightUV-4) dstpU[x] = (srcpnU[x]+srcppU[x]+1)&gt;&gt;1;
-				else dstpU[x] = cubicInt(srcpppU[x],srcppU[x],srcpnU[x],srcpnnU[x]);
-			}
-		}
-		prvpV += prv_pitchUV;
-		prvpU += prv_pitchUV;
-		srcpppV += src_pitchUV;
-		srcppV += src_pitchUV;
-		srcpV += src_pitchUV;
-		srcpnV += src_pitchUV;
-		srcpnnV += src_pitchUV;
-		srcpppU += src_pitchUV;
-		srcppU += src_pitchUV;
-		srcpU += src_pitchUV;
-		srcpnU += src_pitchUV;
-		srcpnnU += src_pitchUV;
-		nxtpV += nxt_pitchUV;
-		nxtpU += nxt_pitchUV;
-		maskpV += mask_pitchUV;
-		maskpU += mask_pitchUV;
-		dstpV += dst_pitchUV;
-		dstpU += dst_pitchUV;
-	}
-}
-
-void vidTDeint::createWeaveFrameYV12(ADMImage *dst, ADMImage *prv, 
-		ADMImage *src, ADMImage *nxt)
-{
-	int b;
-	ADM_PLANE plane;
-	for (b=0; b&lt;3; ++b)
-	{
-		if (b == 0) plane = PLANAR_Y;
-		else if (b == 1) plane = PLANAR_V;
-		else plane = PLANAR_U;
-		if (PRM(field)^PRM(order))
-		{
-			if (accumP &lt;= accumN)
-			{
-				BitBlit(dst-&gt;GetWritePtr(plane), dst-&gt;GetPitch(plane), src-&gt;GetReadPtr(plane), 
-					src-&gt;GetPitch(plane), src-&gt;GetRowSize(plane), src-&gt;GetHeight(plane));
-			}
-			else
-			{
-				BitBlit(dst-&gt;GetWritePtr(plane)+(1-PRM(field))*dst-&gt;GetPitch(plane), dst-&gt;GetPitch(plane)&lt;&lt;1,
-					src-&gt;GetReadPtr(plane)+(1-PRM(field))*src-&gt;GetPitch(plane), src-&gt;GetPitch(plane)&lt;&lt;1, 
-					src-&gt;GetRowSize(plane), src-&gt;GetHeight(plane)&gt;&gt;1);
-				BitBlit(dst-&gt;GetWritePtr(plane)+PRM(field)*dst-&gt;GetPitch(plane), dst-&gt;GetPitch(plane)&lt;&lt;1, 
-					nxt-&gt;GetReadPtr(plane)+PRM(field)*nxt-&gt;GetPitch(plane), nxt-&gt;GetPitch(plane)&lt;&lt;1, nxt-&gt;GetRowSize(plane),
-					nxt-&gt;GetHeight(plane)&gt;&gt;1);
-			}
-		}
-		else
-		{
-			if (accumN &lt;= accumP)
-			{
-				BitBlit(dst-&gt;GetWritePtr(plane), dst-&gt;GetPitch(plane), src-&gt;GetReadPtr(plane), 
-					src-&gt;GetPitch(plane), src-&gt;GetRowSize(plane), src-&gt;GetHeight(plane));
-			}
-			else
-			{
-				BitBlit(dst-&gt;GetWritePtr(plane)+(1-PRM(field))*dst-&gt;GetPitch(plane), dst-&gt;GetPitch(plane)&lt;&lt;1,
-					src-&gt;GetReadPtr(plane)+(1-PRM(field))*src-&gt;GetPitch(plane), src-&gt;GetPitch(plane)&lt;&lt;1, 
-					src-&gt;GetRowSize(plane), src-&gt;GetHeight(plane)&gt;&gt;1);
-				BitBlit(dst-&gt;GetWritePtr(plane)+PRM(field)*dst-&gt;GetPitch(plane), dst-&gt;GetPitch(plane)&lt;&lt;1, 
-					prv-&gt;GetReadPtr(plane)+PRM(field)*prv-&gt;GetPitch(plane), prv-&gt;GetPitch(plane)&lt;&lt;1, prv-&gt;GetRowSize(plane),
-					prv-&gt;GetHeight(plane)&gt;&gt;1);
-			}
-		}
-	}
-}
-
-//*********************************************************
-//*********************************************************
-//*********************************************************
-//*********************************************************
-int vidTDeint::getHint(ADMImage *src, unsigned int &amp;storeHint, int &amp;hintfield)
-{
-	hintfield = -1;
-	const unsigned char *p = YPLANE(src); //src-&gt;GetReadPtr(PLANAR_Y);
-	unsigned int i, magic_number = 0, hint = 0;
-	storeHint = 0xFFFFFFFF;
-	for (i=0; i&lt;32; ++i)
-	{
-		magic_number |= ((*p++ &amp; 1) &lt;&lt; i);
-	}
-	if (magic_number != 0xdeadbeef &amp;&amp; magic_number != 0xdeadfeed) return -1;
-	for (i=0; i&lt;32; ++i)
-	{
-		hint |= ((*p++ &amp; 1) &lt;&lt; i);
-	}
-	if (magic_number == 0xdeadbeef &amp;&amp; hint&amp;0xFFFFFF00) return -1;
-	if (magic_number == 0xdeadfeed &amp;&amp; hint&amp;0xFFFFFF00) return -1;
-	storeHint = hint;
-	if (magic_number == 0xdeadbeef)
-	{
-		storeHint |= 0x00100000;
-		if (hint&amp;0x00000001) return 0;
-		return 1;
-	}
-	if (hint&amp;0x00000008) hintfield = 1;
-	else hintfield = 0;
-	if (hint&amp;0x00000010) return 1;
-	return 0;
-}
-
-void vidTDeint::putHint(ADMImage *src, unsigned int hint, int fieldt)
-{
-	int type = hint&amp;0x00100000 ? 0 : 1;
-	hint &amp;= ~0x00100000;
-	if (hint&amp;0xFFFFFF00) return;
-	if (type == 1)
-	{
-		hint &amp;= 0x00000020;
-		if (fieldt == 1) hint |= 0x0000000E;
-		else hint |= 0x00000005;
-	}
-	unsigned char *p = YPLANE(src); //src-&gt;GetWritePtr(PLANAR_Y);
-	unsigned int i;
-	for (i=0; i&lt;32; ++i)
-	{
-		*p &amp;= ~1;
-		if (type == 0) *p++ |= ((0xdeadbeef &amp; (1 &lt;&lt; i)) &gt;&gt; i);
-		else *p++ |= ((0xdeadfeed &amp; (1 &lt;&lt; i)) &gt;&gt; i);
-	}
-	for (i=0; i&lt;32; ++i)
-	{
-		*p &amp;= ~1;
-		*p++ |= ((hint &amp; (1 &lt;&lt; i)) &gt;&gt; i);
-	}
-}
-/****************************************/
-void vidTDeint::copyFrame(ADMImage *dst,ADMImage *src)
-{
-	int b, stop =  3 ;
-	ADM_PLANE plane[3] = { PLANAR_Y, PLANAR_U, PLANAR_V };
-	for (b=0; b&lt;stop; ++b)
-	{
-		BitBlit(dst-&gt;GetWritePtr(plane[b]),dst-&gt;GetPitch(plane[b]),src-&gt;GetReadPtr(plane[b]),
-			src-&gt;GetPitch(plane[b]),src-&gt;GetRowSize(plane[b]),src-&gt;GetHeight(plane[b]));
-	}
-}
-/****************************************/
-  void vidTDeint::copyForUpsize(ADMImage *dst, ADMImage *src, int np)
-{
-	int b;
-	ADM_PLANE plane[3] = { PLANAR_Y, PLANAR_U, PLANAR_V };
-	for (b=0; b&lt;np; ++b)
-	{
-		BitBlit(dst-&gt;GetWritePtr(plane[b]),dst-&gt;GetPitch(plane[b])*2,src-&gt;GetReadPtr(plane[b]),
-			src-&gt;GetPitch(plane[b]),src-&gt;GetRowSize(plane[b]),src-&gt;GetHeight(plane[b]));
-		BitBlit(dst-&gt;GetWritePtr(plane[b])+(dst-&gt;GetPitch(plane[b])*(dst-&gt;GetHeight(plane[b])-1)),
-			dst-&gt;GetPitch(plane[b]),src-&gt;GetReadPtr(plane[b])+(src-&gt;GetPitch(plane[b])*(src-&gt;GetHeight(plane[b])-1)),
-			src-&gt;GetPitch(plane[b]),src-&gt;GetRowSize(plane[b]),1);
-	}	
-}
-/****************************************/
-void vidTDeint::setMaskForUpsize(ADMImage *msk, int np)
-{
-	unsigned char *maskwc, *maskwn;
-	int msk_pitch, height, width, y;
-	int b;
-	ADM_PLANE plane[3] = { PLANAR_Y, PLANAR_U, PLANAR_V };
-	for (b=0; b&lt;np; ++b)
-	{
-		maskwc = msk-&gt;GetWritePtr(plane[b]);
-		msk_pitch = msk-&gt;GetPitch(plane[b]);
-		height = msk-&gt;GetHeight(plane[b])&gt;&gt;1;
-		width = msk-&gt;GetRowSize(plane[b]);
-		maskwn = maskwc + msk_pitch;
-		msk_pitch &lt;&lt;= 1;
-		if (PRM(field) == 1)
-		{
-			for (y=0; y&lt;height-1; ++y)
-			{
-				memset(maskwc, 10, width);
-				memset(maskwn, 60, width);
-				maskwc += msk_pitch;
-				maskwn += msk_pitch;
-			}
-			memset(maskwc, 10, width);
-			memset(maskwn, 10, width);
-		}
-		else
-		{
-			memset(maskwc, 10, width);
-			memset(maskwn, 10, width);
-			for (y=0; y&lt;height-1; ++y)
-			{
-				maskwc += msk_pitch;
-				maskwn += msk_pitch;
-				memset(maskwc, 60, width);
-				memset(maskwn, 10, width);
-			}
-		}
-	}
-}
-//**************************************
-void vidTDeint::apPostCheck(ADMImage *dst, ADMImage *mask)
-{
-	ADMImage * maskt;
-	if (APType &gt; 0)
-	{
-		maskt = scratch; //_env-&gt;NewVideoFrame(vi);
-		copyFrame(maskt, mask);
-	}
-	unsigned char *maskw;
-	const unsigned char *dstp, *dstpp, *dstpn, *dstppp, *dstpnn, *maskp, *maskpT;
-	int dst_pitch, dst_pitch2, mask_pitch, mask_pitch2, Width, Height;
-	int x, y, b, stop =3 , count = 0, maskp_pitch, maskp_pitch2;
-	int sFirst, sSecond, AP6 = AP*6, moving, neighbors, u, v;
-	int starty, stopy, startx, stopx, inc;
-	ADM_PLANE plane;
-	
-	for (b=0; b&lt;stop; ++b)
-	{
-		if (b == 0) plane = PLANAR_Y;
-		else if (b == 1) plane = PLANAR_U;
-		else plane = PLANAR_V;
-		dstp = dst-&gt;GetReadPtr(plane);
-		dst_pitch = dst-&gt;GetPitch(plane);
-		dst_pitch2 = dst_pitch&lt;&lt;1;
-		Width = dst-&gt;GetRowSize(plane);
-		Height = dst-&gt;GetHeight(plane);
-		dstp += (2-PRM(field))*dst_pitch;
-		dstppp = dstp - dst_pitch2;
-		dstpp = dstp - dst_pitch;
-		dstpn = dstp + dst_pitch;
-		dstpnn = dstp + dst_pitch2;
-		maskw = mask-&gt;GetWritePtr(plane);
-		mask_pitch = mask-&gt;GetPitch(plane);
-		mask_pitch2 = mask_pitch&lt;&lt;1;
-		if (APType &gt; 0)
-		{
-			maskp = maskt-&gt;GetReadPtr(plane);
-			maskp_pitch = maskt-&gt;GetPitch(plane);
-			maskp_pitch2 = maskp_pitch&lt;&lt;1;
-		}
-		maskw += (2-PRM(field))*mask_pitch;
-		y = 2-PRM(field);
-		for (x=0; x&lt;Width; ++x)
-		{
-			if (maskw[x] == 60) { maskw[x] = 10; continue; };
-			maskw[x] = 10;
-			sFirst = dstp[x] - dstpp[x];
-			sSecond = dstp[x] - dstpn[x];
-			if ((sFirst &gt; AP &amp;&amp; sSecond &gt; AP) || (sFirst &lt; -AP &amp;&amp; sSecond &lt; -AP))
-			{
-				sFirst = abs(dstpnn[x]+(dstp[x]&lt;&lt;2)+dstpnn[x]-(3*(dstpp[x]+dstpn[x])));
-				if (sFirst &gt; AP6) 
-				{
-					if (APType &gt; 0)
-					{
-						inc = stop &gt; 1 ? 1 : x&amp;1 ? 4 : 2;
-						startx = x-(inc&lt;&lt;1) &lt; 0 ? x-inc &lt; 0 ? x : x-inc : x-(inc&lt;&lt;1);
-						stopx = x+(inc&lt;&lt;1) &gt; Width-1 ? x+inc &gt; Width-1 ? x : x+inc : x+(inc&lt;&lt;1);
-						starty = y-4 &lt; 0 ? y-2 &lt; 0 ? y : y-2 : y-4;
-						stopy = y+4 &gt; Height-1 ? y+2 &gt; Height-1 ? y : y+2 : y+4;
-						neighbors = moving = 0;
-						maskpT = maskp + starty*maskp_pitch;
-						for (u=starty; u&lt;=stopy; u+=2)
-						{
-							for (v=startx; v&lt;=stopx; v+=inc)
-							{
-								if (maskpT[v] &gt;= 60) ++moving;
-								++neighbors;
-							}
-							maskpT += maskp_pitch2;
-						}
-						if ((APType == 1 &amp;&amp; (moving&lt;&lt;1) &gt;= neighbors) ||
-							(APType == 2 &amp;&amp; (moving*3)  &gt;= neighbors))
-						{
-							maskw[x] = 60;
-							++count;
-						}
-					}
-					else
-					{
-						maskw[x] = 60;
-						++count;
-					}
-				}
-			}
-		}
-		dstppp += dst_pitch2;
-		dstpp += dst_pitch2;
-		dstp += dst_pitch2;
-		dstpn += dst_pitch2;
-		dstpnn += dst_pitch2;
-		maskw += mask_pitch2;
-		y += 2;
-		for (; y&lt;Height-3; y+=2)
-		{
-			starty = y-4 &lt; 0 ? y-2 &lt; 0 ? y : y-2 : y-4;
-			stopy = y+4 &gt; Height-1 ? y+2 &gt; Height-1 ? y : y+2 : y+4;
-			for (x=0; x&lt;Width; ++x)
-			{
-				if (maskw[x] == 60) { maskw[x] = 10; continue; }
-				maskw[x] = 10;
-				sFirst = dstp[x] - dstpp[x];
-				sSecond = dstp[x] - dstpn[x];
-				if ((sFirst &gt; AP &amp;&amp; sSecond &gt; AP) || (sFirst &lt; -AP &amp;&amp; sSecond &lt; -AP))
-				{
-					sFirst = abs(dstppp[x]+(dstp[x]&lt;&lt;2)+dstpnn[x]-(3*(dstpp[x]+dstpn[x])));
-					if (sFirst &gt; AP6) 
-					{ 
-						if (APType &gt; 0)
-						{
-							inc = stop &gt; 1 ? 1 : x&amp;1 ? 4 : 2;
-							startx = x-(inc&lt;&lt;1) &lt; 0 ? x-inc &lt; 0 ? x : x-inc : x-(inc&lt;&lt;1);
-							stopx = x+(inc&lt;&lt;1) &gt; Width-1 ? x+inc &gt; Width-1 ? x : x+inc : x+(inc&lt;&lt;1);
-							neighbors = moving = 0;
-							maskpT = maskp + starty*maskp_pitch;
-							for (u=starty; u&lt;=stopy; u+=2)
-							{
-								for (v=startx; v&lt;=stopx; v+=inc)
-								{
-									if (maskpT[v] &gt;= 60) ++moving;
-									++neighbors;
-								}
-								maskpT += maskp_pitch2;
-							}
-							if ((APType == 1 &amp;&amp; (moving&lt;&lt;1) &gt;= neighbors) ||
-								(APType == 2 &amp;&amp; (moving*3)  &gt;= neighbors))
-							{
-								maskw[x] = 60;
-								++count;
-							}
-						}
-						else
-						{
-							maskw[x] = 60;
-							++count;
-						}
-					}
-				}	
-			}
-			dstppp += dst_pitch2;
-			dstpp += dst_pitch2;
-			dstp += dst_pitch2;
-			dstpn += dst_pitch2;
-			dstpnn += dst_pitch2;
-			maskw += mask_pitch2;
-		}
-		for (x=0; x&lt;Width; ++x)
-		{
-			if (maskw[x] == 60) { maskw[x] = 10; continue; }
-			maskw[x] = 10;
-			sFirst = dstp[x] - dstpp[x];
-			sSecond = dstp[x] - dstpn[x];
-			if ((sFirst &gt; AP &amp;&amp; sSecond &gt; AP) || (sFirst &lt; -AP &amp;&amp; sSecond &lt; -AP))
-			{
-				sFirst = abs(dstppp[x]+(dstp[x]&lt;&lt;2)+dstppp[x]-(3*(dstpp[x]+dstpn[x])));
-				if (sFirst &gt; AP6) 
-				{ 
-					if (APType &gt; 0)
-					{
-						inc = stop &gt; 1 ? 1 : x&amp;1 ? 4 : 2;
-						startx = x-(inc&lt;&lt;1) &lt; 0 ? x-inc &lt; 0 ? x : x-inc : x-(inc&lt;&lt;1);
-						stopx = x+(inc&lt;&lt;1) &gt; Width-1 ? x+inc &gt; Width-1 ? x : x+inc : x+(inc&lt;&lt;1);
-						starty = y-4 &lt; 0 ? y-2 &lt; 0 ? y : y-2 : y-4;
-						stopy = y+4 &gt; Height-1 ? y+2 &gt; Height-1 ? y : y+2 : y+4;
-						neighbors = moving = 0;
-						maskpT = maskp + starty*maskp_pitch;
-						for (u=starty; u&lt;=stopy; u+=2)
-						{
-							for (v=startx; v&lt;=stopx; v+=inc)
-							{
-								if (maskpT[v] &gt;= 60) ++moving;
-								++neighbors;
-							}
-							maskpT += maskp_pitch2;
-						}
-						if ((APType == 1 &amp;&amp; (moving&lt;&lt;1) &gt;= neighbors) ||
-							(APType == 2 &amp;&amp; (moving*3)  &gt;= neighbors))
-						{
-							maskw[x] = 60;
-							++count;
-						}
-					}
-					else
-					{
-						maskw[x] = 60;
-						++count;
-					}
-				}
-			}
-		}
-	}
-	if (count &gt; 0)
-	{
-		//if (vi.IsYV12())
-		{
-			if (type == 0) cubicDeintYV12(dst, mask, dst, dst, dst);
-			else if (type == 1) smartELADeintYV12(dst, mask, dst, dst, dst);
-			else if (type == 2) kernelDeintYV12(dst, mask, dst, dst, dst);
-			else if (type == 3) ELADeintYV12(dst, mask, dst, dst, dst);
-		}
-		
-	}
-}
-

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,7 +1,5 @@
 SET(ADM_videoFilter_SRCS 
 	ADM_vidASS.cpp               
-	ADM_vidRotate.cpp         
-	ADM_vidTdeint.cpp
 	ADM_vidAnimated.cpp
 	ADM_vidDvbSub.cpp
 	ADM_vidVobsub.cpp
@@ -12,10 +10,3 @@
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_videoFilter ${ADM_videoFilter_SRCS})
 
-if(false)
-IF (USE_FREETYPE)
-	ADD_SOURCE_CFLAGS(ADM_vidSRT.cpp &quot;${FREETYPE2_CFLAGS}&quot;)
-	ADD_SOURCE_CFLAGS(ADM_vidSRTload.cpp &quot;${FREETYPE2_CFLAGS}&quot; &quot;-I${LIBICONV_INCLUDE_DIR}&quot;)
-	ADD_SOURCE_CFLAGS(ADM_vidSRTRender.cpp &quot;${FREETYPE2_CFLAGS}&quot;)
-ENDIF (USE_FREETYPE)
-endif(false)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2008-05-27 19:41:54 UTC (rev 4068)
@@ -332,19 +332,6 @@
 	ENDIF (ADM_UI_GTK)
 ENDIF (GETTEXT_FOUND)
 
-# Freetype2
-IF (USE_FREETYPE)
-	ADD_LDFLAGS_ALL_TARGETS(${FREETYPE2_LDFLAGS})
-
-	# libiconv
-	ADD_LIB_ALL_TARGETS(&quot;${LIBICONV_LIBRARY_DIR}&quot;)
-ENDIF (USE_FREETYPE)
-
-# FontConfig
-IF (USE_FONTCONFIG)
-	ADD_LDFLAGS_ALL_TARGETS(${FONTCONFIG_LDFLAGS})
-ENDIF (USE_FONTCONFIG)
-
 # PNG
 IF (USE_PNG)
 	TARGET_LINK_LIBRARIES(avidemux2_cli ${PNG_LIBRARIES})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt	2008-05-27 19:41:54 UTC (rev 4068)
@@ -49,3 +49,6 @@
 ADD_SUBDIRECTORY(Eq2)
 ADD_SUBDIRECTORY(Hue)
 ADD_SUBDIRECTORY(Crop)
+ADD_SUBDIRECTORY(Rotate)
+ADD_SUBDIRECTORY(Tdeint)
+ADD_SUBDIRECTORY(Srt)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Rotate/ADM_vidRotate.cpp (from rev 4067, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidRotate.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidRotate.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Rotate/ADM_vidRotate.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,284 @@
+/***************************************************************************
+                          ADM_vidRotate.cpp  -  description
+                             -------------------
+    begin                : Sat Jan 8 2003
+    copyright            : (C) 2003 by Tracy Harton
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">tracy at amphibious.org</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;DIA_factory.h&quot;
+
+typedef struct ROTATE_PARAM
+{
+  uint32_t width;
+  uint32_t height;
+  uint32_t angle;
+}ROTATE_PARAM;
+
+class  ADMVideoRotate:public AVDMGenericVideoStream
+{
+
+ protected:
+  virtual char                  *printConf(void);
+  ROTATE_PARAM                  *_param;
+
+ public:
+                  ADMVideoRotate(AVDMGenericVideoStream *in, CONFcouple *setup);
+  virtual         ~ADMVideoRotate();
+  virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
+  virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data,uint32_t *flags);
+  virtual uint8_t	getCoupledConf( CONFcouple **couples)				;
+ }     ;
+
+static FILTER_PARAM rotpParam={3,{&quot;width&quot;,&quot;height&quot;,&quot;angle&quot;}};
+
+
+//********** Register chunk ************
+static FILTER_PARAM flipParam={0,{&quot;&quot;}};
+
+//REGISTERX(VF_TRANSFORM, &quot;rotate&quot;,QT_TR_NOOP(&quot;Rotate&quot;),QT_TR_NOOP(
+//    &quot;Rotate the picture by 90, 180 or 270 degrees.&quot;),VF_ROTATE,1,rotate_create,rotate_script);
+VF_DEFINE_FILTER(ADMVideoRotate,flipParam,
+                                rotate,
+                                QT_TR_NOOP(&quot;Rotate&quot;),
+                                1,
+                                VF_TRANSFORM,
+                                QT_TR_NOOP(&quot;Rotate the picture by 90, 180 or 270 degrees.&quot;));
+//************************************
+
+static void do_rotate(ADMImage *source,ADMImage *target,uint32_t angle);
+
+char *ADMVideoRotate::printConf( void )
+{
+  static char buf[50];
+ 	
+  sprintf((char *)buf,&quot; Rotate %u degrees&quot;, _param-&gt;angle);
+  return buf;
+}
+
+ADMVideoRotate::ADMVideoRotate(AVDMGenericVideoStream *in, CONFcouple *couples)
+{
+  _in=in;		
+
+  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info)); 
+  _info.encoding=1;
+
+ // _uncompressed=new uint8_t [3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height];
+ 
+
+  if(couples)
+  {
+   	 _param=NEW(ROTATE_PARAM);
+	GET(width);
+	GET(height);
+	GET(angle);
+	_info.width=_param-&gt;width;
+	_info.height=_param-&gt;height;
+
+  }
+  else
+  {
+    _param = NEW( ROTATE_PARAM);
+    printf(&quot;New Angle 0.0\n&quot;);
+    _param-&gt;angle = 0;
+    _param-&gt;width = _info.width;
+    _param-&gt;height = _info.height;
+  }
+ _uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+  printf(&quot;New Rotate %ld %ld %f\n&quot;, _info.width, _info.height, _param-&gt;angle);
+  ADM_assert(_uncompressed);    	  	
+
+}
+
+
+
+uint8_t	ADMVideoRotate::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(3);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+			CSET(width);
+			CSET(height);
+			CSET(angle);
+
+			return 1;
+
+}
+
+
+ADMVideoRotate::~ADMVideoRotate()
+{
+ 	delete  _uncompressed;
+	_uncompressed=NULL;
+	DELETE(_param);
+}
+uint8_t ADMVideoRotate::getFrameNumberNoAlloc(uint32_t frame,
+                                              uint32_t *len,
+                                              ADMImage *data,
+                                              uint32_t *flags)
+{
+ if(frame&gt;= _info.nb_frames) return 0;
+								
+  // read uncompressed frame
+  if(!_in-&gt;getFrameNumberNoAlloc(frame, len, _uncompressed, flags)) return 0;
+
+  
+  do_rotate(_uncompressed,data,_param-&gt;angle);
+
+  //printf(&quot;%ld,%ld\n&quot;, _info.width, _info.height);
+
+  *flags=_uncompressed-&gt;flags;
+  *len= (_info.width * _info.height) + ((_info.width * _info.height) / 2);
+   data-&gt;copyInfo(_uncompressed);	
+  return 1;
+}
+
+void do_rotate(ADMImage *source,ADMImage *target,uint32_t angle)
+{
+uint8_t *in;
+uint32_t in_w,in_h;
+
+in=source-&gt;data;
+in_w=source-&gt;_width;
+in_h=source-&gt;_height;
+
+uint32_t x, y;
+uint32_t u_offset = (in_w * in_h);
+uint32_t v_offset = u_offset + (in_w/2 * in_h/2);
+uint32_t in_sub_w = in_w/2;
+uint32_t in_sub_h = in_h/2;
+uint32_t out_sub_w, out_sub_h;
+
+uint8_t *out=target-&gt;data;
+uint32_t *out_w=&amp;(target-&gt;_width);
+uint32_t *out_h=&amp;(target-&gt;_height);
+
+ADM_assert(in_w*in_h==(*out_w)*(*out_h));
+
+// In general, for 0 &lt;= i &lt; width and 0 &lt;= j &lt; height, the pixel (x + i, y + j) is colored with red value 
+// red value   rgb_buf[(j * rowstride) + (i * 3) + 0], 
+// green value rgb_buf[(j * rowstride) + (i * 3) + 1], 
+// blue value  rgb_buf[(j * rowstride) + (i * 3) + 2].
+
+        switch(angle)
+        {
+        case 0:
+                *out_w = in_w;
+                *out_h = in_h;
+                out_sub_w = *out_w/2;
+                out_sub_h = *out_h/2;
+            
+                for(x = 0; x &lt; *out_w; x++)
+                for(y = 0; y &lt; *out_h; y++)
+                    *(out + (*out_w * y) + x) = *(in + (in_w * y) + x);
+            
+                for(x = 0; x &lt; out_sub_w; x++)
+                for(y = 0; y &lt; out_sub_h; y++)
+                {
+                    *(out + u_offset + (out_sub_w * y) + x) = *(in + u_offset + (in_sub_w * y) + x);
+                    *(out + v_offset + (out_sub_w * y) + x) = *(in + v_offset + (in_sub_w * y) + x);
+                }
+                break;
+        case 90:
+        {
+            *out_w = in_h;
+            *out_h = in_w;
+            out_sub_w = *out_w/2;
+            out_sub_h = *out_h/2;
+        
+            for(x = 0; x &lt; *out_w; x++)
+            for(y = 0; y &lt; *out_h; y++)
+                *(out + (*out_w * y) + x) = *(in + (in_w * (in_h-x-1)) + y);
+        
+            for(x = 0; x &lt; out_sub_w; x++)
+            for(y = 0; y &lt; out_sub_h; y++)
+            {
+                *(out + u_offset + (out_sub_w * y) + x) = *(in + u_offset + (in_sub_w * (in_sub_h-x-1)) + y);
+                *(out + v_offset + (out_sub_w * y) + x) = *(in + v_offset + (in_sub_w * (in_sub_h-x-1)) + y);
+            }
+        }
+        break;
+        case 180:
+        {
+            *out_w = in_w;
+            *out_h = in_h;
+            out_sub_w = *out_w/2;
+            out_sub_h = *out_h/2;
+        
+            for(x = 0; x &lt; *out_w; x++)
+            for(y = 0; y &lt; *out_h; y++)
+                *(out + (*out_w * y) + x) = *(in + (in_w * (in_h-y-1)) + in_w-x-1);
+        
+        
+            for(x = 0; x &lt; out_sub_w; x++)
+            for(y = 0; y &lt; out_sub_h; y++)
+                {
+                *(out + u_offset + (out_sub_w * y) + x) = *(in + u_offset + (in_sub_w * (in_sub_h-y-1)) + in_sub_w-x-1);
+                *(out + v_offset + (out_sub_w * y) + x) = *(in + v_offset + (in_sub_w * (in_sub_h-y-1)) + in_sub_w-x-1);
+                }
+        }
+            break;
+        case 270:
+        {
+            *out_w = in_h;
+            *out_h = in_w;
+            out_sub_w = *out_w/2;
+            out_sub_h = *out_h/2;
+        
+            for(x = 0; x &lt; *out_w; x++)
+            for(y = 0; y &lt; *out_h; y++)
+                *(out + (*out_w * y) + x) = *(in + (in_w * x) + (in_w-y-1));
+        
+            for(x = 0; x &lt; out_sub_w; x++)
+            for(y = 0; y &lt; out_sub_h; y++)
+            {
+                *(out + u_offset + (out_sub_w * y) + x) = *(in + u_offset + (in_sub_w * x) + (in_sub_w-y-1));
+                *(out + v_offset + (out_sub_w * y) + x) = *(in + v_offset + (in_sub_w * x) + (in_sub_w-y-1));
+            }
+        }
+        break;
+        default:
+            ADM_assert(0);
+        }
+}
+uint8_t ADMVideoRotate::configure( AVDMGenericVideoStream *instream)
+{
+  uint8_t r;
+  
+  diaMenuEntry rotateValues[]={
+      {0,QT_TR_NOOP(&quot;None&quot;),QT_TR_NOOP(&quot;None&quot;)},
+      {90,QT_TR_NOOP(&quot;90 degrees&quot;),QT_TR_NOOP(&quot;90&#176;&quot;)},
+      {180,QT_TR_NOOP(&quot;180 degrees&quot;),QT_TR_NOOP(&quot;180&#176;&quot;)},
+      {270,QT_TR_NOOP(&quot;270 degrees&quot;),QT_TR_NOOP(&quot;270&#176;&quot;)}
+  };
+  diaElemMenu     rotate(&amp;(_param-&gt;angle),QT_TR_NOOP(&quot;_Angle:&quot;),4,rotateValues,NULL);
+  diaElem *allWidgets[]={&amp;rotate};
+  if( !diaFactoryRun(QT_TR_NOOP(&quot;Rotate&quot;),1,allWidgets)) return 0;
+  
+  uint32_t w,h;
+  w=_in-&gt;getInfo()-&gt;width;
+  h=_in-&gt;getInfo()-&gt;height;
+  if((_param-&gt;angle%180)==90)
+  {
+    _info.width=_param-&gt;width=h;
+    _info.height=_param-&gt;height=w;
+  }else
+  {
+      _info.width=_param-&gt;width=w;
+      _info.height=_param-&gt;height=h;
+  }
+  return 1;
+}
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Rotate/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Rotate/CMakeLists.txt	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Rotate/CMakeLists.txt	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_rotate_SRCS ADM_vidRotate.cpp)
+
+ADD_LIBRARY(ADM_vf_rotate SHARED ${ADM_vf_rotate_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_rotate)
+INSTALL_VIDEOFILTER(ADM_vf_rotate)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidFont.cpp (from rev 4067, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidFont.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,218 @@
+/***************************************************************************
+                          ADM_vidFont.cpp  -  description
+                             -------------------
+    begin                : Sun Dec 15 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_vidFont.h&quot;
+
+static    FT_Library   	library;   		/* handle to library     */
+static    int 			initialized=0; 	// 0 No init at all, 1 engine inited
+
+ADMfont::ADMfont ( void )
+{
+	_faceAllocated=0;
+	_use2bytes=0;
+	_hold=0;
+	_value=0;
+
+}
+
+/**
+	Deallocate font allocated stuff
+*/
+ ADMfont::~ADMfont( )
+{
+
+	if(_faceAllocated)
+	{
+		//
+		FT_Done_Face(_face);
+		_faceAllocated=0;
+
+	}
+}
+
+
+int ADMfont::initFreeType( char *fontname )
+{
+int error;
+
+	printf(&quot;\n ** Initializing FreeType **\n&quot;);
+	if(initialized==0)
+	{
+
+    		error = FT_Init_FreeType( &amp;library );
+    		if ( error )
+    		{
+			  printf(&quot;\n Error Initializing Free Type (%d)\n&quot;,error);
+			  return 0;
+		  }
+		initialized=1;
+	}
+  	error = FT_New_Face( library,
+                         fontname,
+                         0,
+                         &amp;_face );
+    	if ( error == FT_Err_Unknown_File_Format )
+    	{
+   	   	printf(&quot;\n Error unknown font format (%d)\n&quot;,error);
+			  return 0;
+
+    	}
+    	else if ( error )
+    	{
+     		printf(&quot;\n Error unknown error (font %d)\n&quot;,error);
+		 return 0;
+    	}
+	_faceAllocated=1;
+
+	error = FT_Set_Pixel_Sizes(
+              _face,   /* handle to face object            */
+              0,      /* pixel_width                      */
+              16 );   /* pixel_height                     */
+
+	printf(&quot;\n **  FreeType Initialized **\n&quot;);
+	_hold=0;
+   	return 1;
+}
+//____________________________________________________
+int ADMfont::fontSetCharSet (char *charset)
+{
+	printf(&quot;OBSOLETE*********\n&quot;);
+	return 1;
+}
+//---------------------------------
+int ADMfont::fontSetSize ( int size)
+{
+int error;
+	if(!_faceAllocated)
+		{
+				printf(&quot;\n not initialized&quot;);
+				return 0;
+		}
+	   error = FT_Set_Pixel_Sizes(
+              _face,   /* handle to face object            */
+              0,      /* pixel_width                      */
+              size );   /* pixel_height                     */
+
+	return 1;
+}
+//____________________________________________________
+
+int ADMfont::fontDraw(char *target, int  c, int prevchar,int stride, int size,int *ww)
+{
+
+
+			if(!_faceAllocated)
+			{
+				printf(&quot;No face!\n&quot;);
+				return 0;
+			}
+FT_GlyphSlot  slot = _face-&gt;glyph;  // a small shortcut
+int  glyph_index,glyph_prev;
+int error;
+FT_Vector delta;
+int kern;
+
+	//printf(&quot;FONT: rendering %d %c\n&quot;,c,c);
+	*ww=0;
+/* Ugly patch t avoid some display problem */
+#if 0
+        if(c=='\'') c='&quot;';
+        if(prevchar=='\'') prevchar='&quot;';
+#endif
+/* Ugly patch t avoid some display problem */
+	glyph_index = FT_Get_Char_Index( _face, c );
+	if(prevchar)
+		glyph_prev=FT_Get_Char_Index( _face, prevchar );
+
+   	error = FT_Load_Glyph(
+        		   _face,          /* handle to face object */
+        		     glyph_index,   /* glyph index           */
+        		      0 );  /* load flags, see below */
+	if(error)
+	{
+		printf(&quot;Loadglyph error\n&quot;);
+	 	return 0;
+	}
+
+	error = FT_Render_Glyph(
+			slot,      /* glyph slot  */
+			ft_render_mode_normal);    /* render mode */
+
+      	if(error)
+	{
+		printf(&quot;RenderGlyph error&quot;);
+	 	return 0;
+	 }
+
+       // now, draw to our target surface
+       // inspired from MPlayer font rendering
+
+	FT_Bitmap *bitmap=&amp;(slot-&gt;bitmap);
+	int heigh;
+	int srow=0;
+
+
+	heigh=bitmap-&gt;rows;
+	target+=stride*(size-slot-&gt;bitmap_top);
+
+	int correction;
+// If kerning is available from freetype
+#ifdef FT_FACE_FLAG_KERNING
+	if(prevchar &amp;&amp; FT_HAS_KERNING( _face ))
+	{
+		FT_Get_Kerning( _face,glyph_prev, glyph_index, 0 /*FT_KERNING_DEFAULT*/, &amp;delta );
+		correction=delta.x/64;
+	}
+	else
+#endif
+		correction=0;
+	target+=correction;
+
+	target+=slot-&gt;bitmap_left;
+	//target+=(slot-&gt;bitmap_top)*stride;
+	for (int h = heigh; h&gt;0 ; h-- )
+	{
+	    for (int w =0;w&lt; bitmap-&gt;width;  w++ )
+	    {
+		if(bitmap-&gt;buffer[srow+w])
+			    *(target+w) = bitmap-&gt;buffer[srow+w];
+
+	     }
+		 target+=stride;
+		 srow+=bitmap-&gt;pitch ;
+	}
+
+	// Now advance cursor
+	int advance=0;//correction;
+	*ww=bitmap-&gt;width;
+	advance+=slot-&gt;advance.x/64;
+
+
+// 	printf(&quot;FONT: Width %d, adance:%d\n&quot;,bitmap-&gt;width,advance);
+//  	printf(&quot;FONT:cur :%c next :%c\n&quot;,c,prevchar);
+//  	printf(&quot;FONT:cur :%d next :%d\n&quot;,glyph_index,glyph_prev);
+//  	printf(&quot;FONT:Raw: %d kerning:%d kerning :%d \n&quot;,*ww,delta.x,delta.y);
+
+
+//	FT_Done_Glyph(glyph_index); Mem leak ?
+	*ww=advance;
+	return 1;
+}
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidFont.h (from rev 4067, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFont.h	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidFont.h	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,51 @@
+/***************************************************************************
+                          ADM_vidFont.h  -  description
+                             -------------------
+    begin                : Sun Dec 15 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#undef free
+#undef alloc
+#undef realloc
+#ifdef HAVE_UNISTD_H
+// avoid warnings due to different definition of this in freetype headers
+#define WE_DO_HAVE_UNISTD_H
+#undef HAVE_UNISTD_H
+#endif
+ #include &lt;ft2build.h&gt;
+ #include FT_FREETYPE_H
+#ifdef WE_DO_HAVE_UNISTD_H
+#undef HAVE_UNISTD_H
+#define HAVE_UNISTD_H
+#endif
+
+ class ADMfont
+ {
+ private:
+ 		  
+		   FT_Face    _face;
+		   int			_faceAllocated;
+		   uint8_t		_use2bytes;
+		   uint8_t		_hold;
+		   int			_value;
+ public :
+		ADMfont(void );
+		~ADMfont();
+
+	int initFreeType( char *fontname );
+	int fontDraw(char *target, int c,int prevchar, int stride, int size,int *ww);
+	int fontSetSize ( int size);
+	int fontSetCharSet (char *code);
+
+};
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRT.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRT.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRT.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -14,47 +14,43 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-
-#include &quot;config.h&quot;
-
-#ifdef USE_FREETYPE
 #include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+
 #include &quot;DIA_coreToolkit.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
 
-#include &quot;ADM_video/ADM_vidFont.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
 
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
+#include &quot;ADM_vidFont.h&quot;
+#include &quot;ADM_vidSRT.h&quot;
 
-#include &quot;prefs.h&quot;
+#define aprintf(...) {}
+//#include &quot;prefs.h&quot;
 
 static FILTER_PARAM subParam={15,{&quot;_fontsize&quot;,&quot;_subname&quot;,&quot;_fontname&quot;,&quot;_charset&quot;,
 				&quot;_baseLine&quot;,&quot;_Y_percent&quot;,&quot;_U_percent&quot;,&quot;_V_percent&quot;,
 				&quot;_selfAdjustable&quot;,&quot;_delay&quot;,&quot;_useBackgroundColor&quot;,&quot;_bg_Y_percent&quot;,
       				&quot;_bg_U_percent&quot;,&quot;_bg_V_percent&quot;,&quot;_blend&quot;}};
 
-SCRIPT_CREATE(subtitle_script,ADMVideoSubtitle,subParam);
-
-BUILD_CREATE(subtitle_create,ADMVideoSubtitle);
-
 //__________________________________________________________________
+VF_DEFINE_FILTER_UI(ADMVideoSubtitle,subParam,
+    subtitle,
+                QT_TR_NOOP(&quot;Subtitler&quot;),
+                1,
+                VF_SUBTITLE,
+                QT_TR_NOOP(&quot;Add srt/sub subtitles to the picture.&quot;));
 
 //_______________________________________________________________
 
-//__________________________________________________________________
 
 char 								*ADMVideoSubtitle::printConf(void)
  {
 	  	static char buf[50];
- 	
+
  				sprintf((char *)buf,&quot;Subtitle &quot;);
         return buf;
 	}
 
-//--------------------------------------------------------	
+//--------------------------------------------------------
 ADMVideoSubtitle::ADMVideoSubtitle(AVDMGenericVideoStream *in,CONFcouple *couples)
 {
 
@@ -75,7 +71,7 @@
  	_line=0;
 	_oldframe=0;
 	_oldline=0;
-	_font = new ADMfont();	
+	_font = new ADMfont();
 	if(couples)
 	{
                 int32_t b;
@@ -112,9 +108,9 @@
                     char *ft,*sub;
                         ft=(char *)ADM_alloc(500);
                         sub=(char *)ADM_alloc(500);
-                        strcpy(ft,(char *)_conf-&gt;_subname); 
+                        strcpy(ft,(char *)_conf-&gt;_subname);
                         _conf-&gt;_subname=(ADM_filename *)ft;
-                        strcpy(sub,(char *)_conf-&gt;_fontname); 
+                        strcpy(sub,(char *)_conf-&gt;_fontname);
                         _conf-&gt;_fontname=(ADM_filename *)sub;
 
                         sub=(char *)ADM_alloc(500);
@@ -134,44 +130,44 @@
 			_conf-&gt;_fontname[0]=0;
 			_conf-&gt;_subname[0]=0;
 			_conf-&gt;_charset[0]=0;
-			
-			
+
+
 			_conf-&gt;_baseLine=_info.height-24*SRT_MAX_LINE;
 			_conf-&gt;_Y_percent=255;
 			_conf-&gt;_U_percent=0;
 			_conf-&gt;_V_percent=0;
-                        _conf-&gt;_fontsize=24; 
+                        _conf-&gt;_fontsize=24;
 			_conf-&gt;_selfAdjustable=0;
 			_conf-&gt;_delay=0;
 			_conf-&gt;_useBackgroundColor=0;
-			
+
 			_conf-&gt;_bg_Y_percent=0;
 			_conf-&gt;_bg_U_percent=0;
 			_conf-&gt;_bg_V_percent=0;
                         _conf-&gt;_blend=BLEND_SOLID;
-
+#if 0
 			prefs-&gt;get(FILTERS_SUBTITLE_FONTSIZE,&amp;(_conf-&gt;_fontsize));
 			prefs-&gt;get(FILTERS_SUBTITLE_YPERCENT,&amp;(_conf-&gt;_Y_percent));
 			prefs-&gt;get(FILTERS_SUBTITLE_UPERCENT,&amp;(_conf-&gt;_U_percent));
 			prefs-&gt;get(FILTERS_SUBTITLE_VPERCENT,&amp;(_conf-&gt;_V_percent));
-			prefs-&gt;get(FILTERS_SUBTITLE_SELFADJUSTABLE,&amp;(_conf-&gt;_selfAdjustable));			
+			prefs-&gt;get(FILTERS_SUBTITLE_SELFADJUSTABLE,&amp;(_conf-&gt;_selfAdjustable));
 			prefs-&gt;get(FILTERS_SUBTITLE_USEBACKGROUNDCOLOR,&amp;(_conf-&gt;_useBackgroundColor));
-			
+
 			// _conf-&gt;_fontname, ... are used as memory for a dialog
 			// later. we can't used the length of the current string
 			{ char *tmp;
 			   prefs-&gt;get(FILTERS_SUBTITLE_FONTNAME,&amp;tmp);
 			   strcpy((char *)_conf-&gt;_fontname,tmp);
 			   ADM_dealloc(tmp);
-			   
+
 			   prefs-&gt;get(FILTERS_SUBTITLE_CHARSET,&amp;tmp);
-			   strcpy(_conf-&gt;_charset,tmp); 
+			   strcpy(_conf-&gt;_charset,tmp);
                            ADM_dealloc(tmp);
 			}
-			
+#endif
 	}
 
-  
+
   	_info.encoding=1;
 
 
@@ -197,7 +193,7 @@
                           GUI_Error_HIG(QT_TR_NOOP(&quot;Could not open subtitle file&quot;), NULL);
 				return 0;
 			}
-			// Try to detect utf16 files			
+			// Try to detect utf16 files
 			c=fgetc(_fd);
 			// Skip utf identifier if any
 			if( (c&amp;0xef)==0xef)
@@ -218,13 +214,13 @@
 			}
 
   // Apply delay to subtitles
-  
+
   aprintf(&quot;[debug] DELAY %d\n&quot;, _conf-&gt;_delay);
   if(_conf-&gt;_delay)
   {
   	int32_t newStartTime;
 	int32_t newEndTime;
-	for(uint32_t i=0;i&lt;_line;i++) 
+	for(uint32_t i=0;i&lt;_line;i++)
 	{
 		aprintf(&quot;[debug] BEFORE DELAY (%d) %d %d\n&quot;,i, _subs[i].startTime,_subs[i].endTime);
 		newStartTime=_subs[i].startTime;
@@ -294,13 +290,13 @@
 				_maskBuffer=0;
 			}
 
- 		if(_bgBitmapBuffer) 
+ 		if(_bgBitmapBuffer)
 			{
 				delete [] _bgBitmapBuffer;
 				_bgBitmapBuffer=0;
 			}
- 
-		if(_bgMaskBuffer) 
+
+		if(_bgMaskBuffer)
 			{
 				delete [] _bgMaskBuffer;
 				_bgMaskBuffer=0;
@@ -323,14 +319,14 @@
 					if(_subs[i].nbLine)
 					{
 					for(uint32_t k=0;k&lt;_subs[i].nbLine;k++)
-					{					
+					{
 						if(_subs[i].string[k])
 						{
 							delete [] _subs[i].string[k];
 							_subs[i].string[k]=NULL;
 						}
-					}					
-					
+					}
+
 					delete _subs[i].string;
 					_subs[i].string=NULL;
 					delete _subs[i].lineSize;
@@ -356,17 +352,17 @@
 }
 
 uint8_t DIA_srt(AVDMGenericVideoStream *source, SUBCONF *param);
-    
+
 uint8_t ADMVideoSubtitle::configure(AVDMGenericVideoStream *instream)
 {
-  
+
   UNUSED_ARG(instream);
 //char c;
 uint8_t ret=0;
 int charset=0;
 uint32_t l,f;
 
-                        
+
           if(DIA_srt(	instream,_conf))
           {
             printf(&quot;\n Font : %s&quot;, _conf-&gt;_fontname);
@@ -380,7 +376,7 @@
 
             loadSubtitle();
             loadFont();
-                        
+#if 0
             prefs-&gt;set(FILTERS_SUBTITLE_FONTNAME,
                     (ADM_filename *)_conf-&gt;_fontname);
             prefs-&gt;set(FILTERS_SUBTITLE_CHARSET,
@@ -393,10 +389,11 @@
                         _conf-&gt;_selfAdjustable);
             prefs-&gt;set(FILTERS_SUBTITLE_USEBACKGROUNDCOLOR,
                         _conf-&gt;_useBackgroundColor);
+#endif
             ret=1;
         }
         return ret;
 
 }
-#endif
 
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRT.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRT.h	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRT.h	2008-05-27 19:41:54 UTC (rev 4068)
@@ -17,7 +17,6 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#ifdef USE_FREETYPE
 
 #define SRT_MAX_LINE 3
 #define SRT_MAX_LINE_LENGTH 512
@@ -125,4 +124,3 @@
 			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
 							
  }     ;
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRTRender.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRTRender.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRTRender.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -15,9 +15,6 @@
  *                                                                         *
  ***************************************************************************/
 
-#include &quot;config.h&quot;
-
-#ifdef USE_FREETYPE
 #include &lt;math.h&gt;
 
 #include &quot;ADM_default.h&quot;
@@ -25,12 +22,10 @@
 
 #include &quot;ADM_videoFilter.h&quot;
 
-#include &quot;ADM_video/ADM_vidFont.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
+#include &quot;ADM_vidFont.h&quot;
+#include &quot;ADM_vidSRT.h&quot;
 
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
+#define aprintf(...) {}
 
 #define SUB_OUT 0xf0000000
 #define ALPHA
@@ -60,7 +55,7 @@
 
 	//		printf(&quot;\n Stabilize : %lu\n&quot;,frame);
           _uncompressed=data;
-	if(frame&gt;=_info.nb_frames) 
+	if(frame&gt;=_info.nb_frames)
 	{
 		printf(&quot;Filter : out of bound!\n&quot;);
 		return 0;
@@ -79,12 +74,12 @@
 	      {
 	      		aprintf(&quot;Sub: cached %lu %lu %lu\n&quot;,time,_subs[_oldline].startTime,_subs[_oldline].endTime);
 			blend(YPLANE(data),_conf-&gt;_baseLine); // re-use it
-			return 1;	
+			return 1;
 
 	      }
 	      srch=search(time);
 	      // we got the right one
-     
+
 	      if(srch!=SUB_OUT) // we got something...
 			{
 					_oldline=srch;
@@ -121,8 +116,8 @@
 //______________________________________
 void ADMVideoSubtitle::displayString(subLine *string)
 {
- 
-	uint32_t base=0;	
+
+	uint32_t base=0;
 	uint32_t nbLine=0;
 	uint32_t i=0;
 	uint32_t overflow=0;
@@ -141,27 +136,27 @@
 	switch(nbLine)
 	{
 		case 0:
-			base=2*_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line		
+			base=2*_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line
 			break;
 		case 1:
-			base=_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line		
+			base=_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line
 			break;
 		default:
                         base=0;
                         break;
-	}	
-		
+	}
+
 	aprintf(&quot;Sub: %d lines to render\n&quot;,nbLine);
 	// scan and display each line
 	for(i=0;i&lt;nbLine;i++)
 	{
-		
+
 			if(string-&gt;lineSize[i]!=displayLine(string-&gt;string[i],base,string-&gt;lineSize[i]))
                                 overflow=1;
 			base+=_conf-&gt;_fontsize;
-		
+
 	}
-        if(overflow &amp;&amp; _conf-&gt;_selfAdjustable) 
+        if(overflow &amp;&amp; _conf-&gt;_selfAdjustable)
         {
                 printf(&quot;Do autosplit\n&quot;);
                 doAutoSplit(string);
@@ -178,7 +173,7 @@
         while(top&lt;_info.height &amp;&amp; !isDirty(top)) top++;
         if(top&gt;_conf-&gt;_fontsize&gt;&gt;1) top-=_conf-&gt;_fontsize&gt;&gt;1;
         memset(&amp;(_dirty[0]),0,top); // Clear top
-        
+
         // Then bottom
         limit=(SRT_MAX_LINE+1)*_conf-&gt;_fontsize;
         if(limit&gt;=_info.height) limit=_info.height-1;
@@ -190,7 +185,7 @@
         ADM_assert(bottom&lt;=limit);
         memset(&amp;(_dirty[bottom]),0,limit-bottom+1);
         //printf(&quot;Top:%d bottom :%d limit:%d\n&quot;,top,bottom,limit);
-	
+
 }
 uint8_t ADMVideoSubtitle::isDirty(int line)
 {
@@ -207,7 +202,7 @@
 */
 void ADMVideoSubtitle::doAutoSplit(subLine *string)
 {
-        uint32_t base=0;    
+        uint32_t base=0;
         uint32_t nbLine=0;
         uint32_t i=0;
         int      total=0,start,end,pivot;
@@ -217,7 +212,7 @@
 
         // Merge all strings into one
 
-        for(int i=0;i&lt;nbLine;i++) 
+        for(int i=0;i&lt;nbLine;i++)
                 total+=1+string-&gt;lineSize[i];
 
         ADM_GLYPH_T allwords[total];
@@ -226,7 +221,7 @@
         int         nbWords=0;
         //
         start=0;
-        for(int i=0;i&lt;nbLine;i++) 
+        for(int i=0;i&lt;nbLine;i++)
         {
                 memcpy(&amp;(allwords[start]),string-&gt;string[i],string-&gt;lineSize[i]*sizeof(ADM_GLYPH_T));
                 start+=string-&gt;lineSize[i];
@@ -244,7 +239,7 @@
         for(i=0;i&lt;end;i++)
                 printf(&quot;%c&quot;,allwords[i]);
         printf(&quot;&gt;\n&quot;);
-        
+
         // Split into words
         pivot=0;
         int car;
@@ -259,7 +254,7 @@
                         }
                 pivot++;
         }
-        printf(&quot;Found %d words\n&quot;,nbWords); 
+        printf(&quot;Found %d words\n&quot;,nbWords);
         // Now  split
         int nbSentence=0,len;
         pivot=0;
@@ -293,14 +288,14 @@
                 printf(&quot;\n&quot;);
         }
         // now display
-        
+
         switch(nbSentence)
         {
                 case 0:
-                        base=2*_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line            
+                        base=2*_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line
                         break;
                 case 1:
-                        base=_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line              
+                        base=_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line
                         break;
                 default:
                         base=0;
@@ -317,7 +312,7 @@
                         base+=_conf-&gt;_fontsize;
         }
         printf(&quot;/Display\n&quot;);
-        
+
 }
 /*
         Once we have the subtitle built, we do the u&amp; v planes
@@ -347,12 +342,12 @@
         lowPass(src,dst,_info.width,_info.height);
         lowPass(tmp,src,_info.width&gt;&gt;1,_info.height&gt;&gt;1);
 
-        if (_conf-&gt;_useBackgroundColor) 
+        if (_conf-&gt;_useBackgroundColor)
         {
                 decimate(_bgMaskBuffer,_bgBitmapBuffer,_info.width,_info.height);
                 //lowPass(tmp,_bgBitmapBuffer,_info.width&gt;&gt;1,_info.height&gt;&gt;1);
         }
-  
+
 }
 /*
         Clear the buffers in case we do a new sub or
@@ -375,8 +370,8 @@
 uint32_t ADMVideoSubtitle::displayLine(ADM_GLYPH_T *string,uint32_t line, uint32_t len)
 {
   // n first chars in string that can &quot;fit&quot; in this line
- 
 
+
 	//uint32_t pixstart;
 	uint8_t *target;
 	int car;
@@ -391,7 +386,7 @@
 	}
 
 
-  
+
 	uint32_t w=0,next;
 	int ww;
 
@@ -432,7 +427,7 @@
 				}
 				w=w+ww;
 			}
-      
+
 	}
 _abt:
 	//Now we can render it at its final position
@@ -474,25 +469,25 @@
 				}
 				w=w+ww;
 			}
-      
+
 	}
 
   {
     if (_conf-&gt;_useBackgroundColor) {
       //Create background info
-      
+
       int32_t delta=_info.width*line+((_info.width-w)&gt;&gt;1);
       uint8_t *bitmapTarget=_bitmapBuffer+delta;
       uint8_t *maskTarget=_maskBuffer+delta;
       //uint8_t *bgBitmapTarget=_bgBitmapBuffer+delta;
       uint8_t *bgMaskTarget=_bgMaskBuffer+delta;
-      
+
       delta=3*_info.width;
       bitmapTarget+=delta;
       maskTarget+=delta;
       //bgBitmapTarget+=delta;
       bgMaskTarget+=delta;
-      
+
       for (uint32_t i=0;i&lt;_conf-&gt;_fontsize;i++) {
 	//memset(bgTarget,1,w);
 	for (uint32_t j=0;j&lt;w;j++) {
@@ -511,9 +506,9 @@
 
     }
   }
-	
 
- 
+
+
   return len;
 }
 //--------------------------------------------------------------------
@@ -538,44 +533,44 @@
 	hei=(SRT_MAX_LINE+1)*_conf-&gt;_fontsize;
 	if(hei&gt;=_info.height-1) hei=_info.height-1;
 	hei*=_info.width;  // max height of our subtitle
-	
 
+
 	aprintf(&quot;Sub:Rendering : %d %d %d (yuv)\n&quot;,_conf-&gt;_Y_percent,_conf-&gt;_U_percent,_conf-&gt;_V_percent);
-	
+
 	// keep a little margin for renderin
 	// to render f y or g
 	if((baseLine) &gt; _conf-&gt;_fontsize)
 		baseLine-=_conf-&gt;_fontsize&gt;&gt;1;
-	
-		
+
+
 	//__________________________
-		
+
 		// Shadow ..
 		uint8_t *shadow=target;
 		uint32_t shadow_pos;
-		
+
 		shadow_pos=_conf-&gt;_fontsize/10;
 		start=_info.width*baseLine;  // base line in final image
 		// mask out left and right
-		mask=_maskBuffer; 
-				
+		mask=_maskBuffer;
+
  		shadow+=start+(1+_info.width)*shadow_pos;
   		for( y=hei;y&gt;0;y--)
 		{
-     		 if(*mask) 
+     		 if(*mask)
 		 {
 				if(*mask&gt;LUMA_LEVEL)
 				{
 					val=*shadow;
 					val=(val*SHADOW_UP)/SHADOW_DOWN;
 					*shadow=(uint8_t )val;
-				}				
-     		 } 	  
-      
+				}
+     		 }
+
 		shadow++;
 		mask++;
 		}
-	
+
 	// /Shadow
 	//__________________________
 	start=_info.width*baseLine;  // base line in final image
@@ -587,7 +582,7 @@
 	mask=_maskBuffer;
   	bgMask=_bgMaskBuffer;
  	target+=start;
-        // clip 
+        // clip
         if(hei+start&gt;_info.width*_info.height)
         {
                 hei=_info.width*_info.height-start;
@@ -613,12 +608,12 @@
                                         val&gt;&gt;=8;
                                         *target=(uint8_t )val;
                                 }
-                                else 
+                                else
                                         { *target=0; }
-                        } else 
+                        } else
                         if(*bgMask)
                         {
-                                if(_conf-&gt;_useBackgroundColor) 
+                                if(_conf-&gt;_useBackgroundColor)
                                 {
                                         *target=(uint8_t )_conf-&gt;_bg_Y_percent;
                                 }
@@ -629,25 +624,25 @@
                                         {
                                                 case BLEND_SOLID: break;
                                                 case BLEND_DIMMER: *target=(*target*3)&gt;&gt;2;break;
-                                                case BLEND_DOTTED: 
+                                                case BLEND_DOTTED:
                                                 {
                                                         int odd;
                                                                 odd= y%_info.width;
                                                                 odd=odd&amp;1;
                                                                 odd+=(1&amp;(y/_info.width));
                                                                 odd&amp;=1;
-                                                                if(odd) *target=0; 
+                                                                if(odd) *target=0;
                                                 }
                                         }
                                 }
-                        
+
                 target++;
                 mask++;
                 bgMask++;
               }
         }
-	
 
+
 // do u &amp; v
 	int8_t *ctarget;
 
@@ -685,7 +680,7 @@
 			} \
                 } \
              else if (_conf-&gt;_useBackgroundColor &amp;&amp; *bgMask) {*target=(uint8_t)bg_val;}
-	     
+
 #define RENDER	     \
 	\
 	for( y=hei;y&gt;0;y--) \
@@ -696,7 +691,7 @@
 		mask++; \
 	bgMask++; \
 	} \
-	
+
 	RENDER;
 
 	mask=_bitmapBuffer;
@@ -780,4 +775,4 @@
 	return 1;
 }
 
-#endif
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRTload.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRTload.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/ADM_vidSRTload.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -7,7 +7,7 @@
 	The structure is
 		uint32_t 		startTime in ms from beginning
 		uint32_t 		endTime  in ms from beginning
-	
+
 	All text are stored as utf16 after loading
 
 
@@ -25,9 +25,6 @@
  *                                                                         *
  ***************************************************************************/
 
-#include &quot;config.h&quot;
-
-#ifdef USE_FREETYPE
 #include &lt;math.h&gt;
 #include &lt;iconv.h&gt;
 #include &lt;errno.h&gt;
@@ -38,12 +35,10 @@
 
 #include &quot;ADM_videoFilter.h&quot;
 
-#include &quot;ADM_video/ADM_vidFont.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
+#include &quot;ADM_vidFont.h&quot;
+#include &quot;ADM_vidSRT.h&quot;
 
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
+#define aprintf(...) {}
 
 #define ADM_RAW 1024
 
@@ -59,7 +54,7 @@
 
 uint8_t	ADMVideoSubtitle::loadFont (void)
 {
- 
+
   if (!_font-&gt;initFreeType ((char *)_conf-&gt;_fontname))
     {
       printf (&quot;\n Free type init failed for font %s!&quot;, _conf-&gt;_fontname);
@@ -68,7 +63,7 @@
     {
       _font-&gt;fontSetSize (_conf-&gt;_fontsize);
     }
-   
+
   return 1;
 }
 
@@ -84,12 +79,12 @@
   uint32_t current_line = 0;
   // first cound how many line
   _line = 0;
-   // init iconv...  
+   // init iconv...
   if(! ADM_utfInit(_conf-&gt;_charset))
   {
   	printf(&quot;Problem initializing iconv, aborting\n&quot;);
 	return 0;
-  
+
   }
   while (fgets (string, 200, _fd))
     {
@@ -105,8 +100,8 @@
   memset (_subs, 0, sizeof (subLine) * _line);
 
 
- 
-//	
+
+//
   for (uint32_t i = 0; i &lt; _line; i++)
     {
       fgets (string, ADM_RAW, _fd);
@@ -116,11 +111,11 @@
       subParse ((subLine *) &amp; (_subs[current_line]), string);
       current_line++;
     }
-	
+
   // the effective number of line we have
   _line = current_line;
   return 1;
-  
+
  ADM_utfEnd( );
 }
 
@@ -137,19 +132,19 @@
   uint32_t   	startindex, endindex,textindex;
   uint32_t 	j;
   float 	f;
- 
+
   uint32_t 	finallen=0;
   uint32_t	alpha;
- 
+
   j = 1;
-  
-  
+
+
   ADM_utfConv(final,string,strlen(string),&amp;finallen);
-  
+
   // ignore { }
   while (ADM_ASC(final[j]) != '}' &amp;&amp; j &lt; finallen)
     j++;
- 
+
   startindex =1;
   j += 2;			// skip }{
   endindex =j;
@@ -177,7 +172,7 @@
   f=(float)alpha;
   aprintf(&quot; end:%d\n&quot;,alpha);
   f = f * 1000000. / _info.fps1000;
-  
+
   in-&gt;endTime = (uint32_t) floor (f);
 
   uint32_t lllines=0;
@@ -198,13 +193,13 @@
   in-&gt;nbLine=lllines+1;
   in-&gt;string=new ADM_GLYPH_T *[in-&gt;nbLine];
   in-&gt;lineSize=new uint32_t[in-&gt;nbLine];
-  
+
   for(uint32_t i=0;i&lt;in-&gt;nbLine;i++)
   {
   	in-&gt;string[i]=new ADM_GLYPH_T[finallen]; 	// yes, we overshot
 	in-&gt;lineSize[i]=0;
   }
-  
+
   uint32_t curline=0, curindex=0;
   for(uint32_t i=0;i&lt;finallen;i++)
   {
@@ -212,14 +207,14 @@
 	{
 		in-&gt;lineSize[curline]=curindex;
 		curindex=0;
-		curline++;		
+		curline++;
 	}
 	else
 	{
 		in-&gt;string[curline][curindex++]=final[i+textindex];
 	}
-  
-  }  
+
+  }
   if(curindex)
   	in-&gt;lineSize[curline]=curindex;
   return 1;
@@ -237,21 +232,21 @@
   ADM_GLYPH_T  		temp[SRT_MAX_LINE][ADM_RAW];
   uint32_t		tempSize[SRT_MAX_LINE];
   char			string[ADM_RAW];
-  
-  
-  uint32_t line;  
+
+
+  uint32_t line;
   uint32_t len;
   // Init iconv
    uint32_t 	finallen=0;
   subLine	*current;
-  
+
   if(! ADM_utfInit(_conf-&gt;_charset))
   {
   	printf(&quot;Problem initializing iconv, aborting\n&quot;);
 	return 0;
-  
-  } 
-  
+
+  }
+
   // first cound how many line
   line = 0;
   _line = 0;
@@ -265,24 +260,24 @@
 
   if (!_subs)
     return 0;
-  
+
   memset (_subs, 0, sizeof (subLine) * line);
-  
+
   // read and allocate
-  
+
   uint32_t j;
   int state = 0;
   int stored=0;
-  
+
   for (uint32_t i = 0; i &lt; line; i++)
     {
 	current=&amp;_subs[_line];
 	fgets (string, ADM_RAW, _fd);
 	ADM_utfConv(final,string,strlen(string),&amp;finallen);
-	// Purge cr/lf	
+	// Purge cr/lf
 	switch (state)
 	{
-	case 0:		// waiting for number	 
+	case 0:		// waiting for number
                   if(!_line &amp;&amp; (final[0]&amp;0xfefe)==0xfefe)
                   {
                       j=ADM_SubAtoi (final+1);
@@ -301,7 +296,7 @@
 			uint32_t dh, dm, ds, md;
 
 			ADM_GLYPH_T *cur=&amp;final[0];
-				
+
 	  		sh=ADM_SubAtoi(cur);
 			cur+=3;
 			sm=ADM_SubAtoi(cur);
@@ -310,9 +305,9 @@
 			cur+=3;
 			ms=ADM_SubAtoi(cur);
 			cur+=3;
-			
+
 			cur+=5;
-			
+
 			dh=ADM_SubAtoi(cur);
 			cur+=3;
 			dm=ADM_SubAtoi(cur);
@@ -320,19 +315,19 @@
 			ds=ADM_SubAtoi(cur);
 			cur+=3;
 			md=ADM_SubAtoi(cur);
-			
+
 			_subs[_line].startTime = ms + 1000 * (ss + sm * 60 + sh * 3600);
 			_subs[_line].endTime = md + 1000 * (ds + dm * 60 + dh * 3600);
 			state = 2;
-			
+
 			aprintf(&quot;%d %d %d %d / %d %d %d %d&gt;%s&lt;\n&quot;,sh,sm,ss,ms,dh,dm,ds,md,string);
-			
+
 		}
 
 		break;
-	case 2:		
+	case 2:
 	   // looking for text
-	   // We append each line to text with a | to separate the lines	 	  
+	   // We append each line to text with a | to separate the lines
 	  {
 	  	if (finallen &lt; 2)
 	    	{
@@ -369,9 +364,9 @@
 
     }
   ADM_utfEnd( );
-  aprintf(&quot;&gt;&gt; Sub: %d subs stored and loaded\n&quot;,_line); 	
+  aprintf(&quot;&gt;&gt; Sub: %d subs stored and loaded\n&quot;,_line);
   return 1;
-  
+
 }
 // Sort of atoi for utf16
 // Very basic
@@ -381,7 +376,7 @@
 	int d;
 	do
 	{
-		d=ADM_ASC(*in);		
+		d=ADM_ASC(*in);
 		in++;
 		if(d&gt;='0' &amp;&amp; d&lt;='9')
 		{
@@ -391,8 +386,8 @@
 		else
 			return result;
 	}while(1);
-	
 
+
 }
 //	Init iconv, so that we can go utf16
 //
@@ -422,22 +417,22 @@
 	sout=ADM_RAW;
 	cin=in;
 	cout=(char *)(out);
-	
+
 	if((uint8_t)in[0]==0xff &amp;&amp; (uint8_t)in[1]==0xfe)
 	{
 		 cin+=2;
 		 sin-=2;
 	}
-	if(!sin) 
+	if(!sin)
 	{
 		*nbOut=0;
 		return 1;
 	}
-#ifdef  ICONV_NEED_CONST 
+#ifdef  ICONV_NEED_CONST
   	sz=iconv(myConv,(const char **)&amp;cin,&amp;sin,&amp;cout,&amp;sout);
 #else
 	sz=iconv(myConv,&amp;cin,&amp;sin,&amp;cout,&amp;sout);
-#endif	
+#endif
 	if(sz==-1)
 	{
   		printf(&quot;Iconv error:%s\n:%s:\n&quot;,strerror(errno),in);
@@ -456,7 +451,7 @@
                out[w]=((glyph&amp;0xff)&lt;&lt;8)+(glyph&gt;&gt;8);
        }
 #endif
-	
+
 	if(done)
 	{
 		if(0xfeff==out[0])
@@ -464,14 +459,14 @@
 			//aprintf(&quot;Removing utf tag\n&quot;);
 			done--;
 			memmove(&amp;out[0],&amp;out[1],done*sizeof(ADM_GLYPH_T));
-			
+
 		}
 	}
 
 	while(done &amp;&amp;( ADM_ASC(out[done-1])==0x0a || ADM_ASC(out[done-1]==0x0d))) done--;
 	*nbOut=done;
 	return 1;
-	
+
 }
 // Close iconv
 //
@@ -487,4 +482,4 @@
 }
 
 
-#endif
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/CMakeLists.txt	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/CMakeLists.txt	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,45 @@
+INCLUDE(admCheckFreeType)
+checkFreeType()
+IF(USE_FREETYPE)
+        INCLUDE(vf_plugin)
+
+        SET(srtCommon_SRCS 
+          ADM_vidFont.cpp  ADM_vidSRT.cpp  ADM_vidSRTload.cpp  ADM_vidSRTRender.cpp  DIA_srt.cpp DIA_flySrtPos.cpp
+        )
+
+        INCLUDE(vf_plugin_gtk)
+        INCLUDE(vf_plugin_qt4)
+
+        SET(srtGtk_SRCS gtk/DIA_srt.cpp)
+        SET(srtQT_SRCS  qt4/Q_srt.cpp)
+        SET(srtQT_HEADERS  qt4/Q_srt.h)
+        SET(srtQT_UI    qt4/srt)
+
+
+INIT_VIDEOFILTER_PLUGIN_QT4(ADM_vf_sub_qt4 
+                ${srtQT_SRCS} ${srtQT_HEADERS} ${srtQT_UI} ${srtCommon_SRCS})
+INIT_VIDEOFILTER_PLUGIN_GTK(  ADM_vf_sub_gtk 
+                ${srtGtk_SRCS} ${srtCommon_SRCS})
+
+        ADD_SOURCE_CFLAGS(DIA_srt.cpp           &quot;${FREETYPE2_CFLAGS}&quot;)
+        ADD_SOURCE_CFLAGS(ADM_vidSRT.cpp        &quot;${FREETYPE2_CFLAGS}&quot;)
+        ADD_SOURCE_CFLAGS(ADM_vidFont.cpp       &quot;${FREETYPE2_CFLAGS}&quot;)
+        ADD_SOURCE_CFLAGS(ADM_vidSRTload.cpp    &quot;${FREETYPE2_CFLAGS}   -I${LIBICONV_INCLUDE_DIR}&quot;)
+        ADD_SOURCE_CFLAGS(ADM_vidSRTRender.cpp  &quot;${FREETYPE2_CFLAGS}&quot;)
+IF (GTK_FOUND AND GTHREAD_FOUND)
+	ADD_TARGET_LDFLAGS(ADM_vf_sub_gtk           &quot;${FREETYPE2_LDFLAGS} ${LIBICONV_LIBRARY_DIR}&quot;)
+        IF (USE_FONTCONFIG)
+	        ADD_TARGET_LDFLAGS(ADM_vf_sub_gtk &quot;${FONTCONFIG_LDFLAGS}&quot;)
+        ENDIF (USE_FONTCONFIG)
+ENDIF (GTK_FOUND AND GTHREAD_FOUND)
+
+
+IF (QT4_FOUND)
+	ADD_TARGET_LDFLAGS(ADM_vf_sub_qt4           &quot;${FREETYPE2_LDFLAGS} ${LIBICONV_LIBRARY_DIR}&quot;)
+        IF (USE_FONTCONFIG)
+	        ADD_TARGET_LDFLAGS(ADM_vf_sub_qt4 &quot;${FONTCONFIG_LDFLAGS}&quot;)
+        ENDIF (USE_FONTCONFIG)
+ENDIF (QT4_FOUND)
+
+ENDIF(USE_FREETYPE)
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/DIA_flySrtPos.cpp (from rev 4067, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/DIA_flySrtPos.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,56 @@
+/***************************************************************************
+                       FlyDialog for Subtitles
+    copyright            : (C) 2007 Mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &lt;math.h&gt;
+#include &quot;DIA_uiTypes.h&quot;
+#include &quot;DIA_flyDialog.h&quot;
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+class ADMfont;
+#include &quot;ADM_vidSRT.h&quot;
+#include &quot;DIA_flySrtPos.h&quot;
+/*********  COMMON PART *********/
+uint8_t    flySrtPos::process(void)
+{
+  uint32_t h;
+        // First copy Y
+        memcpy(_yuvBufferOut-&gt;data,_yuvBuffer-&gt;data,(_w*_h));
+        // then shift u
+        memcpy(UPLANE(_yuvBufferOut),UPLANE(_yuvBuffer),(_w*_h)/4);
+        memcpy(VPLANE(_yuvBufferOut),VPLANE(_yuvBuffer),(_w*_h)/4);
+        // Mark 
+        h=param.fontSize;
+        if(h&gt;8) h-=4;
+  
+        for(uint32_t line=0;line&lt;SRT_MAX_LINE;line++)
+        {
+                uint8_t *src=YPLANE(_yuvBufferOut)+(param.position+line*param.fontSize)*_w;
+  
+                for(uint32_t y=0;y&lt;h;y+=2)
+                {
+                        memset(src,255,_w);
+                        src+=2*_w;
+                }
+        }
+        return 1;
+}
+uint8_t    flySrtPos::update(void)
+{
+    download();
+    process();
+	copyYuvFinalToRgb();
+    display();
+}
+//EOF
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/DIA_flySrtPos.h (from rev 4067, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.h	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/DIA_flySrtPos.h	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,25 @@
+
+
+#ifndef FLY_SRTPOS_H
+#define FLY_SRTPOS_H
+typedef struct
+{
+    uint32_t fontSize;
+    uint32_t position;
+}SRT_POS_PARAM;
+
+class flySrtPos : public FLY_DIALOG_TYPE
+{
+  
+  public:
+   SRT_POS_PARAM  param;
+  public:
+   uint8_t    process(void);
+   uint8_t    download(void);
+   uint8_t    upload(void);
+   uint8_t    update(void);
+   flySrtPos (uint32_t width,uint32_t height,AVDMGenericVideoStream *in,
+                                    void *canvas, void *slider) : FLY_DIALOG_TYPE(width, height,in,canvas, slider,1,RESIZE_AUTO) {};
+};
+
+#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/DIA_srt.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/DIA_srt.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/DIA_srt.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,7 +1,7 @@
 //
 // C++ Implementation: ADM_vidForcedPP
 //
-// Description: 
+// Description:
 //
 //	Force postprocessing assuming constant quant &amp; image type
 //	Uselefull on some badly authored DVD for example
@@ -11,22 +11,15 @@
 // Copyright: See COPYING file that comes with this distribution
 //
 //
-#include &quot;config.h&quot;
 
-#ifdef USE_FREETYPE
 #include &quot;ADM_default.h&quot;
-#include &quot;ADM_userInterfaces/ADM_render/GUI_render.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;DIA_flyDialog.h&quot;
-
-
-
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_vidFont.h&quot;
+#include &quot;ADM_vidSRT.h&quot;
+#define ADM_MINIMAL_UI_INTERFACE
 #include &quot;DIA_factory.h&quot;
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-//#include &quot;ADM_video/ADM_vidFont.h&quot;
-class ADMfont;
-#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
-//#include &quot;ADM_colorspace/colorspace.h&quot;
+#include &quot;ADM_colorspace.h&quot;
 /*****************************************************************/
 extern int DIA_colorSel(uint8_t *r, uint8_t *g, uint8_t *b);
 extern int DIA_srtPos(AVDMGenericVideoStream *source,uint32_t *size,uint32_t *position);
@@ -45,13 +38,13 @@
 	{(char *)&quot;Czech&quot;	,(char *)&quot;ISO-8859-2&quot;},	// cz
 	{(char *)&quot;German&quot;	,(char *)&quot;ISO-8859-9&quot;}		// german ?
 	,{(char *)&quot;Slovene&quot;	,(char *)&quot;CP1250&quot;}		// UTF8
-        
+
         ,{(char *)&quot;UTF16&quot;	,(char *)&quot;UTF16&quot;}		// UTF8
 	,{(char *)&quot;UTF8&quot;	,(char *)&quot;UTF8&quot;}		// UTF8
 	,{(char *)&quot;Chinese Traditionnal(Big5)&quot;	,(char *)&quot;CP950&quot;}		// UTF8
 	,{(char *)&quot;Chinese Simplified (GB2312)&quot;	,(char *)&quot;CP936&quot;}		// UTF8
 };
-typedef struct 
+typedef struct
 {
   AVDMGenericVideoStream *source;
   uint32_t               *size;
@@ -75,18 +68,18 @@
   Mitem(5),
   Mitem(6),
   Mitem(7),
-};       
+};
 
 #define PX(x) &amp;(param-&gt;x)
   diaElemFile subtitle(0,(char **)PX(_subname),QT_TR_NOOP(&quot;_Subtitle file:&quot;), NULL, QT_TR_NOOP(&quot;Select Subtitle file&quot;));
   diaElemFile font(0,(char **)PX(_fontname),QT_TR_NOOP(&quot;_Font (TTF):&quot;), NULL, QT_TR_NOOP(&quot;Select TTF file&quot;));
   int colors[3]={param-&gt;_Y_percent,param-&gt;_U_percent,param-&gt;_V_percent};
-  
+
   uint32_t fontSize=param-&gt;_fontsize;
   uint32_t baseLine=param-&gt;_baseLine;
-  
+
   sizePosition sizePos={source,&amp;fontSize,&amp;baseLine};
-  
+
   uint32_t myEncoding=0;
       // convert internal to display
       if(param-&gt;_charset)
@@ -100,7 +93,7 @@
       diaElemButton    setBase(QT_TR_NOOP(&quot;Set Size and _Position&quot;), sizePositionCallback,&amp;sizePos);
       diaElemToggle    autoSplit(PX(_selfAdjustable),QT_TR_NOOP(&quot;_Auto split&quot;));
       diaElemInteger   delay(PX(_delay),QT_TR_NOOP(&quot;_Delay (ms):&quot;),-100000,100000);
-         
+
       diaElem *tabs[]={&amp;subtitle,&amp;font,&amp;encodingM,&amp;color,&amp;setBase,&amp;autoSplit,&amp;delay};
       if( diaFactoryRun(QT_TR_NOOP(&quot;Subtitler&quot;),7,tabs))
 	{
@@ -121,13 +114,13 @@
 */
 void colorCallBack(void *cookie)
 {
-  
+
       int32_t *colors=(int32_t *)cookie;
-        
+
         uint8_t r,g,b;
         uint8_t y;
         int8_t u,v;
-  
+
         y=colors[0];
         u=colors[1];
         v=colors[2];
@@ -153,5 +146,4 @@
     printf(&quot;Size and position invoked\n&quot;);
     DIA_srtPos(sz-&gt;source,sz-&gt;size,sz-&gt;position);
 }
-#endif
 // EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/gtk/DIA_srt.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/gtk/DIA_srt.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/gtk/DIA_srt.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -14,32 +14,21 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include &quot;config.h&quot;
-
-#ifdef USE_FREETYPE
 #include &quot;ADM_toolkitGtk.h&quot;
+#include &quot;DIA_flyDialog.h&quot;
 
 
 #include &quot;DIA_fileSel.h&quot;
 
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
 #include &quot;ADM_videoFilter.h&quot;
 
-//#include &quot;ADM_video/ADM_vidFont.h&quot;
 class ADMfont;
-#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
-
-
+#include &quot;ADM_vidSRT.h&quot;
+#include &quot;DIA_flySrtPos.h&quot;
 #include &quot;ADM_colorspace.h&quot;
 
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
 
-#include &quot;DIA_flyDialog.h&quot;
-#include &quot;DIA_flySrtPos.h&quot;
 
-
 static void read( void );
 static void upload ( void );
 static gboolean slider_update( void );
@@ -272,4 +261,3 @@
 }
 
 //-------------------------------
-#endif //FREETYPE

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/qt4/Q_srt.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/qt4/Q_srt.h	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Srt/qt4/Q_srt.h	2008-05-27 19:41:54 UTC (rev 4068)
@@ -1,15 +1,15 @@
 #ifndef Q_srt_h
 #define Q_srt_h
 
+#include &quot;DIA_flyDialog.h&quot;
 #include &quot;ui_srt.h&quot;
 #include &quot;ADM_image.h&quot;
 
 class ADMfont;
 
 #include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
+#include &quot;ADM_vidSRT.h&quot;
 #include &quot;DIA_flyDialog.h&quot;
-#include &quot;ADM_UIs/ADM_QT4/include/DIA_flyDialogQt4.h&quot;
 #include &quot;DIA_flySrtPos.h&quot;
 
 class Ui_srtWindow : public QDialog

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/ADM_vidTDeint_param.h (from rev 4067, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTDeint_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTDeint_param.h	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/ADM_vidTDeint_param.h	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,314 @@
+#ifndef ADM_VID_TDEINT_PARAM_H
+#define ADM_VID_TDEINT_PARAM_H
+typedef struct TDEINT_PARAM
+{
+    
+/*  mode:
+  
+      Sets the mode of operation.  Modes -2 and -1 require progressive input.
+
+         -2 - double height using modified ELA
+         -1 - double height using modified ELA-2
+          0 - same rate output
+          1 - double rate output (bobbing)
+
+      default -  0  (int)  &gt;&gt;&gt;&gt;&gt;&gt;&gt;FOR AVIDEMUX ONLY 0 IS SUPPORTED &lt;&lt;&lt;&lt;
+*/
+	int32_t mode; //int
+	
+/*
+      Sets the field order of the video.
+
+        -1 - use parity from AviSynth
+         0 - bottom field first (bff)
+         1 - top field first (tff)
+     
+      default -  -1  (int)
+      */
+	int32_t order; // int
+
+
+/*
+      When in mode 0, this sets the field to be interpolated (i.e. the other field is kept as 
+      is and this field will be constructed).  When in mode 1 this setting does nothing.
+
+        -1 - will set field to 1 if hints = false or 0 if hints is set to true
+         0 - interpolate top field (keep bottom field)
+         1 - interpolate bottom field (keep top field)
+  
+      default -  -1  (int)
+
+*/
+	int32_t field; //int
+/*
+   mthreshL/mthreshC:
+
+      The motion thresholds for luma and chroma (mthreshL for luma, mthreshC for chroma). If
+      the difference between two pixels is less then this value they are declared static.
+      Smaller values will reduce residual combing, larger values will decrease flicker and
+      increase the accuracy of field construction in static areas.  The spatially corresponding
+      parts of the luma and chroma planes are linked (if link != 0), so mthreshC and mthreshL 
+      may be somewhat interconnected.  Setting both values to 0 or below will disable motion 
+      adaptation (i.e. every pixel will be declared moving) allowing for a dumb bob.
+
+      default - mthreshL - 6  (int)
+                mthreshC - 6
+
+
+		*/
+	uint32_t mthreshL,mthreshC; //int
+/*
+	 map:
+
+      Displays an output map instead of the deinterlaced frame.  There are three possible
+      options.  **Note: the maps will not be displayed if the current frame is not being 
+      deinterlaced due to overrides, hints, full=false, or tryWeave=true.
+
+      **AP post-processing is currently not taken into account when using map = 1 or 2.
+
+         0 - no map
+         1 - value (binary) map.  This will output a frame in which all the pixels
+             have one of the following values (indicating how the frame is to be
+             constructed):
+                 0   (use pixel from current frame)
+                 51  (use pixel from previous frame)
+                 102 (use pixel from next frame)
+                 153 (use average of curr/next)
+                 204 (use average of curr/prev)
+                 255 (interpolate pixel)
+         2 - merged map.  This will output a frame in which all the static parts of the 
+             frame (values 0, 51, 102, 153, and 204 from map=1) have been constructed 
+             as they would appear in the deinterlaced frame, and the pixels that are to be 
+             interpolated are marked in white.
+
+      default - 0  (int)
+*/
+	uint32_t map; //int
+	/*
+	   type:
+
+      Sets the type of interpolation to use.  Cubic is the fastest, modified ELA and ELA2 will give
+      smoother, less &quot;jaggy&quot;, edges and are the slowest (ELA2 is faster), and kernel interpolation 
+      will cause significantly less flickering then cubic or ela when interpolation gets used in 
+      almost static areas.  Modified ELA/ELA2 works best with anime/cartoon type material... it is not
+      that great with real life sources (sometimes it is, test for yourself).
+
+         0 - cubic interpolation
+         1 - modified ELA interpolation
+         2 - kernel interpolation (can be normal or sharp, controlled by the sharp setting)
+         3 - modified ELA-2 interpolation
+
+      default - 2  (int)
+      */
+	uint32_t type; //
+/*
+	  debug:
+
+      Will enable debug output, which for each frame will list the values of order, field, 
+      mthreshL, mthreshC, and type if the frame is being deinterlaced.  If the frame is
+      not being deinterlaced (due to user overrides, hints, or full=false) it will simply 
+      say the frame is not being deinterlaced and list the specific reason. If the output
+      frame is weaved, then debug output will report which field the current field was
+      weaved with (PREV or NEXT).
+
+      default - false  (bool)
+      */
+	uint32_t debug; // int
+	/*
+ mtnmode:
+
+      Controls whether a 4 field motion check or a 5 field motion check is used.  5 field 
+      will prevent more artifacts and can deal with duplicate interlaced frames, however
+      it is quite a bit slower then the 4 field motion check.  Modes 2 and 3 are like 0 and
+      1 except that in areas where an average of the prev and next field would have been
+      used in mode 0 or 1, the pixel value from the most similar field (computed via field 
+      differencing) is used instead (i.e. no averages are used).
+
+         0 - 4 field check
+         1 - 5 field check
+         2 - 4 field check (no averages, replace with most similar field)
+         3 - 5 field check (no averages, replace with most similar field)
+
+      default - 1  (int)
+*/
+	uint32_t mtnmode;
+/*
+   sharp:
+
+      Controls whether the sharp or normal kernel is used when using kernel interpolation (type
+      = 2).  The sharp kernel includes more pixels and produces a sharper result, but is
+      slightly slower.
+ 
+         true - use sharp kernel
+         false - use normal kernel
+
+      default - true  (bool)
+*/
+	uint32_t sharp;
+	/*
+	  full:
+
+      If full is set to true, then all frames are processed as usual.  If full=false, all frames
+      are first checked to see if they are combed.  If a frame isn't combed then it is returned 
+      as is.  If a frame is combed then it is processed as usual.  The parameters that effect 
+      combed frame detection are cthresh, chroma, blockx, blocky, and MI.  Full=false allows 
+      TDeint to be an ivtc post-processor without the need for hints.
+
+         true - normal processing
+         false - check all input frames for combing first
+  
+      default - true  (bool)
+      */
+	uint32_t full;
+	/*
+ cthresh:
+
+      Area combing threshold used for combed frame detection.  It is like dthresh or dthreshold
+      in telecide() and fielddeinterlace().  This essentially controls how &quot;strong&quot; or &quot;visible&quot;
+      combing must be to be detected.  Good values are from 6 to 12, if you know your source has 
+      a lot of combed frames set this towards the low end (6-7), if you know your source has
+      very few combed frames set this higher (10-12).  Going much lower then 5 to 6 or much 
+      higher then 12 is not recommended.
+
+      default - 6  (int)
+*/
+	uint32_t cthresh;
+/*
+   blockx -
+
+      Sets the x-axis size of the window used during combed frame detection.  This has to do with 
+      the size of the area in which MI number of pixels are required to be detected as combed for 
+      a frame to be declared combed.  See the MI parameter description for more info.  Possible 
+      values are any number that is a power of 2 starting at 4 and going to 2048 (i.e. 4, 8, 16, 
+      32, ... 2048).
+
+      Default:  16  (int)
+*/
+	uint32_t blockx;
+/*
+   blocky -
+
+      Sets the y-axis size of the window used during combed frame detection.  This has to do with 
+      the size of the area in which MI number of pixels are required to be detected as combed for 
+      a frame to be declared combed.  See the MI parameter description for more info.  Possible 
+      values are any number that is a power of 2 starting at 4 and going to 2048 (i.e. 4, 8, 16, 
+      32, ... 2048).
+
+      Default:  16  (int)
+*/
+	uint32_t blocky;
+ /* 
+   chroma:
+
+      Includes chroma combing in the decision about whether a frame is combed.  Only use this if
+      you have one of those weird sources where the chroma can be temporally separated from the luma
+      (i.e. the chroma moves but the luma doesn't in a field).  Otherwise it will just end up 
+      screwing up the decision most of the time.
+
+         true - include chroma combing
+         false - don't
+ 
+      default - false  (bool)
+      */
+	uint32_t chroma;
+/*
+	 MI:
+
+      # of combed pixels inside any of the blockx by blocky sized blocks on the frame for the 
+      frame to be considered combed.  While cthresh controls how &quot;visible&quot; or &quot;strong&quot; the combing 
+      must be, this setting controls how much combing there must be in any localized area (a 
+      blockx by blocky sized window) on the frame.  Min setting = 0, max setting = blockx x blocky
+      (at which point no frames will ever be detected as combed).
+
+      default - 64  (int)
+*/
+	uint32_t MI;
+/*
+   tryWeave:
+
+      If set to true, when TDeint deinterlaces a frame it will first calculate which field
+      (PREV or NEXT) is most similar to the current field.  It will then weave this field
+      to create a new frame and check this new frame for combing.  If the new frame is not
+      combed, then it returns it. If it is, then it deinterlaces using the usual per-pixel
+      motion adaptation.  Basically, this setting allows TDeint to try to use per-field
+      motion adaptation instead of per-pixel motion adaptation where possible.
+
+      default - false  (bool)
+*/
+	uint32_t tryWeave;
+  /* 
+   link:
+
+      Controls how the three planes (YUV) are linked during comb map creation. Possible
+      settings:
+
+        0 - no linking
+        1 - Full linking (each plane to every other)
+        2 - Y to UV (luma to chroma)
+        3 - UV to Y (chroma to luma)
+
+      default - 2  (int)
+*/
+	uint32_t link;
+/*
+   denoise:
+
+      Controls whether the comb map is denoised or not.  True enables denoising, false disables.
+
+      default - true  (bool)
+*/
+	uint32_t denoise;
+/*
+   AP:
+
+      Artifact protection threshold.  If AP is set to a value greater than or equal to 0, then
+      before outputting a deinterlaced frame TDeint will scan all weaved pixels to see if any
+      create a value greater then AP.  Any pixels that do will be interpolated.  Use this to
+      help prevent very obvious motion adaptive related artifacts, a large value is recommended
+      (25+, or as large as removes the artifacts that can be seen during full-speed playback) as 
+      smaller values will destroy the benefits of motion adaptivity in static, detailed areas.
+      The AP metric is the same as the cthresh metric so the scale is 0-255... at zero everything
+      but completely flat areas will be detected as combing, at 255 nothing will be detected.
+      Using AP will slow down processing. Set AP to a value less then 0 or greater than
+      254 to disable.
+
+      default - -1 (disabled)  (int)
+
+*/
+	int32_t AP;
+	/*
+   APType
+
+      When AP post-processing is being used (AP is set &gt;= 0 and &lt; 255), APType controls whether
+      the motion of surrounding pixels should be taken into account.  There are 3 possible 
+      settings:
+
+        0 = Don't take surrounding motion into account.  If a weaved pixel creates a value that
+            exceeds the AP threshold then it will be interpolated.
+
+        1 = If a weaved pixel creates a value that exceeds the AP threshold and at least half of
+            pixels in a 5x5 window centered on that pixel were detected as moving, then that
+            pixel will be interpolated.
+
+        2 = Exactly like 1, except instead of 1/2 only 1/3 of the pixels in the surrounding 5x5 
+            window must have been detected as moving.
+
+      Modes 1 and 2 provide a way to catch more artifacts (low AP values) without completely 
+      sacrificing static areas.
+
+
+      default -  1  (int)
+         */
+	uint32_t APType;
+
+}TDEINT_PARAM;
+#endif
+//EOF
+
+
+
+
+
+
+
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/ADM_vidTdeint.cpp (from rev 4067, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/ADM_vidTdeint.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,836 @@
+
+/***************************************************************************
+                         
+        Tdeint
+
+    copyright            : Tritical, ported to avidemux by mean
+   <A HREF="http://bengal.missouri.edu/~kes25c/">http://bengal.missouri.edu/~kes25c/</A>
+ ***************************************************************************/
+/*
+**                TDeinterlace v1.0b4 for AviSynth 2.5.x
+**
+**   TDeinterlace is a bi-directionally motion adaptive deinterlacer.
+**   It also uses a couple modified forms of ela interpolation which 
+**   help to reduce &quot;jaggy&quot; edges in places where interpolation must 
+**   be used. TDeinterlace currently supports YV12 and YUY2 colorspaces.
+**   
+**   Copyright (C) 2004-2005 Kevin Stone
+**
+**   This program is free software; you can redistribute it and/or modify
+**   it under the terms of the GNU General Public License as published by
+**   the Free Software Foundation; either version 2 of the License, or
+**   (at your option) any later version.
+**
+**   This program is distributed in the hope that it will be useful,
+**   but WITHOUT ANY WARRANTY; without even the implied warranty of
+**   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**   GNU General Public License for more details.
+**
+**   You should have received a copy of the GNU General Public License
+**   along with this program; if not, write to the Free Software
+**   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &lt;math.h&gt;
+
+#include &quot;DIA_factory.h&quot;
+#define aprintf(...) {}
+
+#define min MIN
+#define max MAX
+
+#define MIN(a,b) a&lt;b ? a : b
+#define MAX(a,b) b&lt;a ? a : b
+#define child_GetParity(x) 0 //FIXME!!
+
+#define OutputDebugString(img,y,text) drawString(img, 0, y, text)
+
+
+#include &quot;ADM_vidTDeint_param.h&quot;
+#define PRM(x) x
+class vidTDeint:public AVDMGenericVideoStream
+{
+
+protected:
+virtual char          *printConf (void);
+VideoCache            *vidCache;
+ADMImage              *rebuild,*scratch,*scratch2;
+TDEINT_PARAM          *_param;
+/* Will go to param */
+int mode, order, field, ovrDefault, type, mtnmode;
+	int mthreshL, mthreshC, map, cthresh, MI, link;
+	int countOvr, nfrms, nfrms2, orderS, fieldS;
+	int mthreshLS, mthreshCS, typeS, cthresh6, AP;
+	int xhalf, yhalf, xshift, yshift, blockx, blocky;
+	int mntmode;
+	
+	int *input, *cArray, APType;
+	unsigned int passHint;
+	unsigned long accumN, accumP;
+	bool debug, sharp, hints, full, chroma;
+	bool autoFO, useClip2, tryWeave, denoise;
+	const char* ovr;
+	char buf[120];
+/* Will go to param */
+void  copyFrame(ADMImage *dst,ADMImage *src);
+
+unsigned char         cubicInt(unsigned char p1, unsigned char p2, unsigned char p3,unsigned char p4);
+void  copyForUpsize(ADMImage *dst, ADMImage *src, int np);
+void  setMaskForUpsize(ADMImage *msk, int np);
+void  createMotionMapYV12(ADMImage *prv2, ADMImage *prv, 
+	                       ADMImage *src, ADMImage *nxt, ADMImage *nxt2, ADMImage *mask, int n);
+void  createMotionMap2YV12(ADMImage *prv2, ADMImage *prv, 
+	                       ADMImage *src, ADMImage *nxt, ADMImage *nxt2, ADMImage *mask, int n)	;
+void  linkFULL_YV12(ADMImage *mask) ;	
+void  linkYtoUV_YV12(ADMImage *mask)  ;                                               
+void  linkUVtoY_YV12(ADMImage *mask) ;
+void  denoiseYV12(ADMImage *mask) ;
+bool  checkCombedYV12(ADMImage *src) ;
+void  subtractFieldsYV12(ADMImage *prv, ADMImage *src, ADMImage *nxt) ;
+void  mapColorsYV12(ADMImage *dst, ADMImage *mask);
+void  mapMergeYV12(ADMImage *dst, ADMImage *mask, 
+		ADMImage *prv, ADMImage *src, ADMImage *nxt);
+void  cubicDeintYV12(ADMImage *dst, ADMImage *mask, 
+		ADMImage *prv, ADMImage *src, ADMImage *nxt);
+void  ELADeintYV12(ADMImage *dst, ADMImage *mask, 
+		ADMImage *prv, ADMImage *src, ADMImage *nxt);
+void  kernelDeintYV12(ADMImage *dst, ADMImage *mask, 
+		ADMImage *prv, ADMImage *src, ADMImage *nxt);
+void  smartELADeintYV12(ADMImage *dst, ADMImage *mask, 
+		ADMImage *prv, ADMImage *src, ADMImage *nxt);
+void  createWeaveFrameYV12(ADMImage *dst, ADMImage *prv, 
+		ADMImage *src, ADMImage *nxt);
+int  getHint(ADMImage *src, unsigned int &amp;storeHint, int &amp;hintField);
+void putHint(ADMImage *src, unsigned int hint, int fieldt);
+void apPostCheck(ADMImage *dst, ADMImage *mask);
+void reset(void);
+public:
+
+                        vidTDeint (AVDMGenericVideoStream * in, CONFcouple * setup);
+        virtual         ~vidTDeint ();
+virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
+                                        ADMImage * data, uint32_t * flags);
+uint8_t configure (AVDMGenericVideoStream * instream);
+virtual uint8_t getCoupledConf (CONFcouple ** couples);
+
+};
+
+static FILTER_PARAM tdeint_template =
+  { 21,
+&quot;mode&quot;,
+&quot;order&quot;,
+&quot;field&quot;,
+&quot;mthreshL&quot;,
+&quot;mthreshC&quot;,
+&quot;map&quot;,
+&quot;type&quot;,
+&quot;debug&quot;,
+&quot;mtnmode&quot;,
+&quot;sharp&quot;,
+&quot;full&quot;,
+&quot;cthresh&quot;,
+&quot;blockx&quot;,
+&quot;blocky&quot;,
+&quot;chroma&quot;,
+&quot;MI&quot;,
+&quot;tryWeave&quot;,
+&quot;link&quot;,
+&quot;denoise&quot;,
+&quot;AP&quot;,
+&quot;APType&quot;
+
+  };
+
+//********** Register chunk ************
+
+
+
+VF_DEFINE_FILTER(vidTDeint,tdeint_template,
+    tdeint,
+                                QT_TR_NOOP(&quot;TDeint&quot;),
+                                1,
+                                VF_INTERLACING,
+                                QT_TR_NOOP(&quot;Motion adaptative deinterlacer by Tritical.&quot;));
+//************************************
+
+#include &quot;ADM_vidTdeint_util.txt&quot;
+extern uint8_t  DIA_tdeint(TDEINT_PARAM *param);
+//*************************************
+uint8_t vidTDeint::configure (AVDMGenericVideoStream * in)
+{
+uint8_t r;
+        r= DIA_tdeint(_param);
+        if(r) reset();
+        return r;
+}
+/*************************************/
+char *vidTDeint::printConf (void)
+{
+  static char buf[50];
+  sprintf ((char *) buf, &quot; Tritical TDeint&quot;);
+  return buf;
+}
+
+#define MAX_BLOCKS 50
+/*************************************/
+vidTDeint::vidTDeint (AVDMGenericVideoStream * in, CONFcouple * couples)
+{
+
+  _in = in;
+  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
+  _info.encoding = 1;
+  vidCache = new VideoCache (10, in);
+  _uncompressed=new ADMImage(_info.width,_info.height);
+  scratch=new ADMImage(_info.width,_info.height);
+  scratch2=new ADMImage(_info.width,_info.height);
+
+  	input = cArray = NULL;
+  _param=new TDEINT_PARAM;
+  if(!couples)
+  {
+  
+                _param-&gt;mode=0;
+                _param-&gt;order=-1;
+                _param-&gt;field=-1;
+                _param-&gt;mthreshL=6;
+                _param-&gt;mthreshC=6;
+                _param-&gt;map=0;
+                _param-&gt;type=2;
+                _param-&gt;debug=0;
+                _param-&gt;mtnmode=1;
+                _param-&gt;sharp=1;
+                _param-&gt;full=1;
+                _param-&gt;cthresh=6;
+                _param-&gt;blockx=16;
+                _param-&gt;blocky=16;
+                _param-&gt;chroma=0;
+                _param-&gt;MI=64;
+                _param-&gt;tryWeave=false;
+                _param-&gt;link=2;
+                _param-&gt;denoise=true;
+                _param-&gt;AP=254;
+                _param-&gt;APType=1;
+  }
+  else
+  {
+                GET(mode);
+                GET(order);
+                GET(field);
+                GET(mthreshL);
+                GET(mthreshC);
+                GET(map);
+                GET(type);
+                GET(debug);
+                GET(mtnmode);
+                GET(sharp);
+                GET(full);
+                GET(cthresh);
+                GET(blockx);
+                GET(blocky);
+                GET(chroma);
+                GET(MI);
+                GET(tryWeave);
+                GET(link);
+                GET(denoise);
+                GET(AP);
+                GET(APType);
+
+  
+  
+  }
+
+    order=1;
+    orderS=1;
+    mode=0;
+    field=0;
+    fieldS=0;
+    mthreshL=6;
+    mthreshLS=6;
+    mthreshC=6;
+    mthreshCS=6;
+    map=0;
+    ovrDefault=0;
+    type=2; // kernel deint
+    debug=true;
+    mntmode=1;
+    mtnmode=1;
+    sharp=true;
+    hints=false;
+    full=false;
+    cthresh=12;
+    ovr=NULL;
+    input=NULL;
+    blocky=16;
+    blockx=16;
+    chroma=false;
+    MI=64;
+    tryWeave=false;
+    link=2;
+    AP=254;
+    APType=254;
+    
+    reset();
+
+}
+void vidTDeint::reset (void)
+{
+
+#define CLONE(x) x=_param-&gt;x
+CLONE(mode);
+CLONE(order);
+CLONE(field);
+CLONE(mthreshL);
+CLONE(mthreshC);
+CLONE(map);
+CLONE(type);
+CLONE(debug);
+CLONE(mtnmode);
+CLONE(sharp);
+CLONE(full);
+CLONE(cthresh);
+CLONE(blockx);
+CLONE(blocky);
+CLONE(chroma);
+CLONE(MI);
+CLONE(tryWeave);
+CLONE(link);
+CLONE(denoise);
+CLONE(AP);
+CLONE(APType);
+
+orderS=order;
+fieldS=field;
+mthreshLS=  mthreshL;
+mthreshCS=mthreshC;
+
+
+         xhalf = blockx &gt;&gt; 1;
+        yhalf = blocky &gt;&gt; 1;
+        xshift = blockx == 4 ? 2 : blockx == 8 ? 3 : blockx == 16 ? 4 : blockx == 32 ? 5 :
+                blockx == 64 ? 6 : blockx == 128 ? 7 : blockx == 256 ? 8 : blockx == 512 ? 9 : 
+                blockx == 1024 ? 10 : 11;
+        yshift = blocky == 4 ? 2 : blocky == 8 ? 3 : blocky == 16 ? 4 : blocky == 32 ? 5 :
+                blocky == 64 ? 6 : blocky == 128 ? 7 : blocky == 256 ? 8 : blocky == 512 ? 9 : 
+                blocky == 1024 ? 10 : 11;
+        if (((!full &amp;&amp; mode == 0) || tryWeave) &amp;&amp; mode &gt;= 0)
+        {
+        int sz;
+        
+        sz=(((_info.width+xhalf)&gt;&gt;xshift)+1)*(((_info.height+yhalf)&gt;&gt;yshift)+1)*4;
+                if(cArray) delete [] cArray;
+                cArray = new int[sz];;
+                
+        }
+        
+        nfrms = nfrms2 = _info.nb_frames - 1;
+        accumP = accumN = 0;
+        cthresh6 = cthresh * 6;
+        passHint = 0xFFFFFFFF;
+        autoFO = false;
+        if (order == -1) autoFO = true;
+#if 0
+        if (mode &lt; 0) 
+        {
+                _info.height *= 2;
+                field = 1;
+        }
+        
+        if (mode == 1)
+        {
+                vi.num_frames *= 2;
+                nfrms2 = vi.num_frames - 1;
+                vi.SetFPS(vi.fps_numerator*2, vi.fps_denominator);
+        }
+        else
+#endif   
+        if (field == -1 &amp;&amp; mode!=1)
+        {
+                // telecide matches off the bottom field so we want field=0 in that case.
+                // tfm can match off top or bottom, but it will indicate which in its hints
+                // and field is adjusted appropriately then... so we use field=0 by default
+                // if hints=true.  Otherwise, if hints=false, we default to field = 1.
+                if (hints) field = 0;
+                else field = 1;
+        }
+        orderS = order; 
+        fieldS = field; 
+        mthreshLS = mthreshL; 
+        mthreshCS = mthreshC;
+        typeS = type;
+#if 0
+        if (debug)
+        {
+                sprintf(buf,&quot;TDeint:  %s (%s) by tritical\n&quot;, &quot;B4&quot;, &quot;08 2005&quot;);
+                OutputDebugString(buf);
+                sprintf(buf,&quot;TDeint:  mode = %d (%s)\n&quot;, mode, mode == 0 ? &quot;normal - same rate&quot; : 
+                                mode == 1 ? &quot;bob - double rate&quot; : mode == -2 ? &quot;upsize - ELA&quot; : &quot;upsize - ELA-2&quot;);
+                OutputDebugString(buf);
+        }
+#endif
+}
+//____________________________________________________________________
+vidTDeint::~vidTDeint ()
+{
+
+  delete vidCache;
+  vidCache = NULL;
+  delete _uncompressed;
+  _uncompressed=NULL;
+  delete scratch;
+  scratch=NULL;
+  delete scratch2;
+  scratch2=NULL;
+  if(cArray) delete [] cArray;
+  cArray=NULL;
+}
+
+
+
+
+
+
+uint8_t vidTDeint::getCoupledConf (CONFcouple ** couples)
+{
+
+  ADM_assert (_param);
+  *couples = new CONFcouple (21);
+#undef CSET
+#define CSET(x)  (*couples)-&gt;setCouple(#x,(_param-&gt;x))
+CSET(mode);
+CSET(order);
+CSET(field);
+CSET(mthreshL);
+CSET(mthreshC);
+CSET(map);
+CSET(type);
+CSET(debug);
+CSET(mtnmode);
+CSET(sharp);
+CSET(full);
+CSET(cthresh);
+CSET(blockx);
+CSET(blocky);
+CSET(chroma);
+CSET(MI);
+CSET(tryWeave);
+CSET(link);
+CSET(denoise);
+CSET(AP);
+CSET(APType);
+
+  return 1;
+}
+
+//***************************************************
+uint8_t vidTDeint::getFrameNumberNoAlloc (uint32_t n,
+                                uint32_t * len,
+                                ADMImage * data, uint32_t * flags)
+{
+
+	int nfrms=_info.nb_frames;
+	ADMImage *srcP,*srcN,*src,*final,*display;
+        float distMerged, distN,distP,distM,distR,skip=0;
+        char txt[255];
+
+        if(n&gt;= _info.nb_frames) return 0;
+        if(n&lt;1 || n&gt;_info.nb_frames-3 )
+        {
+                skip=1;
+        }
+        
+        
+        if(skip)
+        {
+                data-&gt;duplicate(vidCache-&gt;getImage(n));
+                vidCache-&gt;unlockAll();
+                return 1;
+        }
+      
+	if (mode &lt; 0)
+	{
+		//PVideoFrame src2up = child-&gt;GetFrame(n, env);
+		//mask2up=new ADMImage(_info.width,_info.height);
+		ADMImage *src2up;
+		src2up=vidCache-&gt;getImage(n);
+		ADMImage *msk2up=scratch;
+		if(!src2up) return 0;
+		//PVideoFrame dst2up = env-&gt;NewVideoFrame(vi);
+		//PVideoFrame msk2up = env-&gt;NewVideoFrame(vi);
+		copyForUpsize(data, src2up, 3);
+		setMaskForUpsize(msk2up, 3);
+		if (mode == -2) smartELADeintYV12(data, msk2up, data, data, data);
+		else if (mode == -1) ELADeintYV12(data, msk2up, data, data, data);
+		//return dst2up;
+		//delete mask2up;
+		vidCache-&gt;unlockAll();
+		return 1;
+	}
+	if (mode == 1)
+	{
+		if (autoFO) PRM(order) = child_GetParity(n&gt;&gt;1) ? 1 : 0;
+		if (n&amp;1) PRM(field) = PRM(order) == 1 ? 0 : 1;
+		else PRM(field) = PRM(order);
+		n &gt;&gt;= 1;
+	}
+	else if (autoFO) PRM(order) = child_GetParity(n) ? 1 : 0;
+	//PVideoFrame prv2, prv, nxt, nxt2, dst, mask;
+	//PVideoFrame src = child-&gt;GetFrame(n, env);
+	src=vidCache-&gt;getImage(n);
+	if(!src)
+	{
+        vidCache-&gt;unlockAll();
+        return 0;	
+	}
+	ADMImage *prv2,*prv,*nxt,*nxt2,*dst,*mask;
+	bool found = false, fieldOVR = false;
+	int x, hintField = -1;
+	passHint = 0xFFFFFFFF;
+	if (input != NULL &amp;&amp; *ovr)
+	{
+		if (mode != 1) 
+		{
+			PRM(field) = PRM(fieldS); 
+			if (!autoFO) PRM(order) = PRM(orderS);
+		}
+		PRM(mthreshL) = PRM(mthreshLS);
+		mthreshC = mthreshCS;
+		type = typeS;
+		for (x=0; x&lt;countOvr; x+=4)
+		{
+			if (n &gt;= input[x+1] &amp;&amp; n &lt;= input[x+2])
+			{
+				if (input[x] == 45 &amp;&amp; mode != 1) // -
+				{
+					if (debug)
+					{
+						sprintf(buf,&quot;TD fr %d:  not deinterlacing\n&quot;, n);
+						OutputDebugString(data,0,buf);
+					}
+					data-&gt;duplicate(src);
+					vidCache-&gt;unlockAll();
+					return 1;
+					//return src;
+				}
+				else if (input[x] == 43 &amp;&amp; mode != 1) found = true;  // +
+				else if (input[x] == 102 &amp;&amp; mode != 1) { field = input[x+3]; fieldOVR = true; } // f
+				else if (input[x] == 111 &amp;&amp; mode != 1) PRM(order) = input[x+3]; // o
+				else if (input[x] == 108) mthreshL = input[x+3]; // l
+				else if (input[x] == 99) mthreshC = input[x+3]; // c
+				else if (input[x] == 116) type = input[x+3]; // t
+			}
+		}
+		if (!found &amp;&amp; ovrDefault == 1 &amp;&amp; mode != 1)
+		{
+			if (debug)
+			{
+				sprintf(buf,&quot;TD fr %d:  not deinterlacing\n&quot;, n);
+				OutputDebugString(data,0,buf);
+			}
+			data-&gt;duplicate(src);
+			vidCache-&gt;unlockAll();
+			return 1;
+			//return src;
+		}
+	}
+	if (mode == 0 &amp;&amp; hints &amp;&amp; vidTDeint::getHint(src, passHint, hintField) == 0 &amp;&amp; !found) 
+	{
+		if (debug)
+		{
+			sprintf(buf,&quot;TD fr %d:  not deinterlacing (HINTS)\n&quot;, n);
+			OutputDebugString(data,0,buf);
+		}
+		data-&gt;duplicate(src);
+			vidCache-&gt;unlockAll();
+			return 1;
+			//return src;
+	}
+	if (mode == 0 &amp;&amp; !full &amp;&amp; !found)
+	{
+		if (!checkCombedYV12(src))
+		{
+			if (debug)
+			{
+				sprintf(buf,&quot;TD fr %d:  not deinterlacing (full = false)\n&quot;, n);
+				OutputDebugString(data,0,buf);
+			}
+			data-&gt;duplicate(src);
+			vidCache-&gt;unlockAll();
+			return 1;
+			//return src;
+		}
+	}
+	if (!fieldOVR &amp;&amp; hintField &gt;= 0)
+	{
+		int tempf = field;
+		field = hintField;
+		hintField = tempf;
+	}
+	//if (!useClip2)
+	{
+		prv2 = vidCache-&gt;getImage(n&gt;1 ? n-2 : n&gt;0 ? n-1 : 0);//child-&gt;GetFrame(n&gt;1 ? n-2 : n&gt;0 ? n-1 : 0, env);
+		prv = vidCache-&gt;getImage(n&gt;0 ? n-1 : 0); //child-&gt;GetFrame(n&gt;0 ? n-1 : 0, env);
+		nxt = vidCache-&gt;getImage(n&lt;nfrms ? n+1: nfrms); //child-&gt;GetFrame(n&lt;nfrms ? n+1 : nfrms, env);
+		nxt2 = vidCache-&gt;getImage(n&lt;nfrms-1 ? n+2 : n&lt;nfrms ? n+1 : nfrms); //child-&gt;GetFrame(n&lt;nfrms-1 ? n+2 : n&lt;nfrms ? n+1 : nfrms, env);
+	}
+	
+	//dst = env-&gt;NewVideoFrame(vi);
+	dst=data;
+	if (type == 2 || mtnmode &gt; 1 || tryWeave) 
+	{
+		subtractFieldsYV12(prv, src, nxt);
+		if (debug)
+		{
+			sprintf(buf, &quot;TD fr %d:  accumP = %u  &quot;, n, accumP);
+			OutputDebugString(data,2,buf);
+			sprintf(buf, &quot;accumN = %u\n&quot;, accumN);
+			OutputDebugString(data,3,buf);
+		}
+	}
+	if (tryWeave &amp;&amp; (mode != 0 || full || found || (field^PRM(order) &amp;&amp; accumP &gt; accumN) || 
+			(!(field^PRM(order)) &amp;&amp; accumN &gt; accumP)))
+	{
+		createWeaveFrameYV12(dst, prv, src, nxt);
+		if (!checkCombedYV12(dst))
+		{
+			if (debug)
+			{
+				sprintf(buf,&quot;TD  fr %d:  weaved with %s (tryWeave)\n&quot;, n, 
+					field^PRM(order) ? (accumP &lt;= accumN ? &quot;CURR&quot; : &quot;NEXT&quot;) : 
+					(accumN &lt;= accumP ? &quot;CURR&quot; : &quot;PREV&quot;));
+				OutputDebugString(data,2,buf);
+			}
+			if (hintField &gt;= 0 &amp;&amp; !fieldOVR) field = hintField;
+			vidCache-&gt;unlockAll();
+			return 1;//dst;
+		}
+	}
+	mask =scratch2 ; // env-&gt;NewVideoFrame(vi);
+	if (mthreshL &lt;= 0 &amp;&amp; mthreshC &lt;= 0) setMaskForUpsize(mask, 3);
+	else if (mtnmode == 0 || mtnmode == 2) createMotionMapYV12(prv2, prv, src, nxt, nxt2, mask, n);
+	else if (mtnmode == 1 || mtnmode == 3) createMotionMap2YV12(prv2, prv, src, nxt, nxt2, mask, n);
+	else {ADM_assert(0);}
+	if (denoise) denoiseYV12(mask);
+	if (link == 1) linkFULL_YV12(mask);
+	else if (link == 2) linkYtoUV_YV12(mask);
+	else if (link == 3) linkUVtoY_YV12(mask);
+	else if (link != 0) {ADM_assert(0);}//env-&gt;ThrowError(&quot;TDeint:  an unknown error occured (link)!&quot;);
+	if (map == 1) mapColorsYV12(dst, mask);
+	else if (map == 2) mapMergeYV12(dst, mask, prv, src, nxt);
+	else if (type == 0) cubicDeintYV12(dst, mask, prv, src, nxt);
+	else if (type == 1) smartELADeintYV12(dst, mask, prv, src, nxt);
+	else if (type == 2) kernelDeintYV12(dst, mask, prv, src, nxt);
+	else if (type == 3) ELADeintYV12(dst, mask, prv, src, nxt);
+	else {ADM_assert(0);}//env-&gt;ThrowError(&quot;TDeint:  an unknown error occured!&quot;);
+	if (AP &gt;= 0 &amp;&amp; AP &lt; 255 &amp;&amp; map == 0) apPostCheck(dst, mask);
+	if (!(passHint&amp;0xFFFFFF00)) vidTDeint::putHint(dst, passHint, field);
+	if (debug)
+	{
+		sprintf(buf,&quot;TD  fr %d:  field = %s  order = %s\n&quot;, n, 
+			field == 1 ? &quot;bottom&quot; : &quot;top&quot;, PRM(order) == 1 ? &quot;tff&quot; : &quot;bff&quot;);
+		OutputDebugString(data,3,buf);
+		sprintf(buf,&quot;TD  fr %d:  mthreshL = %d  \n&quot;,n,mthreshL);
+		OutputDebugString(data,4,buf);
+		sprintf(buf,&quot;mthreshC = %d  type = %d\n&quot;, mthreshC, type);
+		OutputDebugString(data,5,buf);
+	}
+	if (hintField &gt;= 0 &amp;&amp; !fieldOVR) field = hintField;
+	vidCache-&gt;unlockAll();
+	return 1;
+	//return dst;
+}
+
+//********************************************************************************************
+//********************************************************************************************
+//********************************************************************************************
+//********************************************************************************************
+//********************************************************************************************
+//********************************************************************************************
+
+#if 0
+AVSValue __cdecl Create_TDeinterlace(AVSValue args, void* user_data, IScriptEnvironment* env)
+{
+	int mode = 0;
+	int order = -1;
+	int field = -1;
+	int mthreshL = 6;
+	int mthreshC = 6;
+	int map = 0;
+	char* ovr = &quot;&quot;;
+	int ovrDefault = 0;
+	int type = 2;
+	bool debug = false;
+	int mtnmode = 1;
+	bool sharp = true;
+	bool hints = false;
+	bool full = true;
+	int cthresh = 6;
+	bool chroma = false;
+	int MI = 64;
+	bool tryWeave = false;
+	int link = 2;
+	bool denoise = true;
+	int AP = -1;
+	int blockx = 16, blocky = 16;
+	int APType = 1;
+	if (args[0].IsClip())
+	{
+		unsigned int temp;
+		int tfieldHint;
+		if (!args[13].IsBool() &amp;&amp;
+			TDeinterlace::getHint(args[0].AsClip()-&gt;GetFrame(0,env), temp, tfieldHint) != -1)
+			hints = true;
+	}
+	PClip v;
+	if (args[14].IsClip())
+	{
+		v = args[14].AsClip();
+		try
+		{ 
+			v = env-&gt;Invoke(&quot;InternalCache&quot;, v).AsClip();
+			v-&gt;SetCacheHints(CACHE_RANGE, 4);
+		} 
+		catch (IScriptEnvironment::NotFound) {  }
+	}
+    return new TDeinterlace(args[0].AsClip(),args[1].AsInt(mode),args[2].AsInt(order),
+		args[3].AsInt(field),args[4].AsInt(mthreshL),args[5].AsInt(mthreshC),args[6].AsInt(map),
+		args[7].AsString(ovr),args[8].AsInt(ovrDefault),args[9].AsInt(type),args[10].AsBool(debug),
+		args[11].AsInt(mtnmode),args[12].AsBool(sharp),args[13].AsBool(hints),args[14].IsClip() ? v : NULL,
+		args[15].AsBool(full),args[16].AsInt(cthresh),args[17].AsBool(chroma),args[18].AsInt(MI),
+		args[19].AsBool(tryWeave),args[20].AsInt(link),args[21].AsBool(denoise),args[22].AsInt(AP),
+		args[23].AsInt(blockx),args[24].AsInt(blocky),args[25].AsInt(APType),env);
+}
+
+extern &quot;C&quot; __declspec(dllexport) const char* __stdcall AvisynthPluginInit2(IScriptEnvironment* env) 
+{
+    env-&gt;AddFunction(&quot;TDeint&quot;, &quot;c[mode]i[order]i[field]i[mthreshL]i[mthreshC]i[map]i[ovr]s[ovrDefault]i&quot; \
+		                       &quot;[type]i[debug]b[mtnmode]i[sharp]b[hints]b[clip2]c[full]b[cthresh]i&quot; \
+							   &quot;[chroma]b[MI]i[tryWeave]b[link]i[denoise]b[AP]i[blockx]i[blocky]i[APType]i&quot;, 
+							   Create_TDeinterlace, 0);
+	return 0;
+}
+TDeinterlace::TDeinterlace(PClip _child, int _mode, int _order, int _field, int _mthreshL, 
+	int _mthreshC, int _map, const char* _ovr, int _ovrDefault, int _type, bool _debug, 
+	int _mtnmode, bool _sharp, bool _hints, PClip _clip2, bool _full, int _cthresh, 
+	bool _chroma, int _MI, bool _tryWeave, int _link, bool _denoise, int _AP, 
+	int _blockx, int _blocky, int _APType, IScriptEnvironment* env) :
+GenericVideoFilter(_child), mode(_mode), order(_order), field(_field), mthreshL(_mthreshL), 
+	mthreshC(_mthreshC), map(_map), ovr(_ovr), ovrDefault(_ovrDefault), type(_type), 
+	debug(_debug), mtnmode(_mtnmode), sharp(_sharp), hints(_hints), clip2(_clip2), full(_full),
+	cthresh(_cthresh), chroma(_chroma), MI(_MI), tryWeave(_tryWeave), link(_link), 
+	denoise(_denoise), AP(_AP), blockx(_blockx), blocky(_blocky), APType(_APType)
+{
+	int z, w, q, b, i, track, count;
+	char linein[81];
+	char *linep;
+	FILE *f = NULL;         ***** order mode field map type mntmode 
+	input = cArray = NULL;
+	if (!vi.IsYV12() &amp;&amp; !vi.IsYUY2()) 
+		env-&gt;ThrowError(&quot;TDeint:  YV12 and YUY2 data only!&quot;);
+	if (mode != 0 &amp;&amp; mode != 1 &amp;&amp; mode != -1 &amp;&amp; mode != -2)
+		env-&gt;ThrowError(&quot;TDeint:  mode must be set to -2, -1, 0, or 1!&quot;);
+	if (order != 0 &amp;&amp; order != 1 &amp;&amp; order != -1)
+		env-&gt;ThrowError(&quot;TDeint:  order must be set to 0, 1, or -1!&quot;);
+	if (field != 0 &amp;&amp; field != 1 &amp;&amp; field != -1)
+		env-&gt;ThrowError(&quot;TDeint:  field must be set to 0, 1, or -1!&quot;);
+	if (map &lt; 0 || map &gt; 2)
+		env-&gt;ThrowError(&quot;TDeint:  map option must be set to 0, 1, or 2!&quot;);
+	if (ovrDefault != 0 &amp;&amp; ovrDefault != 1)
+		env-&gt;ThrowError(&quot;TDeint:  ovrDefault must be set to either 0 or 1!&quot;);
+	if (type != 0 &amp;&amp; type != 1 &amp;&amp; type != 2 &amp;&amp; type != 3)
+		env-&gt;ThrowError(&quot;TDeint:  type must be set to either 0, 1, 2, or 3!&quot;);
+	if (mtnmode &lt; 0 || mtnmode &gt; 3)
+		env-&gt;ThrowError(&quot;TDeint:  mtnmode must be set to either 0, 1, 2, or 3!&quot;);
+	if (vi.height&amp;1 || vi.width&amp;1)
+		env-&gt;ThrowError(&quot;TDeint:  width and height must be multiples of 2!&quot;);
+	if (link &lt; 0 || link &gt; 3)
+		env-&gt;ThrowError(&quot;TDeint:  link must be set to 0, 1, 2, or 3!&quot;);
+	if (blockx != 4 &amp;&amp; blockx != 8 &amp;&amp; blockx != 16 &amp;&amp; blockx != 32 &amp;&amp; blockx != 64 &amp;&amp; 
+		blockx != 128 &amp;&amp; blockx != 256 &amp;&amp; blockx != 512 &amp;&amp; blockx != 1024 &amp;&amp; blockx != 2048)
+		env-&gt;ThrowError(&quot;TDeint:  illegal blockx size!&quot;);
+	if (blocky != 4 &amp;&amp; blocky != 8 &amp;&amp; blocky != 16 &amp;&amp; blocky != 32 &amp;&amp; blocky != 64 &amp;&amp; 
+		blocky != 128 &amp;&amp; blocky != 256 &amp;&amp; blocky != 512 &amp;&amp; blocky != 1024 &amp;&amp; blocky != 2048)
+		env-&gt;ThrowError(&quot;TDeint:  illegal blocky size!&quot;);
+	if (APType &lt; 0 || APType &gt; 2)
+		env-&gt;ThrowError(&quot;TDeint:  APType must be set to 0, 1, or 2!&quot;);
+	child-&gt;SetCacheHints(CACHE_RANGE, 4);
+	//useClip2 = false;
+	if ((hints || !full) &amp;&amp; mode == 0 &amp;&amp; clip2)
+	{
+		const VideoInfo&amp; vi1 = clip2-&gt;GetVideoInfo();
+		if (vi1.height != vi.height || vi1.width != vi.width)
+			env-&gt;ThrowError(&quot;TDeint:  width and height of clip2 must equal that of the input clip!&quot;);
+		if (!vi1.IsYV12() &amp;&amp; !vi1.IsYUY2())
+			env-&gt;ThrowError(&quot;TDeint:  YV12 and YUY2 data only (clip2)!&quot;);
+		if ((vi.IsYV12() &amp;&amp; vi1.IsYUY2()) || (vi.IsYUY2() &amp;&amp; vi1.IsYV12()))
+			env-&gt;ThrowError(&quot;TDeint:  colorspace of clip2 doesn't match that of the input clip!&quot;);
+		if (vi.num_frames != vi1.num_frames)
+			env-&gt;ThrowError(&quot;TDeint:  number of frames in clip2 doesn't match that of the input clip!&quot;);
+		useClip2 = true;
+	}
+	xhalf = blockx &gt;&gt; 1;
+	yhalf = blocky &gt;&gt; 1;
+	xshift = blockx == 4 ? 2 : blockx == 8 ? 3 : blockx == 16 ? 4 : blockx == 32 ? 5 :
+		blockx == 64 ? 6 : blockx == 128 ? 7 : blockx == 256 ? 8 : blockx == 512 ? 9 : 
+		blockx == 1024 ? 10 : 11;
+	yshift = blocky == 4 ? 2 : blocky == 8 ? 3 : blocky == 16 ? 4 : blocky == 32 ? 5 :
+		blocky == 64 ? 6 : blocky == 128 ? 7 : blocky == 256 ? 8 : blocky == 512 ? 9 : 
+		blocky == 1024 ? 10 : 11;
+	if (((!full &amp;&amp; mode == 0) || tryWeave) &amp;&amp; mode &gt;= 0)
+	{
+		cArray = (int *)_aligned_malloc((((vi.width+xhalf)&gt;&gt;xshift)+1)*(((vi.height+yhalf)&gt;&gt;yshift)+1)*4*sizeof(int), 32);
+		if (cArray == NULL) env-&gt;ThrowError(&quot;TDeint:  malloc failure!&quot;);
+	}
+	if (vi.IsYUY2())
+	{
+		xhalf *= 2;
+		++xshift;
+	}
+	vi.SetFieldBased(false);
+	nfrms = nfrms2 = vi.num_frames - 1;
+	accumP = accumN = 0;
+	cthresh6 = cthresh * 6;
+	passHint = 0xFFFFFFFF;
+	autoFO = false;
+	if (mode &lt; 0) 
+	{
+		vi.height *= 2;
+		field = 1;
+	}
+	if (order == -1) autoFO = true;
+	if (mode == 1)
+	{
+		vi.num_frames *= 2;
+		nfrms2 = vi.num_frames - 1;
+		vi.SetFPS(vi.fps_numerator*2, vi.fps_denominator);
+	}
+	else if (field == -1)
+	{
+		// telecide matches off the bottom field so we want field=0 in that case.
+		// tfm can match off top or bottom, but it will indicate which in its hints
+		// and field is adjusted appropriately then... so we use field=0 by default
+		// if hints=true.  Otherwise, if hints=false, we default to field = 1.
+		if (hints) field = 0;
+		else field = 1;
+	}
+	orderS = order; 
+	PRM(fieldS) = PRM(field); 
+	mthreshLS = mthreshL; 
+	mthreshCS = mthreshC;
+	typeS = type;
+	if (debug)
+	{
+		sprintf(buf,&quot;TDeint:  %s (%s) by tritical\n&quot;, VERSION, DATE);
+		OutputDebugString(buf);
+		sprintf(buf,&quot;TDeint:  mode = %d (%s)\n&quot;, mode, mode == 0 ? &quot;normal - same rate&quot; : 
+				mode == 1 ? &quot;bob - double rate&quot; : mode == -2 ? &quot;upsize - ELA&quot; : &quot;upsize - ELA-2&quot;);
+		OutputDebugString(buf);
+	}
+	
+noovrexit:
+	_asm emms;
+}
+#endif
+
+        //EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/ADM_vidTdeint_util.txt (from rev 4067, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint_util.txt)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidTdeint_util.txt	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/ADM_vidTdeint_util.txt	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,3144 @@
+
+
+ unsigned char vidTDeint::cubicInt(unsigned char p1, unsigned char p2, unsigned char p3, 
+	unsigned char p4)
+{
+	int temp = (int)((19*(p2+p3)-3*(p1+p4)+16)&gt;&gt;5);
+	if (temp&gt;255) temp = 255; 
+	else if (temp&lt;0) temp = 0;
+	return (unsigned char)temp;
+}
+
+void vidTDeint::createMotionMapYV12(ADMImage *prv2, ADMImage *prv, 
+	ADMImage *src, ADMImage *nxt, ADMImage *nxt2, ADMImage *mask, int n)
+{
+	const unsigned char *prv2pY = prv2-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *prv2pV = prv2-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *prv2pU = prv2-&gt;GetReadPtr(PLANAR_U);
+	int prv2_pitchY = prv2-&gt;GetPitch(PLANAR_Y);
+	int prv2_pitchUV = prv2-&gt;GetPitch(PLANAR_V);
+	prv2pY += prv2_pitchY*(2-PRM(field));
+	prv2pV += prv2_pitchUV*(2-PRM(field));
+	prv2pU += prv2_pitchUV*(2-PRM(field));
+	prv2_pitchY *= 2;
+	prv2_pitchUV *= 2;
+	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
+	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
+	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
+	prvpY += prv_pitchY*(2-PRM(field));
+	prvpV += prv_pitchUV*(2-PRM(field));
+	prvpU += prv_pitchUV*(2-PRM(field));
+	const unsigned char *prvppY = prvpY - prv_pitchY;
+	const unsigned char *prvppV = prvpV - prv_pitchUV;
+	const unsigned char *prvppU = prvpU - prv_pitchUV;
+	const unsigned char *prvpnY = prvpY + prv_pitchY;
+	const unsigned char *prvpnV = prvpV + prv_pitchUV;
+	const unsigned char *prvpnU = prvpU + prv_pitchUV;
+	prv_pitchY *= 2;
+	prv_pitchUV *= 2;
+	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
+	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
+	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
+	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
+	int HeightY = src-&gt;GetHeight(PLANAR_Y);
+	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
+	int HeightUV = src-&gt;GetHeight(PLANAR_V);
+	srcpY += src_pitchY*(2-PRM(field));
+	srcpV += src_pitchUV*(2-PRM(field));
+	srcpU += src_pitchUV*(2-PRM(field));
+	const unsigned char *srcppY = srcpY - src_pitchY;
+	const unsigned char *srcppV = srcpV - src_pitchUV;
+	const unsigned char *srcppU = srcpU - src_pitchUV;
+	const unsigned char *srcpnY = srcpY + src_pitchY;
+	const unsigned char *srcpnV = srcpV + src_pitchUV;
+	const unsigned char *srcpnU = srcpU + src_pitchUV;
+	src_pitchY *= 2;
+	src_pitchUV *= 2;
+	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
+	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
+	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
+	nxtpY += nxt_pitchY*(2-PRM(field));
+	nxtpV += nxt_pitchUV*(2-PRM(field));
+	nxtpU += nxt_pitchUV*(2-PRM(field));
+	const unsigned char *nxtppY = nxtpY - nxt_pitchY;
+	const unsigned char *nxtppV = nxtpV - nxt_pitchUV;
+	const unsigned char *nxtppU = nxtpU - nxt_pitchUV;
+	const unsigned char *nxtpnY = nxtpY + nxt_pitchY;
+	const unsigned char *nxtpnV = nxtpV + nxt_pitchUV;
+	const unsigned char *nxtpnU = nxtpU + nxt_pitchUV;
+	nxt_pitchY *= 2;
+	nxt_pitchUV *= 2;
+	const unsigned char *nxt2pY = nxt2-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *nxt2pV = nxt2-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *nxt2pU = nxt2-&gt;GetReadPtr(PLANAR_U);
+	int nxt2_pitchY = nxt2-&gt;GetPitch(PLANAR_Y);
+	int nxt2_pitchUV = nxt2-&gt;GetPitch(PLANAR_V);
+	nxt2pY += nxt2_pitchY*(2-PRM(field));
+	nxt2pV += nxt2_pitchUV*(2-PRM(field));
+	nxt2pU += nxt2_pitchUV*(2-PRM(field));
+	nxt2_pitchY *= 2;
+	nxt2_pitchUV *= 2;
+	unsigned char *maskwY = mask-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *maskwV = mask-&gt;GetWritePtr(PLANAR_V);
+	unsigned char *maskwU = mask-&gt;GetWritePtr(PLANAR_U);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	memset(maskwY,10,mask_pitchY*HeightY);
+	memset(maskwU,10,mask_pitchUV*HeightUV);
+	memset(maskwV,10,mask_pitchUV*HeightUV);
+	maskwY += mask_pitchY*(2-PRM(field));
+	maskwV += mask_pitchUV*(2-PRM(field));
+	maskwU += mask_pitchUV*(2-PRM(field));
+	mask_pitchY *= 2;
+	mask_pitchUV *= 2;
+	int x, y;
+	unsigned char val1;
+	bool t1, t2, t3, t4, t5, t6, t7;
+	if (PRM(field)^PRM(order))
+	{
+		val1 = PRM(mntmode) &gt; 1 ? (accumP &lt;= accumN ? 10 : 30) : 40;
+		if (n &lt;= 1 || n &gt;= nfrms-1)
+		{
+			for (y=1; y&lt;HeightY-1; y+=2)
+			{
+				for (x=0; x&lt;WidthY; ++x)
+				{
+					t1 = n == 0 ? false : (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
+					t2 = n == 0 ? false : (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t3 = n == nfrms ? false : (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
+					t4 = n == nfrms ? false : (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
+					t5 = n == 0 ? false : (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
+					t6 = n == nfrms ? false : (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
+					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpY[x] - nxt2pY[x]) &lt; mthreshL);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwY[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwY[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwY[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwY[x] = 30;
+					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
+					else if (abs(nxtpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(nxtpY[x]-srcpnY[x])&lt;4) maskwY[x] = 130;
+					else maskwY[x] = 60;
+				}
+				prvppY += prv_pitchY;
+				prvpY += prv_pitchY;
+				prvpnY += prv_pitchY;
+				srcppY += src_pitchY;
+				srcpY += src_pitchY;
+				srcpnY += src_pitchY;
+				nxtppY += nxt_pitchY;
+				nxtpY += nxt_pitchY;
+				nxtpnY += nxt_pitchY;
+				nxt2pY += nxt2_pitchY;
+				maskwY += mask_pitchY;
+			}
+			for (y=1; y&lt;HeightUV-1; y+=2)
+			{
+				for (x=0; x&lt;WidthUV; ++x)
+				{
+					t1 = n == 0 ? false : (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
+					t2 = n == 0 ? false : (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t3 = n == nfrms ? false : (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
+					t4 = n == nfrms ? false : (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
+					t5 = n == 0 ? false : (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
+					t6 = n == nfrms ? false : (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
+					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpV[x] - nxt2pV[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwV[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwV[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwV[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwV[x] = 30;
+					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
+					else if (abs(nxtpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(nxtpV[x]-srcpnV[x])&lt;4) maskwV[x] = 130;
+					else maskwV[x] = 60;
+					t1 = n == 0 ? false : (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
+					t2 = n == 0 ? false : (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t3 = n == nfrms ? false : (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
+					t4 = n == nfrms ? false : (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
+					t5 = n == 0 ? false : (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
+					t6 = n == nfrms ? false : (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
+					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpU[x] - nxt2pU[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwU[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwU[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwU[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwU[x] = 30;
+					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
+					else if (abs(nxtpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(nxtpU[x]-srcpnU[x])&lt;4) maskwU[x] = 130;
+					else maskwU[x] = 60;
+				}
+				prvppV += prv_pitchUV;
+				prvpV += prv_pitchUV;
+				prvpnV += prv_pitchUV;
+				prvppU += prv_pitchUV;
+				prvpU += prv_pitchUV;
+				prvpnU += prv_pitchUV;
+				srcppV += src_pitchUV;
+				srcpV += src_pitchUV;
+				srcpnV += src_pitchUV;
+				srcppU += src_pitchUV;
+				srcpU += src_pitchUV;
+				srcpnU += src_pitchUV;
+				nxtppV += nxt_pitchUV;
+				nxtpV += nxt_pitchUV;
+				nxtpnV += nxt_pitchUV;
+				nxtppU += nxt_pitchUV;
+				nxtpU += nxt_pitchUV;
+				nxtpnU += nxt_pitchUV;
+				nxt2pV += nxt2_pitchUV;
+				nxt2pU += nxt2_pitchUV;
+				maskwV += mask_pitchUV;
+				maskwU += mask_pitchUV;
+			}
+		}
+		else
+		{
+			for (y=1; y&lt;HeightY-1; y+=2)
+			{
+				for (x=0; x&lt;WidthY; ++x)
+				{
+					t1 = (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
+					t2 = (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t3 = (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
+					t4 = (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
+					t5 = (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
+					t6 = (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
+					t7 = (abs(nxtpY[x] - nxt2pY[x]) &lt; mthreshL);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwY[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwY[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwY[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwY[x] = 30;
+					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
+					else if (abs(nxtpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(nxtpY[x]-srcpnY[x])&lt;4) maskwY[x] = 130;
+					else maskwY[x] = 60;
+				}
+				prvppY += prv_pitchY;
+				prvpY += prv_pitchY;
+				prvpnY += prv_pitchY;
+				srcppY += src_pitchY;
+				srcpY += src_pitchY;
+				srcpnY += src_pitchY;
+				nxtppY += nxt_pitchY;
+				nxtpY += nxt_pitchY;
+				nxtpnY += nxt_pitchY;
+				nxt2pY += nxt2_pitchY;
+				maskwY += mask_pitchY;
+			}
+			for (y=1; y&lt;HeightUV-1; y+=2)
+			{
+				for (x=0; x&lt;WidthUV; ++x)
+				{
+					t1 = (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
+					t2 = (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t3 = (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
+					t4 = (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
+					t5 = (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
+					t6 = (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
+					t7 = (abs(nxtpV[x] - nxt2pV[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwV[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwV[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwV[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwV[x] = 30;
+					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
+					else if (abs(nxtpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(nxtpV[x]-srcpnV[x])&lt;4) maskwV[x] = 130;
+					else maskwV[x] = 60;
+					t1 = (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
+					t2 = (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t3 = (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
+					t4 = (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
+					t5 = (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
+					t6 = (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
+					t7 = (abs(nxtpU[x] - nxt2pU[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwU[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwU[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwU[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwU[x] = 30;
+					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
+					else if (abs(nxtpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(nxtpU[x]-srcpnU[x])&lt;4) maskwU[x] = 130;
+					else maskwU[x] = 60;
+				}
+				prvppV += prv_pitchUV;
+				prvpV += prv_pitchUV;
+				prvpnV += prv_pitchUV;
+				prvppU += prv_pitchUV;
+				prvpU += prv_pitchUV;
+				prvpnU += prv_pitchUV;
+				srcppV += src_pitchUV;
+				srcpV += src_pitchUV;
+				srcpnV += src_pitchUV;
+				srcppU += src_pitchUV;
+				srcpU += src_pitchUV;
+				srcpnU += src_pitchUV;
+				nxtppV += nxt_pitchUV;
+				nxtpV += nxt_pitchUV;
+				nxtpnV += nxt_pitchUV;
+				nxtppU += nxt_pitchUV;
+				nxtpU += nxt_pitchUV;
+				nxtpnU += nxt_pitchUV;
+				nxt2pV += nxt2_pitchUV;
+				nxt2pU += nxt2_pitchUV;
+				maskwV += mask_pitchUV;
+				maskwU += mask_pitchUV;
+			}
+		}
+	}
+	else
+	{
+		val1 = PRM(mntmode) &gt; 1 ? (accumP &lt; accumN ? 20 : 10) : 50;
+		if (n &lt;= 1 || n &gt;= nfrms-1)
+		{
+			for (y=1; y&lt;HeightY-1; y+=2)
+			{
+				for (x=0; x&lt;WidthY; ++x)
+				{
+					t1 = n == 0 ? false : (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
+					t2 = n == 0 ? false : (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t3 = n == nfrms ? false : (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
+					t4 = n == nfrms ? false : (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
+					t5 = n &lt;= 1 ? false : (abs(prvpY[x] - prv2pY[x]) &lt; mthreshL);
+					t6 = n == 0 ? false : (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
+					t7 = n == nfrms ? false : (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwY[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwY[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwY[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwY[x] = 10;
+					else if (abs(prvpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(prvpY[x]-srcpnY[x])&lt;4) maskwY[x] = 120;
+					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
+					else maskwY[x] = 60;
+				}
+				prv2pY += prv2_pitchY;
+				prvppY += prv_pitchY;
+				prvpY += prv_pitchY;
+				prvpnY += prv_pitchY;
+				srcppY += src_pitchY;
+				srcpY += src_pitchY;
+				srcpnY += src_pitchY;
+				nxtppY += nxt_pitchY;
+				nxtpY += nxt_pitchY;
+				nxtpnY += nxt_pitchY;
+				maskwY += mask_pitchY;
+			}
+			for (y=1; y&lt;HeightUV-1; y+=2)
+			{
+				for (x=0; x&lt;WidthUV; ++x)
+				{
+					t1 = n == 0 ? false : (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
+					t2 = n == 0 ? false : (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t3 = n == nfrms ? false : (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
+					t4 = n == nfrms ? false : (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
+					t5 = n &lt;= 1 ? false : (abs(prvpV[x] - prv2pV[x]) &lt; mthreshC);
+					t6 = n == 0 ? false : (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
+					t7 = n == nfrms ? false : (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwV[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwV[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwV[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwV[x] = 10;
+					else if (abs(prvpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(prvpV[x]-srcpnV[x])&lt;4) maskwV[x] = 120;
+					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
+					else maskwV[x] = 60;
+					t1 = n == 0 ? false : (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
+					t2 = n == 0 ? false : (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t3 = n == nfrms ? false : (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
+					t4 = n == nfrms ? false : (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
+					t5 = n &lt;= 1 ? false : (abs(prvpU[x] - prv2pU[x]) &lt; mthreshC);
+					t6 = n == 0 ? false : (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
+					t7 = n == nfrms ? false : (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwU[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwU[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwU[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwU[x] = 10;
+					else if (abs(prvpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(prvpU[x]-srcpnU[x])&lt;4) maskwU[x] = 120;
+					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
+					else maskwU[x] = 60;
+				}
+				prv2pV += prv2_pitchUV;
+				prv2pU += prv2_pitchUV;
+				prvppV += prv_pitchUV;
+				prvpV += prv_pitchUV;
+				prvpnV += prv_pitchUV;
+				prvppU += prv_pitchUV;
+				prvpU += prv_pitchUV;
+				prvpnU += prv_pitchUV;
+				srcppV += src_pitchUV;
+				srcpV += src_pitchUV;
+				srcpnV += src_pitchUV;
+				srcppU += src_pitchUV;
+				srcpU += src_pitchUV;
+				srcpnU += src_pitchUV;
+				nxtppV += nxt_pitchUV;
+				nxtpV += nxt_pitchUV;
+				nxtpnV += nxt_pitchUV;
+				nxtppU += nxt_pitchUV;
+				nxtpU += nxt_pitchUV;
+				nxtpnU += nxt_pitchUV;
+				maskwV += mask_pitchUV;
+				maskwU += mask_pitchUV;
+			}
+		}
+		else
+		{
+			for (y=1; y&lt;HeightY-1; y+=2)
+			{
+				for (x=0; x&lt;WidthY; ++x)
+				{
+					t1 = (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
+					t2 = (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t3 = (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
+					t4 = (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
+					t5 = (abs(prvpY[x] - prv2pY[x]) &lt; mthreshL);
+					t6 = (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
+					t7 = (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwY[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwY[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwY[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwY[x] = 10;
+					else if (abs(prvpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(prvpY[x]-srcpnY[x])&lt;4) maskwY[x] = 120;
+					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
+					else maskwY[x] = 60;
+				}
+				prv2pY += prv2_pitchY;
+				prvppY += prv_pitchY;
+				prvpY += prv_pitchY;
+				prvpnY += prv_pitchY;
+				srcppY += src_pitchY;
+				srcpY += src_pitchY;
+				srcpnY += src_pitchY;
+				nxtppY += nxt_pitchY;
+				nxtpY += nxt_pitchY;
+				nxtpnY += nxt_pitchY;
+				maskwY += mask_pitchY;
+			}
+			for (y=1; y&lt;HeightUV-1; y+=2)
+			{
+				for (x=0; x&lt;WidthUV; ++x)
+				{
+					t1 = (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
+					t2 = (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t3 = (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
+					t4 = (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
+					t5 = (abs(prvpV[x] - prv2pV[x]) &lt; mthreshC);
+					t6 = (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
+					t7 = (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwV[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwV[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwV[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwV[x] = 10;
+					else if (abs(prvpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(prvpV[x]-srcpnV[x])&lt;4) maskwV[x] = 120;
+					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
+					else maskwV[x] = 60;
+					t1 = (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
+					t2 = (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t3 = (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
+					t4 = (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
+					t5 = (abs(prvpU[x] - prv2pU[x]) &lt; mthreshC);
+					t6 = (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
+					t7 = (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2) || (t3 &amp;&amp; t4) || (t2 &amp;&amp; t4 &amp;&amp; (t5 || t7)) || (t1 &amp;&amp; t3 &amp;&amp; (t5 || t7))))
+						maskwU[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7) maskwU[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2) maskwU[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4) maskwU[x] = 10;
+					else if (abs(prvpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(prvpU[x]-srcpnU[x])&lt;4) maskwU[x] = 120;
+					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
+					else maskwU[x] = 60;
+				}
+				prv2pV += prv2_pitchUV;
+				prv2pU += prv2_pitchUV;
+				prvppV += prv_pitchUV;
+				prvpV += prv_pitchUV;
+				prvpnV += prv_pitchUV;
+				prvppU += prv_pitchUV;
+				prvpU += prv_pitchUV;
+				prvpnU += prv_pitchUV;
+				srcppV += src_pitchUV;
+				srcpV += src_pitchUV;
+				srcpnV += src_pitchUV;
+				srcppU += src_pitchUV;
+				srcpU += src_pitchUV;
+				srcpnU += src_pitchUV;
+				nxtppV += nxt_pitchUV;
+				nxtpV += nxt_pitchUV;
+				nxtpnV += nxt_pitchUV;
+				nxtppU += nxt_pitchUV;
+				nxtpU += nxt_pitchUV;
+				nxtpnU += nxt_pitchUV;
+				maskwV += mask_pitchUV;
+				maskwU += mask_pitchUV;
+			}
+		}
+	}
+}
+
+void vidTDeint::createMotionMap2YV12(ADMImage *prv2, ADMImage *prv, 
+	ADMImage *src, ADMImage *nxt, ADMImage *nxt2, ADMImage *mask, int n)
+{
+	const unsigned char *prv2pY = prv2-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *prv2pV = prv2-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *prv2pU = prv2-&gt;GetReadPtr(PLANAR_U);
+	int prv2_pitchY = prv2-&gt;GetPitch(PLANAR_Y);
+	int prv2_pitchUV = prv2-&gt;GetPitch(PLANAR_V);
+	prv2pY += prv2_pitchY*(2-PRM(field));
+	prv2pV += prv2_pitchUV*(2-PRM(field));
+	prv2pU += prv2_pitchUV*(2-PRM(field));
+	const unsigned char *prv2ppY = prv2pY - prv2_pitchY;
+	const unsigned char *prv2ppV = prv2pV - prv2_pitchUV;
+	const unsigned char *prv2ppU = prv2pU - prv2_pitchUV;
+	const unsigned char *prv2pnY = prv2pY + prv2_pitchY;
+	const unsigned char *prv2pnV = prv2pV + prv2_pitchUV;
+	const unsigned char *prv2pnU = prv2pU + prv2_pitchUV;
+	prv2_pitchY *= 2;
+	prv2_pitchUV *= 2;
+	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
+	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
+	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
+	prvpY += prv_pitchY*(2-PRM(field));
+	prvpV += prv_pitchUV*(2-PRM(field));
+	prvpU += prv_pitchUV*(2-PRM(field));
+	const unsigned char *prvppY = prvpY - prv_pitchY;
+	const unsigned char *prvppV = prvpV - prv_pitchUV;
+	const unsigned char *prvppU = prvpU - prv_pitchUV;
+	const unsigned char *prvpnY = prvpY + prv_pitchY;
+	const unsigned char *prvpnV = prvpV + prv_pitchUV;
+	const unsigned char *prvpnU = prvpU + prv_pitchUV;
+	prv_pitchY *= 2;
+	prv_pitchUV *= 2;
+	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
+	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
+	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
+	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
+	int HeightY = src-&gt;GetHeight(PLANAR_Y);
+	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
+	int HeightUV = src-&gt;GetHeight(PLANAR_V);
+	srcpY += src_pitchY*(2-PRM(field));
+	srcpV += src_pitchUV*(2-PRM(field));
+	srcpU += src_pitchUV*(2-PRM(field));
+	const unsigned char *srcppY = srcpY - src_pitchY;
+	const unsigned char *srcppV = srcpV - src_pitchUV;
+	const unsigned char *srcppU = srcpU - src_pitchUV;
+	const unsigned char *srcpnY = srcpY + src_pitchY;
+	const unsigned char *srcpnV = srcpV + src_pitchUV;
+	const unsigned char *srcpnU = srcpU + src_pitchUV;
+	src_pitchY *= 2;
+	src_pitchUV *= 2;
+	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
+	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
+	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
+	nxtpY += nxt_pitchY*(2-PRM(field));
+	nxtpV += nxt_pitchUV*(2-PRM(field));
+	nxtpU += nxt_pitchUV*(2-PRM(field));
+	const unsigned char *nxtppY = nxtpY - nxt_pitchY;
+	const unsigned char *nxtppV = nxtpV - nxt_pitchUV;
+	const unsigned char *nxtppU = nxtpU - nxt_pitchUV;
+	const unsigned char *nxtpnY = nxtpY + nxt_pitchY;
+	const unsigned char *nxtpnV = nxtpV + nxt_pitchUV;
+	const unsigned char *nxtpnU = nxtpU + nxt_pitchUV;
+	nxt_pitchY *= 2;
+	nxt_pitchUV *= 2;
+	const unsigned char *nxt2pY = nxt2-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *nxt2pV = nxt2-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *nxt2pU = nxt2-&gt;GetReadPtr(PLANAR_U);
+	int nxt2_pitchY = nxt2-&gt;GetPitch(PLANAR_Y);
+	int nxt2_pitchUV = nxt2-&gt;GetPitch(PLANAR_V);
+	nxt2pY += nxt2_pitchY*(2-PRM(field));
+	nxt2pV += nxt2_pitchUV*(2-PRM(field));
+	nxt2pU += nxt2_pitchUV*(2-PRM(field));
+	const unsigned char *nxt2ppY = nxt2pY - nxt2_pitchY;
+	const unsigned char *nxt2ppV = nxt2pV - nxt2_pitchUV;
+	const unsigned char *nxt2ppU = nxt2pU - nxt2_pitchUV;
+	const unsigned char *nxt2pnY = nxt2pY + nxt2_pitchY;
+	const unsigned char *nxt2pnV = nxt2pV + nxt2_pitchUV;
+	const unsigned char *nxt2pnU = nxt2pU + nxt2_pitchUV;
+	nxt2_pitchY *= 2;
+	nxt2_pitchUV *= 2;
+	unsigned char *maskwY = mask-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *maskwV = mask-&gt;GetWritePtr(PLANAR_V);
+	unsigned char *maskwU = mask-&gt;GetWritePtr(PLANAR_U);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	memset(maskwY,10,mask_pitchY*HeightY);
+	memset(maskwU,10,mask_pitchUV*HeightUV);
+	memset(maskwV,10,mask_pitchUV*HeightUV);
+	maskwY += mask_pitchY*(2-PRM(field));
+	maskwV += mask_pitchUV*(2-PRM(field));
+	maskwU += mask_pitchUV*(2-PRM(field));
+	mask_pitchY *= 2;
+	mask_pitchUV *= 2;
+	int x, y;
+	unsigned char val1;
+	bool t1, t2, t3, t4, t5, t6, t7, t8, t9, t10;
+	bool t11, t12, t13, t14, t15, t16, t17, t18, t19;
+	if (PRM(field)^PRM(order))
+	{
+		val1 = PRM(mntmode) &gt; 1 ? (accumP &lt;= accumN ? 10 : 30) : 40;
+		if (n &lt;= 1 || n &gt;= nfrms-1)
+		{
+			for (y=1; y&lt;HeightY-1; y+=2)
+			{
+				for (x=0; x&lt;WidthY; ++x)
+				{
+					t1 = n == 0 ? false : (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
+					t2 = n == 0 ? false : (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t3 = n == nfrms ? false : (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
+					t4 = n == nfrms ? false : (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
+					t5 = n == 0 ? false : (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
+					t6 = n == nfrms ? false : (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
+					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpY[x] - nxt2pY[x]) &lt; mthreshL);
+					t8 = n &lt;= 1 ? false : (abs(prvppY[x] - prv2ppY[x]) &lt; mthreshL);
+					t9 = n &lt;= 1 ? false : (abs(prvpnY[x] - prv2pnY[x]) &lt; mthreshL);
+					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppY[x] - nxt2ppY[x]) &lt; mthreshL);
+					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnY[x] - nxt2pnY[x]) &lt; mthreshL);
+					t12 = (abs(srcppY[x] - prv2ppY[x]) &lt; mthreshL);
+					t13 = (abs(srcpnY[x] - prv2pnY[x]) &lt; mthreshL);
+					t14 = (abs(nxtppY[x] - prvppY[x]) &lt; mthreshL);
+					t15 = (abs(nxtpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t16 = (abs(nxt2ppY[x] - srcppY[x]) &lt; mthreshL);
+					t17 = (abs(nxt2pnY[x] - srcpnY[x]) &lt; mthreshL);
+					t18 = (abs(nxtpY[x] - prvpY[x]) &lt; mthreshL);
+					t19 = (abs(nxt2pY[x] - srcpY[x]) &lt; mthreshL);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwY[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwY[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwY[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwY[x] = 30;
+					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
+					else if (abs(nxtpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(nxtpY[x]-srcpnY[x])&lt;4) maskwY[x] = 130;
+					else maskwY[x] = 60;
+				}
+				prv2ppY += prv2_pitchY;
+				prv2pY += prv2_pitchY;
+				prv2pnY += prv2_pitchY;
+				prvppY += prv_pitchY;
+				prvpY += prv_pitchY;
+				prvpnY += prv_pitchY;
+				srcppY += src_pitchY;
+				srcpY += src_pitchY;
+				srcpnY += src_pitchY;
+				nxtppY += nxt_pitchY;
+				nxtpY += nxt_pitchY;
+				nxtpnY += nxt_pitchY;
+				nxt2ppY += nxt2_pitchY;
+				nxt2pY += nxt2_pitchY;
+				nxt2pnY += nxt2_pitchY;
+				maskwY += mask_pitchY;
+			}
+			for (y=1; y&lt;HeightUV-1; y+=2)
+			{
+				for (x=0; x&lt;WidthUV; ++x)
+				{
+					t1 = n == 0 ? false : (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
+					t2 = n == 0 ? false : (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t3 = n == nfrms ? false : (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
+					t4 = n == nfrms ? false : (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
+					t5 = n == 0 ? false : (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
+					t6 = n == nfrms ? false : (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
+					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpV[x] - nxt2pV[x]) &lt; mthreshC);
+					t8 = n &lt;= 1 ? false : (abs(prvppV[x] - prv2ppV[x]) &lt; mthreshC);
+					t9 = n &lt;= 1 ? false : (abs(prvpnV[x] - prv2pnV[x]) &lt; mthreshC);
+					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppV[x] - nxt2ppV[x]) &lt; mthreshC);
+					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnV[x] - nxt2pnV[x]) &lt; mthreshC);
+					t12 = (abs(srcppV[x] - prv2ppV[x]) &lt; mthreshC);
+					t13 = (abs(srcpnV[x] - prv2pnV[x]) &lt; mthreshC);
+					t14 = (abs(nxtppV[x] - prvppV[x]) &lt; mthreshC);
+					t15 = (abs(nxtpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t16 = (abs(nxt2ppV[x] - srcppV[x]) &lt; mthreshC);
+					t17 = (abs(nxt2pnV[x] - srcpnV[x]) &lt; mthreshC);
+					t18 = (abs(nxtpV[x] - prvpV[x]) &lt; mthreshC);
+					t19 = (abs(nxt2pV[x] - srcpV[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwV[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwV[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwV[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwV[x] = 30;
+					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
+					else if (abs(nxtpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(nxtpV[x]-srcpnV[x])&lt;4) maskwV[x] = 130;
+					else maskwV[x] = 60;
+					t1 = n == 0 ? false : (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
+					t2 = n == 0 ? false : (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t3 = n == nfrms ? false : (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
+					t4 = n == nfrms ? false : (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
+					t5 = n == 0 ? false : (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
+					t6 = n == nfrms ? false : (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
+					t7 = n &gt;= nfrms-1 ? false : (abs(nxtpU[x] - nxt2pU[x]) &lt; mthreshC);
+					t8 = n &lt;= 1 ? false : (abs(prvppU[x] - prv2ppU[x]) &lt; mthreshC);
+					t9 = n &lt;= 1 ? false : (abs(prvpnU[x] - prv2pnU[x]) &lt; mthreshC);
+					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppU[x] - nxt2ppU[x]) &lt; mthreshC);
+					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnU[x] - nxt2pnU[x]) &lt; mthreshC);
+					t12 = (abs(srcppU[x] - prv2ppU[x]) &lt; mthreshC);
+					t13 = (abs(srcpnU[x] - prv2pnU[x]) &lt; mthreshC);
+					t14 = (abs(nxtppU[x] - prvppU[x]) &lt; mthreshC);
+					t15 = (abs(nxtpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t16 = (abs(nxt2ppU[x] - srcppU[x]) &lt; mthreshC);
+					t17 = (abs(nxt2pnU[x] - srcpnU[x]) &lt; mthreshC);
+					t18 = (abs(nxtpU[x] - prvpU[x]) &lt; mthreshC);
+					t19 = (abs(nxt2pU[x] - srcpU[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwU[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwU[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwU[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwU[x] = 30;
+					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
+					else if (abs(nxtpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(nxtpU[x]-srcpnU[x])&lt;4) maskwU[x] = 130;
+					else maskwU[x] = 60;
+				}
+				prv2ppV += prv2_pitchUV;
+				prv2pV += prv2_pitchUV;
+				prv2pnV += prv2_pitchUV;
+				prv2ppU += prv2_pitchUV;
+				prv2pU += prv2_pitchUV;
+				prv2pnU += prv2_pitchUV;
+				prvppV += prv_pitchUV;
+				prvpV += prv_pitchUV;
+				prvpnV += prv_pitchUV;
+				prvppU += prv_pitchUV;
+				prvpU += prv_pitchUV;
+				prvpnU += prv_pitchUV;
+				srcppV += src_pitchUV;
+				srcpV += src_pitchUV;
+				srcpnV += src_pitchUV;
+				srcppU += src_pitchUV;
+				srcpU += src_pitchUV;
+				srcpnU += src_pitchUV;
+				nxtppV += nxt_pitchUV;
+				nxtpV += nxt_pitchUV;
+				nxtpnV += nxt_pitchUV;
+				nxtppU += nxt_pitchUV;
+				nxtpU += nxt_pitchUV;
+				nxtpnU += nxt_pitchUV;
+				nxt2ppV += nxt2_pitchUV;
+				nxt2pV += nxt2_pitchUV;
+				nxt2pnV += nxt2_pitchUV;
+				nxt2ppU += nxt2_pitchUV;
+				nxt2pU += nxt2_pitchUV;
+				nxt2pnU += nxt2_pitchUV;
+				maskwV += mask_pitchUV;
+				maskwU += mask_pitchUV;
+			}
+		}
+		else
+		{
+			for (y=1; y&lt;HeightY-1; y+=2)
+			{
+				for (x=0; x&lt;WidthY; ++x)
+				{
+					t1 = (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
+					t2 = (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t3 = (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
+					t4 = (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
+					t5 = (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
+					t6 = (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
+					t7 = (abs(nxtpY[x] - nxt2pY[x]) &lt; mthreshL);
+					t8 = (abs(prvppY[x] - prv2ppY[x]) &lt; mthreshL);
+					t9 = (abs(prvpnY[x] - prv2pnY[x]) &lt; mthreshL);
+					t10 = (abs(nxtppY[x] - nxt2ppY[x]) &lt; mthreshL);
+					t11 = (abs(nxtpnY[x] - nxt2pnY[x]) &lt; mthreshL);
+					t12 = (abs(srcppY[x] - prv2ppY[x]) &lt; mthreshL);
+					t13 = (abs(srcpnY[x] - prv2pnY[x]) &lt; mthreshL);
+					t14 = (abs(nxtppY[x] - prvppY[x]) &lt; mthreshL);
+					t15 = (abs(nxtpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t16 = (abs(nxt2ppY[x] - srcppY[x]) &lt; mthreshL);
+					t17 = (abs(nxt2pnY[x] - srcpnY[x]) &lt; mthreshL);
+					t18 = (abs(nxtpY[x] - prvpY[x]) &lt; mthreshL);
+					t19 = (abs(nxt2pY[x] - srcpY[x]) &lt; mthreshL);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwY[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwY[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwY[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwY[x] = 30;
+					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
+					else if (abs(nxtpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(nxtpY[x]-srcpnY[x])&lt;4) maskwY[x] = 130;
+					else maskwY[x] = 60;
+				}
+				prv2ppY += prv2_pitchY;
+				prv2pY += prv2_pitchY;
+				prv2pnY += prv2_pitchY;
+				prvppY += prv_pitchY;
+				prvpY += prv_pitchY;
+				prvpnY += prv_pitchY;
+				srcppY += src_pitchY;
+				srcpY += src_pitchY;
+				srcpnY += src_pitchY;
+				nxtppY += nxt_pitchY;
+				nxtpY += nxt_pitchY;
+				nxtpnY += nxt_pitchY;
+				nxt2ppY += nxt2_pitchY;
+				nxt2pY += nxt2_pitchY;
+				nxt2pnY += nxt2_pitchY;
+				maskwY += mask_pitchY;
+			}
+			for (y=1; y&lt;HeightUV-1; y+=2)
+			{
+				for (x=0; x&lt;WidthUV; ++x)
+				{
+					t1 = (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
+					t2 = (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t3 = (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
+					t4 = (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
+					t5 = (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
+					t6 = (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
+					t7 = (abs(nxtpV[x] - nxt2pV[x]) &lt; mthreshC);
+					t8 = (abs(prvppV[x] - prv2ppV[x]) &lt; mthreshC);
+					t9 = (abs(prvpnV[x] - prv2pnV[x]) &lt; mthreshC);
+					t10 = (abs(nxtppV[x] - nxt2ppV[x]) &lt; mthreshC);
+					t11 = (abs(nxtpnV[x] - nxt2pnV[x]) &lt; mthreshC);
+					t12 = (abs(srcppV[x] - prv2ppV[x]) &lt; mthreshC);
+					t13 = (abs(srcpnV[x] - prv2pnV[x]) &lt; mthreshC);
+					t14 = (abs(nxtppV[x] - prvppV[x]) &lt; mthreshC);
+					t15 = (abs(nxtpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t16 = (abs(nxt2ppV[x] - srcppV[x]) &lt; mthreshC);
+					t17 = (abs(nxt2pnV[x] - srcpnV[x]) &lt; mthreshC);
+					t18 = (abs(nxtpV[x] - prvpV[x]) &lt; mthreshC);
+					t19 = (abs(nxt2pV[x] - srcpV[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwV[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwV[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwV[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwV[x] = 30;
+					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
+					else if (abs(nxtpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(nxtpV[x]-srcpnV[x])&lt;4) maskwV[x] = 130;
+					else maskwV[x] = 60;
+					t1 = (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
+					t2 = (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t3 = (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
+					t4 = (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
+					t5 = (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
+					t6 = (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
+					t7 = (abs(nxtpU[x] - nxt2pU[x]) &lt; mthreshC);
+					t8 = (abs(prvppU[x] - prv2ppU[x]) &lt; mthreshC);
+					t9 = (abs(prvpnU[x] - prv2pnU[x]) &lt; mthreshC);
+					t10 = (abs(nxtppU[x] - nxt2ppU[x]) &lt; mthreshC);
+					t11 = (abs(nxtpnU[x] - nxt2pnU[x]) &lt; mthreshC);
+					t12 = (abs(srcppU[x] - prv2ppU[x]) &lt; mthreshC);
+					t13 = (abs(srcpnU[x] - prv2pnU[x]) &lt; mthreshC);
+					t14 = (abs(nxtppU[x] - prvppU[x]) &lt; mthreshC);
+					t15 = (abs(nxtpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t16 = (abs(nxt2ppU[x] - srcppU[x]) &lt; mthreshC);
+					t17 = (abs(nxt2pnU[x] - srcpnU[x]) &lt; mthreshC);
+					t18 = (abs(nxtpU[x] - prvpU[x]) &lt; mthreshC);
+					t19 = (abs(nxt2pU[x] - srcpU[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwU[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwU[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwU[x] = 10;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwU[x] = 30;
+					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
+					else if (abs(nxtpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(nxtpU[x]-srcpnU[x])&lt;4) maskwU[x] = 130;
+					else maskwU[x] = 60;
+				}
+				prv2ppV += prv2_pitchUV;
+				prv2pV += prv2_pitchUV;
+				prv2pnV += prv2_pitchUV;
+				prv2ppU += prv2_pitchUV;
+				prv2pU += prv2_pitchUV;
+				prv2pnU += prv2_pitchUV;
+				prvppV += prv_pitchUV;
+				prvpV += prv_pitchUV;
+				prvpnV += prv_pitchUV;
+				prvppU += prv_pitchUV;
+				prvpU += prv_pitchUV;
+				prvpnU += prv_pitchUV;
+				srcppV += src_pitchUV;
+				srcpV += src_pitchUV;
+				srcpnV += src_pitchUV;
+				srcppU += src_pitchUV;
+				srcpU += src_pitchUV;
+				srcpnU += src_pitchUV;
+				nxtppV += nxt_pitchUV;
+				nxtpV += nxt_pitchUV;
+				nxtpnV += nxt_pitchUV;
+				nxtppU += nxt_pitchUV;
+				nxtpU += nxt_pitchUV;
+				nxtpnU += nxt_pitchUV;
+				nxt2ppV += nxt2_pitchUV;
+				nxt2pV += nxt2_pitchUV;
+				nxt2pnV += nxt2_pitchUV;
+				nxt2ppU += nxt2_pitchUV;
+				nxt2pU += nxt2_pitchUV;
+				nxt2pnU += nxt2_pitchUV;
+				maskwV += mask_pitchUV;
+				maskwU += mask_pitchUV;
+			}
+		}
+	}
+	else
+	{
+		val1 = PRM(mntmode) &gt; 1 ? (accumP &lt; accumN ? 20 : 10) : 50;
+		if (n &lt;= 1 || n &gt;= nfrms-1)
+		{
+			for (y=1; y&lt;HeightY-1; y+=2)
+			{
+				for (x=0; x&lt;WidthY; ++x)
+				{
+					t1 = n == 0 ? false : (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
+					t2 = n == 0 ? false : (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t3 = n == nfrms ? false : (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
+					t4 = n == nfrms ? false : (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
+					t5 = n &lt;= 1 ? false : (abs(prvpY[x] - prv2pY[x]) &lt; mthreshL);
+					t6 = n == 0 ? false : (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
+					t7 = n == nfrms ? false : (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
+					t8 = n &lt;= 1 ? false : (abs(prvppY[x] - prv2ppY[x]) &lt; mthreshL);
+					t9 = n &lt;= 1 ? false : (abs(prvpnY[x] - prv2pnY[x]) &lt; mthreshL);
+					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppY[x] - nxt2ppY[x]) &lt; mthreshL);
+					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnY[x] - nxt2pnY[x]) &lt; mthreshL);
+					t12 = (abs(srcppY[x] - prv2ppY[x]) &lt; mthreshL);
+					t13 = (abs(srcpnY[x] - prv2pnY[x]) &lt; mthreshL);
+					t14 = (abs(nxtppY[x] - prvppY[x]) &lt; mthreshL);
+					t15 = (abs(nxtpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t16 = (abs(nxt2ppY[x] - srcppY[x]) &lt; mthreshL);
+					t17 = (abs(nxt2pnY[x] - srcpnY[x]) &lt; mthreshL);
+					t18 = (abs(srcpY[x] - prv2pY[x]) &lt; mthreshL);
+					t19 = (abs(nxtpY[x] - prvpY[x]) &lt; mthreshL);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwY[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwY[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwY[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwY[x] = 10;
+					else if (abs(prvpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(prvpY[x]-srcpnY[x])&lt;4) maskwY[x] = 120;
+					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
+					else maskwY[x] = 60;
+				}
+				prv2ppY += prv2_pitchY;
+				prv2pY += prv2_pitchY;
+				prv2pnY += prv2_pitchY;
+				prvppY += prv_pitchY;
+				prvpY += prv_pitchY;
+				prvpnY += prv_pitchY;
+				srcppY += src_pitchY;
+				srcpY += src_pitchY;
+				srcpnY += src_pitchY;
+				nxtppY += nxt_pitchY;
+				nxtpY += nxt_pitchY;
+				nxtpnY += nxt_pitchY;
+				nxt2ppY += nxt2_pitchY;
+				nxt2pY += nxt2_pitchY;
+				nxt2pnY += nxt2_pitchY;
+				maskwY += mask_pitchY;
+			}
+			for (y=1; y&lt;HeightUV-1; y+=2)
+			{
+				for (x=0; x&lt;WidthUV; ++x)
+				{
+					t1 = n == 0 ? false : (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
+					t2 = n == 0 ? false : (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t3 = n == nfrms ? false : (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
+					t4 = n == nfrms ? false : (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
+					t5 = n &lt;= 1 ? false : (abs(prvpV[x] - prv2pV[x]) &lt; mthreshC);
+					t6 = n == 0 ? false : (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
+					t7 = n == nfrms ? false : (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
+					t8 = n &lt;= 1 ? false : (abs(prvppV[x] - prv2ppV[x]) &lt; mthreshC);
+					t9 = n &lt;= 1 ? false : (abs(prvpnV[x] - prv2pnV[x]) &lt; mthreshC);
+					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppV[x] - nxt2ppV[x]) &lt; mthreshC);
+					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnV[x] - nxt2pnV[x]) &lt; mthreshC);
+					t12 = (abs(srcppV[x] - prv2ppV[x]) &lt; mthreshC);
+					t13 = (abs(srcpnV[x] - prv2pnV[x]) &lt; mthreshC);
+					t14 = (abs(nxtppV[x] - prvppV[x]) &lt; mthreshC);
+					t15 = (abs(nxtpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t16 = (abs(nxt2ppV[x] - srcppV[x]) &lt; mthreshC);
+					t17 = (abs(nxt2pnV[x] - srcpnV[x]) &lt; mthreshC);
+					t18 = (abs(srcpV[x] - prv2pV[x]) &lt; mthreshC);
+					t19 = (abs(nxtpV[x] - prvpV[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwV[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwV[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwV[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwV[x] = 10;
+					else if (abs(prvpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(prvpV[x]-srcpnV[x])&lt;4) maskwV[x] = 120;
+					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
+					else maskwV[x] = 60;
+					t1 = n == 0 ? false : (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
+					t2 = n == 0 ? false : (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t3 = n == nfrms ? false : (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
+					t4 = n == nfrms ? false : (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
+					t5 = n &lt;= 1 ? false : (abs(prvpU[x] - prv2pU[x]) &lt; mthreshC);
+					t6 = n == 0 ? false : (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
+					t7 = n == nfrms ? false : (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
+					t8 = n &lt;= 1 ? false : (abs(prvppU[x] - prv2ppU[x]) &lt; mthreshC);
+					t9 = n &lt;= 1 ? false : (abs(prvpnU[x] - prv2pnU[x]) &lt; mthreshC);
+					t10 = n &gt;= nfrms-1 ? false : (abs(nxtppU[x] - nxt2ppU[x]) &lt; mthreshC);
+					t11 = n &gt;= nfrms-1 ? false : (abs(nxtpnU[x] - nxt2pnU[x]) &lt; mthreshC);
+					t12 = (abs(srcppU[x] - prv2ppU[x]) &lt; mthreshC);
+					t13 = (abs(srcpnU[x] - prv2pnU[x]) &lt; mthreshC);
+					t14 = (abs(nxtppU[x] - prvppU[x]) &lt; mthreshC);
+					t15 = (abs(nxtpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t16 = (abs(nxt2ppU[x] - srcppU[x]) &lt; mthreshC);
+					t17 = (abs(nxt2pnU[x] - srcpnU[x]) &lt; mthreshC);
+					t18 = (abs(srcpU[x] - prv2pU[x]) &lt; mthreshC);
+					t19 = (abs(nxtpU[x] - prvpU[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwU[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwU[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwU[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwU[x] = 10;
+					else if (abs(prvpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(prvpU[x]-srcpnU[x])&lt;4) maskwU[x] = 120;
+					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
+					else maskwU[x] = 60;
+				}
+				prv2ppV += prv2_pitchUV;
+				prv2pV += prv2_pitchUV;
+				prv2pnV += prv2_pitchUV;
+				prv2ppU += prv2_pitchUV;
+				prv2pU += prv2_pitchUV;
+				prv2pnU += prv2_pitchUV;
+				prvppV += prv_pitchUV;
+				prvpV += prv_pitchUV;
+				prvpnV += prv_pitchUV;
+				prvppU += prv_pitchUV;
+				prvpU += prv_pitchUV;
+				prvpnU += prv_pitchUV;
+				srcppV += src_pitchUV;
+				srcpV += src_pitchUV;
+				srcpnV += src_pitchUV;
+				srcppU += src_pitchUV;
+				srcpU += src_pitchUV;
+				srcpnU += src_pitchUV;
+				nxtppV += nxt_pitchUV;
+				nxtpV += nxt_pitchUV;
+				nxtpnV += nxt_pitchUV;
+				nxtppU += nxt_pitchUV;
+				nxtpU += nxt_pitchUV;
+				nxtpnU += nxt_pitchUV;
+				nxt2ppV += nxt2_pitchUV;
+				nxt2pV += nxt2_pitchUV;
+				nxt2pnV += nxt2_pitchUV;
+				nxt2ppU += nxt2_pitchUV;
+				nxt2pU += nxt2_pitchUV;
+				nxt2pnU += nxt2_pitchUV;
+				maskwV += mask_pitchUV;
+				maskwU += mask_pitchUV;
+			}
+		}
+		else
+		{
+			for (y=1; y&lt;HeightY-1; y+=2)
+			{
+				for (x=0; x&lt;WidthY; ++x)
+				{
+					t1 = (abs(srcppY[x] - prvppY[x]) &lt; mthreshL);
+					t2 = (abs(srcpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t3 = (abs(srcppY[x] - nxtppY[x]) &lt; mthreshL);
+					t4 = (abs(srcpnY[x] - nxtpnY[x]) &lt; mthreshL);
+					t5 = (abs(prvpY[x] - prv2pY[x]) &lt; mthreshL);
+					t6 = (abs(srcpY[x] - prvpY[x]) &lt; mthreshL);
+					t7 = (abs(srcpY[x] - nxtpY[x]) &lt; mthreshL);
+					t8 = (abs(prvppY[x] - prv2ppY[x]) &lt; mthreshL);
+					t9 = (abs(prvpnY[x] - prv2pnY[x]) &lt; mthreshL);
+					t10 = (abs(nxtppY[x] - nxt2ppY[x]) &lt; mthreshL);
+					t11 = (abs(nxtpnY[x] - nxt2pnY[x]) &lt; mthreshL);
+					t12 = (abs(srcppY[x] - prv2ppY[x]) &lt; mthreshL);
+					t13 = (abs(srcpnY[x] - prv2pnY[x]) &lt; mthreshL);
+					t14 = (abs(nxtppY[x] - prvppY[x]) &lt; mthreshL);
+					t15 = (abs(nxtpnY[x] - prvpnY[x]) &lt; mthreshL);
+					t16 = (abs(nxt2ppY[x] - srcppY[x]) &lt; mthreshL);
+					t17 = (abs(nxt2pnY[x] - srcpnY[x]) &lt; mthreshL);
+					t18 = (abs(srcpY[x] - prv2pY[x]) &lt; mthreshL);
+					t19 = (abs(nxtpY[x] - prvpY[x]) &lt; mthreshL);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwY[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwY[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwY[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwY[x] = 10;
+					else if (abs(prvpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(prvpY[x]-srcpnY[x])&lt;4) maskwY[x] = 120;
+					else if (abs(srcpY[x]-srcppY[x])&lt;4 &amp;&amp; abs(srcpY[x]-srcpnY[x])&lt;4) maskwY[x] = 110;
+					else maskwY[x] = 60;
+				}
+				prv2ppY += prv2_pitchY;
+				prv2pY += prv2_pitchY;
+				prv2pnY += prv2_pitchY;
+				prvppY += prv_pitchY;
+				prvpY += prv_pitchY;
+				prvpnY += prv_pitchY;
+				srcppY += src_pitchY;
+				srcpY += src_pitchY;
+				srcpnY += src_pitchY;
+				nxtppY += nxt_pitchY;
+				nxtpY += nxt_pitchY;
+				nxtpnY += nxt_pitchY;
+				nxt2ppY += nxt2_pitchY;
+				nxt2pY += nxt2_pitchY;
+				nxt2pnY += nxt2_pitchY;
+				maskwY += mask_pitchY;
+			}
+			for (y=1; y&lt;HeightUV-1; y+=2)
+			{
+				for (x=0; x&lt;WidthUV; ++x)
+				{
+					t1 = (abs(srcppV[x] - prvppV[x]) &lt; mthreshC);
+					t2 = (abs(srcpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t3 = (abs(srcppV[x] - nxtppV[x]) &lt; mthreshC);
+					t4 = (abs(srcpnV[x] - nxtpnV[x]) &lt; mthreshC);
+					t5 = (abs(prvpV[x] - prv2pV[x]) &lt; mthreshC);
+					t6 = (abs(srcpV[x] - prvpV[x]) &lt; mthreshC);
+					t7 = (abs(srcpV[x] - nxtpV[x]) &lt; mthreshC);
+					t8 = (abs(prvppV[x] - prv2ppV[x]) &lt; mthreshC);
+					t9 = (abs(prvpnV[x] - prv2pnV[x]) &lt; mthreshC);
+					t10 = (abs(nxtppV[x] - nxt2ppV[x]) &lt; mthreshC);
+					t11 = (abs(nxtpnV[x] - nxt2pnV[x]) &lt; mthreshC);
+					t12 = (abs(srcppV[x] - prv2ppV[x]) &lt; mthreshC);
+					t13 = (abs(srcpnV[x] - prv2pnV[x]) &lt; mthreshC);
+					t14 = (abs(nxtppV[x] - prvppV[x]) &lt; mthreshC);
+					t15 = (abs(nxtpnV[x] - prvpnV[x]) &lt; mthreshC);
+					t16 = (abs(nxt2ppV[x] - srcppV[x]) &lt; mthreshC);
+					t17 = (abs(nxt2pnV[x] - srcpnV[x]) &lt; mthreshC);
+					t18 = (abs(srcpV[x] - prv2pV[x]) &lt; mthreshC);
+					t19 = (abs(nxtpV[x] - prvpV[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwV[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwV[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwV[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwV[x] = 10;
+					else if (abs(prvpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(prvpV[x]-srcpnV[x])&lt;4) maskwV[x] = 120;
+					else if (abs(srcpV[x]-srcppV[x])&lt;4 &amp;&amp; abs(srcpV[x]-srcpnV[x])&lt;4) maskwV[x] = 110;
+					else maskwV[x] = 60;
+					t1 = (abs(srcppU[x] - prvppU[x]) &lt; mthreshC);
+					t2 = (abs(srcpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t3 = (abs(srcppU[x] - nxtppU[x]) &lt; mthreshC);
+					t4 = (abs(srcpnU[x] - nxtpnU[x]) &lt; mthreshC);
+					t5 = (abs(prvpU[x] - prv2pU[x]) &lt; mthreshC);
+					t6 = (abs(srcpU[x] - prvpU[x]) &lt; mthreshC);
+					t7 = (abs(srcpU[x] - nxtpU[x]) &lt; mthreshC);
+					t8 = (abs(prvppU[x] - prv2ppU[x]) &lt; mthreshC);
+					t9 = (abs(prvpnU[x] - prv2pnU[x]) &lt; mthreshC);
+					t10 = (abs(nxtppU[x] - nxt2ppU[x]) &lt; mthreshC);
+					t11 = (abs(nxtpnU[x] - nxt2pnU[x]) &lt; mthreshC);
+					t12 = (abs(srcppU[x] - prv2ppU[x]) &lt; mthreshC);
+					t13 = (abs(srcpnU[x] - prv2pnU[x]) &lt; mthreshC);
+					t14 = (abs(nxtppU[x] - prvppU[x]) &lt; mthreshC);
+					t15 = (abs(nxtpnU[x] - prvpnU[x]) &lt; mthreshC);
+					t16 = (abs(nxt2ppU[x] - srcppU[x]) &lt; mthreshC);
+					t17 = (abs(nxt2pnU[x] - srcpnU[x]) &lt; mthreshC);
+					t18 = (abs(srcpU[x] - prv2pU[x]) &lt; mthreshC);
+					t19 = (abs(nxtpU[x] - prvpU[x]) &lt; mthreshC);
+					if (t6 &amp;&amp; ((t1 &amp;&amp; t2 &amp;&amp; ((t3 &amp;&amp; t4 &amp;&amp; t14 &amp;&amp; t15) || (t5 &amp;&amp; t18))) || 
+							(t3 &amp;&amp; t4 &amp;&amp; t7 &amp;&amp; t19) || 
+							(t5 &amp;&amp; t18 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t1 &amp;&amp; t8 &amp;&amp; t12) || (t2 &amp;&amp; t9 &amp;&amp; t13))) ||
+							(t7 &amp;&amp; t19 &amp;&amp; ((t1 &amp;&amp; t3 &amp;&amp; t14) || (t2 &amp;&amp; t4 &amp;&amp; t15) || (t3 &amp;&amp; t10 &amp;&amp; t16) || (t4 &amp;&amp; t11 &amp;&amp; t17)))))
+						maskwU[x] = val1;
+					else if (t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t7 &amp;&amp; t14 &amp;&amp; t15) maskwU[x] = val1;
+					else if (t1 &amp;&amp; t5 &amp;&amp; t2 &amp;&amp; t8 &amp;&amp; t9 &amp;&amp; t12 &amp;&amp; t13) maskwU[x] = 20;
+					else if (t3 &amp;&amp; t7 &amp;&amp; t4 &amp;&amp; t10 &amp;&amp; t11 &amp;&amp; t16 &amp;&amp; t17) maskwU[x] = 10;
+					else if (abs(prvpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(prvpU[x]-srcpnU[x])&lt;4) maskwU[x] = 120;
+					else if (abs(srcpU[x]-srcppU[x])&lt;4 &amp;&amp; abs(srcpU[x]-srcpnU[x])&lt;4) maskwU[x] = 110;
+					else maskwU[x] = 60;
+				}
+				prv2ppV += prv2_pitchUV;
+				prv2pV += prv2_pitchUV;
+				prv2pnV += prv2_pitchUV;
+				prv2ppU += prv2_pitchUV;
+				prv2pU += prv2_pitchUV;
+				prv2pnU += prv2_pitchUV;
+				prvppV += prv_pitchUV;
+				prvpV += prv_pitchUV;
+				prvpnV += prv_pitchUV;
+				prvppU += prv_pitchUV;
+				prvpU += prv_pitchUV;
+				prvpnU += prv_pitchUV;
+				srcppV += src_pitchUV;
+				srcpV += src_pitchUV;
+				srcpnV += src_pitchUV;
+				srcppU += src_pitchUV;
+				srcpU += src_pitchUV;
+				srcpnU += src_pitchUV;
+				nxtppV += nxt_pitchUV;
+				nxtpV += nxt_pitchUV;
+				nxtpnV += nxt_pitchUV;
+				nxtppU += nxt_pitchUV;
+				nxtpU += nxt_pitchUV;
+				nxtpnU += nxt_pitchUV;
+				nxt2ppV += nxt2_pitchUV;
+				nxt2pV += nxt2_pitchUV;
+				nxt2pnV += nxt2_pitchUV;
+				nxt2ppU += nxt2_pitchUV;
+				nxt2pU += nxt2_pitchUV;
+				nxt2pnU += nxt2_pitchUV;
+				maskwV += mask_pitchUV;
+				maskwU += mask_pitchUV;
+			}
+		}
+	}
+}
+
+void vidTDeint::linkFULL_YV12(ADMImage *mask) 
+{
+	unsigned char *maskpY = mask-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *maskpV = mask-&gt;GetWritePtr(PLANAR_V);
+	unsigned char *maskpU = mask-&gt;GetWritePtr(PLANAR_U);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchY2 = mask_pitchY&lt;&lt;1;
+	int mask_pitchY4 = mask_pitchY&lt;&lt;2;
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	int mask_pitchUV2 = mask_pitchUV&lt;&lt;1;
+	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
+	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
+	maskpY += mask_pitchY*PRM(field);
+	maskpV += mask_pitchUV*PRM(field);
+	maskpU += mask_pitchUV*PRM(field);
+	unsigned char *maskpnY = maskpY + mask_pitchY2;
+	int x, y;
+	for (y=PRM(field); y&lt;HeightUV; y+=2)
+	{
+		for (x=0; x&lt;WidthUV; ++x)
+		{
+			if (((((unsigned short*)maskpY)[x] == (unsigned short)0x3C3C) &amp;&amp; 
+				 (((unsigned short*)maskpnY)[x] == (unsigned short)0x3C3C)) ||
+				maskpV[x] == 0x3C || maskpU[x] == 0x3C)
+			{
+				((unsigned short*)maskpY)[x] = (unsigned short) 0x3C3C;
+				((unsigned short*)maskpnY)[x] = (unsigned short) 0x3C3C;
+				maskpV[x] = maskpU[x] = 0x3C;
+			}
+		}
+		maskpY += mask_pitchY4;
+		maskpnY += mask_pitchY4;
+		maskpV += mask_pitchUV2;
+		maskpU += mask_pitchUV2;
+	}
+}
+
+void vidTDeint::linkYtoUV_YV12(ADMImage *mask) 
+{
+	unsigned char *maskpY = mask-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *maskpV = mask-&gt;GetWritePtr(PLANAR_V);
+	unsigned char *maskpU = mask-&gt;GetWritePtr(PLANAR_U);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchY2 = mask_pitchY&lt;&lt;1;
+	int mask_pitchY4 = mask_pitchY&lt;&lt;2;
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	int mask_pitchUV2 = mask_pitchUV&lt;&lt;1;
+	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
+	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
+	maskpY += mask_pitchY*PRM(field);
+	maskpV += mask_pitchUV*PRM(field);
+	maskpU += mask_pitchUV*PRM(field);
+	unsigned char *maskpnY = maskpY + mask_pitchY2;
+	int x, y;
+	for (y=PRM(field); y&lt;HeightUV; y+=2)
+	{
+		for (x=0; x&lt;WidthUV; ++x)
+		{
+			if (((unsigned short*)maskpY)[x] == (unsigned short)0x3C3C &amp;&amp; 
+				((unsigned short*)maskpnY)[x] == (unsigned short)0x3C3C)
+			{
+				maskpV[x] = maskpU[x] = 0x3C;
+			}
+		}
+		maskpY += mask_pitchY4;
+		maskpnY += mask_pitchY4;
+		maskpV += mask_pitchUV2;
+		maskpU += mask_pitchUV2;
+	}
+}
+
+void vidTDeint::linkUVtoY_YV12(ADMImage *mask) 
+{
+	unsigned char *maskpY = mask-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *maskpV = mask-&gt;GetWritePtr(PLANAR_V);
+	unsigned char *maskpU = mask-&gt;GetWritePtr(PLANAR_U);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchY2 = mask_pitchY&lt;&lt;1;
+	int mask_pitchY4 = mask_pitchY&lt;&lt;2;
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	int mask_pitchUV2 = mask_pitchUV&lt;&lt;1;
+	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
+	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
+	maskpY += mask_pitchY*PRM(field);
+	maskpV += mask_pitchUV*PRM(field);
+	maskpU += mask_pitchUV*PRM(field);
+	unsigned char *maskpnY = maskpY + mask_pitchY2;
+	int x, y;
+	for (y=PRM(field); y&lt;HeightUV; y+=2)
+	{
+		for (x=0; x&lt;WidthUV; ++x)
+		{
+			if (maskpV[x] == 0x3C || maskpU[x] == 0x3C)
+			{
+				((unsigned short*)maskpY)[x] = (unsigned short) 0x3C3C;
+				((unsigned short*)maskpnY)[x] = (unsigned short) 0x3C3C;
+			}
+		}
+		maskpY += mask_pitchY4;
+		maskpnY += mask_pitchY4;
+		maskpV += mask_pitchUV2;
+		maskpU += mask_pitchUV2;
+	}
+}
+
+void vidTDeint::denoiseYV12(ADMImage *mask) 
+{
+	unsigned char *maskpY = mask-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *maskpV = mask-&gt;GetWritePtr(PLANAR_V);
+	unsigned char *maskpU = mask-&gt;GetWritePtr(PLANAR_U);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchY2 = mask_pitchY&lt;&lt;1;
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	int mask_pitchUV2 = mask_pitchUV&lt;&lt;1;
+	int HeightY = mask-&gt;GetHeight(PLANAR_Y);
+	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
+	int WidthY = mask-&gt;GetRowSize(PLANAR_Y);
+	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
+	maskpY += mask_pitchY*(2+PRM(field));
+	maskpV += mask_pitchUV*(2+PRM(field));
+	maskpU += mask_pitchUV*(2+PRM(field));
+	unsigned char *maskppY = maskpY - mask_pitchY2;
+	unsigned char *maskppV = maskpV - mask_pitchUV2;
+	unsigned char *maskppU = maskpU - mask_pitchUV2;
+	unsigned char *maskpnY = maskpY + mask_pitchY2;
+	unsigned char *maskpnV = maskpV + mask_pitchUV2;
+	unsigned char *maskpnU = maskpU + mask_pitchUV2;
+	int sum, xhi, v, x, y;
+	for (y=2; y&lt;HeightY-2; y+=2)
+	{
+		for (x=1; x&lt;WidthY-1; ++x)
+		{
+			if (maskpY[x] == 0x3C)
+			{
+				for (sum=0,v=x-1,xhi=x+2; v&lt;xhi &amp;&amp; sum&lt;2; ++v)
+				{
+					if (maskppY[v] == 0x3C) ++sum;
+					if (maskpY[v] == 0x3C) ++sum;
+					if (maskpnY[v] == 0x3C) ++sum;
+				}
+				if (sum &lt; 2) maskpY[x] = (maskpY[x-1] == maskpY[x+1]) ? maskpY[x-1] :
+								(maskppY[x] == maskpnY[x]) ? maskppY[x] : maskpY[x-1];
+			}
+		}
+		maskppY += mask_pitchY2;
+		maskpY += mask_pitchY2;
+		maskpnY += mask_pitchY2;
+	}
+	for (y=2; y&lt;HeightUV-2; y+=2)
+	{
+		for (x=1; x&lt;WidthUV-1; ++x)
+		{
+			if (maskpV[x] == 0x3C)
+			{
+				for (sum=0,v=x-1,xhi=x+2; v&lt;xhi &amp;&amp; sum&lt;2; ++v)
+				{
+					if (maskppV[v] == 0x3C) ++sum;
+					if (maskpV[v] == 0x3C) ++sum;
+					if (maskpnV[v] == 0x3C) ++sum;
+				}
+				if (sum &lt; 2) maskpV[x] = (maskpV[x-1] == maskpV[x+1]) ? maskpV[x-1] :
+								(maskppV[x] == maskpnV[x]) ? maskppV[x] : maskpV[x-1];
+			}
+			if (maskpU[x] == 0x3C)
+			{
+				for (sum=0,v=x-1,xhi=x+2; v&lt;xhi &amp;&amp; sum&lt;2; ++v)
+				{
+					if (maskppU[v] == 0x3C) ++sum;
+					if (maskpU[v] == 0x3C) ++sum;
+					if (maskpnU[v] == 0x3C) ++sum;
+				}
+				if (sum &lt; 2) maskpU[x] = (maskpU[x-1] == maskpU[x+1]) ? maskpU[x-1] :
+								(maskppU[x] == maskpnU[x]) ? maskppU[x] : maskpU[x-1];
+			}
+		}
+		maskppV += mask_pitchUV2;
+		maskpV += mask_pitchUV2;
+		maskpnV += mask_pitchUV2;
+		maskppU += mask_pitchUV2;
+		maskpU += mask_pitchUV2;
+		maskpnU += mask_pitchUV2;
+	}
+}
+
+bool vidTDeint::checkCombedYV12(ADMImage *src) 
+{
+	ADMImage *cmask = scratch;
+	const unsigned char *srcp, *srcpp, *srcppp, *srcpn, *srcpnn;
+	unsigned char *cmkp, *cmkpp, *cmkpn, *cmkpV, *cmkpU;
+	unsigned char *cmkpnn, *cmkppV, *cmkppU, *cmkpnV, *cmkpnU;
+	int cmk_pitch, src_pitch, Width, Height,  box1, box2;
+	ADM_PLANE plane;
+	int xblocks, yblocks, xblocks4, arraysize, cmk_pitchUV;
+	int x, y, b, sFirst, sSecond, temp1, temp2;
+	for (b=chroma ? 3 : 1; b&gt;0; --b)
+	{
+		if (b == 3) plane = PLANAR_U;
+		else if (b == 2) plane = PLANAR_V;
+		else plane = PLANAR_Y;
+		srcp = src-&gt;GetReadPtr(plane);
+		src_pitch = src-&gt;GetPitch(plane);
+		Width = src-&gt;GetRowSize(plane);
+		Height = src-&gt;GetHeight(plane);
+		srcpp = srcp - src_pitch;
+		srcppp = srcpp - src_pitch;
+		srcpn = srcp + src_pitch;
+		srcpnn = srcpn + src_pitch;
+		cmkp = cmask-&gt;GetWritePtr(plane);
+		cmk_pitch = cmask-&gt;GetPitch(plane);
+		memset(cmkp,0,Height*cmk_pitch);
+		for (x=0; x&lt;Width; ++x)
+		{
+			sFirst = srcp[x] - srcpn[x];
+			if (sFirst &gt; cthresh || sFirst &lt; -cthresh)
+			{
+				sFirst = abs(srcpnn[x]+(srcp[x]&lt;&lt;2)+srcpnn[x]-(3*(srcpn[x]+srcpn[x])));
+				if (sFirst &gt; cthresh6) cmkp[x] = 0x3C;
+			}
+		}
+		srcppp += src_pitch;
+		srcpp += src_pitch;
+		srcp += src_pitch;
+		srcpn += src_pitch;
+		srcpnn += src_pitch;
+		cmkp += cmk_pitch;
+		for (x=0; x&lt;Width; ++x)
+		{
+			sFirst = srcp[x] - srcpp[x];
+			sSecond = srcp[x] - srcpn[x];
+			if ((sFirst &gt; cthresh &amp;&amp; sSecond &gt; cthresh) || (sFirst &lt; -cthresh &amp;&amp; sSecond &lt; -cthresh))
+			{
+				sFirst = abs(srcpnn[x]+(srcp[x]&lt;&lt;2)+srcpnn[x]-(3*(srcpp[x]+srcpn[x])));
+				if (sFirst &gt; cthresh6) cmkp[x] = 0x3C;
+			}
+		}
+		srcppp += src_pitch;
+		srcpp += src_pitch;
+		srcp += src_pitch;
+		srcpn += src_pitch;
+		srcpnn += src_pitch;
+		cmkp += cmk_pitch;
+		for (y=2; y&lt;Height-2; ++y)
+		{
+			for (x=0; x&lt;Width; ++x)
+			{
+				sFirst = srcp[x] - srcpp[x];
+				sSecond = srcp[x] - srcpn[x];
+				if ((sFirst &gt; cthresh &amp;&amp; sSecond &gt; cthresh) || (sFirst &lt; -cthresh &amp;&amp; sSecond &lt; -cthresh))
+				{
+					sFirst = abs(srcppp[x]+(srcp[x]&lt;&lt;2)+srcpnn[x]-(3*(srcpp[x]+srcpn[x])));
+					if (sFirst &gt; cthresh6) cmkp[x] = 0x3C;
+				}	
+			}
+			srcppp += src_pitch;
+			srcpp += src_pitch;
+			srcp += src_pitch;
+			srcpn += src_pitch;
+			srcpnn += src_pitch;
+			cmkp += cmk_pitch;
+		}
+		for (x=0; x&lt;Width; ++x)
+		{
+			sFirst = srcp[x] - srcpp[x];
+			sSecond = srcp[x] - srcpn[x];
+			if ((sFirst &gt; cthresh &amp;&amp; sSecond &gt; cthresh) || (sFirst &lt; -cthresh &amp;&amp; sSecond &lt; -cthresh))
+			{
+				sFirst = abs(srcppp[x]+(srcp[x]&lt;&lt;2)+srcppp[x]-(3*(srcpp[x]+srcpn[x])));
+				if (sFirst &gt; cthresh6) cmkp[x] = 0x3C;
+			}
+		}
+		srcppp += src_pitch;
+		srcpp += src_pitch;
+		srcp += src_pitch;
+		srcpn += src_pitch;
+		srcpnn += src_pitch;
+		cmkp += cmk_pitch;
+		for (x=0; x&lt;Width; ++x)
+		{
+			sFirst = srcp[x] - srcpp[x];
+			if (sFirst &gt; cthresh || sFirst &lt; -cthresh)
+			{
+				sFirst = abs(srcppp[x]+(srcp[x]&lt;&lt;2)+srcppp[x]-(3*(srcpp[x]+srcpp[x])));
+				if (sFirst &gt; cthresh6) cmkp[x] = 0x3C;
+			}
+		}
+	}
+	if (chroma) 
+	{
+		cmkp = cmask-&gt;GetWritePtr(PLANAR_Y);
+		cmkpU = cmask-&gt;GetWritePtr(PLANAR_U);
+		cmkpV = cmask-&gt;GetWritePtr(PLANAR_V);
+		Width = cmask-&gt;GetRowSize(PLANAR_V);
+		Height = cmask-&gt;GetHeight(PLANAR_V);
+		cmk_pitch = cmask-&gt;GetPitch(PLANAR_Y);
+		cmk_pitchUV = cmask-&gt;GetPitch(PLANAR_V);
+		cmkpp = cmkp - cmk_pitch;
+		cmkpn = cmkp + cmk_pitch;
+		cmkpnn = cmkpn + cmk_pitch;
+		cmkppU = cmkpU - cmk_pitchUV;
+		cmkpnU = cmkpU + cmk_pitchUV;
+		cmkppV = cmkpV - cmk_pitchUV;
+		cmkpnV = cmkpV + cmk_pitchUV;
+		cmk_pitch &lt;&lt;= 1;
+		for (y=1; y&lt;Height-1; ++y)
+		{
+			cmkpp += cmk_pitch;
+			cmkp += cmk_pitch;
+			cmkpn += cmk_pitch;
+			cmkpnn += cmk_pitch;
+			cmkppV += cmk_pitchUV;
+			cmkpV += cmk_pitchUV;
+			cmkpnV += cmk_pitchUV;
+			cmkppU += cmk_pitchUV;
+			cmkpU += cmk_pitchUV;
+			cmkpnU += cmk_pitchUV;
+			for (x=1; x&lt;Width-1; ++x)
+			{
+				if ((cmkpV[x] == 0x3C &amp;&amp; (cmkpV[x-1] == 0x3C || cmkpV[x+1] == 0x3C ||
+					 cmkppV[x-1] == 0x3C || cmkppV[x] == 0x3C || cmkppV[x+1] == 0x3C ||
+					 cmkpnV[x-1] == 0x3C || cmkpnV[x] == 0x3C || cmkpnV[x+1] == 0x3C)) || 
+					(cmkpU[x] == 0x3C &amp;&amp; (cmkpU[x-1] == 0x3C || cmkpU[x+1] == 0x3C ||
+					 cmkppU[x-1] == 0x3C || cmkppU[x] == 0x3C || cmkppU[x+1] == 0x3C ||
+					 cmkpnU[x-1] == 0x3C || cmkpnU[x] == 0x3C || cmkpnU[x+1] == 0x3C)))
+				{
+					((unsigned short*)cmkp)[x] = (unsigned short) 0x3C3C;
+					((unsigned short*)cmkpn)[x] = (unsigned short) 0x3C3C;
+					if (y&amp;1) ((unsigned short*)cmkpp)[x] = (unsigned short) 0x3C3C;
+					else ((unsigned short*)cmkpnn)[x] = (unsigned short) 0x3C3C;
+				}
+			}
+		}
+	}
+	cmk_pitch = cmask-&gt;GetPitch(PLANAR_Y);
+	cmkp = cmask-&gt;GetWritePtr(PLANAR_Y) + cmk_pitch;
+	cmkpp = cmkp - cmk_pitch;
+	cmkpn = cmkp + cmk_pitch;
+	Width = cmask-&gt;GetRowSize(PLANAR_Y);
+	Height = cmask-&gt;GetHeight(PLANAR_Y);
+	xblocks = ((Width+xhalf)&gt;&gt;xshift) + 1;
+	xblocks4 = xblocks&lt;&lt;2;
+	yblocks = ((Height+yhalf)&gt;&gt;yshift) + 1;
+	arraysize = (xblocks*yblocks)&lt;&lt;2;
+	memset(cArray,0,arraysize*sizeof(int));
+	for (y=1; y&lt;Height-1; ++y)
+	{
+		temp1 = (y&gt;&gt;yshift)*xblocks4;
+		temp2 = ((y+yhalf)&gt;&gt;yshift)*xblocks4;
+		for (x=0; x&lt;Width; ++x)
+		{
+			if (cmkpp[x] == 0x3C &amp;&amp; cmkp[x] == 0x3C &amp;&amp; cmkpn[x] == 0x3C)
+			{
+				box1 = (x&gt;&gt;xshift)&lt;&lt;2;
+				box2 = ((x+xhalf)&gt;&gt;xshift)&lt;&lt;2;
+				++cArray[temp1+box1+0];
+				++cArray[temp1+box2+1];
+				++cArray[temp2+box1+2];
+				++cArray[temp2+box2+3];
+			}
+		}
+		cmkpp += cmk_pitch;
+		cmkp += cmk_pitch;
+		cmkpn += cmk_pitch;
+	}
+	for (x=0; x&lt;arraysize; ++x)
+	{
+		if (cArray[x] &gt; MI) return true;
+	}
+	return false;
+}
+
+void vidTDeint::subtractFieldsYV12(ADMImage *prv, ADMImage *src, ADMImage *nxt) 
+{
+	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
+	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
+	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
+	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
+	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
+	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
+	int WidthY = src-&gt;GetRowSize(PLANAR_Y)-8;
+	int HeightY = src-&gt;GetHeight(PLANAR_Y);
+	int WidthUV = src-&gt;GetRowSize(PLANAR_V)-4;
+	int HeightUV = src-&gt;GetHeight(PLANAR_V);
+	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
+	const unsigned char *prvpfY, *prvnfY, *nxtpfY, *nxtnfY;
+	const unsigned char *prvpfU, *prvnfU, *nxtpfU, *nxtnfU;
+	const unsigned char *prvpfV, *prvnfV, *nxtpfV, *nxtnfV;
+	const unsigned char *curpfY, *curfY, *curnfY;
+	const unsigned char *curpfU, *curfU, *curnfU;
+	const unsigned char *curpfV, *curfV, *curnfV;
+	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
+	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
+	int prvf_pitchY, prvf_pitchUV;
+	int curf_pitchY, curf_pitchUV;
+	int nxtf_pitchY, nxtf_pitchUV;
+	int x, y, temp, temp2;
+	accumP = accumN = 0;
+	if (PRM(field)^PRM(order))
+	{
+		prvf_pitchY = src_pitchY&lt;&lt;1;
+		prvf_pitchUV = src_pitchUV&lt;&lt;1;
+		curf_pitchY = src_pitchY&lt;&lt;1;
+		curf_pitchUV = src_pitchUV&lt;&lt;1;
+		nxtf_pitchY = nxt_pitchY&lt;&lt;1;
+		nxtf_pitchUV = nxt_pitchUV&lt;&lt;1;
+		prvpfY = srcpY + ((PRM(field) == 1 ? 1 : 2)*src_pitchY);
+		prvpfU = srcpU + ((PRM(field) == 1 ? 1 : 2)*src_pitchUV);
+		prvpfV = srcpV + ((PRM(field) == 1 ? 1 : 2)*src_pitchUV);
+		curfY = srcpY + ((3-PRM(field))*src_pitchY);
+		curfU = srcpU + ((3-PRM(field))*src_pitchUV);
+		curfV = srcpV + ((3-PRM(field))*src_pitchUV);
+		nxtpfY = nxtpY + ((PRM(field) == 1 ? 1 : 2)*nxt_pitchY);
+		nxtpfU = nxtpU + ((PRM(field) == 1 ? 1 : 2)*nxt_pitchUV);
+		nxtpfV = nxtpV + ((PRM(field) == 1 ? 1 : 2)*nxt_pitchUV);
+	}
+	else
+	{
+		prvf_pitchY = prv_pitchY&lt;&lt;1;
+		prvf_pitchUV = prv_pitchUV&lt;&lt;1;
+		curf_pitchY = src_pitchY&lt;&lt;1;
+		curf_pitchUV = src_pitchUV&lt;&lt;1;
+		nxtf_pitchY = src_pitchY&lt;&lt;1;
+		nxtf_pitchUV = src_pitchUV&lt;&lt;1;
+		prvpfY = prvpY + ((PRM(field) == 1 ? 1 : 2)*prv_pitchY);
+		prvpfU = prvpU + ((PRM(field) == 1 ? 1 : 2)*prv_pitchUV);
+		prvpfV = prvpV + ((PRM(field) == 1 ? 1 : 2)*prv_pitchUV);
+		curfY = srcpY + ((3-PRM(field))*src_pitchY);
+		curfU = srcpU + ((3-PRM(field))*src_pitchUV);
+		curfV = srcpV + ((3-PRM(field))*src_pitchUV);
+		nxtpfY = srcpY + ((PRM(field) == 1 ? 1 : 2)*src_pitchY);
+		nxtpfU = srcpU + ((PRM(field) == 1 ? 1 : 2)*src_pitchUV);
+		nxtpfV = srcpV + ((PRM(field) == 1 ? 1 : 2)*src_pitchUV);
+	}
+	prvnfY = prvpfY + prvf_pitchY;
+	prvnfU = prvpfU + prvf_pitchUV;
+	prvnfV = prvpfV + prvf_pitchUV;
+	curpfY = curfY - curf_pitchY;
+	curpfU = curfU - curf_pitchUV;
+	curpfV = curfV - curf_pitchUV;
+	curnfY = curfY + curf_pitchY;
+	curnfU = curfU + curf_pitchUV;
+	curnfV = curfV + curf_pitchUV;
+	nxtnfY = nxtpfY + nxtf_pitchY;
+	nxtnfU = nxtpfU + nxtf_pitchUV;
+	nxtnfV = nxtpfV + nxtf_pitchUV;
+	for (y=2; y&lt;HeightY-2; y+=2)
+	{
+		for (x=8; x&lt;WidthY; ++x)
+		{
+			if (abs(prvpfY[x]-nxtpfY[x]) &gt; 3 || abs(prvnfY[x]-nxtnfY[x]) &gt; 3)
+			{
+				temp = (curpfY[x]+(curfY[x]&lt;&lt;2)+curnfY[x]);
+				temp2 = abs(3*(prvpfY[x]+prvnfY[x])-temp);
+				if (temp2 &gt; 23) accumP += temp2;
+				temp2 = abs(3*(nxtpfY[x]+nxtnfY[x])-temp);
+				if (temp2 &gt; 23) accumN += temp2;
+			}
+		}
+		prvpfY += prvf_pitchY;
+		prvnfY += prvf_pitchY;
+		curpfY += curf_pitchY;
+		curfY += curf_pitchY;
+		curnfY += curf_pitchY;
+		nxtpfY += nxtf_pitchY;
+		nxtnfY += nxtf_pitchY;
+	}
+	for (y=2; y&lt;HeightUV-2; y+=2)
+	{
+		for (x=4; x&lt;WidthUV; ++x)
+		{
+			if (abs(prvpfU[x]-nxtpfU[x]) &gt; 3 || abs(prvnfU[x]-nxtnfU[x]) &gt; 3)
+			{
+				temp = (curpfU[x]+(curfU[x]&lt;&lt;2)+curnfU[x]);
+				temp2 = abs(3*(prvpfU[x]+prvnfU[x])-temp);
+				if (temp2 &gt; 23) accumP += temp2;
+				temp2 = abs(3*(nxtpfU[x]+nxtnfU[x])-temp);
+				if (temp2 &gt; 23) accumN += temp2;
+			}
+			if (abs(prvpfV[x]-nxtpfV[x]) &gt; 3 || abs(prvnfV[x]-nxtnfV[x]) &gt; 3)
+			{
+				temp = (curpfV[x]+(curfV[x]&lt;&lt;2)+curnfV[x]);
+				temp2 = abs(3*(prvpfV[x]+prvnfV[x])-temp);
+				if (temp2 &gt; 23) accumP += temp2;
+				temp2 = abs(3*(nxtpfV[x]+nxtnfV[x])-temp);
+				if (temp2 &gt; 23) accumN += temp2;
+			}
+		}
+		prvpfU += prvf_pitchUV;
+		prvnfU += prvf_pitchUV;
+		prvpfV += prvf_pitchUV;
+		prvnfV += prvf_pitchUV;
+		curpfU += curf_pitchUV;
+		curfU += curf_pitchUV;
+		curnfU += curf_pitchUV;
+		curpfV += curf_pitchUV;
+		curfV += curf_pitchUV;
+		curnfV += curf_pitchUV;
+		nxtpfU += nxtf_pitchUV;
+		nxtnfU += nxtf_pitchUV;
+		nxtpfV += nxtf_pitchUV;
+		nxtnfV += nxtf_pitchUV;
+	}
+}
+
+void vidTDeint::mapColorsYV12(ADMImage *dst, ADMImage *mask)
+{
+	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	int HeightY = mask-&gt;GetHeight(PLANAR_Y);
+	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
+	int WidthY = mask-&gt;GetRowSize(PLANAR_Y);
+	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
+	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
+	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
+	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
+	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
+	int x, y;
+	for (y=0; y&lt;HeightY; ++y)
+	{
+		for (x=0; x&lt;WidthY; ++x)
+		{
+			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = 0;
+			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = 51;
+			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = 102;
+			else if (maskpY[x] == 40) dstpY[x] = 153;
+			else if (maskpY[x] == 50) dstpY[x] = 204;
+			else if (maskpY[x] == 60) dstpY[x] = 255;
+		}
+		maskpY += mask_pitchY;
+		dstpY += dst_pitchY;
+	}
+	for (y=0; y&lt;HeightUV; ++y)
+	{
+		for (x=0; x&lt;WidthUV; ++x)
+		{
+			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = 0;
+			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = 51;
+			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = 102;
+			else if (maskpV[x] == 40) dstpV[x] = 153;
+			else if (maskpV[x] == 50) dstpV[x] = 204;
+			else if (maskpV[x] == 60) dstpV[x] = 255;
+			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = 0;
+			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = 51;
+			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = 102;
+			else if (maskpU[x] == 40) dstpU[x] = 153;
+			else if (maskpU[x] == 50) dstpU[x] = 204;
+			else if (maskpU[x] == 60) dstpU[x] = 255;
+		}
+		maskpV += mask_pitchUV;
+		maskpU += mask_pitchUV;
+		dstpV += dst_pitchUV;
+		dstpU += dst_pitchUV;
+	}
+}
+
+void vidTDeint::mapMergeYV12(ADMImage *dst, ADMImage *mask, 
+		ADMImage *prv, ADMImage *src, ADMImage *nxt)
+{
+	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	int HeightY = mask-&gt;GetHeight(PLANAR_Y);
+	int HeightUV = mask-&gt;GetHeight(PLANAR_V);
+	int WidthY = mask-&gt;GetRowSize(PLANAR_Y);
+	int WidthUV = mask-&gt;GetRowSize(PLANAR_V);
+	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
+	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
+	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
+	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
+	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
+	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
+	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
+	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
+	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
+	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
+	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
+	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
+	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
+	int x, y;
+	for (y=0; y&lt;HeightY; ++y)
+	{
+		for (x=0; x&lt;WidthY; ++x)
+		{
+			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = srcpY[x];
+			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = prvpY[x];
+			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = nxtpY[x];
+			else if (maskpY[x] == 40) dstpY[x] = (srcpY[x]+nxtpY[x]+1)&gt;&gt;1;
+			else if (maskpY[x] == 50) dstpY[x] = (srcpY[x]+prvpY[x]+1)&gt;&gt;1;
+			else if (maskpY[x] == 60) dstpY[x] = 255;
+		}
+		prvpY += prv_pitchY;
+		srcpY += src_pitchY;
+		nxtpY += nxt_pitchY;
+		maskpY += mask_pitchY;
+		dstpY += dst_pitchY;
+	}
+	for (y=0; y&lt;HeightUV; ++y)
+	{
+		for (x=0; x&lt;WidthUV; ++x)
+		{
+			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = srcpV[x];
+			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = prvpV[x];
+			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = nxtpV[x];
+			else if (maskpV[x] == 40) dstpV[x] = (srcpV[x]+nxtpV[x]+1)&gt;&gt;1;
+			else if (maskpV[x] == 50) dstpV[x] = (srcpV[x]+prvpV[x]+1)&gt;&gt;1;
+			else if (maskpV[x] == 60) dstpV[x] = 255;
+			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = srcpU[x];
+			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = prvpU[x];
+			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = nxtpU[x];
+			else if (maskpU[x] == 40) dstpU[x] = (srcpU[x]+nxtpU[x]+1)&gt;&gt;1;
+			else if (maskpU[x] == 50) dstpU[x] = (srcpU[x]+prvpU[x]+1)&gt;&gt;1;
+			else if (maskpU[x] == 60) dstpU[x] = 255;
+		}
+		prvpV += prv_pitchUV;
+		prvpU += prv_pitchUV;
+		srcpV += src_pitchUV;
+		srcpU += src_pitchUV;
+		nxtpV += nxt_pitchUV;
+		nxtpU += nxt_pitchUV;
+		maskpV += mask_pitchUV;
+		maskpU += mask_pitchUV;
+		dstpV += dst_pitchUV;
+		dstpU += dst_pitchUV;
+	}
+}
+
+void vidTDeint::cubicDeintYV12(ADMImage *dst, ADMImage *mask, 
+		ADMImage *prv, ADMImage *src, ADMImage *nxt)
+{
+	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
+	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
+	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
+	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
+	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
+	int src_pitchY2 = src_pitchY&lt;&lt;1;
+	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
+	int src_pitchUV2 = src_pitchUV&lt;&lt;1;
+	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
+	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
+	int HeightY = src-&gt;GetHeight(PLANAR_Y);
+	int HeightUV = src-&gt;GetHeight(PLANAR_V);
+	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
+	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
+	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
+	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
+	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
+	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
+	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
+	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	const unsigned char *srcppY = srcpY - src_pitchY;
+	const unsigned char *srcpppY = srcppY - src_pitchY2;
+	const unsigned char *srcpnY = srcpY + src_pitchY;
+	const unsigned char *srcpnnY = srcpnY + src_pitchY2;
+	const unsigned char *srcppV = srcpV - src_pitchUV;
+	const unsigned char *srcpppV = srcppV - src_pitchUV2;
+	const unsigned char *srcpnV = srcpV + src_pitchUV;
+	const unsigned char *srcpnnV = srcpnV + src_pitchUV2;
+	const unsigned char *srcppU = srcpU - src_pitchUV;
+	const unsigned char *srcpppU = srcppU - src_pitchUV2;
+	const unsigned char *srcpnU = srcpU + src_pitchUV;
+	const unsigned char *srcpnnU = srcpnU + src_pitchUV2;
+	int x, y;
+	for (y=0; y&lt;HeightY; ++y)
+	{
+		for (x=0; x&lt;WidthY; ++x)
+		{
+			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = srcpY[x];
+			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = prvpY[x];
+			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = nxtpY[x];
+			else if (maskpY[x] == 40) dstpY[x] = (srcpY[x]+nxtpY[x]+1)&gt;&gt;1;
+			else if (maskpY[x] == 50) dstpY[x] = (srcpY[x]+prvpY[x]+1)&gt;&gt;1;
+			else if (maskpY[x] == 60)
+			{
+				if (y&lt;3 || y&gt;HeightY-4) dstpY[x] = (srcpnY[x]+srcppY[x]+1)&gt;&gt;1;
+				else dstpY[x] = cubicInt(srcpppY[x],srcppY[x],srcpnY[x],srcpnnY[x]);
+			}
+		}
+		prvpY += prv_pitchY;
+		srcpppY += src_pitchY;
+		srcppY += src_pitchY;
+		srcpY += src_pitchY;
+		srcpnY += src_pitchY;
+		srcpnnY += src_pitchY;
+		nxtpY += nxt_pitchY;
+		maskpY += mask_pitchY;
+		dstpY += dst_pitchY;
+	}
+	for (y=0; y&lt;HeightUV; ++y)
+	{
+		for (x=0; x&lt;WidthUV; ++x)
+		{
+			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = srcpV[x];
+			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = prvpV[x];
+			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = nxtpV[x];
+			else if (maskpV[x] == 40) dstpV[x] = (srcpV[x]+nxtpV[x]+1)&gt;&gt;1;
+			else if (maskpV[x] == 50) dstpV[x] = (srcpV[x]+prvpV[x]+1)&gt;&gt;1;
+			else if (maskpV[x] == 60)
+			{
+				if (y&lt;3 || y&gt;HeightUV-4) dstpV[x] = (srcpnV[x]+srcppV[x]+1)&gt;&gt;1;
+				else dstpV[x] = cubicInt(srcpppV[x],srcppV[x],srcpnV[x],srcpnnV[x]);
+			}
+			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = srcpU[x];
+			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = prvpU[x];
+			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = nxtpU[x];
+			else if (maskpU[x] == 40) dstpU[x] = (srcpU[x]+nxtpU[x]+1)&gt;&gt;1;
+			else if (maskpU[x] == 50) dstpU[x] = (srcpU[x]+prvpU[x]+1)&gt;&gt;1;
+			else if (maskpU[x] == 60)
+			{
+				if (y&lt;3 || y&gt;HeightUV-4) dstpU[x] = (srcpnU[x]+srcppU[x]+1)&gt;&gt;1;
+				else dstpU[x] = cubicInt(srcpppU[x],srcppU[x],srcpnU[x],srcpnnU[x]);
+			}
+		}
+		prvpV += prv_pitchUV;
+		prvpU += prv_pitchUV;
+		srcpppV += src_pitchUV;
+		srcppV += src_pitchUV;
+		srcpV += src_pitchUV;
+		srcpnV += src_pitchUV;
+		srcpnnV += src_pitchUV;
+		srcpppU += src_pitchUV;
+		srcppU += src_pitchUV;
+		srcpU += src_pitchUV;
+		srcpnU += src_pitchUV;
+		srcpnnU += src_pitchUV;
+		nxtpV += nxt_pitchUV;
+		nxtpU += nxt_pitchUV;
+		maskpV += mask_pitchUV;
+		maskpU += mask_pitchUV;
+		dstpV += dst_pitchUV;
+		dstpU += dst_pitchUV;
+	}
+}
+
+void vidTDeint::ELADeintYV12(ADMImage *dst, ADMImage *mask, 
+		ADMImage *prv, ADMImage *src, ADMImage *nxt)
+{
+	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
+	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
+	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
+	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
+	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
+	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
+	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
+	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
+	int HeightY = src-&gt;GetHeight(PLANAR_Y);
+	int HeightUV = src-&gt;GetHeight(PLANAR_V);
+	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
+	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
+	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
+	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
+	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
+	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
+	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
+	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	const unsigned char *srcppY = srcpY - src_pitchY;
+	const unsigned char *srcpnY = srcpY + src_pitchY;
+	const unsigned char *srcppV = srcpV - src_pitchUV;
+	const unsigned char *srcpnV = srcpV + src_pitchUV;
+	const unsigned char *srcppU = srcpU - src_pitchUV;
+	const unsigned char *srcpnU = srcpU + src_pitchUV;
+	int x, y, u, val, stop, temp1, temp2, min, minf, maxf, s1, s2;
+	for (y=0; y&lt;HeightY; ++y)
+	{
+		for (x=0; x&lt;WidthY; ++x)
+		{
+			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = srcpY[x];
+			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = prvpY[x];
+			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = nxtpY[x];
+			else if (maskpY[x] == 40) dstpY[x] = (srcpY[x]+nxtpY[x]+1)&gt;&gt;1;
+			else if (maskpY[x] == 50) dstpY[x] = (srcpY[x]+prvpY[x]+1)&gt;&gt;1;
+			else if (maskpY[x] == 60)
+			{
+				if (x &lt; 2 || x &gt; WidthY-3 || (abs(srcppY[x]-srcpnY[x]) &lt; 10 &amp;&amp;
+					abs(srcppY[x-2]-srcppY[x+2]) &lt; 10 &amp;&amp; abs(srcpnY[x-2]-srcpnY[x+2]) &lt; 10))
+				{
+					dstpY[x] = (srcppY[x]+srcpnY[x]+1)&gt;&gt;1;
+				}
+				else
+				{
+					stop = min(x-1,min(8,WidthY-2-x));
+					minf = min(srcppY[x],srcpnY[x])-2;
+					maxf = max(srcppY[x],srcpnY[x])+2;
+					val = (srcppY[x]+srcpnY[x]+1)&gt;&gt;1;
+					for (min=450, u=0; u&lt;=stop; ++u)
+					{
+						s1 = srcppY[x+(u&gt;&gt;1)]+srcppY[x+((u+1)&gt;&gt;1)];
+						s2 = srcpnY[x-(u&gt;&gt;1)]+srcpnY[x-((u+1)&gt;&gt;1)];
+						temp1 = abs(s1-s2) + abs(srcppY[x-1]-srcpnY[x-1-u]) + 
+							(abs(srcppY[x]-srcpnY[x-u])&lt;&lt;1) + abs(srcppY[x+1]-srcpnY[x+1-u]) +
+							abs(srcpnY[x-1]-srcppY[x-1+u]) + (abs(srcpnY[x]-srcppY[x+u])&lt;&lt;1) + 
+							abs(srcpnY[x+1]-srcppY[x+1+u]);
+						temp2 = (s1+s2+2)&gt;&gt;2;
+						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
+						{
+							min = temp1;
+							val = temp2;
+						}
+						s1 = srcppY[x-(u&gt;&gt;1)]+srcppY[x-((u+1)&gt;&gt;1)];
+						s2 = srcpnY[x+(u&gt;&gt;1)]+srcpnY[x+((u+1)&gt;&gt;1)];
+						temp1 = abs(s1-s2) + abs(srcppY[x-1]-srcpnY[x-1+u]) + 
+							(abs(srcppY[x]-srcpnY[x+u])&lt;&lt;1) + abs(srcppY[x+1]-srcpnY[x+1+u])+
+							abs(srcpnY[x-1]-srcppY[x-1-u]) + (abs(srcpnY[x]-srcppY[x-u])&lt;&lt;1) +
+							abs(srcpnY[x+1]-srcppY[x+1-u]);
+						temp2 = (s1+s2+2)&gt;&gt;2;
+						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
+						{
+							min = temp1;
+							val = temp2;
+						}
+					}
+					dstpY[x] = val;
+				}
+			}
+		}
+		prvpY += prv_pitchY;
+		srcppY += src_pitchY;
+		srcpY += src_pitchY;
+		srcpnY += src_pitchY;
+		nxtpY += nxt_pitchY;
+		maskpY += mask_pitchY;
+		dstpY += dst_pitchY;
+	}
+	for (y=0; y&lt;HeightUV; ++y)
+	{
+		for (x=0; x&lt;WidthUV; ++x)
+		{
+			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = srcpV[x];
+			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = prvpV[x];
+			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = nxtpV[x];
+			else if (maskpV[x] == 40) dstpV[x] = (srcpV[x]+nxtpV[x]+1)&gt;&gt;1;
+			else if (maskpV[x] == 50) dstpV[x] = (srcpV[x]+prvpV[x]+1)&gt;&gt;1;
+			else if (maskpV[x] == 60)
+			{
+				if (x &lt; 2 || x &gt; WidthUV-3 || (abs(srcppV[x]-srcpnV[x]) &lt; 10 &amp;&amp;
+					abs(srcppV[x-2]-srcppV[x+2]) &lt; 10 &amp;&amp; abs(srcpnV[x-2]-srcpnV[x+2]) &lt; 10)) 
+				{
+					dstpV[x] = (srcppV[x]+srcpnV[x]+1)&gt;&gt;1;
+				}
+				else
+				{
+					stop = min(x-1,min(4,WidthUV-2-x));
+					minf = min(srcppV[x],srcpnV[x])-2;
+					maxf = max(srcppV[x],srcpnV[x])+2;
+					val = (srcppV[x]+srcpnV[x]+1)&gt;&gt;1;
+					for (min=450, u=0; u&lt;=stop; ++u) 
+					{
+						s1 = srcppV[x+(u&gt;&gt;1)]+srcppV[x+((u+1)&gt;&gt;1)];
+						s2 = srcpnV[x-(u&gt;&gt;1)]+srcpnV[x-((u+1)&gt;&gt;1)];
+						temp1 = abs(s1-s2) + abs(srcppV[x-1]-srcpnV[x-1-u]) +
+							(abs(srcppV[x]-srcpnV[x-u])&lt;&lt;1) + abs(srcppV[x+1]-srcpnV[x+1-u]) +
+							abs(srcpnV[x-1]-srcppV[x-1+u]) + (abs(srcpnV[x]-srcppV[x+u])&lt;&lt;1) +
+							abs(srcpnV[x+1]-srcppV[x+1+u]);
+						temp2 = (s1+s2+2)&gt;&gt;2;
+						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
+						{
+							min = temp1;
+							val = temp2;
+						}
+						s1 = srcppV[x-(u&gt;&gt;1)]+srcppV[x-((u+1)&gt;&gt;1)];
+						s2 = srcpnV[x+(u&gt;&gt;1)]+srcpnV[x+((u+1)&gt;&gt;1)];
+						temp1 = abs(s1-s2) + abs(srcppV[x-1]-srcpnV[x-1+u]) + 
+							(abs(srcppV[x]-srcpnV[x+u])&lt;&lt;1) + abs(srcppV[x+1]-srcpnV[x+1+u]) +
+							abs(srcpnV[x-1]-srcppV[x-1-u]) + (abs(srcpnV[x]-srcppV[x-u])&lt;&lt;1) + 
+							abs(srcpnV[x+1]-srcppV[x+1-u]);
+						temp2 = (s1+s2+2)&gt;&gt;2;
+						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
+						{
+							min = temp1;
+							val = temp2;
+						}
+					}
+					dstpV[x] = val;
+				}
+			}
+			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = srcpU[x];
+			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = prvpU[x];
+			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = nxtpU[x];
+			else if (maskpU[x] == 40) dstpU[x] = (srcpU[x]+nxtpU[x]+1)&gt;&gt;1;
+			else if (maskpU[x] == 50) dstpU[x] = (srcpU[x]+prvpU[x]+1)&gt;&gt;1;
+			else if (maskpU[x] == 60)
+			{
+				if (x &lt; 2 || x &gt; WidthUV-3 || (abs(srcppU[x]-srcpnU[x]) &lt; 10 &amp;&amp;
+					abs(srcppU[x-2]-srcppU[x+2]) &lt; 10 &amp;&amp; abs(srcpnU[x-2]-srcpnU[x+2]) &lt; 10)) 
+				{
+					dstpU[x] = (srcppU[x]+srcpnU[x]+1)&gt;&gt;1;
+				}
+				else
+				{
+					stop = min(x-1,min(4,WidthUV-2-x));
+					minf = min(srcppU[x],srcpnU[x])-2;
+					maxf = max(srcppU[x],srcpnU[x])+2;
+					val = (srcppU[x]+srcpnU[x]+1)&gt;&gt;1;
+					for (min=450, u=0; u&lt;=stop; ++u) 
+					{
+						s1 = srcppU[x+(u&gt;&gt;1)]+srcppU[x+((u+1)&gt;&gt;1)];
+						s2 = srcpnU[x-(u&gt;&gt;1)]+srcpnU[x-((u+1)&gt;&gt;1)];
+						temp1 = abs(s1-s2) + abs(srcppU[x-1]-srcpnU[x-1-u]) +
+							(abs(srcppU[x]-srcpnU[x-u])&lt;&lt;1) + abs(srcppU[x+1]-srcpnU[x+1-u]) +
+							abs(srcpnU[x-1]-srcppU[x-1+u]) + (abs(srcpnU[x]-srcppU[x+u])&lt;&lt;1) +
+							abs(srcpnU[x+1]-srcppU[x+1+u]);
+						temp2 = (s1+s2+2)&gt;&gt;2;
+						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
+						{
+							min = temp1;
+							val = temp2;
+						}
+						s1 = srcppU[x-(u&gt;&gt;1)]+srcppU[x-((u+1)&gt;&gt;1)];
+						s2 = srcpnU[x+(u&gt;&gt;1)]+srcpnU[x+((u+1)&gt;&gt;1)];
+						temp1 = abs(s1-s2) + abs(srcppU[x-1]-srcpnU[x-1+u]) + 
+							(abs(srcppU[x]-srcpnU[x+u])&lt;&lt;1) + abs(srcppU[x+1]-srcpnU[x+1+u]) +
+							abs(srcpnU[x-1]-srcppU[x-1-u]) + (abs(srcpnU[x]-srcppU[x-u])&lt;&lt;1) +
+							abs(srcpnU[x+1]-srcppU[x+1-u]);
+						temp2 = (s1+s2+2)&gt;&gt;2;
+						if (temp1 &lt; min &amp;&amp; temp2 &gt;= minf &amp;&amp; temp2 &lt;= maxf)
+						{
+							min = temp1;
+							val = temp2;
+						}
+					}
+					dstpU[x] = val;
+				}
+			}
+		}
+		prvpV += prv_pitchUV;
+		prvpU += prv_pitchUV;
+		srcppV += src_pitchUV;
+		srcpV += src_pitchUV;
+		srcpnV += src_pitchUV;
+		srcppU += src_pitchUV;
+		srcpU += src_pitchUV;
+		srcpnU += src_pitchUV;
+		nxtpV += nxt_pitchUV;
+		nxtpU += nxt_pitchUV;
+		maskpV += mask_pitchUV;
+		maskpU += mask_pitchUV;
+		dstpV += dst_pitchUV;
+		dstpU += dst_pitchUV;
+	}
+}
+
+void vidTDeint::kernelDeintYV12(ADMImage *dst, ADMImage *mask, 
+		ADMImage *prv, ADMImage *src, ADMImage *nxt)
+{
+	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
+	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
+	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
+	int prv_pitchY2 = prv_pitchY&lt;&lt;1;
+	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
+	int prv_pitchUV2 = prv_pitchUV&lt;&lt;1;
+	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
+	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
+	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
+	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
+	int src_pitchY2 = src_pitchY&lt;&lt;1;
+	int src_pitchUV2 = src_pitchUV&lt;&lt;1;
+	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
+	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
+	int HeightY = src-&gt;GetHeight(PLANAR_Y);
+	int HeightUV = src-&gt;GetHeight(PLANAR_V);
+	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
+	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
+	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
+	int nxt_pitchY2 = nxt_pitchY&lt;&lt;1;
+	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
+	int nxt_pitchUV2 = nxt_pitchUV&lt;&lt;1;
+	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
+	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
+	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
+	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
+	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
+	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	const unsigned char *srcppY = srcpY - src_pitchY;
+	const unsigned char *srcppU = srcpU - src_pitchUV;
+	const unsigned char *srcppV = srcpV - src_pitchUV;
+	const unsigned char *srcpppY = srcppY - src_pitchY2;
+	const unsigned char *srcpppU = srcppU - src_pitchUV2;
+	const unsigned char *srcpppV = srcppV - src_pitchUV2;
+	const unsigned char *srcpnY = srcpY + src_pitchY;
+	const unsigned char *srcpnU = srcpU + src_pitchUV;
+	const unsigned char *srcpnV = srcpV + src_pitchUV;
+	const unsigned char *srcpnnY = srcpnY + src_pitchY2;
+	const unsigned char *srcpnnU = srcpnU + src_pitchUV2;
+	const unsigned char *srcpnnV = srcpnV + src_pitchUV2;
+	const unsigned char *kercY, *kerpY, *kerppY, *kernY, *kernnY;
+	const unsigned char *kercU, *kerpU, *kerppU, *kernU, *kernnU;
+	const unsigned char *kercV, *kerpV, *kerppV, *kernV, *kernnV;
+	int ker_pitchY, ker_pitchUV, x, y, temp;
+	if (accumP &lt;= accumN)
+	{
+		if (PRM(field)^PRM(order))
+		{
+			ker_pitchY = src_pitchY;
+			ker_pitchUV = src_pitchUV;
+			kerppY = srcpY - (src_pitchY2&lt;&lt;1);
+			kerppU = srcpU - (src_pitchUV2&lt;&lt;1);
+			kerppV = srcpV - (src_pitchUV2&lt;&lt;1);
+			kerpY = srcpY - src_pitchY2;
+			kerpU = srcpU - src_pitchUV2;
+			kerpV = srcpV - src_pitchUV2;
+			kercY = srcpY;
+			kercU = srcpU;
+			kercV = srcpV;
+			kernY = srcpY + src_pitchY2;
+			kernU = srcpU + src_pitchUV2;
+			kernV = srcpV + src_pitchUV2;
+			kernnY = srcpY + (src_pitchY2&lt;&lt;1);
+			kernnU = srcpU + (src_pitchUV2&lt;&lt;1);
+			kernnV = srcpV + (src_pitchUV2&lt;&lt;1);
+		}
+		else
+		{
+			ker_pitchY = prv_pitchY;
+			ker_pitchUV = prv_pitchUV;
+			kerppY = prvpY - (prv_pitchY2&lt;&lt;1);
+			kerppU = prvpU - (prv_pitchUV2&lt;&lt;1);
+			kerppV = prvpV - (prv_pitchUV2&lt;&lt;1);
+			kerpY = prvpY - prv_pitchY2;
+			kerpU = prvpU - prv_pitchUV2;
+			kerpV = prvpV - prv_pitchUV2;
+			kercY = prvpY;
+			kercU = prvpU;
+			kercV = prvpV;
+			kernY = prvpY + prv_pitchY2;
+			kernU = prvpU + prv_pitchUV2;
+			kernV = prvpV + prv_pitchUV2;
+			kernnY = prvpY + (prv_pitchY2&lt;&lt;1);
+			kernnU = prvpU + (prv_pitchUV2&lt;&lt;1);
+			kernnV = prvpV + (prv_pitchUV2&lt;&lt;1);
+		}
+	}
+	else
+	{
+		if (PRM(field)^PRM(order))
+		{
+			ker_pitchY = nxt_pitchY;
+			ker_pitchUV = nxt_pitchUV;
+			kerppY = nxtpY - (nxt_pitchY2&lt;&lt;1);
+			kerppU = nxtpU - (nxt_pitchUV2&lt;&lt;1);
+			kerppV = nxtpV - (nxt_pitchUV2&lt;&lt;1);
+			kerpY = nxtpY - nxt_pitchY2;
+			kerpU = nxtpU - nxt_pitchUV2;
+			kerpV = nxtpV - nxt_pitchUV2;
+			kercY = nxtpY;
+			kercU = nxtpU;
+			kercV = nxtpV;
+			kernY = nxtpY + nxt_pitchY2;
+			kernU = nxtpU + nxt_pitchUV2;
+			kernV = nxtpV + nxt_pitchUV2;
+			kernnY = nxtpY + (nxt_pitchY2&lt;&lt;1);
+			kernnU = nxtpU + (nxt_pitchUV2&lt;&lt;1);
+			kernnV = nxtpV + (nxt_pitchUV2&lt;&lt;1);
+		}
+		else
+		{
+			ker_pitchY = src_pitchY;
+			ker_pitchUV = src_pitchUV;
+			kerppY = srcpY - (src_pitchY2&lt;&lt;1);
+			kerppU = srcpU - (src_pitchUV2&lt;&lt;1);
+			kerppV = srcpV - (src_pitchUV2&lt;&lt;1);
+			kerpY = srcpY - src_pitchY2;
+			kerpU = srcpU - src_pitchUV2;
+			kerpV = srcpV - src_pitchUV2;
+			kercY = srcpY;
+			kercU = srcpU;
+			kercV = srcpV;
+			kernY = srcpY + src_pitchY2;
+			kernU = srcpU + src_pitchUV2;
+			kernV = srcpV + src_pitchUV2;
+			kernnY = srcpY + (src_pitchY2&lt;&lt;1);
+			kernnU = srcpU + (src_pitchUV2&lt;&lt;1);
+			kernnV = srcpV + (src_pitchUV2&lt;&lt;1);
+		}
+	}
+	for (y=0; y&lt;HeightY; ++y)
+	{
+		for (x=0; x&lt;WidthY; ++x)
+		{
+			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = srcpY[x];
+			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = prvpY[x];
+			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = nxtpY[x];
+			else if (maskpY[x] == 40) dstpY[x] = (srcpY[x]+nxtpY[x]+1)&gt;&gt;1;
+			else if (maskpY[x] == 50) dstpY[x] = (srcpY[x]+prvpY[x]+1)&gt;&gt;1;
+			else if (maskpY[x] == 60)
+			{
+				if (sharp &amp;&amp; y&gt;3 &amp;&amp; y&lt;HeightY-4)
+				{
+					temp = (int)((0.526*(srcppY[x]+srcpnY[x]) + 
+								  0.170*(kercY[x]) - 
+								  0.116*(kerpY[x]+kernY[x]) - 
+								  0.026*(srcpppY[x]+srcpnnY[x]) + 
+								  0.031*(kerppY[x] + kernnY[x])) + 0.5f);
+					if (temp &gt; 255) dstpY[x] = 255;
+					else if (temp &lt; 0) dstpY[x] = 0;
+					else dstpY[x] = temp;
+				}
+				else if (y&gt;1 &amp;&amp; y&lt;HeightY-2)
+				{
+					temp = (((srcppY[x]+srcpnY[x])&lt;&lt;3)+
+							(kercY[x]&lt;&lt;1)-(kerpY[x]+kernY[x])+8) &gt;&gt; 4;
+					if (temp &gt; 255) dstpY[x] = 255;
+					else if (temp &lt; 0) dstpY[x] = 0;
+					else dstpY[x] = temp;
+				}
+				else dstpY[x] = (srcpnY[x]+srcppY[x]+1)&gt;&gt;1;
+			}
+		}
+		prvpY += prv_pitchY;
+		srcpppY += src_pitchY;
+		srcppY += src_pitchY;
+		srcpY += src_pitchY;
+		srcpnY += src_pitchY;
+		srcpnnY += src_pitchY;
+		kerppY += ker_pitchY;
+		kerpY += ker_pitchY;
+		kercY += ker_pitchY;
+		kernY += ker_pitchY;
+		kernnY += ker_pitchY;
+		nxtpY += nxt_pitchY;
+		maskpY += mask_pitchY;
+		dstpY += dst_pitchY;
+	}
+	for (y=0; y&lt;HeightUV; ++y)
+	{
+		for (x=0; x&lt;WidthUV; ++x)
+		{
+			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = srcpU[x];
+			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = prvpU[x];
+			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = nxtpU[x];
+			else if (maskpU[x] == 40) dstpU[x] = (srcpU[x]+nxtpU[x]+1)&gt;&gt;1;
+			else if (maskpU[x] == 50) dstpU[x] = (srcpU[x]+prvpU[x]+1)&gt;&gt;1;
+			else if (maskpU[x] == 60)
+			{
+				if (sharp &amp;&amp; y&gt;3 &amp;&amp; y&lt;HeightUV-4)
+				{
+					temp = (int)((0.526*(srcppU[x]+srcpnU[x]) + 
+								  0.170*(kercU[x]) - 
+								  0.116*(kerpU[x]+kernU[x]) - 
+								  0.026*(srcpppU[x]+srcpnnU[x]) + 
+								  0.031*(kerppU[x] + kernnU[x])) + 0.5f);
+					if (temp &gt; 255) dstpU[x] = 255;
+					else if (temp &lt; 0) dstpU[x] = 0;
+					else dstpU[x] = temp;
+				}
+				else if (y&gt;1 &amp;&amp; y&lt;HeightUV-2)
+				{
+					temp = (((srcppU[x]+srcpnU[x])&lt;&lt;3)+
+							(kercU[x]&lt;&lt;1)-(kerpU[x]+kernU[x])+8) &gt;&gt; 4;
+					if (temp &gt; 255) dstpU[x] = 255;
+					else if (temp &lt; 0) dstpU[x] = 0;
+					else dstpU[x] = temp;
+				}
+				else dstpU[x] = (srcpnU[x]+srcppU[x]+1)&gt;&gt;1;
+			}
+			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = srcpV[x];
+			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = prvpV[x];
+			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = nxtpV[x];
+			else if (maskpV[x] == 40) dstpV[x] = (srcpV[x]+nxtpV[x]+1)&gt;&gt;1;
+			else if (maskpV[x] == 50) dstpV[x] = (srcpV[x]+prvpV[x]+1)&gt;&gt;1;
+			else if (maskpV[x] == 60)
+			{
+				if (sharp &amp;&amp; y&gt;3 &amp;&amp; y&lt;HeightUV-4)
+				{
+					temp = (int)((0.526*(srcppV[x]+srcpnV[x]) + 
+								  0.170*(kercV[x]) - 
+								  0.116*(kerpV[x]+kernV[x]) - 
+								  0.026*(srcpppV[x]+srcpnnV[x]) + 
+								  0.031*(kerppV[x] + kernnV[x])) + 0.5f);
+					if (temp &gt; 255) dstpV[x] = 255;
+					else if (temp &lt; 0) dstpV[x] = 0;
+					else dstpV[x] = temp;
+				}
+				else if (y&gt;1 &amp;&amp; y&lt;HeightUV-2)
+				{
+					temp = (((srcppV[x]+srcpnV[x])&lt;&lt;3)+
+							(kercV[x]&lt;&lt;1)-(kerpV[x]+kernV[x])+8) &gt;&gt; 4;
+					if (temp &gt; 255) dstpV[x] = 255;
+					else if (temp &lt; 0) dstpV[x] = 0;
+					else dstpV[x] = temp;
+				}
+				else dstpV[x] = (srcpnV[x]+srcppV[x]+1)&gt;&gt;1;
+			}
+
+		}
+		prvpU += prv_pitchUV;
+		prvpV += prv_pitchUV;
+		srcpppU += src_pitchUV;
+		srcpppV += src_pitchUV;
+		srcppU += src_pitchUV;
+		srcppV += src_pitchUV;
+		srcpU += src_pitchUV;
+		srcpV += src_pitchUV;
+		srcpnU += src_pitchUV;
+		srcpnV += src_pitchUV;
+		srcpnnU += src_pitchUV;
+		srcpnnV += src_pitchUV;
+		kerppU += ker_pitchUV;
+		kerppV += ker_pitchUV;
+		kerpU += ker_pitchUV;
+		kerpV += ker_pitchUV;
+		kercU += ker_pitchUV;
+		kercV += ker_pitchUV;
+		kernU += ker_pitchUV;
+		kernV += ker_pitchUV;
+		kernnU += ker_pitchUV;
+		kernnV += ker_pitchUV;
+		nxtpU += nxt_pitchUV;
+		nxtpV += nxt_pitchUV;
+		maskpU += mask_pitchUV;
+		maskpV += mask_pitchUV;
+		dstpU += dst_pitchUV;
+		dstpV += dst_pitchUV;
+	}
+}
+
+void vidTDeint::smartELADeintYV12(ADMImage *dst, ADMImage *mask, 
+		ADMImage *prv, ADMImage *src, ADMImage *nxt)
+{
+	const unsigned char *prvpY = prv-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *prvpV = prv-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *prvpU = prv-&gt;GetReadPtr(PLANAR_U);
+	int prv_pitchY = prv-&gt;GetPitch(PLANAR_Y);
+	int prv_pitchUV = prv-&gt;GetPitch(PLANAR_V);
+	const unsigned char *srcpY = src-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *srcpV = src-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *srcpU = src-&gt;GetReadPtr(PLANAR_U);
+	int src_pitchY = src-&gt;GetPitch(PLANAR_Y);
+	int src_pitchY2 = src_pitchY&lt;&lt;1;
+	int src_pitchUV = src-&gt;GetPitch(PLANAR_V);
+	int src_pitchUV2 = src_pitchUV&lt;&lt;1;
+	int WidthY = src-&gt;GetRowSize(PLANAR_Y);
+	int WidthUV = src-&gt;GetRowSize(PLANAR_V);
+	int HeightY = src-&gt;GetHeight(PLANAR_Y);
+	int HeightUV = src-&gt;GetHeight(PLANAR_V);
+	const unsigned char *nxtpY = nxt-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *nxtpV = nxt-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *nxtpU = nxt-&gt;GetReadPtr(PLANAR_U);
+	int nxt_pitchY = nxt-&gt;GetPitch(PLANAR_Y);
+	int nxt_pitchUV = nxt-&gt;GetPitch(PLANAR_V);
+	unsigned char *dstpY = dst-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *dstpV = dst-&gt;GetWritePtr(PLANAR_V);
+	unsigned char *dstpU = dst-&gt;GetWritePtr(PLANAR_U);
+	int dst_pitchY = dst-&gt;GetPitch(PLANAR_Y);
+	int dst_pitchUV = dst-&gt;GetPitch(PLANAR_V);
+	const unsigned char *maskpY = mask-&gt;GetReadPtr(PLANAR_Y);
+	const unsigned char *maskpV = mask-&gt;GetReadPtr(PLANAR_V);
+	const unsigned char *maskpU = mask-&gt;GetReadPtr(PLANAR_U);
+	int mask_pitchY = mask-&gt;GetPitch(PLANAR_Y);
+	int mask_pitchUV = mask-&gt;GetPitch(PLANAR_V);
+	const unsigned char *srcppY = srcpY - src_pitchY;
+	const unsigned char *srcpppY = srcppY - src_pitchY2;
+	const unsigned char *srcpnY = srcpY + src_pitchY;
+	const unsigned char *srcpnnY = srcpnY + src_pitchY2;
+	const unsigned char *srcppV = srcpV - src_pitchUV;
+	const unsigned char *srcpppV = srcppV - src_pitchUV2;
+	const unsigned char *srcpnV = srcpV + src_pitchUV;
+	const unsigned char *srcpnnV = srcpnV + src_pitchUV2;
+	const unsigned char *srcppU = srcpU - src_pitchUV;
+	const unsigned char *srcpppU = srcppU - src_pitchUV2;
+	const unsigned char *srcpnU = srcpU + src_pitchUV;
+	const unsigned char *srcpnnU = srcpnU + src_pitchUV2;
+	int x, y, Iy1, Iy2, Iye, Ix1, Ix2, edgeS1, edgeS2;
+	int sum, sumsq, temp, temp1, temp2, minN, maxN;
+	double dir1, dir2, dir, dirF;
+	for (y=0; y&lt;HeightY; ++y)
+	{
+		for (x=0; x&lt;WidthY; ++x)
+		{
+			if (maskpY[x] == 10 || maskpY[x] == 110) dstpY[x] = srcpY[x];
+			else if (maskpY[x] == 20 || maskpY[x] == 120) dstpY[x] = prvpY[x];
+			else if (maskpY[x] == 30 || maskpY[x] == 130) dstpY[x] = nxtpY[x];
+			else if (maskpY[x] == 40) dstpY[x] = (srcpY[x]+nxtpY[x]+1)&gt;&gt;1;
+			else if (maskpY[x] == 50) dstpY[x] = (srcpY[x]+prvpY[x]+1)&gt;&gt;1;
+			else if (maskpY[x] == 60)
+			{
+				if (y&gt;2 &amp;&amp; y&lt;HeightY-3 &amp;&amp; x&gt;3 &amp;&amp; x&lt;WidthY-4)
+				{
+					Iy1 = srcpppY[x-1]+srcpppY[x]+srcpppY[x]+srcpppY[x+1]-srcpnY[x-1]-srcpnY[x]-srcpnY[x]-srcpnY[x+1];
+					Iy2 = srcppY[x-1]+srcppY[x]+srcppY[x]+srcppY[x+1]-srcpnnY[x-1]-srcpnnY[x]-srcpnnY[x]-srcpnnY[x+1];
+					Ix1 = srcpppY[x+1]+srcppY[x+1]+srcppY[x+1]+srcpnY[x+1]-srcpppY[x-1]-srcppY[x-1]-srcppY[x-1]-srcpnY[x-1];
+					Ix2 = srcppY[x+1]+srcpnY[x+1]+srcpnY[x+1]+srcpnnY[x+1]-srcppY[x-1]-srcpnY[x-1]-srcpnY[x-1]-srcpnnY[x-1];
+					edgeS1 = Ix1*Ix1 + Iy1*Iy1;
+					edgeS2 = Ix2*Ix2 + Iy2*Iy2;
+					if (edgeS1 &lt; 1600 &amp;&amp; edgeS2 &lt; 1600) 
+					{
+						dstpY[x] = (srcppY[x]+srcpnY[x]+1)&gt;&gt;1;
+						continue;
+					}
+					if (abs(srcppY[x]-srcpnY[x]) &lt; 10 &amp;&amp; (edgeS1 &lt; 1600 || edgeS2 &lt; 1600))
+					{
+						dstpY[x] = (srcppY[x]+srcpnY[x]+1)&gt;&gt;1;
+						continue;
+					}
+					sum = srcppY[x-1] + srcppY[x] + srcppY[x+1] + srcpnY[x-1] + srcpnY[x] + srcpnY[x+1];
+					sumsq = srcppY[x-1]*srcppY[x-1] + srcppY[x]*srcppY[x] + srcppY[x+1]*srcppY[x+1] +
+							srcpnY[x-1]*srcpnY[x-1] + srcpnY[x]*srcpnY[x] + srcpnY[x+1]*srcpnY[x+1];
+					if ((6*sumsq - sum*sum) &lt; 432)
+					{
+						dstpY[x] = (srcppY[x]+srcpnY[x]+1)&gt;&gt;1;
+						continue;
+					}
+					if (Ix1 == 0) dir1 = 3.1415926;
+					else
+					{
+						dir1 = atan(Iy1/(Ix1*2.0f)) + 1.5707963;
+						if (Iy1 &gt;= 0) { if (Ix1 &lt; 0) dir1 += 3.1415927; }
+						else { if (Ix1 &gt;= 0) dir1 += 3.1415927; }
+						if (dir1 &gt;= 3.1415927) dir1 -= 3.1415927;
+					}
+					if (Ix2 == 0) dir2 = 3.1415926;
+					else 
+					{
+						dir2 = atan(Iy2/(Ix2*2.0f)) + 1.5707963;
+						if (Iy2 &gt;= 0) { if (Ix2 &lt; 0) dir2 += 3.1415927; }
+						else { if (Ix2 &gt;= 0) dir2 += 3.1415927; }
+						if (dir2 &gt;= 3.1415927) dir2 -= 3.1415927;
+					}
+					if (fabs(dir1-dir2) &lt; 0.5)
+					{
+						if (edgeS1 &gt;= 3600 &amp;&amp; edgeS2 &gt;= 3600) dir = (dir1 + dir2) * 0.5f;
+						else dir = edgeS1 &gt;= edgeS2 ? dir1 : dir2;
+					}
+					else
+					{
+						if (edgeS1 &gt;= 5000 &amp;&amp; edgeS2 &gt;= 5000)
+						{
+							Iye = srcppY[x-1]+srcppY[x]+srcppY[x]+srcppY[x+1]-srcpnY[x-1]-srcpnY[x]-srcpnY[x]-srcpnY[x+1];
+							if ((Iy1*Iye &gt; 0) &amp;&amp; (Iy2*Iye &lt; 0)) dir = dir1;
+							else if ((Iy1*Iye &lt; 0) &amp;&amp; (Iy2*Iye &gt; 0)) dir = dir2;
+							else
+							{
+								if (abs(Iye-Iy1) &lt;= abs(Iye-Iy2)) dir = dir1;
+								else dir = dir2;
+							}
+						}
+						else dir = edgeS1 &gt;= edgeS2 ? dir1 : dir2;
+					}
+					dirF = 0.5f/tan(dir);
+					if (dirF &gt;= 0.0f)
+					{
+						if (dirF &gt;= 0.5f)
+						{
+							if (dirF &gt;= 1.0f)
+							{
+								if (dirF &gt;= 1.5f)
+								{
+									if (dirF &gt;= 2.0f)
+									{
+										if (dirF &lt;= 2.50f)
+										{
+											temp1 = srcppY[x+4];
+											temp2 = srcpnY[x-4];
+											temp = (srcppY[x+4]+srcpnY[x-4]+1)&gt;&gt;1;
+										}
+										else 
+										{
+											temp1 = temp2 = srcpnY[x];
+											temp = cubicInt(srcpppY[x],srcppY[x],srcpnY[x],srcpnnY[x]);
+										}
+									}
+									else 
+									{
+										temp1 = (int)((dirF-1.5f)*(srcppY[x+4]) + (2.0f-dirF)*(srcppY[x+3]) + 0.5f);
+										temp2 = (int)((dirF-1.5f)*(srcpnY[x-4]) + (2.0f-dirF)*(srcpnY[x-3]) + 0.5f);
+										temp = (int)((dirF-1.5f)*(srcppY[x+4]+srcpnY[x-4]) + (2.0f-dirF)*(srcppY[x+3]+srcpnY[x-3]) + 0.5f);
+									}
+								}
+								else 
+								{
+									temp1 = (int)((dirF-1.0f)*(srcppY[x+3]) + (1.5f-dirF)*(srcppY[x+2]) + 0.5f);
+									temp2 = (int)((dirF-1.0f)*(srcpnY[x-3]) + (1.5f-dirF)*(srcpnY[x-2]) + 0.5f);
+									temp = (int)((dirF-1.0f)*(srcppY[x+3]+srcpnY[x-3]) + (1.5f-dirF)*(srcppY[x+2]+srcpnY[x-2]) + 0.5f);
+								}
+							}
+							else 
+							{
+								temp1 = (int)((dirF-0.5f)*(srcppY[x+2]) + (1.0f-dirF)*(srcppY[x+1]) + 0.5f);
+								temp2 = (int)((dirF-0.5f)*(srcpnY[x-2]) + (1.0f-dirF)*(srcpnY[x-1]) + 0.5f);
+								temp = (int)((dirF-0.5f)*(srcppY[x+2]+srcpnY[x-2]) + (1.0f-dirF)*(srcppY[x+1]+srcpnY[x-1]) + 0.5f);
+							}
+						}
+						else 
+						{
+							temp1 = (int)(dirF*(srcppY[x+1]) + (0.5f-dirF)*(srcppY[x]) + 0.5f);
+							temp2 = (int)(dirF*(srcpnY[x-1]) + (0.5f-dirF)*(srcpnY[x]) + 0.5f);
+							temp = (int)(dirF*(srcppY[x+1]+srcpnY[x-1]) + (0.5f-dirF)*(srcppY[x]+srcpnY[x]) + 0.5f);
+						}
+					}
+					else
+					{
+						if (dirF &lt;= -0.5f)
+						{
+							if (dirF &lt;= -1.0f)
+							{
+								if (dirF &lt;= -1.5f)
+								{
+									if (dirF &lt;= -2.0f)
+									{
+										if (dirF &gt;= -2.50f) 
+										{
+											temp1 = srcppY[x-4];
+											temp2 = srcpnY[x+4];
+											temp = (srcppY[x-4]+srcpnY[x+4]+1)&gt;&gt;1;
+										}
+										else 
+										{
+											temp1 = temp2 = srcpnY[x];
+											temp = cubicInt(srcpppY[x],srcppY[x],srcpnY[x],srcpnnY[x]);
+										}
+									}
+									else
+									{
+										temp1 = (int)((-dirF-1.5f)*(srcppY[x-4]) + (2.0f+dirF)*(srcppY[x-3]) + 0.5f);
+										temp2 = (int)((-dirF-1.5f)*(srcpnY[x+4]) + (2.0f+dirF)*(srcpnY[x+3]) + 0.5f);
+										temp = (int)((-dirF-1.5f)*(srcppY[x-4]+srcpnY[x+4]) + (2.0f+dirF)*(srcppY[x-3]+srcpnY[x+3]) + 0.5f);
+									}
+								}
+								else 
+								{
+									temp1 = (int)((-dirF-1.0f)*(srcppY[x-3]) + (1.5f+dirF)*(srcppY[x-2]) + 0.5f);
+									temp2 = (int)((-dirF-1.0f)*(srcpnY[x+3]) + (1.5f+dirF)*(srcpnY[x+2]) + 0.5f);
+									temp = (int)((-dirF-1.0f)*(srcppY[x-3]+srcpnY[x+3]) + (1.5f+dirF)*(srcppY[x-2]+srcpnY[x+2]) + 0.5f);
+								}
+							}
+							else 
+							{
+								temp1 = (int)((-dirF-0.5f)*(srcppY[x-2]) + (1.0f+dirF)*(srcppY[x-1]) + 0.5f);
+								temp2 = (int)((-dirF-0.5f)*(srcpnY[x+2]) + (1.0f+dirF)*(srcpnY[x+1]) + 0.5f);
+								temp = (int)((-dirF-0.5f)*(srcppY[x-2]+srcpnY[x+2]) + (1.0f+dirF)*(srcppY[x-1]+srcpnY[x+1]) + 0.5f);
+							}
+						}
+						else 
+						{
+							temp1 = (int)((-dirF)*(srcppY[x-1]) + (0.5f+dirF)*(srcppY[x]) + 0.5f);
+							temp2 = (int)((-dirF)*(srcpnY[x+1]) + (0.5f+dirF)*(srcpnY[x]) + 0.5f);
+							temp = (int)((-dirF)*(srcppY[x-1]+srcpnY[x+1]) + (0.5f+dirF)*(srcppY[x]+srcpnY[x]) + 0.5f);
+						}
+					}
+					maxN = max(srcppY[x],srcpnY[x]) + 25;
+					minN = min(srcppY[x],srcpnY[x]) - 25;
+					if (abs(temp1-temp2) &gt; 20 || abs(srcppY[x]+srcpnY[x]-temp-temp) &gt; 60 || temp &lt; minN || temp &gt; maxN)
+					{
+						temp = cubicInt(srcpppY[x],srcppY[x],srcpnY[x],srcpnnY[x]);
+					}
+					if (temp &gt; 255) temp = 255;
+					else if (temp &lt; 0) temp = 0;
+					dstpY[x] = temp;
+				}
+				else
+				{
+					if (y&lt;3 || y&gt;HeightY-4) dstpY[x] = (srcpnY[x]+srcppY[x]+1)&gt;&gt;1;
+					else dstpY[x] = cubicInt(srcpppY[x],srcppY[x],srcpnY[x],srcpnnY[x]);
+				}
+			}
+		}
+		prvpY += prv_pitchY;
+		srcpppY += src_pitchY;
+		srcppY += src_pitchY;
+		srcpY += src_pitchY;
+		srcpnY += src_pitchY;
+		srcpnnY += src_pitchY;
+		nxtpY += nxt_pitchY;
+		maskpY += mask_pitchY;
+		dstpY += dst_pitchY;
+	}
+	for (y=0; y&lt;HeightUV; ++y)
+	{
+		for (x=0; x&lt;WidthUV; ++x)
+		{
+			if (maskpV[x] == 10 || maskpV[x] == 110) dstpV[x] = srcpV[x];
+			else if (maskpV[x] == 20 || maskpV[x] == 120) dstpV[x] = prvpV[x];
+			else if (maskpV[x] == 30 || maskpV[x] == 130) dstpV[x] = nxtpV[x];
+			else if (maskpV[x] == 40) dstpV[x] = (srcpV[x]+nxtpV[x]+1)&gt;&gt;1;
+			else if (maskpV[x] == 50) dstpV[x] = (srcpV[x]+prvpV[x]+1)&gt;&gt;1;
+			else if (maskpV[x] == 60)
+			{
+				if (y&lt;3 || y&gt;HeightUV-4) dstpV[x] = (srcpnV[x]+srcppV[x]+1)&gt;&gt;1;
+				else dstpV[x] = cubicInt(srcpppV[x],srcppV[x],srcpnV[x],srcpnnV[x]);
+			}
+			if (maskpU[x] == 10 || maskpU[x] == 110) dstpU[x] = srcpU[x];
+			else if (maskpU[x] == 20 || maskpU[x] == 120) dstpU[x] = prvpU[x];
+			else if (maskpU[x] == 30 || maskpU[x] == 130) dstpU[x] = nxtpU[x];
+			else if (maskpU[x] == 40) dstpU[x] = (srcpU[x]+nxtpU[x]+1)&gt;&gt;1;
+			else if (maskpU[x] == 50) dstpU[x] = (srcpU[x]+prvpU[x]+1)&gt;&gt;1;
+			else if (maskpU[x] == 60)
+			{
+				if (y&lt;3 || y&gt;HeightUV-4) dstpU[x] = (srcpnU[x]+srcppU[x]+1)&gt;&gt;1;
+				else dstpU[x] = cubicInt(srcpppU[x],srcppU[x],srcpnU[x],srcpnnU[x]);
+			}
+		}
+		prvpV += prv_pitchUV;
+		prvpU += prv_pitchUV;
+		srcpppV += src_pitchUV;
+		srcppV += src_pitchUV;
+		srcpV += src_pitchUV;
+		srcpnV += src_pitchUV;
+		srcpnnV += src_pitchUV;
+		srcpppU += src_pitchUV;
+		srcppU += src_pitchUV;
+		srcpU += src_pitchUV;
+		srcpnU += src_pitchUV;
+		srcpnnU += src_pitchUV;
+		nxtpV += nxt_pitchUV;
+		nxtpU += nxt_pitchUV;
+		maskpV += mask_pitchUV;
+		maskpU += mask_pitchUV;
+		dstpV += dst_pitchUV;
+		dstpU += dst_pitchUV;
+	}
+}
+
+void vidTDeint::createWeaveFrameYV12(ADMImage *dst, ADMImage *prv, 
+		ADMImage *src, ADMImage *nxt)
+{
+	int b;
+	ADM_PLANE plane;
+	for (b=0; b&lt;3; ++b)
+	{
+		if (b == 0) plane = PLANAR_Y;
+		else if (b == 1) plane = PLANAR_V;
+		else plane = PLANAR_U;
+		if (PRM(field)^PRM(order))
+		{
+			if (accumP &lt;= accumN)
+			{
+				BitBlit(dst-&gt;GetWritePtr(plane), dst-&gt;GetPitch(plane), src-&gt;GetReadPtr(plane), 
+					src-&gt;GetPitch(plane), src-&gt;GetRowSize(plane), src-&gt;GetHeight(plane));
+			}
+			else
+			{
+				BitBlit(dst-&gt;GetWritePtr(plane)+(1-PRM(field))*dst-&gt;GetPitch(plane), dst-&gt;GetPitch(plane)&lt;&lt;1,
+					src-&gt;GetReadPtr(plane)+(1-PRM(field))*src-&gt;GetPitch(plane), src-&gt;GetPitch(plane)&lt;&lt;1, 
+					src-&gt;GetRowSize(plane), src-&gt;GetHeight(plane)&gt;&gt;1);
+				BitBlit(dst-&gt;GetWritePtr(plane)+PRM(field)*dst-&gt;GetPitch(plane), dst-&gt;GetPitch(plane)&lt;&lt;1, 
+					nxt-&gt;GetReadPtr(plane)+PRM(field)*nxt-&gt;GetPitch(plane), nxt-&gt;GetPitch(plane)&lt;&lt;1, nxt-&gt;GetRowSize(plane),
+					nxt-&gt;GetHeight(plane)&gt;&gt;1);
+			}
+		}
+		else
+		{
+			if (accumN &lt;= accumP)
+			{
+				BitBlit(dst-&gt;GetWritePtr(plane), dst-&gt;GetPitch(plane), src-&gt;GetReadPtr(plane), 
+					src-&gt;GetPitch(plane), src-&gt;GetRowSize(plane), src-&gt;GetHeight(plane));
+			}
+			else
+			{
+				BitBlit(dst-&gt;GetWritePtr(plane)+(1-PRM(field))*dst-&gt;GetPitch(plane), dst-&gt;GetPitch(plane)&lt;&lt;1,
+					src-&gt;GetReadPtr(plane)+(1-PRM(field))*src-&gt;GetPitch(plane), src-&gt;GetPitch(plane)&lt;&lt;1, 
+					src-&gt;GetRowSize(plane), src-&gt;GetHeight(plane)&gt;&gt;1);
+				BitBlit(dst-&gt;GetWritePtr(plane)+PRM(field)*dst-&gt;GetPitch(plane), dst-&gt;GetPitch(plane)&lt;&lt;1, 
+					prv-&gt;GetReadPtr(plane)+PRM(field)*prv-&gt;GetPitch(plane), prv-&gt;GetPitch(plane)&lt;&lt;1, prv-&gt;GetRowSize(plane),
+					prv-&gt;GetHeight(plane)&gt;&gt;1);
+			}
+		}
+	}
+}
+
+//*********************************************************
+//*********************************************************
+//*********************************************************
+//*********************************************************
+int vidTDeint::getHint(ADMImage *src, unsigned int &amp;storeHint, int &amp;hintfield)
+{
+	hintfield = -1;
+	const unsigned char *p = YPLANE(src); //src-&gt;GetReadPtr(PLANAR_Y);
+	unsigned int i, magic_number = 0, hint = 0;
+	storeHint = 0xFFFFFFFF;
+	for (i=0; i&lt;32; ++i)
+	{
+		magic_number |= ((*p++ &amp; 1) &lt;&lt; i);
+	}
+	if (magic_number != 0xdeadbeef &amp;&amp; magic_number != 0xdeadfeed) return -1;
+	for (i=0; i&lt;32; ++i)
+	{
+		hint |= ((*p++ &amp; 1) &lt;&lt; i);
+	}
+	if (magic_number == 0xdeadbeef &amp;&amp; hint&amp;0xFFFFFF00) return -1;
+	if (magic_number == 0xdeadfeed &amp;&amp; hint&amp;0xFFFFFF00) return -1;
+	storeHint = hint;
+	if (magic_number == 0xdeadbeef)
+	{
+		storeHint |= 0x00100000;
+		if (hint&amp;0x00000001) return 0;
+		return 1;
+	}
+	if (hint&amp;0x00000008) hintfield = 1;
+	else hintfield = 0;
+	if (hint&amp;0x00000010) return 1;
+	return 0;
+}
+
+void vidTDeint::putHint(ADMImage *src, unsigned int hint, int fieldt)
+{
+	int type = hint&amp;0x00100000 ? 0 : 1;
+	hint &amp;= ~0x00100000;
+	if (hint&amp;0xFFFFFF00) return;
+	if (type == 1)
+	{
+		hint &amp;= 0x00000020;
+		if (fieldt == 1) hint |= 0x0000000E;
+		else hint |= 0x00000005;
+	}
+	unsigned char *p = YPLANE(src); //src-&gt;GetWritePtr(PLANAR_Y);
+	unsigned int i;
+	for (i=0; i&lt;32; ++i)
+	{
+		*p &amp;= ~1;
+		if (type == 0) *p++ |= ((0xdeadbeef &amp; (1 &lt;&lt; i)) &gt;&gt; i);
+		else *p++ |= ((0xdeadfeed &amp; (1 &lt;&lt; i)) &gt;&gt; i);
+	}
+	for (i=0; i&lt;32; ++i)
+	{
+		*p &amp;= ~1;
+		*p++ |= ((hint &amp; (1 &lt;&lt; i)) &gt;&gt; i);
+	}
+}
+/****************************************/
+void vidTDeint::copyFrame(ADMImage *dst,ADMImage *src)
+{
+	int b, stop =  3 ;
+	ADM_PLANE plane[3] = { PLANAR_Y, PLANAR_U, PLANAR_V };
+	for (b=0; b&lt;stop; ++b)
+	{
+		BitBlit(dst-&gt;GetWritePtr(plane[b]),dst-&gt;GetPitch(plane[b]),src-&gt;GetReadPtr(plane[b]),
+			src-&gt;GetPitch(plane[b]),src-&gt;GetRowSize(plane[b]),src-&gt;GetHeight(plane[b]));
+	}
+}
+/****************************************/
+  void vidTDeint::copyForUpsize(ADMImage *dst, ADMImage *src, int np)
+{
+	int b;
+	ADM_PLANE plane[3] = { PLANAR_Y, PLANAR_U, PLANAR_V };
+	for (b=0; b&lt;np; ++b)
+	{
+		BitBlit(dst-&gt;GetWritePtr(plane[b]),dst-&gt;GetPitch(plane[b])*2,src-&gt;GetReadPtr(plane[b]),
+			src-&gt;GetPitch(plane[b]),src-&gt;GetRowSize(plane[b]),src-&gt;GetHeight(plane[b]));
+		BitBlit(dst-&gt;GetWritePtr(plane[b])+(dst-&gt;GetPitch(plane[b])*(dst-&gt;GetHeight(plane[b])-1)),
+			dst-&gt;GetPitch(plane[b]),src-&gt;GetReadPtr(plane[b])+(src-&gt;GetPitch(plane[b])*(src-&gt;GetHeight(plane[b])-1)),
+			src-&gt;GetPitch(plane[b]),src-&gt;GetRowSize(plane[b]),1);
+	}	
+}
+/****************************************/
+void vidTDeint::setMaskForUpsize(ADMImage *msk, int np)
+{
+	unsigned char *maskwc, *maskwn;
+	int msk_pitch, height, width, y;
+	int b;
+	ADM_PLANE plane[3] = { PLANAR_Y, PLANAR_U, PLANAR_V };
+	for (b=0; b&lt;np; ++b)
+	{
+		maskwc = msk-&gt;GetWritePtr(plane[b]);
+		msk_pitch = msk-&gt;GetPitch(plane[b]);
+		height = msk-&gt;GetHeight(plane[b])&gt;&gt;1;
+		width = msk-&gt;GetRowSize(plane[b]);
+		maskwn = maskwc + msk_pitch;
+		msk_pitch &lt;&lt;= 1;
+		if (PRM(field) == 1)
+		{
+			for (y=0; y&lt;height-1; ++y)
+			{
+				memset(maskwc, 10, width);
+				memset(maskwn, 60, width);
+				maskwc += msk_pitch;
+				maskwn += msk_pitch;
+			}
+			memset(maskwc, 10, width);
+			memset(maskwn, 10, width);
+		}
+		else
+		{
+			memset(maskwc, 10, width);
+			memset(maskwn, 10, width);
+			for (y=0; y&lt;height-1; ++y)
+			{
+				maskwc += msk_pitch;
+				maskwn += msk_pitch;
+				memset(maskwc, 60, width);
+				memset(maskwn, 10, width);
+			}
+		}
+	}
+}
+//**************************************
+void vidTDeint::apPostCheck(ADMImage *dst, ADMImage *mask)
+{
+	ADMImage * maskt;
+	if (APType &gt; 0)
+	{
+		maskt = scratch; //_env-&gt;NewVideoFrame(vi);
+		copyFrame(maskt, mask);
+	}
+	unsigned char *maskw;
+	const unsigned char *dstp, *dstpp, *dstpn, *dstppp, *dstpnn, *maskp, *maskpT;
+	int dst_pitch, dst_pitch2, mask_pitch, mask_pitch2, Width, Height;
+	int x, y, b, stop =3 , count = 0, maskp_pitch, maskp_pitch2;
+	int sFirst, sSecond, AP6 = AP*6, moving, neighbors, u, v;
+	int starty, stopy, startx, stopx, inc;
+	ADM_PLANE plane;
+	
+	for (b=0; b&lt;stop; ++b)
+	{
+		if (b == 0) plane = PLANAR_Y;
+		else if (b == 1) plane = PLANAR_U;
+		else plane = PLANAR_V;
+		dstp = dst-&gt;GetReadPtr(plane);
+		dst_pitch = dst-&gt;GetPitch(plane);
+		dst_pitch2 = dst_pitch&lt;&lt;1;
+		Width = dst-&gt;GetRowSize(plane);
+		Height = dst-&gt;GetHeight(plane);
+		dstp += (2-PRM(field))*dst_pitch;
+		dstppp = dstp - dst_pitch2;
+		dstpp = dstp - dst_pitch;
+		dstpn = dstp + dst_pitch;
+		dstpnn = dstp + dst_pitch2;
+		maskw = mask-&gt;GetWritePtr(plane);
+		mask_pitch = mask-&gt;GetPitch(plane);
+		mask_pitch2 = mask_pitch&lt;&lt;1;
+		if (APType &gt; 0)
+		{
+			maskp = maskt-&gt;GetReadPtr(plane);
+			maskp_pitch = maskt-&gt;GetPitch(plane);
+			maskp_pitch2 = maskp_pitch&lt;&lt;1;
+		}
+		maskw += (2-PRM(field))*mask_pitch;
+		y = 2-PRM(field);
+		for (x=0; x&lt;Width; ++x)
+		{
+			if (maskw[x] == 60) { maskw[x] = 10; continue; };
+			maskw[x] = 10;
+			sFirst = dstp[x] - dstpp[x];
+			sSecond = dstp[x] - dstpn[x];
+			if ((sFirst &gt; AP &amp;&amp; sSecond &gt; AP) || (sFirst &lt; -AP &amp;&amp; sSecond &lt; -AP))
+			{
+				sFirst = abs(dstpnn[x]+(dstp[x]&lt;&lt;2)+dstpnn[x]-(3*(dstpp[x]+dstpn[x])));
+				if (sFirst &gt; AP6) 
+				{
+					if (APType &gt; 0)
+					{
+						inc = stop &gt; 1 ? 1 : x&amp;1 ? 4 : 2;
+						startx = x-(inc&lt;&lt;1) &lt; 0 ? x-inc &lt; 0 ? x : x-inc : x-(inc&lt;&lt;1);
+						stopx = x+(inc&lt;&lt;1) &gt; Width-1 ? x+inc &gt; Width-1 ? x : x+inc : x+(inc&lt;&lt;1);
+						starty = y-4 &lt; 0 ? y-2 &lt; 0 ? y : y-2 : y-4;
+						stopy = y+4 &gt; Height-1 ? y+2 &gt; Height-1 ? y : y+2 : y+4;
+						neighbors = moving = 0;
+						maskpT = maskp + starty*maskp_pitch;
+						for (u=starty; u&lt;=stopy; u+=2)
+						{
+							for (v=startx; v&lt;=stopx; v+=inc)
+							{
+								if (maskpT[v] &gt;= 60) ++moving;
+								++neighbors;
+							}
+							maskpT += maskp_pitch2;
+						}
+						if ((APType == 1 &amp;&amp; (moving&lt;&lt;1) &gt;= neighbors) ||
+							(APType == 2 &amp;&amp; (moving*3)  &gt;= neighbors))
+						{
+							maskw[x] = 60;
+							++count;
+						}
+					}
+					else
+					{
+						maskw[x] = 60;
+						++count;
+					}
+				}
+			}
+		}
+		dstppp += dst_pitch2;
+		dstpp += dst_pitch2;
+		dstp += dst_pitch2;
+		dstpn += dst_pitch2;
+		dstpnn += dst_pitch2;
+		maskw += mask_pitch2;
+		y += 2;
+		for (; y&lt;Height-3; y+=2)
+		{
+			starty = y-4 &lt; 0 ? y-2 &lt; 0 ? y : y-2 : y-4;
+			stopy = y+4 &gt; Height-1 ? y+2 &gt; Height-1 ? y : y+2 : y+4;
+			for (x=0; x&lt;Width; ++x)
+			{
+				if (maskw[x] == 60) { maskw[x] = 10; continue; }
+				maskw[x] = 10;
+				sFirst = dstp[x] - dstpp[x];
+				sSecond = dstp[x] - dstpn[x];
+				if ((sFirst &gt; AP &amp;&amp; sSecond &gt; AP) || (sFirst &lt; -AP &amp;&amp; sSecond &lt; -AP))
+				{
+					sFirst = abs(dstppp[x]+(dstp[x]&lt;&lt;2)+dstpnn[x]-(3*(dstpp[x]+dstpn[x])));
+					if (sFirst &gt; AP6) 
+					{ 
+						if (APType &gt; 0)
+						{
+							inc = stop &gt; 1 ? 1 : x&amp;1 ? 4 : 2;
+							startx = x-(inc&lt;&lt;1) &lt; 0 ? x-inc &lt; 0 ? x : x-inc : x-(inc&lt;&lt;1);
+							stopx = x+(inc&lt;&lt;1) &gt; Width-1 ? x+inc &gt; Width-1 ? x : x+inc : x+(inc&lt;&lt;1);
+							neighbors = moving = 0;
+							maskpT = maskp + starty*maskp_pitch;
+							for (u=starty; u&lt;=stopy; u+=2)
+							{
+								for (v=startx; v&lt;=stopx; v+=inc)
+								{
+									if (maskpT[v] &gt;= 60) ++moving;
+									++neighbors;
+								}
+								maskpT += maskp_pitch2;
+							}
+							if ((APType == 1 &amp;&amp; (moving&lt;&lt;1) &gt;= neighbors) ||
+								(APType == 2 &amp;&amp; (moving*3)  &gt;= neighbors))
+							{
+								maskw[x] = 60;
+								++count;
+							}
+						}
+						else
+						{
+							maskw[x] = 60;
+							++count;
+						}
+					}
+				}	
+			}
+			dstppp += dst_pitch2;
+			dstpp += dst_pitch2;
+			dstp += dst_pitch2;
+			dstpn += dst_pitch2;
+			dstpnn += dst_pitch2;
+			maskw += mask_pitch2;
+		}
+		for (x=0; x&lt;Width; ++x)
+		{
+			if (maskw[x] == 60) { maskw[x] = 10; continue; }
+			maskw[x] = 10;
+			sFirst = dstp[x] - dstpp[x];
+			sSecond = dstp[x] - dstpn[x];
+			if ((sFirst &gt; AP &amp;&amp; sSecond &gt; AP) || (sFirst &lt; -AP &amp;&amp; sSecond &lt; -AP))
+			{
+				sFirst = abs(dstppp[x]+(dstp[x]&lt;&lt;2)+dstppp[x]-(3*(dstpp[x]+dstpn[x])));
+				if (sFirst &gt; AP6) 
+				{ 
+					if (APType &gt; 0)
+					{
+						inc = stop &gt; 1 ? 1 : x&amp;1 ? 4 : 2;
+						startx = x-(inc&lt;&lt;1) &lt; 0 ? x-inc &lt; 0 ? x : x-inc : x-(inc&lt;&lt;1);
+						stopx = x+(inc&lt;&lt;1) &gt; Width-1 ? x+inc &gt; Width-1 ? x : x+inc : x+(inc&lt;&lt;1);
+						starty = y-4 &lt; 0 ? y-2 &lt; 0 ? y : y-2 : y-4;
+						stopy = y+4 &gt; Height-1 ? y+2 &gt; Height-1 ? y : y+2 : y+4;
+						neighbors = moving = 0;
+						maskpT = maskp + starty*maskp_pitch;
+						for (u=starty; u&lt;=stopy; u+=2)
+						{
+							for (v=startx; v&lt;=stopx; v+=inc)
+							{
+								if (maskpT[v] &gt;= 60) ++moving;
+								++neighbors;
+							}
+							maskpT += maskp_pitch2;
+						}
+						if ((APType == 1 &amp;&amp; (moving&lt;&lt;1) &gt;= neighbors) ||
+							(APType == 2 &amp;&amp; (moving*3)  &gt;= neighbors))
+						{
+							maskw[x] = 60;
+							++count;
+						}
+					}
+					else
+					{
+						maskw[x] = 60;
+						++count;
+					}
+				}
+			}
+		}
+	}
+	if (count &gt; 0)
+	{
+		//if (vi.IsYV12())
+		{
+			if (type == 0) cubicDeintYV12(dst, mask, dst, dst, dst);
+			else if (type == 1) smartELADeintYV12(dst, mask, dst, dst, dst);
+			else if (type == 2) kernelDeintYV12(dst, mask, dst, dst, dst);
+			else if (type == 3) ELADeintYV12(dst, mask, dst, dst, dst);
+		}
+		
+	}
+}
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/CMakeLists.txt	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/CMakeLists.txt	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_tdeint_SRCS ADM_vidTdeint.cpp  DIA_tdeint.cpp )
+
+ADD_LIBRARY(ADM_vf_tdeint SHARED ${ADM_vf_tdeint_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_tdeint)
+INSTALL_VIDEOFILTER(ADM_vf_tdeint)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/DIA_tdeint.cpp (from rev 4067, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_tdeint.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_tdeint.cpp	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Tdeint/DIA_tdeint.cpp	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,115 @@
+//
+// C++ Implementation: ADM_vidForcedPP
+//
+// Description: 
+//
+//	Force postprocessing assuming constant quant &amp; image type
+//	Uselefull on some badly authored DVD for example
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;DIA_factory.h&quot;
+#include &quot;ADM_vidTDeint_param.h&quot;
+/**
+      \fn DIA_tdeint
+      \brief Dialog for tdeint filter
+*/
+
+uint8_t  DIA_tdeint(TDEINT_PARAM *param)
+{
+         
+         
+diaMenuEntry meField[]={
+  {0,QT_TR_NOOP(&quot;Auto (might not work)&quot;)},
+  {2,QT_TR_NOOP(&quot;Top field first&quot;)},
+  {1,QT_TR_NOOP(&quot;Bottom field first&quot;)}
+};       
+
+diaMenuEntry meInterpolate[]={
+  {0,QT_TR_NOOP(&quot;Auto (might not work)&quot;)},
+  {2,QT_TR_NOOP(&quot;Bottom field (keep top)&quot;)},
+  {1,QT_TR_NOOP(&quot;Top field (keep bottom)&quot;)}
+};       
+
+
+diaMenuEntry meType[]={
+  {0,QT_TR_NOOP(&quot;Cubic interpolation&quot;)},
+  {1,QT_TR_NOOP(&quot;Modified ELA&quot;)},
+  {2,QT_TR_NOOP(&quot;Kernel interpolation&quot;)},
+  {3,QT_TR_NOOP(&quot;Modified ELA-2&quot;)},
+  
+};       
+
+diaMenuEntry meMnt[]={
+  {0,QT_TR_NOOP(&quot;4 fields check&quot;)},
+  {1,QT_TR_NOOP(&quot;5 fields check&quot;)},
+  {2,QT_TR_NOOP(&quot;4 fields check (no avg)&quot;)},
+  {3,QT_TR_NOOP(&quot;5 fields check (no avg)&quot;)},
+  
+};       
+
+
+diaMenuEntry meLink[]={
+  {0,QT_TR_NOOP(&quot;No link&quot;)},
+  {1,QT_TR_NOOP(&quot;Full link&quot;)},
+  {2,QT_TR_NOOP(&quot;Y to UV&quot;)},
+  {3,QT_TR_NOOP(&quot;UV to Y&quot;)}
+};     
+
+diaMenuEntry meAP[]={
+  {0,QT_TR_NOOP(&quot;0&quot;)},
+  {1,QT_TR_NOOP(&quot;1&quot;)},
+  {2,QT_TR_NOOP(&quot;2&quot;)}
+};     
+#define PX(x) &amp;(param-&gt;x)
+      uint32_t order=param-&gt;order+1;
+      uint32_t field=param-&gt;field+1;
+      
+      
+      diaElemMenu     menuFieldOrder(&amp;(order),QT_TR_NOOP(&quot;_Field order:&quot;),3,meField);
+      diaElemMenu     menuInterpolaye(&amp;(field),QT_TR_NOOP(&quot;_Interpolate:&quot;),3,meInterpolate);
+      
+      diaElemMenu     menuType(PX(type),QT_TR_NOOP(&quot;_Type:&quot;),4,meType);
+      diaElemMenu     menuMnt(PX(mtnmode),QT_TR_NOOP(&quot;_MntMode:&quot;),4,meMnt);
+      diaElemMenu     menuLink(PX(link),QT_TR_NOOP(&quot;_Link:&quot;),4,meLink);
+      diaElemMenu     menuAP(PX(APType),QT_TR_NOOP(&quot;_AP type:&quot;),3,meAP);
+
+      // Toggle
+      diaElemToggle    toggleUseChroma(PX(chroma),QT_TR_NOOP(&quot;Use ch_roma to evalute&quot;));
+      diaElemToggle    toggleTryWeave(PX(tryWeave),QT_TR_NOOP(&quot;Try _weave&quot;));
+      diaElemToggle    toggleDenoise(PX(denoise),QT_TR_NOOP(&quot;_Denoise&quot;));
+      diaElemToggle    toggleSharp(PX(sharp),QT_TR_NOOP(&quot;_Sharp&quot;));
+      diaElemToggle    toggleEvaluteAll(PX(full),QT_TR_NOOP(&quot;_Evalute all frames&quot;));
+      
+      // int
+      diaElemUInteger  intMotionLuma(PX(mthreshL),QT_TR_NOOP(&quot;Motion threshold, l_uma:&quot;),0,255);
+      diaElemUInteger  intMotionChroma(PX(mthreshC),QT_TR_NOOP(&quot;Motion threshold, c_hroma:&quot;),0,255);
+      diaElemUInteger  intAreaCombing(PX(cthresh),QT_TR_NOOP(&quot;Area com_bing threshold:&quot;),0,255);
+      diaElemUInteger  intCombed(PX(MI),QT_TR_NOOP(&quot;Combe_d threshold:&quot;),0,255);
+      diaElemInteger   intArtefact(PX(AP),QT_TR_NOOP(&quot;Artefact _protection threshold:&quot;),-1,255);
+      diaElemToggle    intDebug(PX(debug),QT_TR_NOOP(&quot;Debug:&quot;));
+
+         diaElem *diaRC[]={&amp;menuFieldOrder,&amp;menuInterpolaye,&amp;menuType,&amp;menuMnt,&amp;menuLink,&amp;menuAP,
+                            &amp;toggleUseChroma,&amp;toggleTryWeave,&amp;toggleDenoise,&amp;toggleSharp,&amp;toggleEvaluteAll,
+                            &amp;intMotionLuma,&amp;intMotionChroma,&amp;intAreaCombing,&amp;intCombed,&amp;intArtefact,&amp;intDebug
+                  };
+
+        
+         
+        if( diaFactoryRun(QT_TR_NOOP(&quot;TDeint&quot;),17,diaRC))
+	{
+           param-&gt;order=(int)order-1;
+           param-&gt;field=(int)field-1;
+          return 1;
+        }
+         return 0;
+}
+// EOF

Added: branches/avidemux_2.5_branch_gruntster/cmake/admCheckFreeType.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckFreeType.cmake	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckFreeType.cmake	2008-05-27 19:41:54 UTC (rev 4068)
@@ -0,0 +1,57 @@
+MACRO(checkFreeType)
+########################################
+# FreeType2
+########################################
+OPTION(FREETYPE2 &quot;&quot; ON)
+
+MESSAGE(STATUS &quot;Checking for FreeType2&quot;)
+MESSAGE(STATUS &quot;**********************&quot;)
+
+IF (FREETYPE2)
+	PKG_CHECK_MODULES(FREETYPE2 freetype2)
+	PRINT_LIBRARY_INFO(&quot;FreeType2&quot; FREETYPE2_FOUND &quot;${FREETYPE2_CFLAGS}&quot; &quot;${FREETYPE2_LDFLAGS}&quot;)
+
+	IF (FREETYPE2_FOUND)
+		SET(USE_FREETYPE 1)
+	ENDIF (FREETYPE2_FOUND)
+ELSE (FREETYPE2)
+	MESSAGE(&quot;${MSG_DISABLE_OPTION}&quot;)
+ENDIF (FREETYPE2)
+
+MESSAGE(&quot;&quot;)
+
+########################################
+# libiconv
+########################################
+IF (USE_FREETYPE)
+	MESSAGE(STATUS &quot;Checking for libiconv&quot;)
+	MESSAGE(STATUS &quot;*********************&quot;)
+
+	FIND_HEADER_AND_LIB(LIBICONV iconv.h iconv)
+	PRINT_LIBRARY_INFO(&quot;libiconv&quot; LIBICONV_FOUND &quot;${LIBICONV_INCLUDE_DIR}&quot; &quot;${LIBICONV_LIBRARY_DIR}&quot;)
+
+	IF (NOT LIBICONV_INCLUDE_DIR)
+		MESSAGE(STATUS &quot;iconv.h not found, disabling FreeType2&quot;)
+		SET(USE_FREETYPE)
+	ELSE (NOT LIBICONV_INCLUDE_DIR)
+		IF (LIBICONV_LIBRARY_DIR)
+			MESSAGE(STATUS &quot;libiconv is probably needed&quot;)
+
+			CHECK_CFLAGS_REQUIRED(iconv_check.cpp &quot;-DICONV_NEED_CONST&quot; &quot;${LIBICONV_INCLUDE_DIR}&quot; &quot;${LIBICONV_LIBRARY_DIR}&quot; LIBICONV_CFLAGS_REQUIRED)
+		ELSE (LIBICONV_LIBRARY_DIR)
+			SET(LIBICONV_LIBRARY_DIR &quot;&quot;)
+			MESSAGE(STATUS &quot;libiconv is probably not needed&quot;)
+
+			ADM_COMPILE(iconv_check.cpp &quot;-DICONV_NEED_CONST&quot; &quot;${LIBICONV_INCLUDE_DIR}&quot; &quot;&quot; LIBICONV_CFLAGS_REQUIRED LIBICONV_COMPILE_OUTPUT)
+		ENDIF (LIBICONV_LIBRARY_DIR)
+
+		IF (LIBICONV_CFLAGS_REQUIRED)
+			SET(LIBICONV_DEFINITIONS &quot;-DICONV_NEED_CONST&quot;)
+			SET(ICONV_NEED_CONST 1)
+		ENDIF(LIBICONV_CFLAGS_REQUIRED)
+	ENDIF (NOT LIBICONV_INCLUDE_DIR)
+
+	MESSAGE(&quot;&quot;)
+ENDIF (USE_FREETYPE)
+
+ENDMACRO(checkFreeType)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admCheckMiscLibs.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckMiscLibs.cmake	2008-05-26 17:50:21 UTC (rev 4067)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckMiscLibs.cmake	2008-05-27 19:41:54 UTC (rev 4068)
@@ -20,62 +20,8 @@
 
 MESSAGE(&quot;&quot;)
 
-########################################
-# FreeType2
-########################################
-OPTION(FREETYPE2 &quot;&quot; ON)
 
-MESSAGE(STATUS &quot;Checking for FreeType2&quot;)
-MESSAGE(STATUS &quot;**********************&quot;)
-
-IF (FREETYPE2)
-	PKG_CHECK_MODULES(FREETYPE2 freetype2)
-	PRINT_LIBRARY_INFO(&quot;FreeType2&quot; FREETYPE2_FOUND &quot;${FREETYPE2_CFLAGS}&quot; &quot;${FREETYPE2_LDFLAGS}&quot;)
-
-	IF (FREETYPE2_FOUND)
-		SET(USE_FREETYPE 1)
-	ENDIF (FREETYPE2_FOUND)
-ELSE (FREETYPE2)
-	MESSAGE(&quot;${MSG_DISABLE_OPTION}&quot;)
-ENDIF (FREETYPE2)
-
-MESSAGE(&quot;&quot;)
-
 ########################################
-# libiconv
-########################################
-IF (USE_FREETYPE)
-	MESSAGE(STATUS &quot;Checking for libiconv&quot;)
-	MESSAGE(STATUS &quot;*********************&quot;)
-
-	FIND_HEADER_AND_LIB(LIBICONV iconv.h iconv)
-	PRINT_LIBRARY_INFO(&quot;libiconv&quot; LIBICONV_FOUND &quot;${LIBICONV_INCLUDE_DIR}&quot; &quot;${LIBICONV_LIBRARY_DIR}&quot;)
-
-	IF (NOT LIBICONV_INCLUDE_DIR)
-		MESSAGE(STATUS &quot;iconv.h not found, disabling FreeType2&quot;)
-		SET(USE_FREETYPE)
-	ELSE (NOT LIBICONV_INCLUDE_DIR)
-		IF (LIBICONV_LIBRARY_DIR)
-			MESSAGE(STATUS &quot;libiconv is probably needed&quot;)
-
-			CHECK_CFLAGS_REQUIRED(iconv_check.cpp &quot;-DICONV_NEED_CONST&quot; &quot;${LIBICONV_INCLUDE_DIR}&quot; &quot;${LIBICONV_LIBRARY_DIR}&quot; LIBICONV_CFLAGS_REQUIRED)
-		ELSE (LIBICONV_LIBRARY_DIR)
-			SET(LIBICONV_LIBRARY_DIR &quot;&quot;)
-			MESSAGE(STATUS &quot;libiconv is probably not needed&quot;)
-
-			ADM_COMPILE(iconv_check.cpp &quot;-DICONV_NEED_CONST&quot; &quot;${LIBICONV_INCLUDE_DIR}&quot; &quot;&quot; LIBICONV_CFLAGS_REQUIRED LIBICONV_COMPILE_OUTPUT)
-		ENDIF (LIBICONV_LIBRARY_DIR)
-
-		IF (LIBICONV_CFLAGS_REQUIRED)
-			SET(LIBICONV_DEFINITIONS &quot;-DICONV_NEED_CONST&quot;)
-			SET(ICONV_NEED_CONST 1)
-		ENDIF(LIBICONV_CFLAGS_REQUIRED)
-	ENDIF (NOT LIBICONV_INCLUDE_DIR)
-
-	MESSAGE(&quot;&quot;)
-ENDIF (USE_FREETYPE)
-
-########################################
 # gettext
 ########################################
 INCLUDE(admCheckGettext)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001324.html">[Avidemux-svn-commit] r4067 - in	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_filter	ADM_videoFilter plugins/ADM_videoFilters	plugins/ADM_videoFilters/ASharp plugins/ADM_videoFilters/ASharp/gtk	plugins/ADM_videoFilters/ASharp/qt4	plugins/ADM_videoFilters/Contrast	plugins/ADM_videoFilters/Contrast/gtk	plugins/ADM_videoFilters/Contrast/qt4 plugins/ADM_videoFilters/Crop	plugins/ADM_videoFilters/Crop/gtk plugins/ADM_videoFilters/Crop/qt4	plugins/ADM_videoFilters/Eq2 plugins/ADM_videoFilters/Eq2/gtk	plugins/ADM_videoFilters/Eq2/qt4 plugins/ADM_videoFilters/Hue	plugins/ADM_videoFilters/Hue/gtk plugins/ADM_videoFilters/Hue/qt4
</A></li>
	<LI>Next message: <A HREF="001326.html">[Avidemux-svn-commit] r4069 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_UIs/ADM_GTK/include ADM_UIs/ADM_GTK/src	ADM_UIs/ADM_QT4/include ADM_UIs/ADM_QT4/src	ADM_coreImage/include ADM_filter ADM_libraries	ADM_libraries/ADM_libass ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_commonUI ADM_videoFilter	plugins/ADM_videoFilters plugins/ADM_videoFilters/Animated	plugins/ADM_videoFilters/Ass plugins/ADM_videoFilters/Ass/ADM_libass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1325">[ date ]</a>
              <a href="thread.html#1325">[ thread ]</a>
              <a href="subject.html#1325">[ subject ]</a>
              <a href="author.html#1325">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
