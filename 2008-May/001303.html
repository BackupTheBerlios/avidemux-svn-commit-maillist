<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4046 - in	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_filter	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter	plugins/ADM_videoFilters plugins/ADM_videoFilters/CNR2	plugins/ADM_videoFilters/CNR2/gtk	plugins/ADM_videoFilters/ChromaShift	plugins/ADM_videoFilters/ChromaShift/gtk	plugins/ADM_videoFilters/ChromaShift/qt4	plugins/ADM_videoFilters/Clean plugins/ADM_videoFilters/Equalizer	plugins/ADM_videoFilters/Equalizer/gtk	plugins/ADM_videoFilters/MPDelogo	plugins/ADM_videoFilters/MPDelogo/gtk	plugins/ADM_videoFilters/PulldownRemoval	plugins/ADM_videoFilters/colorYUV	plugins/ADM_videoFilters/colorYUV/gtk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4046%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%20ADM_filter%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%0A%09ADM_userInterfaces/ADM_commonUI%20ADM_video%20ADM_videoFilter%0A%09plugins/ADM_videoFilters%20plugins/ADM_videoFilters/CNR2%0A%09plugins/ADM_videoFilters/CNR2/gtk%0A%09plugins/ADM_videoFilters/ChromaShift%0A%09plugins/ADM_videoFilters/ChromaShift/gtk%0A%09plugins/ADM_videoFilters/ChromaShift/qt4%0A%09plugins/ADM_videoFilters/Clean%20plugins/ADM_videoFilters/Equalizer%0A%09plugins/ADM_videoFilters/Equalizer/gtk%0A%09plugins/ADM_videoFilters/MPDelogo%0A%09plugins/ADM_videoFilters/MPDelogo/gtk%0A%09plugins/ADM_videoFilters/PulldownRemoval%0A%09plugins/ADM_videoFilters/colorYUV%0A%09plugins/ADM_videoFilters/colorYUV/gtk&In-Reply-To=%3C200805191822.m4JIM8Jp018612%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001302.html">
   <LINK REL="Next"  HREF="001304.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4046 - in	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_filter	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter	plugins/ADM_videoFilters plugins/ADM_videoFilters/CNR2	plugins/ADM_videoFilters/CNR2/gtk	plugins/ADM_videoFilters/ChromaShift	plugins/ADM_videoFilters/ChromaShift/gtk	plugins/ADM_videoFilters/ChromaShift/qt4	plugins/ADM_videoFilters/Clean plugins/ADM_videoFilters/Equalizer	plugins/ADM_videoFilters/Equalizer/gtk	plugins/ADM_videoFilters/MPDelogo	plugins/ADM_videoFilters/MPDelogo/gtk	plugins/ADM_videoFilters/PulldownRemoval	plugins/ADM_videoFilters/colorYUV	plugins/ADM_videoFilters/colorYUV/gtk</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4046%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%20ADM_filter%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%0A%09ADM_userInterfaces/ADM_commonUI%20ADM_video%20ADM_videoFilter%0A%09plugins/ADM_videoFilters%20plugins/ADM_videoFilters/CNR2%0A%09plugins/ADM_videoFilters/CNR2/gtk%0A%09plugins/ADM_videoFilters/ChromaShift%0A%09plugins/ADM_videoFilters/ChromaShift/gtk%0A%09plugins/ADM_videoFilters/ChromaShift/qt4%0A%09plugins/ADM_videoFilters/Clean%20plugins/ADM_videoFilters/Equalizer%0A%09plugins/ADM_videoFilters/Equalizer/gtk%0A%09plugins/ADM_videoFilters/MPDelogo%0A%09plugins/ADM_videoFilters/MPDelogo/gtk%0A%09plugins/ADM_videoFilters/PulldownRemoval%0A%09plugins/ADM_videoFilters/colorYUV%0A%09plugins/ADM_videoFilters/colorYUV/gtk&In-Reply-To=%3C200805191822.m4JIM8Jp018612%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4046 - in	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_filter	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter	plugins/ADM_videoFilters plugins/ADM_videoFilters/CNR2	plugins/ADM_videoFilters/CNR2/gtk	plugins/ADM_videoFilters/ChromaShift	plugins/ADM_videoFilters/ChromaShift/gtk	plugins/ADM_videoFilters/ChromaShift/qt4	plugins/ADM_videoFilters/Clean plugins/ADM_videoFilters/Equalizer	plugins/ADM_videoFilters/Equalizer/gtk	plugins/ADM_videoFilters/MPDelogo	plugins/ADM_videoFilters/MPDelogo/gtk	plugins/ADM_videoFilters/PulldownRemoval	plugins/ADM_videoFilters/colorYUV	plugins/ADM_videoFilters/colorYUV/gtk">mean at mail.berlios.de
       </A><BR>
    <I>Mon May 19 20:22:08 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001302.html">[Avidemux-svn-commit] r4045 - in	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_editor	ADM_encoder ADM_script plugins/ADM_videoEncoder/ADM_vidEnc_x264	plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4
</A></li>
        <LI>Next message: <A HREF="001304.html">[Avidemux-svn-commit] r4047 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1303">[ date ]</a>
              <a href="thread.html#1303">[ thread ]</a>
              <a href="subject.html#1303">[ subject ]</a>
              <a href="author.html#1303">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-05-19 20:22:05 +0200 (Mon, 19 May 2008)
New Revision: 4046

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/ADM_vidCNR2.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/ADM_vidCNR2_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/gtk/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/gtk/DIA_cnr2.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/ADM_vidChromaShift.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/ADM_vidChromaShift.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/ADM_vidChromaShift_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/DIA_flyChromaShift.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/DIA_flyChromaShift.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/gtk/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/gtk/DIA_chromaShift.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/qt4/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/qt4/Q_chromashift.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/qt4/chromashift.ui
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Clean/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Clean/ADM_vidClean.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Clean/ADM_vidClean.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/ADM_vidEqualizer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/ADM_vidEqualizer.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/gtk/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/gtk/DIA_equalizer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/ADM_vidMPdelogo.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/ADM_vidMPdelogo.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/gtk/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/gtk/DIA_mpdelogo.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/PulldownRemoval/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/PulldownRemoval/ADM_vidFieldUnblend.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/ADM_vidColorYuv.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/ADM_vidColorYuv.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/ADM_vidColorYuv_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/gtk/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/gtk/DIA_coloryuv.cpp
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_chromaShift.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_cnr2.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_coloryuv.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_equalizer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mpdelogo.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_chromashift.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/chromashift.ui
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUnblend.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.h
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt
Log:
[Merge]


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -51,14 +51,13 @@
     REGISTERX(VF_COLORS, &quot;eq2&quot;,QT_TR_NOOP(&quot;MPlayer eq2&quot;),QT_TR_NOOP(&quot;Adjust contrast, brightness, saturation and gamma.&quot;),VF_EQ2,1,Eq2_create,Eq2_script);
     REGISTERX(VF_COLORS, &quot;hue&quot;,QT_TR_NOOP(&quot;MPlayer hue&quot;),QT_TR_NOOP(&quot;Adjust hue and saturation.&quot;),VF_HUE,1,hue_create,hue_script);
     REGISTERX(VF_COLORS, &quot;contrast&quot;,QT_TR_NOOP(&quot;Contrast&quot;),QT_TR_NOOP(&quot;Adjust contrast, brightness and colors.&quot;),VF_CONTRAST,1,contrast_create,contrast_script);
-    REGISTERX(VF_COLORS, &quot;equalizer&quot;,QT_TR_NOOP(&quot;Luma equalizer&quot;),QT_TR_NOOP(&quot;Luma correction filter with histogram.&quot;),VF_EQUALIZER,1,equalizer_create,equalizer_script);
-    REGISTERX(VF_COLORS, &quot;chromashift&quot;,QT_TR_NOOP(&quot;Chroma shift&quot;),QT_TR_NOOP(&quot;Shift chroma U/V to fix badly synced luma/chroma.&quot;),VF_CHROMASHIFT,1,create_chromashift,chromashift_script);
-    REGISTERX(VF_COLORS, &quot;coloryuv&quot;,QT_TR_NOOP(&quot;Avisynth ColorYUV&quot;),QT_TR_NOOP(&quot;Alter colors (auto white balance etc...). Ported from Avisynth.&quot;),VF_COLOR_YUV,1,coloryuv_create,coloryuv_script);
+    
+    
 
 // Custom UI    
-REGISTERX(VF_NOISE, &quot;cnr2&quot;,QT_TR_NOOP(&quot;Cnr2&quot;),QT_TR_NOOP(&quot;Chroma noise reduction filter by MarcFD/Tritical.&quot;),VF_CNR2,1,cnr2_create,cnr2_script);	
+	
 REGISTERX(VF_SHARPNESS, &quot;asharp&quot;,QT_TR_NOOP(&quot;asharp&quot;),QT_TR_NOOP(&quot;Adaptative sharpener by MarcFD.&quot;),VF_ASHARP,1,asharp_create,asharp_script);
-REGISTERX(VF_MISC, &quot;mpdelogo&quot;,QT_TR_NOOP(&quot;MPlayer delogo&quot;),QT_TR_NOOP(&quot;Blend a logo by interpolating its surrounding box.&quot;),VF_MPDELOGO,1,mpdelogo_create,mpdelogo_script);
+
 REGISTERX(VF_MISC, &quot;animatedmenu&quot;,QT_TR_NOOP(&quot;Animated Menu&quot;), QT_TR_NOOP(&quot;Create a video made of 6 mini windows, very useful to do DVD menus.&quot;),
         VF_ANIMATED,1,animated_create,animated_script);
     

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,10 +1,10 @@
 SET(ADM_LIB ADM_dialogGtk)
 
 SET(${ADM_LIB}_SRCS
-	DIA_about.cpp     DIA_calculator.cpp   DIA_crop.cpp       DIA_flyDialog.cpp  DIA_mpdelogo.cpp  DIA_preview.cpp     DIA_srt.cpp      DIA_xvid4.cpp
-	DIA_acodec.cpp    DIA_chromaShift.cpp  DIA_encoding.cpp   DIA_hue.cpp        DIA_ocr.cpp       DIA_properties.cpp  DIA_vcodec.cpp   DIA_xvid.cpp
-	DIA_cnr2.cpp         DIA_eq2.cpp        DIA_idx_pg.cpp     DIA_partial.cpp   DIA_quota.cpp       DIA_vobsub.cpp
-	DIA_asharp.cpp    DIA_coloryuv.cpp     DIA_equalizer.cpp  DIA_jobs.cpp       DIA_pause.cpp     DIA_recent.cpp      DIA_working.cpp
+	DIA_about.cpp     DIA_calculator.cpp   DIA_crop.cpp       DIA_flyDialog.cpp  DIA_preview.cpp     DIA_srt.cpp      DIA_xvid4.cpp
+	DIA_acodec.cpp    DIA_encoding.cpp   DIA_hue.cpp        DIA_ocr.cpp       DIA_properties.cpp  DIA_vcodec.cpp   DIA_xvid.cpp
+	DIA_eq2.cpp        DIA_idx_pg.cpp     DIA_partial.cpp   DIA_quota.cpp       DIA_vobsub.cpp
+	DIA_asharp.cpp    DIA_jobs.cpp       DIA_pause.cpp     DIA_recent.cpp      DIA_working.cpp
 	DIA_busy.cpp      DIA_contrast.cpp     DIA_exLame.cpp     DIA_pipe.cpp      DIA_resize.cpp
 	DIA_threshold.cpp DIA_SwissArmyKnife.cpp DIA_particle.cpp DIA_eraser.cpp
         toolkit_dialog.cpp

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_chromaShift.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_chromaShift.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_chromaShift.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,284 +0,0 @@
-/***************************************************************************
-                          ADM_guiChromaShift.cpp  -  description
-                             -------------------
-    begin                : Sun Aug 24 2003
-    copyright            : (C) 2002-2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_toolkitGtk.h&quot;
-
-
-#include &quot;ADM_image.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_assert.h&quot;
-#include &quot;DIA_flyDialog.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidChromaShift_param.h&quot;
-#include &quot;DIA_flyChromaShift.h&quot;
-
-static int lock=0;
-
-static GtkWidget *dialog;
-static GtkWidget *create_ChromaShift( void );
-
-
-static void read( void );
-static void upload ( void );
-static gboolean gui_draw( void );
-static gboolean gui_update( void );
-static gboolean slider_update( void );
-static void update(void);
-
-static flyChromaShift *myCrop=NULL;
-
-//**************************************
-
-uint8_t DIA_getChromaShift( AVDMGenericVideoStream *instream,CHROMASHIFT_PARAM    *param );
-uint8_t DIA_getChromaShift( AVDMGenericVideoStream *in,CHROMASHIFT_PARAM    *param )
-{
-uint8_t ret=0;
-  
-        uint32_t width,height;
-
-        // Allocate space for green-ised video
-        width=in-&gt;getInfo()-&gt;width;
-        height=in-&gt;getInfo()-&gt;height;
-
-        dialog=create_ChromaShift();
-        gtk_register_dialog(dialog);
-        gtk_window_set_title (GTK_WINDOW (dialog), QT_TR_NOOP(&quot;Chroma Shift&quot;));
-        gtk_widget_show(dialog);
-	
-        myCrop=new flyChromaShift( width, height,in,WID(drawingarea1),WID(hscale));
-        memcpy(&amp;(myCrop-&gt;param),param,sizeof(CHROMASHIFT_PARAM));
-        myCrop-&gt;upload();
-        myCrop-&gt;sliderChanged();
-        
-        gtk_signal_connect(GTK_OBJECT(WID(drawingarea1)), &quot;expose_event&quot;,
-            GTK_SIGNAL_FUNC(gui_draw),
-            NULL);
-        
-        gtk_signal_connect (GTK_OBJECT(WID( spinbutton_U)), &quot;value_changed&quot;,
-                    GTK_SIGNAL_FUNC (gui_update),
-                    NULL);
-        gtk_signal_connect (GTK_OBJECT(WID( spinbutton_V)), &quot;value_changed&quot;,
-                    GTK_SIGNAL_FUNC (gui_update),
-                    NULL);
-        gtk_signal_connect (GTK_OBJECT(WID( spinbutton_V)), &quot;value_changed&quot;,
-                    GTK_SIGNAL_FUNC (gui_update),
-                    NULL);
-         gtk_signal_connect (GTK_OBJECT(WID( hscale)), &quot;value_changed&quot;,
-                    GTK_SIGNAL_FUNC (slider_update),
-                    NULL);
-
-          
-       
-        ret=0;
-        int response;
-        response=gtk_dialog_run(GTK_DIALOG(dialog));
-
-        if(response==GTK_RESPONSE_OK)
-        {
-            myCrop-&gt;download();
-            memcpy(param,&amp;(myCrop-&gt;param),sizeof(CHROMASHIFT_PARAM));
-            ret=1;
-        }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        delete myCrop;
-        return ret;
-}
-      
-/**********************************/
-void read( void )
-{
-	myCrop-&gt;download();
-}
-void upload ( void )
-{
-	myCrop-&gt;upload();
-}
-gboolean slider_update( void )
-{
-        myCrop-&gt;sliderChanged();
-        return true;
-}
-gboolean gui_update( void)
-{
-  if(lock) return true;
-      myCrop-&gt;update();
-  return true;
-}
-gboolean gui_draw( void )
-{
-	myCrop-&gt;display();
-	return true;
-}
-
-/******************************/
-#define SPIN_GET(x,y) {y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(lookup_widget(dialog,#x))) ;\
-				printf(#x&quot;:%d\n&quot;, y);}
-
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(lookup_widget(dialog,#x)),(gfloat)y) ; printf(#x&quot;:%d\n&quot;, y);}
-
-
-uint8_t    flyChromaShift::upload(void)
-{
-        SPIN_SET(spinbutton_U,param.u);
-        SPIN_SET(spinbutton_V,param.v);
-  return 1;
-}
-uint8_t    flyChromaShift::download(void)
-{
-        SPIN_GET(spinbutton_U,param.u);
-        SPIN_GET(spinbutton_V,param.v);
-  
-  return 1;
-}
-
-
-/*----------------------------------------------------------------*/
-
-GtkWidget*
-create_ChromaShift (void)
-{
-  GtkWidget *ChromaShift;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkObject *spinbutton_U_adj;
-  GtkWidget *spinbutton_U;
-  GtkObject *spinbutton_V_adj;
-  GtkWidget *spinbutton_V;
-  GtkWidget *hscale;
-  GtkWidget *frame1;
-  GtkWidget *alignment1;
-  GtkWidget *drawingarea1;
-  GtkWidget *label3;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *applybutton1;
-  GtkWidget *okbutton1;
-
-  ChromaShift = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (ChromaShift), QT_TR_NOOP(&quot;ChromaShift&quot;));
-  gtk_window_set_type_hint (GTK_WINDOW (ChromaShift), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (ChromaShift)-&gt;vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  table1 = gtk_table_new (2, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (vbox1), table1, FALSE, FALSE, 0);
-
-  label1 = gtk_label_new (QT_TR_NOOP(&quot;U Shift :&quot;));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (QT_TR_NOOP(&quot;V Shift :&quot;));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  spinbutton_U_adj = gtk_adjustment_new (0, -32, 32, 1, 10, 10);
-  spinbutton_U = gtk_spin_button_new (GTK_ADJUSTMENT (spinbutton_U_adj), 1, 0);
-  gtk_widget_show (spinbutton_U);
-  gtk_table_attach (GTK_TABLE (table1), spinbutton_U, 1, 2, 0, 1,
-                    (GtkAttachOptions) (0),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbutton_U), TRUE);
-
-  spinbutton_V_adj = gtk_adjustment_new (0, -32, 32, 1, 10, 10);
-  spinbutton_V = gtk_spin_button_new (GTK_ADJUSTMENT (spinbutton_V_adj), 1, 0);
-  gtk_widget_show (spinbutton_V);
-  gtk_table_attach (GTK_TABLE (table1), spinbutton_V, 1, 2, 1, 2,
-                    (GtkAttachOptions) (0),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbutton_V), TRUE);
-
-  hscale = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 100, 1, 1, 1)));
-  gtk_widget_show (hscale);
-  gtk_box_pack_start (GTK_BOX (vbox1), hscale, FALSE, FALSE, 0);
-  gtk_scale_set_digits (GTK_SCALE (hscale), 0);
-
-  frame1 = gtk_frame_new (NULL);
-  gtk_widget_show (frame1);
-  gtk_box_pack_start (GTK_BOX (vbox1), frame1, TRUE, TRUE, 0);
-  gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_NONE);
-
-  alignment1 = gtk_alignment_new (0.5, 0.5, 1, 1);
-  gtk_widget_show (alignment1);
-  gtk_container_add (GTK_CONTAINER (frame1), alignment1);
-  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment1), 0, 0, 12, 0);
-
-  drawingarea1 = gtk_drawing_area_new ();
-  gtk_widget_show (drawingarea1);
-  gtk_container_add (GTK_CONTAINER (alignment1), drawingarea1);
-
-  label3 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Preview&lt;/b&gt;&quot;));
-  gtk_widget_show (label3);
-  gtk_frame_set_label_widget (GTK_FRAME (frame1), label3);
-  gtk_label_set_use_markup (GTK_LABEL (label3), TRUE);
-
-  dialog_action_area1 = GTK_DIALOG (ChromaShift)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (ChromaShift), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  applybutton1 = gtk_button_new_from_stock (&quot;gtk-apply&quot;);
-  gtk_widget_show (applybutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (ChromaShift), applybutton1, GTK_RESPONSE_APPLY);
-  GTK_WIDGET_SET_FLAGS (applybutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (ChromaShift), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (ChromaShift, ChromaShift, &quot;ChromaShift&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (ChromaShift, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, vbox1, &quot;vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, table1, &quot;table1&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, label2, &quot;label2&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, spinbutton_U, &quot;spinbutton_U&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, spinbutton_V, &quot;spinbutton_V&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, hscale, &quot;hscale&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, frame1, &quot;frame1&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, alignment1, &quot;alignment1&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, drawingarea1, &quot;drawingarea1&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, label3, &quot;label3&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (ChromaShift, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, cancelbutton1, &quot;cancelbutton1&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, applybutton1, &quot;applybutton1&quot;);
-  GLADE_HOOKUP_OBJECT (ChromaShift, okbutton1, &quot;okbutton1&quot;);
-
-  return ChromaShift;
-}
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_cnr2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_cnr2.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_cnr2.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,351 +0,0 @@
-//
-// C++ Implementation: DIA_Msmooth
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-
-#include &quot;ADM_toolkitGtk.h&quot;
-
-
-
-#include &quot;ADM_video/ADM_vidCNR2_param.h&quot;
-
-static GtkWidget        *create_dialog1 (void);
-
-#define CHECK_GET(x,y) {param-&gt;y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
-#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param-&gt;y);}     
-
-#define ENTRY_SET(x) {gtk_write_entry(WID(entry##x),(int)param-&gt;x);}
-#define ENTRY_GET(x) {param-&gt;x=gtk_read_entry(WID(entry##x));}
-
-
-uint8_t DIA_cnr2(CNR2Param *param);
-uint8_t DIA_cnr2(CNR2Param *param)
-{
-GtkWidget *dialog;
-int ret=0;
-        dialog=create_dialog1();
-        
-        // Update
-        ENTRY_SET(lm);ENTRY_SET(ln);
-        ENTRY_SET(um);ENTRY_SET(un);
-        ENTRY_SET(vm);ENTRY_SET(vn);
-
-        CHECK_SET(checkbuttonChroma,sceneChroma);
-
-        if(param-&gt;mode &amp; 0xFF0000) gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonl)),1);
-        if(param-&gt;mode &amp; 0xFF00) gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonu)),1);
-        if(param-&gt;mode &amp; 0xFF) gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonv)),1);
-        
-        gtk_range_set_value (GTK_RANGE(WID(hscale1)),(gdouble)param-&gt;scdthr);
-        
-        //**************************
-        gtk_register_dialog(dialog);
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-        {
-          GtkAdjustment *adj;   
-
-                adj=gtk_range_get_adjustment (GTK_RANGE(WID(hscale1)));
-                param-&gt;scdthr=(double)GTK_ADJUSTMENT(adj)-&gt;value;
-        
-                ENTRY_GET(lm);ENTRY_GET(ln);
-                ENTRY_GET(um);ENTRY_GET(un);
-                ENTRY_GET(vm);ENTRY_GET(vn);
-
-                CHECK_GET(checkbuttonChroma,sceneChroma);
-                param-&gt;mode=0;
-#define UPD(x,y) if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(WID(x)))) param-&gt;mode|=y;
-                        UPD(checkbuttonl,0xFF0000);
-                        UPD(checkbuttonu,0xFF00);
-                        UPD(checkbuttonv,0xFF);
-               
-
-                ret=1;
-        
-        }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        return ret;
-
-}
-
-//__________________________________
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *frame3;
-  GtkWidget *alignment3;
-  GtkWidget *hscale1;
-  GtkWidget *label9;
-  GtkWidget *frame1;
-  GtkWidget *alignment1;
-  GtkWidget *table1;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkWidget *label2;
-  GtkWidget *label5;
-  GtkWidget *label6;
-  GtkWidget *label7;
-  GtkWidget *entryln;
-  GtkWidget *entrylm;
-  GtkWidget *entryun;
-  GtkWidget *entryvn;
-  GtkWidget *entryum;
-  GtkWidget *entryvm;
-  GtkWidget *label10;
-  GtkWidget *checkbuttonl;
-  GtkWidget *checkbuttonu;
-  GtkWidget *checkbuttonv;
-  GtkWidget *label1;
-  GtkWidget *frame2;
-  GtkWidget *alignment2;
-  GtkWidget *vbox2;
-  GtkWidget *checkbuttonChroma;
-  GtkWidget *label8;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;Chroma Noise Reduction 2&quot;));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  frame3 = gtk_frame_new (NULL);
-  gtk_widget_show (frame3);
-  gtk_box_pack_start (GTK_BOX (vbox1), frame3, TRUE, TRUE, 0);
-  gtk_frame_set_shadow_type (GTK_FRAME (frame3), GTK_SHADOW_NONE);
-
-  alignment3 = gtk_alignment_new (0.5, 0.5, 1, 1);
-  gtk_widget_show (alignment3);
-  gtk_container_add (GTK_CONTAINER (frame3), alignment3);
-  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment3), 0, 0, 12, 0);
-
-  hscale1 = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 100, 1, 1, 0)));
-  gtk_widget_show (hscale1);
-  gtk_container_add (GTK_CONTAINER (alignment3), hscale1);
-  gtk_scale_set_digits (GTK_SCALE (hscale1), 2);
-
-  label9 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Scene change Treshold&lt;/b&gt;&quot;));
-  gtk_widget_show (label9);
-  gtk_frame_set_label_widget (GTK_FRAME (frame3), label9);
-  gtk_label_set_use_markup (GTK_LABEL (label9), TRUE);
-
-  frame1 = gtk_frame_new (NULL);
-  gtk_widget_show (frame1);
-  gtk_box_pack_start (GTK_BOX (vbox1), frame1, TRUE, TRUE, 0);
-  gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_NONE);
-
-  alignment1 = gtk_alignment_new (0.5, 0.5, 1, 1);
-  gtk_widget_show (alignment1);
-  gtk_container_add (GTK_CONTAINER (frame1), alignment1);
-  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment1), 0, 0, 12, 0);
-
-  table1 = gtk_table_new (4, 4, FALSE);
-  gtk_widget_show (table1);
-  gtk_container_add (GTK_CONTAINER (alignment1), table1);
-
-  label3 = gtk_label_new (QT_TR_NOOP(&quot;Sensibility&quot;));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_CENTER);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (QT_TR_NOOP(&quot;Max&quot;));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 2, 3, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_CENTER);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  label2 = gtk_label_new (&quot;&quot;);
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label5 = gtk_label_new (QT_TR_NOOP(&quot;Luma :&quot;));
-  gtk_widget_show (label5);
-  gtk_table_attach (GTK_TABLE (table1), label5, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
-
-  label6 = gtk_label_new (QT_TR_NOOP(&quot;Chroma U :&quot;));
-  gtk_widget_show (label6);
-  gtk_table_attach (GTK_TABLE (table1), label6, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label6), 0, 0.5);
-
-  label7 = gtk_label_new (QT_TR_NOOP(&quot;Chroma V :&quot;));
-  gtk_widget_show (label7);
-  gtk_table_attach (GTK_TABLE (table1), label7, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label7), 0, 0.5);
-
-  entryln = gtk_entry_new ();
-  gtk_widget_show (entryln);
-  gtk_table_attach (GTK_TABLE (table1), entryln, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  entrylm = gtk_entry_new ();
-  gtk_widget_show (entrylm);
-  gtk_table_attach (GTK_TABLE (table1), entrylm, 2, 3, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  entryun = gtk_entry_new ();
-  gtk_widget_show (entryun);
-  gtk_table_attach (GTK_TABLE (table1), entryun, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  entryvn = gtk_entry_new ();
-  gtk_widget_show (entryvn);
-  gtk_table_attach (GTK_TABLE (table1), entryvn, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  entryum = gtk_entry_new ();
-  gtk_widget_show (entryum);
-  gtk_table_attach (GTK_TABLE (table1), entryum, 2, 3, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  entryvm = gtk_entry_new ();
-  gtk_widget_show (entryvm);
-  gtk_table_attach (GTK_TABLE (table1), entryvm, 2, 3, 3, 4,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label10 = gtk_label_new (QT_TR_NOOP(&quot;Narrow&quot;));
-  gtk_widget_show (label10);
-  gtk_table_attach (GTK_TABLE (table1), label10, 3, 4, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label10), 0, 0.5);
-
-  checkbuttonl = gtk_check_button_new_with_mnemonic (&quot;&quot;);
-  gtk_widget_show (checkbuttonl);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonl, 3, 4, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbuttonu = gtk_check_button_new_with_mnemonic (&quot;&quot;);
-  gtk_widget_show (checkbuttonu);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonu, 3, 4, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbuttonv = gtk_check_button_new_with_mnemonic (&quot;&quot;);
-  gtk_widget_show (checkbuttonv);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonv, 3, 4, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label1 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Settings&lt;/b&gt;&quot;));
-  gtk_widget_show (label1);
-  gtk_frame_set_label_widget (GTK_FRAME (frame1), label1);
-  gtk_label_set_use_markup (GTK_LABEL (label1), TRUE);
-
-  frame2 = gtk_frame_new (NULL);
-  gtk_widget_show (frame2);
-  gtk_box_pack_start (GTK_BOX (vbox1), frame2, TRUE, TRUE, 0);
-  gtk_frame_set_shadow_type (GTK_FRAME (frame2), GTK_SHADOW_NONE);
-
-  alignment2 = gtk_alignment_new (0.5, 0.5, 1, 1);
-  gtk_widget_show (alignment2);
-  gtk_container_add (GTK_CONTAINER (frame2), alignment2);
-  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment2), 0, 0, 12, 0);
-
-  vbox2 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox2);
-  gtk_container_add (GTK_CONTAINER (alignment2), vbox2);
-
-  checkbuttonChroma = gtk_check_button_new_with_mnemonic (QT_TR_NOOP(&quot;Use also chroma to detect scene change&quot;));
-  gtk_widget_show (checkbuttonChroma);
-  gtk_box_pack_start (GTK_BOX (vbox2), checkbuttonChroma, FALSE, FALSE, 0);
-
-  label8 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Mode&lt;/b&gt;&quot;));
-  gtk_widget_show (label8);
-  gtk_frame_set_label_widget (GTK_FRAME (frame2), label8);
-  gtk_label_set_use_markup (GTK_LABEL (label8), TRUE);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, &quot;vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, frame3, &quot;frame3&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, alignment3, &quot;alignment3&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hscale1, &quot;hscale1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label9, &quot;label9&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, frame1, &quot;frame1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, alignment1, &quot;alignment1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, table1, &quot;table1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label3, &quot;label3&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label4, &quot;label4&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label2, &quot;label2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label5, &quot;label5&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label6, &quot;label6&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label7, &quot;label7&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, entryln, &quot;entryln&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, entrylm, &quot;entrylm&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, entryun, &quot;entryun&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, entryvn, &quot;entryvn&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, entryum, &quot;entryum&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, entryvm, &quot;entryvm&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label10, &quot;label10&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonl, &quot;checkbuttonl&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonu, &quot;checkbuttonu&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonv, &quot;checkbuttonv&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, frame2, &quot;frame2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, alignment2, &quot;alignment2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, vbox2, &quot;vbox2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonChroma, &quot;checkbuttonChroma&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label8, &quot;label8&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
-
-  return dialog1;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_coloryuv.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_coloryuv.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_coloryuv.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,469 +0,0 @@
-/*
- * DO NOT EDIT THIS FILE - it is generated by Glade.
- */
-
-#include &quot;ADM_toolkitGtk.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;ADM_audio/aviaudio.hxx&quot;
-#include &quot;ADM_audiofilter/audioprocess.hxx&quot;
-#include &quot;ADM_audiofilter/audioeng_buildfilters.h&quot;
-#include &quot;ADM_gladeSupport.h&quot;
-
-#include &quot;ADM_video/ADM_vidColorYuv_param.h&quot;
-
-static GtkWidget    *        create_dialog1 (void);
-
-#define COMBO_SET(x,y) {gtk_combo_box_set_active(GTK_COMBO_BOX(WID(combobox##x)),param-&gt;y);}
-#define COMBO_GET(x,y) {param-&gt;y=gtk_combo_box_get_active(GTK_COMBO_BOX(WID(combobox##x)));}
-
-#define CHECK_GET(x,y) {param-&gt;y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
-#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param-&gt;y);}	
-
-#define SPIN_GET(x,y) {param-&gt;y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;}
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)param-&gt;y) ;}
-
-#define DO_LUMA(x,y) { SPIN(spinbuttonL##x,y_##y);}
-#define DO_CHROU(x,y) { SPIN(spinbuttonU##x,u_##y);}
-#define DO_CHROV(x,y) { SPIN(spinbuttonV##x,v_##y);}
-
-#define DO_ONE(x,y)   {DO_LUMA(x,y);\
-                        DO_CHROU(x,y)\
-                        DO_CHROV(x,y);}
-
-#define DO_ALL() DO_ONE(C,contrast) ;\
-                 DO_ONE(B,bright) ;\
-                 DO_ONE(G,gamma) ;\
-                 DO_ONE(N,gain)
-
-int DIA_coloryuv(COLOR_YUV_PARAM *param)
-{
-    GtkWidget *dialog;
-    int ret=0;
-
-    dialog=create_dialog1();
-    gtk_register_dialog(dialog);
-    
-    COMBO_SET(Matrix,matrix);
-    COMBO_SET(3,levels);
-    COMBO_SET(2,opt);
-        
-    CHECK_SET(checkbuttonAnalyze,analyze);
-    CHECK_SET(checkbuttonAutoGain,autogain);
-    CHECK_SET(checkbuttonAutoWhite,autowhite);
-    
-#define SPIN SPIN_SET
-    DO_ALL();
-    
-    if(GTK_RESPONSE_OK==gtk_dialog_run(GTK_DIALOG(dialog)))			
-    {
-        COMBO_GET(Matrix,matrix);
-        COMBO_GET(3,levels);
-        COMBO_GET(2,opt);
-        
-        CHECK_GET(checkbuttonAnalyze,analyze);
-        CHECK_GET(checkbuttonAutoGain,autogain);
-        CHECK_GET(checkbuttonAutoWhite,autowhite);
-        
-#undef SPIN
-#define SPIN SPIN_GET
-        DO_ALL();
-
-        ret=1;
-    }
-    gtk_unregister_dialog(dialog);
-    gtk_widget_destroy(dialog);
-    return ret;	    
-
-}
-GtkWidget*
-        create_dialog1 (void)
-{
-    GtkWidget *dialog1;
-    GtkWidget *dialog_vbox1;
-    GtkWidget *vbox1;
-    GtkWidget *frame1;
-    GtkWidget *alignment1;
-    GtkWidget *table1;
-    GtkWidget *label2;
-    GtkWidget *label3;
-    GtkWidget *label4;
-    GtkWidget *label5;
-    GtkWidget *label6;
-    GtkWidget *label7;
-    GtkWidget *label8;
-    GtkObject *spinbuttonUC_adj;
-    GtkWidget *spinbuttonUC;
-    GtkObject *spinbuttonVC_adj;
-    GtkWidget *spinbuttonVC;
-    GtkObject *spinbuttonLB_adj;
-    GtkWidget *spinbuttonLB;
-    GtkObject *spinbuttonUB_adj;
-    GtkWidget *spinbuttonUB;
-    GtkObject *spinbuttonVB_adj;
-    GtkWidget *spinbuttonVB;
-    GtkObject *spinbuttonUG_adj;
-    GtkWidget *spinbuttonUG;
-    GtkObject *spinbuttonVG_adj;
-    GtkWidget *spinbuttonVG;
-    GtkObject *spinbuttonLN_adj;
-    GtkWidget *spinbuttonLN;
-    GtkObject *spinbuttonUN_adj;
-    GtkWidget *spinbuttonUN;
-    GtkObject *spinbuttonVN_adj;
-    GtkWidget *spinbuttonVN;
-    GtkObject *spinbutton23_adj;
-    GtkWidget *spinbutton23;
-    GtkObject *spinbutton24_adj;
-    GtkWidget *spinbutton24;
-    GtkWidget *Color_Correction;
-    GtkWidget *Settings;
-    GtkWidget *alignment2;
-    GtkWidget *hbox1;
-    GtkWidget *table2;
-    GtkWidget *label10;
-    GtkWidget *label11;
-    GtkWidget *label12;
-    GtkWidget *comboboxMatrix;
-    GtkWidget *combobox2;
-    GtkWidget *combobox3;
-    GtkWidget *vbox2;
-    GtkWidget *label13;
-    GtkWidget *checkbuttonAutoGain;
-    GtkWidget *checkbuttonAnalyze;
-    GtkWidget *checkbuttonAutoWhite;
-    GtkWidget *label9;
-    GtkWidget *dialog_action_area1;
-    GtkWidget *cancelbutton1;
-    GtkWidget *okbutton1;
-
-    dialog1 = gtk_dialog_new ();
-    gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;ColorYuv (From avisynth)&quot;));
-    gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-    dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-    gtk_widget_show (dialog_vbox1);
-
-    vbox1 = gtk_vbox_new (FALSE, 0);
-    gtk_widget_show (vbox1);
-    gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-    frame1 = gtk_frame_new (NULL);
-    gtk_widget_show (frame1);
-    gtk_box_pack_start (GTK_BOX (vbox1), frame1, TRUE, TRUE, 0);
-    gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_NONE);
-
-    alignment1 = gtk_alignment_new (0.5, 0.5, 1, 1);
-    gtk_widget_show (alignment1);
-    gtk_container_add (GTK_CONTAINER (frame1), alignment1);
-    gtk_alignment_set_padding (GTK_ALIGNMENT (alignment1), 0, 0, 12, 0);
-
-    table1 = gtk_table_new (4, 5, FALSE);
-    gtk_widget_show (table1);
-    gtk_container_add (GTK_CONTAINER (alignment1), table1);
-
-    label2 = gtk_label_new (QT_TR_NOOP(&quot;Contrast&quot;));
-    gtk_widget_show (label2);
-    gtk_table_attach (GTK_TABLE (table1), label2, 1, 2, 0, 1,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-    label3 = gtk_label_new (QT_TR_NOOP(&quot;Brightness&quot;));
-    gtk_widget_show (label3);
-    gtk_table_attach (GTK_TABLE (table1), label3, 2, 3, 0, 1,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-    label4 = gtk_label_new (QT_TR_NOOP(&quot;Gamma&quot;));
-    gtk_widget_show (label4);
-    gtk_table_attach (GTK_TABLE (table1), label4, 3, 4, 0, 1,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-    label5 = gtk_label_new (QT_TR_NOOP(&quot;Gain&quot;));
-    gtk_widget_show (label5);
-    gtk_table_attach (GTK_TABLE (table1), label5, 4, 5, 0, 1,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
-
-    label6 = gtk_label_new (QT_TR_NOOP(&quot;Luma Y&quot;));
-    gtk_widget_show (label6);
-    gtk_table_attach (GTK_TABLE (table1), label6, 0, 1, 1, 2,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label6), 0, 0.5);
-
-    label7 = gtk_label_new (QT_TR_NOOP(&quot;Chroma U&quot;));
-    gtk_widget_show (label7);
-    gtk_table_attach (GTK_TABLE (table1), label7, 0, 1, 2, 3,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label7), 0, 0.5);
-
-    label8 = gtk_label_new (QT_TR_NOOP(&quot;Chroma V&quot;));
-    gtk_widget_show (label8);
-    gtk_table_attach (GTK_TABLE (table1), label8, 0, 1, 3, 4,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label8), 0, 0.5);
-
-    spinbuttonUC_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbuttonUC = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonUC_adj), 1, 0);
-    gtk_widget_show (spinbuttonUC);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonUC, 1, 2, 2, 3,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonUC), TRUE);
-
-    spinbuttonVC_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbuttonVC = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonVC_adj), 1, 0);
-    gtk_widget_show (spinbuttonVC);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonVC, 1, 2, 3, 4,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonVC), TRUE);
-
-    spinbuttonLB_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbuttonLB = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonLB_adj), 1, 0);
-    gtk_widget_show (spinbuttonLB);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonLB, 2, 3, 1, 2,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonLB), TRUE);
-
-    spinbuttonUB_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbuttonUB = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonUB_adj), 1, 0);
-    gtk_widget_show (spinbuttonUB);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonUB, 2, 3, 2, 3,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonUB), TRUE);
-
-    spinbuttonVB_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbuttonVB = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonVB_adj), 1, 0);
-    gtk_widget_show (spinbuttonVB);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonVB, 2, 3, 3, 4,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonVB), TRUE);
-
-    spinbuttonUG_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbuttonUG = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonUG_adj), 1, 0);
-    gtk_widget_show (spinbuttonUG);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonUG, 3, 4, 2, 3,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonUG), TRUE);
-
-    spinbuttonVG_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbuttonVG = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonVG_adj), 1, 0);
-    gtk_widget_show (spinbuttonVG);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonVG, 3, 4, 3, 4,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonVG), TRUE);
-
-    spinbuttonLN_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbuttonLN = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonLN_adj), 1, 0);
-    gtk_widget_show (spinbuttonLN);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonLN, 4, 5, 1, 2,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonLN), TRUE);
-
-    spinbuttonUN_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbuttonUN = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonUN_adj), 1, 0);
-    gtk_widget_show (spinbuttonUN);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonUN, 4, 5, 2, 3,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonUN), TRUE);
-
-    spinbuttonVN_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbuttonVN = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonVN_adj), 1, 0);
-    gtk_widget_show (spinbuttonVN);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonVN, 4, 5, 3, 4,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonVN), TRUE);
-
-    spinbutton23_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbutton23 = gtk_spin_button_new (GTK_ADJUSTMENT (spinbutton23_adj), 1, 0);
-    gtk_widget_show (spinbutton23);
-    gtk_table_attach (GTK_TABLE (table1), spinbutton23, 1, 2, 1, 2,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbutton23), TRUE);
-
-    spinbutton24_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
-    spinbutton24 = gtk_spin_button_new (GTK_ADJUSTMENT (spinbutton24_adj), 1, 0);
-    gtk_widget_show (spinbutton24);
-    gtk_table_attach (GTK_TABLE (table1), spinbutton24, 3, 4, 1, 2,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbutton24), TRUE);
-
-    Color_Correction = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Color Correction Matrix&lt;/b&gt;&quot;));
-    gtk_widget_show (Color_Correction);
-    gtk_frame_set_label_widget (GTK_FRAME (frame1), Color_Correction);
-    gtk_label_set_use_markup (GTK_LABEL (Color_Correction), TRUE);
-
-    Settings = gtk_frame_new (NULL);
-    gtk_widget_show (Settings);
-    gtk_box_pack_start (GTK_BOX (vbox1), Settings, TRUE, TRUE, 0);
-    gtk_frame_set_shadow_type (GTK_FRAME (Settings), GTK_SHADOW_NONE);
-
-    alignment2 = gtk_alignment_new (0.5, 0.5, 1, 1);
-    gtk_widget_show (alignment2);
-    gtk_container_add (GTK_CONTAINER (Settings), alignment2);
-    gtk_alignment_set_padding (GTK_ALIGNMENT (alignment2), 0, 0, 12, 0);
-
-    hbox1 = gtk_hbox_new (FALSE, 0);
-    gtk_widget_show (hbox1);
-    gtk_container_add (GTK_CONTAINER (alignment2), hbox1);
-
-    table2 = gtk_table_new (3, 2, FALSE);
-    gtk_widget_show (table2);
-    gtk_box_pack_start (GTK_BOX (hbox1), table2, TRUE, TRUE, 0);
-
-    label10 = gtk_label_new (QT_TR_NOOP(&quot;Matrix&quot;));
-    gtk_widget_show (label10);
-    gtk_table_attach (GTK_TABLE (table2), label10, 0, 1, 0, 1,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label10), 0, 0.5);
-
-    label11 = gtk_label_new (QT_TR_NOOP(&quot;Opt&quot;));
-    gtk_widget_show (label11);
-    gtk_table_attach (GTK_TABLE (table2), label11, 0, 1, 1, 2,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label11), 0, 0.5);
-
-    label12 = gtk_label_new (QT_TR_NOOP(&quot;Level&quot;));
-    gtk_widget_show (label12);
-    gtk_table_attach (GTK_TABLE (table2), label12, 0, 1, 2, 3,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label12), 0, 0.5);
-
-    comboboxMatrix = gtk_combo_box_new_text ();
-    gtk_widget_show (comboboxMatrix);
-    gtk_table_attach (GTK_TABLE (table2), comboboxMatrix, 1, 2, 0, 1,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (GTK_FILL), 0, 0);
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxMatrix), QT_TR_NOOP(&quot;None&quot;));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxMatrix), QT_TR_NOOP(&quot;Rec.709&quot;));
-
-    combobox2 = gtk_combo_box_new_text ();
-    gtk_widget_show (combobox2);
-    gtk_table_attach (GTK_TABLE (table2), combobox2, 1, 2, 1, 2,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (GTK_FILL), 0, 0);
-    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox2), QT_TR_NOOP(&quot;None&quot;));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox2), QT_TR_NOOP(&quot;Coring&quot;));
-
-    combobox3 = gtk_combo_box_new_text ();
-    gtk_widget_show (combobox3);
-    gtk_table_attach (GTK_TABLE (table2), combobox3, 1, 2, 2, 3,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (GTK_FILL), 0, 0);
-    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox3), QT_TR_NOOP(&quot;None&quot;));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox3), QT_TR_NOOP(&quot;TV-&gt;PC&quot;));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox3), QT_TR_NOOP(&quot;PC-&gt;TV&quot;));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox3), QT_TR_NOOP(&quot;PC-&gt;TV.Y&quot;));
-
-    vbox2 = gtk_vbox_new (FALSE, 0);
-    gtk_widget_show (vbox2);
-    gtk_box_pack_start (GTK_BOX (hbox1), vbox2, TRUE, TRUE, 0);
-
-    label13 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Matrix Warning :&lt;/b&gt;\nall above values are normalized to 256!&quot;));
-    gtk_widget_show (label13);
-    gtk_box_pack_start (GTK_BOX (vbox2), label13, FALSE, FALSE, 0);
-    gtk_label_set_use_markup (GTK_LABEL (label13), TRUE);
-    gtk_label_set_justify (GTK_LABEL (label13), GTK_JUSTIFY_CENTER);
-
-    checkbuttonAutoGain = gtk_check_button_new_with_mnemonic (QT_TR_NOOP(&quot;AutoGain&quot;));
-    gtk_widget_show (checkbuttonAutoGain);
-    gtk_box_pack_start (GTK_BOX (vbox2), checkbuttonAutoGain, FALSE, FALSE, 0);
-
-    checkbuttonAnalyze = gtk_check_button_new_with_mnemonic (QT_TR_NOOP(&quot;Display Stats&quot;));
-    gtk_widget_show (checkbuttonAnalyze);
-    gtk_box_pack_start (GTK_BOX (vbox2), checkbuttonAnalyze, FALSE, FALSE, 0);
-
-    checkbuttonAutoWhite = gtk_check_button_new_with_mnemonic (QT_TR_NOOP(&quot;AutoWhite&quot;));
-    gtk_widget_show (checkbuttonAutoWhite);
-    gtk_box_pack_start (GTK_BOX (vbox2), checkbuttonAutoWhite, FALSE, FALSE, 0);
-
-    label9 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;frame2&lt;/b&gt;&quot;));
-    gtk_widget_show (label9);
-    gtk_frame_set_label_widget (GTK_FRAME (Settings), label9);
-    gtk_label_set_use_markup (GTK_LABEL (label9), TRUE);
-
-    dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-    gtk_widget_show (dialog_action_area1);
-    gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-    cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-    gtk_widget_show (cancelbutton1);
-    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-    GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-    okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-    gtk_widget_show (okbutton1);
-    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-    GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-    /* Store pointers to all widgets, for use by lookup_widget(). */
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, vbox1, &quot;vbox1&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, frame1, &quot;frame1&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, alignment1, &quot;alignment1&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, table1, &quot;table1&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label2, &quot;label2&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label3, &quot;label3&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label4, &quot;label4&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label5, &quot;label5&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label6, &quot;label6&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label7, &quot;label7&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label8, &quot;label8&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonUC, &quot;spinbuttonUC&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonVC, &quot;spinbuttonVC&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonLB, &quot;spinbuttonLB&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonUB, &quot;spinbuttonUB&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonVB, &quot;spinbuttonVB&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonUG, &quot;spinbuttonUG&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonVG, &quot;spinbuttonVG&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonLN, &quot;spinbuttonLN&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonUN, &quot;spinbuttonUN&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonVN, &quot;spinbuttonVN&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbutton23, &quot;spinbutton23&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, spinbutton24, &quot;spinbutton24&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, Color_Correction, &quot;Color_Correction&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, Settings, &quot;Settings&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, alignment2, &quot;alignment2&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, table2, &quot;table2&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label10, &quot;label10&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label11, &quot;label11&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label12, &quot;label12&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, comboboxMatrix, &quot;comboboxMatrix&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, combobox2, &quot;combobox2&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, combobox3, &quot;combobox3&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, vbox2, &quot;vbox2&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label13, &quot;label13&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, checkbuttonAutoGain, &quot;checkbuttonAutoGain&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, checkbuttonAnalyze, &quot;checkbuttonAnalyze&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, checkbuttonAutoWhite, &quot;checkbuttonAutoWhite&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, label9, &quot;label9&quot;);
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
-    GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
-
-    return dialog1;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_equalizer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_equalizer.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_equalizer.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,531 +0,0 @@
-
-//
-/***************************************************************************
-                          DIA_Equalizer
-                             -------------------
-
-			   Ui for equalizer, ugly
-
-    begin                : 30 Dec 2004
-    copyright            : (C) 2004/5 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;math.h&gt;
-
-#include &quot;ADM_toolkitGtk.h&quot;
-
-#include &quot;avi_vars.h&quot;
-
-
-
-#include &quot;ADM_image.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_video/ADM_vidEqualizer.h&quot;
-
-extern &quot;C&quot; {
-#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h&quot;
-}
-
-static ColYuvRgb    *rgbConv=NULL;
-uint8_t DIA_getEqualizer(EqualizerParam *param, ADMImage *image);
-
-static GtkWidget	*create_dialog1 (void);
-static void  		update ( void);
-static gboolean 	draw (void );
-// static void 		reset( void );
-static void 		upload(void);
-static void  		read ( void );
-static void		recalc( void );
-static void 		drawCross(uint32_t x,uint32_t y);
-static void 		spinner(void);
-static void 		compute_histogram(void);
-static void 		frame_changed( void );
-
-extern void GUI_RGBDisplay(uint8_t * dis, uint32_t w, uint32_t h, void *widg);
-extern float UI_calcZoomToFitScreen(GtkWindow* window, GtkWidget* drawingArea, uint32_t imageWidth, uint32_t imageHeight);
-extern void UI_centreCanvasWindow(GtkWindow *window, GtkWidget *canvas, int newCanvasWidth, int newCanvasHeight);
-
-static ADMImage *imgsrc,*imgdst,*imgdisplay;
-static GtkWidget *dialog=NULL;
-static uint32_t scaler[256];
-static uint32_t w,h,zoomW,zoomH;
-static uint32_t *rgbbuffer=NULL;
-static ADMImageResizer *resizer=NULL;
-
-static uint32_t *histogram=NULL;
-static uint32_t *histogramout=NULL;
-static AVDMGenericVideoStream *incoming;
-static const int cross[8]= {0,36,73,109,
-			146,182,219,255};
-#define CROSS 0xFFFF0000
-#define DRAW  0x0000FF00
-#define LINER 0x0000FFFF
-
-#define ZOOM_FACTOR 5
-
-#define A_RESET 99
-//
-//	Video is in YV12 Colorspace
-//
-//
-uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *in)
-{
-	int ret;
-	uint32_t l,f;
-	uint32_t max=in-&gt;getInfo()-&gt;nb_frames;
-        
-	incoming=in;
-	// Allocate space for green-ised video
-	w=in-&gt;getInfo()-&gt;width;
-	h=in-&gt;getInfo()-&gt;height;
-	rgbConv=new ColYuvRgb(w,h);
-        rgbConv-&gt;reset(w,h);
-	
-	histogram=new uint32_t [256*128];
-        histogramout=new uint32_t [256*128];
-	
-	imgdst=new ADMImage(w,h);
-	imgsrc=new ADMImage(w,h);
-        imgdisplay=new ADMImage(w,h);
-	
-        if(curframe&lt;max) max=curframe;
-        
-	ADM_assert(in-&gt;getFrameNumberNoAlloc(max, &amp;l, imgsrc,&amp;f));
-        memcpy(imgdisplay-&gt;data+w*h,imgsrc-&gt;data+w*h,(w*h)&gt;&gt;1);
-	// init local equalizer
-		
-        memcpy(scaler,param-&gt;_scaler,sizeof(scaler));
-
-	dialog=create_dialog1();
-	gtk_register_dialog(dialog);
-	gtk_widget_set_usize(WID(drawingarea_histin), 256,128);
-    gtk_widget_set_usize(WID(drawingarea_histout), 256,128);
-
-	float zoom = UI_calcZoomToFitScreen(GTK_WINDOW(dialog), WID(drawingarea1), w, h);
-
-	zoomW = w * zoom;
-	zoomH = h * zoom;
-	rgbbuffer=new uint32_t[zoomW*zoomH];
-
-	gtk_widget_set_usize(WID(drawingarea1), zoomW, zoomH);
-
-	if (zoom &lt; 1)
-	{
-		UI_centreCanvasWindow((GtkWindow*)dialog, WID(drawingarea1), zoomW, zoomH);
-		resizer = new ADMImageResizer(w, h, zoomW, zoomH, PIX_FMT_YUV420P, PIX_FMT_RGB32);
-	}
-
-	  gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(buttonCancel), GTK_RESPONSE_CANCEL);
-	  gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(button3),      GTK_RESPONSE_OK);
-	  gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(buttonApply),  GTK_RESPONSE_APPLY);
-        gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(buttonReset),  A_RESET);
-	  upload();
-
-	gtk_signal_connect(GTK_OBJECT(WID(drawingarea1)), &quot;expose_event&quot;,
-		       GTK_SIGNAL_FUNC(draw),
-		       NULL);
-		       
-	
-	gtk_signal_connect(GTK_OBJECT(WID(gui_scale)), &quot;value_changed&quot;,GTK_SIGNAL_FUNC(frame_changed),   NULL);
-  //      gtk_signal_connect(GTK_OBJECT(WID(curve1)), &quot;curve-type-changed&quot;,GTK_SIGNAL_FUNC(spinner),   NULL);
-	
-        /*
-
-        */
-        GtkWidget *curve=WID(curve1);
-        gtk_curve_set_range (GTK_CURVE(curve),0,255.,0.,255.);
-	
-        gtk_widget_show(dialog);
-        upload();
-        compute_histogram();
-        spinner();
-	ret=0;
-	int response;
-_again:
-	while( (response=gtk_dialog_run(GTK_DIALOG(dialog)))==GTK_RESPONSE_APPLY)
-	{
-		spinner();	
-	}
-        if(response==A_RESET)
-        {
-                gfloat duo[2]={0,255.};
-                gtk_curve_set_curve_type(GTK_CURVE(WID(curve1)),GTK_CURVE_TYPE_SPLINE);
-                gtk_curve_reset(GTK_CURVE(WID(curve1)));
-
-                goto _again;
-        }
-        
-	if(response==GTK_RESPONSE_OK)
-        {
-		printf(&quot;Accepting new values\n&quot;);
-		memcpy(param-&gt;_scaler,scaler,sizeof(scaler));
-		ret=1;
-	}
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	
-	delete imgdst;
-	delete imgsrc;
-        delete imgdisplay;
-	delete [] rgbbuffer;
-	
-	delete [] histogram;
-        delete [] histogramout;
-    delete rgbConv;
-
-	if (resizer)
-	{
-		delete resizer;
-		resizer=NULL;
-	}
-
-    rgbConv=NULL;    
-	histogram=NULL;
-        histogramout=NULL;
-	
-	rgbbuffer=NULL;
-	imgdst=NULL;
-	imgsrc=NULL;
-	dialog=NULL;
-        imgdisplay=NULL;
-	return ret;
-
-}
-void frame_changed( void )
-{
-uint32_t new_frame,max,l,f;
-double   percent;
-GtkWidget *wid;	
-GtkAdjustment *adj;
-	
-	max=incoming-&gt;getInfo()-&gt;nb_frames;
-	wid=WID(gui_scale);
-	adj=gtk_range_get_adjustment (GTK_RANGE(wid));
-	new_frame=0;
-	
-	percent=(double)GTK_ADJUSTMENT(adj)-&gt;value;
-	percent*=max;
-	percent/=100.;
-	new_frame=(uint32_t)floor(percent);
-	
-	if(new_frame&gt;=max) new_frame=max-1;
-	
-	ADM_assert(incoming-&gt;getFrameNumberNoAlloc(new_frame, &amp;l, imgsrc,&amp;f));
-         memcpy(imgdisplay-&gt;data+w*h,imgsrc-&gt;data+w*h,(w*h)&gt;&gt;1);
-	compute_histogram();
-	update();
-
-}
-void spinner(void)
-{
-		read();
-		recalc();
-		upload();
-                compute_histogram();
-		update();
-}
-void recalc( void )
-{
-uint32_t y,tgt;
-	// compute the in-between field &amp; display them
-	
-	draw();
-}
-void drawCross(uint32_t x,uint32_t y)
-{
-
-}
-void update( void)
-{
-	uint8_t *src,*dst,*disp;
-	src=imgsrc-&gt;data;
-	dst=imgdst-&gt;data;
-	// Only do left side of target
-	for(int y=0;y&lt;h;y++)
-	{
-		for(int x=0;x&lt;w;x++)
-		{
-			*dst=scaler[*src];
-			dst++;
-			src++;
-		}		
-	}
-        // Img src = 10
-        //           01
-        // Img dst= 01
-        //          10
-        uint32_t half=w&gt;&gt;1;
-        
-        dst=imgdst-&gt;data;
-        src=imgsrc-&gt;data;
-        disp=imgdisplay-&gt;data;
-        
-        for(int y=0;y&lt;h;y++)
-        {
-                if(y&gt;h/2)
-                {
-                        memcpy(disp,src,half);
-                        memcpy(disp+half,dst+half,half);
-                
-                
-                }
-                else
-                {
-                
-                        memcpy(disp,dst,half);
-                        memcpy(disp+half,src+half,half);
-                }
-                src+=w;
-                dst+=w;
-                disp+=w;
-        
-        }
-	// udate u &amp; v
-	// now convert to rgb
-	//COL_yv12rgb(  w,   h,imgdisplay-&gt;data,(uint8_t *)rgbbuffer );
-	if (resizer)
-		resizer-&gt;resize(imgdisplay-&gt;data, (uint8_t*)rgbbuffer);
-	else
-		rgbConv-&gt;scale(imgdisplay-&gt;data, (uint8_t*)rgbbuffer);
-
-	draw();
-}
-// Compute histogram
-// Top is histogram in, bottom is histogram out
-void compute_histogram(void)
-{
-	uint32_t value[256];
-        uint32_t valueout[256];
-        uint8_t v;
-        
-	memset(value,0,256*sizeof(uint32_t));
-        memset(valueout,0,256*sizeof(uint32_t));
-        // In
-	for(uint32_t t=0;t&lt;w*h;t++)
-	{
-                v=imgsrc-&gt;data[t];
-		value[v]++;	
-                valueout[scaler[v]]++;
-	}
-	// normalize
-	double d,a;
-	a=w*h;
-	for(uint32_t i=0;i&lt;256;i++)
-	{
-		d=value[i];
-		d*=256*ZOOM_FACTOR;
-		d/=a;
-		value[i]=(uint32_t)floor(d+0.49);
-		
-		if(value[i]&gt;127) value[i]=127;
-                
-                d=valueout[i];
-                d*=256*ZOOM_FACTOR;
-                d/=a;
-                valueout[i]=(uint32_t)floor(d+0.49);
-                
-                if(valueout[i]&gt;127) valueout[i]=127;
-                
-                
-	}
-	// Draw
-	memset(histogram,0,256*128*sizeof(uint32_t));
-        memset(histogramout,0,256*128*sizeof(uint32_t));
-	uint32_t y,tgt,yout;
-	for(uint32_t i=0;i&lt;256;i++)
-	{
-		y=value[i];
-                
-		for(uint32_t u=0;u&lt;=y;u++)
-		{
-			tgt=i+(127-u)*256;
-			histogram[tgt]=0xFFFFFFFF;
-		}
-                
-                y=valueout[i];
-                
-                for(uint32_t u=0;u&lt;=y;u++)
-                {
-                        tgt=i+(127-u)*256;
-                        histogramout[tgt]=0xFFFFFFFF;
-                }
-	}
-
-        
-}
-/*---------------------------------------------------------------------------
-	Actually draw the working frame on screen
-*/
-gboolean draw (void)
-{
-	GtkWidget *draw=WID(drawingarea1);
-
-	GUI_RGBDisplay((uint8_t *)rgbbuffer, zoomW, zoomH, (void *)draw);
-/*	
-	draw=WID(histogram);
-	GUI_RGBDisplay((uint8_t *)bargraph, 256,256, (void *)draw);
-*/	
-	draw=WID(drawingarea_histin);
-	GUI_RGBDisplay((uint8_t *)histogram, 256,128, (void *)draw);
-	
-        draw=WID(drawingarea_histout);
-        GUI_RGBDisplay((uint8_t *)histogramout, 256,128, (void *)draw);
-        
-	return true;
-}
-
-void read ( void)
-{
-uint32_t g;
-
-        gfloat sample[256];
-        gtk_curve_get_vector(GTK_CURVE(WID(curve1)),256,sample);
-        for(int i=0;i&lt;256;i++)
-                {
-                        if(sample[i]&lt;0) g=0;
-                        else if(sample[i]&gt;255) g=255;
-                                else g=(uint32_t)sample[i];
-                        scaler[i]=g;
-                      //  printf(&quot;%u %u\n&quot;,i,scaler[i]);
-                }
-}
-
-void upload(void)
-{
-#define SCALING 1
-gfloat g;
-
-        gfloat sample[256];
-        
-        for(int i=0;i&lt;256/SCALING;i++)
-                {
-                       
-                       sample[i]=scaler[i*SCALING];
-                }
-        gtk_curve_set_vector(GTK_CURVE(WID(curve1)),256/SCALING,sample);
-        //gtk_curve_set_curve_type(GTK_CURVE(WID(curve1)),GTK_CURVE_TYPE_LINEAR);
-
-}
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *hbox2;
-  GtkWidget *curve1;
-  GtkWidget *vseparator1;
-  GtkWidget *vbox3;
-  GtkWidget *drawingarea_histin;
-  GtkWidget *drawingarea_histout;
-  GtkWidget *hbox1;
-  GtkWidget *buttonReset;
-  GtkWidget *buttonCancel;
-  GtkWidget *buttonApply;
-  GtkWidget *button3;
-  GtkWidget *gui_scale;
-  GtkWidget *drawingarea1;
-  GtkWidget *dialog_action_area1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;Equalizer&quot;));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  hbox2 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox2);
-  gtk_box_pack_start (GTK_BOX (vbox1), hbox2, TRUE, TRUE, 0);
-
-  curve1 = gtk_curve_new ();
-  gtk_widget_show (curve1);
-  gtk_box_pack_start (GTK_BOX (hbox2), curve1, FALSE, FALSE, 0);
-  gtk_curve_set_range (GTK_CURVE (curve1), 0, 1, 0, 1);
-
-  vseparator1 = gtk_vseparator_new ();
-  gtk_widget_show (vseparator1);
-  gtk_box_pack_start (GTK_BOX (hbox2), vseparator1, FALSE, FALSE, 0);
-
-  vbox3 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox3);
-  gtk_box_pack_start (GTK_BOX (hbox2), vbox3, TRUE, TRUE, 0);
-
-  drawingarea_histin = gtk_drawing_area_new ();
-  gtk_widget_show (drawingarea_histin);
-  gtk_box_pack_start (GTK_BOX (vbox3), drawingarea_histin, TRUE, TRUE, 0);
-  gtk_widget_set_size_request (drawingarea_histin, 10, -1);
-
-  drawingarea_histout = gtk_drawing_area_new ();
-  gtk_widget_show (drawingarea_histout);
-  gtk_box_pack_start (GTK_BOX (vbox3), drawingarea_histout, TRUE, TRUE, 0);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox1);
-  gtk_box_pack_start (GTK_BOX (vbox1), hbox1, FALSE, TRUE, 0);
-
-  buttonReset = gtk_button_new_from_stock (&quot;gtk-clear&quot;);
-  gtk_widget_show (buttonReset);
-  gtk_box_pack_start (GTK_BOX (hbox1), buttonReset, FALSE, FALSE, 0);
-
-  buttonCancel = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-  gtk_widget_show (buttonCancel);
-  gtk_box_pack_start (GTK_BOX (hbox1), buttonCancel, FALSE, FALSE, 0);
-
-  buttonApply = gtk_button_new_from_stock (&quot;gtk-apply&quot;);
-  gtk_widget_show (buttonApply);
-  gtk_box_pack_start (GTK_BOX (hbox1), buttonApply, FALSE, FALSE, 0);
-
-  button3 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (button3);
-  gtk_box_pack_start (GTK_BOX (hbox1), button3, FALSE, FALSE, 0);
-
-  gui_scale = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 100, 1, 10, 10)));
-  gtk_widget_show (gui_scale);
-  gtk_box_pack_start (GTK_BOX (vbox1), gui_scale, TRUE, TRUE, 0);
-
-  drawingarea1 = gtk_drawing_area_new ();
-  gtk_widget_show (drawingarea1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), drawingarea1, TRUE, TRUE, 0);
-  gtk_widget_set_size_request (drawingarea1, 100, 100);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, &quot;vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hbox2, &quot;hbox2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, curve1, &quot;curve1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, vseparator1, &quot;vseparator1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, vbox3, &quot;vbox3&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, drawingarea_histin, &quot;drawingarea_histin&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, drawingarea_histout, &quot;drawingarea_histout&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, buttonReset, &quot;buttonReset&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, buttonCancel, &quot;buttonCancel&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, buttonApply, &quot;buttonApply&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, button3, &quot;button3&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, gui_scale, &quot;gui_scale&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, drawingarea1, &quot;drawingarea1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-
-  //gtk_widget_grab_default (buttonApply);
-  return dialog1;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mpdelogo.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mpdelogo.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mpdelogo.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,524 +0,0 @@
-/***************************************************************************
-                          DIA_crop.cpp  -  description
-                             -------------------
-
-			    GUI for cropping including autocrop
-			    +Revisted the Gtk2 way
-			     +Autocrop now in RGB space (more accurate)
-
-    begin                : Fri May 3 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;math.h&gt;
-
-#include &quot;ADM_toolkitGtk.h&quot;
-
-
-#include &quot;ADM_image.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_colorspace.h&quot;
-#include &quot;ADM_video/ADM_vidMPdelogo.h&quot;
-
-extern &quot;C&quot; {
-#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h&quot;
-}
-
-static GtkWidget	*create_dialog1 (void);
-static void  		ui_read ( void);
-static void  		ui_update ( void);
-static void 		draw (GtkWidget *dialog,uint32_t w,uint32_t h );
-static gboolean 	gui_draw( void );
-static void 		autocrop (void );
-static void 		reset( void );
-static void 		ui_upload(void);
-static gboolean		ui_changed(void);
-
-
-static void		prepare(uint32_t img);
-static void 		frame_changed( void );
-
-extern void GUI_RGBDisplay(uint8_t * dis, uint32_t w, uint32_t h, void *widg);
-extern float UI_calcZoomToFitScreen(GtkWindow* window, GtkWidget* drawingArea, uint32_t imageWidth, uint32_t imageHeight);
-extern void UI_centreCanvasWindow(GtkWindow *window, GtkWidget *canvas, int newCanvasWidth, int newCanvasHeight);
-
-static ColYuvRgb    *rgbConv=NULL;
-static uint8_t *working=NULL;
-static uint8_t *rgbBufferDisplay=NULL;
-static uint8_t *original=NULL;
-static GtkWidget *dialog=NULL;
-static uint32_t x,y,w,h,zoomW,zoomH,band;
-
-static AVDMGenericVideoStream *incoming=NULL;
-static ADMImage *imgsrc=NULL;
-static ADMImageResizer *resizer=NULL;
-
-static int lock=0,width,height;
-
-
-//
-//	Video is in YV12 Colorspace
-//
-//
-uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in)
-
-{
-	// Allocate space for green-ised video
-	width=in-&gt;getInfo()-&gt;width;
-	height=in-&gt;getInfo()-&gt;height;
-		
-	working=new uint8_t [width*height*4];	
-	original=NULL;
-
-	uint8_t ret=0;
-
-	dialog=create_dialog1();
-        gtk_register_dialog(dialog);
-	
-	x=param-&gt;xoff;
-	y=param-&gt;yoff;
-	w=param-&gt;lw;
-	h=param-&gt;lh;
-	band=param-&gt;band;
-
-	imgsrc=new ADMImage(width,height);
-	incoming=in;
-	
-	rgbConv=new ColYuvRgb(width,height);
-        rgbConv-&gt;reset(width,height);
-
-	float zoom = UI_calcZoomToFitScreen(GTK_WINDOW(dialog), WID(drawingarea1), width, height);
-
-	zoomW = width * zoom;
-	zoomH = height * zoom;
-	rgbBufferDisplay=new uint8_t[zoomW*zoomH*4];
-
-	gtk_widget_set_usize(WID(drawingarea1), zoomW, zoomH);
-
-	if (zoom &lt; 1)
-	{
-		UI_centreCanvasWindow((GtkWindow*)dialog, WID(drawingarea1), zoomW, zoomH);
-		resizer = new ADMImageResizer(width, height, zoomW, zoomH, PIX_FMT_RGB32, PIX_FMT_RGB32);
-	}
-
-	prepare(0);
-	gtk_widget_show(dialog);
-	
-	ui_upload();
-	ui_update();
-	
-#define CONNECT(x,y,z) 	gtk_signal_connect(GTK_OBJECT(WID(x)), #y,GTK_SIGNAL_FUNC(z),   NULL);
-
-        CONNECT(drawingarea1,expose_event,gui_draw);
-        CONNECT(hscale1,value_changed,frame_changed);	  
-		      
-#define CONNECT_SPIN(x) CONNECT(spinbutton##x, value_changed,ui_changed)
-      	  
-        CONNECT_SPIN(X);
-        CONNECT_SPIN(Y);
-        CONNECT_SPIN(W);
-        CONNECT_SPIN(H);
-        CONNECT_SPIN(Band);
-	  
-	draw(dialog,width,height);
-
-	ret=0;
-	int response;
-	while( (response=gtk_dialog_run(GTK_DIALOG(dialog)))==GTK_RESPONSE_APPLY)
-	{
-		ui_changed();
-		
-	}
-	if(response==GTK_RESPONSE_OK)
-        {
-		ui_read( );
-		param-&gt;xoff=x;
-                param-&gt;yoff=y;
-                param-&gt;lw=w;
-                param-&gt;lh=h;
-                param-&gt;band=band;
-		ret=1;
-	}
-        gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	delete working;	
-	delete imgsrc;
-	delete rgbConv;
-
-	if (resizer)
-	{
-		delete resizer;
-		delete[] rgbBufferDisplay;
-
-		resizer=NULL;
-		rgbBufferDisplay=NULL;
-	}
-
-	working=NULL;
-	dialog=NULL;
-	original=NULL;
-	imgsrc=NULL;
-	return ret;
-}
-void frame_changed( void )
-{
-uint32_t new_frame,max,l,f;
-double   percent;
-GtkWidget *wid;	
-GtkAdjustment *adj;
-
-        max=incoming-&gt;getInfo()-&gt;nb_frames;
-        wid=WID(hscale1);
-        adj=gtk_range_get_adjustment (GTK_RANGE(wid));
-        new_frame=0;
-        
-        percent=(double)GTK_ADJUSTMENT(adj)-&gt;value;
-        percent*=max;
-        percent/=100.;
-        new_frame=(uint32_t)floor(percent);
-        
-        if(new_frame&gt;=max) new_frame=max-1;
-        
-        prepare(new_frame);
-        ui_update();
-        gui_draw();
-
-
-}
-void prepare(uint32_t img)
-{
-	uint32_t l,f;
-	
-	ADM_assert(incoming-&gt;getFrameNumberNoAlloc(img,&amp;l,imgsrc,&amp;f));
-	original=imgsrc-&gt;data;
-	
-
-}
-gboolean ui_changed(void)
-{
-	if(!lock)
-	{
-		ui_read();
-		memcpy(working,original,(width*height*3)&gt;&gt;1);
-		ui_update();
-		draw(dialog,width,height);
-	}
-		return true;
-}
-
-
-/*---------------------------------------------------------------------------
-	Actually draw the working frame on screen
-*/
-gboolean gui_draw( void )
-{
-	draw(dialog,width,height);
-	return true;
-}
-void draw (GtkWidget *dialog,uint32_t w,uint32_t h )
-{
-	GtkWidget *draw=WID(drawingarea1);
-
-	if (resizer)
-	{
-		resizer-&gt;resize(working, rgbBufferDisplay);
-		GUI_RGBDisplay(rgbBufferDisplay, zoomW, zoomH, (void*)draw);
-	}
-	else
-		GUI_RGBDisplay(working, w, h, (void*)draw);
-}
-/*---------------------------------------------------------------------------
-	Read entried from dialog box
-*/
-
-#define SPIN_GET(x,y) {x= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(spinbutton##y))) ;}
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(spinbutton##y)),(gfloat)x) ;}
-
-
-void ui_read (void )
-{
-	int reject=0;
-	
-			SPIN_GET(x,X);
-			SPIN_GET(y,Y);
-			SPIN_GET(h,H);
-			SPIN_GET(w,W);
-                        SPIN_GET(band,Band);
-			
-			//printf(&quot;%d %d %d %d\n&quot;,x,y,w,h);
-			
-			x&amp;=0xffffe;
-			y&amp;=0xffffe;
-			h&amp;=0xffffe;
-			w&amp;=0xffffe;
-			
-			if((x+w)&gt;width)
-				{
-                                        if(w&gt;=width) w=width;
-                                        x=width-w;
-                                        reject=1;
-				}
-			if((y+h)&gt;height)
-				{
-                                        if(h&gt;=height) h=height;
-                                        y=height-h;
-                                        reject=1;
-				}
-			if(reject)
-				ui_upload();
-}
-
-void ui_upload(void)
-{
-	lock++;
-	SPIN_SET(x,X);
-	SPIN_SET(y,Y);
-	SPIN_SET(w,W);
-	SPIN_SET(h,H);
-        SPIN_SET(band,Band);
-	lock--;
-}
-//____________________________________
-void reset( void )
-{
-	
-	x=y=w=h=0;
-	ui_upload();
-	ui_update();
-	gui_draw();
-	
-
-}
-/*---------------------------------------------------------------------------
-	Green-ify the displayed frame on cropped parts
-*/
-void ui_update( )
-{
-
-        uint8_t  *in,*in2;
-        uint8_t *buffer=working;
-
-        rgbConv-&gt;scale(original,buffer);
-        // Buffer is in RGB space
-        in=buffer+x*4+y*width*4;
-        in2=buffer+(x+w)*4+y*width*4;
-        
-        for(int yy=0;yy&lt;h;yy++)
-        {
-          in[0]=in[2]=0;in[1]=0xff;
-          in2[0]=in2[2]=0;in2[1]=0xff;
-          in+=width*4;
-          in2+=width*4;
-        }
-        in=buffer+(y*width+x)*4;
-        in2=buffer+((y+h)*width+x)*4;
-        for(int yy=0;yy&lt;w;yy++)
-        {
-          in[0]=in[2]=0;in[1]=0xff;
-          in2[0]=in2[2]=0;in2[1]=0xff;
-          in+=4;
-          in2+=4;
-        }
-
-}
-
-//--------------------------------------------
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *vbox2;
-  GtkWidget *table2;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkWidget *label5;
-  GtkWidget *label6;
-  GtkWidget *label7;
-  GtkObject *spinbuttonX_adj;
-  GtkWidget *spinbuttonX;
-  GtkObject *spinbuttonY_adj;
-  GtkWidget *spinbuttonY;
-  GtkObject *spinbuttonW_adj;
-  GtkWidget *spinbuttonW;
-  GtkObject *spinbuttonH_adj;
-  GtkWidget *spinbuttonH;
-  GtkWidget *hseparator1;
-  GtkWidget *hseparator2;
-  GtkObject *spinbuttonBand_adj;
-  GtkWidget *spinbuttonBand;
-  GtkWidget *hseparator3;
-  GtkWidget *hscale1;
-  GtkWidget *drawingarea1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;Mplayer Delogo&quot;));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  vbox2 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox2);
-  gtk_box_pack_start (GTK_BOX (vbox1), vbox2, FALSE, FALSE, 0);
-
-  table2 = gtk_table_new (3, 4, FALSE);
-  gtk_widget_show (table2);
-  gtk_box_pack_start (GTK_BOX (vbox2), table2, TRUE, TRUE, 0);
-
-  label3 = gtk_label_new (QT_TR_NOOP(&quot;X&quot;));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table2), label3, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (QT_TR_NOOP(&quot;Y&quot;));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table2), label4, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  label5 = gtk_label_new (QT_TR_NOOP(&quot;W&quot;));
-  gtk_widget_show (label5);
-  gtk_table_attach (GTK_TABLE (table2), label5, 2, 3, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
-
-  label6 = gtk_label_new (QT_TR_NOOP(&quot;H&quot;));
-  gtk_widget_show (label6);
-  gtk_table_attach (GTK_TABLE (table2), label6, 2, 3, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label6), 0, 0.5);
-
-  label7 = gtk_label_new (QT_TR_NOOP(&quot;Band&quot;));
-  gtk_widget_show (label7);
-  gtk_table_attach (GTK_TABLE (table2), label7, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label7), 0, 0.5);
-
-  spinbuttonX_adj = gtk_adjustment_new (1, 0, 2000, 1, 10, 10);
-  spinbuttonX = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonX_adj), 1, 0);
-  gtk_widget_show (spinbuttonX);
-  gtk_table_attach (GTK_TABLE (table2), spinbuttonX, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  spinbuttonY_adj = gtk_adjustment_new (1, 0, 2000, 1, 10, 10);
-  spinbuttonY = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonY_adj), 1, 0);
-  gtk_widget_show (spinbuttonY);
-  gtk_table_attach (GTK_TABLE (table2), spinbuttonY, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  spinbuttonW_adj = gtk_adjustment_new (1, 0, 2000, 1, 10, 10);
-  spinbuttonW = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonW_adj), 1, 0);
-  gtk_widget_show (spinbuttonW);
-  gtk_table_attach (GTK_TABLE (table2), spinbuttonW, 3, 4, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  spinbuttonH_adj = gtk_adjustment_new (1, 0, 2000, 1, 10, 10);
-  spinbuttonH = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonH_adj), 1, 0);
-  gtk_widget_show (spinbuttonH);
-  gtk_table_attach (GTK_TABLE (table2), spinbuttonH, 3, 4, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  hseparator1 = gtk_hseparator_new ();
-  gtk_widget_show (hseparator1);
-  gtk_table_attach (GTK_TABLE (table2), hseparator1, 3, 4, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-
-  hseparator2 = gtk_hseparator_new ();
-  gtk_widget_show (hseparator2);
-  gtk_table_attach (GTK_TABLE (table2), hseparator2, 2, 3, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-
-  spinbuttonBand_adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
-  spinbuttonBand = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonBand_adj), 1, 0);
-  gtk_widget_show (spinbuttonBand);
-  gtk_table_attach (GTK_TABLE (table2), spinbuttonBand, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  hseparator3 = gtk_hseparator_new ();
-  gtk_widget_show (hseparator3);
-  gtk_box_pack_start (GTK_BOX (vbox2), hseparator3, FALSE, FALSE, 0);
-
-  hscale1 = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 100, 1, 1, 0)));
-  gtk_widget_show (hscale1);
-  gtk_box_pack_start (GTK_BOX (vbox1), hscale1, FALSE, FALSE, 0);
-
-  drawingarea1 = gtk_drawing_area_new ();
-  gtk_widget_show (drawingarea1);
-  gtk_box_pack_start (GTK_BOX (vbox1), drawingarea1, TRUE, TRUE, 0);
-  gtk_widget_set_size_request (drawingarea1, 100, 100);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, &quot;vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, vbox2, &quot;vbox2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, table2, &quot;table2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label3, &quot;label3&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label4, &quot;label4&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label5, &quot;label5&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label6, &quot;label6&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label7, &quot;label7&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonX, &quot;spinbuttonX&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonY, &quot;spinbuttonY&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonW, &quot;spinbuttonW&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonH, &quot;spinbuttonH&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hseparator1, &quot;hseparator1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hseparator2, &quot;hseparator2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonBand, &quot;spinbuttonBand&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hseparator3, &quot;hseparator3&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hscale1, &quot;hscale1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, drawingarea1, &quot;drawingarea1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
-
-  return dialog1;
-}
-
-

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -25,12 +25,12 @@
 #include &quot;ADM_assert.h&quot;
 
 #include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_video/ADM_vidCNR2_param.h&quot;
-#include &quot;ADM_video/ADM_vidColorYuv_param.h&quot;
+
+
 #include &quot;ADM_video/ADM_vidPartial_param.h&quot;
-#include &quot;ADM_video/ADM_vidEqualizer.h&quot;
-#include &quot;ADM_video/ADM_vidMPdelogo.h&quot;
 
+
+
 #include &quot;ADM_videoFilter/ADM_vidAnimated_param.h&quot;
 #include &quot;ADM_videoFilter/ADM_vidASharp_param.h&quot;
 #include &quot;ADM_videoFilter/ADM_vidChromaShift_param.h&quot;
@@ -55,9 +55,9 @@
 
 int SliderIsShifted = 0;
 
-int DIA_coloryuv(COLOR_YUV_PARAM *param) {return 0;}
 
 
+
 #ifdef USE_XX_XVID 
 #include &quot;xvid.h&quot;
 int  DIA_getXvidCompressParams(COMPRESSION_MODE * mode, uint32_t * qz,
@@ -65,13 +65,12 @@
 #endif
 
 uint8_t DIA_animated(ANIMATED_PARAM *param) {return 0;}
-uint8_t DIA_cnr2(CNR2Param *param) {return 0;}
+
 uint8_t DIA_getASharp(ASHARP_PARAM *param, AVDMGenericVideoStream *in) {return 0;}
 uint8_t DIA_getEQ2Param(Eq2_Param *param, AVDMGenericVideoStream *in) {return 0;}
-uint8_t DIA_getEqualizer(EqualizerParam *param, ADMImage *image) {return 0;}
-uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *in) {return 0;}
+
 uint8_t DIA_getHue(Hue_Param *param, AVDMGenericVideoStream *in) {return 0;}
-uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in) {return 0;}
+
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous) {return 0;}
 uint8_t DIA_pipe(char **cmd,char **param) {return 0;}
 uint8_t DIA_vobsub(vobSubParam *param) {return 0;}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/CMakeLists.txt	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/CMakeLists.txt	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,11 +1,11 @@
 SET(ADM_LIB ADM_dialogQt4)
 
 SET(uiFiles
-	about.ui  asharp.ui  chromashift.ui  contrast.ui  eq2.ui  crop.ui  encoding.ui  hue.ui  license.ui
+	about.ui  asharp.ui    contrast.ui  eq2.ui  crop.ui  encoding.ui  hue.ui  license.ui
 	jobs.ui  props.ui    vobsub.ui  working.ui)
 
 SET(headers
-	Q_about.h  Q_asharp.h  Q_chromashift.h  Q_contrast.h  Q_crop.h  Q_encoding.h  Q_eq2.h  Q_hue.h
+	Q_about.h  Q_asharp.h   Q_contrast.h  Q_crop.h  Q_encoding.h  Q_eq2.h  Q_hue.h
 	Q_license.h  Q_jobs.h  Q_props.h    Q_vobsub.h  Q_working.h  T_index_pg.h)
 
 IF (USE_FREETYPE)
@@ -20,7 +20,7 @@
 
 SET(${ADM_LIB}_SRCS ${${ADM_LIB}_SRCS}
 	${${ADM_LIB}_headers}  ${${ADM_LIB}_source}  ${${ADM_LIB}_resource}  Q_about.cpp  Q_asharp.cpp
-	Q_chromashift.cpp  Q_contrast.cpp  Q_crop.cpp  Q_encoding.cpp  Q_eq2.cpp  Q_hue.cpp  Q_license.cpp
+	Q_contrast.cpp  Q_crop.cpp  Q_encoding.cpp  Q_eq2.cpp  Q_hue.cpp  Q_license.cpp
 	Q_jobs.cpp  Q_props.cpp   Q_vobsub.cpp  Q_working.cpp  T_flyDialog.cpp  T_index_pg.cpp
 	T_QCanvas.cpp  alert_qt4.cpp  DIA_busy.cpp  DIA_none.cpp  DIA_xvid4.cpp  OCR_none.cpp)
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -16,11 +16,11 @@
 #include &quot;config.h&quot;
 #include &quot;ADM_default.h&quot;
 #include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_video/ADM_vidCNR2_param.h&quot;
-#include &quot;ADM_video/ADM_vidColorYuv_param.h&quot;
-#include &quot;ADM_video/ADM_vidEqualizer.h&quot;
-#include &quot;ADM_video/ADM_vidMPdelogo.h&quot;
 
+
+
+
+
 #include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
 #include &quot;ADM_audiofilter/audioencoder.h&quot;
 
@@ -29,11 +29,9 @@
 int  DIA_getXvidCompressParams(COMPRESSION_MODE * mode, uint32_t * qz,
 		      uint32_t * br,uint32_t *fsize,xvidEncParam *param){return 0;}
 #endif
-int     DIA_coloryuv(COLOR_YUV_PARAM *param){return 0;}
-uint8_t DIA_cnr2(CNR2Param *param){return 0;}
-uint8_t DIA_getEqualizer(EqualizerParam *param, ADMImage *image){return 0;}
-uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *in){return 0;}
-uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in){return 0;}
+
+
+
 uint8_t DIA_videoCodec(int *codecIndex) {return 0;}
 uint8_t DIA_audioCodec( AUDIOENCODER *codec ) {return 0;}
 uint8_t DIA_quota(char *) {return 0;}

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_chromashift.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_chromashift.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_chromashift.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,118 +0,0 @@
-/***************************************************************************
-                          DIA_crop.cpp  -  description
-                             -------------------
-
-			    GUI for cropping including autocrop
-			    +Revisted the Gtk2 way
-			     +Autocrop now in RGB space (more accurate)
-
-    begin                : Fri May 3 2002
-    copyright            : (C) 2002/2007 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;Q_chromashift.h&quot;
-
-Ui_chromaShiftWindow::Ui_chromaShiftWindow(CHROMASHIFT_PARAM *param,AVDMGenericVideoStream *in)
-  {
-    uint32_t width,height;
-        ui.setupUi(this);
-        lock=0;
-        
-        // Allocate space for green-ised video
-        width=in-&gt;getInfo()-&gt;width;
-        height=in-&gt;getInfo()-&gt;height;
-        
-        int boundary=width/2;
-        
-        ui.spinBoxU-&gt;setMaximum(boundary/2);
-        ui.spinBoxU-&gt;setMinimum(-boundary);
-        ui.spinBoxV-&gt;setMaximum(boundary/2);
-        ui.spinBoxV-&gt;setMinimum(-boundary);
-        
-        canvas=new ADM_QCanvas(ui.graphicsView,width,height);
-        
-        myCrop=new flyChromaShift( width, height,in,canvas,ui.horizontalSlider);
-        memcpy(&amp;(myCrop-&gt;param),param,sizeof(CHROMASHIFT_PARAM));
-        myCrop-&gt;_cookie=&ui;
-        myCrop-&gt;upload();
-        myCrop-&gt;sliderChanged();
-
-
-        connect( ui.horizontalSlider,SIGNAL(valueChanged(int)),this,SLOT(sliderUpdate(int)));
-#define SPINNER(x) connect( ui.spinBox##x,SIGNAL(valueChanged(int)),this,SLOT(valueChanged(int))); 
-          SPINNER(U);
-          SPINNER(V);
-  }
-  void Ui_chromaShiftWindow::sliderUpdate(int foo)
-  {
-    myCrop-&gt;sliderChanged();
-  }
-  void Ui_chromaShiftWindow::gather(CHROMASHIFT_PARAM *param)
-  {
-    
-        myCrop-&gt;download();
-        memcpy(param,&amp;(myCrop-&gt;param),sizeof(CHROMASHIFT_PARAM));
-  }
-Ui_chromaShiftWindow::~Ui_chromaShiftWindow()
-{
-  if(myCrop) delete myCrop;
-  myCrop=NULL; 
-  if(canvas) delete canvas;
-  canvas=NULL;
-}
-void Ui_chromaShiftWindow::valueChanged( int f )
-{
-  if(lock) return;
-  lock++;
-  myCrop-&gt;update();
-  lock--;
-}
-
-#define MYSPIN(x) w-&gt;spinBox##x
-//************************
-uint8_t flyChromaShift::upload(void)
-{
-      Ui_chromashiftDialog *w=(Ui_chromashiftDialog *)_cookie;
-
-        MYSPIN(U)-&gt;setValue(param.u);
-        MYSPIN(V)-&gt;setValue(param.v);
-        return 1;
-}
-uint8_t flyChromaShift::download(void)
-{
-       Ui_chromashiftDialog *w=(Ui_chromashiftDialog *)_cookie;
-       param.u= MYSPIN(U)-&gt;value();
-       param.v= MYSPIN(V)-&gt;value();
-       
-}
-
-/**
-      \fn     DIA_getChromaShift
-      \brief  Handle crop dialog
-*/
-uint8_t DIA_getChromaShift( AVDMGenericVideoStream *in,CHROMASHIFT_PARAM    *param )
-{
-        uint8_t ret=0;
-        
-        Ui_chromaShiftWindow dialog(param,in);        
-        if(dialog.exec()==QDialog::Accepted)
-        {
-            dialog.gather(param); 
-            ret=1;
-        }
-        return ret;
-}
-//____________________________________
-// EOF
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/chromashift.ui
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/chromashift.ui	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/chromashift.ui	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,153 +0,0 @@
-&lt;ui version=&quot;4.0&quot; &gt;
- &lt;class&gt;chromashiftDialog&lt;/class&gt;
- &lt;widget class=&quot;QDialog&quot; name=&quot;chromashiftDialog&quot; &gt;
-  &lt;property name=&quot;geometry&quot; &gt;
-   &lt;rect&gt;
-    &lt;x&gt;0&lt;/x&gt;
-    &lt;y&gt;0&lt;/y&gt;
-    &lt;width&gt;422&lt;/width&gt;
-    &lt;height&gt;585&lt;/height&gt;
-   &lt;/rect&gt;
-  &lt;/property&gt;
-  &lt;property name=&quot;windowTitle&quot; &gt;
-   &lt;string&gt;ChromaShift&lt;/string&gt;
-  &lt;/property&gt;
-  &lt;layout class=&quot;QGridLayout&quot; &gt;
-   &lt;property name=&quot;leftMargin&quot; &gt;
-    &lt;number&gt;9&lt;/number&gt;
-   &lt;/property&gt;
-   &lt;property name=&quot;topMargin&quot; &gt;
-    &lt;number&gt;9&lt;/number&gt;
-   &lt;/property&gt;
-   &lt;property name=&quot;rightMargin&quot; &gt;
-    &lt;number&gt;9&lt;/number&gt;
-   &lt;/property&gt;
-   &lt;property name=&quot;bottomMargin&quot; &gt;
-    &lt;number&gt;9&lt;/number&gt;
-   &lt;/property&gt;
-   &lt;property name=&quot;horizontalSpacing&quot; &gt;
-    &lt;number&gt;6&lt;/number&gt;
-   &lt;/property&gt;
-   &lt;property name=&quot;verticalSpacing&quot; &gt;
-    &lt;number&gt;6&lt;/number&gt;
-   &lt;/property&gt;
-   &lt;item row=&quot;1&quot; column=&quot;0&quot; &gt;
-    &lt;widget class=&quot;QLabel&quot; name=&quot;label_2&quot; &gt;
-     &lt;property name=&quot;text&quot; &gt;
-      &lt;string&gt;V Shift&lt;/string&gt;
-     &lt;/property&gt;
-    &lt;/widget&gt;
-   &lt;/item&gt;
-   &lt;item row=&quot;0&quot; column=&quot;0&quot; &gt;
-    &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot; &gt;
-     &lt;property name=&quot;text&quot; &gt;
-      &lt;string&gt;U Shift&lt;/string&gt;
-     &lt;/property&gt;
-    &lt;/widget&gt;
-   &lt;/item&gt;
-   &lt;item row=&quot;4&quot; column=&quot;3&quot; &gt;
-    &lt;spacer&gt;
-     &lt;property name=&quot;orientation&quot; &gt;
-      &lt;enum&gt;Qt::Vertical&lt;/enum&gt;
-     &lt;/property&gt;
-     &lt;property name=&quot;sizeType&quot; &gt;
-      &lt;enum&gt;QSizePolicy::Maximum&lt;/enum&gt;
-     &lt;/property&gt;
-     &lt;property name=&quot;sizeHint&quot; &gt;
-      &lt;size&gt;
-       &lt;width&gt;20&lt;/width&gt;
-       &lt;height&gt;16&lt;/height&gt;
-      &lt;/size&gt;
-     &lt;/property&gt;
-    &lt;/spacer&gt;
-   &lt;/item&gt;
-   &lt;item row=&quot;5&quot; column=&quot;0&quot; colspan=&quot;4&quot; &gt;
-    &lt;widget class=&quot;QDialogButtonBox&quot; name=&quot;buttonBox&quot; &gt;
-     &lt;property name=&quot;orientation&quot; &gt;
-      &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
-     &lt;/property&gt;
-     &lt;property name=&quot;standardButtons&quot; &gt;
-      &lt;set&gt;QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok&lt;/set&gt;
-     &lt;/property&gt;
-    &lt;/widget&gt;
-   &lt;/item&gt;
-   &lt;item row=&quot;2&quot; column=&quot;0&quot; colspan=&quot;4&quot; &gt;
-    &lt;widget class=&quot;QSlider&quot; name=&quot;horizontalSlider&quot; &gt;
-     &lt;property name=&quot;orientation&quot; &gt;
-      &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
-     &lt;/property&gt;
-    &lt;/widget&gt;
-   &lt;/item&gt;
-   &lt;item row=&quot;3&quot; column=&quot;0&quot; colspan=&quot;4&quot; &gt;
-    &lt;widget class=&quot;QGraphicsView&quot; name=&quot;graphicsView&quot; /&gt;
-   &lt;/item&gt;
-   &lt;item row=&quot;1&quot; column=&quot;1&quot; &gt;
-    &lt;widget class=&quot;QSpinBox&quot; name=&quot;spinBoxV&quot; /&gt;
-   &lt;/item&gt;
-   &lt;item row=&quot;0&quot; column=&quot;1&quot; &gt;
-    &lt;widget class=&quot;QSpinBox&quot; name=&quot;spinBoxU&quot; /&gt;
-   &lt;/item&gt;
-   &lt;item row=&quot;0&quot; column=&quot;2&quot; &gt;
-    &lt;spacer&gt;
-     &lt;property name=&quot;orientation&quot; &gt;
-      &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
-     &lt;/property&gt;
-     &lt;property name=&quot;sizeHint&quot; &gt;
-      &lt;size&gt;
-       &lt;width&gt;40&lt;/width&gt;
-       &lt;height&gt;20&lt;/height&gt;
-      &lt;/size&gt;
-     &lt;/property&gt;
-    &lt;/spacer&gt;
-   &lt;/item&gt;
-   &lt;item row=&quot;1&quot; column=&quot;2&quot; &gt;
-    &lt;spacer&gt;
-     &lt;property name=&quot;orientation&quot; &gt;
-      &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
-     &lt;/property&gt;
-     &lt;property name=&quot;sizeHint&quot; &gt;
-      &lt;size&gt;
-       &lt;width&gt;40&lt;/width&gt;
-       &lt;height&gt;20&lt;/height&gt;
-      &lt;/size&gt;
-     &lt;/property&gt;
-    &lt;/spacer&gt;
-   &lt;/item&gt;
-  &lt;/layout&gt;
- &lt;/widget&gt;
- &lt;resources/&gt;
- &lt;connections&gt;
-  &lt;connection&gt;
-   &lt;sender&gt;buttonBox&lt;/sender&gt;
-   &lt;signal&gt;accepted()&lt;/signal&gt;
-   &lt;receiver&gt;chromashiftDialog&lt;/receiver&gt;
-   &lt;slot&gt;accept()&lt;/slot&gt;
-   &lt;hints&gt;
-    &lt;hint type=&quot;sourcelabel&quot; &gt;
-     &lt;x&gt;248&lt;/x&gt;
-     &lt;y&gt;254&lt;/y&gt;
-    &lt;/hint&gt;
-    &lt;hint type=&quot;destinationlabel&quot; &gt;
-     &lt;x&gt;157&lt;/x&gt;
-     &lt;y&gt;274&lt;/y&gt;
-    &lt;/hint&gt;
-   &lt;/hints&gt;
-  &lt;/connection&gt;
-  &lt;connection&gt;
-   &lt;sender&gt;buttonBox&lt;/sender&gt;
-   &lt;signal&gt;rejected()&lt;/signal&gt;
-   &lt;receiver&gt;chromashiftDialog&lt;/receiver&gt;
-   &lt;slot&gt;reject()&lt;/slot&gt;
-   &lt;hints&gt;
-    &lt;hint type=&quot;sourcelabel&quot; &gt;
-     &lt;x&gt;316&lt;/x&gt;
-     &lt;y&gt;260&lt;/y&gt;
-    &lt;/hint&gt;
-    &lt;hint type=&quot;destinationlabel&quot; &gt;
-     &lt;x&gt;286&lt;/x&gt;
-     &lt;y&gt;274&lt;/y&gt;
-    &lt;/hint&gt;
-   &lt;/hints&gt;
-  &lt;/connection&gt;
- &lt;/connections&gt;
-&lt;/ui&gt;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt	2008-05-19 18:22:05 UTC (rev 4046)
@@ -4,7 +4,7 @@
 DIA_audioconfig.cpp   DIA_DVDff.cpp           DIA_flyContrast.cpp  DIA_flySrtPos.cpp   DIA_mjpeg.cpp     DIA_resizeWiz.cpp  DIA_v2v.cpp
 DIA_audioFilter.cpp   DIA_flyCrop.cpp      DIA_gototime.cpp    DIA_postproc.cpp  DIA_srt.cpp        GUI_render.cpp
 DIA_bitrateHisto.cpp  DIA_flyAsharp.cpp       DIA_flyDialog.cpp    DIA_lavcodec.cpp    DIA_prefs.cpp     DIA_SVCD.cpp       GUI_sdlRender.cpp
-DIA_builtin.cpp       DIA_flyChromaShift.cpp  DIA_flyHue.cpp       DIA_lavDecoder.cpp  DIA_requant.cpp   DIA_tdeint.cpp     GUI_xvRender.cpp
+DIA_builtin.cpp       DIA_flyHue.cpp       DIA_lavDecoder.cpp  DIA_requant.cpp   DIA_tdeint.cpp     GUI_xvRender.cpp
 DIA_animated.cpp      DIA_ocr.cpp             DIA_tsSub.cpp        DIA_jobs_save.cpp
 DIA_flyEq2.cpp        DIA_flv1.cpp            DIA_flyThreshold.cpp DIA_flyParticle.cpp DIA_flyEraser.cpp DIA_flySwissArmyKnife.cpp
 )

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,55 +0,0 @@
-/***************************************************************************
-                          ADM_guiChromaShift.cpp  -  description
-                             -------------------
-    begin                : Sun Aug 24 2003
-    copyright            : (C) 2002-2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;math.h&gt;
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_image.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidChromaShift.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidChromaShift_param.h&quot;
-#include &quot;DIA_flyDialog.h&quot;
-#include &quot;DIA_flyChromaShift.h&quot;
-
-/*********  COMMON PART *********/
-uint8_t    flyChromaShift::process(void)
-{
-        // First copy Y
-        memcpy(_yuvBufferOut-&gt;data,_yuvBuffer-&gt;data,(_w*_h));
-        // then shift u
-
-         ADMVideoChromaShift::shift(_yuvBufferOut-&gt;data+_w*_h,
-                                    _yuvBuffer-&gt;data+_w*_h, _w&gt;&gt;1,_h&gt;&gt;1,param.u);
-        ADMVideoChromaShift::shift(_yuvBufferOut-&gt;data+((5*_w*_h)&gt;&gt;2),
-                                    _yuvBuffer-&gt;data+((5*_w*_h)&gt;&gt;2), _w&gt;&gt;1,_h&gt;&gt;1,param.v);
-        if(param.u)
-                ADMVideoChromaShift::fixup(_yuvBufferOut-&gt;data,_w,_h,param.u*2);
-        if(param.v)
-                ADMVideoChromaShift::fixup(_yuvBufferOut-&gt;data,_w,_h,param.v*2);
-
-}
-uint8_t    flyChromaShift::update(void)
-{
-   download();
-    process();
-	copyYuvFinalToRgb();
-    display();
-}
-//EOF
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,18 +0,0 @@
-#ifndef FLY_CHROMASHIFT_H
-#define FLY_CHROMASHIFT_H
-class flyChromaShift : public ADM_flyDialog
-{
-  
-  public:
-   CHROMASHIFT_PARAM  param;
-  public:
-   uint8_t    process(void);
-   uint8_t    download(void);
-   uint8_t    upload(void);
-   uint8_t    update(void);
-   flyChromaShift (uint32_t width,uint32_t height,AVDMGenericVideoStream *in,
-                                    void *canvas, void *slider) : ADM_flyDialog(width, height,in,canvas, slider,1,RESIZE_AUTO) {};
-};
-
-#endif
-//EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,507 +0,0 @@
-//
-//      chroma noise reduction II (version 2.6.1) - Avisynth filter reducing noise on chroma
-//      Copyright (C) 2002 Marc Fauconneau
-//
-//      Inspired by :
-//  chroma noise reduction (version 1.1) - VirtualDub filter reducing noise on chroma
-//  Copyright (C) 2000 Gilles Mouchard
-//
-//  This program is free software; you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation; either version 2 of the License, or
-//  (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-//
-//  Please contact me for any bugs or questions.
-//  <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">marc.fd at libertysurf.fr</A>
-//
-//  Change log :
-//         30/06/2004 - ver 2.6.1 - YUY2 opts as I had slowed it down - tritical 
-//         29/06/2004 - ver 2.6  - Some bug fixes and some code cleanup 
-//                                 and rewriting (tritical - <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">kes25c at mizzou.edu</A>)
-//         18/11/2003 - ver 2.51 - Further bug fixes (by Klaus Post)
-//         13/11/2003 - ver 2.5  - Bug fixes (by Klaus Post)
-//         15/12/2002 - ver 2.4  - Bug fixes
-//         13/11/2002 - ver 2.3  - YV12 mode, scd (scenechange detection)
-//         01/08/2002 - ver 2.2  - Ugly bug fixed
-//         31/07/2002 - ver 2.1  - Bug Fixes (thx to dividee ;)
-//         20/07/2002 - ver 2.0  - Avisynth filter coded (from scratch)
-
-#include &lt;math.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_vidCNR2_param.h&quot;
-
-//#define SUBST 1
-
-class vidCNR2:public AVDMGenericVideoStream
-{
-
-protected:
-
-  unsigned char *py, *py_saved, *cy, *cy_saved;
-  unsigned char lt[513];
-  unsigned char ut[513];
-  unsigned char vt[513];
-  int nfrms, keepTrack;
-  unsigned int diffmax;
-
-  virtual char *printConf (void);
-  VideoCache *vidCache;
-  CNR2Param *_param;
-  void downSampleYV12 (unsigned char *dst, ADMImage * src);
-  uint8_t setup (void);
-public:
-
-    vidCNR2 (AVDMGenericVideoStream * in, CONFcouple * setup);
-    virtual ~ vidCNR2 ();
-  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
-					 ADMImage * data, uint32_t * flags);
-  uint8_t configure (AVDMGenericVideoStream * instream);
-  virtual uint8_t getCoupledConf (CONFcouple ** couples);
-
-};
-
-static FILTER_PARAM cnr2_template =
-  { 9, {&quot;scdthr&quot;, &quot;ln&quot;, &quot;lm&quot;, &quot;un&quot;, &quot;um&quot;, &quot;vn&quot;, &quot;vm&quot;, &quot;sceneChroma&quot;,
-	&quot;mode&quot;} };
-
-BUILD_CREATE (cnr2_create, vidCNR2);
-SCRIPT_CREATE (cnr2_script, vidCNR2, cnr2_template);
-
-extern uint8_t DIA_cnr2(CNR2Param *param);
-/*************************************/
-uint8_t vidCNR2::configure (AVDMGenericVideoStream * in)
-{
-        if( DIA_cnr2(_param))
-        {
-                setup();
-                return 1;
-        }
-        return 0;
-}
-/*************************************/
-char *vidCNR2::printConf (void)
-{
-  static char buf[50];
-  sprintf ((char *) buf, &quot; CNR2 by MarcFD/Tritical&quot;);
-  return buf;
-}
-/*************************************/
-vidCNR2::vidCNR2 (AVDMGenericVideoStream * in, CONFcouple * couples)
-{
-
-  _in = in;
-  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
-  _info.encoding = 1;
-  _param = NEW (CNR2Param);
-  vidCache = new VideoCache (4, in);
-  _uncompressed=new ADMImage(_info.width,_info.height);
-  if (couples)
-    {
-#undef GET
-#define GET(x) couples-&gt;getCouple(#x,&amp;(_param-&gt;x))
-      GET (scdthr);
-      GET (ln);
-      GET (lm);
-      GET (un);
-      GET (um);
-      GET (vn);
-      GET (vm);
-      GET (sceneChroma);
-      GET (mode);
-    }
-  else				// Default
-    {
-      _param-&gt;scdthr = 10.f;
-      _param-&gt;lm = 192;
-      _param-&gt;ln = 35;
-      _param-&gt;un = 47;
-      _param-&gt;um = 255;
-      _param-&gt;vn = 47;
-      _param-&gt;vm = 255;
-      _param-&gt;sceneChroma = 0;
-      _param-&gt;mode = 0x00FFFF; // u&amp;v in narrow mode
-    }
-  //
-  py_saved = py = cy_saved = cy = NULL;
-  py = new unsigned char[(_info.width * _info.height) &gt;&gt; 2];
-  py_saved = py;
-  cy = new unsigned char[(_info.width * _info.height) &gt;&gt; 2];
-  cy_saved = cy;
-  nfrms = _info.nb_frames - 1;
-  setup ();
-}
-/*************************************/
-uint8_t vidCNR2::setup (void)
-{
-double root;
-double num,denum,mul;
-
-  root= _info.height * _info.width;
-  root*=_param-&gt;scdthr;
-  if (_param-&gt;sceneChroma)
-    diffmax =      (int) ((root * 331.0f) / 100.0f);
-  else
-    diffmax =      (int) ((root* 219.0f) / 100.0f);
-
-  memset (lt, 0, 513);		// for safety
-  memset (ut, 0, 513);
-  memset (vt, 0, 513);
-
-  keepTrack = -39482;
-
-  const double pi = M_PI;
-  bool Y = true, U = true, V = true;
-  if (_param-&gt;mode &amp; 0xFF0000 )
-    Y = false;
-  if (_param-&gt;mode &amp; 0x00FF00 )
-    U = false;
-  if (_param-&gt;mode &amp; 0x0000FF )
-    V = false;
-
-// Reset
-  int i, j;
-  for (i = -256; i &lt; 256; ++i)
-  {
-    lt[i + 256] = 0;
-    ut[i + 256] = 0;
-    vt[i + 256] = 0;
-  }
- 
- num=M_PI;
-        /************************ Y********************/
- mul=_param-&gt;lm / 2.;
- if(Y)
- { 
-  denum=_param-&gt;ln*_param-&gt;ln;
-  for (j = -_param-&gt;ln; j &lt;= _param-&gt;ln; ++j)
-        lt[j + 256] =  (int) (mul * (1 + cos ((j * j * num) / denum)));
- }
- else
- {
-  denum=_param-&gt;ln;
-  for (j = -_param-&gt;ln; j &lt;= _param-&gt;ln; ++j)
-        lt[j + 256] =  (int) (mul * (1 + cos ((j * num) / denum)));
- 
- }
-
-  
-    /************************ U ********************/
- mul=_param-&gt;um / 2.;
- if(U)
- {
-        denum=_param-&gt;un*_param-&gt;un;
-        for (j = -_param-&gt;un; j &lt;= _param-&gt;un; ++j)
-                ut[j + 256] =  (int) (mul * (1 + cos ((j * j * pi) / (denum))));
- }
- else
- {
-        denum=_param-&gt;un;
-        for (j = -_param-&gt;un; j &lt;= _param-&gt;un; ++j)
-                ut[j + 256] =  (int) (mul * (1 + cos ((j  * pi) / (denum))));
-
- }
-      /************************ V ********************/  
-  mul=_param-&gt;vm / 2.;
-  if(V)
-   {
-        denum=_param-&gt;vn*_param-&gt;vn;
-        for (j = -_param-&gt;vn; j &lt;= _param-&gt;vn; ++j)
-                vt[j + 256] =  (int) (mul * (1 + cos ((j * j * pi) / (denum))));
- }
- else
- {
-        denum=_param-&gt;vn;
-        for (j = -_param-&gt;vn; j &lt;= _param-&gt;vn; ++j)
-                vt[j + 256] =  (int) (mul * (1 + cos ((j  * pi) / (denum))));
- } 
-  return 1;
-}
-//____________________________________________________________________
-vidCNR2::~vidCNR2 ()
-{
-
-  delete _param;
-  _param = NULL;
-  DELETE( _param);
-  delete vidCache;
-  _param = NULL;
-  vidCache = NULL;
-  delete[]py_saved;
-  delete[]cy_saved;
-  
-  py_saved = NULL;
-  cy_saved = NULL;
-  
-  delete _uncompressed;
-  _uncompressed=NULL;
-
-}
-
-//______________________________________________________________
-uint8_t vidCNR2::getFrameNumberNoAlloc (uint32_t frame,
-				uint32_t * len,
-				ADMImage * data, uint32_t * flags)
-{
-  ADMImage *cur, *mprev, *src;
-
-  if (frame &gt;= _info.nb_frames)
-    return 0;
-
-  cur = vidCache-&gt;getImage (frame);
-  src = cur;
-  if (!frame)
-    {
-      data-&gt;duplicate (cur);
-      vidCache-&gt;unlockAll ();
-      return 1;
-    }
-  const unsigned char *srcpY = YPLANE (src);	//src-&gt;GetReadPtr(PLANAR_Y);
-  const unsigned char *srcpU = UPLANE (src);	//src-&gt;GetReadPtr(PLANAR_U);
-  const unsigned char *srcpV = VPLANE (src);	//src-&gt;GetReadPtr(PLANAR_V);
-  const unsigned char *srcp;
-
-  int src_pitchY = _info.width;	//src-&gt;GetPitch(PLANAR_Y);
-  int src_pitchUV = _info.width &gt;&gt; 1;	//src-&gt;GetPitch(PLANAR_V);
-  int heightY = _info.height;	//src-&gt;GetHeight(PLANAR_Y);
-  int heightUV = _info.height &gt;&gt; 1;	//src-&gt;GetHeight(PLANAR_V);
-  int widthY = _info.width ;	//src-&gt;GetRowSize(PLANAR_Y);
-  int widthYd2 = widthY &gt;&gt; 1;
-  int widthUV = _info.width &gt;&gt; 1;	//src-&gt;GetRowSize(PLANAR_V);
-
-  downSampleYV12 (cy, src);
-  if (keepTrack != frame)
-    {
-      mprev = vidCache-&gt;getImage (frame - 1);
-      _uncompressed-&gt;duplicate(mprev); // not optimal  
-      keepTrack = frame;
-      downSampleYV12 (py, mprev);
-    }
-  unsigned char *dstpY = YPLANE (data);	//dst-&gt;GetWritePtr(PLANAR_Y);
-  unsigned char *dstpU = UPLANE (data);	//dst-&gt;GetWritePtr(PLANAR_U);
-  unsigned char *dstpV = VPLANE (data);	//dst-&gt;GetWritePtr(PLANAR_V);
-  unsigned char *dstp, *prevy, *prevp, *curry, *t, *swap;
-  int dst_pitchY = _info.width;	//dst-&gt;GetPitch(PLANAR_Y);
-  int dst_pitchUV = _info.width &gt;&gt; 1;	//dst-&gt;GetPitch(PLANAR_V);
-  int y, x, ydiff, uvdiff, cr;
-  unsigned int difft = 0;
-  const int off = 256;
-  int res;
-  // U plane (we add the luma plane diff to difft here not on v)
-  prevy = py;
-  curry = cy;
-  t = ut;
-  srcp = srcpU;
-  dstp = dstpU;
-  prevp = UPLANE (_uncompressed);	//prev-&gt;GetWritePtr(PLANAR_U);
-  int prev_pitchUV = _info.width &gt;&gt; 1;	//prev-&gt;GetPitch(PLANAR_V);
-  if (_param-&gt;sceneChroma)
-    {
-      for (y = 0; y &lt; heightUV; ++y)
-	{
-	  for (x = 0; x &lt; widthUV; ++x)
-	    {
-	      ydiff = curry[x] - prevy[x];
-	      uvdiff = srcp[x] - prevp[x];
-	      difft += abs (uvdiff) + abs (ydiff &lt;&lt; 2);
-	      cr = (lt[ydiff + off] * t[uvdiff + off]);
-	       res=(cr * prevp[x] + (65536 - cr) * srcp[x] + 32768) &gt;&gt; 16;
-#ifdef SUBST
-                if(res!=srcp[x]) dstp[x]=120;
-                        else dstp[x]=0;
-#else
-                 dstp[x] = prevp[x]=res;
-#endif
-	    }
-	  if (difft &gt; diffmax)
-	    {
-	      goto exit;
-	    }
-	  srcp += src_pitchUV;
-	  dstp += dst_pitchUV;
-	  prevp += prev_pitchUV;
-	  curry += widthYd2;
-	  prevy += widthYd2;
-	}
-    }
-  else
-    {
-      for (y = 0; y &lt; heightUV; ++y)
-	{
-	  for (x = 0; x &lt; widthUV; ++x)
-	    {
-	      ydiff = curry[x] - prevy[x];
-	      uvdiff = srcp[x] - prevp[x];
-	      difft += abs (ydiff &lt;&lt; 2);
-	      cr = (lt[ydiff + off] * t[uvdiff + off]);
-	      res =		(cr * prevp[x] + (65536 - cr) * srcp[x] + 32768) &gt;&gt; 16;
-#ifdef SUBST
-                if(res!=srcp[x]) dstp[x]=120;
-                        else dstp[x]=0;
-#else
-                 dstp[x] = prevp[x]=res;
-#endif
-
-	    }
-	  if (difft &gt; diffmax)
-	    {
-	      goto exit;
-	    }
-	  srcp += src_pitchUV;
-	  dstp += dst_pitchUV;
-	  prevp += prev_pitchUV;
-	  curry += widthYd2;
-	  prevy += widthYd2;
-	}
-    }
-  // V plane
-  prevy = py;
-  curry = cy;
-  t = vt;
-  srcp = srcpV;
-  dstp = dstpV;
-  prevp = VPLANE (_uncompressed);	//prev-&gt;GetWritePtr(PLANAR_V);
-  if (_param-&gt;sceneChroma)
-    {
-      for (y = 0; y &lt; heightUV; ++y)
-	{
-	  for (x = 0; x &lt; widthUV; ++x)
-	    {
-	      ydiff = curry[x] - prevy[x];
-	      uvdiff = srcp[x] - prevp[x];
-	      difft += abs (uvdiff);
-	      cr = (lt[ydiff + off] * t[uvdiff + off]);
-	      res =(cr * prevp[x] + (65536 - cr) * srcp[x] + 32768) &gt;&gt; 16;
-#ifdef SUBST
-                if(res!=srcp[x]) dstp[x]=120;
-                        else dstp[x]=0;
-#else
-                 dstp[x] = prevp[x]=res;
-#endif
-
-	    }
-	  if (difft &gt; diffmax)
-	    {
-	      goto exit;
-	    }
-	  srcp += src_pitchUV;
-	  dstp += dst_pitchUV;
-	  prevp += prev_pitchUV;
-	  curry += widthYd2;
-	  prevy += widthYd2;
-	}
-    }
-  else
-    {
-      for (y = 0; y &lt; heightUV; ++y)
-	{
-	  for (x = 0; x &lt; widthUV; ++x)
-	    {
-	      ydiff = curry[x] - prevy[x];
-	      uvdiff = srcp[x] - prevp[x];
-	      cr = (lt[ydiff + off] * t[uvdiff + off]);
-	      res =(cr * prevp[x] + (65536 - cr) * srcp[x] + 32768) &gt;&gt; 16;
-#ifdef SUBST
-                if(res!=srcp[x]) dstp[x]=120;
-                        else dstp[x]=0;
-#else
-                 dstp[x] = prevp[x]=res;
-#endif
-
-	    }
-	  srcp += src_pitchUV;
-	  dstp += dst_pitchUV;
-	  prevp += prev_pitchUV;
-	  curry += widthYd2;
-	  prevy += widthYd2;
-	}
-    }
-exit:
-//#define CNR_VERBOSE
-#if defined( CNR_VERBOSE) &amp;&amp; defined(ADM_DEBUG)
-        printf(&quot;cur:%u max:%u\n&quot;,difft,diffmax);
-#endif
-        // Scene change ?
-  if (difft &gt; diffmax)
-    {
-      data-&gt;duplicate (cur);
-      vidCache-&gt;unlockAll ();
-      return 1;
-    }
-  ++keepTrack;
-  // Dupe luma
-  memcpy (dstpY, srcpY, _info.height * _info.width);
-
-  swap = py;
-  py = cy;
-  cy = swap;
-  vidCache-&gt;unlockAll ();
-  return 1;
-}
-
-/*************************************/
-void vidCNR2::downSampleYV12 (unsigned char *dst, ADMImage * src)
-{
-  unsigned char *temp = dst;
-  const unsigned char *srcpY = YPLANE (src);
-  int src_pitchY = _info.width &lt;&lt; 1;
-  const unsigned char *srcpnY = srcpY + (src_pitchY &gt;&gt; 1);
-  int widthY = _info.width &gt;&gt; 1;
-  int heightY = _info.height &gt;&gt; 1;
-  int x, y, temp1;
-  for (y = 0; y &lt; heightY; ++y)
-    {
-      for (x = 0; x &lt; widthY; ++x)
-	{
-	  temp1 = x &lt;&lt; 1;
-	  temp[x] =
-	    (srcpY[temp1] + srcpY[temp1 + 1] + srcpnY[temp1] +
-	     srcpnY[temp1 + 1] + 2) &gt;&gt; 2;
-	}
-      srcpY += src_pitchY;
-      srcpnY += src_pitchY;
-      temp += widthY;
-    }
-}
-/*************************************/
-uint8_t vidCNR2::getCoupledConf (CONFcouple ** couples)
-{
-
-  ADM_assert (_param);
-  *couples = new CONFcouple (9);
-#undef CSET
-#define CSET(x)  (*couples)-&gt;setCouple(#x,(_param-&gt;x))
-
-  CSET (scdthr);
-  CSET (ln);
-  CSET (lm);
-  CSET (un);
-  CSET (um);
-  CSET (vn);
-  CSET (vm);
-  CSET (sceneChroma);
-  CSET (mode);
-
-  return 1;
-}
-
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2_param.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2_param.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,30 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef _CNR2_
-#define _CNR2_
-
-typedef struct CNR2Param
-{
-        double scdthr;          // Scene change threshold in % default 10
-        int32_t ln, lm;         // n=sensibility, m=maximum
-        int32_t un, um;
-        int32_t vn, vm;
-        int32_t sceneChroma;    // If true, both luma &amp; chroma are used for scene detection
-        uint32_t mode;          // XX 00 00 Y, 00 XX 00 U , 00 00 XX V
-                                // Default is wide, puting a bit means narrow
-
-} CNR2Param;
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,199 +0,0 @@
-/***************************************************************************
-                          ADM_vidClean.cpp  -  description
-                             -------------------
-    begin                : Sun Apr 14 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_default.h&quot;
-
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_video/ADM_vidClean.h&quot;
-
-
-
-static FILTER_PARAM smoothParam={2,{&quot;radius&quot;,&quot;blend&quot;}};
-
-
-SCRIPT_CREATE(smooth_script,AVDMVideoSmooth,smoothParam);
-
- char *AVDMVideoSmooth::printConf(void)
-{
-static char str[40];
-		sprintf(str,&quot;Smooth-Clean : R = %02lu, Blend=%01lu&quot;,_param-&gt;radius*2,_param-&gt;blend);
- 		return str; // this one is pure
-}
-BUILD_CREATE(smooth_create,AVDMVideoSmooth);
-
-//_______________________________________________________________
-
-AVDMVideoSmooth::AVDMVideoSmooth(
-									AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-
-  	_in=in;		
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  		
-	if(couples)
-	{
- 		_param=NEW( SMOOTH_PARAMS);
-		GET(radius);
-		GET(blend);
-	}
-    else
-    	{
-         	_param=NEW( SMOOTH_PARAMS);
-         	_param-&gt;radius=3;
-              	_param-&gt;blend=1;
-        }
-
-					
-  
-  _uncompressed=new ADMImage (_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-  ADM_assert(_uncompressed);
-  _info.encoding=1;
-
-  	  	
-}
-
-uint8_t	AVDMVideoSmooth::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(2);
-
-	CSET(radius);
-	CSET(blend);
-			return 1;
-
-}
-AVDMVideoSmooth::~AVDMVideoSmooth()
-{
- 	delete _uncompressed;
- 	DELETE(_param);
-	_uncompressed=NULL;
-}
-
-uint8_t AVDMVideoSmooth::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-uint8_t *dst,*dstu,*dstv,*src,*srcu,*srcv;
-
-            	int16_t l,u=0,v=0;
-             	int16_t nb;
-              int16_t fl,fu,fv;
-              int16_t	ldelta,udelta,vdelta;
-              int16_t   threshold=10,su=0,sv=0;
-
-			if(frame&gt;=_info.nb_frames) return 0;
-			ADM_assert(_uncompressed);					
-								
-		// read uncompressed frame
-       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-         	src=YPLANE(_uncompressed);
-           	srcu=UPLANE(_uncompressed);;
-           	srcv=VPLANE(_uncompressed);;
-
-              dst=YPLANE(data);
-              dstu=UPLANE(data);
-              dstv=VPLANE(data);
-
-              int16_t radius=_param-&gt;radius;
-
-         		for(int32_t y=0;y&lt;(int32_t)(_info.height );y++)
-           	{
-		         		for(int32_t x=0;x&lt;(int32_t)(_info.width );x++)
-             			{
-                      	// for each pixel we take the surrounding one
-                       	// if threshold is not met
-                        		l=getPixel(x,y,_uncompressed-&gt;data);
-                          	if(!(x&amp;1))
-                           	{
-                          		u=getPixelU(x,y,srcu);
-                          		v=getPixelU(x,y,srcv);
-                            }
-                            nb=0;
-                            fl=0;fu=0;fv=0;
-
-
-                             //------------------------                        	                        		
-                   	    	for(int16_t yy=-radius+1;yy&lt;radius;yy++)
-                         	{                       			
-
-                        	    	for(int16_t xx=-radius+1;xx&lt;radius;xx++)
-                              		{
-                                  		if( (xx*xx+yy*yy)&lt;radius*radius)
-                                    	{
-                                   		ldelta =getPixel(x+xx,y+yy,_uncompressed-&gt;data)-l;
-  		                            		udelta=getPixelU(x+xx,y+yy,srcu)-u;
-                                     		vdelta=getPixelU(x+xx,y+yy,srcv)-v;                                       	
-
-
-                                         	if((udelta*udelta&lt;threshold*threshold)&amp;&amp;
-                                          	(vdelta*vdelta&lt;threshold*threshold) &amp;&amp;
-                                           	(ldelta*ldelta&lt;threshold*threshold))
-                                          		{
-                                                  	nb++;
-                                                   	fl=fl+ldelta+l;
-                                                    fu=fu+udelta+u;
-															fv=fv+vdelta+v;
-                                              	}
-                                        }
-                                 	 }
-                                  }
-                                  //----------------------------------
-                                  //
-                                  // average value
-                                  	fl=fl/nb;
-                                 	fu=fu/nb;
-                                  	fv=fv/nb;
-                                   // now melt it
-                                  	// 50/50
-                                 /*  fl=(fl+l)&gt;&gt;1;
-                                   fu=(fu+u)&gt;&gt;1;
-                                   fv=(fv+v)&gt;&gt;1;*/
-
-                                 	*dst++=fl;
-                                  if(y&amp;1)       	
-                                  if(x&amp;1)				
-                                  	{
-                        			setPixelU(  (su+fu)&gt;&gt;1,x,y,dstu);
-                           			setPixelU(  (sv+fv)&gt;&gt;1,x,y,dstv);  
-					}
-                                	else
-                                 	{
-                                     	su=fu;
-                                      	sv=fv;
-                                    }
-
-                  	}          // end for x
-           		
-              }     // end for y
-	        data-&gt;copyInfo(_uncompressed);
-              return 1;
-}
-uint8_t AVDMVideoSmooth::configure( AVDMGenericVideoStream *instream)
-{
-UNUSED_ARG(instream);
-
-SMOOTH_PARAMS *par;
-	
-//     	par=_param;
-     	//return((uint8_t)getSmoothParams(&amp;par-&gt;radius,&amp;par-&gt;blend));
-	return 1;
-#warning FIXME , CODE REMOVED AMD64/GCC4
-}

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,42 +0,0 @@
-/***************************************************************************
-                          ADM_vidClean.h  -  description
-                             -------------------
-    begin                : Sun Apr 14 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- typedef struct
- {
-	   	uint32_t radius,blend;
-   }SMOOTH_PARAMS;
-
-
-    class  AVDMVideoSmooth:public AVDMGenericVideoStream
- {
-
- protected:
-
-    			uint8_t						*_unpack;
-           virtual 	char 							*printConf(void);
-    			SMOOTH_PARAMS				*_param;
- public:
-
-  					AVDMVideoSmooth(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  			virtual 	~AVDMVideoSmooth();
-		        virtual 	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-					uint8_t 	configure( AVDMGenericVideoStream *instream) ;
-			 virtual 	uint8_t	getCoupledConf( CONFcouple **couples)		;
-
- }     ;
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,535 +0,0 @@
-
-/***************************************************************************
-    Port of ColorYuv from avisynth to avidemux by mean
- ***************************************************************************/
- // Avisynth v2.5.  Copyright 2002 Ben Rudiak-Gould et al.
-// <A HREF="http://www.avisynth.org">http://www.avisynth.org</A>
-
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-//
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-//
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit
-// <A HREF="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</A> .
-//
-// Linking Avisynth statically or dynamically with other modules is making a
-// combined work based on Avisynth.  Thus, the terms and conditions of the GNU
-// General Public License cover the whole combination.
-//
-// As a special exception, the copyright holders of Avisynth give you
-// permission to link Avisynth with independent modules that communicate with
-// Avisynth solely through the interfaces defined in avisynth.h, regardless of the license
-// terms of these independent modules, and to copy and distribute the
-// resulting combined work under terms of your choice, provided that
-// every copy of the combined work is accompanied by a complete copy of
-// the source code of Avisynth (the version of Avisynth used to produce the
-// combined work), being distributed under the terms of the GNU General
-// Public License plus this exception.  An independent module is a module
-// which is not derived from or based on Avisynth, such as 3rd-party filters,
-// import and export plugins, or graphical user interfaces.
-
- /***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;math.h&gt;
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#include &quot;ADM_vidColorYuv.h&quot;
-
-
-extern int DIA_coloryuv(COLOR_YUV_PARAM *param);
-
-static FILTER_PARAM coloryuv_template={19,
-    {&quot;y_contrast&quot;,&quot;y_bright&quot;,&quot;y_gamma&quot;,&quot;y_gain&quot;,
-    &quot;u_contrast&quot;,&quot;u_bright&quot;,&quot;u_gamma&quot;,&quot;u_gain&quot;,
-    &quot;v_contrast&quot;,&quot;v_bright&quot;,&quot;v_gamma&quot;,&quot;v_gain&quot;,
-    &quot;matrix&quot;,&quot;levels&quot;,&quot;opt&quot;,
-    &quot;colorbars&quot;,&quot;analyze&quot;,&quot;autowhite&quot;,&quot;autogain&quot;,
-    }};
-BUILD_CREATE(coloryuv_create,ADMVideoColorYuv);
-SCRIPT_CREATE(coloryuv_script,ADMVideoColorYuv,coloryuv_template);
-
-uint8_t ADMVideoColorYuv::configure(AVDMGenericVideoStream *in)
-{
-
-   _in=in;
-   if(DIA_coloryuv(_param))
-   {
-       MakeGammaLUT();
-       return 1;
-   }
-   return 0;
-}
-
-char *ADMVideoColorYuv::printConf( void )
-{
-   static char buf[50];
-   sprintf((char *)buf,&quot; ColorYuv &quot;);
-   return buf;
-}
-
-ADMVideoColorYuv::ADMVideoColorYuv(AVDMGenericVideoStream *in,CONFcouple *couples) 
-{
-   _in=in;
-   memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-   _info.encoding=1;
-   _uncompressed=NULL;
-   _param=NEW(COLOR_YUV_PARAM);
-   if(couples)
-   {
-       double y_contrast, y_bright, y_gamma, y_gain;
-       double u_contrast, u_bright, u_gamma, u_gain;
-       double v_contrast, v_bright, v_gamma, v_gain;
-       int32_t matrix, levels, opt;
-       uint32_t colorbars, analyze, autowhite, autogain;
-       GET(y_contrast);
-       GET(y_bright);
-       GET(y_gamma);
-       GET(y_gain); 
-       
-       GET(u_contrast);
-       GET(u_bright);
-       GET(u_gamma);
-       GET(u_gain); 
-       
-       GET(v_contrast);
-       GET(v_bright);
-       GET(v_gamma);
-       GET(v_gain); 
-       
-       GET(matrix);
-       GET(levels);
-       GET(opt); 
-       
-       GET(colorbars);
-       GET(analyze);
-       GET(autowhite); 
-       GET(autogain); 
-       
-       
-   }
-   else // Default
-   {
-#define MKP(x,y) _param-&gt;x=y;
-            MKP(y_contrast,0);
-            MKP(y_bright,0);
-            MKP(y_gamma,0);
-            MKP(y_gain,0);
-
-            MKP(u_contrast,0);
-            MKP(u_bright,0);
-            MKP(u_gamma,0);
-            MKP(u_gain,0);
-
-            MKP(v_contrast,0);
-            MKP(v_bright,0);
-            MKP(v_gamma,0);
-            MKP(v_gain,0);
-            
-            MKP(matrix,0);
-            MKP(levels,0);
-            MKP(opt,0); 
-       
-            MKP(colorbars,0);
-            MKP(analyze,1);
-            MKP(autowhite,1); 
-            MKP(autogain,0); 
-
-            
-            
-   }
-   MakeGammaLUT();
-}
-//____________________________________________________________________
-ADMVideoColorYuv::~ADMVideoColorYuv()
-{
-   delete _param;
-   _param=NULL;
-   _uncompressed=NULL;
-}
-#define BYTE uint8_t 
-#ifndef MAX
-#define MAX(x,y) ((x)&gt;(y) ?(x):(y))
-#endif
-#ifndef MIN
-#define MIN(x,y) ((x)&lt;(y) ?(x):(y))
-#endif
-//______________________________________________________________
-uint8_t ADMVideoColorYuv::getFrameNumberNoAlloc(uint32_t frame,
-  uint32_t *len,
-  ADMImage *data,
-  uint32_t *flags)
-  {
-      uint32_t page=_info.width*_info.height,pitch;
-      if(frame&gt;_info.nb_frames-1) return 0;
-      
-      if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) 
-      {
-          printf(&quot;ColorYuv : Cannot read cache for frame %u\n&quot;,frame);
-          return 0;
-      }
-      
-      ADMImage *mysrc=NULL;
-      mysrc=data;
-      
-      //*************************************************
-      int i,j,wby4;
-      int modulo,w,h;
-//	int dmodulo;
-      //PIXELDATA	pixel;
-
-      pitch = mysrc-&gt;GetPitch(PLANAR_Y);
-      w = mysrc-&gt;GetRowSize(PLANAR_Y);
-      h = mysrc-&gt;GetHeight(PLANAR_Y);
-  wby4 = w / 4;
-  modulo = pitch - w;
-//	dst = env-&gt;NewVideoFrame(vi);
-//	dstp = (unsigned long *) dst-&gt;GetWritePtr();
-//	dpitch = dst-&gt;GetPitch();
-//	dmodulo = dpitch - dst-&gt;GetRowSize();
-  if (_param-&gt;analyze||_param-&gt;autowhite||_param-&gt;autogain) {
-      for (i=0;i&lt;256;i++) {
-          accum_Y[i]=0;
-          accum_U[i]=0;
-          accum_V[i]=0;
-      }
-      int uvdiv=1;  //UV divider (ratio between Y and UV pixels)
-     {
-          uvdiv=4;
-          BYTE* srcp2 = (BYTE*) mysrc-&gt;GetReadPtr(PLANAR_Y);
-          for (int y=0;y&lt;h;y++) {
-              for (int x=0;x&lt;w;x++) {
-                  accum_Y[srcp2[x]]++;
-              }
-              srcp2+=pitch;
-          }
-          pitch = mysrc-&gt;GetPitch(PLANAR_U);
-          srcp2 = (BYTE*) mysrc-&gt;GetReadPtr(PLANAR_U);
-          for (int y=0;y&lt;h/2;y++) {
-              for (int x=0;x&lt;w/2;x++) {
-                  accum_U[srcp2[x]]++;
-              }
-              srcp2+=pitch;
-          }
-          srcp2 = (BYTE*) mysrc-&gt;GetReadPtr(PLANAR_V);
-          for (int y=0;y&lt;h/2;y++) {
-              for (int x=0;x&lt;w/2;x++) {
-                  accum_V[srcp2[x]]++;
-              }
-              srcp2+=pitch;
-          }
-          pitch = mysrc-&gt;GetPitch(PLANAR_Y);
-      } 
-      int pixels = _info.width*_info.height;
-      float avg_u=0, avg_v=0, avg_y=0;
-      int min_u=0, min_v=0, min_y=0;
-      int max_u=0, max_v=0, max_y=0;
-      bool hit_y=false,hit_u=false,hit_v=false;
-      int Amin_u=0, Amin_v=0, Amin_y=0;
-      int Amax_u=0, Amax_v=0, Amax_y=0;
-      bool Ahit_miny=false,Ahit_minu=false,Ahit_minv=false;
-      bool Ahit_maxy=false,Ahit_maxu=false,Ahit_maxv=false;
-      int At_y2=(pixels/256); // When 1/256th of all pixels have been reached, trigger &quot;Loose min/max&quot;
-      int At_uv2=(pixels/1024); 
-   
-      for (i=0;i&lt;256;i++) {
-          avg_y+=(float)accum_Y[i]*(float)i;
-          avg_u+=(float)accum_U[i]*(float)i;
-          avg_v+=(float)accum_V[i]*(float)i;
-          if (accum_Y[i]!=0) {max_y=i;hit_y=true;} else {if (!hit_y) min_y=i+1;} 
-          if (accum_U[i]!=0) {max_u=i;hit_u=true;} else {if (!hit_u) min_u=i+1;} 
-          if (accum_V[i]!=0) {max_v=i;hit_v=true;} else {if (!hit_v) min_v=i+1;} 
-
-          if (!Ahit_miny) {Amin_y+=accum_Y[i]; if (Amin_y&gt;At_y2){Ahit_miny=true; Amin_y=i;} }
-          if (!Ahit_minu) {Amin_u+=accum_U[i]; if (Amin_u&gt;At_uv2){Ahit_minu=true; Amin_u=i;} }
-          if (!Ahit_minv) {Amin_v+=accum_V[i]; if (Amin_v&gt;At_uv2){Ahit_minv=true; Amin_v=i;} }
-
-          if (!Ahit_maxy) {Amax_y+=accum_Y[255-i]; if (Amax_y&gt;At_y2){Ahit_maxy=true; Amax_y=255-i;} }
-          if (!Ahit_maxu) {Amax_u+=accum_U[255-i]; if (Amax_u&gt;At_uv2){Ahit_maxu=true; Amax_u=255-i;} }
-          if (!Ahit_maxv) {Amax_v+=accum_V[255-i]; if (Amax_v&gt;At_uv2){Ahit_maxv=true; Amax_v=255-i;} }
-      }
-
-      float Favg_y=avg_y/(float)pixels;
-      float Favg_u=(avg_u*(float)uvdiv)/(float)pixels;
-      float Favg_v=(avg_v*(float)uvdiv)/(float)pixels;
-      if (_param-&gt;analyze) {
-          char text[400];
-          sprintf(text,   &quot;Frame  : %-8u ( Y /ChrU/ChrV )\n&quot;,frame);
-          drawString(mysrc, 0, 5, text);
-          
-          sprintf(text,   &quot;Avr:( %3.2f / %3.2f / %3.2f )&quot;,Favg_y,Favg_u,Favg_v);
-          drawString(mysrc, 0, 6, text);
-          
-          sprintf(text,   &quot;Minimum:  ( %3d / %3d / %3d )\n&quot;,
-                  min_y,min_u,min_v);
-          drawString(mysrc, 0, 7, text);                          
-          sprintf(text,   &quot;Maximum:  ( %3d / %3d / %3d )\n&quot;,
-                  max_y,max_u,max_v);
-          drawString(mysrc, 0, 8, text);
-          
-          sprintf(text,   &quot;LooseMin  ( %3d / %3d / %3d )\n&quot;,
-                  Amin_y,Amin_u,Amin_v);
-          drawString(mysrc, 0, 9, text);
-          
-          sprintf(text,   &quot;Loose Max:( %3d / %3d / %3d )\n&quot;,
-                  Amax_y,Amax_u,Amax_v);
-          drawString(mysrc, 0, 10, text);
-          if (!(_param-&gt;autowhite||_param-&gt;autogain)) {
-              return 1;
-          }
-      }
-      if (_param-&gt;autowhite) {
-          _param-&gt;u_bright=127-(int)Favg_u;
-          _param-&gt;v_bright=127-(int)Favg_v;
-      }
-      if (_param-&gt;autogain) {
-          Amax_y=MIN(Amax_y,236);
-          Amin_y=MAX(Amin_y,16);  // Never scale above luma range!
-          if (Amin_y!=Amax_y) {
-              int y_range = Amax_y-Amin_y;
-              double scale = (220.0 / y_range);
-              _param-&gt;y_gain = (int) (256.0 * scale)-256;
-              _param-&gt;y_bright = -(int)(scale * (double)(Amin_y)-16);
-          }
-      }
-      MakeGammaLUT();
-  }
-
-  {
-      BYTE* srcp2 = (BYTE*) mysrc-&gt;data;
-      for (j = 0; j &lt; h; j++) {
-          for (i=0; i&lt;w; i++) {
-              srcp2[i]=LUT_Y[srcp2[i]];
-          }
-          srcp2 +=  pitch;
-      }
-      srcp2 = (BYTE*) mysrc-&gt;GetWritePtr(PLANAR_U);
-      h=mysrc-&gt;GetHeight(PLANAR_U);
-      w=mysrc-&gt;GetRowSize(PLANAR_U);
-      pitch=mysrc-&gt;GetPitch(PLANAR_U);
-      for (j = 0; j &lt; h; j++) {
-          for (i=0; i&lt;w; i++) {
-              srcp2[i]=LUT_U[srcp2[i]];
-          }
-          srcp2 +=  pitch;
-      }
-      srcp2 = (BYTE*) mysrc-&gt;GetWritePtr(PLANAR_V);
-      for (j = 0; j &lt; h; j++) {
-          for (i=0; i&lt;w; i++) {
-              srcp2[i]=LUT_V[srcp2[i]];
-          }
-          srcp2 +=  pitch;
-      }
-  }
-
-
-	return 1;
-
-}
-
-
-uint8_t	ADMVideoColorYuv::getCoupledConf( CONFcouple **couples)
-{
-   
-      ADM_assert(_param);
-      *couples=new CONFcouple(19);
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-       CSET(y_contrast);
-       CSET(y_bright);
-       CSET(y_gamma);
-       CSET(y_gain); 
-       
-       CSET(u_contrast);
-       CSET(u_bright);
-       CSET(u_gamma);
-       CSET(u_gain); 
-       
-       CSET(v_contrast);
-       CSET(v_bright);
-       CSET(v_gamma);
-       CSET(v_gain); 
-       
-       CSET(matrix);
-       CSET(levels);
-       CSET(opt); 
-       
-       CSET(colorbars);
-       CSET(analyze);
-       CSET(autowhite); 
-       CSET(autogain); 
-   
-      return 1;
-}
-
-
-void ADMVideoColorYuv::MakeGammaLUT(void)
-{
-    static const int scale = 256, shift = 2^10,
-    coeff_y0 =  76309, coeff_y1 =  65536,
-    coeff_u0 = 132201, coeff_u1 = 116129,
-    coeff_v0 = 104597, coeff_v1 =  91881;
-    int i;
-    int val;
-    double g,b,c,gain;
-    double v;
-
-    y_thresh1 = u_thresh1 = v_thresh1 = -1;
-    y_thresh2 = u_thresh2 = v_thresh2 = 256;
-
-    gain = ((double)_param-&gt;y_gain + scale) / scale;
-    c = ((double)_param-&gt;y_contrast + scale) / scale;
-    b = ((double)_param-&gt;y_bright + scale) / scale;
-    g = ((double)_param-&gt;y_gamma + scale) / scale;
-    if (g &lt; 0.01)    g = 0.01;
-    for (i = 0; i &lt; 256; i++)
-    {
-        val = i * shift;
-        switch (_param-&gt;levels) {
-            case 1:	// PC-&gt;TV
-                val = (int)((val - 16 * shift) * coeff_y0 / coeff_y1 + shift / 2);
-                break;
-                case 2:	// TV-&gt;PC
-                    case 3:	// TV-&gt;PC.Y
-                        val = (int)(val * coeff_y1 / coeff_y0 + 16 * shift + shift / 2);
-                        break;
-                        default:	//none
-                            break;
-        }
-        val = val / shift;
-
-        v = ((double)val) / 256;
-        v = (v * gain) + ((v-0.5) * c + 0.5) - v + (b - 1);
-
-        if (_param-&gt;y_gamma != 0 &amp;&amp; v &gt; 0)
-            v = pow( v, 1 / g);
-        v = v * 256;
-		
-        v += 0.5;
-        val = (int)floor(v);
-
-        if (val &gt; 255)
-            val = 255;
-        else if (val &lt; 0)
-            val = 0;
-
-        if (val &gt; 235) {
-            if(y_thresh2 &gt; 255)		y_thresh2 = i;
-            if(_param-&gt;opt)		val = 235;
-        }
-        else if (val &lt; 16) {
-            y_thresh1 = i;
-            if(_param-&gt;opt)		val = 16;
-        }
-        LUT_Y[i] = (unsigned char)val;
-    }
-
-    gain = ((double)_param-&gt;u_gain + scale);
-    c = ((double)_param-&gt;u_contrast + scale);
-    b = ((double)_param-&gt;u_bright);
-    for (i = 0; i &lt; 256; i++)
-    {
-        val = i * shift;
-        switch (_param-&gt;levels) {
-            case 1:	// PC-&gt;TV Scale
-                val = (int)((val - 128 * shift) * coeff_u0 / coeff_u1 + 128 * shift + shift / 2);
-                break;
-                case 2:	// TV-&gt;PC Scale
-                    val = (int)((val - 128 * shift) * coeff_u1 / coeff_u0 + 128 * shift + shift / 2);
-                    break;
-                    default:	//none
-                        break;
-        }
-        val = val / shift;
-
-        v = ((double)val);
-        v = (v * gain / scale) + ((v-128) * c / scale + 128) - v + b;
-
-        v += 0.5;
-        val = (int)floor(v);
-		
-        if (val &gt; 255)
-            val = 255;
-        else if (val &lt; 0)
-            val = 0;
-
-        if (val &gt; 240) {
-            if(u_thresh2 &gt; 255)		u_thresh2 = i;
-            if(_param-&gt;opt)		val = 240;
-        }
-        else if (val &lt; 16) {
-            u_thresh1 = i;
-            if(_param-&gt;opt)		val = 16;
-        }
-        LUT_U[i] = (unsigned char)val;
-    }
-
-    gain = ((double)_param-&gt;v_gain + scale);
-    c = ((double)_param-&gt;v_contrast + scale);
-    b = ((double)_param-&gt;v_bright);
-    for (i = 0; i &lt; 256; i++)
-    {
-        val = i * shift;
-        switch (_param-&gt;levels) {
-            case 1:	// PC-&gt;TV Scale
-                val = (int)((val - 128 * shift) * coeff_v0 / coeff_v1 + 128 * shift + shift / 2);
-                break;
-                case 2:	// TV-&gt;PC Scale
-                    val = (int)((val - 128 * shift) * coeff_v1 / coeff_v0 + 128 * shift + shift / 2);
-                    break;
-                    default:	//none
-                        break;
-        }
-        val = val / shift;
-
-        v = ((double)val);
-        v = (v * gain / scale) + ((v-128) * c / scale + 128) - v + b;
-
-        v += 0.5;
-        val = (int)floor(v);
-		
-        if (val &gt; 255)
-            val = 255;
-        else if (val &lt; 0)
-            val = 0;
-		
-        if (val &gt; 240) {
-            if(v_thresh2 &gt; 255)		v_thresh2 = i;
-            if(_param-&gt;opt)		val = 240;
-        }
-        else if (val &lt; 16) {
-            v_thresh1 = i;
-            if(_param-&gt;opt)		val = 16;
-        }
-        LUT_V[i] = (unsigned char)val;
-    }
-
-#ifdef _DEBUG
-	DumpLUT();
-#endif
-
-}
-
-
-
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,45 +0,0 @@
-/***************************************************************************
-                          Port of avisynth ColorYuv Filter
-    copyright            : (C) 2006 by mean
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_VID_COLOR_YUV_H
-#define ADM_VID_COLOR_YUV_H
-#include &quot;ADM_vidColorYuv_param.h&quot;
-class  ADMVideoColorYuv:public AVDMGenericVideoStream
-{
-
-    protected:
-
-        virtual char    *printConf(void) ;
-        COLOR_YUV_PARAM *_param;
-        
-        void            MakeGammaLUT(void);
-        
-        uint8_t      LUT_Y[256],LUT_U[256],LUT_V[256];
-        uint32_t     accum_Y[256],accum_U[256],accum_V[256];
-        int32_t      y_thresh1, y_thresh2, u_thresh1, u_thresh2, v_thresh1, v_thresh2;
-        int32_t      last_y_offset;
-
-        
-    public:
- 					
-        ADMVideoColorYuv(  AVDMGenericVideoStream *in,CONFcouple *setup);
-        ~ADMVideoColorYuv();
-        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                ADMImage *data,uint32_t *flags);
-
-        virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
-        virtual uint8_t getCoupledConf( CONFcouple **couples);
-
-}     ;
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv_param.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv_param.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,36 +0,0 @@
-/***************************************************************************
-                          Port of avisynth ColorYuv Filter
-    copyright            : (C) 2006 by mean
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef ADM_VID_COLOR_YUV_PARAM_H
-#define ADM_VID_COLOR_YUV_PARAM_H
-typedef struct COLOR_YUV_PARAM
-{
-    double y_contrast, y_bright, y_gamma, y_gain;
-    double u_contrast, u_bright, u_gamma, u_gain;
-    double v_contrast, v_bright, v_gamma, v_gain;
-    int32_t matrix, levels, opt;
-    uint32_t colorbars, analyze, autowhite, autogain;
-
-}COLOR_YUV_PARAM;
-
-/*
-matrix : 0 : none   1: rec.709
-Level :  0 : none   1:&quot;TV-&gt;PC&quot;, 2:&quot;PC-&gt;TV&quot;, 3:&quot;PC-&gt;TV.Y&quot; 
-Opt :    0 : none   1: Coring
-
-
-
-*/
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,128 +0,0 @@
-
-/***************************************************************************
-                        Simple equalizer or linear luma/chroma filter
-    
-
-   (C) 2004/2005 Mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-   GPL version 2
-
- ***************************************************************************/
-#include &quot;ADM_default.h&quot;
-#include &lt;math.h&gt;
-
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#include &quot;ADM_vidEqualizer.h&quot;
-
-
-static FILTER_PARAM equalizer_template={8,{&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;
-					,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;}};
-BUILD_CREATE(equalizer_create,vidEqualizer);
-SCRIPT_CREATE(equalizer_script,vidEqualizer,equalizer_template);
-
-extern uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *incoming);
-
-uint8_t vidEqualizer::configure(AVDMGenericVideoStream *in)
-{
-ADMImage *video1;
-uint32_t l,f;
-uint8_t r;
-
-	_in=in;		
-	r= DIA_getEqualizer(_param,in);
-	return r;
-	
-}
-
-char *vidEqualizer::printConf( void )
-{
- 	static char buf[50];
- 	sprintf((char *)buf,&quot; Equalizer&quot;);
-        return buf;
-}
-
-vidEqualizer::vidEqualizer(AVDMGenericVideoStream *in,CONFcouple *couples) 
-{
-		_in=in;		
-   		memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-  		_info.encoding=1;
-		_uncompressed=NULL;
-		
-  		_info.encoding=1;
-		_uncompressed=new ADMImage(_info.width,_info.height);
-		
-		
-		_param=NEW(EqualizerParam);
-		if(couples)
-		{
-		        char dummy[10];
-                        for(int i=0;i&lt;256;i++)  
-                        {
-                                sprintf(dummy,&quot;x%03d&quot;,i);
-                                couples-&gt;getCouple((char *)dummy,&amp;(_param-&gt;_scaler[i]));
-                        }
-		}
-		else // Default
-  		{
-                                for(int i=0;i&lt;256;i++)
-                                        _param-&gt;_scaler[i]=i;
-		}
-}
-//____________________________________________________________________
-vidEqualizer::~vidEqualizer()
-{
-		
-	delete _uncompressed;
-	delete _param;
-	_param=NULL;
-	_uncompressed=NULL;
-		
-		
-}
-
-//______________________________________________________________
-uint8_t vidEqualizer::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-        if(frame&gt;= _info.nb_frames) return 0;
-	if(!_in-&gt;getFrameNumberNoAlloc(frame,len,_uncompressed,flags)) return 0;
-	
-	uint8_t *src,*dst;
-	src=_uncompressed-&gt;data;
-	dst=data-&gt;data;
-	for(uint32_t y=_info.height;y&gt;0;y--)
-	for(uint32_t x=_info.width;x&gt;0;x--)
-		*(dst++)=_param-&gt;_scaler[*(src++)];
-
-	uint32_t square=_info.width*_info.height;
-	square&gt;&gt;=2;
-	// copy u &amp; v too
-	memcpy(data-&gt;data+4*square,_uncompressed-&gt;data+4*square,2*square);
-	return 1;
-}
-
-
-uint8_t	vidEqualizer::getCoupledConf( CONFcouple **couples)
-{
-char dummy[10];
-			ADM_assert(_param);
-			*couples=new CONFcouple(256);
-
-        for(int i=0;i&lt;256;i++)  
-        {
-                sprintf(dummy,&quot;x%03d&quot;,i);
-                (*couples)-&gt;setCouple(dummy,(_param-&gt;_scaler[i]));
-        }
-	return 1;
-}
-
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,40 +0,0 @@
-//
-// C++ Interface: %{MODULE}
-//
-// Description: 
-//
-//
-// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-typedef struct EqualizerParam
-{
-	uint32_t _scaler[256];
-}EqualizerParam;
-
- class  vidEqualizer:public AVDMGenericVideoStream
- {
-
- protected:
-
-
-           virtual char 	*printConf(void);
-			EqualizerParam *_param;	
-			
-
- public:
- 		
-  					vidEqualizer(  AVDMGenericVideoStream *in,CONFcouple *setup);	
-  			virtual 	~vidEqualizer();
-			virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-			  		ADMImage *data,uint32_t *flags);
-				uint8_t configure( AVDMGenericVideoStream *instream);
-			virtual uint8_t	getCoupledConf( CONFcouple **couples);
-							
- }     ;
- 
- uint8_t equalizerBuildScaler(int32_t *p,uint32_t *s);
- 
-//EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUnblend.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUnblend.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUnblend.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,525 +0,0 @@
-/***************************************************************************
-                         
-        Hard ivtc removal for image
-
-        A B C D E -&gt; A BC CD D E
-
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &lt;string.h&gt;
-#include &quot;ADM_default.h&quot;
-#include &lt;math.h&gt;
-
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#include &quot;DIA_enter.h&quot;
-
-#define MUL 1
-// Set it to 2 for post separate field
-
-typedef struct HARD_IVTC_PARAM
-{
-        uint32_t threshold;
-        uint32_t noise;
-        uint32_t show;
-}HARD_IVTC_PARAM;
-
-class vidHardPDRemoval:public AVDMGenericVideoStream
-{
-
-protected:
-  virtual char *printConf (void);
-  VideoCache *vidCache;
-  HARD_IVTC_PARAM *_param;
-  uint32_t              _lastRemoved;
-  ADMImage              *cand1,*cand2,*rebuild;
-public:
-
-                        vidHardPDRemoval (AVDMGenericVideoStream * in, CONFcouple * setup);
-        virtual         ~vidHardPDRemoval ();
-  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
-                                         ADMImage * data, uint32_t * flags);
-  uint8_t configure (AVDMGenericVideoStream * instream);
-  virtual uint8_t getCoupledConf (CONFcouple ** couples);
-
-};
-
-static FILTER_PARAM field_unblend_template =
-  { 3,&quot;threshold&quot;,&quot;show&quot;,&quot;noise&quot;};
-
-BUILD_CREATE (hardivtc_create, vidHardPDRemoval);
-SCRIPT_CREATE (hardivtc_script, vidHardPDRemoval, field_unblend_template);
-//*************************************
-uint8_t vidHardPDRemoval::configure (AVDMGenericVideoStream * in)
-{
-int v,w;
-        _param-&gt;show=GUI_YesNo(QT_TR_NOOP(&quot;Metrics&quot;),QT_TR_NOOP(&quot;Do you want to print metrics on screen ?&quot; ));
-        v=_param-&gt;threshold;
-        w=_param-&gt;noise;        
-        if(DIA_GetIntegerValue(&amp;v, 2, 99,&quot;Treshold&quot;,&quot;Treshold value (smaller = harder to match)&quot;))
-        {
-                if(DIA_GetIntegerValue(&amp;w, 2, 99,&quot;Noise&quot;,&quot;Noise threshold&quot;))
-                {
-                	_param-&gt;threshold=v;
-                    _param-&gt;noise=w;
-                    _lastRemoved=0xFFFF;
-                    return 1;
-                }
-        }
-        return 0;
-}
-/*************************************/
-char *vidHardPDRemoval::printConf (void)
-{
-  static char buf[50];
-  sprintf ((char *) buf, &quot; Field Unblend Thresh:%d Noise:%d&quot;,_param-&gt;threshold,_param-&gt;noise);
-  return buf;
-}
-
-#define MAX_BLOCKS 50
-/*************************************/
-vidHardPDRemoval::vidHardPDRemoval (AVDMGenericVideoStream * in, CONFcouple * couples)
-{
-
-  _in = in;
-  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
-  _info.encoding = 1;
-  vidCache = new VideoCache (10, in);
-  _uncompressed=new ADMImage(_info.width,_info.height);
-  cand1=new ADMImage(_info.width,_info.height);
-  cand2=new ADMImage(_info.width,_info.height);
-  rebuild=new ADMImage(_info.width,_info.height);
-
- _param=new HARD_IVTC_PARAM;
- _lastRemoved=0xFFFF;
- if(couples)
- {
-#undef GET
-#define GET(x) couples-&gt;getCouple(#x,&amp;(_param-&gt;x))
-      GET (threshold);
-      GET (show);
-      GET (noise);
-  }
-  else
-  {
-        _param-&gt;threshold=10;
-        _param-&gt;show=0;
-        _param-&gt;noise=5;
-  }
-}
-//____________________________________________________________________
-vidHardPDRemoval::~vidHardPDRemoval ()
-{
-
-  delete vidCache;
-  vidCache = NULL;
-  delete _uncompressed;
-  _uncompressed=NULL;
-  delete _param;
-  _param=NULL;
-  delete cand1;
-  delete cand2;
-  delete rebuild;
-  cand1=NULL;
-  cand2=NULL;
-  rebuild=NULL;
-}
-static void merge(ADMImage *src1,ADMImage *src2,ADMImage *tgt)
-{
-uint32_t ww,hh;
-uint8_t *s1,*s2,*out;
-int o;
-
-        s1=YPLANE(src1);
-        s2=YPLANE(src2);
-        out=YPLANE(tgt);
-        ww=src1-&gt;_width;
-        hh=src1-&gt;_height;
-        for(int y=0;y&lt;hh;y++)
-                for(int x=0;x&lt;ww;x++)
-                {
-                        o=*s1+*s2;
-                        o&gt;&gt;=1;
-                        *out=o;
-                        s1++;
-                        s2++;
-                        out++;
-
-                }
-
-
-
-
-}
-static float computeDiff(ADMImage *src1,ADMImage *src2,uint32_t noise)
-{
-float df=0;
-int delta;
-uint32_t ww,hh;
-uint8_t *s1,*s2;
-
-        s1=YPLANE(src1);
-        s2=YPLANE(src2);
-        ww=src1-&gt;_width;
-        hh=src1-&gt;_height;
-
-          for(int y=0;y&lt;hh;y++)
-                for(int x=0;x&lt;ww;x++)
-                {
-                        delta=abs(*s1-*s2);
-                        if(delta&gt;noise)
-                                df+=delta;
-                        s1++;
-                        s2++;
-
-                }
-        return df;
-}
-static float computeDiff2(ADMImage *src1,ADMImage *src2,ADMImage *cand)
-{
-float df=0;
-int delta;
-uint32_t ww,hh;
-uint8_t *s1,*s2,*d1;
-int a1,a2,t1;
-        s1=YPLANE(src1);
-        s2=YPLANE(src2);
-        
-        d1=YPLANE(cand);
-        ww=src1-&gt;_width;
-        hh=src1-&gt;_height;
-
-          for(int y=0;y&lt;hh;y++)
-                for(int x=0;x&lt;ww;x++)
-                {
-                        a1=*s1;
-                        a2=*s2;
-                        t1=*d1;
-                        if(a1==a2) ;
-                        else
-                        if(a1&gt;a2)
-                        {
-                                if(t1 &lt;=a1 &amp;&amp; t1&gt;=a2) df+=1;
-                                        else df-=1;
-                        }else
-                                if(t1 &lt;=a2 &amp;&amp; t1&gt;=a1) df+=1;
-                                        else df-=1;
-                        s1++;
-                        s2++;
-                        d1++;
-                }
-        return df;
-}
-
-// so srcR=2*src-srcP
-static uint8_t tinyUnblend(uint8_t *dst, uint8_t *src1, uint8_t *src2,uint32_t w, uint32_t h)
-{
-int delta;
-uint32_t ww,hh;
-uint8_t *s1,*s2,*d1;
-int a1,a2;
-        s1=src1;
-        s2=src2;
-        
-        d1=dst;
-        ww=w;
-        hh=h;
-
-          for(int y=0;y&lt;hh;y++)
-                for(int x=0;x&lt;ww;x++)
-                {
-                        a1=*s1;
-                        a2=*s2;
-                        a1=2*a1-a2;
-                        if(a1&lt;0) a1=0;
-                        if(a1&gt;255) a1=255;
-                        *d1=a1;                         
-
-                        s1++;
-                        s2++;
-                        d1++;
-                }
-        return 1;
-}
-static uint8_t tinyAverage(uint8_t *dst, uint8_t *src1, uint8_t *src2,uint32_t w, uint32_t h)
-{
-int delta;
-uint32_t ww,hh;
-uint8_t *s1,*s2,*d1;
-int a1,a2;
-        s1=src1;
-        s2=src2;
-        
-        d1=dst;
-        ww=w;
-        hh=h;
-
-          for(int y=0;y&lt;hh;y++)
-                for(int x=0;x&lt;ww;x++)
-                {
-                        a1=*s1;
-                        a2=*s2;
-                        a1=a1+a2;
-                        a1&gt;&gt;=1;
-                        if(a1&lt;0) a1=0;
-                        if(a1&gt;255) a1=255;
-                        *d1=a1;                         
-
-                        s1++;
-                        s2++;
-                        d1++;
-                }
-        return 1;
-}
-
-/*
-
-                src=blend of srcP and R         =&gt; src= 1/2(srcP+R)
-                                                   2*src-srcP=R
-
-                srcN=blend of srcNN and R       =&gt; srcN=1/2 (srcNN+R)
-                                                        2*srcN-srcNN=R
-
-*/
-
-static uint8_t tinyRestore(uint8_t *dst, uint8_t *srcP, uint8_t *src,uint8_t *srcN,uint8_t *srcNN,uint32_t w, uint32_t h)
-{
-
-
-uint8_t *s,*sp,*sn,*snn,*d1;
-int a1,a2,a3,a4,sum,delta;
-
-        sp=srcP;
-        s=src;
-        sn=srcN;
-        snn=srcNN;
-        
-        d1=dst;
-
-          for(int y=0;y&lt;h;y++)
-                for(int x=0;x&lt;w;x++)
-                {
-                        a1=*sp;
-                        a2=*s;
-                        a3=*sn;
-                        a4=*snn;
-
-                        sum=2*a2+2*a3-a1-a4;
-                        sum=sum/2;
-                        
-                        a1=sum;                        
-
-                        if(a1&lt;0) a1=0;
-                        if(a1&gt;255) a1=255;
-                        *d1=a1;
-
-                        s++;
-                        sp++;
-                        sn++;
-                        snn++;
-                        d1++;
-                }
-        return 1;
-}
-
-static uint8_t    unblend(ADMImage *tgt,ADMImage *src,ADMImage *srcP)
-{
-int delta;
-uint32_t ww,hh;
-uint8_t *s1,*s2,*d1;
-int a1,a2,t1;
-
-        tinyUnblend(YPLANE(tgt),YPLANE(src),YPLANE(srcP),tgt-&gt;_width,tgt-&gt;_height);
-        tinyUnblend(UPLANE(tgt),UPLANE(src),UPLANE(srcP),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
-        tinyUnblend(VPLANE(tgt),VPLANE(src),VPLANE(srcP),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
-        return 1;
-
-
-}
-static uint8_t    averageF(ADMImage *tgt,ADMImage *src,ADMImage *srcP)
-{
-int delta;
-uint32_t ww,hh;
-uint8_t *s1,*s2,*d1;
-int a1,a2,t1;
-
-        tinyAverage(YPLANE(tgt),YPLANE(src),YPLANE(srcP),tgt-&gt;_width,tgt-&gt;_height);
-        tinyAverage(UPLANE(tgt),UPLANE(src),UPLANE(srcP),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
-        tinyAverage(VPLANE(tgt),VPLANE(src),VPLANE(srcP),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
-        return 1;
-
-
-}
-static uint8_t    restore(ADMImage *tgt,ADMImage *srcP,ADMImage *src,ADMImage *srcN,ADMImage *srcNN)
-{
-int delta;
-uint32_t ww,hh;
-uint8_t *s1,*s2,*d1;
-int a1,a2,t1;
-
-        tinyRestore(YPLANE(tgt),YPLANE(srcP),YPLANE(src),YPLANE(srcN),YPLANE(srcNN),tgt-&gt;_width,tgt-&gt;_height);
-        tinyRestore(UPLANE(tgt),UPLANE(srcP),UPLANE(src),UPLANE(srcN),UPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
-        tinyRestore(VPLANE(tgt),VPLANE(srcP),VPLANE(src),VPLANE(srcN),VPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
-        return 1;
-
-
-}
-
-uint8_t vidHardPDRemoval::getFrameNumberNoAlloc (uint32_t inframe,
-                                uint32_t * len,
-                                ADMImage * data, uint32_t * flags)
-{
-
-	
-	ADMImage *srcP,*srcN,*srcNN,*src,*final,*display;
-        float distMerged, distN,distP,distM,distR;
-        char txt[255];
-        if(inframe&gt;= _info.nb_frames) return 0;
-        if(inframe&lt;1 || inframe&gt;inframe&gt;_info.nb_frames-2 )
-        {
-                data-&gt;duplicate(vidCache-&gt;getImage(inframe));
-                vidCache-&gt;unlockAll();
-                return 1;
-        }
-        if(_lastRemoved==inframe-1)
-        {
-                data-&gt;duplicate(rebuild);
-                if(_param-&gt;show&amp;&amp;inframe)
-                {
-                        sprintf(txt,&quot; Telecined 2&quot;);
-                        drawString(data,2,4,txt);
-                }
-                
-                return 1;
-        }
-
-        data-&gt;duplicate(rebuild);
-
-        srcP=vidCache-&gt;getImage(inframe-1);
-        src=vidCache-&gt;getImage(inframe);
-        srcN=vidCache-&gt;getImage(inframe+1);
-        srcNN=vidCache-&gt;getImage(inframe+2);
-        
-        // Let's rebuild the pseudo R, where we have A AR RB B
-        // If then we got R1 very close to R2, and that AR is very close to src
-        // Decide it is hard telecined (frame blending)
-#if 1
-       restore(rebuild,srcP,src,srcN,srcNN);
-#else
-        unblend(cand1,src,srcP);
-        unblend(cand2,srcN,srcNN);
-        averageF(rebuild,cand1,cand2);
-#endif  
-#if 0
-        data-&gt;duplicate(rebuild);
-        vidCache-&gt;unlockAll();
-        return 1;
-#endif
-
-        // And remerge...
-        averageF(cand1,srcP,rebuild);
-        averageF(cand2,srcNN,rebuild);
-        
-        distP=computeDiff(cand1,src,_param-&gt;noise);
-        distN=computeDiff(cand2,srcN,_param-&gt;noise);
-        distM=computeDiff(src,srcP,_param-&gt;noise);
-        distR=computeDiff(src,srcN,_param-&gt;noise);
-        
-        
-        
-        double medium;
-
-         if(distM&gt;1&amp;&amp;distR&gt;1)
-        {
-                if(distM&gt;distR) medium=distR;
-                          else  medium=distM;
-                  //medium=min(distM,distR);
-                 
-                 medium/=100;
-                 distN/=medium;
-                 distP/=medium;
-                 distR/=medium;
-         
-         }
-
-        medium=medium/(_info.width*_info.height);
-        double mn;
-
-        if(inframe == _lastRemoved+5)
-        {
-                distN=(distN*7)/10;
-                distP=(distP*7)/10;
-                
-        }
-                //data-&gt;duplicate(src); 
-        if(distN&lt;_param-&gt;threshold &amp;&amp; distP&lt;_param-&gt;threshold)
-        {
-                data-&gt;duplicate(rebuild);
-                _lastRemoved=inframe;
-                if(_param-&gt;show &amp;&amp; inframe == _lastRemoved+5)
-                {
-                        sprintf(txt,&quot; Fav&quot;);
-                        drawString(data,2,5,txt);      
-                }
-        }
-        else
-                data-&gt;duplicate(src);
-        if(_param-&gt;show)
-        {
-                display=data;
-
-                sprintf(txt,&quot; N %02.1f&quot;,distN);
-                drawString(display,2,0,txt);
-
-                sprintf(txt,&quot; P %02.1f&quot;,distP);
-                drawString(display,2,1,txt);
-
-                sprintf(txt,&quot; R %02.1f&quot;,distR);
-                drawString(display,2,2,txt);
-
-
-                if(_lastRemoved==inframe)
-                {
-                        sprintf(txt,&quot; Telecined 1&quot;,distP);
-                        drawString(display,2,4,txt);
-                }
-        }
-
-
-          
-        vidCache-&gt;unlockAll();
-	return 1;
-}
-uint8_t vidHardPDRemoval::getCoupledConf (CONFcouple ** couples)
-{
-
-  ADM_assert (_param);
-  *couples = new CONFcouple (3);
-#undef CSET
-#define CSET(x)  (*couples)-&gt;setCouple(#x,(_param-&gt;x))
-  CSET (threshold);
-  CSET (show);
-  CSET (noise);
-  
-  return 1;
-}
-
-
-//EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,393 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-
-extern &quot;C&quot; {
-#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h&quot;
-#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavutil/avutil.h&quot;
-#include &quot;ADM_libraries/ADM_ffmpeg/ADM_libswscale/swscale.h&quot;
-}
-
-
-
-#include &quot;ADM_vidMPdelogo.h&quot;
-
-class  ADMVideoMPdelogo:public AVDMGenericVideoStream
- {
-
- protected:
-                                MPDELOGO_PARAM  *_param;
-                                VideoCache      *vidCache;
-
- public:
-
-                                ADMVideoMPdelogo(  AVDMGenericVideoStream *in,CONFcouple *setup);
-                                ADMVideoMPdelogo(        AVDMGenericVideoStream *in,uint32_t x,uint32_t y);
-                                virtual                 ~ADMVideoMPdelogo();
-          virtual               uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                                ADMImage *data,uint32_t *flags);
-                                uint8_t configure( AVDMGenericVideoStream *instream);
-        virtual                 char    *printConf(void) ;
-
-          virtual uint8_t       getCoupledConf( CONFcouple **couples);
-
-
- }     ;
-extern uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in);
-
-static FILTER_PARAM mpdelogoParam={6,{&quot;xoff&quot;,&quot;yoff&quot;,&quot;lw&quot;,&quot;lh&quot;,&quot;band&quot;,&quot;show&quot;}};
-
-BUILD_CREATE(mpdelogo_create,ADMVideoMPdelogo);
-SCRIPT_CREATE(mpdelogo_script,ADMVideoMPdelogo,mpdelogoParam);
-
-
-uint8_t ADMVideoMPdelogo::configure(AVDMGenericVideoStream * instream)
-{
-    UNUSED_ARG(instream);
-
-    return DIA_getMPdelogo(_param,instream);
-}
-
-char *ADMVideoMPdelogo::printConf( void )
-{
-        static char buf[50];
-
-        sprintf((char *)buf,&quot; MPlayer delogo : at (%d,%d) (%dx%d)&quot;,
-                                _param-&gt;xoff,_param-&gt;yoff,_param-&gt;lw,_param-&gt;lh);
-        return buf;
-}
-//_______________________________________________________________
-ADMVideoMPdelogo::ADMVideoMPdelogo(
-         AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-        _in=in;
-        memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-        _param=NEW(MPDELOGO_PARAM);
-        vidCache=new VideoCache(4,_in);
-        if(couples)
-        {
-
-                GET(xoff);
-                GET(yoff);
-                GET(lw);
-                GET(lh);
-                GET(show);
-                GET(band);
-        
-        }
-        else
-        {
-                _param-&gt;xoff=0;
-                _param-&gt;yoff=0;
-                _param-&gt;lw = _info.width&gt;&gt;1;
-                _param-&gt;lh = _info.height&gt;&gt;1;
-                _param-&gt;band=4;
-                _param-&gt;show=0;
-        }
-        _info.encoding=1;
-}
-
-
-uint8_t ADMVideoMPdelogo::getCoupledConf( CONFcouple **couples)
-{
-
-                        ADM_assert(_param);
-                        *couples=new CONFcouple(6);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-                CSET(xoff);
-                CSET(yoff);
-                CSET(lw);
-                CSET(lh);
-                CSET(show);
-                CSET(band);
-                return 1;
-
-}
-// ___ destructor_____________
-ADMVideoMPdelogo::~ADMVideoMPdelogo()
-{
-        DELETE(_param);
-        delete vidCache;
-        vidCache=NULL;
-}
-static void delogo(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int width, int height,
-                   int logo_x, int logo_y, int logo_w, int logo_h, int band, int show, int direct) ;
-
-uint8_t ADMVideoMPdelogo::getFrameNumberNoAlloc(uint32_t frame,
-                                uint32_t *len,
-                                ADMImage *data,
-                                uint32_t *flags)
-{
-                        if(frame&gt;=_info.nb_frames) 
-                        {
-                                printf(&quot;MPdelogo : Filter : out of bound!\n&quot;);
-                                return 0;
-                        }
-        
-                        ADM_assert(_param);
-
-ADMImage *curImage;
-char txt[256];
-                        curImage=vidCache-&gt;getImage(frame);
-                        if(!curImage)
-                        {
-                                printf(&quot;MPdelogo : error getting frame\n&quot;);
-                                return 0;
-                        }
-                delogo(YPLANE(data), YPLANE(curImage), _info.width, _info.width, _info.width, _info.height,
-                        _param-&gt;xoff, _param-&gt;yoff, _param-&gt;lw, _param-&gt;lh, _param-&gt;band, _param-&gt;show,0);
-                delogo(UPLANE(data), UPLANE(curImage), _info.width&gt;&gt;1, _info.width&gt;&gt;1, _info.width&gt;&gt;1,
-                 _info.height&gt;&gt;1,_param-&gt;xoff&gt;&gt;1, _param-&gt;yoff&gt;&gt;1, _param-&gt;lw&gt;&gt;1,
-                 _param-&gt;lh&gt;&gt;1, _param-&gt;band&gt;&gt;1, _param-&gt;show,0);
-                delogo(VPLANE(data), VPLANE(curImage), _info.width&gt;&gt;1, _info.width&gt;&gt;1, _info.width&gt;&gt;1,
-                 _info.height&gt;&gt;1,_param-&gt;xoff&gt;&gt;1, _param-&gt;yoff&gt;&gt;1, _param-&gt;lw&gt;&gt;1,
-                 _param-&gt;lh&gt;&gt;1, _param-&gt;band&gt;&gt;1, _param-&gt;show,0);
-                
-                        vidCache-&gt;unlockAll();
-        return 1;
-}
-
-
-/*
-  Copyright (C) 2002 Jindrich Makovicka &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">makovick at kmlinux.fjfi.cvut.cz</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-/* A very simple tv station logo remover */
-
-
-
-//===========================================================================//
-
-
-#define MIN(a,b) (((a) &lt; (b)) ? (a) : (b))
-#define MAX(a,b) (((a) &gt; (b)) ? (a) : (b))
-
-void delogo(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int width, int height,
-		   int logo_x, int logo_y, int logo_w, int logo_h, int band, int show, int direct) {
-    int y, x;
-    int interp, dist;
-    uint8_t *xdst, *xsrc;
-    
-    uint8_t *topleft, *botleft, *topright;
-    int xclipl, xclipr, yclipt, yclipb;
-    int logo_x1, logo_x2, logo_y1, logo_y2;
-    
-    xclipl = MAX(-logo_x, 0);
-    xclipr = MAX(logo_x+logo_w-width, 0);
-    yclipt = MAX(-logo_y, 0);
-    yclipb = MAX(logo_y+logo_h-height, 0);
-
-    logo_x1 = logo_x + xclipl;
-    logo_x2 = logo_x + logo_w - xclipr;
-    logo_y1 = logo_y + yclipt;
-    logo_y2 = logo_y + logo_h - yclipb;
-
-    topleft = src+logo_y1*srcStride+logo_x1;
-    topright = src+logo_y1*srcStride+logo_x2-1;
-    botleft = src+(logo_y2-1)*srcStride+logo_x1;
-
-    if (!direct) memcpy(dst, src,(width*height*3)/2); // width, height, dstStride, srcStride);
-
-    dst += (logo_y1+1)*dstStride;
-    src += (logo_y1+1)*srcStride;
-    
-    for(y = logo_y1+1; y &lt; logo_y2-1; y++)
-    {
-	for (x = logo_x1+1, xdst = dst+logo_x1+1, xsrc = src+logo_x1+1; x &lt; logo_x2-1; x++, xdst++, xsrc++) {
-	    interp = ((topleft[srcStride*(y-logo_y-yclipt)]
-		       + topleft[srcStride*(y-logo_y-1-yclipt)]
-		       + topleft[srcStride*(y-logo_y+1-yclipt)])*(logo_w-(x-logo_x))/logo_w
-		      + (topright[srcStride*(y-logo_y-yclipt)]
-			 + topright[srcStride*(y-logo_y-1-yclipt)]
-			 + topright[srcStride*(y-logo_y+1-yclipt)])*(x-logo_x)/logo_w
-		      + (topleft[x-logo_x-xclipl]
-			 + topleft[x-logo_x-1-xclipl]
-			 + topleft[x-logo_x+1-xclipl])*(logo_h-(y-logo_y))/logo_h
-		      + (botleft[x-logo_x-xclipl]
-			 + botleft[x-logo_x-1-xclipl]
-			 + botleft[x-logo_x+1-xclipl])*(y-logo_y)/logo_h
-		)/6;
-/*		interp = (topleft[srcStride*(y-logo_y)]*(logo_w-(x-logo_x))/logo_w
-			  + topright[srcStride*(y-logo_y)]*(x-logo_x)/logo_w
-			  + topleft[x-logo_x]*(logo_h-(y-logo_y))/logo_h
-			  + botleft[x-logo_x]*(y-logo_y)/logo_h
-			  )/2;*/
-	    if (y &gt;= logo_y+band &amp;&amp; y &lt; logo_y+logo_h-band &amp;&amp; x &gt;= logo_x+band &amp;&amp; x &lt; logo_x+logo_w-band) {
-		    *xdst = interp;
-	    } else {
-		dist = 0;
-		if (x &lt; logo_x+band) dist = MAX(dist, logo_x-x+band);
-		else if (x &gt;= logo_x+logo_w-band) dist = MAX(dist, x-(logo_x+logo_w-1-band));
-		if (y &lt; logo_y+band) dist = MAX(dist, logo_y-y+band);
-		else if (y &gt;= logo_y+logo_h-band) dist = MAX(dist, y-(logo_y+logo_h-1-band));
-		*xdst = (*xsrc*dist + interp*(band-dist))/band;
-		if (show &amp;&amp; (dist == band-1)) *xdst = 0;
-	    }
-	}
-
-	dst+= dstStride;
-	src+= srcStride;
-    }
-}
-
-#if 0
-static int put_image(struct vf_instance_s* vf, mp_image_t *mpi){
-    mp_image_t *dmpi;
-
-    if(!(mpi-&gt;flags&amp;MP_IMGFLAG_DIRECT)){
-	// no DR, so get a new image! hope we'll get DR buffer:
-	vf-&gt;dmpi=vf_get_image(vf-&gt;next,vf-&gt;priv-&gt;outfmt,
-			      MP_IMGTYPE_TEMP, MP_IMGFLAG_ACCEPT_STRIDE,
-			      mpi-&gt;w,mpi-&gt;h);
-    }
-    dmpi= vf-&gt;dmpi;
-
-    delogo(dmpi-&gt;planes[0], mpi-&gt;planes[0], dmpi-&gt;stride[0], mpi-&gt;stride[0], mpi-&gt;w, mpi-&gt;h,
-	   vf-&gt;priv-&gt;xoff, vf-&gt;priv-&gt;yoff, vf-&gt;priv-&gt;lw, vf-&gt;priv-&gt;lh, vf-&gt;priv-&gt;band, vf-&gt;priv-&gt;show,
-	   mpi-&gt;flags&amp;MP_IMGFLAG_DIRECT);
-    delogo(dmpi-&gt;planes[1], mpi-&gt;planes[1], dmpi-&gt;stride[1], mpi-&gt;stride[1], mpi-&gt;w/2, mpi-&gt;h/2,
-	   vf-&gt;priv-&gt;xoff/2, vf-&gt;priv-&gt;yoff/2, vf-&gt;priv-&gt;lw/2, vf-&gt;priv-&gt;lh/2, vf-&gt;priv-&gt;band/2, vf-&gt;priv-&gt;show,
-	   mpi-&gt;flags&amp;MP_IMGFLAG_DIRECT);
-    delogo(dmpi-&gt;planes[2], mpi-&gt;planes[2], dmpi-&gt;stride[2], mpi-&gt;stride[2], mpi-&gt;w/2, mpi-&gt;h/2,
-	   vf-&gt;priv-&gt;xoff/2, vf-&gt;priv-&gt;yoff/2, vf-&gt;priv-&gt;lw/2, vf-&gt;priv-&gt;lh/2, vf-&gt;priv-&gt;band/2, vf-&gt;priv-&gt;show,
-	   mpi-&gt;flags&amp;MP_IMGFLAG_DIRECT);
-
-    vf_clone_mpi_attributes(dmpi, mpi);
-
-    return vf_next_put_image(vf,dmpi);
-}
-
-static void uninit(struct vf_instance_s* vf){
-    if(!vf-&gt;priv) return;
-
-    free(vf-&gt;priv);
-    vf-&gt;priv=NULL;
-}
-
-//===========================================================================//
-
-static int query_format(struct vf_instance_s* vf, unsigned int fmt){
-    switch(fmt)
-    {
-    case IMGFMT_YV12:
-    case IMGFMT_I420:
-    case IMGFMT_IYUV:
-	return vf_next_query_format(vf,vf-&gt;priv-&gt;outfmt);
-    }
-    return 0;
-}
-
-static unsigned int fmt_list[]={
-    IMGFMT_YV12,
-    IMGFMT_I420,
-    IMGFMT_IYUV,
-    0
-};
-
-static int open(vf_instance_t *vf, char* args){
-    int res;
-    
-    vf-&gt;config=config;
-    vf-&gt;put_image=put_image;
-    vf-&gt;get_image=get_image;
-    vf-&gt;query_format=query_format;
-    vf-&gt;uninit=uninit;
-    if (!vf-&gt;priv)
-    {
-        vf-&gt;priv=malloc(sizeof(struct vf_priv_s));
-	memset(vf-&gt;priv, 0, sizeof(struct vf_priv_s));
-    }
-
-    if (args) res = sscanf(args, &quot;%d:%d:%d:%d:%d&quot;,
-			   &amp;vf-&gt;priv-&gt;xoff, &amp;vf-&gt;priv-&gt;yoff,
-			   &amp;vf-&gt;priv-&gt;lw, &amp;vf-&gt;priv-&gt;lh,
-			   &amp;vf-&gt;priv-&gt;band);
-    if (args &amp;&amp; (res != 5)) {
-	uninit(vf);
-	return 0; // bad syntax
-    }
-
-    mp_msg(MSGT_VFILTER, MSGL_V, &quot;delogo: %d x %d, %d x %d, band = %d\n&quot;,
-	   vf-&gt;priv-&gt;xoff, vf-&gt;priv-&gt;yoff,
-	   vf-&gt;priv-&gt;lw, vf-&gt;priv-&gt;lh,
-	   vf-&gt;priv-&gt;band);
-
-    vf-&gt;priv-&gt;show = 0;
-
-    if (vf-&gt;priv-&gt;band &lt; 0) {
-	vf-&gt;priv-&gt;band = 4;
-	vf-&gt;priv-&gt;show = 1;
-    }
-    
-
-    vf-&gt;priv-&gt;lw += vf-&gt;priv-&gt;band*2;
-    vf-&gt;priv-&gt;lh += vf-&gt;priv-&gt;band*2;
-    vf-&gt;priv-&gt;xoff -= vf-&gt;priv-&gt;band;
-    vf-&gt;priv-&gt;yoff -= vf-&gt;priv-&gt;band;
-
-    // check csp:
-    vf-&gt;priv-&gt;outfmt=vf_match_csp(&amp;vf-&gt;next,fmt_list,IMGFMT_YV12);
-    if(!vf-&gt;priv-&gt;outfmt)
-    {
-	uninit(vf);
-        return 0; // no csp match :(
-    }
-
-    return 1;
-}
-
-#define ST_OFF(f) M_ST_OFF(struct vf_priv_s,f)
-static m_option_t vf_opts_fields[] = {
-    { &quot;x&quot;, ST_OFF(xoff), CONF_TYPE_INT, 0, 0, 0, NULL },
-    { &quot;y&quot;, ST_OFF(yoff), CONF_TYPE_INT, 0, 0, 0, NULL },
-    { &quot;w&quot;, ST_OFF(lw), CONF_TYPE_INT, 0, 0, 0, NULL },
-    { &quot;h&quot;, ST_OFF(lh), CONF_TYPE_INT, 0, 0, 0, NULL },
-    { &quot;t&quot;, ST_OFF(band), CONF_TYPE_INT, 0, 0, 0, NULL },
-    { &quot;band&quot;, ST_OFF(band), CONF_TYPE_INT, 0, 0, 0, NULL }, // alias
-    { NULL, NULL, 0, 0, 0, 0, NULL }
-};
-
-static m_struct_t vf_opts = {
-    &quot;delogo&quot;,
-    sizeof(struct vf_priv_s),
-    &amp;vf_priv_dflt,
-    vf_opts_fields
-};
-
-vf_info_t vf_info_delogo = {
-    &quot;simple logo remover&quot;,
-    &quot;delogo&quot;,
-    &quot;Jindrich Makovicka, Alex Beregszaszi&quot;,
-    &quot;&quot;,
-    open,
-    &amp;vf_opts
-};
-#endif
-//===========================================================================//

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,24 +0,0 @@
-/***************************************************************************
-    copyright            : Mplayer team/Mean for ADM port
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_DELOGO_H
-#define ADM_DELOGO_H
-typedef struct MPDELOGO_PARAM
-{
-        uint32_t xoff;
-        uint32_t yoff;
-        uint32_t lw;
-        uint32_t lh;
-        uint32_t band;
-        uint32_t show;
-}MPDELOGO_PARAM;
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/CMakeLists.txt	2008-05-19 18:22:05 UTC (rev 4046)
@@ -1,13 +1,8 @@
 SET(ADM_video_SRCS 
-ADM_vidCNR2.cpp       
-ADM_vidFieldUnblend.cpp  
+#ADM_vidFieldUnblend.cpp  
 ADM_vidPartial.cpp    
-ADM_vidColorYuv.cpp   
 ADM_vidRaw.cpp        
 ADM_vidFont.cpp
-ADM_vidMPdelogo.cpp      
-ADM_vidClean.cpp        
-ADM_vidEqualizer.cpp  
 ADM_vidNull.cpp)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_video ${ADM_video_SRCS})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt	2008-05-19 18:22:05 UTC (rev 4046)
@@ -16,7 +16,6 @@
 	ADM_vidVobSubRender.cpp
 	ADM_vobsubinfo.cpp
 	ADM_vidComputeAverage.cpp
-	ADM_vidChromaShift.cpp
 	ADM_vidThreshold.cpp)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_videoFilter ${ADM_videoFilter_SRCS})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt	2008-05-19 18:22:05 UTC (rev 4046)
@@ -39,3 +39,8 @@
 ADD_SUBDIRECTORY(Soften)
 ADD_SUBDIRECTORY(lavDeinterlace)
 # Dependancy toward codecs ADD_SUBDIRECTORY(Logo)
+# Need flyDialog : ADD_SUBDIRECTORY(ChromaShift)
+ADD_SUBDIRECTORY(CNR2)
+ADD_SUBDIRECTORY(colorYUV)
+ADD_SUBDIRECTORY(Equalizer)
+ADD_SUBDIRECTORY(MPDelogo)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/ADM_vidCNR2.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/ADM_vidCNR2.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,505 @@
+//
+//      chroma noise reduction II (version 2.6.1) - Avisynth filter reducing noise on chroma
+//      Copyright (C) 2002 Marc Fauconneau
+//
+//      Inspired by :
+//  chroma noise reduction (version 1.1) - VirtualDub filter reducing noise on chroma
+//  Copyright (C) 2000 Gilles Mouchard
+//
+//  This program is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 2 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+//
+//  Please contact me for any bugs or questions.
+//  <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">marc.fd at libertysurf.fr</A>
+//
+//  Change log :
+//         30/06/2004 - ver 2.6.1 - YUY2 opts as I had slowed it down - tritical 
+//         29/06/2004 - ver 2.6  - Some bug fixes and some code cleanup 
+//                                 and rewriting (tritical - <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">kes25c at mizzou.edu</A>)
+//         18/11/2003 - ver 2.51 - Further bug fixes (by Klaus Post)
+//         13/11/2003 - ver 2.5  - Bug fixes (by Klaus Post)
+//         15/12/2002 - ver 2.4  - Bug fixes
+//         13/11/2002 - ver 2.3  - YV12 mode, scd (scenechange detection)
+//         01/08/2002 - ver 2.2  - Ugly bug fixed
+//         31/07/2002 - ver 2.1  - Bug Fixes (thx to dividee ;)
+//         20/07/2002 - ver 2.0  - Avisynth filter coded (from scratch)
+
+#include &lt;math.h&gt;
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+
+#include &quot;ADM_vidCNR2_param.h&quot;
+
+//#define SUBST 1
+
+class vidCNR2:public AVDMGenericVideoStream
+{
+
+protected:
+
+  unsigned char *py, *py_saved, *cy, *cy_saved;
+  unsigned char lt[513];
+  unsigned char ut[513];
+  unsigned char vt[513];
+  int nfrms, keepTrack;
+  unsigned int diffmax;
+
+  virtual char *printConf (void);
+  VideoCache *vidCache;
+  CNR2Param *_param;
+  void downSampleYV12 (unsigned char *dst, ADMImage * src);
+  uint8_t setup (void);
+public:
+
+    vidCNR2 (AVDMGenericVideoStream * in, CONFcouple * setup);
+    virtual ~ vidCNR2 ();
+  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
+					 ADMImage * data, uint32_t * flags);
+  uint8_t configure (AVDMGenericVideoStream * instream);
+  virtual uint8_t getCoupledConf (CONFcouple ** couples);
+
+};
+
+static FILTER_PARAM cnr2_template =
+  { 9, {&quot;scdthr&quot;, &quot;ln&quot;, &quot;lm&quot;, &quot;un&quot;, &quot;um&quot;, &quot;vn&quot;, &quot;vm&quot;, &quot;sceneChroma&quot;,
+	&quot;mode&quot;} };
+
+//REGISTERX(VF_NOISE, &quot;cnr2&quot;,QT_TR_NOOP(&quot;Cnr2&quot;),
+//QT_TR_NOOP(&quot;Chroma noise reduction filter by MarcFD/Tritical.&quot;),VF_CNR2,1,cnr2_create,cnr2_script);
+VF_DEFINE_FILTER(vidCNR2,cnr2_template,
+                cnr2,
+                QT_TR_NOOP(&quot;Cnr2&quot;),
+                1,
+                VF_NOISE,
+                QT_TR_NOOP(&quot;Chroma noise reduction filter by MarcFD/Tritical..&quot;));
+
+
+extern uint8_t DIA_cnr2(CNR2Param *param);
+/*************************************/
+uint8_t vidCNR2::configure (AVDMGenericVideoStream * in)
+{
+        if( DIA_cnr2(_param))
+        {
+                setup();
+                return 1;
+        }
+        return 0;
+}
+/*************************************/
+char *vidCNR2::printConf (void)
+{
+  static char buf[50];
+  sprintf ((char *) buf, &quot; CNR2 by MarcFD/Tritical&quot;);
+  return buf;
+}
+/*************************************/
+vidCNR2::vidCNR2 (AVDMGenericVideoStream * in, CONFcouple * couples)
+{
+
+  _in = in;
+  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
+  _info.encoding = 1;
+  _param = NEW (CNR2Param);
+  vidCache = new VideoCache (4, in);
+  _uncompressed=new ADMImage(_info.width,_info.height);
+  if (couples)
+    {
+#undef GET
+#define GET(x) couples-&gt;getCouple(#x,&amp;(_param-&gt;x))
+      GET (scdthr);
+      GET (ln);
+      GET (lm);
+      GET (un);
+      GET (um);
+      GET (vn);
+      GET (vm);
+      GET (sceneChroma);
+      GET (mode);
+    }
+  else				// Default
+    {
+      _param-&gt;scdthr = 10.f;
+      _param-&gt;lm = 192;
+      _param-&gt;ln = 35;
+      _param-&gt;un = 47;
+      _param-&gt;um = 255;
+      _param-&gt;vn = 47;
+      _param-&gt;vm = 255;
+      _param-&gt;sceneChroma = 0;
+      _param-&gt;mode = 0x00FFFF; // u&amp;v in narrow mode
+    }
+  //
+  py_saved = py = cy_saved = cy = NULL;
+  py = new unsigned char[(_info.width * _info.height) &gt;&gt; 2];
+  py_saved = py;
+  cy = new unsigned char[(_info.width * _info.height) &gt;&gt; 2];
+  cy_saved = cy;
+  nfrms = _info.nb_frames - 1;
+  setup ();
+}
+/*************************************/
+uint8_t vidCNR2::setup (void)
+{
+double root;
+double num,denum,mul;
+
+  root= _info.height * _info.width;
+  root*=_param-&gt;scdthr;
+  if (_param-&gt;sceneChroma)
+    diffmax =      (int) ((root * 331.0f) / 100.0f);
+  else
+    diffmax =      (int) ((root* 219.0f) / 100.0f);
+
+  memset (lt, 0, 513);		// for safety
+  memset (ut, 0, 513);
+  memset (vt, 0, 513);
+
+  keepTrack = -39482;
+
+  const double pi = M_PI;
+  bool Y = true, U = true, V = true;
+  if (_param-&gt;mode &amp; 0xFF0000 )
+    Y = false;
+  if (_param-&gt;mode &amp; 0x00FF00 )
+    U = false;
+  if (_param-&gt;mode &amp; 0x0000FF )
+    V = false;
+
+// Reset
+  int i, j;
+  for (i = -256; i &lt; 256; ++i)
+  {
+    lt[i + 256] = 0;
+    ut[i + 256] = 0;
+    vt[i + 256] = 0;
+  }
+ 
+ num=M_PI;
+        /************************ Y********************/
+ mul=_param-&gt;lm / 2.;
+ if(Y)
+ { 
+  denum=_param-&gt;ln*_param-&gt;ln;
+  for (j = -_param-&gt;ln; j &lt;= _param-&gt;ln; ++j)
+        lt[j + 256] =  (int) (mul * (1 + cos ((j * j * num) / denum)));
+ }
+ else
+ {
+  denum=_param-&gt;ln;
+  for (j = -_param-&gt;ln; j &lt;= _param-&gt;ln; ++j)
+        lt[j + 256] =  (int) (mul * (1 + cos ((j * num) / denum)));
+ 
+ }
+
+  
+    /************************ U ********************/
+ mul=_param-&gt;um / 2.;
+ if(U)
+ {
+        denum=_param-&gt;un*_param-&gt;un;
+        for (j = -_param-&gt;un; j &lt;= _param-&gt;un; ++j)
+                ut[j + 256] =  (int) (mul * (1 + cos ((j * j * pi) / (denum))));
+ }
+ else
+ {
+        denum=_param-&gt;un;
+        for (j = -_param-&gt;un; j &lt;= _param-&gt;un; ++j)
+                ut[j + 256] =  (int) (mul * (1 + cos ((j  * pi) / (denum))));
+
+ }
+      /************************ V ********************/  
+  mul=_param-&gt;vm / 2.;
+  if(V)
+   {
+        denum=_param-&gt;vn*_param-&gt;vn;
+        for (j = -_param-&gt;vn; j &lt;= _param-&gt;vn; ++j)
+                vt[j + 256] =  (int) (mul * (1 + cos ((j * j * pi) / (denum))));
+ }
+ else
+ {
+        denum=_param-&gt;vn;
+        for (j = -_param-&gt;vn; j &lt;= _param-&gt;vn; ++j)
+                vt[j + 256] =  (int) (mul * (1 + cos ((j  * pi) / (denum))));
+ } 
+  return 1;
+}
+//____________________________________________________________________
+vidCNR2::~vidCNR2 ()
+{
+
+  delete _param;
+  _param = NULL;
+  DELETE( _param);
+  delete vidCache;
+  _param = NULL;
+  vidCache = NULL;
+  delete[]py_saved;
+  delete[]cy_saved;
+  
+  py_saved = NULL;
+  cy_saved = NULL;
+  
+  delete _uncompressed;
+  _uncompressed=NULL;
+
+}
+
+//______________________________________________________________
+uint8_t vidCNR2::getFrameNumberNoAlloc (uint32_t frame,
+				uint32_t * len,
+				ADMImage * data, uint32_t * flags)
+{
+  ADMImage *cur, *mprev, *src;
+
+  if (frame &gt;= _info.nb_frames)
+    return 0;
+
+  cur = vidCache-&gt;getImage (frame);
+  src = cur;
+  if (!frame)
+    {
+      data-&gt;duplicate (cur);
+      vidCache-&gt;unlockAll ();
+      return 1;
+    }
+  const unsigned char *srcpY = YPLANE (src);	//src-&gt;GetReadPtr(PLANAR_Y);
+  const unsigned char *srcpU = UPLANE (src);	//src-&gt;GetReadPtr(PLANAR_U);
+  const unsigned char *srcpV = VPLANE (src);	//src-&gt;GetReadPtr(PLANAR_V);
+  const unsigned char *srcp;
+
+  int src_pitchY = _info.width;	//src-&gt;GetPitch(PLANAR_Y);
+  int src_pitchUV = _info.width &gt;&gt; 1;	//src-&gt;GetPitch(PLANAR_V);
+  int heightY = _info.height;	//src-&gt;GetHeight(PLANAR_Y);
+  int heightUV = _info.height &gt;&gt; 1;	//src-&gt;GetHeight(PLANAR_V);
+  int widthY = _info.width ;	//src-&gt;GetRowSize(PLANAR_Y);
+  int widthYd2 = widthY &gt;&gt; 1;
+  int widthUV = _info.width &gt;&gt; 1;	//src-&gt;GetRowSize(PLANAR_V);
+
+  downSampleYV12 (cy, src);
+  if (keepTrack != frame)
+    {
+      mprev = vidCache-&gt;getImage (frame - 1);
+      _uncompressed-&gt;duplicate(mprev); // not optimal  
+      keepTrack = frame;
+      downSampleYV12 (py, mprev);
+    }
+  unsigned char *dstpY = YPLANE (data);	//dst-&gt;GetWritePtr(PLANAR_Y);
+  unsigned char *dstpU = UPLANE (data);	//dst-&gt;GetWritePtr(PLANAR_U);
+  unsigned char *dstpV = VPLANE (data);	//dst-&gt;GetWritePtr(PLANAR_V);
+  unsigned char *dstp, *prevy, *prevp, *curry, *t, *swap;
+  int dst_pitchY = _info.width;	//dst-&gt;GetPitch(PLANAR_Y);
+  int dst_pitchUV = _info.width &gt;&gt; 1;	//dst-&gt;GetPitch(PLANAR_V);
+  int y, x, ydiff, uvdiff, cr;
+  unsigned int difft = 0;
+  const int off = 256;
+  int res;
+  // U plane (we add the luma plane diff to difft here not on v)
+  prevy = py;
+  curry = cy;
+  t = ut;
+  srcp = srcpU;
+  dstp = dstpU;
+  prevp = UPLANE (_uncompressed);	//prev-&gt;GetWritePtr(PLANAR_U);
+  int prev_pitchUV = _info.width &gt;&gt; 1;	//prev-&gt;GetPitch(PLANAR_V);
+  if (_param-&gt;sceneChroma)
+    {
+      for (y = 0; y &lt; heightUV; ++y)
+	{
+	  for (x = 0; x &lt; widthUV; ++x)
+	    {
+	      ydiff = curry[x] - prevy[x];
+	      uvdiff = srcp[x] - prevp[x];
+	      difft += abs (uvdiff) + abs (ydiff &lt;&lt; 2);
+	      cr = (lt[ydiff + off] * t[uvdiff + off]);
+	       res=(cr * prevp[x] + (65536 - cr) * srcp[x] + 32768) &gt;&gt; 16;
+#ifdef SUBST
+                if(res!=srcp[x]) dstp[x]=120;
+                        else dstp[x]=0;
+#else
+                 dstp[x] = prevp[x]=res;
+#endif
+	    }
+	  if (difft &gt; diffmax)
+	    {
+	      goto exit;
+	    }
+	  srcp += src_pitchUV;
+	  dstp += dst_pitchUV;
+	  prevp += prev_pitchUV;
+	  curry += widthYd2;
+	  prevy += widthYd2;
+	}
+    }
+  else
+    {
+      for (y = 0; y &lt; heightUV; ++y)
+	{
+	  for (x = 0; x &lt; widthUV; ++x)
+	    {
+	      ydiff = curry[x] - prevy[x];
+	      uvdiff = srcp[x] - prevp[x];
+	      difft += abs (ydiff &lt;&lt; 2);
+	      cr = (lt[ydiff + off] * t[uvdiff + off]);
+	      res =		(cr * prevp[x] + (65536 - cr) * srcp[x] + 32768) &gt;&gt; 16;
+#ifdef SUBST
+                if(res!=srcp[x]) dstp[x]=120;
+                        else dstp[x]=0;
+#else
+                 dstp[x] = prevp[x]=res;
+#endif
+
+	    }
+	  if (difft &gt; diffmax)
+	    {
+	      goto exit;
+	    }
+	  srcp += src_pitchUV;
+	  dstp += dst_pitchUV;
+	  prevp += prev_pitchUV;
+	  curry += widthYd2;
+	  prevy += widthYd2;
+	}
+    }
+  // V plane
+  prevy = py;
+  curry = cy;
+  t = vt;
+  srcp = srcpV;
+  dstp = dstpV;
+  prevp = VPLANE (_uncompressed);	//prev-&gt;GetWritePtr(PLANAR_V);
+  if (_param-&gt;sceneChroma)
+    {
+      for (y = 0; y &lt; heightUV; ++y)
+	{
+	  for (x = 0; x &lt; widthUV; ++x)
+	    {
+	      ydiff = curry[x] - prevy[x];
+	      uvdiff = srcp[x] - prevp[x];
+	      difft += abs (uvdiff);
+	      cr = (lt[ydiff + off] * t[uvdiff + off]);
+	      res =(cr * prevp[x] + (65536 - cr) * srcp[x] + 32768) &gt;&gt; 16;
+#ifdef SUBST
+                if(res!=srcp[x]) dstp[x]=120;
+                        else dstp[x]=0;
+#else
+                 dstp[x] = prevp[x]=res;
+#endif
+
+	    }
+	  if (difft &gt; diffmax)
+	    {
+	      goto exit;
+	    }
+	  srcp += src_pitchUV;
+	  dstp += dst_pitchUV;
+	  prevp += prev_pitchUV;
+	  curry += widthYd2;
+	  prevy += widthYd2;
+	}
+    }
+  else
+    {
+      for (y = 0; y &lt; heightUV; ++y)
+	{
+	  for (x = 0; x &lt; widthUV; ++x)
+	    {
+	      ydiff = curry[x] - prevy[x];
+	      uvdiff = srcp[x] - prevp[x];
+	      cr = (lt[ydiff + off] * t[uvdiff + off]);
+	      res =(cr * prevp[x] + (65536 - cr) * srcp[x] + 32768) &gt;&gt; 16;
+#ifdef SUBST
+                if(res!=srcp[x]) dstp[x]=120;
+                        else dstp[x]=0;
+#else
+                 dstp[x] = prevp[x]=res;
+#endif
+
+	    }
+	  srcp += src_pitchUV;
+	  dstp += dst_pitchUV;
+	  prevp += prev_pitchUV;
+	  curry += widthYd2;
+	  prevy += widthYd2;
+	}
+    }
+exit:
+//#define CNR_VERBOSE
+#if defined( CNR_VERBOSE) &amp;&amp; defined(ADM_DEBUG)
+        printf(&quot;cur:%u max:%u\n&quot;,difft,diffmax);
+#endif
+        // Scene change ?
+  if (difft &gt; diffmax)
+    {
+      data-&gt;duplicate (cur);
+      vidCache-&gt;unlockAll ();
+      return 1;
+    }
+  ++keepTrack;
+  // Dupe luma
+  memcpy (dstpY, srcpY, _info.height * _info.width);
+
+  swap = py;
+  py = cy;
+  cy = swap;
+  vidCache-&gt;unlockAll ();
+  return 1;
+}
+
+/*************************************/
+void vidCNR2::downSampleYV12 (unsigned char *dst, ADMImage * src)
+{
+  unsigned char *temp = dst;
+  const unsigned char *srcpY = YPLANE (src);
+  int src_pitchY = _info.width &lt;&lt; 1;
+  const unsigned char *srcpnY = srcpY + (src_pitchY &gt;&gt; 1);
+  int widthY = _info.width &gt;&gt; 1;
+  int heightY = _info.height &gt;&gt; 1;
+  int x, y, temp1;
+  for (y = 0; y &lt; heightY; ++y)
+    {
+      for (x = 0; x &lt; widthY; ++x)
+	{
+	  temp1 = x &lt;&lt; 1;
+	  temp[x] =
+	    (srcpY[temp1] + srcpY[temp1 + 1] + srcpnY[temp1] +
+	     srcpnY[temp1 + 1] + 2) &gt;&gt; 2;
+	}
+      srcpY += src_pitchY;
+      srcpnY += src_pitchY;
+      temp += widthY;
+    }
+}
+/*************************************/
+uint8_t vidCNR2::getCoupledConf (CONFcouple ** couples)
+{
+
+  ADM_assert (_param);
+  *couples = new CONFcouple (9);
+#undef CSET
+#define CSET(x)  (*couples)-&gt;setCouple(#x,(_param-&gt;x))
+
+  CSET (scdthr);
+  CSET (ln);
+  CSET (lm);
+  CSET (un);
+  CSET (um);
+  CSET (vn);
+  CSET (vm);
+  CSET (sceneChroma);
+  CSET (mode);
+
+  return 1;
+}
+
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/ADM_vidCNR2_param.h (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidCNR2_param.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/ADM_vidCNR2_param.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,30 @@
+/***************************************************************************
+    copyright            : (C) 2005 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _CNR2_
+#define _CNR2_
+
+typedef struct CNR2Param
+{
+        double scdthr;          // Scene change threshold in % default 10
+        int32_t ln, lm;         // n=sensibility, m=maximum
+        int32_t un, um;
+        int32_t vn, vm;
+        int32_t sceneChroma;    // If true, both luma &amp; chroma are used for scene detection
+        uint32_t mode;          // XX 00 00 Y, 00 XX 00 U , 00 00 XX V
+                                // Default is wide, puting a bit means narrow
+
+} CNR2Param;
+
+#endif

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/CMakeLists.txt	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/CMakeLists.txt	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,14 @@
+INCLUDE(vf_plugin)
+
+
+SET(cnr2Common_SRCS 
+ADM_vidCNR2.cpp
+)
+
+INCLUDE(vf_plugin_gtk)
+
+SET(cnr2Gtk_SRCS gtk/DIA_cnr2.cpp)
+
+INIT_VIDEOFILTER_PLUGIN_GTK(  ADM_vf_cnr2_gtk 
+                ${cnr2Gtk_SRCS} ${cnr2Common_SRCS})
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/gtk/DIA_cnr2.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_cnr2.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_cnr2.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CNR2/gtk/DIA_cnr2.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,348 @@
+//
+// C++ Implementation: DIA_Msmooth
+//
+// Description: 
+//
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+//
+
+#include &quot;ADM_toolkitGtk.h&quot;
+#include &quot;ADM_vidCNR2_param.h&quot;
+
+static GtkWidget        *create_dialog1 (void);
+
+#define CHECK_GET(x,y) {param-&gt;y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
+#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param-&gt;y);}     
+
+#define ENTRY_SET(x) {gtk_write_entry(WID(entry##x),(int)param-&gt;x);}
+#define ENTRY_GET(x) {param-&gt;x=gtk_read_entry(WID(entry##x));}
+
+
+uint8_t DIA_cnr2(CNR2Param *param);
+uint8_t DIA_cnr2(CNR2Param *param)
+{
+GtkWidget *dialog;
+int ret=0;
+        dialog=create_dialog1();
+        
+        // Update
+        ENTRY_SET(lm);ENTRY_SET(ln);
+        ENTRY_SET(um);ENTRY_SET(un);
+        ENTRY_SET(vm);ENTRY_SET(vn);
+
+        CHECK_SET(checkbuttonChroma,sceneChroma);
+
+        if(param-&gt;mode &amp; 0xFF0000) gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonl)),1);
+        if(param-&gt;mode &amp; 0xFF00) gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonu)),1);
+        if(param-&gt;mode &amp; 0xFF) gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonv)),1);
+        
+        gtk_range_set_value (GTK_RANGE(WID(hscale1)),(gdouble)param-&gt;scdthr);
+        
+        //**************************
+        gtk_register_dialog(dialog);
+        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
+        {
+          GtkAdjustment *adj;   
+
+                adj=gtk_range_get_adjustment (GTK_RANGE(WID(hscale1)));
+                param-&gt;scdthr=(double)GTK_ADJUSTMENT(adj)-&gt;value;
+        
+                ENTRY_GET(lm);ENTRY_GET(ln);
+                ENTRY_GET(um);ENTRY_GET(un);
+                ENTRY_GET(vm);ENTRY_GET(vn);
+
+                CHECK_GET(checkbuttonChroma,sceneChroma);
+                param-&gt;mode=0;
+#define UPD(x,y) if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(WID(x)))) param-&gt;mode|=y;
+                        UPD(checkbuttonl,0xFF0000);
+                        UPD(checkbuttonu,0xFF00);
+                        UPD(checkbuttonv,0xFF);
+               
+
+                ret=1;
+        
+        }
+        gtk_unregister_dialog(dialog);
+        gtk_widget_destroy(dialog);
+        return ret;
+
+}
+
+//__________________________________
+
+GtkWidget*
+create_dialog1 (void)
+{
+  GtkWidget *dialog1;
+  GtkWidget *dialog_vbox1;
+  GtkWidget *vbox1;
+  GtkWidget *frame3;
+  GtkWidget *alignment3;
+  GtkWidget *hscale1;
+  GtkWidget *label9;
+  GtkWidget *frame1;
+  GtkWidget *alignment1;
+  GtkWidget *table1;
+  GtkWidget *label3;
+  GtkWidget *label4;
+  GtkWidget *label2;
+  GtkWidget *label5;
+  GtkWidget *label6;
+  GtkWidget *label7;
+  GtkWidget *entryln;
+  GtkWidget *entrylm;
+  GtkWidget *entryun;
+  GtkWidget *entryvn;
+  GtkWidget *entryum;
+  GtkWidget *entryvm;
+  GtkWidget *label10;
+  GtkWidget *checkbuttonl;
+  GtkWidget *checkbuttonu;
+  GtkWidget *checkbuttonv;
+  GtkWidget *label1;
+  GtkWidget *frame2;
+  GtkWidget *alignment2;
+  GtkWidget *vbox2;
+  GtkWidget *checkbuttonChroma;
+  GtkWidget *label8;
+  GtkWidget *dialog_action_area1;
+  GtkWidget *cancelbutton1;
+  GtkWidget *okbutton1;
+
+  dialog1 = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;Chroma Noise Reduction 2&quot;));
+  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
+
+  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
+  gtk_widget_show (dialog_vbox1);
+
+  vbox1 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
+
+  frame3 = gtk_frame_new (NULL);
+  gtk_widget_show (frame3);
+  gtk_box_pack_start (GTK_BOX (vbox1), frame3, TRUE, TRUE, 0);
+  gtk_frame_set_shadow_type (GTK_FRAME (frame3), GTK_SHADOW_NONE);
+
+  alignment3 = gtk_alignment_new (0.5, 0.5, 1, 1);
+  gtk_widget_show (alignment3);
+  gtk_container_add (GTK_CONTAINER (frame3), alignment3);
+  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment3), 0, 0, 12, 0);
+
+  hscale1 = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 100, 1, 1, 0)));
+  gtk_widget_show (hscale1);
+  gtk_container_add (GTK_CONTAINER (alignment3), hscale1);
+  gtk_scale_set_digits (GTK_SCALE (hscale1), 2);
+
+  label9 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Scene change Treshold&lt;/b&gt;&quot;));
+  gtk_widget_show (label9);
+  gtk_frame_set_label_widget (GTK_FRAME (frame3), label9);
+  gtk_label_set_use_markup (GTK_LABEL (label9), TRUE);
+
+  frame1 = gtk_frame_new (NULL);
+  gtk_widget_show (frame1);
+  gtk_box_pack_start (GTK_BOX (vbox1), frame1, TRUE, TRUE, 0);
+  gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_NONE);
+
+  alignment1 = gtk_alignment_new (0.5, 0.5, 1, 1);
+  gtk_widget_show (alignment1);
+  gtk_container_add (GTK_CONTAINER (frame1), alignment1);
+  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment1), 0, 0, 12, 0);
+
+  table1 = gtk_table_new (4, 4, FALSE);
+  gtk_widget_show (table1);
+  gtk_container_add (GTK_CONTAINER (alignment1), table1);
+
+  label3 = gtk_label_new (QT_TR_NOOP(&quot;Sensibility&quot;));
+  gtk_widget_show (label3);
+  gtk_table_attach (GTK_TABLE (table1), label3, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_CENTER);
+  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
+
+  label4 = gtk_label_new (QT_TR_NOOP(&quot;Max&quot;));
+  gtk_widget_show (label4);
+  gtk_table_attach (GTK_TABLE (table1), label4, 2, 3, 0, 1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_CENTER);
+  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
+
+  label2 = gtk_label_new (&quot;&quot;);
+  gtk_widget_show (label2);
+  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
+
+  label5 = gtk_label_new (QT_TR_NOOP(&quot;Luma :&quot;));
+  gtk_widget_show (label5);
+  gtk_table_attach (GTK_TABLE (table1), label5, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
+
+  label6 = gtk_label_new (QT_TR_NOOP(&quot;Chroma U :&quot;));
+  gtk_widget_show (label6);
+  gtk_table_attach (GTK_TABLE (table1), label6, 0, 1, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label6), 0, 0.5);
+
+  label7 = gtk_label_new (QT_TR_NOOP(&quot;Chroma V :&quot;));
+  gtk_widget_show (label7);
+  gtk_table_attach (GTK_TABLE (table1), label7, 0, 1, 3, 4,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label7), 0, 0.5);
+
+  entryln = gtk_entry_new ();
+  gtk_widget_show (entryln);
+  gtk_table_attach (GTK_TABLE (table1), entryln, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  entrylm = gtk_entry_new ();
+  gtk_widget_show (entrylm);
+  gtk_table_attach (GTK_TABLE (table1), entrylm, 2, 3, 1, 2,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  entryun = gtk_entry_new ();
+  gtk_widget_show (entryun);
+  gtk_table_attach (GTK_TABLE (table1), entryun, 1, 2, 2, 3,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  entryvn = gtk_entry_new ();
+  gtk_widget_show (entryvn);
+  gtk_table_attach (GTK_TABLE (table1), entryvn, 1, 2, 3, 4,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  entryum = gtk_entry_new ();
+  gtk_widget_show (entryum);
+  gtk_table_attach (GTK_TABLE (table1), entryum, 2, 3, 2, 3,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  entryvm = gtk_entry_new ();
+  gtk_widget_show (entryvm);
+  gtk_table_attach (GTK_TABLE (table1), entryvm, 2, 3, 3, 4,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  label10 = gtk_label_new (QT_TR_NOOP(&quot;Narrow&quot;));
+  gtk_widget_show (label10);
+  gtk_table_attach (GTK_TABLE (table1), label10, 3, 4, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label10), 0, 0.5);
+
+  checkbuttonl = gtk_check_button_new_with_mnemonic (&quot;&quot;);
+  gtk_widget_show (checkbuttonl);
+  gtk_table_attach (GTK_TABLE (table1), checkbuttonl, 3, 4, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  checkbuttonu = gtk_check_button_new_with_mnemonic (&quot;&quot;);
+  gtk_widget_show (checkbuttonu);
+  gtk_table_attach (GTK_TABLE (table1), checkbuttonu, 3, 4, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  checkbuttonv = gtk_check_button_new_with_mnemonic (&quot;&quot;);
+  gtk_widget_show (checkbuttonv);
+  gtk_table_attach (GTK_TABLE (table1), checkbuttonv, 3, 4, 3, 4,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  label1 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Settings&lt;/b&gt;&quot;));
+  gtk_widget_show (label1);
+  gtk_frame_set_label_widget (GTK_FRAME (frame1), label1);
+  gtk_label_set_use_markup (GTK_LABEL (label1), TRUE);
+
+  frame2 = gtk_frame_new (NULL);
+  gtk_widget_show (frame2);
+  gtk_box_pack_start (GTK_BOX (vbox1), frame2, TRUE, TRUE, 0);
+  gtk_frame_set_shadow_type (GTK_FRAME (frame2), GTK_SHADOW_NONE);
+
+  alignment2 = gtk_alignment_new (0.5, 0.5, 1, 1);
+  gtk_widget_show (alignment2);
+  gtk_container_add (GTK_CONTAINER (frame2), alignment2);
+  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment2), 0, 0, 12, 0);
+
+  vbox2 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox2);
+  gtk_container_add (GTK_CONTAINER (alignment2), vbox2);
+
+  checkbuttonChroma = gtk_check_button_new_with_mnemonic (QT_TR_NOOP(&quot;Use also chroma to detect scene change&quot;));
+  gtk_widget_show (checkbuttonChroma);
+  gtk_box_pack_start (GTK_BOX (vbox2), checkbuttonChroma, FALSE, FALSE, 0);
+
+  label8 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Mode&lt;/b&gt;&quot;));
+  gtk_widget_show (label8);
+  gtk_frame_set_label_widget (GTK_FRAME (frame2), label8);
+  gtk_label_set_use_markup (GTK_LABEL (label8), TRUE);
+
+  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
+  gtk_widget_show (dialog_action_area1);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
+
+  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
+  gtk_widget_show (cancelbutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
+  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
+
+  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
+  gtk_widget_show (okbutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
+  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, vbox1, &quot;vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, frame3, &quot;frame3&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, alignment3, &quot;alignment3&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hscale1, &quot;hscale1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label9, &quot;label9&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, frame1, &quot;frame1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, alignment1, &quot;alignment1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, table1, &quot;table1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label3, &quot;label3&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label4, &quot;label4&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label2, &quot;label2&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label5, &quot;label5&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label6, &quot;label6&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label7, &quot;label7&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, entryln, &quot;entryln&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, entrylm, &quot;entrylm&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, entryun, &quot;entryun&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, entryvn, &quot;entryvn&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, entryum, &quot;entryum&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, entryvm, &quot;entryvm&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label10, &quot;label10&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonl, &quot;checkbuttonl&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonu, &quot;checkbuttonu&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonv, &quot;checkbuttonv&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, frame2, &quot;frame2&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, alignment2, &quot;alignment2&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, vbox2, &quot;vbox2&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonChroma, &quot;checkbuttonChroma&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label8, &quot;label8&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
+
+  return dialog1;
+}
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/ADM_vidChromaShift.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/ADM_vidChromaShift.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/ADM_vidChromaShift.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,250 @@
+/***************************************************************************
+                          ADM_vidChromaShift.cpp  -  description
+                             -------------------
+	Try to remove the blue-to-theleft &amp; red to the right effect by shifting chroma
+
+    begin                : Sun Aug 14 2003
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+
+
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;ADM_vidChromaShift.h&quot;
+
+
+
+static FILTER_PARAM cshiftParam={2,{&quot;u&quot;,&quot;v&quot;}};
+/*
+REGISTERX(VF_COLORS, &quot;chromashift&quot;,QT_TR_NOOP(&quot;Chroma shift&quot;)
+    ,QT_TR_NOOP(&quot;Shift chroma U/V to fix badly synced luma/chroma.&quot;),VF_CHROMASHIFT,1,create_chromashift,chromashift_script);
+
+SCRIPT_CREATE(chromashift_script,ADMVideoChromaShift,cshiftParam);
+BUILD_CREATE(create_chromashift,ADMVideoChromaShift);
+*/
+VF_DEFINE_FILTER(ADMVideoChromaShift,cshiftParam,
+    chromashift,
+                QT_TR_NOOP(&quot;Chroma shift&quot;),
+                1,
+                VF_COLORS,
+                QT_TR_NOOP(&quot;Shift chroma U/V to fix badly synced luma/chroma.&quot;));
+char *ADMVideoChromaShift::printConf( void )
+{
+ 	static char buf[50];
+
+ 	snprintf((char *)buf,50,&quot; Chroma shift U:%d  V:%d&quot;,
+            _param-&gt;u,_param-&gt;v);
+        return buf;
+}
+
+ADMVideoChromaShift::ADMVideoChromaShift(  AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+ 	_in=in;		
+   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  		
+	 _param=NEW(CHROMASHIFT_PARAM);
+		if(couples)
+		{
+				GET(u);
+				GET(v);
+		}
+			else
+		{	// default parameter
+				_param-&gt;u=0;
+				_param-&gt;v=0;
+		}
+
+	_uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+	ADM_assert(_uncompressed);
+	_info.encoding=1;
+}
+
+
+uint8_t	ADMVideoChromaShift::getCoupledConf( CONFcouple **couples)
+{
+
+		ADM_assert(_param);
+		*couples=new CONFcouple(2);
+		CSET(u);
+		CSET(v);
+		return 1;
+
+}
+
+ADMVideoChromaShift::~ADMVideoChromaShift()
+{
+	if(_uncompressed)
+ 		delete _uncompressed;
+	_uncompressed=NULL;
+	DELETE(_param);
+
+}
+uint8_t ADMVideoChromaShift::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+
+		if(frame&gt;= _info.nb_frames) return 0;
+		ADM_assert(_param);									
+								
+		// read uncompressed frame
+       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+
+		// copy luma as it is left untouched
+		uint32_t w=_info.width;
+		uint32_t h=_info.height;
+//		uint8_t *in,*out;
+		uint32_t page;
+
+		page=(w*h);
+
+		memcpy(YPLANE(data),YPLANE(_uncompressed),page);
+
+		if(!_param-&gt;u)
+			{
+				memcpy(UPLANE(data),UPLANE(_uncompressed),page&gt;&gt;2);
+			}
+		else
+			{
+				shift(UPLANE(data),UPLANE(_uncompressed),w&gt;&gt;1,h&gt;&gt;1,_param-&gt;u);
+			}
+		if(!_param-&gt;v)
+			{
+				memcpy(VPLANE(data),VPLANE(_uncompressed),page&gt;&gt;2);
+			}
+		else
+			{
+				shift(VPLANE(data),VPLANE(_uncompressed),w&gt;&gt;1,h&gt;&gt;1,_param-&gt;v);
+			}
+		if(_param-&gt;u)
+			fixup(YPLANE(data),w,h,_param-&gt;u*2);
+		if(_param-&gt;v)
+			fixup(YPLANE(data),w,h,_param-&gt;v*2);
+		  data-&gt;copyInfo(_uncompressed);
+      return 1;
+}
+/*
+	Black out the area were we don't have a valid chroma color
+
+*/
+uint8_t ADMVideoChromaShift::fixup(uint8_t *target,uint32_t width, uint32_t height,int32_t val)
+{
+uint32_t line,page;
+uint8_t *zero;
+uint8_t *zerochroma;
+/*
+	If val is &gt;0
+		Source  ++++++++
+		Target   __++++++
+*/
+	page=(width*height)&gt;&gt;2;
+	if(val&gt;0)
+		{
+			line=val;
+			zero=target;
+			zerochroma=target+width*height;
+			for(uint32_t h=height;h&gt;0;h--)
+			{
+				memset(zero,0,val);
+				zero+=width;
+			}
+			val&gt;&gt;=1;
+			for(uint32_t h=height&gt;&gt;1;h&gt;0;h--)
+			{
+				memset(zerochroma,128,val);
+				memset(zerochroma+page,128,val);
+				zerochroma+=width&gt;&gt;1;
+			}
+		}
+/*
+	if val is &lt;0
+		Source ++++++
+		Target  ++++__
+
+*/
+
+		else
+		{
+			val=-val;
+
+			zero=target+width-val;
+			zerochroma=target+width*height;
+			zerochroma+=(width-val)/2;
+
+			for(uint32_t h=height;h&gt;0;h--)
+			{
+				memset(zero,0,val);
+				zero+=width;
+			}
+
+			val&gt;&gt;=1;
+			for(uint32_t h=height&gt;&gt;1;h&gt;0;h--)
+			{
+				memset(zerochroma,128,val);
+				memset(zerochroma+page,128,val);
+				zerochroma+=width&gt;&gt;1;
+			}
+		}
+}
+uint8_t ADMVideoChromaShift::shift(uint8_t *target,uint8_t *source, uint32_t width, uint32_t height,int32_t val)
+{
+uint32_t line;
+
+/*
+	If val is &gt;0
+		Source  ++++++++
+		Target   __++++++
+*/
+	if(val&gt;0)
+		{
+			line=width-val;
+			target+=val;
+			for(uint32_t h=height;h&gt;0;h--)
+			{
+			memcpy(target,source,line);
+			target+=width;
+			source+=width;
+			}
+		}
+/*
+	if val is &lt;0
+		Source ++++++
+		Target  ++++__
+
+*/
+
+		else
+		{
+			val=-val;
+			line=width-val;
+			source+=val;
+
+			for(uint32_t h=height;h&gt;0;h--)
+			{
+			memcpy(target,source,line);
+			target+=width;
+			source+=width;
+			}
+		}
+	return 1;
+}
+uint8_t DIA_getChromaShift( AVDMGenericVideoStream *instream,CHROMASHIFT_PARAM    *param );
+uint8_t ADMVideoChromaShift::configure( AVDMGenericVideoStream *instream)
+
+{
+    return DIA_getChromaShift(instream,_param);
+
+}
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/ADM_vidChromaShift.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/ADM_vidChromaShift.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/ADM_vidChromaShift.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,50 @@
+/***************************************************************************
+                          ADM_vidChromaShift.h  -  description
+                             -------------------
+
+	Shift chroma to the left or to the right
+
+    begin                : Wed Aug 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef CHROMASHIFT_
+#define CHROMASHIFT_
+
+#include &quot;ADM_vidChromaShift_param.h&quot;
+ class  ADMVideoChromaShift:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+
+            virtual 	char               *printConf(void);
+                        CHROMASHIFT_PARAM *_param;
+
+ public:
+                        ADMVideoChromaShift(  AVDMGenericVideoStream *in,CONFcouple *setup);
+      virtual           ~ADMVideoChromaShift();
+      virtual uint8_t   getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                                              ADMImage *data,uint32_t *flags);
+      virtual uint8_t   configure( AVDMGenericVideoStream *instream);
+      virtual uint8_t   getCoupledConf( CONFcouple **couples);
+
+      static	uint8_t shift(uint8_t *target,uint8_t *source,
+                                                      uint32_t width, uint32_t height,
+                                                      int32_t val);
+      static uint8_t    fixup(uint8_t *target,uint32_t width, uint32_t height,int32_t val);
+
+ }     ;
+
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/ADM_vidChromaShift_param.h (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/ADM_vidChromaShift_param.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,30 @@
+/***************************************************************************
+                          ADM_vidChromaShift.h  -  description
+                             -------------------
+
+	Shift chroma to the left or to the right
+
+    begin                : Wed Aug 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef CHROMASHIFT_PARAM_
+#define CHROMASHIFT_PARAM_
+
+typedef struct CHROMASHIFT_PARAM
+{
+      int32_t u;
+      int32_t v;
+}CHROMASHIFT_PARAM;
+
+#endif

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/CMakeLists.txt	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/CMakeLists.txt	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,20 @@
+INCLUDE(vf_plugin)
+
+
+SET(chromashiftCommon_SRCS 
+ADM_vidChromaShift.cpp
+DIA_flyChromaShift.cpp
+)
+
+INCLUDE(vf_plugin_gtk)
+INCLUDE(vf_plugin_qt4)
+
+SET(chromashiftGtk_SRCS gtk/DIA_chromaShift.cpp)
+SET(chromashiftQT_SRCS Q_chromashift.cpp)
+SET(chromashiftQT_UI chromashift)
+
+INIT_VIDEOFILTER_PLUGIN_QT4(ADM_vf_chromaShift_qt4 
+                ${chromashiftQT_SRCS} ${chromashiftQT_UI} ${chromashiftCommon_SRCS})
+INIT_VIDEOFILTER_PLUGIN_GTK(  ADM_vf__chromaShift_gtk 
+                ${chromashiftGtk_SRCS} ${chromashiftCommon_SRCS})
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/DIA_flyChromaShift.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/DIA_flyChromaShift.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,55 @@
+/***************************************************************************
+                          ADM_guiChromaShift.cpp  -  description
+                             -------------------
+    begin                : Sun Aug 24 2003
+    copyright            : (C) 2002-2003 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;math.h&gt;
+#include &quot;ADM_default.h&quot;
+
+#include &quot;ADM_image.h&quot;
+#include &quot;ADM_videoFilter.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidChromaShift.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidChromaShift_param.h&quot;
+#include &quot;DIA_flyDialog.h&quot;
+#include &quot;DIA_flyChromaShift.h&quot;
+
+/*********  COMMON PART *********/
+uint8_t    flyChromaShift::process(void)
+{
+        // First copy Y
+        memcpy(_yuvBufferOut-&gt;data,_yuvBuffer-&gt;data,(_w*_h));
+        // then shift u
+
+         ADMVideoChromaShift::shift(_yuvBufferOut-&gt;data+_w*_h,
+                                    _yuvBuffer-&gt;data+_w*_h, _w&gt;&gt;1,_h&gt;&gt;1,param.u);
+        ADMVideoChromaShift::shift(_yuvBufferOut-&gt;data+((5*_w*_h)&gt;&gt;2),
+                                    _yuvBuffer-&gt;data+((5*_w*_h)&gt;&gt;2), _w&gt;&gt;1,_h&gt;&gt;1,param.v);
+        if(param.u)
+                ADMVideoChromaShift::fixup(_yuvBufferOut-&gt;data,_w,_h,param.u*2);
+        if(param.v)
+                ADMVideoChromaShift::fixup(_yuvBufferOut-&gt;data,_w,_h,param.v*2);
+
+}
+uint8_t    flyChromaShift::update(void)
+{
+   download();
+    process();
+	copyYuvFinalToRgb();
+    display();
+}
+//EOF
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/DIA_flyChromaShift.h (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyChromaShift.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/DIA_flyChromaShift.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,18 @@
+#ifndef FLY_CHROMASHIFT_H
+#define FLY_CHROMASHIFT_H
+class flyChromaShift : public ADM_flyDialog
+{
+  
+  public:
+   CHROMASHIFT_PARAM  param;
+  public:
+   uint8_t    process(void);
+   uint8_t    download(void);
+   uint8_t    upload(void);
+   uint8_t    update(void);
+   flyChromaShift (uint32_t width,uint32_t height,AVDMGenericVideoStream *in,
+                                    void *canvas, void *slider) : ADM_flyDialog(width, height,in,canvas, slider,1,RESIZE_AUTO) {};
+};
+
+#endif
+//EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/gtk/DIA_chromaShift.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_chromaShift.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_chromaShift.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/gtk/DIA_chromaShift.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,284 @@
+/***************************************************************************
+                          ADM_guiChromaShift.cpp  -  description
+                             -------------------
+    begin                : Sun Aug 24 2003
+    copyright            : (C) 2002-2003 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_toolkitGtk.h&quot;
+
+
+#include &quot;ADM_image.h&quot;
+#include &quot;ADM_videoFilter.h&quot;
+
+#include &quot;ADM_assert.h&quot;
+#include &quot;DIA_flyDialog.h&quot;
+#include &quot;../ADM_vidChromaShift_param.h&quot;
+#include &quot;DIA_flyChromaShift.h&quot;
+
+static int lock=0;
+
+static GtkWidget *dialog;
+static GtkWidget *create_ChromaShift( void );
+
+
+static void read( void );
+static void upload ( void );
+static gboolean gui_draw( void );
+static gboolean gui_update( void );
+static gboolean slider_update( void );
+static void update(void);
+
+static flyChromaShift *myCrop=NULL;
+
+//**************************************
+
+uint8_t DIA_getChromaShift( AVDMGenericVideoStream *instream,CHROMASHIFT_PARAM    *param );
+uint8_t DIA_getChromaShift( AVDMGenericVideoStream *in,CHROMASHIFT_PARAM    *param )
+{
+uint8_t ret=0;
+  
+        uint32_t width,height;
+
+        // Allocate space for green-ised video
+        width=in-&gt;getInfo()-&gt;width;
+        height=in-&gt;getInfo()-&gt;height;
+
+        dialog=create_ChromaShift();
+        gtk_register_dialog(dialog);
+        gtk_window_set_title (GTK_WINDOW (dialog), QT_TR_NOOP(&quot;Chroma Shift&quot;));
+        gtk_widget_show(dialog);
+	
+        myCrop=new flyChromaShift( width, height,in,WID(drawingarea1),WID(hscale));
+        memcpy(&amp;(myCrop-&gt;param),param,sizeof(CHROMASHIFT_PARAM));
+        myCrop-&gt;upload();
+        myCrop-&gt;sliderChanged();
+        
+        gtk_signal_connect(GTK_OBJECT(WID(drawingarea1)), &quot;expose_event&quot;,
+            GTK_SIGNAL_FUNC(gui_draw),
+            NULL);
+        
+        gtk_signal_connect (GTK_OBJECT(WID( spinbutton_U)), &quot;value_changed&quot;,
+                    GTK_SIGNAL_FUNC (gui_update),
+                    NULL);
+        gtk_signal_connect (GTK_OBJECT(WID( spinbutton_V)), &quot;value_changed&quot;,
+                    GTK_SIGNAL_FUNC (gui_update),
+                    NULL);
+        gtk_signal_connect (GTK_OBJECT(WID( spinbutton_V)), &quot;value_changed&quot;,
+                    GTK_SIGNAL_FUNC (gui_update),
+                    NULL);
+         gtk_signal_connect (GTK_OBJECT(WID( hscale)), &quot;value_changed&quot;,
+                    GTK_SIGNAL_FUNC (slider_update),
+                    NULL);
+
+          
+       
+        ret=0;
+        int response;
+        response=gtk_dialog_run(GTK_DIALOG(dialog));
+
+        if(response==GTK_RESPONSE_OK)
+        {
+            myCrop-&gt;download();
+            memcpy(param,&amp;(myCrop-&gt;param),sizeof(CHROMASHIFT_PARAM));
+            ret=1;
+        }
+        gtk_unregister_dialog(dialog);
+        gtk_widget_destroy(dialog);
+        delete myCrop;
+        return ret;
+}
+      
+/**********************************/
+void read( void )
+{
+	myCrop-&gt;download();
+}
+void upload ( void )
+{
+	myCrop-&gt;upload();
+}
+gboolean slider_update( void )
+{
+        myCrop-&gt;sliderChanged();
+        return true;
+}
+gboolean gui_update( void)
+{
+  if(lock) return true;
+      myCrop-&gt;update();
+  return true;
+}
+gboolean gui_draw( void )
+{
+	myCrop-&gt;display();
+	return true;
+}
+
+/******************************/
+#define SPIN_GET(x,y) {y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(lookup_widget(dialog,#x))) ;\
+				printf(#x&quot;:%d\n&quot;, y);}
+
+#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(lookup_widget(dialog,#x)),(gfloat)y) ; printf(#x&quot;:%d\n&quot;, y);}
+
+
+uint8_t    flyChromaShift::upload(void)
+{
+        SPIN_SET(spinbutton_U,param.u);
+        SPIN_SET(spinbutton_V,param.v);
+  return 1;
+}
+uint8_t    flyChromaShift::download(void)
+{
+        SPIN_GET(spinbutton_U,param.u);
+        SPIN_GET(spinbutton_V,param.v);
+  
+  return 1;
+}
+
+
+/*----------------------------------------------------------------*/
+
+GtkWidget*
+create_ChromaShift (void)
+{
+  GtkWidget *ChromaShift;
+  GtkWidget *dialog_vbox1;
+  GtkWidget *vbox1;
+  GtkWidget *table1;
+  GtkWidget *label1;
+  GtkWidget *label2;
+  GtkObject *spinbutton_U_adj;
+  GtkWidget *spinbutton_U;
+  GtkObject *spinbutton_V_adj;
+  GtkWidget *spinbutton_V;
+  GtkWidget *hscale;
+  GtkWidget *frame1;
+  GtkWidget *alignment1;
+  GtkWidget *drawingarea1;
+  GtkWidget *label3;
+  GtkWidget *dialog_action_area1;
+  GtkWidget *cancelbutton1;
+  GtkWidget *applybutton1;
+  GtkWidget *okbutton1;
+
+  ChromaShift = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (ChromaShift), QT_TR_NOOP(&quot;ChromaShift&quot;));
+  gtk_window_set_type_hint (GTK_WINDOW (ChromaShift), GDK_WINDOW_TYPE_HINT_DIALOG);
+
+  dialog_vbox1 = GTK_DIALOG (ChromaShift)-&gt;vbox;
+  gtk_widget_show (dialog_vbox1);
+
+  vbox1 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
+
+  table1 = gtk_table_new (2, 2, FALSE);
+  gtk_widget_show (table1);
+  gtk_box_pack_start (GTK_BOX (vbox1), table1, FALSE, FALSE, 0);
+
+  label1 = gtk_label_new (QT_TR_NOOP(&quot;U Shift :&quot;));
+  gtk_widget_show (label1);
+  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
+
+  label2 = gtk_label_new (QT_TR_NOOP(&quot;V Shift :&quot;));
+  gtk_widget_show (label2);
+  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
+
+  spinbutton_U_adj = gtk_adjustment_new (0, -32, 32, 1, 10, 10);
+  spinbutton_U = gtk_spin_button_new (GTK_ADJUSTMENT (spinbutton_U_adj), 1, 0);
+  gtk_widget_show (spinbutton_U);
+  gtk_table_attach (GTK_TABLE (table1), spinbutton_U, 1, 2, 0, 1,
+                    (GtkAttachOptions) (0),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbutton_U), TRUE);
+
+  spinbutton_V_adj = gtk_adjustment_new (0, -32, 32, 1, 10, 10);
+  spinbutton_V = gtk_spin_button_new (GTK_ADJUSTMENT (spinbutton_V_adj), 1, 0);
+  gtk_widget_show (spinbutton_V);
+  gtk_table_attach (GTK_TABLE (table1), spinbutton_V, 1, 2, 1, 2,
+                    (GtkAttachOptions) (0),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbutton_V), TRUE);
+
+  hscale = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 100, 1, 1, 1)));
+  gtk_widget_show (hscale);
+  gtk_box_pack_start (GTK_BOX (vbox1), hscale, FALSE, FALSE, 0);
+  gtk_scale_set_digits (GTK_SCALE (hscale), 0);
+
+  frame1 = gtk_frame_new (NULL);
+  gtk_widget_show (frame1);
+  gtk_box_pack_start (GTK_BOX (vbox1), frame1, TRUE, TRUE, 0);
+  gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_NONE);
+
+  alignment1 = gtk_alignment_new (0.5, 0.5, 1, 1);
+  gtk_widget_show (alignment1);
+  gtk_container_add (GTK_CONTAINER (frame1), alignment1);
+  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment1), 0, 0, 12, 0);
+
+  drawingarea1 = gtk_drawing_area_new ();
+  gtk_widget_show (drawingarea1);
+  gtk_container_add (GTK_CONTAINER (alignment1), drawingarea1);
+
+  label3 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Preview&lt;/b&gt;&quot;));
+  gtk_widget_show (label3);
+  gtk_frame_set_label_widget (GTK_FRAME (frame1), label3);
+  gtk_label_set_use_markup (GTK_LABEL (label3), TRUE);
+
+  dialog_action_area1 = GTK_DIALOG (ChromaShift)-&gt;action_area;
+  gtk_widget_show (dialog_action_area1);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
+
+  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
+  gtk_widget_show (cancelbutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (ChromaShift), cancelbutton1, GTK_RESPONSE_CANCEL);
+  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
+
+  applybutton1 = gtk_button_new_from_stock (&quot;gtk-apply&quot;);
+  gtk_widget_show (applybutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (ChromaShift), applybutton1, GTK_RESPONSE_APPLY);
+  GTK_WIDGET_SET_FLAGS (applybutton1, GTK_CAN_DEFAULT);
+
+  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
+  gtk_widget_show (okbutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (ChromaShift), okbutton1, GTK_RESPONSE_OK);
+  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (ChromaShift, ChromaShift, &quot;ChromaShift&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (ChromaShift, dialog_vbox1, &quot;dialog_vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, vbox1, &quot;vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, table1, &quot;table1&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, label1, &quot;label1&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, label2, &quot;label2&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, spinbutton_U, &quot;spinbutton_U&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, spinbutton_V, &quot;spinbutton_V&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, hscale, &quot;hscale&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, frame1, &quot;frame1&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, alignment1, &quot;alignment1&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, drawingarea1, &quot;drawingarea1&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, label3, &quot;label3&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (ChromaShift, dialog_action_area1, &quot;dialog_action_area1&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, cancelbutton1, &quot;cancelbutton1&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, applybutton1, &quot;applybutton1&quot;);
+  GLADE_HOOKUP_OBJECT (ChromaShift, okbutton1, &quot;okbutton1&quot;);
+
+  return ChromaShift;
+}
+
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/qt4/Q_chromashift.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_chromashift.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_chromashift.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/qt4/Q_chromashift.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,118 @@
+/***************************************************************************
+                          DIA_crop.cpp  -  description
+                             -------------------
+
+			    GUI for cropping including autocrop
+			    +Revisted the Gtk2 way
+			     +Autocrop now in RGB space (more accurate)
+
+    begin                : Fri May 3 2002
+    copyright            : (C) 2002/2007 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;Q_chromashift.h&quot;
+
+Ui_chromaShiftWindow::Ui_chromaShiftWindow(CHROMASHIFT_PARAM *param,AVDMGenericVideoStream *in)
+  {
+    uint32_t width,height;
+        ui.setupUi(this);
+        lock=0;
+        
+        // Allocate space for green-ised video
+        width=in-&gt;getInfo()-&gt;width;
+        height=in-&gt;getInfo()-&gt;height;
+        
+        int boundary=width/2;
+        
+        ui.spinBoxU-&gt;setMaximum(boundary/2);
+        ui.spinBoxU-&gt;setMinimum(-boundary);
+        ui.spinBoxV-&gt;setMaximum(boundary/2);
+        ui.spinBoxV-&gt;setMinimum(-boundary);
+        
+        canvas=new ADM_QCanvas(ui.graphicsView,width,height);
+        
+        myCrop=new flyChromaShift( width, height,in,canvas,ui.horizontalSlider);
+        memcpy(&amp;(myCrop-&gt;param),param,sizeof(CHROMASHIFT_PARAM));
+        myCrop-&gt;_cookie=&ui;
+        myCrop-&gt;upload();
+        myCrop-&gt;sliderChanged();
+
+
+        connect( ui.horizontalSlider,SIGNAL(valueChanged(int)),this,SLOT(sliderUpdate(int)));
+#define SPINNER(x) connect( ui.spinBox##x,SIGNAL(valueChanged(int)),this,SLOT(valueChanged(int))); 
+          SPINNER(U);
+          SPINNER(V);
+  }
+  void Ui_chromaShiftWindow::sliderUpdate(int foo)
+  {
+    myCrop-&gt;sliderChanged();
+  }
+  void Ui_chromaShiftWindow::gather(CHROMASHIFT_PARAM *param)
+  {
+    
+        myCrop-&gt;download();
+        memcpy(param,&amp;(myCrop-&gt;param),sizeof(CHROMASHIFT_PARAM));
+  }
+Ui_chromaShiftWindow::~Ui_chromaShiftWindow()
+{
+  if(myCrop) delete myCrop;
+  myCrop=NULL; 
+  if(canvas) delete canvas;
+  canvas=NULL;
+}
+void Ui_chromaShiftWindow::valueChanged( int f )
+{
+  if(lock) return;
+  lock++;
+  myCrop-&gt;update();
+  lock--;
+}
+
+#define MYSPIN(x) w-&gt;spinBox##x
+//************************
+uint8_t flyChromaShift::upload(void)
+{
+      Ui_chromashiftDialog *w=(Ui_chromashiftDialog *)_cookie;
+
+        MYSPIN(U)-&gt;setValue(param.u);
+        MYSPIN(V)-&gt;setValue(param.v);
+        return 1;
+}
+uint8_t flyChromaShift::download(void)
+{
+       Ui_chromashiftDialog *w=(Ui_chromashiftDialog *)_cookie;
+       param.u= MYSPIN(U)-&gt;value();
+       param.v= MYSPIN(V)-&gt;value();
+       
+}
+
+/**
+      \fn     DIA_getChromaShift
+      \brief  Handle crop dialog
+*/
+uint8_t DIA_getChromaShift( AVDMGenericVideoStream *in,CHROMASHIFT_PARAM    *param )
+{
+        uint8_t ret=0;
+        
+        Ui_chromaShiftWindow dialog(param,in);        
+        if(dialog.exec()==QDialog::Accepted)
+        {
+            dialog.gather(param); 
+            ret=1;
+        }
+        return ret;
+}
+//____________________________________
+// EOF
+
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/qt4/chromashift.ui (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/chromashift.ui)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/chromashift.ui	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ChromaShift/qt4/chromashift.ui	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,153 @@
+&lt;ui version=&quot;4.0&quot; &gt;
+ &lt;class&gt;chromashiftDialog&lt;/class&gt;
+ &lt;widget class=&quot;QDialog&quot; name=&quot;chromashiftDialog&quot; &gt;
+  &lt;property name=&quot;geometry&quot; &gt;
+   &lt;rect&gt;
+    &lt;x&gt;0&lt;/x&gt;
+    &lt;y&gt;0&lt;/y&gt;
+    &lt;width&gt;422&lt;/width&gt;
+    &lt;height&gt;585&lt;/height&gt;
+   &lt;/rect&gt;
+  &lt;/property&gt;
+  &lt;property name=&quot;windowTitle&quot; &gt;
+   &lt;string&gt;ChromaShift&lt;/string&gt;
+  &lt;/property&gt;
+  &lt;layout class=&quot;QGridLayout&quot; &gt;
+   &lt;property name=&quot;leftMargin&quot; &gt;
+    &lt;number&gt;9&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;topMargin&quot; &gt;
+    &lt;number&gt;9&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;rightMargin&quot; &gt;
+    &lt;number&gt;9&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;bottomMargin&quot; &gt;
+    &lt;number&gt;9&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;horizontalSpacing&quot; &gt;
+    &lt;number&gt;6&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;verticalSpacing&quot; &gt;
+    &lt;number&gt;6&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;item row=&quot;1&quot; column=&quot;0&quot; &gt;
+    &lt;widget class=&quot;QLabel&quot; name=&quot;label_2&quot; &gt;
+     &lt;property name=&quot;text&quot; &gt;
+      &lt;string&gt;V Shift&lt;/string&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+   &lt;item row=&quot;0&quot; column=&quot;0&quot; &gt;
+    &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot; &gt;
+     &lt;property name=&quot;text&quot; &gt;
+      &lt;string&gt;U Shift&lt;/string&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+   &lt;item row=&quot;4&quot; column=&quot;3&quot; &gt;
+    &lt;spacer&gt;
+     &lt;property name=&quot;orientation&quot; &gt;
+      &lt;enum&gt;Qt::Vertical&lt;/enum&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;sizeType&quot; &gt;
+      &lt;enum&gt;QSizePolicy::Maximum&lt;/enum&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;sizeHint&quot; &gt;
+      &lt;size&gt;
+       &lt;width&gt;20&lt;/width&gt;
+       &lt;height&gt;16&lt;/height&gt;
+      &lt;/size&gt;
+     &lt;/property&gt;
+    &lt;/spacer&gt;
+   &lt;/item&gt;
+   &lt;item row=&quot;5&quot; column=&quot;0&quot; colspan=&quot;4&quot; &gt;
+    &lt;widget class=&quot;QDialogButtonBox&quot; name=&quot;buttonBox&quot; &gt;
+     &lt;property name=&quot;orientation&quot; &gt;
+      &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;standardButtons&quot; &gt;
+      &lt;set&gt;QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok&lt;/set&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+   &lt;item row=&quot;2&quot; column=&quot;0&quot; colspan=&quot;4&quot; &gt;
+    &lt;widget class=&quot;QSlider&quot; name=&quot;horizontalSlider&quot; &gt;
+     &lt;property name=&quot;orientation&quot; &gt;
+      &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+   &lt;item row=&quot;3&quot; column=&quot;0&quot; colspan=&quot;4&quot; &gt;
+    &lt;widget class=&quot;QGraphicsView&quot; name=&quot;graphicsView&quot; /&gt;
+   &lt;/item&gt;
+   &lt;item row=&quot;1&quot; column=&quot;1&quot; &gt;
+    &lt;widget class=&quot;QSpinBox&quot; name=&quot;spinBoxV&quot; /&gt;
+   &lt;/item&gt;
+   &lt;item row=&quot;0&quot; column=&quot;1&quot; &gt;
+    &lt;widget class=&quot;QSpinBox&quot; name=&quot;spinBoxU&quot; /&gt;
+   &lt;/item&gt;
+   &lt;item row=&quot;0&quot; column=&quot;2&quot; &gt;
+    &lt;spacer&gt;
+     &lt;property name=&quot;orientation&quot; &gt;
+      &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;sizeHint&quot; &gt;
+      &lt;size&gt;
+       &lt;width&gt;40&lt;/width&gt;
+       &lt;height&gt;20&lt;/height&gt;
+      &lt;/size&gt;
+     &lt;/property&gt;
+    &lt;/spacer&gt;
+   &lt;/item&gt;
+   &lt;item row=&quot;1&quot; column=&quot;2&quot; &gt;
+    &lt;spacer&gt;
+     &lt;property name=&quot;orientation&quot; &gt;
+      &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;sizeHint&quot; &gt;
+      &lt;size&gt;
+       &lt;width&gt;40&lt;/width&gt;
+       &lt;height&gt;20&lt;/height&gt;
+      &lt;/size&gt;
+     &lt;/property&gt;
+    &lt;/spacer&gt;
+   &lt;/item&gt;
+  &lt;/layout&gt;
+ &lt;/widget&gt;
+ &lt;resources/&gt;
+ &lt;connections&gt;
+  &lt;connection&gt;
+   &lt;sender&gt;buttonBox&lt;/sender&gt;
+   &lt;signal&gt;accepted()&lt;/signal&gt;
+   &lt;receiver&gt;chromashiftDialog&lt;/receiver&gt;
+   &lt;slot&gt;accept()&lt;/slot&gt;
+   &lt;hints&gt;
+    &lt;hint type=&quot;sourcelabel&quot; &gt;
+     &lt;x&gt;248&lt;/x&gt;
+     &lt;y&gt;254&lt;/y&gt;
+    &lt;/hint&gt;
+    &lt;hint type=&quot;destinationlabel&quot; &gt;
+     &lt;x&gt;157&lt;/x&gt;
+     &lt;y&gt;274&lt;/y&gt;
+    &lt;/hint&gt;
+   &lt;/hints&gt;
+  &lt;/connection&gt;
+  &lt;connection&gt;
+   &lt;sender&gt;buttonBox&lt;/sender&gt;
+   &lt;signal&gt;rejected()&lt;/signal&gt;
+   &lt;receiver&gt;chromashiftDialog&lt;/receiver&gt;
+   &lt;slot&gt;reject()&lt;/slot&gt;
+   &lt;hints&gt;
+    &lt;hint type=&quot;sourcelabel&quot; &gt;
+     &lt;x&gt;316&lt;/x&gt;
+     &lt;y&gt;260&lt;/y&gt;
+    &lt;/hint&gt;
+    &lt;hint type=&quot;destinationlabel&quot; &gt;
+     &lt;x&gt;286&lt;/x&gt;
+     &lt;y&gt;274&lt;/y&gt;
+    &lt;/hint&gt;
+   &lt;/hints&gt;
+  &lt;/connection&gt;
+ &lt;/connections&gt;
+&lt;/ui&gt;

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Clean/ADM_vidClean.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Clean/ADM_vidClean.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,199 @@
+/***************************************************************************
+                          ADM_vidClean.cpp  -  description
+                             -------------------
+    begin                : Sun Apr 14 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+
+
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_videoFilter.h&quot;
+#include &quot;ADM_video/ADM_vidClean.h&quot;
+
+
+
+static FILTER_PARAM smoothParam={2,{&quot;radius&quot;,&quot;blend&quot;}};
+
+
+SCRIPT_CREATE(smooth_script,AVDMVideoSmooth,smoothParam);
+
+ char *AVDMVideoSmooth::printConf(void)
+{
+static char str[40];
+		sprintf(str,&quot;Smooth-Clean : R = %02lu, Blend=%01lu&quot;,_param-&gt;radius*2,_param-&gt;blend);
+ 		return str; // this one is pure
+}
+BUILD_CREATE(smooth_create,AVDMVideoSmooth);
+
+//_______________________________________________________________
+
+AVDMVideoSmooth::AVDMVideoSmooth(
+									AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+
+  	_in=in;		
+   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  		
+	if(couples)
+	{
+ 		_param=NEW( SMOOTH_PARAMS);
+		GET(radius);
+		GET(blend);
+	}
+    else
+    	{
+         	_param=NEW( SMOOTH_PARAMS);
+         	_param-&gt;radius=3;
+              	_param-&gt;blend=1;
+        }
+
+					
+  
+  _uncompressed=new ADMImage (_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+  ADM_assert(_uncompressed);
+  _info.encoding=1;
+
+  	  	
+}
+
+uint8_t	AVDMVideoSmooth::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(2);
+
+	CSET(radius);
+	CSET(blend);
+			return 1;
+
+}
+AVDMVideoSmooth::~AVDMVideoSmooth()
+{
+ 	delete _uncompressed;
+ 	DELETE(_param);
+	_uncompressed=NULL;
+}
+
+uint8_t AVDMVideoSmooth::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+uint8_t *dst,*dstu,*dstv,*src,*srcu,*srcv;
+
+            	int16_t l,u=0,v=0;
+             	int16_t nb;
+              int16_t fl,fu,fv;
+              int16_t	ldelta,udelta,vdelta;
+              int16_t   threshold=10,su=0,sv=0;
+
+			if(frame&gt;=_info.nb_frames) return 0;
+			ADM_assert(_uncompressed);					
+								
+		// read uncompressed frame
+       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+
+         	src=YPLANE(_uncompressed);
+           	srcu=UPLANE(_uncompressed);;
+           	srcv=VPLANE(_uncompressed);;
+
+              dst=YPLANE(data);
+              dstu=UPLANE(data);
+              dstv=VPLANE(data);
+
+              int16_t radius=_param-&gt;radius;
+
+         		for(int32_t y=0;y&lt;(int32_t)(_info.height );y++)
+           	{
+		         		for(int32_t x=0;x&lt;(int32_t)(_info.width );x++)
+             			{
+                      	// for each pixel we take the surrounding one
+                       	// if threshold is not met
+                        		l=getPixel(x,y,_uncompressed-&gt;data);
+                          	if(!(x&amp;1))
+                           	{
+                          		u=getPixelU(x,y,srcu);
+                          		v=getPixelU(x,y,srcv);
+                            }
+                            nb=0;
+                            fl=0;fu=0;fv=0;
+
+
+                             //------------------------                        	                        		
+                   	    	for(int16_t yy=-radius+1;yy&lt;radius;yy++)
+                         	{                       			
+
+                        	    	for(int16_t xx=-radius+1;xx&lt;radius;xx++)
+                              		{
+                                  		if( (xx*xx+yy*yy)&lt;radius*radius)
+                                    	{
+                                   		ldelta =getPixel(x+xx,y+yy,_uncompressed-&gt;data)-l;
+  		                            		udelta=getPixelU(x+xx,y+yy,srcu)-u;
+                                     		vdelta=getPixelU(x+xx,y+yy,srcv)-v;                                       	
+
+
+                                         	if((udelta*udelta&lt;threshold*threshold)&amp;&amp;
+                                          	(vdelta*vdelta&lt;threshold*threshold) &amp;&amp;
+                                           	(ldelta*ldelta&lt;threshold*threshold))
+                                          		{
+                                                  	nb++;
+                                                   	fl=fl+ldelta+l;
+                                                    fu=fu+udelta+u;
+															fv=fv+vdelta+v;
+                                              	}
+                                        }
+                                 	 }
+                                  }
+                                  //----------------------------------
+                                  //
+                                  // average value
+                                  	fl=fl/nb;
+                                 	fu=fu/nb;
+                                  	fv=fv/nb;
+                                   // now melt it
+                                  	// 50/50
+                                 /*  fl=(fl+l)&gt;&gt;1;
+                                   fu=(fu+u)&gt;&gt;1;
+                                   fv=(fv+v)&gt;&gt;1;*/
+
+                                 	*dst++=fl;
+                                  if(y&amp;1)       	
+                                  if(x&amp;1)				
+                                  	{
+                        			setPixelU(  (su+fu)&gt;&gt;1,x,y,dstu);
+                           			setPixelU(  (sv+fv)&gt;&gt;1,x,y,dstv);  
+					}
+                                	else
+                                 	{
+                                     	su=fu;
+                                      	sv=fv;
+                                    }
+
+                  	}          // end for x
+           		
+              }     // end for y
+	        data-&gt;copyInfo(_uncompressed);
+              return 1;
+}
+uint8_t AVDMVideoSmooth::configure( AVDMGenericVideoStream *instream)
+{
+UNUSED_ARG(instream);
+
+SMOOTH_PARAMS *par;
+	
+//     	par=_param;
+     	//return((uint8_t)getSmoothParams(&amp;par-&gt;radius,&amp;par-&gt;blend));
+	return 1;
+#warning FIXME , CODE REMOVED AMD64/GCC4
+}

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Clean/ADM_vidClean.h (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidClean.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Clean/ADM_vidClean.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,42 @@
+/***************************************************************************
+                          ADM_vidClean.h  -  description
+                             -------------------
+    begin                : Sun Apr 14 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ typedef struct
+ {
+	   	uint32_t radius,blend;
+   }SMOOTH_PARAMS;
+
+
+    class  AVDMVideoSmooth:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+    			uint8_t						*_unpack;
+           virtual 	char 							*printConf(void);
+    			SMOOTH_PARAMS				*_param;
+ public:
+
+  					AVDMVideoSmooth(  AVDMGenericVideoStream *in,CONFcouple *setup);
+  			virtual 	~AVDMVideoSmooth();
+		        virtual 	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          									ADMImage *data,uint32_t *flags);
+					uint8_t 	configure( AVDMGenericVideoStream *instream) ;
+			 virtual 	uint8_t	getCoupledConf( CONFcouple **couples)		;
+
+ }     ;
+
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/ADM_vidEqualizer.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/ADM_vidEqualizer.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,128 @@
+
+/***************************************************************************
+                        Simple equalizer or linear luma/chroma filter
+    
+
+   (C) 2004/2005 Mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+   GPL version 2
+
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+#include &lt;math.h&gt;
+
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;ADM_vidEqualizer.h&quot;
+
+
+static FILTER_PARAM equalizer_template={8,{&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;
+					,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;}};
+//REGISTERX(VF_COLORS, &quot;equalizer&quot;,QT_TR_NOOP(&quot;Luma equalizer&quot;),
+//QT_TR_NOOP(&quot;Luma correction filter with histogram.&quot;),VF_EQUALIZER,1,equalizer_create,equalizer_script);
+VF_DEFINE_FILTER(vidEqualizer,equalizer_template,
+                equalizer,
+                QT_TR_NOOP(&quot;Luma equalizer&quot;),
+                1,
+                VF_COLORS,
+                QT_TR_NOOP(&quot;Luma correction filter with histogram.&quot;));
+
+
+extern uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *incoming);
+
+uint8_t vidEqualizer::configure(AVDMGenericVideoStream *in)
+{
+ADMImage *video1;
+uint32_t l,f;
+uint8_t r;
+
+	_in=in;		
+	r= DIA_getEqualizer(_param,in);
+	return r;
+	
+}
+
+char *vidEqualizer::printConf( void )
+{
+ 	static char buf[50];
+ 	sprintf((char *)buf,&quot; Equalizer&quot;);
+        return buf;
+}
+
+vidEqualizer::vidEqualizer(AVDMGenericVideoStream *in,CONFcouple *couples) 
+{
+		_in=in;		
+   		memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+  		_info.encoding=1;
+		_uncompressed=NULL;
+		
+  		_info.encoding=1;
+		_uncompressed=new ADMImage(_info.width,_info.height);
+		
+		
+		_param=NEW(EqualizerParam);
+		if(couples)
+		{
+		        char dummy[10];
+                        for(int i=0;i&lt;256;i++)  
+                        {
+                                sprintf(dummy,&quot;x%03d&quot;,i);
+                                couples-&gt;getCouple((char *)dummy,&amp;(_param-&gt;_scaler[i]));
+                        }
+		}
+		else // Default
+  		{
+                                for(int i=0;i&lt;256;i++)
+                                        _param-&gt;_scaler[i]=i;
+		}
+}
+//____________________________________________________________________
+vidEqualizer::~vidEqualizer()
+{
+		
+	delete _uncompressed;
+	delete _param;
+	_param=NULL;
+	_uncompressed=NULL;
+		
+		
+}
+
+//______________________________________________________________
+uint8_t vidEqualizer::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+
+        if(frame&gt;= _info.nb_frames) return 0;
+	if(!_in-&gt;getFrameNumberNoAlloc(frame,len,_uncompressed,flags)) return 0;
+	
+	uint8_t *src,*dst;
+	src=_uncompressed-&gt;data;
+	dst=data-&gt;data;
+	for(uint32_t y=_info.height;y&gt;0;y--)
+	for(uint32_t x=_info.width;x&gt;0;x--)
+		*(dst++)=_param-&gt;_scaler[*(src++)];
+
+	uint32_t square=_info.width*_info.height;
+	square&gt;&gt;=2;
+	// copy u &amp; v too
+	memcpy(data-&gt;data+4*square,_uncompressed-&gt;data+4*square,2*square);
+	return 1;
+}
+
+
+uint8_t	vidEqualizer::getCoupledConf( CONFcouple **couples)
+{
+char dummy[10];
+			ADM_assert(_param);
+			*couples=new CONFcouple(256);
+
+        for(int i=0;i&lt;256;i++)  
+        {
+                sprintf(dummy,&quot;x%03d&quot;,i);
+                (*couples)-&gt;setCouple(dummy,(_param-&gt;_scaler[i]));
+        }
+	return 1;
+}
+
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/ADM_vidEqualizer.h (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidEqualizer.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/ADM_vidEqualizer.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,40 @@
+//
+// C++ Interface: %{MODULE}
+//
+// Description: 
+//
+//
+// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+typedef struct EqualizerParam
+{
+	uint32_t _scaler[256];
+}EqualizerParam;
+
+ class  vidEqualizer:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+
+           virtual char 	*printConf(void);
+			EqualizerParam *_param;	
+			
+
+ public:
+ 		
+  					vidEqualizer(  AVDMGenericVideoStream *in,CONFcouple *setup);	
+  			virtual 	~vidEqualizer();
+			virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+			  		ADMImage *data,uint32_t *flags);
+				uint8_t configure( AVDMGenericVideoStream *instream);
+			virtual uint8_t	getCoupledConf( CONFcouple **couples);
+							
+ }     ;
+ 
+ uint8_t equalizerBuildScaler(int32_t *p,uint32_t *s);
+ 
+//EOF

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/CMakeLists.txt	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/CMakeLists.txt	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,14 @@
+INCLUDE(vf_plugin)
+
+
+SET(equalizerCommon_SRCS 
+ADM_vidEqualizer.cpp
+)
+
+INCLUDE(vf_plugin_gtk)
+
+SET(equalizerGtk_SRCS gtk/DIA_equalizer.cpp)
+
+INIT_VIDEOFILTER_PLUGIN_GTK(  ADM_vf_equalizer_gtk 
+                ${equalizerGtk_SRCS} ${equalizerCommon_SRCS})
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/gtk/DIA_equalizer.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_equalizer.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_equalizer.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Equalizer/gtk/DIA_equalizer.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,527 @@
+
+//
+/***************************************************************************
+                          DIA_Equalizer
+                             -------------------
+
+			   Ui for equalizer, ugly
+
+    begin                : 30 Dec 2004
+    copyright            : (C) 2004/5 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &lt;math.h&gt;
+
+#include &quot;ADM_toolkitGtk.h&quot;
+
+#include &quot;ADM_image.h&quot;
+#include &quot;ADM_videoFilter.h&quot;
+#include &quot;ADM_vidEqualizer.h&quot;
+#include &quot;ADM_colorspace.h&quot;
+extern &quot;C&quot; {
+#include &quot;../../../ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h&quot;
+}
+
+static ColYuvRgb    *rgbConv=NULL;
+uint8_t DIA_getEqualizer(EqualizerParam *param, ADMImage *image);
+
+static GtkWidget	*create_dialog1 (void);
+static void  		update ( void);
+static gboolean 	draw (void );
+// static void 		reset( void );
+static void 		upload(void);
+static void  		read ( void );
+static void		recalc( void );
+static void 		drawCross(uint32_t x,uint32_t y);
+static void 		spinner(void);
+static void 		compute_histogram(void);
+static void 		frame_changed( void );
+
+extern void GUI_RGBDisplay(uint8_t * dis, uint32_t w, uint32_t h, void *widg);
+extern float UI_calcZoomToFitScreen(GtkWindow* window, GtkWidget* drawingArea, uint32_t imageWidth, uint32_t imageHeight);
+extern void UI_centreCanvasWindow(GtkWindow *window, GtkWidget *canvas, int newCanvasWidth, int newCanvasHeight);
+
+static ADMImage *imgsrc,*imgdst,*imgdisplay;
+static GtkWidget *dialog=NULL;
+static uint32_t scaler[256];
+static uint32_t w,h,zoomW,zoomH;
+static uint32_t *rgbbuffer=NULL;
+static ADMImageResizer *resizer=NULL;
+
+static uint32_t *histogram=NULL;
+static uint32_t *histogramout=NULL;
+static AVDMGenericVideoStream *incoming;
+static const int cross[8]= {0,36,73,109,
+			146,182,219,255};
+#define CROSS 0xFFFF0000
+#define DRAW  0x0000FF00
+#define LINER 0x0000FFFF
+
+#define ZOOM_FACTOR 5
+
+#define A_RESET 99
+//
+//	Video is in YV12 Colorspace
+//
+//
+uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *in)
+{
+	int ret;
+	uint32_t l,f;
+	uint32_t max=in-&gt;getInfo()-&gt;nb_frames;
+        
+	incoming=in;
+	// Allocate space for green-ised video
+	w=in-&gt;getInfo()-&gt;width;
+	h=in-&gt;getInfo()-&gt;height;
+	rgbConv=new ColYuvRgb(w,h);
+        rgbConv-&gt;reset(w,h);
+	
+	histogram=new uint32_t [256*128];
+        histogramout=new uint32_t [256*128];
+	
+	imgdst=new ADMImage(w,h);
+	imgsrc=new ADMImage(w,h);
+        imgdisplay=new ADMImage(w,h);
+	
+        //if(curframe&lt;max) max=curframe;
+        
+	ADM_assert(in-&gt;getFrameNumberNoAlloc(max, &amp;l, imgsrc,&amp;f));
+        memcpy(imgdisplay-&gt;data+w*h,imgsrc-&gt;data+w*h,(w*h)&gt;&gt;1);
+	// init local equalizer
+		
+        memcpy(scaler,param-&gt;_scaler,sizeof(scaler));
+
+	dialog=create_dialog1();
+	gtk_register_dialog(dialog);
+	gtk_widget_set_usize(WID(drawingarea_histin), 256,128);
+    gtk_widget_set_usize(WID(drawingarea_histout), 256,128);
+
+	float zoom = UI_calcZoomToFitScreen(GTK_WINDOW(dialog), WID(drawingarea1), w, h);
+
+	zoomW = w * zoom;
+	zoomH = h * zoom;
+	rgbbuffer=new uint32_t[zoomW*zoomH];
+
+	gtk_widget_set_usize(WID(drawingarea1), zoomW, zoomH);
+
+	if (zoom &lt; 1)
+	{
+		UI_centreCanvasWindow((GtkWindow*)dialog, WID(drawingarea1), zoomW, zoomH);
+		resizer = new ADMImageResizer(w, h, zoomW, zoomH, PIX_FMT_YUV420P, PIX_FMT_RGB32);
+	}
+
+	  gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(buttonCancel), GTK_RESPONSE_CANCEL);
+	  gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(button3),      GTK_RESPONSE_OK);
+	  gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(buttonApply),  GTK_RESPONSE_APPLY);
+        gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(buttonReset),  A_RESET);
+	  upload();
+
+	gtk_signal_connect(GTK_OBJECT(WID(drawingarea1)), &quot;expose_event&quot;,
+		       GTK_SIGNAL_FUNC(draw),
+		       NULL);
+		       
+	
+	gtk_signal_connect(GTK_OBJECT(WID(gui_scale)), &quot;value_changed&quot;,GTK_SIGNAL_FUNC(frame_changed),   NULL);
+  //      gtk_signal_connect(GTK_OBJECT(WID(curve1)), &quot;curve-type-changed&quot;,GTK_SIGNAL_FUNC(spinner),   NULL);
+	
+        /*
+
+        */
+        GtkWidget *curve=WID(curve1);
+        gtk_curve_set_range (GTK_CURVE(curve),0,255.,0.,255.);
+	
+        gtk_widget_show(dialog);
+        upload();
+        compute_histogram();
+        spinner();
+	ret=0;
+	int response;
+_again:
+	while( (response=gtk_dialog_run(GTK_DIALOG(dialog)))==GTK_RESPONSE_APPLY)
+	{
+		spinner();	
+	}
+        if(response==A_RESET)
+        {
+                gfloat duo[2]={0,255.};
+                gtk_curve_set_curve_type(GTK_CURVE(WID(curve1)),GTK_CURVE_TYPE_SPLINE);
+                gtk_curve_reset(GTK_CURVE(WID(curve1)));
+
+                goto _again;
+        }
+        
+	if(response==GTK_RESPONSE_OK)
+        {
+		printf(&quot;Accepting new values\n&quot;);
+		memcpy(param-&gt;_scaler,scaler,sizeof(scaler));
+		ret=1;
+	}
+	gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+	
+	delete imgdst;
+	delete imgsrc;
+        delete imgdisplay;
+	delete [] rgbbuffer;
+	
+	delete [] histogram;
+        delete [] histogramout;
+    delete rgbConv;
+
+	if (resizer)
+	{
+		delete resizer;
+		resizer=NULL;
+	}
+
+    rgbConv=NULL;    
+	histogram=NULL;
+        histogramout=NULL;
+	
+	rgbbuffer=NULL;
+	imgdst=NULL;
+	imgsrc=NULL;
+	dialog=NULL;
+        imgdisplay=NULL;
+	return ret;
+
+}
+void frame_changed( void )
+{
+uint32_t new_frame,max,l,f;
+double   percent;
+GtkWidget *wid;	
+GtkAdjustment *adj;
+	
+	max=incoming-&gt;getInfo()-&gt;nb_frames;
+	wid=WID(gui_scale);
+	adj=gtk_range_get_adjustment (GTK_RANGE(wid));
+	new_frame=0;
+	
+	percent=(double)GTK_ADJUSTMENT(adj)-&gt;value;
+	percent*=max;
+	percent/=100.;
+	new_frame=(uint32_t)floor(percent);
+	
+	if(new_frame&gt;=max) new_frame=max-1;
+	
+	ADM_assert(incoming-&gt;getFrameNumberNoAlloc(new_frame, &amp;l, imgsrc,&amp;f));
+         memcpy(imgdisplay-&gt;data+w*h,imgsrc-&gt;data+w*h,(w*h)&gt;&gt;1);
+	compute_histogram();
+	update();
+
+}
+void spinner(void)
+{
+		read();
+		recalc();
+		upload();
+                compute_histogram();
+		update();
+}
+void recalc( void )
+{
+uint32_t y,tgt;
+	// compute the in-between field &amp; display them
+	
+	draw();
+}
+void drawCross(uint32_t x,uint32_t y)
+{
+
+}
+void update( void)
+{
+	uint8_t *src,*dst,*disp;
+	src=imgsrc-&gt;data;
+	dst=imgdst-&gt;data;
+	// Only do left side of target
+	for(int y=0;y&lt;h;y++)
+	{
+		for(int x=0;x&lt;w;x++)
+		{
+			*dst=scaler[*src];
+			dst++;
+			src++;
+		}		
+	}
+        // Img src = 10
+        //           01
+        // Img dst= 01
+        //          10
+        uint32_t half=w&gt;&gt;1;
+        
+        dst=imgdst-&gt;data;
+        src=imgsrc-&gt;data;
+        disp=imgdisplay-&gt;data;
+        
+        for(int y=0;y&lt;h;y++)
+        {
+                if(y&gt;h/2)
+                {
+                        memcpy(disp,src,half);
+                        memcpy(disp+half,dst+half,half);
+                
+                
+                }
+                else
+                {
+                
+                        memcpy(disp,dst,half);
+                        memcpy(disp+half,src+half,half);
+                }
+                src+=w;
+                dst+=w;
+                disp+=w;
+        
+        }
+	// udate u &amp; v
+	// now convert to rgb
+	//COL_yv12rgb(  w,   h,imgdisplay-&gt;data,(uint8_t *)rgbbuffer );
+	if (resizer)
+		resizer-&gt;resize(imgdisplay-&gt;data, (uint8_t*)rgbbuffer);
+	else
+		rgbConv-&gt;scale(imgdisplay-&gt;data, (uint8_t*)rgbbuffer);
+
+	draw();
+}
+// Compute histogram
+// Top is histogram in, bottom is histogram out
+void compute_histogram(void)
+{
+	uint32_t value[256];
+        uint32_t valueout[256];
+        uint8_t v;
+        
+	memset(value,0,256*sizeof(uint32_t));
+        memset(valueout,0,256*sizeof(uint32_t));
+        // In
+	for(uint32_t t=0;t&lt;w*h;t++)
+	{
+                v=imgsrc-&gt;data[t];
+		value[v]++;	
+                valueout[scaler[v]]++;
+	}
+	// normalize
+	double d,a;
+	a=w*h;
+	for(uint32_t i=0;i&lt;256;i++)
+	{
+		d=value[i];
+		d*=256*ZOOM_FACTOR;
+		d/=a;
+		value[i]=(uint32_t)floor(d+0.49);
+		
+		if(value[i]&gt;127) value[i]=127;
+                
+                d=valueout[i];
+                d*=256*ZOOM_FACTOR;
+                d/=a;
+                valueout[i]=(uint32_t)floor(d+0.49);
+                
+                if(valueout[i]&gt;127) valueout[i]=127;
+                
+                
+	}
+	// Draw
+	memset(histogram,0,256*128*sizeof(uint32_t));
+        memset(histogramout,0,256*128*sizeof(uint32_t));
+	uint32_t y,tgt,yout;
+	for(uint32_t i=0;i&lt;256;i++)
+	{
+		y=value[i];
+                
+		for(uint32_t u=0;u&lt;=y;u++)
+		{
+			tgt=i+(127-u)*256;
+			histogram[tgt]=0xFFFFFFFF;
+		}
+                
+                y=valueout[i];
+                
+                for(uint32_t u=0;u&lt;=y;u++)
+                {
+                        tgt=i+(127-u)*256;
+                        histogramout[tgt]=0xFFFFFFFF;
+                }
+	}
+
+        
+}
+/*---------------------------------------------------------------------------
+	Actually draw the working frame on screen
+*/
+gboolean draw (void)
+{
+	GtkWidget *draw=WID(drawingarea1);
+
+	GUI_RGBDisplay((uint8_t *)rgbbuffer, zoomW, zoomH, (void *)draw);
+/*	
+	draw=WID(histogram);
+	GUI_RGBDisplay((uint8_t *)bargraph, 256,256, (void *)draw);
+*/	
+	draw=WID(drawingarea_histin);
+	GUI_RGBDisplay((uint8_t *)histogram, 256,128, (void *)draw);
+	
+        draw=WID(drawingarea_histout);
+        GUI_RGBDisplay((uint8_t *)histogramout, 256,128, (void *)draw);
+        
+	return true;
+}
+
+void read ( void)
+{
+uint32_t g;
+
+        gfloat sample[256];
+        gtk_curve_get_vector(GTK_CURVE(WID(curve1)),256,sample);
+        for(int i=0;i&lt;256;i++)
+                {
+                        if(sample[i]&lt;0) g=0;
+                        else if(sample[i]&gt;255) g=255;
+                                else g=(uint32_t)sample[i];
+                        scaler[i]=g;
+                      //  printf(&quot;%u %u\n&quot;,i,scaler[i]);
+                }
+}
+
+void upload(void)
+{
+#define SCALING 1
+gfloat g;
+
+        gfloat sample[256];
+        
+        for(int i=0;i&lt;256/SCALING;i++)
+                {
+                       
+                       sample[i]=scaler[i*SCALING];
+                }
+        gtk_curve_set_vector(GTK_CURVE(WID(curve1)),256/SCALING,sample);
+        //gtk_curve_set_curve_type(GTK_CURVE(WID(curve1)),GTK_CURVE_TYPE_LINEAR);
+
+}
+GtkWidget*
+create_dialog1 (void)
+{
+  GtkWidget *dialog1;
+  GtkWidget *dialog_vbox1;
+  GtkWidget *vbox1;
+  GtkWidget *hbox2;
+  GtkWidget *curve1;
+  GtkWidget *vseparator1;
+  GtkWidget *vbox3;
+  GtkWidget *drawingarea_histin;
+  GtkWidget *drawingarea_histout;
+  GtkWidget *hbox1;
+  GtkWidget *buttonReset;
+  GtkWidget *buttonCancel;
+  GtkWidget *buttonApply;
+  GtkWidget *button3;
+  GtkWidget *gui_scale;
+  GtkWidget *drawingarea1;
+  GtkWidget *dialog_action_area1;
+
+  dialog1 = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;Equalizer&quot;));
+  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
+
+  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
+  gtk_widget_show (dialog_vbox1);
+
+  vbox1 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
+
+  hbox2 = gtk_hbox_new (FALSE, 0);
+  gtk_widget_show (hbox2);
+  gtk_box_pack_start (GTK_BOX (vbox1), hbox2, TRUE, TRUE, 0);
+
+  curve1 = gtk_curve_new ();
+  gtk_widget_show (curve1);
+  gtk_box_pack_start (GTK_BOX (hbox2), curve1, FALSE, FALSE, 0);
+  gtk_curve_set_range (GTK_CURVE (curve1), 0, 1, 0, 1);
+
+  vseparator1 = gtk_vseparator_new ();
+  gtk_widget_show (vseparator1);
+  gtk_box_pack_start (GTK_BOX (hbox2), vseparator1, FALSE, FALSE, 0);
+
+  vbox3 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox3);
+  gtk_box_pack_start (GTK_BOX (hbox2), vbox3, TRUE, TRUE, 0);
+
+  drawingarea_histin = gtk_drawing_area_new ();
+  gtk_widget_show (drawingarea_histin);
+  gtk_box_pack_start (GTK_BOX (vbox3), drawingarea_histin, TRUE, TRUE, 0);
+  gtk_widget_set_size_request (drawingarea_histin, 10, -1);
+
+  drawingarea_histout = gtk_drawing_area_new ();
+  gtk_widget_show (drawingarea_histout);
+  gtk_box_pack_start (GTK_BOX (vbox3), drawingarea_histout, TRUE, TRUE, 0);
+
+  hbox1 = gtk_hbox_new (FALSE, 0);
+  gtk_widget_show (hbox1);
+  gtk_box_pack_start (GTK_BOX (vbox1), hbox1, FALSE, TRUE, 0);
+
+  buttonReset = gtk_button_new_from_stock (&quot;gtk-clear&quot;);
+  gtk_widget_show (buttonReset);
+  gtk_box_pack_start (GTK_BOX (hbox1), buttonReset, FALSE, FALSE, 0);
+
+  buttonCancel = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
+  gtk_widget_show (buttonCancel);
+  gtk_box_pack_start (GTK_BOX (hbox1), buttonCancel, FALSE, FALSE, 0);
+
+  buttonApply = gtk_button_new_from_stock (&quot;gtk-apply&quot;);
+  gtk_widget_show (buttonApply);
+  gtk_box_pack_start (GTK_BOX (hbox1), buttonApply, FALSE, FALSE, 0);
+
+  button3 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
+  gtk_widget_show (button3);
+  gtk_box_pack_start (GTK_BOX (hbox1), button3, FALSE, FALSE, 0);
+
+  gui_scale = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 100, 1, 10, 10)));
+  gtk_widget_show (gui_scale);
+  gtk_box_pack_start (GTK_BOX (vbox1), gui_scale, TRUE, TRUE, 0);
+
+  drawingarea1 = gtk_drawing_area_new ();
+  gtk_widget_show (drawingarea1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), drawingarea1, TRUE, TRUE, 0);
+  gtk_widget_set_size_request (drawingarea1, 100, 100);
+
+  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
+  gtk_widget_show (dialog_action_area1);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, vbox1, &quot;vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hbox2, &quot;hbox2&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, curve1, &quot;curve1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, vseparator1, &quot;vseparator1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, vbox3, &quot;vbox3&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, drawingarea_histin, &quot;drawingarea_histin&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, drawingarea_histout, &quot;drawingarea_histout&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, buttonReset, &quot;buttonReset&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, buttonCancel, &quot;buttonCancel&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, buttonApply, &quot;buttonApply&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, button3, &quot;button3&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, gui_scale, &quot;gui_scale&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, drawingarea1, &quot;drawingarea1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
+
+  //gtk_widget_grab_default (buttonApply);
+  return dialog1;
+}
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/ADM_vidMPdelogo.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/ADM_vidMPdelogo.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,399 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+
+
+#include &quot;ADM_videoFilterDynamic.h&quot;
+
+
+extern &quot;C&quot; {
+#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h&quot;
+#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavutil/avutil.h&quot;
+#include &quot;ADM_libraries/ADM_ffmpeg/ADM_libswscale/swscale.h&quot;
+}
+
+#include &quot;ADM_vidMPdelogo.h&quot;
+
+class  ADMVideoMPdelogo:public AVDMGenericVideoStream
+ {
+
+ protected:
+                                MPDELOGO_PARAM  *_param;
+                                VideoCache      *vidCache;
+
+ public:
+
+                                ADMVideoMPdelogo(  AVDMGenericVideoStream *in,CONFcouple *setup);
+                                ADMVideoMPdelogo(        AVDMGenericVideoStream *in,uint32_t x,uint32_t y);
+                                virtual                 ~ADMVideoMPdelogo();
+          virtual               uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                                                ADMImage *data,uint32_t *flags);
+                                uint8_t configure( AVDMGenericVideoStream *instream);
+        virtual                 char    *printConf(void) ;
+
+          virtual uint8_t       getCoupledConf( CONFcouple **couples);
+
+
+ }     ;
+extern uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in);
+
+static FILTER_PARAM mpdelogoParam={6,{&quot;xoff&quot;,&quot;yoff&quot;,&quot;lw&quot;,&quot;lh&quot;,&quot;band&quot;,&quot;show&quot;}};
+//REGISTERX(VF_MISC, &quot;mpdelogo&quot;,QT_TR_NOOP(&quot;MPlayer delogo&quot;),
+//QT_TR_NOOP(&quot;Blend a logo by interpolating its surrounding box.&quot;),VF_MPDELOGO,1,mpdelogo_create,mpdelogo_script);
+//******************************************
+VF_DEFINE_FILTER(ADMVideoMPdelogo,mpdelogoParam,
+    mpdelogo,
+                QT_TR_NOOP(&quot;MPlayer delogo&quot;),
+                1,
+                VF_MISC,
+                QT_TR_NOOP(&quot;Blend a logo by interpolating its surrounding box.&quot;));
+
+//******************************************
+
+
+uint8_t ADMVideoMPdelogo::configure(AVDMGenericVideoStream * instream)
+{
+    UNUSED_ARG(instream);
+
+    return DIA_getMPdelogo(_param,instream);
+}
+
+char *ADMVideoMPdelogo::printConf( void )
+{
+        static char buf[50];
+
+        sprintf((char *)buf,&quot; MPlayer delogo : at (%d,%d) (%dx%d)&quot;,
+                                _param-&gt;xoff,_param-&gt;yoff,_param-&gt;lw,_param-&gt;lh);
+        return buf;
+}
+//_______________________________________________________________
+ADMVideoMPdelogo::ADMVideoMPdelogo(
+         AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+        _in=in;
+        memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
+        _param=NEW(MPDELOGO_PARAM);
+        vidCache=new VideoCache(4,_in);
+        if(couples)
+        {
+
+                GET(xoff);
+                GET(yoff);
+                GET(lw);
+                GET(lh);
+                GET(show);
+                GET(band);
+        
+        }
+        else
+        {
+                _param-&gt;xoff=0;
+                _param-&gt;yoff=0;
+                _param-&gt;lw = _info.width&gt;&gt;1;
+                _param-&gt;lh = _info.height&gt;&gt;1;
+                _param-&gt;band=4;
+                _param-&gt;show=0;
+        }
+        _info.encoding=1;
+}
+
+
+uint8_t ADMVideoMPdelogo::getCoupledConf( CONFcouple **couples)
+{
+
+                        ADM_assert(_param);
+                        *couples=new CONFcouple(6);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+                CSET(xoff);
+                CSET(yoff);
+                CSET(lw);
+                CSET(lh);
+                CSET(show);
+                CSET(band);
+                return 1;
+
+}
+// ___ destructor_____________
+ADMVideoMPdelogo::~ADMVideoMPdelogo()
+{
+        DELETE(_param);
+        delete vidCache;
+        vidCache=NULL;
+}
+static void delogo(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int width, int height,
+                   int logo_x, int logo_y, int logo_w, int logo_h, int band, int show, int direct) ;
+
+uint8_t ADMVideoMPdelogo::getFrameNumberNoAlloc(uint32_t frame,
+                                uint32_t *len,
+                                ADMImage *data,
+                                uint32_t *flags)
+{
+                        if(frame&gt;=_info.nb_frames) 
+                        {
+                                printf(&quot;MPdelogo : Filter : out of bound!\n&quot;);
+                                return 0;
+                        }
+        
+                        ADM_assert(_param);
+
+ADMImage *curImage;
+char txt[256];
+                        curImage=vidCache-&gt;getImage(frame);
+                        if(!curImage)
+                        {
+                                printf(&quot;MPdelogo : error getting frame\n&quot;);
+                                return 0;
+                        }
+                delogo(YPLANE(data), YPLANE(curImage), _info.width, _info.width, _info.width, _info.height,
+                        _param-&gt;xoff, _param-&gt;yoff, _param-&gt;lw, _param-&gt;lh, _param-&gt;band, _param-&gt;show,0);
+                delogo(UPLANE(data), UPLANE(curImage), _info.width&gt;&gt;1, _info.width&gt;&gt;1, _info.width&gt;&gt;1,
+                 _info.height&gt;&gt;1,_param-&gt;xoff&gt;&gt;1, _param-&gt;yoff&gt;&gt;1, _param-&gt;lw&gt;&gt;1,
+                 _param-&gt;lh&gt;&gt;1, _param-&gt;band&gt;&gt;1, _param-&gt;show,0);
+                delogo(VPLANE(data), VPLANE(curImage), _info.width&gt;&gt;1, _info.width&gt;&gt;1, _info.width&gt;&gt;1,
+                 _info.height&gt;&gt;1,_param-&gt;xoff&gt;&gt;1, _param-&gt;yoff&gt;&gt;1, _param-&gt;lw&gt;&gt;1,
+                 _param-&gt;lh&gt;&gt;1, _param-&gt;band&gt;&gt;1, _param-&gt;show,0);
+                
+                        vidCache-&gt;unlockAll();
+        return 1;
+}
+
+
+/*
+  Copyright (C) 2002 Jindrich Makovicka &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">makovick at kmlinux.fjfi.cvut.cz</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* A very simple tv station logo remover */
+
+
+
+//===========================================================================//
+
+
+#define MIN(a,b) (((a) &lt; (b)) ? (a) : (b))
+#define MAX(a,b) (((a) &gt; (b)) ? (a) : (b))
+
+void delogo(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int width, int height,
+		   int logo_x, int logo_y, int logo_w, int logo_h, int band, int show, int direct) {
+    int y, x;
+    int interp, dist;
+    uint8_t *xdst, *xsrc;
+    
+    uint8_t *topleft, *botleft, *topright;
+    int xclipl, xclipr, yclipt, yclipb;
+    int logo_x1, logo_x2, logo_y1, logo_y2;
+    
+    xclipl = MAX(-logo_x, 0);
+    xclipr = MAX(logo_x+logo_w-width, 0);
+    yclipt = MAX(-logo_y, 0);
+    yclipb = MAX(logo_y+logo_h-height, 0);
+
+    logo_x1 = logo_x + xclipl;
+    logo_x2 = logo_x + logo_w - xclipr;
+    logo_y1 = logo_y + yclipt;
+    logo_y2 = logo_y + logo_h - yclipb;
+
+    topleft = src+logo_y1*srcStride+logo_x1;
+    topright = src+logo_y1*srcStride+logo_x2-1;
+    botleft = src+(logo_y2-1)*srcStride+logo_x1;
+
+    if (!direct) memcpy(dst, src,(width*height*3)/2); // width, height, dstStride, srcStride);
+
+    dst += (logo_y1+1)*dstStride;
+    src += (logo_y1+1)*srcStride;
+    
+    for(y = logo_y1+1; y &lt; logo_y2-1; y++)
+    {
+	for (x = logo_x1+1, xdst = dst+logo_x1+1, xsrc = src+logo_x1+1; x &lt; logo_x2-1; x++, xdst++, xsrc++) {
+	    interp = ((topleft[srcStride*(y-logo_y-yclipt)]
+		       + topleft[srcStride*(y-logo_y-1-yclipt)]
+		       + topleft[srcStride*(y-logo_y+1-yclipt)])*(logo_w-(x-logo_x))/logo_w
+		      + (topright[srcStride*(y-logo_y-yclipt)]
+			 + topright[srcStride*(y-logo_y-1-yclipt)]
+			 + topright[srcStride*(y-logo_y+1-yclipt)])*(x-logo_x)/logo_w
+		      + (topleft[x-logo_x-xclipl]
+			 + topleft[x-logo_x-1-xclipl]
+			 + topleft[x-logo_x+1-xclipl])*(logo_h-(y-logo_y))/logo_h
+		      + (botleft[x-logo_x-xclipl]
+			 + botleft[x-logo_x-1-xclipl]
+			 + botleft[x-logo_x+1-xclipl])*(y-logo_y)/logo_h
+		)/6;
+/*		interp = (topleft[srcStride*(y-logo_y)]*(logo_w-(x-logo_x))/logo_w
+			  + topright[srcStride*(y-logo_y)]*(x-logo_x)/logo_w
+			  + topleft[x-logo_x]*(logo_h-(y-logo_y))/logo_h
+			  + botleft[x-logo_x]*(y-logo_y)/logo_h
+			  )/2;*/
+	    if (y &gt;= logo_y+band &amp;&amp; y &lt; logo_y+logo_h-band &amp;&amp; x &gt;= logo_x+band &amp;&amp; x &lt; logo_x+logo_w-band) {
+		    *xdst = interp;
+	    } else {
+		dist = 0;
+		if (x &lt; logo_x+band) dist = MAX(dist, logo_x-x+band);
+		else if (x &gt;= logo_x+logo_w-band) dist = MAX(dist, x-(logo_x+logo_w-1-band));
+		if (y &lt; logo_y+band) dist = MAX(dist, logo_y-y+band);
+		else if (y &gt;= logo_y+logo_h-band) dist = MAX(dist, y-(logo_y+logo_h-1-band));
+		*xdst = (*xsrc*dist + interp*(band-dist))/band;
+		if (show &amp;&amp; (dist == band-1)) *xdst = 0;
+	    }
+	}
+
+	dst+= dstStride;
+	src+= srcStride;
+    }
+}
+
+#if 0
+static int put_image(struct vf_instance_s* vf, mp_image_t *mpi){
+    mp_image_t *dmpi;
+
+    if(!(mpi-&gt;flags&amp;MP_IMGFLAG_DIRECT)){
+	// no DR, so get a new image! hope we'll get DR buffer:
+	vf-&gt;dmpi=vf_get_image(vf-&gt;next,vf-&gt;priv-&gt;outfmt,
+			      MP_IMGTYPE_TEMP, MP_IMGFLAG_ACCEPT_STRIDE,
+			      mpi-&gt;w,mpi-&gt;h);
+    }
+    dmpi= vf-&gt;dmpi;
+
+    delogo(dmpi-&gt;planes[0], mpi-&gt;planes[0], dmpi-&gt;stride[0], mpi-&gt;stride[0], mpi-&gt;w, mpi-&gt;h,
+	   vf-&gt;priv-&gt;xoff, vf-&gt;priv-&gt;yoff, vf-&gt;priv-&gt;lw, vf-&gt;priv-&gt;lh, vf-&gt;priv-&gt;band, vf-&gt;priv-&gt;show,
+	   mpi-&gt;flags&amp;MP_IMGFLAG_DIRECT);
+    delogo(dmpi-&gt;planes[1], mpi-&gt;planes[1], dmpi-&gt;stride[1], mpi-&gt;stride[1], mpi-&gt;w/2, mpi-&gt;h/2,
+	   vf-&gt;priv-&gt;xoff/2, vf-&gt;priv-&gt;yoff/2, vf-&gt;priv-&gt;lw/2, vf-&gt;priv-&gt;lh/2, vf-&gt;priv-&gt;band/2, vf-&gt;priv-&gt;show,
+	   mpi-&gt;flags&amp;MP_IMGFLAG_DIRECT);
+    delogo(dmpi-&gt;planes[2], mpi-&gt;planes[2], dmpi-&gt;stride[2], mpi-&gt;stride[2], mpi-&gt;w/2, mpi-&gt;h/2,
+	   vf-&gt;priv-&gt;xoff/2, vf-&gt;priv-&gt;yoff/2, vf-&gt;priv-&gt;lw/2, vf-&gt;priv-&gt;lh/2, vf-&gt;priv-&gt;band/2, vf-&gt;priv-&gt;show,
+	   mpi-&gt;flags&amp;MP_IMGFLAG_DIRECT);
+
+    vf_clone_mpi_attributes(dmpi, mpi);
+
+    return vf_next_put_image(vf,dmpi);
+}
+
+static void uninit(struct vf_instance_s* vf){
+    if(!vf-&gt;priv) return;
+
+    free(vf-&gt;priv);
+    vf-&gt;priv=NULL;
+}
+
+//===========================================================================//
+
+static int query_format(struct vf_instance_s* vf, unsigned int fmt){
+    switch(fmt)
+    {
+    case IMGFMT_YV12:
+    case IMGFMT_I420:
+    case IMGFMT_IYUV:
+	return vf_next_query_format(vf,vf-&gt;priv-&gt;outfmt);
+    }
+    return 0;
+}
+
+static unsigned int fmt_list[]={
+    IMGFMT_YV12,
+    IMGFMT_I420,
+    IMGFMT_IYUV,
+    0
+};
+
+static int open(vf_instance_t *vf, char* args){
+    int res;
+    
+    vf-&gt;config=config;
+    vf-&gt;put_image=put_image;
+    vf-&gt;get_image=get_image;
+    vf-&gt;query_format=query_format;
+    vf-&gt;uninit=uninit;
+    if (!vf-&gt;priv)
+    {
+        vf-&gt;priv=malloc(sizeof(struct vf_priv_s));
+	memset(vf-&gt;priv, 0, sizeof(struct vf_priv_s));
+    }
+
+    if (args) res = sscanf(args, &quot;%d:%d:%d:%d:%d&quot;,
+			   &amp;vf-&gt;priv-&gt;xoff, &amp;vf-&gt;priv-&gt;yoff,
+			   &amp;vf-&gt;priv-&gt;lw, &amp;vf-&gt;priv-&gt;lh,
+			   &amp;vf-&gt;priv-&gt;band);
+    if (args &amp;&amp; (res != 5)) {
+	uninit(vf);
+	return 0; // bad syntax
+    }
+
+    mp_msg(MSGT_VFILTER, MSGL_V, &quot;delogo: %d x %d, %d x %d, band = %d\n&quot;,
+	   vf-&gt;priv-&gt;xoff, vf-&gt;priv-&gt;yoff,
+	   vf-&gt;priv-&gt;lw, vf-&gt;priv-&gt;lh,
+	   vf-&gt;priv-&gt;band);
+
+    vf-&gt;priv-&gt;show = 0;
+
+    if (vf-&gt;priv-&gt;band &lt; 0) {
+	vf-&gt;priv-&gt;band = 4;
+	vf-&gt;priv-&gt;show = 1;
+    }
+    
+
+    vf-&gt;priv-&gt;lw += vf-&gt;priv-&gt;band*2;
+    vf-&gt;priv-&gt;lh += vf-&gt;priv-&gt;band*2;
+    vf-&gt;priv-&gt;xoff -= vf-&gt;priv-&gt;band;
+    vf-&gt;priv-&gt;yoff -= vf-&gt;priv-&gt;band;
+
+    // check csp:
+    vf-&gt;priv-&gt;outfmt=vf_match_csp(&amp;vf-&gt;next,fmt_list,IMGFMT_YV12);
+    if(!vf-&gt;priv-&gt;outfmt)
+    {
+	uninit(vf);
+        return 0; // no csp match :(
+    }
+
+    return 1;
+}
+
+#define ST_OFF(f) M_ST_OFF(struct vf_priv_s,f)
+static m_option_t vf_opts_fields[] = {
+    { &quot;x&quot;, ST_OFF(xoff), CONF_TYPE_INT, 0, 0, 0, NULL },
+    { &quot;y&quot;, ST_OFF(yoff), CONF_TYPE_INT, 0, 0, 0, NULL },
+    { &quot;w&quot;, ST_OFF(lw), CONF_TYPE_INT, 0, 0, 0, NULL },
+    { &quot;h&quot;, ST_OFF(lh), CONF_TYPE_INT, 0, 0, 0, NULL },
+    { &quot;t&quot;, ST_OFF(band), CONF_TYPE_INT, 0, 0, 0, NULL },
+    { &quot;band&quot;, ST_OFF(band), CONF_TYPE_INT, 0, 0, 0, NULL }, // alias
+    { NULL, NULL, 0, 0, 0, 0, NULL }
+};
+
+static m_struct_t vf_opts = {
+    &quot;delogo&quot;,
+    sizeof(struct vf_priv_s),
+    &amp;vf_priv_dflt,
+    vf_opts_fields
+};
+
+vf_info_t vf_info_delogo = {
+    &quot;simple logo remover&quot;,
+    &quot;delogo&quot;,
+    &quot;Jindrich Makovicka, Alex Beregszaszi&quot;,
+    &quot;&quot;,
+    open,
+    &amp;vf_opts
+};
+#endif
+//===========================================================================//

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/ADM_vidMPdelogo.h (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidMPdelogo.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/ADM_vidMPdelogo.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,24 @@
+/***************************************************************************
+    copyright            : Mplayer team/Mean for ADM port
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_DELOGO_H
+#define ADM_DELOGO_H
+typedef struct MPDELOGO_PARAM
+{
+        uint32_t xoff;
+        uint32_t yoff;
+        uint32_t lw;
+        uint32_t lh;
+        uint32_t band;
+        uint32_t show;
+}MPDELOGO_PARAM;
+#endif

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/CMakeLists.txt	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/CMakeLists.txt	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,20 @@
+INCLUDE(vf_plugin)
+
+
+SET(mpdelogoCommon_SRCS 
+ADM_vidMPdelogo.cpp
+)
+
+INCLUDE(vf_plugin_gtk)
+
+SET(mpdelogoGtk_SRCS gtk/DIA_mpdelogo.cpp )
+INCLUDE_DIRECTORIES(&quot;${CMAKE_CURRENT_SOURCE_DIR}/../../../&quot;)
+
+INIT_VIDEOFILTER_PLUGIN_GTK(  ADM_vf_mpdelogo_gtk 
+                ${mpdelogoGtk_SRCS} ${mpdelogoCommon_SRCS})
+
+IF (GTK_FOUND AND GTHREAD_FOUND)
+        TARGET_LINK_LIBRARIES(ADM_vf_mpdelogo_gtk ADM_libswscale)
+        TARGET_LINK_LIBRARIES(ADM_vf_mpdelogo_gtk ADM_libavcodec)
+        TARGET_LINK_LIBRARIES(ADM_vf_mpdelogo_gtk ADM_libavutil)
+ENDIF (GTK_FOUND AND GTHREAD_FOUND)        

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/gtk/DIA_mpdelogo.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mpdelogo.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mpdelogo.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/MPDelogo/gtk/DIA_mpdelogo.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,524 @@
+/***************************************************************************
+                          DIA_crop.cpp  -  description
+                             -------------------
+
+			    GUI for cropping including autocrop
+			    +Revisted the Gtk2 way
+			     +Autocrop now in RGB space (more accurate)
+
+    begin                : Fri May 3 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &lt;math.h&gt;
+
+#include &quot;ADM_toolkitGtk.h&quot;
+
+
+#include &quot;ADM_image.h&quot;
+#include &quot;ADM_videoFilter.h&quot;
+#include &quot;ADM_colorspace.h&quot;
+#include &quot;ADM_vidMPdelogo.h&quot;
+
+extern &quot;C&quot; {
+#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h&quot;
+}
+
+static GtkWidget	*create_dialog1 (void);
+static void  		ui_read ( void);
+static void  		ui_update ( void);
+static void 		draw (GtkWidget *dialog,uint32_t w,uint32_t h );
+static gboolean 	gui_draw( void );
+static void 		autocrop (void );
+static void 		reset( void );
+static void 		ui_upload(void);
+static gboolean		ui_changed(void);
+
+
+static void		prepare(uint32_t img);
+static void 		frame_changed( void );
+
+extern void GUI_RGBDisplay(uint8_t * dis, uint32_t w, uint32_t h, void *widg);
+extern float UI_calcZoomToFitScreen(GtkWindow* window, GtkWidget* drawingArea, uint32_t imageWidth, uint32_t imageHeight);
+extern void UI_centreCanvasWindow(GtkWindow *window, GtkWidget *canvas, int newCanvasWidth, int newCanvasHeight);
+
+static ColYuvRgb    *rgbConv=NULL;
+static uint8_t *working=NULL;
+static uint8_t *rgbBufferDisplay=NULL;
+static uint8_t *original=NULL;
+static GtkWidget *dialog=NULL;
+static uint32_t x,y,w,h,zoomW,zoomH,band;
+
+static AVDMGenericVideoStream *incoming=NULL;
+static ADMImage *imgsrc=NULL;
+static ADMImageResizer *resizer=NULL;
+
+static int lock=0,width,height;
+
+
+//
+//	Video is in YV12 Colorspace
+//
+//
+uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in)
+
+{
+	// Allocate space for green-ised video
+	width=in-&gt;getInfo()-&gt;width;
+	height=in-&gt;getInfo()-&gt;height;
+		
+	working=new uint8_t [width*height*4];	
+	original=NULL;
+
+	uint8_t ret=0;
+
+	dialog=create_dialog1();
+        gtk_register_dialog(dialog);
+	
+	x=param-&gt;xoff;
+	y=param-&gt;yoff;
+	w=param-&gt;lw;
+	h=param-&gt;lh;
+	band=param-&gt;band;
+
+	imgsrc=new ADMImage(width,height);
+	incoming=in;
+	
+	rgbConv=new ColYuvRgb(width,height);
+        rgbConv-&gt;reset(width,height);
+
+	float zoom = UI_calcZoomToFitScreen(GTK_WINDOW(dialog), WID(drawingarea1), width, height);
+
+	zoomW = width * zoom;
+	zoomH = height * zoom;
+	rgbBufferDisplay=new uint8_t[zoomW*zoomH*4];
+
+	gtk_widget_set_usize(WID(drawingarea1), zoomW, zoomH);
+
+	if (zoom &lt; 1)
+	{
+		UI_centreCanvasWindow((GtkWindow*)dialog, WID(drawingarea1), zoomW, zoomH);
+		resizer = new ADMImageResizer(width, height, zoomW, zoomH, PIX_FMT_RGB32, PIX_FMT_RGB32);
+	}
+
+	prepare(0);
+	gtk_widget_show(dialog);
+	
+	ui_upload();
+	ui_update();
+	
+#define CONNECT(x,y,z) 	gtk_signal_connect(GTK_OBJECT(WID(x)), #y,GTK_SIGNAL_FUNC(z),   NULL);
+
+        CONNECT(drawingarea1,expose_event,gui_draw);
+        CONNECT(hscale1,value_changed,frame_changed);	  
+		      
+#define CONNECT_SPIN(x) CONNECT(spinbutton##x, value_changed,ui_changed)
+      	  
+        CONNECT_SPIN(X);
+        CONNECT_SPIN(Y);
+        CONNECT_SPIN(W);
+        CONNECT_SPIN(H);
+        CONNECT_SPIN(Band);
+	  
+	draw(dialog,width,height);
+
+	ret=0;
+	int response;
+	while( (response=gtk_dialog_run(GTK_DIALOG(dialog)))==GTK_RESPONSE_APPLY)
+	{
+		ui_changed();
+		
+	}
+	if(response==GTK_RESPONSE_OK)
+        {
+		ui_read( );
+		param-&gt;xoff=x;
+                param-&gt;yoff=y;
+                param-&gt;lw=w;
+                param-&gt;lh=h;
+                param-&gt;band=band;
+		ret=1;
+	}
+        gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+	delete working;	
+	delete imgsrc;
+	delete rgbConv;
+
+	if (resizer)
+	{
+		delete resizer;
+		delete[] rgbBufferDisplay;
+
+		resizer=NULL;
+		rgbBufferDisplay=NULL;
+	}
+
+	working=NULL;
+	dialog=NULL;
+	original=NULL;
+	imgsrc=NULL;
+	return ret;
+}
+void frame_changed( void )
+{
+uint32_t new_frame,max,l,f;
+double   percent;
+GtkWidget *wid;	
+GtkAdjustment *adj;
+
+        max=incoming-&gt;getInfo()-&gt;nb_frames;
+        wid=WID(hscale1);
+        adj=gtk_range_get_adjustment (GTK_RANGE(wid));
+        new_frame=0;
+        
+        percent=(double)GTK_ADJUSTMENT(adj)-&gt;value;
+        percent*=max;
+        percent/=100.;
+        new_frame=(uint32_t)floor(percent);
+        
+        if(new_frame&gt;=max) new_frame=max-1;
+        
+        prepare(new_frame);
+        ui_update();
+        gui_draw();
+
+
+}
+void prepare(uint32_t img)
+{
+	uint32_t l,f;
+	
+	ADM_assert(incoming-&gt;getFrameNumberNoAlloc(img,&amp;l,imgsrc,&amp;f));
+	original=imgsrc-&gt;data;
+	
+
+}
+gboolean ui_changed(void)
+{
+	if(!lock)
+	{
+		ui_read();
+		memcpy(working,original,(width*height*3)&gt;&gt;1);
+		ui_update();
+		draw(dialog,width,height);
+	}
+		return true;
+}
+
+
+/*---------------------------------------------------------------------------
+	Actually draw the working frame on screen
+*/
+gboolean gui_draw( void )
+{
+	draw(dialog,width,height);
+	return true;
+}
+void draw (GtkWidget *dialog,uint32_t w,uint32_t h )
+{
+	GtkWidget *draw=WID(drawingarea1);
+
+	if (resizer)
+	{
+		resizer-&gt;resize(working, rgbBufferDisplay);
+		GUI_RGBDisplay(rgbBufferDisplay, zoomW, zoomH, (void*)draw);
+	}
+	else
+		GUI_RGBDisplay(working, w, h, (void*)draw);
+}
+/*---------------------------------------------------------------------------
+	Read entried from dialog box
+*/
+
+#define SPIN_GET(x,y) {x= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(spinbutton##y))) ;}
+#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(spinbutton##y)),(gfloat)x) ;}
+
+
+void ui_read (void )
+{
+	int reject=0;
+	
+			SPIN_GET(x,X);
+			SPIN_GET(y,Y);
+			SPIN_GET(h,H);
+			SPIN_GET(w,W);
+                        SPIN_GET(band,Band);
+			
+			//printf(&quot;%d %d %d %d\n&quot;,x,y,w,h);
+			
+			x&amp;=0xffffe;
+			y&amp;=0xffffe;
+			h&amp;=0xffffe;
+			w&amp;=0xffffe;
+			
+			if((x+w)&gt;width)
+				{
+                                        if(w&gt;=width) w=width;
+                                        x=width-w;
+                                        reject=1;
+				}
+			if((y+h)&gt;height)
+				{
+                                        if(h&gt;=height) h=height;
+                                        y=height-h;
+                                        reject=1;
+				}
+			if(reject)
+				ui_upload();
+}
+
+void ui_upload(void)
+{
+	lock++;
+	SPIN_SET(x,X);
+	SPIN_SET(y,Y);
+	SPIN_SET(w,W);
+	SPIN_SET(h,H);
+        SPIN_SET(band,Band);
+	lock--;
+}
+//____________________________________
+void reset( void )
+{
+	
+	x=y=w=h=0;
+	ui_upload();
+	ui_update();
+	gui_draw();
+	
+
+}
+/*---------------------------------------------------------------------------
+	Green-ify the displayed frame on cropped parts
+*/
+void ui_update( )
+{
+
+        uint8_t  *in,*in2;
+        uint8_t *buffer=working;
+
+        rgbConv-&gt;scale(original,buffer);
+        // Buffer is in RGB space
+        in=buffer+x*4+y*width*4;
+        in2=buffer+(x+w)*4+y*width*4;
+        
+        for(int yy=0;yy&lt;h;yy++)
+        {
+          in[0]=in[2]=0;in[1]=0xff;
+          in2[0]=in2[2]=0;in2[1]=0xff;
+          in+=width*4;
+          in2+=width*4;
+        }
+        in=buffer+(y*width+x)*4;
+        in2=buffer+((y+h)*width+x)*4;
+        for(int yy=0;yy&lt;w;yy++)
+        {
+          in[0]=in[2]=0;in[1]=0xff;
+          in2[0]=in2[2]=0;in2[1]=0xff;
+          in+=4;
+          in2+=4;
+        }
+
+}
+
+//--------------------------------------------
+GtkWidget*
+create_dialog1 (void)
+{
+  GtkWidget *dialog1;
+  GtkWidget *dialog_vbox1;
+  GtkWidget *vbox1;
+  GtkWidget *vbox2;
+  GtkWidget *table2;
+  GtkWidget *label3;
+  GtkWidget *label4;
+  GtkWidget *label5;
+  GtkWidget *label6;
+  GtkWidget *label7;
+  GtkObject *spinbuttonX_adj;
+  GtkWidget *spinbuttonX;
+  GtkObject *spinbuttonY_adj;
+  GtkWidget *spinbuttonY;
+  GtkObject *spinbuttonW_adj;
+  GtkWidget *spinbuttonW;
+  GtkObject *spinbuttonH_adj;
+  GtkWidget *spinbuttonH;
+  GtkWidget *hseparator1;
+  GtkWidget *hseparator2;
+  GtkObject *spinbuttonBand_adj;
+  GtkWidget *spinbuttonBand;
+  GtkWidget *hseparator3;
+  GtkWidget *hscale1;
+  GtkWidget *drawingarea1;
+  GtkWidget *dialog_action_area1;
+  GtkWidget *cancelbutton1;
+  GtkWidget *okbutton1;
+
+  dialog1 = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;Mplayer Delogo&quot;));
+  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
+
+  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
+  gtk_widget_show (dialog_vbox1);
+
+  vbox1 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
+
+  vbox2 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox2);
+  gtk_box_pack_start (GTK_BOX (vbox1), vbox2, FALSE, FALSE, 0);
+
+  table2 = gtk_table_new (3, 4, FALSE);
+  gtk_widget_show (table2);
+  gtk_box_pack_start (GTK_BOX (vbox2), table2, TRUE, TRUE, 0);
+
+  label3 = gtk_label_new (QT_TR_NOOP(&quot;X&quot;));
+  gtk_widget_show (label3);
+  gtk_table_attach (GTK_TABLE (table2), label3, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
+
+  label4 = gtk_label_new (QT_TR_NOOP(&quot;Y&quot;));
+  gtk_widget_show (label4);
+  gtk_table_attach (GTK_TABLE (table2), label4, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
+
+  label5 = gtk_label_new (QT_TR_NOOP(&quot;W&quot;));
+  gtk_widget_show (label5);
+  gtk_table_attach (GTK_TABLE (table2), label5, 2, 3, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
+
+  label6 = gtk_label_new (QT_TR_NOOP(&quot;H&quot;));
+  gtk_widget_show (label6);
+  gtk_table_attach (GTK_TABLE (table2), label6, 2, 3, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label6), 0, 0.5);
+
+  label7 = gtk_label_new (QT_TR_NOOP(&quot;Band&quot;));
+  gtk_widget_show (label7);
+  gtk_table_attach (GTK_TABLE (table2), label7, 0, 1, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label7), 0, 0.5);
+
+  spinbuttonX_adj = gtk_adjustment_new (1, 0, 2000, 1, 10, 10);
+  spinbuttonX = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonX_adj), 1, 0);
+  gtk_widget_show (spinbuttonX);
+  gtk_table_attach (GTK_TABLE (table2), spinbuttonX, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  spinbuttonY_adj = gtk_adjustment_new (1, 0, 2000, 1, 10, 10);
+  spinbuttonY = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonY_adj), 1, 0);
+  gtk_widget_show (spinbuttonY);
+  gtk_table_attach (GTK_TABLE (table2), spinbuttonY, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  spinbuttonW_adj = gtk_adjustment_new (1, 0, 2000, 1, 10, 10);
+  spinbuttonW = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonW_adj), 1, 0);
+  gtk_widget_show (spinbuttonW);
+  gtk_table_attach (GTK_TABLE (table2), spinbuttonW, 3, 4, 0, 1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  spinbuttonH_adj = gtk_adjustment_new (1, 0, 2000, 1, 10, 10);
+  spinbuttonH = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonH_adj), 1, 0);
+  gtk_widget_show (spinbuttonH);
+  gtk_table_attach (GTK_TABLE (table2), spinbuttonH, 3, 4, 1, 2,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  hseparator1 = gtk_hseparator_new ();
+  gtk_widget_show (hseparator1);
+  gtk_table_attach (GTK_TABLE (table2), hseparator1, 3, 4, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (GTK_FILL), 0, 0);
+
+  hseparator2 = gtk_hseparator_new ();
+  gtk_widget_show (hseparator2);
+  gtk_table_attach (GTK_TABLE (table2), hseparator2, 2, 3, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (GTK_FILL), 0, 0);
+
+  spinbuttonBand_adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
+  spinbuttonBand = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonBand_adj), 1, 0);
+  gtk_widget_show (spinbuttonBand);
+  gtk_table_attach (GTK_TABLE (table2), spinbuttonBand, 1, 2, 2, 3,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  hseparator3 = gtk_hseparator_new ();
+  gtk_widget_show (hseparator3);
+  gtk_box_pack_start (GTK_BOX (vbox2), hseparator3, FALSE, FALSE, 0);
+
+  hscale1 = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 100, 1, 1, 0)));
+  gtk_widget_show (hscale1);
+  gtk_box_pack_start (GTK_BOX (vbox1), hscale1, FALSE, FALSE, 0);
+
+  drawingarea1 = gtk_drawing_area_new ();
+  gtk_widget_show (drawingarea1);
+  gtk_box_pack_start (GTK_BOX (vbox1), drawingarea1, TRUE, TRUE, 0);
+  gtk_widget_set_size_request (drawingarea1, 100, 100);
+
+  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
+  gtk_widget_show (dialog_action_area1);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
+
+  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
+  gtk_widget_show (cancelbutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
+  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
+
+  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
+  gtk_widget_show (okbutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
+  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, vbox1, &quot;vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, vbox2, &quot;vbox2&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, table2, &quot;table2&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label3, &quot;label3&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label4, &quot;label4&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label5, &quot;label5&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label6, &quot;label6&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label7, &quot;label7&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonX, &quot;spinbuttonX&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonY, &quot;spinbuttonY&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonW, &quot;spinbuttonW&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonH, &quot;spinbuttonH&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hseparator1, &quot;hseparator1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hseparator2, &quot;hseparator2&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonBand, &quot;spinbuttonBand&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hseparator3, &quot;hseparator3&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hscale1, &quot;hscale1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, drawingarea1, &quot;drawingarea1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
+
+  return dialog1;
+}
+
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/PulldownRemoval/ADM_vidFieldUnblend.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUnblend.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidFieldUnblend.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/PulldownRemoval/ADM_vidFieldUnblend.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,525 @@
+/***************************************************************************
+                         
+        Hard ivtc removal for image
+
+        A B C D E -&gt; A BC CD D E
+
+    copyright            : (C) 2005 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+#include &lt;string.h&gt;
+#include &quot;ADM_default.h&quot;
+#include &lt;math.h&gt;
+
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_videoFilter.h&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_FILTER
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#include &quot;DIA_enter.h&quot;
+
+#define MUL 1
+// Set it to 2 for post separate field
+
+typedef struct HARD_IVTC_PARAM
+{
+        uint32_t threshold;
+        uint32_t noise;
+        uint32_t show;
+}HARD_IVTC_PARAM;
+
+class vidHardPDRemoval:public AVDMGenericVideoStream
+{
+
+protected:
+  virtual char *printConf (void);
+  VideoCache *vidCache;
+  HARD_IVTC_PARAM *_param;
+  uint32_t              _lastRemoved;
+  ADMImage              *cand1,*cand2,*rebuild;
+public:
+
+                        vidHardPDRemoval (AVDMGenericVideoStream * in, CONFcouple * setup);
+        virtual         ~vidHardPDRemoval ();
+  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
+                                         ADMImage * data, uint32_t * flags);
+  uint8_t configure (AVDMGenericVideoStream * instream);
+  virtual uint8_t getCoupledConf (CONFcouple ** couples);
+
+};
+
+static FILTER_PARAM field_unblend_template =
+  { 3,&quot;threshold&quot;,&quot;show&quot;,&quot;noise&quot;};
+
+BUILD_CREATE (hardivtc_create, vidHardPDRemoval);
+SCRIPT_CREATE (hardivtc_script, vidHardPDRemoval, field_unblend_template);
+//*************************************
+uint8_t vidHardPDRemoval::configure (AVDMGenericVideoStream * in)
+{
+int v,w;
+        _param-&gt;show=GUI_YesNo(QT_TR_NOOP(&quot;Metrics&quot;),QT_TR_NOOP(&quot;Do you want to print metrics on screen ?&quot; ));
+        v=_param-&gt;threshold;
+        w=_param-&gt;noise;        
+        if(DIA_GetIntegerValue(&amp;v, 2, 99,&quot;Treshold&quot;,&quot;Treshold value (smaller = harder to match)&quot;))
+        {
+                if(DIA_GetIntegerValue(&amp;w, 2, 99,&quot;Noise&quot;,&quot;Noise threshold&quot;))
+                {
+                	_param-&gt;threshold=v;
+                    _param-&gt;noise=w;
+                    _lastRemoved=0xFFFF;
+                    return 1;
+                }
+        }
+        return 0;
+}
+/*************************************/
+char *vidHardPDRemoval::printConf (void)
+{
+  static char buf[50];
+  sprintf ((char *) buf, &quot; Field Unblend Thresh:%d Noise:%d&quot;,_param-&gt;threshold,_param-&gt;noise);
+  return buf;
+}
+
+#define MAX_BLOCKS 50
+/*************************************/
+vidHardPDRemoval::vidHardPDRemoval (AVDMGenericVideoStream * in, CONFcouple * couples)
+{
+
+  _in = in;
+  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
+  _info.encoding = 1;
+  vidCache = new VideoCache (10, in);
+  _uncompressed=new ADMImage(_info.width,_info.height);
+  cand1=new ADMImage(_info.width,_info.height);
+  cand2=new ADMImage(_info.width,_info.height);
+  rebuild=new ADMImage(_info.width,_info.height);
+
+ _param=new HARD_IVTC_PARAM;
+ _lastRemoved=0xFFFF;
+ if(couples)
+ {
+#undef GET
+#define GET(x) couples-&gt;getCouple(#x,&amp;(_param-&gt;x))
+      GET (threshold);
+      GET (show);
+      GET (noise);
+  }
+  else
+  {
+        _param-&gt;threshold=10;
+        _param-&gt;show=0;
+        _param-&gt;noise=5;
+  }
+}
+//____________________________________________________________________
+vidHardPDRemoval::~vidHardPDRemoval ()
+{
+
+  delete vidCache;
+  vidCache = NULL;
+  delete _uncompressed;
+  _uncompressed=NULL;
+  delete _param;
+  _param=NULL;
+  delete cand1;
+  delete cand2;
+  delete rebuild;
+  cand1=NULL;
+  cand2=NULL;
+  rebuild=NULL;
+}
+static void merge(ADMImage *src1,ADMImage *src2,ADMImage *tgt)
+{
+uint32_t ww,hh;
+uint8_t *s1,*s2,*out;
+int o;
+
+        s1=YPLANE(src1);
+        s2=YPLANE(src2);
+        out=YPLANE(tgt);
+        ww=src1-&gt;_width;
+        hh=src1-&gt;_height;
+        for(int y=0;y&lt;hh;y++)
+                for(int x=0;x&lt;ww;x++)
+                {
+                        o=*s1+*s2;
+                        o&gt;&gt;=1;
+                        *out=o;
+                        s1++;
+                        s2++;
+                        out++;
+
+                }
+
+
+
+
+}
+static float computeDiff(ADMImage *src1,ADMImage *src2,uint32_t noise)
+{
+float df=0;
+int delta;
+uint32_t ww,hh;
+uint8_t *s1,*s2;
+
+        s1=YPLANE(src1);
+        s2=YPLANE(src2);
+        ww=src1-&gt;_width;
+        hh=src1-&gt;_height;
+
+          for(int y=0;y&lt;hh;y++)
+                for(int x=0;x&lt;ww;x++)
+                {
+                        delta=abs(*s1-*s2);
+                        if(delta&gt;noise)
+                                df+=delta;
+                        s1++;
+                        s2++;
+
+                }
+        return df;
+}
+static float computeDiff2(ADMImage *src1,ADMImage *src2,ADMImage *cand)
+{
+float df=0;
+int delta;
+uint32_t ww,hh;
+uint8_t *s1,*s2,*d1;
+int a1,a2,t1;
+        s1=YPLANE(src1);
+        s2=YPLANE(src2);
+        
+        d1=YPLANE(cand);
+        ww=src1-&gt;_width;
+        hh=src1-&gt;_height;
+
+          for(int y=0;y&lt;hh;y++)
+                for(int x=0;x&lt;ww;x++)
+                {
+                        a1=*s1;
+                        a2=*s2;
+                        t1=*d1;
+                        if(a1==a2) ;
+                        else
+                        if(a1&gt;a2)
+                        {
+                                if(t1 &lt;=a1 &amp;&amp; t1&gt;=a2) df+=1;
+                                        else df-=1;
+                        }else
+                                if(t1 &lt;=a2 &amp;&amp; t1&gt;=a1) df+=1;
+                                        else df-=1;
+                        s1++;
+                        s2++;
+                        d1++;
+                }
+        return df;
+}
+
+// so srcR=2*src-srcP
+static uint8_t tinyUnblend(uint8_t *dst, uint8_t *src1, uint8_t *src2,uint32_t w, uint32_t h)
+{
+int delta;
+uint32_t ww,hh;
+uint8_t *s1,*s2,*d1;
+int a1,a2;
+        s1=src1;
+        s2=src2;
+        
+        d1=dst;
+        ww=w;
+        hh=h;
+
+          for(int y=0;y&lt;hh;y++)
+                for(int x=0;x&lt;ww;x++)
+                {
+                        a1=*s1;
+                        a2=*s2;
+                        a1=2*a1-a2;
+                        if(a1&lt;0) a1=0;
+                        if(a1&gt;255) a1=255;
+                        *d1=a1;                         
+
+                        s1++;
+                        s2++;
+                        d1++;
+                }
+        return 1;
+}
+static uint8_t tinyAverage(uint8_t *dst, uint8_t *src1, uint8_t *src2,uint32_t w, uint32_t h)
+{
+int delta;
+uint32_t ww,hh;
+uint8_t *s1,*s2,*d1;
+int a1,a2;
+        s1=src1;
+        s2=src2;
+        
+        d1=dst;
+        ww=w;
+        hh=h;
+
+          for(int y=0;y&lt;hh;y++)
+                for(int x=0;x&lt;ww;x++)
+                {
+                        a1=*s1;
+                        a2=*s2;
+                        a1=a1+a2;
+                        a1&gt;&gt;=1;
+                        if(a1&lt;0) a1=0;
+                        if(a1&gt;255) a1=255;
+                        *d1=a1;                         
+
+                        s1++;
+                        s2++;
+                        d1++;
+                }
+        return 1;
+}
+
+/*
+
+                src=blend of srcP and R         =&gt; src= 1/2(srcP+R)
+                                                   2*src-srcP=R
+
+                srcN=blend of srcNN and R       =&gt; srcN=1/2 (srcNN+R)
+                                                        2*srcN-srcNN=R
+
+*/
+
+static uint8_t tinyRestore(uint8_t *dst, uint8_t *srcP, uint8_t *src,uint8_t *srcN,uint8_t *srcNN,uint32_t w, uint32_t h)
+{
+
+
+uint8_t *s,*sp,*sn,*snn,*d1;
+int a1,a2,a3,a4,sum,delta;
+
+        sp=srcP;
+        s=src;
+        sn=srcN;
+        snn=srcNN;
+        
+        d1=dst;
+
+          for(int y=0;y&lt;h;y++)
+                for(int x=0;x&lt;w;x++)
+                {
+                        a1=*sp;
+                        a2=*s;
+                        a3=*sn;
+                        a4=*snn;
+
+                        sum=2*a2+2*a3-a1-a4;
+                        sum=sum/2;
+                        
+                        a1=sum;                        
+
+                        if(a1&lt;0) a1=0;
+                        if(a1&gt;255) a1=255;
+                        *d1=a1;
+
+                        s++;
+                        sp++;
+                        sn++;
+                        snn++;
+                        d1++;
+                }
+        return 1;
+}
+
+static uint8_t    unblend(ADMImage *tgt,ADMImage *src,ADMImage *srcP)
+{
+int delta;
+uint32_t ww,hh;
+uint8_t *s1,*s2,*d1;
+int a1,a2,t1;
+
+        tinyUnblend(YPLANE(tgt),YPLANE(src),YPLANE(srcP),tgt-&gt;_width,tgt-&gt;_height);
+        tinyUnblend(UPLANE(tgt),UPLANE(src),UPLANE(srcP),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
+        tinyUnblend(VPLANE(tgt),VPLANE(src),VPLANE(srcP),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
+        return 1;
+
+
+}
+static uint8_t    averageF(ADMImage *tgt,ADMImage *src,ADMImage *srcP)
+{
+int delta;
+uint32_t ww,hh;
+uint8_t *s1,*s2,*d1;
+int a1,a2,t1;
+
+        tinyAverage(YPLANE(tgt),YPLANE(src),YPLANE(srcP),tgt-&gt;_width,tgt-&gt;_height);
+        tinyAverage(UPLANE(tgt),UPLANE(src),UPLANE(srcP),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
+        tinyAverage(VPLANE(tgt),VPLANE(src),VPLANE(srcP),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
+        return 1;
+
+
+}
+static uint8_t    restore(ADMImage *tgt,ADMImage *srcP,ADMImage *src,ADMImage *srcN,ADMImage *srcNN)
+{
+int delta;
+uint32_t ww,hh;
+uint8_t *s1,*s2,*d1;
+int a1,a2,t1;
+
+        tinyRestore(YPLANE(tgt),YPLANE(srcP),YPLANE(src),YPLANE(srcN),YPLANE(srcNN),tgt-&gt;_width,tgt-&gt;_height);
+        tinyRestore(UPLANE(tgt),UPLANE(srcP),UPLANE(src),UPLANE(srcN),UPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
+        tinyRestore(VPLANE(tgt),VPLANE(srcP),VPLANE(src),VPLANE(srcN),VPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
+        return 1;
+
+
+}
+
+uint8_t vidHardPDRemoval::getFrameNumberNoAlloc (uint32_t inframe,
+                                uint32_t * len,
+                                ADMImage * data, uint32_t * flags)
+{
+
+	
+	ADMImage *srcP,*srcN,*srcNN,*src,*final,*display;
+        float distMerged, distN,distP,distM,distR;
+        char txt[255];
+        if(inframe&gt;= _info.nb_frames) return 0;
+        if(inframe&lt;1 || inframe&gt;inframe&gt;_info.nb_frames-2 )
+        {
+                data-&gt;duplicate(vidCache-&gt;getImage(inframe));
+                vidCache-&gt;unlockAll();
+                return 1;
+        }
+        if(_lastRemoved==inframe-1)
+        {
+                data-&gt;duplicate(rebuild);
+                if(_param-&gt;show&amp;&amp;inframe)
+                {
+                        sprintf(txt,&quot; Telecined 2&quot;);
+                        drawString(data,2,4,txt);
+                }
+                
+                return 1;
+        }
+
+        data-&gt;duplicate(rebuild);
+
+        srcP=vidCache-&gt;getImage(inframe-1);
+        src=vidCache-&gt;getImage(inframe);
+        srcN=vidCache-&gt;getImage(inframe+1);
+        srcNN=vidCache-&gt;getImage(inframe+2);
+        
+        // Let's rebuild the pseudo R, where we have A AR RB B
+        // If then we got R1 very close to R2, and that AR is very close to src
+        // Decide it is hard telecined (frame blending)
+#if 1
+       restore(rebuild,srcP,src,srcN,srcNN);
+#else
+        unblend(cand1,src,srcP);
+        unblend(cand2,srcN,srcNN);
+        averageF(rebuild,cand1,cand2);
+#endif  
+#if 0
+        data-&gt;duplicate(rebuild);
+        vidCache-&gt;unlockAll();
+        return 1;
+#endif
+
+        // And remerge...
+        averageF(cand1,srcP,rebuild);
+        averageF(cand2,srcNN,rebuild);
+        
+        distP=computeDiff(cand1,src,_param-&gt;noise);
+        distN=computeDiff(cand2,srcN,_param-&gt;noise);
+        distM=computeDiff(src,srcP,_param-&gt;noise);
+        distR=computeDiff(src,srcN,_param-&gt;noise);
+        
+        
+        
+        double medium;
+
+         if(distM&gt;1&amp;&amp;distR&gt;1)
+        {
+                if(distM&gt;distR) medium=distR;
+                          else  medium=distM;
+                  //medium=min(distM,distR);
+                 
+                 medium/=100;
+                 distN/=medium;
+                 distP/=medium;
+                 distR/=medium;
+         
+         }
+
+        medium=medium/(_info.width*_info.height);
+        double mn;
+
+        if(inframe == _lastRemoved+5)
+        {
+                distN=(distN*7)/10;
+                distP=(distP*7)/10;
+                
+        }
+                //data-&gt;duplicate(src); 
+        if(distN&lt;_param-&gt;threshold &amp;&amp; distP&lt;_param-&gt;threshold)
+        {
+                data-&gt;duplicate(rebuild);
+                _lastRemoved=inframe;
+                if(_param-&gt;show &amp;&amp; inframe == _lastRemoved+5)
+                {
+                        sprintf(txt,&quot; Fav&quot;);
+                        drawString(data,2,5,txt);      
+                }
+        }
+        else
+                data-&gt;duplicate(src);
+        if(_param-&gt;show)
+        {
+                display=data;
+
+                sprintf(txt,&quot; N %02.1f&quot;,distN);
+                drawString(display,2,0,txt);
+
+                sprintf(txt,&quot; P %02.1f&quot;,distP);
+                drawString(display,2,1,txt);
+
+                sprintf(txt,&quot; R %02.1f&quot;,distR);
+                drawString(display,2,2,txt);
+
+
+                if(_lastRemoved==inframe)
+                {
+                        sprintf(txt,&quot; Telecined 1&quot;,distP);
+                        drawString(display,2,4,txt);
+                }
+        }
+
+
+          
+        vidCache-&gt;unlockAll();
+	return 1;
+}
+uint8_t vidHardPDRemoval::getCoupledConf (CONFcouple ** couples)
+{
+
+  ADM_assert (_param);
+  *couples = new CONFcouple (3);
+#undef CSET
+#define CSET(x)  (*couples)-&gt;setCouple(#x,(_param-&gt;x))
+  CSET (threshold);
+  CSET (show);
+  CSET (noise);
+  
+  return 1;
+}
+
+
+//EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/ADM_vidColorYuv.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/ADM_vidColorYuv.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,537 @@
+
+/***************************************************************************
+    Port of ColorYuv from avisynth to avidemux by mean
+ ***************************************************************************/
+ // Avisynth v2.5.  Copyright 2002 Ben Rudiak-Gould et al.
+// <A HREF="http://www.avisynth.org">http://www.avisynth.org</A>
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit
+// <A HREF="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</A> .
+//
+// Linking Avisynth statically or dynamically with other modules is making a
+// combined work based on Avisynth.  Thus, the terms and conditions of the GNU
+// General Public License cover the whole combination.
+//
+// As a special exception, the copyright holders of Avisynth give you
+// permission to link Avisynth with independent modules that communicate with
+// Avisynth solely through the interfaces defined in avisynth.h, regardless of the license
+// terms of these independent modules, and to copy and distribute the
+// resulting combined work under terms of your choice, provided that
+// every copy of the combined work is accompanied by a complete copy of
+// the source code of Avisynth (the version of Avisynth used to produce the
+// combined work), being distributed under the terms of the GNU General
+// Public License plus this exception.  An independent module is a module
+// which is not derived from or based on Avisynth, such as 3rd-party filters,
+// import and export plugins, or graphical user interfaces.
+
+ /***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;ADM_vidColorYuv.h&quot;
+
+
+extern int DIA_coloryuv(COLOR_YUV_PARAM *param);
+
+static FILTER_PARAM coloryuv_template={19,
+    {&quot;y_contrast&quot;,&quot;y_bright&quot;,&quot;y_gamma&quot;,&quot;y_gain&quot;,
+    &quot;u_contrast&quot;,&quot;u_bright&quot;,&quot;u_gamma&quot;,&quot;u_gain&quot;,
+    &quot;v_contrast&quot;,&quot;v_bright&quot;,&quot;v_gamma&quot;,&quot;v_gain&quot;,
+    &quot;matrix&quot;,&quot;levels&quot;,&quot;opt&quot;,
+    &quot;colorbars&quot;,&quot;analyze&quot;,&quot;autowhite&quot;,&quot;autogain&quot;,
+    }};
+//REGISTERX(VF_COLORS, &quot;coloryuv&quot;,QT_TR_NOOP(&quot;Avisynth ColorYUV&quot;),QT_TR_NOOP
+//    (&quot;Alter colors (auto white balance etc...). Ported from Avisynth.&quot;),VF_COLOR_YUV,1,coloryuv_create,coloryuv_script);
+
+//******************************************
+VF_DEFINE_FILTER(ADMVideoColorYuv,coloryuv_template,
+                coloryuv,
+                QT_TR_NOOP(&quot;Avisynth ColorYUV&quot;),
+                1,
+                VF_COLORS,
+                QT_TR_NOOP(&quot;Alter colors (auto white balance etc...). Ported from Avisynth.&quot;));
+
+//******************************************
+uint8_t ADMVideoColorYuv::configure(AVDMGenericVideoStream *in)
+{
+
+   _in=in;
+   if(DIA_coloryuv(_param))
+   {
+       MakeGammaLUT();
+       return 1;
+   }
+   return 0;
+}
+
+char *ADMVideoColorYuv::printConf( void )
+{
+   static char buf[50];
+   sprintf((char *)buf,&quot; ColorYuv &quot;);
+   return buf;
+}
+
+ADMVideoColorYuv::ADMVideoColorYuv(AVDMGenericVideoStream *in,CONFcouple *couples) 
+{
+   _in=in;
+   memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+   _info.encoding=1;
+   _uncompressed=NULL;
+   _param=NEW(COLOR_YUV_PARAM);
+   if(couples)
+   {
+       double y_contrast, y_bright, y_gamma, y_gain;
+       double u_contrast, u_bright, u_gamma, u_gain;
+       double v_contrast, v_bright, v_gamma, v_gain;
+       int32_t matrix, levels, opt;
+       uint32_t colorbars, analyze, autowhite, autogain;
+       GET(y_contrast);
+       GET(y_bright);
+       GET(y_gamma);
+       GET(y_gain); 
+       
+       GET(u_contrast);
+       GET(u_bright);
+       GET(u_gamma);
+       GET(u_gain); 
+       
+       GET(v_contrast);
+       GET(v_bright);
+       GET(v_gamma);
+       GET(v_gain); 
+       
+       GET(matrix);
+       GET(levels);
+       GET(opt); 
+       
+       GET(colorbars);
+       GET(analyze);
+       GET(autowhite); 
+       GET(autogain); 
+       
+       
+   }
+   else // Default
+   {
+#define MKP(x,y) _param-&gt;x=y;
+            MKP(y_contrast,0);
+            MKP(y_bright,0);
+            MKP(y_gamma,0);
+            MKP(y_gain,0);
+
+            MKP(u_contrast,0);
+            MKP(u_bright,0);
+            MKP(u_gamma,0);
+            MKP(u_gain,0);
+
+            MKP(v_contrast,0);
+            MKP(v_bright,0);
+            MKP(v_gamma,0);
+            MKP(v_gain,0);
+            
+            MKP(matrix,0);
+            MKP(levels,0);
+            MKP(opt,0); 
+       
+            MKP(colorbars,0);
+            MKP(analyze,1);
+            MKP(autowhite,1); 
+            MKP(autogain,0); 
+
+            
+            
+   }
+   MakeGammaLUT();
+}
+//____________________________________________________________________
+ADMVideoColorYuv::~ADMVideoColorYuv()
+{
+   delete _param;
+   _param=NULL;
+   _uncompressed=NULL;
+}
+#define BYTE uint8_t 
+#ifndef MAX
+#define MAX(x,y) ((x)&gt;(y) ?(x):(y))
+#endif
+#ifndef MIN
+#define MIN(x,y) ((x)&lt;(y) ?(x):(y))
+#endif
+//______________________________________________________________
+uint8_t ADMVideoColorYuv::getFrameNumberNoAlloc(uint32_t frame,
+  uint32_t *len,
+  ADMImage *data,
+  uint32_t *flags)
+  {
+      uint32_t page=_info.width*_info.height,pitch;
+      if(frame&gt;_info.nb_frames-1) return 0;
+      
+      if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) 
+      {
+          printf(&quot;ColorYuv : Cannot read cache for frame %u\n&quot;,frame);
+          return 0;
+      }
+      
+      ADMImage *mysrc=NULL;
+      mysrc=data;
+      
+      //*************************************************
+      int i,j,wby4;
+      int modulo,w,h;
+//	int dmodulo;
+      //PIXELDATA	pixel;
+
+      pitch = mysrc-&gt;GetPitch(PLANAR_Y);
+      w = mysrc-&gt;GetRowSize(PLANAR_Y);
+      h = mysrc-&gt;GetHeight(PLANAR_Y);
+  wby4 = w / 4;
+  modulo = pitch - w;
+//	dst = env-&gt;NewVideoFrame(vi);
+//	dstp = (unsigned long *) dst-&gt;GetWritePtr();
+//	dpitch = dst-&gt;GetPitch();
+//	dmodulo = dpitch - dst-&gt;GetRowSize();
+  if (_param-&gt;analyze||_param-&gt;autowhite||_param-&gt;autogain) {
+      for (i=0;i&lt;256;i++) {
+          accum_Y[i]=0;
+          accum_U[i]=0;
+          accum_V[i]=0;
+      }
+      int uvdiv=1;  //UV divider (ratio between Y and UV pixels)
+     {
+          uvdiv=4;
+          BYTE* srcp2 = (BYTE*) mysrc-&gt;GetReadPtr(PLANAR_Y);
+          for (int y=0;y&lt;h;y++) {
+              for (int x=0;x&lt;w;x++) {
+                  accum_Y[srcp2[x]]++;
+              }
+              srcp2+=pitch;
+          }
+          pitch = mysrc-&gt;GetPitch(PLANAR_U);
+          srcp2 = (BYTE*) mysrc-&gt;GetReadPtr(PLANAR_U);
+          for (int y=0;y&lt;h/2;y++) {
+              for (int x=0;x&lt;w/2;x++) {
+                  accum_U[srcp2[x]]++;
+              }
+              srcp2+=pitch;
+          }
+          srcp2 = (BYTE*) mysrc-&gt;GetReadPtr(PLANAR_V);
+          for (int y=0;y&lt;h/2;y++) {
+              for (int x=0;x&lt;w/2;x++) {
+                  accum_V[srcp2[x]]++;
+              }
+              srcp2+=pitch;
+          }
+          pitch = mysrc-&gt;GetPitch(PLANAR_Y);
+      } 
+      int pixels = _info.width*_info.height;
+      float avg_u=0, avg_v=0, avg_y=0;
+      int min_u=0, min_v=0, min_y=0;
+      int max_u=0, max_v=0, max_y=0;
+      bool hit_y=false,hit_u=false,hit_v=false;
+      int Amin_u=0, Amin_v=0, Amin_y=0;
+      int Amax_u=0, Amax_v=0, Amax_y=0;
+      bool Ahit_miny=false,Ahit_minu=false,Ahit_minv=false;
+      bool Ahit_maxy=false,Ahit_maxu=false,Ahit_maxv=false;
+      int At_y2=(pixels/256); // When 1/256th of all pixels have been reached, trigger &quot;Loose min/max&quot;
+      int At_uv2=(pixels/1024); 
+   
+      for (i=0;i&lt;256;i++) {
+          avg_y+=(float)accum_Y[i]*(float)i;
+          avg_u+=(float)accum_U[i]*(float)i;
+          avg_v+=(float)accum_V[i]*(float)i;
+          if (accum_Y[i]!=0) {max_y=i;hit_y=true;} else {if (!hit_y) min_y=i+1;} 
+          if (accum_U[i]!=0) {max_u=i;hit_u=true;} else {if (!hit_u) min_u=i+1;} 
+          if (accum_V[i]!=0) {max_v=i;hit_v=true;} else {if (!hit_v) min_v=i+1;} 
+
+          if (!Ahit_miny) {Amin_y+=accum_Y[i]; if (Amin_y&gt;At_y2){Ahit_miny=true; Amin_y=i;} }
+          if (!Ahit_minu) {Amin_u+=accum_U[i]; if (Amin_u&gt;At_uv2){Ahit_minu=true; Amin_u=i;} }
+          if (!Ahit_minv) {Amin_v+=accum_V[i]; if (Amin_v&gt;At_uv2){Ahit_minv=true; Amin_v=i;} }
+
+          if (!Ahit_maxy) {Amax_y+=accum_Y[255-i]; if (Amax_y&gt;At_y2){Ahit_maxy=true; Amax_y=255-i;} }
+          if (!Ahit_maxu) {Amax_u+=accum_U[255-i]; if (Amax_u&gt;At_uv2){Ahit_maxu=true; Amax_u=255-i;} }
+          if (!Ahit_maxv) {Amax_v+=accum_V[255-i]; if (Amax_v&gt;At_uv2){Ahit_maxv=true; Amax_v=255-i;} }
+      }
+
+      float Favg_y=avg_y/(float)pixels;
+      float Favg_u=(avg_u*(float)uvdiv)/(float)pixels;
+      float Favg_v=(avg_v*(float)uvdiv)/(float)pixels;
+      if (_param-&gt;analyze) {
+          char text[400];
+          sprintf(text,   &quot;Frame  : %-8u ( Y /ChrU/ChrV )\n&quot;,frame);
+          drawString(mysrc, 0, 5, text);
+          
+          sprintf(text,   &quot;Avr:( %3.2f / %3.2f / %3.2f )&quot;,Favg_y,Favg_u,Favg_v);
+          drawString(mysrc, 0, 6, text);
+          
+          sprintf(text,   &quot;Minimum:  ( %3d / %3d / %3d )\n&quot;,
+                  min_y,min_u,min_v);
+          drawString(mysrc, 0, 7, text);                          
+          sprintf(text,   &quot;Maximum:  ( %3d / %3d / %3d )\n&quot;,
+                  max_y,max_u,max_v);
+          drawString(mysrc, 0, 8, text);
+          
+          sprintf(text,   &quot;LooseMin  ( %3d / %3d / %3d )\n&quot;,
+                  Amin_y,Amin_u,Amin_v);
+          drawString(mysrc, 0, 9, text);
+          
+          sprintf(text,   &quot;Loose Max:( %3d / %3d / %3d )\n&quot;,
+                  Amax_y,Amax_u,Amax_v);
+          drawString(mysrc, 0, 10, text);
+          if (!(_param-&gt;autowhite||_param-&gt;autogain)) {
+              return 1;
+          }
+      }
+      if (_param-&gt;autowhite) {
+          _param-&gt;u_bright=127-(int)Favg_u;
+          _param-&gt;v_bright=127-(int)Favg_v;
+      }
+      if (_param-&gt;autogain) {
+          Amax_y=MIN(Amax_y,236);
+          Amin_y=MAX(Amin_y,16);  // Never scale above luma range!
+          if (Amin_y!=Amax_y) {
+              int y_range = Amax_y-Amin_y;
+              double scale = (220.0 / y_range);
+              _param-&gt;y_gain = (int) (256.0 * scale)-256;
+              _param-&gt;y_bright = -(int)(scale * (double)(Amin_y)-16);
+          }
+      }
+      MakeGammaLUT();
+  }
+
+  {
+      BYTE* srcp2 = (BYTE*) mysrc-&gt;data;
+      for (j = 0; j &lt; h; j++) {
+          for (i=0; i&lt;w; i++) {
+              srcp2[i]=LUT_Y[srcp2[i]];
+          }
+          srcp2 +=  pitch;
+      }
+      srcp2 = (BYTE*) mysrc-&gt;GetWritePtr(PLANAR_U);
+      h=mysrc-&gt;GetHeight(PLANAR_U);
+      w=mysrc-&gt;GetRowSize(PLANAR_U);
+      pitch=mysrc-&gt;GetPitch(PLANAR_U);
+      for (j = 0; j &lt; h; j++) {
+          for (i=0; i&lt;w; i++) {
+              srcp2[i]=LUT_U[srcp2[i]];
+          }
+          srcp2 +=  pitch;
+      }
+      srcp2 = (BYTE*) mysrc-&gt;GetWritePtr(PLANAR_V);
+      for (j = 0; j &lt; h; j++) {
+          for (i=0; i&lt;w; i++) {
+              srcp2[i]=LUT_V[srcp2[i]];
+          }
+          srcp2 +=  pitch;
+      }
+  }
+
+
+	return 1;
+
+}
+
+
+uint8_t	ADMVideoColorYuv::getCoupledConf( CONFcouple **couples)
+{
+   
+      ADM_assert(_param);
+      *couples=new CONFcouple(19);
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+       CSET(y_contrast);
+       CSET(y_bright);
+       CSET(y_gamma);
+       CSET(y_gain); 
+       
+       CSET(u_contrast);
+       CSET(u_bright);
+       CSET(u_gamma);
+       CSET(u_gain); 
+       
+       CSET(v_contrast);
+       CSET(v_bright);
+       CSET(v_gamma);
+       CSET(v_gain); 
+       
+       CSET(matrix);
+       CSET(levels);
+       CSET(opt); 
+       
+       CSET(colorbars);
+       CSET(analyze);
+       CSET(autowhite); 
+       CSET(autogain); 
+   
+      return 1;
+}
+
+
+void ADMVideoColorYuv::MakeGammaLUT(void)
+{
+    static const int scale = 256, shift = 2^10,
+    coeff_y0 =  76309, coeff_y1 =  65536,
+    coeff_u0 = 132201, coeff_u1 = 116129,
+    coeff_v0 = 104597, coeff_v1 =  91881;
+    int i;
+    int val;
+    double g,b,c,gain;
+    double v;
+
+    y_thresh1 = u_thresh1 = v_thresh1 = -1;
+    y_thresh2 = u_thresh2 = v_thresh2 = 256;
+
+    gain = ((double)_param-&gt;y_gain + scale) / scale;
+    c = ((double)_param-&gt;y_contrast + scale) / scale;
+    b = ((double)_param-&gt;y_bright + scale) / scale;
+    g = ((double)_param-&gt;y_gamma + scale) / scale;
+    if (g &lt; 0.01)    g = 0.01;
+    for (i = 0; i &lt; 256; i++)
+    {
+        val = i * shift;
+        switch (_param-&gt;levels) {
+            case 1:	// PC-&gt;TV
+                val = (int)((val - 16 * shift) * coeff_y0 / coeff_y1 + shift / 2);
+                break;
+                case 2:	// TV-&gt;PC
+                    case 3:	// TV-&gt;PC.Y
+                        val = (int)(val * coeff_y1 / coeff_y0 + 16 * shift + shift / 2);
+                        break;
+                        default:	//none
+                            break;
+        }
+        val = val / shift;
+
+        v = ((double)val) / 256;
+        v = (v * gain) + ((v-0.5) * c + 0.5) - v + (b - 1);
+
+        if (_param-&gt;y_gamma != 0 &amp;&amp; v &gt; 0)
+            v = pow( v, 1 / g);
+        v = v * 256;
+		
+        v += 0.5;
+        val = (int)floor(v);
+
+        if (val &gt; 255)
+            val = 255;
+        else if (val &lt; 0)
+            val = 0;
+
+        if (val &gt; 235) {
+            if(y_thresh2 &gt; 255)		y_thresh2 = i;
+            if(_param-&gt;opt)		val = 235;
+        }
+        else if (val &lt; 16) {
+            y_thresh1 = i;
+            if(_param-&gt;opt)		val = 16;
+        }
+        LUT_Y[i] = (unsigned char)val;
+    }
+
+    gain = ((double)_param-&gt;u_gain + scale);
+    c = ((double)_param-&gt;u_contrast + scale);
+    b = ((double)_param-&gt;u_bright);
+    for (i = 0; i &lt; 256; i++)
+    {
+        val = i * shift;
+        switch (_param-&gt;levels) {
+            case 1:	// PC-&gt;TV Scale
+                val = (int)((val - 128 * shift) * coeff_u0 / coeff_u1 + 128 * shift + shift / 2);
+                break;
+                case 2:	// TV-&gt;PC Scale
+                    val = (int)((val - 128 * shift) * coeff_u1 / coeff_u0 + 128 * shift + shift / 2);
+                    break;
+                    default:	//none
+                        break;
+        }
+        val = val / shift;
+
+        v = ((double)val);
+        v = (v * gain / scale) + ((v-128) * c / scale + 128) - v + b;
+
+        v += 0.5;
+        val = (int)floor(v);
+		
+        if (val &gt; 255)
+            val = 255;
+        else if (val &lt; 0)
+            val = 0;
+
+        if (val &gt; 240) {
+            if(u_thresh2 &gt; 255)		u_thresh2 = i;
+            if(_param-&gt;opt)		val = 240;
+        }
+        else if (val &lt; 16) {
+            u_thresh1 = i;
+            if(_param-&gt;opt)		val = 16;
+        }
+        LUT_U[i] = (unsigned char)val;
+    }
+
+    gain = ((double)_param-&gt;v_gain + scale);
+    c = ((double)_param-&gt;v_contrast + scale);
+    b = ((double)_param-&gt;v_bright);
+    for (i = 0; i &lt; 256; i++)
+    {
+        val = i * shift;
+        switch (_param-&gt;levels) {
+            case 1:	// PC-&gt;TV Scale
+                val = (int)((val - 128 * shift) * coeff_v0 / coeff_v1 + 128 * shift + shift / 2);
+                break;
+                case 2:	// TV-&gt;PC Scale
+                    val = (int)((val - 128 * shift) * coeff_v1 / coeff_v0 + 128 * shift + shift / 2);
+                    break;
+                    default:	//none
+                        break;
+        }
+        val = val / shift;
+
+        v = ((double)val);
+        v = (v * gain / scale) + ((v-128) * c / scale + 128) - v + b;
+
+        v += 0.5;
+        val = (int)floor(v);
+		
+        if (val &gt; 255)
+            val = 255;
+        else if (val &lt; 0)
+            val = 0;
+		
+        if (val &gt; 240) {
+            if(v_thresh2 &gt; 255)		v_thresh2 = i;
+            if(_param-&gt;opt)		val = 240;
+        }
+        else if (val &lt; 16) {
+            v_thresh1 = i;
+            if(_param-&gt;opt)		val = 16;
+        }
+        LUT_V[i] = (unsigned char)val;
+    }
+
+#ifdef _DEBUG
+	DumpLUT();
+#endif
+
+}
+
+
+
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/ADM_vidColorYuv.h (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/ADM_vidColorYuv.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,45 @@
+/***************************************************************************
+                          Port of avisynth ColorYuv Filter
+    copyright            : (C) 2006 by mean
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_VID_COLOR_YUV_H
+#define ADM_VID_COLOR_YUV_H
+#include &quot;ADM_vidColorYuv_param.h&quot;
+class  ADMVideoColorYuv:public AVDMGenericVideoStream
+{
+
+    protected:
+
+        virtual char    *printConf(void) ;
+        COLOR_YUV_PARAM *_param;
+        
+        void            MakeGammaLUT(void);
+        
+        uint8_t      LUT_Y[256],LUT_U[256],LUT_V[256];
+        uint32_t     accum_Y[256],accum_U[256],accum_V[256];
+        int32_t      y_thresh1, y_thresh2, u_thresh1, u_thresh2, v_thresh1, v_thresh2;
+        int32_t      last_y_offset;
+
+        
+    public:
+ 					
+        ADMVideoColorYuv(  AVDMGenericVideoStream *in,CONFcouple *setup);
+        ~ADMVideoColorYuv();
+        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                ADMImage *data,uint32_t *flags);
+
+        virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
+        virtual uint8_t getCoupledConf( CONFcouple **couples);
+
+}     ;
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/ADM_vidColorYuv_param.h (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidColorYuv_param.h	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/ADM_vidColorYuv_param.h	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,36 @@
+/***************************************************************************
+                          Port of avisynth ColorYuv Filter
+    copyright            : (C) 2006 by mean
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef ADM_VID_COLOR_YUV_PARAM_H
+#define ADM_VID_COLOR_YUV_PARAM_H
+typedef struct COLOR_YUV_PARAM
+{
+    double y_contrast, y_bright, y_gamma, y_gain;
+    double u_contrast, u_bright, u_gamma, u_gain;
+    double v_contrast, v_bright, v_gamma, v_gain;
+    int32_t matrix, levels, opt;
+    uint32_t colorbars, analyze, autowhite, autogain;
+
+}COLOR_YUV_PARAM;
+
+/*
+matrix : 0 : none   1: rec.709
+Level :  0 : none   1:&quot;TV-&gt;PC&quot;, 2:&quot;PC-&gt;TV&quot;, 3:&quot;PC-&gt;TV.Y&quot; 
+Opt :    0 : none   1: Coring
+
+
+
+*/
+
+#endif

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/CMakeLists.txt	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/CMakeLists.txt	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,14 @@
+INCLUDE(vf_plugin)
+
+
+SET(colorYUVCommon_SRCS 
+ADM_vidColorYuv.cpp
+)
+
+INCLUDE(vf_plugin_gtk)
+
+SET(colorYUVGtk_SRCS gtk/DIA_coloryuv.cpp)
+
+INIT_VIDEOFILTER_PLUGIN_GTK(  ADM_vf_colorYUV_gtk 
+                ${colorYUVGtk_SRCS} ${colorYUVCommon_SRCS})
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/gtk/DIA_coloryuv.cpp (from rev 4045, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_coloryuv.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_coloryuv.cpp	2008-05-19 16:06:20 UTC (rev 4045)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/colorYUV/gtk/DIA_coloryuv.cpp	2008-05-19 18:22:05 UTC (rev 4046)
@@ -0,0 +1,463 @@
+/*
+ * DO NOT EDIT THIS FILE - it is generated by Glade.
+ */
+
+#include &quot;ADM_toolkitGtk.h&quot;
+#include &quot;ADM_vidColorYuv_param.h&quot;
+
+static GtkWidget    *        create_dialog1 (void);
+
+#define COMBO_SET(x,y) {gtk_combo_box_set_active(GTK_COMBO_BOX(WID(combobox##x)),param-&gt;y);}
+#define COMBO_GET(x,y) {param-&gt;y=gtk_combo_box_get_active(GTK_COMBO_BOX(WID(combobox##x)));}
+
+#define CHECK_GET(x,y) {param-&gt;y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
+#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param-&gt;y);}	
+
+#define SPIN_GET(x,y) {param-&gt;y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;}
+#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)param-&gt;y) ;}
+
+#define DO_LUMA(x,y) { SPIN(spinbuttonL##x,y_##y);}
+#define DO_CHROU(x,y) { SPIN(spinbuttonU##x,u_##y);}
+#define DO_CHROV(x,y) { SPIN(spinbuttonV##x,v_##y);}
+
+#define DO_ONE(x,y)   {DO_LUMA(x,y);\
+                        DO_CHROU(x,y)\
+                        DO_CHROV(x,y);}
+
+#define DO_ALL() DO_ONE(C,contrast) ;\
+                 DO_ONE(B,bright) ;\
+                 DO_ONE(G,gamma) ;\
+                 DO_ONE(N,gain)
+
+int DIA_coloryuv(COLOR_YUV_PARAM *param)
+{
+    GtkWidget *dialog;
+    int ret=0;
+
+    dialog=create_dialog1();
+    gtk_register_dialog(dialog);
+    
+    COMBO_SET(Matrix,matrix);
+    COMBO_SET(3,levels);
+    COMBO_SET(2,opt);
+        
+    CHECK_SET(checkbuttonAnalyze,analyze);
+    CHECK_SET(checkbuttonAutoGain,autogain);
+    CHECK_SET(checkbuttonAutoWhite,autowhite);
+    
+#define SPIN SPIN_SET
+    DO_ALL();
+    
+    if(GTK_RESPONSE_OK==gtk_dialog_run(GTK_DIALOG(dialog)))			
+    {
+        COMBO_GET(Matrix,matrix);
+        COMBO_GET(3,levels);
+        COMBO_GET(2,opt);
+        
+        CHECK_GET(checkbuttonAnalyze,analyze);
+        CHECK_GET(checkbuttonAutoGain,autogain);
+        CHECK_GET(checkbuttonAutoWhite,autowhite);
+        
+#undef SPIN
+#define SPIN SPIN_GET
+        DO_ALL();
+
+        ret=1;
+    }
+    gtk_unregister_dialog(dialog);
+    gtk_widget_destroy(dialog);
+    return ret;	    
+
+}
+GtkWidget*
+        create_dialog1 (void)
+{
+    GtkWidget *dialog1;
+    GtkWidget *dialog_vbox1;
+    GtkWidget *vbox1;
+    GtkWidget *frame1;
+    GtkWidget *alignment1;
+    GtkWidget *table1;
+    GtkWidget *label2;
+    GtkWidget *label3;
+    GtkWidget *label4;
+    GtkWidget *label5;
+    GtkWidget *label6;
+    GtkWidget *label7;
+    GtkWidget *label8;
+    GtkObject *spinbuttonUC_adj;
+    GtkWidget *spinbuttonUC;
+    GtkObject *spinbuttonVC_adj;
+    GtkWidget *spinbuttonVC;
+    GtkObject *spinbuttonLB_adj;
+    GtkWidget *spinbuttonLB;
+    GtkObject *spinbuttonUB_adj;
+    GtkWidget *spinbuttonUB;
+    GtkObject *spinbuttonVB_adj;
+    GtkWidget *spinbuttonVB;
+    GtkObject *spinbuttonUG_adj;
+    GtkWidget *spinbuttonUG;
+    GtkObject *spinbuttonVG_adj;
+    GtkWidget *spinbuttonVG;
+    GtkObject *spinbuttonLN_adj;
+    GtkWidget *spinbuttonLN;
+    GtkObject *spinbuttonUN_adj;
+    GtkWidget *spinbuttonUN;
+    GtkObject *spinbuttonVN_adj;
+    GtkWidget *spinbuttonVN;
+    GtkObject *spinbutton23_adj;
+    GtkWidget *spinbutton23;
+    GtkObject *spinbutton24_adj;
+    GtkWidget *spinbutton24;
+    GtkWidget *Color_Correction;
+    GtkWidget *Settings;
+    GtkWidget *alignment2;
+    GtkWidget *hbox1;
+    GtkWidget *table2;
+    GtkWidget *label10;
+    GtkWidget *label11;
+    GtkWidget *label12;
+    GtkWidget *comboboxMatrix;
+    GtkWidget *combobox2;
+    GtkWidget *combobox3;
+    GtkWidget *vbox2;
+    GtkWidget *label13;
+    GtkWidget *checkbuttonAutoGain;
+    GtkWidget *checkbuttonAnalyze;
+    GtkWidget *checkbuttonAutoWhite;
+    GtkWidget *label9;
+    GtkWidget *dialog_action_area1;
+    GtkWidget *cancelbutton1;
+    GtkWidget *okbutton1;
+
+    dialog1 = gtk_dialog_new ();
+    gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;ColorYuv (From avisynth)&quot;));
+    gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
+
+    dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
+    gtk_widget_show (dialog_vbox1);
+
+    vbox1 = gtk_vbox_new (FALSE, 0);
+    gtk_widget_show (vbox1);
+    gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
+
+    frame1 = gtk_frame_new (NULL);
+    gtk_widget_show (frame1);
+    gtk_box_pack_start (GTK_BOX (vbox1), frame1, TRUE, TRUE, 0);
+    gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_NONE);
+
+    alignment1 = gtk_alignment_new (0.5, 0.5, 1, 1);
+    gtk_widget_show (alignment1);
+    gtk_container_add (GTK_CONTAINER (frame1), alignment1);
+    gtk_alignment_set_padding (GTK_ALIGNMENT (alignment1), 0, 0, 12, 0);
+
+    table1 = gtk_table_new (4, 5, FALSE);
+    gtk_widget_show (table1);
+    gtk_container_add (GTK_CONTAINER (alignment1), table1);
+
+    label2 = gtk_label_new (QT_TR_NOOP(&quot;Contrast&quot;));
+    gtk_widget_show (label2);
+    gtk_table_attach (GTK_TABLE (table1), label2, 1, 2, 0, 1,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
+
+    label3 = gtk_label_new (QT_TR_NOOP(&quot;Brightness&quot;));
+    gtk_widget_show (label3);
+    gtk_table_attach (GTK_TABLE (table1), label3, 2, 3, 0, 1,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
+
+    label4 = gtk_label_new (QT_TR_NOOP(&quot;Gamma&quot;));
+    gtk_widget_show (label4);
+    gtk_table_attach (GTK_TABLE (table1), label4, 3, 4, 0, 1,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
+
+    label5 = gtk_label_new (QT_TR_NOOP(&quot;Gain&quot;));
+    gtk_widget_show (label5);
+    gtk_table_attach (GTK_TABLE (table1), label5, 4, 5, 0, 1,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
+
+    label6 = gtk_label_new (QT_TR_NOOP(&quot;Luma Y&quot;));
+    gtk_widget_show (label6);
+    gtk_table_attach (GTK_TABLE (table1), label6, 0, 1, 1, 2,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_misc_set_alignment (GTK_MISC (label6), 0, 0.5);
+
+    label7 = gtk_label_new (QT_TR_NOOP(&quot;Chroma U&quot;));
+    gtk_widget_show (label7);
+    gtk_table_attach (GTK_TABLE (table1), label7, 0, 1, 2, 3,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_misc_set_alignment (GTK_MISC (label7), 0, 0.5);
+
+    label8 = gtk_label_new (QT_TR_NOOP(&quot;Chroma V&quot;));
+    gtk_widget_show (label8);
+    gtk_table_attach (GTK_TABLE (table1), label8, 0, 1, 3, 4,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_misc_set_alignment (GTK_MISC (label8), 0, 0.5);
+
+    spinbuttonUC_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbuttonUC = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonUC_adj), 1, 0);
+    gtk_widget_show (spinbuttonUC);
+    gtk_table_attach (GTK_TABLE (table1), spinbuttonUC, 1, 2, 2, 3,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonUC), TRUE);
+
+    spinbuttonVC_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbuttonVC = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonVC_adj), 1, 0);
+    gtk_widget_show (spinbuttonVC);
+    gtk_table_attach (GTK_TABLE (table1), spinbuttonVC, 1, 2, 3, 4,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonVC), TRUE);
+
+    spinbuttonLB_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbuttonLB = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonLB_adj), 1, 0);
+    gtk_widget_show (spinbuttonLB);
+    gtk_table_attach (GTK_TABLE (table1), spinbuttonLB, 2, 3, 1, 2,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonLB), TRUE);
+
+    spinbuttonUB_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbuttonUB = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonUB_adj), 1, 0);
+    gtk_widget_show (spinbuttonUB);
+    gtk_table_attach (GTK_TABLE (table1), spinbuttonUB, 2, 3, 2, 3,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonUB), TRUE);
+
+    spinbuttonVB_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbuttonVB = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonVB_adj), 1, 0);
+    gtk_widget_show (spinbuttonVB);
+    gtk_table_attach (GTK_TABLE (table1), spinbuttonVB, 2, 3, 3, 4,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonVB), TRUE);
+
+    spinbuttonUG_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbuttonUG = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonUG_adj), 1, 0);
+    gtk_widget_show (spinbuttonUG);
+    gtk_table_attach (GTK_TABLE (table1), spinbuttonUG, 3, 4, 2, 3,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonUG), TRUE);
+
+    spinbuttonVG_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbuttonVG = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonVG_adj), 1, 0);
+    gtk_widget_show (spinbuttonVG);
+    gtk_table_attach (GTK_TABLE (table1), spinbuttonVG, 3, 4, 3, 4,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonVG), TRUE);
+
+    spinbuttonLN_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbuttonLN = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonLN_adj), 1, 0);
+    gtk_widget_show (spinbuttonLN);
+    gtk_table_attach (GTK_TABLE (table1), spinbuttonLN, 4, 5, 1, 2,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonLN), TRUE);
+
+    spinbuttonUN_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbuttonUN = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonUN_adj), 1, 0);
+    gtk_widget_show (spinbuttonUN);
+    gtk_table_attach (GTK_TABLE (table1), spinbuttonUN, 4, 5, 2, 3,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonUN), TRUE);
+
+    spinbuttonVN_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbuttonVN = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonVN_adj), 1, 0);
+    gtk_widget_show (spinbuttonVN);
+    gtk_table_attach (GTK_TABLE (table1), spinbuttonVN, 4, 5, 3, 4,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonVN), TRUE);
+
+    spinbutton23_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbutton23 = gtk_spin_button_new (GTK_ADJUSTMENT (spinbutton23_adj), 1, 0);
+    gtk_widget_show (spinbutton23);
+    gtk_table_attach (GTK_TABLE (table1), spinbutton23, 1, 2, 1, 2,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbutton23), TRUE);
+
+    spinbutton24_adj = gtk_adjustment_new (0, -10000, 10000, 1, 1, 1);
+    spinbutton24 = gtk_spin_button_new (GTK_ADJUSTMENT (spinbutton24_adj), 1, 0);
+    gtk_widget_show (spinbutton24);
+    gtk_table_attach (GTK_TABLE (table1), spinbutton24, 3, 4, 1, 2,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbutton24), TRUE);
+
+    Color_Correction = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Color Correction Matrix&lt;/b&gt;&quot;));
+    gtk_widget_show (Color_Correction);
+    gtk_frame_set_label_widget (GTK_FRAME (frame1), Color_Correction);
+    gtk_label_set_use_markup (GTK_LABEL (Color_Correction), TRUE);
+
+    Settings = gtk_frame_new (NULL);
+    gtk_widget_show (Settings);
+    gtk_box_pack_start (GTK_BOX (vbox1), Settings, TRUE, TRUE, 0);
+    gtk_frame_set_shadow_type (GTK_FRAME (Settings), GTK_SHADOW_NONE);
+
+    alignment2 = gtk_alignment_new (0.5, 0.5, 1, 1);
+    gtk_widget_show (alignment2);
+    gtk_container_add (GTK_CONTAINER (Settings), alignment2);
+    gtk_alignment_set_padding (GTK_ALIGNMENT (alignment2), 0, 0, 12, 0);
+
+    hbox1 = gtk_hbox_new (FALSE, 0);
+    gtk_widget_show (hbox1);
+    gtk_container_add (GTK_CONTAINER (alignment2), hbox1);
+
+    table2 = gtk_table_new (3, 2, FALSE);
+    gtk_widget_show (table2);
+    gtk_box_pack_start (GTK_BOX (hbox1), table2, TRUE, TRUE, 0);
+
+    label10 = gtk_label_new (QT_TR_NOOP(&quot;Matrix&quot;));
+    gtk_widget_show (label10);
+    gtk_table_attach (GTK_TABLE (table2), label10, 0, 1, 0, 1,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_misc_set_alignment (GTK_MISC (label10), 0, 0.5);
+
+    label11 = gtk_label_new (QT_TR_NOOP(&quot;Opt&quot;));
+    gtk_widget_show (label11);
+    gtk_table_attach (GTK_TABLE (table2), label11, 0, 1, 1, 2,
+                      (GtkAttachOptions) (GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_misc_set_alignment (GTK_MISC (label11), 0, 0.5);
+
+    label12 = gtk_label_new (QT_TR_NOOP(&quot;Level&quot;));
+    gtk_widget_show (label12);
+    gtk_table_attach (GTK_TABLE (table2), label12, 0, 1, 2, 3,
+                      (GtkAttachOptions) (GTK_FILL),
+                      (GtkAttachOptions) (0), 0, 0);
+    gtk_misc_set_alignment (GTK_MISC (label12), 0, 0.5);
+
+    comboboxMatrix = gtk_combo_box_new_text ();
+    gtk_widget_show (comboboxMatrix);
+    gtk_table_attach (GTK_TABLE (table2), comboboxMatrix, 1, 2, 0, 1,
+                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                      (GtkAttachOptions) (GTK_FILL), 0, 0);
+    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxMatrix), QT_TR_NOOP(&quot;None&quot;));
+    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxMatrix), QT_TR_NOOP(&quot;Rec.709&quot;));
+
+    combobox2 = gtk_combo_box_new_text ();
+    gtk_widget_show (combobox2);
+    gtk_table_attach (GTK_TABLE (table2), combobox2, 1, 2, 1, 2,
+                      (GtkAttachOptions) (GTK_FILL),
+                      (GtkAttachOptions) (GTK_FILL), 0, 0);
+    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox2), QT_TR_NOOP(&quot;None&quot;));
+    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox2), QT_TR_NOOP(&quot;Coring&quot;));
+
+    combobox3 = gtk_combo_box_new_text ();
+    gtk_widget_show (combobox3);
+    gtk_table_attach (GTK_TABLE (table2), combobox3, 1, 2, 2, 3,
+                      (GtkAttachOptions) (GTK_FILL),
+                      (GtkAttachOptions) (GTK_FILL), 0, 0);
+    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox3), QT_TR_NOOP(&quot;None&quot;));
+    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox3), QT_TR_NOOP(&quot;TV-&gt;PC&quot;));
+    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox3), QT_TR_NOOP(&quot;PC-&gt;TV&quot;));
+    gtk_combo_box_append_text (GTK_COMBO_BOX (combobox3), QT_TR_NOOP(&quot;PC-&gt;TV.Y&quot;));
+
+    vbox2 = gtk_vbox_new (FALSE, 0);
+    gtk_widget_show (vbox2);
+    gtk_box_pack_start (GTK_BOX (hbox1), vbox2, TRUE, TRUE, 0);
+
+    label13 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;Matrix Warning :&lt;/b&gt;\nall above values are normalized to 256!&quot;));
+    gtk_widget_show (label13);
+    gtk_box_pack_start (GTK_BOX (vbox2), label13, FALSE, FALSE, 0);
+    gtk_label_set_use_markup (GTK_LABEL (label13), TRUE);
+    gtk_label_set_justify (GTK_LABEL (label13), GTK_JUSTIFY_CENTER);
+
+    checkbuttonAutoGain = gtk_check_button_new_with_mnemonic (QT_TR_NOOP(&quot;AutoGain&quot;));
+    gtk_widget_show (checkbuttonAutoGain);
+    gtk_box_pack_start (GTK_BOX (vbox2), checkbuttonAutoGain, FALSE, FALSE, 0);
+
+    checkbuttonAnalyze = gtk_check_button_new_with_mnemonic (QT_TR_NOOP(&quot;Display Stats&quot;));
+    gtk_widget_show (checkbuttonAnalyze);
+    gtk_box_pack_start (GTK_BOX (vbox2), checkbuttonAnalyze, FALSE, FALSE, 0);
+
+    checkbuttonAutoWhite = gtk_check_button_new_with_mnemonic (QT_TR_NOOP(&quot;AutoWhite&quot;));
+    gtk_widget_show (checkbuttonAutoWhite);
+    gtk_box_pack_start (GTK_BOX (vbox2), checkbuttonAutoWhite, FALSE, FALSE, 0);
+
+    label9 = gtk_label_new (QT_TR_NOOP(&quot;&lt;b&gt;frame2&lt;/b&gt;&quot;));
+    gtk_widget_show (label9);
+    gtk_frame_set_label_widget (GTK_FRAME (Settings), label9);
+    gtk_label_set_use_markup (GTK_LABEL (label9), TRUE);
+
+    dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
+    gtk_widget_show (dialog_action_area1);
+    gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
+
+    cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
+    gtk_widget_show (cancelbutton1);
+    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
+    GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
+
+    okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
+    gtk_widget_show (okbutton1);
+    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
+    GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
+
+    /* Store pointers to all widgets, for use by lookup_widget(). */
+    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
+    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, vbox1, &quot;vbox1&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, frame1, &quot;frame1&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, alignment1, &quot;alignment1&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, table1, &quot;table1&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label2, &quot;label2&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label3, &quot;label3&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label4, &quot;label4&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label5, &quot;label5&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label6, &quot;label6&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label7, &quot;label7&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label8, &quot;label8&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonUC, &quot;spinbuttonUC&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonVC, &quot;spinbuttonVC&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonLB, &quot;spinbuttonLB&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonUB, &quot;spinbuttonUB&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonVB, &quot;spinbuttonVB&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonUG, &quot;spinbuttonUG&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonVG, &quot;spinbuttonVG&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonLN, &quot;spinbuttonLN&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonUN, &quot;spinbuttonUN&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonVN, &quot;spinbuttonVN&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbutton23, &quot;spinbutton23&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, spinbutton24, &quot;spinbutton24&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, Color_Correction, &quot;Color_Correction&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, Settings, &quot;Settings&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, alignment2, &quot;alignment2&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, table2, &quot;table2&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label10, &quot;label10&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label11, &quot;label11&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label12, &quot;label12&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, comboboxMatrix, &quot;comboboxMatrix&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, combobox2, &quot;combobox2&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, combobox3, &quot;combobox3&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, vbox2, &quot;vbox2&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label13, &quot;label13&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, checkbuttonAutoGain, &quot;checkbuttonAutoGain&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, checkbuttonAnalyze, &quot;checkbuttonAnalyze&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, checkbuttonAutoWhite, &quot;checkbuttonAutoWhite&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, label9, &quot;label9&quot;);
+    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
+    GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
+
+    return dialog1;
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001302.html">[Avidemux-svn-commit] r4045 - in	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_editor	ADM_encoder ADM_script plugins/ADM_videoEncoder/ADM_vidEnc_x264	plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4
</A></li>
	<LI>Next message: <A HREF="001304.html">[Avidemux-svn-commit] r4047 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1303">[ date ]</a>
              <a href="thread.html#1303">[ thread ]</a>
              <a href="subject.html#1303">[ subject ]</a>
              <a href="author.html#1303">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
