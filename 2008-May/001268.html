<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4008 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_coreImage/include ADM_coreUI/include ADM_filter	ADM_videoFilter plugins/ADM_videoFilters	plugins/ADM_videoFilters/BlendRemover	plugins/ADM_videoFilters/Chroma	plugins/ADM_videoFilters/DgBob plugins/ADM_videoFilters/Fade	plugins/ADM_videoFilters/ResampleFps	plugins/ADM_videoFilters/Reverse	plugins/ADM_videoFilters/TemporalCleaner	plugins/ADM_videoFilters/Yadif
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4008%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%0A%09ADM_coreImage/include%20ADM_coreUI/include%20ADM_filter%0A%09ADM_videoFilter%20plugins/ADM_videoFilters%0A%09plugins/ADM_videoFilters/BlendRemover%0A%09plugins/ADM_videoFilters/Chroma%0A%09plugins/ADM_videoFilters/DgBob%20plugins/ADM_videoFilters/Fade%0A%09plugins/ADM_videoFilters/ResampleFps%0A%09plugins/ADM_videoFilters/Reverse%0A%09plugins/ADM_videoFilters/TemporalCleaner%0A%09plugins/ADM_videoFilters/Yadif&In-Reply-To=%3C200805011821.m41ILYec020027%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001267.html">
   <LINK REL="Next"  HREF="001269.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4008 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_coreImage/include ADM_coreUI/include ADM_filter	ADM_videoFilter plugins/ADM_videoFilters	plugins/ADM_videoFilters/BlendRemover	plugins/ADM_videoFilters/Chroma	plugins/ADM_videoFilters/DgBob plugins/ADM_videoFilters/Fade	plugins/ADM_videoFilters/ResampleFps	plugins/ADM_videoFilters/Reverse	plugins/ADM_videoFilters/TemporalCleaner	plugins/ADM_videoFilters/Yadif</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4008%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%0A%09ADM_coreImage/include%20ADM_coreUI/include%20ADM_filter%0A%09ADM_videoFilter%20plugins/ADM_videoFilters%0A%09plugins/ADM_videoFilters/BlendRemover%0A%09plugins/ADM_videoFilters/Chroma%0A%09plugins/ADM_videoFilters/DgBob%20plugins/ADM_videoFilters/Fade%0A%09plugins/ADM_videoFilters/ResampleFps%0A%09plugins/ADM_videoFilters/Reverse%0A%09plugins/ADM_videoFilters/TemporalCleaner%0A%09plugins/ADM_videoFilters/Yadif&In-Reply-To=%3C200805011821.m41ILYec020027%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4008 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_coreImage/include ADM_coreUI/include ADM_filter	ADM_videoFilter plugins/ADM_videoFilters	plugins/ADM_videoFilters/BlendRemover	plugins/ADM_videoFilters/Chroma	plugins/ADM_videoFilters/DgBob plugins/ADM_videoFilters/Fade	plugins/ADM_videoFilters/ResampleFps	plugins/ADM_videoFilters/Reverse	plugins/ADM_videoFilters/TemporalCleaner	plugins/ADM_videoFilters/Yadif">mean at mail.berlios.de
       </A><BR>
    <I>Thu May  1 20:21:34 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001267.html">[Avidemux-svn-commit] r4007 - in	branches/avidemux_2.5_branch_gruntster: avidemux	avidemux/ADM_codecs avidemux/ADM_encoder	avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog	avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog	avidemux/ADM_userInterfaces/ADM_QT4	avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog	avidemux/ADM_userInterfaces/ADM_commonUI cmake
</A></li>
        <LI>Next message: <A HREF="001269.html">[Avidemux-svn-commit] r4009 - in	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4:	ADM_dialogFactory ADM_filters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1268">[ date ]</a>
              <a href="thread.html#1268">[ thread ]</a>
              <a href="subject.html#1268">[ subject ]</a>
              <a href="author.html#1268">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-05-01 20:21:27 +0200 (Thu, 01 May 2008)
New Revision: 4008

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidBlendRemoval.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidBlendRemoval_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidHardIvtcRemoval.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/ADM_vidChroma.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/ADM_vidChromaU.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/ADM_vidChromaV.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DgBob/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DgBob/ADM_vidDGbob.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DgBob/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Fade/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Fade/ADM_vidFade.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Fade/ADM_vidFade_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Fade/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ResampleFps/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ResampleFps/ADM_vidResampleFPS.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ResampleFps/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Reverse/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Reverse/ADM_vidReverse.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Reverse/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/TemporalCleaner/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/TemporalCleaner/ADM_vidVlad.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/TemporalCleaner/ADM_vidVlad.h
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/TemporalCleaner/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Yadif/
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Yadif/ADM_vidYadif.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Yadif/ADM_vidYadif_asm.c
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Yadif/CMakeLists.txt
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChroma.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChroma.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDGbob_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidReverse.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif_asm.c
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilterDynamic.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreUI/include/DIA_factory.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlend.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt
Log:
[Merge]


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilterDynamic.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilterDynamic.h	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilterDynamic.h	2008-05-01 18:21:27 UTC (rev 4008)
@@ -21,7 +21,7 @@
 typedef FilterDescriptor *(VF_getDescriptor)(void);
 
 #define VF_DEFINE_FILTER(myClass,name,displayname,version,createFunction,createFunctionFromScript,category,description) \
-	static FilterDescriptor descriptor_vf_id(\
+	static FilterDescriptor descriptor_vf_id_##myClass (\
 								0, \
 								name, \
 								displayname, \
@@ -30,7 +30,7 @@
 								createFunction, \
 								createFunctionFromScript, \
 								ADM_FILTER_API_VERSION); \
-    extern &quot;C&quot; { 	FilterDescriptor *ADM_VF_getDescriptor(void) {return &amp;descriptor_vf_id;}};							
+    extern &quot;C&quot; { 	FilterDescriptor *ADM_VF_getDescriptor(void) {return &amp;descriptor_vf_id_##myClass ;}};							
 
 /* Hook, filters cannot include config.h as they are framework independant */
 #ifdef QT_TR_NOOP
@@ -38,6 +38,6 @@
 #endif
 // FIXME TODO extern const char* translate(const char *__domainname, const char *__msgid);
 #define QT_TR_NOOP(String) String //translate (&quot;avidemux&quot;, String)
+#define ADM_MINIMAL_UI_INTERFACE
 
-
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreUI/include/DIA_factory.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreUI/include/DIA_factory.h	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreUI/include/DIA_factory.h	2008-05-01 18:21:27 UTC (rev 4008)
@@ -390,6 +390,7 @@
 };
 
 /*************************************************/
+#ifndef ADM_MINIMAL_UI_INTERFACE
 #include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
 typedef diaElem  *(CREATE_BITRATE_T)(COMPRES_PARAMS *p,const char *toggleTitle,const char *tip);
 class diaElemBitrateBase : public diaElem
@@ -416,7 +417,7 @@
   
   void updateMe(void);
 };
-
+#endif
 /*************************************************/
 typedef diaElem *CREATE_FILE_T(uint32_t writeMode,char **filename,const char *toggleTitle,  const char *defaultSuffix ,const char *tip);
 class diaElemFileBase : public diaElem

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -53,11 +53,7 @@
   	REGISTERX(VF_TRANSFORM, &quot;addblack&quot;,QT_TR_NOOP(&quot;Add black borders&quot;),QT_TR_NOOP(&quot;Add pure black border(s). Enlarges the picture.&quot;),VF_ADDBORDER,1,addBorder_create,addBorder_script);
 	REGISTERX(VF_TRANSFORM, &quot;blacken&quot;,QT_TR_NOOP(&quot;Blacken borders&quot;),QT_TR_NOOP(&quot;Fill borders with pure black. Doesn't alter size.&quot;),VF_BLACKEN,1,bsmear_create,bsmear_script);
 	REGISTERX(VF_TRANSFORM, &quot;rotate&quot;,QT_TR_NOOP(&quot;Rotate&quot;),QT_TR_NOOP(&quot;Rotate the picture by 90, 180 or 270 degrees.&quot;),VF_ROTATE,1,rotate_create,rotate_script);
-    REGISTERX(VF_TRANSFORM, &quot;resamplefps&quot;,QT_TR_NOOP(&quot;Resample fps&quot;),QT_TR_NOOP(&quot;Change framerate while keeping duration.&quot;),VF_RESAMPLE_FPS,1,resamplefps_create,resamplefps_script);                
-    REGISTERX(VF_TRANSFORM, &quot;reverse&quot;,QT_TR_NOOP(&quot;Reverse&quot;),QT_TR_NOOP(&quot;Play video backward.&quot;),VF_REVERSE,1,reverse_create,reverse_script);
-    REGISTERX(VF_TRANSFORM, &quot;fade&quot;,QT_TR_NOOP(&quot;Fade&quot;),QT_TR_NOOP(&quot;Fade in/out.&quot;),VF_FADE,1,fade_create,fade_script);     
 
-    REGISTERX(VF_INTERLACING, &quot;YADIF&quot;,QT_TR_NOOP(&quot;yadif&quot;),QT_TR_NOOP(&quot;Yet Another DeInterlacer. Ported from MPlayer.&quot;),VF_YADIF,1,yadif_create,yadif_script);
     REGISTERX(VF_INTERLACING, &quot;mcdeinterlace&quot;,QT_TR_NOOP(&quot;mcDeinterlace&quot;),QT_TR_NOOP(&quot;Motion compensation deinterlacer. Ported from MPlayer.&quot;),VF_MCDEINT,1,mcdeint_create,mcdeint_script);
 	REGISTERX(VF_INTERLACING, &quot;deinterlace&quot;,QT_TR_NOOP(&quot;Deinterlace&quot;),QT_TR_NOOP(&quot;Mask interlacing artifacts. Port of Smart deinterlace.&quot;),VF_DEINTERLACE,1,deinterlace_create,deinterlace_script);
 	REGISTERX(VF_INTERLACING, &quot;kerneldeint&quot;,QT_TR_NOOP(&quot;KernelDeint&quot;),QT_TR_NOOP(&quot;Kernel deinterlacer by Donald Graft.&quot;),VF_KRNDEINT,1,kerneldeint_create,kerneldeint_script);
@@ -66,7 +62,6 @@
 	REGISTERX(VF_INTERLACING, &quot;telecide&quot;,QT_TR_NOOP(&quot;Decomb Telecide&quot;),QT_TR_NOOP(&quot;Great deinterlacing package including IVTC.&quot;),VF_DECOMB,1,decomb_create,decomb_script);
 	REGISTERX(VF_INTERLACING, &quot;decimate&quot;,QT_TR_NOOP(&quot;Decomb Decimate&quot;),QT_TR_NOOP(&quot;Useful to remove dupes left by Telecide.&quot;),VF_DECIMATE,1,decimate_create,decimate_script);
 	REGISTERX(VF_INTERLACING, &quot;pulldown&quot;,QT_TR_NOOP(&quot;Pulldown&quot;),QT_TR_NOOP(&quot;Convert 24 fps to 30 fps by repeating fields.&quot;),VF_PULLDOWN,1,pulldown_create,pulldown_script);	
-	REGISTERX(VF_INTERLACING, &quot;dgbob&quot;,&quot;DGBob&quot;,QT_TR_NOOP(&quot;Bobber - convert each field into a full sized frame.&quot;),VF_DGBOB,1,dgbob_create,dgbob_script);
     REGISTERX(VF_INTERLACING, &quot;palfieldshift&quot;,QT_TR_NOOP(&quot;PAL field shift&quot;),QT_TR_NOOP(&quot;Shift fields by one. Useful for some PAL movies.&quot;),VF_PALSHIFT,1,addPALShift_create,addPALShift_script);	
 	REGISTERX(VF_INTERLACING, &quot;palsmart&quot;,QT_TR_NOOP(&quot;PAL smart&quot;),QT_TR_NOOP(&quot;Smartly revert non constant PAL field shift.&quot;),VF_TELECIDE,1,telecide_create,telecide_script);
 
@@ -99,8 +94,6 @@
     REGISTERX(VF_COLORS, &quot;chromashift&quot;,QT_TR_NOOP(&quot;Chroma shift&quot;),QT_TR_NOOP(&quot;Shift chroma U/V to fix badly synced luma/chroma.&quot;),VF_CHROMASHIFT,1,create_chromashift,chromashift_script);
 
     REGISTERX(VF_COLORS, &quot;lumaonly&quot;,QT_TR_NOOP(&quot;Luma only&quot;),QT_TR_NOOP(&quot;Convert picture to greyscale (black and white).&quot;),VF_LUMA,1,luma_create,luma_script);
-    REGISTERX(VF_COLORS, &quot;chromauonly&quot;,QT_TR_NOOP(&quot;Chroma U only&quot;),QT_TR_NOOP(&quot;Convert picture to grey, keeping only chroma U.&quot;),VF_CHROMAU,1,chromaU_create,chromaU_script);
-    REGISTERX(VF_COLORS, &quot;chromavonly&quot;,QT_TR_NOOP(&quot;Chroma V only&quot;),QT_TR_NOOP(&quot;Convert picture to grey, keeping only chroma V.&quot;),VF_CHROMAV,1,chromaV_create,chromaV_script);
    
     REGISTERX(VF_COLORS, &quot;delta&quot;,QT_TR_NOOP(&quot;Luma delta&quot;),QT_TR_NOOP(&quot;Difference between current and previous picture.&quot;),VF_DELTA,1,delta_create,delta_script);
     REGISTERX(VF_COLORS, &quot;coloryuv&quot;,QT_TR_NOOP(&quot;Avisynth ColorYUV&quot;),QT_TR_NOOP(&quot;Alter colors (auto white balance etc...). Ported from Avisynth.&quot;),VF_COLOR_YUV,1,coloryuv_create,coloryuv_script);
@@ -109,9 +102,7 @@
     REGISTERX(VF_NOISE, &quot;mpdenoise3d&quot;,QT_TR_NOOP(&quot;MPlayer denoise3d&quot;),QT_TR_NOOP(&quot;Reduce noise, smooth image, increase compressibility.&quot;),VF_MPLLQD3D,1,MPD3Dlow_create,MPD3Dlow_script);
 	REGISTERX(VF_NOISE, &quot;mphqdenoise3d&quot;,QT_TR_NOOP(&quot;MPlayer hqdn3d&quot;),QT_TR_NOOP(&quot;High quality version of denoise3d. Slower but more precise.&quot;),VF_MPLHQD3D,1,MPD3D_create,MPD3D_script);
 	REGISTERX(VF_NOISE, &quot;fluxsmooth&quot;,QT_TR_NOOP(&quot;FluxSmooth&quot;),QT_TR_NOOP(&quot;Spatio-temporal cleaner by Ross Thomas.&quot;),VF_FLUXSMOOTH,1,fluxsmooth_create,fluxsmooth_script);
-#ifdef ADM_CPU_X86
-    	REGISTERX(VF_NOISE, &quot;temporalcleaner&quot;,QT_TR_NOOP(&quot;Temporal Cleaner&quot;),QT_TR_NOOP(&quot;Vlad59's Avisynth port of Jim Casaburi's denoiser.&quot;),VF_VLADSMOOTH,1,vladsmooth_create,vladsmooth_script);
-#endif
+
 	REGISTERX(VF_NOISE, &quot;denoise&quot;,QT_TR_NOOP(&quot;Denoise&quot;),QT_TR_NOOP(&quot;Port of Transcode DNR.&quot;),VF_DENOISE,1,denoise_create,denoise_script);
 	REGISTERX(VF_NOISE, &quot;stabilize&quot;,QT_TR_NOOP(&quot;Stabilize&quot;),QT_TR_NOOP(&quot;Light denoiser.&quot;),VF_STABILIZE,1,stabilize_create,stabilize_script);
     REGISTERX(VF_NOISE, &quot;cnr2&quot;,QT_TR_NOOP(&quot;Cnr2&quot;),QT_TR_NOOP(&quot;Chroma noise reduction filter by MarcFD/Tritical.&quot;),VF_CNR2,1,cnr2_create,cnr2_script);	
@@ -145,7 +136,6 @@
 
         //*********************
  
-    REGISTERX(VF_MISC, &quot;blendremover&quot;,QT_TR_NOOP(&quot;Blend remover&quot;),QT_TR_NOOP(&quot;Remove blend between previous and next picture.&quot;),VF_BLENDREMOVAL,1,blendremove_create,blendremove_script);
     REGISTERX(VF_MISC, &quot;hardivtcremove&quot;,QT_TR_NOOP(&quot;Hard pulldown removal&quot;),QT_TR_NOOP(&quot;Remove IVTC that has been analog captured or resized.&quot;),VF_HARDIVTC,1,hardivtc_create,hardivtc_script);
     REGISTERX(VF_MISC, &quot;whirl&quot;,QT_TR_NOOP(&quot;Whirl&quot;),QT_TR_NOOP(&quot;Useless whirlwind effect.&quot;),VF_WHIRL,1,whirl_create,whirl_script);
     REGISTERX(VF_MISC, &quot;mosaic&quot;,QT_TR_NOOP(&quot;Mosaic&quot;),QT_TR_NOOP(&quot;Split the picture into tiny thumbnails.&quot;),VF_MOSAIC,1,     mosaic_create,mosaic_script);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlend.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlend.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlend.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -18,7 +18,6 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include &quot;config.h&quot;
 #include &quot;ADM_default.h&quot;
 
 #include &quot;ADM_videoFilter.h&quot;

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,259 +0,0 @@
-/***************************************************************************
-                         
-        Blending remover
-
-        A B C D E -&gt; A AB B 
-
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &lt;math.h&gt;
-
-
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-#include &quot;DIA_enter.h&quot;
-
-#include &quot;DIA_factory.h&quot;
-#include &quot;ADM_vidBlendRemoval_param.h&quot;
-#define MUL 1
-// Set it to 2 for post separate field
-
-
-
-class vidBlendRemoval:public AVDMGenericVideoStream
-{
-
-protected:
-  virtual char *printConf (void);
-  VideoCache *vidCache;
-  BLEND_REMOVER_PARAM *_param;
-  uint32_t              _lastRemoved;
-  ADMImage              *rebuild;
-public:
-
-                        vidBlendRemoval (AVDMGenericVideoStream * in, CONFcouple * setup);
-        virtual         ~vidBlendRemoval ();
-  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
-                                         ADMImage * data, uint32_t * flags);
-  uint8_t configure (AVDMGenericVideoStream * instream);
-  virtual uint8_t getCoupledConf (CONFcouple ** couples);
-
-};
-
-static FILTER_PARAM field_unblend_template =
-  { 4,&quot;threshold&quot;,&quot;show&quot;,&quot;noise&quot;,&quot;identical&quot;};
-
-BUILD_CREATE (blendremove_create, vidBlendRemoval);
-SCRIPT_CREATE (blendremove_script, vidBlendRemoval, field_unblend_template);
-//*************************************
-uint8_t vidBlendRemoval::configure (AVDMGenericVideoStream * in)
-{
-  
-   _in=in;
-    
-#define PX(x) &amp;(_param-&gt;x)
-        
-    diaElemUInteger   thresh(PX(threshold),QT_TR_NOOP(&quot;_Threshold:&quot;),0,99,
-        QT_TR_NOOP(&quot;If value is smaller than threshold it is considered valid.&quot;
-            &quot;Smaller value might mean more false positive.&quot;));
-    diaElemUInteger   noise(PX(noise),QT_TR_NOOP(&quot;_Noise:&quot;),0,99,QT_TR_NOOP(&quot;If pixels are closer than noise, they are considered to be the same&quot;));
-    diaElemUInteger   identical(PX(identical),QT_TR_NOOP(&quot;I_dentical:&quot;),0,99,QT_TR_NOOP(&quot;If metric is less than identical, images are considered identical&quot;));
-    diaElemToggle     show(PX(show),QT_TR_NOOP(&quot;_Show metrics&quot;),QT_TR_NOOP(&quot;Show metric in image (debug)&quot;));
-    
-       diaElem *elems[]={&amp;thresh,&amp;noise,&amp;identical,&amp;show};
-  
-   if(  diaFactoryRun(QT_TR_NOOP(&quot;Blend Removal&quot;),sizeof(elems)/sizeof(diaElem *),elems))
-   {
-        _lastRemoved=0xFFFFFFF;
-        return 1;
-    }
-        return 0;
-}
-/*************************************/
-char *vidBlendRemoval::printConf (void)
-{
-  static char buf[50];
-  sprintf ((char *) buf, &quot; Blend Removal Thresh:%d Noise:%d Ident:%d&quot;,_param-&gt;threshold,_param-&gt;noise,_param-&gt;identical);
-  return buf;
-}
-
-#define MAX_BLOCKS 50
-/*************************************/
-vidBlendRemoval::vidBlendRemoval (AVDMGenericVideoStream * in, CONFcouple * couples)
-{
-
-  _in = in;
-  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
-  _info.encoding = 1;
-  vidCache = new VideoCache (10, in);
-  _uncompressed=new ADMImage(_info.width,_info.height);
-  rebuild=new ADMImage(_info.width,_info.height);
-
- _param=new BLEND_REMOVER_PARAM;
- _lastRemoved=0xFFFF;
- if(couples)
- {
-#undef GET
-#define GET(x) couples-&gt;getCouple(#x,&amp;(_param-&gt;x))
-      GET (threshold);
-      GET (show);
-      GET (noise);
-      GET (identical);
-  }
-  else
-  {
-        _param-&gt;threshold=10;
-        _param-&gt;show=0;
-        _param-&gt;noise=5;
-        _param-&gt;identical=2;
-  }
-}
-//____________________________________________________________________
-vidBlendRemoval::~vidBlendRemoval ()
-{
-
-  delete vidCache;
-  vidCache = NULL;
-  delete _uncompressed;
-  _uncompressed=NULL;
-  delete _param;
-  _param=NULL;
-  delete rebuild;
-  rebuild=NULL;
-}
-
-
-
-
-
-uint8_t vidBlendRemoval::getFrameNumberNoAlloc (uint32_t inframe,
-                                uint32_t * len,
-                                ADMImage * data, uint32_t * flags)
-{
-
-	
-	ADMImage *srcP,*srcN,*src,*final,*display;
-        float distMerged, distN,distP,distM,distR,skip=0;
-        char txt[255];
-
-        if(inframe&gt;= _info.nb_frames) return 0;
-        if(inframe&lt;1 || inframe&gt;inframe&gt;_info.nb_frames-2 )
-        {
-                skip=1;
-        }
-        if(inframe &amp;&amp; _lastRemoved==inframe-1)
-        {
-                skip=1;
-        }
-        
-        if(skip)
-        {
-                data-&gt;duplicate(vidCache-&gt;getImage(inframe));
-                vidCache-&gt;unlockAll();
-                return 1;
-        }
-        
-        
-
-        srcP=vidCache-&gt;getImage(inframe-1);
-        src=vidCache-&gt;getImage(inframe);
-        srcN=vidCache-&gt;getImage(inframe+1);
-        if(!srcP || !src || !srcN)
-        {
-                data-&gt;duplicate(vidCache-&gt;getImage(inframe));
-                vidCache-&gt;unlockAll();
-                return 1;
-        }
-       
-        rebuild-&gt;merge(srcP,srcN);
-        
-        distP=ADMImage::lumaDiff(src,srcN,_param-&gt;noise);
-        distN=ADMImage::lumaDiff(src,srcP,_param-&gt;noise);
-        distM=ADMImage::lumaDiff(src,rebuild,_param-&gt;noise);
-        
-        
-        
-        
-        double medium;
-
-         if(distN&gt;1&amp;&amp;distP&gt;1)
-        {
-                if(distP&gt;distN) medium=distN;
-                          else  medium=distP;
-                  //medium=min(distM,distR);
-                 
-                 medium/=100;
-                 distN/=medium;
-                 distP/=medium;
-                 distM/=medium;
-         
-         }
-        
-        medium=medium/(_info.width*_info.height);
-        medium*=1000;
-        if(distM&lt;_param-&gt;threshold &amp;&amp; medium&gt;_param-&gt;identical) // medium is how close pictures are, too close, we discard
-        {
-                data-&gt;duplicate(srcP);
-                _lastRemoved=inframe;
-                if(_param-&gt;show )
-                {
-                        sprintf(txt,&quot;Dupe&quot;);
-                        drawString(data,2,5,txt);      
-                }
-        }
-        else
-                data-&gt;duplicate(src);
-        if(_param-&gt;show)
-        {
-                display=data;
-
-                sprintf(txt,&quot; N %02.1f&quot;,distN);
-                drawString(display,2,0,txt);
-
-                sprintf(txt,&quot; P %02.1f&quot;,distP);
-                drawString(display,2,1,txt);
-
-                sprintf(txt,&quot; M %02.1f&quot;,distM);
-                drawString(display,2,2,txt);
-
-                sprintf(txt,&quot; %% %02.1f&quot;,medium);
-                drawString(display,2,3,txt);
-        }
-
-
-          
-        vidCache-&gt;unlockAll();
-	return 1;
-}
-uint8_t vidBlendRemoval::getCoupledConf (CONFcouple ** couples)
-{
-
-  ADM_assert (_param);
-  *couples = new CONFcouple (4);
-#undef CSET
-#define CSET(x)  (*couples)-&gt;setCouple(#x,(_param-&gt;x))
-  CSET (threshold);
-  CSET (show);
-  CSET (noise);
-  CSET (identical);
-  
-  return 1;
-}
-
-
-//EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval_param.h	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval_param.h	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,22 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#ifndef BLEND_REMOVAL_PARAM_H
-#define BLEND_REMOVAL_PARAM_H
-
-typedef struct BLEND_REMOVER_PARAM
-{
-        uint32_t threshold;
-        uint32_t noise;
-        uint32_t show;
-        uint32_t identical;
-}BLEND_REMOVER_PARAM;
-uint8_t  DIA_blendRemoval(BLEND_REMOVER_PARAM *mosaic);
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChroma.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChroma.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChroma.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,190 +0,0 @@
-/***************************************************************************
-                          ADM_vidChroma.cpp  -  description
-                             -------------------
-    begin                : Wed Aug 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_vidChroma.h&quot;
-
-
-static FILTER_PARAM nullParam={0,{&quot;&quot;}};
-
-
-SCRIPT_CREATE(chromaU_script,ADMVideoChromaU,nullParam);
-SCRIPT_CREATE(chromaV_script,ADMVideoChromaV,nullParam);
-
-BUILD_CREATE(chromaU_create,ADMVideoChromaU);
-BUILD_CREATE(chromaV_create,ADMVideoChromaV);
-
-
-char *ADMVideoChromaU::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf,&quot; chroma u only&quot;);
-        return buf;
-}
-
-//_______________________________________________________________
-
-ADMVideoChromaU::ADMVideoChromaU(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-    UNUSED_ARG(setup);
-
-	_in=in;		
-	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  			 	
-	_info.encoding=1;
-	
-  	  	
-}
-ADMVideoChromaU::~ADMVideoChromaU()
-{
- 	
-	
- 	
-}
-
-//
-//	Remove y and v just keep U and expand it
-//
-   uint8_t ADMVideoChromaU::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{				
-uint32_t w,x;
-uint32_t page;
-		if(frame&gt;= _info.nb_frames) return 0;
-       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-		
-		page= _info.width*_info.height;
-		*len=(page*3)&gt;&gt;1;
-
-
-		// now expand  u
-		uint8_t *y,*v,*y2;
-
-		y=YPLANE(data);
-		y2=y+_info.width;
-		v=UPLANE(data);
-		for(w= _info.height&gt;&gt;1;w&gt;0;w--)
-		{
-			for(x= _info.width&gt;&gt;1;x&gt;0;x--)
-			{
-				*y=*v;
-				*y2=*v;
-				*(y+1)=*v;
-				*(y2+1)=*v;
-				v++;
-				y+=2;
-				y2+=2;
-			}
-                	y+=_info.width;
-			y2+=_info.width;
-       		 }
-
-		 // Remove chroma u &amp; v
-		 memset(UPLANE(data),0x80,page&gt;&gt;2);
-		 memset(VPLANE(data),0x80,page&gt;&gt;2);
-}
-
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-
-
-
-
-char *ADMVideoChromaV::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf,&quot; chroma v only&quot;);
-        return buf;
-}
-
-//_______________________________________________________________
-
-ADMVideoChromaV::ADMVideoChromaV(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-    UNUSED_ARG(setup);
-
-	_in=in;
-	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-	_info.encoding=1;
- 
-
-}
-ADMVideoChromaV::~ADMVideoChromaV()
-{
-
-	
-
-}
-
-//
-//	Remove y and v just keep U and expand it
-//
-   uint8_t ADMVideoChromaV::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-uint32_t w,x;
-uint32_t page;
-		if(frame&gt;= _info.nb_frames) return 0;
-       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-		
-		page= _info.width*_info.height;
-		*len=(page*3)&gt;&gt;1;
-
-
-		// now expand  u
-		uint8_t *y,*v,*y2;
-
-		y=YPLANE(data);
-		y2=y+_info.width;
-		v=VPLANE(data);
-		for(w= _info.height&gt;&gt;1;w&gt;0;w--)
-		{
-			for(x= _info.width&gt;&gt;1;x&gt;0;x--)
-			{
-				*y=*v;
-				*y2=*v;
-				*(y+1)=*v;
-				*(y2+1)=*v;
-				v++;
-				y+=2;
-				y2+=2;
-			}
-                	y+=_info.width;
-			y2+=_info.width;
-       		 }
-
-		 // Remove chroma u &amp; v
-		 memset(UPLANE(data),0x80,page&gt;&gt;2);
-		 memset(VPLANE(data),0x80,page&gt;&gt;2);
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChroma.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChroma.h	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChroma.h	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,59 +0,0 @@
-/***************************************************************************
-                          ADM_vidChroma.h  -  description
-                             -------------------
-    begin                : Wed Aug 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef CHROMA_
-#define CHROMA_
-
- class  ADMVideoChromaU:public AVDMGenericVideoStream
- {
-
- protected:
-
-
-           virtual char 									*printConf(void);
-			
-			
-
- public:
- 		
-  					ADMVideoChromaU(  AVDMGenericVideoStream *in,CONFcouple *setup);  	          							
-  					virtual ~ADMVideoChromaU();
-		          virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-			  		ADMImage *data,uint32_t *flags);
-				uint8_t configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 1;}
-							
- }     ;
-
- class  ADMVideoChromaV:public AVDMGenericVideoStream
- {
-
- protected:
-
-
-           virtual char 									*printConf(void);
-			uint8_t											_reverse;
-
- public:
- 		
-  					ADMVideoChromaV(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  					virtual ~ADMVideoChromaV();
-		          virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,											ADMImage *data,uint32_t *flags);
-					uint8_t configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 1;}
-							
- }     ;
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,542 +0,0 @@
-/*
-	DGBob() plugin for Avisynth -- Smart bob filter. This filter splits
-	each field of the source into its own frame and then adaptively
-	creates the missing lines either by interpolating the current field
-	or by using the previous field's data. The filter attempts with some
-	success to mitigate the flutter that bobbing produces.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-#include &quot;ADM_vidDGbob_param.h&quot;
-#include &quot;DIA_factory.h&quot;
-
-class DGbob : public AVDMGenericVideoStream
-{
-       
-        DGBobparam      *_param;        
-        
-        VideoCache      *vidCache;
-       
-        void            update(void); 
-public:
-                                
-                        DGbob(AVDMGenericVideoStream *in,CONFcouple *couples);    
-                        ~DGbob(void);
-        uint8_t         getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                ADMImage *data,uint32_t *flags);
-        
-        char            *printConf( void );
-        uint8_t         configure(AVDMGenericVideoStream *in);
-        uint8_t         getCoupledConf( CONFcouple **couples);
-};
-
-static FILTER_PARAM dgbobParam={4,{&quot;order&quot;,&quot;mode&quot;,&quot;thresh&quot;,&quot;ap&quot;}};
-
-BUILD_CREATE(dgbob_create,DGbob);
-SCRIPT_CREATE(dgbob_script,DGbob,dgbobParam);
-
-/*************************************/
-uint8_t DGbob::configure(AVDMGenericVideoStream *in)
-{
-        _in=in;
-#define PX(x) &amp;(_param-&gt;x)
-  
-     diaMenuEntry menuField[2]={{0,QT_TR_NOOP(&quot;Top&quot;),NULL},
-                             {1,QT_TR_NOOP(&quot;Bottom&quot;),NULL}
-                          };
-  
-     diaMenuEntry menuMode[3]={{0,QT_TR_NOOP(&quot;Keep nb of frames and fps&quot;),NULL},
-                            {1,QT_TR_NOOP(&quot;Double nb of frames and fps&quot;),NULL},
-                            {2,QT_TR_NOOP(&quot;Double nb of frames (slow motion)&quot;),NULL}
-                          };
-                          
-    diaElemMenu     menu1(PX(order),QT_TR_NOOP(&quot;_Field order:&quot;), 2,menuField);
-    diaElemMenu     menu2(PX(mode),QT_TR_NOOP(&quot;_Mode:&quot;), 3,menuMode);
-    diaElemUInteger threshold(PX(thresh),QT_TR_NOOP(&quot;_Threshold:&quot;),0,255);
-    diaElemToggle  extra(PX(ap),QT_TR_NOOP(&quot;_Extra&quot;),QT_TR_NOOP(&quot;Extra check, avoid using it&quot;));
-    
-      diaElem *elems[4]={&amp;menu1,&amp;menu2,&amp;threshold ,&amp;extra};
-   if(diaFactoryRun(QT_TR_NOOP(&quot;DGBob&quot;),4,elems))
-  {
-                update();
-                return 1;
-        }
-        return 0;
-        
-}
-
-char *DGbob::printConf( void )
-{
-        static char buf[50];
-
-        //ADM_assert(_param);
-        sprintf((char *)buf,&quot; DGBob mode:%d order:%d thresh:%d\n&quot;,_param-&gt;mode,_param-&gt;order,_param-&gt;thresh);
-        return buf;
-}
-
-
-DGbob::DGbob(AVDMGenericVideoStream *in,CONFcouple *couples)              
-
-{
-                
-                int count = 0;
-                char buf[80];
-                unsigned int *p;
-
-                _in=in;         
-                memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-                _info.encoding=1;
-                _uncompressed=NULL;             
-                _info.encoding=1;
-                _info.fps1000*=2;
-                _info.nb_frames*=2;
-                
-                                
-                vidCache=new VideoCache(7,in);
-                _param= new DGBobparam;
-                if(couples)
-                {
-                        GET(order);
-                        GET(mode);
-                        GET(thresh);
-                        GET(ap);
-                }
-                else
-                {
-                        _param-&gt;order=1;
-                        _param-&gt;mode=0;
-                        _param-&gt;thresh=12;
-                        _param-&gt;ap=0;
-                }
-                update();
-}
-void DGbob::update(void)
-{
-                memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-                _info.encoding=1;
-                switch(_param-&gt;mode)
-                {
-                        case 0:
-                                break;
-                        case 1:
-                                _info.fps1000*=2;
-                                _info.nb_frames*=2;
-                                break;
-                        case 2:
-                                _info.nb_frames*=2;
-                                break;
-                        default: ADM_assert(0);
-
-                }
-             
-}
-//________________________________________________________
-uint8_t DGbob::getCoupledConf( CONFcouple **couples)
-{
-        *couples=NULL;
-        *couples=new CONFcouple(4);
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-        
-        CSET(order);
-        CSET(mode);
-        CSET(thresh);
-        CSET(ap);
-
-        return 1;
-}
-//________________________________________________________
-DGbob::~DGbob(void)
-{
-                
-                if(vidCache) delete vidCache;                
-                vidCache=NULL;   
-                if(_param) delete _param;
-                _param=NULL;                             
-}
-uint8_t DGbob::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                ADMImage *data,uint32_t *flags)
-{
-        ADMImage *src,*prv,*prvprv,*nxt,*nxtnxt,*dst;
-	uint32_t n,num_frames;
-
-        if(frame&gt;=_info.nb_frames) return 0;
-        
-        num_frames=_in-&gt;getInfo()-&gt;nb_frames;   // ??
-
-	if (_param-&gt;mode == 0) n = frame;
-	else n = frame/2;
-
-        src=vidCache-&gt;getImage(n);
-        prv=vidCache-&gt;getImage(n &gt; 0 ? n - 1 :0 );
-        prvprv=vidCache-&gt;getImage(n &gt; 1 ? n - 2 : 0);
-        nxt=vidCache-&gt;getImage(n &lt; num_frames - 1 ? n + 1 : num_frames - 1);
-        nxtnxt=vidCache-&gt;getImage(n &lt; num_frames - 2 ? n + 2 : num_frames - 1);
-
-
-/*
-	PVideoFrame src = child-&gt;GetFrame(n, env);
-	PVideoFrame prv = child-&gt;GetFrame(n &gt; 0 ? n - 1 : 0, env);
-	PVideoFrame prvprv = child-&gt;GetFrame(n &gt; 1 ? n - 2 : 0, env);
-	PVideoFrame nxt = child-&gt;GetFrame(n &lt; vi.num_frames - 1 ? n + 1 : vi.num_frames - 1, env);
-	PVideoFrame nxtnxt = child-&gt;GetFrame(n &lt; vi.num_frames - 2 ? n + 2 : vi.num_frames - 1, env);
-    PVideoFrame dst = env-&gt;NewVideoFrame(vi);
-*/
-    const unsigned char *srcp, *srcp_saved, *srcpp, *srcpn;
-	const unsigned char *prvp, *prvpp, *prvpn, *prvprvp, *prvprvpp, *prvprvpn;
-	const unsigned char *nxtp, *nxtpp, *nxtpn, *nxtnxtp, *nxtnxtpp, *nxtnxtpn;
-    unsigned char *dstp, *dstp_saved;
- 
-    int src_pitch, dst_pitch, w, h;
-	int x, y, z, v1, v2, D = _param-&gt;thresh, T = 6, AP = 30;
-	int plane;
-
-        uint32_t ww,hh;
-	// Try making D a function of the average value of the comparands in
-	// order to make the margin larger in darker areas, where we can't see as
-	// much combing.
-
-	// Force deinterlacing of the first and last frames.
-	if (n == 0 || n == num_frames - 1) D = 0;
-        dst=data;
-	for (z = 0; z &lt; 3; z++)
-	{
-/*
-		if (z == 0) plane = PLANAR_Y;
-		else if (z == 1) plane = PLANAR_U;
-		else plane = PLANAR_V;
-
-*/
-                switch(z)
-                {
-                        case 0:
-                                ww=_info.width;
-                                hh=_info.height;
-                                srcp_saved = srcp = YPLANE(src);                                
-                                dstp_saved = dstp = YPLANE(dst);
-                                src_pitch = ww;
-                                dst_pitch = ww;
-                                w = ww;
-                                h = hh;
-                                break;
-                        case 1:
-                        case 2:
-                                ww=_info.width&gt;&gt;1;
-                                hh=_info.height&gt;&gt;1;
-                                if(z==1)
-                                {
-                                        srcp_saved = srcp = UPLANE(src);
-                                        dstp_saved = dstp = UPLANE(dst);
-                                }
-                                else
-                                {
-                                        srcp_saved = srcp = VPLANE(src);
-                                        dstp_saved = dstp = VPLANE(dst);
-                                }
-                                src_pitch = ww;
-                                dst_pitch = ww;
-                                w = ww;
-                                h = hh;
-                                break;
-                }
-/*
-		srcp_saved = srcp = src-&gt;GetReadPtr(plane);
-		src_pitch = src-&gt;GetPitch(plane);
-		dstp_saved = dstp = dst-&gt;GetWritePtr(plane);
-		dst_pitch = dst-&gt;GetPitch(plane);
-		w = dst-&gt;GetRowSize(plane);
-		h = dst-&gt;GetHeight(plane);
-*/
-		if ((_param-&gt;mode &gt; 0) &amp;&amp; (frame &amp; 1))
-		{
-			// Process odd-numbered frames.
-			// Copy field from current frame.
-			srcp = srcp_saved +_param-&gt;order * src_pitch;
-			dstp = dstp_saved +_param-&gt;order * dst_pitch;
-			for (y = 0; y &lt; h; y+=2)
-			{
-				memcpy(dstp, srcp, w);
-				srcp += 2*src_pitch;
-				dstp += 2*dst_pitch;
-			}
-			// Copy through the line that will be missed below.
-			memcpy(dstp_saved + (1-_param-&gt;order)*(h-1)*dst_pitch, srcp_saved + (1-_param-&gt;order)*(h-1)*src_pitch, w);
-			/* For the other field choose adaptively between using the previous field
-			   or the interpolant from the current field. */
-                        
-			//prvp = prv-&gt;GetReadPtr(plane) + src_pitch + order*src_pitch;
-                        switch(z)
-                        {
-                                case 0:prvp = YPLANE(prv) + src_pitch + _param-&gt;order*src_pitch;break;
-                                case 1:prvp = UPLANE(prv) + src_pitch + _param-&gt;order*src_pitch;break;
-                                case 2:prvp = VPLANE(prv) + src_pitch + _param-&gt;order*src_pitch;break;
-                        }
-			prvpp = prvp - src_pitch;
-			prvpn = prvp + src_pitch;
-			//prvprvp = prvprv-&gt;GetReadPtr(plane) + src_pitch + order*src_pitch;
-                         switch(z)
-                        {
-                                case 0:prvprvp = YPLANE(prvprv) + src_pitch + _param-&gt;order*src_pitch;break;
-                                case 1:prvprvp = UPLANE(prvprv) + src_pitch + _param-&gt;order*src_pitch;break;
-                                case 2:prvprvp = VPLANE(prvprv) + src_pitch + _param-&gt;order*src_pitch;break;
-                        }
-
-			prvprvpp = prvprvp - src_pitch;
-			prvprvpn = prvprvp + src_pitch;
-
-			//nxtp = nxt-&gt;GetReadPtr(plane) + src_pitch + order*src_pitch;
-                        switch(z)
-                        {
-                                case 0:nxtp = YPLANE(nxt) + src_pitch + _param-&gt;order*src_pitch;break;
-                                case 1:nxtp = UPLANE(nxt) + src_pitch + _param-&gt;order*src_pitch;break;
-                                case 2:nxtp = VPLANE(nxt) + src_pitch + _param-&gt;order*src_pitch;break;
-                        }
-
-			nxtpp = nxtp - src_pitch;
-			nxtpn = nxtp + src_pitch;
-			//nxtnxtp = nxtnxt-&gt;GetReadPtr(plane) + src_pitch + order*src_pitch;
-                        switch(z)
-                        {
-                                case 0:nxtnxtp = YPLANE(nxtnxt) + src_pitch + _param-&gt;order*src_pitch;break;
-                                case 1:nxtnxtp = UPLANE(nxtnxt) + src_pitch + _param-&gt;order*src_pitch;break;
-                                case 2:nxtnxtp = VPLANE(nxtnxt) + src_pitch + _param-&gt;order*src_pitch;break;
-                        }
-			nxtnxtpp = nxtnxtp - src_pitch;
-			nxtnxtpn = nxtnxtp + src_pitch;
-			srcp =  srcp_saved + src_pitch + _param-&gt;order*src_pitch;
-			srcpp = srcp - src_pitch;
-			srcpn = srcp + src_pitch;
-			dstp =  dstp_saved + dst_pitch + _param-&gt;order*dst_pitch;
-			for (y = 0; y &lt; h - 2; y+=2)
-			{
-				for (x = 0; x &lt; w; x++)
-				{
-					if (
-						abs(srcp[x] - nxtp[x]) &lt; D
-//						&amp;&amp; abs(srcp[x] - nxtnxtp[x]) &lt; D
-//						&amp;&amp; abs(prvp[x] - nxtp[x]) &lt; D
-						&amp;&amp; abs(srcpn[x] - prvprvpn[x]) &lt; D
-						&amp;&amp; abs(srcpp[x] - prvprvpp[x]) &lt; D
-						&amp;&amp; abs(srcpn[x] - nxtnxtpn[x]) &lt; D
-						&amp;&amp; abs(srcpp[x] - nxtnxtpp[x]) &lt; D
-						&amp;&amp; abs(srcpn[x] - prvpn[x]) &lt; D
-						&amp;&amp; abs(srcpp[x] - prvpp[x]) &lt; D
-						&amp;&amp; abs(srcpn[x] - nxtpn[x]) &lt; D
-						&amp;&amp; abs(srcpp[x] - nxtpp[x]) &lt; D
-					   )
-					{
-						if (_param-&gt;ap == true)
-						{
-							v1 = (int) srcp[x] - AP;
-							if (v1 &lt; 0) v1 = 0; 
-							v2 = (int) srcp[x] + AP;
-							if (v2 &gt; 235) v2 = 235; 
-							if ((v1 &gt; srcpp[x] &amp;&amp; v1 &gt; srcpn[x]) || (v2 &lt; srcpp[x] &amp;&amp; v2 &lt; srcpn[x]))
-							{
-								dstp[x] = ((int)srcpp[x] + srcpn[x]) &gt;&gt; 1;
-//								if (x &amp; 1) dstp[x] = 100; else dstp[x] = 235;
-							}
-							else
-							{
-								dstp[x] = srcp[x];
-//								if (x &amp; 1) dstp[x] = 100; else dstp[x] = 235;
-							}
-						}
-						else
-						{
-							dstp[x] = srcp[x];
-//							if (x &amp; 1) dstp[x] = 100; else dstp[x] = 235;
-						}
-					}
-					else
-					{
-						v1 = (int) srcp[x] - T;
-						if (v1 &lt; 0) v1 = 0; 
-						v2 = (int) srcp[x] + T;
-						if (v2 &gt; 235) v2 = 235; 
-						if ((v1 &gt; srcpp[x] &amp;&amp; v1 &gt; srcpn[x]) || (v2 &lt; srcpp[x] &amp;&amp; v2 &lt; srcpn[x]))
-						{
-							dstp[x] = ((int)srcpp[x] + srcpn[x]) &gt;&gt; 1;
-						}
-						else
-						{
-							dstp[x] = srcp[x];
-//							if (x &amp; 1) dstp[x] = 128; else dstp[x] = 235;
-						}
-					}
-				}
-				prvp    += 2*src_pitch;
-				prvpp    += 2*src_pitch;
-				prvpn    += 2*src_pitch;
-				prvprvpp    += 2*src_pitch;
-				prvprvpn    += 2*src_pitch;
-				nxtp    += 2*src_pitch;
-				nxtpp    += 2*src_pitch;
-				nxtpn    += 2*src_pitch;
-				nxtnxtpp    += 2*src_pitch;
-				nxtnxtpn    += 2*src_pitch;
-				srcp    += 2*src_pitch;
-				srcpp   += 2*src_pitch;
-				srcpn   += 2*src_pitch;
-				dstp    += 2*dst_pitch;
-			}
-		}
-		else
-		{
-			// Process even-numbered frames.
-			// Copy field from current frame.
-			srcp = srcp_saved + (1-_param-&gt;order) * src_pitch;
-			dstp = dstp_saved + (1-_param-&gt;order) * dst_pitch;
-			for (y = 0; y &lt; h; y+=2)
-			{
-				memcpy(dstp, srcp, w);
-				srcp += 2*src_pitch;
-				dstp += 2*dst_pitch;
-			}
-			// Copy through the line that will be missed below.
-			memcpy(dstp_saved + _param-&gt;order*(h-1)*dst_pitch, srcp_saved + _param-&gt;order*(h-1)*src_pitch, w);
-			/* For the other field choose adaptively between using the previous field
-			   or the interpolant from the current field. */
-			//prvp = prv-&gt;GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
-                        switch(z)
-                        {
-                                case 0:prvp = YPLANE(prv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                                case 1:prvp = UPLANE(prv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                                case 2:prvp = VPLANE(prv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                        }
-			prvpp = prvp - src_pitch;
-			prvpn = prvp + src_pitch;
-			// prvprvp = prvprv-&gt;GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
-                        switch(z)
-                        {
-                                case 0:prvprvp = YPLANE(prvprv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                                case 1:prvprvp = UPLANE(prvprv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                                case 2:prvprvp = VPLANE(prvprv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                        }
-                        
-			prvprvpp = prvprvp - src_pitch;
-			prvprvpn = prvprvp + src_pitch;
-			//nxtp = nxt-&gt;GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
-                        switch(z)
-                        {
-                                case 0:nxtp = YPLANE(nxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                                case 1:nxtp = UPLANE(nxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                                case 2:nxtp = VPLANE(nxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                        }
-			nxtpp = nxtp - src_pitch;
-			nxtpn = nxtp + src_pitch;
-			//nxtnxtp = nxtnxt-&gt;GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
-                         switch(z)
-                        {
-                                case 0:nxtnxtp = YPLANE(nxtnxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                                case 1:nxtnxtp = UPLANE(nxtnxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                                case 2:nxtnxtp = VPLANE(nxtnxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
-                        }
-			nxtnxtpp = nxtnxtp - src_pitch;
-			nxtnxtpn = nxtnxtp + src_pitch;
-			srcp =  srcp_saved + src_pitch + (1-_param-&gt;order)*src_pitch;
-			srcpp = srcp - src_pitch;
-			srcpn = srcp + src_pitch;
-			dstp =  dstp_saved + dst_pitch + (1-_param-&gt;order)*dst_pitch;
-			for (y = 0; y &lt; h - 2; y+=2)
-			{
-				for (x = 0; x &lt; w; x++)
-				{
-					if (
-						abs(srcp[x] - prvp[x]) &lt; D
-//						&amp;&amp; abs(srcp[x] - prvprvp[x]) &lt; D
-//						&amp;&amp; abs(prvp[x] - nxtp[x]) &lt; D
-						&amp;&amp; abs(srcpn[x] - prvprvpn[x]) &lt; D
-						&amp;&amp; abs(srcpp[x] - prvprvpp[x]) &lt; D
-						&amp;&amp; abs(srcpn[x] - nxtnxtpn[x]) &lt; D
-						&amp;&amp; abs(srcpp[x] - nxtnxtpp[x]) &lt; D
-						&amp;&amp; abs(srcpn[x] - prvpn[x]) &lt; D
-						&amp;&amp; abs(srcpp[x] - prvpp[x]) &lt; D
-						&amp;&amp; abs(srcpn[x] - nxtpn[x]) &lt; D
-						&amp;&amp; abs(srcpp[x] - nxtpp[x]) &lt; D
-					   )
-					{
-						if (_param-&gt;ap == true)
-						{
-							v1 = (int) prvp[x] - AP;
-							if (v1 &lt; 0) v1 = 0; 
-							v2 = (int) prvp[x] + AP;
-							if (v2 &gt; 235) v2 = 235; 
-							if ((v1 &gt; srcpp[x] &amp;&amp; v1 &gt; srcpn[x]) ||	(v2 &lt; srcpp[x] &amp;&amp; v2 &lt; srcpn[x]))
-							{
-								dstp[x] = ((int)srcpp[x] + srcpn[x]) &gt;&gt; 1;
-//								if (x &amp; 1) dstp[x] = 100; else dstp[x] = 235;
-							}
-							else
-							{
-								dstp[x] = prvp[x];
-//								if (x &amp; 1) dstp[x] = 128; else dstp[x] = 235;
-							}
-						}
-						else
-						{
-							dstp[x] = prvp[x];
-//							if (x &amp; 1) dstp[x] = 128; else dstp[x] = 235;
-						}
-					}
-					else
-					{
-						v1 = (int) prvp[x] - T;
-						if (v1 &lt; 0) v1 = 0; 
-						v2 = (int) prvp[x] + T;
-						if (v2 &gt; 235) v2 = 235; 
-						if ((v1 &gt; srcpp[x] &amp;&amp; v1 &gt; srcpn[x]) ||	(v2 &lt; srcpp[x] &amp;&amp; v2 &lt; srcpn[x]))
-						{
-							dstp[x] = ((int)srcpp[x] + srcpn[x]) &gt;&gt; 1;
-						}
-						else
-						{
-							dstp[x] = prvp[x];
-//							if (x &amp; 1) pp[x] = 128; else dstp[x] = 235;
-						}
-					}
-				}
-				prvp    += 2*src_pitch;
-				prvpp    += 2*src_pitch;
-				prvpn    += 2*src_pitch;
-				prvprvpp    += 2*src_pitch;
-				prvprvpn    += 2*src_pitch;
-				nxtp    += 2*src_pitch;
-				nxtpp    += 2*src_pitch;
-				nxtpn    += 2*src_pitch;
-				nxtnxtpp    += 2*src_pitch;
-				nxtnxtpn    += 2*src_pitch;
-				srcp    += 2*src_pitch;
-				srcpp   += 2*src_pitch;
-				srcpn   += 2*src_pitch;
-				dstp    += 2*dst_pitch;
-			}
-		}
-	}
-        vidCache-&gt;unlockAll();
-	return 1;
-}
-//EOF
-
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDGbob_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDGbob_param.h	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDGbob_param.h	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,12 +0,0 @@
-
-#ifndef DGBOB_PARAM
-#define DGBOB_PARAM
-typedef struct DGBobparam
-{
-        uint32_t  thresh;// low=more flickering, less jaggie
-        uint32_t  order; //0 : Bottom field first, 1 top field first        
-        uint32_t  mode;  // 0 keep # of frames, 1 *2 fps &amp; *2 frame, 2  #*2, fps*150% slow motion
-        uint32_t  ap;    // Extra artifact check, better not to use
-}DGBobparam;
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,282 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;math.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-#include &quot;ADM_vidFade_param.h&quot;
-
-#include &quot;DIA_factory.h&quot;
-
-class AVDM_Fade : public AVDMGenericVideoStream
-{
-  VideoCache      *vidCache;
-  VIDFADE_PARAM   *_param;
-  uint16_t         lookupLuma[256][256];
-  uint16_t         lookupChroma[256][256];
-  uint8_t         buildLut(void);
-  public:
-                                
-                    AVDM_Fade(AVDMGenericVideoStream *in,CONFcouple *couples);    
-                    ~AVDM_Fade(void);
-    uint8_t         getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                          ADMImage *data,uint32_t *flags);
-        
-    char            *printConf( void );
-    uint8_t         configure(AVDMGenericVideoStream *in);
-    uint8_t         getCoupledConf( CONFcouple **couples);
-};
-
-static FILTER_PARAM fadeParam={4,{&quot;startFade&quot;,&quot;endFade&quot;,&quot;inOut&quot;,&quot;toBlack&quot;}};
-
-BUILD_CREATE(fade_create,AVDM_Fade);
-SCRIPT_CREATE(fade_script,AVDM_Fade,fadeParam);
-
-/*************************************/
-uint8_t AVDM_Fade::configure(AVDMGenericVideoStream *in)
-{
-  uint32_t mx=_info.nb_frames;
-  _in=in;
-  
-  diaMenuEntry menuE[2]={{0,QT_TR_NOOP(&quot;Out&quot;),QT_TR_NOOP(&quot;Fade out&quot;)},{1,QT_TR_NOOP(&quot;In&quot;),QT_TR_NOOP(&quot;Fade in&quot;)}};
-  uint32_t start,end;
-  VIDFADE_PARAM param=*_param;
-  
-while(1)
-{
-    diaElemMenu     menu(&amp;(param.inOut),QT_TR_NOOP(&quot;_Fade type:&quot;), 2,menuE);
-    diaElemUInteger start(&amp;(param.startFade),QT_TR_NOOP(&quot;_Start frame:&quot;),0,mx);
-    diaElemUInteger end(&amp;(param.endFade),QT_TR_NOOP(&quot;_End frame:&quot;),0,mx);
-    diaElemToggle   black(&amp;(param.toBlack),QT_TR_NOOP(&quot;Fade to _black&quot;));
-    
-    diaElem *elems[4]={&amp;menu,&amp;start,&amp;end,&amp;black};
-  
-    if( diaFactoryRun(QT_TR_NOOP(&quot;Fade&quot;),4,elems))
-    {
-      // Check it is consistent
-      if(param.startFade&gt;=param.endFade || (param.startFade&gt;=mx) || (param.endFade&gt;=mx))
-      {
-        GUI_Error_HIG(QT_TR_NOOP(&quot;Parameter Error&quot;),QT_TR_NOOP(&quot;Start must be before end, and both within video # of frames.&quot;));
-        continue; 
-      }
-      //
-      *_param=param;
-      return 1;
-    }else
-        return 0;
-} 
-  return 1;
-}
-
-char *AVDM_Fade::printConf( void )
-{
-  static char buf[50];
-
-        //ADM_assert(_param);
-  sprintf((char *)buf,&quot; Fade : Start %u End %u&quot;,_param-&gt;startFade,_param-&gt;endFade);
-  if(_param-&gt;inOut) strcat(buf,&quot; In&quot;); else strcat(buf,&quot; Out&quot;);
-  return buf;
-}
-
-
-AVDM_Fade::AVDM_Fade(AVDMGenericVideoStream *in,CONFcouple *couples)
-
-{
-                
-  int count = 0;
-  char buf[80];
-  unsigned int *p;
-
-  _in=in;         
-  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-  _info.encoding=1;
-  vidCache=new VideoCache(3,in);
-  
-  _param=new VIDFADE_PARAM;
-  if(couples)
-  {
-    GET(startFade);
-    GET(endFade);
-    GET(inOut);
-    GET(toBlack);
-    
-  }else
-  {
-    _param-&gt;startFade=0; 
-    _param-&gt;endFade=_info.nb_frames-1;
-    _param-&gt;inOut=0;
-    _param-&gt;toBlack=0;
-  }
-  buildLut();
-}
-//________________________________________________________
-uint8_t AVDM_Fade::getCoupledConf( CONFcouple **couples)
-{
-  *couples=new CONFcouple(4);
-  CSET(startFade);
-  CSET(endFade);
-  CSET(inOut);
-  CSET(toBlack);
-  return 1;
-}
-//________________________________________________________
-AVDM_Fade::~AVDM_Fade(void)
-{
-                
-  if(vidCache) delete vidCache;                
-  vidCache=NULL;   
-  if(_param) delete _param;
-  _param=NULL;
-}
-uint8_t AVDM_Fade::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                            ADMImage *data,uint32_t *flags)
-{
-
-  uint32_t num_frames,tgt;
-  
-  ADMImage *src;
-
-  num_frames=_info.nb_frames;   // ??
-
-  tgt=frame+_info.orgFrame;
-  if(frame&gt;=num_frames)
-  {
-    printf(&quot;[Fade] out of bound\n&quot;);
-    return 0;
-  }
-
-  src=vidCache-&gt;getImage(frame);
-  if(!src) return 0;
-  if(tgt&gt;_param-&gt;endFade || tgt &lt;_param-&gt;startFade ||_param-&gt;endFade==_param-&gt;startFade )
-  {
-    //printf(&quot;Cur %u start %u end %u\n&quot;,tgt,_param-&gt;startFade,_param-&gt;endFade);
-    data-&gt;duplicate(src);
-    vidCache-&gt;unlockAll();
-    return 1;
-  }
-  uint8_t *s,*d,*s2;
-  uint16_t *index,*invertedIndex;
-  uint32_t count=_info.width*_info.height,w;
-  float num,den;
-  
-  den=_param-&gt;endFade-_param-&gt;startFade;
-  
-  num=tgt-_param-&gt;startFade;
-  
-  num=num/den;
-  num*=255.;
-  w=(uint32_t)floor(num+0.4);
-  
-//printf(&quot;w :%u\n&quot;,w);
-
-  s=src-&gt;data;
-  d=data-&gt;data;
-  if(_param-&gt;toBlack)
-  {
-        index=lookupLuma[w];
-        for(int i=0;i&lt;count;i++)
-        {
-          *d++=(index[*s++]&gt;&gt;8);
-        }
-        // Now do chroma
-        count&gt;&gt;=2;
-        s=UPLANE(src);
-        d=UPLANE(data);
-        index=lookupChroma[w];
-        for(int i=0;i&lt;count;i++)
-        {
-          *d++=(index[*s++]&gt;&gt;8);
-        }
-        s=VPLANE(src);
-        d=VPLANE(data);
-        for(int i=0;i&lt;count;i++)
-        {
-          *d++=(index[*s++]&gt;&gt;8);
-        }
-  }
-  else
-  {
-        uint32_t x,alpha;
-        ADMImage *final;
-
-        final=vidCache-&gt;getImage(_param-&gt;endFade-_info.orgFrame);
-        if(!final)
-        {
-              data-&gt;duplicate(src);
-              vidCache-&gt;unlockAll();
-              return 1;
-        }
-
-        s2=final-&gt;data;
-
-        index=lookupLuma[w];
-        
-        invertedIndex=lookupLuma[255-w];
-        for(int i=0;i&lt;count;i++)
-        {
-          *d++=(index[*s++]+invertedIndex[*s2++])&gt;&gt;8;
-        }
-        // Now do chroma
-        count&gt;&gt;=2;
-        s=UPLANE(src);
-        d=UPLANE(data);
-        s2=UPLANE(final);
-        index=lookupChroma[w];
-        invertedIndex=lookupChroma[255-w];
-        for(int i=0;i&lt;count;i++)
-        {
-            *d++=(index[*s++]+invertedIndex[*s2++]-(128&lt;&lt;8))&gt;&gt;8;
-        }
-        s=VPLANE(src);
-        d=VPLANE(data);
-        s2=VPLANE(final);
-        for(int i=0;i&lt;count;i++)
-        {
-            *d++=(index[*s++]+invertedIndex[*s2++]-(128&lt;&lt;8))&gt;&gt;8;
-            
-        }
-  }
-  vidCache-&gt;unlockAll();
-  return 1;
-}
-
-uint8_t AVDM_Fade::buildLut(void)
-{
-  float f,ration;
-  for(int i=0;i&lt;256;i++)
-  {
-    if(!_param-&gt;inOut) ration=255-i;
-    else ration=i;
-    for(int r=0;r&lt;256;r++)
-    {
-      f=r;
-      f=f*ration;
-      lookupLuma[i][r]=(uint16_t)(f+0.4);
-
-      f=r-128;
-      f=f*ration;
-      lookupChroma[i][r]=(128&lt;&lt;8)+(uint16_t)(f+0.4);
-
-    }
-    
-  }
-  return 1;
-}
-//EOF
-
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade_param.h	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade_param.h	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,23 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef ADM_VIDFADE_PARAM_H
-#define ADM_VIDFADE_PARAM_H
-
-typedef struct VIDFADE_PARAM
-{
-  uint32_t startFade;
-  uint32_t endFade;
-  uint32_t inOut; //0 Out 1 In
-  uint32_t toBlack; // =1 else fade to endFrame
-}VIDFADE_PARAM;
-
-
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,479 +0,0 @@
-/***************************************************************************
-                         
-        Hard ivtc removal for image
-
-        A B C D E -&gt; A BC CD D E
-
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-#include &lt;math.h&gt;
-
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-#include &quot;DIA_enter.h&quot;
-
-#include &quot;DIA_factory.h&quot;
-
-#define MUL 1
-// Set it to 2 for post separate field
-
-#include &quot;ADM_vidBlendRemoval_param.h&quot;
-
-#define PROGRESSIVE  0x00000001
-#define MAGIC_NUMBER (0xdeadbeef)
-#define IN_PATTERN   0x00000002
-
-extern uint8_t PutHintingData(unsigned char *video, unsigned int hint);
-
-class vidHardPDRemoval:public AVDMGenericVideoStream
-{
-
-protected:
-  virtual char *printConf (void);
-  VideoCache *vidCache;
-  BLEND_REMOVER_PARAM *_param;
-  uint32_t              _lastRemoved;
-  ADMImage              *cand1,*cand2,*rebuild;
-public:
-
-                        vidHardPDRemoval (AVDMGenericVideoStream * in, CONFcouple * setup);
-        virtual         ~vidHardPDRemoval ();
-  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
-                                         ADMImage * data, uint32_t * flags);
-  uint8_t configure (AVDMGenericVideoStream * instream);
-  virtual uint8_t getCoupledConf (CONFcouple ** couples);
-
-};
-
-static FILTER_PARAM field_unblend_template =
-  { 4,&quot;threshold&quot;,&quot;show&quot;,&quot;noise&quot;,&quot;identical&quot;};
-
-BUILD_CREATE (hardivtc_create, vidHardPDRemoval);
-SCRIPT_CREATE (hardivtc_script, vidHardPDRemoval, field_unblend_template);
-//*************************************
-uint8_t vidHardPDRemoval::configure (AVDMGenericVideoStream * in)
-{
-       _in=in;
-    
-#define PX(x) &amp;(_param-&gt;x)
-        
-    diaElemUInteger   thresh(PX(threshold),QT_TR_NOOP(&quot;_Threshold:&quot;),0,99,
-        QT_TR_NOOP(&quot;If value is smaller than threshold it is considered valid.&quot;
-            &quot; Smaller value might mean more false positive&quot;));
-    diaElemUInteger   noise(PX(noise),QT_TR_NOOP(&quot;_Noise:&quot;),0,99,QT_TR_NOOP(&quot;If pixels are closer than noise, they are considered to be the same&quot;));
-    diaElemUInteger   identical(PX(identical),QT_TR_NOOP(&quot;_Identical:&quot;),0,99,QT_TR_NOOP(&quot;If metric is less than identical, images are considered identical&quot;));
-    diaElemToggle     show(PX(show),QT_TR_NOOP(&quot;_Show metrics&quot;),QT_TR_NOOP(&quot;Show metric in image (debug)&quot;));
-    
-       diaElem *elems[]={&amp;thresh,&amp;noise,&amp;identical,&amp;show};
-  
-   if(  diaFactoryRun(QT_TR_NOOP(&quot;Hard IVTC Removal&quot;),sizeof(elems)/sizeof(diaElem *),elems))
-   {
-        _lastRemoved=0xFFFFFFF;
-        return 1;
-    }
-        return 0;
-}
-/*************************************/
-char *vidHardPDRemoval::printConf (void)
-{
-  static char buf[50];
-  sprintf ((char *) buf, &quot; Field Unblend Thresh:%d Noise:%d&quot;,_param-&gt;threshold,_param-&gt;noise);
-  return buf;
-}
-static void hint(ADMImage *img)
-{
-       unsigned int hint;
-
-                 hint= PROGRESSIVE;
-                
-                 hint |= IN_PATTERN;
-                
-                PutHintingData(YPLANE(img), hint);  
-
-}
-#define MAX_BLOCKS 50
-/*************************************/
-vidHardPDRemoval::vidHardPDRemoval (AVDMGenericVideoStream * in, CONFcouple * couples)
-{
-
-  _in = in;
-  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
-  _info.encoding = 1;
-  vidCache = new VideoCache (10, in);
-  _uncompressed=new ADMImage(_info.width,_info.height);
-  cand1=new ADMImage(_info.width,_info.height);
-  cand2=new ADMImage(_info.width,_info.height);
-  rebuild=new ADMImage(_info.width,_info.height);
-
- _param=new BLEND_REMOVER_PARAM;
- _lastRemoved=0xFFFFFFF;
- if(couples)
- {
-#undef GET
-#define GET(x) couples-&gt;getCouple(#x,&amp;(_param-&gt;x))
-      GET (threshold);
-      GET (show);
-      GET (noise);
-      GET (identical);
-  }
-  else
-  {
-        _param-&gt;threshold=10;
-        _param-&gt;show=0;
-        _param-&gt;noise=5;
-        _param-&gt;identical=2;
-  }
-}
-//____________________________________________________________________
-vidHardPDRemoval::~vidHardPDRemoval ()
-{
-
-  delete vidCache;
-  vidCache = NULL;
-  delete _uncompressed;
-  _uncompressed=NULL;
-  delete _param;
-  _param=NULL;
-  delete cand1;
-  delete cand2;
-  delete rebuild;
-  cand1=NULL;
-  cand2=NULL;
-  rebuild=NULL;
-}
-
-
-
-
-/*
-
-                src=blend of srcP and R         =&gt; src= 1/2(srcP+R)
-                                                   2*src-srcP=R
-
-                srcN=blend of srcNN and R       =&gt; srcN=1/2 (srcNN+R)
-                                                        2*srcN-srcNN=R
-
-*/
-
-static uint8_t tinyRestore(uint8_t *dst, uint8_t *srcP, uint8_t *src,uint8_t *srcN,uint8_t *srcNN,uint32_t w, uint32_t h)
-{
-
-
-uint8_t *s,*sp,*sn,*snn,*d1;
-int a1,a2,a3,a4,sum,delta;
-
-        sp=srcP;
-        s=src;
-        sn=srcN;
-        snn=srcNN;
-        
-        d1=dst;
-
-          for(int y=0;y&lt;h;y++)
-                for(int x=0;x&lt;w;x++)
-                {
-                        a1=*sp;
-                        a2=*s;
-                        a3=*sn;
-                        a4=*snn;
-
-                        sum=2*a2+2*a3-a1-a4;
-                        sum=sum/2;
-                        
-                        a1=sum;                        
-
-                        if(a1&lt;0) a1=0;
-                        if(a1&gt;255) a1=255;
-                        *d1=a1;
-
-                        s++;
-                        sp++;
-                        sn++;
-                        snn++;
-                        d1++;
-                }
-        return 1;
-}
-#ifdef ADM_CPU_X86
-static uint8_t tinyRestoreMMX(uint8_t *dst, uint8_t *srcP, uint8_t *src,uint8_t *srcN,uint8_t *srcNN,uint32_t w, uint32_t h)
-{
-
-
-uint8_t *s,*sp,*sn,*snn,*d1;
-int a1,a2,a3,a4,sum,delta,l,ll;
-
-        sp=srcP;
-        s=src;
-        sn=srcN;
-        snn=srcNN;
-        
-        d1=dst;
-
-        l=w*h;
-        ll=l&gt;&gt;2;
-#ifdef GCC_2_95_X
-        __asm__(
-                         &quot;pxor %mm7,%mm7&quot;
-                ::
-                 );
-#else
-        __asm__(
-                         &quot;pxor %%mm7,%%mm7&quot;
-                ::
-                 );
-#endif
-        for(int x=0;x&lt;ll;x++)
-                {
-                        __asm__(
-                        &quot;movd           (%0),%%mm0 \n&quot;
-                        &quot;movd           (%1),%%mm1 \n&quot;
-                        &quot;movd           (%2),%%mm2 \n&quot;
-                        &quot;movd           (%3),%%mm3 \n&quot;
-                        &quot;punpcklbw      %%mm7,%%mm0 \n&quot;
-                        &quot;punpcklbw      %%mm7,%%mm1 \n&quot;
-                        &quot;punpcklbw      %%mm7,%%mm2 \n&quot;
-                        &quot;punpcklbw      %%mm7,%%mm3 \n&quot;  //sum=2*m1+2*m2-m0-m3;
-                        
-                        &quot;paddw          %%mm2,%%mm1 \n&quot;
-                        &quot;paddw          %%mm1,%%mm1 \n&quot;
-                        &quot;paddw          %%mm3,%%mm0 \n&quot;
-                        
-                        &quot;psubusw        %%mm0,%%mm1 \n&quot; // mm1=sum
-                        &quot;psraw          $1,%%mm1 \n&quot;    //2 
-                        &quot;packuswb       %%mm1,  %%mm1\n&quot;
-                        &quot;movd           %%mm1,(%4) \n&quot;
-
-                : : &quot;r&quot; (sp),&quot;r&quot; (s),&quot;r&quot;(sn),&quot;r&quot;(snn),&quot;r&quot;(d1)
-                );
-
-                        s+=4;
-                        sp+=4;
-                        sn+=4;
-                        snn+=4;
-                        d1+=4;
-                }
-        if(l&amp;3) tinyRestore(d1, sp, s,sn,snn,l&amp;3, 1);
-        return 1;
-}
-#endif
-
-static uint8_t    restore(ADMImage *tgt,ADMImage *srcP,ADMImage *src,ADMImage *srcN,ADMImage *srcNN)
-{
-int delta;
-uint32_t ww,hh;
-uint8_t *s1,*s2,*d1;
-int a1,a2,t1;
-
-#ifdef ADM_CPU_X86
-        if(CpuCaps::hasMMX())
-        {
-              tinyRestoreMMX(YPLANE(tgt),YPLANE(srcP),YPLANE(src),YPLANE(srcN),YPLANE(srcNN),tgt-&gt;_width,tgt-&gt;_height);
-              tinyRestoreMMX(UPLANE(tgt),UPLANE(srcP),UPLANE(src),UPLANE(srcN),UPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
-              tinyRestoreMMX(VPLANE(tgt),VPLANE(srcP),VPLANE(src),VPLANE(srcN),VPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
-              return 1;
-        }
-#endif
-
-        tinyRestore(YPLANE(tgt),YPLANE(srcP),YPLANE(src),YPLANE(srcN),YPLANE(srcNN),tgt-&gt;_width,tgt-&gt;_height);
-        tinyRestore(UPLANE(tgt),UPLANE(srcP),UPLANE(src),UPLANE(srcN),UPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
-        tinyRestore(VPLANE(tgt),VPLANE(srcP),VPLANE(src),VPLANE(srcN),VPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
-        return 1;
-
-
-}
-
-uint8_t vidHardPDRemoval::getFrameNumberNoAlloc (uint32_t inframe,
-                                uint32_t * len,
-                                ADMImage * data, uint32_t * flags)
-{
-
-	
-	ADMImage *srcP,*srcN,*srcNN,*src,*final,*display;
-        float distMerged, distN,distP,distM,distR,skip=0;
-        char txt[255];
-
-        if(inframe&gt;= _info.nb_frames) return 0;
-        if(inframe&lt;1 || inframe&gt;inframe&gt;_info.nb_frames-3 )
-        {
-                skip=1;
-        }
-        if(inframe&gt;_lastRemoved+1 &amp;&amp; inframe&lt;_lastRemoved+5 )
-        {
-                skip=1;
-        }
-        
-        if(skip)
-        {
-                data-&gt;duplicate(vidCache-&gt;getImage(inframe));
-                hint(data);
-                vidCache-&gt;unlockAll();
-                return 1;
-        }
-        
-        if(_lastRemoved==inframe-1)
-        {
-                data-&gt;duplicate(rebuild);
-                hint(data);
-                if(_param-&gt;show&amp;&amp;inframe)
-                {
-                        sprintf(txt,&quot; Telecined 2&quot;);
-                        drawString(data,2,4,txt);
-                }
-                
-                return 1;
-        }
-
-        //data-&gt;duplicate(rebuild);
-
-        srcP=vidCache-&gt;getImage(inframe-1);
-        src=vidCache-&gt;getImage(inframe);
-        srcN=vidCache-&gt;getImage(inframe+1);
-        srcNN=vidCache-&gt;getImage(inframe+2);
-
-        if(!src || !srcP || !srcN || !srcNN)
-        {
-                data-&gt;duplicate(vidCache-&gt;getImage(inframe));
-                vidCache-&gt;unlockAll();
-                return 1;
-        }
-        
-        // Let's rebuild the pseudo R, where we have A AR RB B
-        // If then we got R1 very close to R2, and that AR is very close to src
-        // Decide it is hard telecined (frame blending)
-#if 1
-        restore(rebuild,srcP,src,srcN,srcNN);
-#else
-        cand1-&gt;substract(src,srcP);
-        cand2-&gt;substract(srcN,srcNN);
-        rebuild-&gt;merge(cand1,cand2);
-#endif  
-#if 0
-        data-&gt;duplicate(rebuild);
-        vidCache-&gt;unlockAll();
-        return 1;
-#endif
-
-        // And remerge...
-        cand1-&gt;merge(srcP,rebuild);
-        cand2-&gt;merge(srcNN,rebuild);
-        
-        distP=ADMImage::lumaDiff(cand1,src,_param-&gt;noise);
-        distN=ADMImage::lumaDiff(cand2,srcN,_param-&gt;noise);
-        distM=ADMImage::lumaDiff(src,srcP,_param-&gt;noise);
-        distR=ADMImage::lumaDiff(src,srcN,_param-&gt;noise);
-        
-        
-        
-        double medium;
-
-         if(distM&gt;1&amp;&amp;distR&gt;1)
-        {
-                if(distM&gt;distR) medium=distR;
-                          else  medium=distM;
-                  //medium=min(distM,distR);
-                 
-                 medium/=100;
-                 distN/=medium;
-                 distP/=medium;
-                 distR/=medium;
-         
-         }
-
-        medium=medium/(_info.width*_info.height);
-        medium*=1000;
-
-        if(medium&lt;_param-&gt;identical)
-        {
-                 data-&gt;duplicate(src);
-                 vidCache-&gt;unlockAll();
-                if(_param-&gt;show)
-                {
-                        sprintf(txt,&quot; %% %02.1f : Identical&quot;,medium);
-                        drawString(data,2,3,txt);
-
-                }
-                return 1;
-        }
-        double mn;
-
-        if(inframe == _lastRemoved+5)
-        {
-                distN=(distN*7)/10;
-                distP=(distP*7)/10;
-                
-        }
-                //data-&gt;duplicate(src); 
-        if(distN&lt;_param-&gt;threshold &amp;&amp; distP&lt;_param-&gt;threshold)
-        {
-                data-&gt;duplicate(rebuild);
-                hint(data);
-                _lastRemoved=inframe;
-                if(_param-&gt;show &amp;&amp; inframe == _lastRemoved+5)
-                {
-                        sprintf(txt,&quot; Fav&quot;);
-                        drawString(data,2,5,txt);      
-                }
-        }
-        else
-                data-&gt;duplicate(src);
-        if(_param-&gt;show)
-        {
-                display=data;
-
-                sprintf(txt,&quot; N %02.1f&quot;,distN);
-                drawString(display,2,0,txt);
-
-                sprintf(txt,&quot; P %02.1f&quot;,distP);
-                drawString(display,2,1,txt);
-
-                sprintf(txt,&quot; R %02.1f&quot;,distR);
-                drawString(display,2,2,txt);
-
-                sprintf(txt,&quot; %% %02.1f&quot;,medium);
-                drawString(display,2,3,txt);
-
-                if(_lastRemoved==inframe)
-                {
-                        sprintf(txt,&quot; Telecined 1&quot;,distP);
-                        drawString(display,2,4,txt);
-                }
-        }
-
-
-          
-        vidCache-&gt;unlockAll();
-	return 1;
-}
-uint8_t vidHardPDRemoval::getCoupledConf (CONFcouple ** couples)
-{
-
-  ADM_assert (_param);
-  *couples = new CONFcouple (4);
-#undef CSET
-#define CSET(x)  (*couples)-&gt;setCouple(#x,(_param-&gt;x))
-  CSET (threshold);
-  CSET (show);
-  CSET (noise);
-  CSET (identical);
-  
-  return 1;
-}
-
-
-//EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,342 +0,0 @@
-/***************************************************************************
-                          Resample fps
-                             -------------------
-    begin                : Wed Nov 6 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;math.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;DIA_enter.h&quot;
-#include &quot;DIA_factory.h&quot;
-
-static FILTER_PARAM ResampParam={2,{&quot;newfps&quot;,&quot;use_linear&quot;}};
-typedef struct FPS_Param
-{
-  uint32_t  newfps; 
-  uint32_t  use_linear;
-}FPS_Param;
-class  ADMVideoResampleFPS:public AVDMGenericVideoStream
-{
-
-  protected:
-    AVDMGenericVideoStream  *_in;           
-    virtual char            *printConf(void);
-            FPS_Param       *_param;    
-            VideoCache      *vidCache; 
-  public:
-                
-                        ADMVideoResampleFPS(  AVDMGenericVideoStream *in,CONFcouple *setup);
-                        ADMVideoResampleFPS(  AVDMGenericVideoStream *in,uint32_t target1000);
-    virtual             ~ADMVideoResampleFPS();
-    virtual uint8_t     configure(AVDMGenericVideoStream *in);
-    virtual uint8_t     getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                          ADMImage *data,uint32_t *flags);
-
-             uint8_t     getCoupledConf( CONFcouple **couples);
-}     ;
-
-SCRIPT_CREATE(resamplefps_script,ADMVideoResampleFPS,ResampParam);
-BUILD_CREATE(resamplefps_create,ADMVideoResampleFPS);
-
-AVDMGenericVideoStream *createResampleFps(AVDMGenericVideoStream *in,uint32_t targetfps1000)
-{
-  return new ADMVideoResampleFPS(in,targetfps1000);
-}
-
-uint8_t ADMVideoResampleFPS::configure(AVDMGenericVideoStream *in)
-{
-  float f=_param-&gt;newfps; 
-  f/=1000;
-  
-  _in=in;
-  
-    diaElemFloat fps(&amp;f,QT_TR_NOOP(&quot;_New frame rate:&quot;),1,200.);
-    diaElemToggle blend(&amp;(_param-&gt;use_linear),QT_TR_NOOP(&quot;_Blend&quot;));
-    
-    diaElem *elems[2]={&amp;fps,&amp;blend};
-  
-    if( diaFactoryRun(QT_TR_NOOP(&quot;Resample fps&quot;),2,elems))
-    {
-        f*=1000;
-      _param-&gt;newfps=(uint32_t)floor(f+0.4); 
-      _info.fps1000=_param-&gt;newfps;
-      return 1;
-    }
-    return 0;
-}
-char *ADMVideoResampleFPS::printConf( void )
-{
-  static char buf[50];
-        
-  sprintf((char *)buf,&quot; Resample to %2.2f fps (blend:%d)&quot;,(double)_param-&gt;newfps/1000.,
-                _param-&gt;use_linear);
-  return buf;
-}
-
-ADMVideoResampleFPS::ADMVideoResampleFPS(  AVDMGenericVideoStream *in,uint32_t target)
-{
-
-  _in=in;         
-  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-  _info.encoding=1; 
-  _param=new  FPS_Param;
-   
-    _param-&gt;newfps =target;                
-    _param-&gt;use_linear=1;
- 
-  double newlength;
-  
-  newlength=_info.nb_frames;
-  newlength/=_info.fps1000;
-  newlength*=_param-&gt;newfps;
-  _info.nb_frames=(uint32_t)floor(newlength);
-  _info.fps1000=_param-&gt;newfps;
-  printf(&quot;[Resample FPS] %u -&gt; %u\n&quot;,_in-&gt;getInfo()-&gt;nb_frames,_info.nb_frames);
-  vidCache=new VideoCache(3,_in);
-
-}
-
-ADMVideoResampleFPS::ADMVideoResampleFPS(  AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-  
-  _in=in;         
-  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-  _info.encoding=1; 
-  _param=new  FPS_Param;
-   
-  if(couples)
-  {                 
-    GET(newfps);    
-    GET(use_linear); 
-  }
-  else
-  {
-    _param-&gt;newfps =_info.fps1000;                
-    _param-&gt;use_linear=0;
-  }      
- 
-  double newlength;
-  
-  newlength=_info.nb_frames;
-  newlength/=_info.fps1000;
-  newlength*=_param-&gt;newfps;
-  _info.nb_frames=(uint32_t)floor(newlength);
-  _info.fps1000=_param-&gt;newfps;
-  vidCache=new VideoCache(3,_in);
-  
-}
-ADMVideoResampleFPS::~ADMVideoResampleFPS()
-{
-  delete _param;
-  delete vidCache;
-  
-}
-uint8_t ADMVideoResampleFPS::getCoupledConf( CONFcouple **couples)
-{
-  ADM_assert(_param);
-  *couples=new CONFcouple(2);
-
-
-                CSET(newfps);
-                CSET(use_linear);
-                return 1;
-}
-#ifdef ADM_CPU_X86
-static uint64_t low,high;
-static void blendMMX(uint8_t *src, uint8_t *src2, uint8_t *dst, uint8_t alpha, uint8_t beta,uint32_t count)
-{
-uint32_t left=count&amp;3;
-#define EXPAND(x) (x)+((x)&lt;&lt;16)+((x)&lt;&lt;32) +((x)&lt;&lt;48)
-        high=alpha;
-        low=beta;
-        high=EXPAND(high);
-        low=EXPAND(low);
-        count&gt;&gt;=2;
-#ifdef GCC_2_95_X
-         __asm__ __volatile__ (
-                                &quot;movq &quot;Mangle(high)&quot;, %mm0\n&quot;
-                                &quot;movq &quot;Mangle(low)&quot;,  %mm1\n&quot;                                
-                                &quot;pxor %mm7        ,  %mm7\n&quot;
-                                :: );
-#else
-         __asm__ __volatile__ (
-                                &quot;movq &quot;Mangle(high)&quot;, %%mm0\n&quot;
-                                &quot;movq &quot;Mangle(low)&quot;,  %%mm1\n&quot;                                
-                                &quot;pxor %%mm7        ,  %%mm7\n&quot;
-                                :: );
-#endif
-
-        while(count&gt;0)
-        {
-                __asm__ __volatile__ (
-                               
-                                &quot;movd      (%0),  %%mm2\n&quot;
-                                &quot;movd      (%1),  %%mm3\n&quot;                               
-
-                                &quot;punpcklbw %%mm7, %%mm2\n&quot;
-                                &quot;punpcklbw %%mm7, %%mm3\n&quot;
-
-                                &quot;pmullw   %%mm0, %%mm2\n&quot;
-                                &quot;pmullw   %%mm1, %%mm3\n&quot;
-                
-                                &quot;paddw    %%mm3, %%mm2\n&quot;
-
-                                &quot;psrlw    $8,    %%mm2 \n&quot;
-
-                                &quot;packuswb %%mm2,%%mm2\n&quot;
-                                &quot;movd     %%mm2, (%2)\n&quot;
-
-                                :: &quot;r&quot; (src), &quot;r&quot; (src2), &quot;r&quot; (dst) );
-                                
-                src+=4;
-                src2+=4;
-                dst+=4;
-                count--;
-        }
-        __asm__ __volatile__ (
-                                &quot;emms\n&quot;
-                                :: );
-        for(uint32_t i=0;i&lt;left;i++)
-        {
-                dst[i] = ((src[i]*alpha) + (src2[i]*beta))&gt;&gt;8;
-        }
-}
-
-#endif
-
-uint8_t ADMVideoResampleFPS::getFrameNumberNoAlloc(uint32_t frame,
-                                             uint32_t *len,
-                                             ADMImage *data,
-                                             uint32_t *flags)
-{
-  ADMImage *mysrc1=NULL;
-  ADMImage *mysrc2=NULL;
-
-  if(frame&gt;=_info.nb_frames) return 0;
-  // read uncompressed frame
-  
-  // What frame are we seeking ?
-  double f;
-  uint32_t page=_info.width*_info.height;
-  
-  f=frame;
-  f*=_in-&gt;getInfo()-&gt;fps1000;
-  f/=_param-&gt;newfps;
-  
-  if(!_param-&gt;use_linear)
-  {
-      uint32_t nw;
-      
-      nw=(uint32_t)floor(f+0.4);
-      if(nw&gt;_in-&gt;getInfo()-&gt;nb_frames-1)
-        nw=_in-&gt;getInfo()-&gt;nb_frames-1;
-    
-      mysrc1=vidCache-&gt;getImage(nw);
-      if(!mysrc1) return 0;
-      
-      memcpy(YPLANE(data),YPLANE(mysrc1),page);
-      memcpy(UPLANE(data),UPLANE(mysrc1),page&gt;&gt;2);
-      memcpy(VPLANE(data),VPLANE(mysrc1),page&gt;&gt;2);
-    
-      vidCache-&gt;unlockAll();
-      
-      return 1;
-  }
-  /* With linear blending */
-  uint32_t nw;
-  uint8_t lowweight;
-  uint8_t highweight;
-  
-  double diff;
-  
-  nw=(uint32_t)floor(f);
-  diff=f-floor(f);
-  highweight = (uint8_t)floor(diff*256);
-  lowweight = 256 - highweight;
-
-  if(nw&gt;=_in-&gt;getInfo()-&gt;nb_frames-1)
-    {
-      printf(&quot;[ResampleFps] In %u Out %u\n&quot;,frame,nw);
-      nw=_in-&gt;getInfo()-&gt;nb_frames-1;
-      highweight=0;
-    }
-  //printf(&quot;New:%lu old:%lu\n&quot;,frame,nw);
-
-  if(highweight == 0)
-    {
-      mysrc1=vidCache-&gt;getImage(nw);  
-      if(!mysrc1) return 0;
-      
-      memcpy(YPLANE(data),YPLANE(mysrc1),page);
-      memcpy(UPLANE(data),UPLANE(mysrc1),page&gt;&gt;2);
-      memcpy(VPLANE(data),VPLANE(mysrc1),page&gt;&gt;2);
-      
-      vidCache-&gt;unlockAll();
-    }
-  else
-    {
-      mysrc1=vidCache-&gt;getImage(nw);
-      mysrc2=vidCache-&gt;getImage(nw+1);
-      if(!mysrc1 || !mysrc2) return 0;
-      
-      uint8_t *out, *in1, *in2;
-      uint32_t count;
-      uint32_t idx;
-      
-      out = YPLANE(data);
-      in1 = YPLANE(mysrc1);
-      in2 = YPLANE(mysrc2);
-        
-      count = page;
-
-#ifdef ADM_CPU_X86
-        if(CpuCaps::hasMMX())
-                blendMMX(in1,in2,out,lowweight,highweight,(count*3)&gt;&gt;1);
-        else
-#endif
-      {
-      for(idx = 0; idx &lt; count; ++idx)
-	out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))&gt;&gt;8;
-
-      out = UPLANE(data);
-      in1 = UPLANE(mysrc1);
-      in2 = UPLANE(mysrc2);
-      count = page&gt;&gt;2;
-
-      for(idx = 0; idx &lt; count; ++idx)
-        out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))&gt;&gt;8;      
-
-
-      out = VPLANE(data);
-      in1 = VPLANE(mysrc1);
-      in2 = VPLANE(mysrc2);
-      count = page&gt;&gt;2;
-
-      for(idx = 0; idx &lt; count; ++idx)
-	out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))&gt;&gt;8;
-      }
-
-      vidCache-&gt;unlockAll();
-    }
-  return 1;
- 
-}
-
-
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidReverse.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidReverse.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidReverse.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,106 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-
-class AVDM_Reverse : public AVDMGenericVideoStream
-{
-  VideoCache      *vidCache;
-  public:
-                                
-    AVDM_Reverse(AVDMGenericVideoStream *in,CONFcouple *couples);    
-    ~AVDM_Reverse(void);
-    uint8_t         getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                          ADMImage *data,uint32_t *flags);
-        
-    char            *printConf( void );
-    uint8_t         configure(AVDMGenericVideoStream *in);
-    uint8_t         getCoupledConf( CONFcouple **couples);
-};
-
-static FILTER_PARAM reverseParam={0,{&quot;&quot;}};
-
-BUILD_CREATE(reverse_create,AVDM_Reverse);
-SCRIPT_CREATE(reverse_script,AVDM_Reverse,reverseParam);
-
-/*************************************/
-
-uint8_t AVDM_Reverse::configure(AVDMGenericVideoStream *in)
-{
-  _in=in;
-  return 1;
-        
-}
-
-char *AVDM_Reverse::printConf( void )
-{
-  static char buf[50];
-
-        //ADM_assert(_param);
-  sprintf((char *)buf,&quot; Reverse&quot;);
-  return buf;
-}
-
-
-AVDM_Reverse::AVDM_Reverse(AVDMGenericVideoStream *in,CONFcouple *couples)
-
-{
-                
-  int count = 0;
-  char buf[80];
-  unsigned int *p;
-
-  _in=in;         
-  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-  _info.encoding=1;
-  vidCache=new VideoCache(18,in);
-}
-//________________________________________________________
-uint8_t AVDM_Reverse::getCoupledConf( CONFcouple **couples)
-{
-  *couples=NULL;
-  return 1;
-}
-//________________________________________________________
-AVDM_Reverse::~AVDM_Reverse(void)
-{
-                
-  if(vidCache) delete vidCache;                
-  vidCache=NULL;   
-}
-uint8_t AVDM_Reverse::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                     ADMImage *data,uint32_t *flags)
-{
-
-  uint32_t num_frames,tgt;
-  ADMImage *src;
-
-  num_frames=_in-&gt;getInfo()-&gt;nb_frames;   // ??
-  if(frame&gt;=num_frames) return 0;
-  
-  tgt=num_frames-frame-1;
-
-  src=vidCache-&gt;getImage(tgt);
-  if(!src) return 0;
-  data-&gt;duplicate(src);
-
-  vidCache-&gt;unlockAll();
-  return 1;
-}
-//EOF
-
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,516 +0,0 @@
-/***************************************************************************
-                          ADM_vidVlad.cpp  -  description
-                             -------------------
-    begin                : Fri Jan 3 2003
-    copyright            : (C) 2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-    
-    Port from Vlad59 / Jim Casaburi TemporalCleaner from avisynth YV12
-    
-    Luma only
-   	Patch by Daniel Glockner 
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_vidVlad.h&quot;
-
-#include &quot;DIA_factory.h&quot;
-
-#ifdef ADM_CPU_X86_64
-#define COUNTER long int
-#else
-#define COUNTER int
-#endif
-
-#ifdef ADM_CPU_X86
-static void ProcessCPlane_mmxe(unsigned char *source,
-				   unsigned char *prev,
-				   unsigned char* dest,
-				   unsigned char* mask,
-				   int width, int height,
-				   uint64_t  threshold);
-static void ProcessYPlane_mmxe( unsigned char *source,
-				    unsigned char *prev,
-				    unsigned char* dest,
-				    unsigned char* mask,
-				    long  int width, long int height,
-				    uint64_t  threshold);
-#endif
-static void ProcessCPlane_C(unsigned char *source,
-				   unsigned char *prev,
-				   unsigned char* dest,
-				   unsigned char* mask,
-				   int width, int height,
-				   uint64_t  threshold);
-static void ProcessYPlane_C( unsigned char *source,
-				    unsigned char *prev,
-				    unsigned char* dest,
-				    unsigned char* mask,
-				    long  int width, long int height,
-				    uint64_t  threshold);
-
-#define EXPAND(x) { x=x+(x&lt;&lt;8)+(x&lt;&lt;16)+(x&lt;&lt;24)+(x&lt;&lt;32)+(x&lt;&lt;40) \
-										+(x&lt;&lt;48)+(x&lt;&lt;56);}
-static FILTER_PARAM vladParam={2,{&quot;ythresholdMask&quot;,&quot;cthresholdMask&quot;}};
-
-
-SCRIPT_CREATE(vladsmooth_script,AVDMVideoVlad,vladParam);
-BUILD_CREATE(vladsmooth_create,AVDMVideoVlad);
-
-
-char *AVDMVideoVlad::printConf(void)
-{
-	static char buf[50];
- 	
-	sprintf((char *)buf,&quot; Temporal Cleaner : Y: %02lu / c: %02lu&quot;,_param-&gt;ythresholdMask,
-				_param-&gt;cthresholdMask	);
-        return buf;
-}
-
-
-uint8_t AVDMVideoVlad::configure( AVDMGenericVideoStream *instream)
-{
-UNUSED_ARG(instream);
-int i,j;
-
-   diaElemUInteger luma(&amp;(_param-&gt;ythresholdMask),QT_TR_NOOP(&quot;_Luma temporal threshold:&quot;),0,255);
-   diaElemUInteger chroma(&amp;(_param-&gt;cthresholdMask),QT_TR_NOOP(&quot;Ch_roma temporal threshold:&quot;),0,255);
-    
-    diaElem *elems[]={&amp;luma,&amp;chroma};
-  
-    if(diaFactoryRun(QT_TR_NOOP(&quot;Temporal Cleaner&quot;),sizeof(elems)/sizeof(diaElem *),elems))
-    {
-      ythresholdMask = (uint64_t)_param-&gt;ythresholdMask;
-      cthresholdMask = (uint64_t)_param-&gt;cthresholdMask;	   
-
-      EXPAND(	ythresholdMask);
-      EXPAND(	cthresholdMask);	
-      return 1;
-    }
-    return 0;
-}
-AVDMVideoVlad::AVDMVideoVlad(  AVDMGenericVideoStream *in,CONFcouple *couples)
-		
-
-{
-	_in=in;
-	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-	num_frame=0xFFFF0000;
-	if(couples)
-	{
-		_param=NEW(VLAD_PARAM);
-		GET(ythresholdMask);
-		GET(cthresholdMask);
-	}
-	else
-	{
-		_param=NEW(VLAD_PARAM);
-		ADM_assert(_param);
-	  _param-&gt;ythresholdMask=5;
- 	  _param-&gt;cthresholdMask=0;
-   }
-    	_mask=new uint8_t[_info.width*_info.height/4];
-  	memset(_mask,0,	_info.width*_info.height/4);
-	  
-	   ythresholdMask=0;
-	   ythresholdMask = (uint64_t)_param-&gt;ythresholdMask;
-	   cthresholdMask = (uint64_t)_param-&gt;cthresholdMask;	   
-
-		EXPAND(	ythresholdMask);
-		EXPAND(	cthresholdMask);
-	vidCache=new VideoCache(2,in);
-
-	ProcessYPlane = ProcessYPlane_C;
-	ProcessCPlane = ProcessCPlane_C;
-#ifdef ADM_CPU_X86
-#if 0
-// Check
-	if(CpuCaps::hasMMXEXT() &amp;&amp; (_info.width&amp;7) == 0)
-	{
-		ProcessYPlane = ProcessYPlane_mmxe;
-		ProcessCPlane = ProcessCPlane_mmxe;
-	}
-#endif	
-#endif
-}
-
-
-uint8_t	AVDMVideoVlad::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(2);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-	CSET(ythresholdMask);
-	CSET(cthresholdMask);
-	return 1;
-
-}
-AVDMVideoVlad::~AVDMVideoVlad()
-{
-		delete [] _mask;
-		DELETE(_param);
-		delete vidCache;
-}  									
-
-void ProcessYPlane_C( unsigned char *source,
-				    unsigned char *prev,
-				    unsigned char* dest,
-				    unsigned char* mask, 
-				    long  int width, long int height,
-				    uint64_t  threshold)
-{
-	int thp=threshold&amp;0xff;
-	int thn=-thp;
-	
-	width &gt;&gt;= 1;
-
-	for (int y = height &gt;&gt; 1; --y &gt;= 0;)
-	{
-		int x2 = -width;
-		int x = x2*2;
-
-		source += 4*width;
-		prev += 4*width;
-		dest += 4*width;
-		mask += width;
-
-		do {
-			int yc,yp;
-			int m = 0;
-			yc=source[x*2];
-			yp=prev[x*2];
-			if(thn&lt;=yc-yp &amp;&amp; yc-yp&lt;=thp) {
-				yc=(yc+yp+1)&gt;&gt;1;
-				m=1;
-			}
-			source[x*2]=dest[x*2]=yc;
-
-			yc=source[x*2+1];
-			yp=prev[x*2+1];
-			if(thn&lt;=yc-yp &amp;&amp; yc-yp&lt;=thp) {
-				yc=(yc+yp+1)&gt;&gt;1;
-				m++;
-			}
-			source[x*2+1]=dest[x*2+1]=yc;
-
-			x++;
-
-			yc=source[x2*2];
-			yp=prev[x2*2];
-			if(thn&lt;=yc-yp &amp;&amp; yc-yp&lt;=thp) {
-				yc=(yc+yp+1)&gt;&gt;1;
-				m++;
-			}
-			source[x2*2]=dest[x2*2]=yc;
-
-			yc=source[x2*2+1];
-			yp=prev[x2*2+1];
-			if(thn&lt;=yc-yp &amp;&amp; yc-yp&lt;=thp) {
-			  yc=(yc+yp+1)&gt;&gt;1;
-			  m++;
-			}
-			source[x2*2+1]=dest[x2*2+1]=yc;
-
-			mask[x2]=m;
-		} while(++x2 &lt; 0);
-	}
-}
-
-void ProcessCPlane_C( unsigned char *source,
-				    unsigned char *prev,
-				    unsigned char* dest,
-				    unsigned char* mask, 
-				    int width, int height,
-				    uint64_t  threshold)
-{
-	int thp = threshold&amp;0xff;
-	int thn = -thp;
-	long int i = width*height;
-	
-	source += i;
-	prev += i;
-	dest += i;
-	mask += i;
-	i = -i;
-	
-	do {
-		int cc,cp;
-		cc=source[i];
-		cp=prev[i];
-		if(thn&lt;=cc-cp &amp;&amp; cc-cp&lt;=thp &amp;&amp; mask[i]&gt;3) {
-			cc=(cc+cp+1)&gt;&gt;1;
-		}
-		source[i]=dest[i]=cc;
-	} while(++i &lt; 0);
-}
-
-#ifdef ADM_CPU_X86
-void ProcessYPlane_mmxe( unsigned char *source,
-				    unsigned char *prev,
-				    unsigned char* dest,
-				    unsigned char* mask, 
-				    long  int width, long int height,
-				    uint64_t  threshold)
-{
-	COUNTER tmp,tmp2;
-	long int  h2, w8;
-
-	w8 = -(width &gt;&gt; 3);
-	width &gt;&gt;= 1;
-
-__asm__ __volatile__(
-			&quot;movq (%0),%%mm6 \n\t&quot;
-			:
-			: &quot;r&quot;(&amp;threshold)
-		);
-	
-	for (h2 = height &gt;&gt; 1; --h2 &gt;= 0;)
-	{
-		source += 4*width;
-		prev += 4*width;
-		dest += 4*width;
-		mask += width;
-
-#define REG_source &quot;%2&quot;
-#define REG_dest &quot;%3&quot;
-#define REG_prev &quot;%4&quot;
-#define REG_mask &quot;%5&quot;
-#define REG_counter &quot;%0&quot;
-#define REG_counter2 &quot;%1&quot;
-	  
-__asm__ __volatile__(
-&quot;prefetchnta (&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;prefetchnta (&quot;REG_prev&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;.p2align 4\n\t&quot;
-&quot;pxor %%mm7,%%mm7\n\t&quot;
-&quot;HLine%=:  \n\t&quot;
-
-&quot;prefetchnta (&quot;REG_source&quot;,&quot;REG_counter2&quot;,8) \n\t&quot;
-&quot;prefetchnta (&quot;REG_prev&quot;,&quot;REG_counter2&quot;,8) \n\t&quot;
-
-&quot;movq (&quot;REG_source&quot;,&quot;REG_counter&quot;,8),%%mm0 \n\t&quot;   // mm0 &lt;- lsource+(size/8)*8
-&quot;movq (&quot;REG_prev&quot;,&quot;REG_counter&quot;,8),%%mm1 \n\t&quot;     // mm1 &lt;- lprev+(size/8)*8
-&quot;movq %%mm0,%%mm2 \n\t&quot;               // mm2 &lt;- mm0  source
-&quot;movq %%mm1,%%mm3 \n\t&quot;               // mm3 &lt;-mm1   oold
-&quot;psubusb %%mm1,%%mm0 \n\t&quot;            // mm0=mm0-mm1
-&quot;psubusb %%mm2,%%mm1 \n\t&quot;            // mm1=mm1-mm2
-&quot;por %%mm1,%%mm0 \n\t&quot;                // mm0=mm0 or mm1
-&quot;pavgb %%mm2,%%mm3 \n\t&quot;              // mm3= 'mm2+mm3&quot;/2
-&quot; \n\t&quot;                               // mm0=mm6-mm0 diff to threshold
-&quot;psubusb %%mm6,%%mm0 \n\t&quot;  // &gt;0 ?
-&quot;pcmpeqb %%mm7,%%mm0 \n\t&quot;
-&quot; \n\t&quot;
-&quot;movq %%mm0,%%mm4 \n\t&quot;               // masked diff &gt;m4
-&quot; \n\t&quot;
-&quot;pand %%mm0,%%mm3 \n\t&quot;               // mm0=old and mask diff
-&quot;pandn %%mm2,%%mm0 \n\t&quot;              // mm1= source and invert diff
-&quot;por %%mm3,%%mm0 \n\t&quot;                // m0 = mix
-&quot;movq %%mm0,(&quot;REG_dest&quot;,&quot;REG_counter&quot;,8) \n\t&quot;   // store to des+ecx*8
-&quot;movq %%mm0,(&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot; // store to mask+ecx*8
-
-&quot;movq (&quot;REG_source&quot;,&quot;REG_counter2&quot;,8),%%mm0 \n\t&quot;  // mm0 &lt;- lsource+(size/8)*8
-&quot;movq (&quot;REG_prev&quot;,&quot;REG_counter2&quot;,8),%%mm1 \n\t&quot;    // mm1 &lt;- lprev+(size/8)*8
-
-&quot;prefetchnta 8(&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;prefetchnta 8(&quot;REG_prev&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;add $1,&quot;REG_counter&quot; \n\t&quot;
-
-&quot;movq %%mm0,%%mm2 \n\t&quot;               // mm2 &lt;- mm0  source
-&quot;movq %%mm1,%%mm3 \n\t&quot;               // mm3 &lt;- mm1  oold
-&quot;psubusb %%mm1,%%mm0 \n\t&quot;            // mm0=mm0-mm1
-&quot;psubusb %%mm2,%%mm1 \n\t&quot;            // mm1=mm1-mm2
-&quot;por %%mm1,%%mm0 \n\t&quot;                // mm0=mm0 or mm1
-&quot;pavgb %%mm2,%%mm3 \n\t&quot;              // mm3= 'mm2+mm3&quot;/2
-&quot; \n\t&quot;                               // mm0=mm6-mm0 diff to threshold
-&quot;psubusb %%mm6,%%mm0 \n\t&quot;  // &gt;0 ?
-&quot;pcmpeqb %%mm7,%%mm0 \n\t&quot;
-&quot; \n\t&quot;
-
-&quot;pand %%mm0,%%mm4 \n\t&quot;
-&quot;movq %%mm4,%%mm1 \n\t&quot;               // masked diff -&gt; mm1
-&quot;psrlw $8,%%mm4 \n\t&quot;                 // shift
-&quot;pand %%mm4,%%mm1 \n\t&quot;               // if right &amp; left triggered
-&quot;packuswb %%mm1,%%mm1 \n\t&quot;           // packed to 4 bytes
-&quot;movd %%mm1,(&quot;REG_mask&quot;,&quot;REG_counter2&quot;,4) \n\t&quot;     // store mask m4-&gt;mask+ecx*4
-
-&quot; \n\t&quot;
-&quot;pand %%mm0,%%mm3 \n\t&quot;               // mm3 = old and mask diff
-&quot;pandn %%mm2,%%mm0 \n\t&quot;              // mm0 = source and invert diff
-&quot;por %%mm3,%%mm0 \n\t&quot;                // mm0 = mix
-&quot;movq %%mm0,(&quot;REG_dest&quot;,&quot;REG_counter2&quot;,8) \n\t&quot;   // store to des+ecx*8
-&quot;movq %%mm0,(&quot;REG_source&quot;,&quot;REG_counter2&quot;,8) \n\t&quot; // store to mask+ecx*8
-
-
-&quot;add $1,&quot;REG_counter2&quot; \n\t&quot;          // add 1 to ecv
-&quot;jnz HLine%=&quot;                         // while !=0
- : &quot;=r&quot;(tmp), &quot;=r&quot;(tmp2)
- : &quot;r&quot;(source), &quot;r&quot;(dest), &quot;r&quot;(prev),
-   &quot;r&quot;(mask)
-   , &quot;0&quot;(2*w8), &quot;1&quot;(w8)
- );
-
-	}
- __asm__ __volatile__(&quot;emms \n\t&quot;);
-}
-
-
-//#pragma -O0
-
-void ProcessCPlane_mmxe(unsigned char *source,
-				   unsigned char *prev, 
-				   unsigned char* dest, 
-				   unsigned char* mask, 
-				   int width, int height,
-				   uint64_t  threshold)
-{
-	long int w8;
-	COUNTER tmp;
-
-	w8 = width*height;
-	source += w8;
-	dest += w8;
-	prev += w8;
-	mask += w8;
-	w8 = -(w8&gt;&gt;3);
-
-__asm__ __volatile__(
-			&quot;movq (%0),%%mm6 \n\t&quot;
-			:
-			: &quot;r&quot;(&amp;threshold)
-		);
-	
-__asm__ __volatile__ (
-&quot;prefetchnta (&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;prefetchnta (&quot;REG_prev&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;prefetchnta (&quot;REG_mask&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;.p2align 4\n\t&quot;
-&quot;pxor %%mm7,%%mm7\n\t&quot;
-&quot;Lfoo%=:  \n\t&quot;
-&quot;prefetchnta 8(&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;prefetchnta 8(&quot;REG_prev&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;prefetchnta 8(&quot;REG_mask&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;movq (&quot;REG_source&quot;,&quot;REG_counter&quot;,8),%%mm0 \n\t&quot;
-&quot;movq (&quot;REG_prev&quot;,&quot;REG_counter&quot;,8),%%mm1 \n\t&quot;
-&quot;movq %%mm0,%%mm2 \n\t&quot;
-&quot;movq %%mm1,%%mm3 \n\t&quot;
-&quot;psubusb %%mm1,%%mm0 \n\t&quot;
-&quot;psubusb %%mm2,%%mm1 \n\t&quot;
-&quot;por %%mm1,%%mm0 \n\t&quot;
-&quot;pavgb %%mm2,%%mm3 \n\t&quot;
-&quot; \n\t&quot;
-&quot;psubusb %%mm6,%%mm0 \n\t&quot;
-&quot;pcmpeqb %%mm7,%%mm0 \n\t&quot;
-&quot; \n\t&quot;
-&quot;pand (&quot;REG_mask&quot;,&quot;REG_counter&quot;,8),%%mm0 \n\t&quot;
-&quot; \n\t&quot;
-&quot;pand %%mm0,%%mm3 \n\t&quot;
-&quot;pandn %%mm2,%%mm0 \n\t&quot;
-&quot;por %%mm3,%%mm0 \n\t&quot;
-&quot;movq %%mm0,(&quot;REG_dest&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;movq %%mm0,(&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
-&quot;add $1,&quot;REG_counter&quot; \n\t&quot;
-&quot;jnz Lfoo%= \n\t&quot;
- : &quot;=r&quot;(tmp)
- : &quot;0&quot;(w8), &quot;r&quot;(source), &quot;r&quot;(dest), &quot;r&quot;(prev),
-   &quot;r&quot;(mask)
- 
- );
-	__asm__ __volatile__(&quot;emms \n\t&quot;);
-}
-#endif
-
-//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
-//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
-//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
-//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
-uint8_t AVDMVideoVlad::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-	
-	uint32_t page=_info.width*_info.height;
-	ADMImage *cur,*prev;
-	
-		if(frame&gt;(_info.nb_frames-1)) return 0;
-		
-		*len=(page*3)&gt;&gt;1;
-		
-		if(frame)
-		{
-		 	prev=vidCache-&gt;getImage(frame-1);
-			if(!prev)
-				return 0;
-		}
-		
-		cur=vidCache-&gt;getImage(frame);
-		if(!cur)
-		{
-			vidCache-&gt;unlockAll();
-			return 0;
-		}
-		data-&gt;copyInfo(cur);
-		if(!frame)
-		{
-			
-			data-&gt;duplicate(cur);
-			vidCache-&gt;unlockAll();
-			return 1  ;
-		}
-		
-		
-			  
-		ProcessYPlane (YPLANE(cur),
-				YPLANE(prev),     	
-				YPLANE(data), 
-				_mask, 
-				_info.width, 
-		       		_info.height,
-				ythresholdMask);
-		if (0==_param-&gt;cthresholdMask)
-		{
-			//memcpy(data-&gt;data+page,_uncompressed-&gt;data+page,page&gt;&gt;1);
-			memcpy(UPLANE(data),UPLANE(cur),page&gt;&gt;2);
-			memcpy(VPLANE(data),VPLANE(cur),page&gt;&gt;2);
-		}
-		else
-		{
-			
-				ProcessCPlane (UPLANE(cur),
-							UPLANE(prev),     	
-							UPLANE(data), 
-							_mask, 
-							_info.width&gt;&gt;1, 
-							_info.height&gt;&gt;1,
-							cthresholdMask);       
-				
-			
-				ProcessCPlane (VPLANE(cur),
-							VPLANE(prev),     	
-							VPLANE(data), 
-							_mask, 
-							_info.width&gt;&gt;1, 
-							_info.height&gt;&gt;1,
-							cthresholdMask);       				
-			
-			}
-		
-		vidCache-&gt;unlockAll();
-		return 1;
-
-}
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.h	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.h	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,61 +0,0 @@
-/***************************************************************************
-                          ADM_vidVlad.h  -  description
-                             -------------------
-    begin                : Fri Jan 3 2003
-    copyright            : (C) 2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef __VLAD__
-#define __VLAD__   
-typedef struct VLAD_PARAM
-{
-	uint32_t ythresholdMask;
-	uint32_t cthresholdMask;
-}VLAD_PARAM;
- class  AVDMVideoVlad:public AVDMGenericVideoStream
- {
-
- protected:
-
-        			VLAD_PARAM	*_param;
-        			virtual char 	*printConf(void);
-	      			uint8_t		*_mask;
-	      			VideoCache	*vidCache;
-	      			
-        			uint64_t		ythresholdMask;
-				uint64_t 		cthresholdMask;
-				uint32_t 		num_frame;
-				void (*ProcessCPlane)(unsigned char *source,
-				                      unsigned char *prev,
-				                      unsigned char* dest,
-				                      unsigned char* mask,
-				                      int width, int height,
-				                      uint64_t  threshold);
-				void (*ProcessYPlane)(unsigned char *source,
-				                      unsigned char *prev,
-				                      unsigned char* dest,
-				                      unsigned char* mask,
-				                      long int width,
-				                      long int height,
-				                      uint64_t  threshold);
- public:
-
-
-						AVDMVideoVlad(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  					 	~AVDMVideoVlad();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          							ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
-			virtual uint8_t	getCoupledConf( CONFcouple **couples)		;
- }     ;
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,416 +0,0 @@
-/*
-	Yadif C-plugin for Avisynth 2.5 - Yet Another DeInterlacing Filter
-	Copyright (C)2007 Alexander G. Balakhnin aka Fizick  <A HREF="http://avisynth.org.ru">http://avisynth.org.ru</A>
-    Port of YADIF filter from MPlayer
-	Copyright (C) 2006 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
-
-    This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-    Avisynth_C plugin
-	Assembler optimized for GNU C compiler
-
-*/
-/*
-  Ported to avidemux by mean
-  Same license as original (?GPL)
-*/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;DIA_factory.h&quot;
-//************************************************
-#define MIN(a,b) ((a) &gt; (b) ? (b) : (a))
-#define MAX(a,b) ((a) &lt; (b) ? (b) : (a))
-#define ABS(a) ((a) &gt; 0 ? (a) : (-(a)))
-
-#define MIN3(a,b,c) MIN(MIN(a,b),c)
-#define MAX3(a,b,c) MAX(MAX(a,b),c)
-
-//===========================================================================//
-#ifdef ADM_CPU_X86
-extern &quot;C&quot;
-{
-void filter_line_mmx2(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity);
-}
-#endif
-//
-typedef struct YADIF_PARAM
-{
-    uint32_t mode;
-    uint32_t order;
-}YADIF_PARAM;
-
-class  ADMVideoYadif:public AVDMGenericVideoStream
-{
-
- protected:
-  virtual char                 *printConf(void);
-  YADIF_PARAM                  *_param;
-   VideoCache                  *vidCache;
-  void                         updateInfo(void);
-
- public:
-                  ADMVideoYadif(AVDMGenericVideoStream *in, CONFcouple *setup);
-  virtual         ~ADMVideoYadif();
-  virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
-  virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data,uint32_t *flags);
-  virtual uint8_t	getCoupledConf( CONFcouple **couples)				;
- }     ;
-
-static FILTER_PARAM yadifParam={2,{&quot;mode&quot;,&quot;order&quot;}};
-
-
-SCRIPT_CREATE(yadif_script,ADMVideoYadif,yadifParam);
-BUILD_CREATE(yadif_create,ADMVideoYadif);
-//
-static void filter_plane(int mode, uint8_t *dst, int dst_stride, const uint8_t *prev0, const uint8_t *cur0, const uint8_t *next0, int refs, int w, int h, int parity, int tff, int mmx);
-
-
-/*   Hook to build it as a dll */
-extern &quot;C&quot;
-{
-SCRIPT_CREATE(FILTER_create_fromscript,ADMVideoYadif,yadifParam);
-BUILD_CREATE(FILTER_create,ADMVideoYadif);
-char *FILTER_getName(void)
-{
-	return &quot;DynYadif&quot;;
-}
-char *FILTER_getDesc(void)
-{
-	return &quot;YADIF&quot;;
-}
-uint32_t FILTER_getVersion(void)
-{
-  return 1; 
-}
-uint32_t FILTER_getAPIVersion(void)
-{
-  return ADM_FILTER_API_VERSION; 
-}
-}
-//***************************************************
-//***************************************************
-char *ADMVideoYadif::printConf( void )
-{
-  static char buf[50];
- 	
-  sprintf((char *)buf,&quot; Yadif : mode %u order %d&quot;,_param-&gt;mode, _param-&gt;order);
-  return buf;
-}
-
-ADMVideoYadif::ADMVideoYadif(AVDMGenericVideoStream *in, CONFcouple *couples)
-{
-  _in=in;		
-
-  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info)); 
-  _info.encoding=1;
-
- // _uncompressed=new uint8_t [3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height];
- 
-
-  if(couples)
-  {
-   	 _param=new (YADIF_PARAM);
-	GET(mode);
-        GET(order);
-  }
-  else
-  {
-    _param = new ( YADIF_PARAM);
-    _param-&gt;mode=0;
-    _param-&gt;order=1;
-  }
-  _uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-  ADM_assert(_uncompressed);    	  	
-  vidCache = new VideoCache (10, in);
-  updateInfo();
-}
-
-void ADMVideoYadif::updateInfo(void)
-{
-   memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info)); 
-  if(_param-&gt;mode &amp;1 ) // Bob
-  {
-    _info.nb_frames*=2;
-    _info.fps1000*=2;
-  }
-}
-
-uint8_t ADMVideoYadif::configure( AVDMGenericVideoStream *instream) 
-{
-  _in= instream;
-     diaMenuEntry tMode[]={
-                             {0,      QT_TR_NOOP(&quot;Temporal &amp; spatial check&quot;),NULL},
-                             {1,   QT_TR_NOOP(&quot;Bob, temporal &amp; spatial check&quot;),NULL},
-                             {2,      QT_TR_NOOP(&quot;Skip spatial temporal check&quot;),NULL},
-                             {3,  QT_TR_NOOP(&quot;Bob, skip spatial temporal check&quot;),NULL}
-          };
-     diaMenuEntry tOrder[]={
-                             {0,      QT_TR_NOOP(&quot;Bottom field first&quot;),NULL},
-                             {1,   QT_TR_NOOP(&quot;Top field first&quot;),NULL}
-          };
-  
-     diaElemMenu mMode(&amp;(_param-&gt;mode),   QT_TR_NOOP(&quot;_Mode:&quot;), 4,tMode);
-     diaElemMenu morder(&amp;(_param-&gt;order),   QT_TR_NOOP(&quot;_Order:&quot;), 2,tOrder);
-     
-     diaElem *elems[]={&amp;mMode,&amp;morder};
-     
-     if(diaFactoryRun(QT_TR_NOOP(&quot;yadif&quot;),sizeof(elems)/sizeof(diaElem *),elems))
-     {
-        updateInfo();
-        return 1;
-     }
-     return 0;
-}
-
-uint8_t	ADMVideoYadif::getCoupledConf( CONFcouple **couples)
-{
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-
-          ADM_assert(_param);
-          *couples=new CONFcouple(2);
-
-          CSET(mode);
-          CSET(order);
-          return 1;
-
-}
-
-
-ADMVideoYadif::~ADMVideoYadif()
-{
-        delete  _uncompressed;
-        _uncompressed=NULL;
-       
-        delete vidCache;
-        vidCache = NULL;
-        
-        delete _param;
-        _param=NULL;
-}
-
-uint8_t ADMVideoYadif::getFrameNumberNoAlloc(uint32_t frame,
-                                              uint32_t *len,
-                                              ADMImage *data,
-                                              uint32_t *flags)
-{
-        int mode;
-        int parity;
-        int tff;
-        int iplane;
-        int cpu;
-        int n;
-        ADMImage *src, *dst, * prev, *next;
-
-    
-        mode = _param-&gt;mode;
-
-        if (mode &amp; 1) 
-                n = (frame&gt;&gt;1); // bob
-        else
-                n = frame;
-
-        src = vidCache-&gt;getImage(n);
-  // Request frame 'n' from the child (source) clip.
-
-        if (n&gt;0)
-                prev =  vidCache-&gt;getImage( n-1); // get previous frame
-        else
-                prev= vidCache-&gt;getImage(0); // get very first frame
-
-        if (n&lt; _in-&gt;getInfo()-&gt;nb_frames-1)
-                next = vidCache-&gt;getImage( n+1); // get next frame
-        else
-                next = vidCache-&gt;getImage( _in-&gt;getInfo()-&gt;nb_frames-1); // get last frame
-
-        dst = data;
-        
-        if(!prev || !src || !next)
-        {
-            printf(&quot;Failed to read frame for frame %u\n&quot;,frame);
-            vidCache-&gt;unlockAll();
-            return 0;
-        }
-        
-  // Construct a frame based on the information of the current frame
-  // contained in the &quot;vi&quot; struct.
-#if 0 //MEANX
-        if (_params-&gt;order == -1)
-//		tff = avs_is_tff(&amp;p-&gt;vi) == 0 ? 0 : 1; // 0 or 1
-                tff = avs_get_parity(p-&gt;child, n) ? 1 : 0; // 0 or 1
-        else
-#endif
-                tff = _param-&gt;order;	
-        
-        parity = (mode &amp; 1) ? (frame &amp; 1) ^ (1^tff) : (tff ^ 1);  // 0 or 1
-
-      //MEANX  cpu = avs_get_cpu_flags(p-&gt;env);
-
-        for (iplane = 0; iplane&lt;3; iplane++)
-        {
-                ADM_PLANE plane = (iplane==0) ? PLANAR_Y : (iplane==1) ? PLANAR_U : PLANAR_V;
-
-                const unsigned char* srcp = src-&gt;GetWritePtr(plane);
-          // Request a Read pointer from the current source frame
-
-                const unsigned char* prevp0 = prev-&gt;GetWritePtr( plane);
-                unsigned char* prevp = (unsigned char*) prevp0; // with same pitch
-          // Request a Read pointer from the prev source frame.
-
-                const unsigned char* nextp0 = next-&gt;GetWritePtr( plane);
-                unsigned char* nextp = (unsigned char*) nextp0; // with same pitch
-          // Request a Read pointer from the next source frame.
-
-                unsigned char* dstp = dst-&gt;GetWritePtr( plane);
-                // Request a Write pointer from the newly created destination image.
-          // You can request a writepointer to images that have just been
-
-                const int dst_pitch = dst-&gt;GetPitch( plane);
-          // Requests pitch (length of a line) of the destination image.
-          // For more information on pitch see: <A HREF="http://www.avisynth.org/index.php?page=WorkingWithImages">http://www.avisynth.org/index.php?page=WorkingWithImages</A>
-                // (short version - pitch is always equal to or greater than width to allow for seriously fast assembly code)
-
-                const int width =dst-&gt;GetPitch( plane);
-          // Requests rowsize (number of used bytes in a line.
-          // See the link above for more information.
-
-                const int height = dst-&gt;GetHeight( plane);
-          // Requests the height of the destination image.
-
-                const int src_pitch = src-&gt;GetPitch(plane);
-                const int prev_pitch = prev-&gt;GetPitch(plane);
-                const int next_pitch = next-&gt;GetPitch(plane);
-
-                // in v.0.1-0.3  all source pitches are  assumed equal (for simplicity)
-                                // consider other (rare) case
-                if (prev_pitch != src_pitch)
-                {
-                    prevp = (unsigned char *)ADM_alloc(height*src_pitch);
-                    int h;
-                    for (h=0; h&lt;0; h++)
-                      memcpy(prevp+h*src_pitch, prevp0+h*prev_pitch, width);
-                }
-                    
-                if (next_pitch != src_pitch)
-                {
-                    nextp = (unsigned char *)ADM_alloc(height*src_pitch);
-                    int h;
-                    for (h=0; h&lt;0; h++)
-                      memcpy(nextp+h*src_pitch, nextp0+h*next_pitch, width);
-                }
-                    
-                filter_plane(mode, dstp, dst_pitch, prevp, srcp, nextp, src_pitch, width, height, parity, tff, 0);
-                if (prev_pitch != src_pitch)
-                        ADM_dealloc(prevp);
-                if (next_pitch != src_pitch)
-                        ADM_dealloc(nextp);
-        }
-       vidCache-&gt;unlockAll();
-      return 1;
-}
-//****************
-
-static void filter_line_c(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity){
-    int x;
-    const uint8_t *prev2= parity ? prev : cur ;
-    const uint8_t *next2= parity ? cur  : next;
-    for(x=0; x&lt;w; x++){
-        int c= cur[-refs];
-        int d= (prev2[0] + next2[0])&gt;&gt;1;
-        int e= cur[+refs];
-        int temporal_diff0= ABS(prev2[0] - next2[0]);
-        int temporal_diff1=( ABS(prev[-refs] - c) + ABS(prev[+refs] - e) )&gt;&gt;1;
-        int temporal_diff2=( ABS(next[-refs] - c) + ABS(next[+refs] - e) )&gt;&gt;1;
-        int diff= MAX3(temporal_diff0&gt;&gt;1, temporal_diff1, temporal_diff2);
-        int spatial_pred= (c+e)&gt;&gt;1;
-        int spatial_score= ABS(cur[-refs-1] - cur[+refs-1]) + ABS(c-e)
-                         + ABS(cur[-refs+1] - cur[+refs+1]) - 1;
-
-#define CHECK(j)\
-    {   int score= ABS(cur[-refs-1+ j] - cur[+refs-1- j])\
-                 + ABS(cur[-refs  + j] - cur[+refs  - j])\
-                 + ABS(cur[-refs+1+ j] - cur[+refs+1- j]);\
-        if(score &lt; spatial_score){\
-            spatial_score= score;\
-            spatial_pred= (cur[-refs  + j] + cur[+refs  - j])&gt;&gt;1;\
-
-        CHECK(-1) CHECK(-2) }} }}
-        CHECK( 1) CHECK( 2) }} }}
-
-        if(mode&lt;2){
-            int b= (prev2[-2*refs] + next2[-2*refs])&gt;&gt;1;
-            int f= (prev2[+2*refs] + next2[+2*refs])&gt;&gt;1;
-#if 0
-            int a= cur[-3*refs];
-            int g= cur[+3*refs];
-            int max= MAX3(d-e, d-c, MIN3(MAX(b-c,f-e),MAX(b-c,b-a),MAX(f-g,f-e)) );
-            int min= MIN3(d-e, d-c, MAX3(MIN(b-c,f-e),MIN(b-c,b-a),MIN(f-g,f-e)) );
-#else
-            int max= MAX3(d-e, d-c, MIN(b-c, f-e));
-            int min= MIN3(d-e, d-c, MAX(b-c, f-e));
-#endif
-
-            diff= MAX3(diff, min, -max);
-        }
-
-        if(spatial_pred &gt; d + diff)
-           spatial_pred = d + diff;
-        else if(spatial_pred &lt; d - diff)
-           spatial_pred = d - diff;
-
-        dst[0] = spatial_pred;
-
-        dst++;
-        cur++;
-        prev++;
-        next++;
-        prev2++;
-        next2++;
-    }
-}
-
-void filter_plane(int mode, uint8_t *dst, int dst_stride, const uint8_t *prev0, const uint8_t *cur0, const uint8_t *next0, int refs, int w, int h, int parity, int tff, int mmx)
-{
-void (*filter_line)(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity);
-	int y;
-	filter_line = filter_line_c;
-#ifdef ADM_CPU_X86
-	if (CpuCaps::hasMMXEXT()) 
-		filter_line = filter_line_mmx2;
-#endif
-
-        memcpy(dst, cur0, w);
-        memcpy(dst + dst_stride, cur0 + refs, w);
-        for(y=2; y&lt;h-1; y++){
-            if(((y ^ parity) &amp; 1)){
-                const uint8_t *prev= prev0 + y*refs;
-                const uint8_t *cur = cur0 + y*refs;
-                const uint8_t *next= next0 + y*refs;
-                uint8_t *dst2= dst + y*dst_stride;
-                filter_line(mode, dst2, prev, cur, next, w, refs, (parity ^ tff));
-            }else{
-                memcpy(dst + y*dst_stride, cur0 + y*refs, w);
-            }
-        }
-        memcpy(dst + (h-1)*dst_stride, cur0 + (h-1)*refs, w);
-
-#ifdef ADM_CPU_X86
-	if (CpuCaps::hasMMXEXT()) 
-		asm volatile(&quot;emms&quot;);
-#endif
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif_asm.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif_asm.c	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif_asm.c	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1,227 +0,0 @@
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;inttypes.h&gt;
-#include &lt;math.h&gt;
-
-#include &quot;ADM_default.h&quot;
-
-#ifdef ADM_CPU_X86
-
-
-#define LOAD4(mem,dst) \
-            &quot;movd      &quot;mem&quot;, &quot;#dst&quot; \n\t&quot;\
-            &quot;punpcklbw %%mm7, &quot;#dst&quot; \n\t&quot;
-
-#define PABS(tmp,dst) \
-            &quot;pxor     &quot;#tmp&quot;, &quot;#tmp&quot; \n\t&quot;\
-            &quot;psubw    &quot;#dst&quot;, &quot;#tmp&quot; \n\t&quot;\
-            &quot;pmaxsw   &quot;#tmp&quot;, &quot;#dst&quot; \n\t&quot;
-
-#define CHECK(pj,mj) \
-            &quot;movq &quot;#pj&quot;(%[cur],%[mrefs]), %%mm2 \n\t&quot; /* cur[x-refs-1+j] */\
-            &quot;movq &quot;#mj&quot;(%[cur],%[prefs]), %%mm3 \n\t&quot; /* cur[x+refs-1-j] */\
-            &quot;movq      %%mm2, %%mm4 \n\t&quot;\
-            &quot;movq      %%mm2, %%mm5 \n\t&quot;\
-            &quot;pxor      %%mm3, %%mm4 \n\t&quot;\
-            &quot;pavgb     %%mm3, %%mm5 \n\t&quot;\
-            &quot;pand     %[pb1], %%mm4 \n\t&quot;\
-            &quot;psubusb   %%mm4, %%mm5 \n\t&quot;\
-            &quot;psrlq     $8,    %%mm5 \n\t&quot;\
-            &quot;punpcklbw %%mm7, %%mm5 \n\t&quot; /* (cur[x-refs+j] + cur[x+refs-j])&gt;&gt;1 */\
-            &quot;movq      %%mm2, %%mm4 \n\t&quot;\
-            &quot;psubusb   %%mm3, %%mm2 \n\t&quot;\
-            &quot;psubusb   %%mm4, %%mm3 \n\t&quot;\
-            &quot;pmaxub    %%mm3, %%mm2 \n\t&quot;\
-            &quot;movq      %%mm2, %%mm3 \n\t&quot;\
-            &quot;movq      %%mm2, %%mm4 \n\t&quot; /* ABS(cur[x-refs-1+j] - cur[x+refs-1-j]) */\
-            &quot;psrlq      $8,   %%mm3 \n\t&quot; /* ABS(cur[x-refs  +j] - cur[x+refs  -j]) */\
-            &quot;psrlq     $16,   %%mm4 \n\t&quot; /* ABS(cur[x-refs+1+j] - cur[x+refs+1-j]) */\
-            &quot;punpcklbw %%mm7, %%mm2 \n\t&quot;\
-            &quot;punpcklbw %%mm7, %%mm3 \n\t&quot;\
-            &quot;punpcklbw %%mm7, %%mm4 \n\t&quot;\
-            &quot;paddw     %%mm3, %%mm2 \n\t&quot;\
-            &quot;paddw     %%mm4, %%mm2 \n\t&quot; /* score */
-
-#define CHECK1 \
-            &quot;movq      %%mm0, %%mm3 \n\t&quot;\
-            &quot;pcmpgtw   %%mm2, %%mm3 \n\t&quot; /* if(score &lt; spatial_score) */\
-            &quot;pminsw    %%mm2, %%mm0 \n\t&quot; /* spatial_score= score; */\
-            &quot;movq      %%mm3, %%mm6 \n\t&quot;\
-            &quot;pand      %%mm3, %%mm5 \n\t&quot;\
-            &quot;pandn     %%mm1, %%mm3 \n\t&quot;\
-            &quot;por       %%mm5, %%mm3 \n\t&quot;\
-            &quot;movq      %%mm3, %%mm1 \n\t&quot; /* spatial_pred= (cur[x-refs+j] + cur[x+refs-j])&gt;&gt;1; */
-
-#define CHECK2 /* pretend not to have checked dir=2 if dir=1 was bad.\
-                  hurts both quality and speed, but matches the C version. */\
-            &quot;paddw    %[pw1], %%mm6 \n\t&quot;\
-            &quot;psllw     $14,   %%mm6 \n\t&quot;\
-            &quot;paddsw    %%mm6, %%mm2 \n\t&quot;\
-            &quot;movq      %%mm0, %%mm3 \n\t&quot;\
-            &quot;pcmpgtw   %%mm2, %%mm3 \n\t&quot;\
-            &quot;pminsw    %%mm2, %%mm0 \n\t&quot;\
-            &quot;pand      %%mm3, %%mm5 \n\t&quot;\
-            &quot;pandn     %%mm1, %%mm3 \n\t&quot;\
-            &quot;por       %%mm5, %%mm3 \n\t&quot;\
-            &quot;movq      %%mm3, %%mm1 \n\t&quot;
-
-void filter_line_mmx2(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity){
-    static const uint64_t pw_1 = 0x0001000100010001ULL;
-    static const uint64_t pb_1 = 0x0101010101010101ULL;
-//    const int mode = p-&gt;mode;
-    uint64_t tmp0, tmp1, tmp2, tmp3;
-    int x;
-
-#define FILTER\
-    for(x=0; x&lt;w; x+=4){\
-        asm volatile(\
-            &quot;pxor      %%mm7, %%mm7 \n\t&quot;\
-            LOAD4(&quot;(%[cur],%[mrefs])&quot;, %%mm0) /* c = cur[x-refs] */\
-            LOAD4(&quot;(%[cur],%[prefs])&quot;, %%mm1) /* e = cur[x+refs] */\
-            LOAD4(&quot;(%[&quot;prev2&quot;])&quot;, %%mm2) /* prev2[x] */\
-            LOAD4(&quot;(%[&quot;next2&quot;])&quot;, %%mm3) /* next2[x] */\
-            &quot;movq      %%mm3, %%mm4 \n\t&quot;\
-            &quot;paddw     %%mm2, %%mm3 \n\t&quot;\
-            &quot;psraw     $1,    %%mm3 \n\t&quot; /* d = (prev2[x] + next2[x])&gt;&gt;1 */\
-            &quot;movq      %%mm0, %[tmp0] \n\t&quot; /* c */\
-            &quot;movq      %%mm3, %[tmp1] \n\t&quot; /* d */\
-            &quot;movq      %%mm1, %[tmp2] \n\t&quot; /* e */\
-            &quot;psubw     %%mm4, %%mm2 \n\t&quot;\
-            PABS(      %%mm4, %%mm2) /* temporal_diff0 */\
-            LOAD4(&quot;(%[prev],%[mrefs])&quot;, %%mm3) /* prev[x-refs] */\
-            LOAD4(&quot;(%[prev],%[prefs])&quot;, %%mm4) /* prev[x+refs] */\
-            &quot;psubw     %%mm0, %%mm3 \n\t&quot;\
-            &quot;psubw     %%mm1, %%mm4 \n\t&quot;\
-            PABS(      %%mm5, %%mm3)\
-            PABS(      %%mm5, %%mm4)\
-            &quot;paddw     %%mm4, %%mm3 \n\t&quot; /* temporal_diff1 */\
-            &quot;psrlw     $1,    %%mm2 \n\t&quot;\
-            &quot;psrlw     $1,    %%mm3 \n\t&quot;\
-            &quot;pmaxsw    %%mm3, %%mm2 \n\t&quot;\
-            LOAD4(&quot;(%[next],%[mrefs])&quot;, %%mm3) /* next[x-refs] */\
-            LOAD4(&quot;(%[next],%[prefs])&quot;, %%mm4) /* next[x+refs] */\
-            &quot;psubw     %%mm0, %%mm3 \n\t&quot;\
-            &quot;psubw     %%mm1, %%mm4 \n\t&quot;\
-            PABS(      %%mm5, %%mm3)\
-            PABS(      %%mm5, %%mm4)\
-            &quot;paddw     %%mm4, %%mm3 \n\t&quot; /* temporal_diff2 */\
-            &quot;psrlw     $1,    %%mm3 \n\t&quot;\
-            &quot;pmaxsw    %%mm3, %%mm2 \n\t&quot;\
-            &quot;movq      %%mm2, %[tmp3] \n\t&quot; /* diff */\
-\
-            &quot;paddw     %%mm0, %%mm1 \n\t&quot;\
-            &quot;paddw     %%mm0, %%mm0 \n\t&quot;\
-            &quot;psubw     %%mm1, %%mm0 \n\t&quot;\
-            &quot;psrlw     $1,    %%mm1 \n\t&quot; /* spatial_pred */\
-            PABS(      %%mm2, %%mm0)      /* ABS(c-e) */\
-\
-            &quot;movq -1(%[cur],%[mrefs]), %%mm2 \n\t&quot; /* cur[x-refs-1] */\
-            &quot;movq -1(%[cur],%[prefs]), %%mm3 \n\t&quot; /* cur[x+refs-1] */\
-            &quot;movq      %%mm2, %%mm4 \n\t&quot;\
-            &quot;psubusb   %%mm3, %%mm2 \n\t&quot;\
-            &quot;psubusb   %%mm4, %%mm3 \n\t&quot;\
-            &quot;pmaxub    %%mm3, %%mm2 \n\t&quot;\
-            &quot;pshufw $9,%%mm2, %%mm3 \n\t&quot;\
-            &quot;punpcklbw %%mm7, %%mm2 \n\t&quot; /* ABS(cur[x-refs-1] - cur[x+refs-1]) */\
-            &quot;punpcklbw %%mm7, %%mm3 \n\t&quot; /* ABS(cur[x-refs+1] - cur[x+refs+1]) */\
-            &quot;paddw     %%mm2, %%mm0 \n\t&quot;\
-            &quot;paddw     %%mm3, %%mm0 \n\t&quot;\
-            &quot;psubw    %[pw1], %%mm0 \n\t&quot; /* spatial_score */\
-\
-            CHECK(-2,0)\
-            CHECK1\
-            CHECK(-3,1)\
-            CHECK2\
-            CHECK(0,-2)\
-            CHECK1\
-            CHECK(1,-3)\
-            CHECK2\
-\
-            /* if(p-&gt;mode&lt;2) ... */\
-            &quot;movq    %[tmp3], %%mm6 \n\t&quot; /* diff */\
-            &quot;cmp       $2, %[mode] \n\t&quot;\
-            &quot;jge       1f \n\t&quot;\
-            LOAD4(&quot;(%[&quot;prev2&quot;],%[mrefs],2)&quot;, %%mm2) /* prev2[x-2*refs] */\
-            LOAD4(&quot;(%[&quot;next2&quot;],%[mrefs],2)&quot;, %%mm4) /* next2[x-2*refs] */\
-            LOAD4(&quot;(%[&quot;prev2&quot;],%[prefs],2)&quot;, %%mm3) /* prev2[x+2*refs] */\
-            LOAD4(&quot;(%[&quot;next2&quot;],%[prefs],2)&quot;, %%mm5) /* next2[x+2*refs] */\
-            &quot;paddw     %%mm4, %%mm2 \n\t&quot;\
-            &quot;paddw     %%mm5, %%mm3 \n\t&quot;\
-            &quot;psrlw     $1,    %%mm2 \n\t&quot; /* b */\
-            &quot;psrlw     $1,    %%mm3 \n\t&quot; /* f */\
-            &quot;movq    %[tmp0], %%mm4 \n\t&quot; /* c */\
-            &quot;movq    %[tmp1], %%mm5 \n\t&quot; /* d */\
-            &quot;movq    %[tmp2], %%mm7 \n\t&quot; /* e */\
-            &quot;psubw     %%mm4, %%mm2 \n\t&quot; /* b-c */\
-            &quot;psubw     %%mm7, %%mm3 \n\t&quot; /* f-e */\
-            &quot;movq      %%mm5, %%mm0 \n\t&quot;\
-            &quot;psubw     %%mm4, %%mm5 \n\t&quot; /* d-c */\
-            &quot;psubw     %%mm7, %%mm0 \n\t&quot; /* d-e */\
-            &quot;movq      %%mm2, %%mm4 \n\t&quot;\
-            &quot;pminsw    %%mm3, %%mm2 \n\t&quot;\
-            &quot;pmaxsw    %%mm4, %%mm3 \n\t&quot;\
-            &quot;pmaxsw    %%mm5, %%mm2 \n\t&quot;\
-            &quot;pminsw    %%mm5, %%mm3 \n\t&quot;\
-            &quot;pmaxsw    %%mm0, %%mm2 \n\t&quot; /* max */\
-            &quot;pminsw    %%mm0, %%mm3 \n\t&quot; /* min */\
-            &quot;pxor      %%mm4, %%mm4 \n\t&quot;\
-            &quot;pmaxsw    %%mm3, %%mm6 \n\t&quot;\
-            &quot;psubw     %%mm2, %%mm4 \n\t&quot; /* -max */\
-            &quot;pmaxsw    %%mm4, %%mm6 \n\t&quot; /* diff= MAX3(diff, min, -max); */\
-            &quot;1: \n\t&quot;\
-\
-            &quot;movq    %[tmp1], %%mm2 \n\t&quot; /* d */\
-            &quot;movq      %%mm2, %%mm3 \n\t&quot;\
-            &quot;psubw     %%mm6, %%mm2 \n\t&quot; /* d-diff */\
-            &quot;paddw     %%mm6, %%mm3 \n\t&quot; /* d+diff */\
-            &quot;pmaxsw    %%mm2, %%mm1 \n\t&quot;\
-            &quot;pminsw    %%mm3, %%mm1 \n\t&quot; /* d = clip(spatial_pred, d-diff, d+diff); */\
-            &quot;packuswb  %%mm1, %%mm1 \n\t&quot;\
-\
-            :[tmp0]&quot;=m&quot;(tmp0),\
-             [tmp1]&quot;=m&quot;(tmp1),\
-             [tmp2]&quot;=m&quot;(tmp2),\
-             [tmp3]&quot;=m&quot;(tmp3)\
-            :[prev] &quot;r&quot;(prev),\
-             [cur]  &quot;r&quot;(cur),\
-             [next] &quot;r&quot;(next),\
-             [prefs]&quot;r&quot;((long)refs),\
-             [mrefs]&quot;r&quot;((long)-refs),\
-             [pw1]  &quot;m&quot;(pw_1),\
-             [pb1]  &quot;m&quot;(pb_1),\
-             [mode] &quot;g&quot;(mode)\
-        );\
-        asm volatile(&quot;movd %%mm1, %0&quot; :&quot;=m&quot;(*dst));\
-        dst += 4;\
-        prev+= 4;\
-        cur += 4;\
-        next+= 4;\
-    }
-
-    if(parity){
-#define prev2 &quot;prev&quot;
-#define next2 &quot;cur&quot;
-        FILTER
-#undef prev2
-#undef next2
-    }else{
-#define prev2 &quot;cur&quot;
-#define next2 &quot;next&quot;
-        FILTER
-#undef prev2
-#undef next2
-    }
-}
-#undef LOAD4
-#undef PABS
-#undef CHECK
-#undef CHECK1
-#undef CHECK2
-#undef FILTER
-#endif
-
-
-

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/CMakeLists.txt	2008-05-01 18:21:27 UTC (rev 4008)
@@ -2,25 +2,22 @@
 	ADM_lavpp_deint.cpp      ADM_vidDecTelecide.cpp      ADM_vidFields.cpp           ADM_vidMcDeint.cpp
 	ADM_vidPulldown.cpp       ADM_vidSwapSmart.cpp
 	ADM_vidAddBorder.cpp     ADM_vidDeintASM.cpp         ADM_vidMosaic.cpp
-	ADM_vidResampleFPS.cpp    ADM_vidUVSwap.cpp
+	ADM_vidUVSwap.cpp
 	ADM_vidASS.cpp           ADM_vidDeinterlace.cpp      ADM_vidFlux.cpp             ADM_vidMPLD3D.cpp
-	ADM_vidReverse.cpp        ADM_vidVlad.cpp
-	ADM_vidBlend.cpp         ADM_vidDenoise.cpp          ADM_vidForcedPP.cpp         ADM_vidMPLD3Dlow.cpp
+	ADM_vidDenoise.cpp          ADM_vidForcedPP.cpp         ADM_vidMPLD3Dlow.cpp
 	ADM_vidRotate.cpp         ADM_vidWhirl.cpp
-	ADM_vidBlendRemoval.cpp  ADM_vidDGbob.cpp            ADM_vidHardIvtcRemoval.cpp  ADM_vidMSharpen.cpp
-	ADM_vidSeparateField.cpp  ADM_vidYadif.cpp
+	ADM_vidMSharpen.cpp
+	ADM_vidSeparateField.cpp  
 	ADM_vidBSmear.cpp        ADM_vidDropOut.cpp          ADM_vidKernelDeint.cpp      ADM_vidMsmooth.cpp
 	ADM_vidSoften.cpp
-	ADM_vidChroma.cpp        ADM_vidFade.cpp             ADM_vidLargeMedian.cpp      ADM_vidPalShift.cpp
+	ADM_vidLargeMedian.cpp      ADM_vidPalShift.cpp
 	ADM_vidStabilize.cpp
 	ADM_vidDecDec.cpp        ADM_vidFastConvolution.cpp  ADM_vidLuma.cpp             ADM_vidPalSmart.cpp
 	ADM_vidSwapFields.cpp
-	ADM_vidYadif_asm.c
 	ADM_guiResize.cpp  ADM_resizebis.cpp  ADM_resizeter.cpp  ADM_vidResize.cpp
 	ADM_vidMPLResize.cpp
 	ADM_vidResize25.cpp
 	ADM_vidTdeint.cpp
-	ADM_vidChromaShift.cpp
 	ADM_vidAnimated.cpp
 	ADM_vidDvbSub.cpp
 	ADM_vidLogo.cpp
@@ -38,13 +35,12 @@
 	ADM_vidVobSubRender.cpp
 	ADM_vobsubinfo.cpp
 	ADM_vidComputeAverage.cpp
+	ADM_vidChromaShift.cpp
+	ADM_vidBlend.cpp
 	ADM_vidThreshold.cpp)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_videoFilter ${ADM_videoFilter_SRCS})
 
-IF (APPLE AND ADM_DEBUG)
-	SET_SOURCE_FILES_PROPERTIES(ADM_vidYadif_asm.c PROPERTIES COMPILE_FLAGS &quot;-O2&quot;)
-ENDIF (APPLE AND ADM_DEBUG)
 
 IF (USE_FREETYPE)
 	ADD_SOURCE_CFLAGS(ADM_vidSRT.cpp &quot;${FREETYPE2_CFLAGS}&quot;)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidBlendRemoval.cpp (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidBlendRemoval.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,260 @@
+/***************************************************************************
+                         
+        Blending remover
+
+        A B C D E -&gt; A AB B 
+
+    copyright            : (C) 2005 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &lt;math.h&gt;
+#include &quot;DIA_enter.h&quot;
+#include &quot;DIA_factory.h&quot;
+#include &quot;ADM_vidBlendRemoval_param.h&quot;
+#define MUL 1
+// Set it to 2 for post separate field
+
+
+
+class vidBlendRemoval:public AVDMGenericVideoStream
+{
+
+protected:
+  virtual char *printConf (void);
+  VideoCache *vidCache;
+  BLEND_REMOVER_PARAM *_param;
+  uint32_t              _lastRemoved;
+  ADMImage              *rebuild;
+public:
+
+                        vidBlendRemoval (AVDMGenericVideoStream * in, CONFcouple * setup);
+        virtual         ~vidBlendRemoval ();
+  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
+                                         ADMImage * data, uint32_t * flags);
+  uint8_t configure (AVDMGenericVideoStream * instream);
+  virtual uint8_t getCoupledConf (CONFcouple ** couples);
+
+};
+
+static FILTER_PARAM field_unblend_template =
+  { 4,&quot;threshold&quot;,&quot;show&quot;,&quot;noise&quot;,&quot;identical&quot;};
+
+BUILD_CREATE (blendremove_create, vidBlendRemoval);
+SCRIPT_CREATE (blendremove_script, vidBlendRemoval, field_unblend_template);
+//*************************************
+VF_DEFINE_FILTER(vidBlendRemoval,
+                &quot;blendremoval&quot;,
+                QT_TR_NOOP(&quot;Blend Removal&quot;),
+                1,
+                blendremove_create,
+                blendremove_script,
+                VF_COLORS,
+                QT_TR_NOOP(&quot;Try to remove blending.&quot;));
+//*************************************
+uint8_t vidBlendRemoval::configure (AVDMGenericVideoStream * in)
+{
+  
+   _in=in;
+    
+#define PX(x) &amp;(_param-&gt;x)
+        
+    diaElemUInteger   thresh(PX(threshold),QT_TR_NOOP(&quot;_Threshold:&quot;),0,99,
+        QT_TR_NOOP(&quot;If value is smaller than threshold it is considered valid.&quot;
+            &quot;Smaller value might mean more false positive.&quot;));
+    diaElemUInteger   noise(PX(noise),QT_TR_NOOP(&quot;_Noise:&quot;),0,99,QT_TR_NOOP(&quot;If pixels are closer than noise, they are considered to be the same&quot;));
+    diaElemUInteger   identical(PX(identical),QT_TR_NOOP(&quot;I_dentical:&quot;),0,99,QT_TR_NOOP(&quot;If metric is less than identical, images are considered identical&quot;));
+    diaElemToggle     show(PX(show),QT_TR_NOOP(&quot;_Show metrics&quot;),QT_TR_NOOP(&quot;Show metric in image (debug)&quot;));
+    
+       diaElem *elems[]={&amp;thresh,&amp;noise,&amp;identical,&amp;show};
+  
+   if(  diaFactoryRun(QT_TR_NOOP(&quot;Blend Removal&quot;),sizeof(elems)/sizeof(diaElem *),elems))
+   {
+        _lastRemoved=0xFFFFFFF;
+        return 1;
+    }
+        return 0;
+}
+/*************************************/
+char *vidBlendRemoval::printConf (void)
+{
+  static char buf[50];
+  sprintf ((char *) buf, &quot; Blend Removal Thresh:%d Noise:%d Ident:%d&quot;,_param-&gt;threshold,_param-&gt;noise,_param-&gt;identical);
+  return buf;
+}
+
+#define MAX_BLOCKS 50
+/*************************************/
+vidBlendRemoval::vidBlendRemoval (AVDMGenericVideoStream * in, CONFcouple * couples)
+{
+
+  _in = in;
+  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
+  _info.encoding = 1;
+  vidCache = new VideoCache (10, in);
+  _uncompressed=new ADMImage(_info.width,_info.height);
+  rebuild=new ADMImage(_info.width,_info.height);
+
+ _param=new BLEND_REMOVER_PARAM;
+ _lastRemoved=0xFFFF;
+ if(couples)
+ {
+#undef GET
+#define GET(x) couples-&gt;getCouple(#x,&amp;(_param-&gt;x))
+      GET (threshold);
+      GET (show);
+      GET (noise);
+      GET (identical);
+  }
+  else
+  {
+        _param-&gt;threshold=10;
+        _param-&gt;show=0;
+        _param-&gt;noise=5;
+        _param-&gt;identical=2;
+  }
+}
+//____________________________________________________________________
+vidBlendRemoval::~vidBlendRemoval ()
+{
+
+  delete vidCache;
+  vidCache = NULL;
+  delete _uncompressed;
+  _uncompressed=NULL;
+  delete _param;
+  _param=NULL;
+  delete rebuild;
+  rebuild=NULL;
+}
+
+
+
+
+
+uint8_t vidBlendRemoval::getFrameNumberNoAlloc (uint32_t inframe,
+                                uint32_t * len,
+                                ADMImage * data, uint32_t * flags)
+{
+
+	
+	ADMImage *srcP,*srcN,*src,*final,*display;
+        float distMerged, distN,distP,distM,distR,skip=0;
+        char txt[255];
+
+        if(inframe&gt;= _info.nb_frames) return 0;
+        if(inframe&lt;1 || inframe&gt;inframe&gt;_info.nb_frames-2 )
+        {
+                skip=1;
+        }
+        if(inframe &amp;&amp; _lastRemoved==inframe-1)
+        {
+                skip=1;
+        }
+        
+        if(skip)
+        {
+                data-&gt;duplicate(vidCache-&gt;getImage(inframe));
+                vidCache-&gt;unlockAll();
+                return 1;
+        }
+        
+        
+
+        srcP=vidCache-&gt;getImage(inframe-1);
+        src=vidCache-&gt;getImage(inframe);
+        srcN=vidCache-&gt;getImage(inframe+1);
+        if(!srcP || !src || !srcN)
+        {
+                data-&gt;duplicate(vidCache-&gt;getImage(inframe));
+                vidCache-&gt;unlockAll();
+                return 1;
+        }
+       
+        rebuild-&gt;merge(srcP,srcN);
+        
+        distP=ADMImage::lumaDiff(src,srcN,_param-&gt;noise);
+        distN=ADMImage::lumaDiff(src,srcP,_param-&gt;noise);
+        distM=ADMImage::lumaDiff(src,rebuild,_param-&gt;noise);
+        
+        
+        
+        
+        double medium;
+
+         if(distN&gt;1&amp;&amp;distP&gt;1)
+        {
+                if(distP&gt;distN) medium=distN;
+                          else  medium=distP;
+                  //medium=min(distM,distR);
+                 
+                 medium/=100;
+                 distN/=medium;
+                 distP/=medium;
+                 distM/=medium;
+         
+         }
+        
+        medium=medium/(_info.width*_info.height);
+        medium*=1000;
+        if(distM&lt;_param-&gt;threshold &amp;&amp; medium&gt;_param-&gt;identical) // medium is how close pictures are, too close, we discard
+        {
+                data-&gt;duplicate(srcP);
+                _lastRemoved=inframe;
+                if(_param-&gt;show )
+                {
+                        sprintf(txt,&quot;Dupe&quot;);
+                        drawString(data,2,5,txt);      
+                }
+        }
+        else
+                data-&gt;duplicate(src);
+        if(_param-&gt;show)
+        {
+                display=data;
+
+                sprintf(txt,&quot; N %02.1f&quot;,distN);
+                drawString(display,2,0,txt);
+
+                sprintf(txt,&quot; P %02.1f&quot;,distP);
+                drawString(display,2,1,txt);
+
+                sprintf(txt,&quot; M %02.1f&quot;,distM);
+                drawString(display,2,2,txt);
+
+                sprintf(txt,&quot; %% %02.1f&quot;,medium);
+                drawString(display,2,3,txt);
+        }
+
+
+          
+        vidCache-&gt;unlockAll();
+	return 1;
+}
+uint8_t vidBlendRemoval::getCoupledConf (CONFcouple ** couples)
+{
+
+  ADM_assert (_param);
+  *couples = new CONFcouple (4);
+#undef CSET
+#define CSET(x)  (*couples)-&gt;setCouple(#x,(_param-&gt;x))
+  CSET (threshold);
+  CSET (show);
+  CSET (noise);
+  CSET (identical);
+  
+  return 1;
+}
+
+
+//EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidBlendRemoval_param.h (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidBlendRemoval_param.h	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidBlendRemoval_param.h	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,22 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef BLEND_REMOVAL_PARAM_H
+#define BLEND_REMOVAL_PARAM_H
+
+typedef struct BLEND_REMOVER_PARAM
+{
+        uint32_t threshold;
+        uint32_t noise;
+        uint32_t show;
+        uint32_t identical;
+}BLEND_REMOVER_PARAM;
+uint8_t  DIA_blendRemoval(BLEND_REMOVER_PARAM *mosaic);
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidHardIvtcRemoval.cpp (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/ADM_vidHardIvtcRemoval.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,486 @@
+/***************************************************************************
+                         
+        Hard ivtc removal for image
+
+        A B C D E -&gt; A BC CD D E
+
+    copyright            : (C) 2005 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+
+#include &lt;math.h&gt;
+
+#include &quot;ADM_videoFilter.h&quot;
+
+#include &quot;DIA_enter.h&quot;
+#include &quot;DIA_factory.h&quot;
+
+#define MUL 1
+// Set it to 2 for post separate field
+
+#include &quot;ADM_vidBlendRemoval_param.h&quot;
+
+#define PROGRESSIVE  0x00000001
+#define MAGIC_NUMBER (0xdeadbeef)
+#define IN_PATTERN   0x00000002
+
+extern uint8_t PutHintingData(unsigned char *video, unsigned int hint);
+
+class vidHardPDRemoval:public AVDMGenericVideoStream
+{
+
+    protected:
+        virtual char *printConf ( void );
+        VideoCache *vidCache;
+        BLEND_REMOVER_PARAM *_param;
+        uint32_t              _lastRemoved;
+        ADMImage              *cand1,*cand2,*rebuild;
+    public:
+
+        vidHardPDRemoval ( AVDMGenericVideoStream * in, CONFcouple * setup );
+        virtual         ~vidHardPDRemoval ();
+        virtual uint8_t getFrameNumberNoAlloc ( uint32_t frame, uint32_t * len,
+                                                ADMImage * data, uint32_t * flags );
+        uint8_t configure ( AVDMGenericVideoStream * instream );
+        virtual uint8_t getCoupledConf ( CONFcouple ** couples );
+
+};
+//***************************
+static FILTER_PARAM field_unblend_template =
+    { 4,&quot;threshold&quot;,&quot;show&quot;,&quot;noise&quot;,&quot;identical&quot;};
+
+BUILD_CREATE ( hardivtc_create, vidHardPDRemoval );
+SCRIPT_CREATE ( hardivtc_script, vidHardPDRemoval, field_unblend_template );
+VF_DEFINE_FILTER ( ADMVideoChromaV,
+                   &quot;unblend&quot;,
+                   QT_TR_NOOP ( &quot;Unblend&quot; ),
+                   1,
+                   hardivtc_create,
+                   hardivtc_script,
+                   VF_COLORS,
+                   QT_TR_NOOP ( &quot;Try to unblend fields.&quot; ) );
+
+
+//*************************************
+uint8_t vidHardPDRemoval::configure (AVDMGenericVideoStream * in)
+{
+       _in=in;
+    
+#define PX(x) &amp;(_param-&gt;x)
+        
+    diaElemUInteger   thresh(PX(threshold),QT_TR_NOOP(&quot;_Threshold:&quot;),0,99,
+        QT_TR_NOOP(&quot;If value is smaller than threshold it is considered valid.&quot;
+            &quot; Smaller value might mean more false positive&quot;));
+    diaElemUInteger   noise(PX(noise),QT_TR_NOOP(&quot;_Noise:&quot;),0,99,QT_TR_NOOP(&quot;If pixels are closer than noise, they are considered to be the same&quot;));
+    diaElemUInteger   identical(PX(identical),QT_TR_NOOP(&quot;_Identical:&quot;),0,99,QT_TR_NOOP(&quot;If metric is less than identical, images are considered identical&quot;));
+    diaElemToggle     show(PX(show),QT_TR_NOOP(&quot;_Show metrics&quot;),QT_TR_NOOP(&quot;Show metric in image (debug)&quot;));
+    
+       diaElem *elems[]={&amp;thresh,&amp;noise,&amp;identical,&amp;show};
+  
+   if(  diaFactoryRun(QT_TR_NOOP(&quot;Hard IVTC Removal&quot;),sizeof(elems)/sizeof(diaElem *),elems))
+   {
+        _lastRemoved=0xFFFFFFF;
+        return 1;
+    }
+        return 0;
+}
+/*************************************/
+char *vidHardPDRemoval::printConf (void)
+{
+  static char buf[50];
+  sprintf ((char *) buf, &quot; Field Unblend Thresh:%d Noise:%d&quot;,_param-&gt;threshold,_param-&gt;noise);
+  return buf;
+}
+static void hint(ADMImage *img)
+{
+       unsigned int hint;
+
+                 hint= PROGRESSIVE;
+                
+                 hint |= IN_PATTERN;
+                
+                PutHintingData(YPLANE(img), hint);  
+
+}
+#define MAX_BLOCKS 50
+/*************************************/
+vidHardPDRemoval::vidHardPDRemoval (AVDMGenericVideoStream * in, CONFcouple * couples)
+{
+
+  _in = in;
+  memcpy (&amp;_info, _in-&gt;getInfo (), sizeof (_info));
+  _info.encoding = 1;
+  vidCache = new VideoCache (10, in);
+  _uncompressed=new ADMImage(_info.width,_info.height);
+  cand1=new ADMImage(_info.width,_info.height);
+  cand2=new ADMImage(_info.width,_info.height);
+  rebuild=new ADMImage(_info.width,_info.height);
+
+ _param=new BLEND_REMOVER_PARAM;
+ _lastRemoved=0xFFFFFFF;
+ if(couples)
+ {
+#undef GET
+#define GET(x) couples-&gt;getCouple(#x,&amp;(_param-&gt;x))
+      GET (threshold);
+      GET (show);
+      GET (noise);
+      GET (identical);
+  }
+  else
+  {
+        _param-&gt;threshold=10;
+        _param-&gt;show=0;
+        _param-&gt;noise=5;
+        _param-&gt;identical=2;
+  }
+}
+//____________________________________________________________________
+vidHardPDRemoval::~vidHardPDRemoval ()
+{
+
+  delete vidCache;
+  vidCache = NULL;
+  delete _uncompressed;
+  _uncompressed=NULL;
+  delete _param;
+  _param=NULL;
+  delete cand1;
+  delete cand2;
+  delete rebuild;
+  cand1=NULL;
+  cand2=NULL;
+  rebuild=NULL;
+}
+
+
+
+
+/*
+
+                src=blend of srcP and R         =&gt; src= 1/2(srcP+R)
+                                                   2*src-srcP=R
+
+                srcN=blend of srcNN and R       =&gt; srcN=1/2 (srcNN+R)
+                                                        2*srcN-srcNN=R
+
+*/
+
+static uint8_t tinyRestore(uint8_t *dst, uint8_t *srcP, uint8_t *src,uint8_t *srcN,uint8_t *srcNN,uint32_t w, uint32_t h)
+{
+
+
+uint8_t *s,*sp,*sn,*snn,*d1;
+int a1,a2,a3,a4,sum,delta;
+
+        sp=srcP;
+        s=src;
+        sn=srcN;
+        snn=srcNN;
+        
+        d1=dst;
+
+          for(int y=0;y&lt;h;y++)
+                for(int x=0;x&lt;w;x++)
+                {
+                        a1=*sp;
+                        a2=*s;
+                        a3=*sn;
+                        a4=*snn;
+
+                        sum=2*a2+2*a3-a1-a4;
+                        sum=sum/2;
+                        
+                        a1=sum;                        
+
+                        if(a1&lt;0) a1=0;
+                        if(a1&gt;255) a1=255;
+                        *d1=a1;
+
+                        s++;
+                        sp++;
+                        sn++;
+                        snn++;
+                        d1++;
+                }
+        return 1;
+}
+#ifdef ADM_CPU_X86
+static uint8_t tinyRestoreMMX(uint8_t *dst, uint8_t *srcP, uint8_t *src,uint8_t *srcN,uint8_t *srcNN,uint32_t w, uint32_t h)
+{
+
+
+uint8_t *s,*sp,*sn,*snn,*d1;
+int a1,a2,a3,a4,sum,delta,l,ll;
+
+        sp=srcP;
+        s=src;
+        sn=srcN;
+        snn=srcNN;
+        
+        d1=dst;
+
+        l=w*h;
+        ll=l&gt;&gt;2;
+#ifdef GCC_2_95_X
+        __asm__(
+                         &quot;pxor %mm7,%mm7&quot;
+                ::
+                 );
+#else
+        __asm__(
+                         &quot;pxor %%mm7,%%mm7&quot;
+                ::
+                 );
+#endif
+        for(int x=0;x&lt;ll;x++)
+                {
+                        __asm__(
+                        &quot;movd           (%0),%%mm0 \n&quot;
+                        &quot;movd           (%1),%%mm1 \n&quot;
+                        &quot;movd           (%2),%%mm2 \n&quot;
+                        &quot;movd           (%3),%%mm3 \n&quot;
+                        &quot;punpcklbw      %%mm7,%%mm0 \n&quot;
+                        &quot;punpcklbw      %%mm7,%%mm1 \n&quot;
+                        &quot;punpcklbw      %%mm7,%%mm2 \n&quot;
+                        &quot;punpcklbw      %%mm7,%%mm3 \n&quot;  //sum=2*m1+2*m2-m0-m3;
+                        
+                        &quot;paddw          %%mm2,%%mm1 \n&quot;
+                        &quot;paddw          %%mm1,%%mm1 \n&quot;
+                        &quot;paddw          %%mm3,%%mm0 \n&quot;
+                        
+                        &quot;psubusw        %%mm0,%%mm1 \n&quot; // mm1=sum
+                        &quot;psraw          $1,%%mm1 \n&quot;    //2 
+                        &quot;packuswb       %%mm1,  %%mm1\n&quot;
+                        &quot;movd           %%mm1,(%4) \n&quot;
+
+                : : &quot;r&quot; (sp),&quot;r&quot; (s),&quot;r&quot;(sn),&quot;r&quot;(snn),&quot;r&quot;(d1)
+                );
+
+                        s+=4;
+                        sp+=4;
+                        sn+=4;
+                        snn+=4;
+                        d1+=4;
+                }
+        if(l&amp;3) tinyRestore(d1, sp, s,sn,snn,l&amp;3, 1);
+        return 1;
+}
+#endif
+
+static uint8_t    restore(ADMImage *tgt,ADMImage *srcP,ADMImage *src,ADMImage *srcN,ADMImage *srcNN)
+{
+int delta;
+uint32_t ww,hh;
+uint8_t *s1,*s2,*d1;
+int a1,a2,t1;
+
+#ifdef ADM_CPU_X86
+        if(CpuCaps::hasMMX())
+        {
+              tinyRestoreMMX(YPLANE(tgt),YPLANE(srcP),YPLANE(src),YPLANE(srcN),YPLANE(srcNN),tgt-&gt;_width,tgt-&gt;_height);
+              tinyRestoreMMX(UPLANE(tgt),UPLANE(srcP),UPLANE(src),UPLANE(srcN),UPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
+              tinyRestoreMMX(VPLANE(tgt),VPLANE(srcP),VPLANE(src),VPLANE(srcN),VPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
+              return 1;
+        }
+#endif
+
+        tinyRestore(YPLANE(tgt),YPLANE(srcP),YPLANE(src),YPLANE(srcN),YPLANE(srcNN),tgt-&gt;_width,tgt-&gt;_height);
+        tinyRestore(UPLANE(tgt),UPLANE(srcP),UPLANE(src),UPLANE(srcN),UPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
+        tinyRestore(VPLANE(tgt),VPLANE(srcP),VPLANE(src),VPLANE(srcN),VPLANE(srcNN),tgt-&gt;_width&gt;&gt;1,tgt-&gt;_height&gt;&gt;1);
+        return 1;
+
+
+}
+
+uint8_t vidHardPDRemoval::getFrameNumberNoAlloc (uint32_t inframe,
+                                uint32_t * len,
+                                ADMImage * data, uint32_t * flags)
+{
+
+	
+	ADMImage *srcP,*srcN,*srcNN,*src,*final,*display;
+        float distMerged, distN,distP,distM,distR,skip=0;
+        char txt[255];
+
+        if(inframe&gt;= _info.nb_frames) return 0;
+        if(inframe&lt;1 || inframe&gt;inframe&gt;_info.nb_frames-3 )
+        {
+                skip=1;
+        }
+        if(inframe&gt;_lastRemoved+1 &amp;&amp; inframe&lt;_lastRemoved+5 )
+        {
+                skip=1;
+        }
+        
+        if(skip)
+        {
+                data-&gt;duplicate(vidCache-&gt;getImage(inframe));
+                hint(data);
+                vidCache-&gt;unlockAll();
+                return 1;
+        }
+        
+        if(_lastRemoved==inframe-1)
+        {
+                data-&gt;duplicate(rebuild);
+                hint(data);
+                if(_param-&gt;show&amp;&amp;inframe)
+                {
+                        sprintf(txt,&quot; Telecined 2&quot;);
+                        drawString(data,2,4,txt);
+                }
+                
+                return 1;
+        }
+
+        //data-&gt;duplicate(rebuild);
+
+        srcP=vidCache-&gt;getImage(inframe-1);
+        src=vidCache-&gt;getImage(inframe);
+        srcN=vidCache-&gt;getImage(inframe+1);
+        srcNN=vidCache-&gt;getImage(inframe+2);
+
+        if(!src || !srcP || !srcN || !srcNN)
+        {
+                data-&gt;duplicate(vidCache-&gt;getImage(inframe));
+                vidCache-&gt;unlockAll();
+                return 1;
+        }
+        
+        // Let's rebuild the pseudo R, where we have A AR RB B
+        // If then we got R1 very close to R2, and that AR is very close to src
+        // Decide it is hard telecined (frame blending)
+#if 1
+        restore(rebuild,srcP,src,srcN,srcNN);
+#else
+        cand1-&gt;substract(src,srcP);
+        cand2-&gt;substract(srcN,srcNN);
+        rebuild-&gt;merge(cand1,cand2);
+#endif  
+#if 0
+        data-&gt;duplicate(rebuild);
+        vidCache-&gt;unlockAll();
+        return 1;
+#endif
+
+        // And remerge...
+        cand1-&gt;merge(srcP,rebuild);
+        cand2-&gt;merge(srcNN,rebuild);
+        
+        distP=ADMImage::lumaDiff(cand1,src,_param-&gt;noise);
+        distN=ADMImage::lumaDiff(cand2,srcN,_param-&gt;noise);
+        distM=ADMImage::lumaDiff(src,srcP,_param-&gt;noise);
+        distR=ADMImage::lumaDiff(src,srcN,_param-&gt;noise);
+        
+        
+        
+        double medium;
+
+         if(distM&gt;1&amp;&amp;distR&gt;1)
+        {
+                if(distM&gt;distR) medium=distR;
+                          else  medium=distM;
+                  //medium=min(distM,distR);
+                 
+                 medium/=100;
+                 distN/=medium;
+                 distP/=medium;
+                 distR/=medium;
+         
+         }
+
+        medium=medium/(_info.width*_info.height);
+        medium*=1000;
+
+        if(medium&lt;_param-&gt;identical)
+        {
+                 data-&gt;duplicate(src);
+                 vidCache-&gt;unlockAll();
+                if(_param-&gt;show)
+                {
+                        sprintf(txt,&quot; %% %02.1f : Identical&quot;,medium);
+                        drawString(data,2,3,txt);
+
+                }
+                return 1;
+        }
+        double mn;
+
+        if(inframe == _lastRemoved+5)
+        {
+                distN=(distN*7)/10;
+                distP=(distP*7)/10;
+                
+        }
+                //data-&gt;duplicate(src); 
+        if(distN&lt;_param-&gt;threshold &amp;&amp; distP&lt;_param-&gt;threshold)
+        {
+                data-&gt;duplicate(rebuild);
+                hint(data);
+                _lastRemoved=inframe;
+                if(_param-&gt;show &amp;&amp; inframe == _lastRemoved+5)
+                {
+                        sprintf(txt,&quot; Fav&quot;);
+                        drawString(data,2,5,txt);      
+                }
+        }
+        else
+                data-&gt;duplicate(src);
+        if(_param-&gt;show)
+        {
+                display=data;
+
+                sprintf(txt,&quot; N %02.1f&quot;,distN);
+                drawString(display,2,0,txt);
+
+                sprintf(txt,&quot; P %02.1f&quot;,distP);
+                drawString(display,2,1,txt);
+
+                sprintf(txt,&quot; R %02.1f&quot;,distR);
+                drawString(display,2,2,txt);
+
+                sprintf(txt,&quot; %% %02.1f&quot;,medium);
+                drawString(display,2,3,txt);
+
+                if(_lastRemoved==inframe)
+                {
+                        sprintf(txt,&quot; Telecined 1&quot;,distP);
+                        drawString(display,2,4,txt);
+                }
+        }
+
+
+          
+        vidCache-&gt;unlockAll();
+	return 1;
+}
+uint8_t vidHardPDRemoval::getCoupledConf (CONFcouple ** couples)
+{
+
+  ADM_assert (_param);
+  *couples = new CONFcouple (4);
+#undef CSET
+#define CSET(x)  (*couples)-&gt;setCouple(#x,(_param-&gt;x))
+  CSET (threshold);
+  CSET (show);
+  CSET (noise);
+  CSET (identical);
+  
+  return 1;
+}
+
+
+//EOF

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/CMakeLists.txt	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/BlendRemover/CMakeLists.txt	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_blendRemoval_SRCS ADM_vidBlendRemoval.cpp)
+
+ADD_LIBRARY(ADM_vf_blendRemoval SHARED ${ADM_vf_blendRemoval_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_blendRemoval)
+INSTALL_VIDEOFILTER(ADM_vf_blendRemoval)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/CMakeLists.txt	2008-05-01 18:21:27 UTC (rev 4008)
@@ -1 +1,9 @@
 ADD_SUBDIRECTORY(VerticalFlip)
+ADD_SUBDIRECTORY(BlendRemover)
+ADD_SUBDIRECTORY(Chroma)
+ADD_SUBDIRECTORY(DgBob)
+ADD_SUBDIRECTORY(TemporalCleaner)
+ADD_SUBDIRECTORY(Yadif)
+ADD_SUBDIRECTORY(ResampleFps)
+ADD_SUBDIRECTORY(Reverse)
+ADD_SUBDIRECTORY(Fade)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/ADM_vidChroma.h (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChroma.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidChroma.h	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/ADM_vidChroma.h	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,59 @@
+/***************************************************************************
+                          ADM_vidChroma.h  -  description
+                             -------------------
+    begin                : Wed Aug 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef CHROMA_
+#define CHROMA_
+
+ class  ADMVideoChromaU:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+
+           virtual char 									*printConf(void);
+			
+			
+
+ public:
+ 		
+  					ADMVideoChromaU(  AVDMGenericVideoStream *in,CONFcouple *setup);  	          							
+  					virtual ~ADMVideoChromaU();
+		          virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+			  		ADMImage *data,uint32_t *flags);
+				uint8_t configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 1;}
+							
+ }     ;
+
+ class  ADMVideoChromaV:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+
+           virtual char 									*printConf(void);
+			uint8_t											_reverse;
+
+ public:
+ 		
+  					ADMVideoChromaV(  AVDMGenericVideoStream *in,CONFcouple *setup);
+  					virtual ~ADMVideoChromaV();
+		          virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,											ADMImage *data,uint32_t *flags);
+					uint8_t configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 1;}
+							
+ }     ;
+
+#endif

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/ADM_vidChromaU.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/ADM_vidChromaU.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/ADM_vidChromaU.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,112 @@
+/***************************************************************************
+                          ADM_vidChroma.cpp  -  description
+                             -------------------
+    begin                : Wed Aug 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+
+#include &quot;ADM_vidChroma.h&quot;
+
+
+static FILTER_PARAM nullParam={0,{&quot;&quot;}};
+
+
+SCRIPT_CREATE(chromaU_script,ADMVideoChromaU,nullParam);
+BUILD_CREATE(chromaU_create,ADMVideoChromaU);
+
+
+VF_DEFINE_FILTER(ADMVideoChromaU,
+				&quot;chromau&quot;,
+				QT_TR_NOOP(&quot;Chroma U&quot;),
+				1,
+				chromaU_create,
+				chromaU_script,
+				VF_COLORS,
+				QT_TR_NOOP(&quot;Keep chroma U only.&quot;));
+
+char *ADMVideoChromaU::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf,&quot; chroma u only&quot;);
+        return buf;
+}
+
+//_______________________________________________________________
+
+ADMVideoChromaU::ADMVideoChromaU(
+									AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+    UNUSED_ARG(setup);
+
+	_in=in;		
+	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  			 	
+	_info.encoding=1;
+	
+  	  	
+}
+ADMVideoChromaU::~ADMVideoChromaU()
+{
+ 	
+	
+ 	
+}
+
+//
+//	Remove y and v just keep U and expand it
+//
+   uint8_t ADMVideoChromaU::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{				
+uint32_t w,x;
+uint32_t page;
+		if(frame&gt;= _info.nb_frames) return 0;
+       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+		
+		page= _info.width*_info.height;
+		*len=(page*3)&gt;&gt;1;
+
+
+		// now expand  u
+		uint8_t *y,*v,*y2;
+
+		y=YPLANE(data);
+		y2=y+_info.width;
+		v=UPLANE(data);
+		for(w= _info.height&gt;&gt;1;w&gt;0;w--)
+		{
+			for(x= _info.width&gt;&gt;1;x&gt;0;x--)
+			{
+				*y=*v;
+				*y2=*v;
+				*(y+1)=*v;
+				*(y2+1)=*v;
+				v++;
+				y+=2;
+				y2+=2;
+			}
+                	y+=_info.width;
+			y2+=_info.width;
+       		 }
+
+		 // Remove chroma u &amp; v
+		 memset(UPLANE(data),0x80,page&gt;&gt;2);
+		 memset(VPLANE(data),0x80,page&gt;&gt;2);
+}
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/ADM_vidChromaV.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/ADM_vidChromaV.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/ADM_vidChromaV.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,114 @@
+/***************************************************************************
+                          ADM_vidChroma.cpp  -  description
+                             -------------------
+    begin                : Wed Aug 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+
+#include &quot;ADM_vidChroma.h&quot;
+
+
+static FILTER_PARAM nullParam={0,{&quot;&quot;}};
+
+
+
+SCRIPT_CREATE(chromaV_script,ADMVideoChromaV,nullParam);
+BUILD_CREATE(chromaV_create,ADMVideoChromaV);
+
+
+VF_DEFINE_FILTER(ADMVideoChromaV,
+				&quot;chromav&quot;,
+				QT_TR_NOOP(&quot;Chroma V&quot;),
+				1,
+				chromaV_create,
+				chromaV_script,
+				VF_COLORS,
+				QT_TR_NOOP(&quot;Keep chroma V only.&quot;));
+
+
+
+char *ADMVideoChromaV::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf,&quot; chroma v only&quot;);
+        return buf;
+}
+
+//_______________________________________________________________
+
+ADMVideoChromaV::ADMVideoChromaV(
+									AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+    UNUSED_ARG(setup);
+
+	_in=in;
+	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
+	_info.encoding=1;
+ 
+
+}
+ADMVideoChromaV::~ADMVideoChromaV()
+{
+
+	
+
+}
+
+//
+//	Remove y and v just keep U and expand it
+//
+   uint8_t ADMVideoChromaV::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+uint32_t w,x;
+uint32_t page;
+		if(frame&gt;= _info.nb_frames) return 0;
+       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+		
+		page= _info.width*_info.height;
+		*len=(page*3)&gt;&gt;1;
+
+
+		// now expand  u
+		uint8_t *y,*v,*y2;
+
+		y=YPLANE(data);
+		y2=y+_info.width;
+		v=VPLANE(data);
+		for(w= _info.height&gt;&gt;1;w&gt;0;w--)
+		{
+			for(x= _info.width&gt;&gt;1;x&gt;0;x--)
+			{
+				*y=*v;
+				*y2=*v;
+				*(y+1)=*v;
+				*(y2+1)=*v;
+				v++;
+				y+=2;
+				y2+=2;
+			}
+                	y+=_info.width;
+			y2+=_info.width;
+       		 }
+
+		 // Remove chroma u &amp; v
+		 memset(UPLANE(data),0x80,page&gt;&gt;2);
+		 memset(VPLANE(data),0x80,page&gt;&gt;2);
+}
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/CMakeLists.txt	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Chroma/CMakeLists.txt	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,13 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vidChromaU_SRCS ADM_vidChromaU.cpp)
+ADD_LIBRARY(ADM_vidChromaU SHARED ${ADM_vidChromaU_SRCS})
+INIT_VIDEOFILTER_PLUGIN(ADM_vidChromaU)
+INSTALL_VIDEOFILTER(ADM_vidChromaU)
+
+
+SET(ADM_vidChromaV_SRCS ADM_vidChromaV.cpp)
+ADD_LIBRARY(ADM_vidChromaV SHARED ${ADM_vidChromaV_SRCS})
+INIT_VIDEOFILTER_PLUGIN(ADM_vidChromaV)
+INSTALL_VIDEOFILTER(ADM_vidChromaV)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DgBob/ADM_vidDGbob.cpp (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DgBob/ADM_vidDGbob.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,557 @@
+/*
+	DGBob() plugin for Avisynth -- Smart bob filter. This filter splits
+	each field of the source into its own frame and then adaptively
+	creates the missing lines either by interpolating the current field
+	or by using the previous field's data. The filter attempts with some
+	success to mitigate the flutter that bobbing produces.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;DIA_factory.h&quot;
+typedef struct DGBobparam
+{
+        uint32_t  thresh;// low=more flickering, less jaggie
+        uint32_t  order; //0 : Bottom field first, 1 top field first        
+        uint32_t  mode;  // 0 keep # of frames, 1 *2 fps &amp; *2 frame, 2  #*2, fps*150% slow motion
+        uint32_t  ap;    // Extra artifact check, better not to use
+}DGBobparam;
+
+class DGbob : public AVDMGenericVideoStream
+{
+       
+        DGBobparam      *_param;        
+        
+        VideoCache      *vidCache;
+       
+        void            update(void); 
+public:
+                                
+                        DGbob(AVDMGenericVideoStream *in,CONFcouple *couples);    
+                        ~DGbob(void);
+        uint8_t         getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                ADMImage *data,uint32_t *flags);
+        
+        char            *printConf( void );
+        uint8_t         configure(AVDMGenericVideoStream *in);
+        uint8_t         getCoupledConf( CONFcouple **couples);
+};
+
+
+//********** Register chunk ************
+static FILTER_PARAM dgbobParam={4,{&quot;order&quot;,&quot;mode&quot;,&quot;thresh&quot;,&quot;ap&quot;}};
+
+
+BUILD_CREATE(dgbob_create,DGbob);
+SCRIPT_CREATE(dgbob_script,DGbob,dgbobParam);
+
+VF_DEFINE_FILTER(ADMVideoFlipV,
+				&quot;dgbob&quot;,
+				QT_TR_NOOP(&quot;DG Bob&quot;),
+				1,
+				dgbob_create,
+				dgbob_script,
+				VF_INTERLACING,
+				QT_TR_NOOP(&quot;Donald Graft Bob.&quot;));
+//************************************
+
+/*************************************/
+uint8_t DGbob::configure(AVDMGenericVideoStream *in)
+{
+        _in=in;
+#define PX(x) &amp;(_param-&gt;x)
+  
+     diaMenuEntry menuField[2]={{0,QT_TR_NOOP(&quot;Top&quot;),NULL},
+                             {1,QT_TR_NOOP(&quot;Bottom&quot;),NULL}
+                          };
+  
+     diaMenuEntry menuMode[3]={{0,QT_TR_NOOP(&quot;Keep nb of frames and fps&quot;),NULL},
+                            {1,QT_TR_NOOP(&quot;Double nb of frames and fps&quot;),NULL},
+                            {2,QT_TR_NOOP(&quot;Double nb of frames (slow motion)&quot;),NULL}
+                          };
+                          
+    diaElemMenu     menu1(PX(order),QT_TR_NOOP(&quot;_Field order:&quot;), 2,menuField);
+    diaElemMenu     menu2(PX(mode),QT_TR_NOOP(&quot;_Mode:&quot;), 3,menuMode);
+    diaElemUInteger threshold(PX(thresh),QT_TR_NOOP(&quot;_Threshold:&quot;),0,255);
+    diaElemToggle  extra(PX(ap),QT_TR_NOOP(&quot;_Extra&quot;),QT_TR_NOOP(&quot;Extra check, avoid using it&quot;));
+    
+      diaElem *elems[4]={&amp;menu1,&amp;menu2,&amp;threshold ,&amp;extra};
+   if(diaFactoryRun(QT_TR_NOOP(&quot;DGBob&quot;),4,elems))
+  {
+                update();
+                return 1;
+        }
+        return 0;
+        
+}
+
+char *DGbob::printConf( void )
+{
+        static char buf[50];
+
+        //ADM_assert(_param);
+        sprintf((char *)buf,&quot; DGBob mode:%d order:%d thresh:%d\n&quot;,_param-&gt;mode,_param-&gt;order,_param-&gt;thresh);
+        return buf;
+}
+
+
+DGbob::DGbob(AVDMGenericVideoStream *in,CONFcouple *couples)              
+
+{
+                
+                int count = 0;
+                char buf[80];
+                unsigned int *p;
+
+                _in=in;         
+                memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+                _info.encoding=1;
+                _uncompressed=NULL;             
+                _info.encoding=1;
+                _info.fps1000*=2;
+                _info.nb_frames*=2;
+                
+                                
+                vidCache=new VideoCache(7,in);
+                _param= new DGBobparam;
+                if(couples)
+                {
+                        GET(order);
+                        GET(mode);
+                        GET(thresh);
+                        GET(ap);
+                }
+                else
+                {
+                        _param-&gt;order=1;
+                        _param-&gt;mode=0;
+                        _param-&gt;thresh=12;
+                        _param-&gt;ap=0;
+                }
+                update();
+}
+void DGbob::update(void)
+{
+                memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+                _info.encoding=1;
+                switch(_param-&gt;mode)
+                {
+                        case 0:
+                                break;
+                        case 1:
+                                _info.fps1000*=2;
+                                _info.nb_frames*=2;
+                                break;
+                        case 2:
+                                _info.nb_frames*=2;
+                                break;
+                        default: ADM_assert(0);
+
+                }
+             
+}
+//________________________________________________________
+uint8_t DGbob::getCoupledConf( CONFcouple **couples)
+{
+        *couples=NULL;
+        *couples=new CONFcouple(4);
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+        
+        CSET(order);
+        CSET(mode);
+        CSET(thresh);
+        CSET(ap);
+
+        return 1;
+}
+//________________________________________________________
+DGbob::~DGbob(void)
+{
+                
+                if(vidCache) delete vidCache;                
+                vidCache=NULL;   
+                if(_param) delete _param;
+                _param=NULL;                             
+}
+uint8_t DGbob::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                ADMImage *data,uint32_t *flags)
+{
+        ADMImage *src,*prv,*prvprv,*nxt,*nxtnxt,*dst;
+	uint32_t n,num_frames;
+
+        if(frame&gt;=_info.nb_frames) return 0;
+        
+        num_frames=_in-&gt;getInfo()-&gt;nb_frames;   // ??
+
+	if (_param-&gt;mode == 0) n = frame;
+	else n = frame/2;
+
+        src=vidCache-&gt;getImage(n);
+        prv=vidCache-&gt;getImage(n &gt; 0 ? n - 1 :0 );
+        prvprv=vidCache-&gt;getImage(n &gt; 1 ? n - 2 : 0);
+        nxt=vidCache-&gt;getImage(n &lt; num_frames - 1 ? n + 1 : num_frames - 1);
+        nxtnxt=vidCache-&gt;getImage(n &lt; num_frames - 2 ? n + 2 : num_frames - 1);
+
+
+/*
+	PVideoFrame src = child-&gt;GetFrame(n, env);
+	PVideoFrame prv = child-&gt;GetFrame(n &gt; 0 ? n - 1 : 0, env);
+	PVideoFrame prvprv = child-&gt;GetFrame(n &gt; 1 ? n - 2 : 0, env);
+	PVideoFrame nxt = child-&gt;GetFrame(n &lt; vi.num_frames - 1 ? n + 1 : vi.num_frames - 1, env);
+	PVideoFrame nxtnxt = child-&gt;GetFrame(n &lt; vi.num_frames - 2 ? n + 2 : vi.num_frames - 1, env);
+    PVideoFrame dst = env-&gt;NewVideoFrame(vi);
+*/
+    const unsigned char *srcp, *srcp_saved, *srcpp, *srcpn;
+	const unsigned char *prvp, *prvpp, *prvpn, *prvprvp, *prvprvpp, *prvprvpn;
+	const unsigned char *nxtp, *nxtpp, *nxtpn, *nxtnxtp, *nxtnxtpp, *nxtnxtpn;
+    unsigned char *dstp, *dstp_saved;
+ 
+    int src_pitch, dst_pitch, w, h;
+	int x, y, z, v1, v2, D = _param-&gt;thresh, T = 6, AP = 30;
+	int plane;
+
+        uint32_t ww,hh;
+	// Try making D a function of the average value of the comparands in
+	// order to make the margin larger in darker areas, where we can't see as
+	// much combing.
+
+	// Force deinterlacing of the first and last frames.
+	if (n == 0 || n == num_frames - 1) D = 0;
+        dst=data;
+	for (z = 0; z &lt; 3; z++)
+	{
+/*
+		if (z == 0) plane = PLANAR_Y;
+		else if (z == 1) plane = PLANAR_U;
+		else plane = PLANAR_V;
+
+*/
+                switch(z)
+                {
+                        case 0:
+                                ww=_info.width;
+                                hh=_info.height;
+                                srcp_saved = srcp = YPLANE(src);                                
+                                dstp_saved = dstp = YPLANE(dst);
+                                src_pitch = ww;
+                                dst_pitch = ww;
+                                w = ww;
+                                h = hh;
+                                break;
+                        case 1:
+                        case 2:
+                                ww=_info.width&gt;&gt;1;
+                                hh=_info.height&gt;&gt;1;
+                                if(z==1)
+                                {
+                                        srcp_saved = srcp = UPLANE(src);
+                                        dstp_saved = dstp = UPLANE(dst);
+                                }
+                                else
+                                {
+                                        srcp_saved = srcp = VPLANE(src);
+                                        dstp_saved = dstp = VPLANE(dst);
+                                }
+                                src_pitch = ww;
+                                dst_pitch = ww;
+                                w = ww;
+                                h = hh;
+                                break;
+                }
+/*
+		srcp_saved = srcp = src-&gt;GetReadPtr(plane);
+		src_pitch = src-&gt;GetPitch(plane);
+		dstp_saved = dstp = dst-&gt;GetWritePtr(plane);
+		dst_pitch = dst-&gt;GetPitch(plane);
+		w = dst-&gt;GetRowSize(plane);
+		h = dst-&gt;GetHeight(plane);
+*/
+		if ((_param-&gt;mode &gt; 0) &amp;&amp; (frame &amp; 1))
+		{
+			// Process odd-numbered frames.
+			// Copy field from current frame.
+			srcp = srcp_saved +_param-&gt;order * src_pitch;
+			dstp = dstp_saved +_param-&gt;order * dst_pitch;
+			for (y = 0; y &lt; h; y+=2)
+			{
+				memcpy(dstp, srcp, w);
+				srcp += 2*src_pitch;
+				dstp += 2*dst_pitch;
+			}
+			// Copy through the line that will be missed below.
+			memcpy(dstp_saved + (1-_param-&gt;order)*(h-1)*dst_pitch, srcp_saved + (1-_param-&gt;order)*(h-1)*src_pitch, w);
+			/* For the other field choose adaptively between using the previous field
+			   or the interpolant from the current field. */
+                        
+			//prvp = prv-&gt;GetReadPtr(plane) + src_pitch + order*src_pitch;
+                        switch(z)
+                        {
+                                case 0:prvp = YPLANE(prv) + src_pitch + _param-&gt;order*src_pitch;break;
+                                case 1:prvp = UPLANE(prv) + src_pitch + _param-&gt;order*src_pitch;break;
+                                case 2:prvp = VPLANE(prv) + src_pitch + _param-&gt;order*src_pitch;break;
+                        }
+			prvpp = prvp - src_pitch;
+			prvpn = prvp + src_pitch;
+			//prvprvp = prvprv-&gt;GetReadPtr(plane) + src_pitch + order*src_pitch;
+                         switch(z)
+                        {
+                                case 0:prvprvp = YPLANE(prvprv) + src_pitch + _param-&gt;order*src_pitch;break;
+                                case 1:prvprvp = UPLANE(prvprv) + src_pitch + _param-&gt;order*src_pitch;break;
+                                case 2:prvprvp = VPLANE(prvprv) + src_pitch + _param-&gt;order*src_pitch;break;
+                        }
+
+			prvprvpp = prvprvp - src_pitch;
+			prvprvpn = prvprvp + src_pitch;
+
+			//nxtp = nxt-&gt;GetReadPtr(plane) + src_pitch + order*src_pitch;
+                        switch(z)
+                        {
+                                case 0:nxtp = YPLANE(nxt) + src_pitch + _param-&gt;order*src_pitch;break;
+                                case 1:nxtp = UPLANE(nxt) + src_pitch + _param-&gt;order*src_pitch;break;
+                                case 2:nxtp = VPLANE(nxt) + src_pitch + _param-&gt;order*src_pitch;break;
+                        }
+
+			nxtpp = nxtp - src_pitch;
+			nxtpn = nxtp + src_pitch;
+			//nxtnxtp = nxtnxt-&gt;GetReadPtr(plane) + src_pitch + order*src_pitch;
+                        switch(z)
+                        {
+                                case 0:nxtnxtp = YPLANE(nxtnxt) + src_pitch + _param-&gt;order*src_pitch;break;
+                                case 1:nxtnxtp = UPLANE(nxtnxt) + src_pitch + _param-&gt;order*src_pitch;break;
+                                case 2:nxtnxtp = VPLANE(nxtnxt) + src_pitch + _param-&gt;order*src_pitch;break;
+                        }
+			nxtnxtpp = nxtnxtp - src_pitch;
+			nxtnxtpn = nxtnxtp + src_pitch;
+			srcp =  srcp_saved + src_pitch + _param-&gt;order*src_pitch;
+			srcpp = srcp - src_pitch;
+			srcpn = srcp + src_pitch;
+			dstp =  dstp_saved + dst_pitch + _param-&gt;order*dst_pitch;
+			for (y = 0; y &lt; h - 2; y+=2)
+			{
+				for (x = 0; x &lt; w; x++)
+				{
+					if (
+						abs(srcp[x] - nxtp[x]) &lt; D
+//						&amp;&amp; abs(srcp[x] - nxtnxtp[x]) &lt; D
+//						&amp;&amp; abs(prvp[x] - nxtp[x]) &lt; D
+						&amp;&amp; abs(srcpn[x] - prvprvpn[x]) &lt; D
+						&amp;&amp; abs(srcpp[x] - prvprvpp[x]) &lt; D
+						&amp;&amp; abs(srcpn[x] - nxtnxtpn[x]) &lt; D
+						&amp;&amp; abs(srcpp[x] - nxtnxtpp[x]) &lt; D
+						&amp;&amp; abs(srcpn[x] - prvpn[x]) &lt; D
+						&amp;&amp; abs(srcpp[x] - prvpp[x]) &lt; D
+						&amp;&amp; abs(srcpn[x] - nxtpn[x]) &lt; D
+						&amp;&amp; abs(srcpp[x] - nxtpp[x]) &lt; D
+					   )
+					{
+						if (_param-&gt;ap == true)
+						{
+							v1 = (int) srcp[x] - AP;
+							if (v1 &lt; 0) v1 = 0; 
+							v2 = (int) srcp[x] + AP;
+							if (v2 &gt; 235) v2 = 235; 
+							if ((v1 &gt; srcpp[x] &amp;&amp; v1 &gt; srcpn[x]) || (v2 &lt; srcpp[x] &amp;&amp; v2 &lt; srcpn[x]))
+							{
+								dstp[x] = ((int)srcpp[x] + srcpn[x]) &gt;&gt; 1;
+//								if (x &amp; 1) dstp[x] = 100; else dstp[x] = 235;
+							}
+							else
+							{
+								dstp[x] = srcp[x];
+//								if (x &amp; 1) dstp[x] = 100; else dstp[x] = 235;
+							}
+						}
+						else
+						{
+							dstp[x] = srcp[x];
+//							if (x &amp; 1) dstp[x] = 100; else dstp[x] = 235;
+						}
+					}
+					else
+					{
+						v1 = (int) srcp[x] - T;
+						if (v1 &lt; 0) v1 = 0; 
+						v2 = (int) srcp[x] + T;
+						if (v2 &gt; 235) v2 = 235; 
+						if ((v1 &gt; srcpp[x] &amp;&amp; v1 &gt; srcpn[x]) || (v2 &lt; srcpp[x] &amp;&amp; v2 &lt; srcpn[x]))
+						{
+							dstp[x] = ((int)srcpp[x] + srcpn[x]) &gt;&gt; 1;
+						}
+						else
+						{
+							dstp[x] = srcp[x];
+//							if (x &amp; 1) dstp[x] = 128; else dstp[x] = 235;
+						}
+					}
+				}
+				prvp    += 2*src_pitch;
+				prvpp    += 2*src_pitch;
+				prvpn    += 2*src_pitch;
+				prvprvpp    += 2*src_pitch;
+				prvprvpn    += 2*src_pitch;
+				nxtp    += 2*src_pitch;
+				nxtpp    += 2*src_pitch;
+				nxtpn    += 2*src_pitch;
+				nxtnxtpp    += 2*src_pitch;
+				nxtnxtpn    += 2*src_pitch;
+				srcp    += 2*src_pitch;
+				srcpp   += 2*src_pitch;
+				srcpn   += 2*src_pitch;
+				dstp    += 2*dst_pitch;
+			}
+		}
+		else
+		{
+			// Process even-numbered frames.
+			// Copy field from current frame.
+			srcp = srcp_saved + (1-_param-&gt;order) * src_pitch;
+			dstp = dstp_saved + (1-_param-&gt;order) * dst_pitch;
+			for (y = 0; y &lt; h; y+=2)
+			{
+				memcpy(dstp, srcp, w);
+				srcp += 2*src_pitch;
+				dstp += 2*dst_pitch;
+			}
+			// Copy through the line that will be missed below.
+			memcpy(dstp_saved + _param-&gt;order*(h-1)*dst_pitch, srcp_saved + _param-&gt;order*(h-1)*src_pitch, w);
+			/* For the other field choose adaptively between using the previous field
+			   or the interpolant from the current field. */
+			//prvp = prv-&gt;GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
+                        switch(z)
+                        {
+                                case 0:prvp = YPLANE(prv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                                case 1:prvp = UPLANE(prv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                                case 2:prvp = VPLANE(prv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                        }
+			prvpp = prvp - src_pitch;
+			prvpn = prvp + src_pitch;
+			// prvprvp = prvprv-&gt;GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
+                        switch(z)
+                        {
+                                case 0:prvprvp = YPLANE(prvprv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                                case 1:prvprvp = UPLANE(prvprv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                                case 2:prvprvp = VPLANE(prvprv) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                        }
+                        
+			prvprvpp = prvprvp - src_pitch;
+			prvprvpn = prvprvp + src_pitch;
+			//nxtp = nxt-&gt;GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
+                        switch(z)
+                        {
+                                case 0:nxtp = YPLANE(nxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                                case 1:nxtp = UPLANE(nxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                                case 2:nxtp = VPLANE(nxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                        }
+			nxtpp = nxtp - src_pitch;
+			nxtpn = nxtp + src_pitch;
+			//nxtnxtp = nxtnxt-&gt;GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
+                         switch(z)
+                        {
+                                case 0:nxtnxtp = YPLANE(nxtnxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                                case 1:nxtnxtp = UPLANE(nxtnxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                                case 2:nxtnxtp = VPLANE(nxtnxt) + src_pitch + (1-_param-&gt;order)*src_pitch;break;
+                        }
+			nxtnxtpp = nxtnxtp - src_pitch;
+			nxtnxtpn = nxtnxtp + src_pitch;
+			srcp =  srcp_saved + src_pitch + (1-_param-&gt;order)*src_pitch;
+			srcpp = srcp - src_pitch;
+			srcpn = srcp + src_pitch;
+			dstp =  dstp_saved + dst_pitch + (1-_param-&gt;order)*dst_pitch;
+			for (y = 0; y &lt; h - 2; y+=2)
+			{
+				for (x = 0; x &lt; w; x++)
+				{
+					if (
+						abs(srcp[x] - prvp[x]) &lt; D
+//						&amp;&amp; abs(srcp[x] - prvprvp[x]) &lt; D
+//						&amp;&amp; abs(prvp[x] - nxtp[x]) &lt; D
+						&amp;&amp; abs(srcpn[x] - prvprvpn[x]) &lt; D
+						&amp;&amp; abs(srcpp[x] - prvprvpp[x]) &lt; D
+						&amp;&amp; abs(srcpn[x] - nxtnxtpn[x]) &lt; D
+						&amp;&amp; abs(srcpp[x] - nxtnxtpp[x]) &lt; D
+						&amp;&amp; abs(srcpn[x] - prvpn[x]) &lt; D
+						&amp;&amp; abs(srcpp[x] - prvpp[x]) &lt; D
+						&amp;&amp; abs(srcpn[x] - nxtpn[x]) &lt; D
+						&amp;&amp; abs(srcpp[x] - nxtpp[x]) &lt; D
+					   )
+					{
+						if (_param-&gt;ap == true)
+						{
+							v1 = (int) prvp[x] - AP;
+							if (v1 &lt; 0) v1 = 0; 
+							v2 = (int) prvp[x] + AP;
+							if (v2 &gt; 235) v2 = 235; 
+							if ((v1 &gt; srcpp[x] &amp;&amp; v1 &gt; srcpn[x]) ||	(v2 &lt; srcpp[x] &amp;&amp; v2 &lt; srcpn[x]))
+							{
+								dstp[x] = ((int)srcpp[x] + srcpn[x]) &gt;&gt; 1;
+//								if (x &amp; 1) dstp[x] = 100; else dstp[x] = 235;
+							}
+							else
+							{
+								dstp[x] = prvp[x];
+//								if (x &amp; 1) dstp[x] = 128; else dstp[x] = 235;
+							}
+						}
+						else
+						{
+							dstp[x] = prvp[x];
+//							if (x &amp; 1) dstp[x] = 128; else dstp[x] = 235;
+						}
+					}
+					else
+					{
+						v1 = (int) prvp[x] - T;
+						if (v1 &lt; 0) v1 = 0; 
+						v2 = (int) prvp[x] + T;
+						if (v2 &gt; 235) v2 = 235; 
+						if ((v1 &gt; srcpp[x] &amp;&amp; v1 &gt; srcpn[x]) ||	(v2 &lt; srcpp[x] &amp;&amp; v2 &lt; srcpn[x]))
+						{
+							dstp[x] = ((int)srcpp[x] + srcpn[x]) &gt;&gt; 1;
+						}
+						else
+						{
+							dstp[x] = prvp[x];
+//							if (x &amp; 1) pp[x] = 128; else dstp[x] = 235;
+						}
+					}
+				}
+				prvp    += 2*src_pitch;
+				prvpp    += 2*src_pitch;
+				prvpn    += 2*src_pitch;
+				prvprvpp    += 2*src_pitch;
+				prvprvpn    += 2*src_pitch;
+				nxtp    += 2*src_pitch;
+				nxtpp    += 2*src_pitch;
+				nxtpn    += 2*src_pitch;
+				nxtnxtpp    += 2*src_pitch;
+				nxtnxtpn    += 2*src_pitch;
+				srcp    += 2*src_pitch;
+				srcpp   += 2*src_pitch;
+				srcpn   += 2*src_pitch;
+				dstp    += 2*dst_pitch;
+			}
+		}
+	}
+        vidCache-&gt;unlockAll();
+	return 1;
+}
+//EOF
+
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DgBob/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DgBob/CMakeLists.txt	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/DgBob/CMakeLists.txt	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_blendDgBob_SRCS ADM_vidDGbob.cpp)
+
+ADD_LIBRARY(ADM_vf_blendDgBob SHARED ${ADM_vf_blendDgBob_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_blendDgBob)
+INSTALL_VIDEOFILTER(ADM_vf_blendDgBob)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Fade/ADM_vidFade.cpp (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Fade/ADM_vidFade.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,283 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;DIA_enter.h&quot;
+#include &quot;DIA_factory.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_vidFade_param.h&quot;
+class AVDM_Fade : public AVDMGenericVideoStream
+{
+  VideoCache      *vidCache;
+  VIDFADE_PARAM   *_param;
+  uint16_t         lookupLuma[256][256];
+  uint16_t         lookupChroma[256][256];
+  uint8_t         buildLut(void);
+  public:
+                                
+                    AVDM_Fade(AVDMGenericVideoStream *in,CONFcouple *couples);    
+                    ~AVDM_Fade(void);
+    uint8_t         getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                          ADMImage *data,uint32_t *flags);
+        
+    char            *printConf( void );
+    uint8_t         configure(AVDMGenericVideoStream *in);
+    uint8_t         getCoupledConf( CONFcouple **couples);
+};
+
+static FILTER_PARAM fadeParam={4,{&quot;startFade&quot;,&quot;endFade&quot;,&quot;inOut&quot;,&quot;toBlack&quot;}};
+
+BUILD_CREATE(fade_create,AVDM_Fade);
+SCRIPT_CREATE(fade_script,AVDM_Fade,fadeParam);
+
+VF_DEFINE_FILTER(AVDM_Fade,
+                &quot;fade&quot;,
+                QT_TR_NOOP(&quot;Fade&quot;),
+                1,
+                fade_create,
+                fade_script,
+                VF_TRANSFORM,
+                QT_TR_NOOP(&quot;Fade in/out.&quot;));
+/*************************************/
+uint8_t AVDM_Fade::configure(AVDMGenericVideoStream *in)
+{
+  uint32_t mx=_info.nb_frames;
+  _in=in;
+  
+  diaMenuEntry menuE[2]={{0,QT_TR_NOOP(&quot;Out&quot;),QT_TR_NOOP(&quot;Fade out&quot;)},{1,QT_TR_NOOP(&quot;In&quot;),QT_TR_NOOP(&quot;Fade in&quot;)}};
+  uint32_t start,end;
+  VIDFADE_PARAM param=*_param;
+  
+while(1)
+{
+    diaElemMenu     menu(&amp;(param.inOut),QT_TR_NOOP(&quot;_Fade type:&quot;), 2,menuE);
+    diaElemUInteger start(&amp;(param.startFade),QT_TR_NOOP(&quot;_Start frame:&quot;),0,mx);
+    diaElemUInteger end(&amp;(param.endFade),QT_TR_NOOP(&quot;_End frame:&quot;),0,mx);
+    diaElemToggle   black(&amp;(param.toBlack),QT_TR_NOOP(&quot;Fade to _black&quot;));
+    
+    diaElem *elems[4]={&amp;menu,&amp;start,&amp;end,&amp;black};
+  
+    if( diaFactoryRun(QT_TR_NOOP(&quot;Fade&quot;),4,elems))
+    {
+      // Check it is consistent
+      if(param.startFade&gt;=param.endFade || (param.startFade&gt;=mx) || (param.endFade&gt;=mx))
+      {
+        GUI_Error_HIG(QT_TR_NOOP(&quot;Parameter Error&quot;),QT_TR_NOOP(&quot;Start must be before end, and both within video # of frames.&quot;));
+        continue; 
+      }
+      //
+      *_param=param;
+      return 1;
+    }else
+        return 0;
+} 
+  return 1;
+}
+
+char *AVDM_Fade::printConf( void )
+{
+  static char buf[50];
+
+        //ADM_assert(_param);
+  sprintf((char *)buf,&quot; Fade : Start %u End %u&quot;,_param-&gt;startFade,_param-&gt;endFade);
+  if(_param-&gt;inOut) strcat(buf,&quot; In&quot;); else strcat(buf,&quot; Out&quot;);
+  return buf;
+}
+
+
+AVDM_Fade::AVDM_Fade(AVDMGenericVideoStream *in,CONFcouple *couples)
+
+{
+                
+  int count = 0;
+  char buf[80];
+  unsigned int *p;
+
+  _in=in;         
+  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+  _info.encoding=1;
+  vidCache=new VideoCache(3,in);
+  
+  _param=new VIDFADE_PARAM;
+  if(couples)
+  {
+    GET(startFade);
+    GET(endFade);
+    GET(inOut);
+    GET(toBlack);
+    
+  }else
+  {
+    _param-&gt;startFade=0; 
+    _param-&gt;endFade=_info.nb_frames-1;
+    _param-&gt;inOut=0;
+    _param-&gt;toBlack=0;
+  }
+  buildLut();
+}
+//________________________________________________________
+uint8_t AVDM_Fade::getCoupledConf( CONFcouple **couples)
+{
+  *couples=new CONFcouple(4);
+  CSET(startFade);
+  CSET(endFade);
+  CSET(inOut);
+  CSET(toBlack);
+  return 1;
+}
+//________________________________________________________
+AVDM_Fade::~AVDM_Fade(void)
+{
+                
+  if(vidCache) delete vidCache;                
+  vidCache=NULL;   
+  if(_param) delete _param;
+  _param=NULL;
+}
+uint8_t AVDM_Fade::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                            ADMImage *data,uint32_t *flags)
+{
+
+  uint32_t num_frames,tgt;
+  
+  ADMImage *src;
+
+  num_frames=_info.nb_frames;   // ??
+
+  tgt=frame+_info.orgFrame;
+  if(frame&gt;=num_frames)
+  {
+    printf(&quot;[Fade] out of bound\n&quot;);
+    return 0;
+  }
+
+  src=vidCache-&gt;getImage(frame);
+  if(!src) return 0;
+  if(tgt&gt;_param-&gt;endFade || tgt &lt;_param-&gt;startFade ||_param-&gt;endFade==_param-&gt;startFade )
+  {
+    //printf(&quot;Cur %u start %u end %u\n&quot;,tgt,_param-&gt;startFade,_param-&gt;endFade);
+    data-&gt;duplicate(src);
+    vidCache-&gt;unlockAll();
+    return 1;
+  }
+  uint8_t *s,*d,*s2;
+  uint16_t *index,*invertedIndex;
+  uint32_t count=_info.width*_info.height,w;
+  float num,den;
+  
+  den=_param-&gt;endFade-_param-&gt;startFade;
+  
+  num=tgt-_param-&gt;startFade;
+  
+  num=num/den;
+  num*=255.;
+  w=(uint32_t)floor(num+0.4);
+  
+//printf(&quot;w :%u\n&quot;,w);
+
+  s=src-&gt;data;
+  d=data-&gt;data;
+  if(_param-&gt;toBlack)
+  {
+        index=lookupLuma[w];
+        for(int i=0;i&lt;count;i++)
+        {
+          *d++=(index[*s++]&gt;&gt;8);
+        }
+        // Now do chroma
+        count&gt;&gt;=2;
+        s=UPLANE(src);
+        d=UPLANE(data);
+        index=lookupChroma[w];
+        for(int i=0;i&lt;count;i++)
+        {
+          *d++=(index[*s++]&gt;&gt;8);
+        }
+        s=VPLANE(src);
+        d=VPLANE(data);
+        for(int i=0;i&lt;count;i++)
+        {
+          *d++=(index[*s++]&gt;&gt;8);
+        }
+  }
+  else
+  {
+        uint32_t x,alpha;
+        ADMImage *final;
+
+        final=vidCache-&gt;getImage(_param-&gt;endFade-_info.orgFrame);
+        if(!final)
+        {
+              data-&gt;duplicate(src);
+              vidCache-&gt;unlockAll();
+              return 1;
+        }
+
+        s2=final-&gt;data;
+
+        index=lookupLuma[w];
+        
+        invertedIndex=lookupLuma[255-w];
+        for(int i=0;i&lt;count;i++)
+        {
+          *d++=(index[*s++]+invertedIndex[*s2++])&gt;&gt;8;
+        }
+        // Now do chroma
+        count&gt;&gt;=2;
+        s=UPLANE(src);
+        d=UPLANE(data);
+        s2=UPLANE(final);
+        index=lookupChroma[w];
+        invertedIndex=lookupChroma[255-w];
+        for(int i=0;i&lt;count;i++)
+        {
+            *d++=(index[*s++]+invertedIndex[*s2++]-(128&lt;&lt;8))&gt;&gt;8;
+        }
+        s=VPLANE(src);
+        d=VPLANE(data);
+        s2=VPLANE(final);
+        for(int i=0;i&lt;count;i++)
+        {
+            *d++=(index[*s++]+invertedIndex[*s2++]-(128&lt;&lt;8))&gt;&gt;8;
+            
+        }
+  }
+  vidCache-&gt;unlockAll();
+  return 1;
+}
+
+uint8_t AVDM_Fade::buildLut(void)
+{
+  float f,ration;
+  for(int i=0;i&lt;256;i++)
+  {
+    if(!_param-&gt;inOut) ration=255-i;
+    else ration=i;
+    for(int r=0;r&lt;256;r++)
+    {
+      f=r;
+      f=f*ration;
+      lookupLuma[i][r]=(uint16_t)(f+0.4);
+
+      f=r-128;
+      f=f*ration;
+      lookupChroma[i][r]=(128&lt;&lt;8)+(uint16_t)(f+0.4);
+
+    }
+    
+  }
+  return 1;
+}
+//EOF
+
+
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Fade/ADM_vidFade_param.h (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidFade_param.h	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Fade/ADM_vidFade_param.h	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,23 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef ADM_VIDFADE_PARAM_H
+#define ADM_VIDFADE_PARAM_H
+
+typedef struct VIDFADE_PARAM
+{
+  uint32_t startFade;
+  uint32_t endFade;
+  uint32_t inOut; //0 Out 1 In
+  uint32_t toBlack; // =1 else fade to endFrame
+}VIDFADE_PARAM;
+
+
+
+#endif

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Fade/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Fade/CMakeLists.txt	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Fade/CMakeLists.txt	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_fade_SRCS ADM_vidFade.cpp)
+
+ADD_LIBRARY(ADM_vf_fade SHARED ${ADM_vf_fade_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_fade)
+INSTALL_VIDEOFILTER(ADM_vf_fade)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ResampleFps/ADM_vidResampleFPS.cpp (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ResampleFps/ADM_vidResampleFPS.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,350 @@
+/***************************************************************************
+                          Resample fps
+                             -------------------
+    begin                : Wed Nov 6 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;DIA_enter.h&quot;
+#include &quot;DIA_factory.h&quot;
+
+static FILTER_PARAM ResampParam={2,{&quot;newfps&quot;,&quot;use_linear&quot;}};
+typedef struct FPS_Param
+{
+  uint32_t  newfps; 
+  uint32_t  use_linear;
+}FPS_Param;
+class  ADMVideoResampleFPS:public AVDMGenericVideoStream
+{
+
+  protected:
+    AVDMGenericVideoStream  *_in;           
+    virtual char            *printConf(void);
+            FPS_Param       *_param;    
+            VideoCache      *vidCache; 
+  public:
+                
+                        ADMVideoResampleFPS(  AVDMGenericVideoStream *in,CONFcouple *setup);
+                        ADMVideoResampleFPS(  AVDMGenericVideoStream *in,uint32_t target1000);
+    virtual             ~ADMVideoResampleFPS();
+    virtual uint8_t     configure(AVDMGenericVideoStream *in);
+    virtual uint8_t     getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                          ADMImage *data,uint32_t *flags);
+
+             uint8_t     getCoupledConf( CONFcouple **couples);
+}     ;
+//***********************************
+SCRIPT_CREATE(resamplefps_script,ADMVideoResampleFPS,ResampParam);
+BUILD_CREATE(resamplefps_create,ADMVideoResampleFPS);
+
+VF_DEFINE_FILTER(ADMVideoResampleFPS,
+                &quot;resamplefps&quot;,
+                QT_TR_NOOP(&quot;Resample fps&quot;),
+                1,
+                resamplefps_create,
+                resamplefps_script,
+                VF_TRANSFORM,
+                QT_TR_NOOP(&quot;Change framerate while keeping duration.&quot;));
+//***********************************
+
+AVDMGenericVideoStream *createResampleFps(AVDMGenericVideoStream *in,uint32_t targetfps1000)
+{
+  return new ADMVideoResampleFPS(in,targetfps1000);
+}
+
+uint8_t ADMVideoResampleFPS::configure(AVDMGenericVideoStream *in)
+{
+  float f=_param-&gt;newfps; 
+  f/=1000;
+  
+  _in=in;
+  
+    diaElemFloat fps(&amp;f,QT_TR_NOOP(&quot;_New frame rate:&quot;),1,200.);
+    diaElemToggle blend(&amp;(_param-&gt;use_linear),QT_TR_NOOP(&quot;_Blend&quot;));
+    
+    diaElem *elems[2]={&amp;fps,&amp;blend};
+  
+    if( diaFactoryRun(QT_TR_NOOP(&quot;Resample fps&quot;),2,elems))
+    {
+        f*=1000;
+      _param-&gt;newfps=(uint32_t)floor(f+0.4); 
+      _info.fps1000=_param-&gt;newfps;
+      return 1;
+    }
+    return 0;
+}
+char *ADMVideoResampleFPS::printConf( void )
+{
+  static char buf[50];
+        
+  sprintf((char *)buf,&quot; Resample to %2.2f fps (blend:%d)&quot;,(double)_param-&gt;newfps/1000.,
+                _param-&gt;use_linear);
+  return buf;
+}
+
+ADMVideoResampleFPS::ADMVideoResampleFPS(  AVDMGenericVideoStream *in,uint32_t target)
+{
+
+  _in=in;         
+  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+  _info.encoding=1; 
+  _param=new  FPS_Param;
+   
+    _param-&gt;newfps =target;                
+    _param-&gt;use_linear=1;
+ 
+  double newlength;
+  
+  newlength=_info.nb_frames;
+  newlength/=_info.fps1000;
+  newlength*=_param-&gt;newfps;
+  _info.nb_frames=(uint32_t)floor(newlength);
+  _info.fps1000=_param-&gt;newfps;
+  printf(&quot;[Resample FPS] %u -&gt; %u\n&quot;,_in-&gt;getInfo()-&gt;nb_frames,_info.nb_frames);
+  vidCache=new VideoCache(3,_in);
+
+}
+
+ADMVideoResampleFPS::ADMVideoResampleFPS(  AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+  
+  _in=in;         
+  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+  _info.encoding=1; 
+  _param=new  FPS_Param;
+   
+  if(couples)
+  {                 
+    GET(newfps);    
+    GET(use_linear); 
+  }
+  else
+  {
+    _param-&gt;newfps =_info.fps1000;                
+    _param-&gt;use_linear=0;
+  }      
+ 
+  double newlength;
+  
+  newlength=_info.nb_frames;
+  newlength/=_info.fps1000;
+  newlength*=_param-&gt;newfps;
+  _info.nb_frames=(uint32_t)floor(newlength);
+  _info.fps1000=_param-&gt;newfps;
+  vidCache=new VideoCache(3,_in);
+  
+}
+ADMVideoResampleFPS::~ADMVideoResampleFPS()
+{
+  delete _param;
+  delete vidCache;
+  
+}
+uint8_t ADMVideoResampleFPS::getCoupledConf( CONFcouple **couples)
+{
+  ADM_assert(_param);
+  *couples=new CONFcouple(2);
+
+
+                CSET(newfps);
+                CSET(use_linear);
+                return 1;
+}
+#ifdef ADM_CPU_X86
+static uint64_t low,high;
+static void blendMMX(uint8_t *src, uint8_t *src2, uint8_t *dst, uint8_t alpha, uint8_t beta,uint32_t count)
+{
+uint32_t left=count&amp;3;
+#define EXPAND(x) (x)+((x)&lt;&lt;16)+((x)&lt;&lt;32) +((x)&lt;&lt;48)
+        high=alpha;
+        low=beta;
+        high=EXPAND(high);
+        low=EXPAND(low);
+        count&gt;&gt;=2;
+#ifdef GCC_2_95_X
+         __asm__ __volatile__ (
+                                &quot;movq &quot;Mangle(high)&quot;, %mm0\n&quot;
+                                &quot;movq &quot;Mangle(low)&quot;,  %mm1\n&quot;                                
+                                &quot;pxor %mm7        ,  %mm7\n&quot;
+                                :: );
+#else
+         __asm__ __volatile__ (
+                                &quot;movq &quot;Mangle(high)&quot;, %%mm0\n&quot;
+                                &quot;movq &quot;Mangle(low)&quot;,  %%mm1\n&quot;                                
+                                &quot;pxor %%mm7        ,  %%mm7\n&quot;
+                                :: );
+#endif
+
+        while(count&gt;0)
+        {
+                __asm__ __volatile__ (
+                               
+                                &quot;movd      (%0),  %%mm2\n&quot;
+                                &quot;movd      (%1),  %%mm3\n&quot;                               
+
+                                &quot;punpcklbw %%mm7, %%mm2\n&quot;
+                                &quot;punpcklbw %%mm7, %%mm3\n&quot;
+
+                                &quot;pmullw   %%mm0, %%mm2\n&quot;
+                                &quot;pmullw   %%mm1, %%mm3\n&quot;
+                
+                                &quot;paddw    %%mm3, %%mm2\n&quot;
+
+                                &quot;psrlw    $8,    %%mm2 \n&quot;
+
+                                &quot;packuswb %%mm2,%%mm2\n&quot;
+                                &quot;movd     %%mm2, (%2)\n&quot;
+
+                                :: &quot;r&quot; (src), &quot;r&quot; (src2), &quot;r&quot; (dst) );
+                                
+                src+=4;
+                src2+=4;
+                dst+=4;
+                count--;
+        }
+        __asm__ __volatile__ (
+                                &quot;emms\n&quot;
+                                :: );
+        for(uint32_t i=0;i&lt;left;i++)
+        {
+                dst[i] = ((src[i]*alpha) + (src2[i]*beta))&gt;&gt;8;
+        }
+}
+
+#endif
+
+uint8_t ADMVideoResampleFPS::getFrameNumberNoAlloc(uint32_t frame,
+                                             uint32_t *len,
+                                             ADMImage *data,
+                                             uint32_t *flags)
+{
+  ADMImage *mysrc1=NULL;
+  ADMImage *mysrc2=NULL;
+
+  if(frame&gt;=_info.nb_frames) return 0;
+  // read uncompressed frame
+  
+  // What frame are we seeking ?
+  double f;
+  uint32_t page=_info.width*_info.height;
+  
+  f=frame;
+  f*=_in-&gt;getInfo()-&gt;fps1000;
+  f/=_param-&gt;newfps;
+  
+  if(!_param-&gt;use_linear)
+  {
+      uint32_t nw;
+      
+      nw=(uint32_t)floor(f+0.4);
+      if(nw&gt;_in-&gt;getInfo()-&gt;nb_frames-1)
+        nw=_in-&gt;getInfo()-&gt;nb_frames-1;
+    
+      mysrc1=vidCache-&gt;getImage(nw);
+      if(!mysrc1) return 0;
+      
+      memcpy(YPLANE(data),YPLANE(mysrc1),page);
+      memcpy(UPLANE(data),UPLANE(mysrc1),page&gt;&gt;2);
+      memcpy(VPLANE(data),VPLANE(mysrc1),page&gt;&gt;2);
+    
+      vidCache-&gt;unlockAll();
+      
+      return 1;
+  }
+  /* With linear blending */
+  uint32_t nw;
+  uint8_t lowweight;
+  uint8_t highweight;
+  
+  double diff;
+  
+  nw=(uint32_t)floor(f);
+  diff=f-floor(f);
+  highweight = (uint8_t)floor(diff*256);
+  lowweight = 256 - highweight;
+
+  if(nw&gt;=_in-&gt;getInfo()-&gt;nb_frames-1)
+    {
+      printf(&quot;[ResampleFps] In %u Out %u\n&quot;,frame,nw);
+      nw=_in-&gt;getInfo()-&gt;nb_frames-1;
+      highweight=0;
+    }
+  //printf(&quot;New:%lu old:%lu\n&quot;,frame,nw);
+
+  if(highweight == 0)
+    {
+      mysrc1=vidCache-&gt;getImage(nw);  
+      if(!mysrc1) return 0;
+      
+      memcpy(YPLANE(data),YPLANE(mysrc1),page);
+      memcpy(UPLANE(data),UPLANE(mysrc1),page&gt;&gt;2);
+      memcpy(VPLANE(data),VPLANE(mysrc1),page&gt;&gt;2);
+      
+      vidCache-&gt;unlockAll();
+    }
+  else
+    {
+      mysrc1=vidCache-&gt;getImage(nw);
+      mysrc2=vidCache-&gt;getImage(nw+1);
+      if(!mysrc1 || !mysrc2) return 0;
+      
+      uint8_t *out, *in1, *in2;
+      uint32_t count;
+      uint32_t idx;
+      
+      out = YPLANE(data);
+      in1 = YPLANE(mysrc1);
+      in2 = YPLANE(mysrc2);
+        
+      count = page;
+
+#ifdef ADM_CPU_X86
+        if(CpuCaps::hasMMX())
+                blendMMX(in1,in2,out,lowweight,highweight,(count*3)&gt;&gt;1);
+        else
+#endif
+      {
+      for(idx = 0; idx &lt; count; ++idx)
+	out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))&gt;&gt;8;
+
+      out = UPLANE(data);
+      in1 = UPLANE(mysrc1);
+      in2 = UPLANE(mysrc2);
+      count = page&gt;&gt;2;
+
+      for(idx = 0; idx &lt; count; ++idx)
+        out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))&gt;&gt;8;      
+
+
+      out = VPLANE(data);
+      in1 = VPLANE(mysrc1);
+      in2 = VPLANE(mysrc2);
+      count = page&gt;&gt;2;
+
+      for(idx = 0; idx &lt; count; ++idx)
+	out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))&gt;&gt;8;
+      }
+
+      vidCache-&gt;unlockAll();
+    }
+  return 1;
+ 
+}
+
+
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ResampleFps/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ResampleFps/CMakeLists.txt	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/ResampleFps/CMakeLists.txt	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_resampleFps_SRCS ADM_vidResampleFPS.cpp)
+
+ADD_LIBRARY(ADM_vf_resampleFps SHARED ${ADM_vf_resampleFps_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_resampleFps)
+INSTALL_VIDEOFILTER(ADM_vf_resampleFps)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Reverse/ADM_vidReverse.cpp (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidReverse.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidReverse.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Reverse/ADM_vidReverse.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,109 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+
+
+class AVDM_Reverse : public AVDMGenericVideoStream
+{
+  VideoCache      *vidCache;
+  public:
+                                
+    AVDM_Reverse(AVDMGenericVideoStream *in,CONFcouple *couples);    
+    ~AVDM_Reverse(void);
+    uint8_t         getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                          ADMImage *data,uint32_t *flags);
+        
+    char            *printConf( void );
+    uint8_t         configure(AVDMGenericVideoStream *in);
+    uint8_t         getCoupledConf( CONFcouple **couples);
+};
+
+static FILTER_PARAM reverseParam={0,{&quot;&quot;}};
+
+BUILD_CREATE(reverse_create,AVDM_Reverse);
+SCRIPT_CREATE(reverse_script,AVDM_Reverse,reverseParam);
+
+VF_DEFINE_FILTER(AVDM_Reverse,
+                &quot;reverse&quot;,
+                QT_TR_NOOP(&quot;Reverse&quot;),
+                1,
+                reverse_create,
+                reverse_script,
+                VF_TRANSFORM,
+                QT_TR_NOOP(&quot;Play video backward.&quot;));
+/*************************************/
+
+uint8_t AVDM_Reverse::configure(AVDMGenericVideoStream *in)
+{
+  _in=in;
+  return 1;
+        
+}
+
+char *AVDM_Reverse::printConf( void )
+{
+  static char buf[50];
+
+        //ADM_assert(_param);
+  sprintf((char *)buf,&quot; Reverse&quot;);
+  return buf;
+}
+
+
+AVDM_Reverse::AVDM_Reverse(AVDMGenericVideoStream *in,CONFcouple *couples)
+
+{
+                
+  int count = 0;
+  char buf[80];
+  unsigned int *p;
+
+  _in=in;         
+  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+  _info.encoding=1;
+  vidCache=new VideoCache(18,in);
+}
+//________________________________________________________
+uint8_t AVDM_Reverse::getCoupledConf( CONFcouple **couples)
+{
+  *couples=NULL;
+  return 1;
+}
+//________________________________________________________
+AVDM_Reverse::~AVDM_Reverse(void)
+{
+                
+  if(vidCache) delete vidCache;                
+  vidCache=NULL;   
+}
+uint8_t AVDM_Reverse::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                     ADMImage *data,uint32_t *flags)
+{
+
+  uint32_t num_frames,tgt;
+  ADMImage *src;
+
+  num_frames=_in-&gt;getInfo()-&gt;nb_frames;   // ??
+  if(frame&gt;=num_frames) return 0;
+  
+  tgt=num_frames-frame-1;
+
+  src=vidCache-&gt;getImage(tgt);
+  if(!src) return 0;
+  data-&gt;duplicate(src);
+
+  vidCache-&gt;unlockAll();
+  return 1;
+}
+//EOF
+
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Reverse/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Reverse/CMakeLists.txt	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Reverse/CMakeLists.txt	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_reverse_SRCS ADM_vidReverse.cpp)
+
+ADD_LIBRARY(ADM_vf_reverse SHARED ${ADM_vf_reverse_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_reverse)
+INSTALL_VIDEOFILTER(ADM_vf_reverse)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/TemporalCleaner/ADM_vidVlad.cpp (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/TemporalCleaner/ADM_vidVlad.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,526 @@
+/***************************************************************************
+                          ADM_vidVlad.cpp  -  description
+                             -------------------
+    begin                : Fri Jan 3 2003
+    copyright            : (C) 2003 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+    
+    Port from Vlad59 / Jim Casaburi TemporalCleaner from avisynth YV12
+    
+    Luma only
+   	Patch by Daniel Glockner 
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;DIA_factory.h&quot;
+
+#include &quot;ADM_vidVlad.h&quot;
+
+#include &quot;DIA_factory.h&quot;
+
+#ifdef ADM_CPU_X86_64
+#define COUNTER long int
+#else
+#define COUNTER int
+#endif
+
+#ifdef ADM_CPU_X86
+static void ProcessCPlane_mmxe(unsigned char *source,
+				   unsigned char *prev,
+				   unsigned char* dest,
+				   unsigned char* mask,
+				   int width, int height,
+				   uint64_t  threshold);
+static void ProcessYPlane_mmxe( unsigned char *source,
+				    unsigned char *prev,
+				    unsigned char* dest,
+				    unsigned char* mask,
+				    long  int width, long int height,
+				    uint64_t  threshold);
+#endif
+static void ProcessCPlane_C(unsigned char *source,
+				   unsigned char *prev,
+				   unsigned char* dest,
+				   unsigned char* mask,
+				   int width, int height,
+				   uint64_t  threshold);
+static void ProcessYPlane_C( unsigned char *source,
+				    unsigned char *prev,
+				    unsigned char* dest,
+				    unsigned char* mask,
+				    long  int width, long int height,
+				    uint64_t  threshold);
+
+#define EXPAND(x) { x=x+(x&lt;&lt;8)+(x&lt;&lt;16)+(x&lt;&lt;24)+(x&lt;&lt;32)+(x&lt;&lt;40) \
+										+(x&lt;&lt;48)+(x&lt;&lt;56);}
+static FILTER_PARAM vladParam={2,{&quot;ythresholdMask&quot;,&quot;cthresholdMask&quot;}};
+
+
+SCRIPT_CREATE(vladsmooth_script,AVDMVideoVlad,vladParam);
+BUILD_CREATE(vladsmooth_create,AVDMVideoVlad);
+//*************************************
+VF_DEFINE_FILTER(AVDMVideoVlad,
+                &quot;temporalcleaner&quot;,
+                QT_TR_NOOP(&quot;Temporal Cleaner&quot;),
+                1,
+                vladsmooth_create,
+                vladsmooth_script,
+                VF_NOISE,
+                QT_TR_NOOP(&quot;Vlad59's Avisynth port of Jim Casaburi's denoiser.&quot;));
+//*************************************
+
+char *AVDMVideoVlad::printConf(void)
+{
+	static char buf[50];
+ 	
+	sprintf((char *)buf,&quot; Temporal Cleaner : Y: %02lu / c: %02lu&quot;,_param-&gt;ythresholdMask,
+				_param-&gt;cthresholdMask	);
+        return buf;
+}
+
+
+uint8_t AVDMVideoVlad::configure( AVDMGenericVideoStream *instream)
+{
+UNUSED_ARG(instream);
+int i,j;
+
+   diaElemUInteger luma(&amp;(_param-&gt;ythresholdMask),QT_TR_NOOP(&quot;_Luma temporal threshold:&quot;),0,255);
+   diaElemUInteger chroma(&amp;(_param-&gt;cthresholdMask),QT_TR_NOOP(&quot;Ch_roma temporal threshold:&quot;),0,255);
+    
+    diaElem *elems[]={&amp;luma,&amp;chroma};
+  
+    if(diaFactoryRun(QT_TR_NOOP(&quot;Temporal Cleaner&quot;),sizeof(elems)/sizeof(diaElem *),elems))
+    {
+      ythresholdMask = (uint64_t)_param-&gt;ythresholdMask;
+      cthresholdMask = (uint64_t)_param-&gt;cthresholdMask;	   
+
+      EXPAND(	ythresholdMask);
+      EXPAND(	cthresholdMask);	
+      return 1;
+    }
+    return 0;
+}
+AVDMVideoVlad::AVDMVideoVlad(  AVDMGenericVideoStream *in,CONFcouple *couples)
+		
+
+{
+	_in=in;
+	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
+	num_frame=0xFFFF0000;
+	if(couples)
+	{
+		_param=NEW(VLAD_PARAM);
+		GET(ythresholdMask);
+		GET(cthresholdMask);
+	}
+	else
+	{
+		_param=NEW(VLAD_PARAM);
+		ADM_assert(_param);
+	  _param-&gt;ythresholdMask=5;
+ 	  _param-&gt;cthresholdMask=0;
+   }
+    	_mask=new uint8_t[_info.width*_info.height/4];
+  	memset(_mask,0,	_info.width*_info.height/4);
+	  
+	   ythresholdMask=0;
+	   ythresholdMask = (uint64_t)_param-&gt;ythresholdMask;
+	   cthresholdMask = (uint64_t)_param-&gt;cthresholdMask;	   
+
+		EXPAND(	ythresholdMask);
+		EXPAND(	cthresholdMask);
+	vidCache=new VideoCache(2,in);
+
+	ProcessYPlane = ProcessYPlane_C;
+	ProcessCPlane = ProcessCPlane_C;
+#ifdef ADM_CPU_X86
+#if 0
+// Check
+	if(CpuCaps::hasMMXEXT() &amp;&amp; (_info.width&amp;7) == 0)
+	{
+		ProcessYPlane = ProcessYPlane_mmxe;
+		ProcessCPlane = ProcessCPlane_mmxe;
+	}
+#endif	
+#endif
+}
+
+
+uint8_t	AVDMVideoVlad::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(2);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+	CSET(ythresholdMask);
+	CSET(cthresholdMask);
+	return 1;
+
+}
+AVDMVideoVlad::~AVDMVideoVlad()
+{
+		delete [] _mask;
+		DELETE(_param);
+		delete vidCache;
+}  									
+
+void ProcessYPlane_C( unsigned char *source,
+				    unsigned char *prev,
+				    unsigned char* dest,
+				    unsigned char* mask, 
+				    long  int width, long int height,
+				    uint64_t  threshold)
+{
+	int thp=threshold&amp;0xff;
+	int thn=-thp;
+	
+	width &gt;&gt;= 1;
+
+	for (int y = height &gt;&gt; 1; --y &gt;= 0;)
+	{
+		int x2 = -width;
+		int x = x2*2;
+
+		source += 4*width;
+		prev += 4*width;
+		dest += 4*width;
+		mask += width;
+
+		do {
+			int yc,yp;
+			int m = 0;
+			yc=source[x*2];
+			yp=prev[x*2];
+			if(thn&lt;=yc-yp &amp;&amp; yc-yp&lt;=thp) {
+				yc=(yc+yp+1)&gt;&gt;1;
+				m=1;
+			}
+			source[x*2]=dest[x*2]=yc;
+
+			yc=source[x*2+1];
+			yp=prev[x*2+1];
+			if(thn&lt;=yc-yp &amp;&amp; yc-yp&lt;=thp) {
+				yc=(yc+yp+1)&gt;&gt;1;
+				m++;
+			}
+			source[x*2+1]=dest[x*2+1]=yc;
+
+			x++;
+
+			yc=source[x2*2];
+			yp=prev[x2*2];
+			if(thn&lt;=yc-yp &amp;&amp; yc-yp&lt;=thp) {
+				yc=(yc+yp+1)&gt;&gt;1;
+				m++;
+			}
+			source[x2*2]=dest[x2*2]=yc;
+
+			yc=source[x2*2+1];
+			yp=prev[x2*2+1];
+			if(thn&lt;=yc-yp &amp;&amp; yc-yp&lt;=thp) {
+			  yc=(yc+yp+1)&gt;&gt;1;
+			  m++;
+			}
+			source[x2*2+1]=dest[x2*2+1]=yc;
+
+			mask[x2]=m;
+		} while(++x2 &lt; 0);
+	}
+}
+
+void ProcessCPlane_C( unsigned char *source,
+				    unsigned char *prev,
+				    unsigned char* dest,
+				    unsigned char* mask, 
+				    int width, int height,
+				    uint64_t  threshold)
+{
+	int thp = threshold&amp;0xff;
+	int thn = -thp;
+	long int i = width*height;
+	
+	source += i;
+	prev += i;
+	dest += i;
+	mask += i;
+	i = -i;
+	
+	do {
+		int cc,cp;
+		cc=source[i];
+		cp=prev[i];
+		if(thn&lt;=cc-cp &amp;&amp; cc-cp&lt;=thp &amp;&amp; mask[i]&gt;3) {
+			cc=(cc+cp+1)&gt;&gt;1;
+		}
+		source[i]=dest[i]=cc;
+	} while(++i &lt; 0);
+}
+
+#ifdef ADM_CPU_X86
+void ProcessYPlane_mmxe( unsigned char *source,
+				    unsigned char *prev,
+				    unsigned char* dest,
+				    unsigned char* mask, 
+				    long  int width, long int height,
+				    uint64_t  threshold)
+{
+	COUNTER tmp,tmp2;
+	long int  h2, w8;
+
+	w8 = -(width &gt;&gt; 3);
+	width &gt;&gt;= 1;
+
+__asm__ __volatile__(
+			&quot;movq (%0),%%mm6 \n\t&quot;
+			:
+			: &quot;r&quot;(&amp;threshold)
+		);
+	
+	for (h2 = height &gt;&gt; 1; --h2 &gt;= 0;)
+	{
+		source += 4*width;
+		prev += 4*width;
+		dest += 4*width;
+		mask += width;
+
+#define REG_source &quot;%2&quot;
+#define REG_dest &quot;%3&quot;
+#define REG_prev &quot;%4&quot;
+#define REG_mask &quot;%5&quot;
+#define REG_counter &quot;%0&quot;
+#define REG_counter2 &quot;%1&quot;
+	  
+__asm__ __volatile__(
+&quot;prefetchnta (&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;prefetchnta (&quot;REG_prev&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;.p2align 4\n\t&quot;
+&quot;pxor %%mm7,%%mm7\n\t&quot;
+&quot;HLine%=:  \n\t&quot;
+
+&quot;prefetchnta (&quot;REG_source&quot;,&quot;REG_counter2&quot;,8) \n\t&quot;
+&quot;prefetchnta (&quot;REG_prev&quot;,&quot;REG_counter2&quot;,8) \n\t&quot;
+
+&quot;movq (&quot;REG_source&quot;,&quot;REG_counter&quot;,8),%%mm0 \n\t&quot;   // mm0 &lt;- lsource+(size/8)*8
+&quot;movq (&quot;REG_prev&quot;,&quot;REG_counter&quot;,8),%%mm1 \n\t&quot;     // mm1 &lt;- lprev+(size/8)*8
+&quot;movq %%mm0,%%mm2 \n\t&quot;               // mm2 &lt;- mm0  source
+&quot;movq %%mm1,%%mm3 \n\t&quot;               // mm3 &lt;-mm1   oold
+&quot;psubusb %%mm1,%%mm0 \n\t&quot;            // mm0=mm0-mm1
+&quot;psubusb %%mm2,%%mm1 \n\t&quot;            // mm1=mm1-mm2
+&quot;por %%mm1,%%mm0 \n\t&quot;                // mm0=mm0 or mm1
+&quot;pavgb %%mm2,%%mm3 \n\t&quot;              // mm3= 'mm2+mm3&quot;/2
+&quot; \n\t&quot;                               // mm0=mm6-mm0 diff to threshold
+&quot;psubusb %%mm6,%%mm0 \n\t&quot;  // &gt;0 ?
+&quot;pcmpeqb %%mm7,%%mm0 \n\t&quot;
+&quot; \n\t&quot;
+&quot;movq %%mm0,%%mm4 \n\t&quot;               // masked diff &gt;m4
+&quot; \n\t&quot;
+&quot;pand %%mm0,%%mm3 \n\t&quot;               // mm0=old and mask diff
+&quot;pandn %%mm2,%%mm0 \n\t&quot;              // mm1= source and invert diff
+&quot;por %%mm3,%%mm0 \n\t&quot;                // m0 = mix
+&quot;movq %%mm0,(&quot;REG_dest&quot;,&quot;REG_counter&quot;,8) \n\t&quot;   // store to des+ecx*8
+&quot;movq %%mm0,(&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot; // store to mask+ecx*8
+
+&quot;movq (&quot;REG_source&quot;,&quot;REG_counter2&quot;,8),%%mm0 \n\t&quot;  // mm0 &lt;- lsource+(size/8)*8
+&quot;movq (&quot;REG_prev&quot;,&quot;REG_counter2&quot;,8),%%mm1 \n\t&quot;    // mm1 &lt;- lprev+(size/8)*8
+
+&quot;prefetchnta 8(&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;prefetchnta 8(&quot;REG_prev&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;add $1,&quot;REG_counter&quot; \n\t&quot;
+
+&quot;movq %%mm0,%%mm2 \n\t&quot;               // mm2 &lt;- mm0  source
+&quot;movq %%mm1,%%mm3 \n\t&quot;               // mm3 &lt;- mm1  oold
+&quot;psubusb %%mm1,%%mm0 \n\t&quot;            // mm0=mm0-mm1
+&quot;psubusb %%mm2,%%mm1 \n\t&quot;            // mm1=mm1-mm2
+&quot;por %%mm1,%%mm0 \n\t&quot;                // mm0=mm0 or mm1
+&quot;pavgb %%mm2,%%mm3 \n\t&quot;              // mm3= 'mm2+mm3&quot;/2
+&quot; \n\t&quot;                               // mm0=mm6-mm0 diff to threshold
+&quot;psubusb %%mm6,%%mm0 \n\t&quot;  // &gt;0 ?
+&quot;pcmpeqb %%mm7,%%mm0 \n\t&quot;
+&quot; \n\t&quot;
+
+&quot;pand %%mm0,%%mm4 \n\t&quot;
+&quot;movq %%mm4,%%mm1 \n\t&quot;               // masked diff -&gt; mm1
+&quot;psrlw $8,%%mm4 \n\t&quot;                 // shift
+&quot;pand %%mm4,%%mm1 \n\t&quot;               // if right &amp; left triggered
+&quot;packuswb %%mm1,%%mm1 \n\t&quot;           // packed to 4 bytes
+&quot;movd %%mm1,(&quot;REG_mask&quot;,&quot;REG_counter2&quot;,4) \n\t&quot;     // store mask m4-&gt;mask+ecx*4
+
+&quot; \n\t&quot;
+&quot;pand %%mm0,%%mm3 \n\t&quot;               // mm3 = old and mask diff
+&quot;pandn %%mm2,%%mm0 \n\t&quot;              // mm0 = source and invert diff
+&quot;por %%mm3,%%mm0 \n\t&quot;                // mm0 = mix
+&quot;movq %%mm0,(&quot;REG_dest&quot;,&quot;REG_counter2&quot;,8) \n\t&quot;   // store to des+ecx*8
+&quot;movq %%mm0,(&quot;REG_source&quot;,&quot;REG_counter2&quot;,8) \n\t&quot; // store to mask+ecx*8
+
+
+&quot;add $1,&quot;REG_counter2&quot; \n\t&quot;          // add 1 to ecv
+&quot;jnz HLine%=&quot;                         // while !=0
+ : &quot;=r&quot;(tmp), &quot;=r&quot;(tmp2)
+ : &quot;r&quot;(source), &quot;r&quot;(dest), &quot;r&quot;(prev),
+   &quot;r&quot;(mask)
+   , &quot;0&quot;(2*w8), &quot;1&quot;(w8)
+ );
+
+	}
+ __asm__ __volatile__(&quot;emms \n\t&quot;);
+}
+
+
+//#pragma -O0
+
+void ProcessCPlane_mmxe(unsigned char *source,
+				   unsigned char *prev, 
+				   unsigned char* dest, 
+				   unsigned char* mask, 
+				   int width, int height,
+				   uint64_t  threshold)
+{
+	long int w8;
+	COUNTER tmp;
+
+	w8 = width*height;
+	source += w8;
+	dest += w8;
+	prev += w8;
+	mask += w8;
+	w8 = -(w8&gt;&gt;3);
+
+__asm__ __volatile__(
+			&quot;movq (%0),%%mm6 \n\t&quot;
+			:
+			: &quot;r&quot;(&amp;threshold)
+		);
+	
+__asm__ __volatile__ (
+&quot;prefetchnta (&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;prefetchnta (&quot;REG_prev&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;prefetchnta (&quot;REG_mask&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;.p2align 4\n\t&quot;
+&quot;pxor %%mm7,%%mm7\n\t&quot;
+&quot;Lfoo%=:  \n\t&quot;
+&quot;prefetchnta 8(&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;prefetchnta 8(&quot;REG_prev&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;prefetchnta 8(&quot;REG_mask&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;movq (&quot;REG_source&quot;,&quot;REG_counter&quot;,8),%%mm0 \n\t&quot;
+&quot;movq (&quot;REG_prev&quot;,&quot;REG_counter&quot;,8),%%mm1 \n\t&quot;
+&quot;movq %%mm0,%%mm2 \n\t&quot;
+&quot;movq %%mm1,%%mm3 \n\t&quot;
+&quot;psubusb %%mm1,%%mm0 \n\t&quot;
+&quot;psubusb %%mm2,%%mm1 \n\t&quot;
+&quot;por %%mm1,%%mm0 \n\t&quot;
+&quot;pavgb %%mm2,%%mm3 \n\t&quot;
+&quot; \n\t&quot;
+&quot;psubusb %%mm6,%%mm0 \n\t&quot;
+&quot;pcmpeqb %%mm7,%%mm0 \n\t&quot;
+&quot; \n\t&quot;
+&quot;pand (&quot;REG_mask&quot;,&quot;REG_counter&quot;,8),%%mm0 \n\t&quot;
+&quot; \n\t&quot;
+&quot;pand %%mm0,%%mm3 \n\t&quot;
+&quot;pandn %%mm2,%%mm0 \n\t&quot;
+&quot;por %%mm3,%%mm0 \n\t&quot;
+&quot;movq %%mm0,(&quot;REG_dest&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;movq %%mm0,(&quot;REG_source&quot;,&quot;REG_counter&quot;,8) \n\t&quot;
+&quot;add $1,&quot;REG_counter&quot; \n\t&quot;
+&quot;jnz Lfoo%= \n\t&quot;
+ : &quot;=r&quot;(tmp)
+ : &quot;0&quot;(w8), &quot;r&quot;(source), &quot;r&quot;(dest), &quot;r&quot;(prev),
+   &quot;r&quot;(mask)
+ 
+ );
+	__asm__ __volatile__(&quot;emms \n\t&quot;);
+}
+#endif
+
+//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
+//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
+//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
+//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
+uint8_t AVDMVideoVlad::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+	
+	uint32_t page=_info.width*_info.height;
+	ADMImage *cur,*prev;
+	
+		if(frame&gt;(_info.nb_frames-1)) return 0;
+		
+		*len=(page*3)&gt;&gt;1;
+		
+		if(frame)
+		{
+		 	prev=vidCache-&gt;getImage(frame-1);
+			if(!prev)
+				return 0;
+		}
+		
+		cur=vidCache-&gt;getImage(frame);
+		if(!cur)
+		{
+			vidCache-&gt;unlockAll();
+			return 0;
+		}
+		data-&gt;copyInfo(cur);
+		if(!frame)
+		{
+			
+			data-&gt;duplicate(cur);
+			vidCache-&gt;unlockAll();
+			return 1  ;
+		}
+		
+		
+			  
+		ProcessYPlane (YPLANE(cur),
+				YPLANE(prev),     	
+				YPLANE(data), 
+				_mask, 
+				_info.width, 
+		       		_info.height,
+				ythresholdMask);
+		if (0==_param-&gt;cthresholdMask)
+		{
+			//memcpy(data-&gt;data+page,_uncompressed-&gt;data+page,page&gt;&gt;1);
+			memcpy(UPLANE(data),UPLANE(cur),page&gt;&gt;2);
+			memcpy(VPLANE(data),VPLANE(cur),page&gt;&gt;2);
+		}
+		else
+		{
+			
+				ProcessCPlane (UPLANE(cur),
+							UPLANE(prev),     	
+							UPLANE(data), 
+							_mask, 
+							_info.width&gt;&gt;1, 
+							_info.height&gt;&gt;1,
+							cthresholdMask);       
+				
+			
+				ProcessCPlane (VPLANE(cur),
+							VPLANE(prev),     	
+							VPLANE(data), 
+							_mask, 
+							_info.width&gt;&gt;1, 
+							_info.height&gt;&gt;1,
+							cthresholdMask);       				
+			
+			}
+		
+		vidCache-&gt;unlockAll();
+		return 1;
+
+}
+
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/TemporalCleaner/ADM_vidVlad.h (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVlad.h	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/TemporalCleaner/ADM_vidVlad.h	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,61 @@
+/***************************************************************************
+                          ADM_vidVlad.h  -  description
+                             -------------------
+    begin                : Fri Jan 3 2003
+    copyright            : (C) 2003 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef __VLAD__
+#define __VLAD__   
+typedef struct VLAD_PARAM
+{
+	uint32_t ythresholdMask;
+	uint32_t cthresholdMask;
+}VLAD_PARAM;
+ class  AVDMVideoVlad:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+        			VLAD_PARAM	*_param;
+        			virtual char 	*printConf(void);
+	      			uint8_t		*_mask;
+	      			VideoCache	*vidCache;
+	      			
+        			uint64_t		ythresholdMask;
+				uint64_t 		cthresholdMask;
+				uint32_t 		num_frame;
+				void (*ProcessCPlane)(unsigned char *source,
+				                      unsigned char *prev,
+				                      unsigned char* dest,
+				                      unsigned char* mask,
+				                      int width, int height,
+				                      uint64_t  threshold);
+				void (*ProcessYPlane)(unsigned char *source,
+				                      unsigned char *prev,
+				                      unsigned char* dest,
+				                      unsigned char* mask,
+				                      long int width,
+				                      long int height,
+				                      uint64_t  threshold);
+ public:
+
+
+						AVDMVideoVlad(  AVDMGenericVideoStream *in,CONFcouple *setup);
+  					 	~AVDMVideoVlad();
+		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          							ADMImage *data,uint32_t *flags);
+
+			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
+			virtual uint8_t	getCoupledConf( CONFcouple **couples)		;
+ }     ;
+#endif

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/TemporalCleaner/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/TemporalCleaner/CMakeLists.txt	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/TemporalCleaner/CMakeLists.txt	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_vlad_SRCS ADM_vidVlad.cpp)
+
+ADD_LIBRARY(ADM_vf_vlad SHARED ${ADM_vf_vlad_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_vlad)
+INSTALL_VIDEOFILTER(ADM_vf_vlad)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Yadif/ADM_vidYadif.cpp (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif.cpp	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Yadif/ADM_vidYadif.cpp	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,423 @@
+/*
+	Yadif C-plugin for Avisynth 2.5 - Yet Another DeInterlacing Filter
+	Copyright (C)2007 Alexander G. Balakhnin aka Fizick  <A HREF="http://avisynth.org.ru">http://avisynth.org.ru</A>
+    Port of YADIF filter from MPlayer
+	Copyright (C) 2006 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+    Avisynth_C plugin
+	Assembler optimized for GNU C compiler
+
+*/
+/*
+  Ported to avidemux by mean
+  Same license as original (?GPL)
+*/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;DIA_factory.h&quot;
+//************************************************
+#define MIN(a,b) ((a) &gt; (b) ? (b) : (a))
+#define MAX(a,b) ((a) &lt; (b) ? (b) : (a))
+#define ABS(a) ((a) &gt; 0 ? (a) : (-(a)))
+
+#define MIN3(a,b,c) MIN(MIN(a,b),c)
+#define MAX3(a,b,c) MAX(MAX(a,b),c)
+
+//===========================================================================//
+#ifdef ADM_CPU_X86
+extern &quot;C&quot;
+{
+void filter_line_mmx2(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity);
+}
+#endif
+//
+typedef struct YADIF_PARAM
+{
+    uint32_t mode;
+    uint32_t order;
+}YADIF_PARAM;
+
+class  ADMVideoYadif:public AVDMGenericVideoStream
+{
+
+ protected:
+  virtual char                 *printConf(void);
+  YADIF_PARAM                  *_param;
+   VideoCache                  *vidCache;
+  void                         updateInfo(void);
+
+ public:
+                  ADMVideoYadif(AVDMGenericVideoStream *in, CONFcouple *setup);
+  virtual         ~ADMVideoYadif();
+  virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
+  virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data,uint32_t *flags);
+  virtual uint8_t	getCoupledConf( CONFcouple **couples)				;
+ }     ;
+
+static FILTER_PARAM yadifParam={2,{&quot;mode&quot;,&quot;order&quot;}};
+//************************************
+
+SCRIPT_CREATE(yadif_script,ADMVideoYadif,yadifParam);
+BUILD_CREATE(yadif_create,ADMVideoYadif);
+VF_DEFINE_FILTER(ADMVideoChromaV,
+                &quot;YADIF&quot;,
+                QT_TR_NOOP(&quot;yadif&quot;),
+                1,
+                yadif_create,
+                yadif_script,
+                VF_INTERLACING,
+                QT_TR_NOOP(&quot;Yet Another DeInterlacer. Ported from MPlayer.&quot;));
+
+//************************************
+//
+static void filter_plane(int mode, uint8_t *dst, int dst_stride, const uint8_t *prev0, const uint8_t *cur0, const uint8_t *next0, int refs, int w, int h, int parity, int tff, int mmx);
+
+
+/*   Hook to build it as a dll */
+extern &quot;C&quot;
+{
+SCRIPT_CREATE(FILTER_create_fromscript,ADMVideoYadif,yadifParam);
+BUILD_CREATE(FILTER_create,ADMVideoYadif);
+char *FILTER_getName(void)
+{
+	return &quot;DynYadif&quot;;
+}
+char *FILTER_getDesc(void)
+{
+	return &quot;YADIF&quot;;
+}
+uint32_t FILTER_getVersion(void)
+{
+  return 1; 
+}
+uint32_t FILTER_getAPIVersion(void)
+{
+  return ADM_FILTER_API_VERSION; 
+}
+}
+//***************************************************
+//***************************************************
+char *ADMVideoYadif::printConf( void )
+{
+  static char buf[50];
+ 	
+  sprintf((char *)buf,&quot; Yadif : mode %u order %d&quot;,_param-&gt;mode, _param-&gt;order);
+  return buf;
+}
+
+ADMVideoYadif::ADMVideoYadif(AVDMGenericVideoStream *in, CONFcouple *couples)
+{
+  _in=in;		
+
+  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info)); 
+  _info.encoding=1;
+
+ // _uncompressed=new uint8_t [3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height];
+ 
+
+  if(couples)
+  {
+   	 _param=new (YADIF_PARAM);
+	GET(mode);
+        GET(order);
+  }
+  else
+  {
+    _param = new ( YADIF_PARAM);
+    _param-&gt;mode=0;
+    _param-&gt;order=1;
+  }
+  _uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+  ADM_assert(_uncompressed);    	  	
+  vidCache = new VideoCache (10, in);
+  updateInfo();
+}
+
+void ADMVideoYadif::updateInfo(void)
+{
+   memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info)); 
+  if(_param-&gt;mode &amp;1 ) // Bob
+  {
+    _info.nb_frames*=2;
+    _info.fps1000*=2;
+  }
+}
+
+uint8_t ADMVideoYadif::configure( AVDMGenericVideoStream *instream) 
+{
+  _in= instream;
+     diaMenuEntry tMode[]={
+                             {0,      QT_TR_NOOP(&quot;Temporal &amp; spatial check&quot;),NULL},
+                             {1,   QT_TR_NOOP(&quot;Bob, temporal &amp; spatial check&quot;),NULL},
+                             {2,      QT_TR_NOOP(&quot;Skip spatial temporal check&quot;),NULL},
+                             {3,  QT_TR_NOOP(&quot;Bob, skip spatial temporal check&quot;),NULL}
+          };
+     diaMenuEntry tOrder[]={
+                             {0,      QT_TR_NOOP(&quot;Bottom field first&quot;),NULL},
+                             {1,   QT_TR_NOOP(&quot;Top field first&quot;),NULL}
+          };
+  
+     diaElemMenu mMode(&amp;(_param-&gt;mode),   QT_TR_NOOP(&quot;_Mode:&quot;), 4,tMode);
+     diaElemMenu morder(&amp;(_param-&gt;order),   QT_TR_NOOP(&quot;_Order:&quot;), 2,tOrder);
+     
+     diaElem *elems[]={&amp;mMode,&amp;morder};
+     
+     if(diaFactoryRun(QT_TR_NOOP(&quot;yadif&quot;),sizeof(elems)/sizeof(diaElem *),elems))
+     {
+        updateInfo();
+        return 1;
+     }
+     return 0;
+}
+
+uint8_t	ADMVideoYadif::getCoupledConf( CONFcouple **couples)
+{
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+
+          ADM_assert(_param);
+          *couples=new CONFcouple(2);
+
+          CSET(mode);
+          CSET(order);
+          return 1;
+
+}
+
+
+ADMVideoYadif::~ADMVideoYadif()
+{
+        delete  _uncompressed;
+        _uncompressed=NULL;
+       
+        delete vidCache;
+        vidCache = NULL;
+        
+        delete _param;
+        _param=NULL;
+}
+
+uint8_t ADMVideoYadif::getFrameNumberNoAlloc(uint32_t frame,
+                                              uint32_t *len,
+                                              ADMImage *data,
+                                              uint32_t *flags)
+{
+        int mode;
+        int parity;
+        int tff;
+        int iplane;
+        int cpu;
+        int n;
+        ADMImage *src, *dst, * prev, *next;
+
+    
+        mode = _param-&gt;mode;
+
+        if (mode &amp; 1) 
+                n = (frame&gt;&gt;1); // bob
+        else
+                n = frame;
+
+        src = vidCache-&gt;getImage(n);
+  // Request frame 'n' from the child (source) clip.
+
+        if (n&gt;0)
+                prev =  vidCache-&gt;getImage( n-1); // get previous frame
+        else
+                prev= vidCache-&gt;getImage(0); // get very first frame
+
+        if (n&lt; _in-&gt;getInfo()-&gt;nb_frames-1)
+                next = vidCache-&gt;getImage( n+1); // get next frame
+        else
+                next = vidCache-&gt;getImage( _in-&gt;getInfo()-&gt;nb_frames-1); // get last frame
+
+        dst = data;
+        
+        if(!prev || !src || !next)
+        {
+            printf(&quot;Failed to read frame for frame %u\n&quot;,frame);
+            vidCache-&gt;unlockAll();
+            return 0;
+        }
+        
+  // Construct a frame based on the information of the current frame
+  // contained in the &quot;vi&quot; struct.
+#if 0 //MEANX
+        if (_params-&gt;order == -1)
+//		tff = avs_is_tff(&amp;p-&gt;vi) == 0 ? 0 : 1; // 0 or 1
+                tff = avs_get_parity(p-&gt;child, n) ? 1 : 0; // 0 or 1
+        else
+#endif
+                tff = _param-&gt;order;	
+        
+        parity = (mode &amp; 1) ? (frame &amp; 1) ^ (1^tff) : (tff ^ 1);  // 0 or 1
+
+      //MEANX  cpu = avs_get_cpu_flags(p-&gt;env);
+
+        for (iplane = 0; iplane&lt;3; iplane++)
+        {
+                ADM_PLANE plane = (iplane==0) ? PLANAR_Y : (iplane==1) ? PLANAR_U : PLANAR_V;
+
+                const unsigned char* srcp = src-&gt;GetWritePtr(plane);
+          // Request a Read pointer from the current source frame
+
+                const unsigned char* prevp0 = prev-&gt;GetWritePtr( plane);
+                unsigned char* prevp = (unsigned char*) prevp0; // with same pitch
+          // Request a Read pointer from the prev source frame.
+
+                const unsigned char* nextp0 = next-&gt;GetWritePtr( plane);
+                unsigned char* nextp = (unsigned char*) nextp0; // with same pitch
+          // Request a Read pointer from the next source frame.
+
+                unsigned char* dstp = dst-&gt;GetWritePtr( plane);
+                // Request a Write pointer from the newly created destination image.
+          // You can request a writepointer to images that have just been
+
+                const int dst_pitch = dst-&gt;GetPitch( plane);
+          // Requests pitch (length of a line) of the destination image.
+          // For more information on pitch see: <A HREF="http://www.avisynth.org/index.php?page=WorkingWithImages">http://www.avisynth.org/index.php?page=WorkingWithImages</A>
+                // (short version - pitch is always equal to or greater than width to allow for seriously fast assembly code)
+
+                const int width =dst-&gt;GetPitch( plane);
+          // Requests rowsize (number of used bytes in a line.
+          // See the link above for more information.
+
+                const int height = dst-&gt;GetHeight( plane);
+          // Requests the height of the destination image.
+
+                const int src_pitch = src-&gt;GetPitch(plane);
+                const int prev_pitch = prev-&gt;GetPitch(plane);
+                const int next_pitch = next-&gt;GetPitch(plane);
+
+                // in v.0.1-0.3  all source pitches are  assumed equal (for simplicity)
+                                // consider other (rare) case
+                if (prev_pitch != src_pitch)
+                {
+                    prevp = (unsigned char *)ADM_alloc(height*src_pitch);
+                    int h;
+                    for (h=0; h&lt;0; h++)
+                      memcpy(prevp+h*src_pitch, prevp0+h*prev_pitch, width);
+                }
+                    
+                if (next_pitch != src_pitch)
+                {
+                    nextp = (unsigned char *)ADM_alloc(height*src_pitch);
+                    int h;
+                    for (h=0; h&lt;0; h++)
+                      memcpy(nextp+h*src_pitch, nextp0+h*next_pitch, width);
+                }
+                    
+                filter_plane(mode, dstp, dst_pitch, prevp, srcp, nextp, src_pitch, width, height, parity, tff, 0);
+                if (prev_pitch != src_pitch)
+                        ADM_dealloc(prevp);
+                if (next_pitch != src_pitch)
+                        ADM_dealloc(nextp);
+        }
+       vidCache-&gt;unlockAll();
+      return 1;
+}
+//****************
+
+static void filter_line_c(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity){
+    int x;
+    const uint8_t *prev2= parity ? prev : cur ;
+    const uint8_t *next2= parity ? cur  : next;
+    for(x=0; x&lt;w; x++){
+        int c= cur[-refs];
+        int d= (prev2[0] + next2[0])&gt;&gt;1;
+        int e= cur[+refs];
+        int temporal_diff0= ABS(prev2[0] - next2[0]);
+        int temporal_diff1=( ABS(prev[-refs] - c) + ABS(prev[+refs] - e) )&gt;&gt;1;
+        int temporal_diff2=( ABS(next[-refs] - c) + ABS(next[+refs] - e) )&gt;&gt;1;
+        int diff= MAX3(temporal_diff0&gt;&gt;1, temporal_diff1, temporal_diff2);
+        int spatial_pred= (c+e)&gt;&gt;1;
+        int spatial_score= ABS(cur[-refs-1] - cur[+refs-1]) + ABS(c-e)
+                         + ABS(cur[-refs+1] - cur[+refs+1]) - 1;
+
+#define CHECK(j)\
+    {   int score= ABS(cur[-refs-1+ j] - cur[+refs-1- j])\
+                 + ABS(cur[-refs  + j] - cur[+refs  - j])\
+                 + ABS(cur[-refs+1+ j] - cur[+refs+1- j]);\
+        if(score &lt; spatial_score){\
+            spatial_score= score;\
+            spatial_pred= (cur[-refs  + j] + cur[+refs  - j])&gt;&gt;1;\
+
+        CHECK(-1) CHECK(-2) }} }}
+        CHECK( 1) CHECK( 2) }} }}
+
+        if(mode&lt;2){
+            int b= (prev2[-2*refs] + next2[-2*refs])&gt;&gt;1;
+            int f= (prev2[+2*refs] + next2[+2*refs])&gt;&gt;1;
+#if 0
+            int a= cur[-3*refs];
+            int g= cur[+3*refs];
+            int max= MAX3(d-e, d-c, MIN3(MAX(b-c,f-e),MAX(b-c,b-a),MAX(f-g,f-e)) );
+            int min= MIN3(d-e, d-c, MAX3(MIN(b-c,f-e),MIN(b-c,b-a),MIN(f-g,f-e)) );
+#else
+            int max= MAX3(d-e, d-c, MIN(b-c, f-e));
+            int min= MIN3(d-e, d-c, MAX(b-c, f-e));
+#endif
+
+            diff= MAX3(diff, min, -max);
+        }
+
+        if(spatial_pred &gt; d + diff)
+           spatial_pred = d + diff;
+        else if(spatial_pred &lt; d - diff)
+           spatial_pred = d - diff;
+
+        dst[0] = spatial_pred;
+
+        dst++;
+        cur++;
+        prev++;
+        next++;
+        prev2++;
+        next2++;
+    }
+}
+
+void filter_plane(int mode, uint8_t *dst, int dst_stride, const uint8_t *prev0, const uint8_t *cur0, const uint8_t *next0, int refs, int w, int h, int parity, int tff, int mmx)
+{
+void (*filter_line)(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity);
+	int y;
+	filter_line = filter_line_c;
+#ifdef ADM_CPU_X86
+	if (CpuCaps::hasMMXEXT()) 
+		filter_line = filter_line_mmx2;
+#endif
+
+        memcpy(dst, cur0, w);
+        memcpy(dst + dst_stride, cur0 + refs, w);
+        for(y=2; y&lt;h-1; y++){
+            if(((y ^ parity) &amp; 1)){
+                const uint8_t *prev= prev0 + y*refs;
+                const uint8_t *cur = cur0 + y*refs;
+                const uint8_t *next= next0 + y*refs;
+                uint8_t *dst2= dst + y*dst_stride;
+                filter_line(mode, dst2, prev, cur, next, w, refs, (parity ^ tff));
+            }else{
+                memcpy(dst + y*dst_stride, cur0 + y*refs, w);
+            }
+        }
+        memcpy(dst + (h-1)*dst_stride, cur0 + (h-1)*refs, w);
+
+#ifdef ADM_CPU_X86
+	if (CpuCaps::hasMMXEXT()) 
+		asm volatile(&quot;emms&quot;);
+#endif
+}
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Yadif/ADM_vidYadif_asm.c (from rev 4007, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif_asm.c)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidYadif_asm.c	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Yadif/ADM_vidYadif_asm.c	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,227 @@
+
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;inttypes.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+
+#ifdef ADM_CPU_X86
+
+
+#define LOAD4(mem,dst) \
+            &quot;movd      &quot;mem&quot;, &quot;#dst&quot; \n\t&quot;\
+            &quot;punpcklbw %%mm7, &quot;#dst&quot; \n\t&quot;
+
+#define PABS(tmp,dst) \
+            &quot;pxor     &quot;#tmp&quot;, &quot;#tmp&quot; \n\t&quot;\
+            &quot;psubw    &quot;#dst&quot;, &quot;#tmp&quot; \n\t&quot;\
+            &quot;pmaxsw   &quot;#tmp&quot;, &quot;#dst&quot; \n\t&quot;
+
+#define CHECK(pj,mj) \
+            &quot;movq &quot;#pj&quot;(%[cur],%[mrefs]), %%mm2 \n\t&quot; /* cur[x-refs-1+j] */\
+            &quot;movq &quot;#mj&quot;(%[cur],%[prefs]), %%mm3 \n\t&quot; /* cur[x+refs-1-j] */\
+            &quot;movq      %%mm2, %%mm4 \n\t&quot;\
+            &quot;movq      %%mm2, %%mm5 \n\t&quot;\
+            &quot;pxor      %%mm3, %%mm4 \n\t&quot;\
+            &quot;pavgb     %%mm3, %%mm5 \n\t&quot;\
+            &quot;pand     %[pb1], %%mm4 \n\t&quot;\
+            &quot;psubusb   %%mm4, %%mm5 \n\t&quot;\
+            &quot;psrlq     $8,    %%mm5 \n\t&quot;\
+            &quot;punpcklbw %%mm7, %%mm5 \n\t&quot; /* (cur[x-refs+j] + cur[x+refs-j])&gt;&gt;1 */\
+            &quot;movq      %%mm2, %%mm4 \n\t&quot;\
+            &quot;psubusb   %%mm3, %%mm2 \n\t&quot;\
+            &quot;psubusb   %%mm4, %%mm3 \n\t&quot;\
+            &quot;pmaxub    %%mm3, %%mm2 \n\t&quot;\
+            &quot;movq      %%mm2, %%mm3 \n\t&quot;\
+            &quot;movq      %%mm2, %%mm4 \n\t&quot; /* ABS(cur[x-refs-1+j] - cur[x+refs-1-j]) */\
+            &quot;psrlq      $8,   %%mm3 \n\t&quot; /* ABS(cur[x-refs  +j] - cur[x+refs  -j]) */\
+            &quot;psrlq     $16,   %%mm4 \n\t&quot; /* ABS(cur[x-refs+1+j] - cur[x+refs+1-j]) */\
+            &quot;punpcklbw %%mm7, %%mm2 \n\t&quot;\
+            &quot;punpcklbw %%mm7, %%mm3 \n\t&quot;\
+            &quot;punpcklbw %%mm7, %%mm4 \n\t&quot;\
+            &quot;paddw     %%mm3, %%mm2 \n\t&quot;\
+            &quot;paddw     %%mm4, %%mm2 \n\t&quot; /* score */
+
+#define CHECK1 \
+            &quot;movq      %%mm0, %%mm3 \n\t&quot;\
+            &quot;pcmpgtw   %%mm2, %%mm3 \n\t&quot; /* if(score &lt; spatial_score) */\
+            &quot;pminsw    %%mm2, %%mm0 \n\t&quot; /* spatial_score= score; */\
+            &quot;movq      %%mm3, %%mm6 \n\t&quot;\
+            &quot;pand      %%mm3, %%mm5 \n\t&quot;\
+            &quot;pandn     %%mm1, %%mm3 \n\t&quot;\
+            &quot;por       %%mm5, %%mm3 \n\t&quot;\
+            &quot;movq      %%mm3, %%mm1 \n\t&quot; /* spatial_pred= (cur[x-refs+j] + cur[x+refs-j])&gt;&gt;1; */
+
+#define CHECK2 /* pretend not to have checked dir=2 if dir=1 was bad.\
+                  hurts both quality and speed, but matches the C version. */\
+            &quot;paddw    %[pw1], %%mm6 \n\t&quot;\
+            &quot;psllw     $14,   %%mm6 \n\t&quot;\
+            &quot;paddsw    %%mm6, %%mm2 \n\t&quot;\
+            &quot;movq      %%mm0, %%mm3 \n\t&quot;\
+            &quot;pcmpgtw   %%mm2, %%mm3 \n\t&quot;\
+            &quot;pminsw    %%mm2, %%mm0 \n\t&quot;\
+            &quot;pand      %%mm3, %%mm5 \n\t&quot;\
+            &quot;pandn     %%mm1, %%mm3 \n\t&quot;\
+            &quot;por       %%mm5, %%mm3 \n\t&quot;\
+            &quot;movq      %%mm3, %%mm1 \n\t&quot;
+
+void filter_line_mmx2(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity){
+    static const uint64_t pw_1 = 0x0001000100010001ULL;
+    static const uint64_t pb_1 = 0x0101010101010101ULL;
+//    const int mode = p-&gt;mode;
+    uint64_t tmp0, tmp1, tmp2, tmp3;
+    int x;
+
+#define FILTER\
+    for(x=0; x&lt;w; x+=4){\
+        asm volatile(\
+            &quot;pxor      %%mm7, %%mm7 \n\t&quot;\
+            LOAD4(&quot;(%[cur],%[mrefs])&quot;, %%mm0) /* c = cur[x-refs] */\
+            LOAD4(&quot;(%[cur],%[prefs])&quot;, %%mm1) /* e = cur[x+refs] */\
+            LOAD4(&quot;(%[&quot;prev2&quot;])&quot;, %%mm2) /* prev2[x] */\
+            LOAD4(&quot;(%[&quot;next2&quot;])&quot;, %%mm3) /* next2[x] */\
+            &quot;movq      %%mm3, %%mm4 \n\t&quot;\
+            &quot;paddw     %%mm2, %%mm3 \n\t&quot;\
+            &quot;psraw     $1,    %%mm3 \n\t&quot; /* d = (prev2[x] + next2[x])&gt;&gt;1 */\
+            &quot;movq      %%mm0, %[tmp0] \n\t&quot; /* c */\
+            &quot;movq      %%mm3, %[tmp1] \n\t&quot; /* d */\
+            &quot;movq      %%mm1, %[tmp2] \n\t&quot; /* e */\
+            &quot;psubw     %%mm4, %%mm2 \n\t&quot;\
+            PABS(      %%mm4, %%mm2) /* temporal_diff0 */\
+            LOAD4(&quot;(%[prev],%[mrefs])&quot;, %%mm3) /* prev[x-refs] */\
+            LOAD4(&quot;(%[prev],%[prefs])&quot;, %%mm4) /* prev[x+refs] */\
+            &quot;psubw     %%mm0, %%mm3 \n\t&quot;\
+            &quot;psubw     %%mm1, %%mm4 \n\t&quot;\
+            PABS(      %%mm5, %%mm3)\
+            PABS(      %%mm5, %%mm4)\
+            &quot;paddw     %%mm4, %%mm3 \n\t&quot; /* temporal_diff1 */\
+            &quot;psrlw     $1,    %%mm2 \n\t&quot;\
+            &quot;psrlw     $1,    %%mm3 \n\t&quot;\
+            &quot;pmaxsw    %%mm3, %%mm2 \n\t&quot;\
+            LOAD4(&quot;(%[next],%[mrefs])&quot;, %%mm3) /* next[x-refs] */\
+            LOAD4(&quot;(%[next],%[prefs])&quot;, %%mm4) /* next[x+refs] */\
+            &quot;psubw     %%mm0, %%mm3 \n\t&quot;\
+            &quot;psubw     %%mm1, %%mm4 \n\t&quot;\
+            PABS(      %%mm5, %%mm3)\
+            PABS(      %%mm5, %%mm4)\
+            &quot;paddw     %%mm4, %%mm3 \n\t&quot; /* temporal_diff2 */\
+            &quot;psrlw     $1,    %%mm3 \n\t&quot;\
+            &quot;pmaxsw    %%mm3, %%mm2 \n\t&quot;\
+            &quot;movq      %%mm2, %[tmp3] \n\t&quot; /* diff */\
+\
+            &quot;paddw     %%mm0, %%mm1 \n\t&quot;\
+            &quot;paddw     %%mm0, %%mm0 \n\t&quot;\
+            &quot;psubw     %%mm1, %%mm0 \n\t&quot;\
+            &quot;psrlw     $1,    %%mm1 \n\t&quot; /* spatial_pred */\
+            PABS(      %%mm2, %%mm0)      /* ABS(c-e) */\
+\
+            &quot;movq -1(%[cur],%[mrefs]), %%mm2 \n\t&quot; /* cur[x-refs-1] */\
+            &quot;movq -1(%[cur],%[prefs]), %%mm3 \n\t&quot; /* cur[x+refs-1] */\
+            &quot;movq      %%mm2, %%mm4 \n\t&quot;\
+            &quot;psubusb   %%mm3, %%mm2 \n\t&quot;\
+            &quot;psubusb   %%mm4, %%mm3 \n\t&quot;\
+            &quot;pmaxub    %%mm3, %%mm2 \n\t&quot;\
+            &quot;pshufw $9,%%mm2, %%mm3 \n\t&quot;\
+            &quot;punpcklbw %%mm7, %%mm2 \n\t&quot; /* ABS(cur[x-refs-1] - cur[x+refs-1]) */\
+            &quot;punpcklbw %%mm7, %%mm3 \n\t&quot; /* ABS(cur[x-refs+1] - cur[x+refs+1]) */\
+            &quot;paddw     %%mm2, %%mm0 \n\t&quot;\
+            &quot;paddw     %%mm3, %%mm0 \n\t&quot;\
+            &quot;psubw    %[pw1], %%mm0 \n\t&quot; /* spatial_score */\
+\
+            CHECK(-2,0)\
+            CHECK1\
+            CHECK(-3,1)\
+            CHECK2\
+            CHECK(0,-2)\
+            CHECK1\
+            CHECK(1,-3)\
+            CHECK2\
+\
+            /* if(p-&gt;mode&lt;2) ... */\
+            &quot;movq    %[tmp3], %%mm6 \n\t&quot; /* diff */\
+            &quot;cmp       $2, %[mode] \n\t&quot;\
+            &quot;jge       1f \n\t&quot;\
+            LOAD4(&quot;(%[&quot;prev2&quot;],%[mrefs],2)&quot;, %%mm2) /* prev2[x-2*refs] */\
+            LOAD4(&quot;(%[&quot;next2&quot;],%[mrefs],2)&quot;, %%mm4) /* next2[x-2*refs] */\
+            LOAD4(&quot;(%[&quot;prev2&quot;],%[prefs],2)&quot;, %%mm3) /* prev2[x+2*refs] */\
+            LOAD4(&quot;(%[&quot;next2&quot;],%[prefs],2)&quot;, %%mm5) /* next2[x+2*refs] */\
+            &quot;paddw     %%mm4, %%mm2 \n\t&quot;\
+            &quot;paddw     %%mm5, %%mm3 \n\t&quot;\
+            &quot;psrlw     $1,    %%mm2 \n\t&quot; /* b */\
+            &quot;psrlw     $1,    %%mm3 \n\t&quot; /* f */\
+            &quot;movq    %[tmp0], %%mm4 \n\t&quot; /* c */\
+            &quot;movq    %[tmp1], %%mm5 \n\t&quot; /* d */\
+            &quot;movq    %[tmp2], %%mm7 \n\t&quot; /* e */\
+            &quot;psubw     %%mm4, %%mm2 \n\t&quot; /* b-c */\
+            &quot;psubw     %%mm7, %%mm3 \n\t&quot; /* f-e */\
+            &quot;movq      %%mm5, %%mm0 \n\t&quot;\
+            &quot;psubw     %%mm4, %%mm5 \n\t&quot; /* d-c */\
+            &quot;psubw     %%mm7, %%mm0 \n\t&quot; /* d-e */\
+            &quot;movq      %%mm2, %%mm4 \n\t&quot;\
+            &quot;pminsw    %%mm3, %%mm2 \n\t&quot;\
+            &quot;pmaxsw    %%mm4, %%mm3 \n\t&quot;\
+            &quot;pmaxsw    %%mm5, %%mm2 \n\t&quot;\
+            &quot;pminsw    %%mm5, %%mm3 \n\t&quot;\
+            &quot;pmaxsw    %%mm0, %%mm2 \n\t&quot; /* max */\
+            &quot;pminsw    %%mm0, %%mm3 \n\t&quot; /* min */\
+            &quot;pxor      %%mm4, %%mm4 \n\t&quot;\
+            &quot;pmaxsw    %%mm3, %%mm6 \n\t&quot;\
+            &quot;psubw     %%mm2, %%mm4 \n\t&quot; /* -max */\
+            &quot;pmaxsw    %%mm4, %%mm6 \n\t&quot; /* diff= MAX3(diff, min, -max); */\
+            &quot;1: \n\t&quot;\
+\
+            &quot;movq    %[tmp1], %%mm2 \n\t&quot; /* d */\
+            &quot;movq      %%mm2, %%mm3 \n\t&quot;\
+            &quot;psubw     %%mm6, %%mm2 \n\t&quot; /* d-diff */\
+            &quot;paddw     %%mm6, %%mm3 \n\t&quot; /* d+diff */\
+            &quot;pmaxsw    %%mm2, %%mm1 \n\t&quot;\
+            &quot;pminsw    %%mm3, %%mm1 \n\t&quot; /* d = clip(spatial_pred, d-diff, d+diff); */\
+            &quot;packuswb  %%mm1, %%mm1 \n\t&quot;\
+\
+            :[tmp0]&quot;=m&quot;(tmp0),\
+             [tmp1]&quot;=m&quot;(tmp1),\
+             [tmp2]&quot;=m&quot;(tmp2),\
+             [tmp3]&quot;=m&quot;(tmp3)\
+            :[prev] &quot;r&quot;(prev),\
+             [cur]  &quot;r&quot;(cur),\
+             [next] &quot;r&quot;(next),\
+             [prefs]&quot;r&quot;((long)refs),\
+             [mrefs]&quot;r&quot;((long)-refs),\
+             [pw1]  &quot;m&quot;(pw_1),\
+             [pb1]  &quot;m&quot;(pb_1),\
+             [mode] &quot;g&quot;(mode)\
+        );\
+        asm volatile(&quot;movd %%mm1, %0&quot; :&quot;=m&quot;(*dst));\
+        dst += 4;\
+        prev+= 4;\
+        cur += 4;\
+        next+= 4;\
+    }
+
+    if(parity){
+#define prev2 &quot;prev&quot;
+#define next2 &quot;cur&quot;
+        FILTER
+#undef prev2
+#undef next2
+    }else{
+#define prev2 &quot;cur&quot;
+#define next2 &quot;next&quot;
+        FILTER
+#undef prev2
+#undef next2
+    }
+}
+#undef LOAD4
+#undef PABS
+#undef CHECK
+#undef CHECK1
+#undef CHECK2
+#undef FILTER
+#endif
+
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Yadif/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Yadif/CMakeLists.txt	2008-05-01 15:58:28 UTC (rev 4007)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/plugins/ADM_videoFilters/Yadif/CMakeLists.txt	2008-05-01 18:21:27 UTC (rev 4008)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_yadif_SRCS ADM_vidYadif_asm.c  ADM_vidYadif.cpp )
+
+ADD_LIBRARY(ADM_vf_yadif SHARED ${ADM_vf_yadif_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_yadif)
+INSTALL_VIDEOFILTER(ADM_vf_yadif)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001267.html">[Avidemux-svn-commit] r4007 - in	branches/avidemux_2.5_branch_gruntster: avidemux	avidemux/ADM_codecs avidemux/ADM_encoder	avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog	avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog	avidemux/ADM_userInterfaces/ADM_QT4	avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog	avidemux/ADM_userInterfaces/ADM_commonUI cmake
</A></li>
	<LI>Next message: <A HREF="001269.html">[Avidemux-svn-commit] r4009 - in	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4:	ADM_dialogFactory ADM_filters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1268">[ date ]</a>
              <a href="thread.html#1268">[ thread ]</a>
              <a href="subject.html#1268">[ subject ]</a>
              <a href="author.html#1268">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
