<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4040 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_UIs/ADM_GTK/src ADM_userInterfaces/ADM_GTK/ADM_dialog
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4040%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%0A%09ADM_UIs/ADM_GTK/src%20ADM_userInterfaces/ADM_GTK/ADM_dialog&In-Reply-To=%3C200805171857.m4HIvW9S002761%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001296.html">
   <LINK REL="Next"  HREF="001298.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4040 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_UIs/ADM_GTK/src ADM_userInterfaces/ADM_GTK/ADM_dialog</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4040%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%0A%09ADM_UIs/ADM_GTK/src%20ADM_userInterfaces/ADM_GTK/ADM_dialog&In-Reply-To=%3C200805171857.m4HIvW9S002761%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4040 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_UIs/ADM_GTK/src ADM_userInterfaces/ADM_GTK/ADM_dialog">mean at mail.berlios.de
       </A><BR>
    <I>Sat May 17 20:57:32 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001296.html">[Avidemux-svn-commit] r4039 -	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src
</A></li>
        <LI>Next message: <A HREF="001298.html">[Avidemux-svn-commit] r4041 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_UIs/ADM_GTK/src ADM_userInterfaces/ADM_GTK/ADM_gui2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1297">[ date ]</a>
              <a href="thread.html#1297">[ thread ]</a>
              <a href="subject.html#1297">[ subject ]</a>
              <a href="author.html#1297">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-05-17 20:57:31 +0200 (Sat, 17 May 2008)
New Revision: 4040

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/TLK_filesel.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/toolkit_dialog.cpp
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/TLK_filesel.cpp
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/DIA_filesel.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/toolkit_dialog.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt
Log:
[UIs] Move thing to remove unresolved


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/CMakeLists.txt	2008-05-17 18:33:52 UTC (rev 4039)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/CMakeLists.txt	2008-05-17 18:57:31 UTC (rev 4040)
@@ -21,11 +21,11 @@
         ADM_gladeSupport.cpp  
         choice.cpp       
         toolkit_dialog.cpp
-        TLK_filesel.cpp
         toolkit.cpp
 )
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/../include)
 ADD_LIBRARY(${ADM_LIB} SHARED ${${ADM_LIB}_SRCS})
 TARGET_LINK_LIBRARIES(${ADM_LIB} ${GTK_LDFLAGS})
 TARGET_LINK_LIBRARIES(${ADM_LIB} ADM_core)
+TARGET_LINK_LIBRARIES(${ADM_LIB} ADM_coreUI)
 ADD_TARGET_CFLAGS(${ADM_LIB} ${GTK_CFLAGS})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/DIA_filesel.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/DIA_filesel.cpp	2008-05-17 18:33:52 UTC (rev 4039)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/DIA_filesel.cpp	2008-05-17 18:57:31 UTC (rev 4040)
@@ -15,7 +15,7 @@
 #include &quot;ADM_toolkitGtk.h&quot;
 #include &quot;DIA_factory.h&quot;
 #include &quot;DIA_fileSel.h&quot;
-#include &quot;prefs.h&quot;
+//#include &quot;prefs.h&quot;
 namespace ADM_GtkFactory
 {
 class diaElemFile : public diaElemFileBase
@@ -50,7 +50,6 @@
 static void fileRead(void *w,void *p);
 static void dirSel(void *w,void *p);
 
-#include &quot;prefs.h&quot;
 
 diaElemFile::diaElemFile(uint32_t writemode,char **filename,const char *toggleTitle,
                          const char * defaultSuffix,const char *selectFileDesc)
@@ -162,6 +161,8 @@
       if (!*txt &amp;&amp; defaultSuffix)
       {
           const char * lastfilename;
+#if 0
+#warning FIXME
           if (prefs-&gt;get(LASTFILES_FILE1,(ADM_filename **)&amp;lastfilename))
           {
               strcpy (newname, lastfilename);
@@ -180,6 +181,7 @@
                   --cptr;
               }
           }
+#endif
       }
       t = FileSel_SelectWrite(tip,buffer,MAX_SEL,txt);
   }

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/TLK_filesel.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/TLK_filesel.cpp	2008-05-17 18:33:52 UTC (rev 4039)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/TLK_filesel.cpp	2008-05-17 18:57:31 UTC (rev 4040)
@@ -1,574 +0,0 @@
-/***************************************************************************
-TLK_filesel.cpp  -  description
--------------------
-New version of file selector
-
-begin                : Fri Sep 20 2002
-copyright            : (C) 2002 by mean
-email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-***************************************************************************/
-
-/***************************************************************************
-*                                                                         *
-*   This program is free software; you can redistribute it and/or modify  *
-*   it under the terms of the GNU General Public License as published by  *
-*   the Free Software Foundation; either version 2 of the License, or     *
-*   (at your option) any later version.                                   *
-*                                                                         *
-***************************************************************************/
-
-#include &quot;ADM_toolkitGtk.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-#include &lt;errno.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;dirent.h&gt;
-
-#include &quot;ADM_default.h&quot;
-//#include &quot;avi_vars.h&quot;
-
-#include &quot;DIA_fileSel.h&quot;
-#include &quot;DIA_coreUI_internal.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;prefs.h&quot;
-
-#define TH_READ 1
-#define TH_WRITE 2
-extern char *actual_workbench_file;
-
-namespace ADM_GTK_fileSel 
-{
-
-static void GUI_FileSel(const char *label, SELFILE_CB cb, int rw, char **name = NULL);
-uint8_t initFileSelector(void);
-
-static GtkFileFilter *filter_avi = NULL, *filter_mpeg = NULL, *filter_image = NULL, *filter_all = NULL;
-static uint8_t setFilter(GtkWidget *dialog);
-
-/**
-\fn FileSel_SelectRead(const char *title,char *target,uint32_t max, const char *source)
-\brief allow to select a file
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at return</A> 0 on failure, 1 on success
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> title : window title 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> target : where to copy the result (must be allocated by caller)
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> max : Max # of bytes that target can hold
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> source : where we start from
-*/
-uint8_t FileSel_SelectRead(const char *title, char *target, uint32_t max, const char *source)
-{
-	GtkWidget *dialog;
-	uint8_t ret = 0;
-	gchar *selected_filename, last;
-	char *dupe = NULL, *tmpname = NULL;
-	DIR *dir = NULL;
-
-	dialog = gtk_file_chooser_dialog_new(&quot;Open File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_OPEN,
-		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,	NULL);
-
-	gtk_window_set_title(GTK_WINDOW(dialog), title);
-	initFileSelector();
-	setFilter(dialog);
-	gtk_register_dialog(dialog);
-
-	if (source &amp;&amp; *source)
-		gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog), (gchar*)source);
-	else	//use pref
-		if (prefs-&gt;get(LASTDIR_READ, (ADM_filename**)&amp;tmpname))
-			gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), (gchar*)tmpname);
-
-	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
-	{
-		selected_filename = (gchar *)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
-
-		if (strlen(selected_filename))
-		{
-			last = selected_filename[strlen(selected_filename) - 1]; 
-
-			if (last == '/' || last =='\\' )
-			{
-				GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
-				return 0;
-			}
-			else
-			{
-				// Check we can read it ..
-				FILE *fd;
-
-				fd = fopen(selected_filename,&quot;rb&quot;);
-
-				if (fd)
-				{
-					fclose(fd);
-					strncpy(target, (char*)selected_filename, max);
-					// Finally we accept it :)
-					ret = 1;
-				}
-			}
-		}
-	}
-
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-
-	return ret;
-}
-/**
-\fn FileSel_SelectWrite(const char *title,char *target,uint32_t max, const char *source)
-\brief allow to select a file
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at return</A> 0 on failure, 1 on success
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> title : window title 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> target : where to copy the result (must be allocated by caller)
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> max : Max # of bytes that target can hold
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> source : where we start from
-*/
-uint8_t FileSel_SelectWrite(const char *title, char *target, uint32_t max, const char *source)
-{
-	GtkWidget *dialog;
-	uint8_t ret = 0;
-	gchar *selected_filename;
-	gchar last;
-	char *dupe = NULL, *tmpname = NULL;
-	DIR *dir = NULL;
-
-	dialog = gtk_file_chooser_dialog_new(&quot;Write to File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_SAVE,
-		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);
-
-	gtk_window_set_title(GTK_WINDOW(dialog), title);
-	initFileSelector();
-	setFilter(dialog);
-	gtk_register_dialog(dialog);
-
-	if (source &amp;&amp; *source)
-	{
-#if 0
-		// well, this is what they say to do, but then you can't easily edit the
-		// name...
-
-		// the following sequence is per GTK docs for gtk_file_chooser_set_filename()
-		if (access (source, W_OK) == 0) // if file exists
-			gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog),(gchar *)source);
-		else // new file
-#endif
-		{
-			dupe = ADM_PathCanonize(source);
-			ADM_PathStripName(dupe);
-
-			gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), (gchar*)dupe);
-			gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(dialog),
-				(gchar*)(source + strlen(dupe)));
-
-			delete [] dupe;
-		}
-	}
-	else	//use pref
-	{
-		if (prefs-&gt;get(LASTDIR_WRITE,(ADM_filename **)&amp;tmpname))
-		{
-			dupe = ADM_PathCanonize(tmpname);
-
-			if (dir = opendir(dupe))
-			{
-				closedir(dir);
-				gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), (gchar*)tmpname);
-			}
-
-			delete [] dupe;
-		}
-	}
-	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
-	{
-		selected_filename = (gchar*)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
-
-		if (strlen(selected_filename))
-		{
-			last = selected_filename[strlen(selected_filename) - 1];
-
-			if (last == '/' || last =='\\')
-			{
-				GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
-				return 0;
-			}
-			else
-			{
-				strncpy(target, (char*)selected_filename, max);
-				// Finally we accept it :)
-				ret = 1;
-			}
-		}
-	}
-
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-
-	return ret;
-}
-
-/**
-\fn FileSel_SelectDir(const char *title,char *target,uint32_t max, const char *source)
-\brief allow to select a directory
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at return</A> 0 on failure, 1 on success
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> title : window title 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> target : where to copy the result (must be allocated by caller)
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> max : Max # of bytes that target can hold
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at param</A> source : where we start from
-*/
-uint8_t FileSel_SelectDir(const char *title, char *target, uint32_t max, const char *source)
-{
-	GtkWidget *dialog;
-	uint8_t ret = 0;
-	gchar *selected_filename;
-	gchar last;
-	char *dupe = NULL, *tmpname = NULL;
-	DIR *dir = NULL;
-
-	dialog = gtk_file_chooser_dialog_new(&quot;Open File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
-		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);
-
-	gtk_window_set_title(GTK_WINDOW(dialog), title);
-	gtk_register_dialog(dialog);
-
-	/* Set default dir if provided ..*/
-	if (source)
-	{
-		dupe = ADM_PathCanonize(source);
-		ADM_PathStripName(dupe);
-
-		if (dir = opendir(dupe))
-		{
-			closedir(dir);
-			gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog), (gchar*)source);
-		}
-
-		delete [] dupe;
-	}
-	else	//use pref
-	{
-		if (prefs-&gt;get(LASTDIR_READ, (ADM_filename **)&amp;tmpname))
-		{
-			dupe = ADM_PathCanonize(tmpname);
-			ADM_PathStripName(dupe);
-
-			if (dir = opendir(dupe))
-			{
-				closedir(dir);
-				gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog), (gchar*)dupe);
-			}
-
-			delete [] dupe;
-		}
-	}
-
-	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
-	{
-		selected_filename = (gchar*)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
-
-		if (strlen(selected_filename))  /* Nothing selected */
-		{
-			/* Check it is a dir ...*/
-			printf(&quot;&lt;%s&gt;\n&quot;, selected_filename);
-			strncpy(target, selected_filename, max);
-			target[max-1] = 0;
-			ret = 1;
-		}
-	}
-
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-
-	return ret;
-}
-
-void GUI_FileSelWrite(const char *label, SELFILE_CB cb)
-{
-	/* Create the selector */
-	GUI_FileSel(label, cb, 1);
-}
-
-void GUI_FileSelRead(const char *label, SELFILE_CB cb)
-{
-	/* Create the selector */
-	GUI_FileSel(label, cb, 0);
-}
-void GUI_FileSelRead(const char *label, char * * name)
-{
-	/* Create the selector */
-	GUI_FileSel(label, NULL, 0, name);
-}
-void GUI_FileSelWrite(const char *label, char * * name)
-{
-	/* Create the selector */
-	GUI_FileSel(label, NULL, 1, name);
-}
-
-// CYB 2005.02.23: DND
-void fileReadWrite(SELFILE_CB cb, int rw, char *name)
-{
-	if (name)
-	{
-		if (cb)
-		{
-			FILE *fd;
-			fd = fopen(name, &quot;rb&quot;);
-
-			if (rw == 0) // read
-			{
-				// try to open it..
-				if (!fd)
-				{
-					GUI_Error_HIG(QT_TR_NOOP(&quot;File error&quot;), QT_TR_NOOP(&quot;Cannot open \&quot;%s\&quot;.&quot;), name);
-					return;
-				}
-			}
-			else // write
-			{
-				if (fd)
-				{
-					struct stat buf;
-					int fdino;
-					char msg[300];
-
-					fclose(fd);
-
-					snprintf(msg, 300, QT_TR_NOOP(&quot;%s already exists.\n\nDo you want to replace it?&quot;), ADM_GetFileName(name));
-
-					if (!GUI_Question(msg))
-						return;
-
-					/*
-					** JSC Fri Feb 10 00:07:30 CET 2006
-					** compare existing output file inode against each current open files inode
-					** i'm ignoring st_dev, so we may get false positives
-					** i'm testing until fd=1024, should be MAXFD computed by configure
-					** keep in mind:
-					** you can overwrite .idx files, they are loaded into memory and closed soon
-					** you cannot overwrite segment data files, all files are kept open and
-					** are detected here
-					*/
-#ifndef __WIN32
-					if (stat(name,&amp;buf) == -1)
-					{
-						fprintf(stderr, &quot;stat(%s) failed\n&quot;, name);
-						return;
-					}
-#endif
-					fdino = buf.st_ino;
-					for (int i = 0; i &lt; 1024; i++)
-					{
-						if (fstat(i, &amp;buf) != -1)
-						{
-							if (buf.st_ino == fdino)
-							{
-								char str[512];
-
-								snprintf(str, 512, &quot;File \&quot;%s\&quot; exists and is opened by Avidemux&quot;, name);
-								GUI_Error_HIG(str, QT_TR_NOOP(&quot;It is possible that you are trying to overwrite an input file!&quot;));
-
-								return;
-							}
-						}
-					}
-					/*
-					** compare output file against actual EMCAscript file
-					** need to stat() to avoid symlink (/home/x.js) vs. real file (/export/home/x.js) case
-					*/
-					if (actual_workbench_file)
-					{
-						if (stat(actual_workbench_file, &amp;buf) != -1)
-						{
-							if (buf.st_ino == fdino)
-							{
-								char str[512];
-
-								snprintf(str, 512, &quot;File \&quot;%s\&quot; exists and is the actual ECMAscript file&quot;, name);
-								GUI_Error_HIG(str, QT_TR_NOOP(&quot;It is possible that you are trying to overwrite an input file!&quot;));
-
-								return;
-							}
-						}
-					}
-				}
-
-				// check we have right access to it
-				fd = fopen(name, &quot;wb&quot;);
-
-				if (!fd)
-				{
-					GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot write the file&quot;), QT_TR_NOOP(&quot;No write access to \&quot;%s\&quot;.&quot;), name);
-
-					return;
-				}
-			}
-
-			fclose(fd);
-			cb(name);
-		} // no callback -&gt; return value
-	}
-}
-// CYB 2005.02.23: DND
-
-
-void GUI_FileSel(const char *label, SELFILE_CB cb, int rw,char **rname)
-{
-	/* Create the selector */
-	GtkWidget *dialog;
-	char *name = NULL;
-	char *tmpname;
-	gchar *selected_filename;
-	uint8_t res;
-
-	if (rname)
-		*rname = NULL;
-
-	if (rw)
-		dialog = gtk_file_chooser_dialog_new (&quot;Save&quot;, NULL, GTK_FILE_CHOOSER_ACTION_SAVE,
-			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT, NULL);
-	else
-		dialog = gtk_file_chooser_dialog_new (&quot;Open File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_OPEN, 
-			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);
-
-	gtk_dialog_set_default_response (GTK_DIALOG(dialog), GTK_RESPONSE_ACCEPT);
-
-	initFileSelector();
-	setFilter(dialog);
-
-	gtk_window_set_title (GTK_WINDOW(dialog), label);
-	gtk_register_dialog(dialog);
-
-	if (rw)
-		res = prefs-&gt;get(LASTDIR_WRITE,(ADM_filename **)&amp;tmpname);
-	else
-		res = prefs-&gt;get(LASTDIR_READ,(ADM_filename **)&amp;tmpname);
-
-	if (res)
-	{
-		DIR *dir;
-		char *str = ADM_PathCanonize(tmpname);
-
-		ADM_PathStripName(str);
-
-		/* LASTDIR may have gone; then do nothing and use current dir instead (implied) */
-		if (dir = opendir(str))
-		{
-			closedir(dir);
-			gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog),(gchar *)str);
-		}
-
-		delete [] str;
-	}
-
-	ADM_dealloc(tmpname);
-
-	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
-	{
-		selected_filename = (gchar *)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
-
-#ifdef __WIN32
-		if (*(selected_filename + strlen(selected_filename) - 1) == '\\'){
-#else
-		if (*(selected_filename + strlen(selected_filename) - 1) == '/'){
-#endif
-			GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
-		}
-		else
-		{
-			name = ADM_strdup(selected_filename);
-
-			char *str = ADM_PathCanonize(name);
-
-			ADM_PathStripName(str);
-
-			if (rw)
-				prefs-&gt;set(LASTDIR_WRITE, (ADM_filename*)str);
-			else
-				prefs-&gt;set(LASTDIR_READ, (ADM_filename*)str);
-
-			delete [] str;
-		}
-	}
-
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-
-	// CYB 2005.02.23
-	if (cb)
-	{
-		fileReadWrite(cb, rw, name);
-		ADM_dealloc(name);
-	}
-	else
-		*rname = name;
-}
-
-
-/* Mean:It seems it is attached to the dialog &amp; destroyed with it
-As it leads to crash if we don't recreate them each time....*/
-uint8_t initFileSelector(void)
-{
-#define ADD_PAT(x,y) gtk_file_filter_add_pattern(x,&quot;*.&quot;#y);
-
-	filter_avi=gtk_file_filter_new();
-	gtk_file_filter_set_name(filter_avi, &quot;AVI (*.avi)&quot;);
-	ADD_PAT(filter_avi, avi);
-	ADD_PAT(filter_avi, AVI);
-
-	filter_mpeg=gtk_file_filter_new();
-	gtk_file_filter_set_name(filter_mpeg, &quot;MPEG (*.m*,*.vob)&quot;);
-	ADD_PAT(filter_mpeg, [mM][12][Vv]);
-	ADD_PAT(filter_mpeg, [Mm][pP][gG]);
-	ADD_PAT(filter_mpeg, [Vv][Oo][Bb]);
-	ADD_PAT(filter_mpeg, ts);
-	ADD_PAT(filter_mpeg, TS);
-
-	filter_image = gtk_file_filter_new();
-
-	gtk_file_filter_set_name(filter_image, QT_TR_NOOP(&quot;Images&quot;));
-	ADD_PAT(filter_image, png);
-	ADD_PAT(filter_image, bmp);
-	ADD_PAT(filter_image, jpg);
-
-	ADD_PAT(filter_image, PNG);
-	ADD_PAT(filter_image, BMP);
-	ADD_PAT(filter_image, JPG);
-
-	filter_all = gtk_file_filter_new();
-
-	gtk_file_filter_set_name(filter_all, QT_TR_NOOP(&quot;All&quot;));
-	gtk_file_filter_add_pattern(filter_all, &quot;*&quot;);
-
-	return 1;
-}
-
-uint8_t setFilter(GtkWidget *dialog)
-{
-	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_all);
-	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_avi);
-	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_mpeg);
-	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_image);
-
-	return 1;
-}
-/*************/
-void init(void)
-{
-	initFileSelector();
-}
-} // End of nameSpace
-static DIA_FILESEL_DESC_T GtkFileSelDesc=
-{
-	ADM_GTK_fileSel::init,
-	ADM_GTK_fileSel::GUI_FileSelRead,
-	ADM_GTK_fileSel::GUI_FileSelWrite,
-	ADM_GTK_fileSel::GUI_FileSelRead,
-	ADM_GTK_fileSel::GUI_FileSelWrite,
-	ADM_GTK_fileSel::FileSel_SelectWrite,
-	ADM_GTK_fileSel::FileSel_SelectRead,
-	ADM_GTK_fileSel::FileSel_SelectDir
-};
-
-// Hook our functions
-void initFileSelector(void)
-{
-	DIA_fileSelInit(&amp;GtkFileSelDesc);
-}
-
-//EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/toolkit_dialog.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/toolkit_dialog.cpp	2008-05-17 18:33:52 UTC (rev 4039)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/toolkit_dialog.cpp	2008-05-17 18:57:31 UTC (rev 4040)
@@ -29,11 +29,6 @@
 #define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
   g_object_set_data (G_OBJECT (component), name, widget)
 
-static GtkWidget	*create_dialogYN (void);
-static GtkWidget	*create_dialogConfirmation (const char *confirm_text);
-static GtkWidget	*create_dialogWarning (void);
-static GtkWidget       *create_dialogInfo (void);
-static int beQuiet=0;
 
 static GtkWidget *widgetStack[10];
 static int	  widgetCount=0;
@@ -98,733 +93,3 @@
 
 }
 
-/**
-	GUI_Quiet : Prevents gui from poping alert
-	Answers always no to question
-
-*/
-namespace ADM_GtkCoreUIToolkit
-{
-uint8_t GUI_isQuiet(void )
-{
-	return beQuiet;
-}
-void GUI_Quiet( void )
-{
-	beQuiet=1;
-
-}
-/**
-	GUI_Verbose : Allow gui to ask question &amp; popup alert
-
-*/
-void GUI_Verbose( void )
-{
-	beQuiet=0;
-
-}
-
-/**
-	GUI_Question
-		Ask the question passed in alertstring
-			Return 1 if yes
-			Return 0 if no
-
-		In silent mode, always return 0
-
-*/
-int 		GUI_Question(const char *alertstring)
-{
-int ret=0;
-
-        GtkWidget *dialog;
-
-        if(beQuiet) 
-        {
-
-                printf(&quot;?? %s ?? -&gt; NO\n&quot;,alertstring);
-                return 0 ;
-        }
-
-        dialog=create_dialogYN();
-        gtk_label_set_text(GTK_LABEL(WID(label1)),alertstring);
-        gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
-        gtk_register_dialog(dialog);
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_YES)
-        {
-                ret=1;
-        }
-
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        UI_purge();
-
-	return ret;
-}
-
-/*
-GUI_Info: display an info dialog.
-Deprecated - use GUI_Info_HIG instead.
-*/
-
-void             GUI_Info(const char *alertstring)
-{
-        GtkWidget *dialog;
-
-        if(beQuiet) 
-        {
-                printf(&quot;Info: %s\n&quot;,alertstring);
-                return  ;
-        }
-        dialog=create_dialogInfo();
-        gtk_label_set_text(GTK_LABEL(WID(label1)),alertstring);
-        gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
-        gtk_register_dialog(dialog);
-        gtk_dialog_run(GTK_DIALOG(dialog));
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        UI_purge();
-
-}
-
-/**
-GUI_Info_HIG: display an info dialog.
-Takes primary and optional secondary string, as described in GNOME HIG 2.0.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at primary</A>: primary string
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at secondary_format</A>: printf()-style format string for secondary text, or NULL for no secondary text
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at ...</A>: arguments for secondary_format
-*/
-void GUI_Info_HIG(const ADM_LOG_LEVEL level,const char *primary, const char *secondary_format)
-{
-	GtkWidget *dialog;
-	uint32_t msglvl=2;
-
-        prefs-&gt;get(MESSAGE_LEVEL,&amp;msglvl);
-
-        if(msglvl&lt;level)
-        {
-                printf(&quot;Info : %s \n&quot;,primary);
-                return;
-        }
-
-
-	char *alertstring;
-	
-	if (secondary_format)
-	{
-
-		if (beQuiet)
-		{
-			printf(&quot;Info: %s\n%s\n&quot;, primary, secondary_format);
-			return;
-		}
-		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;\n\n&quot;, secondary_format, NULL);
-	}
-	else
-	{	
-		if (beQuiet)
-		{
-			printf(&quot;Info: %s\n&quot;, primary);
-			return;
-		}
-		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;&quot;, NULL);
-	}
-	
-	
-	dialog=create_dialogInfo();
-	gtk_label_set_text(GTK_LABEL(WID(label1)), alertstring);
-	g_free(alertstring);
-	gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
-	gtk_register_dialog(dialog);
-	gtk_dialog_run(GTK_DIALOG(dialog));
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	UI_purge();
-}
-
-
-/**
-GUI_Error_HIG: display an error dialog.
-Takes primary and optional secondary string, as described in GNOME HIG 2.0.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at primary</A>: primary string
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at secondary_format</A>: printf()-style format string for secondary text, or NULL for no secondary text
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at ...</A>: arguments for secondary_format
-*/
-void GUI_Error_HIG(const char *primary, const char *secondary_format)
-{
-	GtkWidget *dialog;
-	uint32_t msglvl=2;
-
-        prefs-&gt;get(MESSAGE_LEVEL,&amp;msglvl);
-        if(msglvl==ADM_LOG_NONE) 
-        {
-                printf(&quot;Error :%s\n&quot;,primary);
-                return;
-        }
-
-
-	char *alertstring;
-	
-	if (secondary_format)
-	{
-		
-		if (beQuiet)
-		{
-			printf(&quot;Info: %s\n%s\n&quot;, primary, secondary_format);
-			return;
-		}
-		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;\n\n&quot;, secondary_format, NULL);
-	}
-	else
-	{	
-		if (beQuiet)
-		{
-			printf(&quot;Info: %s\n&quot;, primary);
-			return;
-		}
-		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;&quot;, NULL);
-	}
-	
-	
-	dialog=create_dialogWarning();
-	gtk_label_set_text(GTK_LABEL(WID(label1)), alertstring);
-	g_free(alertstring);
-	gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
-	gtk_register_dialog(dialog);
-	gtk_dialog_run(GTK_DIALOG(dialog));
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	UI_purge();
-}
-
-/**
-GUI_Confirmation_HIG: display a confirmation dialog with Cancel and custom confirmation button.
-See GNOME HIG 2.0, chapter 3, section &quot;Alerts&quot; for more details.
-
-Returns 1 if the answer is yes, 0 if the answer is no.
-In silent mode, always return 0.
-
-Takes primary and optional secondary string.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at button_confirm</A>: confirmation button text
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at primary</A>: primary string
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at secondary_format</A>: printf()-style format string for secondary text, or NULL for no secondary text
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at ...</A>: arguments for secondary_format
-*/
-int GUI_Confirmation_HIG(const char *button_confirm, const char *primary, const char *secondary_format)
-{
-	int ret=0;
-	GtkWidget *dialog;
-	
-	char *alertstring;
-	
-	if (secondary_format)
-	{
-		
-		if (beQuiet)
-		{
-			printf(&quot;Info: %s\n%s\n&quot;, primary, secondary_format);
-			return 0;
-		}
-		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;\n\n&quot;, secondary_format, NULL);
-	}
-	else
-	{	
-		if (beQuiet)
-		{
-			printf(&quot;Info: %s\n&quot;, primary);
-			return 0;
-		}
-		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;&quot;, NULL);
-	}
-	
-
-	dialog=create_dialogConfirmation(button_confirm);
-	gtk_label_set_text(GTK_LABEL(WID(label1)), alertstring);
-	g_free(alertstring);
-	gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
-	gtk_register_dialog(dialog);
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_YES)
-	{
-		ret=1;
-	}
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	UI_purge();
-	return ret;
-}
-
-/**
-GUI_YesNo: display a question dialog with Yes/No buttons.
-Returns 1 if the answer is yes, 0 if the answer is no.
-In silent mode, always return 0.
-
-Takes primary and optional secondary string.
-
-Note: Yes/No alerts are not recommended - if possible, use GUI_Confirmation_HIG.
-See GNOME HIG 2.0, chapter 3, section &quot;Alerts&quot; for more details.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at primary</A>: primary string
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at secondary_format</A>: printf()-style format string for secondary text, or NULL for no secondary text
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">- at ...</A>: arguments for secondary_format
-*/
-int GUI_YesNo(const char *primary, const char *secondary_format)
-{
-	int ret=0;
-	GtkWidget *dialog;
-	
-	char *alertstring;
-	
-	if (secondary_format)
-	{
-		
-		if (beQuiet)
-		{
-			printf(&quot;Info: %s\n%s\n&quot;, primary, secondary_format);
-			return 0;
-		}
-		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;\n\n&quot;, secondary_format, NULL);
-	}
-	else
-	{	
-		if (beQuiet)
-		{
-			printf(&quot;Info: %s\n&quot;, primary);
-			return 0;
-		}
-		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;&quot;, NULL);
-	}
-	
-
-	dialog=create_dialogYN();
-	gtk_label_set_text(GTK_LABEL(WID(label1)), alertstring);
-	g_free(alertstring);
-	gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
-	gtk_register_dialog(dialog);
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_YES)
-	{
-		ret=1;
-	}
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	UI_purge();
-	return ret;
-}
-extern int GUI_Alternate(char *title,char *choice1,char *choice2);
-} // End of namespace
-
-static CoreToolkitDescriptor GtkCoreToolkitDescriptor=
-{
-		&amp;ADM_GtkCoreUIToolkit::GUI_Info_HIG,
-		&amp;ADM_GtkCoreUIToolkit::GUI_Error_HIG,
-		&amp;ADM_GtkCoreUIToolkit::GUI_Confirmation_HIG,
-		&amp;ADM_GtkCoreUIToolkit::GUI_YesNo,
-		&amp;ADM_GtkCoreUIToolkit::GUI_Question,
-		&amp;ADM_GtkCoreUIToolkit::GUI_Alternate,
-		&amp;ADM_GtkCoreUIToolkit::GUI_Verbose,
-		&amp;ADM_GtkCoreUIToolkit::GUI_Quiet,
-		&amp;ADM_GtkCoreUIToolkit::GUI_isQuiet
-};
-
-void InitCoreToolkit(void )
-{
-	DIA_toolkitInit(&amp;GtkCoreToolkitDescriptor);
-	
-}
-/**
-	Return the line number of a selection
-	0 if no selection of fails
-
-*/
-uint8_t getSelectionNumber(uint32_t nb,GtkWidget *tree  , GtkListStore 	*store,uint32_t *number)
-{
-		GtkTreeSelection *selection;
-		GtkTreeIter ref; //iter,ref;
-		int count=-1;
-
-		*number=0;
-		selection= gtk_tree_view_get_selection    (GTK_TREE_VIEW(tree));
-
-		if(TRUE!=    gtk_tree_model_get_iter_first   (GTK_TREE_MODEL(store),&amp;ref))
-		{
-			return 0;
-		}
-
-		for(uint32_t l=0;l&lt;nb;l++)
-		{
-			if(gtk_tree_selection_iter_is_selected  (selection,&amp;ref)) count=l;
-			gtk_tree_model_iter_next  (GTK_TREE_MODEL(store),&amp;ref);
-		}
-//		printf(&quot; Found sel :%d\n&quot;,count);
-		if(count==-1)
-		{
-			return 0;
-
-		}
-		else
-		{
-			*number=count;;
-			return 1;
-		}
-}
-/**
-
-	Select the row number number in the list given as arg
-
-*/
-uint8_t setSelectionNumber(uint32_t nb,GtkWidget *tree  , GtkListStore 	*store,uint32_t number)
-{
-		GtkTreeSelection *selection;
-		GtkTreeIter ref; //iter,ref;
-
-	 	selection= gtk_tree_view_get_selection    (GTK_TREE_VIEW(tree));
-		/*
-		gtk_tree_selection_select_all (selection);
-		return 1;
-		*/
-		if(TRUE!=    gtk_tree_model_get_iter_first   (GTK_TREE_MODEL(store),&amp;ref))
-		{
-			printf(&quot;Cannot get first iter...\n&quot;);
-			return 0;
-		}
-
-		for(uint32_t l=0;l&lt;nb;l++)
-		{
-			if(l==number)
-			{
-				gtk_tree_selection_select_iter (selection,&amp;ref);
-				return 1;
-			}
-			gtk_tree_model_iter_next  (GTK_TREE_MODEL(store),&amp;ref);
-		}
-		printf(&quot; Could not set selection %d!!\n&quot;,number);
-		return 0;
-}
-
-
-
-
-
-GtkWidget*
-create_dialogYN (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *hbox1;
-  GtkWidget *image1;
-  GtkWidget *label1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *buttonYes;
-  GtkWidget *buttonNo;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), &quot;&quot;);
-  
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-  gtk_container_set_border_width (GTK_CONTAINER (dialog1), 6);
-  gtk_window_set_resizable (GTK_WINDOW (dialog1), FALSE);
-  gtk_dialog_set_has_separator (GTK_DIALOG (dialog1), FALSE);  
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_box_set_spacing (GTK_BOX (dialog_vbox1), 12);
-  gtk_widget_show (dialog_vbox1);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_box_set_spacing (GTK_BOX (hbox1), 12);
-  gtk_container_set_border_width (GTK_CONTAINER (hbox1), 6);
-  gtk_widget_show (hbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, TRUE, TRUE, 0);
-
-  image1 = gtk_image_new_from_stock (&quot;gtk-dialog-question&quot;, GTK_ICON_SIZE_DIALOG);
-  gtk_misc_set_alignment (GTK_MISC (image1), 0.5, 0.0);
-  gtk_widget_show (image1);
-  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
-
-  label1 = gtk_label_new (QT_TR_NOOP(&quot;label1&quot;));
-  gtk_label_set_line_wrap (GTK_LABEL(label1), TRUE);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0.5, 0.0);
-  gtk_label_set_selectable (GTK_LABEL(label1), TRUE);
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, TRUE, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_CENTER);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  buttonYes = gtk_button_new_from_stock (&quot;gtk-no&quot;);
-  gtk_widget_show (buttonYes);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), buttonYes, GTK_RESPONSE_NO);
-  GTK_WIDGET_SET_FLAGS (buttonYes, GTK_CAN_DEFAULT);
-
-  buttonNo = gtk_button_new_from_stock (&quot;gtk-yes&quot;);
-  gtk_widget_show (buttonNo);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), buttonNo, GTK_RESPONSE_YES);
-  GTK_WIDGET_SET_FLAGS (buttonNo, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, image1, &quot;image1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, buttonYes, &quot;buttonYes&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, buttonNo, &quot;buttonNo&quot;);
-
-  gtk_widget_grab_default (buttonYes);
-  return dialog1;
-}
-
-
-GtkWidget*
-create_dialogConfirmation (const char *confirm_text)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *hbox1;
-  GtkWidget *image1;
-  GtkWidget *label1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *buttonCancel;
-  GtkWidget *buttonYes;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), &quot;&quot;);
-  
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-  gtk_container_set_border_width (GTK_CONTAINER (dialog1), 6);
-  gtk_window_set_resizable (GTK_WINDOW (dialog1), FALSE);
-  gtk_dialog_set_has_separator (GTK_DIALOG (dialog1), FALSE);  
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_box_set_spacing (GTK_BOX (dialog_vbox1), 12);
-  gtk_widget_show (dialog_vbox1);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_box_set_spacing (GTK_BOX (hbox1), 12);
-  gtk_container_set_border_width (GTK_CONTAINER (hbox1), 6);
-  gtk_widget_show (hbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, TRUE, TRUE, 0);
-
-  image1 = gtk_image_new_from_stock (&quot;gtk-dialog-warning&quot;, GTK_ICON_SIZE_DIALOG);
-  gtk_misc_set_alignment (GTK_MISC (image1), 0.5, 0.0);
-  gtk_widget_show (image1);
-  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
-
-  label1 = gtk_label_new (QT_TR_NOOP(&quot;label1&quot;));
-  gtk_label_set_line_wrap (GTK_LABEL(label1), TRUE);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0.5, 0.0);
-  gtk_label_set_selectable (GTK_LABEL(label1), TRUE);
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, TRUE, 0);
-  //gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_CENTER);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  buttonCancel = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-  gtk_widget_show (buttonCancel);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), buttonCancel, GTK_RESPONSE_NO);
-  GTK_WIDGET_SET_FLAGS (buttonCancel, GTK_CAN_DEFAULT);
-
-  buttonYes = gtk_button_new_from_stock (confirm_text);
-  gtk_widget_show (buttonYes);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), buttonYes, GTK_RESPONSE_YES);
-  GTK_WIDGET_SET_FLAGS (buttonYes, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, image1, &quot;image1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, buttonCancel, &quot;buttonCancel&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, buttonYes, &quot;buttonYes&quot;);
-
-  gtk_widget_grab_default (buttonYes);
-  return dialog1;
-}
-
-
-GtkWidget*
-create_dialogOK (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *hbox1;
-  GtkWidget *image1;
-  GtkWidget *label1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;Alert&quot;));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, TRUE, TRUE, 0);
-
-  image1 = gtk_image_new_from_stock (&quot;gtk-dialog-warning&quot;, GTK_ICON_SIZE_DIALOG);
-  gtk_widget_show (image1);
-  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
-
-  label1 = gtk_label_new (QT_TR_NOOP(&quot;label1&quot;));
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, TRUE, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, image1, &quot;image1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
-
-  return dialog1;
-}
-
-
-GtkWidget       *create_dialogInfo (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *hbox1;
-  GtkWidget *image1;
-  GtkWidget *label1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *closebutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), &quot;&quot;);
-  
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-  gtk_container_set_border_width (GTK_CONTAINER (dialog1), 6);
-  gtk_window_set_resizable (GTK_WINDOW (dialog1), FALSE);
-  gtk_dialog_set_has_separator (GTK_DIALOG (dialog1), FALSE);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_box_set_spacing (GTK_BOX (dialog_vbox1), 12);
-  gtk_widget_show (dialog_vbox1);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_box_set_spacing (GTK_BOX (hbox1), 12);
-  gtk_container_set_border_width (GTK_CONTAINER (hbox1), 6);
-  gtk_widget_show (hbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, TRUE, TRUE, 0);
-
-  image1 = gtk_image_new_from_stock (&quot;gtk-dialog-info&quot;, GTK_ICON_SIZE_DIALOG);
-  gtk_misc_set_alignment (GTK_MISC (image1), 0.5, 0.0);
-  gtk_widget_show (image1);
-  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
-
-  label1 = gtk_label_new (QT_TR_NOOP(&quot;label1&quot;));
-  gtk_label_set_line_wrap (GTK_LABEL(label1), TRUE);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0.5, 0.0);
-  gtk_label_set_selectable (GTK_LABEL(label1), TRUE);
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, TRUE, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  closebutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (closebutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), closebutton1, GTK_RESPONSE_CLOSE);
-  GTK_WIDGET_SET_FLAGS (closebutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, image1, &quot;image1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, closebutton1, &quot;closebutton1&quot;);
-
-  gtk_widget_grab_default (closebutton1);
-  return dialog1;
-}
-
-GtkWidget*
-create_dialogWarning (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *hbox1;
-  GtkWidget *image1;
-  GtkWidget *label1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *closebutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), &quot;&quot;);
-  
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-  gtk_container_set_border_width (GTK_CONTAINER (dialog1), 6);
-  gtk_window_set_resizable (GTK_WINDOW (dialog1), FALSE);
-  gtk_dialog_set_has_separator (GTK_DIALOG (dialog1), FALSE);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_box_set_spacing (GTK_BOX (dialog_vbox1), 12);
-  gtk_widget_show (dialog_vbox1);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_box_set_spacing (GTK_BOX (hbox1), 12);
-  gtk_container_set_border_width (GTK_CONTAINER (hbox1), 6);
-  gtk_widget_show (hbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, TRUE, TRUE, 0);
-
-  image1 = gtk_image_new_from_stock (&quot;gtk-dialog-error&quot;, GTK_ICON_SIZE_DIALOG);
-  gtk_misc_set_alignment (GTK_MISC (image1), 0.5, 0.0);
-  gtk_widget_show (image1);
-  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
-
-  label1 = gtk_label_new (QT_TR_NOOP(&quot;label1&quot;));
-  gtk_label_set_line_wrap (GTK_LABEL(label1), TRUE);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0.5, 0.0);
-  gtk_label_set_selectable (GTK_LABEL(label1), TRUE);
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, TRUE, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  closebutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (closebutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), closebutton1, GTK_RESPONSE_CLOSE);
-  GTK_WIDGET_SET_FLAGS (closebutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, image1, &quot;image1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, closebutton1, &quot;closebutton1&quot;);
-
-  gtk_widget_grab_default (closebutton1);
-  return dialog1;
-}
-

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt	2008-05-17 18:33:52 UTC (rev 4039)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt	2008-05-17 18:57:31 UTC (rev 4040)
@@ -6,7 +6,10 @@
 	DIA_cnr2.cpp         DIA_eq2.cpp        DIA_idx_pg.cpp     DIA_partial.cpp   DIA_quota.cpp       DIA_vobsub.cpp
 	DIA_asharp.cpp    DIA_coloryuv.cpp     DIA_equalizer.cpp  DIA_jobs.cpp       DIA_pause.cpp     DIA_recent.cpp      DIA_working.cpp
 	DIA_busy.cpp      DIA_contrast.cpp     DIA_exLame.cpp     DIA_pipe.cpp      DIA_resize.cpp
-	DIA_threshold.cpp DIA_SwissArmyKnife.cpp DIA_particle.cpp DIA_eraser.cpp)
+	DIA_threshold.cpp DIA_SwissArmyKnife.cpp DIA_particle.cpp DIA_eraser.cpp
+        toolkit_dialog.cpp
+        TLK_filesel.cpp
+)
 
 ADD_ADM_LIB_GTK_TARGET(${ADM_LIB} ${${ADM_LIB}_SRCS})
 ADD_CFLAGS_GTK_TARGET(${ADM_LIB} ${GTK_CFLAGS} -DADM_SUBVERSION=${ADM_SUBVERSION})

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/TLK_filesel.cpp (from rev 4039, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/TLK_filesel.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/TLK_filesel.cpp	2008-05-17 18:33:52 UTC (rev 4039)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/TLK_filesel.cpp	2008-05-17 18:57:31 UTC (rev 4040)
@@ -0,0 +1,574 @@
+/***************************************************************************
+TLK_filesel.cpp  -  description
+-------------------
+New version of file selector
+
+begin                : Fri Sep 20 2002
+copyright            : (C) 2002 by mean
+email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+***************************************************************************/
+
+/***************************************************************************
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+***************************************************************************/
+
+#include &quot;ADM_toolkitGtk.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &lt;errno.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;dirent.h&gt;
+
+#include &quot;ADM_default.h&quot;
+//#include &quot;avi_vars.h&quot;
+
+#include &quot;DIA_fileSel.h&quot;
+#include &quot;DIA_coreUI_internal.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;prefs.h&quot;
+
+#define TH_READ 1
+#define TH_WRITE 2
+extern char *actual_workbench_file;
+
+namespace ADM_GTK_fileSel 
+{
+
+static void GUI_FileSel(const char *label, SELFILE_CB cb, int rw, char **name = NULL);
+uint8_t initFileSelector(void);
+
+static GtkFileFilter *filter_avi = NULL, *filter_mpeg = NULL, *filter_image = NULL, *filter_all = NULL;
+static uint8_t setFilter(GtkWidget *dialog);
+
+/**
+\fn FileSel_SelectRead(const char *title,char *target,uint32_t max, const char *source)
+\brief allow to select a file
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at return</A> 0 on failure, 1 on success
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> title : window title 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> target : where to copy the result (must be allocated by caller)
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> max : Max # of bytes that target can hold
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> source : where we start from
+*/
+uint8_t FileSel_SelectRead(const char *title, char *target, uint32_t max, const char *source)
+{
+	GtkWidget *dialog;
+	uint8_t ret = 0;
+	gchar *selected_filename, last;
+	char *dupe = NULL, *tmpname = NULL;
+	DIR *dir = NULL;
+
+	dialog = gtk_file_chooser_dialog_new(&quot;Open File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_OPEN,
+		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,	NULL);
+
+	gtk_window_set_title(GTK_WINDOW(dialog), title);
+	initFileSelector();
+	setFilter(dialog);
+	gtk_register_dialog(dialog);
+
+	if (source &amp;&amp; *source)
+		gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog), (gchar*)source);
+	else	//use pref
+		if (prefs-&gt;get(LASTDIR_READ, (ADM_filename**)&amp;tmpname))
+			gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), (gchar*)tmpname);
+
+	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
+	{
+		selected_filename = (gchar *)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+
+		if (strlen(selected_filename))
+		{
+			last = selected_filename[strlen(selected_filename) - 1]; 
+
+			if (last == '/' || last =='\\' )
+			{
+				GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
+				return 0;
+			}
+			else
+			{
+				// Check we can read it ..
+				FILE *fd;
+
+				fd = fopen(selected_filename,&quot;rb&quot;);
+
+				if (fd)
+				{
+					fclose(fd);
+					strncpy(target, (char*)selected_filename, max);
+					// Finally we accept it :)
+					ret = 1;
+				}
+			}
+		}
+	}
+
+	gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+
+	return ret;
+}
+/**
+\fn FileSel_SelectWrite(const char *title,char *target,uint32_t max, const char *source)
+\brief allow to select a file
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at return</A> 0 on failure, 1 on success
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> title : window title 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> target : where to copy the result (must be allocated by caller)
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> max : Max # of bytes that target can hold
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> source : where we start from
+*/
+uint8_t FileSel_SelectWrite(const char *title, char *target, uint32_t max, const char *source)
+{
+	GtkWidget *dialog;
+	uint8_t ret = 0;
+	gchar *selected_filename;
+	gchar last;
+	char *dupe = NULL, *tmpname = NULL;
+	DIR *dir = NULL;
+
+	dialog = gtk_file_chooser_dialog_new(&quot;Write to File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_SAVE,
+		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);
+
+	gtk_window_set_title(GTK_WINDOW(dialog), title);
+	initFileSelector();
+	setFilter(dialog);
+	gtk_register_dialog(dialog);
+
+	if (source &amp;&amp; *source)
+	{
+#if 0
+		// well, this is what they say to do, but then you can't easily edit the
+		// name...
+
+		// the following sequence is per GTK docs for gtk_file_chooser_set_filename()
+		if (access (source, W_OK) == 0) // if file exists
+			gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog),(gchar *)source);
+		else // new file
+#endif
+		{
+			dupe = ADM_PathCanonize(source);
+			ADM_PathStripName(dupe);
+
+			gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), (gchar*)dupe);
+			gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(dialog),
+				(gchar*)(source + strlen(dupe)));
+
+			delete [] dupe;
+		}
+	}
+	else	//use pref
+	{
+		if (prefs-&gt;get(LASTDIR_WRITE,(ADM_filename **)&amp;tmpname))
+		{
+			dupe = ADM_PathCanonize(tmpname);
+
+			if (dir = opendir(dupe))
+			{
+				closedir(dir);
+				gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), (gchar*)tmpname);
+			}
+
+			delete [] dupe;
+		}
+	}
+	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
+	{
+		selected_filename = (gchar*)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+
+		if (strlen(selected_filename))
+		{
+			last = selected_filename[strlen(selected_filename) - 1];
+
+			if (last == '/' || last =='\\')
+			{
+				GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
+				return 0;
+			}
+			else
+			{
+				strncpy(target, (char*)selected_filename, max);
+				// Finally we accept it :)
+				ret = 1;
+			}
+		}
+	}
+
+	gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+
+	return ret;
+}
+
+/**
+\fn FileSel_SelectDir(const char *title,char *target,uint32_t max, const char *source)
+\brief allow to select a directory
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at return</A> 0 on failure, 1 on success
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> title : window title 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> target : where to copy the result (must be allocated by caller)
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> max : Max # of bytes that target can hold
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> source : where we start from
+*/
+uint8_t FileSel_SelectDir(const char *title, char *target, uint32_t max, const char *source)
+{
+	GtkWidget *dialog;
+	uint8_t ret = 0;
+	gchar *selected_filename;
+	gchar last;
+	char *dupe = NULL, *tmpname = NULL;
+	DIR *dir = NULL;
+
+	dialog = gtk_file_chooser_dialog_new(&quot;Open File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
+		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);
+
+	gtk_window_set_title(GTK_WINDOW(dialog), title);
+	gtk_register_dialog(dialog);
+
+	/* Set default dir if provided ..*/
+	if (source)
+	{
+		dupe = ADM_PathCanonize(source);
+		ADM_PathStripName(dupe);
+
+		if (dir = opendir(dupe))
+		{
+			closedir(dir);
+			gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog), (gchar*)source);
+		}
+
+		delete [] dupe;
+	}
+	else	//use pref
+	{
+		if (prefs-&gt;get(LASTDIR_READ, (ADM_filename **)&amp;tmpname))
+		{
+			dupe = ADM_PathCanonize(tmpname);
+			ADM_PathStripName(dupe);
+
+			if (dir = opendir(dupe))
+			{
+				closedir(dir);
+				gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog), (gchar*)dupe);
+			}
+
+			delete [] dupe;
+		}
+	}
+
+	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
+	{
+		selected_filename = (gchar*)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+
+		if (strlen(selected_filename))  /* Nothing selected */
+		{
+			/* Check it is a dir ...*/
+			printf(&quot;&lt;%s&gt;\n&quot;, selected_filename);
+			strncpy(target, selected_filename, max);
+			target[max-1] = 0;
+			ret = 1;
+		}
+	}
+
+	gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+
+	return ret;
+}
+
+void GUI_FileSelWrite(const char *label, SELFILE_CB cb)
+{
+	/* Create the selector */
+	GUI_FileSel(label, cb, 1);
+}
+
+void GUI_FileSelRead(const char *label, SELFILE_CB cb)
+{
+	/* Create the selector */
+	GUI_FileSel(label, cb, 0);
+}
+void GUI_FileSelRead(const char *label, char * * name)
+{
+	/* Create the selector */
+	GUI_FileSel(label, NULL, 0, name);
+}
+void GUI_FileSelWrite(const char *label, char * * name)
+{
+	/* Create the selector */
+	GUI_FileSel(label, NULL, 1, name);
+}
+
+// CYB 2005.02.23: DND
+void fileReadWrite(SELFILE_CB cb, int rw, char *name)
+{
+	if (name)
+	{
+		if (cb)
+		{
+			FILE *fd;
+			fd = fopen(name, &quot;rb&quot;);
+
+			if (rw == 0) // read
+			{
+				// try to open it..
+				if (!fd)
+				{
+					GUI_Error_HIG(QT_TR_NOOP(&quot;File error&quot;), QT_TR_NOOP(&quot;Cannot open \&quot;%s\&quot;.&quot;), name);
+					return;
+				}
+			}
+			else // write
+			{
+				if (fd)
+				{
+					struct stat buf;
+					int fdino;
+					char msg[300];
+
+					fclose(fd);
+
+					snprintf(msg, 300, QT_TR_NOOP(&quot;%s already exists.\n\nDo you want to replace it?&quot;), ADM_GetFileName(name));
+
+					if (!GUI_Question(msg))
+						return;
+
+					/*
+					** JSC Fri Feb 10 00:07:30 CET 2006
+					** compare existing output file inode against each current open files inode
+					** i'm ignoring st_dev, so we may get false positives
+					** i'm testing until fd=1024, should be MAXFD computed by configure
+					** keep in mind:
+					** you can overwrite .idx files, they are loaded into memory and closed soon
+					** you cannot overwrite segment data files, all files are kept open and
+					** are detected here
+					*/
+#ifndef __WIN32
+					if (stat(name,&amp;buf) == -1)
+					{
+						fprintf(stderr, &quot;stat(%s) failed\n&quot;, name);
+						return;
+					}
+#endif
+					fdino = buf.st_ino;
+					for (int i = 0; i &lt; 1024; i++)
+					{
+						if (fstat(i, &amp;buf) != -1)
+						{
+							if (buf.st_ino == fdino)
+							{
+								char str[512];
+
+								snprintf(str, 512, &quot;File \&quot;%s\&quot; exists and is opened by Avidemux&quot;, name);
+								GUI_Error_HIG(str, QT_TR_NOOP(&quot;It is possible that you are trying to overwrite an input file!&quot;));
+
+								return;
+							}
+						}
+					}
+					/*
+					** compare output file against actual EMCAscript file
+					** need to stat() to avoid symlink (/home/x.js) vs. real file (/export/home/x.js) case
+					*/
+					if (actual_workbench_file)
+					{
+						if (stat(actual_workbench_file, &amp;buf) != -1)
+						{
+							if (buf.st_ino == fdino)
+							{
+								char str[512];
+
+								snprintf(str, 512, &quot;File \&quot;%s\&quot; exists and is the actual ECMAscript file&quot;, name);
+								GUI_Error_HIG(str, QT_TR_NOOP(&quot;It is possible that you are trying to overwrite an input file!&quot;));
+
+								return;
+							}
+						}
+					}
+				}
+
+				// check we have right access to it
+				fd = fopen(name, &quot;wb&quot;);
+
+				if (!fd)
+				{
+					GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot write the file&quot;), QT_TR_NOOP(&quot;No write access to \&quot;%s\&quot;.&quot;), name);
+
+					return;
+				}
+			}
+
+			fclose(fd);
+			cb(name);
+		} // no callback -&gt; return value
+	}
+}
+// CYB 2005.02.23: DND
+
+
+void GUI_FileSel(const char *label, SELFILE_CB cb, int rw,char **rname)
+{
+	/* Create the selector */
+	GtkWidget *dialog;
+	char *name = NULL;
+	char *tmpname;
+	gchar *selected_filename;
+	uint8_t res;
+
+	if (rname)
+		*rname = NULL;
+
+	if (rw)
+		dialog = gtk_file_chooser_dialog_new (&quot;Save&quot;, NULL, GTK_FILE_CHOOSER_ACTION_SAVE,
+			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT, NULL);
+	else
+		dialog = gtk_file_chooser_dialog_new (&quot;Open File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_OPEN, 
+			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);
+
+	gtk_dialog_set_default_response (GTK_DIALOG(dialog), GTK_RESPONSE_ACCEPT);
+
+	initFileSelector();
+	setFilter(dialog);
+
+	gtk_window_set_title (GTK_WINDOW(dialog), label);
+	gtk_register_dialog(dialog);
+
+	if (rw)
+		res = prefs-&gt;get(LASTDIR_WRITE,(ADM_filename **)&amp;tmpname);
+	else
+		res = prefs-&gt;get(LASTDIR_READ,(ADM_filename **)&amp;tmpname);
+
+	if (res)
+	{
+		DIR *dir;
+		char *str = ADM_PathCanonize(tmpname);
+
+		ADM_PathStripName(str);
+
+		/* LASTDIR may have gone; then do nothing and use current dir instead (implied) */
+		if (dir = opendir(str))
+		{
+			closedir(dir);
+			gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog),(gchar *)str);
+		}
+
+		delete [] str;
+	}
+
+	ADM_dealloc(tmpname);
+
+	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
+	{
+		selected_filename = (gchar *)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+
+#ifdef __WIN32
+		if (*(selected_filename + strlen(selected_filename) - 1) == '\\'){
+#else
+		if (*(selected_filename + strlen(selected_filename) - 1) == '/'){
+#endif
+			GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
+		}
+		else
+		{
+			name = ADM_strdup(selected_filename);
+
+			char *str = ADM_PathCanonize(name);
+
+			ADM_PathStripName(str);
+
+			if (rw)
+				prefs-&gt;set(LASTDIR_WRITE, (ADM_filename*)str);
+			else
+				prefs-&gt;set(LASTDIR_READ, (ADM_filename*)str);
+
+			delete [] str;
+		}
+	}
+
+	gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+
+	// CYB 2005.02.23
+	if (cb)
+	{
+		fileReadWrite(cb, rw, name);
+		ADM_dealloc(name);
+	}
+	else
+		*rname = name;
+}
+
+
+/* Mean:It seems it is attached to the dialog &amp; destroyed with it
+As it leads to crash if we don't recreate them each time....*/
+uint8_t initFileSelector(void)
+{
+#define ADD_PAT(x,y) gtk_file_filter_add_pattern(x,&quot;*.&quot;#y);
+
+	filter_avi=gtk_file_filter_new();
+	gtk_file_filter_set_name(filter_avi, &quot;AVI (*.avi)&quot;);
+	ADD_PAT(filter_avi, avi);
+	ADD_PAT(filter_avi, AVI);
+
+	filter_mpeg=gtk_file_filter_new();
+	gtk_file_filter_set_name(filter_mpeg, &quot;MPEG (*.m*,*.vob)&quot;);
+	ADD_PAT(filter_mpeg, [mM][12][Vv]);
+	ADD_PAT(filter_mpeg, [Mm][pP][gG]);
+	ADD_PAT(filter_mpeg, [Vv][Oo][Bb]);
+	ADD_PAT(filter_mpeg, ts);
+	ADD_PAT(filter_mpeg, TS);
+
+	filter_image = gtk_file_filter_new();
+
+	gtk_file_filter_set_name(filter_image, QT_TR_NOOP(&quot;Images&quot;));
+	ADD_PAT(filter_image, png);
+	ADD_PAT(filter_image, bmp);
+	ADD_PAT(filter_image, jpg);
+
+	ADD_PAT(filter_image, PNG);
+	ADD_PAT(filter_image, BMP);
+	ADD_PAT(filter_image, JPG);
+
+	filter_all = gtk_file_filter_new();
+
+	gtk_file_filter_set_name(filter_all, QT_TR_NOOP(&quot;All&quot;));
+	gtk_file_filter_add_pattern(filter_all, &quot;*&quot;);
+
+	return 1;
+}
+
+uint8_t setFilter(GtkWidget *dialog)
+{
+	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_all);
+	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_avi);
+	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_mpeg);
+	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_image);
+
+	return 1;
+}
+/*************/
+void init(void)
+{
+	initFileSelector();
+}
+} // End of nameSpace
+static DIA_FILESEL_DESC_T GtkFileSelDesc=
+{
+	ADM_GTK_fileSel::init,
+	ADM_GTK_fileSel::GUI_FileSelRead,
+	ADM_GTK_fileSel::GUI_FileSelWrite,
+	ADM_GTK_fileSel::GUI_FileSelRead,
+	ADM_GTK_fileSel::GUI_FileSelWrite,
+	ADM_GTK_fileSel::FileSel_SelectWrite,
+	ADM_GTK_fileSel::FileSel_SelectRead,
+	ADM_GTK_fileSel::FileSel_SelectDir
+};
+
+// Hook our functions
+void initFileSelector(void)
+{
+	DIA_fileSelInit(&amp;GtkFileSelDesc);
+}
+
+//EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/toolkit_dialog.cpp (from rev 4039, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/toolkit_dialog.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/toolkit_dialog.cpp	2008-05-17 18:33:52 UTC (rev 4039)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/toolkit_dialog.cpp	2008-05-17 18:57:31 UTC (rev 4040)
@@ -0,0 +1,768 @@
+/***************************************************************************
+                          toolkit_dialog.cpp  -  description
+                             -------------------
+
+  Handle simple dialog (alert, yes./no)
+
+
+    begin                : Fri Dec 14 2001
+    copyright            : (C) 2001 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_toolkitGtk.h&quot;
+#include &quot;prefs.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;DIA_coreUI_internal.h&quot;
+#define GLADE_HOOKUP_OBJECT(component,widget,name) \
+  g_object_set_data_full (G_OBJECT (component), name, \
+    gtk_widget_ref (widget), (GDestroyNotify) gtk_widget_unref)
+
+#define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
+  g_object_set_data (G_OBJECT (component), name, widget)
+
+static GtkWidget	*create_dialogYN (void);
+static GtkWidget	*create_dialogConfirmation (const char *confirm_text);
+static GtkWidget	*create_dialogWarning (void);
+static GtkWidget       *create_dialogInfo (void);
+static int beQuiet=0;
+
+
+/**
+	GUI_Quiet : Prevents gui from poping alert
+	Answers always no to question
+
+*/
+namespace ADM_GtkCoreUIToolkit
+{
+uint8_t GUI_isQuiet(void )
+{
+	return beQuiet;
+}
+void GUI_Quiet( void )
+{
+	beQuiet=1;
+
+}
+/**
+	GUI_Verbose : Allow gui to ask question &amp; popup alert
+
+*/
+void GUI_Verbose( void )
+{
+	beQuiet=0;
+
+}
+
+/**
+	GUI_Question
+		Ask the question passed in alertstring
+			Return 1 if yes
+			Return 0 if no
+
+		In silent mode, always return 0
+
+*/
+int 		GUI_Question(const char *alertstring)
+{
+int ret=0;
+
+        GtkWidget *dialog;
+
+        if(beQuiet) 
+        {
+
+                printf(&quot;?? %s ?? -&gt; NO\n&quot;,alertstring);
+                return 0 ;
+        }
+
+        dialog=create_dialogYN();
+        gtk_label_set_text(GTK_LABEL(WID(label1)),alertstring);
+        gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
+        gtk_register_dialog(dialog);
+        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_YES)
+        {
+                ret=1;
+        }
+
+        gtk_unregister_dialog(dialog);
+        gtk_widget_destroy(dialog);
+        UI_purge();
+
+	return ret;
+}
+
+/*
+GUI_Info: display an info dialog.
+Deprecated - use GUI_Info_HIG instead.
+*/
+
+void             GUI_Info(const char *alertstring)
+{
+        GtkWidget *dialog;
+
+        if(beQuiet) 
+        {
+                printf(&quot;Info: %s\n&quot;,alertstring);
+                return  ;
+        }
+        dialog=create_dialogInfo();
+        gtk_label_set_text(GTK_LABEL(WID(label1)),alertstring);
+        gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
+        gtk_register_dialog(dialog);
+        gtk_dialog_run(GTK_DIALOG(dialog));
+        gtk_unregister_dialog(dialog);
+        gtk_widget_destroy(dialog);
+        UI_purge();
+
+}
+
+/**
+GUI_Info_HIG: display an info dialog.
+Takes primary and optional secondary string, as described in GNOME HIG 2.0.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at primary</A>: primary string
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at secondary_format</A>: printf()-style format string for secondary text, or NULL for no secondary text
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at ...</A>: arguments for secondary_format
+*/
+void GUI_Info_HIG(const ADM_LOG_LEVEL level,const char *primary, const char *secondary_format)
+{
+	GtkWidget *dialog;
+	uint32_t msglvl=2;
+
+        prefs-&gt;get(MESSAGE_LEVEL,&amp;msglvl);
+
+        if(msglvl&lt;level)
+        {
+                printf(&quot;Info : %s \n&quot;,primary);
+                return;
+        }
+
+
+	char *alertstring;
+	
+	if (secondary_format)
+	{
+
+		if (beQuiet)
+		{
+			printf(&quot;Info: %s\n%s\n&quot;, primary, secondary_format);
+			return;
+		}
+		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;\n\n&quot;, secondary_format, NULL);
+	}
+	else
+	{	
+		if (beQuiet)
+		{
+			printf(&quot;Info: %s\n&quot;, primary);
+			return;
+		}
+		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;&quot;, NULL);
+	}
+	
+	
+	dialog=create_dialogInfo();
+	gtk_label_set_text(GTK_LABEL(WID(label1)), alertstring);
+	g_free(alertstring);
+	gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
+	gtk_register_dialog(dialog);
+	gtk_dialog_run(GTK_DIALOG(dialog));
+	gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+	UI_purge();
+}
+
+
+/**
+GUI_Error_HIG: display an error dialog.
+Takes primary and optional secondary string, as described in GNOME HIG 2.0.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at primary</A>: primary string
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at secondary_format</A>: printf()-style format string for secondary text, or NULL for no secondary text
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at ...</A>: arguments for secondary_format
+*/
+void GUI_Error_HIG(const char *primary, const char *secondary_format)
+{
+	GtkWidget *dialog;
+	uint32_t msglvl=2;
+
+        prefs-&gt;get(MESSAGE_LEVEL,&amp;msglvl);
+        if(msglvl==ADM_LOG_NONE) 
+        {
+                printf(&quot;Error :%s\n&quot;,primary);
+                return;
+        }
+
+
+	char *alertstring;
+	
+	if (secondary_format)
+	{
+		
+		if (beQuiet)
+		{
+			printf(&quot;Info: %s\n%s\n&quot;, primary, secondary_format);
+			return;
+		}
+		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;\n\n&quot;, secondary_format, NULL);
+	}
+	else
+	{	
+		if (beQuiet)
+		{
+			printf(&quot;Info: %s\n&quot;, primary);
+			return;
+		}
+		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;&quot;, NULL);
+	}
+	
+	
+	dialog=create_dialogWarning();
+	gtk_label_set_text(GTK_LABEL(WID(label1)), alertstring);
+	g_free(alertstring);
+	gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
+	gtk_register_dialog(dialog);
+	gtk_dialog_run(GTK_DIALOG(dialog));
+	gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+	UI_purge();
+}
+
+/**
+GUI_Confirmation_HIG: display a confirmation dialog with Cancel and custom confirmation button.
+See GNOME HIG 2.0, chapter 3, section &quot;Alerts&quot; for more details.
+
+Returns 1 if the answer is yes, 0 if the answer is no.
+In silent mode, always return 0.
+
+Takes primary and optional secondary string.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at button_confirm</A>: confirmation button text
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at primary</A>: primary string
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at secondary_format</A>: printf()-style format string for secondary text, or NULL for no secondary text
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at ...</A>: arguments for secondary_format
+*/
+int GUI_Confirmation_HIG(const char *button_confirm, const char *primary, const char *secondary_format)
+{
+	int ret=0;
+	GtkWidget *dialog;
+	
+	char *alertstring;
+	
+	if (secondary_format)
+	{
+		
+		if (beQuiet)
+		{
+			printf(&quot;Info: %s\n%s\n&quot;, primary, secondary_format);
+			return 0;
+		}
+		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;\n\n&quot;, secondary_format, NULL);
+	}
+	else
+	{	
+		if (beQuiet)
+		{
+			printf(&quot;Info: %s\n&quot;, primary);
+			return 0;
+		}
+		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;&quot;, NULL);
+	}
+	
+
+	dialog=create_dialogConfirmation(button_confirm);
+	gtk_label_set_text(GTK_LABEL(WID(label1)), alertstring);
+	g_free(alertstring);
+	gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
+	gtk_register_dialog(dialog);
+	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_YES)
+	{
+		ret=1;
+	}
+	gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+	UI_purge();
+	return ret;
+}
+
+/**
+GUI_YesNo: display a question dialog with Yes/No buttons.
+Returns 1 if the answer is yes, 0 if the answer is no.
+In silent mode, always return 0.
+
+Takes primary and optional secondary string.
+
+Note: Yes/No alerts are not recommended - if possible, use GUI_Confirmation_HIG.
+See GNOME HIG 2.0, chapter 3, section &quot;Alerts&quot; for more details.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at primary</A>: primary string
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at secondary_format</A>: printf()-style format string for secondary text, or NULL for no secondary text
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at ...</A>: arguments for secondary_format
+*/
+int GUI_YesNo(const char *primary, const char *secondary_format)
+{
+	int ret=0;
+	GtkWidget *dialog;
+	
+	char *alertstring;
+	
+	if (secondary_format)
+	{
+		
+		if (beQuiet)
+		{
+			printf(&quot;Info: %s\n%s\n&quot;, primary, secondary_format);
+			return 0;
+		}
+		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;\n\n&quot;, secondary_format, NULL);
+	}
+	else
+	{	
+		if (beQuiet)
+		{
+			printf(&quot;Info: %s\n&quot;, primary);
+			return 0;
+		}
+		alertstring = g_strconcat(&quot;&lt;span size=\&quot;larger\&quot; weight=\&quot;bold\&quot;&gt;&quot;, primary, &quot;&lt;/span&gt;&quot;, NULL);
+	}
+	
+
+	dialog=create_dialogYN();
+	gtk_label_set_text(GTK_LABEL(WID(label1)), alertstring);
+	g_free(alertstring);
+	gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
+	gtk_register_dialog(dialog);
+	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_YES)
+	{
+		ret=1;
+	}
+	gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+	UI_purge();
+	return ret;
+}
+extern int GUI_Alternate(char *title,char *choice1,char *choice2);
+} // End of namespace
+
+static CoreToolkitDescriptor GtkCoreToolkitDescriptor=
+{
+		&amp;ADM_GtkCoreUIToolkit::GUI_Info_HIG,
+		&amp;ADM_GtkCoreUIToolkit::GUI_Error_HIG,
+		&amp;ADM_GtkCoreUIToolkit::GUI_Confirmation_HIG,
+		&amp;ADM_GtkCoreUIToolkit::GUI_YesNo,
+		&amp;ADM_GtkCoreUIToolkit::GUI_Question,
+		&amp;ADM_GtkCoreUIToolkit::GUI_Alternate,
+		&amp;ADM_GtkCoreUIToolkit::GUI_Verbose,
+		&amp;ADM_GtkCoreUIToolkit::GUI_Quiet,
+		&amp;ADM_GtkCoreUIToolkit::GUI_isQuiet
+};
+
+void InitCoreToolkit(void )
+{
+	DIA_toolkitInit(&amp;GtkCoreToolkitDescriptor);
+	
+}
+/**
+	Return the line number of a selection
+	0 if no selection of fails
+
+*/
+uint8_t getSelectionNumber(uint32_t nb,GtkWidget *tree  , GtkListStore 	*store,uint32_t *number)
+{
+		GtkTreeSelection *selection;
+		GtkTreeIter ref; //iter,ref;
+		int count=-1;
+
+		*number=0;
+		selection= gtk_tree_view_get_selection    (GTK_TREE_VIEW(tree));
+
+		if(TRUE!=    gtk_tree_model_get_iter_first   (GTK_TREE_MODEL(store),&amp;ref))
+		{
+			return 0;
+		}
+
+		for(uint32_t l=0;l&lt;nb;l++)
+		{
+			if(gtk_tree_selection_iter_is_selected  (selection,&amp;ref)) count=l;
+			gtk_tree_model_iter_next  (GTK_TREE_MODEL(store),&amp;ref);
+		}
+//		printf(&quot; Found sel :%d\n&quot;,count);
+		if(count==-1)
+		{
+			return 0;
+
+		}
+		else
+		{
+			*number=count;;
+			return 1;
+		}
+}
+/**
+
+	Select the row number number in the list given as arg
+
+*/
+uint8_t setSelectionNumber(uint32_t nb,GtkWidget *tree  , GtkListStore 	*store,uint32_t number)
+{
+		GtkTreeSelection *selection;
+		GtkTreeIter ref; //iter,ref;
+
+	 	selection= gtk_tree_view_get_selection    (GTK_TREE_VIEW(tree));
+		/*
+		gtk_tree_selection_select_all (selection);
+		return 1;
+		*/
+		if(TRUE!=    gtk_tree_model_get_iter_first   (GTK_TREE_MODEL(store),&amp;ref))
+		{
+			printf(&quot;Cannot get first iter...\n&quot;);
+			return 0;
+		}
+
+		for(uint32_t l=0;l&lt;nb;l++)
+		{
+			if(l==number)
+			{
+				gtk_tree_selection_select_iter (selection,&amp;ref);
+				return 1;
+			}
+			gtk_tree_model_iter_next  (GTK_TREE_MODEL(store),&amp;ref);
+		}
+		printf(&quot; Could not set selection %d!!\n&quot;,number);
+		return 0;
+}
+
+
+
+
+
+GtkWidget*
+create_dialogYN (void)
+{
+  GtkWidget *dialog1;
+  GtkWidget *dialog_vbox1;
+  GtkWidget *hbox1;
+  GtkWidget *image1;
+  GtkWidget *label1;
+  GtkWidget *dialog_action_area1;
+  GtkWidget *buttonYes;
+  GtkWidget *buttonNo;
+
+  dialog1 = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (dialog1), &quot;&quot;);
+  
+  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
+  gtk_container_set_border_width (GTK_CONTAINER (dialog1), 6);
+  gtk_window_set_resizable (GTK_WINDOW (dialog1), FALSE);
+  gtk_dialog_set_has_separator (GTK_DIALOG (dialog1), FALSE);  
+
+  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
+  gtk_box_set_spacing (GTK_BOX (dialog_vbox1), 12);
+  gtk_widget_show (dialog_vbox1);
+
+  hbox1 = gtk_hbox_new (FALSE, 0);
+  gtk_box_set_spacing (GTK_BOX (hbox1), 12);
+  gtk_container_set_border_width (GTK_CONTAINER (hbox1), 6);
+  gtk_widget_show (hbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, TRUE, TRUE, 0);
+
+  image1 = gtk_image_new_from_stock (&quot;gtk-dialog-question&quot;, GTK_ICON_SIZE_DIALOG);
+  gtk_misc_set_alignment (GTK_MISC (image1), 0.5, 0.0);
+  gtk_widget_show (image1);
+  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
+
+  label1 = gtk_label_new (QT_TR_NOOP(&quot;label1&quot;));
+  gtk_label_set_line_wrap (GTK_LABEL(label1), TRUE);
+  gtk_misc_set_alignment (GTK_MISC (label1), 0.5, 0.0);
+  gtk_label_set_selectable (GTK_LABEL(label1), TRUE);
+  gtk_widget_show (label1);
+  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, TRUE, 0);
+  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_CENTER);
+
+  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
+  gtk_widget_show (dialog_action_area1);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
+
+  buttonYes = gtk_button_new_from_stock (&quot;gtk-no&quot;);
+  gtk_widget_show (buttonYes);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), buttonYes, GTK_RESPONSE_NO);
+  GTK_WIDGET_SET_FLAGS (buttonYes, GTK_CAN_DEFAULT);
+
+  buttonNo = gtk_button_new_from_stock (&quot;gtk-yes&quot;);
+  gtk_widget_show (buttonNo);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), buttonNo, GTK_RESPONSE_YES);
+  GTK_WIDGET_SET_FLAGS (buttonNo, GTK_CAN_DEFAULT);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, image1, &quot;image1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, buttonYes, &quot;buttonYes&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, buttonNo, &quot;buttonNo&quot;);
+
+  gtk_widget_grab_default (buttonYes);
+  return dialog1;
+}
+
+
+GtkWidget*
+create_dialogConfirmation (const char *confirm_text)
+{
+  GtkWidget *dialog1;
+  GtkWidget *dialog_vbox1;
+  GtkWidget *hbox1;
+  GtkWidget *image1;
+  GtkWidget *label1;
+  GtkWidget *dialog_action_area1;
+  GtkWidget *buttonCancel;
+  GtkWidget *buttonYes;
+
+  dialog1 = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (dialog1), &quot;&quot;);
+  
+  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
+  gtk_container_set_border_width (GTK_CONTAINER (dialog1), 6);
+  gtk_window_set_resizable (GTK_WINDOW (dialog1), FALSE);
+  gtk_dialog_set_has_separator (GTK_DIALOG (dialog1), FALSE);  
+
+  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
+  gtk_box_set_spacing (GTK_BOX (dialog_vbox1), 12);
+  gtk_widget_show (dialog_vbox1);
+
+  hbox1 = gtk_hbox_new (FALSE, 0);
+  gtk_box_set_spacing (GTK_BOX (hbox1), 12);
+  gtk_container_set_border_width (GTK_CONTAINER (hbox1), 6);
+  gtk_widget_show (hbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, TRUE, TRUE, 0);
+
+  image1 = gtk_image_new_from_stock (&quot;gtk-dialog-warning&quot;, GTK_ICON_SIZE_DIALOG);
+  gtk_misc_set_alignment (GTK_MISC (image1), 0.5, 0.0);
+  gtk_widget_show (image1);
+  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
+
+  label1 = gtk_label_new (QT_TR_NOOP(&quot;label1&quot;));
+  gtk_label_set_line_wrap (GTK_LABEL(label1), TRUE);
+  gtk_misc_set_alignment (GTK_MISC (label1), 0.5, 0.0);
+  gtk_label_set_selectable (GTK_LABEL(label1), TRUE);
+  gtk_widget_show (label1);
+  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, TRUE, 0);
+  //gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_CENTER);
+
+  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
+  gtk_widget_show (dialog_action_area1);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
+
+  buttonCancel = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
+  gtk_widget_show (buttonCancel);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), buttonCancel, GTK_RESPONSE_NO);
+  GTK_WIDGET_SET_FLAGS (buttonCancel, GTK_CAN_DEFAULT);
+
+  buttonYes = gtk_button_new_from_stock (confirm_text);
+  gtk_widget_show (buttonYes);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), buttonYes, GTK_RESPONSE_YES);
+  GTK_WIDGET_SET_FLAGS (buttonYes, GTK_CAN_DEFAULT);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, image1, &quot;image1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, buttonCancel, &quot;buttonCancel&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, buttonYes, &quot;buttonYes&quot;);
+
+  gtk_widget_grab_default (buttonYes);
+  return dialog1;
+}
+
+
+GtkWidget*
+create_dialogOK (void)
+{
+  GtkWidget *dialog1;
+  GtkWidget *dialog_vbox1;
+  GtkWidget *hbox1;
+  GtkWidget *image1;
+  GtkWidget *label1;
+  GtkWidget *dialog_action_area1;
+  GtkWidget *okbutton1;
+
+  dialog1 = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;Alert&quot;));
+
+  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
+  gtk_widget_show (dialog_vbox1);
+
+  hbox1 = gtk_hbox_new (FALSE, 0);
+  gtk_widget_show (hbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, TRUE, TRUE, 0);
+
+  image1 = gtk_image_new_from_stock (&quot;gtk-dialog-warning&quot;, GTK_ICON_SIZE_DIALOG);
+  gtk_widget_show (image1);
+  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
+
+  label1 = gtk_label_new (QT_TR_NOOP(&quot;label1&quot;));
+  gtk_widget_show (label1);
+  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, TRUE, 0);
+  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
+
+  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
+  gtk_widget_show (dialog_action_area1);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
+
+  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
+  gtk_widget_show (okbutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
+  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, image1, &quot;image1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
+
+  return dialog1;
+}
+
+
+GtkWidget       *create_dialogInfo (void)
+{
+  GtkWidget *dialog1;
+  GtkWidget *dialog_vbox1;
+  GtkWidget *hbox1;
+  GtkWidget *image1;
+  GtkWidget *label1;
+  GtkWidget *dialog_action_area1;
+  GtkWidget *closebutton1;
+
+  dialog1 = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (dialog1), &quot;&quot;);
+  
+  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
+  gtk_container_set_border_width (GTK_CONTAINER (dialog1), 6);
+  gtk_window_set_resizable (GTK_WINDOW (dialog1), FALSE);
+  gtk_dialog_set_has_separator (GTK_DIALOG (dialog1), FALSE);
+
+  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
+  gtk_box_set_spacing (GTK_BOX (dialog_vbox1), 12);
+  gtk_widget_show (dialog_vbox1);
+
+  hbox1 = gtk_hbox_new (FALSE, 0);
+  gtk_box_set_spacing (GTK_BOX (hbox1), 12);
+  gtk_container_set_border_width (GTK_CONTAINER (hbox1), 6);
+  gtk_widget_show (hbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, TRUE, TRUE, 0);
+
+  image1 = gtk_image_new_from_stock (&quot;gtk-dialog-info&quot;, GTK_ICON_SIZE_DIALOG);
+  gtk_misc_set_alignment (GTK_MISC (image1), 0.5, 0.0);
+  gtk_widget_show (image1);
+  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
+
+  label1 = gtk_label_new (QT_TR_NOOP(&quot;label1&quot;));
+  gtk_label_set_line_wrap (GTK_LABEL(label1), TRUE);
+  gtk_misc_set_alignment (GTK_MISC (label1), 0.5, 0.0);
+  gtk_label_set_selectable (GTK_LABEL(label1), TRUE);
+  gtk_widget_show (label1);
+  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, TRUE, 0);
+
+  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
+  gtk_widget_show (dialog_action_area1);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
+
+  closebutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
+  gtk_widget_show (closebutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), closebutton1, GTK_RESPONSE_CLOSE);
+  GTK_WIDGET_SET_FLAGS (closebutton1, GTK_CAN_DEFAULT);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, image1, &quot;image1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, closebutton1, &quot;closebutton1&quot;);
+
+  gtk_widget_grab_default (closebutton1);
+  return dialog1;
+}
+
+GtkWidget*
+create_dialogWarning (void)
+{
+  GtkWidget *dialog1;
+  GtkWidget *dialog_vbox1;
+  GtkWidget *hbox1;
+  GtkWidget *image1;
+  GtkWidget *label1;
+  GtkWidget *dialog_action_area1;
+  GtkWidget *closebutton1;
+
+  dialog1 = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (dialog1), &quot;&quot;);
+  
+  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
+  gtk_container_set_border_width (GTK_CONTAINER (dialog1), 6);
+  gtk_window_set_resizable (GTK_WINDOW (dialog1), FALSE);
+  gtk_dialog_set_has_separator (GTK_DIALOG (dialog1), FALSE);
+
+  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
+  gtk_box_set_spacing (GTK_BOX (dialog_vbox1), 12);
+  gtk_widget_show (dialog_vbox1);
+
+  hbox1 = gtk_hbox_new (FALSE, 0);
+  gtk_box_set_spacing (GTK_BOX (hbox1), 12);
+  gtk_container_set_border_width (GTK_CONTAINER (hbox1), 6);
+  gtk_widget_show (hbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, TRUE, TRUE, 0);
+
+  image1 = gtk_image_new_from_stock (&quot;gtk-dialog-error&quot;, GTK_ICON_SIZE_DIALOG);
+  gtk_misc_set_alignment (GTK_MISC (image1), 0.5, 0.0);
+  gtk_widget_show (image1);
+  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
+
+  label1 = gtk_label_new (QT_TR_NOOP(&quot;label1&quot;));
+  gtk_label_set_line_wrap (GTK_LABEL(label1), TRUE);
+  gtk_misc_set_alignment (GTK_MISC (label1), 0.5, 0.0);
+  gtk_label_set_selectable (GTK_LABEL(label1), TRUE);
+  gtk_widget_show (label1);
+  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, TRUE, 0);
+
+  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
+  gtk_widget_show (dialog_action_area1);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
+
+  closebutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
+  gtk_widget_show (closebutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), closebutton1, GTK_RESPONSE_CLOSE);
+  GTK_WIDGET_SET_FLAGS (closebutton1, GTK_CAN_DEFAULT);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, hbox1, &quot;hbox1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, image1, &quot;image1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
+  GLADE_HOOKUP_OBJECT (dialog1, closebutton1, &quot;closebutton1&quot;);
+
+  gtk_widget_grab_default (closebutton1);
+  return dialog1;
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001296.html">[Avidemux-svn-commit] r4039 -	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src
</A></li>
	<LI>Next message: <A HREF="001298.html">[Avidemux-svn-commit] r4041 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_UIs/ADM_GTK/src ADM_userInterfaces/ADM_GTK/ADM_gui2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1297">[ date ]</a>
              <a href="thread.html#1297">[ thread ]</a>
              <a href="subject.html#1297">[ subject ]</a>
              <a href="author.html#1297">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
