<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5365 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_filter common/ADM_toolkit common/ADM_videoFilter	gtk/ADM_userInterfaces/ADM_dialog gtk/ADM_userInterfaces/ADM_filters	gtk/ADM_userInterfaces/ADM_ocr
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-October/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5365%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux%3A%20.%20common%0A%09common/ADM_filter%20common/ADM_toolkit%20common/ADM_videoFilter%0A%09gtk/ADM_userInterfaces/ADM_dialog%20gtk/ADM_userInterfaces/ADM_filters%0A%09gtk/ADM_userInterfaces/ADM_ocr&In-Reply-To=%3C200910020522.n925MEbB030709%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002575.html">
   <LINK REL="Next"  HREF="002577.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5365 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_filter common/ADM_toolkit common/ADM_videoFilter	gtk/ADM_userInterfaces/ADM_dialog gtk/ADM_userInterfaces/ADM_filters	gtk/ADM_userInterfaces/ADM_ocr</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5365%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux%3A%20.%20common%0A%09common/ADM_filter%20common/ADM_toolkit%20common/ADM_videoFilter%0A%09gtk/ADM_userInterfaces/ADM_dialog%20gtk/ADM_userInterfaces/ADM_filters%0A%09gtk/ADM_userInterfaces/ADM_ocr&In-Reply-To=%3C200910020522.n925MEbB030709%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5365 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_filter common/ADM_toolkit common/ADM_videoFilter	gtk/ADM_userInterfaces/ADM_dialog gtk/ADM_userInterfaces/ADM_filters	gtk/ADM_userInterfaces/ADM_ocr">mean at mail.berlios.de
       </A><BR>
    <I>Fri Oct  2 07:22:14 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002575.html">[Avidemux-svn-commit] r5364 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_editor common/ADM_filter common/ADM_script	common/ADM_toolkit common/ADM_video common/ADM_videoFilter2	gtk/ADM_userInterfaces/ADM_dialog gtk/ADM_userInterfaces/ADM_filters
</A></li>
        <LI>Next message: <A HREF="002577.html">[Avidemux-svn-commit] r5366 -	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2576">[ date ]</a>
              <a href="thread.html#2576">[ thread ]</a>
              <a href="subject.html#2576">[ subject ]</a>
              <a href="author.html#2576">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-10-02 07:22:11 +0200 (Fri, 02 Oct 2009)
New Revision: 5365

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_autoFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_mpdetc.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidNumber.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidUnblend_param.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSub.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubBitmap.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobsub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADMmpdetc.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/CMakeLists.txt
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_autodrive.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_vobsub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_ocr/adm_ocr.cpp
Log:
[videoFilter] Remove old code

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,9 +0,0 @@
-SET(ADM_filter_SRCS 
-filter.cpp  
-filter_declaration.cpp  
-filter_saveload.cpp  
-filter_autoFilter.cpp
-vidVCD.cpp)
-
-ADD_LIBRARY(ADM_filter6 STATIC ${ADM_filter_SRCS})
-ADD_TARGET_CFLAGS(ADM_filter6 -I${LIBXML2_INCLUDE_DIR} ${LIBXML2_DEFINITIONS})

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,479 +0,0 @@
-/***************************************************************************
-                          filter.cpp  -  description
-                             -------------------
-    begin                : Wed Mar 27 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#if 0
-#include &quot;ADM_default.h&quot;
-#include &lt;vector&gt;
-#include &quot;fourcc.h&quot;
-#include &quot;DIA_fileSel.h&quot;
-#include &quot;ADM_dynamicLoading.h&quot;
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_video/ADM_videoNull.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-#include &quot;ADM_videoFilterDynamic.h&quot;
-#include &quot;ADM_video/ADM_vidPartial.h&quot;
-#include &quot;ADM_render/GUI_render.h&quot;
-
-#include &quot;ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_PREVIEW
-#include &quot;ADM_debug.h&quot;
-#include &quot;ADM_quota.h&quot;
-#include &quot;ADM_preview.h&quot;
-//
-
-extern ADM_UI_TYPE UI_GetCurrentUI(void);
-
-class ADM_vf_pluginLoader : public ADM_LibWrapper
-{
-	public:
-		VF_getDescriptor		*getDesc;
-		ADM_vf_pluginLoader(const char *file) : ADM_LibWrapper()
-		{
-				getDesc=NULL;
-				if(loadLibrary(file))
-					getDesc=(VF_getDescriptor *)getSymbol(&quot;ADM_VF_getDescriptor&quot;);
-		};
-};
-// exported vars
-std::vector &lt;FilterDescriptor *&gt; allfilters;
-std::vector &lt;FilterDescriptor *&gt; filterCategories[VF_MAX];
-std::vector &lt;ADM_vf_pluginLoader *&gt; pluginLoaderQueue;
-
-uint32_t nb_active_filter=0;
-FILTER  videofilters[VF_MAX_FILTER];
-
-
-
-static uint32_t lastStart=0, lastNb=0;
-static uint32_t tagCount=VF_START_TAG;
-
-extern ADM_Composer *video_body;
-extern AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *conf, AVDMGenericVideoStream *in) ;
-extern char *ADM_escape(const ADM_filename *incoming);
-//
-
-static  void updateVideoFilters(void);
-
-// Ugly should be dynamically allocated
-#warning HARDCODEC IMAGE SIZE
-
-// dummy constructor used to register the filter
-//____________________________________
-AVDMVideo_FilterDec::AVDMVideo_FilterDec(char *name,
-									AVDMGenericVideoStream *(*create) (AVDMGenericVideoStream *in, void *))
-{
-    UNUSED_ARG(name);
-    UNUSED_ARG(create);
-         //registerFilter(name, create);
-	 //
-}
-//
-// Delete everything that is pending
-void filterCleanUp( void )
-{
-	for(uint32_t i=0;i&lt;nb_active_filter;i++)
-	{
-		  	delete videofilters[i].filter;
-			if(videofilters[i].conf) delete videofilters[i].conf;
-             videofilters[i].conf=NULL;
-             videofilters[i].filter=NULL;
-	}
-   nb_active_filter=0;
-}
-void filterListAll( void )
-{
-const char *name;
-	printf(&quot;\nVideo filters\n&quot;);
-	for(uint32_t i=0;i&lt;allfilters.size();i++)
-	{
-		name=allfilters[i]-&gt;filterName;
-
-		{
-			if(name)
-				printf(&quot;\t%s\n&quot;,name);
-		}
-	}
-
-}
-/**
- *      \fn filterGetTagFromName
- *      \Brief returns the tag associated with a name, invalid otherwise
- */
-VF_FILTERS filterGetTagFromName(const char *inname)
-{
-const char *name;
-int max=allfilters.size();
-	VF_FILTERS filter=VF_INVALID;
-	for(uint32_t i=0;i&lt;max;i++)
-	{
-		name=allfilters[ i]-&gt;filterName;
-		if(1) // allfilters[i]-&gt;tag==VF_PARTIAL_FILTER)
-		{
-			if(name)
-			{
-				if(strlen(name))
-				{
-					if(!strcasecmp(name,inname))
-						return allfilters[ i]-&gt;tag;
-				}
-			}
-		}
-	}
-	return filter;
-}
-/**
- * 	\fn tryLoadingFilterPlugin
- *  \brief try to load the plugin given as argument..
- */
-
-#define Fail(x) {printf(&quot;%s:&quot;#x&quot;\n&quot;,file);goto er;}
-static bool tryLoadingFilterPlugin(const char *file)
-{
-	ADM_vf_pluginLoader *dll=new ADM_vf_pluginLoader(file);
-
-	FilterDescriptor *desc=NULL;
-	FilterDescriptor *myDesc=NULL;
-	if(!dll-&gt;getDesc) Fail(nogetdesc);
-
-	desc=dll-&gt;getDesc();
-	if(!desc) Fail(GetDescriptor);
-	// Check the API version
-	if(desc-&gt;apiVersion!=ADM_FILTER_API_VERSION) Fail(WrongAPI);
-	if(!(desc-&gt;uiFlags &amp; UI_GetCurrentUI())) Fail(WrongUI);
-	// Duplicate it, just in case...
-	myDesc=new FilterDescriptor();
-	memcpy(myDesc,desc,sizeof(*myDesc));
-	// push it !
-	myDesc-&gt;tag=tagCount++;
-	ADM_assert(myDesc-&gt;category&lt;VF_MAX);
-
-    allfilters.push_back (myDesc);
-    filterCategories[myDesc-&gt;category].push_back(myDesc);
-    pluginLoaderQueue.push_back(dll); // Needed for cleanup. FIXME TODO Delete it.
-    printf(&quot;[Filters] Registered filter %s as  %s\n&quot;,file,desc-&gt;name);
-    return true;
-	// Tag it
-	// Fail!
-er:
-	delete dll;
-	return false;
-
-}
-/**
- * 	\fn ADM_vf_loadPlugins
- *  \brief load all video plugins
- */
-uint8_t ADM_vf_loadPlugins(const char *path)
-{
-#define MAX_EXTERNAL_FILTER 100
-
-
-	char *files[MAX_EXTERNAL_FILTER];
-	uint32_t nbFile;
-
-	memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
-	printf(&quot;[ADM_vf_plugin] Scanning directory %s\n&quot;,path);
-
-	if(!buildDirectoryContent(&amp;nbFile, path, files, MAX_EXTERNAL_FILTER, SHARED_LIB_EXT))
-	{
-		printf(&quot;[ADM_vf_plugin] Cannot parse plugin\n&quot;);
-		return 0;
-	}
-
-	for(int i=0;i&lt;nbFile;i++)
-		tryLoadingFilterPlugin(files[i]);
-
-	printf(&quot;[ADM_vf_plugin] Scanning done\n&quot;);
-
-	return 1;
-}
-/**
- * 	\fn registerFilterEx
- *  \brief Register a video filter
- */
-void registerFilterEx(const char *name,const char *filtername,VF_CATEGORY category,
-		AVDMGenericVideoStream *(*create) (AVDMGenericVideoStream *in, CONFcouple *),
-		AVDMGenericVideoStream *(*create_from_script) (AVDMGenericVideoStream *in, int n,Arg *args),
-		const char *descText)
-{
-
-	FilterDescriptor *desc=new FilterDescriptor(tagCount++,filtername,name,
-												descText,
-												category,
-												create,
-												create_from_script);
-
-		ADM_assert(desc-&gt;category&lt;VF_MAX);
-
-        allfilters.push_back (desc);
-        filterCategories[desc-&gt;category].push_back(desc);
-
-        aprintf(&quot;[Filters] Registered filter %s\n&quot;,desc-&gt;name);
-
-
-}
-/************************** Get the last video filter of the chain ***************************
-The reference is 0 in that case !
-************************************************************************************************/
-AVDMGenericVideoStream *getLastVideoFilter(void)
-{
-    aviInfo info;
-
-	video_body-&gt;getVideoInfo(&amp;info);
-
-	lastNb=info.nb_frames;
-	lastStart=0;
-	aprintf(&quot;GetLast : -- LasrNB %lu start %lu \n&quot;,lastNb,lastNb);
-  // sanity check
-  	if(nb_active_filter==0)
-  		{
-  		 		nb_active_filter=1;
-				aprintf(&quot;--preview filter 0\n&quot;);
-				return videofilters[  nb_active_filter-1].filter;
-  		}
- 	updateVideoFilters();
-	return videofilters[  nb_active_filter-1].filter;
-}
-
-/*
-	Return last video filter and rebuild a chain with only the selected frame
-
-*/
-AVDMGenericVideoStream *getLastVideoFilter( uint32_t start, uint32_t nb)
-{
-  // sanity check
-  	lastNb=nb;
-	lastStart=start;
-	aprintf(&quot;GetLast full : -- LasrNB %lu start %lu \n&quot;,lastNb,lastNb);
-  	if(nb_active_filter==0)
-  		{
-  		 		nb_active_filter=1;
-  		 		videofilters[0].filter=  new AVDMVideoStreamNull(video_body,start,nb);
-  		}
-	updateVideoFilters();
-       return videofilters[  nb_active_filter-1].filter;
-}
-
-/********* Returns the first video filters starting from frame xx with nb frames ***************/
-AVDMGenericVideoStream *getFirstVideoFilter( uint32_t start, uint32_t nbFrame)
-{
-  // sanity check
-  	lastNb=nbFrame;
-	lastStart=start;
-	aprintf(&quot;GetFirst full : -- LasrNB %lu start %lu \n&quot;,lastNb,lastNb);
-	updateVideoFilters();
-       return videofilters[  0].filter;
-}
-AVDMGenericVideoStream *getFirstCurrentVideoFilter( void)
-{
-	ADM_assert(nb_active_filter);
- 	return videofilters[  0].filter;
-}
-AVDMGenericVideoStream *getFirstVideoFilter( void)
-{
-  // sanity check
-  aviInfo info;
-
-	video_body-&gt;getVideoInfo(&amp;info);
-	lastNb=info.nb_frames;
-	lastStart=0;
-	aprintf(&quot;GetFirst : -- LasrNB %lu start %lu \n&quot;,lastNb,lastNb);
-	updateVideoFilters();
-       return videofilters[  0].filter;
-
-}
-
-FILTER * getCurrentVideoFilterList (uint32_t * count)
-{
-    if (count)
-        *count = nb_active_filter;
-    return videofilters;
-}
-
-//
-//	Parse the list of active filters, delete them et recreate them with (new ?) configuration
-//
-void updateVideoFilters(void )
-{
-		if(nb_active_filter!=0)
-		{
-			delete videofilters[0].filter;
-			videofilters[0].filter=NULL;
-
-		}
-  		 videofilters[0].filter=  new AVDMVideoStreamNull(video_body,lastStart,lastNb);
-
-  		if(nb_active_filter&lt;=1)
-  		{
-  		 	nb_active_filter=1;
-			aprintf(&quot;--preview filter %d\n&quot;,nb_active_filter-1);
-                        admPreview::updateFilters(videofilters[0].filter,videofilters[nb_active_filter-1].filter);
-  		 	return;
-  		}
-  		// Rebuild other filters
-                for(uint32_t i=1;i&lt;nb_active_filter;i++)
-                {
-                    VF_FILTERS tag;
-                    AVDMGenericVideoStream *old;
-                            old= videofilters[i].filter;
-                            tag=videofilters[i].tag;
-
-                            videofilters[i].filter=filterCreateFromTag(tag,
-                                                videofilters[i].conf,
-                                                videofilters[i-1].filter);
-                          delete old;
-                }
-		aprintf(&quot;--preview filter %d\n&quot;,nb_active_filter-1);
-                ADM_assert(nb_active_filter);
-                admPreview::updateFilters(videofilters[0].filter,videofilters[nb_active_filter-1].filter);
-}
-//
-//	Create a filter from : its tag, its config and an input stream
-//
-
-AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *couple, AVDMGenericVideoStream *in)
-{
-	 AVDMGenericVideoStream *filter;
-
-			ADM_assert(tag!=VF_INVALID);
-
-                        {
-                          for(unsigned int i=0;i&lt;allfilters.size();i++)
-                                  {
-                                          if(tag==allfilters[i]-&gt;tag)
-                                                  {
-                                                          filter=allfilters[i]-&gt;create( in, couple);
-                                                          return filter;
-                                                  }
-                                  }
-                        }
-			ADM_assert(0);
-			return NULL;
-}
-
-/*
-
-
-*/
-const FilterDescriptor * filterGetEntryFromTag (VF_FILTERS tag)
-{
-    ADM_assert(tag!=VF_INVALID);
-    for(unsigned int i=0;i&lt;allfilters.size();i++)
-    {
-        if(tag==allfilters[i]-&gt;tag)
-        {
-            return (allfilters[i]);
-        }
-    }
-    ADM_assert(0);
-    return NULL;
-}
-
-const char  *filterGetNameFromTag(VF_FILTERS tag)
-{
-    const FilterDescriptor * entry = filterGetEntryFromTag (tag);
-    ADM_assert(entry);
-    return entry-&gt;name;
-}
-/*____________________________________
-	Save and load current set of filters
-
-	We save/load the tag that identifies the filter
-	and a raw hex dump of its config
-		+ comment and name in clear text
-	____________________________________
-*/
-
-/*---------------------------------------*/
-
-
-uint8_t 	filterAddScript(VF_FILTERS tag,uint32_t n,Arg *args)
-{
-	// 1- search filter
-	int found=-1;
-	aviInfo info;
-
-	video_body-&gt;getVideoInfo(&amp;info);
-
-	for(unsigned int i=0;i&lt;allfilters.size();i++)
-	{
-		if(tag==allfilters[i]-&gt;tag)
-		{
-			if(nb_active_filter&lt;1)
-			{
-  		 		nb_active_filter=1;
-  		 		videofilters[0].filter=  new AVDMVideoStreamNull(video_body,0,info.nb_frames);
-			}
-			AVDMGenericVideoStream *filter=NULL;
-			CONFcouple *setup=NULL;
-			if(!allfilters[i]-&gt;create_from_script)
-			{
-				printf(&quot;That filter cannot be created from script\n&quot;);
-				return 0;
-			}
-			filter=allfilters[i]-&gt;create_from_script(videofilters[nb_active_filter-1].filter,n-1,&amp;(args[1]));
-			if(!filter) return 0;
-			videofilters[nb_active_filter].filter=filter;
-			videofilters[nb_active_filter].tag=tag;
-			filter-&gt;getCoupledConf(&amp;setup);
-			videofilters[nb_active_filter].conf=setup;
-			nb_active_filter++;
-			return 1;
-		}
-	}
-	printf(&quot;Tag not found:%d\n&quot;,tag);
-	return 0;
-}
-
-void filterSaveScriptJS(FILE *f)
-{
-                for(int i=1;i&lt;nb_active_filter;i++)
-                {
-                        VF_FILTERS tag=videofilters[i].tag;
-                        qfprintf(f,&quot;app.video.addFilter(&quot;);
-                        for(unsigned int j=0;j&lt;allfilters.size();j++)
-                                {
-                                        if(tag==allfilters[j]-&gt;tag)
-                                        {
-                                                qfprintf(f,&quot;\&quot;%s\&quot;&quot;,allfilters[j]-&gt;filterName);
-                                                break;
-                                        }
-                                }
-                        // get args
-                        CONFcouple *couple;
-                        char *arg,*value,*filtered=NULL;
-                        if(videofilters[i].filter-&gt;getCoupledConf( &amp;couple))
-                        {
-                                for(int j=0;j&lt;couple-&gt;getNumber();j++)
-                                {
-                                         couple-&gt;getEntry(j, &amp;arg,&amp;value);
-                                        // Filter out backslash
-                                         filtered=ADM_escape((ADM_filename *)value);
-                                         qfprintf(f,&quot;,\&quot;%s=%s\&quot;&quot;,arg,filtered);
-                                         if(filtered) delete [] filtered ;
-                                         filtered=NULL;
-                                }
-                                delete couple;
-                        }
-                        qfprintf(f,&quot;);\n&quot;);
-
-                }
-
-}
-#endif
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_autoFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_autoFilter.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_autoFilter.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,94 +0,0 @@
-
-/***************************************************************************
-    \fn filter_autoFilter
-    \brief Build aut8omatically addborder &amp; resize filter.
-    copyright            : (C) 200 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-
-#include &quot;DIA_coreToolkit.h&quot;
-
-
-extern uint32_t nb_active_filter;
-extern FILTER  videofilters[VF_MAX_FILTER];
-extern AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *couple, AVDMGenericVideoStream *in);
-//#include &quot;ADM_video/ADM_vidCommonFilter.h&quot;
-//BUILD_CREATE(crop_create,AVDMVideoStreamCrop);
-
-/**
- *      \fn insertFilter
- *      \brief Create filter
- */
-static AVDMGenericVideoStream *insertFilter(AVDMGenericVideoStream *in,VF_FILTERS tag, CONFcouple *conf)
-{
-  
-  AVDMGenericVideoStream *filter;
-   
-  filter=filterCreateFromTag(tag,conf, in) ;
-  if(!filter)
-    {
-      GUI_Error_HIG(&quot;Filter&quot;,&quot;Cannot create filter.\nMake sure your plugins are properly installed.\n I might crash soon.&quot;);
-      return NULL;
-    }
-  return filter;
-}
-/**
- *      \fn create_addBorder
- * 
- */
-AVDMGenericVideoStream *create_addBorder(VF_FILTERS *tag,AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2)
-{
-  VF_FILTERS filterTag=VF_INVALID;
-  
-  filterTag=filterGetTagFromName(&quot;addblack&quot;);
-  if(filterTag==VF_INVALID)
-    {
-        GUI_Error_HIG(&quot;Border&quot;,&quot;The filter addBorder cannot be found.\nMake sure your plugins are properly installed.&quot;);
-        return NULL;
-    }
-    // Create confcouples
-  CONFcouple couple(4);
-    couple.setCouple(&quot;left&quot;,x);
-    couple.setCouple(&quot;right&quot;,x2);
-    couple.setCouple(&quot;top&quot;,y);
-    couple.setCouple(&quot;bottom&quot;,y2);
-    *tag=filterTag;
-    return insertFilter(in,filterTag,&amp;couple);
-}
-
-/**
- *      \fn createResizeFromParam
- *      \brief Create &amp; instert a resize filter
- */
-AVDMGenericVideoStream *createResizeFromParam(VF_FILTERS *tag,AVDMGenericVideoStream*in, unsigned int a, unsigned int b)
-{
-  VF_FILTERS filterTag=VF_INVALID;
-   
-   filterTag=filterGetTagFromName(&quot;mpresize&quot;);
-   if(filterTag==VF_INVALID)
-     {
-         GUI_Error_HIG(&quot;Resize&quot;,&quot;The filter resize cannot be found.\nMake sure your plugins are properly installed.&quot;);
-         return NULL;
-     }
-     // Create confcouples
-   CONFcouple couple(3);
-     couple.setCouple(&quot;w&quot;,a);
-     couple.setCouple(&quot;h&quot;,b);
-     couple.setCouple(&quot;algo&quot;,1);
-     *tag=filterTag;
-     return insertFilter(in,filterTag,&amp;couple);     
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,63 +0,0 @@
-/***************************************************************************
-                          filter_declaration.cpp  -  description
-
-                          Declare filters that are statically linked to avidemux.
-                          Usually it is to be avoided and better to use dynamic filter.
-
-                             -------------------
-
-    copyright            : (C) 2008 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-
-
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-
-#define FILTERDEC_create(x) extern   AVDMGenericVideoStream *x(AVDMGenericVideoStream *in, CONFcouple *param)
-#define FILTERDEC_createFromScript(x) extern   AVDMGenericVideoStream *x(AVDMGenericVideoStream *in, int n,Arg *args)
-
-#define REGISTERX(z,a,b,c,d,e,f,g) {\
-			FILTERDEC_create(f);\
-			FILTERDEC_createFromScript(g);\
-			registerFilterEx((const char*)a,(const char *)b,z,f,g,(const char *)c);\
-}
-
-void registerVideoFilters( void )
-{
-printf(&quot;\n Registering Internal Filters\n&quot;);
-printf(  &quot;******************************\n&quot;);
-
-
-#if BAZOOKA
-        REGISTERX(VF_SUBTITLE,&quot;vobsub&quot;,QT_TR_NOOP(&quot;VobSub&quot;),QT_TR_NOOP(&quot;Embed VobSub subtitles into picture.&quot;),VF_VOBSUB,1,vobsub_create,vobsub_script);
-        REGISTERX(VF_SUBTITLE,&quot;dvbsub&quot;,QT_TR_NOOP(&quot;DVB sub&quot;),QT_TR_NOOP(&quot;Embed DVB-T subtitle.&quot;),VF_DVBSUB,1,dvbsub_create,dvbsub_script);
-#endif
-        //*********************
-#if 0
-	REGISTERX(VF_MISC, &quot;computeaverage&quot;,QT_TR_NOOP(&quot;Compute Average&quot;),QT_TR_NOOP(&quot;Compute average luma value for each pixel throughout all frames, and save to file&quot;),VF_COMPUTEAVERAGE,1,computeaverage_create,computeaverage_script);
-	REGISTERX(VF_MISC, &quot;threshold&quot;,QT_TR_NOOP(&quot;Threshold&quot;),QT_TR_NOOP(&quot;Force too-bright/too-dim pixels to 0 and the rest to 255 or vice-versa&quot;),VF_THRESHOLD,1,threshold_create,threshold_script);
-	REGISTERX(&quot;particlelist&quot;,QT_TR_NOOP(&quot;Particle List&quot;),QT_TR_NOOP(&quot;Identify 'particles' (groups of pixels)&quot;),VF_PARTICLELIST,1,particle_create,particle_script);
-	REGISTERX(&quot;eraser&quot;,QT_TR_NOOP(&quot;Eraser&quot;),QT_TR_NOOP(&quot;\&quot;Erase\&quot; arbitrary areas of each frame&quot;),VF_ERASER,1,eraser_create,eraser_script);
-	REGISTERX(&quot;swissarmyknife&quot;,QT_TR_NOOP(&quot;Swiss Army Knife&quot;),QT_TR_NOOP(&quot;Apply operation like P'=P*A, P-A, P+A, etc. using a convolution, rolling average, image from file, or constant&quot;),VF_SWISSARMYKNIFE,1,swissarmyknife_create,swissarmyknife_script);
-#endif
-// Misc filter, internal only
-//	REGISTERX(VF_MISC,&quot;partial&quot;,QT_TR_NOOP(&quot;Partial&quot;),&quot;&quot;,VF_PARTIAL,0,partial_create,partial_script);
-//	REGISTERX(VF_MISC,&quot;framenum&quot;,QT_TR_NOOP(&quot;Add Framenumber&quot;),QT_TR_NOOP(&quot;Print frame number directly in image&quot;),VF_FRAMENUM,1,number_create,number_script);
- printf(&quot;\n&quot;);
-}
-
-
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,304 +0,0 @@
-/***************************************************************************
-                          filter_saveload.cpp  -  description
-                             -------------------
-	Save/load filter
-
-    begin                : Wed Apr 12 2003
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#define ADM_LEGACY_PROGGY
-
-#include &quot;ADM_default.h&quot;
-#include &lt;libxml/tree.h&gt;
-#include &lt;libxml/parser.h&gt;
-#include &quot;fourcc.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;ADM_quota.h&quot;
-
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-//#include &quot;ADM_video/ADM_videoNull.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-//#include &quot;ADM_video/ADM_vidPartial.h&quot;
-#include &quot;avi_vars.h&quot;
-// exported vars
-extern uint32_t nb_active_filter;
-extern FILTER  videofilters[VF_MAX_FILTER];
-
-extern AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *couple, AVDMGenericVideoStream *in);
-extern void filterCleanUp( void );
-
-
-/*
-
-  	Try to rebuild filter from text file
-
-
-*/
-
-static int32_t getIntegerAttribute(xmlNodePtr node, char *name, char *atrname);
-static xmlNodePtr nextByName(xmlNodePtr node,char *name);
-static CONFcouple *buildCouple(uint32_t nb, xmlNodePtr node);
-extern int qxmlSaveFormatFile(const char *filename, xmlDocPtr cur, int format);
-/**
-	Xml Read/write ConfCouple from files
-*/
-void filterSaveXml(const char *docname)
-{
-	filterSaveXml(docname,0);
-}
-
-void filterSaveXml(const char *docname,uint8_t silent)
-{
- xmlDocPtr xdoc;
- xmlNodePtr node;
- xmlAttrPtr attr;
- char tmpstring[1024];
-VF_FILTERS tag;
-int max;
-		UNUSED_ARG(silent);
-		if( ! (xdoc = xmlNewDoc((const xmlChar *)&quot;1.0&quot;)) ) {printf(&quot;Problem creating xml doc\n&quot;);	return ;}
-		if( ! (xdoc-&gt;children = xmlNewNode(NULL,(xmlChar *)&quot;filters&quot;)) )
-			{
-				xmlFreeDoc(xdoc);
-				xdoc = NULL;
-				return ;
-			}
-		// we add # of filteras as attribute to the first children
-		max=nb_active_filter;
-		if(max) max--;
-		sprintf(tmpstring,&quot;%d&quot;,max);
-		attr=xmlNewProp(xdoc-&gt;children,(xmlChar *)&quot;FilterNumber&quot;,(xmlChar *)tmpstring);
-		if(max)
-		for(uint32_t curFilter=1;curFilter&lt;nb_active_filter;curFilter++)
-		{
-			// for each filter we create a new node
-
-			node= xmlNewChild(xdoc-&gt;children,NULL,(xmlChar *)&quot;Filter&quot;,NULL );
-
-			tag=videofilters[curFilter].tag;
-
-			// and fill-up some informations
-			sprintf(tmpstring,&quot;%d&quot;,tag);
-			attr=xmlNewProp(node,(xmlChar *)&quot;Tag&quot;,(xmlChar *)tmpstring);
-
-			attr=xmlNewProp(node,(xmlChar *)&quot;Conf&quot;,(xmlChar *)videofilters[curFilter].filter-&gt;printConf());
-
-			// now we create a child containing the config
-			CONFcouple *setup;
-
-			if( videofilters[curFilter].filter-&gt;getCoupledConf(&amp;setup))
-			{
-				// we create a new child parameters with # of parameter as attribute
-				 xmlNodePtr nodeConf; //,tmpnode;
-// 				 xmlAttrPtr attrConf;
-
-
-				 char *nm,*val;
-
-					nodeConf= xmlNewChild(node,NULL,(xmlChar *)&quot;Parameters&quot;,NULL );
-					sprintf(tmpstring,&quot;%&quot;LU&quot;&quot;,setup-&gt;getNumber());
-					xmlNewProp(nodeConf,(xmlChar *)&quot;Number&quot;,(xmlChar *)tmpstring);
-
-					// and write each attribute
-					for(uint32_t i=0;i&lt;setup-&gt;getNumber();i++)
-					{
-						ADM_assert(setup-&gt;getEntry(i,&amp;nm,&amp;val));
-						xmlNewChild(nodeConf,NULL,(xmlChar *)nm,(xmlChar *)val );
-					}
-				delete setup;
-			}
-
-		}
-
-		xmlSetDocCompressMode(xdoc,0);  // we want pure text
-		qxmlSaveFormatFile(docname,xdoc,1);
-		xmlFreeDoc(xdoc);
-	return ;
-}
-void filterLoadXml(const char *docname)
-{
-	filterLoadXml(docname,0);
-}
-
-int filterLoadXml(const char *docname,uint8_t silent)
-{
-#if 0
- xmlDocPtr xdoc;
- xmlNodePtr node,subnode;
-int32_t nb_filters,itag;
-CONFcouple *couple;
-//uint16_t s16;
-			UNUSED_ARG(silent);
-			xdoc=xmlParseFile(docname);
-			if(!xdoc)
-				{
-                                  GUI_Error_HIG(QT_TR_NOOP(&quot;Problem reading XML filters&quot;), NULL);
-					return 0;
-				}
-			node=xdoc-&gt;children;
-			nb_filters=getIntegerAttribute(node,(  char *)&quot;filters&quot;,(  char *)&quot;FilterNumber&quot;);
-			if(nb_filters==-1)
-					{
-							xmlFreeDoc(xdoc);
-                                                        GUI_Error_HIG(QT_TR_NOOP(&quot;No filter found&quot;), NULL);
-							return 0;
-					}
-
-			if(1&lt;nb_active_filter)
-			{
-					  filterCleanUp();
-			}
-
-			// if there is no active filter
-			// Create at least the editor output one
-
-			if(!nb_active_filter)
-			{
-                                uint32_t fStart,fEnd;
-
-				// avoid going down
-				aviInfo aviinf;
-  				// now build infos
-  				video_body-&gt;getVideoInfo(&amp;aviinf);
-				fStart=0;
-				fEnd=aviinf.nb_frames-1;
-  		 		videofilters[0].filter=  new AVDMVideoStreamNull(video_body,0,fEnd);
-
-    			}
-			nb_active_filter=1;
-
-			// now ready to add new ones
-
-			subnode=node-&gt;children;
-			for(uint32_t curFilter=0;curFilter&lt;(uint32_t)nb_filters;curFilter++)
-			{
-				// lookup next filter_saveload
-				subnode=nextByName(subnode ,(char *)&quot;Filter&quot;);
-				if(!node)
-					{
-                                          GUI_Error_HIG(QT_TR_NOOP(&quot;Could not find a filter&quot;), NULL);
-						return 0;
-					}
-
-				itag=getIntegerAttribute(subnode,(char *)&quot;Filter&quot;,(char *)&quot;Tag&quot;);
-				if(itag==-1)
-					{
-							xmlFreeDoc(xdoc);
-                                                        GUI_Error_HIG(QT_TR_NOOP(&quot;No tag found&quot;), NULL);
-							return 0;
-					}
-				// now we got the tag
-				printf(&quot;\n %&quot;LU&quot; tag \n&quot;,itag);
-
-				// and we can build a CONFCouple if necessary
-				xmlNodePtr conf;
-				conf=subnode-&gt;children;
-				conf=nextByName(conf ,(char *)&quot;Parameters&quot;);
-				if(!conf)
-					{ // no paramaters needed
-						couple=NULL;
-					}
-				else
-					{
-						int32_t args=getIntegerAttribute(conf,(char *)&quot;Parameters&quot;,(char *)&quot;Number&quot;);
-			//			printf(&quot;\n ** needs %d param :\n&quot;,args);
-
-						conf=conf-&gt;children;
-						ADM_assert(conf);
-						ADM_assert(args);
-						couple=buildCouple(args,conf);
-
-					}
-
-				// once we have tag and CONFcouple we can build the filter
-			//	if(couple) couple-&gt;dump();
-				videofilters[nb_active_filter].filter= filterCreateFromTag( (VF_FILTERS)itag,
-													couple,
-													videofilters[nb_active_filter-1].filter);
-				videofilters[nb_active_filter].tag=(VF_FILTERS)itag;
-				videofilters[nb_active_filter].conf=couple;;
-				nb_active_filter++;
-
-
-				couple=NULL;
-				// next filter please!
-				subnode=subnode-&gt;next;
-			}
-			printf(&quot;\n found : %&quot;LU&quot; filters\n&quot;,nb_filters);
-	xmlFreeDoc(xdoc);
-#endif
-	return 1;
-}
-CONFcouple *buildCouple(uint32_t nb, xmlNodePtr node)
-{
-char *val,*nm;
-	CONFcouple *couple=new CONFcouple(nb);
-	while(node)
-	{
-		nm=(char *)node-&gt;name;
-		if(!xmlStrcmp((xmlChar *)nm,(xmlChar *)&quot;text&quot;))
-			{
-				node=node-&gt;next;
-			 	continue;
-			 }
-		val=(char *)xmlNodeGetContent(node);
-
-		ADM_assert(val);
-		ADM_assert(couple-&gt;setCouple(nm,val));
-	//	printf(&quot;\n --&gt; :%s: %s \n&quot;,nm,val);
-		nb--;
-		node=node-&gt;next;
-
-	};
-	ADM_assert(nb==0);
-	return couple;
-
-}
-xmlNodePtr nextByName(xmlNodePtr node,char *name)
-{
-// lookup next filter_saveload
-				if(!node) return NULL;
-				while(1)
-				{
-				//	printf(&quot;\n %d %s\n&quot;,curFilter,subnode-&gt;name);
-					if(!xmlStrcmp(node-&gt;name,(const xmlChar *)name)) break;
-					node=node-&gt;next;
-					if(!node)
-					{
-                                          GUI_Error_HIG(QT_TR_NOOP(&quot;Node not found&quot;), NULL);
-						return NULL;
-					}
-				};
-				return node;
-
-}
-int32_t getIntegerAttribute(xmlNodePtr node, char *name, char *atrname)
-{
-
-			if(!xmlStrcmp(node-&gt;name,(const xmlChar *)name))
-			{
-				// found
-				char *str;
-				str=(char *)xmlGetProp(node,(const xmlChar *)atrname);
-				return atoi(str);
-			}
-			printf(&quot;\n %s was the name\n&quot;,node-&gt;name);
-
-
-
-	return -1;
-}
-
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,324 +0,0 @@
-/***************************************************************************
-                          vidVCD.cpp  -  description
-                             -------------------
-    begin                : Wed Aug 21 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-	This is a meta filter that adds the needed filter to convert the stream to VCD resolution
-   It computes the parmater and create
-			- A resize filter
-			- A Add border filter
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-#include &quot;fourcc.h&quot;
-#include &quot;avi_vars.h&quot;
-
-
-#include &quot;prototype.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-#include &quot;ADM_filter/vidVCD.h&quot;
-#include &quot;prefs.h&quot;
-#include &quot;ADM_commonUI/DIA_resizeWiz.h&quot;
-#include &quot;ADM_vidMisc.h&quot;
-//___________________________________________
-extern FILTER videofilters[VF_MAX_FILTER];
-extern uint32_t nb_active_filter;
-extern ADM_Composer *video_body;
-
-static uint8_t computeResize (void);
-
-
-RESWIZ_FORMAT format;
-RESWIZ_AR sourceAR, destinationAR;
-static double aspectRatio[2][3]={
-                                                                {1.,0.888888,1.19}, // NTSC 1:1 4:3 16:9
-                                                                {1.,1.066667,1.43} // PAL  1:1 4:3 16:9
-                                                        };
-
-typedef struct 
-{
-        int x1,x2,y1,y2;
-}targetFmt;
-
-
-static targetFmt VCD={352, 352, 288, 240};
-static targetFmt SVCD={480, 720, 576, 480};
-static targetFmt DVD={720, 720, 576, 480};
-static targetFmt DVDHD1={352, 720, 576, 480};
-static targetFmt PSP={480, 480, 272, 272};
-static targetFmt PSPH264={720, 720, 480, 480};
-static targetFmt IPOD={320, 320, 240, 240};
-static targetFmt IPOD640={640, 640, 480, 480};
-
-/* Dont forget to update DIA_resizeWiz if you change something here */
-
-targetFmt *allFormats[]={&amp;VCD,&amp;SVCD,&amp;DVD,&amp;DVDHD1,&amp;PSP,&amp;PSPH264,&amp;IPOD,&amp;IPOD640};
-extern AVDMGenericVideoStream *createResampleFps(AVDMGenericVideoStream *in,uint32_t targetfps1000);
-#define ARME(x) format=RESWIZ_##x
-
-uint8_t setVCD (void)
-{
-
-  ARME (VCD);
-  return computeResize();
-}
-
-/**
-    \fn     setIPOD (void)
-    \brief  Setup  video size &amp; fps to be compatible with IPOD
-*/
-uint8_t setIPOD (void)
-{
-  int8_t r=0;
-ADV_Info *info;
-uint32_t fps1000;
-
-    ARME (IPOD);
-    return computeResize();
-}
-
-/**
-    \fn     setPSP (void)
-    \brief  Setup  video size &amp; fps to be compatible with PSP
-*/
-uint8_t setPSP (void)
-{
-uint8_t r=0;
-ADV_Info *info;
-uint32_t fps1000;
-
-    ARME (PSP);
-    return computeResize();
-}
-/**
-    \fn     setPSPFullRes (void)
-    \brief  Setup  video size &amp; fps to be compatible with PSP FULL SCREEN
-*/
-uint8_t setPSPFullRes (void)
-{
-uint8_t r=0;
-ADV_Info *info;
-uint32_t fps1000;
-
-    ARME (PSP_FULLRES);
-    return computeResize();
-}
-
-uint8_t setSVCD (void)
-{
-
-  ARME (SVCD);
-  return computeResize();
-}
-uint8_t setDVD (void)
-{
-
-  ARME (DVD);
-  return computeResize();
-}
-uint8_t setHalfD1 (void)
-{
-
-  ARME (DVD_HD1);
-  return computeResize();
-}
-
-
-extern AVDMGenericVideoStream *create_addBorder (VF_FILTERS *o, AVDMGenericVideoStream * in,
-						 uint32_t x, uint32_t x2,
-						 uint32_t y, uint32_t y2);
-extern AVDMGenericVideoStream *createResizeFromParam (VF_FILTERS *o, AVDMGenericVideoStream *
-						      in, uint32_t x,
-						      uint32_t y);
-//
-//  Compute the filters, aspect is the reduction factor for h
-//  =1 for VCD/DVD
-//      =2/3 for SVCD
-//------------------------------
-/********************************************************************/
-uint8_t
-computeResize (void)
-{
-
-int targetx,targetxFinal,targetyPAL,targetyNTSC;
-
-  ADV_Info *info;
-  char *inputratio = NULL;
-
-
-  uint8_t res = 0;		/* 1 Pal, 2 NSTC or film */
-  uint32_t targety;
-
-  // scale as if it was 1:1 -&gt; 4:3
-        prefs-&gt;get (FEATURE_SVCDRES_PREFEREDSOURCERATIO, &amp;inputratio);
-        if(inputratio)
-        {
-                if (inputratio &amp;&amp; !strcmp (inputratio, &quot;1:1&quot;)) 
-                        sourceAR=RESWIZ_AR_1_1;
-                if (inputratio &amp;&amp; !strcmp (inputratio, &quot;4:3&quot;)) 
-                        sourceAR=RESWIZ_AR_4_3;
-                if (inputratio &amp;&amp; !strcmp (inputratio, &quot;16:9&quot;)) 
-                        sourceAR=RESWIZ_AR_16_9;
-     
-                ADM_dealloc (inputratio);
-                inputratio = NULL;
-        }
-        
-  
-  if (!DIA_resizeWiz (&amp;format, &amp;sourceAR, &amp;destinationAR))
-    return 0;
-
- targetx=allFormats[format]-&gt;x1;
- targetxFinal=allFormats[format]-&gt;x2;
- targetyPAL=allFormats[format]-&gt;y1;
- targetyNTSC=allFormats[format]-&gt;y2;
-        
-
-  info = getLastVideoFilter (frameStart, frameEnd - frameStart)-&gt;getInfo ();
-
-
-  res = identMovieType (info-&gt;fps1000);
-  //printf(&quot;fps : %lu / %d \n&quot;,info-&gt;fps1000,res);
-  switch (res)
-    {
-    case FRAME_PAL:
-      res = 1;
-      break;
-    case FRAME_NTSC:
-    case FRAME_FILM:
-      res = 2;
-      break;
-    default:
-      res = 0;
-      return 0;
-      break;
-    }
-  if (res == 2)
-    targety = targetyNTSC;
-  else
-    targety = targetyPAL;
-
-
-  double rx, ry;
-  uint32_t newx, newy;
-  uint32_t cropx, cropy;
-  uint32_t original_x, original_y;
-
-
-  original_x = info-&gt;width;
-  original_y = info-&gt;height;
-
-  
-  // scale as if it was 1:1 -&gt; 4:3
-  rx = original_x;
-  switch (res)
-  {
-      case 1:		//PAL
-                rx = rx *aspectRatio[1][sourceAR]/aspectRatio[1][destinationAR];
-                break;
-       case 2:		// NTSC
-                rx = rx * aspectRatio[0][sourceAR]/aspectRatio[0][destinationAR];
-                break;
-   }
-
-  original_x = (uint32_t) floor (rx + 0.49);
-
-  rx = original_x;
-  rx = rx / targetxFinal;
-
-
-  ry = original_y;
-  ry = ry / targety;
-
-  // which do do we compress less ?
-  if (rx &gt; ry)			// resize by X, add border afterward
-    {
-      newx = targetx;
-      ry = original_y;
-      ry = ry / rx;
-      newy = (uint32_t) floor (ry + 0.49);
-      printf (&quot; resize by x\n&quot;);
-
-    }
-  else
-    {
-      newy = targety;
-      rx = original_x;
-      rx = rx / ry;
-      rx *= targetx;
-      rx /= targetxFinal;
-      newx = (uint32_t) floor (rx + 0.49);
-      printf (&quot; resize by y\n&quot;);
-
-    }
-
-  printf (&quot;\n New X x Y = %u x %u\n&quot;, newx, newy);
-
-  // correct odd / even
-
-  newx -= newx % 4;
-  newy -= newy % 4;
-
-  // Now correct crop
-
-
-  cropx = targetx - newx;
-  cropy = targety - newy;
-
-  printf (&quot;\n Resized to : %u x %u, add black border %u x %u&quot;,
-	  newx, newy, cropx, cropy);
-
-  // now build filter
-
-
-// first resize (if needed)
-
-  CONFcouple *couple;
-  if (newx != info-&gt;width || newy != info-&gt;height)
-    {
-      VF_FILTERS rtag=VF_INVALID;
-      videofilters[nb_active_filter].filter =
-	createResizeFromParam (&amp;rtag,getLastVideoFilter (), newx, newy);
-      if(! videofilters[nb_active_filter].filter) return 0;
-
-      videofilters[nb_active_filter].tag = rtag;
-      videofilters[nb_active_filter].filter-&gt;getCoupledConf (&amp;couple);
-      videofilters[nb_active_filter].conf = couple;;
-      nb_active_filter++;
-    }
-// then add crop (if needed)
-
-  if (cropx || cropy)
-    {
-      VF_FILTERS ctag=VF_INVALID;
-      videofilters[nb_active_filter].filter =
-	create_addBorder (&amp;ctag,videofilters[nb_active_filter - 1].filter,
-			  cropx &gt;&gt; 1, cropx &gt;&gt; 1, cropy &gt;&gt; 1, cropy &gt;&gt; 1);
-      if(! videofilters[nb_active_filter].filter) return 0;
-      videofilters[nb_active_filter].tag = ctag;
-      videofilters[nb_active_filter].filter-&gt;getCoupledConf (&amp;couple);
-      videofilters[nb_active_filter].conf = couple;;
-      nb_active_filter++;
-    }
-  return 1;
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,31 +0,0 @@
-/***************************************************************************
-                          vidVCD.h  -  description
-                             -------------------
-    begin                : Wed Aug 21 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-	
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef vidVCD_H
-#define vidVCD_H
-
-uint8_t setSVCD( void );
-uint8_t setVCD( void );
-uint8_t setPSP(void);
-uint8_t setPSPFullRes(void);
-uint8_t setDVD( void );
-uint8_t setHalfD1( void );
-uint8_t setIPOD( void);
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -40,7 +40,7 @@
 #include &quot;ADM_debug.h&quot;
 #include &quot;avidemutils.h&quot;
 
-#include &quot;ADM_filter/vidVCD.h&quot;
+
 #include &quot;ADM_vidMisc.h&quot;
 #include &quot;ADM_coreVideoEncoder.h&quot;
 #include &quot;ADM_audioFilter/include/ADM_audioFilterInterface.h&quot;

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_mpdetc.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_mpdetc.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_mpdetc.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,71 +0,0 @@
-//
-//
-// C++ Interface: ADM_mpdetc
-//
-// Description: 
-//		Port of Mplayer Detc filter (inverse telecine)
-//		Original author &amp; copyright : Richard Felker
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2003
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-typedef struct metrics {
-	/* difference: total, even lines, odd lines */
-	int d, e, o;
-	/* noise: temporal, spacial (current), spacial (past) */
-	int t, s, p;
-};
-
-typedef struct frameinfo {
-	/* peak, relative, mean */
-	 metrics p, r, m;
-};
-
-struct vf_priv_s {
-	struct frameinfo fi[2];
-	uint8_t  *dmpi;
-	int first;
-	int drop, lastdrop, dropnext;
-	int inframes, outframes;
-};
-
-enum {
-	F_DROP,
-	F_MERGE,
-	F_NEXT,
-	F_SHOW
-};
-
-
-
-class  AVDMVideoMPDetc:public AVDMGenericVideoStream
- {
-
- protected:
-
-	struct vf_priv_s	*_param;
-	ADMImage		*_lastFrame;
-        virtual char 		*printConf(void) ;
-	
-	
-		uint8_t 	do_put_image(ADMImage *data);
-		uint32_t	_inFrame;
-		uint32_t	_lastAsked;
-		uint32_t 	_copy;
-	
-
- public:
-  				AVDMVideoMPDetc(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  				~AVDMVideoMPDetc();
-	virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream) 
-								{return 0;};
-
-
- }     ;
-
- 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,513 +0,0 @@
-/***************************************************************************
-                          ADM_vidComputeAverage.cpp  -  compute average of
-                                                     all frames (so it can
-                                                     later be subtracted to
-                                                     remove static
-                                                     background details)
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;DIA_factory.h&quot;
-#include &quot;ADM_vidComputeAverage.h&quot;
-
-static FILTER_PARAM computeAverageParam={5,{&quot;start_frame&quot;,
-                                            &quot;end_frame&quot;,
-                                            &quot;output_file&quot;,
-                                            &quot;bias&quot;,
-                                            &quot;display_mode&quot;}};
-
-// This is a hack to work around the fact that the ctor &amp; dtor get called
-// too often.  The right solution would be to arrange for the filter
-// objects to be constructed and destructed only when really necessary:
-// when a new instance of a filter is added to the list (by the user), it
-// is constructed, and when it is removed from the list (by the user), it
-// is destructed, and anything else is handled by a separate init() or
-// configure() method.  This would allow the objects to maintain a
-// persistent state in a more straightforward way.
-
-ADMVideoComputeAverage::PImap ADMVideoComputeAverage::pimap;
-
-
-SCRIPT_CREATE(computeaverage_script,ADMVideoComputeAverage,computeAverageParam);
-
-BUILD_CREATE(computeaverage_create,ADMVideoComputeAverage);
-
-ADMVideoComputeAverage::ADMVideoComputeAverage(AVDMGenericVideoStream *in,CONFcouple *couples)
-			
-{
-    _in = in;
-    memcpy (&amp;_info, in-&gt;getInfo(), sizeof(_info));
-    _info.encoding = 1;	
-    _uncompressed = new ADMImage (_in-&gt;getInfo()-&gt;width, _in-&gt;getInfo()-&gt;height);
-    ADM_assert(_uncompressed);
-    _param = new COMPUTEAVERAGE_PARAM;
-
-    if (couples)
-    {
-        GET(start_frame);
-        GET(end_frame);
-        char * tmp;
-        GET2(output_file, tmp);
-        GET(bias);
-        GET(display_mode);
-    }
-    else
-    {
-        _param-&gt;start_frame = 0;
-        _param-&gt;end_frame = -1;
-        _param-&gt;output_file = ADM_strdup (&quot;&quot;);
-        _param-&gt;bias = 128;
-        _param-&gt;display_mode = DISPLAYMODE_FRAME_MINUS_AVERAGE;
-    }
-
-    // This is a hack to work around the fact that the ctor &amp; dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    // This explicit check wouldn't be necessary if there was an easier way of
-    // ensuring that we got a 0 pointer when a new map entry was auto-consed
-    // up...
-
-    if (pimap.count (couples) == 0)
-    {
-        myInfo = new PersistentInfo;
-        myInfo-&gt;conf = couples;
-        pimap [couples] = myInfo;
-    }
-    else
-    {
-        myInfo = pimap [couples];
-        if (couples)
-        {
-            if (myInfo-&gt;oldConf == couples)
-            {
-                pimap.erase (myInfo-&gt;conf);
-                myInfo-&gt;conf = myInfo-&gt;oldConf;
-                myInfo-&gt;oldConf = 0;
-            }
-            else
-            {
-                ADM_assert (myInfo-&gt;conf == couples);
-
-                if (myInfo-&gt;oldConf)
-                {
-                    pimap.erase (myInfo-&gt;oldConf);
-                    myInfo-&gt;oldConf = 0;
-                }
-            }
-        }
-    }
-
-    myInfo-&gt;refCount++;
-
-    printf (&quot;ADMVideoComputeAverage ctor (%p, conf = %p), pi = %p, rc now %d\n&quot;,
-            this, couples, myInfo, myInfo-&gt;refCount);
-}
-
-uint8_t	ADMVideoComputeAverage::getCoupledConf (CONFcouple **couples)
-{
-
-    ADM_assert(_param);
-    *couples=new CONFcouple(computeAverageParam.nb);
-
-    // This is a hack to work around the fact that the ctor &amp; dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    printf(&quot;ADMVideoComputeAverage::getCoupledConf(): this = %p, couples = %p, &quot;
-           &quot;oldConf = %p (was %p), pi = %p\n&quot;,
-           this, *couples, myInfo-&gt;conf, myInfo-&gt;oldConf, myInfo);
-
-    if (myInfo-&gt;oldConf)
-        pimap.erase (myInfo-&gt;oldConf);
-    myInfo-&gt;oldConf = myInfo-&gt;conf;
-    myInfo-&gt;conf = *couples;
-    pimap [myInfo-&gt;conf] = myInfo;
-    if (myInfo-&gt;oldConf == 0)
-        pimap.erase (0);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-    CSET(start_frame);
-    CSET(end_frame);
-    CSET(output_file);
-    CSET(bias);
-    CSET(display_mode);
-
-    return 1;
-
-}
-
-uint8_t ADMVideoComputeAverage::configure(AVDMGenericVideoStream *in)
-{
-    UNUSED_ARG(in);
-
-    diaElemInteger start_frame
-        (&amp;(_param-&gt;start_frame),
-         QT_TR_NOOP(&quot;_Start Frame (first frame # to include in average):&quot;),
-         0, 0x7fffffff);
-    diaElemInteger end_frame
-        (&amp;(_param-&gt;end_frame),
-         QT_TR_NOOP(&quot;_End Frame (last frame # to include), -1 = last:&quot;),
-         -1000000, 0x7fffffff);
-    diaElemFile output_file
-        (1, const_cast&lt;char **&gt;(&amp;(_param-&gt;output_file)),
-         QT_TR_NOOP(&quot;_Output File:&quot;), NULL, QT_TR_NOOP(&quot;Select output file&quot;));
-    diaElemSlider bias
-        (&amp;(_param-&gt;bias),
-         QT_TR_NOOP(&quot;_Bias (only for display; use 0 for &quot;
-           &quot;average, 128 for frame minus average):&quot;), -256, +256);
-    diaMenuEntry tDisplayMode [] = {
-        { DISPLAYMODE_FRAME_MINUS_AVERAGE,
-          QT_TR_NOOP(&quot;Current frame minus average so far&quot;), NULL },
-        { DISPLAYMODE_AVERAGE, QT_TR_NOOP(&quot;Average so far&quot;), NULL },
-        { DISPLAYMODE_BLANK,
-          QT_TR_NOOP(&quot;Display nothing (fast for batch processing)&quot;), NULL },
-    };
-    diaElemMenu display_mode
-        (&amp;(_param-&gt;display_mode),
-         QT_TR_NOOP(&quot;Display _Mode:&quot;),
-         sizeof (tDisplayMode) / sizeof (diaMenuEntry), tDisplayMode);
-    diaElem * elems[] = { &amp;start_frame, &amp;end_frame, &amp;output_file,
-                          &amp;bias, &amp;display_mode };
-
-    uint8_t ret = diaFactoryRun(QT_TR_NOOP(&quot;ComputeAverage&quot;), sizeof (elems) / sizeof (diaElem *), elems);
-    return ret;
-	
-}
-
-ADMVideoComputeAverage::~ADMVideoComputeAverage()
-{
-    // This is a hack to work around the fact that the ctor &amp; dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    myInfo-&gt;refCount--;
-    printf (&quot;ADMVideoComputeAverage dtor (%p), conf = %p, pi = %p, rc now %d\n&quot;,
-            this, myInfo-&gt;conf, myInfo, myInfo-&gt;refCount);
-
-    if (myInfo-&gt;oldConf)
-    {
-        pimap.erase (myInfo-&gt;oldConf);
-        myInfo-&gt;oldConf = 0;
-    }
-
-    if (myInfo-&gt;refCount &lt; 1)
-    {
-        pimap.erase (myInfo-&gt;conf);
-        delete myInfo;
-    }
-
-    DELETE(_param);
-    delete  _uncompressed;	
-    _uncompressed=NULL;
-}
-
-char * ADMVideoComputeAverage::printConf (void) 
-{
-    const int CONF_LEN = 512;
-    static char conf[CONF_LEN];
-
-    const char * display = &quot;oops&quot;;
-    if (_param-&gt;display_mode == DISPLAYMODE_AVERAGE)
-        display = &quot;average so far&quot;;
-    else if (_param-&gt;display_mode == DISPLAYMODE_FRAME_MINUS_AVERAGE)
-        display = &quot;current frame minus average so far&quot;;
-    else if (_param-&gt;display_mode == DISPLAYMODE_BLANK)
-        display = &quot;nothing (fast)&quot;;
-
-    snprintf(conf, CONF_LEN, &quot;ComputeAverage: Average of frames %d - %d, &quot;
-             &quot;output to %s, display %s %+d&quot;,
-             _param-&gt;start_frame, _param-&gt;end_frame, _param-&gt;output_file,
-             display, _param-&gt;bias);
-    return conf;
-	
-}
-
-static inline
-uint8_t saturate_pixel (uint32_t pixel)
-{
-    if (pixel &amp; 0xffffff00)
-    {
-        if (int32_t (pixel) &lt; 0)
-            return 0;
-        else // if (pixel &gt; 255)
-            return 255;
-    }
-
-    return pixel;
-}
-
-uint8_t ADMVideoComputeAverage::getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                                       ADMImage *data, uint32_t *flags)
-{
-    if (frame &gt;= _info.nb_frames)
-        return 0;
-
-    int debug = 0;
-
-    int curr_frame = frame + _info.orgFrame;
-    int num_frames = _info.nb_frames + _info.orgFrame;
-
-    int planesize = _info.width * _info.height;
-    uint32_t size = (planesize * 3) &gt;&gt; 1;
-    *len = size;
-			
-    if (!_in-&gt;getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
-        return 0;
-    ADMImage * image = _uncompressed;
-
-    uint32_t start_frame = _param-&gt;start_frame;
-    uint32_t end_frame = _param-&gt;end_frame;
-    if (int32_t (end_frame) &lt; 0)
-        end_frame = int32_t (num_frames) + int32_t (end_frame); // 0-based, thus -1 = last frame
-
-    if (!myInfo-&gt;sums
-        || myInfo-&gt;width != _info.width || myInfo-&gt;height != _info.height
-        || myInfo-&gt;start_frame != start_frame
-        || myInfo-&gt;end_frame != end_frame)
-    {
-        printf (&quot;ADMVideoComputeAverage: resetting; was %p %ux%u, %u..%u\n&quot;,
-                myInfo-&gt;sums, myInfo-&gt;width, myInfo-&gt;height,
-                myInfo-&gt;start_frame, myInfo-&gt;end_frame);
-
-        if (!myInfo-&gt;sums
-            || myInfo-&gt;width != _info.width || myInfo-&gt;height != _info.height)
-        {
-            myInfo-&gt;width = _info.width;
-            myInfo-&gt;height = _info.height;
-            delete[] myInfo-&gt;sums;
-            myInfo-&gt;sums = new uint32_t [planesize];
-        }
-
-        uint32_t pixremaining = planesize + 1;
-        uint32_t * sums = myInfo-&gt;sums + planesize;
-        while (--pixremaining)
-        {
-            *--sums = 0;
-        }
-
-        myInfo-&gt;frame_count = 0;
-        myInfo-&gt;most_recent_frame = -1;
-        myInfo-&gt;start_frame = start_frame;
-        myInfo-&gt;end_frame = end_frame;
-
-        printf (&quot;ADMVideoComputeAverage: reset average; now %p %ux%u, &quot;
-                &quot;%u..%u\n&quot;,
-                myInfo-&gt;sums, myInfo-&gt;width, myInfo-&gt;height,
-                myInfo-&gt;start_frame, myInfo-&gt;end_frame);
-    }
-			
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    uint32_t * sums = myInfo-&gt;sums + planesize;
-    uint32_t pixremaining = planesize + 1;
-    int32_t bias = _param-&gt;bias;
-
-    if (curr_frame &gt;= start_frame &amp;&amp; curr_frame &lt;= end_frame
-        &amp;&amp; curr_frame != myInfo-&gt;most_recent_frame)
-    {
-        uint32_t frame_count = ++(myInfo-&gt;frame_count);
-        uint32_t half_frame_count = frame_count / 2;
-        if (debug &amp; 2)
-            printf (&quot;Including frame %u of %u, now have %u (%u - %u)\n&quot;,
-                    curr_frame, num_frames, frame_count, start_frame, end_frame);
-
-        if (_param-&gt;display_mode == DISPLAYMODE_AVERAGE)
-        {
-            while (--pixremaining)
-            {
-                uint8_t curr = *--currp;
-                uint32_t sum = (*--sums += curr);
-
-                uint32_t avg = (sum + half_frame_count) / frame_count;
-                *--destp = saturate_pixel (avg + bias);
-            }
-        }
-        else if (_param-&gt;display_mode == DISPLAYMODE_FRAME_MINUS_AVERAGE)
-        {
-            while (--pixremaining)
-            {
-                uint8_t curr = *--currp;
-                uint32_t sum = (*--sums += curr);
-
-                uint32_t avg = (sum + half_frame_count) / frame_count;
-                *--destp = saturate_pixel (curr + bias - avg);
-            }
-        }
-        else // if (_param-&gt;display_mode == DISPLAYMODE_BLANK)
-        {
-            while (--pixremaining)
-            {
-                *--sums += *--currp;
-            }
-        }
-
-        myInfo-&gt;most_recent_frame = curr_frame;
-
-        // If we just did the last frame of the specified range, then we need
-        // to write the output file.
-
-        if (curr_frame == end_frame
-            &amp;&amp; frame_count == end_frame - start_frame + 1)
-            write_output_file();
-    }
-    else // frame out of specified range for collecting average
-    {
-        uint32_t frame_count = myInfo-&gt;frame_count;
-        uint32_t half_frame_count = frame_count / 2;
-        if (debug &amp; 2)
-            printf (&quot;Using %u frame(s) (%u - %u) worth of average on frame %u of %u\n&quot;,
-                    frame_count, start_frame, end_frame, curr_frame, num_frames);
-
-        if (frame_count == 0)
-        {
-            // dividing by zero is not a good idea.  Just punt.
-            return 0;
-        }
-        else if (_param-&gt;display_mode == DISPLAYMODE_AVERAGE)
-        {
-            while (--pixremaining)
-            {
-                uint32_t sum = *--sums;
-                uint32_t avg = (sum + half_frame_count) / frame_count;
-                *--destp = saturate_pixel (avg + bias);
-            }
-        }
-        else if (_param-&gt;display_mode == DISPLAYMODE_FRAME_MINUS_AVERAGE)
-        {
-            while (--pixremaining)
-            {
-                uint8_t curr = *--currp;
-                uint32_t sum = *--sums;
-
-                uint32_t avg = (sum + half_frame_count) / frame_count;
-                *--destp = saturate_pixel (curr + bias - avg);
-            }
-        }
-        else if (curr_frame &gt; end_frame)
-        {
-            // nothing more to do
-            return 0;
-        }
-    }
-
-    if (_param-&gt;display_mode != DISPLAYMODE_BLANK)
-    {
-        // HERE: the following two lines do a luma-only-ize
-
-        memset (UPLANE (data), 128, planesize &gt;&gt; 2);
-        memset (VPLANE (data), 128, planesize &gt;&gt; 2);
-    }
-
-    data-&gt;copyInfo(image);
-    return 1;
-}
-
-void ADMVideoComputeAverage::write_output_file () const
-{
-    const char * output_file = _param-&gt;output_file;
-    if (!output_file || !*output_file)
-    {
-        fprintf (stderr, &quot;ADMVideoComputeAverage: Wanted to write output &quot;
-                 &quot;file, but no file has been specified!!\n&quot;);
-        return;
-    }
-
-    FILE * fp = fopen (output_file, &quot;wb&quot;);
-    if (!fp)
-    {
-        perror (output_file);
-        return;
-    }
-
-    uint32_t width = myInfo-&gt;width;
-    uint32_t height = myInfo-&gt;height;
-
-    int pixelcount = width * height;
-    uint32_t * sums = myInfo-&gt;sums;
-    uint32_t pixremaining = pixelcount + 1;
-
-    FileHeader header;
-    memcpy (header.magic, &quot;DGCMimgF&quot;, sizeof (header.magic));
-    header.width = width;
-    header.height = height;
-
-    int nwritten = fwrite (&amp;header, sizeof (FileHeader), 1, fp);
-    if (nwritten != 1)
-    {
-        fprintf (stderr, &quot;Failed to write file header to %s\n&quot;, output_file);
-        perror (output_file);
-        fclose (fp);
-        unlink (output_file);
-        return;
-    }
-
-    uint32_t frame_count = myInfo-&gt;frame_count;
-
-    printf (&quot;frame count = %u\n&quot;, frame_count);
-
-    float minavg = 1000;
-    float maxavg = -1000;
-    while (--pixremaining)
-    {
-        uint32_t sum = *sums++;
-        float avg = float (sum) / frame_count;
-
-        if (avg &lt; minavg)
-            minavg = avg;
-        if (avg &gt; maxavg)
-            maxavg = avg;
-
-        nwritten = fwrite (&amp;avg, sizeof (float), 1, fp);
-        if (nwritten != 1)
-        {
-            fprintf (stderr, &quot;Failed to write pixel %u to %s\n&quot;,
-                     pixelcount - pixremaining + 1, output_file);
-            fflush (stdout);
-            perror (output_file);
-            fclose (fp);
-            unlink (output_file);
-            return;
-        }
-    }
-
-    fprintf (stderr, &quot;Successfully wrote %ux%u = %u floating point pixel &quot;
-             &quot;averages (from %.6f to %.6f) of %u frames to %s\n&quot;,
-             width, height, pixelcount, minavg, maxavg, frame_count,
-             output_file);
-
-    fclose (fp);
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,129 +0,0 @@
-/***************************************************************************
-                          ADM_vidComputeAverage.h  -  compute average of
-                                                     all frames (so it can
-                                                     later be subtracted to
-                                                     remove static
-                                                     background details)
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __COMPUTEAVERAGE__
-#define __COMPUTEAVERAGE__   
-
-#include &lt;map&gt;
-
-
-typedef struct COMPUTEAVERAGE_PARAM
-{
-    int32_t start_frame;
-    int32_t end_frame; // -1 means last frame, -2 = last - 1, ...
-    const char * output_file;
-    int32_t bias;
-    uint32_t display_mode;
-
-} COMPUTEAVERAGE_PARAM;
-
-class  ADMVideoComputeAverage : public AVDMGenericVideoStream
-{
-
-    enum DisplayMode
-    {
-        DISPLAYMODE_INVALID = 0,
-        DISPLAYMODE_FRAME_MINUS_AVERAGE,
-        DISPLAYMODE_AVERAGE,
-        DISPLAYMODE_BLANK,
-        DISPLAYMODE_COUNT
-    };
-
- public:
-
-    struct FileHeader
-    {
-        char magic [8]; // &quot;DGCMimg&quot; + (is_float ? &quot;F&quot; : &quot;8&quot;)
-        uint32_t width;
-        uint32_t height;
-    };
-        
-
- protected:
-
-     // This is a hack to work around the fact that the ctor &amp; dtor get called
-     // too often.  The right solution would be to arrange for the filter
-     // objects to be constructed and destructed only when really necessary:
-     // when a new instance of a filter is added to the list (by the user), it
-     // is constructed, and when it is removed from the list (by the user), it
-     // is destructed, and anything else is handled by a separate init() or
-     // configure() method.  This would allow the objects to maintain a
-     // persistent state in a more straightforward way.
-
-     class PersistentInfo
-     {
-     public:
-         CONFcouple *  conf;
-         CONFcouple *  oldConf;
-         uint32_t      refCount;
-
-         uint32_t *    sums;
-         uint32_t      frame_count;
-         uint32_t      width;
-         uint32_t      height;
-         uint32_t      start_frame;
-         uint32_t      end_frame;
-         uint32_t      most_recent_frame;
-
-         PersistentInfo ()
-             : conf (0),
-               oldConf (0),
-               refCount (0),
-
-               sums (0),
-               frame_count (0),
-               width (0),
-               height (0),
-               start_frame (0),
-               end_frame (0),
-               most_recent_frame (0)
-         {
-         }
-
-        ~PersistentInfo ()
-        {
-            delete [] sums;
-        }
-     };
-
-     typedef std::map &lt;CONFcouple *, PersistentInfo *&gt; PImap;
-     static PImap pimap;
-
-     PersistentInfo * myInfo;
-
-     COMPUTEAVERAGE_PARAM *  _param;
-
-     void write_output_file () const;
-
- public:
- 		
-     ADMVideoComputeAverage (AVDMGenericVideoStream *in, CONFcouple *setup);
-
-     ~ADMVideoComputeAverage();
-
-     virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                            ADMImage *data, uint32_t *flags);
-
-     virtual uint8_t configure (AVDMGenericVideoStream *instream);
-     virtual char * printConf (void);
-     virtual uint8_t getCoupledConf (CONFcouple **couples);
-							
- };
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,447 +0,0 @@
-/***************************************************************************
-                         DVB-T subtitle filter
-    
-    This is a dummy DVB-T Filter and should be only used through OCR
-    The filter exists just for debugging purpose and should not be exposed
-    to end user at all.
-    
-    copyright            : (C) 2007 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &quot;ADM_lavcodec.h&quot;
-#include &quot;ADM_assert.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_videoFilterDynamic.h&quot;
-#include &quot;fourcc.h&quot;
-
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_colorspace.h&quot;
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_vidDvbSub.h&quot;
-static FILTER_PARAM assParam={7,
-        { /* float */ &quot;font_scale&quot;,
-          /*float*/ &quot;line_spacing&quot;,
-          /* int */ &quot;top_margin&quot;,
-          /* int */ &quot;bottom_margin&quot;,
-          /* bool */ &quot;extract_embedded_fonts&quot;,
-          /* ADM_filename */ &quot;fonts_dir&quot;,
-          /* ADM_filename */ &quot;subfile&quot; }};
-
-SCRIPT_CREATE(dvbsub_script,ADMVideoSubDVB,assParam);
-BUILD_CREATE(dvbsub_create,ADMVideoSubDVB);
-
-char *ADMVideoSubDVB::printConf() 
-{
-    ADM_FILTER_DECLARE_CONF(&quot; DVB Subtitle &quot;);
-      
-      
-}
-
-
-uint8_t ADMVideoSubDVB::configure(AVDMGenericVideoStream * instream)
-{
-  
-   return 1;
-}
-//_______________________________________________________________
-
-ADMVideoSubDVB::ADMVideoSubDVB(const char *ts, uint32_t pid,uint32_t w, uint32_t h) 
-{
-        _in=NULL;		
-        memset(&amp;_info,0,sizeof(_info));
-        _info.width=w;
-        _info.height=h;
-        _inited=0;
-        
-      
-        _uncompressed=new ADMImage(getInfo()-&gt;width,getInfo()-&gt;height);
-        ADM_assert(_uncompressed);
-        _info.encoding=1;
-        
-        decoder=new decoderFFSubs(1);
-        binary=new ADMCompressedImage;
-        binary-&gt;data=readBuffer+2;
-        
-        MPEG_TRACK track;
-        track.pid=pid;
-
-        
-        demuxer=new dmx_demuxerTS(1,&amp;track,0,DMX_MPG_TS);
-      
-
-      
-}
-//_______________________________________________________________
-
-ADMVideoSubDVB::ADMVideoSubDVB(AVDMGenericVideoStream *in, CONFcouple *conf) 
-{
-        _in=in;		
-        memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-        
-        
-      
-        _uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-        ADM_assert(_uncompressed);
-        _info.encoding=1;
-        
-        decoder=new decoderFFSubs(1);
-        binary=new ADMCompressedImage;
-        binary-&gt;data=readBuffer+2;
-        
-        MPEG_TRACK track;
-        track.pid=0x96;
-
-        
-        demuxer=new dmx_demuxerTS(1,&amp;track,0,DMX_MPG_TS);
-        _inited=init(NULL);
-
-      
-}
-// **********************************
-uint8_t ADMVideoSubDVB::init(const char  *tsFileName)
-{
-	// For test only!
-#ifdef ADM_DEBUG
-	if(!tsFileName) tsFileName=&quot;/capture/grey/Grey_anatomy_2007_05_22_Avec_Le_Temp.mpg&quot;;
-#endif
-    // First create our demuxer
-     
-     if(!demuxer-&gt;open(tsFileName))
-     {
-        printf(&quot;Cannot open TS\n&quot;);
-        return 0; 
-     }
-      memset(&amp;sub,0,sizeof(sub));
-      _inited=1;
-     return 1;
-} 
-
-//*******************************************
-ADMVideoSubDVB::~ADMVideoSubDVB() 
-{
-      if(_uncompressed) DELETE(_uncompressed);
-      if(decoder) delete decoder;
-      if(binary) delete binary;
-      if(demuxer) delete demuxer;
-      decoder=NULL;
-      binary=NULL;
-      demuxer=NULL;
-   
-}
-//*******************************************
-#define _r(c)  ((c)&amp;0xff)
-#define _b(c)  (((c)&gt;&gt;16)&amp;0xFF)
-#define _g(c)  (((c)&gt;&gt;8)&amp;0xFF)
-#define _a(c)  ((c)&gt;&gt;24)
-#define rgba2y(c)  ( (( 263*_r(c)  + 516*_g(c) + 100*_b(c)) &gt;&gt; 10) + 16  )
-#define rgba2u(c)  ( (( 450*_r(c) - 376*_g(c) -  73*_b(c)) &gt;&gt; 10) + 128 )
-#define rgba2v(c)  ( ((-152*_r(c) - 298*_g(c) + 450*_b(c)) &gt;&gt; 10) + 128 )
-
-uint8_t ADMVideoSubDVB::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data, uint32_t *flags) 
-{
-uint8_t *org=NULL;
-
-      // Read the original PIC
-        
-        if(!_in-&gt;getFrameNumberNoAlloc(frame, len, data, flags))
-                return 0;
-
-        if(!_inited) 
-        {
-          return 0; 
-        }
-        // Read the compressed DVB....
-        
-        uint32_t packetLen,dts,pts;
-          if(!demuxer-&gt;readPes(readBuffer,&amp;packetLen, &amp;dts,&amp;pts)) return 1;
-          binary-&gt;dataLength=packetLen-3; // -2 for stream iD, -1 for ????
-          if(packetLen&lt;=5) return 1;
-          // And decompress...
-          decoder-&gt;uncompress(binary,&amp;sub);
-            
-          // Process All rectangles
-          
-            printf(&quot;Found %d rects to process\n&quot;,sub.num_rects);
-            for(int i=0;i&lt;sub.num_rects;i++)
-            {
-              AVSubtitleRect *r=&amp;(sub.rects[i]);
-              // First convert RGB to Y+ALPHA
-              for(int col=0;col&lt;r-&gt;nb_colors;col++)
-              {
-                    // Color is RGB, convert to YUV
-                    uint32_t y,u,v,a;
-                    uint32_t rgb=r-&gt;rgba_palette[col];
-                
-                          y=rgba2y(rgb);
-                          u=rgba2u(rgb)&amp;0xff;
-                          v=rgba2v(rgb)&amp;0xff;
-                          a=_a(rgb);
-                          r-&gt;rgba_palette[col]=y+(u&lt;&lt;8)+(v&lt;&lt;16)+(a&lt;&lt;24);
-                          printf(&quot;Color %d, alpha %u luma %u rgb:%x\n&quot;,col,a,y,rgb);
-              }
-              // Palette is ready, display !
-              if(r-&gt;x&gt;_info.width || r-&gt;y&gt;_info.height)
-              {
-                  printf(&quot;[DVBSUB]Box is outside image\n&quot;);
-                  goto _skip;
-              }
-#if 0
-                  printf(&quot;x :%d\n&quot;,r-&gt;x);
-                  printf(&quot;y :%d\n&quot;,r-&gt;y);
-                  printf(&quot;w :%d\n&quot;,r-&gt;w);
-                  printf(&quot;h :%d\n&quot;,r-&gt;h);
-#endif
-                  {
-                      uint32_t clipW,clipH;
-                      
-                      clipW=FFMIN(_info.width,r-&gt;x+r-&gt;w)-r-&gt;x;
-                      clipH=FFMIN(_info.height,r-&gt;y+r-&gt;h)-r-&gt;y;
-                      
-                      ADMImage image(r-&gt;w,r-&gt;h);
-                      ADMImage imageU(r-&gt;w,r-&gt;h);
-                      ADMImage imageV(r-&gt;w,r-&gt;h);
-                      ADMImage alphaImage(r-&gt;w,r-&gt;h);
-                      
-                      uint8_t *ptr=image.data;
-                      uint8_t *ptrU=imageU.data;
-                      uint8_t *ptrV=imageV.data;
-                      uint8_t *ptrAlpha=alphaImage.data;
-                      uint8_t *in=r-&gt;bitmap;
-                      for(int yy=0;yy&lt;r-&gt;h;yy++)
-                      {
-                          for(int xx=0;xx&lt;r-&gt;w;xx++)
-                          {
-                            uint32_t alpha,valout;
-                            uint32_t val=*in++;
-                            
-                                  val=r-&gt;rgba_palette[val];
-                                  
-                                  *ptrAlpha++=(val&gt;&gt;24)&amp;0xff;
-                                  *ptr++=(val&amp;0xff);;
-                                  *ptrU++=(val&gt;&gt;8)&amp;0xff;
-                                  *ptrV++=(val&gt;&gt;16)&amp;0xff;
-                          }
-                      }
-              
-                      // Merge Luma
-                      for(int yy=0;yy&lt;clipH;yy++)
-                      {
-                          org=data-&gt;data+(yy+r-&gt;y)*_info.width+r-&gt;x;
-                          
-                          ptrAlpha=alphaImage.data+yy*r-&gt;w;
-                          ptr=image.data+yy*r-&gt;w;
-                        
-                          for(int xx=0;xx&lt;clipW;xx++)
-                          {
-                            uint32_t val,before,alpha;
-                            
-                                  before=*org;
-                                  val=*ptr++;
-                                  alpha=*ptrAlpha++;
-                                  
-                                  val=val*alpha+(255-alpha)*before;
-                                  val&gt;&gt;=8;
-                                  *org++=val;
-                          }
-                      }
-                      // Shrink alpha  &amp; u &amp; v
-                     alphaImage.LumaReduceBy2();
-                     imageU.LumaReduceBy2();
-                     imageV.LumaReduceBy2();
-                     r-&gt;x&gt;&gt;=1;
-                     r-&gt;y&gt;&gt;=1;
-                     r-&gt;w&gt;&gt;=1;
-                     r-&gt;h&gt;&gt;=1;
-                     clipH&gt;&gt;=1;
-                     clipW&gt;&gt;=1;
-                     
-                     
-                      uint8_t *orgU=(uint8_t *)(UPLANE(data)+(r-&gt;y)*(_info.width&gt;&gt;1)+(r-&gt;x));
-                      uint8_t *orgV=(uint8_t *)(VPLANE(data)+(r-&gt;y)*(_info.width&gt;&gt;1)+(r-&gt;x));
-#if 1
-                      // Merge
-                      for(int yy=0;yy&lt;clipH;yy++)
-                      {
-                          ptrAlpha=alphaImage.data+yy*(r-&gt;w);
-                          ptrU=imageU.data+yy*r-&gt;w;
-                          ptrV=imageV.data+yy*r-&gt;w;
-                        
-                          for(int xx=0;xx&lt;clipW;xx++)
-                          {
-                            uint32_t val,valU,valV,before,alpha;
-                            uint32_t newU,newV;
-                                  
-                                  newU=*ptrU++;
-                                  newV=*ptrV++;  // New color
-                                 
-                                   newU=(newU+newV)/2;
-                                   newV=newU;
-                                  
-                                  alpha=*ptrAlpha++;
-                                  
-                                  before=*orgU; // old color
-                                  valU=newU*alpha+(255-alpha)*before;
-                                  
-                                  before=*orgV;
-                                  valV=newV*alpha+(255-alpha)*before;
-                                  
-                                  valU=valU&gt;&gt;8;
-                                  valV=valV&gt;&gt;8;
-                                  
-                                  *orgU++=valU;
-                                  *orgV++=valV;
-                          }
-                      }
-#endif
-              }
-               // Delete palette &amp; data
-_skip:
-               av_free(r-&gt;rgba_palette);
-               av_free(r-&gt;bitmap);
-            } // Next rec..
-            memset(&amp;sub,0,sizeof(sub));
-        
-        return 1;
-}
-/**
- * \fn 			getNextBitmap
- * \brief 		Decode a bitmap and store the result (luma only) in the caller supplied vobSubBitmap
- * @param data  (in) Vobsubbitmap to put image in
- * @param pts   Raw pts in 90 Khz Tick
- * @return      0 on failure, 1 on success 
- * */
-uint8_t ADMVideoSubDVB::getNextBitmap(vobSubBitmap *data,uint32_t *pts) 
-{
-uint8_t *org=NULL;
-
-        uint32_t packetLen,dts; //,pts;
-        // Clear incoming picture
-        	data-&gt;clear();
-        
-          if(!demuxer-&gt;readPes(readBuffer,&amp;packetLen, &amp;dts,pts)) return 0;
-          binary-&gt;dataLength=packetLen-3; // -2 for stream iD, -1 for ????
-          if(packetLen&lt;=5) return 1;
-          // And decompress...
-          decoder-&gt;uncompress(binary,&amp;sub);
-            
-          // Process All rectangles
-          
-            printf(&quot;Found %d rects to process\n&quot;,sub.num_rects);
-            for(int i=0;i&lt;sub.num_rects;i++)
-            {
-              AVSubtitleRect *r=&amp;(sub.rects[i]);
-              // First convert RGB to Y+ALPHA
-              for(int col=0;col&lt;r-&gt;nb_colors;col++)
-              {
-                    // Color is RGB, convert to YUV
-                    uint32_t y,u,v,a;
-                    uint32_t rgb=r-&gt;rgba_palette[col];
-                
-                          y=rgba2y(rgb);
-                          u=rgba2u(rgb)&amp;0xff;
-                          v=rgba2v(rgb)&amp;0xff;
-                          a=_a(rgb);
-                          r-&gt;rgba_palette[col]=y+(u&lt;&lt;8)+(v&lt;&lt;16)+(a&lt;&lt;24);
-#if 0
-                          printf(&quot;Color %d, alpha %u luma %u rgb:%x\n&quot;,col,a,y,rgb);
-#endif
-              }
-              // Palette is ready, display !
-              if(r-&gt;x&gt;_info.width || r-&gt;y&gt;_info.height)
-              {
-                  printf(&quot;[DVBSUB]Box is outside image\n&quot;);
-                  goto _skipX;
-              }
-#if 0
-                  printf(&quot;x :%d\n&quot;,r-&gt;x);
-                  printf(&quot;y :%d\n&quot;,r-&gt;y);
-                  printf(&quot;w :%d\n&quot;,r-&gt;w);
-                  printf(&quot;h :%d\n&quot;,r-&gt;h);
-#endif
-                  {
-                      uint32_t clipW,clipH;
-                      
-                      clipW=FFMIN(_info.width,r-&gt;x+r-&gt;w)-r-&gt;x;
-                      clipH=FFMIN(_info.height,r-&gt;y+r-&gt;h)-r-&gt;y;
-                      
-                      ADMImage image(r-&gt;w,r-&gt;h);
-                      ADMImage alphaImage(r-&gt;w,r-&gt;h);
-                      
-                      uint8_t *ptr=image.data;
-                      uint8_t *ptrAlpha=alphaImage.data;
-                      uint8_t *in=r-&gt;bitmap;
-                      for(int yy=0;yy&lt;r-&gt;h;yy++)
-                      {
-                          for(int xx=0;xx&lt;r-&gt;w;xx++)
-                          {
-                            uint32_t alpha,valout;
-                            uint32_t val=*in++;
-                            
-                                  val=r-&gt;rgba_palette[val];
-                                  
-                                  *ptrAlpha++=(val&gt;&gt;24)&amp;0xff;
-                                  *ptr++=(val&amp;0xff);;
-                          }
-                      }
-              
-                      // Merge Luma
-                      
-                      for(int yy=0;yy&lt;clipH;yy++)
-                      {
-                          org=data-&gt;_bitmap+(yy+r-&gt;y)*_info.width+r-&gt;x;
-                          
-                          ptrAlpha=alphaImage.data+yy*r-&gt;w;
-                          ptr=image.data+yy*r-&gt;w;
-                          int clean=0;
-                          for(int xx=0;xx&lt;clipW;xx++)
-                          {
-                            uint32_t val,before,alpha;
-                            
-                                  //before=*org;
-                                  val=*ptr++;
-                                  alpha=*ptrAlpha++;
-                                  
-                                  val=val*alpha;//+(255-alpha)*before;
-                                  val=val&gt;&gt;8;
-                                  if(val&gt;10) clean=1; // Remove noise
-                                  *org++=val;
-                                  
-                          }
-                          if(clean) data-&gt;setDirty(r-&gt;y+yy);
-                      }
-                  }
-                   // We dont need chroma here...
-               // Delete palette &amp; data
-_skipX:
-               av_free(r-&gt;rgba_palette);
-               av_free(r-&gt;bitmap);
-            } // Next rec..
-            memset(&amp;sub,0,sizeof(sub));
-        
-        return 1;
-}
-uint8_t	ADMVideoSubDVB::getCoupledConf(CONFcouple **conf) 
-{
-
-        *conf=new CONFcouple(0);
-        return 1;
-}
-/************************************************/

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,53 +0,0 @@
-/***************************************************************************
-                         DVB-T subtitle filter
-    
-    copyright            : (C) 2007 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef ADM_VIDDVBSUB_H
-#define ADM_VIDDVBSUB_H
-#include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_mpegstartcode.h&quot;
-#include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.h&quot;
-
-#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidVobSubBitmap.h&quot;
-
-
-#define READ_BUFFER_SIZE (64*1024)
-
-class ADMVideoSubDVB : public AVDMGenericVideoStream 
-{
-protected:
-        virtual char* printConf(void);
-       
-       
-        
-        decoderFFSubs *decoder;
-        ADMCompressedImage *binary;
-        dmx_demuxerTS *demuxer;
-        AVSubtitle  sub;
-        uint8_t     readBuffer[READ_BUFFER_SIZE];
-        uint32_t    _inited;
-        
-public:
-        ADMVideoSubDVB(AVDMGenericVideoStream *in, CONFcouple *conf);
-        ADMVideoSubDVB(const char *fileName, uint32_t pid,uint32_t w,uint32_t h);
-        virtual ~ADMVideoSubDVB();
-        virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data,uint32_t *flags);
-        uint8_t configure(AVDMGenericVideoStream *instream);
-        uint8_t	getCoupledConf(CONFcouple **conf);
-        uint8_t getNextBitmap(vobSubBitmap *data,uint32_t *pts);
-        uint8_t init(const char  *tsFileName);
-};
-#endif
-/************************************************/

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,539 +0,0 @@
-/***************************************************************************
-                          ADM_vidEraser.cpp  -  &quot;Erase&quot; arbitrary areas of
-                                                        each frame
-                             -------------------
-                         Chris MacGregor, December 2007
-                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#include &quot;ADM_default.h&quot;
-
-#include &lt;ctype.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;math.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;iterator&gt;
-
-#include &quot;ADM_assert.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avi_vars.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-#include &quot;ADM_encoder/adm_encoder.h&quot;
-
-
-#include &quot;DIA_factory.h&quot;
-
-#include &quot;ADM_vidEraser.h&quot;
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.h&quot; // for MenuMapping
-
-using namespace std;
-
-static const int MAX_PIXEL_LUMA = 255;
-
-static FILTER_PARAM eraserParam =
-{
-    5,
-    { &quot;brush_mode&quot;, &quot;brush_size&quot;, &quot;output_color&quot;, &quot;data_file&quot;, &quot;debug&quot; // 4
-    }
-};
-
-// This is a hack to work around the fact that the ctor &amp; dtor get called
-// too often.  The right solution would be to arrange for the filter
-// objects to be constructed and destructed only when really necessary:
-// when a new instance of a filter is added to the list (by the user), it
-// is constructed, and when it is removed from the list (by the user), it
-// is destructed, and anything else is handled by a separate init() or
-// configure() method.  This would allow the objects to maintain a
-// persistent state in a more straightforward way.
-
-ADMVideoEraser::PImap ADMVideoEraser::pimap;
-
-
-SCRIPT_CREATE(eraser_script,ADMVideoEraser,eraserParam);
-
-BUILD_CREATE(eraser_create,ADMVideoEraser);
-
-ADMVideoEraser::ADMVideoEraser (AVDMGenericVideoStream *in, CONFcouple *couples)
-{
-    _in = in;
-    memcpy (&amp;_info, in-&gt;getInfo(), sizeof(_info));
-    _info.encoding = 1;
-    _uncompressed = new ADMImage (_in-&gt;getInfo()-&gt;width, _in-&gt;getInfo()-&gt;height);
-    ADM_assert (_uncompressed);
-    _param = new ERASER_PARAM;
-
-    if (couples)
-    {
-        GET(brush_mode);
-        GET(brush_size);
-        GET(output_color);
-        char * tmp;
-        GET2(data_file, tmp);
-        GET(debug);
-    }
-    else
-    {
-        _param-&gt;brush_mode = 1; // erase
-        _param-&gt;brush_size = 1; // 3x3
-        _param-&gt;output_color = 0;
-        // _param-&gt;data_file = &quot;&quot;; // implicit
-        _param-&gt;debug = 0;
-    }
-
-    // This is a hack to work around the fact that the ctor &amp; dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    // This explicit check wouldn't be necessary if there was an easier way of
-    // ensuring that we got a 0 pointer when a new map entry was auto-consed
-    // up...
-
-    if (pimap.count (couples) == 0)
-    {
-        myInfo = new PersistentInfo;
-        myInfo-&gt;conf = couples;
-        pimap [couples] = myInfo;
-    }
-    else
-    {
-        myInfo = pimap [couples];
-        if (couples)
-        {
-            if (myInfo-&gt;oldConf == couples)
-            {
-                pimap.erase (myInfo-&gt;conf);
-                myInfo-&gt;conf = myInfo-&gt;oldConf;
-                myInfo-&gt;oldConf = 0;
-            }
-            else
-            {
-                ADM_assert (myInfo-&gt;conf == couples);
-
-                if (myInfo-&gt;oldConf)
-                {
-                    pimap.erase (myInfo-&gt;oldConf);
-                    myInfo-&gt;oldConf = 0;
-                }
-            }
-        }
-    }
-
-    myInfo-&gt;refCount++;
-
-    printf (&quot;ADMVideoEraser ctor (%p, conf = %p), pi = %p, rc now %d\n&quot;,
-            this, couples, myInfo, myInfo-&gt;refCount);
-}
-
-uint8_t	ADMVideoEraser::getCoupledConf (CONFcouple **couples)
-{
-
-    ADM_assert (_param);
-    *couples = new CONFcouple (eraserParam.nb);
-
-    // This is a hack to work around the fact that the ctor &amp; dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    printf (&quot;ADMVideoEraser::getCoupledConf(): this = %p, couples = %p, &quot;
-            &quot;oldConf = %p (was %p), pi = %p\n&quot;,
-            this, *couples, myInfo-&gt;conf, myInfo-&gt;oldConf, myInfo);
-
-    if (myInfo-&gt;oldConf)
-        pimap.erase (myInfo-&gt;oldConf);
-    myInfo-&gt;oldConf = myInfo-&gt;conf;
-    myInfo-&gt;conf = *couples;
-    pimap [myInfo-&gt;conf] = myInfo;
-    if (myInfo-&gt;oldConf == 0)
-        pimap.erase (0);
-
-    CSET(brush_mode);
-    CSET(brush_size);
-    CSET(output_color);
-    (*couples)-&gt;setCouple(&quot;data_file&quot;, _param-&gt;data_file.c_str());
-    CSET(debug);
-
-    return 1;
-}
-
-uint8_t ADMVideoEraser::configure (AVDMGenericVideoStream *in)
-{
-    diaMenuEntry tBrushMode [] = {
-        { 1, QT_TR_NOOP(&quot;Erase&quot;), NULL },
-        { 0, QT_TR_NOOP(&quot;Un-Erase&quot;), NULL },
-    };
-
-    diaMenuEntry tBrushSize [] = {
-        { 0, QT_TR_NOOP(&quot;1x1&quot;), NULL },
-        { 1, QT_TR_NOOP(&quot;3x3&quot;), NULL },
-        { 2, QT_TR_NOOP(&quot;5x5&quot;), NULL },
-        { 3, QT_TR_NOOP(&quot;7x7&quot;), NULL },
-        { 4, QT_TR_NOOP(&quot;9x9&quot;), NULL },
-        { 5, QT_TR_NOOP(&quot;11x11&quot;), NULL },
-        { 7, QT_TR_NOOP(&quot;15x15&quot;), NULL },
-        { 10, QT_TR_NOOP(&quot;21x21&quot;), NULL },
-    };
-
-    diaElemMenu brush_mode
-        (&amp;(_param-&gt;brush_mode), QT_TR_NOOP(&quot;Brush _Mode:&quot;),
-         sizeof (tBrushMode) / sizeof (diaMenuEntry), tBrushMode);
-
-    diaElemMenu brush_size
-        (&amp;(_param-&gt;brush_size), QT_TR_NOOP(&quot;Brush _Size:&quot;),
-         sizeof (tBrushSize) / sizeof (diaMenuEntry), tBrushSize);
-
-    MenuMapping menu_mapping [] = {
-        { &quot;brushModeMenu&quot;, my_offsetof (ERASER_PARAM, brush_mode),
-          sizeof (tBrushMode) / sizeof (diaMenuEntry), tBrushMode },
-        { &quot;brushSizeMenu&quot;, my_offsetof (ERASER_PARAM, brush_size),
-          sizeof (tBrushSize) / sizeof (diaMenuEntry), tBrushSize },
-    };
-
-    if (myInfo-&gt;masks.empty() || myInfo-&gt;mask_data_invalid)
-        readDataFile (_info.width);
-
-    // printf (&quot;ADM_vidEraser: _param = %p\n&quot;, _param);
-    uint8_t ret = DIA_eraser (_in, this, _param, menu_mapping,
-                              sizeof (menu_mapping) / sizeof (MenuMapping));
-    if (ret == 1)
-    {
-        writeDataFile();
-        return ret;
-    }
-    else if (ret == 0) // 0 = cancel
-    {
-        myInfo-&gt;mask_data_invalid = true;
-        return ret;
-    }
-    else
-    {
-        ADM_assert (ret == 255); // 255 = whizzy dialog not implemented
-    }
-
-    diaElemUSlider output_color
-        (&amp;(_param-&gt;output_color),
-         QT_TR_NOOP(&quot;Output \&quot;_Color\&quot; for all masked pixels:&quot;), 0, 255);
-
-    char * file = ADM_strdup (_param-&gt;data_file.c_str());
-
-    diaElemFile data_file
-        (0, &amp;file,
-         QT_TR_NOOP(&quot;Eraser _Data File:&quot;), 0, QT_TR_NOOP(&quot;Select data file&quot;));
-
-    // TODO: The configuration of the masks is not implemented!!!
-
-    diaElemUInteger debug
-        (&amp;(_param-&gt;debug), QT_TR_NOOP(&quot;_Debugging settings (bits):&quot;),
-         0, 0x7fffffff);
-
-    diaElem * elems[] = { &amp;brush_mode, &amp;brush_size, &amp;output_color,
-                          &amp;data_file, &amp;debug };
-
-    ret = diaFactoryRun (QT_TR_NOOP(&quot;Eraser Configuration&quot;),
-                         sizeof (elems) / sizeof (diaElem *), elems);
-    if (ret) // 0 = cancel
-    {
-        writeDataFile();
-        myInfo-&gt;mask_data_invalid = true;
-    }
-
-    _param-&gt;data_file = file;
-    delete[] file;
-
-    return ret;
-}
-
-ADMVideoEraser::~ADMVideoEraser()
-{
-    // This is a hack to work around the fact that the ctor &amp; dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    myInfo-&gt;refCount--;
-    printf (&quot;ADMVideoEraser dtor (%p), conf = %p, pi = %p, rc now %d\n&quot;,
-            this, myInfo-&gt;conf, myInfo, myInfo-&gt;refCount);
-
-    if (myInfo-&gt;oldConf)
-    {
-        pimap.erase (myInfo-&gt;oldConf);
-        myInfo-&gt;oldConf = 0;
-    }
-
-    if (myInfo-&gt;refCount &lt; 1)
-    {
-        pimap.erase (myInfo-&gt;conf);
-        delete myInfo;
-    }
-
-    DELETE (_param);
-    delete _uncompressed;
-    _uncompressed = NULL;
-}
-
-char * ADMVideoEraser::printConf ()
-{
-    const int CONF_LEN = 1024;
-    static char conf[CONF_LEN];
-
-    const char * data_file = _param-&gt;data_file.c_str();
-    if (!data_file || !*data_file)
-        data_file = &quot;**** no file selected ****&quot;;
-
-    char * cptr = conf;
-    cptr += snprintf (conf, CONF_LEN, &quot;Eraser: erase to %d, data in %s&quot;,
-                      _param-&gt;output_color, data_file);
-
-    if (_param-&gt;debug)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          &quot;, debug = 0x%x&quot;, _param-&gt;debug);
-    return conf;
-}
-
-void ADMVideoEraser::writeDataFile () const
-{
-    const char * filename = _param-&gt;data_file.c_str();
-    ofstream outputStream (filename);
-    if (!outputStream)
-    {
-        perror (filename);
-        fprintf (stderr, &quot;******** FAILED to write eraser data to %s (%d)\n&quot;,
-                 filename, errno);
-        return;
-    }
-
-    Eraser::MaskVec &amp; masks = myInfo-&gt;masks;
-
-    outputStream &lt;&lt; &quot;# avidemux Eraser video filter data\n&quot;
-                 &lt;&lt; &quot;version: 1&quot;
-                 &lt;&lt; &quot;\ndimensions: &quot; &lt;&lt; _info.width &lt;&lt; &quot; &quot; &lt;&lt; _info.height
-                 &lt;&lt; &quot;\nmaskcount: &quot; &lt;&lt; masks.size()
-                 &lt;&lt; &quot;\n&quot;;
-
-    for (Eraser::MaskVec::const_iterator maskit = masks.begin();
-         maskit != masks.end();
-         ++maskit)
-    {
-        const Eraser::Mask &amp; mask = *maskit;
-        const Eraser::LineVec &amp; lines = mask.lines;
-        outputStream &lt;&lt; &quot;\nmask: &quot; &lt;&lt; mask.first_frame &lt;&lt; &quot; &quot;
-                     &lt;&lt; mask.last_frame &lt;&lt; &quot; &quot; &lt;&lt; lines.size() &lt;&lt; &quot;\n&quot;;
-
-        for (Eraser::LineVec::const_iterator lineit = lines.begin();
-             lineit != lines.end();
-             ++lineit)
-        {
-            outputStream &lt;&lt; lineit-&gt;x &lt;&lt; &quot; &quot; &lt;&lt; lineit-&gt;y &lt;&lt; &quot; &quot;
-                         &lt;&lt; lineit-&gt;count &lt;&lt; &quot;\n&quot;;
-        }
-    }
-
-    outputStream &lt;&lt; &quot;\nend\n&quot;;
-}
-
-uint8_t ADMVideoEraser::readDataFile (uint32_t width)
-{
-    Eraser::MaskVec &amp; masks = myInfo-&gt;masks;
-
-//    uint32_t &amp; mask_w = myInfo-&gt;mask_w;
-//    uint32_t &amp; mask_h = myInfo-&gt;mask_h;
-
-    const char * filename = _param-&gt;data_file.c_str();
-    if (filename[0] == '\0')
-    {
-        fprintf (stderr, &quot;Eraser: no input file selected!\n&quot;);
-        return 0;
-    }
-
-//    mask_w = 0;
-//    mask_h = 0;
-
-    ifstream inputStream (filename);
-    if (!inputStream)
-    {
-        fprintf (stderr, &quot;Eraser: can't open input file %s, &quot;
-                 &quot;but it apparently does exist...(%d)\n&quot;,
-                 filename, errno);
-        return 0;
-    }
-
-    masks.clear();
-    string buffer;
-
-    while (inputStream)
-    {
-        inputStream &gt;&gt; buffer;
-        if (buffer [0] == '#')
-        {
-            // toss rest of line
-            inputStream.ignore (1000000,'\n');
-        }
-        else if (buffer == &quot;mask:&quot;)
-        {
-            uint32_t first_frame, last_frame, linecount;
-            inputStream &gt;&gt; first_frame &gt;&gt; last_frame &gt;&gt; linecount;
-            masks.push_back (Eraser::Mask (first_frame, last_frame));
-            Eraser::MaskVec::iterator maskit = masks.end() - 1;
-            Eraser::LineVec &amp; lines = maskit-&gt;lines;
-            lines.reserve (linecount);
-            while (linecount--)
-            {
-                uint16_t x, y, count;
-                inputStream &gt;&gt; x &gt;&gt; y &gt;&gt; count;
-                if (count == 0)
-                {
-                    fprintf (stderr, &quot;%s: bad count (x = %d, y = %d)\n&quot;,
-                             filename, x, y);
-                    return 0;
-                }
-                lines.push_back (Eraser::Line (x, y, count));
-            }
-            printf (&quot;mask %d: %d lines\n&quot;, masks.size() - 1, lines.size());
-        }
-        else if (buffer == &quot;maskcount:&quot;)
-        {
-            uint32_t count;
-            inputStream &gt;&gt; count;
-            masks.reserve (count);
-        }
-        else if (buffer == &quot;version:&quot;)
-        {
-            int version;
-            inputStream &gt;&gt; version;
-            if (version != 1)
-            {
-                fprintf (stderr, &quot;%s: unsupported version: %d\n&quot;,
-                         filename, version);
-                return 0;
-            }
-        }
-        else if (buffer == &quot;dimensions:&quot;)
-        {
-            int dummy;
-            inputStream &gt;&gt; dummy; // width
-            inputStream &gt;&gt; dummy; // height
-        }
-        else if (buffer != &quot;end&quot;)
-        {
-            fprintf (stderr, &quot;%s: unrecognized gunk: \&quot;%s\&quot;\n&quot;,
-                     filename, buffer.c_str());
-            return 0;
-        }
-    }
-
-    myInfo-&gt;mask_data_invalid = false;
-    return 1;
-}
-
-//============================================================================
-
-uint8_t ADMVideoEraser::getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                               ADMImage *data, uint32_t *flags)
-{
-    if (frame &gt;= _info.nb_frames)
-        return 0;
-
-    if (_param-&gt;debug &amp; 1)
-        printf (&quot;in ADMVideoEraser::getFrameNumberNoAlloc(%d, ...)\n&quot;, frame);
-
-    if (!_in-&gt;getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
-        return 0;
-
-    if (myInfo-&gt;masks.empty() || myInfo-&gt;mask_data_invalid)
-        readDataFile (_info.width);
-
-    uint32_t planesize = _info.width * _info.height;
-    uint32_t size = (planesize * 3) &gt;&gt; 1;
-    *len = size;
-
-    uint32_t real_frame = frame + _info.orgFrame;
-    uint8_t ret = doEraser (_uncompressed, data, _in, real_frame,
-                            this, _param, _info.width, _info.height);
-    return ret;
-}
-
-uint8_t
-ADMVideoEraser::doEraser (ADMImage * image, ADMImage * data,
-                          AVDMGenericVideoStream * in,
-                          uint32_t real_frame,
-                          ADMVideoEraser * eraser, ERASER_PARAM * param,
-                          uint32_t width, uint32_t height)
-{
-    PersistentInfo * myInfo = eraser-&gt;myInfo;
-    uint32_t debug = param-&gt;debug;
-
-    Eraser::MaskVec &amp; masks = myInfo-&gt;masks;
-    uint32_t planesize = width * height;
-    uint8_t * outPixels = YPLANE (data);
-
-    memcpy (outPixels, YPLANE (image), planesize);
-
-    // HERE: for better performance, especially with more than a small number
-    // of masks, figure out how to use lower_bound() or some other binary
-    // search type of thing (write our own if necessary to handle comparing an
-    // int to an Eraser::Mask) to find the mask whose range includes
-    // real_frame, rather than linear searching on every frame.
-
-    for (Eraser::MaskVec::const_iterator maskit = masks.begin();
-         maskit != masks.end();
-         ++maskit)
-    {
-        const Eraser::Mask &amp; mask = *maskit;
-
-        if (real_frame &lt; mask.first_frame)
-            break; // they're sorted, so no more will match
-
-        if (real_frame &gt; mask.last_frame)
-            continue;
-
-        const Eraser::LineVec &amp; lines = mask.lines;
-        for (Eraser::LineVec::const_iterator lineit = lines.begin();
-             lineit != lines.end();
-             ++lineit)
-        {
-            memset (outPixels + (lineit-&gt;y * width) + lineit-&gt;x,
-                    param-&gt;output_color, lineit-&gt;count);
-        }
-
-        break; // only one can match any given frame number, since they can't
-               // overlap.
-    }
-
-    // HERE: the following two lines do a luma-only-ize
-
-    memset (UPLANE (data), 128, planesize &gt;&gt; 2);
-    memset (VPLANE (data), 128, planesize &gt;&gt; 2);
-
-    data-&gt;copyInfo (image);
-
-    return 1;
-}	                           

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,202 +0,0 @@
-/***************************************************************************
-                          ADM_vidEraser.h  -  &quot;Erase&quot; arbitrary areas of
-                                                      each frame
-                             -------------------
-                         Chris MacGregor, December 2007
-                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __ERASER__
-#define __ERASER__   
-
-#include &lt;map&gt;
-
-
-#include &lt;vector&gt;
-#include &lt;string&gt;
-
-#include &lt;sys/time.h&gt;
-
-struct ERASER_PARAM
-{
-    uint32_t brush_mode; // 0 = un-erase, 1 = erase
-    uint32_t brush_size; // NxN where N = brush_size * 2 + 1
-    uint32_t output_color; // 0 - 255
-    std::string data_file;
-    uint32_t debug;
-};
-
-// Alas, because offsetof() is only supposed to work on POD (plain old data)
-// structs, and our ERASER_PARAM includes a std::string (which has a
-// constructor, and which causes ERASER_PARAM to therefore have an implicit
-// constructor), we need to define our own offsetof() to use for the dialog
-// menus.  See
-// <A HREF="http://www.cplusplus.com/reference/clibrary/cstddef/offsetof.html">http://www.cplusplus.com/reference/clibrary/cstddef/offsetof.html</A> for more
-// on offsetof().
-
-#define my_offsetof(_type, _memb) (size_t (&amp;(((_type *)1)-&gt;_memb)) - 1)
-
-namespace Eraser
-{
-    // The mask for a range of frames is represented as a list (vector) of
-    // lines, where each line is a horizontal line of pixels.  Thus, each Line
-    // has a y coordinate, and a range of x coordinates (represented as the
-    // leftmost x coordinate and a count of pixels).  The list of lines is
-    // kept sorted by y and then by x, to make it more efficient to merge in
-    // new pixels or find ones to remove while maintaining the most compact
-    // (and thus most efficient to apply to an image) representation.
-
-    struct Line
-    {
-        uint16_t x;
-        uint16_t y;
-        uint16_t count;
-
-        Line ()
-            : x(), y(), count()
-        {
-        }
-
-        Line (uint16_t x, uint16_t y, uint16_t count)
-            : x (x), y (y), count (count)
-        {
-        }
-    };
-
-    typedef std::vector &lt;Line&gt; LineVec;
-
-    struct Mask
-    {
-        uint32_t first_frame;
-        uint32_t last_frame;
-        LineVec lines;
-
-        Mask (uint32_t first_frame, uint32_t last_frame)
-            : first_frame (first_frame),
-              last_frame (last_frame)
-        {
-        }
-
-        Mask (uint32_t first_frame, uint32_t last_frame,
-              const LineVec &amp; lines)
-            : first_frame (first_frame),
-              last_frame (last_frame),
-              lines (lines)
-        {
-        }
-    };
-
-    typedef std::vector &lt;Mask&gt; MaskVec;
-}
-
-class ADMVideoEraser : public AVDMGenericVideoStream
-{
-protected:
-    	
-    // This is a hack to work around the fact that the ctor &amp; dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    class PersistentInfo
-    {
-    public:
-        CONFcouple *  conf;
-        CONFcouple *  oldConf;
-        uint32_t      refCount;
-
-//        uint32_t      mask_w;
-//        uint32_t      mask_h;
-
-//        std::string   data_file_name;
-//        time_t        data_file_mtime;
-
-        Eraser::MaskVec masks;
-
-        bool          mask_data_invalid;
-
-        PersistentInfo ()
-            : conf (0),
-              oldConf (0),
-              refCount (0),
-
-//              mask_w (0),
-//              mask_h (0),
-
-//              data_file_mtime (0),
-              mask_data_invalid (true)
-        {
-        }
-    };
-
-    typedef std::map &lt;CONFcouple *, PersistentInfo *&gt; PImap;
-    static PImap pimap;
-
-    PersistentInfo * myInfo;
-
-    ERASER_PARAM * _param;
-
-public:
-
-    ADMVideoEraser (AVDMGenericVideoStream * in, CONFcouple * setup);
-    ~ADMVideoEraser();
-
-    virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
-                                           ADMImage * data, uint32_t * flags);
-
-    virtual uint8_t configure (AVDMGenericVideoStream * instream);
-    virtual char * printConf (void);
-    virtual uint8_t getCoupledConf (CONFcouple ** couples);
-
-    static uint8_t doEraser (ADMImage * from_image,
-                             ADMImage * to_image,
-                             AVDMGenericVideoStream * in,
-                             uint32_t real_frame,
-                             ADMVideoEraser * eraserp,
-                             ERASER_PARAM * param,
-                             uint32_t width, uint32_t height);
-
-    Eraser::MaskVec &amp; getMasks ()
-    {
-        return myInfo-&gt;masks;
-    }
-
-    void masksIsValid (bool valid)
-    {
-        myInfo-&gt;mask_data_invalid = !valid;
-    }
-
-protected:
-
-    uint8_t readDataFile (uint32_t width);
-    void writeDataFile () const;
-
-private:
-
-    const ADV_Info &amp; getInfo () const
-    {
-        return _info;
-    }
-};
-
-struct MenuMapping;
-uint8_t DIA_eraser (AVDMGenericVideoStream * in,
-                    ADMVideoEraser * eraserp,
-                    ERASER_PARAM * param,
-                    const MenuMapping * menu_mapping,
-                    uint32_t menu_mapping_count);
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidNumber.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidNumber.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidNumber.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,76 +0,0 @@
-/***************************************************************************
-                          ADM_vidNumber.cpp  -  Add frame number 
-                             -------------------
-
-    copyright            : (C) 2008 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilterDynamic.h&quot;
-
-static FILTER_PARAM flipParam={0,{&quot;&quot;}};
-
- class  ADMVideoNumber:public AVDMGenericVideoStream
- {
-
- protected:
-    		AVDMGenericVideoStream 	*_in;    	
-           virtual char 									*printConf(void);
-          
- public:
- 		
-  					ADMVideoNumber(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  					virtual ~ADMVideoNumber();
-		          virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          																	ADMImage *data,uint32_t *flags);
-					virtual uint8_t configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 1;};          																	
-
-
- }     ;
-SCRIPT_CREATE(number_script,ADMVideoNumber,flipParam);
-BUILD_CREATE(number_create,ADMVideoNumber);
- 
-
-char *ADMVideoNumber::printConf( void )
-{
-    ADM_FILTER_DECLARE_CONF(&quot; Add Frame Number&quot;);
-        
-}
-
-ADMVideoNumber::ADMVideoNumber(  AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-    UNUSED_ARG(setup);
- 	_in=in;		
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info)); 	
-  	_info.encoding=1;	
-}
-ADMVideoNumber::~ADMVideoNumber()
-{
-  
-}
-uint8_t ADMVideoNumber::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-	if(frame&gt;= _info.nb_frames) return 0;
-	// read uncompressed frame
-	if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-    char f[50];
-    snprintf(f,49,&quot;%08u&quot;,frame);
-    drawString(data, 2, 2, f); 
-        
-	return 1;
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,1462 +0,0 @@
-/***************************************************************************
-                          ADM_vidParticle.cpp  -  detect particles (groups
-                                                     of pixels)
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#include &lt;math.h&gt;
-#include &lt;algorithm&gt;
-#include &lt;string&gt;
-#include &lt;ctype.h&gt;
-
-using namespace std;
-
-#include &quot;ADM_default.h&quot;
-
-#undef memcpy   // avoid compile errors due to macro
-#include &quot;fourcc.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-#include &quot;ADM_encoder/adm_encoder.h&quot;
-
-#include &quot;ADM_filter/video_filters.h&quot;
-
-#include &quot;DIA_factory.h&quot;
-
-#include &quot;ADM_vidParticle.h&quot;
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.h&quot; // for MenuMapping
-
-FILE * ADMVideoParticle::outfp = 0;
-uint32_t ADMVideoParticle::last_frame_written = 0xffffffff;
-
-static FILTER_PARAM particleParam =
-{
-    10,
-    { &quot;min_area&quot;, &quot;max_area&quot;, &quot;left_crop&quot;, &quot;right_crop&quot;,          // 4
-      &quot;top_crop&quot;, &quot;bottom_crop&quot;, &quot;output_format&quot;, &quot;output_file&quot;,  // + 4 = 8
-//      &quot;camera_number&quot;, &quot;min_dim_pctile&quot;, &quot;max_dim_pctile&quot;, &quot;debug&quot; // + 4 = 12
-      &quot;camera_number&quot;, &quot;debug&quot; // + 2 = 10
-    }
-};
-
-SCRIPT_CREATE(particle_script,ADMVideoParticle,particleParam);
-
-BUILD_CREATE(particle_create,ADMVideoParticle);
-
-ADMVideoParticle::ADMVideoParticle (AVDMGenericVideoStream *in, CONFcouple *couples)
-{
-    printf (&quot;ADMVideoParticle ctor (%p)\n&quot;, this);
-    _in = in;
-    memcpy(&amp;_info, in-&gt;getInfo(), sizeof(_info));
-    _info.encoding = 1;
-    _uncompressed = new ADMImage(_in-&gt;getInfo()-&gt;width, _in-&gt;getInfo()-&gt;height);
-    ADM_assert(_uncompressed);
-    _param = new PARTICLE_PARAM;
-
-    if (couples)
-    {
-        GET(min_area);
-        GET(max_area);
-        GET(left_crop);
-        GET(right_crop);
-        GET(top_crop);
-        GET(bottom_crop);
-        GET(output_format);
-
-	char* tmp;
-        GET2(output_file, tmp);
-        GET(camera_number);
-//        GET(min_dim_pctile);
-//        GET(max_dim_pctile);
-        GET(debug);
-    }
-    else
-    {
-        _param-&gt;min_area = 5;
-        _param-&gt;max_area = 50000;
-        _param-&gt;left_crop = 0;
-        _param-&gt;right_crop = 0;
-        _param-&gt;top_crop = 0;
-        _param-&gt;bottom_crop = 0;
-        _param-&gt;output_format = OUTPUTFMT_FORMAT_NEW;
-        // _param-&gt;output_file = &quot;&quot;; // implicit
-        _param-&gt;camera_number = 1;
-//        _param-&gt;min_dim_pctile = 0;
-//        _param-&gt;max_dim_pctile = 100;
-        _param-&gt;debug = 0;
-    }
-}
-
-uint8_t	ADMVideoParticle::getCoupledConf (CONFcouple **couples)
-{
-
-    ADM_assert(_param);
-    *couples = new CONFcouple(particleParam.nb);
-
-    CSET(min_area);
-    CSET(max_area);
-    CSET(left_crop);
-    CSET(right_crop);
-    CSET(top_crop);
-    CSET(bottom_crop);
-    CSET(output_format);
-	(*couples)-&gt;setCouple(&quot;output_file&quot;, _param-&gt;output_file.c_str());
-    CSET(camera_number);
-//    CSET(min_dim_pctile);
-//    CSET(max_dim_pctile);
-    CSET(debug);
-
-    return 1;
-
-}
-
-uint8_t ADMVideoParticle::configure (AVDMGenericVideoStream *in)
-{
-    diaMenuEntry tOutputFmt [] = {
-        { OUTPUTFMT_FORMAT_NEW,
-          QT_TR_NOOP(&quot;New format, preferred, good for Tracker3D&quot;), NULL },
-        { OUTPUTFMT_FORMAT_DG_UWA,
-          QT_TR_NOOP(&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">DG at UWA</A> format (includes shape info &amp; bounding box)&quot;), NULL },
-        { OUTPUTFMT_FORMAT_AB_ODU,
-          QT_TR_NOOP(&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">AB at ODU</A> format (includes shape info)&quot;), NULL },
-        { OUTPUTFMT_FORMAT_OLD,
-          QT_TR_NOOP(&quot;Old format that Tracker3D can't read directly&quot;), NULL },
-    };
-
-    diaElemMenu output_format
-        (&amp;(_param-&gt;output_format), QT_TR_NOOP(&quot;Output _Format:&quot;),
-         sizeof (tOutputFmt) / sizeof (diaMenuEntry), tOutputFmt);
-
-    MenuMapping menu_mapping [] = {
-        { &quot;outputFormatMenu&quot;, my_offsetof (PARTICLE_PARAM, output_format),
-          sizeof (tOutputFmt) / sizeof (diaMenuEntry), tOutputFmt },
-    };
-
-    uint8_t ret = DIA_particle (_in, this, _param, menu_mapping,
-                                sizeof (menu_mapping) / sizeof (MenuMapping));
-    if (ret == 1)
-    {
-        return ret;
-    }
-    else if (ret == 0) // 0 = cancel
-    {
-        return ret;
-    }
-    else
-    {
-        ADM_assert (ret == 255); // 255 = whizzy dialog not implemented
-    }
-
-    diaElemUInteger min_area
-        (&amp;(_param-&gt;min_area),
-         QT_TR_NOOP(&quot;Mi_nimum area for a particle to be detected:&quot;), 1, 0x7fffffff);
-    diaElemUInteger max_area
-        (&amp;(_param-&gt;max_area),
-         QT_TR_NOOP(&quot;Ma_ximum area for a particle to be detected:&quot;), 1, 0x7fffffff);
-
-    diaElemUInteger left_crop
-        (&amp;(_param-&gt;left_crop),
-         QT_TR_NOOP(&quot;_Left side crop (ignore particles in):&quot;), 0, 0x7fffffff);
-    diaElemUInteger right_crop
-        (&amp;(_param-&gt;right_crop),
-         QT_TR_NOOP(&quot;_Right side crop (ignore particles in):&quot;), 0, 0x7fffffff);
-    diaElemUInteger top_crop
-        (&amp;(_param-&gt;top_crop),
-         QT_TR_NOOP(&quot;_Top crop (ignore particles in):&quot;), 0, 0x7fffffff);
-    diaElemUInteger bottom_crop
-        (&amp;(_param-&gt;bottom_crop),
-         QT_TR_NOOP(&quot;_Bottom crop (ignore particles in):&quot;), 0, 0x7fffffff);
-
-	char* file = ADM_strdup(_param-&gt;output_file.c_str());
-
-    diaElemFile output_file
-        (1, &amp;file, QT_TR_NOOP(&quot;_Output File:&quot;), NULL, QT_TR_NOOP(&quot;Select file&quot;));
-
-    diaElemUInteger camera_number
-        (&amp;(_param-&gt;camera_number), QT_TR_NOOP(&quot;_Camera number:&quot;), 1, 0x7fffffff);
-
-    diaElemUInteger debug(&amp;(_param-&gt;debug), QT_TR_NOOP(&quot;_Debugging settings (bits):&quot;),
-                          0, 0x7fffffff);
-
-    diaElem * elems[] = { &amp;min_area, &amp;max_area, &amp;left_crop, &amp;right_crop,
-                          &amp;top_crop, &amp;bottom_crop, &amp;output_format,
-                          &amp;output_file, &amp;camera_number, &amp;debug };
-
-    ret = diaFactoryRun (&quot;Particle Detection Configuration&quot;,
-                         sizeof (elems) / sizeof (diaElem *), elems);
-
-	_param-&gt;output_file = file;
-	delete[] file;
-
-    return ret;
-}
-
-ADMVideoParticle::~ADMVideoParticle()
-{
-    printf (&quot;ADMVideoParticle dtor (%p)\n&quot;, this);
-    DELETE(_param);
-    delete _uncompressed;
-    _uncompressed = NULL;
-}
-
-char *ADMVideoParticle::printConf (void)
-{
-    const int CONF_LEN = 1024;
-    static char conf[CONF_LEN];
-
-    char * cptr = conf;
-
-    cptr += snprintf (conf, CONF_LEN, &quot;ParticleList: Area=%u..%u&quot;,
-                      _param-&gt;min_area, _param-&gt;max_area);
-
-    if (_param-&gt;left_crop || _param-&gt;right_crop || _param-&gt;top_crop
-        || _param-&gt;bottom_crop)
-    {
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          &quot;, Crop (L/R/T/B): %u/%u/%u/%u&quot;,
-                          _param-&gt;left_crop, _param-&gt;right_crop,
-                          _param-&gt;top_crop, _param-&gt;bottom_crop);
-    }
-
-    if (!_param-&gt;output_file.empty())
-    {
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf), &quot;, %s Output to %s&quot;,
-                          _param-&gt;output_format == OUTPUTFMT_FORMAT_OLD
-                          ? &quot;Old&quot; : &quot;New&quot;, _param-&gt;output_file.c_str());
-    }
-
-    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), &quot;, Camera # %u&quot;,
-                      _param-&gt;camera_number);
-
-    if (_param-&gt;debug)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          &quot;, debug=0x%x&quot;, _param-&gt;debug);
-
-    return conf;
-}
-
-uint8_t ADMVideoParticle::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                ADMImage *data, uint32_t *flags)
-{
-    if (frame &gt;= _info.nb_frames)
-        return 0;
-
-    if (_param-&gt;debug &amp; (0x01 &lt;&lt; ImageTool::SHIFT_PAST_SHOW_FLAGS))
-        printf (&quot;in ADMVideoParticle::getFrameNumberNoAlloc(%d, ...)\n&quot;, frame);
-
-    if (!_in-&gt;getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
-        return 0;
-
-    uint32_t planesize = _info.width * _info.height;
-    uint32_t size = (planesize * 3) &gt;&gt; 1;
-    *len = size;
-
-    uint32_t real_frame = frame + _info.orgFrame;
-    OutputFmt outfmt = static_cast &lt;OutputFmt&gt; (_param-&gt;output_format);
-
-    if (!outfp &amp;&amp; real_frame == 0 &amp;&amp; !_param-&gt;output_file.empty())
-    {
-        printf (&quot;Starting to write particle list to %s\n&quot;,
-                _param-&gt;output_file.c_str());
-
-        outfp = fopen (_param-&gt;output_file.c_str(), &quot;w&quot;);
-        if (!outfp)
-        {
-            perror (_param-&gt;output_file.c_str());
-        }
-        else if (real_frame == 0) // ick
-        {
-            switch (outfmt)
-            {
-            case OUTPUTFMT_FORMAT_OLD:
-                fprintf (outfp, &quot;%% Particle  Area  X  Y  Frame\n&quot;);
-                break;
-
-            case OUTPUTFMT_FORMAT_NEW:
-                fprintf (outfp, &quot;%% Frame  Camera  X  Y  Area  Particle\n&quot;);
-                break;
-
-            case OUTPUTFMT_FORMAT_DG_UWA:
-                fprintf (outfp,
-                         &quot;%% Frame #, Camera #, X, Y, Area, Particle #, &quot;
-                         &quot;Bounding Box Width, Bounding Box Height, &quot;
-                         &quot;Min Dim, Max Dim, Min Dim Angle, Max Dim Angle, &quot;
-                         &quot;Max / Min, Length, Length Angle, &quot;
-                         &quot;Width, Width Angle, Length / Width\n&quot;);
-                break;
-
-            case OUTPUTFMT_FORMAT_AB_ODU:
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-                fprintf (outfp,
-                         &quot;Frame #,Particle #,Area,X,Y,Min Dim,Max Dim,&quot;
-                         &quot;Min Dim Angle,Max Dim Angle,Min / Max\n&quot;);
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-                fprintf (outfp,
-                         &quot;Frame #,Particle #,Area,X,Y, Min Dim,Max Dim, &quot;
-                         &quot;Min Dim Angle,Max Dim Angle, Max / Min,  &quot;
-                         &quot;Length,Length Angle, Width,Width Angle, &quot;
-                         &quot;Length / Width\n&quot;);
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-                break;
-
-            default:
-                fprintf (outfp, &quot;%% Uh oh, unknown output format %d!\n&quot;,
-                         outfmt);
-                break;
-            }
-        }
-    }
-
-    uint8_t ret = doParticle (_uncompressed, data, _in, real_frame,
-                              (last_frame_written == real_frame) ? 0 : outfp,
-                              _param, _info.width, _info.height);
-
-    last_frame_written = real_frame;
-
-    if (outfp &amp;&amp; real_frame &gt;= _info.nb_frames + _info.orgFrame - 1)
-    {
-        fclose (outfp);
-        outfp = 0;
-        fprintf (stderr, &quot;Finished writing particle list to %s\n&quot;,
-                 _param-&gt;output_file.c_str());
-    }
-
-    return ret;
-}
-
-uint8_t
-ADMVideoParticle::doParticle (ADMImage * image, ADMImage * data,
-                              AVDMGenericVideoStream * in,
-                              uint32_t real_frame,
-                              FILE * do_outfp, PARTICLE_PARAM * param,
-                              uint32_t width, uint32_t height)
-{
-    uint32_t debug = param-&gt;debug;
-
-    uint32_t planesize = width * height;
-    uint32_t uvplanesize = planesize &gt;&gt; 2;
-    uint32_t size = planesize + (uvplanesize * 2);
-			
-    memset (UPLANE (data), 128, uvplanesize);
-    memset (VPLANE (data), 128, uvplanesize);
-    memset (YPLANE (data), 0, planesize);
-
-    // HERE: we should erase anything outside the ROI (region of interest),
-    // unless we decide to handle that some other way and/or place...
-
-    OutputFmt outfmt = static_cast &lt;OutputFmt&gt; (param-&gt;output_format);
-    bool fancyOutput = (outfmt == OUTPUTFMT_FORMAT_AB_ODU ||
-                        outfmt == OUTPUTFMT_FORMAT_DG_UWA);
-
-    uint8_t * imagePixels = YPLANE (image);
-    uint32_t imagetool_flags
-        = fancyOutput ? ImageTool::FLAG_DO_SHAPE : ImageTool::FLAG_NONE;
-
-    ImageTool imtool (imagePixels, width, height, data, imagetool_flags);
-    imtool.setDebug (debug);
-    imtool.setMinArea (param-&gt;min_area);
-    imtool.setMaxArea (param-&gt;max_area);
-    imtool.setCropping (param-&gt;left_crop, param-&gt;right_crop,
-                        param-&gt;top_crop, param-&gt;bottom_crop);
-    static uint32_t totalParticleNum = 0;
-    uint32_t frameParticleNum = 0;
-
-    uint32_t camera_number = param-&gt;camera_number;
-
-    for (uint32_t y = param-&gt;top_crop; y &lt; height - param-&gt;bottom_crop; y++)
-    {
-        uint8_t * pixelrow = imagePixels + (y * width);
-        for (uint32_t x = param-&gt;left_crop; x &lt; width - param-&gt;right_crop; x++)
-        {
-            if (imtool.goodPixel (pixelrow [x]))
-            {
-                if (imtool.autoOutline (x, y) == 0)
-                    continue;
-
-                const Particle &amp; particle = imtool.getParticle();
-                uint32_t area = particle.area;
-                float centroid_x = particle.centroidX;
-                float centroid_y = particle.centroidY;
-
-                if (debug &amp; (0x02 &lt;&lt; ImageTool::SHIFT_PAST_SHOW_FLAGS))
-                    printf (&quot;frame %d, particle %d (%d total), &quot;
-                            &quot;%d pixels centered at (%.6f,%.6f)\n&quot;,
-                            real_frame, frameParticleNum,
-                            totalParticleNum, area, centroid_x, centroid_y);
-
-                if (!do_outfp)
-                    continue;
-
-                ++totalParticleNum;
-                ++frameParticleNum;
-
-                if (fancyOutput)
-                {
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-                    uint32_t mindim = particle.getMinDimCount();
-                    uint32_t maxdim = particle.getMaxDimCount();
-                    float mindimangle = particle.getMinDimAngle();
-                    float maxdimangle = particle.getMaxDimAngle();
-                    float minmaxratio = float (mindim) / float (maxdim);
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-                    float mindist = particle.getMinDistance();
-                    float maxdist = particle.getMaxDistance();
-                    float mindistangle = particle.getMinDistAngle();
-                    float maxdistangle = particle.getMaxDistAngle();
-                    float maxminratio = float (maxdist) / float (mindist);
-                    const Particle::BestFit &amp; bf = particle.getBestFit();
-                    float lenwidthratio = bf.length / bf.width;
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-
-                    if (outfmt == OUTPUTFMT_FORMAT_DG_UWA)
-                    {
-                        fprintf (do_outfp,
-                                 &quot;%d %d &quot;
-                                 &quot;%.6f %.6f &quot; // x, y
-                                 &quot;%d %d &quot; // area, totalParticleNum
-                                 &quot;%d %d &quot; // bbox width, bbox height
-                                 &quot;%.5f %.5f &quot; // min, max
-                                 &quot;%.5f %.5f %.5f  &quot; // minang,maxang,max/min
-                                 &quot;%.5f %.5f &quot; // len, len_angle
-                                 &quot;%.5f %.5f %.5f\n&quot;, // wid, wid_ang, len/wid
-                                 real_frame, camera_number,
-                                 centroid_x, centroid_y,
-                                 area, totalParticleNum,
-                                 particle.maxx - particle.minx + 1,
-                                 particle.maxy - particle.miny + 1,
-                                 mindist, maxdist,
-                                 mindistangle, maxdistangle, maxminratio,
-                                 bf.length, bf.length_angle,
-                                 bf.width, bf.width_angle, lenwidthratio);
-                    }
-                    else if (outfmt == OUTPUTFMT_FORMAT_AB_ODU)
-                    {
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-                        fprintf (do_outfp,
-                                 &quot;%d,%d,%d,%.6f,%.6f,%d,%d,%.5f,%.5f,%.5f\n&quot;,
-                                 real_frame, frameParticleNum, area,
-                                 centroid_x, centroid_y, mindim, maxdim,
-                                 mindimangle, maxdimangle, minmaxratio);
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-                        fprintf (do_outfp,
-                                 &quot;%d,%d,%d,&quot;
-                                 &quot;%.6f,%.6f, %.5f,%.5f, &quot; // x, y, min, max
-                                 &quot;%.5f,%.5f, %.5f,  &quot; // minang,maxang,max/min
-                                 &quot;%.5f,%.5f, &quot; // len, len_angle
-                                 &quot;%.5f,%.5f, %.5f\n&quot;, // wid, wid_ang, len/wid
-                                 real_frame, frameParticleNum, area,
-                                 centroid_x, centroid_y, mindist, maxdist,
-                                 mindistangle, maxdistangle, maxminratio,
-                                 bf.length, bf.length_angle,
-                                 bf.width, bf.width_angle, lenwidthratio);
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-                    }
-                    else
-                        fprintf (do_outfp,
-                                 &quot;uh oh, unknown fancy output format %d\n&quot;,
-                                 outfmt);
-                }
-                else
-                {
-                    if (outfmt == OUTPUTFMT_FORMAT_NEW)
-                    {
-                        fprintf (do_outfp, &quot;%d %d %.6f %.6f %d %d\n&quot;,
-                                 real_frame, camera_number,
-                                 centroid_x, centroid_y,
-                                 area, totalParticleNum);
-                    }
-                    else
-                    {
-                        fprintf (do_outfp, &quot;%d %d %.6f %.6f %d\n&quot;,
-                                 totalParticleNum, area,
-                                 centroid_x, centroid_y, real_frame);
-                    }
-                }
-            }
-        }
-    }
-
-    data-&gt;copyInfo(image);
-    return 1;
-}	                           
-
-//////////////////////////////////////////////////////////////////////////////
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-inline void Particle_Old::Wedge::trim_to_edge ()
-{
-    for (int i = pixel_distance.size() - 1; i &gt;= 0; --i)
-    {
-        if (pixel_distance [i] &gt; max_white_distance)
-        {
-            // toss it; to save time we just mark it invalid instead of
-            // deleting from the various vectors.
-            pixel_distance [i] = -1;
-            --pixel_count;
-        }
-    }
-}
-#endif
-
-char ImageTool::directionLetters [] = &quot;ESWN#?&quot;;
-
-PixelOffset ImageTool::leftOffset [ImageTool::DIRECTION_COUNT] =
-{
-//     East         South        West         North
-    {  0, -1 },  {  1,  0 },  {  0,  1 },  { -1,  0 }
-};
-
-// Interesting - aheadOffset [n] == leftOffset [(n + 1) % DIRECTION_COUNT]...
-PixelOffset ImageTool::aheadOffset [ImageTool::DIRECTION_COUNT] =
-{
-//     East         South        West         North
-    {  1,  0 },  {  0,  1 },  { -1,  0 },  {  0, -1 }
-};
-
-// If we're using 4-connectedness (current implementation), then the following
-// would be treated as two independent particles; with 8-connectedness, this
-// would be a single particle with some &quot;holes&quot; in it.
-
-// . . . * * . . .
-// . . * * * . . .
-// . * * * . * . .
-// . * * * . * * .
-// * * * . * * * .
-// * * . * * * * .
-// . * . * * * . .
-// . . . * . . . .
-
-
-uint8_t ImageTool::autoOutline (uint32_t x, uint32_t y)
-{
-/*    my_particle.init (debug);
-    PixelLocVec &amp; outline = my_particle.outline;
-
-    static int needbar = 1;
-
-    if (needbar &amp;&amp; (debug &amp; 0xffff)) // anything
-    {
-        printf (&quot;\n=======================================&quot;
-                &quot;=======================================\n\n&quot;);
-        needbar = 0;
-    }
-
-    if ((debug &amp; (0x04 &lt;&lt; SHIFT_PAST_SHOW_FLAGS)) &amp;&amp; ++needbar)
-        printf (&quot;autoOutline(%d,%d):&quot;, x, y);
-
-    ADM_assert (goodPixel (x, y));
-
-    uint32_t startingX = x;
-    uint32_t startingY = y;
-
-    TracingDirection direction = DIRECTION_COUNT; // deliberately invalid
-    TracingDirection newDirection = DIRECTION_EAST;
-
-    int8_t
-        Lx, Ly,  // left
-        Ax, Ay;  // ahead
-
-#if 0
-    uint32_t prevX;
-    uint32_t prevY;
-    TracingDirection startingDirection = direction;
-#endif
-
-    uint32_t pointCount = 0;
-    uint32_t pointMax = my_w * my_h; // more than that and something is wrong
-
-    do
-    {
-#if 0
-        prevX = x;
-        prevY = y;
-#endif
-
-        outline.push_back (PixelLoc (x, y));
-        if ((debug &amp; (0x08 &lt;&lt; SHIFT_PAST_SHOW_FLAGS)) &amp;&amp; ++needbar)
-            printf (&quot; %c(%d,%d)%c&quot;, directionLetters [direction],
-                    x, y, directionLetters [newDirection]);
-
-        if (++pointCount &gt;= pointMax)
-        {
-            printf (&quot;\nUh oh!  Too many points!! (%d) (@(%d,%d), dir %c)\n&quot;,
-                    pointCount, x, y, directionLetters [direction]);
-            showStuff (SHOW_INPUT);
-            showStuff (SHOW_OUTLINE);
-            break;
-        }
-
-        if (newDirection != direction)
-        {
-            direction = newDirection;
-            Lx = leftOffset [direction].x;
-            Ly = leftOffset [direction].y;
-            Ax = aheadOffset [direction].x;
-            Ay = aheadOffset [direction].y;
-#define ARx (Ax + Rx)
-#define ARy (Ay + Ry)
-#define Rx  (-Lx)
-#define Ry  (-Ly)
-#define BRx (Bx + Rx)
-#define BRy (By + Ry)
-#define Bx  (-Ax)
-#define By  (-Ay)
-#define BLx (Bx + Lx)
-#define BLy (By + Ly)
-        }
-
-        if (goodPixel (x + Lx, y + Ly))
-        {
-            // Turn left
-            x += Lx;
-            y += Ly;
-            newDirection = TracingDirection ((direction + TURN_LEFT)
-                                             % DIRECTION_COUNT);
-        }
-        else if (goodPixel (x + Ax, y + Ay))
-        {
-            // Continue in same direction
-            x += Ax;
-            y += Ay;
-            // newDirection = direction;
-        }
-        else if (goodPixel (x + Rx, y + Ry))
-        {
-            // Turn right
-            x += Rx;
-            y += Ry;
-            newDirection = TracingDirection ((direction + TURN_RIGHT)
-                                             % DIRECTION_COUNT);
-        }
-#if 0
-// if we turn this on, we probably ought to be looking at the AL pixel as
-// well.  (And turn on the BR case, below?)
-
-        else if (goodPixel (x + ARx, y + ARy))
-        {
-            // Slide down one pixel and continue
-            do that!;
-        }
-#endif
-        else if (goodPixel (x + Bx, y + By))
-        {
-            // Turn around (reverse direction)
-            x += Bx;
-            y += By;
-            newDirection = TracingDirection ((direction + TURN_AROUND)
-                                             % DIRECTION_COUNT);
-        }
-#if 0
-        else if (goodPixel (x + BRx, y + BRy))
-        {
-            // Slide down one pixel and turn right
-            do that (the slide)!;
-            newDirection = TracingDirection ((direction + TURN_RIGHT)
-                                             % DIRECTION_COUNT);
-        }
-#endif
-        else
-        {
-            // Apparently there is nowhere to go.  This should happen only if
-            // we're looking at an isolated pixel (a one-pixel particle).
-
-            if (outline.size() &gt; 1)
-            {
-                printf (&quot;\nUh oh!  We're stuck, but it's not a lonely pixel!  &quot;
-                        &quot;(@(%d,%d), dir %c)\n&quot;,
-                        x, y, directionLetters [direction]);
-                showStuff (SHOW_INPUT);
-                showStuff (SHOW_OUTLINE);
-                ADM_assert (outline.size() &gt; 1);
-            }
-
-            break; // we'd fall out anyway, but this is faster &amp; more explicit
-        }
-
-    } while (x != startingX || y != startingY);
-
-    if ((debug &amp; (0x04 &lt;&lt; SHIFT_PAST_SHOW_FLAGS)) &amp;&amp; ++needbar)
-        printf (&quot; done! %d points in all\n&quot;, outline.size());
-
-    // We now do 5 things in one pass: 1. count the pixels in the particle
-    // (thus computing the area, defined as the number of pixels in the
-    // particle); 2. clear those pixels in the input image so that we don't
-    // count the particle more than once; 3. compute the centroid (defined as
-    // the point whose x is the average of all the x's in the particle, and
-    // whose y is the average of all the y's in the particle); 4. if there is
-    // an output image, draw the particle in the output, with the outline
-    // highlighted; 5. compute the bounding box (rectangle that completely
-    // encloses the particle).
-
-    PixelLocVec::iterator plit = outline.begin();
-    while (plit != outline.end())
-    {
-        uint32_t px = plit-&gt;x;
-        uint32_t py = plit-&gt;y;
-
-        ++plit;
-
-        if (my_outImage)
-        {
-            outPixel (px, py) = 255;
-#ifdef USE_COLOR_IN_OUTPUT
-            outUPixel (px, py) = 0;
-            outVPixel (px, py) = 0;
-#endif
-        }
-
-        // We do the above (set up output pixels) first so we ensure that the
-        // outline is highlighted even if the code below has already displayed
-        // some of the pixels in the outline (due to direct or indirect
-        // adjacency to other outline pixels).
-
-        if (getPixel (px, py) == 0)
-            continue;
-
-        // If we're still here, then this pixel is part of the particle but
-        // has not yet been counted or otherwise processed.  There may be
-        // other horizontally adjacent pixels, as well, which we will also
-        // process now, if they are present - this accomplishes &quot;filling&quot; the
-        // particle outline (except that any pixels that were actually not
-        // &quot;on&quot; in the particle will be ignored).
-
-        // First, we process the pixel itself, and any pixels to the right of
-        // it (if they are on).
-
-        uint32_t startX = px;
-
-        my_particle.addWhitePixel (px, py);
-        getPixel (px, py) = 0; // erase to prevent being counted again
-
-        while (goodPixel (++px, py))
-        {
-            my_particle.addWhitePixel (px, py);
-            getPixel (px, py) = 0; // erase to prevent being counted again
-            if (my_outImage)
-                outPixel (px, py) = 128;
-        }
-
-        // Now, we process any pixels to the left of the original one (if they
-        // are on).
-
-        px = startX;
-        while (goodPixel (--px, py))
-        {
-            my_particle.addWhitePixel (px, py);
-            getPixel (px, py) = 0; // erase to prevent being counted again
-            if (my_outImage)
-                outPixel (px, py) = 128;
-        }
-    }
-
-    if (my_particle.area &lt; my_minArea || my_particle.area &gt; my_maxArea)
-    {
-        if (my_outImage)
-        {
-            // We need to erase the particle we just drew. :-(
-
-            plit = my_particle.white_pixels.begin();
-            while (plit != my_particle.white_pixels.end())
-            {
-                outPixel (plit-&gt;x, plit-&gt;y) = 0;
-                ++plit;
-            }
-        }
-
-        return 0;
-    }
-
-    needbar = 1;
-
-    my_particle.computeCentroid();
-
-    if (debug &amp; (0x0002 &lt;&lt; ImageTool::SHIFT_PAST_SHOW_FLAGS))
-        printf (&quot;    particle has %d pixels from (%d,%d) to (%d,%d) &quot;
-                &quot;with centroid at (%.5f,%.5f)\n&quot;,
-                my_particle.area, my_particle.minx, my_particle.miny,
-                my_particle.maxx, my_particle.maxy,
-                my_particle.centroidX, my_particle.centroidY);
-
-    if (my_outImage)
-    {
-        uint32_t px = static_cast &lt;uint32_t&gt; (nearbyintf (my_particle.centroidX));
-        uint32_t py = static_cast &lt;uint32_t&gt; (nearbyintf (my_particle.centroidY));
-        if (validPixel (px, py))
-            outPixel (px, py) = 255;
-        else
-            fprintf (stderr, &quot;################# Uh oh, about to stomp &quot;
-                     &quot;invalid centroid pixel (%d, %d)!!\n&quot;, px, py);
-#ifdef USE_COLOR_IN_OUTPUT
-        outUPixel (px, py) = 255;
-        outVPixel (px, py) = 255;
-#endif
-    }
-
-    if (debug &amp; SHOW_INPUT)
-        showStuff (SHOW_INPUT);
-
-    if (debug &amp; SHOW_OUTLINE)
-        showStuff (SHOW_OUTLINE);
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-
-    if (my_flags &amp; FLAG_DO_SHAPE)
-    {
-        typedef Particle::Wedge Wedge;
-        typedef Particle::WedgeVec WedgeVec;
-        typedef Particle::WedgePair WedgePair;
-        typedef Particle::WedgePairVec WedgePairVec;
-
-        // HERE: for DG/UWA format, we may only need the white pixels.  For
-        // AB/ODU format, we need to find all the pixels which are no further
-        // from the centroid than the furthest white pixel in the same wedge.
-        // For now, for DG/UWA format, we will show both numbers, so we need
-        // to measure the distance from the centroid for both formats.
-
-        my_particle.init_wedges();
-
-        // HERE: we don't need to sort the white_pixels vector unless we're
-        // counting non-white pixels in the shape stuff.
-
-        PixelLocVec &amp; white_pixels = my_particle.white_pixels;
-        sort (white_pixels.begin(), white_pixels.end(), PixelLoc::Compare());
-
-        WedgeVec &amp; wedges = my_particle.wedges;
-
-        uint16_t minx = my_particle.minx;
-        uint16_t miny = my_particle.miny;
-        uint16_t maxx = my_particle.maxx;
-        uint16_t maxy = my_particle.maxy;
-
-        const float pi_plus_half_wedge_arc
-            = M_PI + my_particle.half_wedge_arc;
-        const float wedge_arc = my_particle.wedge_arc;
-        const uint32_t num_wedges = my_particle.num_wedges;
-
-        for (uint16_t py = miny; py &lt;= maxy; py++)
-        {
-            const float dy = py - my_particle.centroidY;
-            const float dy_squared = dy * dy;
-
-            for (uint16_t px = minx; px &lt;= maxx; px++)
-            {
-                float dx = px - my_particle.centroidX;
-                float angle = atan2f (dy, dx);
-                uint32_t wedgeIndex
-                    = int ((angle + pi_plus_half_wedge_arc) / wedge_arc);
-                wedgeIndex %= num_wedges; // just in case
-
-                // uint8_t value = getPixel (px, py);
-                // oops, can't use that - we erased it already. :-(
-                bool value
-                    = binary_search (white_pixels.begin(), white_pixels.end(),
-                                     PixelLoc (px, py), PixelLoc::Compare());
-                float distance = sqrtf (dx * dx + dy_squared);
-                wedges [wedgeIndex].add_pixel (px, py, value, distance);
-                                               
-                printf (&quot;%d @ (%d,%d) %.5f -&gt; %d @ %.5f\n&quot;,
-                        value, px, py, distance,
-                        wedgeIndex, wedges[wedgeIndex].center_angle);
-            }
-        }
-
-        // See note in init_wedges() about what we're doing with the last
-        // wedge here.
-
-        wedges [0] += wedges [num_wedges];
-        wedges.pop_back();
-
-        // Now, in each wedge, toss any non-white pixels that are further out
-        // than the furthest white pixel in that wedge.
-
-        for (WedgeVec::iterator wit = wedges.begin();
-             wit != wedges.end();
-             ++wit)
-        {
-            printf (&quot;wedge @ %.5f: max white distance = %.5f\n&quot;,
-                    wit-&gt;center_angle, wit-&gt;max_white_distance);
-            wit-&gt;trim_to_edge();
-        }
-
-        // Next, we combine opposite wedges so that we can report the
-        // dimension along a line through the centroid across the whole
-        // particle (not just from the centroid to the particle boundary).
-
-        WedgePairVec &amp; wedge_pairs = my_particle.wedge_pairs;
-        int num_lines = my_particle.num_wedges / 2;
-        for (int widx = 0; widx &lt; num_lines; ++widx)
-        {
-            const Wedge &amp; neg_wedge = wedges [widx];
-            const Wedge &amp; pos_wedge = wedges [widx + num_lines];
-
-            float angle = pos_wedge.center_angle;
-            printf (&quot;wedge %d at %.5f = %d of %d  &quot;
-                    &quot;wedge %d at %.5f = %d of %d\n&quot;,
-                    widx, neg_wedge.center_angle, neg_wedge.pixel_count,
-                    neg_wedge.pixel_distance.size(),
-                    widx + num_lines, angle, pos_wedge.pixel_count,
-                    pos_wedge.pixel_distance.size());
-            uint32_t pixel_count
-                = pos_wedge.pixel_count + neg_wedge.pixel_count;
-            wedge_pairs.push_back (WedgePair (angle, pixel_count));
-        }
-
-        // Now we (effectively) sort the wedges by the number of pixels in
-        // them.
-
-        sort (wedge_pairs.begin(), wedge_pairs.end(), WedgePair::Less());
-
-        if (debug &amp; SHOW_WEDGE_PIXELS)
-            showStuff (SHOW_WEDGE_PIXELS);
-    }
-
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-
-    if (my_flags &amp; FLAG_DO_SHAPE)
-    {
-        typedef Particle::Wedge Wedge;
-        typedef Particle::WedgeVec WedgeVec;
-        typedef Particle::WedgePair WedgePair;
-        typedef Particle::WedgePairVec WedgePairVec;
-
-        my_particle.init_wedges();
-
-        PixelLocVec &amp; white_pixels = my_particle.white_pixels;
-        WedgeVec &amp; wedges = my_particle.wedges;
-
-        uint16_t minx = my_particle.minx;
-        uint16_t miny = my_particle.miny;
-        uint16_t maxx = my_particle.maxx;
-        uint16_t maxy = my_particle.maxy;
-
-        const float wedge_interval = my_particle.wedge_interval;
-        const uint32_t num_wedges = my_particle.num_wedges;
-
-        for (PixelLocVec::const_iterator wpit = white_pixels.begin();
-             wpit != white_pixels.end();
-             ++wpit)
-        {
-            const uint16_t px = wpit-&gt;x;
-            const uint16_t py = wpit-&gt;y;
-            const float dy = py - my_particle.centroidY;
-            const float dx = px - my_particle.centroidX;
-            float angle = atan2f (dy, dx);
-            uint32_t wedgeIndex = int ((angle + M_PI) / wedge_interval);
-            float distance = sqrtf (dx * dx + dy * dy);
-
-            while (1)
-            {
-                wedgeIndex %= num_wedges + 1;
-
-                Wedge &amp; wedge = wedges [wedgeIndex];
-
-                if (angle &lt; wedge.min_angle || angle &gt; wedge.max_angle)
-                {
-                    if (debug &amp; (0x0020 &lt;&lt; SHIFT_PAST_SHOW_FLAGS))
-                        printf (&quot;(%d,%d) = %.5f @ %.5f out of range for &quot;
-                                &quot;%d @ %.5f (%.5f to %.5f)\n&quot;,
-                                px, py, distance, angle,
-                                wedgeIndex, wedge.center_angle,
-                                wedge.min_angle, wedge.max_angle);
-                    break;
-                }
-
-                wedge.add_pixel (px, py, distance, angle);
-
-                if (debug &amp; (0x0010 &lt;&lt; SHIFT_PAST_SHOW_FLAGS))
-                    printf (&quot;(%d,%d) = %.5f @ %.5f -&gt; %d @ %.5f (%.5f)\n&quot;,
-                            px, py, distance, angle, wedgeIndex,
-                            wedge.angle_for_mwd, wedge.center_angle);
-                ++wedgeIndex;
-            }
-        }
-
-        // See note in init_wedges() about what we're doing with the last
-        // wedge here.
-
-        wedges [0] += wedges [num_wedges];
-        wedges.pop_back();
-
-        // Next, we combine opposite wedges so that we can report the
-        // dimension along a line through the centroid across the whole
-        // particle (not just from the centroid to the particle boundary).
-
-        WedgePairVec &amp; wedge_pairs = my_particle.wedge_pairs;
-        int num_lines = my_particle.num_wedges / 2;
-        for (int widx = 0; widx &lt; num_lines; ++widx)
-        {
-            const Wedge &amp; neg_wedge = wedges [widx];
-            const Wedge &amp; pos_wedge = wedges [widx + num_lines];
-
-            wedge_pairs.push_back (WedgePair (neg_wedge, pos_wedge));
-            const WedgePair &amp; wp = wedge_pairs.end()[-1];
-            if (debug &amp; (0x0100 &lt;&lt; ImageTool::SHIFT_PAST_SHOW_FLAGS))
-                printf (&quot;%c: wedge %d = %8.5f @ %.5f (%.5f), + &quot;
-                        &quot;wedge %d = %8.5f @ %.5f (%.5f), --&gt; %9.5f @ %.5f\n&quot;,
-                        widx + 'a', widx, neg_wedge.max_white_distance,
-                        neg_wedge.angle_for_mwd, neg_wedge.center_angle,
-                        widx + num_lines, pos_wedge.max_white_distance,
-                        pos_wedge.angle_for_mwd, pos_wedge.center_angle,
-                        wp.total_distance, wp.angle);
-        }
-
-        // Now, we find the pair of perpendicular wedges with the greatest
-        // ratio of length to width, where length and width are arbitrary
-        // designations (but length will never be less than width).
-
-        float best_ratio = -1;
-        int best_ratio_index = -1;
-        for (int wpidx = 0; wpidx &lt; num_lines; ++wpidx)
-        {
-            const WedgePair &amp; wp = wedge_pairs [wpidx];
-            // Find the perpendicular wedge.
-            int pwpidx = (wpidx + (num_lines / 2)) % num_lines;
-            const WedgePair &amp; pwp = wedge_pairs [pwpidx];
-            float ratio = wp.total_distance / pwp.total_distance;
-            if (debug &amp; (0x0200 &lt;&lt; ImageTool::SHIFT_PAST_SHOW_FLAGS))
-                printf (&quot;%c: wedgepair %d = %9.5f @ %.5f / &quot;
-                        &quot;wedgepair %d = %9.5f @ %.5f = %.5f\n&quot;,
-                        wpidx + 'a', wpidx, wp.total_distance, wp.angle,
-                        pwpidx, pwp.total_distance, pwp.angle, ratio);
-            if (ratio &gt; best_ratio)
-            {
-                best_ratio = ratio;
-                best_ratio_index = wpidx;
-            }
-        }
-
-        Particle::BestFit &amp; best_fit = my_particle.best_fit;
-        const WedgePair &amp; wp = wedge_pairs [best_ratio_index];
-        best_fit.length = wp.total_distance;
-        best_fit.length_angle = wp.angle;
-        int best_ratio_width_index
-            = (best_ratio_index + (num_lines / 2)) % num_lines;
-        const WedgePair &amp; pwp = wedge_pairs [best_ratio_width_index];
-        best_fit.width = pwp.total_distance;
-        best_fit.width_angle = pwp.angle;
-
-        if (debug &amp; (0x0200 &lt;&lt; ImageTool::SHIFT_PAST_SHOW_FLAGS))
-            printf (&quot;\nbest fit: length = wedgepair %d (%.5f @ %.5f) X &quot;
-                    &quot;wedgepair %d (%.5f @ %.5f); len/wid = %.5f\n\n&quot;,
-                    best_ratio_index, wp.total_distance, wp.angle,
-                    best_ratio_width_index, pwp.total_distance, pwp.angle,
-                    best_ratio);
-
-        // Finally, we (effectively) sort the wedges by the number of pixels
-        // in them.
-
-        sort (wedge_pairs.begin(), wedge_pairs.end(), WedgePair::Less());
-
-        if (debug &amp; SHOW_WEDGE_PIXELS)
-            showStuff (SHOW_WEDGE_PIXELS);
-    }
-
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-*/
-    return 1;
-}
-
-const PixelLoc PixelLoc::INVALID (0xffff, 0xffff);
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-
-void Particle_Old::init_wedges ()
-{
-    // num_wedges = (maxx - minx + 1 + maxy - miny + 1) * 2;
-    //    The above was too many - not enough pixels in any one wedge, and
-    //    minimum was always zero.
-    // num_wedges = maxx - minx + 1 + maxy - miny + 1;
-    //    The above was still too many.
-    num_wedges = min (int (area / 2), maxx - minx + 1 + maxy - miny + 1);
-
-    num_wedges = (num_wedges + 3) &amp; ~3; // round up to multiple of 4
-    wedge_arc = 2.0 * M_PI / num_wedges;
-    half_wedge_arc = wedge_arc / 2;
-    printf (&quot;init_wedges(): area = %d; %d wedges of arc %.5f\n&quot;,
-            area, num_wedges, wedge_arc);
-
-    // We are going to set up one extra wedge, because out on the negative X
-    // axis, there is a discontinuity: angles will be around +pi or -pi,
-    // depending on whether they are just above or below the negative X axis.
-    // So with the extra wedge, we have two exactly overlapping wedges (the
-    // first and last ones), with the first one catching all the ~-pi values
-    // and the last one catching the ~+pi values.  Later, we'll dump the last
-    // one into the first one before we process the wedges themselves.
-
-    wedges.reserve (num_wedges + 1);
-    double angle = -M_PI;
-    uint32_t wedge_index = 0;
-    while (wedge_index &lt;= num_wedges)
-    {
-        wedges.push_back (Wedge (angle, half_wedge_arc));
-        angle += wedge_arc;
-        ++wedge_index;
-    }
-}
-
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-
-void Particle::init_wedges ()
-{
-    // We've tried various other things, but they didn't work out well.
-    // Now we have a fixed number of wedges, and each wedge overlaps with 50%
-    // of each of its neighbors (e.g., 16 wedges, each one 1/8 of the circle).
-
-    num_wedges = 16;
-    wedge_interval = 2.0 * M_PI / num_wedges;
-    wedge_arc = wedge_interval * 2;
-    half_wedge_arc = wedge_arc / 2;
-    if (debug &amp; (0x40 &lt;&lt; ImageTool::SHIFT_PAST_SHOW_FLAGS))
-        printf (&quot;init_wedges(): %d wedges of arc %.5f, centered every %.5f\n&quot;,
-                num_wedges, wedge_arc, wedge_interval);
-
-    // We are going to set up one extra wedge, because out on the negative X
-    // axis, there is a discontinuity: angles will be around +pi or -pi,
-    // depending on whether they are just above or below the negative X axis.
-    // So with the extra wedge, we have two exactly overlapping wedges (the
-    // first and last ones), with the first one catching all the ~-pi values
-    // and the last one catching the ~+pi values.  Later, we'll dump the last
-    // one into the first one before we process the wedges themselves.
-
-    wedges.reserve (num_wedges + 1);
-    double angle = -M_PI;
-    uint32_t wedge_index = 0;
-    while (wedge_index &lt;= num_wedges)
-    {
-        if (debug &amp; (0x80 &lt;&lt; ImageTool::SHIFT_PAST_SHOW_FLAGS))
-            printf (&quot;    wedge %2d: %.5f (%.5f to %.5f)\n&quot;,
-                    wedge_index, angle, angle - half_wedge_arc,
-                    angle + half_wedge_arc);
-        wedges.push_back (Wedge (angle, half_wedge_arc));
-        angle += wedge_interval;
-        ++wedge_index;
-    }
-}
-
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-
-static inline
-char &amp; pixel_char (vector &lt;string&gt; &amp; grid, int16_t xbase, int16_t ybase,
-                   float cX, float cY, float dX, float dY)
-{
-    uint16_t x = static_cast &lt;uint16_t&gt; (nearbyintf (cX + dX));
-    uint16_t y = static_cast &lt;uint16_t&gt; (nearbyintf (cY + dY));
-    return grid [y - ybase][x - xbase];
-}
-
-static inline
-char &amp; pixel_char_from_angle (vector &lt;string&gt; &amp; grid, int16_t xbase, int16_t ybase,
-                              float cX, float cY, float distance, float angle)
-{
-    float dX = distance * cosf (angle);
-    float dY = distance * sinf (angle);
-    return pixel_char (grid, xbase, ybase, cX, cY, dX, dY);
-}
-
-void ImageTool::showStuff (ShowStuff what) const
-{
-    const PixelLocVec &amp; outline = my_particle.outline;
-
-    const int margin = 5;
-
-    uint16_t bbminx = my_particle.minx;
-    uint16_t bbminy = my_particle.miny;
-    uint16_t bbmaxx = my_particle.maxx;
-    uint16_t bbmaxy = my_particle.maxy;
-
-    if (bbminx &gt; bbmaxx)
-    {
-        PixelLocVec::const_iterator plit = outline.begin();
-        while (plit != outline.end())
-        {
-            uint32_t px = plit-&gt;x;
-            uint32_t py = plit-&gt;y;
-
-            if (px &lt; bbminx)
-                bbminx = px;
-            if (px &gt; bbmaxx)
-                bbmaxx = px;
-            if (py &lt; bbminy)
-                bbminy = py;
-            if (py &gt; bbmaxy)
-                bbmaxy = py;
-
-            ++plit;
-        }
-    }
-
-    uint16_t minx = max (int16_t (bbminx) - margin, 0);
-    uint16_t miny = max (int16_t (bbminy) - margin, 0);
-    uint16_t maxx = min (bbmaxx + margin, int16_t (my_w) - 1);
-    uint16_t maxy = min (bbmaxy + margin, int16_t (my_h) - 1);
-
-    switch (what)
-    {
-    case SHOW_INPUT:
-        printf (&quot;Input (after previous particle(s) erased):\n\n&quot;);
-        break;
-
-    case SHOW_OUTLINE:
-        printf (&quot;Outline (%d points):\n\n&quot;, outline.size());
-        break;
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-    case SHOW_WEDGE_PIXELS:
-        printf (&quot;Wedge pair assignments (%d wedges):\n\n&quot;,
-                my_particle.num_wedges);
-        break;
-#else
-    case SHOW_WEDGE_PIXELS:
-        printf (&quot;Wedge distances (%d wedges, %.5f arc at %.5f interval):\n\n&quot;,
-                my_particle.num_wedges, my_particle.wedge_arc,
-                my_particle.wedge_interval);
-        break;
-#endif
-
-    default:
-        break;
-    }
-
-    uint16_t dimx = maxx - minx + 1;
-    uint16_t dimy = maxy - miny + 1;
-    int16_t xbase = minx - 1;
-    int16_t ybase = miny;
-
-    if (debug &amp; (0x0400 &lt;&lt; ImageTool::SHIFT_PAST_SHOW_FLAGS))
-        printf (&quot;%dx%d (%d,%d - %d,%d; %d,%d - %d,%d; base = %d,%d)\n&quot;,
-                dimx, dimy, bbminx, bbminy, bbmaxx, bbmaxy,
-                minx, miny, maxx, maxy, xbase, ybase);
-
-    string ruler (dimx + 2, '-');
-    ruler [0] = '+';
-    ruler [dimx + 1] = '+';
-    printf (&quot;  x|&quot;);
-    const int x_ruler_spacing = 5;
-    unsigned xtick = minx + x_ruler_spacing - (minx % x_ruler_spacing);
-    unsigned field_width = xtick - minx + 2;
-    while (xtick &lt; maxx)
-    {
-        printf (&quot;%*d&quot;, field_width, xtick);
-        ruler [xtick - xbase] = '+';
-        xtick += x_ruler_spacing;
-        field_width = x_ruler_spacing;
-    }
-    ruler [bbminx - xbase] = '|';
-    ruler [bbmaxx - xbase] = '|';
-    printf (&quot;\ny: %s\n&quot;, ruler.c_str());
-
-    string blankLine (dimx + 2, '.');
-    blankLine [0] = '|';
-    blankLine [dimx + 1] = '|';
-    vector &lt;string&gt; grid (dimy, blankLine);
-    grid [bbminy - ybase][0] = '=';
-    grid [bbminy - ybase][dimx + 1] = '=';
-    grid [bbmaxy - ybase][0] = '=';
-    grid [bbmaxy - ybase][dimx + 1] = '=';
-
-    switch (what)
-    {
-    case SHOW_INPUT:
-    case SHOW_OUTLINE:
-    {
-        for (uint32_t py = miny; py &lt;= maxy; py++)
-        {
-            string &amp; gridline = grid [py - ybase];
-            for (uint32_t px = minx; px &lt;= maxx; px++)
-                if (goodPixel (px, py))
-                    gridline [px - xbase] = 'x';
-        }
-    }
-
-    // case SHOW_OUTLINE:
-    {
-        PixelLocVec::const_iterator plit = my_particle.white_pixels.begin();
-        while (plit != my_particle.white_pixels.end())
-        {
-            grid [plit-&gt;y - ybase][plit-&gt;x - xbase] = '*';
-            ++plit;
-        }
-
-        if (what == SHOW_INPUT)
-            break;
-
-        plit = outline.begin();
-        while (plit != outline.end())
-        {
-            uint32_t px = plit-&gt;x;
-            uint32_t py = plit-&gt;y;
-
-            char &amp; ch = grid [py - ybase][px - xbase];
-            // printf (&quot;(%d,%d)%c&quot;, px, py, ch);
-            if (ch == '*')
-                ch = '1';
-            else if (ch == '9')
-                ch = '+';
-            else if (ch == '.')
-                ch = '1';
-            else if (ch != '+')
-                ++ch;
-            // printf (&quot;-&gt;%c  &quot;, ch);
-
-            ++plit;
-        }
-
-        uint32_t px = static_cast &lt;uint32_t&gt; (nearbyintf (my_particle.centroidX));
-        uint32_t py = static_cast &lt;uint32_t&gt; (nearbyintf (my_particle.centroidY));
-        char &amp; ch = grid [py - ybase][px - xbase];
-        if (ch == 'x')
-            ch = 'X';
-        else if (ch == '.')
-            ch = 'c';
-        else
-            ch = 'C';
-        break;
-    }
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-    case SHOW_WEDGE_PIXELS:
-    {
-        const Particle::WedgeVec &amp; wedges = my_particle.wedges;
-        int num_lines = my_particle.num_wedges / 2;
-        for (int widx = 0; widx &lt; num_lines; ++widx)
-        {
-            char ch = 'a' + (widx % 26);
-            for (int incr = 0; incr &lt;= num_lines; incr += num_lines)
-            {
-                const Particle::Wedge &amp; wedge = wedges [widx + incr];
-                PixelLocVec::const_iterator plit = wedge.pixel_locs.begin();
-                vector &lt;float&gt;::const_iterator fit
-                    = wedge.pixel_distance.begin();
-                while (plit != wedge.pixel_locs.end())
-                {
-                    if (*fit++ &gt; 0)
-                        grid [plit-&gt;y - ybase][plit-&gt;x - xbase] = ch;
-                    ++plit;
-                }
-            }
-        }
-        uint32_t px = static_cast &lt;uint32_t&gt; (nearbyintf (my_particle.centroidX));
-        uint32_t py = static_cast &lt;uint32_t&gt; (nearbyintf (my_particle.centroidY));
-        char &amp; ch = grid [py - ybase][px - xbase];
-        if (ch == '.')
-            ch = '*';
-        else
-            ch = toupper (ch);
-        break;
-    }
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-    case SHOW_WEDGE_PIXELS:
-    {
-        // For each wedge, we mark the max distance for it with a lowercase
-        // letter at the point along the angle for that wedge that is the max
-        // distance from the centroid.
-        // 
-        // We mark the best-fit points with an L at points half the &quot;length&quot;
-        // from the centroid along the angle for the length and a W at points
-        // half the &quot;width&quot; from the centroid along the angle for the width.
-
-        const Particle::WedgeVec &amp; wedges = my_particle.wedges;
-        const float centroidX = my_particle.centroidX;
-        const float centroidY = my_particle.centroidY;
-        int num_lines = my_particle.num_wedges / 2;
-        for (int widx = 0; widx &lt; num_lines; ++widx)
-        {
-            char newch = 'a' + (widx % 26);
-            for (int incr = 0; incr &lt;= num_lines; incr += num_lines)
-            {
-                const Particle::Wedge &amp; wedge = wedges [widx + incr];
-                char &amp; ch = pixel_char_from_angle (grid, xbase, ybase,
-                                                   centroidX, centroidY,
-                                                   wedge.max_white_distance,
-                                                   wedge.angle_for_mwd);
-                // printf (&quot;(%d,%d) = '%c' (%.5f @ %.5f)\n&quot;,
-                //         x, y, newch, wedge.max_white_distance,
-                //         wedge.angle_for_mwd);
-                ch = newch;
-            }
-        }
-        const Particle::BestFit &amp; bf = my_particle.best_fit;
-        pixel_char_from_angle (grid, xbase, ybase, centroidX, centroidY,
-                               bf.length / 2, bf.length_angle)
-            = 'L';
-        pixel_char_from_angle (grid, xbase, ybase, centroidX, centroidY,
-                               bf.length / 2, bf.length_angle - M_PI)
-            = 'L';
-        pixel_char_from_angle (grid, xbase, ybase, centroidX, centroidY,
-                               bf.width / 2, bf.width_angle)
-            = 'W';
-        pixel_char_from_angle (grid, xbase, ybase, centroidX, centroidY,
-                               bf.width / 2, bf.width_angle - M_PI)
-            = 'W';
-        char &amp; ch = pixel_char (grid, xbase, ybase,
-                                centroidX, centroidY, 0, 0);
-        if (ch == '.')
-            ch = '*';
-        else
-            ch = '@';
-        break;
-    }
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-
-    default:
-        break;
-    }
-
-    for (unsigned i = miny; i &lt;= maxy; ++i)
-        printf (&quot;%3d%s\n&quot;, i, grid [i - ybase].c_str());
-
-    printf (&quot;   %s\n\n&quot;, ruler.c_str());
-}
-
-// Debug output should be able to show:
-
-// input: contents of entire bounding box plus 5-pixel margin on all sides
-// (with box boundaries marked somehow)
-
-// outline (current showStuff()) but with margin as above and showing all
-// pixel states (on/off) (on = *, C for centroid; . = off)
-
-// all pixels considered part of the particle, with wedge assignments if using
-// a shape-reporting format, and showing centroid.  each pixel is shown as
-// (wedge # % 26) + 'a', and (closest pixel to) centroid is in uppercase, or
-// a * if not actually a white pixel.  (use same letter for opposite wedges.)
-
-// list of wedges in angle order, showing their angles (center &amp; bounds),
-// on/off/included pixel counts, and optionally list of all pixels in them
-
-// should show the angles to the bounding box corners, for comparison
-
-// list of wedges in percentile order, showing their percentiles, angles, etc.
-
-// debug option to draw line through the max angle - better, draw bounding box
-// (+1 on all sides), with lines from bounding box edges outward (20 pixels
-// for len, 10 for width)
-
-//   x|260 264 268 272 276
-// y: +-+-|-+---+---+-|-+-+
-// 120|...................|
-// 121|...................|
-// 122|...................|
-// 123=.....11111.........=
-// 124|...111***1111......|
-// 125|....111**C**111....|
-// 126|......111**11111...|
-// 127=........1111.......=
-// 128|...................|
-// 129|...................|
-// 130|...................|
-//    +---|-----------|---+

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,851 +0,0 @@
-/***************************************************************************
-                          ADM_vidParticle.h  -  detect particles (groups of pixels)
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __PARTICLE__
-#define __PARTICLE__   
-
-#include &lt;string&gt;
-#include &lt;algorithm&gt;
-#include &lt;math.h&gt;
-
-
-struct PARTICLE_PARAM
-{
-    uint32_t min_area;
-    uint32_t max_area;
-    uint32_t left_crop;
-    uint32_t right_crop;
-    uint32_t top_crop;
-    uint32_t bottom_crop;
-    uint32_t output_format;
-    std::string output_file;
-    uint32_t camera_number;
-    uint32_t min_dim_pctile;
-    uint32_t max_dim_pctile;
-    uint32_t debug;
-};
-
-// Alas, because offsetof() is only supposed to work on POD (plain old data)
-// structs, and our PARTICLE_PARAM includes a std::string (which has a
-// constructor, and which causes PARTICLE_PARAM to therefore have an implicit
-// constructor), we need to define our own offsetof() to use for the dialog
-// menus.  See
-// <A HREF="http://www.cplusplus.com/reference/clibrary/cstddef/offsetof.html">http://www.cplusplus.com/reference/clibrary/cstddef/offsetof.html</A> for more
-// on offsetof().
-
-#define my_offsetof(_type, _memb) (size_t (&amp;(((_type *)1)-&gt;_memb)) - 1)
-
-class ADMVideoParticle : public AVDMGenericVideoStream
-{
-
- protected:
-    	
-     PARTICLE_PARAM *  _param;
-
-     static FILE * outfp; // ugly, but hard to avoid
-     static uint32_t last_frame_written; // ditto
-
- public:
- 		
-     enum OutputFmt
-     {
-         OUTPUTFMT_INVALID = 0,
-
-         OUTPUTFMT_FORMAT_NEW,
-         OUTPUTFMT_FORMAT_DG_UWA,
-         OUTPUTFMT_FORMAT_AB_ODU,
-         OUTPUTFMT_FORMAT_OLD,
-
-         OUTPUTFMT_COUNT
-     };
-
-     ADMVideoParticle (AVDMGenericVideoStream *in, CONFcouple *setup);
-
-     ~ADMVideoParticle();
-
-     virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                            ADMImage *data,uint32_t *flags);
-
-     virtual uint8_t configure (AVDMGenericVideoStream *instream);
-     virtual char * printConf (void);
-     virtual uint8_t getCoupledConf (CONFcouple **couples);
-							
-     static uint8_t doParticle (ADMImage * image, ADMImage * data,
-                                AVDMGenericVideoStream * in,
-                                uint32_t real_frame,
-                                FILE * do_outfp,
-                                PARTICLE_PARAM * param,
-                                uint32_t width, uint32_t height);
-};
-
-//////////////////////////////////////////////////////////////////////////////
-
-#include &lt;list&gt;
-//#include &lt;vector&gt;
-//#include &lt;iostream&gt;
-#include &lt;iterator&gt;
-
-class PixelLoc
-{
-public:
-    uint16_t x;
-    uint16_t y;
-
-    PixelLoc ()
-        : x (0),
-          y (0)
-    {
-    }
-
-    PixelLoc (uint32_t a_x, uint32_t a_y)
-        : x (a_x),
-          y (a_y)
-    {
-    }
-
-    // Use this to sort by y's, then (for PixelLoc's with the same y) by x's.
-
-    class Compare
-    {
-    public:
-        int operator () (const PixelLoc &amp; p1, const PixelLoc &amp; p2) const
-        {
-            return ((p1.y == p2.y) ? (p1.x &lt; p2.x) : (p1.y &lt; p2.y));
-        }
-    };
-
-    bool operator == (const PixelLoc &amp; rhs)
-    {
-        return (x == rhs.x &amp;&amp; y == rhs.y);
-    }
-
-    static const PixelLoc INVALID;
-};
-
-//typedef std::vector &lt;PixelLoc&gt; PixelLocVec;
-/*
-inline std::ostream &amp;
-operator &lt;&lt; (std::ostream &amp; s, const PixelLoc &amp; pl)
-{
-    return s &lt;&lt; &quot;(&quot; &lt;&lt; pl.x &lt;&lt; &quot;,&quot; &lt;&lt; pl.y &lt;&lt; &quot;)&quot;;
-}
-
-inline std::ostream &amp;
-operator &lt;&lt; (std::ostream &amp; s, const PixelLocVec &amp; theList)
-{
-    s &lt;&lt; &quot;[ &quot;;
-    std::copy (theList.begin(), theList.end(),
-               std::ostream_iterator &lt;PixelLoc&gt; (s, &quot; &quot;));
-    s &lt;&lt; &quot;]&quot;;
-    return s;
-}
-*/
-class ImageTool;
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-
-class Particle_Old
-{
-    struct Wedge
-    {
-        // HERE: if we're only counting white pixels, then we actually don't
-        // need any of the three vectors except for debugging output - we
-        // could just keep a count of pixels and that would be enough.
-
-        uint32_t pixel_count;
-        std::vector &lt;float&gt; pixel_distance;
-        PixelLocVec pixel_locs; // used only for debug output, else empty
-        std::vector &lt;char&gt; is_white; // faster than vector&lt;bool&gt;
-        float max_white_distance;
-        float min_angle;
-        float center_angle;
-        float max_angle;
-        float percentile;
-
-    private: // probably we don't need the default ctor - let's see...
-        Wedge ()
-            : pixel_count (0),
-              max_white_distance (-1),
-              min_angle (-10 * M_PI),
-              center_angle (-10 * M_PI),
-              max_angle (-10 * M_PI),
-              percentile (-1)
-        {
-        }
-    public:
-
-        Wedge (float angle, float half_arc)
-            : pixel_count (0),
-              max_white_distance (-1),
-              min_angle (angle - half_arc),
-              center_angle (angle),
-              max_angle (angle + half_arc),
-              percentile (-1)
-        {
-        }
-
-        void add_pixel (uint16_t x, uint16_t y)
-        {
-            ++pixel_count;
-            pixel_locs.push_back (PixelLoc (x, y));
-        }
-
-        void add_pixel (uint16_t x, uint16_t y, bool is_it_white, float distance)
-        {
-            ++pixel_count;
-            is_white.push_back (is_it_white);
-            if (is_it_white &amp;&amp; max_white_distance &lt; distance)
-                max_white_distance = distance;
-            pixel_distance.push_back (distance);
-            pixel_locs.push_back (PixelLoc (x, y));
-        }
-
-        Wedge &amp; operator += (const Wedge &amp; rhs)
-        {
-            pixel_count += rhs.pixel_count;
-            pixel_distance.insert (pixel_distance.end(),
-                                   rhs.pixel_distance.begin(),
-                                   rhs.pixel_distance.end());
-            pixel_locs.insert (pixel_locs.end(),
-                               rhs.pixel_locs.begin(),
-                               rhs.pixel_locs.end());
-            is_white.insert (is_white.end(),
-                             rhs.is_white.begin(),
-                             rhs.is_white.end());
-            if (rhs.max_white_distance &gt; max_white_distance)
-                max_white_distance = rhs.max_white_distance;
-
-            return *this;
-        }
-
-        class Less
-        {
-        public:
-            bool operator () (const Wedge &amp; lhs, const Wedge &amp; rhs) const
-            {
-                return (lhs.pixel_count &lt; rhs.pixel_count);
-            }
-        };
-
-        void trim_to_edge ();
-    };
-
-    //typedef std::vector &lt;Wedge&gt; WedgeVec;
-
-    struct WedgePair
-    {
-        float angle;
-        uint32_t pixel_count;
-
-        WedgePair (float angle, uint32_t pixel_count)
-            : angle (angle),
-              pixel_count (pixel_count)
-        {
-        }
-
-        class Less
-        {
-        public:
-            bool operator () (const WedgePair &amp; lhs,
-                              const WedgePair &amp; rhs) const
-            {
-                return (lhs.pixel_count &lt; rhs.pixel_count);
-            }
-        };
-    };
-
-    typedef std::vector &lt;WedgePair&gt; WedgePairVec;
-
-public:
-    uint16_t minx, maxx; // bounding box x
-    uint16_t miny, maxy; // bounding box y
-    uint32_t area;
-    float centroidX, centroidY;
-
-private:
-    uint32_t sumOfXs;
-    uint32_t sumOfYs;
-    uint32_t num_wedges;
-    // doubles used to minimize error accumulation when generating wedges
-    double wedge_arc;
-    double half_wedge_arc;
-
-    PixelLocVec outline;
-    PixelLocVec white_pixels;
-    //WedgeVec wedges;
-    WedgePairVec wedge_pairs;
-
-public:
-    Particle ()
-    {
-        init();
-    }
-
-private:
-    void init ()
-    {
-        minx = 0xffff;
-        maxx = 0;
-        miny = 0xffff;
-        maxy = 0;
-        area = 0;
-        centroidX = -1;
-        centroidY = -1;
-        sumOfXs = 0;
-        sumOfYs = 0;
-        num_wedges = 0;
-        wedge_arc = -1;
-        half_wedge_arc = -1;
-        outline.clear();
-        white_pixels.clear();
-        wedges.clear();
-        wedge_pairs.clear();
-    }
-
-    void init_wedges ();
-
-    void addWhitePixel (uint16_t x, uint16_t y)
-    {
-        ++area;
-        sumOfXs += x;
-        if (x &lt; minx)
-            minx = x;
-        if (x &gt; maxx)
-            maxx = x;
-        sumOfYs += y;
-        if (y &lt; miny)
-            miny = y;
-        if (y &gt; maxy)
-            maxy = y;
-        white_pixels.push_back (PixelLoc (x, y));
-    }
-
-    void computeCentroid ()
-    {
-        if (!area)
-        {
-            fprintf (stderr, &quot;Can't compute centroid of zero-pixel particle!\n&quot;);
-            centroidX = 0;
-            centroidY = 0;
-            return;
-        }
-        centroidX = float (sumOfXs) / area;
-        centroidY = float (sumOfYs) / area;
-    }
-
-public:
-    const WedgePair &amp; getMinDim () const
-    {
-        WedgePairVec::const_iterator wit = wedge_pairs.begin();
-        while (!wit-&gt;pixel_count)
-            ++wit;
-        return *wit;
-    }
-
-    const WedgePair &amp; getMaxDim () const
-    {
-        WedgePairVec::const_iterator wit = wedge_pairs.end();
-        return *--wit;
-    }
-
-    uint32_t getMinDimCount () const
-    {
-        return getMinDim().pixel_count;
-    }
-
-    uint32_t getMaxDimCount () const
-    {
-        return getMaxDim().pixel_count;
-    }
-
-    float getMinDimAngle () const
-    {
-        return getMinDim().angle;
-    }
-
-    float getMaxDimAngle () const
-    {
-        return getMaxDim().angle;
-    }
-
-    friend class ImageTool;
-};
-
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-
-class Particle
-{
-    struct Wedge
-    {
-        float max_white_distance;
-        float angle_for_mwd;
-        float min_angle;
-        float center_angle;
-        float max_angle;
-        float percentile;
-
-        Wedge (float angle, float half_arc)
-            : max_white_distance (.5), // minimum width is 1
-              angle_for_mwd (angle),
-              min_angle (angle - half_arc),
-              center_angle (angle),
-              max_angle (angle + half_arc),
-              percentile (-1)
-        {
-        }
-
-        void add_pixel (uint16_t x, uint16_t y, float distance, float angle)
-        {
-            if (max_white_distance &lt; distance)
-            {
-                max_white_distance = distance;
-                angle_for_mwd = angle;
-            }
-        }
-
-        Wedge &amp; operator += (const Wedge &amp; rhs)
-        {
-            if (rhs.max_white_distance &gt; max_white_distance)
-            {
-                max_white_distance = rhs.max_white_distance;
-                angle_for_mwd = rhs.angle_for_mwd;
-            }
-
-            return *this;
-        }
-
-        class Less
-        {
-        public:
-            bool operator () (const Wedge &amp; lhs, const Wedge &amp; rhs) const
-            {
-                return (lhs.max_white_distance &lt; rhs.max_white_distance);
-            }
-        };
-    };
-
-    //typedef std::vector &lt;Wedge&gt; WedgeVec;
-
-    struct WedgePair
-    {
-        float angle;
-        float total_distance;
-
-        WedgePair (const Wedge &amp; w1, const Wedge &amp; w2)
-            : total_distance (w1.max_white_distance + w2.max_white_distance)
-        {
-            float a1 = w1.angle_for_mwd;
-            float a2 = w2.angle_for_mwd;
-            if (a1 &gt; a2)
-                std::swap (a1, a2);
-            a1 += M_PI;
-            float avg = (a1 + a2) / 2;
-            if (avg &lt; 0)
-                avg += M_PI;
-            angle = avg;
-        }
-
-        class Less
-        {
-        public:
-            bool operator () (const WedgePair &amp; lhs,
-                              const WedgePair &amp; rhs) const
-            {
-                return (lhs.total_distance &lt; rhs.total_distance);
-            }
-        };
-    };
-
-    //typedef std::vector &lt;WedgePair&gt; WedgePairVec;
-
-public:
-    uint16_t minx, maxx; // bounding box x
-    uint16_t miny, maxy; // bounding box y
-    uint32_t area;
-    float centroidX, centroidY;
-
-    struct BestFit
-    {
-        float length;
-        float length_angle;
-        float width;
-        float width_angle;
-
-        BestFit ()
-            : length (-1),
-              length_angle (0),
-              width (-1),
-              width_angle (0)
-        {
-        }
-    };
-
-private:
-    uint32_t debug;
-    uint32_t sumOfXs;
-    uint32_t sumOfYs;
-    uint32_t num_wedges;
-    // doubles used to minimize error accumulation when generating wedges
-    double wedge_interval; // 2*PI / num_wedges
-    double wedge_arc;      // is &gt; wedge_interval if overlapped with neighbors
-    double half_wedge_arc;
-    BestFit best_fit;
-
-    //PixelLocVec outline;
-    //PixelLocVec white_pixels;
-    //WedgeVec wedges;
-    //WedgePairVec wedge_pairs;
-
-public:
-    Particle ()
-    {
-        init (debug);
-    }
-
-private:
-    void init (uint32_t a_debug)
-    {
-        minx = 0xffff;
-        maxx = 0;
-        miny = 0xffff;
-        maxy = 0;
-        area = 0;
-        centroidX = -1;
-        centroidY = -1;
-        sumOfXs = 0;
-        sumOfYs = 0;
-        num_wedges = 0;
-        wedge_arc = -1;
-        wedge_interval = -1;
-        half_wedge_arc = -1;
-        best_fit = BestFit();
-        //outline.clear();
-        //white_pixels.clear();
-        //wedges.clear();
-        //wedge_pairs.clear();
-        debug = a_debug;
-    }
-
-    void init_wedges ();
-
-    void addWhitePixel (uint16_t x, uint16_t y)
-    {
-        ++area;
-        sumOfXs += x;
-        if (x &lt; minx)
-            minx = x;
-        if (x &gt; maxx)
-            maxx = x;
-        sumOfYs += y;
-        if (y &lt; miny)
-            miny = y;
-        if (y &gt; maxy)
-            maxy = y;
-        //white_pixels.push_back (PixelLoc (x, y));
-    }
-
-    void computeCentroid ()
-    {
-        if (!area)
-        {
-            fprintf (stderr, &quot;Can't compute centroid of zero-pixel particle!\n&quot;);
-            centroidX = 0;
-            centroidY = 0;
-            return;
-        }
-        centroidX = float (sumOfXs) / area;
-        centroidY = float (sumOfYs) / area;
-    }
-
-public:
-    const BestFit &amp; getBestFit () const
-    {
-        return best_fit;
-    }
-
-    const WedgePair &amp; getMinDist () const
-    {
-/*        WedgePairVec::const_iterator wit = wedge_pairs.begin();
-#if 0
-        while (!wit-&gt;total_distance)
-            ++wit;
-#endif
-        return *wit; */
-    }
-
-    const WedgePair &amp; getMaxDist () const
-    {
-        /*WedgePairVec::const_iterator wit = wedge_pairs.end();
-        return *--wit; */
-    }
-
-    float getMinDistance () const
-    {
-        return getMinDist().total_distance;
-    }
-
-    float getMaxDistance () const
-    {
-        return getMaxDist().total_distance;
-    }
-
-    float getMinDistAngle () const
-    {
-        return getMinDist().angle;
-    }
-
-    float getMaxDistAngle () const
-    {
-        return getMaxDist().angle;
-    }
-
-    friend class ImageTool;
-};
-
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-
-struct PixelOffset
-{
-    int8_t x;
-    int8_t y;
-};
-
-class ImageTool
-{
-private:
-    uint8_t * my_pixels;
-    uint32_t my_w;
-    uint32_t my_h;
-    uint32_t my_left_margin;
-    uint32_t my_right_margin;
-    uint32_t my_top_margin;
-    uint32_t my_bottom_margin;
-    ADMImage * my_outImage;
-    uint32_t my_minArea;
-    uint32_t my_maxArea;
-    uint32_t my_flags;
-    uint32_t debug;
-    Particle my_particle;
-
-    enum TracingDirection
-    {
-        // The order of the members here is important - several things depend
-        // on it!
-
-        DIRECTION_EAST,   // x + 1, y
-        DIRECTION_SOUTH,  // x    , y + 1
-        DIRECTION_WEST,   // x - 1, y
-        DIRECTION_NORTH,  // x    , y - 1
-        DIRECTION_COUNT
-    };
-
-    enum TurnDirection
-    {
-        // These values are designed to be added to TracingDirection values.
-        TURN_RIGHT = 1,
-        TURN_AROUND = 2, // reverse
-        TURN_LEFT = 3,
-    };
-
-    static char directionLetters [];
-    static PixelOffset leftOffset [DIRECTION_COUNT];
-    static PixelOffset aheadOffset [DIRECTION_COUNT];
-
-public:
-    enum Flags
-    {
-        FLAG_NONE = 0,
-        FLAG_DO_SHAPE = 1,
-    };
-
-    ImageTool (uint8_t * pixels, uint32_t w, uint32_t h, ADMImage * outImage = 0,
-               uint32_t flags = 0)
-        : my_pixels (pixels),
-          my_w (w),
-          my_h (h),
-          my_left_margin (0),
-          my_right_margin (w),
-          my_top_margin (0),
-          my_bottom_margin (h),
-          my_outImage (outImage),
-          my_flags (flags),
-          debug (0)
-    {
-    }
-
-    void setCropping (uint32_t left_crop, uint32_t right_crop,
-                      uint32_t top_crop, uint32_t bottom_crop)
-    {
-        my_left_margin = left_crop;
-        my_right_margin = my_w - right_crop;
-        my_top_margin = top_crop;
-        my_bottom_margin = my_h - bottom_crop;
-    }
-
-    // Return true if the pixel is part of a particle.
-
-    bool goodPixel (uint8_t pixel) const
-    {
-        // HERE: If we wanted to incorporate thresholding into this step, or look
-        // for black particles on a white background, this function would be the
-        // place to make the change.
-
-        return (pixel != 0);
-    }
-
-    uint8_t &amp; getPixel (uint32_t x, uint32_t y) const
-    {
-        return my_pixels [(y * my_w) + x];
-    }
-
-    uint8_t &amp; getPixel (uint32_t index) const
-    {
-        return my_pixels [index];
-    }
-
-    // This one does bounds checking, and forces references &quot;off the edge&quot; to
-    // the nearest valid pixel - it's useful for convolutions.  It does not
-    // currently respect the crop settings, only because we know that this
-    // function is used only when those aren't set.
-
-    uint8_t &amp; getPixelSafely (int32_t x, int32_t y) const
-    {
-        if (x &lt; 0)
-            x = 0;
-        else if (x &gt;= my_w)
-            x = my_w - 1;
-
-        if (y &lt; 0)
-            y = 0;
-        else if (y &gt;= my_h)
-            y = my_h - 1;
-
-        return my_pixels [(y * my_w) + x];
-    }
-
-    uint8_t &amp; getPixelSafely (uint32_t x, uint32_t y) const
-    {
-        return getPixelSafely (static_cast &lt;int32_t&gt; (x),
-                               static_cast &lt;int32_t&gt; (y));
-    }
-
-    uint8_t &amp; outPixel (uint32_t x, uint32_t y) const
-    {
-        return YPLANE (my_outImage) [(y * my_w) + x];
-    }
-
-    uint8_t &amp; outUPixel (uint32_t x, uint32_t y) const
-    {
-        return UPLANE (my_outImage) [((y &gt;&gt; 2) * my_w) + (x &gt;&gt; 1)];
-    }
-
-    uint8_t &amp; outVPixel (uint32_t x, uint32_t y) const
-    {
-        return VPLANE (my_outImage) [((y &gt;&gt; 2) * my_w) + (x &gt;&gt; 1)];
-    }
-
-    bool validPixel (uint32_t x, uint32_t y) const
-    {
-        // return (x &lt; my_w &amp;&amp; y &lt; my_h);
-        return (x &gt;= my_left_margin &amp;&amp; x &lt; my_right_margin
-                &amp;&amp; y &gt;= my_top_margin &amp;&amp; y &lt; my_bottom_margin);
-    }
-
-    bool goodPixel (uint32_t x, uint32_t y) const
-    {
-        // HERE: this might be a good place to implement ROI (region of
-        // interest) if we want that.
-
-        return (validPixel (x, y) &amp;&amp; goodPixel (getPixel (x, y)));
-    }
-
-    uint32_t width () const
-    {
-        return my_w;
-    }
-
-    uint32_t height () const
-    {
-        return my_h;
-    }
-
-#if 0
-    uint32_t particleArea () const
-    {
-        return my_particle.area;
-    }
-
-    float particleCentroidX () const
-    {
-        return my_particle.centroidX;
-    }
-
-    float particleCentroidY () const
-    {
-        return my_particle.centroidY;
-    }
-#endif
-
-    const Particle &amp; getParticle () const
-    {
-        return my_particle;
-    }
-
-    uint8_t autoOutline (uint32_t x, uint32_t y);
-
-    enum ShowStuff
-    {
-        SHOW_NOTHING = 0,
-        SHOW_INPUT          = 0x0001,
-        SHOW_OUTLINE        = 0x0002,
-        SHOW_WEDGE_PIXELS   = 0x0004,
-        SHIFT_PAST_SHOW_FLAGS = 4, // leave room for one more for now
-    };
-
-    void showStuff (ShowStuff what) const;
-
-    // implementation is in ADM_vidSwissArmyKnife.cpp - nothing else uses it
-    // (currently).
-/*
-    template &lt;class Oper, class Histo&gt;
-    void convolve (const std::vector &lt;float&gt; &amp; kernel,
-                   uint32_t kw, uint32_t kh, int32_t bias, const Oper &amp; op,
-                   const Histo &amp; histogram_in); */
-
-    void setDebug (uint32_t newDebug)
-    {
-        debug = newDebug;
-    }
-
-    void setMinArea (uint32_t newMinArea)
-    {
-        my_minArea = newMinArea;
-    }
-
-    void setMaxArea (uint32_t newMaxArea)
-    {
-        my_maxArea = newMaxArea;
-    }
-};
-
-struct MenuMapping;
-uint8_t DIA_particle (AVDMGenericVideoStream *in,
-                      ADMVideoParticle * particlep,
-                      PARTICLE_PARAM * param,
-                      const MenuMapping * menu_mapping,
-                      uint32_t menu_mapping_count);
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,3252 +0,0 @@
-/***************************************************************************
-                          ADM_vidSwissArmyKnife.cpp  -  Perform one of many
-                                                        possible operations
-                             -------------------
-                          Chris MacGregor, 2005, 2007
-                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#include &quot;ADM_default.h&quot;
-
-#include &lt;ctype.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;math.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;iterator&gt;
-
-#include &quot;fourcc.h&quot;
-#include &quot;avi_vars.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-#include &quot;ADM_encoder/adm_encoder.h&quot;
-
-#include &quot;ADM_filter/video_filters.h&quot;
-
-#include &quot;DIA_factory.h&quot;
-
-#include &quot;ADM_vidSwissArmyKnife.h&quot;
-#include &quot;ADM_vidParticle.h&quot; // for ImageTool
-#include &quot;ADM_vidComputeAverage.h&quot; // for ADMVideoComputeAverage::FileHeader
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.h&quot; // for MenuMapping
-
-static const int MAX_PIXEL_LUMA = 255;
-
-static FILTER_PARAM swissArmyKnifeParam =
-{
-    16,
-    { &quot;tool&quot;, &quot;input_type&quot;, &quot;input_file&quot;, &quot;load_bias&quot;,              // 4
-      &quot;load_multiplier&quot;, &quot;input_constant&quot;, &quot;memory_constant_alpha&quot;, // + 3 = 7
-      &quot;lookahead_n_frames&quot;, &quot;init_start_frame&quot;, &quot;init_end_frame&quot;,   // + 3 = 10
-      &quot;init_by_rolling&quot;, &quot;bias&quot;, &quot;result_bias&quot;,                     // + 3 = 13
-      &quot;result_multiplier&quot;, &quot;histogram_frame_interval&quot;, &quot;debug&quot;      // + 3 = 16
-    }
-};
-
-ADMVideoSwissArmyKnife::ToolMap ADMVideoSwissArmyKnife::tool_map [] =
-{
-    { TOOL_A,         &quot;A&quot;,        &quot;%s&quot;,        &quot;%s&quot;     },
-    { TOOL_P,         &quot;P&quot;,        &quot;P&quot;,         &quot;P&quot;      },
-    { TOOL_P_MINUS_A, &quot;P-A&quot;,      &quot;P-%s&quot;,      &quot;P - %s&quot; },
-    { TOOL_A_MINUS_P, &quot;A-P&quot;,      &quot;%s-P&quot;,      &quot;%s - P&quot; },
-    { TOOL_P_PLUS_A,  &quot;P+A&quot;,      &quot;P+%s&quot;,      &quot;P + %s&quot; },
-    { TOOL_P_TIMES_A, &quot;P*A&quot;,      &quot;P*%s&quot;,      &quot;P * %s&quot; },
-    { TOOL_P_DIVBY_A, &quot;P/A&quot;,      &quot;P/%s&quot;,      &quot;P / %s&quot; },
-    { TOOL_A_DIVBY_P, &quot;A/P&quot;,      &quot;%s/P&quot;,      &quot;%s / P&quot; },
-    { TOOL_MIN_P_A,   &quot;min(P,A)&quot;, &quot;min(P,%s)&quot;, &quot;min (P, %s)&quot; },
-    { TOOL_MAX_P_A,   &quot;max(P,A)&quot;, &quot;max(P,%s)&quot;, &quot;max (P, %s)&quot; },
-
-    { TOOL_INVALID, 0, 0, 0 }
-};
-
-// This is a hack to work around the fact that the ctor &amp; dtor get called
-// too often.  The right solution would be to arrange for the filter
-// objects to be constructed and destructed only when really necessary:
-// when a new instance of a filter is added to the list (by the user), it
-// is constructed, and when it is removed from the list (by the user), it
-// is destructed, and anything else is handled by a separate init() or
-// configure() method.  This would allow the objects to maintain a
-// persistent state in a more straightforward way.
-
-ADMVideoSwissArmyKnife::PImap ADMVideoSwissArmyKnife::pimap;
-
-
-SCRIPT_CREATE(swissarmyknife_script,ADMVideoSwissArmyKnife,swissArmyKnifeParam);
-
-BUILD_CREATE(swissarmyknife_create,ADMVideoSwissArmyKnife);
-
-ADMVideoSwissArmyKnife::ADMVideoSwissArmyKnife (AVDMGenericVideoStream *in, CONFcouple *couples)
-{
-    _in = in;
-    memcpy (&amp;_info, in-&gt;getInfo(), sizeof(_info));
-    _info.encoding = 1;
-    _uncompressed = new ADMImage (_in-&gt;getInfo()-&gt;width, _in-&gt;getInfo()-&gt;height);
-    ADM_assert (_uncompressed);
-    _param = new SWISSARMYKNIFE_PARAM;
-
-    if (couples)
-    {
-        GET(tool);
-        GET(input_type);
-
-        char* tmp;
-        GET2(input_file, tmp);
-        GET(load_bias);
-        GET(load_multiplier);
-
-        GET(input_constant);
-
-        GET(memory_constant_alpha);
-        GET(lookahead_n_frames);
-        GET(init_start_frame);
-        GET(init_end_frame);
-        GET(init_by_rolling);
-
-        GET(bias);
-        GET(result_bias);
-        GET(result_multiplier);
-        GET(histogram_frame_interval);
-        GET(debug);
-
-        _param-&gt;enable_preview
-            = (_param-&gt;input_type != INPUT_ROLLING_AVERAGE);
-    }
-    else
-    {
-        _param-&gt;tool = TOOL_P_MINUS_A;
-        _param-&gt;input_type = INPUT_ROLLING_AVERAGE;
-
-        // _param-&gt;input_file = &quot;&quot;; // implicit
-        _param-&gt;load_bias = 0.0;
-        _param-&gt;load_multiplier = 1.0;
-
-        _param-&gt;input_constant = 0;
-
-        _param-&gt;memory_constant_alpha = 1.0 / _param-&gt;init_end_frame;
-        _param-&gt;lookahead_n_frames = 0;
-        _param-&gt;init_start_frame = 0;
-        _param-&gt;init_end_frame = 99;
-        _param-&gt;init_by_rolling = false;
-
-        _param-&gt;bias = 128;
-        _param-&gt;result_bias = 0.0;
-        _param-&gt;result_multiplier = 1.0;
-        _param-&gt;histogram_frame_interval = 0;
-        _param-&gt;debug = 0;
-
-        _param-&gt;enable_preview = false;
-    }
-
-    // This is a hack to work around the fact that the ctor &amp; dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    // This explicit check wouldn't be necessary if there was an easier way of
-    // ensuring that we got a 0 pointer when a new map entry was auto-consed
-    // up...
-
-    if (pimap.count (couples) == 0)
-    {
-        myInfo = new PersistentInfo;
-        myInfo-&gt;conf = couples;
-        pimap [couples] = myInfo;
-    }
-    else
-    {
-        myInfo = pimap [couples];
-        if (couples)
-        {
-            if (myInfo-&gt;oldConf == couples)
-            {
-                pimap.erase (myInfo-&gt;conf);
-                myInfo-&gt;conf = myInfo-&gt;oldConf;
-                myInfo-&gt;oldConf = 0;
-            }
-            else
-            {
-                ADM_assert (myInfo-&gt;conf == couples);
-
-                if (myInfo-&gt;oldConf)
-                {
-                    pimap.erase (myInfo-&gt;oldConf);
-                    myInfo-&gt;oldConf = 0;
-                }
-            }
-        }
-    }
-
-    myInfo-&gt;refCount++;
-
-    printf (&quot;ADMVideoSwissArmyKnife ctor (%p, conf = %p), pi = %p, rc now %d\n&quot;,
-            this, couples, myInfo, myInfo-&gt;refCount);
-}
-
-uint8_t	ADMVideoSwissArmyKnife::getCoupledConf (CONFcouple **couples)
-{
-
-    ADM_assert (_param);
-    *couples = new CONFcouple (swissArmyKnifeParam.nb);
-
-    // This is a hack to work around the fact that the ctor &amp; dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    printf(&quot;ADMVideoSwissArmyKnife::getCoupledConf(): this = %p, couples = %p, &quot;
-           &quot;oldConf = %p (was %p), pi = %p\n&quot;,
-           this, *couples, myInfo-&gt;conf, myInfo-&gt;oldConf, myInfo);
-
-    if (myInfo-&gt;oldConf)
-        pimap.erase (myInfo-&gt;oldConf);
-    myInfo-&gt;oldConf = myInfo-&gt;conf;
-    myInfo-&gt;conf = *couples;
-    pimap [myInfo-&gt;conf] = myInfo;
-    if (myInfo-&gt;oldConf == 0)
-        pimap.erase (0);
-
-    CSET(tool);
-    CSET(input_type);
-
-    (*couples)-&gt;setCouple(&quot;input_file&quot;, _param-&gt;input_file.c_str());
-    CSET(load_bias);
-    CSET(load_multiplier);
-
-    CSET(input_constant);
-
-    CSET(memory_constant_alpha);
-    CSET(lookahead_n_frames);
-    CSET(init_start_frame);
-    CSET(init_end_frame);
-    CSET(init_by_rolling);
-
-    CSET(bias);
-    CSET(result_bias);
-    CSET(result_multiplier);
-    CSET(histogram_frame_interval);
-    CSET(debug);
-
-    return 1;
-}
-
-uint8_t ADMVideoSwissArmyKnife::configure (AVDMGenericVideoStream *in)
-{
-    diaMenuEntry tTool [] = {
-        { TOOL_A,          QT_TR_NOOP(&quot;P' = A&quot;), NULL },
-        { TOOL_P,          QT_TR_NOOP(&quot;P' = P&quot;), NULL },
-        { TOOL_P_MINUS_A,  QT_TR_NOOP(&quot;P' = P - A&quot;), NULL },
-        { TOOL_A_MINUS_P,  QT_TR_NOOP(&quot;P' = A - P&quot;), NULL },
-        { TOOL_P_PLUS_A,   QT_TR_NOOP(&quot;P' = P + A&quot;), NULL },
-        { TOOL_P_TIMES_A,  QT_TR_NOOP(&quot;P' = P * A&quot;), NULL },
-        { TOOL_P_DIVBY_A,  QT_TR_NOOP(&quot;P' = P / A&quot;), NULL },
-        { TOOL_A_DIVBY_P,  QT_TR_NOOP(&quot;P' = A / P&quot;), NULL },
-        { TOOL_MIN_P_A,    QT_TR_NOOP(&quot;P' = min (P, A)&quot;), NULL },
-        { TOOL_MAX_P_A,    QT_TR_NOOP(&quot;P' = max (P, A)&quot;), NULL }
-    };
-
-    diaMenuEntry tInputType [] = {
-        { INPUT_CUSTOM_CONVOLUTION,
-          QT_TR_NOOP(&quot;A = convolve(P); Load convolution kernel from file&quot;), NULL },
-        { INPUT_FILE_IMAGE_FLOAT,
-          QT_TR_NOOP(&quot;A = pixel from image file as float; Load image from file&quot;), NULL },
-        { INPUT_FILE_IMAGE_INTEGER,
-          QT_TR_NOOP(&quot;A = pixel from image file as integer; Load image from file&quot;), NULL },
-        { INPUT_CONSTANT_VALUE,
-          QT_TR_NOOP(&quot;A = floating point constant value&quot;), NULL },
-        { INPUT_ROLLING_AVERAGE,
-          QT_TR_NOOP(&quot;A = rolling average of pixel: A = A*(1-alpha)+(P*alpha)&quot;), NULL },
-    };
-
-    diaElemMenu tool
-        (&amp;(_param-&gt;tool),
-         QT_TR_NOOP(&quot;Select _Operation on each pixel P and input A:&quot;),
-         sizeof (tTool) / sizeof (diaMenuEntry), tTool);
-
-    diaElemMenu input_type
-        (&amp;(_param-&gt;input_type),
-         QT_TR_NOOP(&quot;Input _Type:&quot;),
-         sizeof (tInputType) / sizeof (diaMenuEntry), tInputType);
-
-    MenuMapping menu_mapping [] = {
-        { &quot;operationMenu&quot;, my_offsetof (SWISSARMYKNIFE_PARAM, tool),
-          sizeof (tTool) / sizeof (diaMenuEntry), tTool },
-        { &quot;inputTypeMenu&quot;, my_offsetof (SWISSARMYKNIFE_PARAM, input_type),
-          sizeof (tInputType) / sizeof (diaMenuEntry), tInputType },
-    };
-
-    // printf (&quot;ADM_vidSwissArmyKnife: _param = %p\n&quot;, _param);
-    uint8_t ret = DIA_SwissArmyKnife (_in, this, _param, menu_mapping,
-                                      sizeof (menu_mapping)
-                                      / sizeof (MenuMapping));
-    if (ret == 1)
-    {
-        return ret;
-    }
-    else if (ret == 0) // 0 = cancel
-    {
-        return ret;
-    }
-    else
-    {
-        ADM_assert (ret == 255); // 255 = whizzy dialog not implemented
-    }
-
-    char * file = ADM_strdup (_param-&gt;input_file.c_str());
-
-    diaElemFile input_file
-        (0, &amp;file,
-         QT_TR_NOOP(&quot;Input _File (image or convolution kernel):&quot;), NULL, QT_TR_NOOP(&quot;Select file&quot;));
-    diaElemFloat load_bias
-        (&amp;(_param-&gt;load_bias),
-         QT_TR_NOOP(&quot;_Load Bias (added to each pixel\n&quot;
-           &quot;in file image when loaded):&quot;),
-         -99999, +99999); // arbitrary!
-    diaElemFloat load_multiplier
-        (&amp;(_param-&gt;load_multiplier),
-         QT_TR_NOOP(&quot;Load _Multiplier (each pixel in\n&quot;
-           &quot;file image mult. by this when loaded):&quot;),
-         -99999, +99999); // arbitrary!
-
-    diaElemFloat input_constant
-        (&amp;(_param-&gt;input_constant),
-         QT_TR_NOOP(&quot;Input _Constant:&quot;), -99999, +99999); // arbitrary!
-
-    diaElemFloat memory_constant_alpha
-        (&amp;(_param-&gt;memory_constant_alpha),
-         QT_TR_NOOP(&quot;Memory constant _alpha\n&quot;
-           &quot;(where A = (1-alpha)*A + alpha*(curr_frame + lookahead)):&quot;),
-         0, 0x7fffffff);
-    diaElemUInteger lookahead_n_frames
-        (&amp;(_param-&gt;lookahead_n_frames),
-         QT_TR_NOOP(&quot;Look ahead _N frames:&quot;),
-         0, 0x7fffffff);
-    diaElemUInteger init_start_frame
-        (&amp;(_param-&gt;init_start_frame),
-         QT_TR_NOOP(&quot;Init _Start Frame (first frame # to use for head start):&quot;),
-         0, 0x7fffffff);
-    diaElemUInteger init_end_frame
-        (&amp;(_param-&gt;init_end_frame),
-         QT_TR_NOOP(&quot;Init _End Frame (last frame # to use for head start):&quot;),
-         0, 0x7fffffff);
-    diaElemToggle init_by_rolling
-        (&amp;(_param-&gt;init_by_rolling),
-         QT_TR_NOOP(&quot;Init By _Rolling (compute head start using a &quot;
-           &quot;rolling average rather than a straight average)&quot;));
-
-    diaElemSlider bias
-        (&amp;(_param-&gt;bias),
-         QT_TR_NOOP(&quot;_Bias (will be added to result):&quot;), -256, +256);
-    diaElemFloat result_bias
-        (&amp;(_param-&gt;result_bias),
-         QT_TR_NOOP(&quot;_Result Bias (added to each result pixel):&quot;),
-         -99999, +99999); // arbitrary!
-    diaElemFloat result_multiplier
-        (&amp;(_param-&gt;result_multiplier),
-         QT_TR_NOOP(&quot;Result _Multiplier (each result pixel\n&quot;
-           &quot;multiplied by this):&quot;),
-         -99999, +99999); // arbitrary!
-    diaElemUInteger histogram_frame_interval
-        (&amp;(_param-&gt;histogram_frame_interval),
-         QT_TR_NOOP(&quot;_Histogram every N frames (0 to disable):&quot;), 0, 0x7fffffff);
-    diaElemUInteger debug
-        (&amp;(_param-&gt;debug), QT_TR_NOOP(&quot;_Debugging settings (bits):&quot;), 0, 0x7fffffff);
-
-    diaElem * elems[] = { &amp;tool, &amp;input_type, &amp;input_file, &amp;load_bias,
-                          &amp;load_multiplier, &amp;input_constant,
-                          &amp;memory_constant_alpha, &amp;lookahead_n_frames,
-                          &amp;init_start_frame, &amp;init_end_frame,
-                          &amp;init_by_rolling, &amp;bias, &amp;result_bias,
-                          &amp;result_multiplier, &amp;histogram_frame_interval,
-                          &amp;debug };
-
-    ret = diaFactoryRun (QT_TR_NOOP(&quot;Swiss Army Knife Configuration&quot;),
-                         sizeof (elems) / sizeof (diaElem *), elems);
-    if (ret) // 0 = cancel
-    {
-        myInfo-&gt;image_data_invalid = true;
-        myInfo-&gt;histogram_data_invalid = true;
-    }
-
-    _param-&gt;input_file = file;
-    delete[] file;
-
-    return ret;
-}
-
-ADMVideoSwissArmyKnife::~ADMVideoSwissArmyKnife()
-{
-    // This is a hack to work around the fact that the ctor &amp; dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    myInfo-&gt;refCount--;
-    printf (&quot;ADMVideoSwissArmyKnife dtor (%p), conf = %p, pi = %p, rc now %d\n&quot;,
-            this, myInfo-&gt;conf, myInfo, myInfo-&gt;refCount);
-
-    if (myInfo-&gt;oldConf)
-    {
-        pimap.erase (myInfo-&gt;oldConf);
-        myInfo-&gt;oldConf = 0;
-    }
-
-    if (myInfo-&gt;refCount &lt; 1)
-    {
-        pimap.erase (myInfo-&gt;conf);
-        delete myInfo;
-    }
-
-    DELETE(_param);
-    delete _uncompressed;
-    _uncompressed = NULL;
-}
-
-char * ADMVideoSwissArmyKnife::printConf ()
-{
-    return getConf (_param, false);
-}
-
-char * ADMVideoSwissArmyKnife::getConf (SWISSARMYKNIFE_PARAM * param,
-                                        bool forDialog)
-{
-    const int CONF_LEN = 1024;
-    static char conf[CONF_LEN];
-
-    ToolMap * tm;
-    for (tm = tool_map; tm-&gt;outputName; tm++)
-        if (tm-&gt;toolid == param-&gt;tool)
-            break;
-
-    char inputstr [CONF_LEN];
-    char where [256];
-    where[0] = '\0';
-    char moreinfo [256];
-    moreinfo[0] = '\0';
-    const char * input_file = param-&gt;input_file.c_str();
-    if (!input_file || !*input_file)
-        input_file = &quot;**** no file selected ****&quot;;
-
-    const char * space = forDialog ? &quot; &quot; : &quot;&quot;;
-    char * cptr;
-
-    switch (param-&gt;input_type)
-    {
-    case INPUT_CUSTOM_CONVOLUTION:
-        snprintf (inputstr, CONF_LEN, &quot;convolve%s(P,%s%s)&quot;,
-                  space, space, input_file);
-        break;
-    case INPUT_FILE_IMAGE_FLOAT:
-        snprintf (inputstr, CONF_LEN,
-                  (param-&gt;load_bias == 0.0 &amp;&amp; param-&gt;load_multiplier == 1.0)
-                  ? &quot;pixel_from%s(%s)&quot;
-                  : (forDialog ? &quot;((pixel_from%s(%s) + %.6f) * %.6f)&quot;
-                     : &quot;((pixel_from%s(%s)%+.6f)*%.6f)&quot;),
-                  space, input_file,
-                  param-&gt;load_bias, param-&gt;load_multiplier);
-        break;
-    case INPUT_FILE_IMAGE_INTEGER:
-        snprintf (inputstr, CONF_LEN,
-                  (param-&gt;load_bias == 0.0 &amp;&amp; param-&gt;load_multiplier == 1.0)
-                  ? &quot;integer(pixel_from%s(%s))&quot;
-                  : (forDialog ? &quot;integer((pixel_from%s(%s) + %.6f) * %.6f)&quot;
-                     : &quot;integer((pixel_from%s(%s)%+.6f)*%.6f)&quot;),
-                  space, input_file,
-                  param-&gt;load_bias, param-&gt;load_multiplier);
-        break;
-    case INPUT_CONSTANT_VALUE:
-        if (int (param-&gt;input_constant) == param-&gt;input_constant)
-            sprintf (inputstr, &quot;%d&quot;, int (param-&gt;input_constant));
-        else
-            sprintf (inputstr, &quot;%.6f&quot;, param-&gt;input_constant);
-        break;
-    case INPUT_ROLLING_AVERAGE:
-        sprintf (inputstr, &quot;A&quot;);
-        cptr = where + sprintf (where, &quot; (where each frame, &quot;
-                                &quot;A=(A*(1-alpha))+(P*alpha), alpha%s=%s%.6f&quot;,
-                                space, space, param-&gt;memory_constant_alpha);
-        if (param-&gt;lookahead_n_frames)
-            sprintf (cptr, &quot;, P = pixel from %d frames ahead)&quot;,
-                     param-&gt;lookahead_n_frames);
-        else
-            strcpy (cptr, &quot;)&quot;);
-        if (param-&gt;init_start_frame &lt;= param-&gt;init_end_frame)
-            sprintf (moreinfo, &quot;, initial A = %s avg of frames %u - %u&quot;,
-                     param-&gt;init_by_rolling ? &quot;rolling&quot; : &quot;straight&quot;,
-                     param-&gt;init_start_frame, param-&gt;init_end_frame);
-        break;
-    default:
-        sprintf (inputstr, &quot;OOOPS!! (unexpected type %d)&quot;,
-                 param-&gt;input_type);
-        break;
-    }
-
-    cptr = conf;
-
-    bool result_is_scaled
-        = (param-&gt;result_bias != 0.0 || param-&gt;result_multiplier != 1.0);
-
-    if (!forDialog)
-        cptr += snprintf (conf, CONF_LEN, &quot;Swiss Army Knife: &quot;);
-    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), &quot;P' = %s&quot;,
-                      result_is_scaled ? &quot;((&quot; : &quot;&quot;);
-    cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                      forDialog ? tm-&gt;spacy_format : tm-&gt;format, inputstr);
-    if (param-&gt;bias)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          forDialog ? &quot; + %d&quot; : &quot;%+d&quot;, param-&gt;bias);
-    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), &quot;%s&quot;, where);
-    if (result_is_scaled)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          forDialog ? &quot;) + %.6f) * %.6f&quot; : &quot;)%+.6f)*%.6f&quot;,
-                          param-&gt;result_bias, param-&gt;result_multiplier);
-    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), &quot;%s&quot;, moreinfo);
-    if (param-&gt;histogram_frame_interval)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          &quot;, histogram every %u frames&quot;,
-                          param-&gt;histogram_frame_interval);
-    if (param-&gt;debug)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          &quot;, debug%s=%s0x%x&quot;, space, space, param-&gt;debug);
-    if (!forDialog)
-        fprintf (stderr, &quot;SAK conf is (%d) \&quot;%s\&quot;\n&quot;, cptr - conf, conf);
-    return conf;
-}
-
-//============================================================================
-
-// Note: The structure of the following code (with the template functions, and
-// the functor objects, etc.) is all about minimizing the code executed
-// per-pixel.  We need to select an input (convolution, etc.), and an
-// operation to apply that input to each pixel (P' = P - A, etc.), and
-// optionally scale the result, and optionally collect a histogram...but we
-// don't want any more if's or pointer (or reference dereferences) in the
-// per-pixel core of the loop than we absolutely must have, and we certainly
-// don't want any switches or function calls.  At the same time, we don't want
-// to duplicate the code that humans have to deal with - that's the whole
-// point of templates.  So, buckle your seat belts, because this is where C++
-// gets really fun!
-
-//============================================================================
-
-class HistogramNull // do-nothing version
-{
-public:
-    static
-    void reset()
-    {
-    }
-    static
-    void record_input (uint8_t P)
-    {
-    }
-    static
-    void record_output (int32_t P)
-    {
-    }
-    static
-    void dump (uint32_t frame_count, uint32_t pixels_per_frame)
-    {
-    }
-    static
-    bool frame_check ()
-    {
-        return false;
-    }
-};
-
-//----------------------------------------------------------------------------
-
-class Histogram
-{
-public:
-    // Optionally, we could make this a template class with range_size a
-    // template parameter.  However, it would have to be used in more than one
-    // place, with different range sizes, for that to be worth doing.
-
-    static const int32_t input_range_size = 256; // 8 bit pixels
-    static const int32_t range_size = 1024; // This must be a power of 2!
-    static const int32_t midpoint = 128;
-    static const int32_t range_min = midpoint - (range_size / 2);
-    static const int32_t range_max = midpoint + (range_size / 2) - 1;
-    static const int32_t out_of_range_mask = ~(range_size - 1);
-
-    uint32_t * input_data;
-    uint32_t * output_data;
-    uint32_t pixels_per_frame;
-    uint32_t &amp; frame_count;
-    uint32_t frame_interval;
-
-    // The default copy ctor and assignment operators are just fine in this
-    // case!  Also, note that the ctor allocates the memory and sets the
-    // pointers to which it is passed references, but does not keep the
-    // references (since it won't need to change those pointers again) - it
-    // keeps local copies instead, to avoid later indirections.  It does store
-    // a reference to the frame_count for use in frame_check().
-
-    Histogram (uint32_t * &amp; input_data_ref, uint32_t * &amp; output_data_ref,
-               uint32_t frame_interval, uint32_t &amp; frame_count,
-               uint32_t pixels_per_frame)
-        : input_data (input_data_ref),
-          output_data (output_data_ref),
-          pixels_per_frame (pixels_per_frame),
-          frame_count (frame_count),
-          frame_interval (frame_interval)
-    {
-        if (!input_data)
-        {
-            input_data = input_data_ref = new uint32_t [input_range_size];
-            output_data = output_data_ref = new uint32_t [range_size];
-            // printf (&quot;histogram: allocated data at %p, %p\n&quot;,
-            //         input_data, output_data);
-            reset();
-        }
-        else
-            ;// printf (&quot;histogram: using data at %p, %p\n&quot;,
-             //         input_data, output_data);
-    }
-
-    // no dtor needed - deallocation is handled elsewhere
-
-    void reset () const
-    {
-        memset (input_data, 0, input_range_size * sizeof (input_data[0]));
-        memset (output_data, 0, range_size * sizeof (output_data[0]));
-        frame_count = 0;
-    }
-
-    void record_input (uint8_t P) const
-    {
-        input_data[P]++;
-    }
-
-    void record_output (int32_t P) const
-    {
-        P -= range_min; // scale into histogram data array index
-        if ((P &amp; out_of_range_mask) == 0)
-        {
-            output_data[P]++;
-            return;
-        }
-
-        if (P &lt; 0)
-            P = 0;
-        else if (P &gt;= range_size)
-            P = range_size - 1;
-
-        output_data[P]++;
-    }
-
-    void dump () const
-    {
-        int32_t index_min = 0;
-        int32_t index_max = range_size - 1;
-        while (index_min &lt; index_max)
-        {
-            if (output_data[index_min])
-                break;
-            ++index_min;
-        }
-        while (index_min &lt; index_max)
-        {
-            if (output_data[index_max])
-                break;
-            --index_max;
-        }
-        
-        printf (&quot;Swiss Army Knife Histogram for past %u frames:\n&quot;
-                &quot; =================== Input (0 - 255), &quot;
-                &quot;avg/frame over %d frames: ====================\n&quot;,
-                frame_count, frame_count);
-        do_dump (input_data, 0, 255, 0);
-        printf (&quot;=========== Result before saturation (%d - %d), &quot;
-                &quot;avg/frame over %d frames: ==========\n&quot;,
-                index_min + range_min, index_max + range_min, frame_count);
-        do_dump (output_data, index_min, index_max, range_min);
-    }
-
-    // returns true if it outputs data and resets the counter, else false.
-
-    bool frame_check () const
-    {
-        if (++frame_count &lt; frame_interval)
-        {
-            // printf (&quot;histogram: frame %d of %d\n&quot;,
-            //         frame_count, frame_interval);
-            return false;
-        }
-
-        dump();
-        reset();
-        return true;
-    }
-
-private:
-    void do_dump (uint32_t * data, int32_t index_min, int32_t index_max,
-                  int32_t bias) const
-    {
-        // We scan the data to find the maximum value, so we can scale the
-        // bars to provide useful visual data.
-
-        uint32_t max_pixels = 0;
-        for (int32_t index = index_min; index &lt;= index_max; index++)
-        {
-            if (data[index] &gt; max_pixels)
-                max_pixels = data[index];
-        }
-
-        // Effectively, for each pixel-value count, we divide by the frame
-        // count to get the average number of times that pixel value occurred
-        // per frame, and then we scale the bar so that only the max number of
-        // pixels gets 100% of the bar.
-
-        const int32_t bar_max = 11; // hardcoded as %11s in printf below
-#if 0
-        max_pixels /= frame_count;
-        int32_t divisor = frame_count * max_pixels / bar_max;
-#else
-        int32_t divisor = max_pixels / bar_max;
-#endif
-
-        const int32_t columns = 4;
-        // The &quot;+ columns&quot; below is to round up to the total number of rows we
-        // need including partial rows; it's really &quot;+ 1 + (columns - 1)&quot;,
-        // where the + 1 is to account for index_max being the top end of the
-        // range, not the top end + 1.
-        int32_t column_len = (index_max - index_min + columns) / columns;
-
-        int32_t column_end = index_min + column_len;
-
-        const char * bar = &quot;*********************************************&quot;;
-        const char * bar_end = bar + strlen (bar);
-
-        for (int32_t index = index_min; index &lt; column_end; index++)
-        {
-            int32_t index2 = index;
-            int32_t val = index + bias;
-            
-            for (int32_t column = 0;
-                 column &lt; columns;
-                 ++column, index2 += column_len, val += column_len)
-            {
-                if (index2 &gt; index_max)
-                    break;
-
-                int32_t dat = data[index2];
-                int32_t bar_size = dat / divisor;
-                if (bar_size == 0 &amp;&amp; dat != 0)
-                    bar_size = 1;
-#define HISTOGRAM_SHOW_VALUES 1
-#ifdef HISTOGRAM_SHOW_VALUES
-                printf (&quot; %5d: %6d %-11s&quot;, val, dat / frame_count, bar_end - bar_size);
-#else
-                printf (&quot; %5d: %-11s&quot;, val, bar_end - bar_size);
-#endif
-            }
-            printf (&quot;\n&quot;);
-        }
-    }
-};
-
-//============================================================================
-/*
-template &lt;typename Oper, typename Histo&gt;
-void ImageTool::convolve (const std::vector &lt;float&gt; &amp; kernel,
-                          uint32_t kw, uint32_t kh, int32_t bias,
-                          const Oper &amp; op_in, const Histo &amp; histogram_in)
-{
-    // We make local copies of the functors so that the calls below to
-    // record_input() and record_output() (for the histogram) and operator()
-    // (for the op) are accessing stack data rather than incurring yet another
-    // indirection.  When it's per-pixel, every little bit helps!
-
-    Histo histogram = histogram_in;
-    Oper op = op_in;
-
-    uint32_t sathigh = 0;
-    uint32_t satlow = 0;
-
-    // The following code is copied with little significant change (mostly
-    // just porting &amp; performance tweaks, and adding some debugging output)
-    // from ImageJ's Convolver::convolveFloat() function.  Blame them for
-    // variable names like &quot;uc&quot;. ;-)
-
-    // We have (for the moment) skipped the normalizing step - we assume that
-    // the scale is 1.0.
-
-    // We also assume that kw and kh are both odd.
-
-    int32_t uc = kw / 2;
-    int32_t vc = kh / 2;
-
-    uint32_t xedge = my_w - uc;
-    uint32_t yedge = my_h - vc;
-
-    for (uint32_t y = 0; y &lt; my_h; y++)
-    {
-        bool y_is_edgy = (y &lt; vc || y &gt;= yedge);
-
-        for (uint32_t x = 0; x &lt; my_w; x++)
-        {
-            float sum = 0;
-            uint32_t i = 0;
-
-            // If some of this pixel's neighbors are &quot;off the edge&quot; of the
-            // input image, we'll use the &quot;safe&quot; getPixel().
-
-            if (y_is_edgy || x &lt; uc || x &gt;= xedge)
-            {
-                for (int32_t v = -vc; v &lt;= vc; v++)
-                    for (int32_t u = -uc; u &lt;= uc; u++)
-                        sum += getPixelSafely (x + u, y + v) * kernel [i++];
-            }
-            else
-            {
-                // HERE: we could optimize this a good bit by putting
-                // &amp;(getPixel(x - uc, y - vc)) into a pointer, then just
-                // incrementing the pointer (and adding a precomputed (my_w -
-                // uc * 2) to shift lines).  It violates the nice
-                // encapsulation provided by ImageTool, but if/when we add a
-                // SIMD version of this loop, that sure isn't going to use
-                // GetPixel()... ;-)
-
-                for (int32_t v = -vc; v &lt;= vc; v++)
-                {
-                    int32_t offset = x + ((y + v) * my_w);
-
-                    for (int32_t u = -uc; u &lt;= uc; u++)
-                        sum += getPixel (offset + u) * kernel [i++];
-                }
-            }
-
-            // as noted above, we're currently assuming the matrix was already
-            // normalized...
-            // sum *= scale;
-
-            int32_t P = getPixel (x, y);
-
-            histogram.record_input (P);
-
-            float A = sum;
-
-            int32_t result = op (P, A) + bias;
-
-            histogram.record_output (result);
-
-            if (result &amp; 0xffffff00)
-            {
-                if (result &lt; 0)
-                {
-                    result = 0;
-                    satlow++;
-                }
-                else // if (result &gt; 255)
-                {
-                    result = 255;
-                    sathigh++;
-                }
-            }
-
-            outPixel (x, y) = result;
-        }
-    }
-
-    if (debug &amp; 2)
-    {
-        if (satlow || sathigh)
-            printf (&quot;    Saturated %d low, %d high\n&quot;, satlow, sathigh);
-    }
-}
-*/
-//============================================================================
-
-template &lt;typename Oper, typename Histo&gt;
-void ADMVideoSwissArmyKnife::computeRollingAverage (ADMImage * image,
-                                                    ADMImage * data,
-                                                    uint32_t planesize,
-                                                    SWISSARMYKNIFE_PARAM * param,
-                                                    int32_t bias,
-                                                    const Oper &amp; op_in,
-                                                    const Histo &amp; histogram_in)
-{
-    // We make local copies of the functors so that the calls below to
-    // record_input() and record_output() (for the histogram) and operator()
-    // (for the op) are accessing stack data rather than incurring yet another
-    // indirection.  When it's per-pixel, every little bit helps!
-
-    Histo histogram = histogram_in;
-    Oper op = op_in;
-
-    float alpha = param-&gt;memory_constant_alpha;
-    float oneminusalpha = 1 - alpha;
-
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    float * bgp = myInfo-&gt;bg + planesize;
-    uint32_t pixremaining = planesize + 1;
-
-    uint32_t sathigh = 0;
-    uint32_t satlow = 0;
-
-    while (--pixremaining)
-    {
-        int32_t P = *--currp;
-        histogram.record_input (P);
-
-        float A = *--bgp;
-        *bgp = (A * oneminusalpha) + (P * alpha);
-
-        int32_t result = op (P, A) + bias;
-
-        histogram.record_output (result);
-
-        if (result &amp; 0xffffff00)
-        {
-            if (result &lt; 0)
-            {
-                result = 0;
-                satlow++;
-            }
-            else // if (result &gt; 255)
-            {
-                result = 255;
-                sathigh++;
-            }
-        }
-
-        *--destp = result;
-    }
-
-    if (param-&gt;debug &amp; 2)
-    {
-        if (satlow || sathigh)
-            printf (&quot;    Saturated %d low, %d high\n&quot;, satlow, sathigh);
-    }
-}
-
-//============================================================================
-
-// This one is used in the lookahead case; it takes the additional parameter
-// supplying the lookahead frame.
-
-template &lt;typename Oper, typename Histo&gt;
-void ADMVideoSwissArmyKnife::computeRollingAverage (ADMImage * image,
-                                                    ADMImage * lookaheadimage,
-                                                    ADMImage * data,
-                                                    uint32_t planesize,
-                                                    SWISSARMYKNIFE_PARAM * param,
-                                                    int32_t bias,
-                                                    const Oper &amp; op_in,
-                                                    const Histo &amp; histogram_in)
-{
-    // We make local copies of the functors so that the calls below to
-    // record_input() and record_output() (for the histogram) and operator()
-    // (for the op) are accessing stack data rather than incurring yet another
-    // indirection.  When it's per-pixel, every little bit helps!
-
-    Histo histogram = histogram_in;
-    Oper op = op_in;
-
-    float alpha = param-&gt;memory_constant_alpha;
-    float oneminusalpha = 1 - alpha;
-
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    float * bgp = myInfo-&gt;bg + planesize;
-    uint32_t pixremaining = planesize + 1;
-
-    uint32_t sathigh = 0;
-    uint32_t satlow = 0;
-
-    if (lookaheadimage)
-    {
-        uint8_t * aheadp = YPLANE (lookaheadimage) + planesize;
-
-        while (--pixremaining)
-        {
-            int32_t P = *--currp;
-            histogram.record_input (P);
-
-            float A = *--bgp;
-            *bgp = (A * oneminusalpha) + (*--aheadp * alpha);
-
-            int32_t result = op (P, A) + bias;
-
-            histogram.record_output (result);
-
-            if (result &amp; 0xffffff00)
-            {
-                if (result &lt; 0)
-                {
-                    result = 0;
-                    satlow++;
-                }
-                else // if (result &gt; 255)
-                {
-                    result = 255;
-                    sathigh++;
-                }
-            }
-
-            *--destp = result;
-        }
-    }
-    else
-    {
-        while (--pixremaining)
-        {
-            int32_t P = *--currp;
-            histogram.record_input (P);
-
-            float A = *--bgp;
-            // no update of background - the lookahead is looking past the
-            // end of the video
-
-            int32_t result = op (P, A) + bias;
-
-            histogram.record_output (result);
-
-            if (result &amp; 0xffffff00)
-            {
-                if (result &lt; 0)
-                {
-                    result = 0;
-                    satlow++;
-                }
-                else // if (result &gt; 255)
-                {
-                    result = 255;
-                    sathigh++;
-                }
-            }
-
-            *--destp = result;
-        }
-    }
-
-    if (param-&gt;debug &amp; 2)
-    {
-        if (satlow || sathigh)
-            printf (&quot;    Saturated %d low, %d high\n&quot;, satlow, sathigh);
-    }
-}
-
-//============================================================================
-
-template &lt;typename InputImageType, typename Oper, typename Histo&gt;
-void ADMVideoSwissArmyKnife::applyImage (ADMImage * image, ADMImage * data,
-                                         uint32_t planesize,
-                                         SWISSARMYKNIFE_PARAM * param,
-                                         int32_t bias,
-                                         InputImageType * input_image,
-                                         const Oper &amp; op_in,
-                                         const Histo &amp; histogram_in)
-{
-    // We make local copies of the functors so that the calls below to
-    // record_input() and record_output() (for the histogram) and operator()
-    // (for the op) are accessing stack data rather than incurring yet another
-    // indirection.  When it's per-pixel, every little bit helps!
-
-    Histo histogram = histogram_in;
-    Oper op = op_in;
-
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    InputImageType * bgp = input_image + planesize;
-    uint32_t pixremaining = planesize + 1;
-
-    uint32_t sathigh = 0;
-    uint32_t satlow = 0;
-
-    while (--pixremaining)
-    {
-        int32_t P = *--currp;
-        histogram.record_input (P);
-
-        InputImageType A = *--bgp;
-        int32_t result = op (P, A) + bias;
-
-        histogram.record_output (result);
-
-        if (result &amp; 0xffffff00)
-        {
-            if (result &lt; 0)
-            {
-                result = 0;
-                satlow++;
-            }
-            else // if (result &gt; 255)
-            {
-                result = 255;
-                sathigh++;
-            }
-        }
-
-        *--destp = result;
-    }
-
-    if (param-&gt;debug &amp; 2)
-    {
-        if (satlow || sathigh)
-            printf (&quot;    Saturated %d low, %d high\n&quot;, satlow, sathigh);
-    }
-}
-
-//============================================================================
-
-template &lt;typename Oper, typename Histo&gt;
-void ADMVideoSwissArmyKnife::applyConstant (ADMImage * image, ADMImage * data,
-                                            uint32_t planesize,
-                                            SWISSARMYKNIFE_PARAM * param,
-                                            int32_t bias,
-                                            const Oper &amp; op_in,
-                                            const Histo &amp; histogram_in)
-{
-    // We make local copies of the functors so that the calls below to
-    // record_input() and record_output() (for the histogram) and operator()
-    // (for the op) are accessing stack data rather than incurring yet another
-    // indirection.  When it's per-pixel, every little bit helps!
-
-    Histo histogram = histogram_in;
-    Oper op = op_in;
-
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    float A = param-&gt;input_constant;
-    uint32_t pixremaining = planesize + 1;
-
-    uint32_t sathigh = 0;
-    uint32_t satlow = 0;
-
-    while (--pixremaining)
-    {
-        int32_t P = *--currp;
-        histogram.record_input (P);
-
-        int32_t result = op (P, A) + bias;
-
-        histogram.record_output (result);
-
-        if (result &amp; 0xffffff00)
-        {
-            if (result &lt; 0)
-            {
-                result = 0;
-                satlow++;
-            }
-            else // if (result &gt; 255)
-            {
-                result = 255;
-                sathigh++;
-            }
-        }
-
-        *--destp = result;
-    }
-
-    if (param-&gt;debug &amp; 2)
-    {
-        if (satlow || sathigh)
-            printf (&quot;    Saturated %d low, %d high\n&quot;, satlow, sathigh);
-    }
-}
-
-//============================================================================
-
-class OpPequalsA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast &lt;int32_t&gt; (A + .5);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return A;
-    }
-};
-
-class OpPequalsP
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return P;
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return P;
-    }
-};
-
-class OpPequalsPminusA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (P - static_cast &lt;int32_t&gt; (A + .5));
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (P - A);
-    }
-};
-
-class OpPequalsAminusP
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast &lt;int32_t&gt; (A + .5) - P);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (A - P);
-    }
-};
-
-class OpPequalsPplusA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (P + static_cast &lt;int32_t&gt; (A + .5));
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (P + A);
-    }
-};
-
-class OpPequalsPtimesA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast &lt;int32_t&gt; ((P * A) + .5);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (P * A);
-    }
-};
-
-class OpPequalsPdivByA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast &lt;int32_t&gt; ((P / A) + .5);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (P / A);
-    }
-};
-
-class OpPequalsAdivByP
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast &lt;int32_t&gt; ((A / P) + .5);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (A / P);
-    }
-};
-
-class OpPequalsMinPA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        int32_t intA = static_cast &lt;int32_t&gt; (A + .5);
-        return ((intA &gt; P) ? P : intA);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return ((A &gt; P) ? P : A);
-    }
-};
-
-class OpPequalsMaxPA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        int32_t intA = static_cast &lt;int32_t&gt; (A + .5);
-        return ((intA &gt; P) ? intA : P);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return ((A &gt; P) ? A : P);
-    }
-};
-
-//----------------------------------------------------------------------------
-
-class OpPequalsA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast &lt;int32_t&gt; (((A + bias) * multiplier) + .5);
-    }
-};
-
-class OpPequalsP_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsP_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast &lt;int32_t&gt; (((P + bias) * multiplier) + .5);
-    }
-};
-
-class OpPequalsPminusA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsPminusA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast &lt;int32_t&gt;
-                ((((P - A) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsAminusP_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsAminusP_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast &lt;int32_t&gt;
-                ((((A - P) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsPplusA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsPplusA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast &lt;int32_t&gt;
-                ((((P + A) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsPtimesA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsPtimesA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast &lt;int32_t&gt;
-                ((((P * A) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsPdivByA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsPdivByA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast &lt;int32_t&gt;
-                ((((P / A) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsAdivByP_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsAdivByP_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast &lt;int32_t&gt;
-                ((((A / P) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsMinPA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsMinPA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast &lt;int32_t&gt;
-                ((((A &gt; P ? P : A) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsMaxPA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsMaxPA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast &lt;int32_t&gt;
-                ((((A &gt; P ? A : P) + bias) * multiplier) + .5));
-    }
-};
-
-//============================================================================
-
-uint8_t ADMVideoSwissArmyKnife::getFrameNumberNoAlloc(uint32_t frame,
-                                                      uint32_t *len,
-                                                      ADMImage *data,
-                                                      uint32_t *flags)
-{
-    if (frame &gt;= _info.nb_frames)
-        return 0;
-
-    if (_param-&gt;debug &amp; 1)
-        printf (&quot;in ADMVideoSwissArmyKnife::getFrameNumberNoAlloc(%d, ...)\n&quot;,
-                frame);
-
-    if (!_in-&gt;getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
-        return 0;
-
-    uint32_t planesize = _info.width * _info.height;
-    uint32_t size = (planesize * 3) &gt;&gt; 1;
-    ADMImage * lookaheadimage;
-
-    if (_param-&gt;lookahead_n_frames)
-    {
-        if (myInfo-&gt;bg_lab_size != planesize)
-        {
-            delete myInfo-&gt;bg_lab;
-            myInfo-&gt;bg_lab_size = planesize;
-            myInfo-&gt;bg_lab = new ADMImage (_info.width, _info.height);
-        }
-
-        if (frame + _param-&gt;lookahead_n_frames &gt;= _info.nb_frames)
-            lookaheadimage = 0;
-        else if (!_in-&gt;getFrameNumberNoAlloc (frame
-                                              + _param-&gt;lookahead_n_frames,
-                                              len, myInfo-&gt;bg_lab, flags))
-            return 0;
-        else
-            lookaheadimage = myInfo-&gt;bg_lab;
-    }
-    else
-        lookaheadimage = 0;
-
-    // printf (&quot;%s\n&quot;, getConf (_param, true));
-
-    *len = size;
-
-    uint8_t ret = doSwissArmyKnife (_uncompressed, lookaheadimage,
-                                    data, _in, this, _param,
-                                    _info.width, _info.height);
-    return ret;
-}
-
-uint8_t
-ADMVideoSwissArmyKnife::doSwissArmyKnife (ADMImage * image,
-                                          ADMImage * lookaheadimage,
-                                          ADMImage * data,
-                                          AVDMGenericVideoStream * in,
-                                          ADMVideoSwissArmyKnife * sak,
-                                          SWISSARMYKNIFE_PARAM * param,
-                                          uint32_t width, uint32_t height)
-{
-    PersistentInfo * myInfo = sak-&gt;myInfo;
-    uint32_t debug = param-&gt;debug;
-
-    bool doingConvolution = (param-&gt;input_type == INPUT_CUSTOM_CONVOLUTION);
-    bool doingRollingAvg = (param-&gt;input_type == INPUT_ROLLING_AVERAGE);
-    bool doingFileImage = (param-&gt;input_type == INPUT_FILE_IMAGE_FLOAT
-                           || param-&gt;input_type == INPUT_FILE_IMAGE_INTEGER);
-    bool doingFileImageFloat = (param-&gt;input_type == INPUT_FILE_IMAGE_FLOAT);
-    bool doingApplyConstant = (param-&gt;input_type == INPUT_CONSTANT_VALUE);
-
-    bool needRead = false;
-    bool needFile = doingConvolution || doingFileImage;
-
-    if (needFile)
-    {
-        if (myInfo-&gt;input_file_name != param-&gt;input_file)
-        {
-            myInfo-&gt;input_file_name = param-&gt;input_file;
-            myInfo-&gt;input_file_mtime = 0;
-            printf (&quot;SwissArmyKnife: new input file has been selected: %s\n&quot;,
-                    myInfo-&gt;input_file_name.c_str());
-            needRead = true;
-        }
-
-        // HERE: we should rearrange a bit to move the stat() call out to the
-        // ctor - we don't need to check it every frame!
-
-        struct stat st;
-        if (stat (myInfo-&gt;input_file_name.c_str(), &amp;st) == -1)
-        {
-            perror (myInfo-&gt;input_file_name.c_str());
-            return 0;
-        }
-
-        if (st.st_mtime != myInfo-&gt;input_file_mtime)
-        {
-            if (!needRead &amp;&amp; myInfo-&gt;input_file_mtime)
-                printf (&quot;SwissArmyKnife: input file %s has been changed - &quot;
-                        &quot;re-reading it\n&quot;, myInfo-&gt;input_file_name.c_str());
-            needRead = true;
-            myInfo-&gt;input_file_mtime = st.st_mtime;
-        }
-        else if (!needRead &amp;&amp; doingFileImage)
-        {
-            if (myInfo-&gt;image_data_invalid
-                || myInfo-&gt;image_bias != param-&gt;load_bias
-                || myInfo-&gt;image_multiplier != param-&gt;load_multiplier)
-            {
-                needRead = true;
-            }
-        }
-    }
-
-    //FloatVector &amp; kernel = myInfo-&gt;kernel;
-    uint32_t &amp; kernel_w = myInfo-&gt;kernel_w;
-    uint32_t &amp; kernel_h = myInfo-&gt;kernel_h;
-
-    uint32_t planesize = width * height;
-			
-    if (needRead)
-    {
-        myInfo-&gt;histogram_data_invalid = true;
-
-        if (doingConvolution)
-        {
-            //kernel.clear();
-            kernel_w = 0;
-            kernel_h = 0;
-
-            using namespace std;
-
-            const char * filename = myInfo-&gt;input_file_name.c_str();
-            ifstream inputStream (filename);
-            if (!inputStream)
-            {
-                fprintf (stderr, &quot;SwissArmyKnife: can't open input file %s, &quot;
-                         &quot;but it apparently does exist...(%d)\n&quot;,
-                         filename, errno);
-                return 0;
-            }
-
-#ifndef ASSUME_SQUARE_MATRIX
-            // We read the dimensions as floats just in case they happen to be
-            // written that way (no reason to punt) - however, we do expect
-            // that anything to the right of the decimal is 0!
-
-            float dimtmp;
-            inputStream &gt;&gt; dimtmp;
-            kernel_w = uint32_t (dimtmp);
-            if (float (kernel_w) != dimtmp)
-                printf (&quot;SwissArmyKnife: %s: What exactly do you expect a &quot;
-                        &quot;width of %f to mean?  Truncating to %d...\n&quot;,
-                        filename, dimtmp, uint32_t (dimtmp));
-            inputStream &gt;&gt; dimtmp;
-            kernel_h = uint32_t (dimtmp);
-            if (float (kernel_h) != dimtmp)
-                printf (&quot;SwissArmyKnife: %s: What exactly do you expect a &quot;
-                        &quot;height of %f to mean?  Truncating to %d...\n&quot;,
-                        filename, dimtmp, uint32_t (dimtmp));
-            if (kernel_w &lt; 1 || (kernel_w &amp; 1) == 0
-                || kernel_h &lt; 1 || (kernel_h &amp; 1) == 0)
-            {
-                printf (&quot;SwissArmyKnife: %s: Can't handle a convolution &quot;
-                        &quot;kernel with dimensions %dx%d - both dimensions &quot;
-                        &quot;must be odd (and positive)\n&quot;,
-                        filename, int (kernel_w), int (kernel_h));
-                myInfo-&gt;input_file_mtime = 0;  // force re-read, avoid crash
-                return 0;
-            }
-#endif
-/*
-            copy (istream_iterator &lt;float&gt; (inputStream),
-                  istream_iterator &lt;float&gt; (),
-                  back_inserter (kernel));
-
-#ifdef ASSUME_SQUARE_MATRIX
-            kernel_dim = uint32_t (sqrtf (kernel.size()));
-            if (kernel_dim * kernel_dim != kernel.size())
-            {
-                if ((kernel_dim + 1) * (kernel_dim + 1) == kernel.size())
-                    ++kernel_dim;
-                else
-                {
-                    printf (&quot;SwissArmyKnife: Can't determine matrix &quot;
-                            &quot;dimensions to explain %d input values! &quot;
-                            &quot;(sqrt(%d) = %f)\n&quot;,
-                            kernel.size(), kernel.size(),
-                            sqrt (kernel.size()));
-                    kernel_dim = 0;
-                    return 0;
-                }
-            }
-#endif
-
-            printf (&quot;SwissArmyKnife: read %d convolution kernel values &quot;
-                    &quot;from %s (%dx%d):\n&quot;,
-                    kernel.size(), filename, kernel_w, kernel_h);
-            if (debug &amp; 8)
-            {
-                FloatVector::const_iterator kit = kernel.begin();
-                int count = 0;
-                while (kit != kernel.end())
-                {
-                    printf (&quot;%.6f%c&quot;, *kit++,
-                            (++count % kernel_w) ? ' ' : '\n');
-                }
-                if (count % kernel_w)
-                    printf (&quot;[incomplete?!]\n&quot;);
-            } */
-        }
-        else // file image (not convolution)
-        {
-            ADM_assert (param-&gt;input_type == INPUT_FILE_IMAGE_FLOAT
-                        || param-&gt;input_type == INPUT_FILE_IMAGE_INTEGER);
-
-            const char * filename = myInfo-&gt;input_file_name.c_str();
-            FILE * fin = fopen (filename, &quot;rb&quot;);
-            if (!fin)
-            {
-                fprintf (stderr, &quot;SwissArmyKnife: can't open input file %s, &quot;
-                         &quot;but it apparently does exist...(%d)\n&quot;,
-                         filename, errno);
-                return 0;
-            }
-
-            ADMVideoComputeAverage::FileHeader header;
-            int nread = fread (&amp;header, sizeof (header), 1, fin);
-            if (nread != 1 || strncmp (header.magic, &quot;DGCMimgF&quot;, 8) != 0)
-            {
-                fprintf (stderr, &quot;SwissArmyKnife: %s does not appear to be a &quot;
-                         &quot;valid DG/CM floating-point raw image file (produced &quot;
-                         &quot;by the ComputeAverage filter)\n&quot;, filename);
-                fclose (fin);
-                return 0;
-            }
-
-            uint32_t width = header.width;
-            uint32_t height = header.height;
-            uint32_t pixelcount = width * height;
-
-            if (width &gt; 2000 || height &gt; 2000)
-            {
-                fprintf (stderr, &quot;SwissArmyKnife: invalid image dimensions &quot;
-                         &quot;(%dx%d) in %s\n&quot;,
-                         int (width), int (height), filename);
-                fclose (fin);
-                return 0;
-            }
-
-            myInfo-&gt;image_data_invalid = true;
-            delete [] myInfo-&gt;image_float;
-            delete [] myInfo-&gt;image_int;
-
-            myInfo-&gt;image_float = new float [pixelcount];
-
-            nread = fread (myInfo-&gt;image_float, sizeof (float), pixelcount, fin);
-            fclose (fin);
-            if (nread != pixelcount)
-            {
-                fprintf (stderr, &quot;SwissArmyKnife: failed to read image data &quot;
-                         &quot;(%ux%u = %u) from %s (got %u)\n&quot;,
-                         width, height, pixelcount, filename, nread);
-                delete [] myInfo-&gt;image_float;
-                myInfo-&gt;image_float = 0;
-                return 0;
-            }
-
-            printf (&quot;SwissArmyKnife: successfully loaded image data &quot;
-                    &quot;(%ux%u = %u) from %s\n&quot;,
-                    width, height, pixelcount, filename);
-
-            myInfo-&gt;image_int = new uint8_t [pixelcount];
-            float * floatpixp = myInfo-&gt;image_float + pixelcount;
-            uint8_t * intpixp = myInfo-&gt;image_int + pixelcount;
-
-            if (param-&gt;load_bias == 0.0 &amp;&amp; param-&gt;load_multiplier == 1.0)
-            {
-                printf (&quot;Converting %u pixels to integer values (and keeping &quot;
-                        &quot;the floats, too)\n&quot;, pixelcount);
-
-                ++pixelcount;
-                while (--pixelcount)
-                {
-                    *--intpixp = static_cast &lt;uint8_t&gt; (*--floatpixp + 0.5);
-                }
-            }
-            else
-            {
-                float load_bias = param-&gt;load_bias;
-                float load_multiplier = param-&gt;load_multiplier;
-
-                printf (&quot;applying P = (P + %.6f) * %.6f to %u pixels\n&quot;,
-                        load_bias, load_multiplier, pixelcount);
-
-                ++pixelcount;
-                while (--pixelcount)
-                {
-                    float floatpix
-                        = (*--floatpixp + load_bias) * load_multiplier;
-                    *floatpixp = floatpix;
-
-                    uint8_t intpix;
-                    if (floatpix &lt; 0)
-                        intpix = 0;
-                    else if (floatpix &gt; 255)
-                        intpix = 255;
-                    else
-                        intpix = static_cast &lt;uint8_t&gt; (floatpix + 0.5);
-
-                    *--intpixp = intpix;
-                }
-            }
-
-            myInfo-&gt;image_w = width;
-            myInfo-&gt;image_h = height;
-            myInfo-&gt;image_bias = param-&gt;load_bias;
-            myInfo-&gt;image_multiplier = param-&gt;load_multiplier;
-            myInfo-&gt;image_data_invalid = false;
-        }
-    }
-    else if (doingRollingAvg)
-    {
-        if (!myInfo-&gt;bg
-            || myInfo-&gt;bg_x != width || myInfo-&gt;bg_y != height
-            || myInfo-&gt;bg_mca != param-&gt;memory_constant_alpha
-            || myInfo-&gt;bg_lanf != param-&gt;lookahead_n_frames
-            || myInfo-&gt;bg_isf != param-&gt;init_start_frame
-            || myInfo-&gt;bg_ief != param-&gt;init_end_frame
-            || myInfo-&gt;bg_ibr != param-&gt;init_by_rolling)
-        {
-            if (!myInfo-&gt;bg || myInfo-&gt;bg_x != width || myInfo-&gt;bg_y != height)
-            {
-                myInfo-&gt;bg_x = width;
-                myInfo-&gt;bg_y = height;
-                delete [] myInfo-&gt;bg;
-                myInfo-&gt;bg = new float [planesize];
-            }
-
-            myInfo-&gt;histogram_data_invalid = true;
-
-            myInfo-&gt;bg_mca = param-&gt;memory_constant_alpha;
-            myInfo-&gt;bg_lanf = param-&gt;lookahead_n_frames;
-            myInfo-&gt;bg_isf = param-&gt;init_start_frame;
-            myInfo-&gt;bg_ief = param-&gt;init_end_frame;
-            myInfo-&gt;bg_ibr = param-&gt;init_by_rolling;
-
-            if (myInfo-&gt;bg_isf &lt;= myInfo-&gt;bg_ief)
-            {
-                uint32_t do_frames = myInfo-&gt;bg_ief - myInfo-&gt;bg_isf + 1;
-
-                uint32_t firstframe = myInfo-&gt;bg_isf;
-                uint32_t lastframe = myInfo-&gt;bg_ief;
-                const ADV_Info &amp; info = sak-&gt;getInfo();
-                if (lastframe &gt;= info.nb_frames)
-                {
-                    lastframe = info.nb_frames - 1;
-                    if (firstframe &gt;= info.nb_frames)
-                    {
-                        firstframe = lastframe - do_frames + 1;
-                        if (firstframe &gt;= info.nb_frames)
-                            firstframe = 0;
-                    }
-                    do_frames = lastframe - firstframe + 1;
-                }
-
-                // if (debug &amp; 2)
-                printf (&quot;Getting a \&quot;head start\&quot; on rolling average by &quot;
-                        &quot;computing a %s %d frames of size %dx%d from %d to &quot;
-                        &quot;%d with alpha = %.6f\n&quot;,
-                        myInfo-&gt;bg_ibr ? &quot;rolling average over&quot;
-                        : &quot;straight average of&quot;,
-                        do_frames, myInfo-&gt;bg_x, myInfo-&gt;bg_y,
-                        firstframe, lastframe, myInfo-&gt;bg_mca);
-
-                ADMImage aimage (myInfo-&gt;bg_x, myInfo-&gt;bg_y);
-
-                // HERE: for speed, we do luma (Y plane) only.  However, some
-                // users might want chroma, too... we should make that an option
-                // or something.  (...in which case bg should be big enough for
-                // all three planes.)
-
-
-//***************************************************************************
-//***************************************************************************
-//***************************************************************************
-
-                // HERE: issue: if we are not starting at the first frame,
-                // then I think that &quot;in-&gt;getFrameNumberNoAlloc(framenum)&quot;
-                // will give us framenum+frame_at_which_we_are_starting!!
-                // not sure this matters a lot in practice right now, but it
-                // might matter more if users start using a start frame &gt; 1 to
-                // get a good fore/aft ratio...
-
-//***************************************************************************
-//***************************************************************************
-//***************************************************************************
-
-                if (myInfo-&gt;bg_ibr)
-                {
-                    // We want to &quot;prime&quot; the rolling average with the values from
-                    // the first frame (rather than zeroes, which doesn't seem to
-                    // work out well).  So we do the following block just once,
-                    // but in its own scope to not collide with the locals of the
-                    // loop that follows:
-                    {
-                        uint32_t flen;
-                        uint32_t fflags = 0;
-                        if (!in-&gt;getFrameNumberNoAlloc (firstframe, &amp;flen,
-                                                        &amp;aimage, &amp;fflags))
-                            return 0;
-
-                        uint8_t * currp = YPLANE (&amp;aimage) + planesize;
-                        float * bgp = myInfo-&gt;bg + planesize;
-                        uint32_t pixremaining = planesize + 1;
-                        while (--pixremaining)
-                        {
-                            *--bgp = *--currp;
-                        }
-
-                        ++firstframe; // don't include this one again
-                    }
-
-                    float alpha = param-&gt;memory_constant_alpha;
-                    float oneminusalpha = 1 - alpha;
-
-                    for (int fnum = firstframe; fnum &lt;= lastframe; fnum++)
-                    {
-                        uint32_t flen;
-                        uint32_t fflags = 0;
-                        if (!in-&gt;getFrameNumberNoAlloc (fnum, &amp;flen,
-                                                        &amp;aimage, &amp;fflags))
-                            return 0;
-
-                        uint8_t * currp = YPLANE (&amp;aimage) + planesize;
-                        float * bgp = myInfo-&gt;bg + planesize;
-                        uint32_t pixremaining = planesize + 1;
-                        while (--pixremaining)
-                        {
-                            --bgp;
-                            *bgp = (*bgp * oneminusalpha) + (*--currp * alpha);
-                        }
-                    }
-                }
-                else // head start uses straight average (not rolling average)
-                {
-                    uint32_t sums [planesize];
-                    memset (sums, 0, planesize * sizeof sums[0]);
-
-                    for (int fnum = firstframe; fnum &lt;= lastframe; fnum++)
-                    {
-                        uint32_t flen;
-                        uint32_t fflags = 0;
-                        if (!in-&gt;getFrameNumberNoAlloc (fnum, &amp;flen,
-                                                        &amp;aimage, &amp;fflags))
-                            return 0;
-
-                        uint8_t * currp = YPLANE (&amp;aimage) + planesize;
-                        uint32_t * sump = sums + planesize;
-                        uint32_t pixremaining = planesize + 1;
-                        while (--pixremaining)
-                        {
-                            *--sump += *--currp;
-                        }
-                    }
-
-                    float * bgp = myInfo-&gt;bg + planesize;
-                    uint32_t * sump = sums + planesize;
-                    uint32_t pixremaining = planesize + 1;
-                    // we use a floating point multiply of a reciprocal rather
-                    // than a floating point divide, because floating point
-                    // folklore says the multiply will be faster.
-                    float one_over_framecount = 1.0 / do_frames;
-                    while (--pixremaining)
-                    {
-                        *--bgp = *--sump * one_over_framecount;
-                    }
-                }
-
-                // if (debug &amp; 2)
-                printf (&quot;Done computing head start.\n&quot;);
-            }
-            else // if (debug &amp; 2)
-            {
-                printf (&quot;Starting with new 0 baseline background\n&quot;);
-                memset (myInfo-&gt;bg, 0, planesize * sizeof (myInfo-&gt;bg[0]));
-            }
-        }
-        else
-        {
-            if (debug &amp; 4)
-                printf (&quot;Using existing baseline background of size %dx%d with &quot;
-                        &quot;alpha = %.6f (1/%d)\n&quot;, myInfo-&gt;bg_x, myInfo-&gt;bg_y,
-                        myInfo-&gt;bg_mca);
-        }
-    }			
-
-    uint8_t * imagePixels = YPLANE (image);
-
-    ImageTool imtool (imagePixels, width, height, data);
-    imtool.setDebug (debug);
-
-    Histogram * histogram = 0;
-    int32_t bias = param-&gt;bias;
-    uint32_t tool = param-&gt;tool;
-
-    // HERE: give some thought to the general issue of keeping myInfo &amp; param
-    // in sync, and resetting the histogram (or whatever) when things change.
-
-    if (param-&gt;histogram_frame_interval != 0)
-    {
-        histogram = new Histogram (myInfo-&gt;histogram_input_data,
-                                   myInfo-&gt;histogram_output_data,
-                                   param-&gt;histogram_frame_interval,
-                                   myInfo-&gt;histogram_frame_count,
-                                   width * height);
-        tool += TOOL_ADD_HISTOGRAM;
-        if (myInfo-&gt;histogram_frame_interval !=
-            param-&gt;histogram_frame_interval)
-        {
-            if (myInfo-&gt;histogram_frame_interval)
-                myInfo-&gt;histogram_data_invalid = true;
-            myInfo-&gt;histogram_frame_interval
-                = param-&gt;histogram_frame_interval;
-        }
-
-        if (myInfo-&gt;histogram_data_invalid)
-        {
-            myInfo-&gt;histogram_data_invalid = false;
-            histogram-&gt;reset();
-        }
-    }
-
-    float rbias = param-&gt;result_bias;
-    float rmultiplier = param-&gt;result_multiplier;
-    if (fabsf (rbias) &gt;= 0.0001 || fabsf (rmultiplier - 1.0) &gt;= 0.0001)
-    {
-        tool += TOOL_ADD_SCALING;
-    }
-
-    // It might look like the following switches could be collapsed
-    // significantly if we just used a pointer to the functor objects,
-    // assigning the appropriate operation, histogram functor, etc., and then
-    // using fewer cases.  The problem is that to get the fastest possible
-    // code (important since we're talking about per-pixel operations here),
-    // the tool functor object (e.g., OpPequalsAminusP) needs to be
-    // instantiated inline in the call to the operation template (e.g.,
-    // convolve(), computeRollingAverage(), etc.) so that the functor code can
-    // be inlined.  If we passed an object through a pointer or reference,
-    // we'd have much smaller code (both source and binary), but it would also
-    // be much slower because every pixel would have to traverse the pointer.
-    // So in this case we are buying performance at the cost of a bunch of big
-    // messy switches in the source plus massive template code expansion in
-    // the output.  It's worth it.
-
-    if (doingConvolution)
-    {
-        /*if (kernel.empty())
-        {
-            fprintf (stderr, &quot;No convolution kernel loaded - can't do &quot;
-                     &quot;convolution!\n&quot;);
-            return 0;
-        }*/
-
-        switch (tool)
-        {
-        case TOOL_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsP_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPminusA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsAminusP_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPplusA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPtimesA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPdivByA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsAdivByP_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsMinPA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsMaxPA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsP_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPminusA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsAminusP_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPplusA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPtimesA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPdivByA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsAdivByP_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsMinPA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsMaxPA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-
-        default:
-            fprintf (stderr, &quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
-                     param-&gt;tool);
-            return 0;
-        }
-    }
-    else if (doingRollingAvg &amp;&amp; param-&gt;lookahead_n_frames == 0)
-    {
-        switch (tool)
-        {
-        case TOOL_A:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-
-        default:
-            fprintf (stderr, &quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
-                     param-&gt;tool);
-            return 0;
-        }
-    }
-    else if (doingRollingAvg)
-    {
-        switch (tool)
-        {
-        case TOOL_A:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-
-        default:
-            fprintf (stderr, &quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
-                     param-&gt;tool);
-            return 0;
-        }
-    }
-    else if (doingFileImageFloat)
-    {
-        if (width != myInfo-&gt;image_w || height != myInfo-&gt;image_h)
-        {
-            const char * bar = &quot;*************************&quot;;
-            fprintf (stderr, &quot;\n%s%s%s\nAttempting to apply a %ux%u input &quot;
-                     &quot;image to %ux%u video - even if I could do that, it &quot;
-                     &quot;probably wouldn't be what you wanted...\n%s%s%s\n&quot;,
-                     bar, bar, bar, myInfo-&gt;image_w, myInfo-&gt;image_h,
-                     width, height, bar, bar, bar);
-            return 0;
-        }
-
-        float * flt_img = myInfo-&gt;image_float;
-
-        switch (tool)
-        {
-        case TOOL_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-
-        default:
-            fprintf (stderr, &quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
-                     param-&gt;tool);
-            return 0;
-        }
-    }
-    else if (doingFileImage)
-    {
-        if (width != myInfo-&gt;image_w || height != myInfo-&gt;image_h)
-        {
-            const char * bar = &quot;*************************&quot;;
-            fprintf (stderr, &quot;\n%s%s%s\nAttempting to apply a %ux%u input &quot;
-                     &quot;image to %ux%u video - even if I could do that, it &quot;
-                     &quot;probably wouldn't be what you wanted...\n%s%s%s\n&quot;,
-                     bar, bar, bar, myInfo-&gt;image_w, myInfo-&gt;image_h,
-                     width, height, bar, bar, bar);
-            return 0;
-        }
-
-        uint8_t * int_img = myInfo-&gt;image_int;
-
-        switch (tool)
-        {
-        case TOOL_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-
-        default:
-            fprintf (stderr, &quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
-                     param-&gt;tool);
-            return 0;
-        }
-    }
-    else if (doingApplyConstant)
-    {
-        switch (tool)
-        {
-        case TOOL_A:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsP_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsP_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            sak-&gt;applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-
-        default:
-            fprintf (stderr, &quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
-                     param-&gt;tool);
-            return 0;
-        }
-    }
-    else
-    {
-        fprintf (stderr, &quot;ooops!  input selection botch in SwissArmyKnife!\n&quot;);
-        return 0;
-    }
-
-    if (histogram)
-    {
-        histogram-&gt;frame_check();
-        delete histogram;
-    }
-
-    // HERE: the following two lines do a luma-only-ize
-
-    memset (UPLANE (data), 128, planesize &gt;&gt; 2);
-    memset (VPLANE (data), 128, planesize &gt;&gt; 2);
-
-    data-&gt;copyInfo(image);
-
-    return 1;
-}	                           

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,323 +0,0 @@
-/***************************************************************************
-                          ADM_vidSwissArmyKnife.h  -  Perform one of many
-                                                      possible operations
-                             -------------------
-                          Chris MacGregor, 2005, 2007
-                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __SWISSARMYKNIFE__
-#define __SWISSARMYKNIFE__   
-
-#include &lt;map&gt;
-
-
-//#include &lt;vector&gt;
-#include &lt;string&gt;
-
-#include &lt;sys/time.h&gt;
-
-struct SWISSARMYKNIFE_PARAM
-{
-    uint32_t tool; // ADMVideoSwissArmyKnife::Tool
-    uint32_t input_type; // ADMVideoSwissArmyKnife::Input
-
-    std::string input_file;
-    float load_bias;
-    float load_multiplier;
-
-    float input_constant;
-
-    float    memory_constant_alpha;
-    uint32_t lookahead_n_frames;
-    uint32_t init_start_frame;
-    uint32_t init_end_frame;
-    uint32_t init_by_rolling;
-
-    int32_t  bias;
-    float    result_bias;
-    float    result_multiplier;
-    uint32_t histogram_frame_interval;
-    uint32_t debug;
-
-    bool     enable_preview;  // not loaded/stored; only for dialog
-};
-
-// Alas, because offsetof() is only supposed to work on POD (plain old data)
-// structs, and our SWISSARMYKNIFE_PARAM includes a std::string (which has a
-// constructor, and which causes SWISSARMYKNIFE_PARAM to therefore have an
-// implicit constructor), we need to define our own offsetof() to use for the
-// dialog menus.  See
-// <A HREF="http://www.cplusplus.com/reference/clibrary/cstddef/offsetof.html">http://www.cplusplus.com/reference/clibrary/cstddef/offsetof.html</A> for more
-// on offsetof().
-
-#define my_offsetof(_type, _memb) (size_t (&amp;(((_type *)1)-&gt;_memb)) - 1)
-
-class ADMVideoSwissArmyKnife : public AVDMGenericVideoStream
-{
-protected:
-    	
-    // This is a hack to work around the fact that the ctor &amp; dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    //typedef std::vector &lt;float&gt; FloatVector;
-
-    class PersistentInfo
-    {
-    public:
-        CONFcouple *  conf;
-        CONFcouple *  oldConf;
-        uint32_t      refCount;
-
-        //FloatVector   kernel;
-        uint32_t      kernel_w;
-        uint32_t      kernel_h;
-
-        uint32_t      image_w;
-        uint32_t      image_h;
-        float         image_bias;
-        float         image_multiplier;
-        uint8_t *     image_int;
-        float *       image_float;
-
-        std::string   input_file_name;
-        time_t        input_file_mtime;
-
-        float *       bg;
-        float         bg_mca;
-        ADMImage *    bg_lab; // lookahead buffer
-        uint32_t      bg_lab_size;
-        uint32_t      bg_lanf;
-        uint32_t      bg_isf;
-        uint32_t      bg_ief;
-        uint32_t      bg_x;
-        uint32_t      bg_y;
-
-        uint32_t      histogram_frame_interval;
-        uint32_t *    histogram_input_data;
-        uint32_t *    histogram_output_data;
-        uint32_t      histogram_frame_count;
-
-        bool          bg_ibr;
-        bool          histogram_data_invalid;
-        bool          image_data_invalid;
-
-        PersistentInfo ()
-            : conf (0),
-              oldConf (0),
-              refCount (0),
-
-              kernel_w (0),
-              kernel_h (0),
-
-              image_w (0),
-              image_h (0),
-              image_bias (0),
-              image_multiplier (0),
-              image_int (0),
-              image_float (0),
-
-              input_file_mtime (0),
-
-              bg (0),
-              bg_mca (0),
-              bg_lab (0),
-              bg_lab_size (0),
-              bg_lanf (0),
-              bg_isf (0),
-              bg_ief (0),
-              bg_x (0),
-              bg_y (0),
-
-              histogram_frame_interval (0),
-              histogram_input_data (0),
-              histogram_output_data (0),
-              histogram_frame_count (0),
-
-              bg_ibr (false),
-              histogram_data_invalid (false),
-              image_data_invalid (false)
-        {
-        }
-
-        ~PersistentInfo ()
-        {
-            delete [] image_int;
-            delete [] image_float;
-            delete [] bg;
-            delete bg_lab;
-            delete [] histogram_input_data;
-            delete [] histogram_output_data;
-        }
-    };
-
-    typedef std::map &lt;CONFcouple *, PersistentInfo *&gt; PImap;
-    static PImap pimap;
-
-    PersistentInfo * myInfo;
-
-public:
-    enum Input
-    {
-        INPUT_INVALID = 0,
-
-        INPUT_FILE_IMAGE_FLOAT,
-        INPUT_FILE_IMAGE_INTEGER,
-        INPUT_CUSTOM_CONVOLUTION,
-        INPUT_CONSTANT_VALUE,
-        INPUT_ROLLING_AVERAGE,
-
-        INPUT_COUNT
-    };
-
-protected:
-    enum Tool
-    {
-        TOOL_INVALID = 0,
-
-        TOOL_A,          // P' = A
-        TOOL_P,          // P' = P
-        TOOL_P_MINUS_A,  // P' = P - A
-        TOOL_A_MINUS_P,  // P' = A - P
-        TOOL_P_PLUS_A,   // P' = P + A
-        TOOL_P_TIMES_A,  // P' = P * A
-        TOOL_P_DIVBY_A,  // P' = P / A
-        TOOL_A_DIVBY_P,  // P' = A / P
-        TOOL_MIN_P_A,    // P' = min (P, A)
-        TOOL_MAX_P_A,    // P' = max (P, A)
-
-        TOOL_A_WITH_HISTOGRAM,
-        TOOL_P_WITH_HISTOGRAM,
-        TOOL_P_MINUS_A_WITH_HISTOGRAM,
-        TOOL_A_MINUS_P_WITH_HISTOGRAM,
-        TOOL_P_PLUS_A_WITH_HISTOGRAM,
-        TOOL_P_TIMES_A_WITH_HISTOGRAM,
-        TOOL_P_DIVBY_A_WITH_HISTOGRAM,
-        TOOL_A_DIVBY_P_WITH_HISTOGRAM,
-        TOOL_MIN_P_A_WITH_HISTOGRAM,
-        TOOL_MAX_P_A_WITH_HISTOGRAM,
-
-        TOOL_A_SCALED,
-        TOOL_P_SCALED,
-        TOOL_P_MINUS_A_SCALED,
-        TOOL_A_MINUS_P_SCALED,
-        TOOL_P_PLUS_A_SCALED,
-        TOOL_P_TIMES_A_SCALED,
-        TOOL_P_DIVBY_A_SCALED,
-        TOOL_A_DIVBY_P_SCALED,
-        TOOL_MIN_P_A_SCALED,
-        TOOL_MAX_P_A_SCALED,
-
-        TOOL_A_SCALED_WITH_HISTOGRAM,
-        TOOL_P_SCALED_WITH_HISTOGRAM,
-        TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM,
-        TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM,
-        TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM,
-        TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM,
-        TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM,
-        TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM,
-        TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM,
-        TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM,
-
-        TOOL_TOTAL_COUNT,
-
-        TOOL_ADD_HISTOGRAM = TOOL_A_WITH_HISTOGRAM - TOOL_A,
-        TOOL_ADD_SCALING = TOOL_A_SCALED - TOOL_A,
-    };
-
-    struct ToolMap
-    {
-        Tool toolid;
-        const char * outputName; // displayed name
-        const char * format;     // printf format (%s is A)
-        const char * spacy_format; // same with more whitespace
-    };
-
-    static ToolMap tool_map [];
-
-    SWISSARMYKNIFE_PARAM * _param;
-
-public:
-
-    ADMVideoSwissArmyKnife (AVDMGenericVideoStream *in,CONFcouple *setup);
-    ~ADMVideoSwissArmyKnife();
-
-    virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                           ADMImage *data, uint32_t *flags);
-
-    virtual uint8_t configure (AVDMGenericVideoStream *instream);
-    virtual char * printConf (void);
-    virtual uint8_t getCoupledConf (CONFcouple **couples);
-
-    static char * getConf (SWISSARMYKNIFE_PARAM * param, bool forDialog);
-
-    static uint8_t doSwissArmyKnife (ADMImage * from_image,
-                                     ADMImage * lookaheadimage,
-                                     ADMImage * to_image,
-                                     AVDMGenericVideoStream * in,
-                                     ADMVideoSwissArmyKnife * sak,
-                                     SWISSARMYKNIFE_PARAM * param,
-                                     uint32_t width, uint32_t height);
-
-private:
-
-    template &lt;typename Oper, typename Histo&gt;
-    void computeRollingAverage (ADMImage * image, ADMImage * data,
-                                uint32_t planesize,
-                                SWISSARMYKNIFE_PARAM * param,
-                                int32_t bias,
-                                const Oper &amp; op_in,
-                                const Histo &amp; histogram_in);
-
-    template &lt;typename Oper, typename Histo&gt;
-    void computeRollingAverage (ADMImage * image, ADMImage * lookaheadimage,
-                                ADMImage * data,
-                                uint32_t planesize,
-                                SWISSARMYKNIFE_PARAM * param,
-                                int32_t bias,
-                                const Oper &amp; op_in,
-                                const Histo &amp; histogram_in);
-
-    template &lt;typename InputImageType, typename Oper, typename Histo&gt;
-    void applyImage (ADMImage * image, ADMImage * data,
-                     uint32_t planesize,
-                     SWISSARMYKNIFE_PARAM * param,
-                     int32_t bias, InputImageType * input_image,
-                     const Oper &amp; op_in, const Histo &amp; histogram_in);
-
-    template &lt;typename Oper, typename Histo&gt;
-    void applyConstant (ADMImage * image, ADMImage * data,
-                        uint32_t planesize,
-                        SWISSARMYKNIFE_PARAM * param,
-                        int32_t bias,
-                        const Oper &amp; op_in,
-                        const Histo &amp; histogram_in);
-    const ADV_Info &amp; getInfo () const
-    {
-        return _info;
-    }
-};
-
-struct MenuMapping;
-uint8_t DIA_SwissArmyKnife (AVDMGenericVideoStream * in,
-                            ADMVideoSwissArmyKnife * sakp,
-                            SWISSARMYKNIFE_PARAM * param,
-                            const MenuMapping * menu_mapping,
-                            uint32_t menu_mapping_count);
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,251 +0,0 @@
-/***************************************************************************
-                          ADM_vidThreshold.cpp  -  do thresholding
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;DIA_factory.h&quot;
-#include &quot;ADM_vidThreshold.h&quot;
-
-// #define THRESHOLD_HISTO 1
-
-static FILTER_PARAM thresholdParam={4,{&quot;min&quot;, &quot;max&quot;, &quot;in_range_is_white&quot;, &quot;debug&quot;}};
-
-SCRIPT_CREATE(threshold_script,ADMVideoThreshold,thresholdParam);
-
-BUILD_CREATE(threshold_create,ADMVideoThreshold);
-
-ADMVideoThreshold::ADMVideoThreshold (AVDMGenericVideoStream *in,
-                                      CONFcouple *couples)
-			
-{
-    printf (&quot;ADMVideoThreshold ctor (%p)\n&quot;, this);
-    _in = in;
-    memcpy (&amp;_info,in-&gt;getInfo(),sizeof(_info));
-    _info.encoding = 1;
-    _uncompressed = new ADMImage(_in-&gt;getInfo()-&gt;width, _in-&gt;getInfo()-&gt;height);
-    ADM_assert (_uncompressed);
-    _param = new THRESHOLD_PARAM;
-    if (couples)
-    {
-        GET(min);
-        GET(max);
-        GET(in_range_is_white);
-        GET(debug);
-    }
-    else
-    {
-        _param-&gt;min = 100;
-        _param-&gt;max = 200;
-        _param-&gt;in_range_is_white = 1;
-        _param-&gt;debug = 0;
-    }
-
-    computeLookupTable (_param);
-}
-
-uint8_t ADMVideoThreshold::computeLookupTable (THRESHOLD_PARAM * param)
-{
-    uint8_t changed = false;
-
-    if (param-&gt;min &gt; param-&gt;max)
-    {
-        uint32_t tmp = param-&gt;min;
-        param-&gt;min = param-&gt;max;
-        param-&gt;max = tmp;
-        param-&gt;in_range_is_white = !param-&gt;in_range_is_white;
-        changed = true;
-    }
-
-    uint32_t min = param-&gt;min;
-    uint32_t max = param-&gt;max;
-    ADM_assert (min &lt;= max);
-
-    uint8_t in_range_value;
-    uint8_t out_of_range_value;
-
-    if (param-&gt;in_range_is_white)
-    {
-        in_range_value = 255;
-        out_of_range_value = 0;
-    }
-    else
-    {
-        in_range_value = 0;
-        out_of_range_value = 255;
-    }
-
-    for (uint32_t i = 0; i &lt;= 255; i++)
-    {
-        if (i &lt; min || i &gt; max)
-            lookup_table [i] = out_of_range_value;
-        else
-            lookup_table [i] = in_range_value;
-    }
-
-    return changed;
-}
-
-uint8_t	ADMVideoThreshold::getCoupledConf( CONFcouple **couples)
-{
-
-    ADM_assert(_param);
-    *couples = new CONFcouple(thresholdParam.nb);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-    CSET(min);
-    CSET(max);
-    CSET(in_range_is_white);
-    CSET(debug);
-
-    return 1;
-}
-
-uint8_t ADMVideoThreshold::configure (AVDMGenericVideoStream *in)
-{
-    uint8_t ret = DIA_threshold (_in, this, _param);
-    if (ret == 1)
-    {
-        computeLookupTable (_param);
-        return ret;
-    }
-    else if (ret == 0) // 0 = cancel
-    {
-        computeLookupTable (_param);
-        return ret;
-    }
-    else
-    {
-        ADM_assert (ret == 255); // 255 = whizzy dialog not implemented
-    }
-
-    diaElemUSlider minslide(&amp;(_param-&gt;min), QT_TR_NOOP(&quot;Mi_nimum value to be in-range:&quot;), 0, 255);
-    diaElemUSlider maxslide(&amp;(_param-&gt;max), QT_TR_NOOP(&quot;Ma_ximum value to be in-range:&quot;), 0, 255);
-
-    diaMenuEntry tInRangeIsWhite [] = {
-        { 1, QT_TR_NOOP(&quot;In-range values go white, out-of-range go black&quot;), NULL },
-        { 0, QT_TR_NOOP(&quot;In-range values go black, out-of-range go white&quot;), NULL },
-    };
-
-    diaElemMenu in_range_is_white
-        (&amp;(_param-&gt;in_range_is_white),
-         QT_TR_NOOP(&quot;Output values:&quot;),
-         sizeof (tInRangeIsWhite) / sizeof (diaMenuEntry), tInRangeIsWhite);
-
-    diaElemUInteger debug(&amp;(_param-&gt;debug), QT_TR_NOOP(&quot;_Debugging settings (bits):&quot;),
-                          0, 0x7fffffff);
-    diaElem * elems[] = { &amp;minslide, &amp;maxslide, &amp;in_range_is_white, &amp;debug };
-
-    ret = diaFactoryRun(QT_TR_NOOP(&quot;Threshold Configuration&quot;), sizeof (elems) / sizeof (diaElem *), elems);
-
-    if (ret) // 0 = cancel
-    {
-        computeLookupTable (_param);
-    }
-
-    return ret;
-}
-
-ADMVideoThreshold::~ADMVideoThreshold()
-{
-    printf (&quot;ADMVideoThreshold dtor (%p)\n&quot;, this);
-    DELETE(_param);
-    delete _uncompressed;	
-    _uncompressed = NULL;
-}
-
-char *ADMVideoThreshold::printConf (void) 
-{
-    const int CONF_LEN = 100;
-    static char conf[CONF_LEN];
-    char * cptr = conf;
-    cptr += snprintf (conf, CONF_LEN, &quot;Threshold: In-range values (%u - %u) &quot;
-                      &quot;go %s, others %s&quot;,
-                      _param-&gt;min, _param-&gt;max,
-                      _param-&gt;in_range_is_white ? &quot;white&quot; : &quot;black&quot;,
-                      _param-&gt;in_range_is_white ? &quot;black&quot; : &quot;white&quot;);
-    if (_param-&gt;debug)
-        snprintf (cptr, CONF_LEN - (cptr - conf), &quot;; debug=0x%x&quot;, _param-&gt;debug);
-
-    return conf;
-}
-
-uint8_t ADMVideoThreshold::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          			ADMImage *data,uint32_t *flags)
-{
-    if (frame&gt;= _info.nb_frames)
-        return 0;
-
-    uint32_t debug = _param-&gt;debug;
-
-    if (debug &amp; 1)
-        printf (&quot;in ADMVideoThreshold::getFrameNumberNoAlloc(%d, ...)\n&quot;,
-                frame);
-
-    uint32_t planesize = _info.width * _info.height;
-    uint32_t size = (planesize * 3) &gt;&gt; 1;
-    *len = size;
-			
-    if (!_in-&gt;getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
-        return 0;
-    ADMImage * image = _uncompressed;
-
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    uint32_t pixremaining = planesize + 1;
-
-    while (--pixremaining)
-    {
-        int32_t curr = *--currp;
-
-        *--destp = lookup_table [curr];
-    }
-
-    // HERE: the following two lines do a luma-only-ize
-
-    memset (UPLANE (data), 128, planesize &gt;&gt; 2);
-    memset (VPLANE (data), 128, planesize &gt;&gt; 2);
-
-    data-&gt;copyInfo (image);
-    return 1;
-}	                           
-
-// This is used by the preview code for the configuration dialog.
-
-void ADMVideoThreshold::doThreshold (ADMImage * from, ADMImage * to,
-                                     ADMVideoThreshold * thresholdp,
-                                     uint32_t pixelcount)
-{
-    uint8_t * currp = YPLANE (from) + pixelcount;
-    uint8_t * destp = YPLANE (to) + pixelcount;
-    uint32_t pixremaining = pixelcount + 1;
-    const uint8_t * table = thresholdp-&gt;lookup_table;
-
-    while (--pixremaining)
-    {
-        int32_t curr = *--currp;
-
-        *--destp = table [curr];
-    }
-
-    // HERE: the following two lines do a luma-only-ize
-
-    memset (UPLANE (to), 128, pixelcount &gt;&gt; 2);
-    memset (VPLANE (to), 128, pixelcount &gt;&gt; 2);
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,63 +0,0 @@
-/***************************************************************************
-                          ADM_vidThreshold.h  -  do thresholding
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __THRESHOLD__
-#define __THRESHOLD__   
-
-
-typedef struct THRESHOLD_PARAM
-{
-
-    uint32_t min;
-    uint32_t max;
-    uint32_t in_range_is_white;
-    uint32_t debug;
-
-} THRESHOLD_PARAM;
-
-class ADMVideoThreshold : public AVDMGenericVideoStream
-{
- protected:
-    	
-     THRESHOLD_PARAM * _param;
-     uint8_t lookup_table [256];
-
- public:
- 		
-
-     ADMVideoThreshold (AVDMGenericVideoStream *in, CONFcouple *setup);
-
-     ~ADMVideoThreshold();
-
-     virtual uint8_t 	getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                               ADMImage *data,uint32_t *flags);
-
-     virtual uint8_t 	configure (AVDMGenericVideoStream *instream);
-     virtual char *     printConf(void);
-     virtual uint8_t 	getCoupledConf (CONFcouple **couples);
-
-     uint8_t computeLookupTable (THRESHOLD_PARAM * param);
-
-     static void doThreshold (ADMImage * from, ADMImage * to,
-                              ADMVideoThreshold * thresholdp,
-                              uint32_t pixelcount);
-};
-
-uint8_t DIA_threshold (AVDMGenericVideoStream *in,
-                       ADMVideoThreshold * thresholdp,
-                       THRESHOLD_PARAM * param);
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidUnblend_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidUnblend_param.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidUnblend_param.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,26 +0,0 @@
-/***************************************************************************
-        See avisynth unblend
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef UNBLEND_PARAM_H
-#define UNBLEND_PARAM_H
-
-typedef struct PARAM_UNBLEND
-{
-        uint32_t show;
-        uint32_t threshold;
-        float    dthresh;
-
-}PARAM_UNBLEND;
-
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSub.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSub.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSub.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,81 +0,0 @@
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef _VOBSUB_V_
-#define _VOBSUB_V_
-#include &quot;ADM_coreDemuxerMpeg/include/dmx_demuxerPS.h&quot;
-#define VS_MAXPACKET 128*1024
-
-#define NOSUB 0xffffffff
-
-#define MAX_DISPLAY_TIME 3000 // 3s
-
-//************************************
-typedef struct vobSubParam
-{
-        char            *subname;
-        uint32_t        index;
-        int32_t         subShift;
-}vobSubParam;
-//************************************
-#include &quot;ADM_videoFilter/ADM_vidVobSubBitmap.h&quot;
-//************************************
-class  ADMVideoVobSub:public AVDMGenericVideoStream
- {
-
- protected:
-        virtual char                    *printConf(void);
-        uint8_t                         guessPalette(void);
-        uint8_t                         readbyte(void);         /// Read a byte from buffer
-        uint16_t                        readword(void);         /// Read a 16 bits word from buffer
-        uint8_t                         forward(uint32_t v);    /// Read a 16 bits word from buffer
-        uint8_t                         decodeRLE(uint32_t off,uint32_t start,uint32_t end);
-        uint8_t                         setup(void);            /// Rebuild internal info
-        uint8_t                         cleanup(void);          /// Destroy all internal info
-        uint8_t                         paletteYUV( void );     /// Convert RGB Pallette to yuv
-        uint8_t                         Palettte2Display( void ); /// Convert the RLE to YUV bitmap
-        uint8_t                         handleSub( uint32_t idx );/// Decode a sub packet
-        uint32_t                        lookupSub(uint64_t time);/// Return sub index corresponding to time
-        
-        dmx_demuxerPS                   *_parser;        
-        uint8_t                         *_data;                 /// Data for packet
-        VobSubInfo                      *_vobSubInfo;           /// Info of the index file
-        vobSubParam                     *_param;
-        vobSubBitmap                    *_original;              /// True size (..) depacked vobsub
-        vobSubBitmap                    *_resampled;            /// Final one; to be blended in picture
-        vobSubBitmap                    *_chromaResampled;      /// Same as above but shinked by 2
-        uint32_t                        _x1,_y1,_x2,_y2;        /// sub boxing
-        uint32_t                        _subW,_subH;
-        uint8_t                         _displaying;            ///  Is display active
-        uint32_t                        _curOffset;
-        uint32_t                        _subSize;
-        uint32_t                        _dataSize;              /// Size of the data chunk
-        
-        uint8_t                         _colors[4];             /// Colors palette
-        uint8_t                         _alpha[4];              /// Colors alpha
-        int16_t                         _YUVPalette[16];        /// Luma only
-        uint32_t                        _currentSub;            ///
-        uint32_t                        _initialPts;
- public:
-    /* This 3 functions are used by OCR */
-                        ADMVideoVobSub(  char *fileidx,uint32_t idx);
-              vobSubBitmap *getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last);
-              uint32_t     getNbImage( void);
-    /* /ocr */ 
-    
-                        ADMVideoVobSub(  AVDMGenericVideoStream *in,CONFcouple *setup);
-                        ~ADMVideoVobSub();
-        virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                ADMImage *data,uint32_t *flags);
-        virtual uint8_t getCoupledConf( CONFcouple **couples)           ;
-        virtual uint8_t configure( AVDMGenericVideoStream *instream);
-                                                        
-};
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubBitmap.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubBitmap.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubBitmap.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,40 +0,0 @@
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef _VOBSUB_BITMAP_H
-#define _VOBSUB_BITMAP_H
-//************************************
-class vobSubBitmap
-{
-  protected:
-        uint8_t                         *_dirty;                   /// Dirty lines (non transparent)
-  public:
-        uint8_t                         isDirty(uint32_t line);
-        uint8_t                         setDirty(uint32_t line);
-
-        uint32_t                        _width,_height;
-        uint32_t                        placeTop, placeHeight;     /// Position of the sub
-      
-        uint8_t                         *_bitmap;                  /// YUV image
-        uint8_t                         *_alphaMask;               /// alpha mask 
-        
- 
-                                        vobSubBitmap(uint32_t w, uint32_t h); 
-                                        ~vobSubBitmap();
-        void                            clear(void);
-        
-                                        /// Convert palette bitmap to yuv&amp;mask bitmap
-        uint8_t                         buildYUV( int16_t *palette ); 
-                                        /// Generate the final bitmap (resized)
-        uint8_t                         subResize(vobSubBitmap **tgt,uint32_t newx,uint32_t newy,
-                                                uint32_t oldtop, uint32_t oldheight);
-};
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubRender.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubRender.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,663 +0,0 @@
-//
-// C++ Implementation: %{MODULE}
-//
-// Description:
-//
-//
-// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation:Spudecoder (subs for DVd like stream)
-//
-// Description:
-//
-//
-// Author: Mean, <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-// see <A HREF="http://sam.zoy.org/writings/dvd/subtitles/">http://sam.zoy.org/writings/dvd/subtitles/</A>
-
-/*
-        This part of the vobsub stuff 
-                - decodes the command spu block
-                - rle decode the bitmap itself
-                
-        
-       palettized is the palette based decoded sub
-       
-       Elsewhere
-       
-       bitmap &amp; alphamask are the bitmap &amp; alpha channel stuff
-       subW &amp; subH are width and height of them
-       
-       The RLE decoder is derivated from mplayer one
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#include &quot;ADM_assert.h&quot;
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-
-#include &quot;avi_vars.h&quot;
-
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;DIA_fileSel.h&quot;
-#include &quot;ADM_colorspace.h&quot;
-#include &quot;ADM_vobsubinfo.h&quot;
-#include &quot;ADM_vidVobSub.h&quot;
-
-
-extern &quot;C&quot; {
-#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h&quot;
-#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavutil/avutil.h&quot;
-#include &quot;ADM_libraries/ADM_ffmpeg/ADM_libswscale/swscale.h&quot;
-}
-
-
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-//*************************************************************
-uint8_t ADMVideoVobSub::forward(uint32_t v)
-{
-        aprintf(&quot;Current : %lu forwarding : %lu\n&quot;,_curOffset,v);
-         if(_curOffset+v&gt;=_subSize) return 0;
-         _curOffset+=v;
-         return 1;
-
-}
-//*************************************************************
-uint8_t ADMVideoVobSub::readbyte( void )
-{
-        ADM_assert(_curOffset&lt;_subSize);
-        return _data[_curOffset++];
-
-}
-//*************************************************************
-uint16_t ADMVideoVobSub::readword( void )
-{
-uint16_t w;
-        ADM_assert(_curOffset&lt;_subSize-1);
-        w= _data[_curOffset]&lt;&lt;8;
-        w+= _data[_curOffset+1];
-        _curOffset+=2;
-        return w;
-}
-//***********************************************************
-//      Convert RGB Palette to YUV Palette
-//      ALL 16 of them
-//
-uint8_t ADMVideoVobSub::paletteYUV( void )
-{
-uint8_t r,g,b,a;
-uint8_t y;
-int8_t u,v;
-uint32_t value;
-        for(int i=0;i&lt;16;i++)
-        {
-               value=_vobSubInfo-&gt;Palette[i];
-               r=(value&gt;&gt;16)&amp;0xff;
-               g=(value&gt;&gt;8)&amp;0xff; 
-               b=(value)&amp;0xff;
-               
-               COL_RgbToYuv(b,  g,  r, &amp;y, &amp;u,&amp;v);
-               
-                _YUVPalette[i]=y;
-                //_YUVPalette[i][1]=u;
-                //_YUVPalette[i][2]=v;
-        
-        }
-        return 1;
-
-}
-
-
-//***********************************************************
-// RLE code inspired from mplayer
-uint8_t ADMVideoVobSub::decodeRLE(uint32_t off,uint32_t start,uint32_t end)
-{
-
-        if(!_original) return 0;
-
-        uint32_t oldoffset=_curOffset;
-        uint32_t stride=_subW;
-        uint32_t x,y;
-        uint8_t *ptr=_original-&gt;_bitmap;
-        uint8_t *alpha=_original-&gt;_alphaMask;
-        uint32_t a,b;
-        int     nibbleparity=0;
-        int     nibble=0;
-        
-        int run,color;
-        
-#define SKIPNIBBLE        {nibbleparity=0;}
-#define NEXTNIBBLE(x) if(nibbleparity){ x=nibble&amp;0xf;nibbleparity=0;}else {nibble=readbyte();nibbleparity=1;x=nibble&gt;&gt;4;}
-       
-        _curOffset=off;
-        aprintf(&quot;Vobsub: Rle at offset :%d datasize:%d (stride:%d)\n&quot;,off,_dataSize,stride);
-        if(!ptr)
-        {
-                printf(&quot;Vobsub:No infos yet RLE data...\n&quot;);
-                 return 1;
-        }
-        x=0;
-        y=0;
-        while(
-               (_curOffset&lt;_dataSize)
-            &amp;&amp; (y&lt;(_subH&gt;&gt;1)) 
-            &amp;&amp; ((!end) || (_curOffset&lt;end))
-        )
-        {
-               NEXTNIBBLE(a);
-               if(a&lt;4)
-               {
-                 a&lt;&lt;=4;
-                 NEXTNIBBLE(b);
-                 a|=b;
-                 if(a&lt;0x10)
-                 {
-                        a&lt;&lt;=4;
-                        NEXTNIBBLE(b);
-                        a|=b;
-                        if(a&lt;0x40)
-                        {
-                                a&lt;&lt;=4;
-                                NEXTNIBBLE(b);
-                                a|=b;
-                                if(a&lt;0x100)
-                                {
-                                        a|=(stride-x)&lt;&lt;2;
-                                }
-                        }
-                 }
-              }
-              run=a&gt;&gt;2;
-              color=3-(a&amp;0x3);
-             // aprintf(&quot;Vobsub: Run:%d color:%d\n&quot;,run,color);
-              if((run&gt;stride-x) || !run)
-                run=stride-x;
-              
-              //memset(ptr,color,run);
-              memset(ptr,_colors[color],run);
-              memset(alpha,_alpha[color],run);
-              if(run!=stride) _original-&gt;setDirty(y*2+start);
-              x+=run;
-              ptr+=run;
-              alpha+=run;
-              //  aprintf(&quot;x:%d y:%d\n&quot;,x,y);
-              if(x&gt;=stride)
-              {
-                        
-                     y++;
-                     x=0;
-                     ptr=_original-&gt;_bitmap+(y*2+start)*stride;
-                     alpha=_original-&gt;_alphaMask+(y*2+start)*stride;
-                     SKIPNIBBLE;
-              }
-        }
-        aprintf(&quot;vobsub End :%d y:%d\n&quot;,_curOffset,y); 
-        _curOffset=oldoffset;
-} 
-//***********************************************        
-// Decode Sub automaton command
-//***********************************************
-uint8_t  ADMVideoVobSub::handleSub( uint32_t idx )
-{       
-uint16_t date,next,dum;
-uint8_t  command;
-        _subSize=0;
-uint32_t pts;
-uint64_t posA,posR;
- uint32_t odd,even;
-int doneA=0;
-int doneB=0;
-        _parser-&gt;getPos(&amp;posA,&amp;posR);
-        // Read data
-aprintf(&quot;**Cur:A:%llx R:%llx next:%llx\n&quot;,posA,posR,_vobSubInfo-&gt;lines[idx+1].fileOffset);        
-while(posA&lt;_vobSubInfo-&gt;lines[idx+1].fileOffset)
-{        
-        odd=even=0;
-        aprintf(&quot;**Cur: A:%llx R:%llx next:%llx\n&quot;,posA,posR,_vobSubInfo-&gt;lines[idx+1].fileOffset);
-        
-        _subSize=_parser-&gt;read16i();
-        if(!_subSize)
-        {
-            printf(&quot;Vobsub: error reading\n&quot;);
-            return 0;
-        }
-        
-        aprintf(&quot;Vobsub: data len =%d\n&quot;,_subSize);
-        
-        if(_subSize&gt;VS_MAXPACKET-1)
-         {
-            printf(&quot;Vobsub: error reading (packet too big)\n&quot;);
-            return 0;
-        }
-        if(!_parser-&gt;read(_data+2,_subSize-2)) 
-        {
-                printf(&quot;VS: read failed\n&quot;);
-                return 0;
-        }
-       
-        // We got the full packet
-        // now scan it
-        _curOffset=2;
-        if(_subSize&lt;4)
-        {
-          printf(&quot;[handleSub] Packet too short!\n&quot;);
-          return 1; 
-        }
-        _dataSize=readword();
-        aprintf(&quot;data block=%lu\n&quot;,_dataSize);
-        if(_dataSize&lt;=4)
-        {
-            printf(&quot;Vobsub: data block too small\n&quot;);
-            return 0;       
-        }
-        
-        if(!forward(_dataSize-4)) return 0;    // go to the command block
-        
-        
-        while(2)
-        {
-                if(_curOffset&gt;_subSize-5) break;
-                date=readword();
-                next=readword();
-                if(next==_curOffset-4) break;            // end of command
-                
-                while(_curOffset&lt;next)
-                {
-                      
-                      
-                        command=readbyte();
-                        aprintf(&quot;vobsub:Command : %d date:%d next:%d cur:%lu\n&quot;,command,date,next,_curOffset);
-                        int left=next-_curOffset;
-                        switch(command)
-                        {
-                                case 00: _displaying=1;
-                                        break;
-                                case 01: // start date
-                                        break;
-                                case 02: // stop date
-#if 0                                
-                                        pts=_parser-&gt;getPTS();
-                                        if(!_vobSubInfo-&gt;lines[idx].stopTime)
-                                        {
-                                                double comp;
-                                           
-                                                comp=pts-_initialPts;
-                                                comp=comp/90;     // 90khz
-                                                comp+=date*10;    // 1/100th of a second
-                                                 _vobSubInfo-&gt;lines[idx].stopTime=(uint32_t)comp;
-                                                aprintf(&quot;****Sub: idx : %lu starts at :%lu end at :%lu\n&quot;,
-                                                        idx,
-                                                        _vobSubInfo-&gt;lines[idx].startTime, 
-                                                        _vobSubInfo-&gt;lines[idx].stopTime);
-                                        
-                                        }
-#endif                                        
-                                        break;
-                                case 03: // Pallette 4 nibble= 16 bits
-                                         if(left&lt;2)
-                                         {
-                                            printf(&quot;Command 3: Palette: Not enough bytes left\n&quot;);
-                                            return 1; 
-                                         }
-                                         dum=readword();
-                                        _colors[0]=dum&gt;&gt;12;
-                                        _colors[1]=0xf &amp; (dum&gt;&gt;8);
-                                        _colors[2]=0xf &amp; (dum&gt;&gt;4);
-                                        _colors[3]=0xf &amp; (dum);
-                                        break;          
-                                case 0xff:
-                                        break;
-                                case 04: // alpha channel
-                                         //4 nibble= 16 bits
-                                        if(left&lt;2)
-                                         {
-                                            printf(&quot;Command 4: Alpha: Not enough bytes left\n&quot;);
-                                            return 1; 
-                                         }
-
-                                        dum=readword();
-                                        _alpha[0]=dum&gt;&gt;12;
-                                        _alpha[1]=0xf &amp; (dum&gt;&gt;8);
-                                        _alpha[2]=0xf &amp; (dum&gt;&gt;4);
-                                        _alpha[3]=0xf &amp; (dum);
-                                        break;
-                                case 05:
-                                        // Coordinates 12 bits per entry X1/X2/Y1/Y2
-                                        // 48 bits total / 6 bytes
-                                        {
-                                                uint16_t a,b,c;
-                                                uint32_t nx1,nx2,ny1,ny2;
-                                                if(left&lt;6)
-                                                {
-                                                    printf(&quot;Command 5: Coord: Not enough bytes left\n&quot;);
-                                                    return 1; 
-                                                }
-                                                if(doneA) return 1;
-                                                doneA++;
-                                                a=readword();
-                                                b=readword();
-                                                c=readword();
-                                                nx1=a&gt;&gt;4;
-                                                nx2=((a&amp;0xf)&lt;&lt;8)+(b&gt;&gt;8);
-                                                ny1=((b&amp;0xf)&lt;&lt;4)+(c&gt;&gt;12);
-                                                ny2=c&amp;0xfff;
-                                                
-                                                aprintf(&quot;vobsuv: x1:%d x2:%d y1:%d y2:%d\n&quot;,nx1,nx2,ny1,ny2);
-                                                
-                                                if(nx1==_x1 &amp;&amp; nx2==_x2 &amp;&amp; ny1==_y1 &amp;&amp; ny2==_y2 &amp;&amp; _original)
-                                                {       // Reuse old bitmap
-                                                        _original-&gt;clear();
-                                                }
-                                                else
-                                                {
-                                                  if(_original)
-                                                        delete _original;
-                                                  _original=NULL;
-                                                  _x1=nx1;
-                                                  _x2=nx2;
-                                                  _y1=ny1;
-                                                  _y2=ny2;
-                                                  _subW=_x2-_x1+1;
-                                                  _subH=_y2-_y1+1;                                                
-                                                  _original=new vobSubBitmap(_subW,_subH);
-                                                }
-                                                                        
-                                        }
-                                        break;
-                                case 06: // RLE offset 
-                                        // 2*16 bits : odd offset, even offset
-                                        {
-                                                if(doneB) return 1;
-                                                doneB++;
-                                                if(left&lt;4)
-                                                {
-                                                    printf(&quot;Command 6: RLE: Not enough bytes left\n&quot;);
-                                                    return 1; 
-                                                }
-                                        odd=readword();                                        
-                                        even=readword();
- 
-                                        }
-                                        break;   
-                                default:                                                     
-                                        printf(&quot;Unknown command:%d\n&quot;,command);
-                                        return 0;
-                                  
-                        } //End switch command     
-                }// end while
-        }
-        _parser-&gt;getPos(&amp;posA,&amp;posR);
-        /*****/
-        if(_original &amp;&amp; odd &amp;&amp; even) 
-        {
-                _original-&gt;clear();
-                decodeRLE(odd,0,even);
-                decodeRLE(even,1,0);
-                if(!_vobSubInfo-&gt;hasPalette)
-                {
-                        // guess palette   
-                        guessPalette();
-                }
-        }
-        /*****/
-  }   // Next picture  
-  return 1;
-}
-/*
-    Try to guess the palette...
-*/
-uint8_t ADMVideoVobSub::guessPalette(void)
-{
- int  stat[4];
- uint32_t sum,sumalpha,y,x;
- uint8_t *in,*inmax,*inalpha;
- int background,foreground,candidate1,candidate2;
- 
-    memset(stat,0,4*sizeof(int));
-   
-    in=_original-&gt;_bitmap ;
-    y=_original-&gt;_width*_original-&gt;_height;
-    inmax=in+y;
-    for(x=0;x&lt;y;x++)
-    {
-        stat[(*in)&amp;0x03]++;
-        in++; 
-           
-    }  
-    // normally just between 0 &amp; 3
-    sum=stat[0]+stat[1]+stat[2]+stat[3];
-   
-    #define PERC(x) stat[x]*=10000;stat[x]/=sum;//alpha[x]*=1000;alpha[x]/=sumalpha;
-    PERC(0);
-    PERC(1);
-    PERC(2);
-    PERC(3);
-    int nbColor=0;
-    for(int i=0;i&lt;4;i++) 
-    {
-        printf(&quot;Color : %d percent :%d \n&quot;,i,stat[i]);
-    }
-#define NB_COLOR nbColor=0;for(int i=0;i&lt;4;i++) if(stat[i]) nbColor++;
-#define SEARCH_MAX(OUT) max=0;for(int o=0;o&lt;4;o++) if(stat[o]&gt;max) {max=stat[o];OUT=o;}stat[OUT]=0;
-#define SET_COLOR(x,color) for(int k=0;k&lt;4;k++) _YUVPalette[x+4*k]=color;
-    // Search Max
-    int max=0;
-    memset(_YUVPalette,0,sizeof(_YUVPalette));
-    
-    // The most common color is background
-    SEARCH_MAX(background);
-    SET_COLOR(background,0);
-    printf(&quot;Background is %d\n&quot;,background);
- 
-    // Search for A/B /C
-    in=_original-&gt;_bitmap ;
-    while(in&lt;inmax)
-    {
-        if(*in!=background) break;
-        in++;   
-    };
-    candidate1=*in; 
-    while(in&lt;inmax)
-    {
-        if(*in!=candidate1) break;
-        in++;   
-    };
-    // if we have background / candidate / candidate2
-    //  we consider candidate to be blending and candidate2 to be solid
-    candidate2=*in;
-    if(candidate2!=background)
-    {
-        SET_COLOR(candidate1,0x40);
-        SET_COLOR(candidate2,0xFF); 
-    }else 
-    // We have background / candidate / background
-    // candidate is then considered solid color
-    {
-        SET_COLOR(candidate2,0xff);
-    }
-    return 1;
-    
-}
-
-vobSubBitmap::vobSubBitmap(uint32_t w, uint32_t h)
-{
-  uint32_t page;
-  
-  _width=w;
-  _height=h;
-  
-  page=w*h;
-   
-
-  _bitmap=new uint8_t [page];
-  _alphaMask=new uint8_t [page];
-  _dirty=new uint8_t[h];                                                
-  clear();
-}
-uint8_t vobSubBitmap::isDirty(uint32_t line)
-{
-        ADM_assert(line&lt;_height);
-        if(_dirty[line]) return 1;
-        return 0;
-
-}
-uint8_t vobSubBitmap::setDirty(uint32_t line)
-{
-        ADM_assert(line&lt;_height);
-        _dirty[line]=1;
-        return 1;
-}
-vobSubBitmap::~vobSubBitmap()
-{
-#define CLN(x) if(x) delete [] x;
-
-  CLN(_bitmap);
-  CLN(_alphaMask);  
-  CLN(_dirty);
-}
-void vobSubBitmap::clear(void)
-{
-#define CLR(x) memset(x,0,_width*_height);
-
-  CLR(_bitmap);
-  CLR(_alphaMask);
-  memset(_dirty,0,_height);
-}
-
-//***********************************************************
-// Convert the palette bitmap into yuv + alphamask bitmap
-//
-//***********************************************************
-uint8_t vobSubBitmap::buildYUV( int16_t *palette )
-{
-  
-  uint8_t *ptr;
-
-  ptr=_bitmap;      
-        
-  for(uint32_t y=0;y&lt;_width*_height;y++)
-  {
-    *ptr=palette[*ptr];
-    ptr++;  
-  }
-  return 1;
-}
-//***********************************************************
-//
-//      Resample the square beginning at position = oldtop with a height of oldheigh
-//        to a square of size new, newy
-//
-//***********************************************************
-uint8_t vobSubBitmap::subResize(vobSubBitmap **tgt,uint32_t newx,uint32_t newy,uint32_t oldtop, uint32_t oldheight)
-{
-  int flags=0;
-  SwsContext *ctx=NULL;
-  int er=0;
-  
-  aprintf(&quot;Sub Resize : top %lu height %lu -&gt; %lu %lu\n&quot;,oldtop, oldheight,newx, newy);
-  
-#if 0  
-//#ifdef USE_MMX
-                
-#define ADD(x,y) if( CpuCaps::has##x()) flags|=SWS_CPU_CAPS_##y;
-                ADD(MMX,MMX);           
-                ADD(3DNOW,3DNOW);
-                ADD(MMXEXT,MMX2);
-#endif  
-  flags+=SWS_BILINEAR;
-  // Need a new one ?
-  // Or reuse the old one ?
-  if(*tgt &amp;&amp; (*tgt)-&gt;_width==newx &amp;&amp; (*tgt)-&gt;_height==newy)
-  {
-    (*tgt)-&gt;clear(); // useless FIXME
-  }
-  else
-  {
-    if(*tgt) delete *tgt;
-    *tgt=NULL;
-    *tgt=new  vobSubBitmap(newx,newy);    
-  }
-  
-  // Need to resize ?
-  if(oldheight==newy &amp;&amp; _width==newx)
-  {
-    uint8_t *src,*dst;
-    aprintf(&quot;No need to resize\n&quot;);
-    src=_bitmap+oldtop*_width;
-    dst=(*tgt)-&gt;_bitmap;
-    memcpy(dst,src,newx*newy); 
-    
-    src=_alphaMask+oldtop*_width;
-    dst=(*tgt)-&gt;_alphaMask;
-    memcpy(dst,src,newx*newy); 
-    
-    return 1;    
-  }
-  
-  ctx=sws_getContext(
-  _width,oldheight,
-  PIX_FMT_GRAY8,
-  newx,newy,
-  PIX_FMT_GRAY8,
-  flags,
-  NULL, NULL,NULL);
-
-  ADM_assert(ctx);
-    
-  //************************
-  uint8_t *src[3];
-  uint8_t *dst[3];
-  int ssrc[3];
-  int ddst[3];
-  
-
-  //resize bitmap
-  
-  src[0]=_bitmap+oldtop*_width;
-  src[1]=NULL;
-  src[2]=NULL;
-
-  ssrc[0]=_width;
-  ssrc[1]=ssrc[2]=0;
-
-  
-  dst[0]=(*tgt)-&gt;_bitmap;
-  dst[1]=NULL;
-  dst[2]=NULL;
-  
-  ddst[0]=newx;
-  ddst[1]=ddst[2]=0;
-
-  er=sws_scale(ctx,src,ssrc,0,oldheight,dst,ddst);
-  aprintf(&quot;Er:%d\n&quot;,er);
-  
-  // And alpha
-  src[0]=_alphaMask+oldtop*_width;  
-  dst[0]=(*tgt)-&gt;_alphaMask;
-  er=sws_scale(ctx,src,ssrc,0,_height,dst,ddst);
-  aprintf(&quot;Er:%d\n&quot;,er);
-  // end
-  sws_freeContext(ctx); 
-  return 1;             
-}
-
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobsub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobsub.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobsub.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,650 +0,0 @@
-//
-// C++ Implementation:Spudecoder (subs for DVd like stream)
-//
-// Description:
-//
-//
-// Author: Mean, <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-// see <A HREF="http://sam.zoy.org/writings/dvd/subtitles/">http://sam.zoy.org/writings/dvd/subtitles/</A>
-
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;DIA_fileSel.h&quot;
-#include &quot;ADM_colorspace.h&quot;
-#include &quot;ADM_vobsubinfo.h&quot;
-#define VOBSUB &quot;/capture/sub/phone.sub&quot;
-#include &quot;ADM_videoFilterDynamic.h&quot;
-#include &quot;ADM_vidVobSub.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-#include &lt;math.h&gt;
-
-extern uint8_t DIA_vobsub(vobSubParam *param);
-
-static FILTER_PARAM vobsubParam={3,{&quot;subname&quot;,&quot;index&quot;,&quot;subShift&quot;}};
-//*************************************************************
-//
-
-//*************************************************************
-SCRIPT_CREATE(vobsub_script,ADMVideoVobSub,vobsubParam);
-BUILD_CREATE(vobsub_create,ADMVideoVobSub);
-//*************************************************************
-uint8_t ADMVideoVobSub::configure(AVDMGenericVideoStream *in)
-{
-
-       
-  if(DIA_vobsub(_param))
-       {
-                cleanup();
-                setup();
-                return 1;
-       }
-        
-        return 0;        
-}
- 
-//*************************************************************
-char *ADMVideoVobSub::printConf( void )
-{
-    ADM_FILTER_DECLARE_CONF(&quot; VobSub&quot;);
-        
-}
-//*************************************************************
-ADMVideoVobSub::ADMVideoVobSub(  AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-        _in=in;         
-        memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-        _info.encoding=1;       
-        _parser=NULL;  
-        _resampled=NULL;
-        _chromaResampled=NULL;
-        _original=NULL;        
-        
-        _param=NEW(vobSubParam);
-        
-        if(couples)
-        {                 
-                GET(subname);
-                GET(index);                               
-                GET(subShift);  
-        }
-        else
-        {
-#ifdef KK_ADM_DEBUG
-                _param-&gt;subname=ADM_strdup(VOBSUB);
-#else                
-                _param-&gt;subname =NULL;
-#endif                
-                _param-&gt;index = 0;   
-                _param-&gt;subShift=0;             
-        }
-        
-        setup();
-}
-/*
-    Alternate constructor for use by OCR
-*/
-ADMVideoVobSub::ADMVideoVobSub(  char *fileidx,uint32_t idx)
-{
-
-        _in=NULL;         
-        memset(&amp;_info,0,sizeof(_info));    
-        _info.encoding=1;       
-        _parser=NULL;  
-        _resampled=NULL;
-        _chromaResampled=NULL;
-        _original=NULL;        
-        
-        _param=NEW(vobSubParam);
-        
-        
-        _param-&gt;subname=ADM_strdup(fileidx);
-        _param-&gt;index = idx;   
-        _param-&gt;subShift=0;                    
-        
-        setup();
-}
-/*
-    Returns bitmap &amp; info for the Nth subs
-*/
-
-vobSubBitmap *ADMVideoVobSub::getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last)
-{
-uint32_t top=0,bottom=0;
-    ADM_assert(_vobSubInfo);
-    ADM_assert(nb&lt;_vobSubInfo-&gt;nbLines);
-    
-    // Seek &amp; decode
-    //_parser-&gt;_asyncJump2(0,_vobSubInfo-&gt;lines[nb].fileOffset);
-    _parser-&gt;setPos(_vobSubInfo-&gt;lines[nb].fileOffset,0);
-    if(!handleSub(nb))
-        {
-                printf(&quot;Error reading getBimap\n&quot;);
-                *first=*last=0;
-                return _original; // might be null (?)
-        }
-    *first=*last=0;
-    if(_original)
-    {
-    uint32_t ox,oy;
-        _original-&gt;buildYUV(_YUVPalette);
-        ox=_original-&gt;_width;        
-        oy=_original-&gt;_height;
-        printf(&quot;Original :%lu x %lu (original  %d)\n&quot;,ox,oy,_vobSubInfo-&gt;height);
-        ADM_assert(oy&lt;=_vobSubInfo-&gt;height);
-        
-        // Search the 1st/last non null line
-//#define DONTCLIP
-#ifdef DONTCLIP     
-         *first=0;
-         *last=oy-1;   
-#else
-        if(oy&gt;_original-&gt;_height) oy=_original-&gt;_height-1;
-
-        while(top&lt;oy &amp;&amp; !_original-&gt;isDirty(top) ) top++;
-        
-        if(top==oy)
-        {
-                top=bottom=0;   // Empty bitmap ?
-                *first=top;
-                *last=bottom;
-                printf(&quot;Empry bitmap\n&quot;);
-                return NULL; 
-        }
-        bottom=oy-1;
-        while(bottom&gt;top &amp;&amp; !_original-&gt;isDirty(bottom)) bottom--;
-        
-        // If true it means we have 2 subs, one on top, one on bottom
-        //
-#if 0
-        if(bottom&gt;(oy&gt;&gt;1) &amp;&amp; top&lt;(oy&gt;&gt;1) &amp;&amp; (bottom-top&gt;(oy&gt;&gt;1)))
-        {
-          // in that case, take only the lower one
-          top=oy&gt;&gt;1;
-          while(top&lt;oy &amp;&amp; !_original-&gt;isDirty(top)) top++;                    
-        }
-        printf(&quot;&gt; clipped: %lu / %lu=%lu\n&quot;,top,bottom,bottom-top+1);
-#endif
-        *first=top;
-        *last=bottom;
-#endif
-    }
-    *start=_vobSubInfo-&gt;lines[nb].startTime;
-    *end=_vobSubInfo-&gt;lines[nb].stopTime;
-    return _original;
-}
-/*
-    Returns the nb of lines found in the sub
-*/
-uint32_t     ADMVideoVobSub::getNbImage( void)
-{
-    if(!_parser) return 0;
-    if(!_param) return 0;
-    if(!_vobSubInfo) return 0;
-    return _vobSubInfo-&gt;nbLines;
-
-}
-//************************************
-uint8_t ADMVideoVobSub::setup(void)
-{
-  char *dup;
-  int l;
-  
-   _vobSubInfo=NULL;
-   if(_param-&gt;subname &amp;&amp; strlen(_param-&gt;subname)&gt;5)
-        {
-                printf(&quot;Opening %s\n&quot;,_param-&gt;subname);
-                dup=ADM_strdup(_param-&gt;subname);
-                l=strlen(dup);
-                if(l&gt;5)
-                  if(dup[l-4]=='.')
-                {
-                  dup[l-3]='s';
-                  dup[l-2]='u';
-                  dup[l-1]='b';
-                          
-                }
-                if(vobSubRead(_param-&gt;subname,_param-&gt;index,&amp;_vobSubInfo))
-                {
-                        printf(&quot;Opening index \n&quot;);
-                       
-                        MPEG_TRACK track;
-                        memset(&amp;track,0,sizeof(track));
-                        track.pes=_param-&gt;index+0x20;
-                        track.pid=0;
-                       // _parser=new ADM_mpegDemuxerProgramStream(_param-&gt;index+0x20,0xe0);
-                        _parser=new dmx_demuxerPS(1,&amp;track,0);
-                        if(!_parser-&gt;open(dup))
-                        {
-                                printf(&quot;Mpeg Parser : opening %s failed\n&quot;,_param-&gt;subname);
-                                delete _parser;
-                                _parser=NULL;
-                
-                         }
-                         
-                }
-                ADM_dealloc(dup);
-        }
-        
-        
-        if(!_parser)
-        {
-                printf(&quot;opening of vobsub file failed\n&quot;);
-        }
-         else
-        {       // Recompute sub duration
-                uint32_t end;
-                vobSubLine *cur,*next;
-                // Assuming max displat time = MAX_DISPLAY_TIME
-                for(uint32_t i=0;i&lt;_vobSubInfo-&gt;nbLines-1;i++)
-                {
-                        if(i &amp;&amp; !_vobSubInfo-&gt;lines[i].startTime)
-                        {
-                                _vobSubInfo-&gt;lines[i].startTime=0xf0000000;
-                                _vobSubInfo-&gt;lines[i].stopTime=0xf0000001;
-                                
-                        }
-                        else
-                        {
-                                cur=&amp;_vobSubInfo-&gt;lines[i];
-                                next=&amp;_vobSubInfo-&gt;lines[i+1];
-                        
-                                end=cur-&gt;startTime+MAX_DISPLAY_TIME;
-                                if(end&gt;=next-&gt;startTime) end=next-&gt;startTime-1;
-                                cur-&gt;stopTime=end;                                
-                        }
-                }
-                _vobSubInfo-&gt;lines[_vobSubInfo-&gt;nbLines-1].stopTime=
-                        MAX_DISPLAY_TIME+_vobSubInfo-&gt;lines[_vobSubInfo-&gt;nbLines-1].startTime;
-                // Convert all the palette from RGB to YUV
-                paletteYUV();
-        }
-      
-        _x1=_y1=_x2=_y2=0;
-        _data=new uint8_t [VS_MAXPACKET];
-        _subSize=0;
-        _subW=_subH=0;
-        
-        memset(&amp;_original,0,sizeof(_original));
-        _currentSub=NOSUB;
-        _initialPts=0;
-                
-
-}
-//*************************************************************
-uint8_t ADMVideoVobSub::cleanup(void)
-{
-
-        if(_parser) delete _parser;
-        _parser=NULL;
-        
-        if(_original)
-          delete _original;
-        _original=NULL;        
-        
-        if(_resampled)
-          delete _resampled;
-        _resampled=NULL;
-        
-        if(_chromaResampled)
-          delete _chromaResampled;
-        _chromaResampled=NULL;
-        
-        
-        if(_data) delete [] _data;
-        _data=NULL;
-        
-        if(_vobSubInfo) destroySubInfo( _vobSubInfo);
-        _vobSubInfo=NULL;
-        
-
-}
-//*************************************************************
-ADMVideoVobSub::~ADMVideoVobSub()
-{
-        cleanup();
-         if(_param)
-        {
-                if(_param-&gt;subname)  ADM_dealloc(_param-&gt;subname);
-                DELETE(_param);
-        }
-        _param=NULL;
-}
-
-//*************************************************************
-uint8_t ADMVideoVobSub::getCoupledConf( CONFcouple **couples)
-{
-                        ADM_assert(_param);
-                        *couples=new CONFcouple(3);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-                        if(_param-&gt;subname)
-                                CSET(subname);
-                        else
-                          (*couples)-&gt;setCouple(&quot;subname&quot;,&quot;none&quot;) ;
-                        CSET(index);
-                        CSET(subShift);
-                        
-
-                        return 1;
-}
-//*************************************************************
-uint8_t ADMVideoVobSub::getFrameNumberNoAlloc(uint32_t frame,
-                                uint32_t *len,
-                                ADMImage *data,
-                                uint32_t *flags)
-{
-
-uint64_t time;
-uint32_t sub;
-
-        if(frame&gt;= _info.nb_frames) return 0;
-        // read uncompressed frame
-        if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-
-        if(!_parser)        
-        {
-                //
-                printf(&quot;No valid vobsub to process\n&quot;);
-                
-                return 1;
-        
-        }
-        
-        time=(frame+_info.orgFrame);
-        time=(time*1000*1000)/_info.fps1000;
-        
-        sub=lookupSub(time);  
-        // Should we re-use the current one ? 
-        if(sub==NOSUB)
-        {
-                aprintf(&quot;No matching sub for time %llu frame%lu\n&quot;,time,frame);
-                return 1;
-        }
-        // If it is a new sub, decode it...
-        if(sub!=_currentSub )
-        {                
-                // _parser-&gt;_asyncJump2(0,_vobSubInfo-&gt;lines[sub].fileOffset);
-                _parser-&gt;setPos(_vobSubInfo-&gt;lines[sub].fileOffset,0);
-                 //_initialPts=_parser-&gt;getPTS();
-                 handleSub(sub);
-                _currentSub=sub;
-                Palettte2Display(); // Create the bitmap
-                // Time to resize the bitmap
-                // First try : Do it bluntly
-                
-        }                
-        
-        // and if there is something to display, display it
-        //
-        vobSubBitmap *src;
-        //src=_original;
-        src=_resampled;
-        
-        if(src)          
-        {
-               
-          aprintf(&quot;We have %lu %lu to merge\n&quot;,src-&gt;_width,src-&gt;_height);
-                // Merge
-                
-                uint32_t stridein,strideout,len;
-                uint8_t *in,*out,*mask,*in2;
-                uint16_t old,nw,alp;
-                uint32_t xx,yy;
-                
-                stridein=src-&gt;_width;
-                strideout=_info.width;
-                
-                if(strideout&gt;stridein)
-                {
-                        len=stridein;
-                        xx=src-&gt;_width;
-                }
-                else
-                {
-                        xx=_info.width;
-                        len=strideout;
-                }
-                if(src-&gt;_height&gt;_info.height) yy=_info.height;
-                        else                 yy=src-&gt;_height;           
-                in=src-&gt;_bitmap;
-                mask=src-&gt;_alphaMask;
-               
-                out=data-&gt;data+_info.width*src-&gt;placeTop;
-                // auto center
-                uint32_t center=_info.width-src-&gt;_width;
-                out+=(center&gt;&gt;2)*2;
-                
-                for(uint32_t y=0;y&lt;yy;y++)
-                {
-                  for(uint32_t x=0;x&lt;xx;x++)
-                        {
-                               old=out[x];
-                               nw=in[x];
-                               alp=mask[x];
-
-                                if(alp) 
-                                {
-                                  if(alp&gt;7)  nw=old*(16-alp-1)+(alp+1)*nw;
-                                        else nw=old*(16-alp)+(alp)*nw;
-                                  out[x]=nw&gt;&gt;4;                                         
-                                }
-
-                               //out[x]=nw;
-                        }
-                        //memcpy(out,in,len);
-                        out+=strideout;
-                        in+=stridein;
-                        mask+=stridein;
-                }
-                
-                // Now do chroma u &amp; chroma V
-#define DOCHROMA                
-#if defined(DOCHROMA)                
-                uint32_t crosspage=(_info.width*_info.height)&gt;&gt;2;
-                
-                strideout=_info.width&gt;&gt;1;
-                stridein=_chromaResampled-&gt;_width;
-                
-                out=data-&gt;data+_info.width*_info.height;
-                out+=(src-&gt;placeTop&gt;&gt;1)*(_info.width&gt;&gt;1);
-                mask=_chromaResampled-&gt;_alphaMask;
-                // Center
-                out+=(center&gt;&gt;2)*1;
-                if(strideout&gt;stridein) xx=stridein;
-                else            xx=strideout;
-                
-                int16_t left=(_info.height&gt;&gt;1)-(_chromaResampled-&gt;_height+(_original-&gt;placeTop&gt;&gt;1));
-                
-                if(left&lt;_chromaResampled-&gt;_height) yy=left;
-                else yy=_chromaResampled-&gt;_height;
-                
-                for(uint32_t y=0;y&lt;yy;y++)
-                {
-                   for(uint32_t x=0;x&lt;xx;x++)
-                   {
-                        if(mask[x]&gt;10)         
-                        {
-                          int16_t val;
-                          val=out[x];
-                          val-=128;
-                         
-                          
-                          
-                          nw=val*(16-alp);
-                          
-                          val/=4;
-                          val=val+128;
-                                
-                          out[x]=val; 
-                          out[crosspage+x]=val;
-                        }                                                 
-                   }
-                   out+=strideout;
-                   mask+=stridein;
-                }
-#endif                
-        }
-        return 1;
-}
-//*************************************************************************
-//
-//      Convert the original bitmap to a rescaled &amp; repositionned one
-//      that will be blended into the current picutr
-//
-//*************************************************************************
-uint8_t ADMVideoVobSub::Palettte2Display( void )
-{
-        ADM_assert(_parser);
-        ADM_assert(_vobSubInfo);
-     
-        // Then Process the RLE Datas
-        // To get the _bitmap yuv data
-        ADM_assert(_original);
-        
-        // Set correct color
-        _original-&gt;buildYUV(_YUVPalette);
-        
-        // rebuild the scaled one
-        // Compute the target size
-        uint32_t fx,fy;
-        uint32_t ox,oy;
-        uint32_t sx,sy;
-        /*
-                Fx, fy : Final size of the image (i.e size of the current picture)
-                ox,oy  : Original size of the image where the sub is coming from
-                sx,sy  : Size of the  sub
-        
-                And we want the final size of the sub
-                        + coordinates but that we will do later
-        
-        */
-        
-        fx=_info.width;
-        fy=_info.height;
-        
-        ox=_vobSubInfo-&gt;width;
-        oy=_vobSubInfo-&gt;height;
-        
-        sx=_subW;
-        sy=_subH;
-        
-        // Search the 1st/last non null line
-        uint32_t top=0,bottom=0;
-
-        if(oy&gt;_original-&gt;_height) oy=_original-&gt;_height-1;
-
-        while(top&lt;oy &amp;&amp; !_original-&gt;isDirty(top)) top++;
-        
-        bottom=_original-&gt;_height-1;
-        if(top==bottom)
-        {
-                printf(&quot;Empty sub ?&quot;);
-                return 0;
-        }
-        
-        while(bottom &amp;&amp; !_original-&gt;isDirty(bottom)) bottom--;
-        
-        // If true it means we have 2 subs, one on top, one on bottom
-        //
-        if(bottom&gt;(oy&gt;&gt;1) &amp;&amp; top&lt;(oy&gt;&gt;1) &amp;&amp; (bottom-top&gt;(oy&gt;&gt;1)))
-        {
-          // in that case, take only the lower one
-          top=oy&gt;&gt;1;
-          while(top&lt;oy &amp;&amp; !_original-&gt;isDirty(top)) top++;                    
-        }
-        //
-        //  The useful part is between top &amp; bottom lines
-        //
-        
-        // Shrink factor
-        // The shrink factor is the one used to shrink from the original video
-        // to the resize video
-        
-        double scale,l;
-        scale=fx;
-        scale/=ox;
-        printf(&quot;top %lu : bottom :%lu Scale :%f ox:%lu oy:%lu fx:%lu \n&quot;,top,bottom,scale,ox,oy,fx);
-        
-        // We rescale the sub by the same factor
-        // Only the visible / useful part
-        l=scale;
-        l=l*sx;
-        sx=(uint32_t )floor(l);
-        
-       
-        l=scale;
-        l=l*(bottom-top);
-        sy=(uint32_t )floor(l);
-        
-
-        // And we resize that useful part of sub
-        // to our final bitmap (resampled)
-                
-        _original-&gt;subResize(&amp;_resampled,sx,sy,top, bottom-top);
-                
-        uint32_t tail;
-        
-        // Set the position of the sub so that it is ok
-        
-        tail=16+sy;
-        
-        if(tail&gt;fy) tail=0;
-        else
-        {
-            tail=fy-tail;           
-        }
-        
-        _resampled-&gt;placeTop=tail;
-        
-        _resampled-&gt;subResize(&amp;_chromaResampled,sx&gt;&gt;1,sy&gt;&gt;1,0,sy);
-        return 1;
-}
-
-//
-//      Return the index in the sub table of the sub matching the time
-//
-uint32_t ADMVideoVobSub::lookupSub(uint64_t time)
-{
-int64_t head,tail, cur;
-int32_t i;
-        cur=(int64_t)time;
-        i=0;
-        while(i&lt;_vobSubInfo-&gt;nbLines-1)
-        {
-                head=(int64_t)_vobSubInfo-&gt;lines[i].startTime;
-                tail=(int64_t) _vobSubInfo-&gt;lines[i].stopTime;
-                head+=_param-&gt;subShift;
-                tail+=_param-&gt;subShift;
-                if(head&lt;=cur &amp;&amp;tail&gt;cur)
-                {
-                  aprintf(&quot;Matching for time %llu : sub %lu starting at :%lu (shift %lu)\n&quot;,
-                                        time,i,_vobSubInfo-&gt;lines[i].startTime,_param-&gt;subShift);
-                        return i; 
-                }   
-                if(head&gt;cur) return NOSUB;                   
-                i++;       
-        }
-        return NOSUB;
-
-
-}
-//EOF
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,263 +0,0 @@
-//
-// C++ Implementation: vobsub parser
-//
-// Description:
-//
-//
-// Author: Mean, 2005 GPL
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;config.h&quot;
-
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_vobsubinfo.h&quot;
-
-static uint8_t fillLine(char *str,VobSubInfo *sub,uint32_t line);
-static uint32_t countLine(FILE *f,int index);
-uint8_t fillPalette(char *str,VobSubInfo *sub);
-
-uint8_t destroySubInfo(VobSubInfo *sub)
-{
-        if(!sub) return 1;      // ?
-        if(sub-&gt;lines) delete [] sub-&gt;lines;
-        delete sub;
-        return 1;
-
-
-}
-//****************** 
-// Extract Line info
-//******************
-uint8_t fillLine(char *str,VobSubInfo *sub,uint32_t line)
-{
-int hh,mm,ss,ms,o;
-uint64_t ti;
-uint32_t pos;
-
-        ADM_assert(line&lt;sub-&gt;nbLines);
-
-        o=sscanf(str,&quot;timestamp: %d:%d:%d:%d, filepos: %x\n&quot;,&amp;hh,&amp;mm,&amp;ss,&amp;ms,&amp;pos);
-        ADM_assert(o==5);
-        
-        ti=hh*3600+mm*60+ss;
-        ti=ti*1000+ms;
-        
-        sub-&gt;lines[line].startTime      =ti;
-        sub-&gt;lines[line].stopTime       =ti+1000;
-        sub-&gt;lines[line].fileOffset     =pos;
-        
-        return 1;
-}
-//******************
-// Extract palette
-//******************
-uint8_t fillPalette(char *str,VobSubInfo *sub)
-{
-int p[16],o;
-
-        o=sscanf(str,&quot;palette: %x, %x, %x, %x, %x, %x, %x, %x,&quot;
-                                &quot; %x, %x, %x, %x, %x, %x, %x, %x&quot;,
-                                &amp;p[0],&amp;p[1],&amp;p[2],&amp;p[3],&amp;p[4],&amp;p[5],&amp;p[6],&amp;p[7],
-                                &amp;p[8],&amp;p[9],&amp;p[10],&amp;p[11],&amp;p[12],&amp;p[13],&amp;p[14],&amp;p[15]);
-        ADM_assert(o==16);
-        for(int i=0;i&lt;16;i++)
-                sub-&gt;Palette[i]=p[i];
-                                       
-        return 1;
-}
-//******************
-//******************
-uint8_t vobSubRead(char *filename,int index,VobSubInfo **info)
-{
-FILE            *file=NULL;
-uint32_t        nb_lines;
-VobSubInfo      *sub=NULL;
-uint8_t         success=0;
-uint32_t        line=0,l;
-char            str[1024];
-char            *dup;
-int             language=0;
-
-        if(!filename)
-        {
-                printf(&quot;Null file ?\n&quot;);
-                return 0;
-        }
-        *info=NULL;
-        file=fopen(filename,&quot;rt&quot;);
-        if(!file) 
-        {
-                printf(&quot;Could not open %s file\n&quot;,filename);
-                return 0;
-        }
-        nb_lines=countLine(file,index);
-        if(!nb_lines)
-        {
-                printf(&quot;Empty file\n&quot;);
-                 goto subAbort;
-        }
-        // Try to read the file
-        sub=new VobSubInfo;
-        memset(sub,0,sizeof(VobSubInfo));
-        //
-        sub-&gt;nbLines=nb_lines;
-        sub-&gt;lines=new vobSubLine[nb_lines];
-        memset(sub-&gt;lines,0,sizeof(vobSubLine)*nb_lines);
-        printf(&quot;Rebuilding %d lines of subs\n&quot;,nb_lines);
-        
-        while(line&lt;nb_lines &amp;&amp; !feof(file))
-        {
-                fgets(str,1023,file); 
-                if(!strncmp(str,&quot;palette:&quot;,7))
-                {
-                                 fillPalette(str,sub);
-                                 sub-&gt;hasPalette=1;
-                }
-                else 
-                {
-                        if(!strncmp(str,&quot;timestamp: &quot;,10) &amp;&amp; language)        
-                        {
-                                fillLine(str,sub,line);
-                                line++;
-                        }
-                        else
-                        {
-                                if(!strncmp(str,&quot;id:&quot;,3))       // Catch language/index
-                                {
-                                  int  l;
-                                  char s[50];
-                                  s[0]=0;
-                                  l=999;
-                                  sscanf(str,&quot;id: %s index: %d&quot;,s,&amp;l);
-                                  printf(&quot;Found lang : %s index %d while searching %d\n&quot;,s,l,index);
-                                  if(l==index)
-                                  {
-                                	  language=1;
-                                	  printf(&quot;Match\n&quot;);
-                                  }
-                                  else language=0;                                                                              
-                                
-                                }
-                                else
-                                {
-                                        if(!strncmp(str,&quot;size:&quot;,5))       // Catch original screen dimension
-                                        {
-                                            sscanf(str,&quot;size:%&quot;SCNu32&quot;x%&quot;SCNu32&quot;&quot;,&amp;(sub-&gt;width),&amp;(sub-&gt;height));
-                                        }
-                                
-                                }
-                                
-                        }
-                }
-        }
-subSuccess:        
-        success=1;
-        if(!sub-&gt;hasPalette)
-        {
-            for(int j=0;j&lt;16;j++)
-                sub-&gt;Palette[j]=j;   
-        }
-subAbort:        
-        if(success)
-        {
-                *info=sub;
-        }
-        else
-        {
-                destroySubInfo( sub);        
-        }
-        fclose(file);
-        return success;
-
-}
-//******************
-// count #nb beginning by timestamp in file
-//******************
-uint32_t countLine(FILE *f,int index)
-{
-char str[1024],s[1024];
-uint32_t nb=0;
-uint32_t match=0;
-int lang;
-
-        fseek(f,0,SEEK_SET);
-        while(!feof(f))
-        {
-                fgets(str,1023,f);
-                if(!strncmp(str,&quot;id:&quot;,3))
-                {
-                  s[0]=0;
-                  lang=9999;
-                  sscanf(str,&quot;id: %s index: %d&quot;,s,&amp;lang);
-                  if(lang==index) match=1;
-                  else match=0;
-                }
-                else
-                  if(match)
-                        if(!strncmp(str,&quot;timestamp: &quot;,10)) nb++;
-        
-        }
-        fseek(f,0,SEEK_SET);
-        return nb;
-}
-//*****************************************
-vobSubLanguage *vobSubAllocateLanguage(void)
-{
-  vobSubLanguage *l;
-  l=new vobSubLanguage;
-  memset(l,0,sizeof(vobSubLanguage));
-  return l;  
-}
-//*****************************************
-uint8_t vobSubDestroyLanguage(vobSubLanguage *lingua)
-{
-  for(uint32_t i=0;i&lt;lingua-&gt;nbLanguage;i++)  
-    delete [] lingua-&gt;language[i].name;
-  delete lingua; 
-  return 1;
-}
-//*****************************************
-uint8_t vobSubGetLanguage(const char *filename,vobSubLanguage *lingua)
-{
-  char str[1024];
-  char s[16];
-  uint32_t nb=0,index;
-  FILE *fd=NULL;
-  
-  fd=fopen(filename,&quot;rb&quot;);
-  if(!fd) return 0;
-  
-  
-
-  
-  while(!feof(fd))
-  {
-    fgets(str,1023,fd);
-    if(!strncmp(str,&quot;id: &quot;,3))
-    {
-      sscanf(str,&quot;id: %s index: %d&quot;,s,&amp;index);
-      lingua-&gt;language[nb].name=new char[3];
-      lingua-&gt;language[nb].name[0]=str[4];
-      lingua-&gt;language[nb].name[1]=str[5];
-      lingua-&gt;language[nb].name[2]=0;
-      //
-      lingua-&gt;language[nb].index=index;
-      nb++;
-    }        
-  }
-  lingua-&gt;nbLanguage=nb;
-  return 1;
-}
-
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,60 +0,0 @@
-//
-// C++ Interface: Vobsubinfo struct &amp; prototyping
-//
-// Description: Read the idx part of an index file
-//
-//
-// Author: mean , <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>, GPL (C) 2005
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef _VOBSUB_INFO_
-#define _VOBSUB_INFO_
-#define ADM_MAX_LANGUAGE 33
-typedef struct vobSubLine
-{
-        uint32_t        startTime;      /// Starting time in ms
-        uint32_t        stopTime;       /// Stop time
-        uint64_t        fileOffset;     /// Offset in the file where this sub starts
-
-}vobSubLine;
-typedef struct vobSubOneLang
-{
-        char     *name;
-        uint32_t index;
-}vobSubOneLang;
-typedef struct vobSubLanguage
-{
-        uint32_t        nbLanguage; 
-        vobSubOneLang   language[ADM_MAX_LANGUAGE];  
-}vobSubLanguage;
-
-typedef struct VobSubInfo
-{
-        uint32_t        hasPalette;
-        uint32_t        Palette[16];
-        uint32_t        nbLines;
-        uint32_t        width;
-        uint32_t        height;
-        vobSubLine      *lines;
-}VobSubInfo;
-
-/// Read the sub and return a new filled out vobsub info struct
-uint8_t vobSubRead(char *filename,int index,VobSubInfo **info);
-uint8_t destroySubInfo(VobSubInfo *sub);
-
-uint8_t         vobSubGetLanguage(const char *filename,vobSubLanguage *lingua);
-vobSubLanguage  *vobSubAllocateLanguage(void);
-uint8_t         vobSubDestroyLanguage(vobSubLanguage *lingua);
-
-#endif
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADMmpdetc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADMmpdetc.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADMmpdetc.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,741 +0,0 @@
-//
-//
-// C++ Implementation: ADM_mpdetc
-//
-// Description: 
-//
-//	This is a port of mplayer ivtc filter by Richard 
-//	Copyright Richard Felker
-//
-// Author:Richard Felker, port to avidemux2 by  mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2003
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-#define HAVE_DETC
-#ifdef HAVE_DETC
-
-#include &quot;config.h&quot;
-#include &quot;ADM_lavcodec.h&quot;
-#include &quot;fourcc.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_video/ADM_mpdetc.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-//static void decimate(uint8_t *src,uint8_t *target, uint32_t linessrc, uint32_t width);
-#include &quot;ADM_filter/video_filters.h&quot;
-
-
-static FILTER_PARAM flipParam={0,{&quot;&quot;}};
-
-
-SCRIPT_CREATE(mpdetc_script,AVDMVideoMPDetc,flipParam);
-BUILD_CREATE(mpdetc_create,AVDMVideoMPDetc);
-
-
-void 		*my_memcpy_pic(uint8_t * dst, uint8_t * src, int bytesPerLine, int height, 
-						int dstStride, int srcStride);
-unsigned int 	hash_pic(unsigned char *img, int w, int h, int stride);
-static void 	block_diffs_C(struct metrics *m, unsigned char *old, unsigned char *nw, int os, int ns);
-#ifdef ADM_CPU_X86
-void block_diffs_MMX(struct metrics *m, unsigned char *old, unsigned char *ew, int os, int ns);
-#endif
-static void 	diff_planes(struct metrics *m, unsigned char *old, unsigned char *nw, int w, int h, int os, int ns);
-static void 	diff_fields(struct frameinfo *fi, uint8_t  *old, uint8_t  *nw);
-static void 	status(struct frameinfo *f);
-static void 	copy_image(ADMImage  *sdest, ADMImage  *ssrc, int field);
-
-static uint32_t 	myw,myh;
-static struct vf_priv_s *myparam; // UGLY FIXME BURK
-
-
-
-
-char *AVDMVideoMPDetc::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf,&quot; Mplayer ivtc&quot;);
-        return buf;
-}
-
-//_______________________________________________________________
-AVDMVideoMPDetc::AVDMVideoMPDetc(
-				AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-	
-	// We alter frame rate here and # of frames
-	aprintf(&quot;Frame in : %lu fpsin: %lu\n&quot;,_info.nb_frames,_info.fps1000);
-	_info.fps1000=(_info.fps1000*4)/5;	
-	_info.nb_frames=_info.nb_frames/5;
-	_info.nb_frames=_info.nb_frames*4;
-	aprintf(&quot;Frame out : %lu fpout: %lu\n&quot;,_info.nb_frames,_info.fps1000);
-//	_uncompressed=new uint8_t[(3*_info.width*_info.height)&gt;&gt;1];
-//	_lastFrame=new uint8_t[(3*_info.width*_info.height)&gt;&gt;1];
-	_uncompressed=new ADMImage(_info.width,_info.height);
-	_lastFrame=new ADMImage(_info.width,_info.height);
-	
-	_param=new vf_priv_s;
-	_param-&gt;drop = 0;
-	_param-&gt;first = 1;
-	_inFrame=0;
-	_lastAsked=0xffffff0;
-		
-}
-
-// ___ destructor_____________
-AVDMVideoMPDetc::~AVDMVideoMPDetc()
-{
- 	delete  _uncompressed;
-	delete  _lastFrame;
-	if(myparam)
-	{
-		delete _param;
-		_param=NULL;
-	}
-	
-
-}
-
-int foo(struct vf_priv_s *p, uint8_t  *nw, uint8_t *cur)
-{
-	struct frameinfo *f = p-&gt;fi;
-
-	f[0] = f[1];
-	diff_fields(&amp;(f[1]), cur, nw);
-	status(&amp;(f[1]));
-
-	// Immediately drop this frame if it's already been used.
-	if (p-&gt;dropnext) {
-		p-&gt;dropnext = 0;
-		return F_DROP;
-	}
-	
-	// Sometimes a pulldown frame comes all by itself, so both
-	// its top and bottom field are duplicates from the adjacent
-	// two frames. We can just drop such a frame, but we
-	// immediately show the next frame instead to keep the frame
-	// drops evenly spaced during normal 3:2 pulldown sequences.
-	if ((3*f[1].r.o &lt; f[1].r.e) &amp;&amp; (f[1].r.s &lt; f[1].r.d)) {
-		p-&gt;dropnext = 1;
-		return F_NEXT;
-	}
-	
-	// If none of these conditions hold, we will consider the frame
-	// progressive and just show it as-is.
-	if (!(  (3*f[0].r.e &lt; f[0].r.o) ||
-		((2*f[0].r.d &lt; f[0].r.s) &amp;&amp; (f[0].r.s &gt; 1200)) ||
-		((2*f[1].r.t &lt; f[1].r.p) &amp;&amp; (f[1].r.p &gt; 1200))  ))
-		return F_SHOW;
-
-	// Otherwise, we have to decide whether to merge or drop.
-	// If the noise metric only increases minimally, we're off
-	// to a good start...
-	if (((2*f[1].r.t &lt; 3*f[1].r.p) &amp;&amp; (f[1].r.t &lt; 3600)) ||
-		(f[1].r.t &lt; 900) || (f[1].r.d &lt; 900)) {
-		// ...and if noise decreases or the duplicate even field
-		// is detected, we go ahead with the merge.
-		if ((3*f[0].r.e &lt; f[0].r.o) || (2*f[1].r.t &lt; f[1].r.p)) {
-			p-&gt;dropnext = 1;
-			return F_MERGE;
-		}
-	}
-	return F_DROP;
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-#define clear(x) {memset(x,0,page);memset(x+page,128,page&gt;&gt;1);}
-
-uint8_t AVDMVideoMPDetc::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-uint32_t page=_info.width*_info.height;
-
-		if(frame&gt;=_info.nb_frames) return 0;
-		
-       				
-		myw=_info.width;
-		myh=_info.height; // UGLY!!!
-		myparam=_param;
-		aprintf(&quot;Request for %lu frames (last %lu)\n&quot;,frame,_lastAsked);
-		// First frame or out of order, we copy it to prefill buffer
-		if(_lastAsked+1!=frame) 
-		{
-			// Convert to source filter frame no
-		  uint32_t off;			
-			aprintf(&quot;--Out of order access\n&quot;);
-			off=frame%4;	
-			frame=frame-off;		
-			_inFrame=(frame*5)&gt;&gt;2;
-			// 4 frame -&gt; 5 frame
-			_inFrame+=off;
-			// Init buffer
-			// Clear refimage
-			clear(_lastFrame);	
-			_param-&gt;lastdrop=0;
-			_param-&gt;inframes = 1;
-			_param-&gt;outframes=1;					
-			_param-&gt;first=0;
-			_copy=0;
-			_lastAsked=frame;
-			if(!_in-&gt;getFrameNumberNoAlloc(_inFrame, len,data,flags)) return 0;	
-			return 1;
-		}
-		// Sequential access, we have the previous frame pre-filled		
-		uint8_t frame_ready=0;
-		int off;
-		
-		_lastAsked=frame;
-		while(!frame_ready )
-		{
-			
-			
-			if(!_in-&gt;getFrameNumberNoAlloc(_inFrame, len,_uncompressed,flags))
-			{
-				// be nice and return 1 if it does not seem to stupid
-				if(_param-&gt;inframes*4-_param-&gt;outframes*5 &lt; 30)
-				{
-					_param-&gt;outframes++;
-					printf(&quot;Skew ignored\n&quot;);
-					return 1;
-				}
-				 return 0;
-			}
-		
-			_inFrame++;
-			myparam-&gt;inframes++;
-			off=4*_param-&gt;inframes - 5*(_param-&gt;outframes+1);
-			aprintf(&quot;**** Inframe : %lu / outframe : %lu / Off: %d (in: %lu)\n&quot;,
-				 _param-&gt;inframes,_param-&gt;outframes,off,_inFrame);
-/*				 
-			if(off&gt;11)
-			{
-				_copy=9;
-			}
-			if(_copy)
-			{
-				_copy--;
-				aprintf(&quot;Too much drops!\n&quot;);
-				_param-&gt;outframes++;
-				_param-&gt;lastdrop=0;
-				if(!_copy)
-					copy_image(_lastFrame, _uncompressed, 2);
-				copy_image(data, _uncompressed, 2);
-				
-				return 1;				
-			}				 
-			
-*/			
-			
-			switch (foo(_param, _uncompressed-&gt;data, _lastFrame-&gt;data)) 
-			{
-			case F_DROP:
-				copy_image(_lastFrame, _uncompressed, 2);
-				frame_ready = 0;
-				_param-&gt;lastdrop = 0;
-				aprintf(&quot;MPivtc DROP\n&quot;);				
-				// we are dropping too much frames!
-				if(off&gt;6)
-				{
-					aprintf(&quot;Cancelled dropout!, deinterlacing in place----------\n&quot;);
-					memcpy(data-&gt;data,_lastFrame,(page*3)&gt;&gt;1);
-					frame_ready=1;
-					_param-&gt;outframes++;
-					_param-&gt;dropnext=0;
-					// we deinterlace it in place
-					AVPicture src;
-					uint32_t page=_info.width*_info.height;
-		
-					src.data[0]=data-&gt;data;
-					src.data[1]=data-&gt;data+page;
-					src.data[2]=data-&gt;data+((page*5)&gt;&gt;2);
-  					
-		
-					src.linesize[0]=_info.width;
-					src.linesize[1]=_info.width&gt;&gt;1;
-					src.linesize[2]=_info.width&gt;&gt;1;
-  
-					if (avpicture_deinterlace(&amp;src,&amp;src,
-						PIX_FMT_YUV420P,_info.width,_info.height)&lt;0)
-					{
-						printf(&quot;Error in avpicture deinterlace!\n&quot;);
-						return 0;
-					} 		
-				}
-				
-				break;
-			case F_MERGE:
-				copy_image(_lastFrame, _uncompressed, 0);
-				frame_ready = do_put_image(_lastFrame);
-				if(frame_ready) memcpy(data-&gt;data,_lastFrame-&gt;data,(page*3)&gt;&gt;1);
-				copy_image(_lastFrame, _uncompressed, 1);
-				aprintf(&quot;MPivtc MERGE\n&quot;);
-				//clear(_lastFrame);
-				break;
-			case F_NEXT:
-				copy_image(_lastFrame, _uncompressed, 2);
-				frame_ready = do_put_image(_lastFrame);
-				if(frame_ready) memcpy(data-&gt;data,_lastFrame-&gt;data,(page*3)&gt;&gt;1);
-				aprintf(&quot;MPivtc NEXT\n&quot;);
-				//clear(_lastFrame);
-				break;
-			case F_SHOW:
-				frame_ready = do_put_image(_lastFrame);
-				if(frame_ready) memcpy(data-&gt;data,_lastFrame-&gt;data,(page*3)&gt;&gt;1);
-				copy_image(_lastFrame, _uncompressed, 2);
-				aprintf(&quot;MPivtc OK\n&quot;);
-				//clear(_lastFrame);
-				break;
-			}
-		}
-	if(!frame_ready) return 0;	
-	return 1;
-}
-		
-
-/*
-	Return 1 if ok, 0 if dropped
-*/
-uint8_t AVDMVideoMPDetc::do_put_image(ADMImage *data)
-{
-	int dropflag;
-	int off=0;
-/*
-	switch (_param-&gt;drop &amp;&amp; !_param-&gt;dropnext) 
-	{
-	case 0:
-		dropflag = 0;
-		break;
-	case 1:
-		dropflag = (++_param-&gt;lastdrop &gt;= 5);
-		break;
-	case 2:
-		dropflag = (++_param-&gt;lastdrop &gt;= 5) &amp;&amp; (4*_param-&gt;inframes &lt;= 5*_param-&gt;outframes);
-		break;
-	}
-*/
-	off=4*_param-&gt;inframes - 5*(_param-&gt;outframes+1);
-	aprintf(&quot;Dropnext : %d lastdrop  : %d off : %d \n&quot;,_param-&gt;dropnext,_param-&gt;lastdrop,off);
-		
-	dropflag = ((_param-&gt;dropnext)||(++_param-&gt;lastdrop &gt;= 5)) &amp;&amp; off&lt; 0;
-	
-	if (dropflag) {
-		aprintf(&quot;--&gt;drop! [%d/%d=%g]\n&quot;,
-			_param-&gt;outframes, _param-&gt;inframes, (float)_param-&gt;outframes/_param-&gt;inframes);
-		_param-&gt;lastdrop = 0;
-		return 0;
-	}
-
-	_param-&gt;outframes++;
-	return 1;
-
-
-}
-
-
-
-
-
-
-void *my_memcpy_pic(uint8_t  * dst, uint8_t * src, int bytesPerLine, int height, int dstStride, int srcStride)
-{
-	int i;
-	void *retval=dst;
-
-	for(i=0; i&lt;height; i++)
-	{
-		memcpy(dst, src, bytesPerLine);
-		src+= srcStride;
-		dst+= dstStride;
-	}
-
-	return retval;
-}
-
-unsigned int hash_pic(unsigned char *img, int w, int h, int stride)
-{
-	int step = w*h/1024;
-	unsigned int hash=0;
-	int x=0, y;
-
-	step -= step % 3;
-
-	for (y=0; y&lt;h; y++) {
-		for (; x&lt;w; x+=step) {
-			hash = hash ^ (hash&lt;&lt;4) ^ img[x];
-		}
-		x -= w;
-		img += stride;
-	}
-	
-	return hash;
-}
-#define MAG(a) (((a)^((a)&gt;&gt;31))-((a)&gt;&gt;31))
-#define LOWPASS(s) ((s)[0])
-
-
- void block_diffs_C(struct metrics *m, unsigned char *old, unsigned char *nw, int os, int ns)
-{
-	int x, y, e=0, o=0, s=0, p=0, t=0;
-	unsigned char *oldp, *newp;
-	m-&gt;s = m-&gt;p = m-&gt;t = 0;
-	for (x = 8; x; x--) {
-		oldp = old++;
-		newp = nw++;
-		s = p = t = 0;
-		for (y = 4; y; y--) {
-			e += MAG(newp[0]-oldp[0]);
-			o += MAG(newp[ns]-oldp[os]);
-			s += newp[ns]-newp[0];
-			p += oldp[os]-oldp[0];
-			t += oldp[os]-newp[0];
-			oldp += os&lt;&lt;1;
-			newp += ns&lt;&lt;1;
-		}
-		m-&gt;s += MAG(s);
-		m-&gt;p += MAG(p);
-		m-&gt;t += MAG(t);
-	}
-	m-&gt;e = e;
-	m-&gt;o = o;
-	m-&gt;d = e+o;
-}
-#define MAXUP(a,b) ((a) = ((a)&gt;(b)) ? (a) : (b))
-
-static void diff_planes(struct frameinfo *fi,
-	unsigned char *old, unsigned char *nw, int w, int h, int os, int ns)
-{
-	int x, y;
-	struct metrics l;
-	struct metrics *peak=&amp;fi-&gt;p, *rel=&amp;fi-&gt;r, *mean=&amp;fi-&gt;m;
-	memset(peak, 0, sizeof(struct metrics));
-	memset(rel, 0, sizeof(struct metrics));
-	memset(mean, 0, sizeof(struct metrics));
-	for (y = 0; y &lt; h-7; y += 8) {
-		for (x = 8; x &lt; w-8-7; x += 8) {
-#if 00 //FIXME def USE_MMX	
-	#define block_diffs block_diffs_MMX
-#else
-	#define block_diffs block_diffs_C
-#endif	
-			block_diffs(&amp;l, old+x+y*os, nw+x+y*ns, os, ns);
-			mean-&gt;d += l.d;
-			mean-&gt;e += l.e;
-			mean-&gt;o += l.o;
-			mean-&gt;s += l.s;
-			mean-&gt;p += l.p;
-			mean-&gt;t += l.t;
-			MAXUP(peak-&gt;d, l.d);
-			MAXUP(peak-&gt;e, l.e);
-			MAXUP(peak-&gt;o, l.o);
-			MAXUP(peak-&gt;s, l.s);
-			MAXUP(peak-&gt;p, l.p);
-			MAXUP(peak-&gt;t, l.t);
-			MAXUP(rel-&gt;e, l.e-l.o);
-			MAXUP(rel-&gt;o, l.o-l.e);
-			MAXUP(rel-&gt;s, l.s-l.t);
-			MAXUP(rel-&gt;p, l.p-l.t);
-			MAXUP(rel-&gt;t, l.t-l.p);
-			MAXUP(rel-&gt;d, l.t-l.s); /* hack */
-	
-		}
-	}
-	x = (w/8-2)*(h/8);
-	mean-&gt;d /= x;
-	mean-&gt;e /= x;
-	mean-&gt;o /= x;
-	mean-&gt;s /= x;
-	mean-&gt;p /= x;
-	mean-&gt;t /= x;
-}
-void diff_fields(struct frameinfo *fi, uint8_t  *old, uint8_t  *nw)
-{
-	diff_planes(fi, old, nw,
-		myw, myh, myw, myw);
-}
-
-
-
- void status(struct frameinfo *f)
-{
-	aprintf(&quot;       pd=%d re=%d ro=%d rp=%d rt=%d rs=%d rd=%d pp=%d pt=%d ps=%d\n&quot;,
-		f-&gt;p.d, f-&gt;r.e, f-&gt;r.o, f-&gt;r.p, f-&gt;r.t, f-&gt;r.s, f-&gt;r.d, f-&gt;p.p, f-&gt;p.t, f-&gt;p.s);
-}
-
-
-
-//void copy_image(mp_image_t *dmpi, mp_image_t *mpi, int field)
-void copy_image(ADMImage  *sdest, ADMImage  *ssrc, int field)
-{
-	uint32_t page;
-	page=myw*myh;
-	uint8_t *src,*dest;
-	src=ssrc-&gt;data;
-	dest=sdest-&gt;data;
-	switch (field) {
-	case 0:
-		my_memcpy_pic(dest, src, myw, myh&gt;&gt;1,
-			myw*2, myw*2);
-		//if (mpi-&gt;flags &amp; MP_IMGFLAG_PLANAR) {
-		if(1){
-			src+=page;
-			dest+=page;
-			/*my_memcpy_pic(dmpi-&gt;planes[1], mpi-&gt;planes[1],
-				mpi-&gt;chroma_width, mpi-&gt;chroma_height/2,
-				dmpi-&gt;stride[1]*2, mpi-&gt;stride[1]*2);
-			my_memcpy_pic(dmpi-&gt;planes[2], mpi-&gt;planes[2],
-				mpi-&gt;chroma_width, mpi-&gt;chroma_height/2,
-				dmpi-&gt;stride[2]*2, mpi-&gt;stride[2]*2);*/
-			my_memcpy_pic(dest, src, myw&gt;&gt;1, myh&gt;&gt;2,
-						myw, myw);
-			src+=page&gt;&gt;2;
-			dest+=page&gt;&gt;2;
-			my_memcpy_pic(dest, src, myw&gt;&gt;1, myh&gt;&gt;2,
-					myw, myw);
-		}
-		break;
-	case 1:
-		/*my_memcpy_pic(dmpi-&gt;planes[0]+dmpi-&gt;stride[0],
-			mpi-&gt;planes[0]+mpi-&gt;stride[0], mpi-&gt;w, mpi-&gt;h/2,
-			dmpi-&gt;stride[0]*2, mpi-&gt;stride[0]*2);*/
-		my_memcpy_pic(dest+myw, src+myw, myw, myh&gt;&gt;1,
-			myw*2, myw*2);	
-		//if (mpi-&gt;flags &amp; MP_IMGFLAG_PLANAR) {
-		if(1){/*
-			my_memcpy_pic(dmpi-&gt;planes[1]+dmpi-&gt;stride[1],
-				mpi-&gt;planes[1]+mpi-&gt;stride[1],
-				mpi-&gt;chroma_width, mpi-&gt;chroma_height/2,
-				dmpi-&gt;stride[1]*2, mpi-&gt;stride[1]*2);
-			my_memcpy_pic(dmpi-&gt;planes[2]+dmpi-&gt;stride[2],
-				mpi-&gt;planes[2]+mpi-&gt;stride[2],
-				mpi-&gt;chroma_width, mpi-&gt;chroma_height/2,
-				dmpi-&gt;stride[2]*2, mpi-&gt;stride[2]*2);*/
-			src+=page;
-			dest+=page;
-			/*my_memcpy_pic(dmpi-&gt;planes[1], mpi-&gt;planes[1],
-				mpi-&gt;chroma_width, mpi-&gt;chroma_height/2,
-				dmpi-&gt;stride[1]*2, mpi-&gt;stride[1]*2);
-			my_memcpy_pic(dmpi-&gt;planes[2], mpi-&gt;planes[2],
-				mpi-&gt;chroma_width, mpi-&gt;chroma_height/2,
-				dmpi-&gt;stride[2]*2, mpi-&gt;stride[2]*2);*/
-			my_memcpy_pic(dest+myw/2, src+myw/2, myw&gt;&gt;1, myh&gt;&gt;2,
-					myw, myw);
-			src+=page&gt;&gt;2;
-			dest+=page&gt;&gt;2;
-			my_memcpy_pic(dest+myw/2, src+myw/2, myw&gt;&gt;1, myh&gt;&gt;2,
-					myw, myw);				
-		}
-		break;
-	case 2:
-		/*
-		memcpy_pic(dmpi-&gt;planes[0], mpi-&gt;planes[0], mpi-&gt;w, mpi-&gt;h,
-			dmpi-&gt;stride[0], mpi-&gt;stride[0]);
-		if (mpi-&gt;flags &amp; MP_IMGFLAG_PLANAR) {
-			memcpy_pic(dmpi-&gt;planes[1], mpi-&gt;planes[1],
-				mpi-&gt;chroma_width, mpi-&gt;chroma_height,
-				dmpi-&gt;stride[1], mpi-&gt;stride[1]);
-			memcpy_pic(dmpi-&gt;planes[2], mpi-&gt;planes[2],
-				mpi-&gt;chroma_width, mpi-&gt;chroma_height,
-				dmpi-&gt;stride[2], mpi-&gt;stride[2]);
-		}*/
-		memcpy(dest,src,(page*3)&gt;&gt;1);
-		break;
-	}
-}
-#if 0 // FIXME USE_MMX
- void block_diffs_MMX(struct metrics *m, unsigned char *old, unsigned char *nw, int os, int ns)
-{
-	int i;
-	short out[24]; // output buffer for the partial metrics from the mmx code
-	
-	__asm__ (
-		&quot;movl $4, %%ecx \n\t&quot;
-		&quot;pxor %%mm4, %%mm4 \n\t&quot; // 4 even difference sums
-		&quot;pxor %%mm5, %%mm5 \n\t&quot; // 4 odd difference sums
-		&quot;pxor %%mm7, %%mm7 \n\t&quot; // all zeros
-		
-		&quot;.balign 16 \n\t&quot;
-		&quot;1: \n\t&quot;
-		
-		// Even difference
-		&quot;movq (%%esi), %%mm0 \n\t&quot;
-		&quot;movq (%%esi), %%mm2 \n\t&quot;
-		&quot;addl %%eax, %%esi \n\t&quot;
-		&quot;movq (%%edi), %%mm1 \n\t&quot;
-		&quot;addl %%ebx, %%edi \n\t&quot;
-		&quot;psubusb %%mm1, %%mm2 \n\t&quot;
-		&quot;psubusb %%mm0, %%mm1 \n\t&quot;
-		&quot;movq %%mm2, %%mm0 \n\t&quot;
-		&quot;movq %%mm1, %%mm3 \n\t&quot;
-		&quot;punpcklbw %%mm7, %%mm0 \n\t&quot;
-		&quot;punpcklbw %%mm7, %%mm1 \n\t&quot;
-		&quot;punpckhbw %%mm7, %%mm2 \n\t&quot;
-		&quot;punpckhbw %%mm7, %%mm3 \n\t&quot;
-		&quot;paddw %%mm0, %%mm4 \n\t&quot;
-		&quot;paddw %%mm1, %%mm4 \n\t&quot;
-		&quot;paddw %%mm2, %%mm4 \n\t&quot;
-		&quot;paddw %%mm3, %%mm4 \n\t&quot;
-		
-		// Odd difference
-		&quot;movq (%%esi), %%mm0 \n\t&quot;
-		&quot;movq (%%esi), %%mm2 \n\t&quot;
-		&quot;addl %%eax, %%esi \n\t&quot;
-		&quot;movq (%%edi), %%mm1 \n\t&quot;
-		&quot;addl %%ebx, %%edi \n\t&quot;
-		&quot;psubusb %%mm1, %%mm2 \n\t&quot;
-		&quot;psubusb %%mm0, %%mm1 \n\t&quot;
-		&quot;movq %%mm2, %%mm0 \n\t&quot;
-		&quot;movq %%mm1, %%mm3 \n\t&quot;
-		&quot;punpcklbw %%mm7, %%mm0 \n\t&quot;
-		&quot;punpcklbw %%mm7, %%mm1 \n\t&quot;
-		&quot;punpckhbw %%mm7, %%mm2 \n\t&quot;
-		&quot;punpckhbw %%mm7, %%mm3 \n\t&quot;
-		&quot;paddw %%mm0, %%mm5 \n\t&quot;
-		&quot;paddw %%mm1, %%mm5 \n\t&quot;
-		&quot;paddw %%mm2, %%mm5 \n\t&quot;
-		&quot;paddw %%mm3, %%mm5 \n\t&quot;
-			
-		&quot;decl %%ecx \n\t&quot;
-		&quot;jnz 1b \n\t&quot;
-		&quot;movq %%mm4, (%%edx) \n\t&quot;
-		&quot;movq %%mm5, 8(%%edx) \n\t&quot;
-		: 
-		: &quot;S&quot; (old), &quot;D&quot; (nw), &quot;a&quot; (os), &quot;b&quot; (ns), &quot;d&quot; (out)
-		: &quot;memory&quot;
-		);
-	m-&gt;e = out[0]+out[1]+out[2]+out[3];
-	m-&gt;o = out[4]+out[5]+out[6]+out[7];
-	m-&gt;d = m-&gt;e + m-&gt;o;
-
-	asm (
-		// First loop to measure first four columns
-		&quot;movl $4, %%ecx \n\t&quot;
-		&quot;pxor %%mm4, %%mm4 \n\t&quot; // Past spacial noise
-		&quot;pxor %%mm5, %%mm5 \n\t&quot; // Temporal noise
-		&quot;pxor %%mm6, %%mm6 \n\t&quot; // Current spacial noise
-		
-		&quot;.balign 16 \n\t&quot;
-		&quot;2: \n\t&quot;
-		
-		&quot;movq (%%esi), %%mm0 \n\t&quot;
-		&quot;movq (%%esi,%%eax), %%mm1 \n\t&quot;
-		&quot;addl %%eax, %%esi \n\t&quot;
-		&quot;addl %%eax, %%esi \n\t&quot;
-		&quot;movq (%%edi), %%mm2 \n\t&quot;
-		&quot;movq (%%edi,%%ebx), %%mm3 \n\t&quot;
-		&quot;addl %%ebx, %%edi \n\t&quot;
-		&quot;addl %%ebx, %%edi \n\t&quot;
-		&quot;punpcklbw %%mm7, %%mm0 \n\t&quot;
-		&quot;punpcklbw %%mm7, %%mm1 \n\t&quot;
-		&quot;punpcklbw %%mm7, %%mm2 \n\t&quot;
-		&quot;punpcklbw %%mm7, %%mm3 \n\t&quot;
-		&quot;paddw %%mm1, %%mm4 \n\t&quot;
-		&quot;paddw %%mm1, %%mm5 \n\t&quot;
-		&quot;paddw %%mm3, %%mm6 \n\t&quot;
-		&quot;psubw %%mm0, %%mm4 \n\t&quot;
-		&quot;psubw %%mm2, %%mm5 \n\t&quot;
-		&quot;psubw %%mm2, %%mm6 \n\t&quot;
-		
-		&quot;decl %%ecx \n\t&quot;
-		&quot;jnz 2b \n\t&quot;
-		
-		&quot;movq %%mm0, %%mm1 \n\t&quot;
-		&quot;movq %%mm0, %%mm2 \n\t&quot;
-		&quot;movq %%mm0, %%mm3 \n\t&quot;
-		&quot;pcmpgtw %%mm4, %%mm1 \n\t&quot;
-		&quot;pcmpgtw %%mm5, %%mm2 \n\t&quot;
-		&quot;pcmpgtw %%mm6, %%mm3 \n\t&quot;
-		&quot;pxor %%mm1, %%mm4 \n\t&quot;
-		&quot;pxor %%mm2, %%mm5 \n\t&quot;
-		&quot;pxor %%mm3, %%mm6 \n\t&quot;
-		&quot;psubw %%mm1, %%mm4 \n\t&quot;
-		&quot;psubw %%mm2, %%mm5 \n\t&quot;
-		&quot;psubw %%mm3, %%mm6 \n\t&quot;
-		&quot;movq %%mm4, (%%edx) \n\t&quot;
-		&quot;movq %%mm5, 16(%%edx) \n\t&quot;
-		&quot;movq %%mm6, 32(%%edx) \n\t&quot;
-
-		&quot;movl %%eax, %%ecx \n\t&quot;
-		&quot;shll $3, %%ecx \n\t&quot;
-		&quot;subl %%ecx, %%esi \n\t&quot;
-		&quot;movl %%ebx, %%ecx \n\t&quot;
-		&quot;shll $3, %%ecx \n\t&quot;
-		&quot;subl %%ecx, %%edi \n\t&quot;
-
-		// Second loop for the last four columns
-		&quot;movl $4, %%ecx \n\t&quot;
-		&quot;pxor %%mm4, %%mm4 \n\t&quot;
-		&quot;pxor %%mm5, %%mm5 \n\t&quot;
-		&quot;pxor %%mm6, %%mm6 \n\t&quot;
-		
-		&quot;.balign 16 \n\t&quot;
-		&quot;3: \n\t&quot;
-		
-		&quot;movq (%%esi), %%mm0 \n\t&quot;
-		&quot;movq (%%esi,%%eax), %%mm1 \n\t&quot;
-		&quot;addl %%eax, %%esi \n\t&quot;
-		&quot;addl %%eax, %%esi \n\t&quot;
-		&quot;movq (%%edi), %%mm2 \n\t&quot;
-		&quot;movq (%%edi,%%ebx), %%mm3 \n\t&quot;
-		&quot;addl %%ebx, %%edi \n\t&quot;
-		&quot;addl %%ebx, %%edi \n\t&quot;
-		&quot;punpckhbw %%mm7, %%mm0 \n\t&quot;
-		&quot;punpckhbw %%mm7, %%mm1 \n\t&quot;
-		&quot;punpckhbw %%mm7, %%mm2 \n\t&quot;
-		&quot;punpckhbw %%mm7, %%mm3 \n\t&quot;
-		&quot;paddw %%mm1, %%mm4 \n\t&quot;
-		&quot;paddw %%mm1, %%mm5 \n\t&quot;
-		&quot;paddw %%mm3, %%mm6 \n\t&quot;
-		&quot;psubw %%mm0, %%mm4 \n\t&quot;
-		&quot;psubw %%mm2, %%mm5 \n\t&quot;
-		&quot;psubw %%mm2, %%mm6 \n\t&quot;
-		
-		&quot;decl %%ecx \n\t&quot;
-		&quot;jnz 3b \n\t&quot;
-		
-		&quot;movq %%mm0, %%mm1 \n\t&quot;
-		&quot;movq %%mm0, %%mm2 \n\t&quot;
-		&quot;movq %%mm0, %%mm3 \n\t&quot;
-		&quot;pcmpgtw %%mm4, %%mm1 \n\t&quot;
-		&quot;pcmpgtw %%mm5, %%mm2 \n\t&quot;
-		&quot;pcmpgtw %%mm6, %%mm3 \n\t&quot;
-		&quot;pxor %%mm1, %%mm4 \n\t&quot;
-		&quot;pxor %%mm2, %%mm5 \n\t&quot;
-		&quot;pxor %%mm3, %%mm6 \n\t&quot;
-		&quot;psubw %%mm1, %%mm4 \n\t&quot;
-		&quot;psubw %%mm2, %%mm5 \n\t&quot;
-		&quot;psubw %%mm3, %%mm6 \n\t&quot;
-		&quot;movq %%mm4, 8(%%edx) \n\t&quot;
-		&quot;movq %%mm5, 24(%%edx) \n\t&quot;
-		&quot;movq %%mm6, 40(%%edx) \n\t&quot;
-
-		&quot;emms \n\t&quot;
-		: 
-		: &quot;S&quot; (old), &quot;D&quot; (nw), &quot;a&quot; (os), &quot;b&quot; (ns), &quot;d&quot; (out)
-		: &quot;memory&quot;
-		);
-	m-&gt;p = m-&gt;t = m-&gt;s = 0;
-	for (i=0; i&lt;8; i++) {
-		m-&gt;p += out[i];
-		m-&gt;t += out[8+i];
-		m-&gt;s += out[16+i];
-	}
-	//printf(&quot;e=%d o=%d d=%d p=%d t=%d s=%d\n&quot;, m-&gt;e, m-&gt;o, m-&gt;d, m-&gt;p, m-&gt;t, m-&gt;s);
-}
-#endif
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/CMakeLists.txt	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/CMakeLists.txt	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,12 +0,0 @@
-SET(ADM_videoFilter_SRCS 
-#
-#	ADM_vidDvbSub.cpp
-	#ADM_vidVobsub.cpp
-	#ADM_vidVobSubRender.cpp
-	#ADM_vobsubinfo.cpp
-	ADM_vidComputeAverage.cpp
-	ADM_vidThreshold.cpp
-	ADM_vidNumber.cpp)
-
-ADD_LIBRARY(ADM_videoFilter6 STATIC ${ADM_videoFilter_SRCS})
-

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2009-10-02 05:22:11 UTC (rev 5365)
@@ -4,7 +4,7 @@
 ADD_SUBDIRECTORY(ADM_codecs)
 ADD_SUBDIRECTORY(ADM_commonUI)
 ADD_SUBDIRECTORY(ADM_editor)
-ADD_SUBDIRECTORY(ADM_filter)
+#ADD_SUBDIRECTORY(ADM_filter)
 #ADD_SUBDIRECTORY(ADM_infoExtractor)
 ADD_SUBDIRECTORY(ADM_libraries)
 #ADD_SUBDIRECTORY(ADM_mpegIndexer)
@@ -17,6 +17,6 @@
 ADD_SUBDIRECTORY(ADM_script)
 ADD_SUBDIRECTORY(ADM_toolkit)
 #ADD_SUBDIRECTORY(ADM_video)
-ADD_SUBDIRECTORY(ADM_videoFilter)
+#ADD_SUBDIRECTORY(ADM_videoFilter)
 ADD_SUBDIRECTORY(ADM_videoEncoder)
 ADD_SUBDIRECTORY(ADM_videoFilter2)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_autodrive.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_autodrive.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_autodrive.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -32,7 +32,7 @@
 #include &quot;gui_action.hxx&quot;
 
 //#include &quot;ADM_encoder/adm_encConfig.h&quot;
-#include &quot;ADM_filter/vidVCD.h&quot;
+//#include &quot;ADM_filter/vidVCD.h&quot;
 //#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
 
 //extern void setVideoEncoderSettings (COMPRESSION_MODE mode, uint32_t param,     uint32_t extraConf, uint8_t * extraData);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -223,7 +223,7 @@
     video_body = new ADM_Composer;
 
 #ifdef HAVE_ENCODER
-     registerVideoFilters();
+//     registerVideoFilters();
 #endif
     ADM_lavFormatInit();
 	//***************Plugins *********************

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-10-02 05:22:11 UTC (rev 5365)
@@ -90,15 +90,16 @@
 ADM_commonUI6
 )
 SET(commonLibs2
-ADM_filter6 
+#ADM_filter6 
 ADM_osSupport6 
 ADM_requant6 
 ADM_script6 
 ADM_toolkit6
 ADM_videoEncoder6 
+ADM_internalVideoFilter6
+
 #ADM_video6 
-ADM_videoFilter6 
-ADM_internalVideoFilter6
+#ADM_videoFilter6 
 )
 
 # END

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_vobsub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_vobsub.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_vobsub.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -21,7 +21,7 @@
 
 #include &quot;DIA_coreToolkit.h&quot;
 #include &quot;DIA_fileSel.h&quot;
-
+#if 0
 #define CHECK_GET(x,y) {*y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
 #define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),*y);}   
 #include &quot;ADM_videoFilter.h&quot;
@@ -315,4 +315,4 @@
 
   return dialog1;
 }
-
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -18,7 +18,7 @@
 #include &quot;ADM_videoFilter_internal.h&quot;
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 #include &quot;avi_vars.h&quot;
-#include &quot;ADM_filter/vidVCD.h&quot;
+//#include &quot;ADM_filter/vidVCD.h&quot;
 //___________________________________________
 typedef enum 
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_ocr/adm_ocr.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_ocr/adm_ocr.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_ocr/adm_ocr.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -37,9 +37,9 @@
 #include &quot;ADM_videoFilter.h&quot;
 #include &quot;DIA_fileSel.h&quot;
 
-
-#include &quot;ADM_videoFilter/ADM_vobsubinfo.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidVobSub.h&quot;
+#if 0
+//#include &quot;ADM_videoFilter/ADM_vobsubinfo.h&quot;
+//#include &quot;ADM_videoFilter/ADM_vidVobSub.h&quot;
 #include &quot;ADM_ocr/ADM_leftturn.h&quot;
 #include &quot;DIA_enter.h&quot;
 
@@ -367,4 +367,5 @@
 	    return (void *)dialog;
 	
 }
+#endif
 //;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002575.html">[Avidemux-svn-commit] r5364 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_editor common/ADM_filter common/ADM_script	common/ADM_toolkit common/ADM_video common/ADM_videoFilter2	gtk/ADM_userInterfaces/ADM_dialog gtk/ADM_userInterfaces/ADM_filters
</A></li>
	<LI>Next message: <A HREF="002577.html">[Avidemux-svn-commit] r5366 -	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2576">[ date ]</a>
              <a href="thread.html#2576">[ thread ]</a>
              <a href="subject.html#2576">[ subject ]</a>
              <a href="author.html#2576">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
