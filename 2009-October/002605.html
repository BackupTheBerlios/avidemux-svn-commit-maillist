<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5394 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-October/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5394%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor&In-Reply-To=%3C200910210514.n9L5ETRe013582%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002604.html">
   <LINK REL="Next"  HREF="002606.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5394 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5394%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor&In-Reply-To=%3C200910210514.n9L5ETRe013582%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5394 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor">mean at mail.berlios.de
       </A><BR>
    <I>Wed Oct 21 07:14:29 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002604.html">[Avidemux-svn-commit] r5393 - in	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
</A></li>
        <LI>Next message: <A HREF="002606.html">[Avidemux-svn-commit] r5395 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2605">[ date ]</a>
              <a href="thread.html#2605">[ thread ]</a>
              <a href="subject.html#2605">[ subject ]</a>
              <a href="author.html#2605">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-10-21 07:14:27 +0200 (Wed, 21 Oct 2009)
New Revision: 5394

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp.orig
Log:
[editor] remove unused file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp.orig
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp.orig	2009-10-20 17:17:18 UTC (rev 5393)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp.orig	2009-10-21 05:14:27 UTC (rev 5394)
@@ -1,1591 +0,0 @@
-/***************************************************************************
-                          ADM_edit.cpp  -  description
-                             -------------------
-    begin                : Thu Feb 28 2002
-    copyright            : (C) 2002/2008 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;math.h&gt;
-#include &lt;string.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;errno.h&gt;
-
-#if defined(__MINGW32__) || defined(ADM_BSD_FAMILY)
-#include &lt;sys/stat.h&gt;
-#endif
-
-#include &quot;ADM_assert.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_inputs/ADM_inpics/ADM_pics.h&quot;
-#include &quot;ADM_inputs/ADM_nuv/ADM_nuv.h&quot;
-#include &quot;ADM_inputs/ADM_h263/ADM_h263.h&quot;
-//#include &quot;ADM_3gp/ADM_3gp.h&quot;
-#include &quot;ADM_inputs/ADM_mp4/ADM_mp4.h&quot;
-#include &quot;ADM_inputs/ADM_openDML/ADM_openDML.h&quot;
-#include &quot;ADM_inputs/ADM_avsproxy/ADM_avsproxy.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-//#include &quot;ADM_dialog/DIA_working.h&quot;
-#include &quot;ADM_inputs/ADM_ogm/ADM_ogm.h&quot;
-#include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_video.h&quot;
-#include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_identify.h&quot;
-#include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_probe.h&quot;
-#include &quot;ADM_inputs/ADM_matroska/ADM_mkv.h&quot;
-#include &quot;ADM_inputs/ADM_flv/ADM_flv.h&quot;
-#include &quot;ADM_inputs/ADM_amv/ADM_amv.h&quot;
-#include &quot;ADM_inputs/ADM_asf/ADM_asf.h&quot;
-#include &quot;prefs.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_EDITOR
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#ifdef USE_DIVX
-	#include &quot;ADM_codecs/ADM_divx4.h&quot;
-#endif
-#include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h&quot;
-#include &quot;ADM_outputfmt.h&quot;
-//#include &quot;ADM_gui2/GUI_ui.h&quot;
-int DIA_mpegIndexer (char **mpegFile, char **indexFile, int *aid,
-		     int already = 0);
-void DIA_indexerPrefill(char *name);
-extern uint8_t indexMpeg (char *mpeg, char *file, uint8_t aid);
-
-extern uint8_t loadVideoCodecConf( const char *name);
-extern uint8_t parseScript(char *name);
-uint8_t UI_SetCurrentFormat( ADM_OUT_FORMAT fmt );
-const char *VBR_MSG = QT_TR_NOOP(&quot;Avidemux detected VBR MP3 audio in this file. For keeping audio/video in sync, time map is needed. Build it now?\n\nYou can do it later with \&quot;Audio -&gt; Build VBR Time Map\&quot;.&quot;);
-//
-//
-
-#define TEST_MPEG2DEC
-
-ADM_Composer::ADM_Composer (void) : ADM_audioStream(NULL,NULL)
-{
-uint32_t type,value;
-   audioBufferStart=0;
-   audioBufferEnd=0;
-  _nb_segment = 0;
-  _nb_video = 0;
-  _total_frames = 0;
-  _audioseg = 0;
-  _audiooffset = 0;
-  _audioSample=0;
-  _lastseg = 99;
-  _lastframe = 99;
-  _nb_clipboard=0;
-  _haveMarkers=0; // only edl have markers
-  // Initialize a default postprocessing (dummy)
-  initPostProc(&amp;_pp,16,16);
-  if(!prefs-&gt;get(DEFAULT_POSTPROC_TYPE,&amp;type)) type=3;
-  if(!prefs-&gt;get(DEFAULT_POSTPROC_VALUE,&amp;value)) value=3;
-
-  _pp.postProcType=type;
-  _pp.postProcStrength=value;
-  _pp.swapuv=0;
-  _pp.forcedQuant=0;
-  updatePostProc(&amp;_pp);
-  _imageBuffer=NULL;    
-  _internalFlags=0;
-  // Start with a clean base
-  memset (_videos, 0, sizeof (_videos));
-  max_seg = MAX_SEG;
-  _segments = new _SEGMENT[max_seg];
-  memset (_segments, 0, sizeof (_segments));
-  _scratch=NULL;
-  
-}
-/**
-	Remap 1:1 video to segments
-
-*/
-uint8_t ADM_Composer::resetSeg( void )
-{
-	_total_frames=0;
-	for(uint32_t i=0;i&lt;_nb_video;i++)
-	{
-		_segments[i]._reference = i;
-  		_segments[i]._audio_size = _videos[i]._audio_size;
-  		_segments[i]._audio_start = 0;
-  		_segments[i]._start_frame = 0;
-		_segments[i]._audio_duration = 0;		
-		_segments[i]._nb_frames   =   _videos[i]._nb_video_frames ;
-		_total_frames+=_segments[i]._nb_frames  ;
-		updateAudioTrack (i);
-	}
-
-  	_nb_segment=_nb_video;
-  	computeTotalFrames();
-	dumpSeg();
-	return 1;
-}
-/**
-	Return extra Header info present in avi chunk that are needed to initialize
-	the video codec
-	It is assumed that there is only one file or can share the same init data
-	(huffyuv for example)
-*/
-uint8_t ADM_Composer::getExtraHeaderData (uint32_t * len, uint8_t ** data)
-{
-  return _videos[0]._aviheader-&gt;getExtraHeaderData (len, data);
-
-}
-
-
-/**
-	Purge all segments
-*/
-uint8_t ADM_Composer::deleteAllSegments (void)
-{
-
-
-  memset (_segments, 0, sizeof (_segments));
-  _nb_segment = 0;
-  _total_frames=computeTotalFrames();
-  return 1;
-
-}
-
-/**
-	\fn Purge all videos
-    \brief delete datas associated with all video
-*/
-void
-ADM_Composer::deleteAllVideos (void)
-{
-
-  for (uint32_t vid = 0; vid &lt; _nb_video; vid++)
-    {
-
-      // if there is a video decoder...
-      if (_videos[vid].decoder)
-            delete _videos[vid].decoder;
-      if(_videos[vid].color)
-            delete _videos[vid].color;
-      // prevent from crashing
-      _videos[vid]._aviheader-&gt;close ();
-      delete _videos[vid]._aviheader;
-      if(_videos[vid]._videoCache)
-      	delete  _videos[vid]._videoCache;
-      _videos[vid]._videoCache=NULL;
-     // Delete audio codec too
-     // audioStream will be deleted by the demuxer
-      if(_videos[vid]._audioCodec)
-        delete _videos[vid]._audioCodec;
-      _videos[vid]._audioCodec=NULL;
-    }
-
-  memset (_videos, 0, sizeof (_videos));
-  
-  
-  if(_imageBuffer)
-  	delete _imageBuffer;
-  _imageBuffer=NULL;
-
-}
-
-ADM_Composer::~ADM_Composer ()
-{
-	deleteAllSegments();
-	deleteAllVideos();
-	deletePostProc(&amp;_pp);
-
-	if(_segments)
-	{
-		delete[] _segments;
-		_segments=NULL;
-	}
-	if(_scratch)
-	{
-		delete _scratch;
-		_scratch=NULL;
-	}
-}
-
-/*
-   			Return Magic : 4*4 bytes first
-
-*/
-
-/**
-    \fn addFile
-    \brief	Load or append a file.	The file type is determined automatically and the ad-hoc video decoder is spawned
-    
-    @param name: filename
-    @param mode: 0 open, 1 append
-    @param forcedType : if !=Unknown_FileType, it enables to force the file type
-
-    @return 1 on success, 0 on failure
-        
-
-*/
-uint8_t ADM_Composer::addFile (const char *name, uint8_t mode,fileType forcedType)
-{
-  uint8_t    ret =    0;
-  aviInfo    info;
-  WAVHeader *    _wavinfo;
-//  aviHeader *    tmp;
-  fileType    type =    forcedType;
-
-UNUSED_ARG(mode);
-	_haveMarkers=0; // by default no markers are present
-  ADM_assert (_nb_segment &lt; max_seg);
-  ADM_assert (_nb_video &lt; MAX_VIDEO);
-
-  // Autodetect file type ?
-  if(Unknown_FileType==type)
-  {
-      if (!identify (name, &amp;type))
-        return 0;
-  }
-
-
-#define OPEN_AS(x,y) case x:\
-						_videos[_nb_video]._aviheader=new y; \
-						 ret = _videos[_nb_video]._aviheader-&gt;open(name); \
-						break;
-#if 0 // BAZOOKA
-  switch (type)
-    {
-      case VCodec_FileType:
-      		loadVideoCodecConf(name);      		
-		return ADM_IGN; // we do it but it wil fail, no problem with that
-      		break;
-      OPEN_AS (Mp4_FileType, mp4Header);
-      OPEN_AS (H263_FileType, h263Header);
-      
-      case ASF_FileType:
-              _videos[_nb_video]._aviheader=new asfHeader; 
-              ret = _videos[_nb_video]._aviheader-&gt;open(name); 
-              if(!ret)
-              {
-                delete _videos[_nb_video]._aviheader;
-                printf(&quot;Trying mpeg\n&quot;); 
-                goto thisIsMpeg; 
-              }
-              break;
-      OPEN_AS (NewMpeg_FileType,dmxHeader);
-      // For AVI we first try top open it as openDML
-      case AVI_FileType:
-      			_videos[_nb_video]._aviheader=new OpenDMLHeader; 
-			 ret = _videos[_nb_video]._aviheader-&gt;open(name); 			
-			break;
-      
-    case Nuppel_FileType:
-	{ // look if the idx exists
-	  char *tmpname = (char*)ADM_alloc(strlen(name)+strlen(&quot;.idx&quot;)+1);
-		ADM_assert(tmpname);
-		sprintf(tmpname,&quot;%s.idx&quot;,name);
-		if(addFile(tmpname))
-		{
-			return 1; // Memleak ?
-		}
-		ADM_dealloc(tmpname);
-		// open .nuv file
-		_videos[_nb_video]._aviheader=new nuvHeader;
-		ret = _videos[_nb_video]._aviheader-&gt;open(name);
-		// we store the native .nuv file in the edl
-		// the next load of the edl will open .idx instead
-		break;
-	}
-      OPEN_AS (BMP_FileType, picHeader);
-      OPEN_AS (Matroska_FileType, mkvHeader);
-      OPEN_AS (FLV_FileType, flvHeader);
-      OPEN_AS (AvsProxy_FileType, avsHeader);
-      OPEN_AS (_3GPP_FileType, MP4Header);
-      OPEN_AS (Ogg_FileType, oggHeader);
-      OPEN_AS (AMV_FileType, amvHeader);
-
-    case Mpeg_FileType:
-thisIsMpeg:
-    	// look if the idx exists
-	char tmpname[256];
-	ADM_assert(strlen(name)+5&lt;256);
-	strcpy(tmpname,name);
-	strcat(tmpname,&quot;.idx&quot;);
-        if(ADM_fileExist(tmpname))
-        {
-	       return addFile(tmpname);
-        }
-	/* check for &quot;Read-only file system&quot; */
-	{
-                int fd = open(tmpname,O_CREAT|O_EXCL|O_WRONLY,S_IRUSR|S_IWUSR);
-                if( fd &gt;= 0 )
-                {
-                    close(fd);
-                    unlink(tmpname);
-                    printf(&quot;Filesystem is writable\n&quot;);
-		}else if( errno == EROFS ){
-		  char *tmpdir = getenv(&quot;TMPDIR&quot;);
-#ifdef __WIN32
-                        printf(&quot;Filesystem is not writable, looking for somewhere else\n&quot;);
-			if( !tmpdir )
-				tmpdir = &quot;c:&quot;;
-			snprintf(tmpname,256,&quot;%s%s.idx&quot;,tmpdir,strrchr(name,'\\'));
-#else
-			if( !tmpdir )
-				tmpdir = &quot;/tmp&quot;;
-			snprintf(tmpname,256,&quot;%s%s.idx&quot;,tmpdir,strrchr(name,'/'));
-#endif
-			tmpname[255] = 0;
-                        printf(&quot;Storing index in %s\n&quot;,tmpname);
-                    if(ADM_fileExist(tmpname))
-                    {
-                        printf(&quot;Index present, loading it\n&quot;);
-                        return addFile(tmpname);
-                    }
-                }
-        }
-        if(tryIndexing(name,tmpname))
-        {
-                return addFile (tmpname);
-        }
-        return 0;
-      break;
-	case WorkBench_FileType:
-
-  		return loadWorbench(name);
-#if 0
-        case Script_FileType:
-                return parseScript(name);
-#endif
-	case ECMAScript_FileType:
-                printf(&quot;****** This is an ecmascript, run it with avidemux2 --run yourscript *******\n&quot;);
-                printf(&quot;****** This is an ecmascript, run it with avidemux2 --run yourscript *******\n&quot;);
-                printf(&quot;****** This is an ecmascript, run it with avidemux2 --run yourscript *******\n&quot;);
-                return 0;
-		
-                
-    default:
-      if (type == Unknown_FileType)
-	{
-	  printf (&quot;\n not identified ...\n&quot;);
-	}
-      else
-        GUI_Error_HIG(QT_TR_NOOP(&quot;File type identified but no loader support detected...&quot;),
-                      QT_TR_NOOP(&quot;May be related to an old index file.&quot;));
-      return 0;
-    }
-#else // BAZOOKA
-switch (type)
-    {
-        case AVI_FileType:
-            _videos[_nb_video]._aviheader=new OpenDMLHeader; 
-            ret = _videos[_nb_video]._aviheader-&gt;open(name); 			
-            break;
-        OPEN_AS (NewMpeg_FileType,dmxHeader);
-         
-
-    }
-#endif // BAZOOKA
-   // check opening was successful
-   if (ret == 0) {
-     char str[512+1];
-     snprintf(str,512,QT_TR_NOOP(&quot;Attempt to open %s failed!&quot;), name);
-      str[512] = '\0';
-      GUI_Error_HIG(str,NULL);
-      delete _videos[_nb_video]._aviheader;
-      return 0;
-   }
-
-   /* check for resolution */
-   if( _nb_video ){
-      /* append operation */
-      aviInfo info0, infox;
-      _videos[   0     ]._aviheader-&gt;getVideoInfo (&amp;info0);
-      _videos[_nb_video]._aviheader-&gt;getVideoInfo (&amp;infox);
-      if( info0.width != infox.width || info0.height != infox.height ){
-        char str[512+1];
-         str[0] = '\0';
-         if( info0.width != infox.width )
-            strcpy(str,&quot;width&quot;);
-         if( info0.height != infox.height )
-            snprintf(str+strlen(str),512-strlen(str),
-              &quot;%sheight%sdifferent between first and this video stream&quot;,
-                 (strlen(str)?&quot; and &quot;:&quot;&quot;),
-                 (strlen(str)?&quot; are &quot;:&quot; is &quot;) );
-         str[512] = '\0';
-         GUI_Error_HIG(str,QT_TR_NOOP(&quot;You cannot mix different video dimensions yet. Using the partial video filter later, will not work around this problem. The workaround is:\n1.) \&quot;resize\&quot; / \&quot;add border\&quot; / \&quot;crop\&quot; each stream to the same resolution\n2.) concatinate them together&quot;));
-         delete _videos[_nb_video]._aviheader;
-         return 0;
-      }
-   }
- 
-  // else update info
-  _videos[_nb_video]._aviheader-&gt;getVideoInfo (&amp;info);
-  _videos[_nb_video]._aviheader-&gt;setMyName (name);
-  
-  // Printf some info about extradata
-  {
-    uint32_t l=0;
-    uint8_t *d=NULL;
-    _videos[_nb_video]._aviheader-&gt;getExtraHeaderData(&amp;l,&amp;d);
-    if(l &amp;&amp; d)
-    {
-        printf(&quot;The video codec has some extradata (%d bytes)\n&quot;,l);
-        mixDump(d,l);
-        printf(&quot;\n&quot;);
-    }
-  }
-  // 1st if it is our first video we update postproc
- if(!_nb_video)
- {
-        uint32_t type,value;
-
-        if(!prefs-&gt;get(DEFAULT_POSTPROC_TYPE,&amp;type)) type=3;
-        if(!prefs-&gt;get(DEFAULT_POSTPROC_VALUE,&amp;value)) value=3; 	
-
-	deletePostProc(&amp;_pp );
- 	initPostProc(&amp;_pp,info.width,info.height);
-	_pp.postProcType=type;
-	_pp.postProcStrength=value;
-	_pp.forcedQuant=0;
-	updatePostProc(&amp;_pp);
-
-	if(_imageBuffer) delete _imageBuffer;
-	_imageBuffer=new ADMImage(info.width,info.height);
- 	_imageBuffer-&gt;_qSize= ((info.width+15)&gt;&gt;4)*((info.height+15)&gt;&gt;4);
-	_imageBuffer-&gt;quant=new uint8_t[_imageBuffer-&gt;_qSize];
-	_imageBuffer-&gt;_qStride=(info.width+15)&gt;&gt;4;
- }
-    
- 
-//    fourCC::print( info.fcc );
-  _total_frames += info.nb_frames;
-  _videos[_nb_video]._nb_video_frames = info.nb_frames;
-
-
-  // Update audio infos
-  // an spawn the appropriate decoder
-  //_________________________
-  _wavinfo = _videos[_nb_video]._aviheader-&gt;getAudioInfo ();	//wavinfo); // will be null if no audio
-  if (!_wavinfo)
-    {
-      printf (&quot;\n *** NO AUDIO ***\n&quot;);
-      _videos[_nb_video]._audiostream = NULL;
-      _videos[_nb_video]._audioCodec=NULL;
-    }
-  else
-    {
-      float duration;
-      uint32_t extraLen;
-      uint8_t  *extraData;
-      _videos[_nb_video]._aviheader-&gt;getAudioStream (&amp;_videos[_nb_video]. _audiostream);
-
-      ADM_audioStream *stream=_videos[_nb_video]. _audiostream;
-      stream-&gt;getExtraData(&amp;extraLen,&amp;extraData);
-      duration=stream-&gt;getDurationInUs();
-      duration*=stream-&gt;getInfo()-&gt;frequency;
-      duration/=1000*1000.; // Us -&gt; seconds
-  	  _videos[_nb_video]._audio_duration=(uint64_t)floor(duration);
-      _videos[_nb_video]._audioCodec=getAudioCodec(_wavinfo-&gt;encoding,_wavinfo,extraLen,extraData);
-      printf(&quot;[Editor] Duration in seconds: %&quot;LLU&quot;, in samples: %&quot;LLU&quot;\n&quot;,_videos[_nb_video]._audio_duration/_wavinfo-&gt;frequency,_videos[_nb_video]._audio_duration);
-    }
-
-  printf (&quot;\n Decoder FCC: &quot;);
-  fourCC::print (info.fcc);
-  // ugly hack
-  if (info.fps1000 &gt; 2000 * 1000)
-    {
-      printf (&quot; FPS too high, switching to 25 fps hardcoded\n&quot;);
-      info.fps1000 = 25 * 1000;
-      updateVideoInfo (&amp;info);
-    }
-  uint32_t    	l;
-  uint8_t 	*d;
-  _videos[_nb_video]._aviheader-&gt;getExtraHeaderData (&amp;l, &amp;d);
-  _videos[_nb_video].decoder = getDecoder (info.fcc,  info.width, info.height, l, d,info.bpp);
-
-  _videos[_nb_video]._videoCache   =   new EditorCache(10,info.width,info.height) ;
-  //
-  //  And automatically create the segment
-  //
-  _segments[_nb_segment]._reference = _nb_video;
-  _segments[_nb_segment]._audio_size = _videos[_nb_video]._audio_size;
-  _segments[_nb_segment]._audio_duration =_videos[_nb_video]._audio_duration;
-  _segments[_nb_segment]._audio_start = 0;
-  _segments[_nb_segment]._start_frame = 0;
-  _segments[_nb_segment]._nb_frames   =   _videos[_nb_video]._nb_video_frames ;
-
-  _videos[_nb_video]._isAudioVbr=0;
-//****************************
-   
-
-  // next one please
-        if(_wavinfo)
-        if(_wavinfo-&gt;encoding==WAV_MP3 &amp;&amp; _wavinfo-&gt;blockalign==1152)
-        {
-          uint32_t autovbr=0;
-          prefs-&gt;get(FEATURE_AUTO_BUILDMAP,&amp;autovbr);
-          if(autovbr || GUI_Confirmation_HIG(QT_TR_NOOP(&quot;Build Time Map&quot;),QT_TR_NOOP( &quot;Build VBR time map?&quot;), VBR_MSG))
-                {
-               // _videos[_nb_video]._isAudioVbr=_videos[_nb_video]._audiostream-&gt;buildAudioTimeLine ();
-                }
-        }
-
-	_nb_video++;
-	_nb_segment++;
-
-//______________________________________
-// 1-  check for B _ frame  existence
-// 2- check  for consistency with reported flags
-//______________________________________
-	uint8_t count=0;
-TryAgain:	
-	_VIDEOS 	*vid;
-	uint32_t err=0;
-
-		vid= &amp;(_videos[_nb_video-1]);
-		vid-&gt;_reorderReady=0;
-                vid-&gt;_unpackReady=0;
-		// we only try if we got everything needed...
-		if(!vid-&gt;decoder)
-		{
-			printf(&quot;\n no decoder to check for B- frame\n&quot;);
-			return 1;
-		}
-		if(!vid-&gt;decoder-&gt;bFramePossible())
-		{
-			printf(&quot;\n no  B- frame with that codec \n&quot;);
-			return 1;
-		}
-                if(isH264Compatible(info.fcc))
-                {
-                  if(getEnv(ENV_EDITOR_X264) || GUI_Confirmation_HIG(QT_TR_NOOP(&quot;Use safe mode&quot;),QT_TR_NOOP(&quot;H.264 detected&quot;),QT_TR_NOOP(&quot;If the file is using B-frames as reference it can lead to a crash or stuttering.\nAvidemux can use another mode which is safe but YOU WILL LOSE FRAME ACCURACY.\nDo you want to use that mode?&quot;)))
-                    {
-                              printf(&quot;Switching to non low delay codec\n&quot;);
-                              _videos[_nb_video-1].decoder = getDecoderH264noLogic (info.fcc,  info.width, info.height, l, d);
-                              return 1;
-                    }
-
-
-                }
-		printf(&quot;\n checking for B-Frames...\n&quot;);
-		if( vid-&gt;_nb_video_frames &gt; 12)
-		{
-				uint8_t 		*bufferin;
-				uint32_t 		len,flags;
-				uint8_t 		bframe=0, bconsistency=1;
-				uint32_t		scanned;
-                                ADMImage                *buffer=NULL;
-
-				if(vid-&gt;_nb_video_frames &gt; (info.fps1000 * 5) / 1000)
-					scanned = (info.fps1000 * 5) / 1000;
-				else				scanned=vid-&gt;_nb_video_frames;
-
-				printf(&quot; scanning %lu frames\n&quot;, scanned);
-				
-				bufferin=new uint8_t [info.width* info.height*2];
-                                if(vid-&gt;decoder-&gt;dontcopy())
-                                        buffer=new ADMImage(info.width,info.height,1);
-                                else
-				        buffer=new ADMImage(info.width,info.height);
-
-                                ADMCompressedImage img;
-                                img.data=bufferin;
-				for(uint32_t i=0;i&lt;scanned;i++)  //10
-				{
-					flags=0;
-  					vid-&gt;_aviheader-&gt;getFrameNoAlloc (i,&amp;img);
-                                        if(!img.dataLength) continue;
-					if(!vid-&gt;decoder-&gt;uncompress( &amp;img,buffer ))
-					{
-						err++;
-						printf(&quot;\n ***oops***\n&quot;);
-					}
-
-					if(i&lt;5) continue; // ignore the first frames
-					
-					// check if it is a b-frame
-					//printf(&quot; %lu : %lu \n&quot;,i,flag2);
-					if(buffer-&gt;flags &amp; AVI_B_FRAME)
-					{
-						printf(&quot; * &quot;);
-					 	bframe=1;
-						vid-&gt;_aviheader-&gt;getFlags(i,&amp;flags);
-						if(!(flags &amp; AVI_B_FRAME))
-                                                {
-                                                        printf(&quot;Frame %lu is A B frame, flag not ok\n&quot;,i);
-							bconsistency=0;
-                                                }
-						else
-							printf(&quot;# &quot;);
-					}
-					if((i%16)==15) printf(&quot;\n&quot;);
-				}
-                                printf(&quot;\n&quot;);
-				delete  buffer;
-				delete [] bufferin;
-				if(getEnv(ENV_EDITOR_BFRAME))
-				{
-					printf(&quot;Forcing Bframe present and incorrect\n&quot;);
-					bframe=1;
-					bconsistency=0;
-					
-				}
-                                uint32_t ffcheck=vid-&gt;decoder-&gt;isDivxPacked ();
-                                if(ffcheck)
-                                {
-                                  printf(&quot;[Editor] Decoder says it is vop packed\n&quot;);
-                                }
-				if(bframe || ffcheck)
-				{
-					printf(&quot;\n Mmm this appear to have b-frame...\n&quot;);
-					if(bconsistency )
-					{
-						printf(&quot;\n And the index is ok\n&quot;);
-
-						//uint8_t [720*576*3];
-						vid-&gt;_reorderReady=vid-&gt;_aviheader-&gt;reorder();
-						if(vid-&gt;_reorderReady)
-						{
-							printf(&quot;\n Frames re-ordered, B-frame friendly now :)\n&quot;);
-							aprintf(&quot; we had :%lu&quot;,info.nb_frames);
-							// update nb frame in case we dropped some
-							_total_frames -= info.nb_frames;
-							_videos[_nb_video-1]._aviheader-&gt;getVideoInfo (&amp;info);
-							aprintf(&quot; we have now  :%lu&quot;,info.nb_frames);
-							_total_frames += info.nb_frames;
-  							_videos[_nb_video-1]._nb_video_frames = info.nb_frames;
-						}
-						else
-						{
-							printf(&quot;\n Frames not  re-ordered, expect problem with b-frames\n&quot;);
-						}
-
-					}
-					else
-					{
-						printf(&quot;\n But the  index is not up to date \n&quot;);
-						uint32_t ispacked=0;
-                                                
-                                                uint32_t ff=vid-&gt;decoder-&gt;isDivxPacked ();
-                                                if(ff)
-                                                {
-                                                  printf(&quot;[Editor] Decoder says it is vop packed\n&quot;);
-                                                }
-                                                
-						// If it is Divx 5.0.xxx use divx decoder
-						if(isMpeg4Compatible(info.fcc))
-						{
-
-
-							//if(vid-&gt;decoder-&gt;isDivxPacked())
-							uint8_t forced= getEnv(ENV_EDITOR_PVOP);
-							if(ff ||forced)
-							{
-								
-								// can only unpack avi
-								if(!count &amp;&amp; type==AVI_FileType)
-								{
-                                                                  uint32_t autounpack=0;
-                                                                  prefs-&gt;get(FEATURE_AUTO_UNPACK,&amp;autounpack);
-									if( forced || autounpack || GUI_YesNo(
-                                                                                QT_TR_NOOP(&quot;Packed Bitstream detected&quot;),
-                                                                        QT_TR_NOOP(&quot;Do you want me to unpack it ?&quot;)))
-									{
-									OpenDMLHeader *dml=NULL;
-									count++;	
-									dml=(OpenDMLHeader *)vid-&gt;_aviheader;
-									// Can we repack it ?
-									if(dml-&gt;unpackPacked())
-									{
-                                                                                // Set ouput to avi vop
-                                                                                UI_SetCurrentFormat(ADM_AVI_UNP);
-                                                                                // Create a new decoder
-                                                                                // As the current one have already decoded
-                                                                                // some pics
-                                                                                delete  _videos[_nb_video-1].decoder;
-                                                                                _videos[_nb_video-1].decoder=NULL;
-                                                                                printf(&quot;Creating fresh decoder\n&quot;);
-                                                                                 _videos[_nb_video-1].decoder = getDecoder (info.fcc,
-                                           info.width, info.height, l, d);
-										goto TryAgain;
-									}
-                                                                        GUI_Error_HIG(QT_TR_NOOP(&quot;Could not unpack the video&quot;),QT_TR_NOOP( &quot;Using backup decoder - not frame accurate.&quot;));
-									}
-								}
-#if  1 //def USE_DIVX
-                                                                if(count)
-                                                                        GUI_Info_HIG(ADM_LOG_IMPORTANT,QT_TR_NOOP(&quot;Weird&quot;),QT_TR_NOOP( &quot;The unpacking succeedeed but the index is still not up to date.&quot;));
-								printf(&quot;\n Switching codec...\n&quot;);
-								delete vid-&gt;decoder;
-								vid-&gt;decoder=getDecoderVopPacked(info.fcc, info.width,info.height,0,NULL);
-								ispacked=1;
-#else
-								GUI_Info_HIG(ADM_LOG_IMPORTANT,QT_TR_NOOP(&quot;Troubles ahead&quot;), QT_TR_NOOP(&quot;This a VOP packed AVI.&quot;));
-#endif
-
-							}
-
-						}
-						// else warn user
-						if(!ispacked)
-                                                {
-                                                   uint32_t reindex=0;
-                                                  prefs-&gt;get(FEATURE_AUTO_REBUILDINDEX,&amp;reindex);
-                                                  if(reindex || GUI_YesNo(QT_TR_NOOP(&quot;Index is not up to date&quot;),QT_TR_NOOP(&quot;You should use Tool-&gt;Rebuild frame. Do it now ?&quot;)))
-                                                        {
-                                                                rebuildFrameType();
-							}
-                                                }
-					}
-				}
-				else
-				{
-					printf(&quot;Seems it does not contain B-frames...\n&quot;);
-				}
-		printf(&quot; End of B-frame check\n&quot;);
-		}
-  return 1;
-}
-/**
-	Send a re-order order to all video if
-		- They may need it
-		- It is not already done.
-*/
-uint8_t ADM_Composer::reorder (void)
-{
-_VIDEOS *vid;
-	for(uint32_t i=0;i&lt;_nb_video;i++)
-	{
-		vid=&amp;_videos[i];
-		if(!vid-&gt;_reorderReady) // not already reordered ?
-		{
-				if(vid-&gt;decoder-&gt;bFramePossible()) // can be re-ordered ?
-				{
-						if((vid-&gt;_reorderReady=vid-&gt;_aviheader-&gt;reorder()))
-						{
-							aviInfo    info;
-							_videos[i]._aviheader-&gt;getVideoInfo (&amp;info);
-                                                        
-							printf(&quot; Video %lu has been reordered\n&quot;,i);
-						}
-
-				}
-		}
-	}
-	return 1;
-}
-/*
-        If one of the videos has VBR audio we handle the whole editor audio has VBR
-        If it is CBR, it is not harmful 
-        and it avoid loosing the VBR info in case we do VBR time map upon loading
-*/
-uint8_t ADM_Composer::hasVBRVideos(void)
-{
-        for(int i=0;i&lt;_nb_video;i++)
-                if(_videos[i]._isAudioVbr) return 1;
-        return 0;
-}
-
-/*
-
-*/
-uint32_t ADM_Composer::getPARWidth()
-{
-  if (_nb_video)
-  {
-    return _videos[0].decoder-&gt;getPARWidth();
-  }
-  return 1;
-
-}
-
-uint32_t ADM_Composer::getPARHeight()
-{
-  if (_nb_video)
-  {
-    return _videos[0].decoder-&gt;getPARHeight();
-  }
-  return 1;
-
-}
-
-/**
-	Set decoder settings (post process/swap u&amp;v...)
-	for the segment referred by frame
-
-*/
-uint8_t ADM_Composer::setDecodeParam (uint32_t frame)
-{
-uint32_t seg,relframe,ref;
-  if (_nb_video)
-  {
-   if (!convFrame2Seg (frame, &amp;seg, &amp;relframe))
-    {
-      printf (&quot;\n Conversion failed !\n&quot;);
-      return 0;
-    }
-    // Search source
-     ref = _segments[seg]._reference;
-    _videos[ref].decoder-&gt;setParam ();        
-  }
-  return 1;
-
-}
-
-/**
-	Free all allocated memory and destroy all editors object
-
-
-*/
-uint8_t ADM_Composer::cleanup (void)
-{
-  deleteAllSegments ();
-  deleteAllVideos ();
-  _nb_segment = 0;
-  _nb_video = 0;
-  _total_frames = 0;
-
-	if(_scratch)
-	{
-		delete _scratch;
-		_scratch=NULL;
-	}
-
-  return 1;
-}
-/*
-        param:
-                source : source #
-                start : start frame in source #
-                nb    : nb frame to copy into segment
-*/
-uint8_t ADM_Composer::addSegment(uint32_t source,uint32_t start, uint32_t nb)
-{
-        // do some sanity check
-        if(_nb_segment==max_seg-1)
-	{
-	   _SEGMENT *s;
-            max_seg += MAX_SEG;
-            s = new _SEGMENT[max_seg];
-            memset (s, 0, sizeof(_SEGMENT)*max_seg);
-            memcpy(s,_segments,sizeof(_SEGMENT)*(max_seg-MAX_SEG));
-            delete _segments;
-            _segments = s;
-        }
-        if(_nb_video&lt;=source)
-        {
-                printf(&quot;[editor]: No such source %d/%d\n&quot;,source,_nb_video);
-                 return 0;
-        }
-        if(_videos[source]._nb_video_frames&lt;=start)
-        {
-                printf(&quot;[editor]:start out of bound %d/%d\n&quot;,start,_videos[source]._nb_video_frames);
-                 return 0;
-        }
-        if(_videos[source]._nb_video_frames&lt;start+nb)
-        {
-                printf(&quot;[editor]:end out of bound %d/%d\n&quot;,start+nb,_videos[source]._nb_video_frames);
-                 return 0;
-        }
-        // ok, let's go
-        _SEGMENT *seg=&amp;(_segments[_nb_segment]);
-        seg-&gt;_reference=source;
-        seg-&gt;_start_frame=start;
-        seg-&gt;_nb_frames=nb;
-        _nb_segment++;
-        updateAudioTrack (_nb_segment-1);
-        _total_frames=computeTotalFrames();
-
-        return 1;
-}
-/**
-______________________________________________________
-//  Remove frames , the frame are given as seen by GUI
-//  We remove from start to end -1
-// [start,end[
-//______________________________________________________
-*/
-uint8_t ADM_Composer::removeFrames (uint32_t start, uint32_t end)
-{
-
-  uint32_t
-    seg1,
-    seg2,
-    rel1,
-    rel2;
-  uint8_t
-    lastone =
-    0;
-
-  if (end == _total_frames - 1)
-    lastone = 1;
-
-  // sanity check
-  if (start &gt; end)
-    return 0;
-  //if((1+start)==end) return 0;
-
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (start, &amp;seg1, &amp;rel1) ||
-      !convFrame2Seg (end, &amp;seg2, &amp;rel2))
-    {
-      ADM_assert (0);
-    }
-  // if seg1 != seg2 we can just modify seg1 and seg2
-  if (seg1 != seg2)
-    {
-      // remove end of seg1
-
-      removeFrom (rel1, seg1, 1);
-      //  delete in between seg
-      for (uint32_t seg = seg1 + 1; seg &lt; (seg2); seg++)
-	_segments[seg]._nb_frames = 0;
-      // remove beginning of seg2
-      removeTo (rel2, seg2, lastone);
-    }
-  else
-    {
-      // it is in the same segment, split it...
-      // complete seg ?
-      if ((rel1 == _segments[seg1]._start_frame)
-	  &amp;&amp; (rel2 ==
-	      (_segments[seg1]._start_frame +
-	       _segments[seg1]._nb_frames - 1)))
-	{
-	  _segments[seg1]._nb_frames = 0;
-	}
-      else
-	{
-	  // split in between.... duh !
-	  duplicateSegment (seg1);
-	  //
-	  removeFrom (rel1, seg1, 1);
-	  removeTo (rel2, seg1 + 1, lastone);
-	}
-    }
-
-  // Crunch
-  crunch ();
-  sanityCheck ();
-  // Compute total nb of frame
-  _total_frames = computeTotalFrames ();
-  printf (&quot;\n %lu frames &quot;, _total_frames);
-  return 1;
-
-}
-//******************************
-// Select audio track
-//
-//******************************
-uint8_t ADM_Composer::getAudioStreamsInfo(uint32_t frame,uint32_t *nbStreams, audioInfo **infos)
-{
-uint32_t seg,rel,reference;
-
-        if (!convFrame2Seg (frame, &amp;seg, &amp;rel))
-        {
-                printf(&quot;Editor : frame2seg failed (%u)\n&quot;,frame);
-                return 0;
-        }
-        reference=_segments[seg]._reference;
-        return _videos[reference]._aviheader-&gt;getAudioStreamsInfo(nbStreams,infos);
-}
-/*
-        Change the audio track for the source video attached to the &quot;frame&quot; frame
-
-*/
-uint32_t ADM_Composer::getCurrentAudioStreamNumber(uint32_t frame)
-{
-uint32_t   seg,rel,reference;
-
-        if (!convFrame2Seg (frame, &amp;seg, &amp;rel))
-        {
-                printf(&quot;Editor : frame2seg failed (%u)\n&quot;,frame);
-                return 0;
-        }
-        reference=_segments[seg]._reference;
-        return _videos[reference]._aviheader-&gt;getCurrentAudioStreamNumber();
-}
-uint8_t ADM_Composer::changeAudioStream(uint32_t frame,uint32_t newstream)
-{
-uint32_t   seg,rel,reference;
-double     duration;
-WAVHeader *wav;
-aviInfo    info;
-
-        if (!convFrame2Seg (frame, &amp;seg, &amp;rel))
-        {
-                printf(&quot;Editor : frame2seg failed (%u)\n&quot;,frame);
-                return 0;
-        }
-        reference=_segments[seg]._reference;
-        if(!_videos[reference]._aviheader-&gt;changeAudioStream(newstream))
-        {
-                printf(&quot;Editor : stream change failed for frame %u seg %u stream %u\n&quot;,frame,seg,newstream);
-                return 0;
-        }
-        // Now update audio tracks infos
-        wav = _videos[reference]._aviheader-&gt;getAudioInfo ();
-        if(!wav)
-        {
-                ADM_assert(0); // Cannot change to a non existing track!
-        }
-        _videos[reference]._aviheader-&gt;getVideoInfo (&amp;info);
-        _videos[reference]._aviheader-&gt;getAudioStream (&amp;_videos[reference]._audiostream);
-
-        duration=_videos[reference]._nb_video_frames;
-        duration/=info.fps1000;
-        duration*=1000;                 // duration in seconds
-        duration*=wav-&gt;frequency;          // In sample
-        _videos[reference]._audio_duration=(uint64_t)floor(duration);
-        for(uint32_t i=0;i&lt;_nb_segment;i++)
-                updateAudioTrack(i);
-        return 1;
-}
-
-/**
-______________________________________________________
-//
-//	Copy the start/eng seg  to clipboard
-//______________________________________________________
-*/
-uint8_t ADM_Composer::copyToClipBoard (uint32_t start, uint32_t end)
-{
-
-  uint32_t	    seg1,    seg2,    rel1,    rel2;
-  uint8_t    lastone =    0;
-uint32_t seg=0xfff;
-
-  if (end == _total_frames - 1)
-    lastone = 1;
-
-  // sanity check
-  if (start &gt; end)
-  {
-    printf(&quot;End &lt; Start \n&quot;);
-    return 0;
-   }
-  //if((1+start)==end) return 0;
-
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (start, &amp;seg1, &amp;rel1) ||
-      !convFrame2Seg (end, &amp;seg2, &amp;rel2))
-    {
-      ADM_assert (0);
-    }
-    _nb_clipboard=0;
-  // if seg1 != seg2 we can just modify seg1 and seg2
-  if (seg1 != seg2)
-    {
-    aprintf(&quot;Diff  seg: %lu /%lu from %lu to %lu \n&quot;,seg1,seg2,rel1,rel2);
-      // remove end of seg1
-	_clipboard[_nb_clipboard]._reference=_segments[seg1]._reference;
-	_clipboard[_nb_clipboard]._start_frame=rel1;
- 	_clipboard[_nb_clipboard]._nb_frames =_segments[seg]._nb_frames- (rel1 - _segments[seg]._start_frame);
-	_nb_clipboard++;
-      // copy  in between seg
-      for ( seg = seg1 + 1; seg &lt;=seg2; seg++)
-		memcpy(&amp;_clipboard[_nb_clipboard++], &amp;_segments[seg],sizeof(_segments[0]));
-      // Adjust nb frame for last seg
-      uint32_t l;
-      l=_nb_clipboard-1;
-	_clipboard[l]._nb_frames=rel2-_segments[seg2]._start_frame;
-    }
-  else
-    {
-      // it is in the same segment, split it...
-      // complete seg ?
-      if ((rel1 == _segments[seg1]._start_frame)
-	  &amp;&amp; (rel2 ==
-	      (_segments[seg1]._start_frame +
-	       _segments[seg1]._nb_frames - 1)))
-	{
-	  aprintf(&quot;Full seg: %lu from %lu to %lu \n&quot;,seg1,rel1,rel2);
-		memcpy(&amp;_clipboard[_nb_clipboard++], &amp;_segments[seg1],sizeof(_segments[0]));
-	}
-      else
-	{
-	  // we just take a part of one chunk
-	  aprintf(&quot;Same seg: %lu from %lu to %lu \n&quot;,seg1,rel1,rel2);
-	  memcpy(&amp;_clipboard[_nb_clipboard], &amp;_segments[seg1],sizeof(_segments[0]));
-	  _clipboard[_nb_clipboard]._start_frame=rel1;
-	  _clipboard[_nb_clipboard]._nb_frames=rel2-rel1;
-	_nb_clipboard++;
-	aprintf(&quot;clipboard: %lu \n&quot;,_nb_clipboard);
-	}
-    }
-	dumpSeg();
-  return 1;
-
-}
-uint8_t ADM_Composer::pasteFromClipBoard (uint32_t whereto)
-{
-uint32_t rel,seg;
-
-	if (!convFrame2Seg (whereto, &amp;seg, &amp;rel) )
-    	{
-      		ADM_assert (0);
-    	}
-	dumpSeg();
-
-	// past at frame 0
-	if(	seg==0 &amp;&amp; rel==_segments[0]._start_frame)
-	{
-		aprintf(&quot;Pasting at frame 0\n&quot;);
-		for(uint32_t i=0;i&lt;_nb_clipboard;i++)
-			duplicateSegment(seg);
-		memcpy(&amp;_segments[0],&amp;_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-	}
-	else
-	if(rel==_segments[seg]._start_frame+_segments[seg]._nb_frames )
-	{
-		aprintf(&quot;\n setting at the end of seg %lu\n&quot;,seg);
-		// we put it after OLD insert OLD+1
-		for(uint32_t i=0;i&lt;_nb_clipboard;i++)
-			duplicateSegment(seg);
-		memcpy(&amp;_segments[seg+1],&amp;_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-
-	}
-	else // need to split it
-	{
-		for(uint32_t i=0;i&lt;_nb_clipboard+1;i++)
-			duplicateSegment(seg);
-		memcpy(&amp;_segments[seg+1],&amp;_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-
-		// and the last one
-		_segments[seg+_nb_clipboard+1]._nb_frames=(_segments[seg]._start_frame+_segments[seg]._nb_frames)-rel;
-		_segments[seg+_nb_clipboard+1]._start_frame=rel;
-		// adjust the current one
-		_segments[seg]._nb_frames=rel-_segments[seg]._start_frame;
-	}
-	 _total_frames = computeTotalFrames ();
-	for(uint32_t i=0;i&lt;_nb_segment;i++)
- 		updateAudioTrack(i);
-  dumpSeg();
-  return 1;
-
-}
-
-//____________________________________
-//      Duplicate a segment
-//____________________________________
-
-uint8_t ADM_Composer::duplicateSegment (uint32_t segno)
-{
-
-  for (uint32_t i = _nb_segment; i &gt; segno; i--)
-    {
-
-      memcpy (&amp;_segments[i], &amp;_segments[i - 1], sizeof (_SEGMENT));
-
-    }
-  _nb_segment++;
-  return 1;
-
-
-}
-
-//____________________________________
-//      Remove empty segments
-//____________________________________
-uint8_t ADM_Composer::crunch (void)
-{
-  uint32_t
-    seg =
-    0;
-  while (seg &lt; _nb_segment)
-    {
-      if (_segments[seg]._nb_frames == 0)
-	{
-	  //
-
-	  for (uint32_t c = seg + 1; c &lt; _nb_segment; c++)
-	    {
-	      memcpy (&amp;_segments[c - 1], &amp;_segments[c], sizeof (_SEGMENT));
-	    }
-	  _nb_segment--;
-
-	}
-      else
-	{
-	  seg++;
-	}
-    }
-  // Remove last seg if there is only one frame in it
-  if (_nb_segment)
-    {
-      if (_segments[_nb_segment - 1]._nb_frames == 1)
-	{
-	  _nb_segment--;
-	}
-    }
-  return 1;
-
-}
-
-//____________________________________
-//      Remove empty segments
-//____________________________________
-uint32_t ADM_Composer::computeTotalFrames (void)
-{
-  uint32_t
-    seg,
-    tf =
-    0;
-  for (seg = 0; seg &lt; _nb_segment; seg++)
-    {
-      tf += _segments[seg]._nb_frames;
-
-    }
-
-  return tf;
-}
-
-//____________________________________
-//      Remove empty segments
-//____________________________________
-void
-ADM_Composer::dumpSeg (void)
-{
-  uint32_t seg;
-  printf (&quot;\n________Video______________&quot;);
-  for (seg = 0; seg &lt; _nb_video; seg++)
-    {
-      printf (&quot;\n Video : %lu, nb video  :%lu, audio size:%lu  audioDuration:%lu&quot;,
-	      seg, _videos[seg]._nb_video_frames, _videos[seg]._audio_size,_videos[seg]._audio_duration);
-
-    }
-
-  printf (&quot;\n______________________&quot;);
-  for (seg = 0; seg &lt; _nb_segment; seg++)
-    {
-      printf
-	(&quot;\n Seg : %lu, ref: %lu start :%lu, size:%lu audio size : %lu audio start : %lu duration:%lu&quot;,
-	 seg, _segments[seg]._reference, _segments[seg]._start_frame,
-	 _segments[seg]._nb_frames, _segments[seg]._audio_size,
-	 _segments[seg]._audio_start,
-	  _segments[seg]._audio_duration
-	 );
-
-    }
-  printf (&quot;\n_________Clipboard_____________&quot;);
-  for (seg = 0; seg &lt; _nb_clipboard; seg++)
-    {
-      printf
-	(&quot;\n Seg : %lu, ref: %lu start :%lu, size:%lu audio size : %lu audio start : %lu  duration:%lu\n&quot;,
-	 seg, _clipboard[seg]._reference, _clipboard[seg]._start_frame,
-	 _clipboard[seg]._nb_frames, _clipboard[seg]._audio_size,
-	 _clipboard[seg]._audio_start,
-	 _segments[seg]._audio_duration);
-
-    }
-
-
-}
-
-// Clear from position to/from
-//
-// 0------To------end
-//  xxxxxx removed
-
-uint8_t ADM_Composer::removeTo (uint32_t to, uint32_t seg, uint8_t included)
-{
-  uint32_t
-    ref;
-
-  ADM_assert (checkInSeg (seg, to));
-  ref = _segments[seg]._start_frame;
-  _segments[seg]._start_frame = to;
-  if (included)
-    _segments[seg]._start_frame++;
-  _segments[seg]._nb_frames -= (_segments[seg]._start_frame - ref);
-
-
-  updateAudioTrack (seg);
-
-//---------------------------------------
-
-
-
-  return 1;
-}
-
-//
-// 0------From------end
-//            xxxxxx removed
-
-uint8_t
-  ADM_Composer::removeFrom (uint32_t from, uint32_t seg, uint8_t included)
-{
-  ADM_assert (checkInSeg (seg, from));
-  _segments[seg]._nb_frames = (from - _segments[seg]._start_frame);
-
-  if (!included)
-    _segments[seg]._nb_frames++;
-
-  updateAudioTrack (seg);
-  return 1;
-}
-
-//
-//      Update the real size of audio track by computing the
-// delta between sync @end and <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">sync at begin</A>
-// We also upate the duration of the selected part
-//
-
-uint8_t ADM_Composer::updateAudioTrack (uint32_t seg)
-{
-  // audio sync
-  uint32_t
-    pos_start,
-    pos_end,
-    off,
-    tf;
-  uint32_t
-    reference;
-
-  reference = _segments[seg]._reference;
-  // Mika
-  if (!_videos[reference]._audiostream)
-    return 1;
-  // Compute the resulting duration
-  // Of the segment
-  double duration;
-  aviInfo info;
-  	_videos[reference]._aviheader-&gt;getVideoInfo(&amp;info);
-  	duration= _segments[seg]._nb_frames;
-	ADM_assert(info.fps1000);
-	duration/=info.fps1000;
-	duration*=1000*_videos[reference]._audiostream-&gt;getInfo()-&gt;frequency;
-	
-  _segments[seg]._audio_duration = (uint64_t)floor(duration);
-
-  // If we cannot go to sync point start --&gt; no need to continue
-  // It can happen if audio track is shorter than video
-#if 0 // BAZOOKA
-  if (!audioGoToFn (seg, _segments[seg]._start_frame, &amp;off))
-    {
-      _segments[seg]._audio_size = 0;
-      printf (&quot; cannot seek audio tp frame : %lu\n&quot;, seg);
-      return 1;
-
-    }
-//  pos_start = _videos[reference]._audiostream-&gt;getPos ();
-
-  // Now try to go to the end...
-  // if it fails, try previous frame stamp
-  tf = _segments[seg]._start_frame + _segments[seg]._nb_frames;	//-1;
-
-  while ((!audioGoToFn (seg, tf, &amp;off)
-	  &amp;&amp; ((tf - 1) &gt; _segments[seg]._start_frame)))
-    {
-      printf (&quot; trying to sync on frame %lu\n&quot;, tf);
-      tf--;
-    }
-#endif
-//  pos_end = _videos[reference]._audiostream-&gt;getPos ();
-
-  _segments[seg]._audio_size = pos_end - pos_start;
-  _segments[seg]._audio_start = pos_start;
-  
-  printf (&quot; Audio start : %lu end : %lu size : %lu\n&quot;, pos_start, pos_end,
-	  _segments[seg]._audio_size);
-
-  return 1;
-
-#warning FIXME, does not work if audio track is shorter
-
-}
-uint8_t WAV2AudioInfo(WAVHeader *hdr,audioInfo *info)
-{
-    info-&gt;bitrate=(hdr-&gt;byterate*8)/1000;
-    info-&gt;channels=hdr-&gt;channels;
-    info-&gt;encoding=hdr-&gt;encoding;
-    info-&gt;frequency=hdr-&gt;frequency;
-    info-&gt;av_sync=0;
-    return 1;
-}
-
-
-//__________________________________________________
-// check that the given frame is inside the segment
-//__________________________________________________
-uint8_t ADM_Composer::checkInSeg (uint32_t seg, uint32_t frame)
-{
-  if (frame &lt; _segments[seg]._start_frame)
-    return 0;
-  if (frame &gt; (_segments[seg]._nb_frames + _segments[seg]._start_frame))
-    return 0;
-  return 1;
-
-}
-uint8_t	ADM_Composer::isIndexable( void)
-{
-	if(!_nb_video) ADM_assert(0);
-	return _videos[0].decoder-&gt;isIndexable();
-
-}
-
-uint8_t ADM_Composer::sanityCheck (void)
-{
-  uint32_t
-    ref,
-    seg;
-
-  for (seg = 0; seg &lt; _nb_segment; seg++)
-    {
-      ref = _segments[seg]._start_frame + _segments[seg]._nb_frames - 1;
-
-    }
-  return 1;
-
-
-}
-
-/**
-	Propagate VBR building to underlying segment
-
-*/
-void
-ADM_Composer::propagateBuildMap (void)
-{
-uint8_t need_update=0;
-  if (_nb_video)
-    {
-    for(uint32_t i=0;i&lt;_nb_video;i++)
-    	{
-    		if(! _videos[i]._isAudioVbr)
-		{
-//			if((    		_videos[i]._isAudioVbr=_videos[i]._audiostream-&gt;buildAudioTimeLine ()))
-			{
-				need_update=1;
-			}
-		}
-	}
-    }
-
-}
-//_________________________________________
-uint8_t		ADM_Composer::setEnv(_ENV_EDITOR_FLAGS newflag)
-{
-	_internalFlags|=newflag;
-	return 1;
-
-}
-//_________________________________________
-//	Return 1 if the flag was set
-//		The flag is reset in all cases!!!!!!!!!!!!!
-uint8_t		ADM_Composer::getEnv(_ENV_EDITOR_FLAGS newflag)
-{
-uint8_t r=0;
-		if(_internalFlags&amp;newflag) r=1;
-		_internalFlags&amp;=~newflag;
-		if(r) { printf(&quot;Env override %d used\n&quot;,newflag);}
-		return r;
-
-}
-#if BAZOOKA
-//_________________________________________
-//    Try indexing the file, return 1 if file successfully indexed 
-//              0 else
-//_________________________________________
-//
-uint8_t         ADM_Composer::tryIndexing(const char *name, const char *idxname)
-{
- unsigned int autoidx = 0;
-      prefs-&gt;get(FEATURE_TRYAUTOIDX,&amp;autoidx);
-      if (!autoidx)
-        {
-          if (!GUI_Question (QT_TR_NOOP(&quot;This looks like mpeg\n Do you want to index it?&quot;)))
-            {
-                return 0;
-            }
-		}  
-          char      *idx;
-          DMX_TYPE  type;
-          uint32_t  nbTrack=0,audioTrack=0;
-          MPEG_TRACK *tracks=NULL;
-          uint8_t r=1;
-
-                if(!dmx_probe(name,&amp;type,&amp;nbTrack,&amp;tracks))
-                {
-                        printf(&quot;This is not mpeg\n&quot;);
-                        return 0;
-                }
-
-          
-                if(type==DMX_MPG_PS || type==DMX_MPG_TS || type==DMX_MPG_TS2)
-                {
-                       if(nbTrack&gt;2)
-		       if(autoidx)
-			{
-				printf(&quot;Using autoindex\n&quot;);
-			}
-/*                        else
-		       {
-                           
-                        if(!DIA_dmx(name,type,nbTrack,tracks,&amp;audioTrack))
-                        {
-                                delete [] tracks;
-                                return 0;
-                        }
-		       }
-*/
-                        audioTrack=0;
-                }
-		if( idxname ){
-			idx=new char[strlen(idxname)];
-			strcpy(idx,idxname);
-		}else{
-                	idx=new char[strlen(name)+5];
-                	strcpy(idx,name);
-                	strcat(idx,&quot;.idx&quot;);
-		}
-
-                r=dmx_indexer(name,idx,audioTrack,0,nbTrack,tracks);
-
-                if(tracks)
-                        delete [] tracks;
-                delete [] idx;
-
-                if(!r) GUI_Error_HIG(QT_TR_NOOP(&quot;Indexing failed&quot;), NULL); 
-                return r;
-}
-#endif
-/**
-      If a parameter has changed, rebuild the duration of the streams
-      It can happen, for example in case of SBR audio such as AAC
-      The demuxer says it is xx kHz, but the codec updates it to 2*xx kHz
-*/
-uint8_t ADM_Composer::rebuildDuration(void)
-{
-  double duration;
-  WAVHeader *wav ;
-  aviInfo    info;
-  printf(&quot;[Editor] updating soundtracks duration\n&quot;);
-  _videos[   0     ]._aviheader-&gt;getVideoInfo (&amp;info);
-  for(int i=0;i&lt;_nb_video;i++)
-  {
-    wav= _videos[i]._aviheader-&gt;getAudioInfo ();
-      if(wav)
-      {
-          duration=_videos[i]._nb_video_frames;
-          duration/=info.fps1000;
-          duration*=1000;                 // duration in seconds
-          duration*=wav-&gt;frequency;          // In sample
-          _videos[i]._audio_duration=(uint64_t)floor(duration);
-      }
-  }
-  for(int i=0;i&lt;_nb_segment;i++)
-    updateAudioTrack(i);
-  return 1;
-}
-//
-//


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002604.html">[Avidemux-svn-commit] r5393 - in	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
</A></li>
	<LI>Next message: <A HREF="002606.html">[Avidemux-svn-commit] r5395 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2605">[ date ]</a>
              <a href="thread.html#2605">[ thread ]</a>
              <a href="subject.html#2605">[ subject ]</a>
              <a href="author.html#2605">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
