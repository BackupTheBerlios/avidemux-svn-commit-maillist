<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5380 - in	branches/avidemux_2.6_branch_mean/avidemux/common: .	ADM_editor ADM_script
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-October/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5380%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux/common%3A%20.%0A%09ADM_editor%20ADM_script&In-Reply-To=%3C200910140546.n9E5kMbC004582%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002590.html">
   <LINK REL="Next"  HREF="002592.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5380 - in	branches/avidemux_2.6_branch_mean/avidemux/common: .	ADM_editor ADM_script</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5380%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux/common%3A%20.%0A%09ADM_editor%20ADM_script&In-Reply-To=%3C200910140546.n9E5kMbC004582%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5380 - in	branches/avidemux_2.6_branch_mean/avidemux/common: .	ADM_editor ADM_script">mean at mail.berlios.de
       </A><BR>
    <I>Wed Oct 14 07:46:22 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002590.html">[Avidemux-svn-commit] r5379 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core:	include src
</A></li>
        <LI>Next message: <A HREF="002592.html">[Avidemux-svn-commit] r5381 - in	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2591">[ date ]</a>
              <a href="thread.html#2591">[ thread ]</a>
              <a href="subject.html#2591">[ subject ]</a>
              <a href="author.html#2591">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-10-14 07:46:21 +0200 (Wed, 14 Oct 2009)
New Revision: 5380

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
Log:
[Editor] Switch seeking to time based seeking

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -935,58 +935,8 @@
 	*swapuv=_pp.swapuv;
 	return 1;
 }
-//______________________________________________
-//_______________________________________________
-/**
-    \fn getPKFrame
-    \brief returns the keyFrame strictly before *frame
-*/
-bool	ADM_Composer::getPKFrame(uint32_t *frame)
-{
-	uint32_t fr, seg, relframe;	//,len; //flags,ret,nf;
 
-  fr = *frame;
 
-  if (*frame == 0)
-    {
-      return false;
-    }
-  if (!searchPreviousKeyFrame (fr, &amp;seg, &amp;relframe))
-    {
-      printf (&quot; NKF not found\n&quot;);
-      return false;
-    }
-    if(false==_segments.getFrameFromRef(frame,seg,relframe))
-    {
-        ADM_warning(&quot;[getPKFrame] getFrameFromRef failed for sefg : %&quot;LD&quot; reframe %&quot;LD&quot;\n&quot;,seg,relframe);
-        return false;
-    }
-  return true;
-
-}
-/**
-    \fn getNKFrame
-    \brief returns the keyFrame strictly after *frame
-*/
-
-bool	ADM_Composer::getNKFrame(uint32_t *frame)
-{
-	uint32_t fr, seg, relframe;	//,len; //flags,ret,nf;
-
-  fr = *frame;
-  if (!searchNextKeyFrame (fr, &amp;seg, &amp;relframe))
-    {
-      printf (&quot; NKF not found\n&quot;);
-      return 0;
-    }
-    if(false==_segments.getFrameFromRef(frame,seg,relframe))
-    {
-        ADM_warning(&quot;[getNKFrame] getFrameFromRef failed for sefg : %&quot;LD&quot; reframe %&quot;LD&quot;\n&quot;,seg,relframe);
-        return false;
-    }
-  return true;
-}
-
 #if 0
 uint8_t	ADM_Composer::isReordered( uint32_t framenum )
 {
@@ -1041,74 +991,7 @@
     }
     return true;
 }
-/**
-    \fn searchFrameBefore
-    \brief Return the frame number with pts just before pts
-*/
-uint32_t ADM_Composer::searchFrameBefore(uint64_t pts)
-{
-uint64_t refTime;
-uint32_t ref;
-    if(false==_segments.getRefFromTime(pts,&amp;ref,&amp;refTime))
-    {
-        ADM_warning(&quot;[searchFrameBefore] Failed for pts %&quot;LLU&quot;\n&quot;,pts);
-        ref=0;
-        refTime=pts;
-    }
-#warning fix over-seg issue
-    _VIDEOS   *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid-&gt;_aviheader;
-    uint64_t  lastPts=demuxer-&gt;getTime(0);
-    uint32_t  nb=demuxer-&gt;getVideoStreamHeader()-&gt;dwLength;
 
-    if(lastPts&gt;pts) return 0;
 
-	for(int i=1;i&lt;nb-2;i++)
-    {
-        uint64_t cur,next;
-        cur=lastPts;
-        next=demuxer-&gt;getTime(i+1);
-        if(next==ADM_NO_PTS) next=cur+vid-&gt;timeIncrementInUs;
-        if(pts&gt;=cur &amp;&amp; pts&lt;next) return i-1;
-        lastPts=next;
-    }
-    return nb-1;
-}
-/**
-    \fn getImageFromCacheForFrameBefore
-    \brief Search the cache for the image with PTS just before the input PTS
-*/
-bool    ADM_Composer::getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out)
-{
-    int ref=0;
-    EditorCache   *cache;
-	_VIDEOS *vid=_segments.getRefVideo(0);
-	cache=vid-&gt;_videoCache;
-	ADM_assert(cache);
-        ADMImage *r=cache-&gt;findLastBefore(pts);
-        if(!r) return false;
-        out-&gt;duplicateFull(r);
-        return true;
 
-}
-/**
-    \fn getPtsDts
-    \brief Return PTS &amp; DTS for a given frame (in bitstream order)
-*/
-bool        ADM_Composer::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
-{
-uint32_t ref,refOffset;
-    if(_segments.getRefFromFrame(frame,&amp;ref,&amp;refOffset)==false)
-    {
-        ADM_warning(&quot;[Composer::getPtsDts] Cannot get ref video for frame %&quot;LD&quot;\n&quot;,frame);
-        return false;
-    }
- 
-     _VIDEOS   *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid-&gt;_aviheader;
-    return demuxer-&gt;getPtsDts(frame,pts,dts); // FIXME : Rescale frame number
-
-}
-
-
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -19,143 +19,153 @@
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 
 /**
-    \fn searchNextKeyFrame
- //             Input : frame &lt;b&gt;as seen by GUI  &lt;/b&gt;
- //     Output, segment &amp; relframe previous keyframe
- //
+    \fn getNKFramePTS
 */
-uint8_t   ADM_Composer::searchNextKeyFrame (uint32_t in, uint32_t * oseg,
-				    uint32_t * orel)
+bool	ADM_Composer::getNKFramePTS(uint64_t *frameTime)
 {
-#if 0
-  uint32_t relframe;
-  uint32_t seg, flags;
-  uint8_t switched = 0;
-  uint32_t ref;
+uint64_t refTime,nkTime,segTime;
+int lastSeg=_segments.getNbSegments();
+uint32_t seg;
+bool r;
+    // 1- Convert frameTime to segments
+    if(false== _segments.convertLinearTimeToSeg(  *frameTime, &amp;seg, &amp;segTime))
+    {
+        ADM_warning(&quot;[getSegmentFromTime] Cannot find seg for time %&quot;LLD&quot;\n&quot;,*frameTime);
+        return false;
+    }   
+    // 
+again:
+    _SEGMENT *s=_segments.getSegment(seg);
+    uint32_t ref=s-&gt;_reference;
+    // 2- Now search the previous keyframe in the ref image...
+    // The time in reference = relTime+segmentStartTime
+    refTime=s-&gt;_startTimeUs+segTime; // Absolute time in the reference image
+    
+    r=searchNextKeyFrameInRef(ref,refTime,&amp;nkTime);
 
-
-  if (in &gt;= (_total_frames - 1))
+    // 3- if it does not belong to the same seg  ....
+    if(r==false || nkTime &gt; (s-&gt;_refStartTimeUs+s-&gt;_refStartTimeUs))
     {
-      printf (&quot;\nNKF  out of bounds\n&quot;);
-      return 0;;
+        if(seg&gt;=lastSeg-1)
+        {
+            ADM_warning(&quot;[getSegmentFromTime] No next keyframe keyfr for frameTime \n&quot;);
+            return false;
+        }
+        // Go to the next segment
+        seg++;
+        goto again;
     }
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (in, &amp;seg, &amp;relframe))
-    {
-      printf (&quot;\n Conversion failed !\n&quot;);
-      return 0;
-    }
+    // Gotit, now convert it to the linear time
+    nkTime-=s-&gt;_startTimeUs;  // Ref to segment...
+    _segments.convertSegTimeToLinear(seg,nkTime,frameTime);
+    return true;
 
-  while (seg &lt; _segments.size())
-    {
-      ref = _segments[seg]._reference;
-      // Search next kf in seg
-      if (!switched)
-	flags = 0;
-      else
-	_videos[ref]._aviheader-&gt;getFlags (relframe, &amp;flags);
+}
 
+/**
+    \fn getPKFramePTS
+*/
 
-      while (!(flags &amp; AVI_KEY_FRAME) &amp;&amp; (relframe != 0xffffffff))
-	{
-	  relframe++;
-	  if (!_videos[ref]._aviheader-&gt;getFlags (relframe, &amp;flags))
-	    relframe = 0xffffffff;
-	}
-      // verify it is within the segment
+bool			ADM_Composer::getPKFramePTS(uint64_t *frameTime)
+{
 
-      if (relframe == 0xffffffff)
-	printf (&quot;\n not found in current seg\n&quot;);
-      if (relframe &lt;
-	  (_segments[seg]._start_frame + _segments[seg]._nb_frames))
-	{			// It is ...
-	  *oseg = seg;
-	  *orel = relframe;
-	  return 1;
-	}
-      // Not in segment
-      printf (&quot;\n trying next seg...\n&quot;);
-      seg++;
-      relframe = _segments[seg]._start_frame;
-      switched = 1;
-    }
-#endif
-#warning : Obsolete!
-  return 0;
 
 }
+/**
+    \fn searchNextKeyFrameInRef
+    \brief Search next key frame in ref video ref
+    @param ref: # of ref video
+    @param refTime : PTS to search keyframe after   
+    @param nkTime : Time of the ref video
 
-//_________________________________________
-uint8_t
-  ADM_Composer::searchPreviousKeyFrame (uint32_t in, uint32_t * oseg,
-					uint32_t * orel)
+*/
+bool ADM_Composer::searchNextKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime)
 {
-#if 0
-  uint32_t relframe;
-  uint32_t seg, flags;
-  uint32_t ref;
-
-
-  if (in == 0)
+    // Search from the end till we get a keyframe
+    _VIDEOS *v=_segments.getRefVideo(ref);
+    uint32_t nbFrame=v-&gt;_nb_video_frames;
+    
+    for(int i=0;i&lt;nbFrame;i++)
     {
-      printf (&quot;\n PKF out of bounds\n&quot;);
-      return 0;;
+        uint64_t p;
+        uint32_t flags;
+        v-&gt;_aviheader-&gt;getFlags(i,&amp;flags);
+        if(!(flags &amp; AVI_KEY_FRAME)) continue;
+        p=v-&gt;_aviheader-&gt;estimatePts(i);
+        if(p&gt;refTime &amp;&amp;p!=ADM_NO_PTS)
+        {
+            *nkTime=p;
+            return true;
+        }
     }
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (in, &amp;seg, &amp;relframe))
+    return false;
+}
+
+/**
+    \fn searchFrameBefore
+    \brief Return the frame number with pts just before pts
+*/
+uint32_t ADM_Composer::searchFrameBefore(uint64_t pts)
+{
+uint64_t refTime;
+uint32_t ref;
+    if(false==_segments.getRefFromTime(pts,&amp;ref,&amp;refTime))
     {
-      printf (&quot;\n Conversion failed !\n&quot;);
-      return 0;
+        ADM_warning(&quot;[searchFrameBefore] Failed for pts %&quot;LLU&quot;\n&quot;,pts);
+        ref=0;
+        refTime=pts;
     }
+#warning fix over-seg issue
+    _VIDEOS   *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid-&gt;_aviheader;
+    uint64_t  lastPts=demuxer-&gt;getTime(0);
+    uint32_t  nb=demuxer-&gt;getVideoStreamHeader()-&gt;dwLength;
 
-  if (relframe == 0)		//switch to last frame of prev seg
+    if(lastPts&gt;pts) return 0;
+
+	for(int i=1;i&lt;nb-2;i++)
     {
-      ADM_assert (seg);
-      seg--;
-      relframe = _segments[seg]._nb_frames - 1;
-
+        uint64_t cur,next;
+        cur=lastPts;
+        next=demuxer-&gt;getTime(i+1);
+        if(next==ADM_NO_PTS) next=cur+vid-&gt;timeIncrementInUs;
+        if(pts&gt;=cur &amp;&amp; pts&lt;next) return i-1;
+        lastPts=next;
     }
+    return nb-1;
+}
+/**
+    \fn getImageFromCacheForFrameBefore
+    \brief Search the cache for the image with PTS just before the input PTS
+*/
+bool    ADM_Composer::getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out)
+{
+    int ref=0;
+    EditorCache   *cache;
+	_VIDEOS *vid=_segments.getRefVideo(0);
+	cache=vid-&gt;_videoCache;
+	ADM_assert(cache);
+        ADMImage *r=cache-&gt;findLastBefore(pts);
+        if(!r) return false;
+        out-&gt;duplicateFull(r);
+        return true;
 
-  do
+}
+/**
+    \fn getPtsDts
+    \brief Return PTS &amp; DTS for a given frame (in bitstream order)
+*/
+bool        ADM_Composer::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+uint32_t ref,refOffset;
+    if(_segments.getRefFromFrame(frame,&amp;ref,&amp;refOffset)==false)
     {
-      ref = _segments[seg]._reference;
-      // Search next kf in seg
-      flags = 0;
-      while (!(flags &amp; AVI_KEY_FRAME) &amp;&amp; (relframe &gt; 0))
-	{
-	  relframe--;
-	  if (!_videos[ref]._aviheader-&gt;getFlags (relframe, &amp;flags))
-          {
-	    relframe = 0xffffffff;
-            break;
-          }
-	}
-      // verify it is within the segment
-
-      if ((relframe &lt;
-	   (_segments[seg]._start_frame +
-	    _segments[seg]._nb_frames)) &amp;&amp;
-	  (relframe &gt;= _segments[seg]._start_frame))
-
-	{			// It is ...
-	  *oseg = seg;
-	  *orel = relframe;
-	  return 1;
-	}
-      // Not in segment
-      printf (&quot;\n trying previous seg...\n&quot;);
-      if (seg == 0)
-	{
-	  printf (&quot;\n failed..\n&quot;);
-	  return 0;
-	}
-      seg--;
-      relframe = _segments[seg]._start_frame + _segments[seg]._nb_frames - 1;
+        ADM_warning(&quot;[Composer::getPtsDts] Cannot get ref video for frame %&quot;LD&quot;\n&quot;,frame);
+        return false;
     }
-  while (1);
-  printf (&quot;\n failed pkf..\n&quot;);
-#endif
-#warning obsolete
-  return 0;
+ 
+     _VIDEOS   *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid-&gt;_aviheader;
+    return demuxer-&gt;getPtsDts(frame,pts,dts); // FIXME : Rescale frame number
 
-}
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -29,7 +29,8 @@
         ADM_warning(#func &quot; cannot translate fame %&quot;LD&quot;\n&quot;,frame); \
         return false; \
     }
-/*
+/**
+    \fn getSpecificMpeg4Info
 	Propagate this hack to the underlying decoder
 */
 uint32_t ADM_Composer::getSpecificMpeg4Info( void )
@@ -92,7 +93,7 @@
             return t;
         }
     }
-    printf(&quot;[ADM_Composer::getTime] Cannot estimate time for frame %u\n&quot;,org);
+    ADM_warning(&quot;[ADM_Composer::getTime] Cannot estimate time for frame %u\n&quot;,org);
     return 0;
 }
 /**
@@ -108,16 +109,10 @@
 */
 uint32_t ADM_Composer::getFlagsAndSeg (uint32_t frame, uint32_t * flags,uint32_t *segs)
 {
-#if 0
-  uint32_t    relframe;
-  uint32_t    seg;
-  if (!convFrame2Seg (frame, &amp;seg, &amp;relframe))
-    return 0;
-  uint32_t    ref =   _segments[seg]._reference;
-
-    *segs=seg;
-#endif
-    return _segments.getRefVideo(0)-&gt;_aviheader-&gt;getFlags (frame, flags);
+ ADM_TRANSLATE(getFlagsAndSeg,frame);
+*segs=0;
+#warning fixme
+ return _segments.getRefVideo(ref)-&gt;_aviheader-&gt;getFlags (refOffset, flags);
 }
 /**
     \fn getFrameSize
@@ -127,11 +122,11 @@
  
   ADM_TRANSLATE(getframeSize,frame);
   return _segments.getRefVideo(ref)-&gt;_aviheader-&gt;getFrameSize (refOffset, size);
-
-
 }
 
-
+/**
+    \fn setFlag
+*/
 uint8_t ADM_Composer::setFlag (uint32_t frame, uint32_t flags)
 {
     ADM_TRANSLATE(setFlag,frame);
@@ -174,7 +169,7 @@
   ret = STUBB-&gt;getVideoInfo (info);
   if (ret)
     {
-      info-&gt;nb_frames = _total_frames;
+      info-&gt;nb_frames = _segments.getNbFrames();
     }
   return ret;
 }
@@ -195,93 +190,8 @@
 {
   return STUBB-&gt;getBIH ();
 };
-/**
-    \fn sanityCheckRef
-//	Do a sanity check for copy mode
-//	Check that B frames did not loose there backward/forward ref frame
-// 	It is brute force as we only need to check begin/end of each segment
-//	But it should be fast anyway
-*/
-uint8_t		ADM_Composer::sanityCheckRef(uint32_t start, uint32_t end,uint32_t *fatal)
-{
-#if 0
-uint32_t flags,seg;
-uint32_t lastnonb=0,segnonB=0xffff;
-uint32_t forward=0,forwardseg=0xffff;
 
-uint8_t ok=0;
-uint32_t i=0;
-	*fatal=0;
-	// If it is not in PTS, no need to bother
-	if(!isReordered(start))
-	{
-		printf(&quot;Not reordered or no B frame, nothing to check\n&quot;);
-		return 1;
-	}
-	// If the last frames are B frames it is fatal
-	if(!getFlagsAndSeg (end-1, &amp;flags,&amp;seg))
-	{
-				printf(&quot;Cannot get flags for frame %&quot;LU&quot;\n&quot;,end-1);
-				goto _abt;
-	}
-	if(flags &amp; AVI_B_FRAME)
-	{
-		printf(&quot;Ending B frame -&gt; abort (%&quot;LU&quot;)\n&quot;,end-1);
-		*fatal=1;
-		return 0;
-	}
-	if(!getFlagsAndSeg (start, &amp;flags,&amp;seg))
-	{
-				printf(&quot;Cannot get flags for frame %&quot;LU&quot;\n&quot;,start);
-				goto _abt;
-	}
-	if(flags &amp; AVI_B_FRAME)
-	{
-		printf(&quot;Starting B frame -&gt; abort\n&quot;);
-		*fatal=1;
-		return 0;
-	}
-	for( i=start;i&lt;end;i++)
-	{
-			//printf(&quot;%08lu/%08lu\r&quot;,i,end-start);
-			if(!getFlagsAndSeg (i, &amp;flags,&amp;seg))
-			{
-				printf(&quot;Cannot get flags for frame %&quot;LU&quot;\n&quot;,i);
-				goto _abt;
-			}
-			if(flags &amp; AVI_B_FRAME)
-			{ 	// search if we have to send a I/P frame in adance
-				if(segnonB!=seg)
-				{
-					printf(&quot;bw failed! (%&quot;LU&quot;/%&quot;LU&quot;)\n&quot;,seg,segnonB);
-					 goto _abt;
-				}
-;
 
-				forwardseg=searchForwardSeg(i);
-				if(seg!=forwardseg)
-				{
-					printf(&quot;Fw failed! (%&quot;LU&quot;/%&quot;LU&quot;)\n&quot;,seg,forwardseg);
-					 goto _abt;
-				}
-			}
-			else // it is not a B frame and we have nothing on hold, sent it..
-			{
-				lastnonb=i;
-				segnonB=seg;
-			}
-	}
-	ok=1;
-_abt:
-	if(!ok)
-	{
-		printf(&quot;Frame %d has lost its fw/bw reference frame (%&quot;LU&quot;/%&quot;LU&quot;)\n&quot;,i,start,end);
-	}
-	return ok;
-#endif
-    return true;
-}
-
 /**
     \fn getVideoDuration
     \brief returns duration of the video track

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -36,27 +36,22 @@
 #define MODULE_NAME MODULE_EDITOR
 #include &quot;ADM_debug.h&quot;
 
-#include &quot;ADM_outputfmt.h&quot;
+//#include &quot;ADM_outputfmt.h&quot;
 #include &quot;ADM_edPtsDts.h&quot;
 
 vidHeader *ADM_demuxerSpawn(uint32_t magic,const char *name);
 
-extern uint8_t parseScript(char *name);
-uint8_t UI_SetCurrentFormat( ADM_OUT_FORMAT fmt );
-const char *VBR_MSG = QT_TR_NOOP(&quot;Avidemux detected VBR MP3 audio in this file. For keeping audio/video in sync, time map is needed. Build it now?\n\nYou can do it later with \&quot;Audio -&gt; Build VBR Time Map\&quot;.&quot;);
-//
-//
+//#define TEST_MPEG2DEC
+/**
+    \fn ADM_Composer
 
-#define TEST_MPEG2DEC
-
+*/
 ADM_Composer::ADM_Composer (void) : ADM_audioStream(NULL,NULL)
 {
 uint32_t type,value;
 
    packetBufferSize=0;
    packetBufferDts=ADM_NO_PTS;
-
-  _total_frames = 0;
   _audioseg = 0;
   _audiooffset = 0;
   _audioSample=0;
@@ -90,9 +85,6 @@
 uint8_t ADM_Composer::resetSeg( void )
 {
 	_segments.resetSegment();
-
-  	computeTotalFrames();
-//	dumpSeg();
 	return 1;
 }
 /**
@@ -237,11 +229,6 @@
     }
 
 
-//    fourCC::print( info.fcc );
-    _total_frames += info.nb_frames;
-
-
-
   // Update audio infos
   // an spawn the appropriate decoder
   //_________________________
@@ -421,129 +408,8 @@
   _segments.deleteAll();
   return 1;
 }
-#if 0
-/*
-        param:
-                source : source #
-                start : start frame in source #
-                nb    : nb frame to copy into segment
-*/
-uint8_t ADM_Composer::addSegment(uint32_t source,uint32_t start, uint32_t nb)
-{
-        // do some sanity check
-        if(_nb_segment==max_seg-1)
-	{
-	   _SEGMENT *s;
-            max_seg += MAX_SEG;
-            s = new _SEGMENT[max_seg];
-            memset (s, 0, sizeof(_SEGMENT)*max_seg);
-            memcpy(s,_segments,sizeof(_SEGMENT)*(max_seg-MAX_SEG));
-            delete _segments;
-            _segments = s;
-        }
-        if(_nb_video&lt;=source)
-        {
-                printf(&quot;[editor]: No such source %d/%d\n&quot;,source,_nb_video);
-                 return 0;
-        }
-        if(_videos[source]._nb_video_frames&lt;=start)
-        {
-                printf(&quot;[editor]:start out of bound %d/%d\n&quot;,start,_videos[source]._nb_video_frames);
-                 return 0;
-        }
-        if(_videos[source]._nb_video_frames&lt;start+nb)
-        {
-                printf(&quot;[editor]:end out of bound %d/%d\n&quot;,start+nb,_videos[source]._nb_video_frames);
-                 return 0;
-        }
-        // ok, let's go
-        _SEGMENT *seg=&amp;(_segments[_nb_segment]);
-        seg-&gt;_reference=source;
-        seg-&gt;_start_frame=start;
-        seg-&gt;_nb_frames=nb;
-        _nb_segment++;
-        updateAudioTrack (_nb_segment-1);
-        _total_frames=computeTotalFrames();
 
-        return 1;
-}
 /**
-______________________________________________________
-//  Remove frames , the frame are given as seen by GUI
-//  We remove from start to end -1
-// [start,end[
-//______________________________________________________
-*/
-uint8_t ADM_Composer::removeFrames (uint32_t start, uint32_t end)
-{
-
-  uint32_t
-    seg1,
-    seg2,
-    rel1,
-    rel2;
-  uint8_t
-    lastone =
-    0;
-
-  if (end == _total_frames - 1)
-    lastone = 1;
-
-  // sanity check
-  if (start &gt; end)
-    return 0;
-  //if((1+start)==end) return 0;
-
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (start, &amp;seg1, &amp;rel1) ||
-      !convFrame2Seg (end, &amp;seg2, &amp;rel2))
-    {
-      ADM_assert (0);
-    }
-  // if seg1 != seg2 we can just modify seg1 and seg2
-  if (seg1 != seg2)
-    {
-      // remove end of seg1
-
-      removeFrom (rel1, seg1, 1);
-      //  delete in between seg
-      for (uint32_t seg = seg1 + 1; seg &lt; (seg2); seg++)
-	_segments[seg]._nb_frames = 0;
-      // remove beginning of seg2
-      removeTo (rel2, seg2, lastone);
-    }
-  else
-    {
-      // it is in the same segment, split it...
-      // complete seg ?
-      if ((rel1 == _segments[seg1]._start_frame)
-	  &amp;&amp; (rel2 ==
-	      (_segments[seg1]._start_frame +
-	       _segments[seg1]._nb_frames - 1)))
-	{
-	  _segments[seg1]._nb_frames = 0;
-	}
-      else
-	{
-	  // split in between.... duh !
-	  duplicateSegment (seg1);
-	  //
-	  removeFrom (rel1, seg1, 1);
-	  removeTo (rel2, seg1 + 1, lastone);
-	}
-    }
-
-  // Crunch
-  crunch ();
-  sanityCheck ();
-  // Compute total nb of frame
-  _total_frames = computeTotalFrames ();
-  printf (&quot;\n %&quot;LU&quot; frames &quot;, _total_frames);
-  return 1;
-
-}
-#endif
-/**
     \fn getAudioStreamsInfo
     \brief Returns a copy of all audio trackes at frame frame
     call delete [] infos when you dont need them anymore
@@ -632,294 +498,8 @@
         v-&gt;currentAudioStream=newstream;
         return true;
 }
-#if 0
-/**
-______________________________________________________
-//
-//	Copy the start/eng seg  to clipboard
-//______________________________________________________
-*/
-uint8_t ADM_Composer::copyToClipBoard (uint32_t start, uint32_t end)
-{
 
-  uint32_t	    seg1,    seg2,    rel1,    rel2;
-  uint8_t    lastone =    0;
-uint32_t seg=0xfff;
-
-  if (end == _total_frames - 1)
-    lastone = 1;
-
-  // sanity check
-  if (start &gt; end)
-  {
-    printf(&quot;End &lt; Start \n&quot;);
-    return 0;
-   }
-  //if((1+start)==end) return 0;
-
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (start, &amp;seg1, &amp;rel1) ||
-      !convFrame2Seg (end, &amp;seg2, &amp;rel2))
-    {
-      ADM_assert (0);
-    }
-    _nb_clipboard=0;
-  // if seg1 != seg2 we can just modify seg1 and seg2
-  if (seg1 != seg2)
-    {
-    aprintf(&quot;Diff  seg: %&quot;LU&quot; /%&quot;LU&quot; from %&quot;LU&quot; to %&quot;LU&quot; \n&quot;,seg1,seg2,rel1,rel2);
-      // remove end of seg1
-	_clipboard[_nb_clipboard]._reference=_segments[seg1]._reference;
-	_clipboard[_nb_clipboard]._start_frame=rel1;
- 	_clipboard[_nb_clipboard]._nb_frames =_segments[seg]._nb_frames- (rel1 - _segments[seg]._start_frame);
-	_nb_clipboard++;
-      // copy  in between seg
-      for ( seg = seg1 + 1; seg &lt;=seg2; seg++)
-		memcpy(&amp;_clipboard[_nb_clipboard++], &amp;_segments[seg],sizeof(_segments[0]));
-      // Adjust nb frame for last seg
-      uint32_t l;
-      l=_nb_clipboard-1;
-	_clipboard[l]._nb_frames=rel2-_segments[seg2]._start_frame;
-    }
-  else
-    {
-      // it is in the same segment, split it...
-      // complete seg ?
-      if ((rel1 == _segments[seg1]._start_frame)
-	  &amp;&amp; (rel2 ==
-	      (_segments[seg1]._start_frame +
-	       _segments[seg1]._nb_frames - 1)))
-	{
-	  aprintf(&quot;Full seg: %&quot;LU&quot; from %&quot;LU&quot; to %&quot;LU&quot; \n&quot;,seg1,rel1,rel2);
-		memcpy(&amp;_clipboard[_nb_clipboard++], &amp;_segments[seg1],sizeof(_segments[0]));
-	}
-      else
-	{
-	  // we just take a part of one chunk
-	  aprintf(&quot;Same seg: %&quot;LU&quot; from %&quot;LU&quot; to %&quot;LU&quot; \n&quot;,seg1,rel1,rel2);
-	  memcpy(&amp;_clipboard[_nb_clipboard], &amp;_segments[seg1],sizeof(_segments[0]));
-	  _clipboard[_nb_clipboard]._start_frame=rel1;
-	  _clipboard[_nb_clipboard]._nb_frames=rel2-rel1;
-	_nb_clipboard++;
-	aprintf(&quot;clipboard: %&quot;LU&quot; \n&quot;,_nb_clipboard);
-	}
-    }
-	dumpSeg();
-  return 1;
-
-}
-uint8_t ADM_Composer::pasteFromClipBoard (uint32_t whereto)
-{
-uint32_t rel,seg;
-
-	if (!convFrame2Seg (whereto, &amp;seg, &amp;rel) )
-    	{
-      		ADM_assert (0);
-    	}
-	dumpSeg();
-
-	// past at frame 0
-	if(	seg==0 &amp;&amp; rel==_segments[0]._start_frame)
-	{
-		aprintf(&quot;Pasting at frame 0\n&quot;);
-		for(uint32_t i=0;i&lt;_nb_clipboard;i++)
-			duplicateSegment(seg);
-		memcpy(&amp;_segments[0],&amp;_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-	}
-	else
-	if(rel==_segments[seg]._start_frame+_segments[seg]._nb_frames )
-	{
-		aprintf(&quot;\n setting at the end of seg %&quot;LU&quot;\n&quot;,seg);
-		// we put it after OLD insert OLD+1
-		for(uint32_t i=0;i&lt;_nb_clipboard;i++)
-			duplicateSegment(seg);
-		memcpy(&amp;_segments[seg+1],&amp;_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-
-	}
-	else // need to split it
-	{
-		for(uint32_t i=0;i&lt;_nb_clipboard+1;i++)
-			duplicateSegment(seg);
-		memcpy(&amp;_segments[seg+1],&amp;_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-
-		// and the last one
-		_segments[seg+_nb_clipboard+1]._nb_frames=(_segments[seg]._start_frame+_segments[seg]._nb_frames)-rel;
-		_segments[seg+_nb_clipboard+1]._start_frame=rel;
-		// adjust the current one
-		_segments[seg]._nb_frames=rel-_segments[seg]._start_frame;
-	}
-	 _total_frames = computeTotalFrames ();
-	for(uint32_t i=0;i&lt;_nb_segment;i++)
- 		updateAudioTrack(i);
-  dumpSeg();
-  return 1;
-
-}
-
-//____________________________________
-//      Duplicate a segment
-//____________________________________
-
-uint8_t ADM_Composer::duplicateSegment (uint32_t segno)
-{
-
-  for (uint32_t i = _nb_segment; i &gt; segno; i--)
-    {
-
-      memcpy (&amp;_segments[i], &amp;_segments[i - 1], sizeof (_SEGMENT));
-
-    }
-  _nb_segment++;
-  return 1;
-
-
-}
-
-//____________________________________
-//      Remove empty segments
-//____________________________________
-uint8_t ADM_Composer::crunch (void)
-{
-  uint32_t
-    seg =
-    0;
-  while (seg &lt; _nb_segment)
-    {
-      if (_segments[seg]._nb_frames == 0)
-	{
-	  //
-
-	  for (uint32_t c = seg + 1; c &lt; _nb_segment; c++)
-	    {
-	      memcpy (&amp;_segments[c - 1], &amp;_segments[c], sizeof (_SEGMENT));
-	    }
-	  _nb_segment--;
-
-	}
-      else
-	{
-	  seg++;
-	}
-    }
-  // Remove last seg if there is only one frame in it
-  if (_nb_segment)
-    {
-      if (_segments[_nb_segment - 1]._nb_frames == 1)
-	{
-	  _nb_segment--;
-	}
-    }
-  return 1;
-
-}
-#endif
-//____________________________________
-//      Remove empty segments
-//____________________________________
-uint32_t ADM_Composer::computeTotalFrames (void)
-{
-#if 0
-  uint32_t
-    seg,
-    tf =
-    0;
-  for (seg = 0; seg &lt; _nb_segment; seg++)
-    {
-      tf += _segments[seg]._nb_frames;
-
-    }
-
-  return tf;
-#endif
-}
-#if 0
-//____________________________________
-//      Remove empty segments
-//____________________________________
-void
-ADM_Composer::dumpSeg (void)
-{
-  uint32_t seg;
-  printf (&quot;\n________Video______________&quot;);
-  for (seg = 0; seg &lt; _nb_video; seg++)
-    {
-//      printf (&quot;\n Video : %&quot;LU&quot;, nb video  :%&quot;LU&quot;, audio size:%&quot;LU&quot;  audioDuration:%&quot;LU&quot;&quot;,
-//	      seg, _videos[seg]._nb_video_frames, _videos[seg]._audio_size,_videos[seg]._audio_duration);
-
-    }
-
-  printf (&quot;\n______________________&quot;);
-  for (seg = 0; seg &lt; _nb_segment; seg++)
-    {
-      printf
-	(&quot;\n Seg : %&quot;LU&quot;, ref: %&quot;LU&quot; start :%&quot;LU&quot;, size:%&quot;LU&quot; audio size : %&quot;LU&quot; audio start : %&quot;LU&quot; duration:%&quot;LLU&quot;&quot;,
-	 seg, _segments[seg]._reference, _segments[seg]._start_frame,
-	 _segments[seg]._nb_frames, _segments[seg]._audio_size,
-	 _segments[seg]._audio_start,
-	  _segments[seg]._audio_duration
-	 );
-
-    }
-  printf (&quot;\n_________Clipboard_____________&quot;);
-  for (seg = 0; seg &lt; _nb_clipboard; seg++)
-    {
-      printf
-	(&quot;\n Seg : %&quot;LU&quot;, ref: %&quot;LU&quot; start :%&quot;LU&quot;, size:%&quot;LU&quot; audio size : %&quot;LU&quot; audio start : %&quot;LU&quot;  duration:%&quot;LLU&quot;\n&quot;,
-	 seg, _clipboard[seg]._reference, _clipboard[seg]._start_frame,
-	 _clipboard[seg]._nb_frames, _clipboard[seg]._audio_size,
-	 _clipboard[seg]._audio_start,
-	 _segments[seg]._audio_duration);
-
-    }
-
-
-}
-
-// Clear from position to/from
 //
-// 0------To------end
-//  xxxxxx removed
-
-uint8_t ADM_Composer::removeTo (uint32_t to, uint32_t seg, uint8_t included)
-{
-  uint32_t
-    ref;
-
-  ADM_assert (checkInSeg (seg, to));
-  ref = _segments[seg]._start_frame;
-  _segments[seg]._start_frame = to;
-  if (included)
-    _segments[seg]._start_frame++;
-  _segments[seg]._nb_frames -= (_segments[seg]._start_frame - ref);
-
-
-  updateAudioTrack (seg);
-
-//---------------------------------------
-
-
-
-  return 1;
-}
-
-//
-// 0------From------end
-//            xxxxxx removed
-
-uint8_t
-  ADM_Composer::removeFrom (uint32_t from, uint32_t seg, uint8_t included)
-{
-  ADM_assert (checkInSeg (seg, from));
-  _segments[seg]._nb_frames = (from - _segments[seg]._start_frame);
-
-  if (!included)
-    _segments[seg]._nb_frames++;
-
-  updateAudioTrack (seg);
-  return 1;
-}
-#endif
-//
 //      Update the real size of audio track by computing the
 // delta between sync @end and <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">sync at begin</A>
 // We also upate the duration of the selected part
@@ -950,43 +530,7 @@
 }
 
 
-#if 0
-//__________________________________________________
-// check that the given frame is inside the segment
-//__________________________________________________
-uint8_t ADM_Composer::checkInSeg (uint32_t seg, uint32_t frame)
-{
-  if (frame &lt; _segments[seg]._start_frame)
-    return 0;
-  if (frame &gt; (_segments[seg]._nb_frames + _segments[seg]._start_frame))
-    return 0;
-  return 1;
 
-}
-uint8_t	ADM_Composer::isIndexable( void)
-{
-	if(!_nb_video) ADM_assert(0);
-	return _videos[0].decoder-&gt;isIndexable();
-
-}
-
-uint8_t ADM_Composer::sanityCheck (void)
-{
-  uint32_t
-    ref,
-    seg;
-
-  for (seg = 0; seg &lt; _nb_segment; seg++)
-    {
-      ref = _segments[seg]._start_frame + _segments[seg]._nb_frames - 1;
-
-    }
-  return 1;
-
-
-}
-#endif
-
 //_________________________________________
 uint8_t		ADM_Composer::setEnv(_ENV_EDITOR_FLAGS newflag)
 {
@@ -1006,74 +550,7 @@
 		return r;
 
 }
-#if BAZOOKA
-//_________________________________________
-//    Try indexing the file, return 1 if file successfully indexed
-//              0 else
-//_________________________________________
-//
-uint8_t         ADM_Composer::tryIndexing(const char *name, const char *idxname)
-{
- unsigned int autoidx = 0;
-      prefs-&gt;get(FEATURE_TRYAUTOIDX,&amp;autoidx);
-      if (!autoidx)
-        {
-          if (!GUI_Question (QT_TR_NOOP(&quot;This looks like mpeg\n Do you want to index it?&quot;)))
-            {
-                return 0;
-            }
-		}
-          char      *idx;
-          DMX_TYPE  type;
-          uint32_t  nbTrack=0,audioTrack=0;
-          MPEG_TRACK *tracks=NULL;
-          uint8_t r=1;
 
-                if(!dmx_probe(name,&amp;type,&amp;nbTrack,&amp;tracks))
-                {
-                        printf(&quot;This is not mpeg\n&quot;);
-                        return 0;
-                }
-
-
-                if(type==DMX_MPG_PS || type==DMX_MPG_TS || type==DMX_MPG_TS2)
-                {
-                       if(nbTrack&gt;2)
-		       if(autoidx)
-			{
-				printf(&quot;Using autoindex\n&quot;);
-			}
-/*                        else
-		       {
-
-                        if(!DIA_dmx(name,type,nbTrack,tracks,&amp;audioTrack))
-                        {
-                                delete [] tracks;
-                                return 0;
-                        }
-		       }
-*/
-                        audioTrack=0;
-                }
-		if( idxname ){
-			idx=new char[strlen(idxname)];
-			strcpy(idx,idxname);
-		}else{
-                	idx=new char[strlen(name)+5];
-                	strcpy(idx,name);
-                	strcat(idx,&quot;.idx&quot;);
-		}
-
-                r=dmx_indexer(name,idx,audioTrack,0,nbTrack,tracks);
-
-                if(tracks)
-                        delete [] tracks;
-                delete [] idx;
-
-                if(!r) GUI_Error_HIG(QT_TR_NOOP(&quot;Indexing failed&quot;), NULL);
-                return r;
-}
-#endif
 /**
       If a parameter has changed, rebuild the duration of the streams
       It can happen, for example in case of SBR audio such as AAC
@@ -1108,5 +585,16 @@
     wantedPts+=vid-&gt;timeIncrementInUs*count;
     return wantedPts;
 }
+/**
+    \fn getCurrentFramePts
+    \brief Get the PTS of current frame
+
+*/
+uint64_t    ADM_Composer::getCurrentFramePts(void)
+{
+    _SEGMENT *seg=_segments.getCurrentSeg();
+    _VIDEOS *vid=_segments.getRefVideo(seg-&gt;_reference);
+    return vid-&gt;lastDecodedPts;
+}
 //
 //

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-14 05:46:21 UTC (rev 5380)
@@ -69,8 +69,6 @@
   					ADM_PP 		_pp;
 					ADMImage	*_imageBuffer;
   					uint8_t		decodeCache(uint32_t frame,uint32_t seg, ADMImage *image);
-  					uint32_t 	_total_frames;
-  					uint32_t 	_audio_size;
   					// _audiooffset points to the offset / the total segment
   					// not the used part !
   					uint32_t  _audioseg;
@@ -81,34 +79,15 @@
        				uint32_t _lastseg,_lastframe,_lastlen;
 
                     ADM_audioStreamTrack *getTrack(uint32_t i);
-#if 0
-                                            {
-                                                if(!_videos[i].audioTracks) return NULL;
-                                                return _videos[i].audioTracks[_videos[i].currentAudioStream];
-                                            }
-#endif
-                    ADMImage        *_scratch;
-                    uint8_t 	crunch( void)																			;
-                    uint8_t 	duplicateSegment( uint32_t segno);
-                    uint32_t 	computeTotalFrames(void) ;
-
-                    uint8_t 	removeTo( 	uint32_t to, uint32_t seg,uint8_t included);
-                    uint8_t 	removeFrom( uint32_t from, uint32_t seg,uint8_t included);
-                    uint8_t 	checkInSeg( uint32_t seg, uint32_t frame);
-                    uint8_t 	sanityCheck( void);
+                    ADMImage    *_scratch;																		;
                     uint8_t  	updateAudioTrack(uint32_t seg);			   	
                     void 		deleteAllVideos(void );
-
                     uint8_t 	getMagic(const char *name,uint32_t *magic);
-
                     uint32_t 	searchForwardSeg(uint32_t startframe);
-                    uint8_t     tryIndexing(const char *name, const char *idxname=NULL);
                     bool        rederiveFrameType(vidHeader *demuxer);
 
   public:
                     bool        hasVBRAudio(void);
-                    uint8_t     addSegment(uint32_t source,uint32_t start, uint32_t nb);
-                    uint8_t     deleteAllSegments(void);
                     bool     	getExtraHeaderData(uint32_t *len, uint8_t **data);
                     uint32_t    getPARWidth(void);
                     uint32_t    getPARHeight(void);
@@ -116,27 +95,13 @@
   								ADM_Composer();
   				virtual 			~ADM_Composer();
                     void		clean( void );
-                    void		dumpSeg(void);
                     uint8_t     saveAsScript (const char *name, const char *out);
                     uint8_t 	saveWorbench(const char *name);
                     uint8_t 	loadWorbench(const char *name);
                     uint8_t     resetSeg( void );
-                    uint8_t	    reorder( void );
-                    uint8_t	    isReordered( uint32_t framenum ) {return true;}
-                    uint8_t	    isIndexable( void);
-            //_______________________
-            // specific to composer
-            //_______________________
                     bool     	addFile (const char *name);
                     uint8_t 	cleanup( void);
                     bool 	    isMultiSeg( void);
-                    uint8_t 	removeFrames(uint32_t start,uint32_t end);
-                    uint8_t 	addFrameFrom(uint32_t to,uint32_t frombegin,uint32_t fromend);
-                    uint8_t 	copyToClipBoard (uint32_t start, uint32_t end);
-                    uint8_t 	pasteFromClipBoard (uint32_t whereto);
-            //_____________________________
-  				// navigation &amp; frame functions
-  				//_____________________________
 /************************************* Markers *****************************/
 private:        
                     uint64_t    markerAPts,markerBPts;
@@ -151,7 +116,7 @@
                     uint32_t    currentFrame;
 public:
                     uint32_t    getCurrentFrame(void);
-                    
+                    uint64_t    getCurrentFramePts(void);
                     bool        setCurrentFrame(uint32_t frame);
                     bool        GoToIntra(uint32_t frame);
                     bool        GoToTime(uint64_t time);
@@ -175,26 +140,21 @@
                     bool     	getNextPicture(ADMImage *out,uint32_t ref);
                                 /// Get again last decoded picture
                     bool        getSamePicture(ADMImage *out,uint32_t ref);
+
+                    bool        searchNextKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
 /************************************ Internal ******************************/
                     uint8_t 	getFrame(uint32_t   framenum,ADMCompressedImage *img,uint8_t *isSequential);
                     
                 
                     uint64_t 	getTime(uint32_t fn);
                     uint32_t 	getFlags(uint32_t frame,uint32_t *flags);
-                    uint8_t   	isSequential (uint32_t framenum);
+
                             // B follow A with just Bframes in between
-                    uint8_t 	sequentialFramesB(uint32_t frameA,uint32_t frameB);
                     uint32_t 	getFlagsAndSeg (uint32_t frame, 
                                 uint32_t * flags,uint32_t *segs);
                     uint8_t  	setFlag(uint32_t frame,uint32_t flags);
                     uint8_t	    updateVideoInfo(aviInfo *info);
-
                     uint8_t  	getFrameSize(uint32_t frame,uint32_t *size) ;
-                    uint8_t		sanityCheckRef(uint32_t start, uint32_t end,
-                                uint32_t *fatal);
-                                            uint8_t         hasPtsDts(uint32_t ); // Return 1 if the container gives PTS &amp; DTS info
-                                            uint32_t        ptsDtsDelta(uint32_t framenum) ;
-                //*******************************************	
                     uint32_t 	getSpecificMpeg4Info( void );
 /************************************ audioStream ******************************/
 protected:
@@ -235,7 +195,8 @@
 /***************************************** Seeking *****************************/            
 		  			bool			getPKFrame(uint32_t *frame);
 					bool			getNKFrame(uint32_t *frame);
-					
+                    bool			getNKFramePTS(uint64_t *frameTime);
+                    bool			getPKFramePTS(uint64_t *frameTime);
                     bool			getUncompressedFrame(uint32_t frame,ADMImage *out,uint32_t *flagz=NULL);
 public:
                     
@@ -246,14 +207,7 @@
 /******************************* Misc ************************************/				
 					uint8_t			setEnv(_ENV_EDITOR_FLAGS newflag);
 					uint8_t			getEnv(_ENV_EDITOR_FLAGS newflag);
-					decoders 		*rawGetDecoder(uint32_t frame);
 /******************************* /Misc ************************************/				
-/***** OBSOLETE API *****/
-/***** OBSOLETE API *****/
-/***** OBSOLETE API *****/
-protected:					// Obsolete									
-                    uint8_t			searchNextKeyFrame(uint32_t in,uint32_t *oseg, uint32_t * orel);
-                    uint8_t			searchPreviousKeyFrame(uint32_t in,uint32_t *oseg, uint32_t * orel);
 
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -22,6 +22,8 @@
  #include &quot;ADM_pp.h&quot;
  #include &quot;ADM_colorspace.h&quot;
 
+#include &quot;ADM_audiocodec/ADM_audiocodec.h&quot;
+
 ADM_EditorSegment::ADM_EditorSegment(void)
 {
 
@@ -79,65 +81,49 @@
     return true;
 }
 
-/**
-    \fn deleteAll
-    \brief Delete all segments &amp; ref video
-*/
-bool        ADM_EditorSegment::deleteAll(void)
-{
-#warning todo
-    return true;
-}
 
-#if 0
 /**
-	\fn Purge all videos
+	\fn deleteAll
     \brief delete datas associated with all video
 */
-void getFlags::deleteAllVideos (void)
+bool ADM_EditorSegment::deleteAll (void)
 {
-
-  for (uint32_t vid = 0; vid &lt; _videos.size(); vid++)
+  ADM_info(&quot;[Editor] Deleting all video\n&quot;);
+  int n=videos.size();
+  for (uint32_t vid = 0; vid &lt; n; vid++)
     {
-
+        _VIDEOS *v=&amp;(videos[vid]);
       // if there is a video decoder...
-      if (_videos[vid].decoder)
-            delete _videos[vid].decoder;
-      if(_videos[vid].color)
-            delete _videos[vid].color;
-      // prevent from crashing
-      _videos[vid]._aviheader-&gt;close ();
-      delete _videos[vid]._aviheader;
-      if(_videos[vid]._videoCache)
-      	delete  _videos[vid]._videoCache;
-      _videos[vid]._videoCache=NULL;
+      if (v-&gt;decoder)
+            delete v-&gt;decoder;
+      if(v-&gt;color)
+            delete v-&gt;color;
+      v-&gt;_aviheader-&gt;close ();
+      delete v-&gt;_aviheader;
+      if(v-&gt;_videoCache)
+      	delete  v-&gt;_videoCache;
+      v-&gt;_videoCache=NULL;
+      v-&gt;color=NULL;
+      v-&gt;decoder=NULL;
+      v-&gt;_aviheader=NULL;
      // Delete audio codec too
      // audioStream will be deleted by the demuxer
-      if(_videos[vid].audioTracks)
+      if(v-&gt;audioTracks)
       {
-            for(int i=0;i&lt;_videos[vid].nbAudioStream;i++)
+            for(int i=0;i&lt;v-&gt;nbAudioStream;i++)
             {
-                delete _videos[vid].audioTracks[i];
+                delete v-&gt;audioTracks[i];
             }
-            delete [] _videos[vid].audioTracks;
-            _videos[vid].audioTracks=NULL;
+            delete [] v-&gt;audioTracks;
+            v-&gt;audioTracks=NULL;
       }
     }
 
-   if(_videos.size())
-    {
-        _videos.erase(_videos.begin(),_videos.begin()+_videos.size()-1);
-    }
+    videos.clear();
+    return true;
+}
 
 
-  if(_imageBuffer)
-  	delete _imageBuffer;
-  _imageBuffer=NULL;
-
-}
-
-}
-#endif
 /**
     \fn resetSegment
     \brief Redo a 1:1 mapping between videos and segments
@@ -155,11 +141,21 @@
         memset(&amp;seg,0,sizeof(seg));
         seg._durationUs=vid-&gt;_aviheader-&gt;getVideoDuration();
         seg._reference=i;
+        segments.push_back(seg);
     }
     updateStartTime();
     return true;
 }
 /**
+    \fn getSegment
+    \brief getRefVideo
+*/
+_SEGMENT     *ADM_EditorSegment::getSegment(int i)
+{
+    ADM_assert(i&lt;segments.size());
+    return &amp;(segments[i]);
+}
+/**
     \fn getRefVideo
     \brief getRefVideo
 */
@@ -253,4 +249,36 @@
     return true;
 
 }
+/**
+    \fn ~ADM_audioStreamTrack
+*/
+ ADM_audioStreamTrack::~ADM_audioStreamTrack()
+    {
+        stream=NULL;
+        info=NULL;   // These 2 are destroyed by the demuxer itself
+        if(codec) 
+        {
+            delete codec;
+            codec=NULL;
+        }
+    }
+/**
+    \fn getCurrentSeg
+*/
+_SEGMENT   * ADM_EditorSegment::getCurrentSeg(void)
+{
+    return &amp;(segments[0]);
+}
+
+bool        ADM_EditorSegment::convertLinearTimeToSeg(  uint64_t frameTime, uint32_t *seg, uint64_t *segTime)
+{
+    *seg=0;
+    *segTime=frameTime;
+    return true;
+}
+bool        ADM_EditorSegment::convertSegTimeToLinear(  uint32_t seg,uint64_t segTime, uint64_t *frameTime)
+{
+    *frameTime=segTime;
+    return true;
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-14 05:46:21 UTC (rev 5380)
@@ -40,16 +40,7 @@
 
 public:
     ADM_audioStreamTrack() {memset(this,0,sizeof(*this));}
-    ~ADM_audioStreamTrack()
-    {
-        stream=NULL;
-        info=NULL;   // These 2 are destroyed by the demuxer itself
-        if(codec) 
-        {
-            delete codec;
-            codec=NULL;
-        }
-    }
+virtual    ~ADM_audioStreamTrack();
 };
 /**
     \struct _VIDEOS
@@ -89,7 +80,7 @@
  	uint64_t							_refStartTimeUs;  /// Starting time in reference
     uint64_t                            _startTimeUs;     /// Start time in current (=sum(_duration of previous seg))
 	uint64_t							_durationUs;      ///
-
+    uint32_t                            _nbFrame;
 }_SEGMENT;
 /*
     Use vectors to store our videos &amp; segments
@@ -106,6 +97,7 @@
         ListOfSegments segments;
         ListOfVideos   videos;
         bool           updateStartTime(void);
+        uint32_t       currentSeg;
 
 public:
                         ADM_EditorSegment(void);
@@ -117,14 +109,22 @@
             _VIDEOS     *getRefVideo(int i);
             int         getNbRefVideos(void);
 
+            _SEGMENT    *getSegment(int i);
             int         getNbSegments(void);
+
             uint64_t    getTotalDuration(void);
             uint32_t    getNbFrames(void);
 
             bool        getRefFromTime(uint64_t time,uint32_t *refVideo, uint64_t *offset);
             bool        getRefFromFrame(uint32_t frame,uint32_t *refVideo, uint32_t *frameOffset);
+
             bool        getFrameFromRef(uint32_t *frame,uint32_t refVideo, uint32_t frameOffset);
 
+
+            bool        convertLinearTimeToSeg(  uint64_t frameTime, uint32_t *seg, uint64_t *segTime);
+            bool        convertSegTimeToLinear(  uint32_t seg,uint64_t segTime, uint64_t *frameTime);
+
+            _SEGMENT    *getCurrentSeg(void);
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -623,11 +623,22 @@
 */
 bool admPreview::nextKeyFrame(void)
 {
+    uint64_t pts=getCurrentPts();
+    ADM_info(&quot;Current PTS :%&quot;LLD&quot; ms\n&quot;,pts/1000LL);
+    if(false==video_body-&gt;getNKFramePTS(&amp;pts))
+    {
+        ADM_warning(&quot;Cannot find next keyframe\n&quot;);
+        return false;
+    }
+    ADM_info(&quot;next kf PTS :%&quot;LLD&quot; ms\n&quot;,pts/1000LL);
+    return true;
+/*
     uint32_t frame=video_body-&gt;getCurrentFrame();
     if(!video_body-&gt;getNKFrame(&amp;frame)) return false;
     if(!video_body-&gt;GoToIntra(frame)) return false;
     video_body-&gt;setCurrentFrame(frame);
     samePicture();
+*/
     return true;
 }
 /**
@@ -636,11 +647,13 @@
 */
 bool admPreview::previousKeyFrame(void)
 {
+/*
     uint32_t frame=video_body-&gt;getCurrentFrame();
     if(!video_body-&gt;getPKFrame(&amp;frame)) return false;
     if(!video_body-&gt;GoToIntra(frame)) return false;
     video_body-&gt;setCurrentFrame(frame);
     samePicture();
+*/
     return true;
 }/**
     \fn previousFrame
@@ -663,7 +676,7 @@
         }
         return false;
     }
-
+#if 0
     // Else go to the previous  keyframe...
     if(!video_body-&gt;getPKFrame(&amp;frame)) return false;
     if(!video_body-&gt;GoToIntra(frame)) return false;
@@ -685,6 +698,7 @@
         renderUpdateImage(rdrImage-&gt;data,zoom);
         return true;
     }
+#endif
     return false;
 }
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -500,7 +500,7 @@
         if(argc != 0)
                 return JS_FALSE;
         enterLock();
-        if(!video_body-&gt;isReordered(0)) // already done
+//        if(!video_body-&gt;isReordered(0)) // already done
         {
           //video_body-&gt;rebuildFrameType();
         }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -239,7 +239,7 @@
 
     } else
       {
-	  if (!video_body-&gt;getPKFrame(&amp;frame))
+//	  if (!video_body-&gt;getPKFrame(&amp;frame))
 	    {
 		printf(&quot;[GUI_GoToKFrame] failed for frame %u\n&quot;, frame);
 		return;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002590.html">[Avidemux-svn-commit] r5379 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core:	include src
</A></li>
	<LI>Next message: <A HREF="002592.html">[Avidemux-svn-commit] r5381 - in	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2591">[ date ]</a>
              <a href="thread.html#2591">[ thread ]</a>
              <a href="subject.html#2591">[ subject ]</a>
              <a href="author.html#2591">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
