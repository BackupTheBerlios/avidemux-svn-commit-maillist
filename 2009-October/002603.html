<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5392 - in	branches/avidemux_2.6_branch_mean/avidemux/common: .	ADM_editor ADM_muxerGate/src ADM_videoFilter2
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-October/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5392%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux/common%3A%20.%0A%09ADM_editor%20ADM_muxerGate/src%20ADM_videoFilter2&In-Reply-To=%3C200910201326.n9KDQnrF003911%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002602.html">
   <LINK REL="Next"  HREF="002604.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5392 - in	branches/avidemux_2.6_branch_mean/avidemux/common: .	ADM_editor ADM_muxerGate/src ADM_videoFilter2</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5392%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux/common%3A%20.%0A%09ADM_editor%20ADM_muxerGate/src%20ADM_videoFilter2&In-Reply-To=%3C200910201326.n9KDQnrF003911%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5392 - in	branches/avidemux_2.6_branch_mean/avidemux/common: .	ADM_editor ADM_muxerGate/src ADM_videoFilter2">mean at mail.berlios.de
       </A><BR>
    <I>Tue Oct 20 15:26:49 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002602.html">[Avidemux-svn-commit] r5391 - in	branches/avidemux_2.6_branch_mean/avidemux/common:	ADM_commonUI ADM_editor ADM_muxerGate/src
</A></li>
        <LI>Next message: <A HREF="002604.html">[Avidemux-svn-commit] r5393 - in	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2603">[ date ]</a>
              <a href="thread.html#2603">[ thread ]</a>
              <a href="subject.html#2603">[ subject ]</a>
              <a href="author.html#2603">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-10-20 15:26:48 +0200 (Tue, 20 Oct 2009)
New Revision: 5392

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
Log:
[Editor] huge cleanup in editor api to only handle time, utterly boken

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -1,13 +1,10 @@
 /***************************************************************************
-                          ADM_edRender.cpp  -  description
-                             -------------------
-     This file renders the compressed video depending on the availabilty of
-     		CODECs.      It also deals with key frame and stuff
+    \file  ADM_edRender.cpp  
+    \brief handle decoding by masking the editor segments (appended video, cut, etc..)
+    \author mean (c) 2002/2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
 
+    
 
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
  ***************************************************************************/
 
 /***************************************************************************
@@ -29,878 +26,188 @@
 #endif
 
 #include &quot;ADM_pp.h&quot;
-
-// FIXME BADLY !!!
-// This should be in a context somewhere
-static uint8_t compBuffer[MAXIMUM_SIZE * MAXIMUM_SIZE * 3];
 /**
-        \fn GoToIntra
-        \brief Go to frame which must be an intra
-        @param frame is framenumber as seen by user
-        \return true on success, false on error
+    \fn recalibrate
+    \brief Convert time given in time from absolute ref video to linear time
 */
-bool        ADM_Composer::GoToIntra(uint32_t frame)
+static void recalibrate(uint64_t *time,_SEGMENT *seg)
 {
-uint32_t relframe, ref, flags, len;
+int64_t t=(int64_t)*time;
+        if(*time==ADM_NO_PTS) return;
 
-    if(_segments.getRefFromFrame(frame,&amp;ref,&amp;relframe)==false)
-    {
-        ADM_warning(&quot; Cannot convert frame %&quot;LU&quot;\n&quot;,frame);
-        return false;
-    }
-    return DecodePictureUpToIntra(relframe,ref);
+        t-=seg-&gt;_refStartTimeUs;
+        if(t&lt;0)
+        {
+            ADM_warning(&quot;Segment time is negative!\n&quot;);
+            t=0;
+        }
+        t+=seg-&gt;_startTimeUs;
+        *time=(uint64_t )t;
 }
 /**
-    \fn GoToTime
-    \brief Go to time time (just before)
-    \return true on success, false on error
+    \fn updateImageTiming
 */
-bool        ADM_Composer::GoToTime(uint64_t time)
+bool updateImageTiming(_SEGMENT *seg,ADMImage *image)
 {
-    // 1st go to the previous intra...
-      uint32_t frame=searchFrameBefore(time+1);
-      while(frame)
-      {
-            uint32_t flags;
-                getFlags(frame,&amp;flags);
-                if(flags &amp; AVI_KEY_FRAME) break;
-                frame--;
-      }
-        // Now go forward if needed
-#warning todo fixme!
-    printf(&quot;[Composer:GoToTime] Going to frame %&quot;LU&quot;\n&quot;,frame);
-    return GoToIntra(frame);
+    recalibrate(&amp;(image-&gt;Pts),seg);
+//    recalibrate(&amp;(image-&gt;Dts),seg);
+    return true;
 }
 /**
     \fn GoToIntraTime
     \brief Go to an intra at time time (exact)
     \return true on success, false on error
 */
-bool        ADM_Composer::GoToIntraTime(uint64_t time)
+bool        ADM_Composer::goToIntraTimeVideo(uint64_t time)
 {
-    // 1st go to the previous intra...
-      uint32_t frame=searchFrameAt(time);
-    ADM_info(&quot;When looking for frame at %&quot;LLU&quot; ms, found frame %&quot;LU&quot; as candidate\n&quot;,time,frame);
-    return GoToIntra(frame);
-}
-/**
-    \fn NextPicture
-    \brief decode &amp; returns the next picture
-*/
-bool        ADM_Composer::NextPicture(ADMImage *image)
-{
-    return getNextPicture(image,0);
-
-}
-/**
-    \fn samePicture
-    \brief returns the last already decoded picture
-*/
-bool        ADM_Composer::samePicture(ADMImage *image)
-{
-    return getSamePicture(image,0);
-
-}
-/**
-        \fn getCompressedPicure
-        \brief bypass decoder and directly get the source image
-
-*/
-bool        ADM_Composer::getCompressedPicure(ADMCompressedImage *img)
-{
-    return false;
-#if 0
-uint32_t ref = 0,relative=0;
-    if(false==_segments.getRefFromFrame(framenum,&amp;ref,&amp;relative))
+    uint32_t s;
+    uint64_t segTime;
+    // Search the seg ..;
+    if(false==_segments.convertLinearTimeToSeg(time,&amp;s,&amp;segTime))
     {
-        ADM_warning(&quot;[getCompressedPicure] Cannot get ref+frame to frame %&quot;LD&quot;\n&quot;,framenum);
+        ADM_warning(&quot;GoToIntraTime failed!\n&quot;);
         return false;
     }
-    _VIDEOS *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid-&gt;_aviheader;
+    _SEGMENT *seg=_segments.getSegment(s);
+    ADM_assert(seg);
+    _VIDEOS *ref=_segments.getRefVideo(seg-&gt;_reference);
+    ADM_assert(ref);
+    //
 
-    img-&gt;cleanup(framenum);
+    uint64_t refTime=seg-&gt;_refStartTimeUs+segTime;
 
-    if (!demuxer-&gt;getFrame (relative,img)) return false;
-    return true;
-#endif
-}
-//***************************** Internal API**************************
-/**
-    \fn DecodePictureUpToIntra
-    \brief Decode pictures from frameno, which must be an intra and on
-            until the decoded frameno is popped by the decoder
-
-    @param frame, framenumber relative to video ref (i.e. from its beginning)
-    @param ref  , video we are dealing with
-    returns true on success
-            fail on error
-
-*/
-bool ADM_Composer::DecodePictureUpToIntra(uint32_t frame,uint32_t ref)
-{
-  uint8_t ret = 0;
-  EditorCache   *cache;
-  ADMImage	*result;
-  uint32_t  flags;
-  ADMCompressedImage img;
-
-    // PlaceHolder...
-    img.data=compBuffer;
-    img.cleanup(frame);
-
-    printf(&quot;[EditorRender] DecodeUpToInta %u ref:%u\n&quot;,frame,ref);
-	_VIDEOS *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid-&gt;_aviheader;
-	cache=_segments.getRefVideo(ref)-&gt;_videoCache;
-	ADM_assert(cache);
-    // Make sure frame is an intra
-    demuxer-&gt;getFlags(frame,&amp;flags);
-    ADM_assert(flags==AVI_KEY_FRAME);
-
-    bool found=false;
-    vid-&gt;lastSentFrame=frame;
-    uint32_t nbFrames=vid-&gt;_nb_video_frames;
-    aprintf(&quot;[EditorRender] DecodeUpToIntra flushing cache &amp; codec\n&quot;);
-    cache-&gt;flush();
-    vid-&gt;decoder-&gt;flush();
-    // The PTS associated with our frame is the one we are looking for
-    uint64_t wantedPts=vid-&gt;_aviheader-&gt;estimatePts(frame);
-    uint32_t tries=15+7; // Max Ref frames for H264 + MaxRecovery , let's say 7 is ok for recovery
-    bool syncFound=false;
-    while(found==false &amp;&amp; tries--)
+    uint32_t frame=_segments.intraTimeToFrame(seg-&gt;_reference,time);       
+    if(false==switchToSegment(s))
     {
-        // Last frame ? if so repeat
-        if(vid-&gt;lastSentFrame&gt;=nbFrames-1) vid-&gt;lastSentFrame=nbFrames-1;
-        // Fetch frame
-         aprintf(&quot;[Editor] Decoding  frame %u\n&quot;,vid-&gt;lastSentFrame);
-         
-         if (!demuxer-&gt;getFrame (vid-&gt;lastSentFrame,&amp;img))
-         {
-                printf(&quot;[DecodePictureUpToIntra] getFrame failed for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
-                //cache-&gt;flush();
-                return false;
-         }
-         // Now uncompress it...
-         result=cache-&gt;getFreeImage();
-         if(frame==0) // out first frame, make sure it starts black to avoid the all green effect
-         {
-            result-&gt;blacken();
-         }
-         if(!result)
-         {
-                printf(&quot;[DecodePictureUpToIntra] Cache full for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
-                return false;
-          }
-           aprintf(&quot;[Decoder] Demuxer Frame %&quot;LU&quot; pts=%&quot;LLU&quot; ms, %&quot;LLU&quot; us\n&quot;,vid-&gt;lastSentFrame,img.demuxerPts/1000,
-                                                                    img.demuxerPts);
-          if(!decompressImage(result,&amp;img,ref))
-          {
-             printf(&quot;[DecodePictureUpToIntra] decode error for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
-             //cache-&gt;dump();
-             cache-&gt;invalidate(result);
-             //cache-&gt;dump();
-             vid-&gt;lastSentFrame++;
-             continue;
-          }else
-            {
-                cache-&gt;updateFrameNum(result,vid-&gt;lastSentFrame);
-                uint64_t pts=result-&gt;Pts;
-                aprintf(&quot;[Decoder] Decoder Frame %&quot;LU&quot; pts=%&quot;LLU&quot; ms, %&quot;LLU&quot; us\n&quot;,vid-&gt;lastSentFrame,
-                                                        result-&gt;Pts/1000,result-&gt;Pts);
-                if(pts==ADM_COMPRESSED_NO_PTS) // No PTS available ?
-                {
-                   
-                    if(false==syncFound)
-                    {
-                        aprintf(&quot;[DecodePictureUpToIntra] No time stamp yet, dropping picture\n&quot;);
-                        cache-&gt;invalidate(result);
-                    }else
-                    {
-                        // increment it using average fps
-                        vid-&gt;lastDecodedPts+=vid-&gt;timeIncrementInUs;
-                        result-&gt;Pts=vid-&gt;lastDecodedPts;
-                    }
-                }else
-                {
-                    if(false==syncFound)
-                    {
-                        aprintf(&quot;[DecodePictureUpToIntra] Sync found\n&quot;);
-                        syncFound=true;
-                    }
-                    vid-&gt;lastDecodedPts=pts;
-                }
-            }
-
-            // Found our image ?
-          if(result-&gt;Pts==wantedPts)
-                found=true;
-          else
-                vid-&gt;lastSentFrame++;
+        ADM_warning(&quot;Cannot go to segment %&quot;LU&quot;\n&quot;,s);
+        return false;
     }
-    if(found==false)
+    if(false== DecodePictureUpToIntra(frame,seg-&gt;_reference))
     {
-        printf(&quot;[GoToIntra] Could not find decoded frame, wanted PTS :%&quot;LU&quot; PTS=%&quot;LLU&quot; ms, %&quot;LLU&quot; us\n&quot;,frame,wantedPts/1000,wantedPts);
-        cache-&gt;dump();
         return false;
     }
-    vid-&gt;lastReadPts=wantedPts;
-    currentFrame=frame;
     return true;
 }
 /**
-    \fn getSamePicture
-    \brief returns the last already decoded picture
-    @param out : Where to put the decoded image to
-    @param ref : Video we are dealing with
-    @return true on success, false on failure
-
+    \fn GoToTime
 */
-bool ADM_Composer::getSamePicture(ADMImage *out,uint32_t ref)
+bool  ADM_Composer::goToTimeVideo(uint64_t startTime)
 {
-    _VIDEOS *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid-&gt;_aviheader;
-	EditorCache   *cache =vid-&gt;_videoCache;
-	ADM_assert(cache);
+    return goToIntraTimeVideo(startTime);
 
-  ADMImage *in=cache-&gt;getByPts(vid-&gt;lastDecodedPts);
-  if(!in)
-  {
-    printf(&quot;[ADM_Composer::getSamePicture] Failed\n&quot;);
-    return false;
-  }
-  out-&gt;duplicate(in);
-  return true;
 }
-
 /**
-    \fn getNextPicture
-    \brief returns the next picture
-    @param out : Where to put the decoded image to
-    @param ref : Video we are dealing with
-    @return true on success, false on failure
-
+    \fn NextPicture
+    \brief decode &amp; returns the next picture
 */
-bool ADM_Composer::getNextPicture(ADMImage *out,uint32_t ref)
+bool        ADM_Composer::nextPicture(ADMImage *image)
 {
-  EditorCache   *cache=_segments.getRefVideo(ref)-&gt;_videoCache;
-  ADMImage	*result;
-  _VIDEOS *vid=_segments.getRefVideo(ref);
+uint64_t pts;
+uint64_t tail;
 
-   uint32_t loop=20; // Try 20 frames ahead
-
-	// Try decoding loop&#340; rames ahead, if not we can consider it fails
-    while(loop--)
+    // Decode image...
+    _SEGMENT *seg=_segments.getSegment(_currentSegment);
+    if(false== nextPictureInternal(seg-&gt;_reference,image))
     {
-        // first decode a picture, cannot hurt...
-        if(DecodeNextPicture(ref)==false)
+        goto np_nextSeg;
+    }
+        // no we have our image, let's check it is within this segment range..
+        pts=image-&gt;Pts;
+        tail=seg-&gt;_startTimeUs+seg-&gt;_durationUs;
+        if(pts&gt;=tail)
         {
-            printf(&quot;[AdmComposer::getPicture] Next picture failed\n&quot;);
-            continue;
+                ADM_info(&quot;Got an image (%&quot;LU&quot; ms, but is out of this segment (%&quot;LU&quot;+%&quot;LU&quot;=%&quot;LU&quot; ms)\n&quot;,
+                                                                    pts,seg-&gt;_startTimeUs,seg-&gt;_durationUs,tail);
+                goto np_nextSeg;
         }
-        // Search the lowest PTS above our current PTS...
-        ADMImage *img=cache-&gt;findJustAfter(vid-&gt;lastReadPts);
-        if(img)
+        
+        updateImageTiming(seg,image);
+        return true;
+
+// Try to get an image for the following segment....
+np_nextSeg:
+        if(_currentSegment+1&lt;_segments.getNbSegments())
         {
-            // Duplicate
-            if(out)
+            if(switchToNextSegment()==false)
             {
-                aprintf(&quot;[getNextPicture] Looking for after&gt; %&quot;LLU&quot;, got %&quot;LLU&quot; delta=%&quot;LD&quot; ms\n&quot;,vid-&gt;lastReadPts,img-&gt;Pts,(img-&gt;Pts-vid-&gt;lastReadPts)/1000);
-                out-&gt;duplicate(img);
-                vid-&gt;lastReadPts=img-&gt;Pts;
-                currentFrame++;
+                ADM_warning(&quot;Cannot get next picture. cannot go to next segment also !\n&quot;);
+                return false;
             }
+            ADM_info(&quot;Switched to next segment\n&quot;);
+            seg=_segments.getSegment(_currentSegment);
+            samePictureInternal(seg-&gt;_reference,image);
+            updateImageTiming(seg,image);
             return true;
-        }else   
+        } else  
         {
-            aprintf(&quot;[getNextPic] Loop:%d, looking for pts&gt; :%&quot;LLU&quot; ms %&quot;LLU&quot; us\n&quot;,loop,vid-&gt;lastReadPts/1000,vid-&gt;lastReadPts);
-#ifdef VERBOSE
-            cache-&gt;dump();
-#endif
-
+                ADM_warning(&quot;Cannot get next picture. Last segment\n&quot;);
+                return false;
         }
-    }
-    printf(&quot;[ADM_Composer::getPicture] Failed\n&quot;);
-    printf(&quot;[ADM_composer] while looking for %&quot;LLU&quot; us, %&quot;LLU&quot; ms\n&quot;,vid-&gt;lastReadPts,vid-&gt;lastReadPts/1000);
-    cache-&gt;dump();
-    return false;
+        return false;
 }
-
 /**
-    \fn DecodeNextPicture
-    \brief Decode the next picture
-
-    @param ref  , video we are dealing with
-    returns true on success
-            fail on error
-
+    \fn samePicture
+    \brief returns the last already decoded picture
 */
-bool ADM_Composer::DecodeNextPicture(uint32_t ref)
+bool        ADM_Composer::samePicture(ADMImage *image)
 {
-uint8_t ret = 0;
-  EditorCache   *cache;
-  ADMImage	*result;
-  uint32_t  flags;
-  ADMCompressedImage img;
-   _VIDEOS *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid-&gt;_aviheader;
-	cache=vid-&gt;_videoCache;
-    // PlaceHolder...
-    img.data=compBuffer;
-    img.cleanup(vid-&gt;lastSentFrame+1);
-
-	ADM_assert(cache);
-    vid-&gt;lastSentFrame++;
-
-    uint32_t frame=vid-&gt;lastSentFrame;
-    aprintf(&quot;[EditorRender] DecodeNext %u ref:%u\n&quot;,frame,ref);
-    // Fetch frame
-     aprintf(&quot;[Editor] Decoding frame %u\n&quot;,frame);
-     if (!demuxer-&gt;getFrame (frame,&amp;img))
-     {
-            printf(&quot;[DecodePictureUpToIntra] getFrame failed for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
-            return false;
-     }
-
-     // Now uncompress it...
-     result=cache-&gt;getFreeImage();
-     if(!result)
-     {
-            printf(&quot;[DecodePictureUpToIntra] Cache full for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
-            return false;
-      }
-        aprintf(&quot;Demuxed frame %&quot;LU&quot; with pts=%&quot;LLD&quot; us, %&quot;LLD&quot; ms\n&quot;,
-            frame,
-            img.demuxerPts,
-            img.demuxerPts/1000);
-    
-      if(!decompressImage(result,&amp;img,ref))
-      {
-         printf(&quot;[DecodePictureUpToIntra] decode error for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
-         cache-&gt;invalidate(result);
-         return true; // Not an error in itself
-      }
-     cache-&gt;updateFrameNum(result,vid-&gt;lastSentFrame);
-     uint64_t pts=result-&gt;Pts;
-     uint64_t old=vid-&gt;lastDecodedPts;
-        if(pts==ADM_COMPRESSED_NO_PTS) // No PTS available ?
+      _SEGMENT *seg=_segments.getSegment(_currentSegment);
+        if(false== samePictureInternal(seg-&gt;_reference,image))
         {
-                aprintf(&quot;[Editor] No PTS, guessing value\n&quot;);
-                vid-&gt;lastDecodedPts+=vid-&gt;timeIncrementInUs;
-                result-&gt;Pts=vid-&gt;lastDecodedPts;
-        }else
-           {
-                aprintf(&quot;[Editor] got PTS\n&quot;);
-                vid-&gt;lastDecodedPts=pts;
-            }
-    aprintf(&quot;&gt;&gt;Decoded frame %&quot;LU&quot; with pts=%&quot;LLD&quot; us, %&quot;LLD&quot; ms, ptsdelta=%&quot;LLD&quot; ms \n&quot;,
-    frame,
-    vid-&gt;lastDecodedPts,
-    vid-&gt;lastDecodedPts/1000,
-    (vid-&gt;lastDecodedPts-old)/1000);
-    if(old&gt;vid-&gt;lastDecodedPts) printf(&quot;&gt;&gt;&gt;&gt;&gt; PTS going backward by %&quot;LLD&quot; ms\n&quot;,(old-vid-&gt;lastDecodedPts)/1000);
-    return true;
-}
-/**
-    \fn decompressImage
-    \brief push an image inside decoder and pop one. Warning the popped one might be an older image due to decoder lag.
-            Also do postprocessing and color conversion
-*/
-bool ADM_Composer::decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t ref)
-{
- ADMImage *tmpImage=NULL;
- uint32_t ww,hh,left,right;
- _VIDEOS *v=_segments.getRefVideo(ref);
- uint32_t refOnly=v-&gt;decoder-&gt;dontcopy(); // can we skip one memcpy ?
-// This is only an empty Shell
-    if(refOnly)
-    {
-                uint32_t w,h;
-                if(_scratch) // Can we reuse the old scratch memory ?
-                {
-                    _scratch-&gt;getWidthHeight(&amp;w,&amp;h);
-                    if(w!=_imageBuffer-&gt;_width || _imageBuffer-&gt;_height!=h)
-                    {
-                        delete _scratch;
-                        _scratch=NULL;
-                    }
-                }
-                if(!_scratch)
-                {
-                  _scratch=new ADMImage(_imageBuffer-&gt;_width,_imageBuffer-&gt;_height,1);
-                }
-                tmpImage=_scratch;
-                ww=_imageBuffer-&gt;_width &amp; 0xfffff0;
-                left=_imageBuffer-&gt;_width &amp; 0xf;
-
-        }
-        else
-        {
-                tmpImage=_imageBuffer;
-                ww=_imageBuffer-&gt;_width;
-                left=0;
-       }
-    //
-    tmpImage-&gt;_colorspace=ADM_COLOR_YV12;
-	// Decode it
-        if (!v-&gt;decoder-&gt;uncompress (in, tmpImage))
-	    {
-            printf(&quot;[decompressImage] uncompress failed\n&quot;);
+            ADM_warning(&quot;SamePicture failed\n&quot;);
             return false;
         }
-
-        //
-        if(tmpImage-&gt;_noPicture &amp;&amp; refOnly)
-        {
-            printf(&quot;[decompressImage] NoPicture\n&quot;);
-            // Fill in with black
-            return true;
-        }
-        aprintf(&quot;[::Decompress] in:%&quot;LU&quot; out:%&quot;LU&quot; flags:%x\n&quot;,in-&gt;demuxerPts,out-&gt;Pts,out-&gt;flags);
-	// If not quant and it is already YV12, we can stop here
-	if((!tmpImage-&gt;quant || !tmpImage-&gt;_qStride) &amp;&amp; tmpImage-&gt;_colorspace==ADM_COLOR_YV12)
-	{
-		out-&gt;_Qp=2;
-		out-&gt;duplicate(tmpImage);
-		aprintf(&quot;[decompressImage] : No quant avail\n&quot;);
-		return true;
-	}
-	// We got everything, let's go
-	// 1 compute average quant
-	int qz;
-	uint32_t sumit=0;
-    // Dupe infos
-    out-&gt;copyInfo(tmpImage);
-
-
-        // Do postprocessing if any
-	for(uint32_t z=0;z&lt;tmpImage-&gt;_qSize;z++)
-	{
-            qz=(int)tmpImage-&gt;quant[z];
-			sumit+=qz;
-	}
-	sumit+=(tmpImage-&gt;_qSize-1);
-	float sum=(float)sumit;
-	sum/=tmpImage-&gt;_qSize;
-	if(sum&gt;31) sum=31;
-	if(sum&lt;1) sum=1;
-
-        // update average Q
-	tmpImage-&gt;_Qp=out-&gt;_Qp=(uint32_t)floor(sum);
-
-	// Pp deactivated ?
-	if(!_pp.postProcType || !_pp.postProcStrength || tmpImage-&gt;_colorspace!=ADM_COLOR_YV12)
-    {
-        dupe(tmpImage,out,v);
-        aprintf(&quot;EdCache: Postproc disabled\n&quot;);
-		return 1;
-	}
-
-	int type;
-	#warning FIXME should be FF_I_TYPE/B/P
-	if(tmpImage-&gt;flags &amp; AVI_KEY_FRAME) type=1;
-		else if(tmpImage-&gt;flags &amp; AVI_B_FRAME) type=3;
-			else type=2;
-
-        ADM_assert(tmpImage-&gt;_colorspace==ADM_COLOR_YV12);
-
-	// we do postproc !
-	// keep
-	uint8_t *oBuff[3];
-	const uint8_t *iBuff[3];
-	int	strideTab[3];
-	int	strideTab2[3];
-	aviInfo _info;
-
-        getVideoInfo(&amp;_info);
-        if(refOnly)
-        {
-                iBuff[0]= tmpImage-&gt;_planes[0];
-                iBuff[1]= tmpImage-&gt;_planes[1];
-                iBuff[2]= tmpImage-&gt;_planes[2];
-
-                strideTab2[0]=_info.width;
-                strideTab2[1]=_info.width&gt;&gt;1;
-                strideTab2[2]=_info.width&gt;&gt;1;
-
-                strideTab[0]=tmpImage-&gt;_planeStride[0];
-                strideTab[1]=tmpImage-&gt;_planeStride[1];
-                strideTab[2]=tmpImage-&gt;_planeStride[2];
-
-        }
-        else
-        {
-                iBuff[0]= YPLANE((tmpImage));
-                iBuff[1]= UPLANE((tmpImage));
-                iBuff[2]= VPLANE((tmpImage));
-
-                strideTab[0]=strideTab2[0]=_info.width;
-                strideTab[1]=strideTab2[1]=_info.width&gt;&gt;1;
-                strideTab[2]=strideTab2[2]=_info.width&gt;&gt;1;
-        }
-        if(_pp.swapuv)
-        {
-                oBuff[0]= YPLANE(out);
-                oBuff[1]= VPLANE(out);
-                oBuff[2]= UPLANE(out);
-        }else
-        {
-
-                oBuff[0]= YPLANE(out);
-                oBuff[1]= UPLANE(out);
-                oBuff[2]= VPLANE(out);
-        }
-        pp_postprocess(
-            iBuff,
-            strideTab,
-            oBuff,
-            strideTab2,
-            ww,
-            _info.height,
-            (int8_t *)(tmpImage-&gt;quant),
-            tmpImage-&gt;_qStride,
-            _pp.ppMode,
-            _pp.ppContext,
-            type);			// img type
-        /*
-                If there is a chroma block that needs padding
-                (width not multiple of 16) while postprocessing,
-                we process up to the nearest 16 multiple and
-                just copy luma &amp; chroma info that was left over
-        */
-        if(refOnly &amp;&amp; left)
-        {
-                uint8_t *src,*dst;
-                uint32_t stridein,strideout,right;
-                right=_info.width-left;
-                // Luma
-                dst=YPLANE(out)+right;
-                src=tmpImage-&gt;_planes[0]+right;
-                stridein=tmpImage-&gt;_planeStride[0];
-                strideout=_info.width;
-                for(uint32_t y=_info.height;y&gt;0;y--)
-                {
-                        memcpy(dst,src,left);
-                        dst+=strideout;
-                        src+=stridein;
-                }
-                // Chroma
-                left&gt;&gt;=1;
-                right&gt;&gt;=1;
-                //
-                dst=UPLANE(out)+right;
-                src=tmpImage-&gt;_planes[1]+right;
-                stridein=tmpImage-&gt;_planeStride[1];
-                strideout=_info.width&gt;&gt;1;
-                for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
-                {
-                        memcpy(dst,src,left);
-                        dst+=strideout;
-                        src+=stridein;
-                }
-                //
-                dst=VPLANE(out)+right;
-                src=tmpImage-&gt;_planes[2]+right;
-                stridein=tmpImage-&gt;_planeStride[2];
-                strideout=_info.width&gt;&gt;1;
-                for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
-                {
-                        memcpy(dst,src,left);
-                        dst+=strideout;
-                        src+=stridein;
-                }
-
-
-        }
-    return true;
+         updateImageTiming(seg,image);
+        return true;
 }
 
-
-
 /**
-    \fn decodeCache
-    \brief Decode an image an update cache
+        \fn getCompressedPicture
+        \brief bypass decoder and directly get the source image
 
 */
-
-uint8_t		ADM_Composer::decodeCache(uint32_t frame,uint32_t seg, ADMImage *image)
+bool        ADM_Composer::getCompressedPicture(ADMCompressedImage *img)
 {
+    uint64_t tail;
+    //
+    _SEGMENT *seg=_segments.getSegment(_currentSegment);
+    ADM_assert(seg);
+    _VIDEOS *vid=_segments.getRefVideo(seg-&gt;_reference);
+    ADM_assert(vid);
+    vidHeader *demuxer=vid-&gt;_aviheader;
+    ADM_assert(demuxer);
 
-uint32_t sumit;
-float	 sum;
+    // Get next pic?
+    if(false==demuxer-&gt;getFrame (seg-&gt;_curFrame,img))
+    {
+        ADM_info(&quot;Failed to get next frame for ref %&quot;LU&quot;\n&quot;,seg-&gt;_reference);
+        goto nextSeg;
+    }
+    seg-&gt;_curFrame++;
+    // Need to switch seg ?
+    tail=seg-&gt;_refStartTimeUs+seg-&gt;_durationUs;
+    if(img-&gt;demuxerDts!= ADM_NO_PTS &amp;&amp; img-&gt;demuxerDts&gt;tail) goto nextSeg;
+    if(img-&gt;demuxerPts!= ADM_NO_PTS &amp;&amp; img-&gt;demuxerPts&gt;tail) goto nextSeg;
+    {
+    // Recalibrate PTS &amp; DTS...
+    int64_t offset=seg-&gt;_refStartTimeUs;
+    offset=seg-&gt;_startTimeUs;
+    recalibrate(&amp;(img-&gt;demuxerPts),seg);
+    recalibrate(&amp;(img-&gt;demuxerDts),seg);
+    }
+    return true;
 
-uint32_t ref,refOffset;
-
-        if(false==_segments.getRefFromFrame(frame,&amp;ref,&amp;refOffset))
-        {
-            ADM_warning(&quot;[decodeCache] Cannot get ref for frame %&quot;LD&quot;\n&quot;,frame);
-            return false;
-        }
-
-
-_VIDEOS *v=_segments.getRefVideo(ref); // FIXME!!!!
-EditorCache *cache=v-&gt;_videoCache;
-ADMImage *tmpImage=NULL;
-uint8_t refOnly=0;
-uint32_t left,ww;
-ADMCompressedImage img;
-
-        aprintf(&quot;decodeCache : original :%&quot;LD&quot; Frame in ref %&quot;LD&quot;\n&quot;,frame,refOffset);
-        img.data=compBuffer;
-        img.cleanup(frame);
-        // Step 1, retrieve the compressed datas, including PTS &amp; DTS infos
-         if (!v-&gt;_aviheader-&gt;getFrame (refOffset,&amp;img))
-        {
-          ADM_warning (&quot;Editor: last decoding failed.%&quot;LD&quot;)\n&quot;,   refOffset );
-          return 0;
-        }
-        ADM_assert(_imageBuffer);
-
-        // if len is 0 then take the previous image
-        //
-
-        refOnly=v-&gt;decoder-&gt;dontcopy(); // can we skip one memcpy ?
-
-        if(!img.dataLength &amp; refOnly &amp; !refOffset)      // Size is null = no image and we only got a pointer
-                                // copy the previous one
-        {
-                // First image
-
-                uint32_t page=_imageBuffer-&gt;_width*_imageBuffer-&gt;_height;
-                        memset(YPLANE(image),0,page);
-                        memset(UPLANE(image),128,page&gt;&gt;2);
-                        memset(VPLANE(image),128,page&gt;&gt;2);
-                        if(!refOffset)
-                                image-&gt;flags=AVI_KEY_FRAME;
-                        else
-                                image-&gt;flags=AVI_P_FRAME;
-                        image-&gt;_Qp=2;
-                        image-&gt;_qStride=0;
-                        return 1;
-        }
-
-        if(refOnly)
-        {       // This is only an empty Shell
-                uint32_t w,h;
-                if(_scratch) // Can we reuse the old scratch memory ?
-                {
-                    _scratch-&gt;getWidthHeight(&amp;w,&amp;h);
-                    if(w!=_imageBuffer-&gt;_width || _imageBuffer-&gt;_height!=h)
-                    {
-                        delete _scratch;
-                        _scratch=NULL;
-                    }
-                }
-                if(!_scratch)
-                {
-                  _scratch=new ADMImage(_imageBuffer-&gt;_width,_imageBuffer-&gt;_height,1);
-                }
-                tmpImage=_scratch;
-                ww=_imageBuffer-&gt;_width &amp; 0xfffff0;
-                left=_imageBuffer-&gt;_width &amp; 0xf;
-
-        }
-        else
-        {
-                tmpImage=_imageBuffer;
-                ww=_imageBuffer-&gt;_width;
-                left=0;
-       }
-	tmpImage-&gt;_colorspace=ADM_COLOR_YV12;
-	// Do pp, and use imageBuffer as intermediate buffer
-	if (!v-&gt;decoder-&gt;uncompress (&amp;img, tmpImage))
-	    {
-	      printf (&quot;\nEditor: Last Decoding2 failed for frame %&quot;LU&quot;\n&quot;,refOffset);
-	       // Try to dupe previous frame
-                if(refOffset)
-                {
-                        ADMImage *prev;
-                        prev=cache-&gt;getImage(refOffset-1);
-                        if(prev)
-                        {
-                                image-&gt;duplicate(prev);
-                                cache-&gt;updateFrameNum(image,refOffset);
-                                return 1;
-                        }
-                }
-                goto _next;
-           }
-
-        //
-        if(tmpImage-&gt;_noPicture &amp;&amp; refOnly &amp;&amp; refOffset)
-        {
-                cache-&gt;updateFrameNum(image,0xffffffffU);
-                return 0;
-        }
-	// If not quant and it is already YV12, we can stop here
-	if((!tmpImage-&gt;quant || !tmpImage-&gt;_qStride) &amp;&amp; tmpImage-&gt;_colorspace==ADM_COLOR_YV12)
-	{
-		image-&gt;_Qp=2;
-		image-&gt;duplicate(tmpImage);
-		cache-&gt;updateFrameNum(image,refOffset);
-          //      if(refOnly) delete tmpImage;
-		aprintf(&quot;EdCache: No quant avail\n&quot;);
-		return 1;
-	}
-	// We got everything, let's go
-	// 1 compute average quant
-	int qz;
-	sumit=0;
-        // Dupe infos
-        image-&gt;copyInfo(tmpImage);
-
-
-        // Do postprocessing if any
-	for(uint32_t z=0;z&lt;tmpImage-&gt;_qSize;z++)
-	{
-            qz=(int)tmpImage-&gt;quant[z];
-			sumit+=qz;
-	}
-	sumit+=(tmpImage-&gt;_qSize-1);
-//	sumit*=2;
-	sum=(float)sumit;
-	sum/=tmpImage-&gt;_qSize;
-	if(sum&gt;31) sum=31;
-	if(sum&lt;1) sum=1;
-
-        // update average Q
-	tmpImage-&gt;_Qp=image-&gt;_Qp=(uint32_t)floor(sum);
-
-	// Pp deactivated ?
-	if(!_pp.postProcType || !_pp.postProcStrength || tmpImage-&gt;_colorspace!=ADM_COLOR_YV12)
-     {
-        dupe(tmpImage,image,v);
-		cache-&gt;updateFrameNum(image,refOffset);
-               // if(refOnly) delete tmpImage;
-		aprintf(&quot;EdCache: Postproc disabled\n&quot;);
-		return 1;
-	}
-
-	int type;
-	#warning FIXME should be FF_I_TYPE/B/P
-	if(tmpImage-&gt;flags &amp; AVI_KEY_FRAME) type=1;
-		else if(tmpImage-&gt;flags &amp; AVI_B_FRAME) type=3;
-			else type=2;
-
-        ADM_assert(tmpImage-&gt;_colorspace==ADM_COLOR_YV12);
-
-	// we do postproc !
-	// keep
-	uint8_t *oBuff[3];
-	const uint8_t *iBuff[3];
-	int	strideTab[3];
-	int	strideTab2[3];
-	aviInfo _info;
-
-		getVideoInfo(&amp;_info);
-                if(refOnly)
-                {
-                        iBuff[0]= tmpImage-&gt;_planes[0];
-                        iBuff[1]= tmpImage-&gt;_planes[1];
-                        iBuff[2]= tmpImage-&gt;_planes[2];
-
-                        strideTab2[0]=_info.width;
-                        strideTab2[1]=_info.width&gt;&gt;1;
-                        strideTab2[2]=_info.width&gt;&gt;1;
-
-                        strideTab[0]=tmpImage-&gt;_planeStride[0];
-                        strideTab[1]=tmpImage-&gt;_planeStride[1];
-                        strideTab[2]=tmpImage-&gt;_planeStride[2];
-
-                }
-                else
-                {
-		        iBuff[0]= YPLANE((tmpImage));
-                iBuff[1]= UPLANE((tmpImage));
-                iBuff[2]= VPLANE((tmpImage));
-
-
-
-                        strideTab[0]=strideTab2[0]=_info.width;
-                        strideTab[1]=strideTab2[1]=_info.width&gt;&gt;1;
-                        strideTab[2]=strideTab2[2]=_info.width&gt;&gt;1;
-                }
-                if(_pp.swapuv)
-                {
-        	        oBuff[0]= YPLANE(image);
-                        oBuff[1]= VPLANE(image);
-                        oBuff[2]= UPLANE(image);
-                }else
-                {
-
-                        oBuff[0]= YPLANE(image);
-                        oBuff[1]= UPLANE(image);
-                        oBuff[2]= VPLANE(image);
-                }
-		 pp_postprocess(
-		 		iBuff,
-		 		strideTab,
-		 		oBuff,
-		 		strideTab2,
-		 		ww,
-		        	_info.height,
-		          	(int8_t *)(tmpImage-&gt;quant),
-		          	tmpImage-&gt;_qStride,
-		         	_pp.ppMode,
-		          	_pp.ppContext,
-		          	type);			// img type
-                /*
-                        If there is a chroma block that needs padding
-                        (width not multiple of 16) while postprocessing,
-                        we process up to the nearest 16 multiple and
-                        just copy luma &amp; chroma info that was left over
-                */
-                if(refOnly &amp;&amp; left)
-                {
-                        uint8_t *src,*dst;
-                        uint32_t stridein,strideout,right;
-                        right=_info.width-left;
-                        // Luma
-                        dst=YPLANE(image)+right;
-                        src=tmpImage-&gt;_planes[0]+right;
-                        stridein=tmpImage-&gt;_planeStride[0];
-                        strideout=_info.width;
-                        for(uint32_t y=_info.height;y&gt;0;y--)
-                        {
-                                memcpy(dst,src,left);
-                                dst+=strideout;
-                                src+=stridein;
-                        }
-                        // Chroma
-                        left&gt;&gt;=1;
-                        right&gt;&gt;=1;
-                        //
-                        dst=UPLANE(image)+right;
-                        src=tmpImage-&gt;_planes[1]+right;
-                        stridein=tmpImage-&gt;_planeStride[1];
-                        strideout=_info.width&gt;&gt;1;
-                        for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
-                        {
-                                memcpy(dst,src,left);
-                                dst+=strideout;
-                                src+=stridein;
-                        }
-                        //
-                        dst=VPLANE(image)+right;
-                        src=tmpImage-&gt;_planes[2]+right;
-                        stridein=tmpImage-&gt;_planeStride[2];
-                        strideout=_info.width&gt;&gt;1;
-                        for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
-                        {
-                                memcpy(dst,src,left);
-                                dst+=strideout;
-                                src+=stridein;
-                        }
-
-
-                }
-_next:
-        // update some infos
-        //   if(refOnly) delete tmpImage;
-		cache-&gt;updateFrameNum(image,refOffset);
-		aprintf(&quot;EdCache: Postproc done\n&quot;);
-		return 1;
+nextSeg:
+    if(false==switchToNextSegment())
+    {
+        ADM_warning(&quot;Cannot update to new segment\n&quot;);
+        return false;
+    }
+    ADM_info(&quot;Retrying for next segment\n&quot;);
+    return getCompressedPicture(img);
+   
 }
+
 /**
         \fn dupe
 */
@@ -950,63 +257,62 @@
 	*swapuv=_pp.swapuv;
 	return 1;
 }
+/**
+    \fn switchToNextSegment
+    \brief Switch to the next segment
 
-
-#if 0
-uint8_t	ADM_Composer::isReordered( uint32_t framenum )
+*/
+bool        ADM_Composer::switchToNextSegment(void)
 {
-uint32_t seg,relframe;
- if (!convFrame2Seg (framenum, &amp;seg, &amp;relframe))
+    if(_currentSegment==_segments.getNbSegments()-1)
     {
-      printf (&quot;\n Conversion failed !\n&quot;);
-      return 0;
+        ADM_warning(&quot;This is the last segment (%&quot;LU&quot;)\n&quot;,_currentSegment);
+        return false;
     }
-    uint32_t ref=_segments[seg]._reference;
-   return _videos[ref]._aviheader-&gt;isReordered();
+    if(true==switchToSegment(_currentSegment+1)) return true;
+    return false;
 }
-#endif
 /**
-    \fn getCurrentFrame
+    \fn switchToSegment
+    \brief Switch to the segment given as argument
+
 */
-uint32_t    ADM_Composer::getCurrentFrame(void)
+bool        ADM_Composer::switchToSegment(uint32_t s)
 {
-    return currentFrame;
-}
-/**
-    \fn setCurrentFrame
-*/
-bool        ADM_Composer::setCurrentFrame(uint32_t frame)
-{
-    // Seatch previous keyFrame
-    printf(&quot;[setCurrentFrame] &gt;&gt;&gt; REQ for frame %&quot;LU&quot;\n&quot;,frame);
-    uint32_t keyFrame=frame,f;
-    while(keyFrame)
+    if(s+1&gt;_segments.getNbSegments())
     {
-        if(getFlags(keyFrame,&amp;f))
-        {
-            if(f&amp;AVI_KEY_FRAME) break;
-        }
-        keyFrame--;
-    }
-    printf(&quot;[setCurrentFrame] &gt;&gt;&gt; Prev KeyFrame %&quot;LU&quot;\n&quot;,keyFrame);
-    if(false==GoToIntra(keyFrame))
-    {
-        printf(&quot;[setCurrentFrame] GoToIntra failed for frame %u\n&quot;,keyFrame);
+        ADM_warning(&quot;Cannot switch to segment:%&quot;LU&quot;\n&quot;,s);
         return false;
     }
-    //Now go forward
-    uint32_t mx=frame-keyFrame;
-    uint32_t i=0;
-    for(i=0;i&lt;mx;i++)
+    _SEGMENT *seg=_segments.getSegment(s);
+    ADM_assert(seg);
+    ADM_info(&quot;Switching to seg %&quot;LU&quot; with startTime in reference pic= %&quot;LU&quot; ms\n&quot;,s,seg-&gt;_refStartTimeUs/1000);
+    // Search the previous keyframe for segment....
+    uint64_t seekTime;
+    if(_segments.isKeyFrameByTime(seg-&gt;_reference,seg-&gt;_refStartTimeUs))
     {
-        if(NextPicture(NULL) ==false)
+        seekTime=seg-&gt;_refStartTimeUs;
+        ADM_info(&quot;First frame of the new segment is a keyframe at %&quot;LU&quot;ms\n&quot;,seekTime/1000);
+    }else   
+    {
+        if(false==searchPreviousKeyFrameInRef(seg-&gt;_reference,seg-&gt;_refStartTimeUs,&amp;seekTime))
         {
+            ADM_warning(&quot;Cannot identify the keyframe before %&quot;LLU&quot; ms\n&quot;,seekTime/1000);
             return false;
         }
     }
+    // ok now seek...
+    uint32_t frame=_segments.intraTimeToFrame(seg-&gt;_reference,seekTime);
+    if(false==DecodePictureUpToIntra(frame,seg-&gt;_reference))
+    {
+        return false;
+    }
+    // Now forward to the frame we want...
+#warning TODO do not seek only on intra
+    _VIDEOS *ref=_segments.getRefVideo(seg-&gt;_reference);
+    seg-&gt;_curFrame=ref-&gt;lastSentFrame;
     return true;
 }
 
 
-
 //EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp (from rev 5391, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -0,0 +1,813 @@
+/***************************************************************************
+    \file  ADM_edRenderInternal.cpp  
+    \brief handle decoding from ONE source, ignoring the segments
+    \author mean (c) 2002/2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &lt;math.h&gt;
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+
+#if defined(ADM_DEBUG) &amp;&amp; 0
+#define aprintf printf
+#else
+#define aprintf(...) {}// printf
+#endif
+
+#include &quot;ADM_pp.h&quot;
+
+// FIXME BADLY !!!
+// This should be in a context somewhere
+static uint8_t compBuffer[MAXIMUM_SIZE * MAXIMUM_SIZE * 3];
+
+
+/**
+    \fn samePictureInternal
+    \brief returns the last already decoded picture
+    @param out : Where to put the decoded image to
+    @param ref : Video we are dealing with
+    @return true on success, false on failure
+
+*/
+bool ADM_Composer::samePictureInternal(uint32_t ref,ADMImage *out)
+{
+    _VIDEOS *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid-&gt;_aviheader;
+	EditorCache   *cache =vid-&gt;_videoCache;
+	ADM_assert(cache);
+
+  ADMImage *in=cache-&gt;getByPts(vid-&gt;lastDecodedPts);
+  if(!in)
+  {
+    printf(&quot;[ADM_Composer::getSamePicture] Failed, while looking for Pts=%&quot;LU&quot; ms\n&quot;,vid-&gt;lastDecodedPts);
+    cache-&gt;dump();
+    return false;
+  }
+  out-&gt;duplicate(in);
+  return true;
+}
+
+/**
+    \fn nextPictureInternal
+    \brief returns the next picture
+    @param out : Where to put the decoded image to
+    @param ref : Video we are dealing with
+    @return true on success, false on failure
+
+*/
+bool ADM_Composer::nextPictureInternal(uint32_t ref,ADMImage *out)
+{
+  ADMImage	*result;
+  EditorCache   *cache=_segments.getRefVideo(ref)-&gt;_videoCache;
+  _VIDEOS *vid=_segments.getRefVideo(ref);
+
+  ADM_assert(vid);
+
+   uint32_t loop=20; // Try 20 frames ahead
+
+	// Try decoding loop rames ahead, if not we can consider it fails
+    while(loop--)
+    {
+        // first decode a picture, cannot hurt...
+        if(DecodeNextPicture(ref)==false)
+        {
+            ADM_warning(&quot;Next picture failed\n&quot;);
+            continue;
+        }
+        // Search the lowest PTS above our current PTS...
+        ADMImage *img=cache-&gt;findJustAfter(vid-&gt;lastReadPts);
+        if(img)
+        {
+            // Duplicate
+            if(out)
+            {
+                aprintf(&quot;[getNextPicture] Looking for after&gt; %&quot;LLU&quot;, got %&quot;LLU&quot; delta=%&quot;LD&quot; ms\n&quot;,vid-&gt;lastReadPts,img-&gt;Pts,(img-&gt;Pts-vid-&gt;lastReadPts)/1000);
+                out-&gt;duplicate(img);
+                vid-&gt;lastReadPts=img-&gt;Pts;
+                currentFrame++;
+            }
+            return true;
+        }else   
+        {
+            aprintf(&quot;[getNextPic] Loop:%d, looking for pts&gt; :%&quot;LLU&quot; ms %&quot;LLU&quot; us\n&quot;,loop,vid-&gt;lastReadPts/1000,vid-&gt;lastReadPts);
+#ifdef VERBOSE
+            cache-&gt;dump();
+#endif
+
+        }
+    }
+    ADM_warning(&quot;nextPictureInternal Failed\n&quot;);
+    ADM_warning(&quot;while looking for %&quot;LLU&quot; us, %&quot;LLU&quot; ms\n&quot;,vid-&gt;lastReadPts,vid-&gt;lastReadPts/1000);
+    cache-&gt;dump();
+    return false;
+}
+
+/**
+    \fn DecodeNextPicture
+    \brief Decode the next picture
+
+    @param ref  , video we are dealing with
+    returns true on success
+            fail on error
+
+*/
+bool ADM_Composer::DecodeNextPicture(uint32_t ref)
+{
+uint8_t ret = 0;
+  EditorCache   *cache;
+  ADMImage	*result;
+  uint32_t  flags;
+  ADMCompressedImage img;
+   _VIDEOS *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid-&gt;_aviheader;
+	cache=vid-&gt;_videoCache;
+    // PlaceHolder...
+    img.data=compBuffer;
+    img.cleanup(vid-&gt;lastSentFrame+1);
+
+	ADM_assert(cache);
+    vid-&gt;lastSentFrame++;
+
+    uint32_t frame=vid-&gt;lastSentFrame;
+    aprintf(&quot;[EditorRender] DecodeNext %u ref:%u\n&quot;,frame,ref);
+    // Fetch frame
+     aprintf(&quot;[Editor] Decoding frame %u\n&quot;,frame);
+     if (!demuxer-&gt;getFrame (frame,&amp;img))
+     {
+            ADM_warning(&quot;getFrame failed for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
+            return false;
+     }
+
+     // Now uncompress it...
+     result=cache-&gt;getFreeImage();
+     if(!result)
+     {
+            ADM_warning(&quot; Cache full for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
+            return false;
+      }
+        aprintf(&quot;Demuxed frame %&quot;LU&quot; with pts=%&quot;LLD&quot; us, %&quot;LLD&quot; ms\n&quot;,
+            frame,
+            img.demuxerPts,
+            img.demuxerPts/1000);
+    
+      if(!decompressImage(result,&amp;img,ref))
+      {
+         ADM_warning(&quot;Decoding error for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
+         cache-&gt;invalidate(result);
+         return true; // Not an error in itself
+      }
+     cache-&gt;updateFrameNum(result,vid-&gt;lastSentFrame);
+     uint64_t pts=result-&gt;Pts;
+     uint64_t old=vid-&gt;lastDecodedPts;
+        if(pts==ADM_COMPRESSED_NO_PTS) // No PTS available ?
+        {
+                aprintf(&quot;[Editor] No PTS, guessing value\n&quot;);
+                vid-&gt;lastDecodedPts+=vid-&gt;timeIncrementInUs;
+                result-&gt;Pts=vid-&gt;lastDecodedPts;
+        }else
+           {
+                aprintf(&quot;[Editor] got PTS\n&quot;);
+                vid-&gt;lastDecodedPts=pts;
+            }
+    aprintf(&quot;&gt;&gt;Decoded frame %&quot;LU&quot; with pts=%&quot;LLD&quot; us, %&quot;LLD&quot; ms, ptsdelta=%&quot;LLD&quot; ms \n&quot;,
+    frame,
+    vid-&gt;lastDecodedPts,
+    vid-&gt;lastDecodedPts/1000,
+    (vid-&gt;lastDecodedPts-old)/1000);
+    if(old&gt;vid-&gt;lastDecodedPts) ADM_warning(&quot;&gt;&gt;&gt;&gt;&gt; PTS going backward by %&quot;LLD&quot; ms\n&quot;,(old-vid-&gt;lastDecodedPts)/1000);
+    return true;
+}
+
+
+/**
+    \fn decompressImage
+    \brief push an image inside decoder and pop one. Warning the popped one might be an older image due to decoder lag.
+            Also do postprocessing and color conversion
+*/
+bool ADM_Composer::decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t ref)
+{
+ ADMImage *tmpImage=NULL;
+ uint32_t ww,hh,left,right;
+ _VIDEOS *v=_segments.getRefVideo(ref);
+ uint32_t refOnly=v-&gt;decoder-&gt;dontcopy(); // can we skip one memcpy ?
+// This is only an empty Shell
+    if(refOnly)
+    {
+                uint32_t w,h;
+                if(_scratch) // Can we reuse the old scratch memory ?
+                {
+                    _scratch-&gt;getWidthHeight(&amp;w,&amp;h);
+                    if(w!=_imageBuffer-&gt;_width || _imageBuffer-&gt;_height!=h)
+                    {
+                        delete _scratch;
+                        _scratch=NULL;
+                    }
+                }
+                if(!_scratch)
+                {
+                  _scratch=new ADMImage(_imageBuffer-&gt;_width,_imageBuffer-&gt;_height,1);
+                }
+                tmpImage=_scratch;
+                ww=_imageBuffer-&gt;_width &amp; 0xfffff0;
+                left=_imageBuffer-&gt;_width &amp; 0xf;
+
+        }
+        else
+        {
+                tmpImage=_imageBuffer;
+                ww=_imageBuffer-&gt;_width;
+                left=0;
+       }
+    //
+    tmpImage-&gt;_colorspace=ADM_COLOR_YV12;
+	// Decode it
+        if (!v-&gt;decoder-&gt;uncompress (in, tmpImage))
+	    {
+            printf(&quot;[decompressImage] uncompress failed\n&quot;);
+            return false;
+        }
+
+        //
+        if(tmpImage-&gt;_noPicture &amp;&amp; refOnly)
+        {
+            printf(&quot;[decompressImage] NoPicture\n&quot;);
+            // Fill in with black
+            return true;
+        }
+        aprintf(&quot;[::Decompress] in:%&quot;LU&quot; out:%&quot;LU&quot; flags:%x\n&quot;,in-&gt;demuxerPts,out-&gt;Pts,out-&gt;flags);
+	// If not quant and it is already YV12, we can stop here
+	if((!tmpImage-&gt;quant || !tmpImage-&gt;_qStride) &amp;&amp; tmpImage-&gt;_colorspace==ADM_COLOR_YV12)
+	{
+		out-&gt;_Qp=2;
+		out-&gt;duplicate(tmpImage);
+		aprintf(&quot;[decompressImage] : No quant avail\n&quot;);
+		return true;
+	}
+	// We got everything, let's go
+	// 1 compute average quant
+	int qz;
+	uint32_t sumit=0;
+    // Dupe infos
+    out-&gt;copyInfo(tmpImage);
+
+
+        // Do postprocessing if any
+	for(uint32_t z=0;z&lt;tmpImage-&gt;_qSize;z++)
+	{
+            qz=(int)tmpImage-&gt;quant[z];
+			sumit+=qz;
+	}
+	sumit+=(tmpImage-&gt;_qSize-1);
+	float sum=(float)sumit;
+	sum/=tmpImage-&gt;_qSize;
+	if(sum&gt;31) sum=31;
+	if(sum&lt;1) sum=1;
+
+        // update average Q
+	tmpImage-&gt;_Qp=out-&gt;_Qp=(uint32_t)floor(sum);
+
+	// Pp deactivated ?
+	if(!_pp.postProcType || !_pp.postProcStrength || tmpImage-&gt;_colorspace!=ADM_COLOR_YV12)
+    {
+        dupe(tmpImage,out,v);
+        aprintf(&quot;EdCache: Postproc disabled\n&quot;);
+		return 1;
+	}
+
+	int type;
+	#warning FIXME should be FF_I_TYPE/B/P
+	if(tmpImage-&gt;flags &amp; AVI_KEY_FRAME) type=1;
+		else if(tmpImage-&gt;flags &amp; AVI_B_FRAME) type=3;
+			else type=2;
+
+        ADM_assert(tmpImage-&gt;_colorspace==ADM_COLOR_YV12);
+
+	// we do postproc !
+	// keep
+	uint8_t *oBuff[3];
+	const uint8_t *iBuff[3];
+	int	strideTab[3];
+	int	strideTab2[3];
+	aviInfo _info;
+
+        getVideoInfo(&amp;_info);
+        if(refOnly)
+        {
+                iBuff[0]= tmpImage-&gt;_planes[0];
+                iBuff[1]= tmpImage-&gt;_planes[1];
+                iBuff[2]= tmpImage-&gt;_planes[2];
+
+                strideTab2[0]=_info.width;
+                strideTab2[1]=_info.width&gt;&gt;1;
+                strideTab2[2]=_info.width&gt;&gt;1;
+
+                strideTab[0]=tmpImage-&gt;_planeStride[0];
+                strideTab[1]=tmpImage-&gt;_planeStride[1];
+                strideTab[2]=tmpImage-&gt;_planeStride[2];
+
+        }
+        else
+        {
+                iBuff[0]= YPLANE((tmpImage));
+                iBuff[1]= UPLANE((tmpImage));
+                iBuff[2]= VPLANE((tmpImage));
+
+                strideTab[0]=strideTab2[0]=_info.width;
+                strideTab[1]=strideTab2[1]=_info.width&gt;&gt;1;
+                strideTab[2]=strideTab2[2]=_info.width&gt;&gt;1;
+        }
+        if(_pp.swapuv)
+        {
+                oBuff[0]= YPLANE(out);
+                oBuff[1]= VPLANE(out);
+                oBuff[2]= UPLANE(out);
+        }else
+        {
+
+                oBuff[0]= YPLANE(out);
+                oBuff[1]= UPLANE(out);
+                oBuff[2]= VPLANE(out);
+        }
+        pp_postprocess(
+            iBuff,
+            strideTab,
+            oBuff,
+            strideTab2,
+            ww,
+            _info.height,
+            (int8_t *)(tmpImage-&gt;quant),
+            tmpImage-&gt;_qStride,
+            _pp.ppMode,
+            _pp.ppContext,
+            type);			// img type
+        /*
+                If there is a chroma block that needs padding
+                (width not multiple of 16) while postprocessing,
+                we process up to the nearest 16 multiple and
+                just copy luma &amp; chroma info that was left over
+        */
+        if(refOnly &amp;&amp; left)
+        {
+                uint8_t *src,*dst;
+                uint32_t stridein,strideout,right;
+                right=_info.width-left;
+                // Luma
+                dst=YPLANE(out)+right;
+                src=tmpImage-&gt;_planes[0]+right;
+                stridein=tmpImage-&gt;_planeStride[0];
+                strideout=_info.width;
+                for(uint32_t y=_info.height;y&gt;0;y--)
+                {
+                        memcpy(dst,src,left);
+                        dst+=strideout;
+                        src+=stridein;
+                }
+                // Chroma
+                left&gt;&gt;=1;
+                right&gt;&gt;=1;
+                //
+                dst=UPLANE(out)+right;
+                src=tmpImage-&gt;_planes[1]+right;
+                stridein=tmpImage-&gt;_planeStride[1];
+                strideout=_info.width&gt;&gt;1;
+                for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
+                {
+                        memcpy(dst,src,left);
+                        dst+=strideout;
+                        src+=stridein;
+                }
+                //
+                dst=VPLANE(out)+right;
+                src=tmpImage-&gt;_planes[2]+right;
+                stridein=tmpImage-&gt;_planeStride[2];
+                strideout=_info.width&gt;&gt;1;
+                for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
+                {
+                        memcpy(dst,src,left);
+                        dst+=strideout;
+                        src+=stridein;
+                }
+
+
+        }
+    return true;
+}
+
+/**
+    \fn DecodePictureUpToIntra
+    \brief Decode pictures from frameno, which must be an intra and on
+            until the decoded frameno is popped by the decoder
+
+    @param frame, framenumber relative to video ref (i.e. from its beginning)
+    @param ref  , video we are dealing with
+    returns true on success
+            fail on error
+
+*/
+bool ADM_Composer::DecodePictureUpToIntra(uint32_t ref,uint32_t frame)
+{
+  uint8_t ret = 0;
+  EditorCache   *cache;
+  ADMImage	*result;
+  uint32_t  flags;
+  ADMCompressedImage img;
+
+    // PlaceHolder...
+    img.data=compBuffer;
+    img.cleanup(frame);
+
+    ADM_info(&quot; DecodeUpToInta %u ref:%u\n&quot;,frame,ref);
+	_VIDEOS *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid-&gt;_aviheader;
+	cache=vid-&gt;_videoCache;
+	ADM_assert(cache);
+    // Make sure frame is an intra
+    demuxer-&gt;getFlags(frame,&amp;flags);
+    ADM_assert(flags==AVI_KEY_FRAME);
+
+    bool found=false;
+    vid-&gt;lastSentFrame=frame;
+    uint32_t nbFrames=vid-&gt;_nb_video_frames;
+    aprintf(&quot;[EditorRender] DecodeUpToIntra flushing cache &amp; codec\n&quot;);
+    cache-&gt;flush();
+    vid-&gt;decoder-&gt;flush();
+    // The PTS associated with our frame is the one we are looking for
+    uint64_t wantedPts=demuxer-&gt;estimatePts(frame);
+    uint32_t tries=15+7; // Max Ref frames for H264 + MaxRecovery , let's say 7 is ok for recovery
+    bool syncFound=false;
+    while(found==false &amp;&amp; tries--)
+    {
+        // Last frame ? if so repeat
+        if(vid-&gt;lastSentFrame&gt;=nbFrames-1) vid-&gt;lastSentFrame=nbFrames-1;
+        // Fetch frame
+         aprintf(&quot;[Editor] Decoding  frame %u\n&quot;,vid-&gt;lastSentFrame);
+         
+         if (!demuxer-&gt;getFrame (vid-&gt;lastSentFrame,&amp;img))
+         {
+                ADM_warning(&quot; getFrame failed for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
+                //cache-&gt;flush();
+                return false;
+         }
+         // Now uncompress it...
+         result=cache-&gt;getFreeImage();
+         if(frame==0) // out first frame, make sure it starts black to avoid the all green effect
+         {
+            result-&gt;blacken();
+         }
+         if(!result)
+         {
+                ADM_warning(&quot; Cache full for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
+                return false;
+          }
+           aprintf(&quot;[Decoder] Demuxer Frame %&quot;LU&quot; pts=%&quot;LLU&quot; ms, %&quot;LLU&quot; us\n&quot;,vid-&gt;lastSentFrame,img.demuxerPts/1000,
+                                                                    img.demuxerPts);
+          if(!decompressImage(result,&amp;img,ref))
+          {
+             ADM_warning(&quot; decode error for frame %&quot;LU&quot;\n&quot;,vid-&gt;lastSentFrame);
+             //cache-&gt;dump();
+             cache-&gt;invalidate(result);
+             //cache-&gt;dump();
+             vid-&gt;lastSentFrame++;
+             continue;
+          }else
+            {
+                cache-&gt;updateFrameNum(result,vid-&gt;lastSentFrame);
+                uint64_t pts=result-&gt;Pts;
+                aprintf(&quot;[Decoder] Decoder Frame %&quot;LU&quot; pts=%&quot;LLU&quot; ms, %&quot;LLU&quot; us\n&quot;,vid-&gt;lastSentFrame,
+                                                        result-&gt;Pts/1000,result-&gt;Pts);
+                if(pts==ADM_COMPRESSED_NO_PTS) // No PTS available ?
+                {
+                   
+                    if(false==syncFound)
+                    {
+                        aprintf(&quot;[DecodePictureUpToIntra] No time stamp yet, dropping picture\n&quot;);
+                        cache-&gt;invalidate(result);
+                    }else
+                    {
+                        // increment it using average fps
+                        vid-&gt;lastDecodedPts+=vid-&gt;timeIncrementInUs;
+                        result-&gt;Pts=vid-&gt;lastDecodedPts;
+                    }
+                }else
+                {
+                    if(false==syncFound)
+                    {
+                        aprintf(&quot;[DecodePictureUpToIntra] Sync found\n&quot;);
+                        syncFound=true;
+                    }
+                    vid-&gt;lastDecodedPts=pts;
+                }
+            }
+
+            // Found our image ?
+          if(result-&gt;Pts==wantedPts)
+                found=true;
+          else
+                vid-&gt;lastSentFrame++;
+    }
+    if(found==false)
+    {
+        ADM_warning(&quot; Could not find decoded frame, wanted PTS :%&quot;LU&quot; PTS=%&quot;LLU&quot; ms, %&quot;LLU&quot; us\n&quot;,frame,wantedPts/1000,wantedPts);
+        cache-&gt;dump();
+        return false;
+    }
+    vid-&gt;lastReadPts=wantedPts;
+    currentFrame=frame;
+    return true;
+}
+
+#if 0
+
+/**
+    \fn decodeCache
+    \brief Decode an image an update cache
+    @param ref:index of reference video
+    @param frame:Frame to decode
+    @param image where to put the decoded image
+    @return true if a frame is available
+*/
+
+ bool		ADM_Composer::decodeCache(uint32_t ref, uint32_t frame,ADMImage *image)
+{
+
+uint32_t sumit;
+float	 sum;
+
+_VIDEOS *v=_segments.getRefVideo(ref); // FIXME!!!!
+EditorCache *cache=v-&gt;_videoCache;
+ADMImage *tmpImage=NULL;
+uint8_t refOnly=0;
+uint32_t left,ww;
+ADMCompressedImage img;
+
+        aprintf(&quot;decodeCache : original :%&quot;LD&quot; Frame in ref %&quot;LD&quot;\n&quot;,frame,refOffset);
+        img.data=compBuffer;
+        img.cleanup(frame);
+        // Step 1, retrieve the compressed datas, including PTS &amp; DTS infos
+         if (!v-&gt;_aviheader-&gt;getFrame (frame,&amp;img))
+        {
+          ADM_warning (&quot;Editor: last decoding failed.%&quot;LD&quot;)\n&quot;,   frame );
+          return 0;
+        }
+        ADM_assert(_imageBuffer);
+
+        // if len is 0 then take the previous image
+        //
+
+        refOnly=v-&gt;decoder-&gt;dontcopy(); // can we skip one memcpy ?
+
+        if(!img.dataLength &amp; refOnly &amp; !frame)      // Size is null = no image and we only got a pointer
+                                // copy the previous one
+        {
+                // First image
+
+                uint32_t page=_imageBuffer-&gt;_width*_imageBuffer-&gt;_height;
+                        memset(YPLANE(image),0,page);
+                        memset(UPLANE(image),128,page&gt;&gt;2);
+                        memset(VPLANE(image),128,page&gt;&gt;2);
+                        if(!frame)
+                                image-&gt;flags=AVI_KEY_FRAME;
+                        else
+                                image-&gt;flags=AVI_P_FRAME;
+                        image-&gt;_Qp=2;
+                        image-&gt;_qStride=0;
+                        return 1;
+        }
+
+        if(refOnly)
+        {       // This is only an empty Shell
+                uint32_t w,h;
+                if(_scratch) // Can we reuse the old scratch memory ?
+                {
+                    _scratch-&gt;getWidthHeight(&amp;w,&amp;h);
+                    if(w!=_imageBuffer-&gt;_width || _imageBuffer-&gt;_height!=h)
+                    {
+                        delete _scratch;
+                        _scratch=NULL;
+                    }
+                }
+                if(!_scratch)
+                {
+                  _scratch=new ADMImage(_imageBuffer-&gt;_width,_imageBuffer-&gt;_height,1);
+                }
+                tmpImage=_scratch;
+                ww=_imageBuffer-&gt;_width &amp; 0xfffff0;
+                left=_imageBuffer-&gt;_width &amp; 0xf;
+
+        }
+        else
+        {
+                tmpImage=_imageBuffer;
+                ww=_imageBuffer-&gt;_width;
+                left=0;
+       }
+	tmpImage-&gt;_colorspace=ADM_COLOR_YV12;
+	// Do pp, and use imageBuffer as intermediate buffer
+	if (!v-&gt;decoder-&gt;uncompress (&amp;img, tmpImage))
+	    {
+	      ADM_warning (&quot; Last Decoding2 failed for frame %&quot;LU&quot;\n&quot;,frame);
+	       // Try to dupe previous frame
+                if(frame)
+                {
+                        ADMImage *prev;
+                        prev=cache-&gt;getImage(frame-1);
+                        if(prev)
+                        {
+                                image-&gt;duplicate(prev);
+                                cache-&gt;updateFrameNum(image,frame);
+                                return 1;
+                        }
+                }
+                goto _next;
+           }
+
+        //
+        if(tmpImage-&gt;_noPicture &amp;&amp; refOnly &amp;&amp; frame)
+        {
+                cache-&gt;updateFrameNum(image,0xffffffffU);
+                return 0;
+        }
+	// If not quant and it is already YV12, we can stop here
+	if((!tmpImage-&gt;quant || !tmpImage-&gt;_qStride) &amp;&amp; tmpImage-&gt;_colorspace==ADM_COLOR_YV12)
+	{
+		image-&gt;_Qp=2;
+		image-&gt;duplicate(tmpImage);
+		cache-&gt;updateFrameNum(image,frame);
+          //      if(refOnly) delete tmpImage;
+		aprintf(&quot;EdCache: No quant avail\n&quot;);
+		return 1;
+	}
+	// We got everything, let's go
+	// 1 compute average quant
+	int qz;
+	sumit=0;
+        // Dupe infos
+        image-&gt;copyInfo(tmpImage);
+
+
+        // Do postprocessing if any
+	for(uint32_t z=0;z&lt;tmpImage-&gt;_qSize;z++)
+	{
+            qz=(int)tmpImage-&gt;quant[z];
+			sumit+=qz;
+	}
+	sumit+=(tmpImage-&gt;_qSize-1);
+//	sumit*=2;
+	sum=(float)sumit;
+	sum/=tmpImage-&gt;_qSize;
+	if(sum&gt;31) sum=31;
+	if(sum&lt;1) sum=1;
+
+        // update average Q
+	tmpImage-&gt;_Qp=image-&gt;_Qp=(uint32_t)floor(sum);
+
+	// Pp deactivated ?
+	if(!_pp.postProcType || !_pp.postProcStrength || tmpImage-&gt;_colorspace!=ADM_COLOR_YV12)
+     {
+        dupe(tmpImage,image,v);
+		cache-&gt;updateFrameNum(image,frame);
+               // if(refOnly) delete tmpImage;
+		aprintf(&quot;EdCache: Postproc disabled\n&quot;);
+		return 1;
+	}
+
+	int type;
+	#warning FIXME should be FF_I_TYPE/B/P
+	if(tmpImage-&gt;flags &amp; AVI_KEY_FRAME) type=1;
+		else if(tmpImage-&gt;flags &amp; AVI_B_FRAME) type=3;
+			else type=2;
+
+        ADM_assert(tmpImage-&gt;_colorspace==ADM_COLOR_YV12);
+
+	// we do postproc !
+	// keep
+	uint8_t *oBuff[3];
+	const uint8_t *iBuff[3];
+	int	strideTab[3];
+	int	strideTab2[3];
+	aviInfo _info;
+
+		getVideoInfo(&amp;_info);
+                if(refOnly)
+                {
+                        iBuff[0]= tmpImage-&gt;_planes[0];
+                        iBuff[1]= tmpImage-&gt;_planes[1];
+                        iBuff[2]= tmpImage-&gt;_planes[2];
+
+                        strideTab2[0]=_info.width;
+                        strideTab2[1]=_info.width&gt;&gt;1;
+                        strideTab2[2]=_info.width&gt;&gt;1;
+
+                        strideTab[0]=tmpImage-&gt;_planeStride[0];
+                        strideTab[1]=tmpImage-&gt;_planeStride[1];
+                        strideTab[2]=tmpImage-&gt;_planeStride[2];
+
+                }
+                else
+                {
+		        iBuff[0]= YPLANE((tmpImage));
+                iBuff[1]= UPLANE((tmpImage));
+                iBuff[2]= VPLANE((tmpImage));
+
+
+
+                        strideTab[0]=strideTab2[0]=_info.width;
+                        strideTab[1]=strideTab2[1]=_info.width&gt;&gt;1;
+                        strideTab[2]=strideTab2[2]=_info.width&gt;&gt;1;
+                }
+                if(_pp.swapuv)
+                {
+        	        oBuff[0]= YPLANE(image);
+                        oBuff[1]= VPLANE(image);
+                        oBuff[2]= UPLANE(image);
+                }else
+                {
+
+                        oBuff[0]= YPLANE(image);
+                        oBuff[1]= UPLANE(image);
+                        oBuff[2]= VPLANE(image);
+                }
+		 pp_postprocess(
+		 		iBuff,
+		 		strideTab,
+		 		oBuff,
+		 		strideTab2,
+		 		ww,
+		        	_info.height,
+		          	(int8_t *)(tmpImage-&gt;quant),
+		          	tmpImage-&gt;_qStride,
+		         	_pp.ppMode,
+		          	_pp.ppContext,
+		          	type);			// img type
+                /*
+                        If there is a chroma block that needs padding
+                        (width not multiple of 16) while postprocessing,
+                        we process up to the nearest 16 multiple and
+                        just copy luma &amp; chroma info that was left over
+                */
+                if(refOnly &amp;&amp; left)
+                {
+                        uint8_t *src,*dst;
+                        uint32_t stridein,strideout,right;
+                        right=_info.width-left;
+                        // Luma
+                        dst=YPLANE(image)+right;
+                        src=tmpImage-&gt;_planes[0]+right;
+                        stridein=tmpImage-&gt;_planeStride[0];
+                        strideout=_info.width;
+                        for(uint32_t y=_info.height;y&gt;0;y--)
+                        {
+                                memcpy(dst,src,left);
+                                dst+=strideout;
+                                src+=stridein;
+                        }
+                        // Chroma
+                        left&gt;&gt;=1;
+                        right&gt;&gt;=1;
+                        //
+                        dst=UPLANE(image)+right;
+                        src=tmpImage-&gt;_planes[1]+right;
+                        stridein=tmpImage-&gt;_planeStride[1];
+                        strideout=_info.width&gt;&gt;1;
+                        for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
+                        {
+                                memcpy(dst,src,left);
+                                dst+=strideout;
+                                src+=stridein;
+                        }
+                        //
+                        dst=VPLANE(image)+right;
+                        src=tmpImage-&gt;_planes[2]+right;
+                        stridein=tmpImage-&gt;_planeStride[2];
+                        strideout=_info.width&gt;&gt;1;
+                        for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
+                        {
+                                memcpy(dst,src,left);
+                                dst+=strideout;
+                                src+=stridein;
+                        }
+
+
+                }
+_next:
+        // update some infos
+        //   if(refOnly) delete tmpImage;
+		cache-&gt;updateFrameNum(image,frame);
+		aprintf(&quot;EdCache: Postproc done\n&quot;);
+		return 1;
+}
+#endif
+
+
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -168,108 +168,6 @@
 }
 
 /**
-    \fn searchFrameBefore
-    \brief Return the frame number with pts just before pts
-*/
-uint32_t ADM_Composer::searchFrameBefore(uint64_t pts)
-{
-uint64_t refTime;
-uint32_t ref;
-    if(false==_segments.getRefFromTime(pts,&amp;ref,&amp;refTime))
-    {
-        ADM_warning(&quot; Failed for pts %&quot;LLU&quot;\n&quot;,pts);
-        ref=0;
-        refTime=pts;
-    }
-#warning fix over-seg issue
-    _VIDEOS   *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid-&gt;_aviheader;
-    uint64_t  lastPts=demuxer-&gt;getTime(0);
-    uint32_t  nb=demuxer-&gt;getVideoStreamHeader()-&gt;dwLength;
-
-    if(lastPts&gt;pts) return 0;
-
-	for(int i=1;i&lt;nb-2;i++)
-    {
-        uint64_t cur,next;
-        cur=lastPts;
-        next=demuxer-&gt;getTime(i+1);
-        if(next==ADM_NO_PTS) next=cur+vid-&gt;timeIncrementInUs;
-        if(pts&gt;=cur &amp;&amp; pts&lt;next) return i-1;
-        lastPts=next;
-    }
-    return nb-1;
-}
-/**
-    \fn searchFrameBefore
-    \brief Return the frame number with pts just before pts
-*/
-uint32_t ADM_Composer::searchFrameAt(uint64_t pts)
-{
-uint64_t refTime;
-uint32_t ref;
-    if(false==_segments.getRefFromTime(pts,&amp;ref,&amp;refTime))
-    {
-        ADM_warning(&quot; Failed for pts %&quot;LLU&quot;\n&quot;,pts);
-        ref=0;
-        refTime=pts;
-    }
-#warning fix over-seg issue
-    _VIDEOS   *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid-&gt;_aviheader;
-    
-    uint32_t  nb=demuxer-&gt;getVideoStreamHeader()-&gt;dwLength;
-;
-
-	for(int i=0;i&lt;nb;i++)
-    {
-        uint64_t thisPts,thisDts;
-        demuxer-&gt;getPtsDts(i,&amp;thisPts,&amp;thisDts);
-        if(thisPts==ADM_NO_PTS) continue;
-        if(refTime==thisPts)
-        {
-            ADM_info(&quot;Found frame %&quot;LU&quot; for time %&quot;LLU&quot; ms\n&quot;,i,thisPts/1000);
-            return i;
-        }
-    }
-    ADM_warning(&quot;Cannot find frame at %&quot;LLU&quot;\n&quot;,pts);
-    return 0;
-}
-/**
-    \fn getImageFromCacheForFrameBefore
-    \brief Search the cache for the image with PTS just before the input PTS
-*/
-bool    ADM_Composer::getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out)
-{
-    int ref=0;
-    EditorCache   *cache;
-	_VIDEOS *vid=_segments.getRefVideo(0);
-	cache=vid-&gt;_videoCache;
-	ADM_assert(cache);
-        ADMImage *r=cache-&gt;findLastBefore(pts);
-        if(!r) return false;
-        out-&gt;duplicateFull(r);
-        return true;
-
-}
-/**
-    \fn getPtsDts
-    \brief Return PTS &amp; DTS for a given frame (in bitstream order)
-*/
-bool        ADM_Composer::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
-{
-uint32_t ref,refOffset;
-    if(_segments.getRefFromFrame(frame,&amp;ref,&amp;refOffset)==false)
-    {
-        ADM_warning(&quot;Cannot get ref video for frame %&quot;LD&quot;\n&quot;,frame);
-        return false;
-    }
- 
-     _VIDEOS   *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid-&gt;_aviheader;
-    return demuxer-&gt;getPtsDts(frame,pts,dts); // FIXME : Rescale frame number
-}
-/**
     \fn getDurationInUs
     \brief Return total duration of video in us
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -45,96 +45,10 @@
 
 }
 
-
 /**
-    \fn getFrame
-    \brief returns the raw frame from the demuxer with len pts &amp; dts
-*/
-uint8_t   ADM_Composer::getFrame (uint32_t framenum, ADMCompressedImage *img, uint8_t *isSeq)
-{
-  static uint32_t lastRef = 0, lastframe = 0;
-  ADM_TRANSLATE(getFrame,framenum)
+    \fn updateVideoInfo
 
-  if (ref)
-    {
-      if ((lastRef == ref) &amp;&amp; ((lastframe + 1) == refOffset))
-	{
-	  *isSeq = 1;
-	}
-      else
-	*isSeq = 0;
-    }
-  lastRef = ref;
-  lastframe = refOffset;
-  return _segments.getRefVideo(ref)-&gt;_aviheader-&gt;getFrame (refOffset,img);
-}
-
-
-/**
-    \fn getTime
-    \brief return or estimate the pts of frame fn
 */
-uint64_t ADM_Composer::getTime (uint32_t fn)
-{
-    
-    uint64_t t= STUBB-&gt;getTime(fn);
-    uint32_t org=fn;
-    if(t!=ADM_COMPRESSED_NO_PTS) return t;
-    if(!fn) return 0;
-
-    // Try to guess what is the time...
-    while(1)
-    {
-        fn--;
-        if(STUBB-&gt;getTime(fn)!=ADM_COMPRESSED_NO_PTS)
-        {
-            t=STUBB-&gt;getTime(fn);
-            t+= _segments.getRefVideo(0)-&gt;timeIncrementInUs*(org-fn);
-            return t;
-        }
-    }
-    ADM_warning(&quot;[ADM_Composer::getTime] Cannot estimate time for frame %u\n&quot;,org);
-    return 0;
-}
-/**
-    \fn getFlags
-*/
-uint32_t ADM_Composer::getFlags (uint32_t frame, uint32_t * flags)
-{
-    ADM_TRANSLATE(getFlags,frame);
-    return _segments.getRefVideo(ref)-&gt;_aviheader-&gt;getFlags (refOffset, flags);
-}
-/**
-    \fn getFlagsAndSeg
-*/
-uint32_t ADM_Composer::getFlagsAndSeg (uint32_t frame, uint32_t * flags,uint32_t *segs)
-{
- ADM_TRANSLATE(getFlagsAndSeg,frame);
-*segs=0;
-#warning fixme
- return _segments.getRefVideo(ref)-&gt;_aviheader-&gt;getFlags (refOffset, flags);
-}
-/**
-    \fn getFrameSize
-*/
-uint8_t ADM_Composer::getFrameSize (uint32_t frame, uint32_t * size)
-{
- 
-  ADM_TRANSLATE(getframeSize,frame);
-  return _segments.getRefVideo(ref)-&gt;_aviheader-&gt;getFrameSize (refOffset, size);
-}
-
-/**
-    \fn setFlag
-*/
-uint8_t ADM_Composer::setFlag (uint32_t frame, uint32_t flags)
-{
-    ADM_TRANSLATE(setFlag,frame);
-    return _segments.getRefVideo(ref)-&gt;_aviheader-&gt;setFlag (refOffset, flags);
-}
-
-//
-//
 uint8_t ADM_Composer::updateVideoInfo (aviInfo * info)
 {
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -55,9 +55,7 @@
   _audioseg = 0;
   _audiooffset = 0;
   _audioSample=0;
-  _lastseg = 99;
-  _lastframe = 99;
-  _haveMarkers=0; // only edl have markers
+
   // Initialize a default postprocessing (dummy)
   initPostProc(&amp;_pp,16,16);
   if(!prefs-&gt;get(DEFAULT_POSTPROC_TYPE,&amp;type)) type=3;
@@ -70,8 +68,7 @@
   updatePostProc(&amp;_pp);
   _imageBuffer=NULL;
   _internalFlags=0;
-  // Start with a clean base
-
+  _currentSegment=0;
 }
 /**
 	Remap 1:1 video to segments
@@ -132,7 +129,7 @@
   _VIDEOS video;
     memset(&amp;video,0,sizeof(video));
 
-	_haveMarkers=0; // by default no markers are present
+	
   
     FILE *f=fopen(name,&quot;r&quot;);
     uint8_t buffer[4];
@@ -556,36 +553,11 @@
       It can happen, for example in case of SBR audio such as AAC
       The demuxer says it is xx kHz, but the codec updates it to 2*xx kHz
 */
-uint8_t ADM_Composer::rebuildDuration(void)
+bool  ADM_Composer::rebuildDuration(void)
 {
-  return 1;
+  return true;
 }
 /**
-    \fn estimatePts
-    \brief Get or estimate PTS of given frame
-*/
-uint64_t    ADM_Composer::estimatePts(uint32_t frame)
-{
-    uint32_t flags;
-    _VIDEOS *vid=_segments.getRefVideo(0);
-    vidHeader *demuxer=vid-&gt;_aviheader;
-    int count=0;
-    uint64_t  wantedPts;
-	while(1)
-    {
-        demuxer-&gt;getFlags(frame,&amp;flags);
-        wantedPts=vid-&gt;_aviheader-&gt;getTime(frame);
-        if((flags &amp; AVI_KEY_FRAME)&amp;&amp;(wantedPts!=ADM_NO_PTS))
-        {
-                break;
-        }
-        count++;
-        frame--;
-    }
-    wantedPts+=vid-&gt;timeIncrementInUs*count;
-    return wantedPts;
-}
-/**
     \fn getCurrentFramePts
     \brief Get the PTS of current frame
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-20 13:26:48 UTC (rev 5392)
@@ -63,6 +63,31 @@
 class ADM_Composer : public ADM_audioStream
 {
   private:
+//*********************************PRIVATE API *******************************************
+                    bool		decodeCache(uint32_t ref, uint32_t frame,ADMImage *image);
+                    bool        switchToNextSegment(void);
+                    bool        switchToSegment(uint32_t s);
+                    uint32_t    currentFrame;
+
+                    bool        nextPictureInternal(uint32_t ref,ADMImage *image);
+                    bool        samePictureInternal(uint32_t ref,ADMImage *image);
+
+protected:
+                                /// Decode frame and on until frame is popped out of decoders
+                    bool        DecodePictureUpToIntra(uint32_t frame,uint32_t ref);
+                                /// compressed image-&gt;yb12 image image and do postproc/colorconversion
+                    bool        decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t ref);
+                                /// Decode next image
+                    bool        DecodeNextPicture(uint32_t ref);
+                                /// Get the next decoded picture
+                    bool     	getNextPicture(ADMImage *out,uint32_t ref);
+                                /// Get again last decoded picture
+                    bool        getSamePicture(ADMImage *out,uint32_t ref);
+
+                    bool        searchNextKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
+                    bool        searchPreviousKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
+//******************************************************************************************
+  private:
                     ADM_EditorSegment _segments;
                     uint8_t     dupe(ADMImage *src,ADMImage *dst,_VIDEOS *vid); 
                                                             // Duplicate img, do colorspace
@@ -70,16 +95,16 @@
   					uint32_t	_internalFlags;
   					ADM_PP 		_pp;
 					ADMImage	*_imageBuffer;
-  					uint8_t		decodeCache(uint32_t frame,uint32_t seg, ADMImage *image);
+  				
   					// _audiooffset points to the offset / the total segment
   					// not the used part !
   					uint32_t  _audioseg;
 					int64_t   _audioSample;
   					uint32_t  _audiooffset;
-					uint8_t	  _haveMarkers; // used for load/save edl
-                    
-       				uint32_t _lastseg,_lastframe,_lastlen;
 
+                    uint32_t  _currentSegment;
+       				//uint32_t _lastseg,_lastframe,_lastlen;
+
                     ADM_audioStreamTrack *getTrack(uint32_t i);
                     ADMImage    *_scratch;																		;
                     uint8_t  	updateAudioTrack(uint32_t seg);			   	
@@ -93,7 +118,7 @@
                     bool     	getExtraHeaderData(uint32_t *len, uint8_t **data);
                     uint32_t    getPARWidth(void);
                     uint32_t    getPARHeight(void);
-                    uint8_t     rebuildDuration(void);
+                    bool        rebuildDuration(void);
   								ADM_Composer();
   				virtual 			~ADM_Composer();
                     void		clean( void );
@@ -114,62 +139,13 @@
                     bool        setMarkerBPts(uint64_t pts);
 public:
 /************************************ Public API ***************************/
-protected:
-                    uint32_t    currentFrame;
-                    bool        GoToIntra(uint32_t frame);
-                    uint32_t    getCurrentFrame(void); 
-                    bool        setCurrentFrame(uint32_t frame);
-
-                    uint64_t    estimatePts(uint32_t frame);
 public:
-                    bool        getCompressedPicure(ADMCompressedImage *img);
-      
-public:
-                   
+                    bool        getCompressedPicture(ADMCompressedImage *img);
                     uint64_t    getCurrentFramePts(void);
-                   
-                    
-                    bool        GoToTime(uint64_t time);
-                    bool        GoToIntraTime(uint64_t time);
-                    bool        NextPicture(ADMImage *image);
+                    bool        goToTimeVideo(uint64_t time);
+                    bool        goToIntraTimeVideo(uint64_t time);
+                    bool        nextPicture(ADMImage *image);
                     bool        samePicture(ADMImage *image);
-
-                   // Fixme, framenumber !
-                    uint32_t    searchFrameBefore(uint64_t pts);
-                    uint32_t    searchFrameAt(uint64_t pts);
-                    bool        getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out);
-                    bool        getPictureJustBefore(uint64_t pts);
-                    bool        getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
-/************************************ Internal ******************************/
-protected:
-                                /// Decode frame and on until frame is popped out of decoders
-                    bool        DecodePictureUpToIntra(uint32_t frame,uint32_t ref);
-                                /// compressed image-&gt;yb12 image image and do postproc/colorconversion
-                    bool        decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t ref);
-                                /// Decode next image
-                    bool        DecodeNextPicture(uint32_t ref);
-                                /// Get the next decoded picture
-                    bool     	getNextPicture(ADMImage *out,uint32_t ref);
-                                /// Get again last decoded picture
-                    bool        getSamePicture(ADMImage *out,uint32_t ref);
-
-                    bool        searchNextKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
-                    bool        searchPreviousKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
-
-/************************************ Internal ******************************/
-protected:
-                    uint8_t 	getFrame(uint32_t   framenum,ADMCompressedImage *img,uint8_t *isSequential);
-                    
-                
-                    uint64_t 	getTime(uint32_t fn);
-                    uint32_t 	getFlags(uint32_t frame,uint32_t *flags);
-
-                            // B follow A with just Bframes in between
-                    uint32_t 	getFlagsAndSeg (uint32_t frame,    uint32_t * flags,uint32_t *segs);
-                    uint8_t  	setFlag(uint32_t frame,uint32_t flags);
-
-                    uint8_t  	getFrameSize(uint32_t frame,uint32_t *size) ;
-
 public:
                     uint8_t	    updateVideoInfo(aviInfo *info);
                     uint32_t 	getSpecificMpeg4Info( void );
@@ -210,12 +186,6 @@
 					
 					
 /***************************************** Seeking *****************************/            
-protected:
-		  			bool			getPKFrame(uint32_t *frame);
-					bool			getNKFrame(uint32_t *frame);
-
-                    
-                    bool			getUncompressedFrame(uint32_t frame,ADMImage *out,uint32_t *flagz=NULL);
 public:
                     bool			getNKFramePTS(uint64_t *frameTime);
                     bool			getPKFramePTS(uint64_t *frameTime);   

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -239,24 +239,6 @@
     return true;
 }
 /**
-    \fn getRefFromFrame
-*/
-bool        ADM_EditorSegment::getRefFromFrame(uint32_t frame,uint32_t *refVideo, uint32_t *frameOffset)
-{
-    *refVideo=0;
-    *frameOffset=frame;
-    return true;
-}
-/**
-    \fn getFrameFromRef
-*/
-bool        ADM_EditorSegment::getFrameFromRef(uint32_t *frame,uint32_t refVideo, uint32_t frameOffset)
-{
-    *frame=frameOffset;
-    return true;
-
-}
-/**
     \fn ~ADM_audioStreamTrack
 */
  ADM_audioStreamTrack::~ADM_audioStreamTrack()
@@ -300,4 +282,59 @@
     *frameTime=segTime+segments[seg]._startTimeUs;
     return true;
 }
+/**
+    \fn TimeToFrame
+    \brief return the frameno whose PTS==time
+*/
+static bool TimeToFrame(_VIDEOS *v,uint64_t time,uint32_t *frame,uint32_t *oflags)
+{
+    vidHeader 							*demuxer=v-&gt;_aviheader;  
+    int nb=demuxer-&gt;getMainHeader()-&gt;dwTotalFrames;
+    for(int i=0;i&lt;nb;i++)
+    {
+        uint64_t pts,dts;
+        uint32_t flags;
+            demuxer-&gt;getPtsDts(i,&amp;pts,&amp;dts);
+            demuxer-&gt;getFlags(i,&amp;flags);
+            if(pts==time)
+            {
+                *frame=i;
+                *oflags=flags;
+                return true;
+            }
+            if(pts!=ADM_NO_PTS &amp;&amp;pts&gt;time) return false;
+    }
+    return false;
+}
+/**
+    \fn intraTimeToFrame
+    \brief Return the frame whosePTS==seektime, assert if does not exist
+*/
+uint32_t    ADM_EditorSegment::intraTimeToFrame(uint32_t refVideo,uint64_t seekTime)
+{
+        uint32_t frame;
+        uint32_t flags;
+        _VIDEOS *v=getRefVideo(refVideo);
+        ADM_assert(v);
+        if(false==TimeToFrame(v,seekTime,&amp;frame,&amp;flags))
+        {
+            ADM_assert(0);
+        }
+        ADM_assert(flags &amp; AVI_KEY_FRAME);
+        return frame;
+}
+/**
+    \fn         isKeyFrameByTime
+    \brief      Return true if frame with PTS==seektime is a keyframe
+*/
+bool        ADM_EditorSegment::isKeyFrameByTime(uint32_t refVideo,uint64_t seekTime)
+{
+        uint32_t frame;
+        uint32_t flags;
+        _VIDEOS *v=getRefVideo(refVideo);
+        ADM_assert(v);
+        if(false==TimeToFrame(v,seekTime,&amp;frame,&amp;flags)) return false;
+        if(flags &amp; AVI_KEY_FRAME) return true;
+        return false;
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-20 13:26:48 UTC (rev 5392)
@@ -81,6 +81,7 @@
     uint64_t                            _startTimeUs;     /// Start time in current (=sum(_duration of previous seg))
 	uint64_t							_durationUs;      ///
     uint32_t                            _nbFrame;
+    uint32_t                            _curFrame;        ///
 }_SEGMENT;
 /*
     Use vectors to store our videos &amp; segments
@@ -97,7 +98,6 @@
         ListOfSegments segments;
         ListOfVideos   videos;
         bool           updateStartTime(void);
-        uint32_t       currentSeg;
 
 public:
                         ADM_EditorSegment(void);
@@ -117,14 +117,14 @@
 
             bool        getRefFromTime(uint64_t time,uint32_t *refVideo, uint64_t *offset);
 
-            bool        getRefFromFrame(uint32_t frame,uint32_t *refVideo, uint32_t *frameOffset);
-            bool        getFrameFromRef(uint32_t *frame,uint32_t refVideo, uint32_t frameOffset);
-
-
             bool        convertLinearTimeToSeg(  uint64_t frameTime, uint32_t *seg, uint64_t *segTime);
             bool        convertSegTimeToLinear(  uint32_t seg,uint64_t segTime, uint64_t *frameTime);
 
             _SEGMENT    *getCurrentSeg(void);
+
+
+            uint32_t    intraTimeToFrame(uint32_t refVideo,uint64_t seekTime);       
+            bool        isKeyFrameByTime(uint32_t refVideo,uint64_t seekTime);
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt	2009-10-20 13:26:48 UTC (rev 5392)
@@ -7,6 +7,7 @@
 ADM_edFrameType.cpp 
 ADM_edit.cpp 
 ADM_edRender.cpp 
+ADM_edRenderInternal.cpp 
 ADM_edMarker.cpp
 ADM_edStub.cpp
 ADM_edPtsDts.cpp

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -40,7 +40,7 @@
     eofMet=false;
     this-&gt;startTime=realStart;
     this-&gt;endTime=endTime;
-    video_body-&gt;GoToIntraTime(realStart);
+    video_body-&gt;goToIntraTimeVideo(realStart);
     ADM_info(&quot; Fixating start time by %u\n&quot;,abs((int)(this-&gt;startTime-startTime)));
 }
 /**
@@ -83,7 +83,7 @@
 {
     if(true==eofMet) return false;
     image.data=data;
-    if(false==video_body-&gt;getCompressedPicure(&amp;image))
+    if(false==video_body-&gt;getCompressedPicture(&amp;image))
     {
             ADM_warning(&quot; Get packet failed &quot;);
             return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -352,7 +352,7 @@
 
 bool admPreview::seekToIntraPts(uint64_t timeframe)
 {
-    if(!video_body-&gt;GoToIntraTime(timeframe)) 
+    if(!video_body-&gt;goToIntraTimeVideo(timeframe)) 
     {
         ADM_warning(&quot; seeking for frame at %&quot;LLU&quot; ms failed\n&quot;,timeframe/1000LL);
         return false;
@@ -405,7 +405,7 @@
         }
 #else
 
-        if(!video_body-&gt;NextPicture(rdrImage)) return 0;
+        if(!video_body-&gt;nextPicture(rdrImage)) return 0;
 #endif
             UI_setFrameType(  rdrImage-&gt;flags,rdrImage-&gt;_Qp);
 
@@ -672,6 +672,7 @@
 */
 bool admPreview::previousFrame(void)
 {
+#if 0
     uint64_t pts=rdrImage-&gt;Pts;
     // If the frame is not an intra, the previous one
     // is still in the cache
@@ -685,7 +686,7 @@
         }
         return false;
     }
-#if 0
+
     // Else go to the previous  keyframe...
     if(!video_body-&gt;getPKFrame(&amp;frame)) return false;
     if(!video_body-&gt;GoToIntra(frame)) return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -46,7 +46,7 @@
 bool ADM_videoFilterBridge::rewind(void)
 {
     printf(&quot;[VideoBridge] Goint to %&quot;LU&quot; ms\n&quot;,(uint32_t)(startTime/1000));
-    video_body-&gt;GoToTime(startTime);
+    video_body-&gt;goToTimeVideo(startTime);
     firstImage=true;
     lastSentImage=0;
     return true;
@@ -75,7 +75,7 @@
         lastSentImage=0;
     }else
     {
-        r=   video_body-&gt;NextPicture(image);
+        r=   video_body-&gt;nextPicture(image);
         lastSentImage++;
     }
     if(r==false) return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -37,7 +37,7 @@
 extern void UI_purge(void);
 extern uint8_t DIA_gotoTime(uint16_t *hh, uint16_t *mm, uint16_t *ss);
 extern bool SliderIsShifted;
-
+bool   GUI_GoToTime(uint64_t time);
 uint8_t A_jumpToTime(uint32_t hh,uint32_t mm,uint32_t ss,uint32_t ms);
 /**
     \fn HandleAction_Navigate
@@ -81,8 +81,7 @@
                 uint64_t pts;
                 if(action==ACT_GotoMarkA) pts=video_body-&gt;getMarkerAPts();
                         else  pts=video_body-&gt;getMarkerBPts();
-                 uint32_t frame=video_body-&gt;searchFrameBefore(pts);
-                  GUI_GoToFrame(frame);
+                GUI_GoToTime(pts);
                  
             }
             break;
@@ -450,9 +449,16 @@
         pts*=1000;
         pts+=ms;
         pts*=1000;
-        uint32_t frame=video_body-&gt;searchFrameBefore(pts);
-        return GUI_GoToFrame(frame);
 
+        return GUI_GoToTime(pts);
+
 }
-
+/**
+    \fn GUI_GoToTime
+*/
+bool GUI_GoToTime(uint64_t time)
+{
+    ADM_warning(&quot;GUI_GoToTime called\n&quot;);
+    return false; 
+}   
 // EOF


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002602.html">[Avidemux-svn-commit] r5391 - in	branches/avidemux_2.6_branch_mean/avidemux/common:	ADM_commonUI ADM_editor ADM_muxerGate/src
</A></li>
	<LI>Next message: <A HREF="002604.html">[Avidemux-svn-commit] r5393 - in	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2603">[ date ]</a>
              <a href="thread.html#2603">[ thread ]</a>
              <a href="subject.html#2603">[ subject ]</a>
              <a href="author.html#2603">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
