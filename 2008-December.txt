From mean at mail.berlios.de  Wed Dec 17 19:21:02 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 17 Dec 2008 19:21:02 +0100
Subject: [Avidemux-svn-commit] r4500 - branches/avidemux_2.4_branch
Message-ID: <200812171821.mBHIL2ZK013273@sheep.berlios.de>

Author: mean
Date: 2008-12-17 19:21:01 +0100 (Wed, 17 Dec 2008)
New Revision: 4500

Modified:
   branches/avidemux_2.4_branch/ConfigureChecks.cmake
   branches/avidemux_2.4_branch/config.h.cmake
Log:
[dca] Try also linking libdca if libdts fails

Modified: branches/avidemux_2.4_branch/ConfigureChecks.cmake
===================================================================
--- branches/avidemux_2.4_branch/ConfigureChecks.cmake	2008-11-05 19:54:07 UTC (rev 4499)
+++ branches/avidemux_2.4_branch/ConfigureChecks.cmake	2008-12-17 18:21:01 UTC (rev 4500)
@@ -480,7 +480,18 @@
 IF (USE_LATE_BINDING)
 	CHECK_INCLUDE_FILES(dts.h USE_LIBDCA)
 ELSE (USE_LATE_BINDING)
-	ADM_CHECK_HL(libdca dts.h dts dts_init USE_LIBDCA)
+	ADM_CHECK_HL(libdca dts.h dts dts_init USE_LIBDCA_A)
+        if(NOT USE_LIBDCA_A)
+                MESSAGE(STATUS "Trying libdca instead of libdts")
+	        ADM_CHECK_HL(libdca dts.h dca dca_init USE_LIBDCA_B)
+                if(USE_LIBDCA_B)
+                        SET(USE_DCA_INSTEAD_OF_DTS 1)
+                        SET(USE_LIBDCA 1)
+                endif(USE_LIBDCA_B)
+                
+        else(NOT USE_LIBDCA_A)
+                SET(USE_LIBDCA 1)
+        endif(NOT USE_LIBDCA_A)
 ENDIF (USE_LATE_BINDING)
 
 SET(CMAKE_REQUIRED_LIBRARIES)

Modified: branches/avidemux_2.4_branch/config.h.cmake
===================================================================
--- branches/avidemux_2.4_branch/config.h.cmake	2008-11-05 19:54:07 UTC (rev 4499)
+++ branches/avidemux_2.4_branch/config.h.cmake	2008-12-17 18:21:01 UTC (rev 4500)
@@ -220,6 +220,7 @@
 
 /* libdca detected */
 #cmakedefine USE_LIBDCA
+#cmakedefine USE_DCA_INSTEAD_OF_DTS
 
 /* Libxml2 is available */
 #cmakedefine USE_LIBXML2



From mean at mail.berlios.de  Wed Dec 17 19:21:33 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 17 Dec 2008 19:21:33 +0100
Subject: [Avidemux-svn-commit] r4501 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska
Message-ID: <200812171821.mBHILXat013615@sheep.berlios.de>

Author: mean
Date: 2008-12-17 19:21:33 +0100 (Wed, 17 Dec 2008)
New Revision: 4501

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp
Log:
[mkv] Properly identify DTS audio inside mkv

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp	2008-12-17 18:21:01 UTC (rev 4500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp	2008-12-17 18:21:33 UTC (rev 4501)
@@ -48,6 +48,7 @@
   
   {"A_AAC",0,WAV_AAC,""},
   {"A_VORBIS",0,WAV_OGG,""},
+  {"A_DTS",0,WAV_DTS,""},
   
   // Video
   {"V_MPEG2",1,0,"MPEG"}, // Mpeg2



From gruntster at mail.berlios.de  Sat Dec 27 21:38:58 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 27 Dec 2008 21:38:58 +0100
Subject: [Avidemux-svn-commit] r4502 -
	branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mp4
Message-ID: <200812272038.mBRKcwpi025041@sheep.berlios.de>

Author: gruntster
Date: 2008-12-27 21:38:45 +0100 (Sat, 27 Dec 2008)
New Revision: 4502

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mp4/oplug_mp4.cpp
Log:
[mp4] correctly generate extra data for esds atom (fixes regression in r4375)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mp4/oplug_mp4.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mp4/oplug_mp4.cpp	2008-12-17 18:21:33 UTC (rev 4501)
+++ branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mp4/oplug_mp4.cpp	2008-12-27 20:38:45 UTC (rev 4502)
@@ -199,27 +199,9 @@
                         videoExtraData=new uint8_t[videoExtraDataSize];
                         memcpy(videoExtraData,dummy,videoExtraDataSize);
                 }
-        // _________________Setup video (cont) _______________
-             
-             ADM_assert(_encode);
-             bitstream.data=videoBuffer;
 
-           // If needed get VOL header
-           if(isMpeg4Compatible(info.fcc) && !videoExtraDataSize && bitstream.len)
-           {
-                // And put them as extradata for esds atom
-                uint32_t voslen=0;
-               
-                if(extractVolHeader(videoBuffer,bitstream.len,&voslen))
-                {
-                        if(voslen)
-                        {
-                                videoExtraDataSize=voslen;
-                                videoExtraData=new uint8_t[videoExtraDataSize];
-                                memcpy(videoExtraData,videoBuffer,videoExtraDataSize);
-                        }
-                } else  printf("Oops should be settings data for esds\n");
-            }
+				ADM_assert(_encode);
+				bitstream.data = videoBuffer;
 
 // ____________Setup audio__________________
           if(currentaudiostream)
@@ -260,16 +242,7 @@
            {
                 encoding_gui->setAudioCodec(QT_TR_NOOP("None"));
            }
-// ____________Setup Muxer _____________________
-           muxer= new lavMuxer;
-           
-           if(!muxer->open(
-                name,
-                2000000, // Muxrate
-                muxerType,
-                &info,videoExtraDataSize,videoExtraData,
-                audioinfo,extraDataSize,extraData))
-                         goto stopit;
+
 //_____________ Loop _____________________
           
           encoding_gui->setContainer(containerTitle);
@@ -302,25 +275,6 @@
 				  break;
 			  }
 
-			  while (muxer->needAudio())
-			  {
-				  if (pq->Pop(audioBuffer, &alen, &sample))
-				  {
-					  if (alen)
-					  {
-						  muxer->writeAudioPacket(alen, audioBuffer, sample_got);
-						  totalAudioSize += alen;
-						  encoding_gui->setAudioSize(totalAudioSize);
-						  sample_got += sample;
-					  }
-				  }
-				  else
-				  {
-					  r = 0;
-					  break;
-				  }
-			  }
-
 			  for (;;)
 			  {
 				  bitstream.cleanup(frame);
@@ -370,6 +324,57 @@
 			  if (!r)
 				  break;
 
+			  if (!muxer)
+			  {
+				  // If needed get VOL header
+				  if (isMpeg4Compatible(info.fcc) && !videoExtraDataSize && bitstream.len)
+				  {
+					  // And put them as extradata for esds atom
+					  uint32_t voslen = 0;
+
+					  if(extractVolHeader(videoBuffer, bitstream.len, &voslen))
+					  {
+						  if (voslen)
+						  {
+							  videoExtraDataSize = voslen;
+							  videoExtraData = new uint8_t[videoExtraDataSize];
+							  memcpy(videoExtraData, videoBuffer, videoExtraDataSize);
+						  }
+					  }
+					  else 
+						  printf("Oops should be settings data for esds\n");
+				  }
+
+				  muxer = new lavMuxer;
+
+				  if (!muxer->open(
+					  name,
+					  2000000, // Muxrate
+					  muxerType,
+					  &info, videoExtraDataSize, videoExtraData,
+					  audioinfo, extraDataSize, extraData))
+					  break;
+			  }
+
+			  while (muxer->needAudio())
+			  {
+				  if (pq->Pop(audioBuffer, &alen, &sample))
+				  {
+					  if (alen)
+					  {
+						  muxer->writeAudioPacket(alen, audioBuffer, sample_got);
+						  totalAudioSize += alen;
+						  encoding_gui->setAudioSize(totalAudioSize);
+						  sample_got += sample;
+					  }
+				  }
+				  else
+				  {
+					  r = 0;
+					  break;
+				  }
+			  }
+
 			  muxer->writeVideoPacket(&bitstream);
 			  encoding_gui->setFrame(frame, bitstream.len, bitstream.out_quantizer, total);
 		  }



From gruntster at mail.berlios.de  Tue Dec 30 21:21:53 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 30 Dec 2008 21:21:53 +0100
Subject: [Avidemux-svn-commit] r4503 - in
	branches/avidemux_2.4_branch/avidemux: ADM_codecs
	ADM_inputs/ADM_inpics
Message-ID: <200812302021.mBUKLruM010923@sheep.berlios.de>

Author: gruntster
Date: 2008-12-30 21:21:38 +0100 (Tue, 30 Dec 2008)
New Revision: 4503

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_inpics/ADM_pics.cpp
Log:
[rawvid] use libavcodec decoder instead of internal for raw video and support BGR24 colourspace

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-12-27 20:38:45 UTC (rev 4502)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-12-30 20:21:38 UTC (rev 4503)
@@ -396,21 +396,18 @@
       return (decoders *) (new decoderFFVP6F (w, h,extraLen,extraData));
     }
 
+  if (fourCC::check (fcc, (uint8_t *) "BMP "))
+  {
+	  printf ("\n using RGB codec\n");
+	  return (decoders *) (new decoderRGB16(w, h, 1, bpp));
+  }
 
-  if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) "RGB "))
-    {
-      // RGB 16 Codecs
-      printf ("\n using RGB codec\n");
-      return (decoders *) (new decoderRGB16 (w, h, 1, bpp));
+  if (fcc == 0 || fourCC::check(fcc, (uint8_t *) "RGB ") || fourCC::check(fcc, (uint8_t *) "DIB "))
+  {
+	  printf ("\n using Rawvideo codec, BPP: %d\n", bpp);
+	  return (decoders *) (new decoderFFRaw(w, h, bpp));
+  }
 
-    }
- if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) "DIB "))
-    {
-      // RGB 16 Codecs
-      printf ("\n using DIB codec\n");
-      return (decoders *) (new decoderRGB16 (w, h, 0, bpp));
-
-    }
   if (isMpeg12Compatible (fcc))
     {
       uint32_t lavcodec_mpeg = 0;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2008-12-27 20:38:45 UTC (rev 4502)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2008-12-30 20:21:38 UTC (rev 4503)
@@ -417,6 +417,9 @@
       // we do it or not
       out->_colorspace = ADM_COLOR_YV12;
       break;
+	case PIX_FMT_BGR24:
+	  out->_colorspace = ADM_COLOR_BGR24;
+	  break;
 	case PIX_FMT_RGB24:
 	  out->_colorspace = ADM_COLOR_RGB24;
 	  break;
@@ -558,6 +561,12 @@
   _context->pix_fmt = PIX_FMT_GRAY8;
 }
 
+decoderFFRaw::decoderFFRaw(uint32_t w, uint32_t h, uint32_t bpp) : decoderFF (w, h)
+{
+	_context->bits_per_sample = bpp;
+	WRAP_Open (CODEC_ID_RAWVIDEO);
+}
+
 decoderFFPng::decoderFFPng (uint32_t w, uint32_t h):decoderFF (w, h)
 {
   WRAP_Open (CODEC_ID_PNG);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h	2008-12-27 20:38:45 UTC (rev 4502)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h	2008-12-30 20:21:38 UTC (rev 4503)
@@ -261,6 +261,12 @@
   decoderFFY800 (uint32_t w, uint32_t h);
 };
 
+class decoderFFRaw : public decoderFF
+{
+public:
+	decoderFFRaw(uint32_t w, uint32_t h, uint32_t bpp);
+};
+
 class decoderFFPng : public decoderFF
 {
 public:

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_inpics/ADM_pics.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_inpics/ADM_pics.cpp	2008-12-27 20:38:45 UTC (rev 4502)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_inpics/ADM_pics.cpp	2008-12-30 20:21:38 UTC (rev 4503)
@@ -407,7 +407,7 @@
 	        break;
 	    case PIC_BMP:
 	    case PIC_BMP2:
-	        _video_bih.biCompression = _videostream.fccHandler = fourCC::get((uint8_t *) "DIB ");
+	        _video_bih.biCompression = _videostream.fccHandler = fourCC::get((uint8_t *) "BMP ");
 	        break;
 	    case PIC_PNG:
 	        _video_bih.biCompression = _videostream.fccHandler =



From gruntster at mail.berlios.de  Tue Dec 30 21:29:12 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 30 Dec 2008 21:29:12 +0100
Subject: [Avidemux-svn-commit] r4504 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libswscale
Message-ID: <200812302029.mBUKTCBA012099@sheep.berlios.de>

Author: gruntster
Date: 2008-12-30 21:29:02 +0100 (Tue, 30 Dec 2008)
New Revision: 4504

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libswscale/swscale_template.c
Log:
[swscale] rename rgb/bgr 15/16 function names to match actual implementation (backport of r24965)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libswscale/swscale_template.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libswscale/swscale_template.c	2008-12-30 20:21:38 UTC (rev 4503)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libswscale/swscale_template.c	2008-12-30 20:29:02 UTC (rev 4504)
@@ -2073,7 +2073,7 @@
     assert(src1 == src2);
 }
 
-static inline void RENAME(bgr16ToY)(uint8_t *dst, uint8_t *src, int width)
+static inline void RENAME(rgb16ToY)(uint8_t *dst, uint8_t *src, int width)
 {
     int i;
     for (i=0; i<width; i++)
@@ -2087,7 +2087,7 @@
     }
 }
 
-static inline void RENAME(bgr16ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
+static inline void RENAME(rgb16ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
 {
     int i;
     assert(src1==src2);
@@ -2109,7 +2109,7 @@
     }
 }
 
-static inline void RENAME(bgr15ToY)(uint8_t *dst, uint8_t *src, int width)
+static inline void RENAME(rgb15ToY)(uint8_t *dst, uint8_t *src, int width)
 {
     int i;
     for (i=0; i<width; i++)
@@ -2123,7 +2123,7 @@
     }
 }
 
-static inline void RENAME(bgr15ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
+static inline void RENAME(rgb15ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
 {
     int i;
     assert(src1==src2);
@@ -2206,7 +2206,7 @@
     }
 }
 
-static inline void RENAME(rgb16ToY)(uint8_t *dst, uint8_t *src, int width)
+static inline void RENAME(bgr16ToY)(uint8_t *dst, uint8_t *src, int width)
 {
     int i;
     for (i=0; i<width; i++)
@@ -2220,7 +2220,7 @@
     }
 }
 
-static inline void RENAME(rgb16ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
+static inline void RENAME(bgr16ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
 {
     int i;
     assert(src1 == src2);
@@ -2239,7 +2239,7 @@
     }
 }
 
-static inline void RENAME(rgb15ToY)(uint8_t *dst, uint8_t *src, int width)
+static inline void RENAME(bgr15ToY)(uint8_t *dst, uint8_t *src, int width)
 {
     int i;
     for (i=0; i<width; i++)
@@ -2253,7 +2253,7 @@
     }
 }
 
-static inline void RENAME(rgb15ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
+static inline void RENAME(bgr15ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
 {
     int i;
     assert(src1 == src2);



From gruntster at mail.berlios.de  Tue Dec 30 22:06:53 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 30 Dec 2008 22:06:53 +0100
Subject: [Avidemux-svn-commit] r4505 - in
	branches/avidemux_2.4_branch/avidemux: ADM_codecs
	ADM_inputs/ADM_inpics ADM_libraries/ADM_lavcodec
Message-ID: <200812302106.mBUL6rUv018039@sheep.berlios.de>

Author: gruntster
Date: 2008-12-30 22:06:44 +0100 (Tue, 30 Dec 2008)
New Revision: 4505

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_inpics/ADM_pics.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h
Log:
[dib] use libavcodec decoder instead of internal for DIBs

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-12-30 20:29:02 UTC (rev 4504)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-12-30 21:06:44 UTC (rev 4505)
@@ -398,8 +398,8 @@
 
   if (fourCC::check (fcc, (uint8_t *) "BMP "))
   {
-	  printf ("\n using RGB codec\n");
-	  return (decoders *) (new decoderRGB16(w, h, 1, bpp));
+	  printf ("\n using BMP codec\n");
+	  return (decoders *) (new decoderFFBmp(w, h, extraLen, extraData));
   }
 
   if (fcc == 0 || fourCC::check(fcc, (uint8_t *) "RGB ") || fourCC::check(fcc, (uint8_t *) "DIB "))

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2008-12-30 20:29:02 UTC (rev 4504)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2008-12-30 21:06:44 UTC (rev 4505)
@@ -561,6 +561,13 @@
   _context->pix_fmt = PIX_FMT_GRAY8;
 }
 
+decoderFFBmp::decoderFFBmp(uint32_t w, uint32_t h, uint32_t l, uint8_t *d) : decoderFF (w, h)
+{
+	_context->extradata = (uint8_t*)d;
+	_context->extradata_size = (int)l;
+	WRAP_Open (CODEC_ID_BMP);
+}
+
 decoderFFRaw::decoderFFRaw(uint32_t w, uint32_t h, uint32_t bpp) : decoderFF (w, h)
 {
 	_context->bits_per_sample = bpp;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h	2008-12-30 20:29:02 UTC (rev 4504)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h	2008-12-30 21:06:44 UTC (rev 4505)
@@ -261,6 +261,12 @@
   decoderFFY800 (uint32_t w, uint32_t h);
 };
 
+class decoderFFBmp : public decoderFF
+{
+public:
+	decoderFFBmp(uint32_t w, uint32_t h, uint32_t l, uint8_t *d);
+};
+
 class decoderFFRaw : public decoderFF
 {
 public:

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_inpics/ADM_pics.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_inpics/ADM_pics.cpp	2008-12-30 20:29:02 UTC (rev 4504)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_inpics/ADM_pics.cpp	2008-12-30 21:06:44 UTC (rev 4505)
@@ -266,7 +266,7 @@
 		fclose(fd);
 		return 0;
 	    }
-	    _offset = bmph.size + 14;
+	    //_offset = bmph.size + 14;
 	    w = bmph.width;
 	    h = bmph.height;
 		bpp = bmph.numBitsPerPlane;
@@ -326,11 +326,11 @@
 
 	    fseek(fd, 10, SEEK_SET);
 
-#define MK32() (fcc_tab[0]+(fcc_tab[1]<<8)+(fcc_tab[2]<<16)+ \
-						(fcc_tab[3]<<24))
+//#define MK32() (fcc_tab[0]+(fcc_tab[1]<<8)+(fcc_tab[2]<<16)+ \
+						//(fcc_tab[3]<<24))
 
 	    fread(fcc_tab, 4, 1, fd);
-	    _offset = MK32();
+	    //_offset = MK32();
 	    // size, width height follow as int32 
 	    fread(&bmph, sizeof(bmph), 1, fd);
 #ifdef ADM_BIG_ENDIAN

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-12-30 20:29:02 UTC (rev 4504)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-12-30 21:06:44 UTC (rev 4505)
@@ -32,7 +32,7 @@
                 dvbsubdec.c
                 dvbsub.c xiph.c
                 sp5xdec.c nellymoserdec.c
-                rawdec.c rawenc.c
+                rawdec.c rawenc.c bmp.c
 )
 # ADD x86 ones
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2008-12-30 20:29:02 UTC (rev 4504)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2008-12-30 21:06:44 UTC (rev 4505)
@@ -70,7 +70,7 @@
                 wma.c \
                 dvbsub_parser.c \
                 dvbsubdec.c \
-                dvbsub.c xiph.c sp5xdec.c nellymoserdec.c
+                dvbsub.c xiph.c sp5xdec.c nellymoserdec.c bmp.c
 
 	
 

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.c	2008-12-30 20:29:02 UTC (rev 4504)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.c	2008-12-30 21:06:44 UTC (rev 4505)
@@ -0,0 +1,253 @@
+/*
+ * BMP image format decoder
+ * Copyright (c) 2005 Mans Rullgard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avcodec.h"
+#include "bytestream.h"
+#include "bmp.h"
+
+static int bmp_decode_init(AVCodecContext *avctx){
+    BMPContext *s = avctx->priv_data;
+
+    avcodec_get_frame_defaults((AVFrame*)&s->picture);
+    avctx->coded_frame = (AVFrame*)&s->picture;
+
+    return 0;
+}
+
+static int bmp_decode_frame(AVCodecContext *avctx,
+                            void *data, int *data_size,
+                            uint8_t *buf, int buf_size)
+{
+    BMPContext *s = avctx->priv_data;
+    AVFrame *picture = data;
+    AVFrame *p = &s->picture;
+    unsigned int fsize, hsize;
+    int width, height;
+    unsigned int depth;
+    BiCompression comp;
+    unsigned int ihsize;
+    int i, j, n, linesize;
+    uint32_t rgb[3];
+    uint8_t *ptr;
+    int dsize;
+    uint8_t *buf0 = buf;
+
+    if(buf_size < 14){
+        av_log(avctx, AV_LOG_ERROR, "buf size too small (%d)\n", buf_size);
+        return -1;
+    }
+
+    if(bytestream_get_byte(&buf) != 'B' ||
+       bytestream_get_byte(&buf) != 'M') {
+        av_log(avctx, AV_LOG_ERROR, "bad magic number\n");
+        return -1;
+    }
+
+    fsize = bytestream_get_le32(&buf);
+    if(buf_size < fsize){
+        av_log(avctx, AV_LOG_ERROR, "not enough data (%d < %d)\n",
+               buf_size, fsize);
+        return -1;
+    }
+
+    buf += 2; /* reserved1 */
+    buf += 2; /* reserved2 */
+
+    hsize = bytestream_get_le32(&buf); /* header size */
+    if(fsize <= hsize){
+        av_log(avctx, AV_LOG_ERROR, "not enough data (%d < %d)\n",
+               fsize, hsize);
+        return -1;
+    }
+
+    ihsize = bytestream_get_le32(&buf);       /* more header size */
+    if(ihsize + 14 > hsize){
+        av_log(avctx, AV_LOG_ERROR, "invalid header size %d\n", hsize);
+        return -1;
+    }
+
+    width = bytestream_get_le32(&buf);
+    height = bytestream_get_le32(&buf);
+
+    if(bytestream_get_le16(&buf) != 1){ /* planes */
+        av_log(avctx, AV_LOG_ERROR, "invalid BMP header\n");
+        return -1;
+    }
+
+    depth = bytestream_get_le16(&buf);
+
+    if(ihsize > 16)
+        comp = bytestream_get_le32(&buf);
+    else
+        comp = BMP_RGB;
+
+    if(comp != BMP_RGB && comp != BMP_BITFIELDS){
+        av_log(avctx, AV_LOG_ERROR, "BMP coding %d not supported\n", comp);
+        return -1;
+    }
+
+    if(comp == BMP_BITFIELDS){
+        buf += 20;
+        rgb[0] = bytestream_get_le32(&buf);
+        rgb[1] = bytestream_get_le32(&buf);
+        rgb[2] = bytestream_get_le32(&buf);
+    }
+
+    avctx->width = width;
+    avctx->height = height > 0? height: -height;
+
+    avctx->pix_fmt = PIX_FMT_NONE;
+
+    switch(depth){
+    case 32:
+        if(comp == BMP_BITFIELDS){
+            rgb[0] = (rgb[0] >> 15) & 3;
+            rgb[1] = (rgb[1] >> 15) & 3;
+            rgb[2] = (rgb[2] >> 15) & 3;
+
+            if(rgb[0] + rgb[1] + rgb[2] != 3 ||
+               rgb[0] == rgb[1] || rgb[0] == rgb[2] || rgb[1] == rgb[2]){
+                break;
+            }
+        } else {
+            rgb[0] = 2;
+            rgb[1] = 1;
+            rgb[2] = 0;
+        }
+
+        avctx->pix_fmt = PIX_FMT_BGR24;
+        break;
+    case 24:
+        avctx->pix_fmt = PIX_FMT_BGR24;
+        break;
+    case 16:
+        if(comp == BMP_RGB)
+            avctx->pix_fmt = PIX_FMT_RGB555;
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "depth %d not supported\n", depth);
+        return -1;
+    }
+
+    if(avctx->pix_fmt == PIX_FMT_NONE){
+        av_log(avctx, AV_LOG_ERROR, "unsupported pixel format\n");
+        return -1;
+    }
+
+    if(p->data[0])
+        avctx->release_buffer(avctx, p);
+
+    p->reference = 0;
+    if(avctx->get_buffer(avctx, p) < 0){
+        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
+        return -1;
+    }
+    p->pict_type = FF_I_TYPE;
+    p->key_frame = 1;
+
+    buf = buf0 + hsize;
+    dsize = buf_size - hsize;
+
+    /* Line size in file multiple of 4 */
+    n = (avctx->width * (depth / 8) + 3) & ~3;
+
+    if(n * avctx->height > dsize){
+        av_log(avctx, AV_LOG_ERROR, "not enough data (%d < %d)\n",
+               dsize, n * avctx->height);
+        return -1;
+    }
+
+    if(height > 0){
+        ptr = p->data[0] + (avctx->height - 1) * p->linesize[0];
+        linesize = -p->linesize[0];
+    } else {
+        ptr = p->data[0];
+        linesize = p->linesize[0];
+    }
+
+    switch(depth){
+    case 24:
+        for(i = 0; i < avctx->height; i++){
+            memcpy(ptr, buf, avctx->width*(depth>>3));
+            buf += n;
+            ptr += linesize;
+        }
+        break;
+    case 16:
+        for(i = 0; i < avctx->height; i++){
+            uint16_t *src = (uint16_t *) buf;
+            uint16_t *dst = (uint16_t *) ptr;
+
+            for(j = 0; j < avctx->width; j++)
+                *dst++ = le2me_16(*src++);
+
+            buf += n;
+            ptr += linesize;
+        }
+        break;
+    case 32:
+        for(i = 0; i < avctx->height; i++){
+            uint8_t *src = buf;
+            uint8_t *dst = ptr;
+
+            for(j = 0; j < avctx->width; j++){
+                dst[0] = src[rgb[2]];
+                dst[1] = src[rgb[1]];
+                dst[2] = src[rgb[0]];
+                dst += 3;
+                src += 4;
+            }
+
+            buf += n;
+            ptr += linesize;
+        }
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "BMP decoder is broken\n");
+        return -1;
+    }
+
+    *picture = s->picture;
+    *data_size = sizeof(AVPicture);
+
+    return buf_size;
+}
+
+static int bmp_decode_end(AVCodecContext *avctx)
+{
+    BMPContext* c = avctx->priv_data;
+
+    if (c->picture.data[0])
+        avctx->release_buffer(avctx, &c->picture);
+
+    return 0;
+}
+
+AVCodec bmp_decoder = {
+    "bmp",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_BMP,
+    sizeof(BMPContext),
+    bmp_decode_init,
+    NULL,
+    bmp_decode_end,
+    bmp_decode_frame
+};

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.h	2008-12-30 20:29:02 UTC (rev 4504)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.h	2008-12-30 21:06:44 UTC (rev 4505)
@@ -0,0 +1,38 @@
+/*
+ * internals for BMP codecs
+ * Copyright (c) 2005 Mans Rullgard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_BMP_H
+#define AVCODEC_BMP_H
+
+#include "avcodec.h"
+
+typedef struct BMPContext {
+    AVFrame picture;
+} BMPContext;
+
+typedef enum {
+    BMP_RGB         =0,
+    BMP_RLE8        =1,
+    BMP_RLE4        =2,
+    BMP_BITFIELDS   =3,
+} BiCompression;
+
+#endif // AVCODEC_BMP_H

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c	2008-12-30 20:29:02 UTC (rev 4504)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c	2008-12-30 21:06:44 UTC (rev 4505)
@@ -55,6 +55,7 @@
     DECLARE_DECODER (SNOW, snow);
     DECLARE_DECODER (AMV, amv);
     DECLARE_DECODER (RAWVIDEO, rawvideo);
+	DECLARE_DECODER (BMP, bmp);
 #undef DECLARE_DECODER
 #define DECLARE_DECODER(a,b); printf("#define ENABLE_"#a"_DECODER 0\n"); 
 
@@ -130,7 +131,6 @@
     /* DUPE */
     DECLARE_DECODER (ASV1, asv1);
     DECLARE_DECODER (ASV2, asv2);
-    DECLARE_DECODER (BMP, bmp);
     DECLARE_DECODER (FLASHSV, flashsv);
     DECLARE_DECODER (GIF, gif);
     DECLARE_DECODER (H261, h261);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h	2008-12-30 20:29:02 UTC (rev 4504)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h	2008-12-30 21:06:44 UTC (rev 4505)
@@ -45,6 +45,7 @@
 #define ENABLE_SNOW_DECODER 1
 #define ENABLE_AMV_DECODER 1
 #define ENABLE_RAWVIDEO_DECODER 1
+#define ENABLE_BMP_DECODER 1
 #define ENABLE_AASC_DECODER 0
 #define ENABLE_AVS_DECODER 0
 #define ENABLE_BETHSOFTVID_DECODER 0
@@ -116,7 +117,6 @@
 #define ENABLE_ADPCM_THP_DECODER 0
 #define ENABLE_ASV1_DECODER 0
 #define ENABLE_ASV2_DECODER 0
-#define ENABLE_BMP_DECODER 0
 #define ENABLE_FLASHSV_DECODER 0
 #define ENABLE_GIF_DECODER 0
 #define ENABLE_H261_DECODER 0



From gruntster at mail.berlios.de  Tue Dec 30 22:11:13 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 30 Dec 2008 22:11:13 +0100
Subject: [Avidemux-svn-commit] r4506 -
	branches/avidemux_2.4_branch/avidemux/ADM_codecs
Message-ID: <200812302111.mBULBDXQ018927@sheep.berlios.de>

Author: gruntster
Date: 2008-12-30 22:11:06 +0100 (Tue, 30 Dec 2008)
New Revision: 4506

Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_rgb16.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_rgb16.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am
Log:
[dib] remove internal RGB/DIB decoder

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-12-30 21:06:44 UTC (rev 4505)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-12-30 21:11:06 UTC (rev 4506)
@@ -47,7 +47,6 @@
 #include "ADM_codecs/ADM_codec.h"
 #include "ADM_codecs/ADM_mjpeg.h"
 #include "ADM_codecs/ADM_codecNull.h"
-#include "ADM_codecs/ADM_rgb16.h"
 #include "ADM_codecs/ADM_uyvy.h"
 #include "ADM_codecs/ADM_xvideco.h"
 

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_rgb16.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_rgb16.cpp	2008-12-30 21:06:44 UTC (rev 4505)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_rgb16.cpp	2008-12-30 21:11:06 UTC (rev 4506)
@@ -1,127 +0,0 @@
-/***************************************************************************
-                          ADM_rgb16.cpp  -  description
-                             -------------------
-    begin                : Mon May 27 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "ADM_utilities/default.h"
-#include "ADM_assert.h"
-#include "ADM_colorspace/colorspace.h"
-
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_rgb16.h"
-
-decoderRGB16::decoderRGB16(uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp) : decoders (w, h)
-{
-	isRgb = rgb;
-	_bpp = bpp;
-
-	decoded = new uint8_t[_bpp * w * h];
-}
-
-decoderRGB16::~decoderRGB16()
-{
-	delete[] decoded;
-}
-
-uint8_t decoderRGB16::uncompress(ADMCompressedImage * in, ADMImage * out)
-{
-	int xx = _w * _h;
-	int lineSize = (_w * (_bpp / 8) + 3) & ~3;
-	ADM_colorspace colorspace;
-	int i, j;
-	uint8_t *src = in->data;
-	uint8_t *dst = decoded;
-
-	switch (_bpp)
-	{
-		case 16:
-			// FIXME - 16-bit could use a BGR555 or BGR565 colour mask
-			colorspace = ADM_COLOR_BGR555;
-			break;
-		case 24:
-		case 32:
-			if(isRgb)
-				colorspace = ADM_COLOR_RGB24;
-			else
-				colorspace = ADM_COLOR_BGR24;
-
-			break;
-		default:
-			printf("bpp %d not supported\n", _bpp);
-			return 0;
-	}
-
-	if (_bpp == 32)
-	{
-		for(i = 0; i < _h; i++)
-		{
-			uint8_t *buf = src;
-			uint8_t *ptr = dst;
-
-			for(j = 0; j < _w; j++)
-			{
-				ptr[0] = buf[0];
-				ptr[1] = buf[1];
-				ptr[2] = buf[2];
-				ptr += 3;
-				buf += 4;
-			}
-
-			src += lineSize;
-			dst += _w * 3;
-		}
-	}
-	else
-	{
-		memcpy(decoded, in->data, lineSize * _h);
-
-		if (lineSize == _w * _bpp)
-		{
-			// no extra junk in scanlines so copy as is
-			memcpy(decoded, in->data, lineSize * _h);
-		}
-		else
-		{
-			// strip extra junk from scanlines (due to 4 byte alignment)
-			for(i = 0; i < _h; i++)
-			{
-				memcpy(dst, src, _w * (_bpp / 8));
-				src += lineSize;
-				dst += _w * (_bpp / 8);
-			}
-		}
-	}
-
-	ADM_assert(out->_isRef);
-
-	out->flags = AVI_KEY_FRAME;
-	out->_colorspace = (ADM_colorspace)(colorspace | ADM_COLOR_BACKWARD);
-
-	out->_planes[0] = decoded;
-	out->_planes[1] = NULL;
-	out->_planes[2] = NULL;
-
-	out->_planeStride[0] = (_bpp / 8) * _w;
-	out->_planeStride[1] = 0;
-	out->_planeStride[2] = 0;
-
-	return 1;
-}
-//EOF

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_rgb16.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_rgb16.h	2008-12-30 21:06:44 UTC (rev 4505)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_rgb16.h	2008-12-30 21:11:06 UTC (rev 4506)
@@ -1,38 +0,0 @@
-/***************************************************************************
-                          ADM_rgb16.h  -  description
-                             -------------------
-    begin                : Mon May 27 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_RGB16_H
-#define ADM_RGB16_H
-
-#include "ADM_colorspace/ADM_rgb.h"
-
-class decoderRGB16 : decoders
-{
-	protected:
-		uint8_t* planar;
-		ColRgbToYV12* color;
-		uint32_t isRgb; // Else BGR
-		uint32_t _bpp;
-		uint8_t* decoded;
-
-	public:
-		uint8_t dontcopy (void) { return 1; }
-		decoderRGB16 (uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp);
-		virtual ~decoderRGB16();
-		virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
-};
-
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt	2008-12-30 21:06:44 UTC (rev 4505)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt	2008-12-30 21:11:06 UTC (rev 4506)
@@ -1,6 +1,6 @@
 
 SET(ADM_codecs_SRCS 
 ADM_codecs.cpp  ADM_ffmpeg.cpp  ADM_mjpegEncode.cpp  ADM_theora_dec.cpp  ADM_x264.cpp   ADM_xvid.cpp     ADM_xvideco.cpp
-ADM_ffmp43.cpp  ADM_mjpeg.cpp   ADM_mpeg.cpp         ADM_rgb16.cpp  ADM_uyvy.cpp        ADM_xvid4.cpp  ADM_xvidcvs.cpp
+ADM_ffmp43.cpp  ADM_mjpeg.cpp   ADM_mpeg.cpp         ADM_uyvy.cpp        ADM_xvid4.cpp  ADM_xvidcvs.cpp
 )
 ADD_LIBRARY(ADM_codecs STATIC ${ADM_codecs_SRCS})

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am	2008-12-30 21:06:44 UTC (rev 4505)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am	2008-12-30 21:11:06 UTC (rev 4506)
@@ -18,8 +18,8 @@
 ADM_ffmp43.h        ADM_mpeg.h           ADM_uyvy.h        ADM_xvid4.h \
 ADM_ffmpeg.cpp      ADM_png.cpp          ADM_xvid4param.h \
 ADM_ffmpeg.h        ADM_png.h            ADM_xvidcvs.cpp \
-ADM_ffmpegConfig.h  ADM_rgb16.cpp        ADM_x264.cpp      ADM_xvideco.cpp \
-ADM_mjpeg.cpp       ADM_rgb16.h          ADM_x264.h        ADM_xvideco.h \
+ADM_ffmpegConfig.h  ADM_x264.cpp      ADM_xvideco.cpp \
+ADM_mjpeg.cpp       ADM_x264.h        ADM_xvideco.h \
 ADM_mjpeg.h         ADM_theora_dec.cpp   ADM_x264param.h \
 ADM_y800.h
 



From gruntster at mail.berlios.de  Tue Dec 30 22:34:01 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 30 Dec 2008 22:34:01 +0100
Subject: [Avidemux-svn-commit] r4507 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
Message-ID: <200812302134.mBULY10C022746@sheep.berlios.de>

Author: gruntster
Date: 2008-12-30 22:33:51 +0100 (Tue, 30 Dec 2008)
New Revision: 4507

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msrledec.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msrledec.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.h
Log:
[dib] update libavcodec BMP decoder (backport r15924)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-12-30 21:11:06 UTC (rev 4506)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-12-30 21:33:51 UTC (rev 4507)
@@ -32,7 +32,7 @@
                 dvbsubdec.c
                 dvbsub.c xiph.c
                 sp5xdec.c nellymoserdec.c
-                rawdec.c rawenc.c bmp.c
+                rawdec.c rawenc.c bmp.c msrledec.c
 )
 # ADD x86 ones
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2008-12-30 21:11:06 UTC (rev 4506)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2008-12-30 21:33:51 UTC (rev 4507)
@@ -70,7 +70,7 @@
                 wma.c \
                 dvbsub_parser.c \
                 dvbsubdec.c \
-                dvbsub.c xiph.c sp5xdec.c nellymoserdec.c bmp.c
+                dvbsub.c xiph.c sp5xdec.c nellymoserdec.c bmp.c msrledec.c
 
 	
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.c	2008-12-30 21:11:06 UTC (rev 4506)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.c	2008-12-30 21:33:51 UTC (rev 4507)
@@ -22,6 +22,7 @@
 #include "avcodec.h"
 #include "bytestream.h"
 #include "bmp.h"
+#include "msrledec.h"
 
 static int bmp_decode_init(AVCodecContext *avctx){
     BMPContext *s = avctx->priv_data;
@@ -34,7 +35,7 @@
 
 static int bmp_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     BMPContext *s = avctx->priv_data;
     AVFrame *picture = data;
@@ -48,7 +49,7 @@
     uint32_t rgb[3];
     uint8_t *ptr;
     int dsize;
-    uint8_t *buf0 = buf;
+    const uint8_t *buf0 = buf;
 
     if(buf_size < 14){
         av_log(avctx, AV_LOG_ERROR, "buf size too small (%d)\n", buf_size);
@@ -72,21 +73,39 @@
     buf += 2; /* reserved2 */
 
     hsize = bytestream_get_le32(&buf); /* header size */
+    ihsize = bytestream_get_le32(&buf);       /* more header size */
+    if(ihsize + 14 > hsize){
+        av_log(avctx, AV_LOG_ERROR, "invalid header size %d\n", hsize);
+        return -1;
+    }
+
+    /* sometimes file size is set to some headers size, set a real size in that case */
+    if(fsize == 14 || fsize == ihsize + 14)
+        fsize = buf_size - 2;
+
     if(fsize <= hsize){
-        av_log(avctx, AV_LOG_ERROR, "not enough data (%d < %d)\n",
+        av_log(avctx, AV_LOG_ERROR, "declared file size is less than header size (%d < %d)\n",
                fsize, hsize);
         return -1;
     }
 
-    ihsize = bytestream_get_le32(&buf);       /* more header size */
-    if(ihsize + 14 > hsize){
-        av_log(avctx, AV_LOG_ERROR, "invalid header size %d\n", hsize);
+    switch(ihsize){
+    case  40: // windib v3
+    case  64: // OS/2 v2
+    case 108: // windib v4
+    case 124: // windib v5
+        width = bytestream_get_le32(&buf);
+        height = bytestream_get_le32(&buf);
+        break;
+    case  12: // OS/2 v1
+        width  = bytestream_get_le16(&buf);
+        height = bytestream_get_le16(&buf);
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "unsupported BMP file, patch welcome\n");
         return -1;
     }
 
-    width = bytestream_get_le32(&buf);
-    height = bytestream_get_le32(&buf);
-
     if(bytestream_get_le16(&buf) != 1){ /* planes */
         av_log(avctx, AV_LOG_ERROR, "invalid BMP header\n");
         return -1;
@@ -94,12 +113,12 @@
 
     depth = bytestream_get_le16(&buf);
 
-    if(ihsize > 16)
+    if(ihsize == 40)
         comp = bytestream_get_le32(&buf);
     else
         comp = BMP_RGB;
 
-    if(comp != BMP_RGB && comp != BMP_BITFIELDS){
+    if(comp != BMP_RGB && comp != BMP_BITFIELDS && comp != BMP_RLE4 && comp != BMP_RLE8){
         av_log(avctx, AV_LOG_ERROR, "BMP coding %d not supported\n", comp);
         return -1;
     }
@@ -141,7 +160,26 @@
     case 16:
         if(comp == BMP_RGB)
             avctx->pix_fmt = PIX_FMT_RGB555;
+        if(comp == BMP_BITFIELDS)
+            avctx->pix_fmt = rgb[1] == 0x07E0 ? PIX_FMT_RGB565 : PIX_FMT_RGB555;
         break;
+    case 8:
+        if(hsize - ihsize - 14 > 0)
+            avctx->pix_fmt = PIX_FMT_PAL8;
+        else
+            avctx->pix_fmt = PIX_FMT_GRAY8;
+        break;
+    case 4:
+        if(hsize - ihsize - 14 > 0){
+            avctx->pix_fmt = PIX_FMT_PAL8;
+        }else{
+            av_log(avctx, AV_LOG_ERROR, "Unknown palette for 16-colour BMP\n");
+            return -1;
+        }
+        break;
+    case 1:
+        avctx->pix_fmt = PIX_FMT_MONOBLACK;
+        break;
     default:
         av_log(avctx, AV_LOG_ERROR, "depth %d not supported\n", depth);
         return -1;
@@ -167,14 +205,21 @@
     dsize = buf_size - hsize;
 
     /* Line size in file multiple of 4 */
-    n = (avctx->width * (depth / 8) + 3) & ~3;
+    n = ((avctx->width * depth) / 8 + 3) & ~3;
 
-    if(n * avctx->height > dsize){
+    if(n * avctx->height > dsize && comp != BMP_RLE4 && comp != BMP_RLE8){
         av_log(avctx, AV_LOG_ERROR, "not enough data (%d < %d)\n",
                dsize, n * avctx->height);
         return -1;
     }
 
+    // RLE may skip decoding some picture areas, so blank picture before decoding
+    if(comp == BMP_RLE4 || comp == BMP_RLE8)
+        memset(p->data[0], 0, avctx->height * p->linesize[0]);
+
+    if(depth == 4 || depth == 8)
+        memset(p->data[1], 0, 1024);
+
     if(height > 0){
         ptr = p->data[0] + (avctx->height - 1) * p->linesize[0];
         linesize = -p->linesize[0];
@@ -183,46 +228,86 @@
         linesize = p->linesize[0];
     }
 
-    switch(depth){
-    case 24:
-        for(i = 0; i < avctx->height; i++){
-            memcpy(ptr, buf, avctx->width*(depth>>3));
-            buf += n;
-            ptr += linesize;
+    if(avctx->pix_fmt == PIX_FMT_PAL8){
+        buf = buf0 + 14 + ihsize; //palette location
+        if((hsize-ihsize-14)>>depth < 4){ // OS/2 bitmap, 3 bytes per palette entry
+            for(i = 0; i < (1 << depth); i++)
+                ((uint32_t*)p->data[1])[i] = bytestream_get_le24(&buf);
+        }else{
+            for(i = 0; i < (1 << depth); i++)
+                ((uint32_t*)p->data[1])[i] = bytestream_get_le32(&buf);
         }
-        break;
-    case 16:
-        for(i = 0; i < avctx->height; i++){
-            uint16_t *src = (uint16_t *) buf;
-            uint16_t *dst = (uint16_t *) ptr;
+        buf = buf0 + hsize;
+    }
+    if(comp == BMP_RLE4 || comp == BMP_RLE8){
+        ff_msrle_decode(avctx, p, depth, buf, dsize);
+    }else{
+        switch(depth){
+        case 1:
+            for(i = 0; i < avctx->height; i++){
+                memcpy(ptr, buf, n);
+                buf += n;
+                ptr += linesize;
+            }
+            break;
+        case 4:
+            for(i = 0; i < avctx->height; i++){
+                int j;
+                for(j = 0; j < n; j++){
+                    ptr[j*2+0] = (buf[j] >> 4) & 0xF;
+                    ptr[j*2+1] = buf[j] & 0xF;
+                }
+                buf += n;
+                ptr += linesize;
+            }
+            break;
+        case 8:
+            for(i = 0; i < avctx->height; i++){
+                memcpy(ptr, buf, avctx->width);
+                buf += n;
+                ptr += linesize;
+            }
+            break;
+        case 24:
+            for(i = 0; i < avctx->height; i++){
+                memcpy(ptr, buf, avctx->width*(depth>>3));
+                buf += n;
+                ptr += linesize;
+            }
+            break;
+        case 16:
+            for(i = 0; i < avctx->height; i++){
+                const uint16_t *src = (const uint16_t *) buf;
+                uint16_t *dst = (uint16_t *) ptr;
 
-            for(j = 0; j < avctx->width; j++)
-                *dst++ = le2me_16(*src++);
+                for(j = 0; j < avctx->width; j++)
+                    *dst++ = le2me_16(*src++);
 
-            buf += n;
-            ptr += linesize;
-        }
-        break;
-    case 32:
-        for(i = 0; i < avctx->height; i++){
-            uint8_t *src = buf;
-            uint8_t *dst = ptr;
+                buf += n;
+                ptr += linesize;
+            }
+            break;
+        case 32:
+            for(i = 0; i < avctx->height; i++){
+                const uint8_t *src = buf;
+                uint8_t *dst = ptr;
 
-            for(j = 0; j < avctx->width; j++){
-                dst[0] = src[rgb[2]];
-                dst[1] = src[rgb[1]];
-                dst[2] = src[rgb[0]];
-                dst += 3;
-                src += 4;
+                for(j = 0; j < avctx->width; j++){
+                    dst[0] = src[rgb[2]];
+                    dst[1] = src[rgb[1]];
+                    dst[2] = src[rgb[0]];
+                    dst += 3;
+                    src += 4;
+                }
+
+                buf += n;
+                ptr += linesize;
             }
-
-            buf += n;
-            ptr += linesize;
+            break;
+        default:
+            av_log(avctx, AV_LOG_ERROR, "BMP decoder is broken\n");
+            return -1;
         }
-        break;
-    default:
-        av_log(avctx, AV_LOG_ERROR, "BMP decoder is broken\n");
-        return -1;
     }
 
     *picture = s->picture;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.h	2008-12-30 21:11:06 UTC (rev 4506)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bmp.h	2008-12-30 21:33:51 UTC (rev 4507)
@@ -35,4 +35,4 @@
     BMP_BITFIELDS   =3,
 } BiCompression;
 
-#endif // AVCODEC_BMP_H
+#endif /* AVCODEC_BMP_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msrledec.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msrledec.c	2008-12-30 21:11:06 UTC (rev 4506)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msrledec.c	2008-12-30 21:33:51 UTC (rev 4507)
@@ -0,0 +1,256 @@
+/*
+ * Micrsoft RLE Decoder
+ * Copyright (C) 2008 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file msrledec.c
+ * MS RLE Decoder based on decoder by Mike Melanson and my own for TSCC
+ * For more information about the MS RLE format, visit:
+ *   http://www.multimedia.cx/msrle.txt
+ */
+
+#include "avcodec.h"
+
+#define FETCH_NEXT_STREAM_BYTE() \
+    if (stream_ptr >= data_size) \
+    { \
+      av_log(avctx, AV_LOG_ERROR, " MS RLE: stream ptr just went out of bounds (1)\n"); \
+      return -1; \
+    } \
+    stream_byte = data[stream_ptr++];
+
+static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,
+                              const uint8_t *data, int data_size)
+{
+    int stream_ptr = 0;
+    unsigned char rle_code;
+    unsigned char extra_byte, odd_pixel;
+    unsigned char stream_byte;
+    int pixel_ptr = 0;
+    int row_dec = pic->linesize[0];
+    int row_ptr = (avctx->height - 1) * row_dec;
+    int frame_size = row_dec * avctx->height;
+    int i;
+
+    while (row_ptr >= 0) {
+        FETCH_NEXT_STREAM_BYTE();
+        rle_code = stream_byte;
+        if (rle_code == 0) {
+            /* fetch the next byte to see how to handle escape code */
+            FETCH_NEXT_STREAM_BYTE();
+            if (stream_byte == 0) {
+                /* line is done, goto the next one */
+                row_ptr -= row_dec;
+                pixel_ptr = 0;
+            } else if (stream_byte == 1) {
+                /* decode is done */
+                return 0;
+            } else if (stream_byte == 2) {
+                /* reposition frame decode coordinates */
+                FETCH_NEXT_STREAM_BYTE();
+                pixel_ptr += stream_byte;
+                FETCH_NEXT_STREAM_BYTE();
+                row_ptr -= stream_byte * row_dec;
+        } else {
+            // copy pixels from encoded stream
+            odd_pixel =  stream_byte & 1;
+            rle_code = (stream_byte + 1) / 2;
+            extra_byte = rle_code & 0x01;
+            if ((row_ptr + pixel_ptr + stream_byte > frame_size) ||
+                (row_ptr < 0)) {
+                av_log(avctx, AV_LOG_ERROR, " MS RLE: frame ptr just went out of bounds (1)\n");
+                return -1;
+            }
+
+            for (i = 0; i < rle_code; i++) {
+                if (pixel_ptr >= avctx->width)
+                    break;
+                FETCH_NEXT_STREAM_BYTE();
+                pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;
+                pixel_ptr++;
+                if (i + 1 == rle_code && odd_pixel)
+                    break;
+                if (pixel_ptr >= avctx->width)
+                    break;
+                pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;
+                pixel_ptr++;
+            }
+
+            // if the RLE code is odd, skip a byte in the stream
+            if (extra_byte)
+              stream_ptr++;
+            }
+        } else {
+            // decode a run of data
+            if ((row_ptr + pixel_ptr + stream_byte > frame_size) ||
+                (row_ptr < 0)) {
+                av_log(avctx, AV_LOG_ERROR, " MS RLE: frame ptr just went out of bounds (1)\n");
+                return -1;
+            }
+            FETCH_NEXT_STREAM_BYTE();
+            for (i = 0; i < rle_code; i++) {
+                if (pixel_ptr >= avctx->width)
+                    break;
+                if ((i & 1) == 0)
+                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;
+                else
+                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;
+                pixel_ptr++;
+            }
+        }
+    }
+
+    /* one last sanity check on the way out */
+    if (stream_ptr < data_size) {
+        av_log(avctx, AV_LOG_ERROR, " MS RLE: ended frame decode with bytes left over (%d < %d)\n",
+            stream_ptr, data_size);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+static int msrle_decode_8_16_24_32(AVCodecContext *avctx, AVPicture *pic, int depth,
+                                    const uint8_t *data, int srcsize)
+{
+    uint8_t *output, *output_end;
+    const uint8_t* src = data;
+    int p1, p2, line=avctx->height, pos=0, i;
+    uint16_t pix16;
+    uint32_t pix32;
+
+    output = pic->data[0] + (avctx->height - 1) * pic->linesize[0];
+    output_end = pic->data[0] + (avctx->height) * pic->linesize[0];
+    while(src < data + srcsize) {
+        p1 = *src++;
+        if(p1 == 0) { //Escape code
+            p2 = *src++;
+            if(p2 == 0) { //End-of-line
+                output = pic->data[0] + (--line) * pic->linesize[0];
+                if (line < 0){
+                    av_log(avctx, AV_LOG_ERROR, "Next line is beyond picture bounds\n");
+                    return -1;
+                }
+                pos = 0;
+                continue;
+            } else if(p2 == 1) { //End-of-picture
+                return 0;
+            } else if(p2 == 2) { //Skip
+                p1 = *src++;
+                p2 = *src++;
+                line -= p2;
+                if (line < 0){
+                    av_log(avctx, AV_LOG_ERROR, "Skip beyond picture bounds\n");
+                    return -1;
+                }
+                pos += p1;
+                output = pic->data[0] + line * pic->linesize[0] + pos * (depth >> 3);
+                continue;
+            }
+            // Copy data
+            if (output + p2 * (depth >> 3) > output_end) {
+                src += p2 * (depth >> 3);
+                continue;
+            }
+            if ((depth == 8) || (depth == 24)) {
+                for(i = 0; i < p2 * (depth >> 3); i++) {
+                    *output++ = *src++;
+                }
+                // RLE8 copy is actually padded - and runs are not!
+                if(depth == 8 && (p2 & 1)) {
+                    src++;
+                }
+            } else if (depth == 16) {
+                for(i = 0; i < p2; i++) {
+                    pix16 = AV_RL16(src);
+                    src += 2;
+                    *(uint16_t*)output = pix16;
+                    output += 2;
+                }
+            } else if (depth == 32) {
+                for(i = 0; i < p2; i++) {
+                    pix32 = AV_RL32(src);
+                    src += 4;
+                    *(uint32_t*)output = pix32;
+                    output += 4;
+                }
+            }
+            pos += p2;
+        } else { //Run of pixels
+            uint8_t pix[3]; //original pixel
+            switch(depth){
+            case  8: pix[0] = *src++;
+                     break;
+            case 16: pix16 = AV_RL16(src);
+                     src += 2;
+                     break;
+            case 24: pix[0] = *src++;
+                     pix[1] = *src++;
+                     pix[2] = *src++;
+                     break;
+            case 32: pix32 = AV_RL32(src);
+                     src += 4;
+                     break;
+            }
+            if (output + p1 * (depth >> 3) > output_end)
+                continue;
+            for(i = 0; i < p1; i++) {
+                switch(depth){
+                case  8: *output++ = pix[0];
+                         break;
+                case 16: *(uint16_t*)output = pix16;
+                         output += 2;
+                         break;
+                case 24: *output++ = pix[0];
+                         *output++ = pix[1];
+                         *output++ = pix[2];
+                         break;
+                case 32: *(uint32_t*)output = pix32;
+                         output += 4;
+                         break;
+                }
+            }
+            pos += p1;
+        }
+    }
+
+    av_log(avctx, AV_LOG_WARNING, "MS RLE warning: no End-of-picture code\n");
+    return 0;
+}
+
+
+int ff_msrle_decode(AVCodecContext *avctx, AVPicture *pic, int depth,
+                    const uint8_t* data, int data_size)
+{
+    switch(depth){
+    case  4:
+        return msrle_decode_pal4(avctx, pic, data, data_size);
+    case  8:
+    case 16:
+    case 24:
+    case 32:
+        return msrle_decode_8_16_24_32(avctx, pic, depth, data, data_size);
+    default:
+        av_log(avctx, AV_LOG_ERROR, "Unknown depth %d\n", depth);
+        return -1;
+    }
+}
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msrledec.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msrledec.h	2008-12-30 21:11:06 UTC (rev 4506)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msrledec.h	2008-12-30 21:33:51 UTC (rev 4507)
@@ -0,0 +1,40 @@
+/*
+ * Micrsoft RLE Decoder
+ * Copyright (C) 2008 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_MSRLEDEC_H
+#define AVCODEC_MSRLEDEC_H
+
+#include "avcodec.h"
+
+/**
+ * decode stream in MS RLE format into frame
+ *
+ * @param avctx     codec context
+ * @param pic       destination frame
+ * @param depth     bit depth
+ * @param data      input stream
+ * @param data_size input size
+ */
+int ff_msrle_decode(AVCodecContext *avctx, AVPicture *pic, int depth,
+                    const uint8_t* data, int data_size);
+
+#endif /* AVCODEC_MSRLEDEC_H */
+



