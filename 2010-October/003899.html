<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6717 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. colorYUV
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-October/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6717%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6%3A%0A%09.%20colorYUV&In-Reply-To=%3C20101028055449.D5734480FA4%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003898.html">
   <LINK REL="Next"  HREF="003900.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6717 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. colorYUV</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6717%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6%3A%0A%09.%20colorYUV&In-Reply-To=%3C20101028055449.D5734480FA4%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6717 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. colorYUV">mean at mail.berlios.de
       </A><BR>
    <I>Thu Oct 28 07:54:49 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003898.html">[Avidemux-svn-commit] r6716 -	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src
</A></li>
        <LI>Next message: <A HREF="003900.html">[Avidemux-svn-commit] r6718 -	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3899">[ date ]</a>
              <a href="thread.html#3899">[ thread ]</a>
              <a href="subject.html#3899">[ subject ]</a>
              <a href="author.html#3899">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-10-28 07:54:49 +0200 (Thu, 28 Oct 2010)
New Revision: 6717

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv_param.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/avsColor.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp
Log:
[VideoFilter] Import avsFilter

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,134 @@
+
+/***************************************************************************
+    Port of ColorYuv from avisynth to avidemux by mean
+ ***************************************************************************/
+ // Avisynth v2.5.  Copyright 2002 Ben Rudiak-Gould et al.
+// <A HREF="http://www.avisynth.org">http://www.avisynth.org</A>
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit
+// <A HREF="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</A> .
+//
+// Linking Avisynth statically or dynamically with other modules is making a
+// combined work based on Avisynth.  Thus, the terms and conditions of the GNU
+// General Public License cover the whole combination.
+//
+// As a special exception, the copyright holders of Avisynth give you
+// permission to link Avisynth with independent modules that communicate with
+// Avisynth solely through the interfaces defined in avisynth.h, regardless of the license
+// terms of these independent modules, and to copy and distribute the
+// resulting combined work under terms of your choice, provided that
+// every copy of the combined work is accompanied by a complete copy of
+// the source code of Avisynth (the version of Avisynth used to produce the
+// combined work), being distributed under the terms of the GNU General
+// Public License plus this exception.  An independent module is a module
+// which is not derived from or based on Avisynth, such as 3rd-party filters,
+// import and export plugins, or graphical user interfaces.
+
+ /***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &lt;math.h&gt;
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_coreVideoFilterInternal.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_vidColorYuv.h&quot;
+#include &quot;DIA_factory.h&quot;
+#include &quot;colorYuv_desc.cpp&quot;
+
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   vidColorYuv,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_COLORS,            // Category
+                        &quot;colorYuv&quot;,            // internal name (must be uniq!)
+                        &quot;Avisynth color filter.&quot;,            // Display name
+                        &quot;Color management filter.&quot; // Description
+                    );
+
+/**
+    \fn configure
+*/
+bool         vidColorYuv::configure(void)
+{
+    MakeGammaLUT();
+    return true;
+}
+/**
+    \fn getConfiguration
+*/
+const char   *vidColorYuv::getConfiguration(void)
+{
+      const char *foobar=&quot;colorYuv&quot;;
+      return foobar;
+}
+/**
+    \fn ctor
+*/
+vidColorYuv::vidColorYuv( ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilter(in,setup)
+{	
+	 if(!setup || !ADM_paramLoad(setup,colorYuv_param,&amp;param))
+    {
+        // Default value
+        #define MKP(x,y) param.x=y;
+            MKP(y_contrast,0);
+            MKP(y_bright,0);
+            MKP(y_gamma,0);
+            MKP(y_gain,0);
+
+            MKP(u_contrast,0);
+            MKP(u_bright,0);
+            MKP(u_gamma,0);
+            MKP(u_gain,0);
+
+            MKP(v_contrast,0);
+            MKP(v_bright,0);
+            MKP(v_gamma,0);
+            MKP(v_gain,0);
+            
+            MKP(matrix,0);
+            MKP(levels,0);
+            MKP(opt,0); 
+       
+            MKP(colorbars,0);
+            MKP(analyze,1);
+            MKP(autowhite,1); 
+            MKP(autogain,0); 
+    }  	 
+    MakeGammaLUT(); 	
+}
+/**
+    \fn getCoupledConf
+*/
+bool         vidColorYuv::getCoupledConf(CONFcouple **couples)
+{
+    return ADM_paramSave(couples, colorYuv_param,&amp;param);
+}
+
+
+/**
+    \fn dtor
+*/
+vidColorYuv::~vidColorYuv()
+{
+}
+
+
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.h	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,43 @@
+/***************************************************************************
+                          Port of avisynth ColorYuv Filter
+    copyright            : (C) 2006 by mean
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_VID_COLOR_YUV_H
+#define ADM_VID_COLOR_YUV_H
+
+#include &quot;colorYuv.h&quot;
+/**
+    \class vidColorYuv
+*/
+class vidColorYuv : public  ADM_coreVideoFilter
+{
+protected:
+        uint8_t       LUT_Y[256],LUT_U[256],LUT_V[256];
+        int           y_thresh1, y_thresh2, u_thresh1, u_thresh2, v_thresh1, v_thresh2;
+
+protected:
+        colorYuv    param;
+        void        MakeGammaLUT(void);
+public:
+        vidColorYuv(ADM_coreVideoFilter *previous,CONFcouple *conf);
+        ~vidColorYuv();
+
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+};
+
+
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv_param.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv_param.h	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,36 @@
+/***************************************************************************
+                          Port of avisynth ColorYuv Filter
+    copyright            : (C) 2006 by mean
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef ADM_VID_COLOR_YUV_PARAM_H
+#define ADM_VID_COLOR_YUV_PARAM_H
+typedef struct COLOR_YUV_PARAM
+{
+    double y_contrast, y_bright, y_gamma, y_gain;
+    double u_contrast, u_bright, u_gamma, u_gain;
+    double v_contrast, v_bright, v_gamma, v_gain;
+    int32_t matrix, levels, opt;
+    uint32_t colorbars, analyze, autowhite, autogain;
+
+}COLOR_YUV_PARAM;
+
+/*
+matrix : 0 : none   1: rec.709
+Level :  0 : none   1:&quot;TV-&gt;PC&quot;, 2:&quot;PC-&gt;TV&quot;, 3:&quot;PC-&gt;TV.Y&quot; 
+Opt :    0 : none   1: Coring
+
+
+
+*/
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/CMakeLists.txt	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,8 @@
+INCLUDE(vf_plugin)
+
+SET(ADM_vf_colorYuv_SRCS ADM_vidColorYuv.cpp avsColor.cpp)
+
+ADD_VIDEO_FILTER(ADM_vf_colorYuv ${ADM_vf_colorYuv_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_colorYuv)
+INSTALL_VIDEO_FILTER(ADM_vf_colorYuv)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/avsColor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/avsColor.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/avsColor.cpp	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,732 @@
+// Avisynth v2.5.  Copyright 2002 Ben Rudiak-Gould et al.
+// <A HREF="http://www.avisynth.org">http://www.avisynth.org</A>
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit
+// <A HREF="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</A> .
+//
+// Linking Avisynth statically or dynamically with other modules is making a
+// combined work based on Avisynth.  Thus, the terms and conditions of the GNU
+// General Public License cover the whole combination.
+//
+// As a special exception, the copyright holders of Avisynth give you
+// permission to link Avisynth with independent modules that communicate with
+// Avisynth solely through the interfaces defined in avisynth.h, regardless of the license
+// terms of these independent modules, and to copy and distribute the
+// resulting combined work under terms of your choice, provided that
+// every copy of the combined work is accompanied by a complete copy of
+// the source code of Avisynth (the version of Avisynth used to produce the
+// combined work), being distributed under the terms of the GNU General
+// Public License plus this exception.  An independent module is a module
+// which is not derived from or based on Avisynth, such as 3rd-party filters,
+// import and export plugins, or graphical user interfaces.
+
+#include &lt;math.h&gt;
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_coreVideoFilterInternal.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_vidColorYuv.h&quot;
+
+#define BYTE uint8_t
+#ifndef x_max
+#define x_max(x,y) ((x)&gt;(y) ?(x):(y))
+#endif
+#ifndef x_min
+#define x_min(x,y) ((x)&lt;(y) ?(x):(y))
+#endif
+
+
+/**
+    \fn getNextFrame
+*/
+bool         vidColorYuv::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+//x	PVideoFrame src;
+//x	unsigned long *srcp;
+    uint8_t *srcp;
+	int pitch, w, h;
+	int i,j,wby4;
+	int modulo;
+
+#ifdef _DEBUG
+	COUNT y0,u0,v0;
+	COUNT y,u,v;
+	COUNT r,g,b;
+	COUNT r0,g0,b0;
+	PIXELDATA	pixel0;
+	int   total,totalby2;
+#endif
+
+#if 0
+  if (colorbars) {
+    PVideoFrame dst= env-&gt;NewVideoFrame(vi);
+    int* pdst=(int*)dst-&gt;GetWritePtr(PLANAR_Y);
+    int Y=16+abs(219-((frame+219)%438));
+    Y|=(Y&lt;&lt;8)|(Y&lt;&lt;16)|(Y&lt;&lt;24);
+    for (int i = 0;i&lt;224*224;i++)
+      pdst[i] = Y;
+    unsigned char* pdstb = dst-&gt;GetWritePtr(PLANAR_U);
+    for (unsigned int y=0;y&lt;224;y++) {
+      for (unsigned int x=0;x&lt;224;x++) {
+        pdstb[x] = 16+x;
+      }
+      pdstb += dst-&gt;GetPitch(PLANAR_U);
+    }
+
+    pdstb = dst-&gt;GetWritePtr(PLANAR_V);
+    for (y=0;y&lt;224;y++) {
+      for (unsigned int x=0;x&lt;224;x++) {
+        pdstb[x] = 16+y;
+      }
+      pdstb += dst-&gt;GetPitch(PLANAR_U);
+    }
+    return dst;
+  }
+#endif
+    if(false==previousFilter-&gt;getNextFrame(fn,image))
+    {
+        return false;
+    }
+    ADMImage *src=image;
+//x	src = child-&gt;GetFrame(frame, env);
+//x	env-&gt;MakeWritable(&amp;src);
+
+//x	srcp = (unsigned long *) src-&gt;GetWritePtr();
+//x	pitch = src-&gt;GetPitch();
+    srcp=src-&gt;GetWritePtr(PLANAR_Y);
+    pitch=src-&gt;GetPitch(PLANAR_Y);
+
+	w = info.width;  //x src-&gt;GetRowSize();
+	h = info.height; //x src-&gt;GetHeight();
+	wby4 = w / 4;
+	modulo = pitch - w;
+//	dst = env-&gt;NewVideoFrame(vi);
+//	dstp = (unsigned long *) dst-&gt;GetWritePtr();
+//	dpitch = dst-&gt;GetPitch();
+//	dmodulo = dpitch - dst-&gt;GetRowSize();
+  if (param.analyze||param.autowhite||param.autogain) {
+    unsigned int accum_Y[256],accum_U[256],accum_V[256];
+    for (int i=0;i&lt;256;i++) {
+      accum_Y[i]=0;
+      accum_U[i]=0;
+      accum_V[i]=0;
+    }
+    int uvdiv=1;  //UV divider (ratio between Y and UV pixels)
+    if (1) { //x vi.IsPlanar()) {
+      uvdiv=4;
+	    BYTE* srcp2 = (BYTE*) src-&gt;GetReadPtr(PLANAR_Y);
+      for (int y=0;y&lt;h;y++) {
+        for (int x=0;x&lt;w;x++) {
+          accum_Y[srcp2[x]]++;
+        }
+        srcp2+=pitch;
+      }
+      pitch = src-&gt;GetPitch(PLANAR_U);
+	    srcp2 = (BYTE*) src-&gt;GetReadPtr(PLANAR_U);
+      for (int y=0;y&lt;h/2;y++) {
+        for (int x=0;x&lt;w/2;x++) {
+          accum_U[srcp2[x]]++;
+        }
+        srcp2+=pitch;
+      }
+	    srcp2 = (BYTE*) src-&gt;GetReadPtr(PLANAR_V);
+      for (int y=0;y&lt;h/2;y++) {
+        for (int x=0;x&lt;w/2;x++) {
+          accum_V[srcp2[x]]++;
+        }
+        srcp2+=pitch;
+      }
+      pitch = src-&gt;GetPitch(PLANAR_Y);
+    } 
+#if 0 
+    else {  // YUY2
+      uvdiv=2;
+      for (int y=0;y&lt;h;y++) {
+        for (int x=0;x&lt;wby4;x++) {
+          unsigned long p=srcp[x];
+          accum_Y[p&amp;0xff]++;
+          accum_Y[(p&gt;&gt;16)&amp;0xff]++;
+          accum_U[(p&gt;&gt;8)&amp;0xff]++;
+          accum_V[(p&gt;&gt;24)&amp;0xff]++;
+        }
+        srcp+=pitch/4;
+      }
+      srcp=(unsigned long *)src-&gt;GetReadPtr();
+    }
+#endif
+    int pixels = info.width*info.height;
+    float avg_u=0, avg_v=0, avg_y=0;
+    int x_min_u=0, x_min_v=0, x_min_y=0;
+    int x_max_u=0, x_max_v=0, x_max_y=0;
+    bool hit_y=false,hit_u=false,hit_v=false;
+    int Ax_min_u=0, Ax_min_v=0, Ax_min_y=0;
+    int Ax_max_u=0, Ax_max_v=0, Ax_max_y=0;
+    bool Ahit_x_miny=false,Ahit_x_minu=false,Ahit_x_minv=false;
+    bool Ahit_x_maxy=false,Ahit_x_maxu=false,Ahit_x_maxv=false;
+    int At_y2=(pixels/256); // When 1/256th of all pixels have been reached, trigger &quot;Loose x_min/x_max&quot;
+    int At_uv2=(pixels/1024); 
+   
+    for (int i=0;i&lt;256;i++) {
+      avg_y+=(float)accum_Y[i]*(float)i;
+      avg_u+=(float)accum_U[i]*(float)i;
+      avg_v+=(float)accum_V[i]*(float)i;
+      if (accum_Y[i]!=0) {x_max_y=i;hit_y=true;} else {if (!hit_y) x_min_y=i+1;} 
+      if (accum_U[i]!=0) {x_max_u=i;hit_u=true;} else {if (!hit_u) x_min_u=i+1;} 
+      if (accum_V[i]!=0) {x_max_v=i;hit_v=true;} else {if (!hit_v) x_min_v=i+1;} 
+
+      if (!Ahit_x_miny) {Ax_min_y+=accum_Y[i]; if (Ax_min_y&gt;At_y2){Ahit_x_miny=true; Ax_min_y=i;} }
+      if (!Ahit_x_minu) {Ax_min_u+=accum_U[i]; if (Ax_min_u&gt;At_uv2){Ahit_x_minu=true; Ax_min_u=i;} }
+      if (!Ahit_x_minv) {Ax_min_v+=accum_V[i]; if (Ax_min_v&gt;At_uv2){Ahit_x_minv=true; Ax_min_v=i;} }
+
+      if (!Ahit_x_maxy) {Ax_max_y+=accum_Y[255-i]; if (Ax_max_y&gt;At_y2){Ahit_x_maxy=true; Ax_max_y=255-i;} }
+      if (!Ahit_x_maxu) {Ax_max_u+=accum_U[255-i]; if (Ax_max_u&gt;At_uv2){Ahit_x_maxu=true; Ax_max_u=255-i;} }
+      if (!Ahit_x_maxv) {Ax_max_v+=accum_V[255-i]; if (Ax_max_v&gt;At_uv2){Ahit_x_maxv=true; Ax_max_v=255-i;} }
+    }
+
+    float Favg_y=avg_y/(float)pixels;
+    float Favg_u=(avg_u*(float)uvdiv)/(float)pixels;
+    float Favg_v=(avg_v*(float)uvdiv)/(float)pixels;
+    if (param.analyze) {
+#if 0
+      char text[400];
+      sprintf(text,
+      &quot;        Frame: %-8u ( Luma Y / ChromaU / ChromaV )\n&quot;
+      &quot;      Average:      ( %7.2f / %7.2f / %7.2f )\n&quot;
+      &quot;      x_minimum:      (   %3d   /   %3d   /   %3d    )\n&quot;
+      &quot;      x_maximum:      (   %3d   /   %3d   /   %3d    )\n&quot;
+      &quot;Loose x_minimum:      (   %3d   /   %3d   /   %3d    )\n&quot;
+      &quot;Loose x_maximum:      (   %3d   /   %3d   /   %3d    )\n&quot;
+      ,
+      frame,
+      Favg_y,Favg_u,Favg_v,
+      x_min_y,x_min_u,x_min_v,
+      x_max_y,x_max_u,x_max_v,
+      Ax_min_y,Ax_min_u,Ax_min_v,
+      Ax_max_y,Ax_max_u,Ax_max_v
+      );
+
+      ApplyMessage(&amp;src, vi, text, vi.width/4, 0xa0a0a0,0,0 , env );
+      if (!(param.autowhite||param.autogain)) {
+        return true; //x src;
+      }
+#endif
+    }
+    if (param.autowhite) {
+      param.u_bright=127-(int)Favg_u;
+      param.v_bright=127-(int)Favg_v;
+    }
+    if (param.autogain) {
+      Ax_max_y=x_min(Ax_max_y,236);
+      Ax_min_y=x_max(Ax_min_y,16);  // Never scale above luma range!
+      if (Ax_min_y!=Ax_max_y) {
+        int y_range = Ax_max_y-Ax_min_y;
+        double scale = (220.0 / y_range);
+        param.y_gain = (int) (256.0 * scale)-256;
+        param.y_bright = -(int)(scale * (double)(Ax_min_y)-16);
+      }
+    }
+	  MakeGammaLUT();
+  }
+
+#ifdef _DEBUG
+	total = wby4 * h;
+	totalby2 = total / 2;
+
+	y.x_min  = u.x_min  = v.x_min  = 255;
+	y.x_max  = u.x_max  = v.x_max  = 0;
+	y.ave  = u.ave  = v.ave  = 0;
+	y.over  = u.over  = v.over  = 0;
+	y.under = u.under = v.under = 0;
+
+	y0.x_min = u0.x_min = v0.x_min = 255;
+	y0.x_max = u0.x_max = v0.x_max = 0;
+	y0.ave = u0.ave = v0.ave = 0;
+	y0.over  = u0.over  = v0.over  = 0;
+	y0.under = u0.under = v0.under = 0;
+
+	r.x_min   = g.x_min   = b.x_min   = 255;
+	r.x_max   = g.x_max   = b.x_max   = 0;
+	r.ave   = g.ave   = b.ave   = 0;
+	r.over  = g.over  = b.over  = 0;
+	r.under = g.under = b.under = 0;
+
+	r0.x_min   = g0.x_min   = b0.x_min   = 255;
+	r0.x_max   = g0.x_max   = b0.x_max   = 0;
+	r0.ave   = g0.ave   = b0.ave   = 0;
+	r0.over  = g0.over  = b0.over  = 0;
+	r0.under = g0.under = b0.under = 0;
+#endif
+#if 0 //x
+  if (vi.IsYUY2()) {
+	  for (j = 0; j &lt; h; j++)
+	  {
+		  for (i=0; i&lt;wby4; i++)
+		  {
+			  pixel.data = *srcp;
+
+#ifdef _DEBUG
+			pixel0.data = pixel.data;
+			CheckYUV(NULL, &amp;pixel, &amp;y0, &amp;u0, &amp;v0, 0);
+			
+			YUV2RGB(pixel.yuv.y0, pixel.yuv.u, pixel.yuv.v, &amp;r0.d, &amp;g0.d, &amp;b0.d, matrix);
+			CheckRGB(&amp;r0, &amp;g0, &amp;b0);
+			YUV2RGB(pixel.yuv.y1, pixel.yuv.u, pixel.yuv.v, &amp;r0.d, &amp;g0.d, &amp;b0.d, matrix);
+			CheckRGB(&amp;r0, &amp;g0, &amp;b0);
+#endif 
+
+			  pixel.yuv.y0 = LUT_Y[pixel.yuv.y0];
+			  pixel.yuv.u  = LUT_U[pixel.yuv.u ];
+			  pixel.yuv.y1 = LUT_Y[pixel.yuv.y1];
+			  pixel.yuv.v  = LUT_V[pixel.yuv.v ];
+			  *srcp++ = pixel.data;
+
+#ifdef _DEBUG
+			CheckYUV(&amp;pixel0, &amp;pixel, &amp;y, &amp;u, &amp;v, 1);
+
+			YUV2RGB(pixel.yuv.y0, pixel.yuv.u, pixel.yuv.v, &amp;r.d, &amp;g.d, &amp;b.d, matrix);
+			CheckRGB(&amp;r, &amp;g, &amp;b);
+			YUV2RGB(pixel.yuv.y1, pixel.yuv.u, pixel.yuv.v, &amp;r.d, &amp;g.d, &amp;b.d, matrix);
+			CheckRGB(&amp;r, &amp;g, &amp;b);
+#endif
+		  }
+		  srcp = (unsigned long *)((unsigned char *)srcp + modulo) ;
+	  }
+  } else 
+if (vi.IsPlanar()) 
+#endif //x
+    {
+	  BYTE* srcp2 = (BYTE*) src-&gt;GetWritePtr(PLANAR_Y);
+    for (j = 0; j &lt; h; j++) {
+		  for (i=0; i&lt;w; i++) {
+        srcp2[i]=LUT_Y[srcp2[i]];
+      }
+	    srcp2 +=  pitch;
+    }
+	  srcp2 = (BYTE*) src-&gt;GetWritePtr(PLANAR_U);
+    h=src-&gt;GetHeight(PLANAR_U);
+    w=src-&gt;GetRowSize(PLANAR_U);
+    pitch=src-&gt;GetPitch(PLANAR_U);
+    for (j = 0; j &lt; h; j++) {
+		  for (i=0; i&lt;w; i++) {
+        srcp2[i]=LUT_U[srcp2[i]];
+      }
+	    srcp2 +=  pitch;
+    }
+	  srcp2 = (BYTE*) src-&gt;GetWritePtr(PLANAR_V);
+    for (j = 0; j &lt; h; j++) {
+		  for (i=0; i&lt;w; i++) {
+        srcp2[i]=LUT_V[srcp2[i]];
+      }
+	    srcp2 +=  pitch;
+    }
+  }
+
+#ifdef _DEBUG
+/*
+	y.ave  = ( y.ave+total)/total/2; u.ave  = ( u.ave+totalby2)/total;   v.ave  = ( v.ave+totalby2)/total;
+	y0.ave = (y0.ave+total)/total/2; u0.ave = (u0.ave+totalby2)/total;   v0.ave = (v0.ave+totalby2)/total;
+	r.ave  = ( r.ave+total)/total/2; g.ave  = ( g.ave+total   )/total/2; b.ave  = ( b.ave+total   )/total/2;
+	r0.ave = (r0.ave+total)/total/2; g0.ave = (g0.ave+total   )/total/2; b0.ave = (b0.ave+total   )/total/2;
+
+  char buf[256];
+  OutputDebugString(&quot;\n&quot;);
+	sprintf(buf,&quot;frame=%05d  x_minimun   Src=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]&quot; \
+				&quot;  Dst=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]&quot;,
+				frame, y0.x_min,u0.x_min,v0.x_min, r0.x_min,g0.x_min,b0.x_min,
+				y.x_min,u.x_min,v.x_min, r.x_min,g.x_min,b.x_min);
+	OutputDebugString(buf);
+
+	sprintf(buf,&quot;             x_maximum   Src=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]&quot; \
+				&quot;  Dst=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]&quot;,
+				y0.x_max,u0.x_max,v0.x_max, r0.x_max,g0.x_max,b0.x_max,
+				y.x_max,u.x_max,v.x_max, r.x_max,g.x_max,b.x_max);
+	OutputDebugString(buf);
+
+	sprintf(buf,&quot;             average   Src=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]&quot; \
+				&quot;  Dst=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]&quot;,
+				y0.ave,u0.ave,v0.ave, r0.ave,g0.ave,b0.ave,
+				y.ave,u.ave,v.ave, r.ave,g.ave,b.ave);
+	OutputDebugString(buf);
+
+	sprintf(buf,&quot;             underflow Src=[Y:%3d  U:%3d  V:%3d  R:%3d  G:%3d  B:%3d]&quot; \
+				&quot;  Dst=[Y:%3d  U:%3d  V:%3d  R:%3d  G:%3d  B:%3d]&quot;,
+				y0.under,u0.under,v0.under, r0.under,g0.under,b0.under,
+				y.under,u.under,v.under, r.under,g.under,b.under
+			);
+	OutputDebugString(buf);
+
+	sprintf(buf,&quot;             overflow  Src=[Y:%3d  U:%3d  V:%3d  R:%3d  G:%3d  B:%3d]&quot; \
+				&quot;  Dst=[Y:%3d  U:%3d  V:%3d  R:%3d  G:%3d  B:%3d]&quot;,
+				y0.over,u0.over,v0.over, r0.over,g0.over,b0.over,
+				y.over,u.over,v.over, r.over,g.over,b.over
+			);
+	OutputDebugString(buf);
+*/
+#endif
+
+	return true;
+}
+/**
+    \fn MakeGammaLUT
+*/
+void vidColorYuv::MakeGammaLUT(void)
+{
+	static const int scale = 256, shift = 2^10,
+		coeff_y0 =  76309, coeff_y1 =  65536,
+		coeff_u0 = 132201, coeff_u1 = 116129,
+		coeff_v0 = 104597, coeff_v1 =  91881;
+	int i;
+	int val;
+	double g,b,c,gain;
+	double v;
+
+	y_thresh1 = u_thresh1 = v_thresh1 = -1;
+	y_thresh2 = u_thresh2 = v_thresh2 = 256;
+
+	gain = ((double)param.y_gain + scale) / scale;
+	c = ((double)param.y_contrast + scale) / scale;
+	b = ((double)param.y_bright + scale) / scale;
+	g = ((double)param.y_gamma + scale) / scale;
+	if (g &lt; 0.01)    g = 0.01;
+	for (i = 0; i &lt; 256; i++)
+    {
+		val = i * shift;
+		switch (param.levels) {
+			case 1:	// PC-&gt;TV
+				val = (int)((val - 16 * shift) * coeff_y0 / coeff_y1 + shift / 2);
+				break;
+			case 2:	// TV-&gt;PC
+			case 3:	// TV-&gt;PC.Y
+				val = (int)(val * coeff_y1 / coeff_y0 + 16 * shift + shift / 2);
+				break;
+			default:	//none
+				break;
+		}
+		val = val / shift;
+
+		v = ((double)val) / 256;
+		v = (v * gain) + ((v-0.5) * c + 0.5) - v + (b - 1);
+
+		if (param.y_gamma != 0 &amp;&amp; v &gt; 0)
+			v = pow( v, 1 / g);
+		v = v * 256;
+		
+		v += 0.5;
+		val = (int)floor(v);
+
+		if (val &gt; 255)
+			val = 255;
+		else if (val &lt; 0)
+			val = 0;
+
+		if (val &gt; 235) {
+			if(y_thresh2 &gt; 255)		y_thresh2 = i;
+			if(param.opt)		val = 235;
+		}
+		else if (val &lt; 16) {
+			y_thresh1 = i;
+			if(param.opt)		val = 16;
+		}
+		LUT_Y[i] = (unsigned char)val;
+    }
+
+	gain = ((double)param.u_gain + scale);
+	c = ((double)param.u_contrast + scale);
+	b = ((double)param.u_bright);
+	for (i = 0; i &lt; 256; i++)
+    {
+		val = i * shift;
+		switch (param.levels) {
+			case 1:	// PC-&gt;TV Scale
+				val = (int)((val - 128 * shift) * coeff_u0 / coeff_u1 + 128 * shift + shift / 2);
+				break;
+			case 2:	// TV-&gt;PC Scale
+				val = (int)((val - 128 * shift) * coeff_u1 / coeff_u0 + 128 * shift + shift / 2);
+				break;
+			default:	//none
+				break;
+		}
+		val = val / shift;
+
+		v = ((double)val);
+		v = (v * gain / scale) + ((v-128) * c / scale + 128) - v + b;
+
+		v += 0.5;
+		val = (int)floor(v);
+		
+		if (val &gt; 255)
+			val = 255;
+		else if (val &lt; 0)
+			val = 0;
+
+		if (val &gt; 240) {
+			if(u_thresh2 &gt; 255)		u_thresh2 = i;
+			if(param.opt)		val = 240;
+		}
+		else if (val &lt; 16) {
+			u_thresh1 = i;
+			if(param.opt)		val = 16;
+		}
+		LUT_U[i] = (unsigned char)val;
+    }
+
+	gain = ((double)param.v_gain + scale);
+	c = ((double)param.v_contrast + scale);
+	b = ((double)param.v_bright);
+	for (i = 0; i &lt; 256; i++)
+    {
+		val = i * shift;
+		switch (param.levels) {
+			case 1:	// PC-&gt;TV Scale
+				val = (int)((val - 128 * shift) * coeff_v0 / coeff_v1 + 128 * shift + shift / 2);
+				break;
+			case 2:	// TV-&gt;PC Scale
+				val = (int)((val - 128 * shift) * coeff_v1 / coeff_v0 + 128 * shift + shift / 2);
+				break;
+			default:	//none
+				break;
+		}
+		val = val / shift;
+
+		v = ((double)val);
+		v = (v * gain / scale) + ((v-128) * c / scale + 128) - v + b;
+
+		v += 0.5;
+		val = (int)floor(v);
+		
+		if (val &gt; 255)
+			val = 255;
+		else if (val &lt; 0)
+			val = 0;
+		
+		if (val &gt; 240) {
+			if(v_thresh2 &gt; 255)		v_thresh2 = i;
+			if(param.opt)		val = 240;
+		}
+		else if (val &lt; 16) {
+			v_thresh1 = i;
+			if(param.opt)		val = 16;
+		}
+		LUT_V[i] = (unsigned char)val;
+    }
+
+#ifdef _DEBUG
+	DumpLUT();
+#endif
+
+}
+#if 0
+
+void	Color::YUV2RGB(int y, int u, int v, int *r, int *g, int *b, int matrix)
+{
+  if (matrix==0) {
+	  const int cy  = int((255.0/219.0)*65536+0.5);
+	  const int crv = int(1.596*65536+0.5);
+	  const int cgv = int(0.813*65536+0.5);
+	  const int cgu = int(0.391*65536+0.5);
+	  const int cbu = int(2.018*65536+0.5);
+	  int scaled_y = (y - 16) * cy;
+	  *b = ((scaled_y + (u-128) * cbu) + 2^15) &gt;&gt; 16;					// blue
+	  *g = ((scaled_y - (u-128) * cgu - (v-128) * cgv) + 2^15) &gt;&gt; 16;	// green
+	  *r = ((scaled_y + (v-128) * crv) + 2^15) &gt;&gt; 16;					// red
+  } else {
+	  // ITU-R Recommendation  BT.709
+	  const int cy  = 19077;
+	  const int crv = 3960 * 2;
+	  const int cgv = -4363 * 2;
+	  const int cgu = -1744 * 2;
+	  const int cbu = 17307 * 2;
+	  const int shift = 14;
+	  int scaled_y = (y - 16) * cy;
+	  *b = ((scaled_y + (u-128) * cbu) + 2^13) &gt;&gt; 14;					// blue
+	  *g = ((scaled_y - (u-128) * cgu - (v-128) * cgv) + 2^13) &gt;&gt; 14;	// green
+	  *r = ((scaled_y + (v-128) * crv) + 2^13) &gt;&gt; 14;					// red
+  }
+}
+
+
+void	Color::CheckRGB(COUNT *r, COUNT *b, COUNT *g)
+{
+	if(r-&gt;d &lt; 0)		{ r-&gt;under++;	/*r-&gt;d = 0;*/	}
+	if(r-&gt;d &gt; 255)		{ r-&gt;over++;	/*r-&gt;d = 255;*/	}
+	if(g-&gt;d &lt; 0)		{ g-&gt;under++;	/*g-&gt;d = 0;*/	}
+	if(g-&gt;d &gt; 255)		{ g-&gt;over++;	/*g-&gt;d = 255;*/	}
+	if(b-&gt;d &lt; 0)		{ b-&gt;under++;	/*b-&gt;d = 0;*/	}
+	if(b-&gt;d &gt; 255)		{ b-&gt;over++;	/*b-&gt;d = 255;*/	}
+	if(r-&gt;d &lt; r-&gt;x_min)	{ r-&gt;x_min = r-&gt;d;	}
+	if(g-&gt;d &lt; g-&gt;x_min)	{ g-&gt;x_min = g-&gt;d;	}
+	if(b-&gt;d &lt; b-&gt;x_min)	{ b-&gt;x_min = b-&gt;d;	}
+	if(r-&gt;d &gt; r-&gt;x_max)	{ r-&gt;x_max = r-&gt;d;	}
+	if(g-&gt;d &gt; g-&gt;x_max)	{ g-&gt;x_max = g-&gt;d;	}
+	if(b-&gt;d &gt; b-&gt;x_max)	{ b-&gt;x_max = b-&gt;d;	}
+	r-&gt;ave += r-&gt;d;
+	g-&gt;ave += g-&gt;d;
+	b-&gt;ave += b-&gt;d;
+}	
+
+void	Color::CheckYUV(PIXELDATA *pixel0, PIXELDATA *pixel, COUNT *y, COUNT *u, COUNT *v, int terget )
+{
+	if(!terget)	{
+		if(pixel-&gt;yuv.y0 &lt; 16)			{ y-&gt;under++;	}
+		if(pixel-&gt;yuv.y0 &gt; 235)			{ y-&gt;over++;	}
+		if(pixel-&gt;yuv.y1 &lt; 16)			{ y-&gt;under++;	}
+		if(pixel-&gt;yuv.y1 &gt; 235)			{ y-&gt;over++;	}
+	} else {
+		if(pixel0-&gt;yuv.y0 &lt;= y_thresh1)	{ y-&gt;under++;	}
+		if(pixel0-&gt;yuv.y0 &gt;= y_thresh2)	{ y-&gt;over++;	}
+		if(pixel0-&gt;yuv.y1 &lt;= y_thresh1)	{ y-&gt;under++;	}
+		if(pixel0-&gt;yuv.y1 &gt;= y_thresh2)	{ y-&gt;over++;	}
+	}
+	if(pixel-&gt;yuv.y0 &lt; y-&gt;x_min)			{ y-&gt;x_min = pixel-&gt;yuv.y0;}
+	if(pixel-&gt;yuv.y0 &gt; y-&gt;x_max)			{ y-&gt;x_max = pixel-&gt;yuv.y0;}
+	if(pixel-&gt;yuv.y1 &lt; y-&gt;x_min)			{ y-&gt;x_min = pixel-&gt;yuv.y1;}
+	if(pixel-&gt;yuv.y1 &gt; y-&gt;x_max)			{ y-&gt;x_max = pixel-&gt;yuv.y1;}
+	y-&gt;ave += pixel-&gt;yuv.y0;
+	y-&gt;ave += pixel-&gt;yuv.y1;
+
+	if(!terget)	{
+		if(pixel-&gt;yuv.u &lt; 16)			{ u-&gt;under++;	}
+		if(pixel-&gt;yuv.u &gt; 240)			{ u-&gt;over++;	}
+	} else {
+		if(pixel0-&gt;yuv.u &lt;= u_thresh1)	{ u-&gt;under++;	}
+		if(pixel0-&gt;yuv.u &gt;= u_thresh2)	{ u-&gt;over++;	}
+	}
+	if(pixel-&gt;yuv.u &lt; u-&gt;x_min)			{ u-&gt;x_min = pixel-&gt;yuv.u;}
+	if(pixel-&gt;yuv.u &gt; u-&gt;x_max)			{ u-&gt;x_max = pixel-&gt;yuv.u;}
+	u-&gt;ave += pixel-&gt;yuv.u;
+
+	if(!terget)	{
+		if(pixel-&gt;yuv.v &lt; 16)			{ v-&gt;under++;	}
+		if(pixel-&gt;yuv.v &gt; 240)			{ v-&gt;over++;	}
+	} else {
+		if(pixel0-&gt;yuv.v &lt;= v_thresh1)	{ v-&gt;under++;	}
+		if(pixel0-&gt;yuv.v &gt;= v_thresh2)	{ v-&gt;over++;	}
+	}
+	if(pixel-&gt;yuv.v &lt; v-&gt;x_min)			{ v-&gt;x_min = pixel-&gt;yuv.v;}
+	if(pixel-&gt;yuv.v &gt; v-&gt;x_max)			{ v-&gt;x_max = pixel-&gt;yuv.v;}
+	v-&gt;ave += pixel-&gt;yuv.v;
+}
+
+bool Color::CheckParms(const char *_levels, const char *_matrix, const char *_opt)
+{
+	int i;
+	static const char	*LevelsTbl[] = { &quot;&quot;, &quot;TV-&gt;PC&quot;, &quot;PC-&gt;TV&quot;, &quot;PC-&gt;TV.Y&quot; },
+		*MatrixTbl[] = { &quot;&quot;, &quot;rec.709&quot; },
+		*OptTbl[] = { &quot;&quot;, &quot;coring&quot; };
+
+	levels = -1;
+	if (_levels) {
+		for (i=0; i&lt;4 ; i++) {
+			if (!lstrcmpi(_levels, LevelsTbl[i])) 
+			{
+				levels = i;
+				break;
+			}
+		}
+	} else {		
+		levels = 0;
+	}
+
+	matrix = -1;
+	if (_matrix) {
+		for (i=0; i&lt;2 ; i++) {
+			if (!lstrcmpi(_matrix, MatrixTbl[i])) 
+			{
+				matrix = i;
+				break;
+			}
+		}
+	} else {		
+		matrix = 0;
+	}
+
+	opt = -1;
+	if (_opt) {
+		for (i=0; i&lt;2 ; i++) {
+			if (!lstrcmpi(_opt, OptTbl[i])) 
+			{
+				opt = i;
+				break;
+			}
+		}
+	} else {		
+		opt = 0;
+	}
+
+	if ( levels &lt; 0 || matrix &lt; 0 || opt &lt; 0 )	return FALSE;
+	return TRUE;
+}
+
+
+void Color::DumpLUT(void)
+{
+/*
+  static const char *TitleTbl[] = {
+		&quot;Color Adjust Look-up Table : Y, lux_minance\n&quot;,
+		&quot;Color Adjust Look-up Table : U, Cb, Color Difference(blue)\n&quot;,
+		&quot;Color Adjust Look-up Table : V, Cr, Color Difference(red)\n&quot;
+	};
+	static const BYTE *LUT[] = { (BYTE *)&amp;LUT_Y, (BYTE *)&amp;LUT_U, (BYTE *)&amp;LUT_V };
+	int	index,i,j;
+	char buf[512];
+
+	for(index=0; index&lt;3; index++)
+	{
+		OutputDebugString( TitleTbl[index] );
+		for(i=0; i&lt;16;i++)
+		{
+			sprintf(buf,&quot;%03d(%02X) : &quot;, i * 16, i * 16);
+			for(j=0;j&lt;8;j++)
+			{
+				sprintf(&amp;buf[j*4+10], &quot;%03d &quot;,LUT[index][i*16+j]);
+			}
+			sprintf(&amp;buf[8*4+10], &quot; - &quot;);
+			for(j=8;j&lt;16;j++)
+			{
+				sprintf(&amp;buf[j*4+13], &quot;%03d &quot;,LUT[index][i*16+j]);
+			}
+			OutputDebugString(buf);
+		}
+		OutputDebugString(&quot;\n&quot;);
+	}
+*/
+}
+AVSValue __cdecl Color::Create(AVSValue args, void* user_data, IScriptEnvironment* env) {
+    try {	// HIDE DAMN SEH COMPILER BUG!!!
+		return new Color(args[0].AsClip(),
+						args[1].AsFloat(0.0),		// gain_y
+						args[2].AsFloat(0.0),		// off_y      bright
+						args[3].AsFloat(0.0),		// gamma_y
+						args[4].AsFloat(0.0),		// cont_y
+						args[5].AsFloat(0.0),		// gain_u
+						args[6].AsFloat(0.0),		// off_u      bright
+						args[7].AsFloat(0.0),		// gamma_u
+						args[8].AsFloat(0.0),		// cont_u
+						args[9].AsFloat(0.0),		// gain_v
+						args[10].AsFloat(0.0),		// off_v
+						args[11].AsFloat(0.0),		// gamma_v
+						args[12].AsFloat(0.0),		// cont_v
+						args[13].AsString(&quot;&quot;),		// levels = &quot;&quot;, &quot;TV-&gt;PC&quot;, &quot;PC-&gt;TV&quot;
+						args[14].AsString(&quot;&quot;),		// opt = &quot;&quot;, &quot;coring&quot;
+						args[15].AsString(&quot;&quot;),		// matrix = &quot;&quot;, &quot;rec.709&quot;
+						args[16].AsBool(false),		// colorbars
+						args[17].AsBool(false),		// analyze
+						args[18].AsBool(false),		// autowhite
+						args[19].AsBool(false),		// autogain
+						env);
+	}
+	catch (...) { throw; }
+}
+#endif
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,19 @@
+float:y_contrast
+float:y_bright
+float:y_gamma
+float:y_gain
+float:u_contrast
+float:u_bright
+float:u_gamma
+float:u_gain;
+float:v_contrast
+float:v_bright
+float:v_gamma
+float:v_gain
+int32_t:matrix
+int32_t:levels
+int32_t:opt
+uint32_t:colorbars
+uint32_t:analyze
+uint32_t:autowhite
+uint32_t:autogain #matrix : 0 : none   1: rec.709 #Level :  0 : none   1:&quot;TV-&gt;PC&quot;, 2:&quot;PC-&gt;TV&quot;, 3:&quot;PC-&gt;TV.Y&quot; Opt :    0 : none   1: Coring

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,26 @@
+// Automatically generated, do not edit!
+#ifndef ADM_colorYuv_CONF_H
+#define ADM_colorYuv_CONF_H
+typedef struct {
+   float y_contrast;
+   float y_bright;
+   float y_gamma;
+   float y_gain;
+   float u_contrast;
+   float u_bright;
+   float u_gamma;
+   float u_gain;
+   float v_contrast;
+   float v_bright;
+   float v_gamma;
+   float v_gain;
+   int32_t matrix;
+   int32_t levels;
+   int32_t opt;
+   uint32_t colorbars;
+   uint32_t analyze;
+   uint32_t autowhite;
+   uint32_t autogain ;
+}colorYuv;
+#endif //colorYuv
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,23 @@
+// Automatically generated, do not edit!
+const ADM_paramList colorYuv_param[]={
+ {&quot;y_contrast&quot;,offsetof( colorYuv,y_contrast),&quot;float&quot;,ADM_param_float},
+ {&quot;y_bright&quot;,offsetof( colorYuv,y_bright),&quot;float&quot;,ADM_param_float},
+ {&quot;y_gamma&quot;,offsetof( colorYuv,y_gamma),&quot;float&quot;,ADM_param_float},
+ {&quot;y_gain&quot;,offsetof( colorYuv,y_gain),&quot;float&quot;,ADM_param_float},
+ {&quot;u_contrast&quot;,offsetof( colorYuv,u_contrast),&quot;float&quot;,ADM_param_float},
+ {&quot;u_bright&quot;,offsetof( colorYuv,u_bright),&quot;float&quot;,ADM_param_float},
+ {&quot;u_gamma&quot;,offsetof( colorYuv,u_gamma),&quot;float&quot;,ADM_param_float},
+ {&quot;u_gain&quot;,offsetof( colorYuv,u_gain),&quot;float&quot;,ADM_param_float},
+ {&quot;v_contrast&quot;,offsetof( colorYuv,v_contrast),&quot;float&quot;,ADM_param_float},
+ {&quot;v_bright&quot;,offsetof( colorYuv,v_bright),&quot;float&quot;,ADM_param_float},
+ {&quot;v_gamma&quot;,offsetof( colorYuv,v_gamma),&quot;float&quot;,ADM_param_float},
+ {&quot;v_gain&quot;,offsetof( colorYuv,v_gain),&quot;float&quot;,ADM_param_float},
+ {&quot;matrix&quot;,offsetof( colorYuv,matrix),&quot;int32_t&quot;,ADM_param_int32_t},
+ {&quot;levels&quot;,offsetof( colorYuv,levels),&quot;int32_t&quot;,ADM_param_int32_t},
+ {&quot;opt&quot;,offsetof( colorYuv,opt),&quot;int32_t&quot;,ADM_param_int32_t},
+ {&quot;colorbars&quot;,offsetof( colorYuv,colorbars),&quot;uint32_t&quot;,ADM_param_uint32_t},
+ {&quot;analyze&quot;,offsetof( colorYuv,analyze),&quot;uint32_t&quot;,ADM_param_uint32_t},
+ {&quot;autowhite&quot;,offsetof( colorYuv,autowhite),&quot;uint32_t&quot;,ADM_param_uint32_t},
+ {&quot;autogain &quot;,offsetof( colorYuv,autogain ),&quot;uint32_t&quot;,ADM_param_uint32_t},
+{NULL,0,NULL}
+};


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003898.html">[Avidemux-svn-commit] r6716 -	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src
</A></li>
	<LI>Next message: <A HREF="003900.html">[Avidemux-svn-commit] r6718 -	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3899">[ date ]</a>
              <a href="thread.html#3899">[ thread ]</a>
              <a href="subject.html#3899">[ subject ]</a>
              <a href="author.html#3899">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
