<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6697 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-October/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6697%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src&In-Reply-To=%3C20101006054209.1E5D9480E0A%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003878.html">
   <LINK REL="Next"  HREF="003880.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6697 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6697%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src&In-Reply-To=%3C20101006054209.1E5D9480E0A%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6697 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src">mean at mail.berlios.de
       </A><BR>
    <I>Wed Oct  6 07:42:09 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003878.html">[Avidemux-svn-commit] r6696 -	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Srt
</A></li>
        <LI>Next message: <A HREF="003880.html">[Avidemux-svn-commit] r6698 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3879">[ date ]</a>
              <a href="thread.html#3879">[ thread ]</a>
              <a href="subject.html#3879">[ subject ]</a>
              <a href="author.html#3879">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-10-06 07:42:08 +0200 (Wed, 06 Oct 2010)
New Revision: 6697

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
Log:
[corevideo] revert CR/LF to LF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-10-04 05:27:28 UTC (rev 6696)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-10-06 05:42:08 UTC (rev 6697)
@@ -1,623 +1,623 @@
-/***************************************************************************
-    \file ADM_ffmp43
-    \brief Decoders using lavcodec
-    \author mean &amp; all (c) 2002-2010
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-extern &quot;C&quot; {
-#include &quot;ADM_lavcodec.h&quot;
-}
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_codec.h&quot;
-#include &quot;ADM_ffmp43.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-//#include &quot;ADM_videoInfoExtractor.h&quot;
-
-extern int ADM_cpu_num_processors(void);
-extern &quot;C&quot;
-{
-    static void ADM_releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-    static int  ADM_getBuffer(AVCodecContext *avctx, AVFrame *pic);
-}
-
-#define aprintf(...) {}
-
-#define WRAP_Open_Template(funcz,argz,display,codecid) \
-{\
-AVCodec *codec=funcz(argz);\
-if(!codec) {GUI_Error_HIG(&quot;Codec&quot;,QT_TR_NOOP(&quot;Internal error finding codec&quot;display));ADM_assert(0);} \
-  codecId=codecid; \
-  _context-&gt;workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
-  _context-&gt;error_concealment=3; \
-  if (avcodec_open(_context, codec) &lt; 0)  \
-                      { \
-                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder failed!\n&quot;); \
-                                        GUI_Error_HIG(&quot;Codec&quot;,&quot;Internal error opening &quot;display); \
-                                        ADM_assert(0); \
-                                } \
-                                else \
-                                { \
-                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder initialized! (%s)\n&quot;,codec-&gt;long_name); \
-                                } \
-}
-
-#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
-#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
-
-
-//****************************
-extern uint8_t DIA_lavDecoder (uint32_t * swapUv, uint32_t * showU);
-extern &quot;C&quot;
-{
-  int av_is_voppacked (AVCodecContext * avctx, int *vop_packed, int *gmc,
-		       int *qpel);
-};
-/**
-    \fn clonePic
-    \brief Convert AvFrame to ADMImage
-*/
-uint8_t decoderFF::clonePic (AVFrame * src, ADMImage * out)
-{
-  uint32_t    u,v;
-  ADM_assert(out-&gt;isRef());
-  ADMImageRef *ref=out-&gt;castToRef();
-  ref-&gt;_planes[0] = (uint8_t *) src-&gt;data[0];
-  ref-&gt;_planeStride[0] = src-&gt;linesize[0];
-  if (_swapUV)
-    {
-      u = 1;
-      v = 2;
-    }
-  else
-    {
-      u = 2;
-      v = 1;
-    }
-  ref-&gt;_planes[1] = (uint8_t *) src-&gt;data[u];
-  ref-&gt;_planeStride[1] = src-&gt;linesize[u];
-
-  ref-&gt;_planes[2] = (uint8_t *) src-&gt;data[v];
-  ref-&gt;_planeStride[2] = src-&gt;linesize[v];
-
-  _lastQ = 0;			//_context-&gt;quality;
-  out-&gt;_Qp = (src-&gt;quality * 32) / FF_LAMBDA_MAX;
-  out-&gt;flags = frameType ();
-
-  // Quant ?
-  if (src-&gt;qstride &amp;&amp; src-&gt;qscale_table &amp;&amp; codecId != CODEC_ID_H264)
-    {
-      out-&gt;quant = (uint8_t *) src-&gt;qscale_table;
-      out-&gt;_qStride = src-&gt;qstride;
-      out-&gt;_qSize = (_w + 15) &gt;&gt; 4;
-      out-&gt;_qSize *= (_h + 15) &gt;&gt; 4;	// FixME?
-    }
-  else
-    {
-      out-&gt;_qSize = out-&gt;_qStride = 0;
-      out-&gt;quant = NULL;
-    }
-    //printf(&quot;[LAVC] Old pts :%&quot;LLD&quot; new pts :%&quot;LLD&quot;\n&quot;,out-&gt;Pts, (uint64_t)(src-&gt;reordered_opaque));
-    //printf(&quot;[LAVC] pts: %&quot;LLU&quot;\n&quot;,src-&gt;pts);
-    out-&gt;Pts= (uint64_t)(src-&gt;reordered_opaque);
- 
-    return 1;
-}
-/**
-        \fn decoderMultiThread
-        \brief Enabled multitheaded decoder if possible
-*/
-void decoderFF::decoderMultiThread (void)
-{
-  uint32_t threads = 0;
-
- // prefs-&gt;get(FEATURE_THREADING_LAVC, &amp;threads);
-#warning Fixme
-    threads=1;
-  if (threads == 0)
-	  threads = ADM_cpu_num_processors();
-
-  if (threads == 1)
-	  threads = 0;
-
-  if (threads)
-  {
-      printf (&quot;[lavc] Enabling MT decoder with %u threads\n&quot;, threads);
-
-      if (avcodec_thread_init (_context, threads) == -1)
-	      printf (&quot;[lavc] Failed!!\n&quot;);
-	  else
-          _usingMT = 1;
-  }
-}
-uint8_t decoderFF::getPARWidth (void)
-{
-  if(!_context-&gt;sample_aspect_ratio.num) return 1;
-  return _context-&gt;sample_aspect_ratio.num;
-}
-uint8_t decoderFF::getPARHeight (void)
-{
-  if(!_context-&gt;sample_aspect_ratio.den) return 1;
-  return _context-&gt;sample_aspect_ratio.den;
-
-}
-
-//________________________________________________
-bool  decoderFF::setParam (void)
-{
-  DIA_lavDecoder (&amp;_swapUV, &amp;_showMv);
-  return true;			// no param for ffmpeg
-}
-
-//-------------------------------
-decoderFF::decoderFF (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-            :decoders (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  codecId = 0;
-//                              memset(&amp;_context,0,sizeof(_context));
-  _allowNull = 0;
-  _gmc = 0;
-  _context = NULL;
-  _refCopy = 0;
-  _usingMT = 0;
-#if LIBAVCODEC_BUILD &gt;= 4624
-  _context = avcodec_alloc_context ();
-#else
-  _context = new AVCodecContext;
-  memset (_context, 0, sizeof (AVCodecContext));
-#endif
-  ADM_assert (_context);
-  memset (&amp;_frame, 0, sizeof (_frame));
-
-  _context-&gt;max_b_frames = 0;
-
-  _context-&gt;width = _w;
-  _context-&gt;height = _h;
-  _context-&gt;pix_fmt = PIX_FMT_YUV420P;	//PIX_FMT_RGBA32
-  //_context-&gt;debug=1;
-
-  _internalBuffer = new uint8_t[w * h * 3];
-
-  _swapUV = 0;
-  //_context-&gt;strict_std_compliance=-1;
-
-  _showMv = 0;
-#define FF_SHOW		(FF_DEBUG_VIS_MV_P_FOR+	FF_DEBUG_VIS_MV_B_FOR+FF_DEBUG_VIS_MV_B_BACK)
-//#define FF_SHOW               (FF_DEBUG_VIS_MV_P_FOR)
-  printf (&quot;[lavc] Build: %d\n&quot;, LIBAVCODEC_BUILD);
-  _context-&gt;debug_mv |= FF_SHOW;
-  _context-&gt;debug |= FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP;
-  
-}
-
-//_____________________________________________________
-
-decoderFF::~decoderFF ()
-{
-  if (_usingMT)
-    {
-      printf (&quot;[lavc] Killing decoding threads\n&quot;);
-      avcodec_thread_free (_context);
-      _usingMT = 0;
-    }
-
-  avcodec_close (_context);
-  ADM_dealloc (_context);
-  delete[]_internalBuffer;
-  printf (&quot;[lavc] Destroyed\n&quot;);
-}
-
-/**
-    \fn frameType
-    \return frametype of the last decoded frame
-*/
-uint32_t decoderFF::frameType (void)
-{
-  uint32_t
-    flag = 0;
-
-  AVFrame *
-    target;
-#define SET(x) {flag=x;aprintf(&quot;Frame is %s\n&quot;,#x);}
-
-
-  target = &amp;_frame;
-  switch (target-&gt;pict_type)
-    {
-    case FF_B_TYPE:
-      SET (AVI_B_FRAME);
-      if (target-&gt;key_frame)
-	aprintf (&quot;\n But keyframe is set\n&quot;);
-      break;
-
-    case FF_I_TYPE:
-      SET (AVI_KEY_FRAME);
-      if (!target-&gt;key_frame)
-	{
-	  if (codecId == CODEC_ID_H264)
-	    {
-	      SET (AVI_P_FRAME);
-	    }
-	  else
-	    printf (&quot;\n But keyframe is not set\n&quot;);
-	}
-      break;
-    case FF_S_TYPE:
-      _gmc = 1;			// No break, just inform that gmc is there
-    case FF_P_TYPE:
-      SET (AVI_P_FRAME);
-      if (target-&gt;key_frame)
-	aprintf (&quot;\n But keyframe is set\n&quot;);
-      break;
-    default:
-//                              printf(&quot;\n OOops XXX frame ?\n&quot;);
-      break;
-    }
-    flag&amp;=~AVI_STRUCTURE_TYPE_MASK;
-    if(target-&gt;interlaced_frame)
-    {
-        flag|=AVI_FIELD_STRUCTURE;
-        if(target-&gt;top_field_first)
-            flag|=AVI_TOP_FIELD;
-        else
-            flag|=AVI_BOTTOM_FIELD;
-    }
-  return flag;
-}
-bool decoderFF::decodeHeaderOnly (void)
-{
-  if (codecId == CODEC_ID_H264)
-    _context-&gt;hurry_up = 4;
-  else
-    _context-&gt;hurry_up = 5;
-  printf (&quot;\n[lavc] Hurry up\n&quot;);
-  return 1;
-}
-bool decoderFF::decodeFull (void)
-{
-  _context-&gt;hurry_up = 0;
-  printf (&quot;\n[lavc] full decoding\n&quot;);
-  return 1;
-}
-
-/**
-    \fn flush
-    \brief empty internal buffer
-*/
-bool    decoderFF::flush(void)
-{
-    if(_context)
-        avcodec_flush_buffers(_context);
-    return true;
-}
-/**
-    \fn uncompress
-    \brief Actually decode an image
-*/
-bool   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-  int got_picture = 0;
-  uint8_t *oBuff[3];
-  int strideTab[3];
-  int strideTab2[3];
-  int ret = 0;
-  out-&gt;_noPicture = 0;
-  if (_showMv)
-    {
-      _context-&gt;debug_mv |= FF_SHOW;
-      _context-&gt;debug |= 0;	//FF_DEBUG_VIS_MB_TYPE;
-    }
-  else
-    {
-      _context-&gt;debug_mv &amp;= ~FF_SHOW;
-      _context-&gt;debug &amp;= ~(FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP);
-    }
-
-   
-    
-  if (in-&gt;dataLength == 0 &amp;&amp; !_allowNull)	// Null frame, silently skipped
-    {
-      
-      printf (&quot;[Codec] null frame\n&quot;);
-        // search the last image
-        if (_context-&gt;coded_frame &amp;&amp; 
-            _context-&gt;coded_frame-&gt;data &amp;&amp;
-            _context-&gt;coded_frame-&gt;data[0]
-            )
-          {
-            printf(&quot;[Codec] Cloning older pic\n&quot;);
-            clonePic (_context-&gt;coded_frame, out);
-            out-&gt;Pts=ADM_COMPRESSED_NO_PTS;
-          }
-        else
-            {
-                out-&gt;_noPicture = 1;
-                out-&gt;Pts=ADM_COMPRESSED_NO_PTS;
-                printf(&quot;[Codec] No Picture\n&quot;);
-            }
-          return 1;
-    }
-   // Put a safe value....
-   out-&gt;Pts=in-&gt;demuxerPts;
-    _context-&gt;reordered_opaque=in-&gt;demuxerPts;
-  //_frame.opaque=(void *)out-&gt;Pts;
-  //printf(&quot;Incoming Pts :%&quot;LLD&quot;\n&quot;,out-&gt;Pts);
-  AVPacket pkt;
-  av_init_packet(&amp;pkt);
-  pkt.data=in-&gt;data;
-  pkt.size=in-&gt;dataLength;
-  if(in-&gt;flags&amp;AVI_KEY_FRAME)
-    pkt.flags=AV_PKT_FLAG_KEY;
-  else
-    pkt.flags=0;
-  
-  ret = avcodec_decode_video2 (_context, &amp;_frame, &amp;got_picture, &amp;pkt);
-  if(!bFramePossible())
-  {
-    // No delay, the value is sure, no need to hide it in opaque
-    _context-&gt;reordered_opaque=(int64_t)in-&gt;demuxerPts;
-  }
-  out-&gt;_qStride = 0;		//Default = no quant
-  if (0 &gt; ret &amp;&amp; !_context-&gt;hurry_up)
-    {
-      printf (&quot;\n[lavc] error in lavcodec decoder!\n&quot;);
-      printf (&quot;[lavc] Err: %d, size :%d\n&quot;, ret, in-&gt;dataLength);
-      return 0;
-    }
-  if (!got_picture &amp;&amp; !_context-&gt;hurry_up)
-    {
-      // Some encoder code a vop header with the 
-      // vop flag set to 0
-      // it is meant to mean frame skipped but very dubious
-      if (in-&gt;dataLength &lt;= 8 &amp;&amp; codecId == CODEC_ID_MPEG4)
-	{
-	  printf (&quot;[lavc] Probably pseudo black frame...\n&quot;);
-	  out-&gt;_Qp = 2;
-	  out-&gt;flags = 0;	// assume P ?
-
-	  clonePic (_context-&gt;coded_frame, out);
-	  return 1;
-	}
-      // allow null means we allow null frame in and so potentially
-      // have no frame out for a time
-      // in that case silently fill with black and returns it as KF
-      if (_allowNull)
-	{
-	  out-&gt;flags = AVI_KEY_FRAME;
-	  if (!_refCopy)
-	    {
-            out-&gt;blacken();
-	    }
-	  else
-	    {
-	      out-&gt;_noPicture = 1;
-	    }
-	  printf (&quot;\n[lavc] ignoring got pict ==0\n&quot;);
-	  return 1;
-
-	}
-#if 0
-      printf (&quot;[lavc] Err: %d, size: %d\n&quot;, ret, in-&gt;dataLength);
-      printf (&quot;\n[lavc] error in FFMP43/mpeg4!: got picture\n&quot;);
-#endif
-      //GUI_Alert(&quot;Please retry with misc-&gt;Turbo off&quot;);
-      //return 1;
-      return 0;
-    }
-  if (_context-&gt;hurry_up)
-    {
-      out-&gt;flags = frameType ();
-      return 1;
-    }
-  // We have an image....
-  switch (_context-&gt;pix_fmt)
-    {
-    case PIX_FMT_YUV411P:
-      out-&gt;_colorspace = ADM_COLOR_YUV411;
-      break;
-    case PIX_FMT_YUYV422:
-      out-&gt;_colorspace = ADM_COLOR_YUV422;
-      break;
-    case PIX_FMT_YUV422P:
-    case PIX_FMT_YUVJ422P:
-      out-&gt;_colorspace = ADM_COLOR_YUV422P;
-      break;
-    case PIX_FMT_YUV444P:
-    case PIX_FMT_YUVJ444P:
-      out-&gt;_colorspace = ADM_COLOR_YUV444;
-      break;
-    case PIX_FMT_YUV420P:
-    case PIX_FMT_YUVJ420P:
-    case PIX_FMT_YUVA420P:
-      // Default is YV12 or I420
-      // In that case depending on swap u/v
-      // we do it or not
-      out-&gt;_colorspace = ADM_COLOR_YV12;
-      break;
-	case PIX_FMT_RGB24:
-	  out-&gt;_colorspace = ADM_COLOR_BGR24;
-	  break;
-    case PIX_FMT_BGRA:
-      out-&gt;_colorspace = ADM_COLOR_BGR32A;
-      break;
-    case PIX_FMT_RGBA: // ???PIX_FMT_RGBA32:
-      out-&gt;_colorspace = ADM_COLOR_RGB32A;
-      break;
-    case PIX_FMT_RGB555:
-      out-&gt;_colorspace = ADM_COLOR_RGB555;
-      break;
-    case PIX_FMT_VDPAU_MPEG1:
-    case PIX_FMT_VDPAU_MPEG2:
-    case PIX_FMT_VDPAU_WMV3:
-    case PIX_FMT_VDPAU_VC1:
-    case PIX_FMT_VDPAU_H264:
-        out-&gt;_colorspace=ADM_COLOR_VDPAU;
-        break;
-    default:
-      printf (&quot;[lavc] Unhandled colorspace: %d\n&quot;, _context-&gt;pix_fmt);
-      return 0;
-    }
-    clonePic (&amp;_frame, out);
-    //printf(&quot;[AvCodec] Pts : %llu Out Pts:%llu \n&quot;,_frame.pts,out-&gt;Pts);
-
-  return 1;
-}
-// *******************************************************************
-// *******************************************************************
-// *******************************************************************
-
-decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_MSMPEG4V3);
-}
-
-decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-// force low delay as avidemux don't handle B-frames
-  ADM_info (&quot;[lavc] Using %d bytes of extradata for MPEG4 decoder\n&quot;, (int)extraDataLen);
-  
-  _refCopy = 1;			// YUV420 only
-  _context-&gt;extradata = (uint8_t *) extraData;
-  _context-&gt;extradata_size = (int)extraDataLen  ;
-  _context-&gt;codec_tag=fcc;
-  _context-&gt;stream_codec_tag=fcc;
-  decoderMultiThread ();
-  //  _context-&gt;flags|=FF_DEBUG_VIS_MV;
-  WRAP_Open (CODEC_ID_MPEG4);
-}
-bool decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-    // For pseudo startcode
-    if(in-&gt;dataLength)
-    {
-        in-&gt;data[in-&gt;dataLength]=0;
-        in-&gt;data[in-&gt;dataLength+1]=0;
-    }
-    return decoderFF::uncompress(in,out);
-
-}
-//************************************
-decoderFFDV::decoderFFDV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context-&gt;extradata = (uint8_t *) extraData;
-  _context-&gt;extradata_size = (int) extraDataLen;
-  WRAP_Open (CODEC_ID_DVVIDEO);
-
-}
-decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-                decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _refCopy = 1;			// YUV420 only
-  decoderMultiThread ();
-  WRAP_Open (CODEC_ID_MPEG2VIDEO);
-}
-
-decoderFFPng::decoderFFPng(uint32_t w, uint32_t h, uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData, uint32_t bpp) : decoderFF(w, h, fcc, extraDataLen, extraData, bpp)
-{
-	WRAP_Open (CODEC_ID_PNG);
-}
-
-decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context-&gt;extradata = (uint8_t *) extraData;
-  _context-&gt;extradata_size = (int) extraDataLen;
-  _context-&gt;bits_per_coded_sample=bpp;
-  ADM_info (&quot;[lavc] FFhuff: We have %d bytes of extra data\n&quot;, (int)extraDataLen);
-  WRAP_Open (CODEC_ID_FFVHUFF);
-
-}
-decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-        :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-
-  _refCopy = 1;			// YUV420 only
-  _context-&gt;extradata = (uint8_t *) extraData;
-  _context-&gt;extradata_size = (int) extraDataLen;
-  decoderMultiThread ();
-  ADM_info (&quot;[lavc] Initializing H264 decoder with %d extradata\n&quot;, (int)extraDataLen);
-  WRAP_Open(CODEC_ID_H264);
-}
-//*********************
-extern &quot;C&quot; {int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc);}
-/**
-    \fn uncompress
-*/
-bool   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-  if(!_context-&gt;hurry_up) return decoderFF::uncompress (in, out);
-    ADM_assert(0);
-#if 0  
-  uint32_t nalSize, isAvc;
-  av_getAVCStreamInfo(_context,&amp;nalSize,&amp;isAvc);
-  if(isAvc)
-  {
-      return extractH264FrameType(nalSize, in-&gt;data,in-&gt;dataLength,&amp;(out-&gt;flags));
-  }else
-  {
-    return extractH264FrameType_startCode(nalSize, in-&gt;data,in-&gt;dataLength,&amp;(out-&gt;flags));
-  }
-#endif
-}
-//*********************
-decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context-&gt;extradata = (uint8_t *) extraData;
-  _context-&gt;extradata_size = (int) extraDataLen;
-  _context-&gt;bits_per_coded_sample = bpp;
-  WRAP_Open (CODEC_ID_HUFFYUV);
-}
-
-//***************
-extern uint8_t  lavformat_init(void);
-extern void     avcodec_init(void );
-extern  void    avcodec_register_all(void );
-extern &quot;C&quot;
-{
-  void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list);
-}
-/**
-    \fn ADM_lavInit
-    \brief Init both lavcodec and lavformat
-*/
-void ADM_lavInit(void)
-{
-    avcodec_init();
-    avcodec_register_all();
-//BAZOOKA    lavformat_init();
-    av_log_set_callback(adm_lavLogCallback);
-#ifdef ADM_DEBUG
-  //  av_log_set_level(AV_LOG_DEBUG);
-#endif
-
-}
-void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list)
-{
-   // if(level&gt;1) return;
-    char buf[256];
-  
-    vsnprintf(buf, sizeof(buf), fmt, list);
-    if(level&lt;=AV_LOG_INFO)
-        ADM_info(&quot;[lavc] %s&quot;,buf);
-}
-
-void ADM_lavDestroy(void)
-{
-	//av_free_static();
-}
-
-// EOF
+/***************************************************************************
+    \file ADM_ffmp43
+    \brief Decoders using lavcodec
+    \author mean &amp; all (c) 2002-2010
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+extern &quot;C&quot; {
+#include &quot;ADM_lavcodec.h&quot;
+}
+#include &quot;ADM_default.h&quot;
+
+#include &quot;ADM_codec.h&quot;
+#include &quot;ADM_ffmp43.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+//#include &quot;ADM_videoInfoExtractor.h&quot;
+
+extern int ADM_cpu_num_processors(void);
+extern &quot;C&quot;
+{
+    static void ADM_releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+    static int  ADM_getBuffer(AVCodecContext *avctx, AVFrame *pic);
+}
+
+#define aprintf(...) {}
+
+#define WRAP_Open_Template(funcz,argz,display,codecid) \
+{\
+AVCodec *codec=funcz(argz);\
+if(!codec) {GUI_Error_HIG(&quot;Codec&quot;,QT_TR_NOOP(&quot;Internal error finding codec&quot;display));ADM_assert(0);} \
+  codecId=codecid; \
+  _context-&gt;workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
+  _context-&gt;error_concealment=3; \
+  if (avcodec_open(_context, codec) &lt; 0)  \
+                      { \
+                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder failed!\n&quot;); \
+                                        GUI_Error_HIG(&quot;Codec&quot;,&quot;Internal error opening &quot;display); \
+                                        ADM_assert(0); \
+                                } \
+                                else \
+                                { \
+                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder initialized! (%s)\n&quot;,codec-&gt;long_name); \
+                                } \
+}
+
+#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
+#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
+
+
+//****************************
+extern uint8_t DIA_lavDecoder (uint32_t * swapUv, uint32_t * showU);
+extern &quot;C&quot;
+{
+  int av_is_voppacked (AVCodecContext * avctx, int *vop_packed, int *gmc,
+		       int *qpel);
+};
+/**
+    \fn clonePic
+    \brief Convert AvFrame to ADMImage
+*/
+uint8_t decoderFF::clonePic (AVFrame * src, ADMImage * out)
+{
+  uint32_t    u,v;
+  ADM_assert(out-&gt;isRef());
+  ADMImageRef *ref=out-&gt;castToRef();
+  ref-&gt;_planes[0] = (uint8_t *) src-&gt;data[0];
+  ref-&gt;_planeStride[0] = src-&gt;linesize[0];
+  if (_swapUV)
+    {
+      u = 1;
+      v = 2;
+    }
+  else
+    {
+      u = 2;
+      v = 1;
+    }
+  ref-&gt;_planes[1] = (uint8_t *) src-&gt;data[u];
+  ref-&gt;_planeStride[1] = src-&gt;linesize[u];
+
+  ref-&gt;_planes[2] = (uint8_t *) src-&gt;data[v];
+  ref-&gt;_planeStride[2] = src-&gt;linesize[v];
+
+  _lastQ = 0;			//_context-&gt;quality;
+  out-&gt;_Qp = (src-&gt;quality * 32) / FF_LAMBDA_MAX;
+  out-&gt;flags = frameType ();
+
+  // Quant ?
+  if (src-&gt;qstride &amp;&amp; src-&gt;qscale_table &amp;&amp; codecId != CODEC_ID_H264)
+    {
+      out-&gt;quant = (uint8_t *) src-&gt;qscale_table;
+      out-&gt;_qStride = src-&gt;qstride;
+      out-&gt;_qSize = (_w + 15) &gt;&gt; 4;
+      out-&gt;_qSize *= (_h + 15) &gt;&gt; 4;	// FixME?
+    }
+  else
+    {
+      out-&gt;_qSize = out-&gt;_qStride = 0;
+      out-&gt;quant = NULL;
+    }
+    //printf(&quot;[LAVC] Old pts :%&quot;LLD&quot; new pts :%&quot;LLD&quot;\n&quot;,out-&gt;Pts, (uint64_t)(src-&gt;reordered_opaque));
+    //printf(&quot;[LAVC] pts: %&quot;LLU&quot;\n&quot;,src-&gt;pts);
+    out-&gt;Pts= (uint64_t)(src-&gt;reordered_opaque);
+ 
+    return 1;
+}
+/**
+        \fn decoderMultiThread
+        \brief Enabled multitheaded decoder if possible
+*/
+void decoderFF::decoderMultiThread (void)
+{
+  uint32_t threads = 0;
+
+ // prefs-&gt;get(FEATURE_THREADING_LAVC, &amp;threads);
+#warning Fixme
+    threads=1;
+  if (threads == 0)
+	  threads = ADM_cpu_num_processors();
+
+  if (threads == 1)
+	  threads = 0;
+
+  if (threads)
+  {
+      printf (&quot;[lavc] Enabling MT decoder with %u threads\n&quot;, threads);
+
+      if (avcodec_thread_init (_context, threads) == -1)
+	      printf (&quot;[lavc] Failed!!\n&quot;);
+	  else
+          _usingMT = 1;
+  }
+}
+uint8_t decoderFF::getPARWidth (void)
+{
+  if(!_context-&gt;sample_aspect_ratio.num) return 1;
+  return _context-&gt;sample_aspect_ratio.num;
+}
+uint8_t decoderFF::getPARHeight (void)
+{
+  if(!_context-&gt;sample_aspect_ratio.den) return 1;
+  return _context-&gt;sample_aspect_ratio.den;
+
+}
+
+//________________________________________________
+bool  decoderFF::setParam (void)
+{
+  DIA_lavDecoder (&amp;_swapUV, &amp;_showMv);
+  return true;			// no param for ffmpeg
+}
+
+//-------------------------------
+decoderFF::decoderFF (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+            :decoders (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  codecId = 0;
+//                              memset(&amp;_context,0,sizeof(_context));
+  _allowNull = 0;
+  _gmc = 0;
+  _context = NULL;
+  _refCopy = 0;
+  _usingMT = 0;
+#if LIBAVCODEC_BUILD &gt;= 4624
+  _context = avcodec_alloc_context ();
+#else
+  _context = new AVCodecContext;
+  memset (_context, 0, sizeof (AVCodecContext));
+#endif
+  ADM_assert (_context);
+  memset (&amp;_frame, 0, sizeof (_frame));
+
+  _context-&gt;max_b_frames = 0;
+
+  _context-&gt;width = _w;
+  _context-&gt;height = _h;
+  _context-&gt;pix_fmt = PIX_FMT_YUV420P;	//PIX_FMT_RGBA32
+  //_context-&gt;debug=1;
+
+  _internalBuffer = new uint8_t[w * h * 3];
+
+  _swapUV = 0;
+  //_context-&gt;strict_std_compliance=-1;
+
+  _showMv = 0;
+#define FF_SHOW		(FF_DEBUG_VIS_MV_P_FOR+	FF_DEBUG_VIS_MV_B_FOR+FF_DEBUG_VIS_MV_B_BACK)
+//#define FF_SHOW               (FF_DEBUG_VIS_MV_P_FOR)
+  printf (&quot;[lavc] Build: %d\n&quot;, LIBAVCODEC_BUILD);
+  _context-&gt;debug_mv |= FF_SHOW;
+  _context-&gt;debug |= FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP;
+  
+}
+
+//_____________________________________________________
+
+decoderFF::~decoderFF ()
+{
+  if (_usingMT)
+    {
+      printf (&quot;[lavc] Killing decoding threads\n&quot;);
+      avcodec_thread_free (_context);
+      _usingMT = 0;
+    }
+
+  avcodec_close (_context);
+  ADM_dealloc (_context);
+  delete[]_internalBuffer;
+  printf (&quot;[lavc] Destroyed\n&quot;);
+}
+
+/**
+    \fn frameType
+    \return frametype of the last decoded frame
+*/
+uint32_t decoderFF::frameType (void)
+{
+  uint32_t
+    flag = 0;
+
+  AVFrame *
+    target;
+#define SET(x) {flag=x;aprintf(&quot;Frame is %s\n&quot;,#x);}
+
+
+  target = &amp;_frame;
+  switch (target-&gt;pict_type)
+    {
+    case FF_B_TYPE:
+      SET (AVI_B_FRAME);
+      if (target-&gt;key_frame)
+	aprintf (&quot;\n But keyframe is set\n&quot;);
+      break;
+
+    case FF_I_TYPE:
+      SET (AVI_KEY_FRAME);
+      if (!target-&gt;key_frame)
+	{
+	  if (codecId == CODEC_ID_H264)
+	    {
+	      SET (AVI_P_FRAME);
+	    }
+	  else
+	    printf (&quot;\n But keyframe is not set\n&quot;);
+	}
+      break;
+    case FF_S_TYPE:
+      _gmc = 1;			// No break, just inform that gmc is there
+    case FF_P_TYPE:
+      SET (AVI_P_FRAME);
+      if (target-&gt;key_frame)
+	aprintf (&quot;\n But keyframe is set\n&quot;);
+      break;
+    default:
+//                              printf(&quot;\n OOops XXX frame ?\n&quot;);
+      break;
+    }
+    flag&amp;=~AVI_STRUCTURE_TYPE_MASK;
+    if(target-&gt;interlaced_frame)
+    {
+        flag|=AVI_FIELD_STRUCTURE;
+        if(target-&gt;top_field_first)
+            flag|=AVI_TOP_FIELD;
+        else
+            flag|=AVI_BOTTOM_FIELD;
+    }
+  return flag;
+}
+bool decoderFF::decodeHeaderOnly (void)
+{
+  if (codecId == CODEC_ID_H264)
+    _context-&gt;hurry_up = 4;
+  else
+    _context-&gt;hurry_up = 5;
+  printf (&quot;\n[lavc] Hurry up\n&quot;);
+  return 1;
+}
+bool decoderFF::decodeFull (void)
+{
+  _context-&gt;hurry_up = 0;
+  printf (&quot;\n[lavc] full decoding\n&quot;);
+  return 1;
+}
+
+/**
+    \fn flush
+    \brief empty internal buffer
+*/
+bool    decoderFF::flush(void)
+{
+    if(_context)
+        avcodec_flush_buffers(_context);
+    return true;
+}
+/**
+    \fn uncompress
+    \brief Actually decode an image
+*/
+bool   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+  int got_picture = 0;
+  uint8_t *oBuff[3];
+  int strideTab[3];
+  int strideTab2[3];
+  int ret = 0;
+  out-&gt;_noPicture = 0;
+  if (_showMv)
+    {
+      _context-&gt;debug_mv |= FF_SHOW;
+      _context-&gt;debug |= 0;	//FF_DEBUG_VIS_MB_TYPE;
+    }
+  else
+    {
+      _context-&gt;debug_mv &amp;= ~FF_SHOW;
+      _context-&gt;debug &amp;= ~(FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP);
+    }
+
+   
+    
+  if (in-&gt;dataLength == 0 &amp;&amp; !_allowNull)	// Null frame, silently skipped
+    {
+      
+      printf (&quot;[Codec] null frame\n&quot;);
+        // search the last image
+        if (_context-&gt;coded_frame &amp;&amp; 
+            _context-&gt;coded_frame-&gt;data &amp;&amp;
+            _context-&gt;coded_frame-&gt;data[0]
+            )
+          {
+            printf(&quot;[Codec] Cloning older pic\n&quot;);
+            clonePic (_context-&gt;coded_frame, out);
+            out-&gt;Pts=ADM_COMPRESSED_NO_PTS;
+          }
+        else
+            {
+                out-&gt;_noPicture = 1;
+                out-&gt;Pts=ADM_COMPRESSED_NO_PTS;
+                printf(&quot;[Codec] No Picture\n&quot;);
+            }
+          return 1;
+    }
+   // Put a safe value....
+   out-&gt;Pts=in-&gt;demuxerPts;
+    _context-&gt;reordered_opaque=in-&gt;demuxerPts;
+  //_frame.opaque=(void *)out-&gt;Pts;
+  //printf(&quot;Incoming Pts :%&quot;LLD&quot;\n&quot;,out-&gt;Pts);
+  AVPacket pkt;
+  av_init_packet(&amp;pkt);
+  pkt.data=in-&gt;data;
+  pkt.size=in-&gt;dataLength;
+  if(in-&gt;flags&amp;AVI_KEY_FRAME)
+    pkt.flags=AV_PKT_FLAG_KEY;
+  else
+    pkt.flags=0;
+  
+  ret = avcodec_decode_video2 (_context, &amp;_frame, &amp;got_picture, &amp;pkt);
+  if(!bFramePossible())
+  {
+    // No delay, the value is sure, no need to hide it in opaque
+    _context-&gt;reordered_opaque=(int64_t)in-&gt;demuxerPts;
+  }
+  out-&gt;_qStride = 0;		//Default = no quant
+  if (0 &gt; ret &amp;&amp; !_context-&gt;hurry_up)
+    {
+      printf (&quot;\n[lavc] error in lavcodec decoder!\n&quot;);
+      printf (&quot;[lavc] Err: %d, size :%d\n&quot;, ret, in-&gt;dataLength);
+      return 0;
+    }
+  if (!got_picture &amp;&amp; !_context-&gt;hurry_up)
+    {
+      // Some encoder code a vop header with the 
+      // vop flag set to 0
+      // it is meant to mean frame skipped but very dubious
+      if (in-&gt;dataLength &lt;= 8 &amp;&amp; codecId == CODEC_ID_MPEG4)
+	{
+	  printf (&quot;[lavc] Probably pseudo black frame...\n&quot;);
+	  out-&gt;_Qp = 2;
+	  out-&gt;flags = 0;	// assume P ?
+
+	  clonePic (_context-&gt;coded_frame, out);
+	  return 1;
+	}
+      // allow null means we allow null frame in and so potentially
+      // have no frame out for a time
+      // in that case silently fill with black and returns it as KF
+      if (_allowNull)
+	{
+	  out-&gt;flags = AVI_KEY_FRAME;
+	  if (!_refCopy)
+	    {
+            out-&gt;blacken();
+	    }
+	  else
+	    {
+	      out-&gt;_noPicture = 1;
+	    }
+	  printf (&quot;\n[lavc] ignoring got pict ==0\n&quot;);
+	  return 1;
+
+	}
+#if 0
+      printf (&quot;[lavc] Err: %d, size: %d\n&quot;, ret, in-&gt;dataLength);
+      printf (&quot;\n[lavc] error in FFMP43/mpeg4!: got picture\n&quot;);
+#endif
+      //GUI_Alert(&quot;Please retry with misc-&gt;Turbo off&quot;);
+      //return 1;
+      return 0;
+    }
+  if (_context-&gt;hurry_up)
+    {
+      out-&gt;flags = frameType ();
+      return 1;
+    }
+  // We have an image....
+  switch (_context-&gt;pix_fmt)
+    {
+    case PIX_FMT_YUV411P:
+      out-&gt;_colorspace = ADM_COLOR_YUV411;
+      break;
+    case PIX_FMT_YUYV422:
+      out-&gt;_colorspace = ADM_COLOR_YUV422;
+      break;
+    case PIX_FMT_YUV422P:
+    case PIX_FMT_YUVJ422P:
+      out-&gt;_colorspace = ADM_COLOR_YUV422P;
+      break;
+    case PIX_FMT_YUV444P:
+    case PIX_FMT_YUVJ444P:
+      out-&gt;_colorspace = ADM_COLOR_YUV444;
+      break;
+    case PIX_FMT_YUV420P:
+    case PIX_FMT_YUVJ420P:
+    case PIX_FMT_YUVA420P:
+      // Default is YV12 or I420
+      // In that case depending on swap u/v
+      // we do it or not
+      out-&gt;_colorspace = ADM_COLOR_YV12;
+      break;
+	case PIX_FMT_RGB24:
+	  out-&gt;_colorspace = ADM_COLOR_BGR24;
+	  break;
+    case PIX_FMT_BGRA:
+      out-&gt;_colorspace = ADM_COLOR_BGR32A;
+      break;
+    case PIX_FMT_RGBA: // ???PIX_FMT_RGBA32:
+      out-&gt;_colorspace = ADM_COLOR_RGB32A;
+      break;
+    case PIX_FMT_RGB555:
+      out-&gt;_colorspace = ADM_COLOR_RGB555;
+      break;
+    case PIX_FMT_VDPAU_MPEG1:
+    case PIX_FMT_VDPAU_MPEG2:
+    case PIX_FMT_VDPAU_WMV3:
+    case PIX_FMT_VDPAU_VC1:
+    case PIX_FMT_VDPAU_H264:
+        out-&gt;_colorspace=ADM_COLOR_VDPAU;
+        break;
+    default:
+      printf (&quot;[lavc] Unhandled colorspace: %d\n&quot;, _context-&gt;pix_fmt);
+      return 0;
+    }
+    clonePic (&amp;_frame, out);
+    //printf(&quot;[AvCodec] Pts : %llu Out Pts:%llu \n&quot;,_frame.pts,out-&gt;Pts);
+
+  return 1;
+}
+// *******************************************************************
+// *******************************************************************
+// *******************************************************************
+
+decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  _refCopy = 1;			// YUV420 only
+  WRAP_Open (CODEC_ID_MSMPEG4V3);
+}
+
+decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+// force low delay as avidemux don't handle B-frames
+  ADM_info (&quot;[lavc] Using %d bytes of extradata for MPEG4 decoder\n&quot;, (int)extraDataLen);
+  
+  _refCopy = 1;			// YUV420 only
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int)extraDataLen  ;
+  _context-&gt;codec_tag=fcc;
+  _context-&gt;stream_codec_tag=fcc;
+  decoderMultiThread ();
+  //  _context-&gt;flags|=FF_DEBUG_VIS_MV;
+  WRAP_Open (CODEC_ID_MPEG4);
+}
+bool decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+    // For pseudo startcode
+    if(in-&gt;dataLength)
+    {
+        in-&gt;data[in-&gt;dataLength]=0;
+        in-&gt;data[in-&gt;dataLength+1]=0;
+    }
+    return decoderFF::uncompress(in,out);
+
+}
+//************************************
+decoderFFDV::decoderFFDV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
+  WRAP_Open (CODEC_ID_DVVIDEO);
+
+}
+decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+                decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  _refCopy = 1;			// YUV420 only
+  decoderMultiThread ();
+  WRAP_Open (CODEC_ID_MPEG2VIDEO);
+}
+
+decoderFFPng::decoderFFPng(uint32_t w, uint32_t h, uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData, uint32_t bpp) : decoderFF(w, h, fcc, extraDataLen, extraData, bpp)
+{
+	WRAP_Open (CODEC_ID_PNG);
+}
+
+decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
+  _context-&gt;bits_per_coded_sample=bpp;
+  ADM_info (&quot;[lavc] FFhuff: We have %d bytes of extra data\n&quot;, (int)extraDataLen);
+  WRAP_Open (CODEC_ID_FFVHUFF);
+
+}
+decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+        :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+
+  _refCopy = 1;			// YUV420 only
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
+  decoderMultiThread ();
+  ADM_info (&quot;[lavc] Initializing H264 decoder with %d extradata\n&quot;, (int)extraDataLen);
+  WRAP_Open(CODEC_ID_H264);
+}
+//*********************
+extern &quot;C&quot; {int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc);}
+/**
+    \fn uncompress
+*/
+bool   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+  if(!_context-&gt;hurry_up) return decoderFF::uncompress (in, out);
+    ADM_assert(0);
+#if 0  
+  uint32_t nalSize, isAvc;
+  av_getAVCStreamInfo(_context,&amp;nalSize,&amp;isAvc);
+  if(isAvc)
+  {
+      return extractH264FrameType(nalSize, in-&gt;data,in-&gt;dataLength,&amp;(out-&gt;flags));
+  }else
+  {
+    return extractH264FrameType_startCode(nalSize, in-&gt;data,in-&gt;dataLength,&amp;(out-&gt;flags));
+  }
+#endif
+}
+//*********************
+decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
+  _context-&gt;bits_per_coded_sample = bpp;
+  WRAP_Open (CODEC_ID_HUFFYUV);
+}
+
+//***************
+extern uint8_t  lavformat_init(void);
+extern void     avcodec_init(void );
+extern  void    avcodec_register_all(void );
+extern &quot;C&quot;
+{
+  void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list);
+}
+/**
+    \fn ADM_lavInit
+    \brief Init both lavcodec and lavformat
+*/
+void ADM_lavInit(void)
+{
+    avcodec_init();
+    avcodec_register_all();
+//BAZOOKA    lavformat_init();
+    av_log_set_callback(adm_lavLogCallback);
+#ifdef ADM_DEBUG
+  //  av_log_set_level(AV_LOG_DEBUG);
+#endif
+
+}
+void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list)
+{
+   // if(level&gt;1) return;
+    char buf[256];
+  
+    vsnprintf(buf, sizeof(buf), fmt, list);
+    if(level&lt;=AV_LOG_INFO)
+        ADM_info(&quot;[lavc] %s&quot;,buf);
+}
+
+void ADM_lavDestroy(void)
+{
+	//av_free_static();
+}
+
+// EOF


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003878.html">[Avidemux-svn-commit] r6696 -	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Srt
</A></li>
	<LI>Next message: <A HREF="003880.html">[Avidemux-svn-commit] r6698 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3879">[ date ]</a>
              <a href="thread.html#3879">[ thread ]</a>
              <a href="subject.html#3879">[ subject ]</a>
              <a href="author.html#3879">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
