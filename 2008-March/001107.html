<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3843 - in	branches/avidemux_2.5_branch_mean/avidemux: ADM_audiocodec	ADM_libraries ADM_libraries/ADM_liba52	plugins/ADM_audiodecoder plugins/ADM_audiodecoder/ADM_ad_ac3	plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52	plugins/ADM_audiodecoder/ADM_ad_mad
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3843%20-%20in%0A%09branches/avidemux_2.5_branch_mean/avidemux%3A%20ADM_audiocodec%0A%09ADM_libraries%20ADM_libraries/ADM_liba52%0A%09plugins/ADM_audiodecoder%20plugins/ADM_audiodecoder/ADM_ad_ac3%0A%09plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52%0A%09plugins/ADM_audiodecoder/ADM_ad_mad&In-Reply-To=%3C200803071834.m27IYFW1000411%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001106.html">
   <LINK REL="Next"  HREF="001108.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3843 - in	branches/avidemux_2.5_branch_mean/avidemux: ADM_audiocodec	ADM_libraries ADM_libraries/ADM_liba52	plugins/ADM_audiodecoder plugins/ADM_audiodecoder/ADM_ad_ac3	plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52	plugins/ADM_audiodecoder/ADM_ad_mad</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3843%20-%20in%0A%09branches/avidemux_2.5_branch_mean/avidemux%3A%20ADM_audiocodec%0A%09ADM_libraries%20ADM_libraries/ADM_liba52%0A%09plugins/ADM_audiodecoder%20plugins/ADM_audiodecoder/ADM_ad_ac3%0A%09plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52%0A%09plugins/ADM_audiodecoder/ADM_ad_mad&In-Reply-To=%3C200803071834.m27IYFW1000411%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3843 - in	branches/avidemux_2.5_branch_mean/avidemux: ADM_audiocodec	ADM_libraries ADM_libraries/ADM_liba52	plugins/ADM_audiodecoder plugins/ADM_audiodecoder/ADM_ad_ac3	plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52	plugins/ADM_audiodecoder/ADM_ad_mad">mean at mail.berlios.de
       </A><BR>
    <I>Fri Mar  7 19:34:15 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001106.html">[Avidemux-svn-commit] r3842 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_libraries/ADM_mplex ADM_osSupport
</A></li>
        <LI>Next message: <A HREF="001108.html">[Avidemux-svn-commit] r3844 - in	branches/avidemux_2.5_branch_mean/avidemux: ADM_audiocodec	plugins/ADM_audiodecoder plugins/ADM_audiodecoder/ADM_ad_faad	plugins/ADM_audiodecoder/ADM_ad_vorbis
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1107">[ date ]</a>
              <a href="thread.html#1107">[ thread ]</a>
              <a href="subject.html#1107">[ subject ]</a>
              <a href="author.html#1107">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-03-07 19:34:14 +0100 (Fri, 07 Mar 2008)
New Revision: 3843

Added:
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_ad_a52.cpp
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/CMakeLists.txt
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/Makefile.am
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/a52.h
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/a52_internal.h
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/attributes.h
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/bit_allocate.c
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/bitstream.c
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/bitstream.h
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/downmix.c
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/imdct.c
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/mm_accel.h
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/parse.c
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/tables.h
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/CMakeLists.txt
Removed:
   branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_codecac3.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/CMakeLists.txt
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/Makefile.am
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52.h
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52_internal.h
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/attributes.h
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bit_allocate.c
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.c
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.h
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/downmix.c
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/imdct.c
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/mm_accel.h
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/parse.c
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/tables.h
Modified:
   branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_ad_plugin.h
   branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_audiocodec.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_audiocodec.h
   branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_pluginLoad.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/CMakeLists.txt
   branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/CMakeLists.txt
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_mad/ADM_ad_mad.cpp
   branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/CMakeLists.txt
Log:
[Audio plugin] Cleanup + also do ac3


Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_ad_plugin.h
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_ad_plugin.h	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_ad_plugin.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -19,6 +19,42 @@
 typedef uint32_t         (ADM_ad_GetApiVersion)(void);
 typedef bool            (ADM_ad_GetDecoderVersion)(uint32_t *major, uint32_t *minor, uint32_t *patch);
 typedef const char       *(ADM_ADM_ad_GetInfo)(void);
-/* */
 
+/* handly macro to declare plugins*/
+
+#define DECLARE_AUDIO_DECODER(Class,Major,Minor,Patch,Formats,Desc) \
+	extern &quot;C&quot; { \
+	ADM_Audiocodec *create(uint32_t fourcc,	WAVHeader *info,uint32_t extraLength,uint8_t *extraData)\
+	{ \
+		return new Class(fourcc,	info,extraLength,extraData);\
+	} \
+	ADM_Audiocodec *destroy(ADM_Audiocodec *codec) \
+	{ \
+		Class *a=(Class *)codec;\
+		delete a;\
+	}\
+	bool supportedFormat(uint32_t audioFourcc) \
+	{ \
+		for(int i=0;i&lt;sizeof(Formats)/sizeof(uint32_t);i++)\
+			if(Formats[i]==audioFourcc) \
+				return true; \
+		return false; \
+	} \
+	uint32_t getApiVersion(void)\
+	{\
+			return AD_API_VERSION;\
+	}\
+	bool getDecoderVersion(uint32_t *major,uint32_t *minor, uint32_t *patch)\
+	{\
+		*major=Major;\
+		*minor=Minor;\
+		*patch=Patch;\
+		return true;\
+	}\
+	const char *getInfo(void)\
+	{\
+		return Desc; \
+	}\
+	}
+
 #endif

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_audiocodec.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_audiocodec.cpp	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_audiocodec.cpp	2008-03-07 18:34:14 UTC (rev 3843)
@@ -92,13 +92,6 @@
 					out= (ADM_Audiocodec *)new ADM_AudiocodecWav(fourcc);
 #endif					
                   		break;
-#ifdef USE_AC3
-				case WAV_AC3:
-        				printf(&quot;\n Audio codec:  AC3\n&quot;);
-
-					out= (ADM_Audiocodec *) new ADM_AudiocodecAC3(fourcc, info);
-                  break;
-#endif
 #ifdef USE_LIBDCA
                 case WAV_DTS:
 					if (dca-&gt;isAvailable())
@@ -109,16 +102,6 @@
 
 					break;
 #endif
-#if 0
-#ifdef USE_MP3
-				case WAV_MP3:
-				case WAV_MP2:
-        				printf(&quot;\n Audio codec:  MP2-3\n&quot;);
-
-					out= (ADM_Audiocodec *) new ADM_AudiocodecMP3(fourcc);
-                  break;
-#endif
-#endif
 #ifdef USE_VORBIS
 				case WAV_OGG:
 						printf(&quot;\n Ogg/Vorbis \n&quot;);

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_audiocodec.h
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_audiocodec.h	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_audiocodec.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -74,27 +74,7 @@
 		uint8_t isDecompressable(void) {return 0;}
 };
 
-#ifdef USE_AC3
-#define ADM_AC3_BUFFER (50000*2)
-class ADM_AudiocodecAC3 : public     ADM_Audiocodec
-{
-	protected:
-		void *ac3_handle;
-		void *ac3_sample;
-		uint32_t _downmix;
 
-	public:
-		ADM_AudiocodecAC3(uint32_t fourcc, WAVHeader *info);
-		virtual	~ADM_AudiocodecAC3();
-		virtual	uint8_t beginDecompress(void);
-		virtual	uint8_t endDecompress(void);
-		virtual	uint8_t run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut);
-		virtual	uint8_t isCompressed(void) {return 1;}
-		virtual	uint8_t isDecompressable(void) {return 1;}
-
-   };
-#endif
-
 #ifdef USE_LIBDCA
 class ADM_AudiocodecDCA : public     ADM_Audiocodec
 {

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_codecac3.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_codecac3.cpp	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_codecac3.cpp	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,204 +0,0 @@
-/***************************************************************************
-                          ADM_codecac3.cpp  -  description
-                             -------------------
-    begin                : Fri May 31 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-#include &lt;math.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;ADM_audio/aviaudio.hxx&quot;
-#include &quot;ADM_audiocodec/ADM_audiocodec.h&quot;
-#include &quot;ADM_audiofilter/audiofilter_channel_route.h&quot;
-
-#include &quot;prefs.h&quot;
-
-#ifdef USE_AC3
-extern &quot;C&quot; {
-#include &quot;ADM_liba52/a52.h&quot;
-#include &quot;ADM_liba52/mm_accel.h&quot;
-};
-
-#define AC3_HANDLE ((a52_state_t *)ac3_handle)
-
-ADM_AudiocodecAC3::ADM_AudiocodecAC3( uint32_t fourcc, WAVHeader *info) :   ADM_Audiocodec(fourcc)
-{
-    int flags=0;
-    ADM_assert(fourcc==WAV_AC3);
-    ac3_handle=NULL;
-    ac3_sample=NULL;
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-#define CHK(x,y) if(CpuCaps::has##x()) flags|=MM_ACCEL_X86_##y;
-    CHK(MMX,MMX);
-    CHK(3DNOW,3DNOW);
-    CHK(MMXEXT,MMXEXT);
-#endif
-    
-    ac3_handle=(void *)a52_init(flags);
-    if(!ac3_handle)
-    {
-        printf(&quot;Cannot init a52\n&quot;);
-        ADM_assert(0);   
-    }
-    ac3_sample=(sample_t *)a52_samples(AC3_HANDLE);
-    if(!ac3_sample)
-    {
-        printf(&quot;Cannot init a52 sample\n&quot;);
-        ADM_assert(0);   
-    }
-        _downmix=0;
-      _wavHeader = info;
-      ADM_assert(_wavHeader);
-}
-
-ADM_AudiocodecAC3::~ADM_AudiocodecAC3( )
-{
-    if(ac3_handle)
-    {
-        a52_free(AC3_HANDLE);
-        ac3_handle=NULL;
-        ac3_sample=NULL;
-    }
-}
-
-uint8_t ADM_AudiocodecAC3::beginDecompress( void )
-{
-		return 1;
-}
-
-uint8_t ADM_AudiocodecAC3::endDecompress( void )
-{
-    return 1;
-}
-
-uint8_t ADM_AudiocodecAC3::run(uint8_t *inptr, uint32_t nbIn, float *outptr,   uint32_t *nbOut)
-{
-    uint32_t avail;
-    uint32_t length;
-    int flags = 0, samprate = 0, bitrate = 0;
-    uint8_t chan = _wavHeader-&gt;channels;
-    *nbOut=0;
-
-    //  Ready to decode
-    while(nbIn)
-    {
-        if(nbIn&lt;7)
-        {
-            if(nbIn)
-                printf(&quot;[a52]: no data to decode avail %u\n&quot;,nbIn);
-            break;
-        }
-        length = a52_syncinfo(inptr, &amp;flags, &amp;samprate, &amp;bitrate);
-        if(length==0)
-        {
-            printf(&quot;[a52] No startcode found\n&quot;);
-            break;
-        }
-        if(length&gt;nbIn)
-        {
-            // not enough data
-            break;
-        }
-
-	if (ch_route.mode &lt; 1) {
-		CHANNEL_TYPE *p_ch_type = ch_route.input_type;
-		if (flags &amp; A52_LFE) {
-			*(p_ch_type++) = CH_LFE;
-		}
-		switch (flags &amp; A52_CHANNEL_MASK) {
-			case A52_MONO:
-				*(p_ch_type++) = CH_MONO;
-			break;
-			case A52_STEREO:
-			case A52_DOLBY:
-				*(p_ch_type++) = CH_FRONT_LEFT;
-				*(p_ch_type++) = CH_FRONT_RIGHT;
-			break;
-			case A52_3F:
-				*(p_ch_type++) = CH_FRONT_LEFT;
-				*(p_ch_type++) = CH_FRONT_CENTER;
-				*(p_ch_type++) = CH_FRONT_RIGHT;
-			break;
-			case A52_2F1R:
-				*(p_ch_type++) = CH_FRONT_LEFT;
-				*(p_ch_type++) = CH_FRONT_RIGHT;
-				*(p_ch_type++) = CH_REAR_CENTER;
-			break;
-			case A52_3F1R:
-				*(p_ch_type++) = CH_FRONT_LEFT;
-				*(p_ch_type++) = CH_FRONT_CENTER;
-				*(p_ch_type++) = CH_FRONT_RIGHT;
-				*(p_ch_type++) = CH_REAR_CENTER;
-			break;
-			case A52_2F2R:
-				*(p_ch_type++) = CH_FRONT_LEFT;
-				*(p_ch_type++) = CH_FRONT_RIGHT;
-				*(p_ch_type++) = CH_REAR_LEFT;
-				*(p_ch_type++) = CH_REAR_RIGHT;
-			break;
-			case A52_3F2R:
-				*(p_ch_type++) = CH_FRONT_LEFT;
-				*(p_ch_type++) = CH_FRONT_CENTER;
-				*(p_ch_type++) = CH_FRONT_RIGHT;
-				*(p_ch_type++) = CH_REAR_LEFT;
-				*(p_ch_type++) = CH_REAR_RIGHT;
-			break;
-			default:
-				ADM_assert(0);
-		}
-	}
-
-        sample_t level = 1, bias = 0;
-
-        if (a52_frame(AC3_HANDLE, inptr, &amp;flags, &amp;level, bias))
-        {
-            printf(&quot;\n A52_frame failed!&quot;);
-            inptr+=length;
-            nbIn-=length;
-            *nbOut += 256 * chan * 6;
-            break;
-        };
-        inptr+=length;
-        nbIn-=length;
-        *nbOut += 256 * chan * 6;
-
-        float *cur;
-        for (int i = 0; i &lt; 6; i++) {
-                if (a52_block(AC3_HANDLE)) {
-                        printf(&quot;\n A52_block failed! on fblock :%lu&quot;, i);
-                        // in that case we silent out the chunk
-                        memset(outptr, 0, 256 * chan * sizeof(float));
-                } else {
-                        for (int k = 0; k &lt; chan; k++) {
-                                sample_t *sample=(sample_t *)ac3_sample;
-                                sample += 256 * k;
-                                cur = outptr + k;
-                                for (int j = 0; j &lt; 256; j++) {
-                                        *cur = *sample++;
-                                        cur+=chan;
-                                }
-                        }
-                }
-                outptr += chan * 256;
-        }
-    }
-    return 1; 
-
-}
-
-#endif

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_pluginLoad.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_pluginLoad.cpp	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_pluginLoad.cpp	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,6 +1,11 @@
 /**
         \file ADM_pluginLoad.cpp
         \brief Interface for dynamically loaded audio decoder
+        
+        There are 2 known problem here
+        1: The destructor is called instead of calling destroy in the class factory
+        2: Memory leak, ADM_audioPlugins is not destroyed as of today
+        
 */
 
 
@@ -28,6 +33,7 @@
 	ADM_ad_GetApiVersion		*getApiVersion;
 	ADM_ad_GetDecoderVersion	*getDecoderVersion;
 	ADM_ADM_ad_GetInfo			*getInfo;
+	ADM_LibWrapper				*wrapper;
 };
 
 std::vector&lt;ADM_ad_plugin *&gt; ADM_audioPlugins;
@@ -64,6 +70,7 @@
 	 uint32_t major,minor,patch;
 	 const char *desc;
 	 blank.getDecoderVersion(&amp;major,&amp;minor,&amp;patch);
+	 blank.wrapper=wrapper;
 	 desc=blank.getInfo();
 	 // Print out stuff
 	 printf(&quot;[ADM_ad_plugin] Plugin loaded version %d.%d.%d, desc : %s\n&quot;,major,minor,patch,desc);
@@ -87,7 +94,7 @@
 uint8_t ADM_ad_loadPlugins(void)
 {
 #define MAX_EXTERNAL_FILTER 50
-	  char *path=&quot;/home/fx/workspace/avidemux_git/avidemux_2.5_branch_mean/Build/avidemux/plugins/ADM_audiodecoder/ADM_ad_mad&quot;;
+	  char *path=&quot;/home/fx/ADM_plugins&quot;;
 	  char *files[MAX_EXTERNAL_FILTER];
 	  uint32_t nbFile;
 	  

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/CMakeLists.txt	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/CMakeLists.txt	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,5 +1,5 @@
 
-SET(ADM_audiocodec_SRCS ADM_8bits.cpp       ADM_codecac3.cpp   
+SET(ADM_audiocodec_SRCS ADM_8bits.cpp          
 ADM_codecimaadpcm.cpp  
 ADM_codecmsadpcm.cpp  
 ADM_codeculaw.cpp  ADM_codecwma.cpp  ADM_lpcm.cpp

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/CMakeLists.txt	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/CMakeLists.txt	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,14 +0,0 @@
-################################
-#
-################################
-include(AdmLib)
-SET(ADM_LIB ADM_liba52)
-#
-SET(${ADM_LIB}_SRCS 
-bit_allocate.c  bitstream.c  downmix.c  imdct.c  parse.c
-)
-ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
-ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
-
-
-################################

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/Makefile.am
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/Makefile.am	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/Makefile.am	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,10 +0,0 @@
-noinst_LIBRARIES = libADM_liba52.a
-
-INCLUDES = $(all_includes) 
-
-libADM_liba52_a_METASOURCES = AUTO
-
-libADM_liba52_a_SOURCES = bitstream.c imdct.c bit_allocate.c parse.c downmix.c
-
-EXTRA_DIST = a52.h  a52_internal.h  attributes.h  bitstream.h  mm_accel.h  tables.h bit_allocate.c  bitstream.c  downmix.c  imdct.c  parse.c
-

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52.h
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52.h	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,62 +0,0 @@
-/*
- * a52.h
- * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
- * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
- *
- * This file is part of a52dec, a free ATSC A-52 stream decoder.
- * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
- *
- * a52dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * a52dec is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef A52_H
-#define A52_H
-
-#ifndef LIBA52_DOUBLE
-typedef float sample_t;
-#else
-typedef double sample_t;
-#endif
-
-typedef struct a52_state_s a52_state_t;
-
-#define A52_CHANNEL 0
-#define A52_MONO 1
-#define A52_STEREO 2
-#define A52_3F 3
-#define A52_2F1R 4
-#define A52_3F1R 5
-#define A52_2F2R 6
-#define A52_3F2R 7
-#define A52_CHANNEL1 8
-#define A52_CHANNEL2 9
-#define A52_DOLBY 10
-#define A52_CHANNEL_MASK 15
-
-#define A52_LFE 16
-#define A52_ADJUST_LEVEL 32
-
-a52_state_t * a52_init (uint32_t mm_accel);
-sample_t * a52_samples (a52_state_t * state);
-int a52_syncinfo (uint8_t * buf, int * flags,
-		  int * sample_rate, int * bit_rate);
-int a52_frame (a52_state_t * state, uint8_t * buf, int * flags,
-	       sample_t * level, sample_t bias);
-void a52_dynrng (a52_state_t * state,
-		 sample_t (* call) (sample_t, void *), void * data);
-int a52_block (a52_state_t * state);
-void a52_free (a52_state_t * state);
-
-#endif /* A52_H */

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52_internal.h
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52_internal.h	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52_internal.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,123 +0,0 @@
-/*
- * a52_internal.h
- * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
- * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
- *
- * This file is part of a52dec, a free ATSC A-52 stream decoder.
- * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
- *
- * a52dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * a52dec is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-typedef struct {
-    uint8_t bai;		/* fine SNR offset, fast gain */
-    uint8_t deltbae;		/* delta bit allocation exists */
-    int8_t deltba[50];		/* per-band delta bit allocation */
-} ba_t;
-
-typedef struct {
-    uint8_t exp[256];		/* decoded channel exponents */
-    int8_t bap[256];		/* derived channel bit allocation */
-} expbap_t;
-
-struct a52_state_s {
-    uint8_t fscod;		/* sample rate */
-    uint8_t halfrate;		/* halfrate factor */
-    uint8_t acmod;		/* coded channels */
-    uint8_t lfeon;		/* coded lfe channel */
-    sample_t clev;		/* centre channel mix level */
-    sample_t slev;		/* surround channels mix level */
-
-    int output;			/* type of output */
-    sample_t level;		/* output level */
-    sample_t bias;		/* output bias */
-
-    int dynrnge;		/* apply dynamic range */
-    sample_t dynrng;		/* dynamic range */
-    void * dynrngdata;		/* dynamic range callback funtion and data */
-    sample_t (* dynrngcall) (sample_t range, void * dynrngdata);
-
-    uint8_t chincpl;		/* channel coupled */
-    uint8_t phsflginu;		/* phase flags in use (stereo only) */
-    uint8_t cplstrtmant;	/* coupling channel start mantissa */
-    uint8_t cplendmant;		/* coupling channel end mantissa */
-    uint32_t cplbndstrc;	/* coupling band structure */
-    sample_t cplco[5][18];	/* coupling coordinates */
-
-    /* derived information */
-    uint8_t cplstrtbnd;		/* coupling start band (for bit allocation) */
-    uint8_t ncplbnd;		/* number of coupling bands */
-
-    uint8_t rematflg;		/* stereo rematrixing */
-
-    uint8_t endmant[5];		/* channel end mantissa */
-
-    uint16_t bai;		/* bit allocation information */
-
-    uint32_t * buffer_start;
-    uint16_t lfsr_state;	/* dither state */
-    uint32_t bits_left;
-    uint32_t current_word;
-
-    uint8_t csnroffst;		/* coarse SNR offset */
-    ba_t cplba;			/* coupling bit allocation parameters */
-    ba_t ba[5];			/* channel bit allocation parameters */
-    ba_t lfeba;			/* lfe bit allocation parameters */
-
-    uint8_t cplfleak;		/* coupling fast leak init */
-    uint8_t cplsleak;		/* coupling slow leak init */
-
-    expbap_t cpl_expbap;
-    expbap_t fbw_expbap[5];
-    expbap_t lfe_expbap;
-
-    sample_t * samples;
-    int downmixed;
-};
-
-#define LEVEL_PLUS6DB 2.0
-#define LEVEL_PLUS3DB 1.4142135623730951
-#define LEVEL_3DB 0.7071067811865476
-#define LEVEL_45DB 0.5946035575013605
-#define LEVEL_6DB 0.5
-
-#define LEVEL_DPL2_1 0.8165
-#define LEVEL_DPL2_2 0.5774
-
-#define EXP_REUSE (0)
-#define EXP_D15   (1)
-#define EXP_D25   (2)
-#define EXP_D45   (3)
-
-#define DELTA_BIT_REUSE (0)
-#define DELTA_BIT_NEW (1)
-#define DELTA_BIT_NONE (2)
-#define DELTA_BIT_RESERVED (3)
-
-void a52_bit_allocate (a52_state_t * state, ba_t * ba, int bndstart,
-		       int start, int end, int fastleak, int slowleak,
-		       expbap_t * expbap);
-
-int a52_downmix_init (int input, int flags, sample_t * level,
-		      sample_t clev, sample_t slev);
-int a52_downmix_coeff (sample_t * coeff, int acmod, int output, sample_t level,
-		       sample_t clev, sample_t slev);
-void a52_downmix (sample_t * samples, int acmod, int output, sample_t bias,
-		  sample_t clev, sample_t slev);
-void a52_upmix (sample_t * samples, int acmod, int output);
-
-void a52_imdct_init (uint32_t mm_accel);
-void a52_imdct_256 (sample_t * data, sample_t * delay, sample_t bias);
-void a52_imdct_512 (sample_t * data, sample_t * delay, sample_t bias);

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/attributes.h
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/attributes.h	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/attributes.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,29 +0,0 @@
-/*
- * attributes.h
- * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
- * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
- *
- * This file is part of a52dec, a free ATSC A-52 stream decoder.
- * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
- *
- * a52dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * a52dec is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/* use gcc attribs to align critical data structures */
-#ifdef ATTRIBUTE_ALIGNED_MAX
-#define ATTR_ALIGN(align) __attribute__ ((__aligned__ ((ATTRIBUTE_ALIGNED_MAX &lt; align) ? ATTRIBUTE_ALIGNED_MAX : align)))
-#else
-#define ATTR_ALIGN(align)
-#endif

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bit_allocate.c
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bit_allocate.c	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bit_allocate.c	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,265 +0,0 @@
-/*
- * bit_allocate.c
- * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
- * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
- *
- * This file is part of a52dec, a free ATSC A-52 stream decoder.
- * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
- *
- * a52dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * a52dec is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include &quot;config.h&quot;
-
-#include &lt;inttypes.h&gt;
-
-#include &quot;a52.h&quot;
-#include &quot;a52_internal.h&quot;
-
-static int hthtab[3][50] = {
-    {0x730, 0x730, 0x7c0, 0x800, 0x820, 0x840, 0x850, 0x850, 0x860, 0x860,
-     0x860, 0x860, 0x860, 0x870, 0x870, 0x870, 0x880, 0x880, 0x890, 0x890,
-     0x8a0, 0x8a0, 0x8b0, 0x8b0, 0x8c0, 0x8c0, 0x8d0, 0x8e0, 0x8f0, 0x900,
-     0x910, 0x910, 0x910, 0x910, 0x900, 0x8f0, 0x8c0, 0x870, 0x820, 0x7e0,
-     0x7a0, 0x770, 0x760, 0x7a0, 0x7c0, 0x7c0, 0x6e0, 0x400, 0x3c0, 0x3c0},
-    {0x710, 0x710, 0x7a0, 0x7f0, 0x820, 0x830, 0x840, 0x850, 0x850, 0x860,
-     0x860, 0x860, 0x860, 0x860, 0x870, 0x870, 0x870, 0x880, 0x880, 0x880,
-     0x890, 0x890, 0x8a0, 0x8a0, 0x8b0, 0x8b0, 0x8c0, 0x8c0, 0x8e0, 0x8f0,
-     0x900, 0x910, 0x910, 0x910, 0x910, 0x900, 0x8e0, 0x8b0, 0x870, 0x820,
-     0x7e0, 0x7b0, 0x760, 0x770, 0x7a0, 0x7c0, 0x780, 0x5d0, 0x3c0, 0x3c0},
-    {0x680, 0x680, 0x750, 0x7b0, 0x7e0, 0x810, 0x820, 0x830, 0x840, 0x850,
-     0x850, 0x850, 0x860, 0x860, 0x860, 0x860, 0x860, 0x860, 0x860, 0x860,
-     0x870, 0x870, 0x870, 0x870, 0x880, 0x880, 0x880, 0x890, 0x8a0, 0x8b0,
-     0x8c0, 0x8d0, 0x8e0, 0x8f0, 0x900, 0x910, 0x910, 0x910, 0x900, 0x8f0,
-     0x8d0, 0x8b0, 0x840, 0x7f0, 0x790, 0x760, 0x7a0, 0x7c0, 0x7b0, 0x720}
-};
-
-static int8_t baptab[305] = {
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,	/* 93 padding elems */
-
-    16, 16, 16, 16, 16, 16, 16, 16, 16, 14, 14, 14, 14, 14, 14, 14,
-    14, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10,  9,  9,  9,
-     9,  8,  8,  8,  8,  7,  7,  7,  7,  6,  6,  6,  6,  5,  5,  5,
-     5,  4,  4, -3, -3,  3,  3,  3, -2, -2, -1, -1, -1, -1, -1,  0,
-
-     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-     0,  0,  0,  0					/* 148 padding elems */
-};
-
-static int bndtab[30] = {21, 22,  23,  24,  25,  26,  27,  28,  31,  34,
-			 37, 40,  43,  46,  49,  55,  61,  67,  73,  79,
-			 85, 97, 109, 121, 133, 157, 181, 205, 229, 253};
-
-static int8_t latab[256] = {
-    -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53,
-    -52, -52, -51, -50, -49, -48, -47, -47, -46, -45, -44, -44,
-    -43, -42, -41, -41, -40, -39, -38, -38, -37, -36, -36, -35,
-    -35, -34, -33, -33, -32, -32, -31, -30, -30, -29, -29, -28,
-    -28, -27, -27, -26, -26, -25, -25, -24, -24, -23, -23, -22,
-    -22, -21, -21, -21, -20, -20, -19, -19, -19, -18, -18, -18,
-    -17, -17, -17, -16, -16, -16, -15, -15, -15, -14, -14, -14,
-    -13, -13, -13, -13, -12, -12, -12, -12, -11, -11, -11, -11,
-    -10, -10, -10, -10, -10,  -9,  -9,  -9,  -9,  -9,  -8,  -8,
-     -8,  -8,  -8,  -8,  -7,  -7,  -7,  -7,  -7,  -7,  -6,  -6,
-     -6,  -6,  -6,  -6,  -6,  -6,  -5,  -5,  -5,  -5,  -5,  -5,
-     -5,  -5,  -4,  -4,  -4,  -4,  -4,  -4,  -4,  -4,  -4,  -4,
-     -4,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,
-     -3,  -3,  -3,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,
-     -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -1,  -1,
-     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
-     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
-     -1,  -1,  -1,  -1,  -1,  -1,   0,   0,   0,   0,   0,   0,
-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
-      0,   0,   0,   0
-};
-
-#define UPDATE_LEAK() 		\
-do {				\
-    fastleak += fdecay;		\
-    if (fastleak &gt; psd + fgain)	\
-	fastleak = psd + fgain;	\
-    slowleak += sdecay;		\
-    if (slowleak &gt; psd + sgain)	\
-	slowleak = psd + sgain;	\
-} while (0)
-
-#define COMPUTE_MASK()				\
-do {						\
-    if (psd &gt; dbknee)				\
-	mask -= (psd - dbknee) &gt;&gt; 2;		\
-    if (mask &gt; hth [i &gt;&gt; halfrate])		\
-	mask = hth [i &gt;&gt; halfrate];		\
-    mask -= snroffset + 128 * deltba[i];	\
-    mask = (mask &gt; 0) ? 0 : ((-mask) &gt;&gt; 5);	\
-    mask -= floor;				\
-} while (0)
-
-void a52_bit_allocate (a52_state_t * state, ba_t * ba, int bndstart,
-		       int start, int end, int fastleak, int slowleak,
-		       expbap_t * expbap)
-{
-    static int slowgain[4] = {0x540, 0x4d8, 0x478, 0x410};
-    static int dbpbtab[4]  = {0xc00, 0x500, 0x300, 0x100};
-    static int floortab[8] = {0x910, 0x950, 0x990, 0x9d0,
-			      0xa10, 0xa90, 0xb10, 0x1400};
-
-    int i, j;
-    uint8_t * exp;
-    int8_t * bap;
-    int fdecay, fgain, sdecay, sgain, dbknee, floor, snroffset;
-    int psd, mask;
-    int8_t * deltba;
-    int * hth;
-    int halfrate;
-
-    halfrate = state-&gt;halfrate;
-    fdecay = (63 + 20 * ((state-&gt;bai &gt;&gt; 7) &amp; 3)) &gt;&gt; halfrate;	/* fdcycod */
-    fgain = 128 + 128 * (ba-&gt;bai &amp; 7);				/* fgaincod */
-    sdecay = (15 + 2 * (state-&gt;bai &gt;&gt; 9)) &gt;&gt; halfrate;		/* sdcycod */
-    sgain = slowgain[(state-&gt;bai &gt;&gt; 5) &amp; 3];			/* sgaincod */
-    dbknee = dbpbtab[(state-&gt;bai &gt;&gt; 3) &amp; 3];			/* dbpbcod */
-    hth = hthtab[state-&gt;fscod];
-    /*
-     * if there is no delta bit allocation, make deltba point to an area
-     * known to contain zeroes. baptab+156 here.
-     */
-    deltba = (ba-&gt;deltbae == DELTA_BIT_NONE) ? baptab + 156 : ba-&gt;deltba;
-    floor = floortab[state-&gt;bai &amp; 7];				/* floorcod */
-    snroffset = 960 - 64 * state-&gt;csnroffst - 4 * (ba-&gt;bai &gt;&gt; 3) + floor;
-    floor &gt;&gt;= 5;
-
-    exp = expbap-&gt;exp;
-    bap = expbap-&gt;bap;
-
-    i = bndstart;
-    j = start;
-    if (start == 0) {	/* not the coupling channel */
-	int lowcomp;
-
-	lowcomp = 0;
-	j = end - 1;
-	do {
-	    if (i &lt; j) {
-		if (exp[i+1] == exp[i] - 2)
-		    lowcomp = 384;
-		else if (lowcomp &amp;&amp; (exp[i+1] &gt; exp[i]))
-		    lowcomp -= 64;
-	    }
-	    psd = 128 * exp[i];
-	    mask = psd + fgain + lowcomp;
-	    COMPUTE_MASK ();
-	    bap[i] = (baptab+156)[mask + 4 * exp[i]];
-	    i++;
-	} while ((i &lt; 3) || ((i &lt; 7) &amp;&amp; (exp[i] &gt; exp[i-1])));
-	fastleak = psd + fgain;
-	slowleak = psd + sgain;
-
-	while (i &lt; 7) {
-	    if (i &lt; j) {
-		if (exp[i+1] == exp[i] - 2)
-		    lowcomp = 384;
-		else if (lowcomp &amp;&amp; (exp[i+1] &gt; exp[i]))
-		    lowcomp -= 64;
-	    }
-	    psd = 128 * exp[i];
-	    UPDATE_LEAK ();
-	    mask = ((fastleak + lowcomp &lt; slowleak) ?
-		    fastleak + lowcomp : slowleak);
-	    COMPUTE_MASK ();
-	    bap[i] = (baptab+156)[mask + 4 * exp[i]];
-	    i++;
-	}
-
-	if (end == 7)	/* lfe channel */
-	    return;
-
-	do {
-	    if (exp[i+1] == exp[i] - 2)
-		lowcomp = 320;
-	    else if (lowcomp &amp;&amp; (exp[i+1] &gt; exp[i]))
-		lowcomp -= 64;
-	    psd = 128 * exp[i];
-	    UPDATE_LEAK ();
-	    mask = ((fastleak + lowcomp &lt; slowleak) ?
-		    fastleak + lowcomp : slowleak);
-	    COMPUTE_MASK ();
-	    bap[i] = (baptab+156)[mask + 4 * exp[i]];
-	    i++;
-	} while (i &lt; 20);
-
-	while (lowcomp &gt; 128) {		/* two iterations maximum */
-	    lowcomp -= 128;
-	    psd = 128 * exp[i];
-	    UPDATE_LEAK ();
-	    mask = ((fastleak + lowcomp &lt; slowleak) ?
-		    fastleak + lowcomp : slowleak);
-	    COMPUTE_MASK ();
-	    bap[i] = (baptab+156)[mask + 4 * exp[i]];
-	    i++;
-	}
-	j = i;
-    }
-
-    do {
-	int startband, endband;
-
-	startband = j;
-	endband = ((bndtab-20)[i] &lt; end) ? (bndtab-20)[i] : end;
-	psd = 128 * exp[j++];
-	while (j &lt; endband) {
-	    int next, delta;
-
-	    next = 128 * exp[j++];
-	    delta = next - psd;
-	    switch (delta &gt;&gt; 9) {
-	    case -6: case -5: case -4: case -3: case -2:
-		psd = next;
-		break;
-	    case -1:
-		psd = next + latab[(-delta) &gt;&gt; 1];
-		break;
-	    case 0:
-		psd += latab[delta &gt;&gt; 1];
-		break;
-	    }
-	}
-	/* minpsd = -289 */
-	UPDATE_LEAK ();
-	mask = (fastleak &lt; slowleak) ? fastleak : slowleak;
-	COMPUTE_MASK ();
-	i++;
-	j = startband;
-	do {
-	    /* max(mask+4*exp)=147=-(minpsd+fgain-deltba-snroffset)&gt;&gt;5+4*exp */
-	    /* min(mask+4*exp)=-156=-(sgain-deltba-snroffset)&gt;&gt;5 */
-	    bap[j] = (baptab+156)[mask + 4 * exp[j]];
-	} while (++j &lt; endband);
-    } while (j &lt; end);
-}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.c
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.c	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.c	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,95 +0,0 @@
-/*
- * bitstream.c
- * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
- * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
- *
- * This file is part of a52dec, a free ATSC A-52 stream decoder.
- * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
- *
- * a52dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * a52dec is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include &quot;config.h&quot;
-
-#include &lt;inttypes.h&gt;
-
-#include &quot;a52.h&quot;
-#include &quot;a52_internal.h&quot;
-#include &quot;bitstream.h&quot;
-
-#define BUFFER_SIZE 4096
-
-void a52_bitstream_set_ptr (a52_state_t * state, uint8_t * buf)
-{
-    int align;
-
-    align = (long)buf &amp; 3;
-    state-&gt;buffer_start = (uint32_t *) (buf - align);
-    state-&gt;bits_left = 0;
-    bitstream_get (state, align * 8);
-}
-
-static inline void bitstream_fill_current (a52_state_t * state)
-{
-    uint32_t tmp;
-
-    tmp = *(state-&gt;buffer_start++);
-    state-&gt;current_word = swab32 (tmp);
-}
-
-/*
- * The fast paths for _get is in the
- * bitstream.h header file so it can be inlined.
- *
- * The &quot;bottom half&quot; of this routine is suffixed _bh
- *
- * -ah
- */
-
-uint32_t a52_bitstream_get_bh (a52_state_t * state, uint32_t num_bits)
-{
-    uint32_t result;
-
-    num_bits -= state-&gt;bits_left;
-    result = ((state-&gt;current_word &lt;&lt; (32 - state-&gt;bits_left)) &gt;&gt;
-	      (32 - state-&gt;bits_left));
-
-    bitstream_fill_current (state);
-
-    if (num_bits != 0)
-	result = (result &lt;&lt; num_bits) | (state-&gt;current_word &gt;&gt; (32 - num_bits));
-
-    state-&gt;bits_left = 32 - num_bits;
-
-    return result;
-}
-
-int32_t a52_bitstream_get_bh_2 (a52_state_t * state, uint32_t num_bits)
-{
-    int32_t result;
-
-    num_bits -= state-&gt;bits_left;
-    result = ((((int32_t)state-&gt;current_word) &lt;&lt; (32 - state-&gt;bits_left)) &gt;&gt;
-	      (32 - state-&gt;bits_left));
-
-    bitstream_fill_current(state);
-
-    if (num_bits != 0)
-	result = (result &lt;&lt; num_bits) | (state-&gt;current_word &gt;&gt; (32 - num_bits));
-	
-    state-&gt;bits_left = 32 - num_bits;
-
-    return result;
-}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.h
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.h	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,77 +0,0 @@
-/*
- * bitstream.h
- * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
- * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
- *
- * This file is part of a52dec, a free ATSC A-52 stream decoder.
- * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
- *
- * a52dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * a52dec is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/* (stolen from the kernel) */
-#ifdef WORDS_BIGENDIAN
-
-#	define swab32(x) (x)
-
-#else
-
-#	if 0 &amp;&amp; defined (__i386__)
-
-#	define swab32(x) __i386_swab32(x)
-	static inline const uint32_t __i386_swab32(uint32_t x)
-	{
-		__asm__(&quot;bswap %0&quot; : &quot;=r&quot; (x) : &quot;0&quot; (x));
-		return x;
-	}
-
-#	else
-
-#	define swab32(x)\
-((((uint8_t*)&amp;x)[0] &lt;&lt; 24) | (((uint8_t*)&amp;x)[1] &lt;&lt; 16) |  \
- (((uint8_t*)&amp;x)[2] &lt;&lt; 8)  | (((uint8_t*)&amp;x)[3]))
-
-#	endif
-#endif
-
-void a52_bitstream_set_ptr (a52_state_t * state, uint8_t * buf);
-uint32_t a52_bitstream_get_bh (a52_state_t * state, uint32_t num_bits);
-int32_t a52_bitstream_get_bh_2 (a52_state_t * state, uint32_t num_bits);
-
-static inline uint32_t bitstream_get (a52_state_t * state, uint32_t num_bits)
-{
-    uint32_t result;
-	
-    if (num_bits &lt; state-&gt;bits_left) {
-	result = (state-&gt;current_word &lt;&lt; (32 - state-&gt;bits_left)) &gt;&gt; (32 - num_bits);
-	state-&gt;bits_left -= num_bits;
-	return result;
-    }
-
-    return a52_bitstream_get_bh (state, num_bits);
-}
-
-static inline int32_t bitstream_get_2 (a52_state_t * state, uint32_t num_bits)
-{
-    int32_t result;
-	
-    if (num_bits &lt; state-&gt;bits_left) {
-	result = (((int32_t)state-&gt;current_word) &lt;&lt; (32 - state-&gt;bits_left)) &gt;&gt; (32 - num_bits);
-	state-&gt;bits_left -= num_bits;
-	return result;
-    }
-
-    return a52_bitstream_get_bh_2 (state, num_bits);
-}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/downmix.c
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/downmix.c	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/downmix.c	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,655 +0,0 @@
-/*
- * downmix.c
- * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
- * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
- *
- * This file is part of a52dec, a free ATSC A-52 stream decoder.
- * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
- *
- * a52dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * a52dec is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include &quot;config.h&quot;
-
-#include &lt;string.h&gt;
-#include &lt;inttypes.h&gt;
-
-#include &quot;a52.h&quot;
-#include &quot;a52_internal.h&quot;
-
-#define CONVERT(acmod,output) (((output) &lt;&lt; 3) + (acmod))
-
-int a52_downmix_init (int input, int flags, sample_t * level,
-		      sample_t clev, sample_t slev)
-{
-    static uint8_t table[11][8] = {
-	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_STEREO,
-	 A52_STEREO,	A52_STEREO,	A52_STEREO,	A52_STEREO},
-	{A52_MONO,	A52_MONO,	A52_MONO,	A52_MONO,
-	 A52_MONO,	A52_MONO,	A52_MONO,	A52_MONO},
-	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_STEREO,
-	 A52_STEREO,	A52_STEREO,	A52_STEREO,	A52_STEREO},
-	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_3F,
-	 A52_STEREO,	A52_3F,		A52_STEREO,	A52_3F},
-	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_STEREO,
-	 A52_2F1R,	A52_2F1R,	A52_2F1R,	A52_2F1R},
-	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_STEREO,
-	 A52_2F1R,	A52_3F1R,	A52_2F1R,	A52_3F1R},
-	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_3F,
-	 A52_2F2R,	A52_2F2R,	A52_2F2R,	A52_2F2R},
-	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_3F,
-	 A52_2F2R,	A52_3F2R,	A52_2F2R,	A52_3F2R},
-	{A52_CHANNEL1,	A52_MONO,	A52_MONO,	A52_MONO,
-	 A52_MONO,	A52_MONO,	A52_MONO,	A52_MONO},
-	{A52_CHANNEL2,	A52_MONO,	A52_MONO,	A52_MONO,
-	 A52_MONO,	A52_MONO,	A52_MONO,	A52_MONO},
-	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_DOLBY,
-	 A52_DOLBY,	A52_DOLBY,	A52_DOLBY,	A52_DOLBY}
-    };
-    int output;
-
-    output = flags &amp; A52_CHANNEL_MASK;
-    if (output &gt; A52_DOLBY)
-	return -1;
-
-    output = table[output][input &amp; 7];
-
-    if ((output == A52_STEREO) &amp;&amp;
-	((input == A52_DOLBY) || ((input == A52_3F) &amp;&amp; (clev == LEVEL_3DB))))
-	output = A52_DOLBY;
-
-    if (flags &amp; A52_ADJUST_LEVEL)
-	switch (CONVERT (input &amp; 7, output)) {
-
-	case CONVERT (A52_3F, A52_MONO):
-	    *level *= LEVEL_3DB / (1 + clev);
-	    break;
-
-	case CONVERT (A52_STEREO, A52_MONO):
-	case CONVERT (A52_2F2R, A52_2F1R):
-	case CONVERT (A52_3F2R, A52_3F1R):
-	level_3db:
-	    *level *= LEVEL_3DB;
-	    break;
-
-	case CONVERT (A52_3F2R, A52_2F1R):
-	    if (clev &lt; LEVEL_PLUS3DB - 1)
-		goto level_3db;
-	    /* break thru */
-	case CONVERT (A52_3F, A52_STEREO):
-	case CONVERT (A52_3F1R, A52_2F1R):
-	case CONVERT (A52_3F1R, A52_2F2R):
-	case CONVERT (A52_3F2R, A52_2F2R):
-	    *level /= 1 + clev;
-	    break;
-
-	case CONVERT (A52_2F1R, A52_MONO):
-	    *level *= LEVEL_PLUS3DB / (2 + slev);
-	    break;
-
-	case CONVERT (A52_2F1R, A52_STEREO):
-	case CONVERT (A52_3F1R, A52_3F):
-	    *level /= 1 + slev * LEVEL_3DB;
-	    break;
-
-	case CONVERT (A52_3F1R, A52_MONO):
-	    *level *= LEVEL_3DB / (1 + clev + 0.5 * slev);
-	    break;
-
-	case CONVERT (A52_3F1R, A52_STEREO):
-	    *level /= 1 + clev + slev * LEVEL_3DB;
-	    break;
-
-	case CONVERT (A52_2F2R, A52_MONO):
-	    *level *= LEVEL_3DB / (1 + slev);
-	    break;
-
-	case CONVERT (A52_2F2R, A52_STEREO):
-	case CONVERT (A52_3F2R, A52_3F):
-	    *level /= 1 + slev;
-	    break;
-
-	case CONVERT (A52_3F2R, A52_MONO):
-	    *level *= LEVEL_3DB / (1 + clev + slev);
-	    break;
-
-	case CONVERT (A52_3F2R, A52_STEREO):
-	    *level /= 1 + clev + slev;
-	    break;
-
-	case CONVERT (A52_MONO, A52_DOLBY):
-	    *level *= LEVEL_PLUS3DB;
-	    break;
-
-	case CONVERT (A52_3F, A52_DOLBY):
-	case CONVERT (A52_2F1R, A52_DOLBY):
-	    *level *= 1 / (1 + LEVEL_3DB);
-	    break;
-
-	case CONVERT (A52_3F1R, A52_DOLBY):
-	case CONVERT (A52_2F2R, A52_DOLBY):
-	    *level *= 1 / (1 + 2 * LEVEL_3DB);
-	    break;
-
-	case CONVERT (A52_3F2R, A52_DOLBY):
-	    *level *= 1 / (1 + 3 * LEVEL_3DB);
-	    break;
-	}
-
-    return output;
-}
-
-int a52_downmix_coeff (sample_t * coeff, int acmod, int output, sample_t level,
-		       sample_t clev, sample_t slev)
-{
-    switch (CONVERT (acmod, output &amp; A52_CHANNEL_MASK)) {
-
-    case CONVERT (A52_CHANNEL, A52_CHANNEL):
-    case CONVERT (A52_MONO, A52_MONO):
-    case CONVERT (A52_STEREO, A52_STEREO):
-    case CONVERT (A52_3F, A52_3F):
-    case CONVERT (A52_2F1R, A52_2F1R):
-    case CONVERT (A52_3F1R, A52_3F1R):
-    case CONVERT (A52_2F2R, A52_2F2R):
-    case CONVERT (A52_3F2R, A52_3F2R):
-    case CONVERT (A52_STEREO, A52_DOLBY):
-	coeff[0] = coeff[1] = coeff[2] = coeff[3] = coeff[4] = level;
-	return 0;
-
-    case CONVERT (A52_CHANNEL, A52_MONO):
-	coeff[0] = coeff[1] = level * LEVEL_6DB;
-	return 3;
-
-    case CONVERT (A52_STEREO, A52_MONO):
-	coeff[0] = coeff[1] = level * LEVEL_3DB;
-	return 3;
-
-    case CONVERT (A52_3F, A52_MONO):
-	coeff[0] = coeff[2] = level * LEVEL_3DB;
-	coeff[1] = level * clev * LEVEL_PLUS3DB;
-	return 7;
-
-    case CONVERT (A52_2F1R, A52_MONO):
-	coeff[0] = coeff[1] = level * LEVEL_3DB;
-	coeff[2] = level * slev * LEVEL_3DB;
-	return 7;
-
-    case CONVERT (A52_2F2R, A52_MONO):
-	coeff[0] = coeff[1] = level * LEVEL_3DB;
-	coeff[2] = coeff[3] = level * slev * LEVEL_3DB;
-	return 15;
-
-    case CONVERT (A52_3F1R, A52_MONO):
-	coeff[0] = coeff[2] = level * LEVEL_3DB;
-	coeff[1] = level * clev * LEVEL_PLUS3DB;
-	coeff[3] = level * slev * LEVEL_3DB;
-	return 15;
-
-    case CONVERT (A52_3F2R, A52_MONO):
-	coeff[0] = coeff[2] = level * LEVEL_3DB;
-	coeff[1] = level * clev * LEVEL_PLUS3DB;
-	coeff[3] = coeff[4] = level * slev * LEVEL_3DB;
-	return 31;
-
-    case CONVERT (A52_MONO, A52_DOLBY):
-	coeff[0] = level * LEVEL_3DB;
-	return 0;
-
-    case CONVERT (A52_3F, A52_DOLBY):
-	clev = LEVEL_3DB;
-    case CONVERT (A52_3F, A52_STEREO):
-    case CONVERT (A52_3F1R, A52_2F1R):
-    case CONVERT (A52_3F2R, A52_2F2R):
-	coeff[0] = coeff[2] = coeff[3] = coeff[4] = level;
-	coeff[1] = level * clev;
-	return 7;
-
-    case CONVERT (A52_2F1R, A52_DOLBY):
-	slev = 1;
-    case CONVERT (A52_2F1R, A52_STEREO):
-	coeff[0] = coeff[1] = level;
-	coeff[2] = level * slev * LEVEL_3DB;
-	return 7;
-
-    case CONVERT (A52_3F1R, A52_DOLBY):
-	clev = LEVEL_3DB;
-	slev = 1;
-    case CONVERT (A52_3F1R, A52_STEREO):
-	coeff[0] = coeff[2] = level;
-	coeff[1] = level * clev;
-	coeff[3] = level * slev * LEVEL_3DB;
-	return 15;
-
-    case CONVERT (A52_2F2R, A52_DOLBY):
-	slev = LEVEL_3DB;
-    case CONVERT (A52_2F2R, A52_STEREO):
-	coeff[0] = coeff[1] = level;
-	coeff[2] = coeff[3] = level * slev;
-	return 15;
-
-    case CONVERT (A52_3F2R, A52_DOLBY):
-	clev = LEVEL_3DB;
-    case CONVERT (A52_3F2R, A52_2F1R):
-	slev = LEVEL_3DB;
-    case CONVERT (A52_3F2R, A52_STEREO):
-	coeff[0] = coeff[2] = level;
-	coeff[1] = level * clev;
-	coeff[3] = coeff[4] = level * slev;
-	return 31;
-
-    case CONVERT (A52_3F1R, A52_3F):
-	coeff[0] = coeff[1] = coeff[2] = level;
-	coeff[3] = level * slev * LEVEL_3DB;
-	return 13;
-
-    case CONVERT (A52_3F2R, A52_3F):
-	coeff[0] = coeff[1] = coeff[2] = level;
-	coeff[3] = coeff[4] = level * slev;
-	return 29;
-
-    case CONVERT (A52_2F2R, A52_2F1R):
-	coeff[0] = coeff[1] = level;
-	coeff[2] = coeff[3] = level * LEVEL_3DB;
-	return 12;
-
-    case CONVERT (A52_3F2R, A52_3F1R):
-	coeff[0] = coeff[1] = coeff[2] = level;
-	coeff[3] = coeff[4] = level * LEVEL_3DB;
-	return 24;
-
-    case CONVERT (A52_2F1R, A52_2F2R):
-	coeff[0] = coeff[1] = level;
-	coeff[2] = level * LEVEL_3DB;
-	return 0;
-
-    case CONVERT (A52_3F1R, A52_2F2R):
-	coeff[0] = coeff[2] = level;
-	coeff[1] = level * clev;
-	coeff[3] = level * LEVEL_3DB;
-	return 7;
-
-    case CONVERT (A52_3F1R, A52_3F2R):
-	coeff[0] = coeff[1] = coeff[2] = level;
-	coeff[3] = level * LEVEL_3DB;
-	return 0;
-
-    case CONVERT (A52_CHANNEL, A52_CHANNEL1):
-	coeff[0] = level;
-	coeff[1] = 0;
-	return 0;
-
-    case CONVERT (A52_CHANNEL, A52_CHANNEL2):
-	coeff[0] = 0;
-	coeff[1] = level;
-	return 0;
-    }
-
-    return -1;	/* NOTREACHED */
-}
-
-static void mix2to1 (sample_t * dest, sample_t * src, sample_t bias)
-{
-    int i;
-
-    for (i = 0; i &lt; 256; i++)
-	dest[i] += src[i] + bias;
-}
-
-static void mix3to1 (sample_t * samples, sample_t bias)
-{
-    int i;
-
-    for (i = 0; i &lt; 256; i++)
-	samples[i] += samples[i + 256] + samples[i + 512] + bias;
-}
-
-static void mix4to1 (sample_t * samples, sample_t bias)
-{
-    int i;
-
-    for (i = 0; i &lt; 256; i++)
-	samples[i] += (samples[i + 256] + samples[i + 512] +
-		       samples[i + 768] + bias);
-}
-
-static void mix5to1 (sample_t * samples, sample_t bias)
-{
-    int i;
-
-    for (i = 0; i &lt; 256; i++)
-	samples[i] += (samples[i + 256] + samples[i + 512] +
-		       samples[i + 768] + samples[i + 1024] + bias);
-}
-
-static void mix3to2 (sample_t * samples, sample_t bias)
-{
-    int i;
-    sample_t common;
-
-    for (i = 0; i &lt; 256; i++) {
-	common = samples[i + 256] + bias;
-	samples[i] += common;
-	samples[i + 256] = samples[i + 512] + common;
-    }
-}
-
-static void mix21to2 (sample_t * left, sample_t * right, sample_t bias)
-{
-    int i;
-    sample_t common;
-
-    for (i = 0; i &lt; 256; i++) {
-	common = right[i + 256] + bias;
-	left[i] += common;
-	right[i] += common;
-    }
-}
-
-static void mix21toS (sample_t * samples, sample_t bias)
-{
-    int i;
-    sample_t surround;
-
-    for (i = 0; i &lt; 256; i++) {
-	surround = samples[i + 512];
-	samples[i] += bias - surround;
-	samples[i + 256] += bias + surround;
-    }
-}
-
-static void mix31to2 (sample_t * samples, sample_t bias)
-{
-    int i;
-    sample_t common;
-
-    for (i = 0; i &lt; 256; i++) {
-	common = samples[i + 256] + samples[i + 768] + bias;
-	samples[i] += common;
-	samples[i + 256] = samples[i + 512] + common;
-    }
-}
-
-static void mix31toS (sample_t * samples, sample_t bias)
-{
-    int i;
-    sample_t common, surround;
-
-    for (i = 0; i &lt; 256; i++) {
-	common = samples[i + 256] + bias;
-	surround = samples[i + 768];
-	samples[i] += common - surround;
-	samples[i + 256] = samples[i + 512] + common + surround;
-    }
-}
-
-static void mix22toS (sample_t * samples, sample_t bias)
-{
-    int i;
-    sample_t surround;
-
-    for (i = 0; i &lt; 256; i++) {
-	surround = samples[i + 512] + samples[i + 768];
-	samples[i] += bias - surround;
-	samples[i + 256] += bias + surround;
-    }
-}
-
-static void mix32to2 (sample_t * samples, sample_t bias)
-{
-    int i;
-    sample_t common;
-
-    for (i = 0; i &lt; 256; i++) {
-	common = samples[i + 256] + bias;
-	samples[i] += common + samples[i + 768];
-	samples[i + 256] = common + samples[i + 512] + samples[i + 1024];
-    }
-}
-
-static void mix32toS (sample_t * samples, sample_t bias)
-{
-    int i;
-    sample_t common, surround;
-
-    for (i = 0; i &lt; 256; i++) {
-	common = samples[i + 256] + bias;
-	surround = samples[i + 768] + samples[i + 1024];
-	samples[i] += common - surround;
-	samples[i + 256] = samples[i + 512] + common + surround;
-    }
-}
-
-static void move2to1 (sample_t * src, sample_t * dest, sample_t bias)
-{
-    int i;
-
-    for (i = 0; i &lt; 256; i++)
-	dest[i] = src[i] + src[i + 256] + bias;
-}
-
-static void zero (sample_t * samples)
-{
-    int i;
-
-    for (i = 0; i &lt; 256; i++)
-	samples[i] = 0;
-}
-
-void a52_downmix (sample_t * samples, int acmod, int output, sample_t bias,
-		  sample_t clev, sample_t slev)
-{
-    switch (CONVERT (acmod, output &amp; A52_CHANNEL_MASK)) {
-
-    case CONVERT (A52_CHANNEL, A52_CHANNEL2):
-	memcpy (samples, samples + 256, 256 * sizeof (sample_t));
-	break;
-
-    case CONVERT (A52_CHANNEL, A52_MONO):
-    case CONVERT (A52_STEREO, A52_MONO):
-    mix_2to1:
-	mix2to1 (samples, samples + 256, bias);
-	break;
-
-    case CONVERT (A52_2F1R, A52_MONO):
-	if (slev == 0)
-	    goto mix_2to1;
-    case CONVERT (A52_3F, A52_MONO):
-    mix_3to1:
-	mix3to1 (samples, bias);
-	break;
-
-    case CONVERT (A52_3F1R, A52_MONO):
-	if (slev == 0)
-	    goto mix_3to1;
-    case CONVERT (A52_2F2R, A52_MONO):
-	if (slev == 0)
-	    goto mix_2to1;
-	mix4to1 (samples, bias);
-	break;
-
-    case CONVERT (A52_3F2R, A52_MONO):
-	if (slev == 0)
-	    goto mix_3to1;
-	mix5to1 (samples, bias);
-	break;
-
-    case CONVERT (A52_MONO, A52_DOLBY):
-	memcpy (samples + 256, samples, 256 * sizeof (sample_t));
-	break;
-
-    case CONVERT (A52_3F, A52_STEREO):
-    case CONVERT (A52_3F, A52_DOLBY):
-    mix_3to2:
-	mix3to2 (samples, bias);
-	break;
-
-    case CONVERT (A52_2F1R, A52_STEREO):
-	if (slev == 0)
-	    break;
-	mix21to2 (samples, samples + 256, bias);
-	break;
-
-    case CONVERT (A52_2F1R, A52_DOLBY):
-	mix21toS (samples, bias);
-	break;
-
-    case CONVERT (A52_3F1R, A52_STEREO):
-	if (slev == 0)
-	    goto mix_3to2;
-	mix31to2 (samples, bias);
-	break;
-
-    case CONVERT (A52_3F1R, A52_DOLBY):
-	mix31toS (samples, bias);
-	break;
-
-    case CONVERT (A52_2F2R, A52_STEREO):
-	if (slev == 0)
-	    break;
-	mix2to1 (samples, samples + 512, bias);
-	mix2to1 (samples + 256, samples + 768, bias);
-	break;
-
-    case CONVERT (A52_2F2R, A52_DOLBY):
-	mix22toS (samples, bias);
-	break;
-
-    case CONVERT (A52_3F2R, A52_STEREO):
-	if (slev == 0)
-	    goto mix_3to2;
-	mix32to2 (samples, bias);
-	break;
-
-    case CONVERT (A52_3F2R, A52_DOLBY):
-	mix32toS (samples, bias);
-	break;
-
-    case CONVERT (A52_3F1R, A52_3F):
-	if (slev == 0)
-	    break;
-	mix21to2 (samples, samples + 512, bias);
-	break;
-
-    case CONVERT (A52_3F2R, A52_3F):
-	if (slev == 0)
-	    break;
-	mix2to1 (samples, samples + 768, bias);
-	mix2to1 (samples + 512, samples + 1024, bias);
-	break;
-
-    case CONVERT (A52_3F1R, A52_2F1R):
-	mix3to2 (samples, bias);
-	memcpy (samples + 512, samples + 768, 256 * sizeof (sample_t));
-	break;
-
-    case CONVERT (A52_2F2R, A52_2F1R):
-	mix2to1 (samples + 512, samples + 768, bias);
-	break;
-
-    case CONVERT (A52_3F2R, A52_2F1R):
-	mix3to2 (samples, bias);
-	move2to1 (samples + 768, samples + 512, bias);
-	break;
-
-    case CONVERT (A52_3F2R, A52_3F1R):
-	mix2to1 (samples + 768, samples + 1024, bias);
-	break;
-
-    case CONVERT (A52_2F1R, A52_2F2R):
-	memcpy (samples + 768, samples + 512, 256 * sizeof (sample_t));
-	break;
-
-    case CONVERT (A52_3F1R, A52_2F2R):
-	mix3to2 (samples, bias);
-	memcpy (samples + 512, samples + 768, 256 * sizeof (sample_t));
-	break;
-
-    case CONVERT (A52_3F2R, A52_2F2R):
-	mix3to2 (samples, bias);
-	memcpy (samples + 512, samples + 768, 256 * sizeof (sample_t));
-	memcpy (samples + 768, samples + 1024, 256 * sizeof (sample_t));
-	break;
-
-    case CONVERT (A52_3F1R, A52_3F2R):
-	memcpy (samples + 1027, samples + 768, 256 * sizeof (sample_t));
-	break;
-    }
-}
-
-void a52_upmix (sample_t * samples, int acmod, int output)
-{
-    switch (CONVERT (acmod, output &amp; A52_CHANNEL_MASK)) {
-
-    case CONVERT (A52_CHANNEL, A52_CHANNEL2):
-	memcpy (samples + 256, samples, 256 * sizeof (sample_t));
-	break;
-
-    case CONVERT (A52_3F2R, A52_MONO):
-	zero (samples + 1024);
-    case CONVERT (A52_3F1R, A52_MONO):
-    case CONVERT (A52_2F2R, A52_MONO):
-	zero (samples + 768);
-    case CONVERT (A52_3F, A52_MONO):
-    case CONVERT (A52_2F1R, A52_MONO):
-	zero (samples + 512);
-    case CONVERT (A52_CHANNEL, A52_MONO):
-    case CONVERT (A52_STEREO, A52_MONO):
-	zero (samples + 256);
-	break;
-
-    case CONVERT (A52_3F2R, A52_STEREO):
-    case CONVERT (A52_3F2R, A52_DOLBY):
-	zero (samples + 1024);
-    case CONVERT (A52_3F1R, A52_STEREO):
-    case CONVERT (A52_3F1R, A52_DOLBY):
-	zero (samples + 768);
-    case CONVERT (A52_3F, A52_STEREO):
-    case CONVERT (A52_3F, A52_DOLBY):
-    mix_3to2:
-	memcpy (samples + 512, samples + 256, 256 * sizeof (sample_t));
-	zero (samples + 256);
-	break;
-
-    case CONVERT (A52_2F2R, A52_STEREO):
-    case CONVERT (A52_2F2R, A52_DOLBY):
-	zero (samples + 768);
-    case CONVERT (A52_2F1R, A52_STEREO):
-    case CONVERT (A52_2F1R, A52_DOLBY):
-	zero (samples + 512);
-	break;
-
-    case CONVERT (A52_3F2R, A52_3F):
-	zero (samples + 1024);
-    case CONVERT (A52_3F1R, A52_3F):
-    case CONVERT (A52_2F2R, A52_2F1R):
-	zero (samples + 768);
-	break;
-
-    case CONVERT (A52_3F2R, A52_3F1R):
-	zero (samples + 1024);
-	break;
-
-    case CONVERT (A52_3F2R, A52_2F1R):
-	zero (samples + 1024);
-    case CONVERT (A52_3F1R, A52_2F1R):
-    mix_31to21:
-	memcpy (samples + 768, samples + 512, 256 * sizeof (sample_t));
-	goto mix_3to2;
-
-    case CONVERT (A52_3F2R, A52_2F2R):
-	memcpy (samples + 1024, samples + 768, 256 * sizeof (sample_t));
-	goto mix_31to21;
-    }
-}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/imdct.c
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/imdct.c	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/imdct.c	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,432 +0,0 @@
-/*
- * imdct.c
- * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
- * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
- *
- * The ifft algorithms in this file have been largely inspired by Dan
- * Bernstein's work, djbfft, available at <A HREF="http://cr.yp.to/djbfft.html">http://cr.yp.to/djbfft.html</A>
- *
- * This file is part of a52dec, a free ATSC A-52 stream decoder.
- * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
- *
- * a52dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * a52dec is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include &quot;config.h&quot;
-
-#include &lt;math.h&gt;
-#include &lt;stdio.h&gt;
-#ifdef LIBA52_DJBFFT
-#include &lt;fftc4.h&gt;
-#endif
-#ifndef M_PI
-#define M_PI 3.1415926535897932384626433832795029
-#endif
-#include &lt;inttypes.h&gt;
-
-#include &quot;a52.h&quot;
-#include &quot;a52_internal.h&quot;
-#include &quot;mm_accel.h&quot;
-
-typedef struct complex_s {
-    sample_t real;
-    sample_t imag;
-} complex_t;
-
-static uint8_t fftorder[] = {
-      0,128, 64,192, 32,160,224, 96, 16,144, 80,208,240,112, 48,176,
-      8,136, 72,200, 40,168,232,104,248,120, 56,184, 24,152,216, 88,
-      4,132, 68,196, 36,164,228,100, 20,148, 84,212,244,116, 52,180,
-    252,124, 60,188, 28,156,220, 92, 12,140, 76,204,236,108, 44,172,
-      2,130, 66,194, 34,162,226, 98, 18,146, 82,210,242,114, 50,178,
-     10,138, 74,202, 42,170,234,106,250,122, 58,186, 26,154,218, 90,
-    254,126, 62,190, 30,158,222, 94, 14,142, 78,206,238,110, 46,174,
-      6,134, 70,198, 38,166,230,102,246,118, 54,182, 22,150,214, 86
-};
-
-/* Root values for IFFT */
-static sample_t roots16[3];
-static sample_t roots32[7];
-static sample_t roots64[15];
-static sample_t roots128[31];
-
-/* Twiddle factors for IMDCT */
-static complex_t pre1[128];
-static complex_t post1[64];
-static complex_t pre2[64];
-static complex_t post2[32];
-
-static sample_t a52_imdct_window[256];
-
-static void (* ifft128) (complex_t * buf);
-static void (* ifft64) (complex_t * buf);
-
-static inline void ifft2 (complex_t * buf)
-{
-    double r, i;
-
-    r = buf[0].real;
-    i = buf[0].imag;
-    buf[0].real += buf[1].real;
-    buf[0].imag += buf[1].imag;
-    buf[1].real = r - buf[1].real;
-    buf[1].imag = i - buf[1].imag;
-}
-
-static inline void ifft4 (complex_t * buf)
-{
-    double tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
-
-    tmp1 = buf[0].real + buf[1].real;
-    tmp2 = buf[3].real + buf[2].real;
-    tmp3 = buf[0].imag + buf[1].imag;
-    tmp4 = buf[2].imag + buf[3].imag;
-    tmp5 = buf[0].real - buf[1].real;
-    tmp6 = buf[0].imag - buf[1].imag;
-    tmp7 = buf[2].imag - buf[3].imag;
-    tmp8 = buf[3].real - buf[2].real;
-
-    buf[0].real = tmp1 + tmp2;
-    buf[0].imag = tmp3 + tmp4;
-    buf[2].real = tmp1 - tmp2;
-    buf[2].imag = tmp3 - tmp4;
-    buf[1].real = tmp5 + tmp7;
-    buf[1].imag = tmp6 + tmp8;
-    buf[3].real = tmp5 - tmp7;
-    buf[3].imag = tmp6 - tmp8;
-}
-
-/* the basic split-radix ifft butterfly */
-
-#define BUTTERFLY(a0,a1,a2,a3,wr,wi) do {	\
-    tmp5 = a2.real * wr + a2.imag * wi;		\
-    tmp6 = a2.imag * wr - a2.real * wi;		\
-    tmp7 = a3.real * wr - a3.imag * wi;		\
-    tmp8 = a3.imag * wr + a3.real * wi;		\
-    tmp1 = tmp5 + tmp7;				\
-    tmp2 = tmp6 + tmp8;				\
-    tmp3 = tmp6 - tmp8;				\
-    tmp4 = tmp7 - tmp5;				\
-    a2.real = a0.real - tmp1;			\
-    a2.imag = a0.imag - tmp2;			\
-    a3.real = a1.real - tmp3;			\
-    a3.imag = a1.imag - tmp4;			\
-    a0.real += tmp1;				\
-    a0.imag += tmp2;				\
-    a1.real += tmp3;				\
-    a1.imag += tmp4;				\
-} while (0)
-
-/* split-radix ifft butterfly, specialized for wr=1 wi=0 */
-
-#define BUTTERFLY_ZERO(a0,a1,a2,a3) do {	\
-    tmp1 = a2.real + a3.real;			\
-    tmp2 = a2.imag + a3.imag;			\
-    tmp3 = a2.imag - a3.imag;			\
-    tmp4 = a3.real - a2.real;			\
-    a2.real = a0.real - tmp1;			\
-    a2.imag = a0.imag - tmp2;			\
-    a3.real = a1.real - tmp3;			\
-    a3.imag = a1.imag - tmp4;			\
-    a0.real += tmp1;				\
-    a0.imag += tmp2;				\
-    a1.real += tmp3;				\
-    a1.imag += tmp4;				\
-} while (0)
-
-/* split-radix ifft butterfly, specialized for wr=wi */
-
-#define BUTTERFLY_HALF(a0,a1,a2,a3,w) do {	\
-    tmp5 = (a2.real + a2.imag) * w;		\
-    tmp6 = (a2.imag - a2.real) * w;		\
-    tmp7 = (a3.real - a3.imag) * w;		\
-    tmp8 = (a3.imag + a3.real) * w;		\
-    tmp1 = tmp5 + tmp7;				\
-    tmp2 = tmp6 + tmp8;				\
-    tmp3 = tmp6 - tmp8;				\
-    tmp4 = tmp7 - tmp5;				\
-    a2.real = a0.real - tmp1;			\
-    a2.imag = a0.imag - tmp2;			\
-    a3.real = a1.real - tmp3;			\
-    a3.imag = a1.imag - tmp4;			\
-    a0.real += tmp1;				\
-    a0.imag += tmp2;				\
-    a1.real += tmp3;				\
-    a1.imag += tmp4;				\
-} while (0)
-
-static inline void ifft8 (complex_t * buf)
-{
-    double tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
-
-    ifft4 (buf);
-    ifft2 (buf + 4);
-    ifft2 (buf + 6);
-    BUTTERFLY_ZERO (buf[0], buf[2], buf[4], buf[6]);
-    BUTTERFLY_HALF (buf[1], buf[3], buf[5], buf[7], roots16[1]);
-}
-
-static void ifft_pass (complex_t * buf, sample_t * weight, int n)
-{
-    complex_t * buf1;
-    complex_t * buf2;
-    complex_t * buf3;
-    double tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
-    int i;
-
-    buf++;
-    buf1 = buf + n;
-    buf2 = buf + 2 * n;
-    buf3 = buf + 3 * n;
-
-    BUTTERFLY_ZERO (buf[-1], buf1[-1], buf2[-1], buf3[-1]);
-
-    i = n - 1;
-
-    do {
-	BUTTERFLY (buf[0], buf1[0], buf2[0], buf3[0], weight[n], weight[2*i]);
-	buf++;
-	buf1++;
-	buf2++;
-	buf3++;
-	weight++;
-    } while (--i);
-}
-
-static void ifft16 (complex_t * buf)
-{
-    ifft8 (buf);
-    ifft4 (buf + 8);
-    ifft4 (buf + 12);
-    ifft_pass (buf, roots16 - 4, 4);
-}
-
-static void ifft32 (complex_t * buf)
-{
-    ifft16 (buf);
-    ifft8 (buf + 16);
-    ifft8 (buf + 24);
-    ifft_pass (buf, roots32 - 8, 8);
-}
-
-static void ifft64_c (complex_t * buf)
-{
-    ifft32 (buf);
-    ifft16 (buf + 32);
-    ifft16 (buf + 48);
-    ifft_pass (buf, roots64 - 16, 16);
-}
-
-static void ifft128_c (complex_t * buf)
-{
-    ifft32 (buf);
-    ifft16 (buf + 32);
-    ifft16 (buf + 48);
-    ifft_pass (buf, roots64 - 16, 16);
-
-    ifft32 (buf + 64);
-    ifft32 (buf + 96);
-    ifft_pass (buf, roots128 - 32, 32);
-}
-
-void a52_imdct_512 (sample_t * data, sample_t * delay, sample_t bias)
-{
-    int i, k;
-    sample_t t_r, t_i, a_r, a_i, b_r, b_i, w_1, w_2;
-    const sample_t * window = a52_imdct_window;
-    complex_t buf[128];
-	
-    for (i = 0; i &lt; 128; i++) {
-	k = fftorder[i];
-	t_r = pre1[i].real;
-	t_i = pre1[i].imag;
-
-	buf[i].real = t_i * data[255-k] + t_r * data[k];
-	buf[i].imag = t_r * data[255-k] - t_i * data[k];
-    }
-
-    ifft128 (buf);
-
-    /* Post IFFT complex multiply plus IFFT complex conjugate*/
-    /* Window and convert to real valued signal */
-    for (i = 0; i &lt; 64; i++) {
-	/* y[n] = z[n] * (xcos1[n] + j * xsin1[n]) ; */
-	t_r = post1[i].real;
-	t_i = post1[i].imag;
-
-	a_r = t_r * buf[i].real     + t_i * buf[i].imag;
-	a_i = t_i * buf[i].real     - t_r * buf[i].imag;
-	b_r = t_i * buf[127-i].real + t_r * buf[127-i].imag;
-	b_i = t_r * buf[127-i].real - t_i * buf[127-i].imag;
-
-	w_1 = window[2*i];
-	w_2 = window[255-2*i];
-	data[2*i]     = delay[2*i] * w_2 - a_r * w_1 + bias;
-	data[255-2*i] = delay[2*i] * w_1 + a_r * w_2 + bias;
-	delay[2*i] = a_i;
-
-	w_1 = window[2*i+1];
-	w_2 = window[254-2*i];
-	data[2*i+1]   = delay[2*i+1] * w_2 + b_r * w_1 + bias;
-	data[254-2*i] = delay[2*i+1] * w_1 - b_r * w_2 + bias;
-	delay[2*i+1] = b_i;
-    }
-}
-
-void a52_imdct_256(sample_t * data, sample_t * delay, sample_t bias)
-{
-    int i, k;
-    sample_t t_r, t_i, a_r, a_i, b_r, b_i, c_r, c_i, d_r, d_i, w_1, w_2;
-    const sample_t * window = a52_imdct_window;
-    complex_t buf1[64], buf2[64];
-
-    /* Pre IFFT complex multiply plus IFFT cmplx conjugate */
-    for (i = 0; i &lt; 64; i++) {
-	k = fftorder[i];
-	t_r = pre2[i].real;
-	t_i = pre2[i].imag;
-
-	buf1[i].real = t_i * data[254-k] + t_r * data[k];
-	buf1[i].imag = t_r * data[254-k] - t_i * data[k];
-
-	buf2[i].real = t_i * data[255-k] + t_r * data[k+1];
-	buf2[i].imag = t_r * data[255-k] - t_i * data[k+1];
-    }
-
-    ifft64 (buf1);
-    ifft64 (buf2);
-
-    /* Post IFFT complex multiply */
-    /* Window and convert to real valued signal */
-    for (i = 0; i &lt; 32; i++) {
-	/* y1[n] = z1[n] * (xcos2[n] + j * xs in2[n]) ; */ 
-	t_r = post2[i].real;
-	t_i = post2[i].imag;
-
-	a_r = t_r * buf1[i].real    + t_i * buf1[i].imag;
-	a_i = t_i * buf1[i].real    - t_r * buf1[i].imag;
-	b_r = t_i * buf1[63-i].real + t_r * buf1[63-i].imag;
-	b_i = t_r * buf1[63-i].real - t_i * buf1[63-i].imag;
-
-	c_r = t_r * buf2[i].real    + t_i * buf2[i].imag;
-	c_i = t_i * buf2[i].real    - t_r * buf2[i].imag;
-	d_r = t_i * buf2[63-i].real + t_r * buf2[63-i].imag;
-	d_i = t_r * buf2[63-i].real - t_i * buf2[63-i].imag;
-
-	w_1 = window[2*i];
-	w_2 = window[255-2*i];
-	data[2*i]     = delay[2*i] * w_2 - a_r * w_1 + bias;
-	data[255-2*i] = delay[2*i] * w_1 + a_r * w_2 + bias;
-	delay[2*i] = c_i;
-
-	w_1 = window[128+2*i];
-	w_2 = window[127-2*i];
-	data[128+2*i] = delay[127-2*i] * w_2 + a_i * w_1 + bias;
-	data[127-2*i] = delay[127-2*i] * w_1 - a_i * w_2 + bias;
-	delay[127-2*i] = c_r;
-
-	w_1 = window[2*i+1];
-	w_2 = window[254-2*i];
-	data[2*i+1]   = delay[2*i+1] * w_2 - b_i * w_1 + bias;
-	data[254-2*i] = delay[2*i+1] * w_1 + b_i * w_2 + bias;
-	delay[2*i+1] = d_r;
-
-	w_1 = window[129+2*i];
-	w_2 = window[126-2*i];
-	data[129+2*i] = delay[126-2*i] * w_2 + b_r * w_1 + bias;
-	data[126-2*i] = delay[126-2*i] * w_1 - b_r * w_2 + bias;
-	delay[126-2*i] = d_i;
-    }
-}
-
-static double besselI0 (double x)
-{
-    double bessel = 1;
-    int i = 100;
-
-    do
-	bessel = bessel * x / (i * i) + 1;
-    while (--i);
-    return bessel;
-}
-
-void a52_imdct_init (uint32_t mm_accel)
-{
-    int i, k;
-    double sum;
-
-    /* compute imdct window - kaiser-bessel derived window, alpha = 5.0 */
-    sum = 0;
-    for (i = 0; i &lt; 256; i++) {
-	sum += besselI0 (i * (256 - i) * (5 * M_PI / 256) * (5 * M_PI / 256));
-	a52_imdct_window[i] = sum;
-    }
-    sum++;
-    for (i = 0; i &lt; 256; i++)
-	a52_imdct_window[i] = sqrt (a52_imdct_window[i] / sum);
-
-    for (i = 0; i &lt; 3; i++)
-	roots16[i] = cos ((M_PI / 8) * (i + 1));
-
-    for (i = 0; i &lt; 7; i++)
-	roots32[i] = cos ((M_PI / 16) * (i + 1));
-
-    for (i = 0; i &lt; 15; i++)
-	roots64[i] = cos ((M_PI / 32) * (i + 1));
-
-    for (i = 0; i &lt; 31; i++)
-	roots128[i] = cos ((M_PI / 64) * (i + 1));
-
-    for (i = 0; i &lt; 64; i++) {
-	k = fftorder[i] / 2 + 64;
-	pre1[i].real = cos ((M_PI / 256) * (k - 0.25));
-	pre1[i].imag = sin ((M_PI / 256) * (k - 0.25));
-    }
-
-    for (i = 64; i &lt; 128; i++) {
-	k = fftorder[i] / 2 + 64;
-	pre1[i].real = -cos ((M_PI / 256) * (k - 0.25));
-	pre1[i].imag = -sin ((M_PI / 256) * (k - 0.25));
-    }
-
-    for (i = 0; i &lt; 64; i++) {
-	post1[i].real = cos ((M_PI / 256) * (i + 0.5));
-	post1[i].imag = sin ((M_PI / 256) * (i + 0.5));
-    }
-
-    for (i = 0; i &lt; 64; i++) {
-	k = fftorder[i] / 4;
-	pre2[i].real = cos ((M_PI / 128) * (k - 0.25));
-	pre2[i].imag = sin ((M_PI / 128) * (k - 0.25));
-    }
-
-    for (i = 0; i &lt; 32; i++) {
-	post2[i].real = cos ((M_PI / 128) * (i + 0.5));
-	post2[i].imag = sin ((M_PI / 128) * (i + 0.5));
-    }
-
-#ifdef LIBA52_DJBFFT
-    if (mm_accel &amp; MM_ACCEL_DJBFFT) {
-	fprintf (stderr, &quot;Using djbfft for IMDCT transform\n&quot;);
-	ifft128 = (void (*) (complex_t *)) fftc4_un128;
-	ifft64 = (void (*) (complex_t *)) fftc4_un64;
-    } else
-#endif
-    {
-	fprintf (stderr, &quot;No accelerated IMDCT transform found\n&quot;);
-	ifft128 = ifft128_c;
-	ifft64 = ifft64_c;
-    }
-}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/mm_accel.h
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/mm_accel.h	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/mm_accel.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,37 +0,0 @@
-/*
- * mm_accel.h
- * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
- * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
- *
- * This file is part of a52dec, a free ATSC A-52 stream decoder.
- * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
- *
- * a52dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * a52dec is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef MM_ACCEL_H
-#define MM_ACCEL_H
-
-/* generic accelerations */
-#define MM_ACCEL_DJBFFT		0x00000001
-
-/* x86 accelerations */
-#define MM_ACCEL_X86_MMX	0x80000000
-#define MM_ACCEL_X86_3DNOW	0x40000000
-#define MM_ACCEL_X86_MMXEXT	0x20000000
-
-uint32_t mm_accel (void);
-
-#endif /* MM_ACCEL_H */

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/parse.c
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/parse.c	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/parse.c	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,905 +0,0 @@
-/*
- * parse.c
- * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
- * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
- *
- * This file is part of a52dec, a free ATSC A-52 stream decoder.
- * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
- *
- * a52dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * a52dec is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-//MEANX
-#define ADM_LEGACY_PROGGY
-#include &quot;ADM_default.h&quot;
-// /MEANX
-
-    
-#include &quot;a52.h&quot;
-#include &quot;a52_internal.h&quot;
-#include &quot;bitstream.h&quot;
-#include &quot;tables.h&quot;
-
-
-#ifdef HAVE_MEMALIGN
-/* some systems have memalign() but no declaration for it */
-void * memalign (size_t align, size_t size);
-#else
-/* assume malloc alignment is sufficient */
-#define memalign(align,size) malloc (size)
-#endif
-
-
-
-typedef struct {
-    sample_t q1[2];
-    sample_t q2[2];
-    sample_t q4;
-    int q1_ptr;
-    int q2_ptr;
-    int q4_ptr;
-} quantizer_t;
-
-static uint8_t halfrate[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3};
-
-a52_state_t * a52_init (uint32_t mm_accel)
-{
-    a52_state_t * state;
-    int i;
-
-    state = malloc (sizeof (a52_state_t));
-    if (state == NULL)
-	return NULL;
-
-    state-&gt;samples = memalign (16, 256 * 12 * sizeof (sample_t));
-    if (state-&gt;samples == NULL) {
-	free (state);
-	return NULL;
-    }
-
-    for (i = 0; i &lt; 256 * 12; i++)
-	state-&gt;samples[i] = 0;
-
-    state-&gt;downmixed = 1;
-
-    state-&gt;lfsr_state = 1;
-
-    a52_imdct_init (mm_accel);
-
-    return state;
-}
-
-sample_t * a52_samples (a52_state_t * state)
-{
-    return state-&gt;samples;
-}
-
-int a52_syncinfo (uint8_t * buf, int * flags,
-		  int * sample_rate, int * bit_rate)
-{
-    static int rate[] = { 32,  40,  48,  56,  64,  80,  96, 112,
-			 128, 160, 192, 224, 256, 320, 384, 448,
-			 512, 576, 640};
-    static uint8_t lfeon[8] = {0x10, 0x10, 0x04, 0x04, 0x04, 0x01, 0x04, 0x01};
-    int frmsizecod;
-    int bitrate;
-    int half;
-    int acmod;
-
-    if ((buf[0] != 0x0b) || (buf[1] != 0x77))	/* syncword */
-	return 0;
-
-    if (buf[5] &gt;= 0x60)		/* bsid &gt;= 12 */
-	return 0;
-    half = halfrate[buf[5] &gt;&gt; 3];
-
-    /* acmod, dsurmod and lfeon */
-    acmod = buf[6] &gt;&gt; 5;
-    *flags = ((((buf[6] &amp; 0xf8) == 0x50) ? A52_DOLBY : acmod) |
-	      ((buf[6] &amp; lfeon[acmod]) ? A52_LFE : 0));
-
-    frmsizecod = buf[4] &amp; 63;
-    if (frmsizecod &gt;= 38)
-	return 0;
-    bitrate = rate [frmsizecod &gt;&gt; 1];
-    *bit_rate = (bitrate * 1000) &gt;&gt; half;
-
-    switch (buf[4] &amp; 0xc0) {
-    case 0:
-	*sample_rate = 48000 &gt;&gt; half;
-	return 4 * bitrate;
-    case 0x40:
-	*sample_rate = 44100 &gt;&gt; half;
-	return 2 * (320 * bitrate / 147 + (frmsizecod &amp; 1));
-    case 0x80:
-	*sample_rate = 32000 &gt;&gt; half;
-	return 6 * bitrate;
-    default:
-	return 0;
-    }
-}
-
-int a52_frame (a52_state_t * state, uint8_t * buf, int * flags,
-	       sample_t * level, sample_t bias)
-{
-    static sample_t clev[4] = {LEVEL_3DB, LEVEL_45DB, LEVEL_6DB, LEVEL_45DB};
-    static sample_t slev[4] = {LEVEL_3DB, LEVEL_6DB, 0, LEVEL_6DB};
-    int chaninfo;
-    int acmod;
-
-    state-&gt;fscod = buf[4] &gt;&gt; 6;
-    state-&gt;halfrate = halfrate[buf[5] &gt;&gt; 3];
-    state-&gt;acmod = acmod = buf[6] &gt;&gt; 5;
-
-    a52_bitstream_set_ptr (state, buf + 6);
-    bitstream_get (state, 3);	/* skip acmod we already parsed */
-
-    if ((acmod == 2) &amp;&amp; (bitstream_get (state, 2) == 2))	/* dsurmod */
-	acmod = A52_DOLBY;
-
-    if ((acmod &amp; 1) &amp;&amp; (acmod != 1))
-	state-&gt;clev = clev[bitstream_get (state, 2)];	/* cmixlev */
-
-    if (acmod &amp; 4)
-	state-&gt;slev = slev[bitstream_get (state, 2)];	/* surmixlev */
-
-    state-&gt;lfeon = bitstream_get (state, 1);
-
-    state-&gt;output = a52_downmix_init (acmod, *flags, level,
-				      state-&gt;clev, state-&gt;slev);
-    if (state-&gt;output &lt; 0)
-	return 1;
-    if (state-&gt;lfeon &amp;&amp; (*flags &amp; A52_LFE))
-	state-&gt;output |= A52_LFE;
-    *flags = state-&gt;output;
-    /* the 2* compensates for differences in imdct */
-    state-&gt;dynrng = state-&gt;level = 2 * *level;
-    state-&gt;bias = bias;
-    state-&gt;dynrnge = 1;
-    state-&gt;dynrngcall = NULL;
-    state-&gt;cplba.deltbae = DELTA_BIT_NONE;
-    state-&gt;ba[0].deltbae = state-&gt;ba[1].deltbae = state-&gt;ba[2].deltbae =
-	state-&gt;ba[3].deltbae = state-&gt;ba[4].deltbae = DELTA_BIT_NONE;
-
-    chaninfo = !acmod;
-    do {
-	bitstream_get (state, 5);	/* dialnorm */
-	if (bitstream_get (state, 1))	/* compre */
-	    bitstream_get (state, 8);	/* compr */
-	if (bitstream_get (state, 1))	/* langcode */
-	    bitstream_get (state, 8);	/* langcod */
-	if (bitstream_get (state, 1))	/* audprodie */
-	    bitstream_get (state, 7);	/* mixlevel + roomtyp */
-    } while (chaninfo--);
-
-    bitstream_get (state, 2);		/* copyrightb + origbs */
-
-    if (bitstream_get (state, 1))	/* timecod1e */
-	bitstream_get (state, 14);	/* timecod1 */
-    if (bitstream_get (state, 1))	/* timecod2e */
-	bitstream_get (state, 14);	/* timecod2 */
-
-    if (bitstream_get (state, 1)) {	/* addbsie */
-	int addbsil;
-
-	addbsil = bitstream_get (state, 6);
-	do {
-	    bitstream_get (state, 8);	/* addbsi */
-	} while (addbsil--);
-    }
-
-    return 0;
-}
-
-void a52_dynrng (a52_state_t * state,
-		 sample_t (* call) (sample_t, void *), void * data)
-{
-    state-&gt;dynrnge = 0;
-    if (call) {
-	state-&gt;dynrnge = 1;
-	state-&gt;dynrngcall = call;
-	state-&gt;dynrngdata = data;
-    }
-}
-
-static int parse_exponents (a52_state_t * state, int expstr, int ngrps,
-			    uint8_t exponent, uint8_t * dest)
-{
-    int exps;
-
-    while (ngrps--) {
-	exps = bitstream_get (state, 7);
-
-	exponent += exp_1[exps];
-	if (exponent &gt; 24)
-	    return 1;
-
-	switch (expstr) {
-	case EXP_D45:
-	    *(dest++) = exponent;
-	    *(dest++) = exponent;
-	case EXP_D25:
-	    *(dest++) = exponent;
-	case EXP_D15:
-	    *(dest++) = exponent;
-	}
-
-	exponent += exp_2[exps];
-	if (exponent &gt; 24)
-	    return 1;
-
-	switch (expstr) {
-	case EXP_D45:
-	    *(dest++) = exponent;
-	    *(dest++) = exponent;
-	case EXP_D25:
-	    *(dest++) = exponent;
-	case EXP_D15:
-	    *(dest++) = exponent;
-	}
-
-	exponent += exp_3[exps];
-	if (exponent &gt; 24)
-	    return 1;
-
-	switch (expstr) {
-	case EXP_D45:
-	    *(dest++) = exponent;
-	    *(dest++) = exponent;
-	case EXP_D25:
-	    *(dest++) = exponent;
-	case EXP_D15:
-	    *(dest++) = exponent;
-	}
-    }	
-
-    return 0;
-}
-
-static int parse_deltba (a52_state_t * state, int8_t * deltba)
-{
-    int deltnseg, deltlen, delta, j;
-
-    memset (deltba, 0, 50);
-
-    deltnseg = bitstream_get (state, 3);
-    j = 0;
-    do {
-	j += bitstream_get (state, 5);
-	deltlen = bitstream_get (state, 4);
-	delta = bitstream_get (state, 3);
-	delta -= (delta &gt;= 4) ? 3 : 4;
-	if (!deltlen)
-	    continue;
-	if (j + deltlen &gt;= 50)
-	    return 1;
-	while (deltlen--)
-	    deltba[j++] = delta;
-    } while (deltnseg--);
-
-    return 0;
-}
-
-static inline int zero_snr_offsets (int nfchans, a52_state_t * state)
-{
-    int i;
-
-    if ((state-&gt;csnroffst) ||
-	(state-&gt;chincpl &amp;&amp; state-&gt;cplba.bai &gt;&gt; 3) ||	/* cplinu, fsnroffst */
-	(state-&gt;lfeon &amp;&amp; state-&gt;lfeba.bai &gt;&gt; 3))	/* fsnroffst */
-	return 0;
-    for (i = 0; i &lt; nfchans; i++)
-	if (state-&gt;ba[i].bai &gt;&gt; 3)			/* fsnroffst */
-	    return 0;
-    return 1;
-}
-
-static inline int16_t dither_gen (a52_state_t * state)
-{
-    int16_t nstate;
-
-    nstate = dither_lut[state-&gt;lfsr_state &gt;&gt; 8] ^ (state-&gt;lfsr_state &lt;&lt; 8);
-	
-    state-&gt;lfsr_state = (uint16_t) nstate;
-
-    return nstate;
-}
-
-static void coeff_get (a52_state_t * state, sample_t * coeff,
-		       expbap_t * expbap, quantizer_t * quantizer,
-		       sample_t level, int dither, int end)
-{
-    int i;
-    uint8_t * exp;
-    int8_t * bap;
-    sample_t factor[25];
-
-    for (i = 0; i &lt;= 24; i++)
-	factor[i] = scale_factor[i] * level;
-
-    exp = expbap-&gt;exp;
-    bap = expbap-&gt;bap;
-
-    for (i = 0; i &lt; end; i++) {
-	int bapi;
-
-	bapi = bap[i];
-	switch (bapi) {
-	case 0:
-	    if (dither) {
-		coeff[i] = dither_gen (state) * LEVEL_3DB * factor[exp[i]];
-		continue;
-	    } else {
-		coeff[i] = 0;
-		continue;
-	    }
-
-	case -1:
-	    if (quantizer-&gt;q1_ptr &gt;= 0) {
-		coeff[i] = quantizer-&gt;q1[quantizer-&gt;q1_ptr--] * factor[exp[i]];
-		continue;
-	    } else {
-		int code;
-
-		code = bitstream_get (state, 5);
-
-		quantizer-&gt;q1_ptr = 1;
-		quantizer-&gt;q1[0] = q_1_2[code];
-		quantizer-&gt;q1[1] = q_1_1[code];
-		coeff[i] = q_1_0[code] * factor[exp[i]];
-		continue;
-	    }
-
-	case -2:
-	    if (quantizer-&gt;q2_ptr &gt;= 0) {
-		coeff[i] = quantizer-&gt;q2[quantizer-&gt;q2_ptr--] * factor[exp[i]];
-		continue;
-	    } else {
-		int code;
-
-		code = bitstream_get (state, 7);
-
-		quantizer-&gt;q2_ptr = 1;
-		quantizer-&gt;q2[0] = q_2_2[code];
-		quantizer-&gt;q2[1] = q_2_1[code];
-		coeff[i] = q_2_0[code] * factor[exp[i]];
-		continue;
-	    }
-
-	case 3:
-	    coeff[i] = q_3[bitstream_get (state, 3)] * factor[exp[i]];
-	    continue;
-
-	case -3:
-	    if (quantizer-&gt;q4_ptr == 0) {
-		quantizer-&gt;q4_ptr = -1;
-		coeff[i] = quantizer-&gt;q4 * factor[exp[i]];
-		continue;
-	    } else {
-		int code;
-
-		code = bitstream_get (state, 7);
-
-		quantizer-&gt;q4_ptr = 0;
-		quantizer-&gt;q4 = q_4_1[code];
-		coeff[i] = q_4_0[code] * factor[exp[i]];
-		continue;
-	    }
-
-	case 4:
-	    coeff[i] = q_5[bitstream_get (state, 4)] * factor[exp[i]];
-	    continue;
-
-	default:
-	    coeff[i] = ((bitstream_get_2 (state, bapi) &lt;&lt; (16 - bapi)) *
-			  factor[exp[i]]);
-	}
-    }
-}
-
-static void coeff_get_coupling (a52_state_t * state, int nfchans,
-				sample_t * coeff, sample_t (* samples)[256],
-				quantizer_t * quantizer, uint8_t dithflag[5])
-{
-    int cplbndstrc, bnd, i, i_end, ch;
-    uint8_t * exp;
-    int8_t * bap;
-    sample_t cplco[5];
-
-    exp = state-&gt;cpl_expbap.exp;
-    bap = state-&gt;cpl_expbap.bap;
-    bnd = 0;
-    cplbndstrc = state-&gt;cplbndstrc;
-    i = state-&gt;cplstrtmant;
-    while (i &lt; state-&gt;cplendmant) {
-	i_end = i + 12;
-	while (cplbndstrc &amp; 1) {
-	    cplbndstrc &gt;&gt;= 1;
-	    i_end += 12;
-	}
-	cplbndstrc &gt;&gt;= 1;
-	for (ch = 0; ch &lt; nfchans; ch++)
-	    cplco[ch] = state-&gt;cplco[ch][bnd] * coeff[ch];
-	bnd++;
-
-	while (i &lt; i_end) {
-	    sample_t cplcoeff;
-	    int bapi;
-
-	    bapi = bap[i];
-	    switch (bapi) {
-	    case 0:
-		cplcoeff = LEVEL_3DB * scale_factor[exp[i]];
-		for (ch = 0; ch &lt; nfchans; ch++)
-		    if ((state-&gt;chincpl &gt;&gt; ch) &amp; 1) {
-			if (dithflag[ch])
-			    samples[ch][i] = (cplcoeff * cplco[ch] *
-					      dither_gen (state));
-			else
-			    samples[ch][i] = 0;
-		    }
-		i++;
-		continue;
-
-	    case -1:
-		if (quantizer-&gt;q1_ptr &gt;= 0) {
-		    cplcoeff = quantizer-&gt;q1[quantizer-&gt;q1_ptr--];
-		    break;
-		} else {
-		    int code;
-
-		    code = bitstream_get (state, 5);
-
-		    quantizer-&gt;q1_ptr = 1;
-		    quantizer-&gt;q1[0] = q_1_2[code];
-		    quantizer-&gt;q1[1] = q_1_1[code];
-		    cplcoeff = q_1_0[code];
-		    break;
-		}
-
-	    case -2:
-		if (quantizer-&gt;q2_ptr &gt;= 0) {
-		    cplcoeff = quantizer-&gt;q2[quantizer-&gt;q2_ptr--];
-		    break;
-		} else {
-		    int code;
-
-		    code = bitstream_get (state, 7);
-
-		    quantizer-&gt;q2_ptr = 1;
-		    quantizer-&gt;q2[0] = q_2_2[code];
-		    quantizer-&gt;q2[1] = q_2_1[code];
-		    cplcoeff = q_2_0[code];
-		    break;
-		}
-
-	    case 3:
-		cplcoeff = q_3[bitstream_get (state, 3)];
-		break;
-
-	    case -3:
-		if (quantizer-&gt;q4_ptr == 0) {
-		    quantizer-&gt;q4_ptr = -1;
-		    cplcoeff = quantizer-&gt;q4;
-		    break;
-		} else {
-		    int code;
-
-		    code = bitstream_get (state, 7);
-
-		    quantizer-&gt;q4_ptr = 0;
-		    quantizer-&gt;q4 = q_4_1[code];
-		    cplcoeff = q_4_0[code];
-		    break;
-		}
-
-	    case 4:
-		cplcoeff = q_5[bitstream_get (state, 4)];
-		break;
-
-	    default:
-		cplcoeff = bitstream_get_2 (state, bapi) &lt;&lt; (16 - bapi);
-	    }
-
-	    cplcoeff *= scale_factor[exp[i]];
-	    for (ch = 0; ch &lt; nfchans; ch++)
-		if ((state-&gt;chincpl &gt;&gt; ch) &amp; 1)
-		    samples[ch][i] = cplcoeff * cplco[ch];
-	    i++;
-	}
-    }
-}
-
-int a52_block (a52_state_t * state)
-{
-    static const uint8_t nfchans_tbl[] = {2, 1, 2, 3, 3, 4, 4, 5, 1, 1, 2};
-    static int rematrix_band[4] = {25, 37, 61, 253};
-    int i, nfchans, chaninfo;
-    uint8_t cplexpstr, chexpstr[5], lfeexpstr, do_bit_alloc, done_cpl;
-    uint8_t blksw[5], dithflag[5];
-    sample_t coeff[5];
-    int chanbias;
-    quantizer_t quantizer;
-    sample_t * samples;
-
-    nfchans = nfchans_tbl[state-&gt;acmod];
-
-    for (i = 0; i &lt; nfchans; i++)
-	blksw[i] = bitstream_get (state, 1);
-
-    for (i = 0; i &lt; nfchans; i++)
-	dithflag[i] = bitstream_get (state, 1);
-
-    chaninfo = !state-&gt;acmod;
-    do {
-	if (bitstream_get (state, 1)) {	/* dynrnge */
-	    int dynrng;
-
-	    dynrng = bitstream_get_2 (state, 8);
-	    if (state-&gt;dynrnge) {
-		sample_t range;
-
-		range = ((((dynrng &amp; 0x1f) | 0x20) &lt;&lt; 13) *
-			 scale_factor[3 - (dynrng &gt;&gt; 5)]);
-		if (state-&gt;dynrngcall)
-		    range = state-&gt;dynrngcall (range, state-&gt;dynrngdata);
-		state-&gt;dynrng = state-&gt;level * range;
-	    }
-	}
-    } while (chaninfo--);
-
-    if (bitstream_get (state, 1)) {	/* cplstre */
-	state-&gt;chincpl = 0;
-	if (bitstream_get (state, 1)) {	/* cplinu */
-	    static uint8_t bndtab[16] = {31, 35, 37, 39, 41, 42, 43, 44,
-					 45, 45, 46, 46, 47, 47, 48, 48};
-	    int cplbegf;
-	    int cplendf;
-	    int ncplsubnd;
-
-	    for (i = 0; i &lt; nfchans; i++)
-		state-&gt;chincpl |= bitstream_get (state, 1) &lt;&lt; i;
-	    switch (state-&gt;acmod) {
-	    case 0: case 1:
-		return 1;
-	    case 2:
-		state-&gt;phsflginu = bitstream_get (state, 1);
-	    }
-	    cplbegf = bitstream_get (state, 4);
-	    cplendf = bitstream_get (state, 4);
-
-	    if (cplendf + 3 - cplbegf &lt; 0)
-		return 1;
-	    state-&gt;ncplbnd = ncplsubnd = cplendf + 3 - cplbegf;
-	    state-&gt;cplstrtbnd = bndtab[cplbegf];
-	    state-&gt;cplstrtmant = cplbegf * 12 + 37;
-	    state-&gt;cplendmant = cplendf * 12 + 73;
-
-	    state-&gt;cplbndstrc = 0;
-	    for (i = 0; i &lt; ncplsubnd - 1; i++)
-		if (bitstream_get (state, 1)) {
-		    state-&gt;cplbndstrc |= 1 &lt;&lt; i;
-		    state-&gt;ncplbnd--;
-		}
-	}
-    }
-
-    if (state-&gt;chincpl) {	/* cplinu */
-	int j, cplcoe;
-
-	cplcoe = 0;
-	for (i = 0; i &lt; nfchans; i++)
-	    if ((state-&gt;chincpl) &gt;&gt; i &amp; 1)
-		if (bitstream_get (state, 1)) {	/* cplcoe */
-		    int mstrcplco, cplcoexp, cplcomant;
-
-		    cplcoe = 1;
-		    mstrcplco = 3 * bitstream_get (state, 2);
-		    for (j = 0; j &lt; state-&gt;ncplbnd; j++) {
-			cplcoexp = bitstream_get (state, 4);
-			cplcomant = bitstream_get (state, 4);
-			if (cplcoexp == 15)
-			    cplcomant &lt;&lt;= 14;
-			else
-			    cplcomant = (cplcomant | 0x10) &lt;&lt; 13;
-			state-&gt;cplco[i][j] =
-			    cplcomant * scale_factor[cplcoexp + mstrcplco];
-		    }
-		}
-	if ((state-&gt;acmod == 2) &amp;&amp; state-&gt;phsflginu &amp;&amp; cplcoe)
-	    for (j = 0; j &lt; state-&gt;ncplbnd; j++)
-		if (bitstream_get (state, 1))	/* phsflg */
-		    state-&gt;cplco[1][j] = -state-&gt;cplco[1][j];
-    }
-
-    if ((state-&gt;acmod == 2) &amp;&amp; (bitstream_get (state, 1))) {	/* rematstr */
-	int end;
-
-	state-&gt;rematflg = 0;
-	end = (state-&gt;chincpl) ? state-&gt;cplstrtmant : 253;	/* cplinu */
-	i = 0;
-	do
-	    state-&gt;rematflg |= bitstream_get (state, 1) &lt;&lt; i;
-	while (rematrix_band[i++] &lt; end);
-    }
-
-    cplexpstr = EXP_REUSE;
-    lfeexpstr = EXP_REUSE;
-    if (state-&gt;chincpl)	/* cplinu */
-	cplexpstr = bitstream_get (state, 2);
-    for (i = 0; i &lt; nfchans; i++)
-	chexpstr[i] = bitstream_get (state, 2);
-    if (state-&gt;lfeon) 
-	lfeexpstr = bitstream_get (state, 1);
-
-    for (i = 0; i &lt; nfchans; i++)
-	if (chexpstr[i] != EXP_REUSE) {
-	    if ((state-&gt;chincpl &gt;&gt; i) &amp; 1)
-		state-&gt;endmant[i] = state-&gt;cplstrtmant;
-	    else {
-		int chbwcod;
-
-		chbwcod = bitstream_get (state, 6);
-		if (chbwcod &gt; 60)
-		    return 1;
-		state-&gt;endmant[i] = chbwcod * 3 + 73;
-	    }
-	}
-
-    do_bit_alloc = 0;
-
-    if (cplexpstr != EXP_REUSE) {
-	int cplabsexp, ncplgrps;
-
-	do_bit_alloc = 64;
-	ncplgrps = ((state-&gt;cplendmant - state-&gt;cplstrtmant) /
-		    (3 &lt;&lt; (cplexpstr - 1)));
-	cplabsexp = bitstream_get (state, 4) &lt;&lt; 1;
-	if (parse_exponents (state, cplexpstr, ncplgrps, cplabsexp,
-			     state-&gt;cpl_expbap.exp + state-&gt;cplstrtmant))
-	    return 1;
-    }
-    for (i = 0; i &lt; nfchans; i++)
-	if (chexpstr[i] != EXP_REUSE) {
-	    int grp_size, nchgrps;
-
-	    do_bit_alloc |= 1 &lt;&lt; i;
-	    grp_size = 3 &lt;&lt; (chexpstr[i] - 1);
-	    nchgrps = (state-&gt;endmant[i] + grp_size - 4) / grp_size;
-	    state-&gt;fbw_expbap[i].exp[0] = bitstream_get (state, 4);
-	    if (parse_exponents (state, chexpstr[i], nchgrps,
-				 state-&gt;fbw_expbap[i].exp[0],
-				 state-&gt;fbw_expbap[i].exp + 1))
-		return 1;
-	    bitstream_get (state, 2);	/* gainrng */
-	}
-    if (lfeexpstr != EXP_REUSE) {
-	do_bit_alloc |= 32;
-	state-&gt;lfe_expbap.exp[0] = bitstream_get (state, 4);
-	if (parse_exponents (state, lfeexpstr, 2, state-&gt;lfe_expbap.exp[0],
-			     state-&gt;lfe_expbap.exp + 1))
-	    return 1;
-    }
-
-    if (bitstream_get (state, 1)) {	/* baie */
-	do_bit_alloc = -1;
-	state-&gt;bai = bitstream_get (state, 11);
-    }
-    if (bitstream_get (state, 1)) {	/* snroffste */
-	do_bit_alloc = -1;
-	state-&gt;csnroffst = bitstream_get (state, 6);
-	if (state-&gt;chincpl)	/* cplinu */
-	    state-&gt;cplba.bai = bitstream_get (state, 7);
-	for (i = 0; i &lt; nfchans; i++)
-	    state-&gt;ba[i].bai = bitstream_get (state, 7);
-	if (state-&gt;lfeon)
-	    state-&gt;lfeba.bai = bitstream_get (state, 7);
-    }
-    if ((state-&gt;chincpl) &amp;&amp; (bitstream_get (state, 1))) { /* cplleake */
-	do_bit_alloc |= 64;
-	state-&gt;cplfleak = 9 - bitstream_get (state, 3);
-	state-&gt;cplsleak = 9 - bitstream_get (state, 3);
-    }
-
-    if (bitstream_get (state, 1)) {	/* deltbaie */
-	do_bit_alloc = -1;
-	if (state-&gt;chincpl)	/* cplinu */
-	    state-&gt;cplba.deltbae = bitstream_get (state, 2);
-	for (i = 0; i &lt; nfchans; i++)
-	    state-&gt;ba[i].deltbae = bitstream_get (state, 2);
-	if (state-&gt;chincpl &amp;&amp;	/* cplinu */
-	    (state-&gt;cplba.deltbae == DELTA_BIT_NEW) &amp;&amp;
-	    parse_deltba (state, state-&gt;cplba.deltba))
-	    return 1;
-	for (i = 0; i &lt; nfchans; i++)
-	    if ((state-&gt;ba[i].deltbae == DELTA_BIT_NEW) &amp;&amp;
-		parse_deltba (state, state-&gt;ba[i].deltba))
-		return 1;
-    }
-
-    if (do_bit_alloc) {
-	if (zero_snr_offsets (nfchans, state)) {
-	    memset (state-&gt;cpl_expbap.bap, 0, sizeof (state-&gt;cpl_expbap.bap));
-	    for (i = 0; i &lt; nfchans; i++)
-		memset (state-&gt;fbw_expbap[i].bap, 0,
-			sizeof (state-&gt;fbw_expbap[i].bap));
-	    memset (state-&gt;lfe_expbap.bap, 0, sizeof (state-&gt;lfe_expbap.bap));
-	} else {
-	    if (state-&gt;chincpl &amp;&amp; (do_bit_alloc &amp; 64))	/* cplinu */
-		a52_bit_allocate (state, &amp;state-&gt;cplba, state-&gt;cplstrtbnd,
-				  state-&gt;cplstrtmant, state-&gt;cplendmant,
-				  state-&gt;cplfleak &lt;&lt; 8, state-&gt;cplsleak &lt;&lt; 8,
-				  &amp;state-&gt;cpl_expbap);
-	    for (i = 0; i &lt; nfchans; i++)
-		if (do_bit_alloc &amp; (1 &lt;&lt; i))
-		    a52_bit_allocate (state, state-&gt;ba + i, 0, 0,
-				      state-&gt;endmant[i], 0, 0,
-				      state-&gt;fbw_expbap +i);
-	    if (state-&gt;lfeon &amp;&amp; (do_bit_alloc &amp; 32)) {
-		state-&gt;lfeba.deltbae = DELTA_BIT_NONE;
-		a52_bit_allocate (state, &amp;state-&gt;lfeba, 0, 0, 7, 0, 0,
-				  &amp;state-&gt;lfe_expbap);
-	    }
-	}
-    }
-
-    if (bitstream_get (state, 1)) {	/* skiple */
-	i = bitstream_get (state, 9);	/* skipl */
-	while (i--)
-	    bitstream_get (state, 8);
-    }
-
-    samples = state-&gt;samples;
-    if (state-&gt;output &amp; A52_LFE)
-	samples += 256;	/* shift for LFE channel */
-
-    chanbias = a52_downmix_coeff (coeff, state-&gt;acmod, state-&gt;output,
-				  state-&gt;dynrng, state-&gt;clev, state-&gt;slev);
-
-    quantizer.q1_ptr = quantizer.q2_ptr = quantizer.q4_ptr = -1;
-    done_cpl = 0;
-
-    for (i = 0; i &lt; nfchans; i++) {
-	int j;
-
-	coeff_get (state, samples + 256 * i, state-&gt;fbw_expbap +i, &amp;quantizer,
-		   coeff[i], dithflag[i], state-&gt;endmant[i]);
-
-	if ((state-&gt;chincpl &gt;&gt; i) &amp; 1) {
-	    if (!done_cpl) {
-		done_cpl = 1;
-		coeff_get_coupling (state, nfchans, coeff,
-				    (sample_t (*)[256])samples, &amp;quantizer,
-				    dithflag);
-	    }
-	    j = state-&gt;cplendmant;
-	} else
-	    j = state-&gt;endmant[i];
-	do
-	    (samples + 256 * i)[j] = 0;
-	while (++j &lt; 256);
-    }
-
-    if (state-&gt;acmod == 2) {
-	int j, end, band, rematflg;
-
-	end = ((state-&gt;endmant[0] &lt; state-&gt;endmant[1]) ?
-	       state-&gt;endmant[0] : state-&gt;endmant[1]);
-
-	i = 0;
-	j = 13;
-	rematflg = state-&gt;rematflg;
-	do {
-	    if (! (rematflg &amp; 1)) {
-		rematflg &gt;&gt;= 1;
-		j = rematrix_band[i++];
-		continue;
-	    }
-	    rematflg &gt;&gt;= 1;
-	    band = rematrix_band[i++];
-	    if (band &gt; end)
-		band = end;
-	    do {
-		sample_t tmp0, tmp1;
-
-		tmp0 = samples[j];
-		tmp1 = (samples+256)[j];
-		samples[j] = tmp0 + tmp1;
-		(samples+256)[j] = tmp0 - tmp1;
-	    } while (++j &lt; band);
-	} while (j &lt; end);
-    }
-
-    if (state-&gt;lfeon) {
-	if (state-&gt;output &amp; A52_LFE) {
-	    coeff_get (state, samples - 256, &amp;state-&gt;lfe_expbap, &amp;quantizer,
-		       state-&gt;dynrng, 0, 7);
-	    for (i = 7; i &lt; 256; i++)
-		(samples-256)[i] = 0;
-	    a52_imdct_512 (samples - 256, samples + 1536 - 256, state-&gt;bias);
-	} else {
-	    /* just skip the LFE coefficients */
-	    coeff_get (state, samples + 1280, &amp;state-&gt;lfe_expbap, &amp;quantizer,
-		       0, 0, 7);
-	}
-    }
-
-    i = 0;
-    if (nfchans_tbl[state-&gt;output &amp; A52_CHANNEL_MASK] &lt; nfchans)
-	for (i = 1; i &lt; nfchans; i++)
-	    if (blksw[i] != blksw[0])
-		break;
-
-    if (i &lt; nfchans) {
-	if (state-&gt;downmixed) {
-	    state-&gt;downmixed = 0;
-	    a52_upmix (samples + 1536, state-&gt;acmod, state-&gt;output);
-	}
-
-	for (i = 0; i &lt; nfchans; i++) {
-	    sample_t bias;
-
-	    bias = 0;
-	    if (!(chanbias &amp; (1 &lt;&lt; i)))
-		bias = state-&gt;bias;
-
-	    if (coeff[i]) {
-		if (blksw[i])
-		    a52_imdct_256 (samples + 256 * i, samples + 1536 + 256 * i,
-				   bias);
-		else 
-		    a52_imdct_512 (samples + 256 * i, samples + 1536 + 256 * i,
-				   bias);
-	    } else {
-		int j;
-
-		for (j = 0; j &lt; 256; j++)
-		    (samples + 256 * i)[j] = bias;
-	    }
-	}
-
-	a52_downmix (samples, state-&gt;acmod, state-&gt;output, state-&gt;bias,
-		     state-&gt;clev, state-&gt;slev);
-    } else {
-	nfchans = nfchans_tbl[state-&gt;output &amp; A52_CHANNEL_MASK];
-
-	a52_downmix (samples, state-&gt;acmod, state-&gt;output, 0,
-		     state-&gt;clev, state-&gt;slev);
-
-	if (!state-&gt;downmixed) {
-	    state-&gt;downmixed = 1;
-	    a52_downmix (samples + 1536, state-&gt;acmod, state-&gt;output, 0,
-			 state-&gt;clev, state-&gt;slev);
-	}
-
-	if (blksw[0])
-	    for (i = 0; i &lt; nfchans; i++)
-		a52_imdct_256 (samples + 256 * i, samples + 1536 + 256 * i,
-			       state-&gt;bias);
-	else 
-	    for (i = 0; i &lt; nfchans; i++)
-		a52_imdct_512 (samples + 256 * i, samples + 1536 + 256 * i,
-			       state-&gt;bias);
-    }
-
-    return 0;
-}
-
-void a52_free (a52_state_t * state)
-{
-    free (state-&gt;samples);
-    free (state);
-}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/tables.h
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/tables.h	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/tables.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,246 +0,0 @@
-/*
- * tables.h
- * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
- * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
- *
- * This file is part of a52dec, a free ATSC A-52 stream decoder.
- * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
- *
- * a52dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * a52dec is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-static const int8_t exp_1[128] = {
-    -2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,
-    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-    25,25,25
-};
-static const int8_t exp_2[128] = {
-    -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
-    -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
-    -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
-    -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
-    -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
-    25,25,25
-};
-static const int8_t exp_3[128] = {
-    -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,
-    -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,
-    -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,
-    -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,
-    -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,
-    25,25,25
-};
-
-#define Q0 ((-2 &lt;&lt; 15) / 3.0)
-#define Q1 (0)
-#define Q2 ((2 &lt;&lt; 15) / 3.0)
-
-static const sample_t q_1_0[32] = {
-    Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,
-    Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,
-    Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,
-    0,0,0,0,0
-};
-
-static const sample_t q_1_1[32] = {
-    Q0,Q0,Q0,Q1,Q1,Q1,Q2,Q2,Q2,
-    Q0,Q0,Q0,Q1,Q1,Q1,Q2,Q2,Q2,
-    Q0,Q0,Q0,Q1,Q1,Q1,Q2,Q2,Q2,
-    0,0,0,0,0
-};
-
-static const sample_t q_1_2[32] = {
-    Q0,Q1,Q2,Q0,Q1,Q2,Q0,Q1,Q2,
-    Q0,Q1,Q2,Q0,Q1,Q2,Q0,Q1,Q2,
-    Q0,Q1,Q2,Q0,Q1,Q2,Q0,Q1,Q2,
-    0,0,0,0,0
-};
-
-#undef Q0
-#undef Q1
-#undef Q2
-
-#define Q0 ((-4 &lt;&lt; 15) / 5.0)
-#define Q1 ((-2 &lt;&lt; 15) / 5.0)
-#define Q2 (0)
-#define Q3 ((2 &lt;&lt; 15) / 5.0)
-#define Q4 ((4 &lt;&lt; 15) / 5.0)
-
-static const sample_t q_2_0[128] = {
-    Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,
-    Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,
-    Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,
-    Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,
-    Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,
-    0,0,0
-};
-
-static const sample_t q_2_1[128] = {
-    Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
-    Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
-    Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
-    Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
-    Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
-    0,0,0
-};
-
-static const sample_t q_2_2[128] = {
-    Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
-    Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
-    Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
-    Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
-    Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
-    0,0,0
-};
-
-#undef Q0
-#undef Q1
-#undef Q2
-#undef Q3
-#undef Q4
-
-static const sample_t q_3[8] = {
-    (-6 &lt;&lt; 15)/7.0, (-4 &lt;&lt; 15)/7.0, (-2 &lt;&lt; 15)/7.0, 0,
-    ( 2 &lt;&lt; 15)/7.0, ( 4 &lt;&lt; 15)/7.0, ( 6 &lt;&lt; 15)/7.0, 0
-};
-
-#define Q0 ((-10 &lt;&lt; 15) / 11.0)
-#define Q1 ((-8 &lt;&lt; 15) / 11.0)
-#define Q2 ((-6 &lt;&lt; 15) / 11.0)
-#define Q3 ((-4 &lt;&lt; 15) / 11.0)
-#define Q4 ((-2 &lt;&lt; 15) / 11.0)
-#define Q5 (0)
-#define Q6 ((2 &lt;&lt; 15) / 11.0)
-#define Q7 ((4 &lt;&lt; 15) / 11.0)
-#define Q8 ((6 &lt;&lt; 15) / 11.0)
-#define Q9 ((8 &lt;&lt; 15) / 11.0)
-#define QA ((10 &lt;&lt; 15) / 11.0)
-
-static const sample_t q_4_0[128] = {
-    Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0,
-    Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1,
-    Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2,
-    Q3, Q3, Q3, Q3, Q3, Q3, Q3, Q3, Q3, Q3, Q3,
-    Q4, Q4, Q4, Q4, Q4, Q4, Q4, Q4, Q4, Q4, Q4,
-    Q5, Q5, Q5, Q5, Q5, Q5, Q5, Q5, Q5, Q5, Q5,
-    Q6, Q6, Q6, Q6, Q6, Q6, Q6, Q6, Q6, Q6, Q6,
-    Q7, Q7, Q7, Q7, Q7, Q7, Q7, Q7, Q7, Q7, Q7,
-    Q8, Q8, Q8, Q8, Q8, Q8, Q8, Q8, Q8, Q8, Q8,
-    Q9, Q9, Q9, Q9, Q9, Q9, Q9, Q9, Q9, Q9, Q9,
-    QA, QA, QA, QA, QA, QA, QA, QA, QA, QA, QA,
-    0,  0,  0,  0,  0,  0,  0
-};
-
-static const sample_t q_4_1[128] = {
-    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
-    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
-    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
-    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
-    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
-    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
-    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
-    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
-    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
-    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
-    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
-    0,  0,  0,  0,  0,  0,  0
-};
-
-#undef Q0
-#undef Q1
-#undef Q2
-#undef Q3
-#undef Q4
-#undef Q5
-#undef Q6
-#undef Q7
-#undef Q8
-#undef Q9
-#undef QA
-
-static const sample_t q_5[16] = {
-    (-14 &lt;&lt; 15)/15.0,(-12 &lt;&lt; 15)/15.0,(-10 &lt;&lt; 15)/15.0,
-    ( -8 &lt;&lt; 15)/15.0,( -6 &lt;&lt; 15)/15.0,( -4 &lt;&lt; 15)/15.0,
-    ( -2 &lt;&lt; 15)/15.0,   0            ,(  2 &lt;&lt; 15)/15.0,
-    (  4 &lt;&lt; 15)/15.0,(  6 &lt;&lt; 15)/15.0,(  8 &lt;&lt; 15)/15.0,
-    ( 10 &lt;&lt; 15)/15.0,( 12 &lt;&lt; 15)/15.0,( 14 &lt;&lt; 15)/15.0,
-    0
-};
-
-static const sample_t scale_factor[25] = {
-    0.000030517578125,
-    0.0000152587890625,
-    0.00000762939453125,
-    0.000003814697265625,
-    0.0000019073486328125,
-    0.00000095367431640625,
-    0.000000476837158203125,
-    0.0000002384185791015625,
-    0.00000011920928955078125,
-    0.000000059604644775390625,
-    0.0000000298023223876953125,
-    0.00000001490116119384765625,
-    0.000000007450580596923828125,
-    0.0000000037252902984619140625,
-    0.00000000186264514923095703125,
-    0.000000000931322574615478515625,
-    0.0000000004656612873077392578125,
-    0.00000000023283064365386962890625,
-    0.000000000116415321826934814453125,
-    0.0000000000582076609134674072265625,
-    0.00000000002910383045673370361328125,
-    0.000000000014551915228366851806640625,
-    0.0000000000072759576141834259033203125,
-    0.00000000000363797880709171295166015625,
-    0.000000000001818989403545856475830078125
-};
-
-static const uint16_t dither_lut[256] = {
-    0x0000, 0xa011, 0xe033, 0x4022, 0x6077, 0xc066, 0x8044, 0x2055,
-    0xc0ee, 0x60ff, 0x20dd, 0x80cc, 0xa099, 0x0088, 0x40aa, 0xe0bb,
-    0x21cd, 0x81dc, 0xc1fe, 0x61ef, 0x41ba, 0xe1ab, 0xa189, 0x0198,
-    0xe123, 0x4132, 0x0110, 0xa101, 0x8154, 0x2145, 0x6167, 0xc176,
-    0x439a, 0xe38b, 0xa3a9, 0x03b8, 0x23ed, 0x83fc, 0xc3de, 0x63cf,
-    0x8374, 0x2365, 0x6347, 0xc356, 0xe303, 0x4312, 0x0330, 0xa321,
-    0x6257, 0xc246, 0x8264, 0x2275, 0x0220, 0xa231, 0xe213, 0x4202,
-    0xa2b9, 0x02a8, 0x428a, 0xe29b, 0xc2ce, 0x62df, 0x22fd, 0x82ec,
-    0x8734, 0x2725, 0x6707, 0xc716, 0xe743, 0x4752, 0x0770, 0xa761,
-    0x47da, 0xe7cb, 0xa7e9, 0x07f8, 0x27ad, 0x87bc, 0xc79e, 0x678f,
-    0xa6f9, 0x06e8, 0x46ca, 0xe6db, 0xc68e, 0x669f, 0x26bd, 0x86ac,
-    0x6617, 0xc606, 0x8624, 0x2635, 0x0660, 0xa671, 0xe653, 0x4642,
-    0xc4ae, 0x64bf, 0x249d, 0x848c, 0xa4d9, 0x04c8, 0x44ea, 0xe4fb,
-    0x0440, 0xa451, 0xe473, 0x4462, 0x6437, 0xc426, 0x8404, 0x2415,
-    0xe563, 0x4572, 0x0550, 0xa541, 0x8514, 0x2505, 0x6527, 0xc536,
-    0x258d, 0x859c, 0xc5be, 0x65af, 0x45fa, 0xe5eb, 0xa5c9, 0x05d8,
-    0xae79, 0x0e68, 0x4e4a, 0xee5b, 0xce0e, 0x6e1f, 0x2e3d, 0x8e2c,
-    0x6e97, 0xce86, 0x8ea4, 0x2eb5, 0x0ee0, 0xaef1, 0xeed3, 0x4ec2,
-    0x8fb4, 0x2fa5, 0x6f87, 0xcf96, 0xefc3, 0x4fd2, 0x0ff0, 0xafe1,
-    0x4f5a, 0xef4b, 0xaf69, 0x0f78, 0x2f2d, 0x8f3c, 0xcf1e, 0x6f0f,
-    0xede3, 0x4df2, 0x0dd0, 0xadc1, 0x8d94, 0x2d85, 0x6da7, 0xcdb6,
-    0x2d0d, 0x8d1c, 0xcd3e, 0x6d2f, 0x4d7a, 0xed6b, 0xad49, 0x0d58,
-    0xcc2e, 0x6c3f, 0x2c1d, 0x8c0c, 0xac59, 0x0c48, 0x4c6a, 0xec7b,
-    0x0cc0, 0xacd1, 0xecf3, 0x4ce2, 0x6cb7, 0xcca6, 0x8c84, 0x2c95,
-    0x294d, 0x895c, 0xc97e, 0x696f, 0x493a, 0xe92b, 0xa909, 0x0918,
-    0xe9a3, 0x49b2, 0x0990, 0xa981, 0x89d4, 0x29c5, 0x69e7, 0xc9f6,
-    0x0880, 0xa891, 0xe8b3, 0x48a2, 0x68f7, 0xc8e6, 0x88c4, 0x28d5,
-    0xc86e, 0x687f, 0x285d, 0x884c, 0xa819, 0x0808, 0x482a, 0xe83b,
-    0x6ad7, 0xcac6, 0x8ae4, 0x2af5, 0x0aa0, 0xaab1, 0xea93, 0x4a82,
-    0xaa39, 0x0a28, 0x4a0a, 0xea1b, 0xca4e, 0x6a5f, 0x2a7d, 0x8a6c,
-    0x4b1a, 0xeb0b, 0xab29, 0x0b38, 0x2b6d, 0x8b7c, 0xcb5e, 0x6b4f,
-    0x8bf4, 0x2be5, 0x6bc7, 0xcbd6, 0xeb83, 0x4b92, 0x0bb0, 0xaba1
-};

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/CMakeLists.txt	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/CMakeLists.txt	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1,7 +1,6 @@
 subdirs (PREORDER ADM_lavcodec)
 subdirs (PREORDER ADM_lavformat)
 subdirs (PREORDER ADM_lavutil)
-subdirs (PREORDER ADM_liba52)
 subdirs (PREORDER ADM_libMpeg2Dec)
 subdirs (PREORDER ADM_libmpeg2enc)
 subdirs (PREORDER ADM_libswscale)

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_ad_a52.cpp (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_codecac3.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_audiocodec/ADM_codecac3.cpp	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_ad_a52.cpp	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,220 @@
+/***************************************************************************
+                          ADM_codecac3.cpp  -  description
+                             -------------------
+    begin                : Fri May 31 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_ad_plugin.h&quot;
+#include &quot;ADM_audiofilter/audiofilter_channel_route.h&quot;
+#ifdef USE_AC3
+extern &quot;C&quot; {
+#include &quot;ADM_liba52/a52.h&quot;
+#include &quot;ADM_liba52/mm_accel.h&quot;
+};
+
+#define AC3_HANDLE ((a52_state_t *)ac3_handle)
+#define ADM_AC3_BUFFER (50000*2)
+class ADM_AudiocodecAC3 : public     ADM_Audiocodec
+{
+	protected:
+		void *ac3_handle;
+		void *ac3_sample;
+		uint32_t _downmix;
+
+	public:
+		ADM_AudiocodecAC3(uint32_t fourcc, WAVHeader *info,uint32_t extraLength,uint8_t *extraDatab);
+		virtual	~ADM_AudiocodecAC3();
+		virtual	uint8_t beginDecompress(void);
+		virtual	uint8_t endDecompress(void);
+		virtual	uint8_t run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut);
+		virtual	uint8_t isCompressed(void) {return 1;}
+		virtual	uint8_t isDecompressable(void) {return 1;}
+
+   };
+// Supported formats + declare our plugin
+//*******************************************************
+   uint32_t Formats[]={WAV_AC3};
+   DECLARE_AUDIO_DECODER(ADM_AudiocodecAC3,						// Class
+		   	0,0,1, 												// Major, minor,patch 
+		   	Formats, 											// Supported formats
+		   	&quot;LibAC3 decoder plugin for avidemux (c) Mean\n&quot;); 	// Desc
+   //********************************************************
+
+ADM_AudiocodecAC3::ADM_AudiocodecAC3( uint32_t fourcc, WAVHeader *info,uint32_t extraLength,uint8_t *extraData)
+		:   ADM_Audiocodec(fourcc)
+{
+    int flags=0;
+    ADM_assert(fourcc==WAV_AC3);
+    ac3_handle=NULL;
+    ac3_sample=NULL;
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+#define CHK(x,y) if(CpuCaps::has##x()) flags|=MM_ACCEL_X86_##y;
+    CHK(MMX,MMX);
+    CHK(3DNOW,3DNOW);
+    CHK(MMXEXT,MMXEXT);
+#endif
+    
+    ac3_handle=(void *)a52_init(flags);
+    if(!ac3_handle)
+    {
+        printf(&quot;Cannot init a52\n&quot;);
+        ADM_assert(0);   
+    }
+    ac3_sample=(sample_t *)a52_samples(AC3_HANDLE);
+    if(!ac3_sample)
+    {
+        printf(&quot;Cannot init a52 sample\n&quot;);
+        ADM_assert(0);   
+    }
+        _downmix=0;
+      _wavHeader = info;
+      ADM_assert(_wavHeader);
+}
+
+ADM_AudiocodecAC3::~ADM_AudiocodecAC3( )
+{
+    if(ac3_handle)
+    {
+        a52_free(AC3_HANDLE);
+        ac3_handle=NULL;
+        ac3_sample=NULL;
+    }
+}
+
+uint8_t ADM_AudiocodecAC3::beginDecompress( void )
+{
+		return 1;
+}
+
+uint8_t ADM_AudiocodecAC3::endDecompress( void )
+{
+    return 1;
+}
+
+uint8_t ADM_AudiocodecAC3::run(uint8_t *inptr, uint32_t nbIn, float *outptr,   uint32_t *nbOut)
+{
+    uint32_t avail;
+    uint32_t length;
+    int flags = 0, samprate = 0, bitrate = 0;
+    uint8_t chan = _wavHeader-&gt;channels;
+    *nbOut=0;
+
+    //  Ready to decode
+    while(nbIn)
+    {
+        if(nbIn&lt;7)
+        {
+            if(nbIn)
+                printf(&quot;[a52]: no data to decode avail %u\n&quot;,nbIn);
+            break;
+        }
+        length = a52_syncinfo(inptr, &amp;flags, &amp;samprate, &amp;bitrate);
+        if(length==0)
+        {
+            printf(&quot;[a52] No startcode found\n&quot;);
+            break;
+        }
+        if(length&gt;nbIn)
+        {
+            // not enough data
+            break;
+        }
+
+	if (ch_route.mode &lt; 1) {
+		CHANNEL_TYPE *p_ch_type = ch_route.input_type;
+		if (flags &amp; A52_LFE) {
+			*(p_ch_type++) = CH_LFE;
+		}
+		switch (flags &amp; A52_CHANNEL_MASK) {
+			case A52_MONO:
+				*(p_ch_type++) = CH_MONO;
+			break;
+			case A52_STEREO:
+			case A52_DOLBY:
+				*(p_ch_type++) = CH_FRONT_LEFT;
+				*(p_ch_type++) = CH_FRONT_RIGHT;
+			break;
+			case A52_3F:
+				*(p_ch_type++) = CH_FRONT_LEFT;
+				*(p_ch_type++) = CH_FRONT_CENTER;
+				*(p_ch_type++) = CH_FRONT_RIGHT;
+			break;
+			case A52_2F1R:
+				*(p_ch_type++) = CH_FRONT_LEFT;
+				*(p_ch_type++) = CH_FRONT_RIGHT;
+				*(p_ch_type++) = CH_REAR_CENTER;
+			break;
+			case A52_3F1R:
+				*(p_ch_type++) = CH_FRONT_LEFT;
+				*(p_ch_type++) = CH_FRONT_CENTER;
+				*(p_ch_type++) = CH_FRONT_RIGHT;
+				*(p_ch_type++) = CH_REAR_CENTER;
+			break;
+			case A52_2F2R:
+				*(p_ch_type++) = CH_FRONT_LEFT;
+				*(p_ch_type++) = CH_FRONT_RIGHT;
+				*(p_ch_type++) = CH_REAR_LEFT;
+				*(p_ch_type++) = CH_REAR_RIGHT;
+			break;
+			case A52_3F2R:
+				*(p_ch_type++) = CH_FRONT_LEFT;
+				*(p_ch_type++) = CH_FRONT_CENTER;
+				*(p_ch_type++) = CH_FRONT_RIGHT;
+				*(p_ch_type++) = CH_REAR_LEFT;
+				*(p_ch_type++) = CH_REAR_RIGHT;
+			break;
+			default:
+				ADM_assert(0);
+		}
+	}
+
+        sample_t level = 1, bias = 0;
+
+        if (a52_frame(AC3_HANDLE, inptr, &amp;flags, &amp;level, bias))
+        {
+            printf(&quot;\n A52_frame failed!&quot;);
+            inptr+=length;
+            nbIn-=length;
+            *nbOut += 256 * chan * 6;
+            break;
+        };
+        inptr+=length;
+        nbIn-=length;
+        *nbOut += 256 * chan * 6;
+
+        float *cur;
+        for (int i = 0; i &lt; 6; i++) {
+                if (a52_block(AC3_HANDLE)) {
+                        printf(&quot;\n A52_block failed! on fblock :%lu&quot;, i);
+                        // in that case we silent out the chunk
+                        memset(outptr, 0, 256 * chan * sizeof(float));
+                } else {
+                        for (int k = 0; k &lt; chan; k++) {
+                                sample_t *sample=(sample_t *)ac3_sample;
+                                sample += 256 * k;
+                                cur = outptr + k;
+                                for (int j = 0; j &lt; 256; j++) {
+                                        *cur = *sample++;
+                                        cur+=chan;
+                                }
+                        }
+                }
+                outptr += chan * 256;
+        }
+    }
+    return 1; 
+
+}
+
+#endif

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/CMakeLists.txt (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/CMakeLists.txt)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/CMakeLists.txt	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/CMakeLists.txt	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,15 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_liba52)
+#
+SET(${ADM_LIB}_SRCS 
+bit_allocate.c  bitstream.c  downmix.c  imdct.c  parse.c
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+add_definitions(-fPIC)
+
+
+################################

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/Makefile.am (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/Makefile.am)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/Makefile.am	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/Makefile.am	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,10 @@
+noinst_LIBRARIES = libADM_liba52.a
+
+INCLUDES = $(all_includes) 
+
+libADM_liba52_a_METASOURCES = AUTO
+
+libADM_liba52_a_SOURCES = bitstream.c imdct.c bit_allocate.c parse.c downmix.c
+
+EXTRA_DIST = a52.h  a52_internal.h  attributes.h  bitstream.h  mm_accel.h  tables.h bit_allocate.c  bitstream.c  downmix.c  imdct.c  parse.c
+

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/a52.h (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52.h)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52.h	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/a52.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,62 @@
+/*
+ * a52.h
+ * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file is part of a52dec, a free ATSC A-52 stream decoder.
+ * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
+ *
+ * a52dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * a52dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef A52_H
+#define A52_H
+
+#ifndef LIBA52_DOUBLE
+typedef float sample_t;
+#else
+typedef double sample_t;
+#endif
+
+typedef struct a52_state_s a52_state_t;
+
+#define A52_CHANNEL 0
+#define A52_MONO 1
+#define A52_STEREO 2
+#define A52_3F 3
+#define A52_2F1R 4
+#define A52_3F1R 5
+#define A52_2F2R 6
+#define A52_3F2R 7
+#define A52_CHANNEL1 8
+#define A52_CHANNEL2 9
+#define A52_DOLBY 10
+#define A52_CHANNEL_MASK 15
+
+#define A52_LFE 16
+#define A52_ADJUST_LEVEL 32
+
+a52_state_t * a52_init (uint32_t mm_accel);
+sample_t * a52_samples (a52_state_t * state);
+int a52_syncinfo (uint8_t * buf, int * flags,
+		  int * sample_rate, int * bit_rate);
+int a52_frame (a52_state_t * state, uint8_t * buf, int * flags,
+	       sample_t * level, sample_t bias);
+void a52_dynrng (a52_state_t * state,
+		 sample_t (* call) (sample_t, void *), void * data);
+int a52_block (a52_state_t * state);
+void a52_free (a52_state_t * state);
+
+#endif /* A52_H */

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/a52_internal.h (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52_internal.h)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/a52_internal.h	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/a52_internal.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,123 @@
+/*
+ * a52_internal.h
+ * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file is part of a52dec, a free ATSC A-52 stream decoder.
+ * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
+ *
+ * a52dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * a52dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+typedef struct {
+    uint8_t bai;		/* fine SNR offset, fast gain */
+    uint8_t deltbae;		/* delta bit allocation exists */
+    int8_t deltba[50];		/* per-band delta bit allocation */
+} ba_t;
+
+typedef struct {
+    uint8_t exp[256];		/* decoded channel exponents */
+    int8_t bap[256];		/* derived channel bit allocation */
+} expbap_t;
+
+struct a52_state_s {
+    uint8_t fscod;		/* sample rate */
+    uint8_t halfrate;		/* halfrate factor */
+    uint8_t acmod;		/* coded channels */
+    uint8_t lfeon;		/* coded lfe channel */
+    sample_t clev;		/* centre channel mix level */
+    sample_t slev;		/* surround channels mix level */
+
+    int output;			/* type of output */
+    sample_t level;		/* output level */
+    sample_t bias;		/* output bias */
+
+    int dynrnge;		/* apply dynamic range */
+    sample_t dynrng;		/* dynamic range */
+    void * dynrngdata;		/* dynamic range callback funtion and data */
+    sample_t (* dynrngcall) (sample_t range, void * dynrngdata);
+
+    uint8_t chincpl;		/* channel coupled */
+    uint8_t phsflginu;		/* phase flags in use (stereo only) */
+    uint8_t cplstrtmant;	/* coupling channel start mantissa */
+    uint8_t cplendmant;		/* coupling channel end mantissa */
+    uint32_t cplbndstrc;	/* coupling band structure */
+    sample_t cplco[5][18];	/* coupling coordinates */
+
+    /* derived information */
+    uint8_t cplstrtbnd;		/* coupling start band (for bit allocation) */
+    uint8_t ncplbnd;		/* number of coupling bands */
+
+    uint8_t rematflg;		/* stereo rematrixing */
+
+    uint8_t endmant[5];		/* channel end mantissa */
+
+    uint16_t bai;		/* bit allocation information */
+
+    uint32_t * buffer_start;
+    uint16_t lfsr_state;	/* dither state */
+    uint32_t bits_left;
+    uint32_t current_word;
+
+    uint8_t csnroffst;		/* coarse SNR offset */
+    ba_t cplba;			/* coupling bit allocation parameters */
+    ba_t ba[5];			/* channel bit allocation parameters */
+    ba_t lfeba;			/* lfe bit allocation parameters */
+
+    uint8_t cplfleak;		/* coupling fast leak init */
+    uint8_t cplsleak;		/* coupling slow leak init */
+
+    expbap_t cpl_expbap;
+    expbap_t fbw_expbap[5];
+    expbap_t lfe_expbap;
+
+    sample_t * samples;
+    int downmixed;
+};
+
+#define LEVEL_PLUS6DB 2.0
+#define LEVEL_PLUS3DB 1.4142135623730951
+#define LEVEL_3DB 0.7071067811865476
+#define LEVEL_45DB 0.5946035575013605
+#define LEVEL_6DB 0.5
+
+#define LEVEL_DPL2_1 0.8165
+#define LEVEL_DPL2_2 0.5774
+
+#define EXP_REUSE (0)
+#define EXP_D15   (1)
+#define EXP_D25   (2)
+#define EXP_D45   (3)
+
+#define DELTA_BIT_REUSE (0)
+#define DELTA_BIT_NEW (1)
+#define DELTA_BIT_NONE (2)
+#define DELTA_BIT_RESERVED (3)
+
+void a52_bit_allocate (a52_state_t * state, ba_t * ba, int bndstart,
+		       int start, int end, int fastleak, int slowleak,
+		       expbap_t * expbap);
+
+int a52_downmix_init (int input, int flags, sample_t * level,
+		      sample_t clev, sample_t slev);
+int a52_downmix_coeff (sample_t * coeff, int acmod, int output, sample_t level,
+		       sample_t clev, sample_t slev);
+void a52_downmix (sample_t * samples, int acmod, int output, sample_t bias,
+		  sample_t clev, sample_t slev);
+void a52_upmix (sample_t * samples, int acmod, int output);
+
+void a52_imdct_init (uint32_t mm_accel);
+void a52_imdct_256 (sample_t * data, sample_t * delay, sample_t bias);
+void a52_imdct_512 (sample_t * data, sample_t * delay, sample_t bias);

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/attributes.h (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/attributes.h)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/attributes.h	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/attributes.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,29 @@
+/*
+ * attributes.h
+ * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file is part of a52dec, a free ATSC A-52 stream decoder.
+ * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
+ *
+ * a52dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * a52dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* use gcc attribs to align critical data structures */
+#ifdef ATTRIBUTE_ALIGNED_MAX
+#define ATTR_ALIGN(align) __attribute__ ((__aligned__ ((ATTRIBUTE_ALIGNED_MAX &lt; align) ? ATTRIBUTE_ALIGNED_MAX : align)))
+#else
+#define ATTR_ALIGN(align)
+#endif

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/bit_allocate.c (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bit_allocate.c)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bit_allocate.c	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/bit_allocate.c	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,265 @@
+/*
+ * bit_allocate.c
+ * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file is part of a52dec, a free ATSC A-52 stream decoder.
+ * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
+ *
+ * a52dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * a52dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include &quot;config.h&quot;
+
+#include &lt;inttypes.h&gt;
+
+#include &quot;a52.h&quot;
+#include &quot;a52_internal.h&quot;
+
+static int hthtab[3][50] = {
+    {0x730, 0x730, 0x7c0, 0x800, 0x820, 0x840, 0x850, 0x850, 0x860, 0x860,
+     0x860, 0x860, 0x860, 0x870, 0x870, 0x870, 0x880, 0x880, 0x890, 0x890,
+     0x8a0, 0x8a0, 0x8b0, 0x8b0, 0x8c0, 0x8c0, 0x8d0, 0x8e0, 0x8f0, 0x900,
+     0x910, 0x910, 0x910, 0x910, 0x900, 0x8f0, 0x8c0, 0x870, 0x820, 0x7e0,
+     0x7a0, 0x770, 0x760, 0x7a0, 0x7c0, 0x7c0, 0x6e0, 0x400, 0x3c0, 0x3c0},
+    {0x710, 0x710, 0x7a0, 0x7f0, 0x820, 0x830, 0x840, 0x850, 0x850, 0x860,
+     0x860, 0x860, 0x860, 0x860, 0x870, 0x870, 0x870, 0x880, 0x880, 0x880,
+     0x890, 0x890, 0x8a0, 0x8a0, 0x8b0, 0x8b0, 0x8c0, 0x8c0, 0x8e0, 0x8f0,
+     0x900, 0x910, 0x910, 0x910, 0x910, 0x900, 0x8e0, 0x8b0, 0x870, 0x820,
+     0x7e0, 0x7b0, 0x760, 0x770, 0x7a0, 0x7c0, 0x780, 0x5d0, 0x3c0, 0x3c0},
+    {0x680, 0x680, 0x750, 0x7b0, 0x7e0, 0x810, 0x820, 0x830, 0x840, 0x850,
+     0x850, 0x850, 0x860, 0x860, 0x860, 0x860, 0x860, 0x860, 0x860, 0x860,
+     0x870, 0x870, 0x870, 0x870, 0x880, 0x880, 0x880, 0x890, 0x8a0, 0x8b0,
+     0x8c0, 0x8d0, 0x8e0, 0x8f0, 0x900, 0x910, 0x910, 0x910, 0x900, 0x8f0,
+     0x8d0, 0x8b0, 0x840, 0x7f0, 0x790, 0x760, 0x7a0, 0x7c0, 0x7b0, 0x720}
+};
+
+static int8_t baptab[305] = {
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,	/* 93 padding elems */
+
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 14, 14, 14, 14, 14, 14, 14,
+    14, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10,  9,  9,  9,
+     9,  8,  8,  8,  8,  7,  7,  7,  7,  6,  6,  6,  6,  5,  5,  5,
+     5,  4,  4, -3, -3,  3,  3,  3, -2, -2, -1, -1, -1, -1, -1,  0,
+
+     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+     0,  0,  0,  0					/* 148 padding elems */
+};
+
+static int bndtab[30] = {21, 22,  23,  24,  25,  26,  27,  28,  31,  34,
+			 37, 40,  43,  46,  49,  55,  61,  67,  73,  79,
+			 85, 97, 109, 121, 133, 157, 181, 205, 229, 253};
+
+static int8_t latab[256] = {
+    -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53,
+    -52, -52, -51, -50, -49, -48, -47, -47, -46, -45, -44, -44,
+    -43, -42, -41, -41, -40, -39, -38, -38, -37, -36, -36, -35,
+    -35, -34, -33, -33, -32, -32, -31, -30, -30, -29, -29, -28,
+    -28, -27, -27, -26, -26, -25, -25, -24, -24, -23, -23, -22,
+    -22, -21, -21, -21, -20, -20, -19, -19, -19, -18, -18, -18,
+    -17, -17, -17, -16, -16, -16, -15, -15, -15, -14, -14, -14,
+    -13, -13, -13, -13, -12, -12, -12, -12, -11, -11, -11, -11,
+    -10, -10, -10, -10, -10,  -9,  -9,  -9,  -9,  -9,  -8,  -8,
+     -8,  -8,  -8,  -8,  -7,  -7,  -7,  -7,  -7,  -7,  -6,  -6,
+     -6,  -6,  -6,  -6,  -6,  -6,  -5,  -5,  -5,  -5,  -5,  -5,
+     -5,  -5,  -4,  -4,  -4,  -4,  -4,  -4,  -4,  -4,  -4,  -4,
+     -4,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,
+     -3,  -3,  -3,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,
+     -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -1,  -1,
+     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
+     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
+     -1,  -1,  -1,  -1,  -1,  -1,   0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0
+};
+
+#define UPDATE_LEAK() 		\
+do {				\
+    fastleak += fdecay;		\
+    if (fastleak &gt; psd + fgain)	\
+	fastleak = psd + fgain;	\
+    slowleak += sdecay;		\
+    if (slowleak &gt; psd + sgain)	\
+	slowleak = psd + sgain;	\
+} while (0)
+
+#define COMPUTE_MASK()				\
+do {						\
+    if (psd &gt; dbknee)				\
+	mask -= (psd - dbknee) &gt;&gt; 2;		\
+    if (mask &gt; hth [i &gt;&gt; halfrate])		\
+	mask = hth [i &gt;&gt; halfrate];		\
+    mask -= snroffset + 128 * deltba[i];	\
+    mask = (mask &gt; 0) ? 0 : ((-mask) &gt;&gt; 5);	\
+    mask -= floor;				\
+} while (0)
+
+void a52_bit_allocate (a52_state_t * state, ba_t * ba, int bndstart,
+		       int start, int end, int fastleak, int slowleak,
+		       expbap_t * expbap)
+{
+    static int slowgain[4] = {0x540, 0x4d8, 0x478, 0x410};
+    static int dbpbtab[4]  = {0xc00, 0x500, 0x300, 0x100};
+    static int floortab[8] = {0x910, 0x950, 0x990, 0x9d0,
+			      0xa10, 0xa90, 0xb10, 0x1400};
+
+    int i, j;
+    uint8_t * exp;
+    int8_t * bap;
+    int fdecay, fgain, sdecay, sgain, dbknee, floor, snroffset;
+    int psd, mask;
+    int8_t * deltba;
+    int * hth;
+    int halfrate;
+
+    halfrate = state-&gt;halfrate;
+    fdecay = (63 + 20 * ((state-&gt;bai &gt;&gt; 7) &amp; 3)) &gt;&gt; halfrate;	/* fdcycod */
+    fgain = 128 + 128 * (ba-&gt;bai &amp; 7);				/* fgaincod */
+    sdecay = (15 + 2 * (state-&gt;bai &gt;&gt; 9)) &gt;&gt; halfrate;		/* sdcycod */
+    sgain = slowgain[(state-&gt;bai &gt;&gt; 5) &amp; 3];			/* sgaincod */
+    dbknee = dbpbtab[(state-&gt;bai &gt;&gt; 3) &amp; 3];			/* dbpbcod */
+    hth = hthtab[state-&gt;fscod];
+    /*
+     * if there is no delta bit allocation, make deltba point to an area
+     * known to contain zeroes. baptab+156 here.
+     */
+    deltba = (ba-&gt;deltbae == DELTA_BIT_NONE) ? baptab + 156 : ba-&gt;deltba;
+    floor = floortab[state-&gt;bai &amp; 7];				/* floorcod */
+    snroffset = 960 - 64 * state-&gt;csnroffst - 4 * (ba-&gt;bai &gt;&gt; 3) + floor;
+    floor &gt;&gt;= 5;
+
+    exp = expbap-&gt;exp;
+    bap = expbap-&gt;bap;
+
+    i = bndstart;
+    j = start;
+    if (start == 0) {	/* not the coupling channel */
+	int lowcomp;
+
+	lowcomp = 0;
+	j = end - 1;
+	do {
+	    if (i &lt; j) {
+		if (exp[i+1] == exp[i] - 2)
+		    lowcomp = 384;
+		else if (lowcomp &amp;&amp; (exp[i+1] &gt; exp[i]))
+		    lowcomp -= 64;
+	    }
+	    psd = 128 * exp[i];
+	    mask = psd + fgain + lowcomp;
+	    COMPUTE_MASK ();
+	    bap[i] = (baptab+156)[mask + 4 * exp[i]];
+	    i++;
+	} while ((i &lt; 3) || ((i &lt; 7) &amp;&amp; (exp[i] &gt; exp[i-1])));
+	fastleak = psd + fgain;
+	slowleak = psd + sgain;
+
+	while (i &lt; 7) {
+	    if (i &lt; j) {
+		if (exp[i+1] == exp[i] - 2)
+		    lowcomp = 384;
+		else if (lowcomp &amp;&amp; (exp[i+1] &gt; exp[i]))
+		    lowcomp -= 64;
+	    }
+	    psd = 128 * exp[i];
+	    UPDATE_LEAK ();
+	    mask = ((fastleak + lowcomp &lt; slowleak) ?
+		    fastleak + lowcomp : slowleak);
+	    COMPUTE_MASK ();
+	    bap[i] = (baptab+156)[mask + 4 * exp[i]];
+	    i++;
+	}
+
+	if (end == 7)	/* lfe channel */
+	    return;
+
+	do {
+	    if (exp[i+1] == exp[i] - 2)
+		lowcomp = 320;
+	    else if (lowcomp &amp;&amp; (exp[i+1] &gt; exp[i]))
+		lowcomp -= 64;
+	    psd = 128 * exp[i];
+	    UPDATE_LEAK ();
+	    mask = ((fastleak + lowcomp &lt; slowleak) ?
+		    fastleak + lowcomp : slowleak);
+	    COMPUTE_MASK ();
+	    bap[i] = (baptab+156)[mask + 4 * exp[i]];
+	    i++;
+	} while (i &lt; 20);
+
+	while (lowcomp &gt; 128) {		/* two iterations maximum */
+	    lowcomp -= 128;
+	    psd = 128 * exp[i];
+	    UPDATE_LEAK ();
+	    mask = ((fastleak + lowcomp &lt; slowleak) ?
+		    fastleak + lowcomp : slowleak);
+	    COMPUTE_MASK ();
+	    bap[i] = (baptab+156)[mask + 4 * exp[i]];
+	    i++;
+	}
+	j = i;
+    }
+
+    do {
+	int startband, endband;
+
+	startband = j;
+	endband = ((bndtab-20)[i] &lt; end) ? (bndtab-20)[i] : end;
+	psd = 128 * exp[j++];
+	while (j &lt; endband) {
+	    int next, delta;
+
+	    next = 128 * exp[j++];
+	    delta = next - psd;
+	    switch (delta &gt;&gt; 9) {
+	    case -6: case -5: case -4: case -3: case -2:
+		psd = next;
+		break;
+	    case -1:
+		psd = next + latab[(-delta) &gt;&gt; 1];
+		break;
+	    case 0:
+		psd += latab[delta &gt;&gt; 1];
+		break;
+	    }
+	}
+	/* minpsd = -289 */
+	UPDATE_LEAK ();
+	mask = (fastleak &lt; slowleak) ? fastleak : slowleak;
+	COMPUTE_MASK ();
+	i++;
+	j = startband;
+	do {
+	    /* max(mask+4*exp)=147=-(minpsd+fgain-deltba-snroffset)&gt;&gt;5+4*exp */
+	    /* min(mask+4*exp)=-156=-(sgain-deltba-snroffset)&gt;&gt;5 */
+	    bap[j] = (baptab+156)[mask + 4 * exp[j]];
+	} while (++j &lt; endband);
+    } while (j &lt; end);
+}

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/bitstream.c (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.c)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.c	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/bitstream.c	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,95 @@
+/*
+ * bitstream.c
+ * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file is part of a52dec, a free ATSC A-52 stream decoder.
+ * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
+ *
+ * a52dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * a52dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include &quot;config.h&quot;
+
+#include &lt;inttypes.h&gt;
+
+#include &quot;a52.h&quot;
+#include &quot;a52_internal.h&quot;
+#include &quot;bitstream.h&quot;
+
+#define BUFFER_SIZE 4096
+
+void a52_bitstream_set_ptr (a52_state_t * state, uint8_t * buf)
+{
+    int align;
+
+    align = (long)buf &amp; 3;
+    state-&gt;buffer_start = (uint32_t *) (buf - align);
+    state-&gt;bits_left = 0;
+    bitstream_get (state, align * 8);
+}
+
+static inline void bitstream_fill_current (a52_state_t * state)
+{
+    uint32_t tmp;
+
+    tmp = *(state-&gt;buffer_start++);
+    state-&gt;current_word = swab32 (tmp);
+}
+
+/*
+ * The fast paths for _get is in the
+ * bitstream.h header file so it can be inlined.
+ *
+ * The &quot;bottom half&quot; of this routine is suffixed _bh
+ *
+ * -ah
+ */
+
+uint32_t a52_bitstream_get_bh (a52_state_t * state, uint32_t num_bits)
+{
+    uint32_t result;
+
+    num_bits -= state-&gt;bits_left;
+    result = ((state-&gt;current_word &lt;&lt; (32 - state-&gt;bits_left)) &gt;&gt;
+	      (32 - state-&gt;bits_left));
+
+    bitstream_fill_current (state);
+
+    if (num_bits != 0)
+	result = (result &lt;&lt; num_bits) | (state-&gt;current_word &gt;&gt; (32 - num_bits));
+
+    state-&gt;bits_left = 32 - num_bits;
+
+    return result;
+}
+
+int32_t a52_bitstream_get_bh_2 (a52_state_t * state, uint32_t num_bits)
+{
+    int32_t result;
+
+    num_bits -= state-&gt;bits_left;
+    result = ((((int32_t)state-&gt;current_word) &lt;&lt; (32 - state-&gt;bits_left)) &gt;&gt;
+	      (32 - state-&gt;bits_left));
+
+    bitstream_fill_current(state);
+
+    if (num_bits != 0)
+	result = (result &lt;&lt; num_bits) | (state-&gt;current_word &gt;&gt; (32 - num_bits));
+	
+    state-&gt;bits_left = 32 - num_bits;
+
+    return result;
+}

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/bitstream.h (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.h)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/bitstream.h	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/bitstream.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,77 @@
+/*
+ * bitstream.h
+ * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file is part of a52dec, a free ATSC A-52 stream decoder.
+ * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
+ *
+ * a52dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * a52dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* (stolen from the kernel) */
+#ifdef WORDS_BIGENDIAN
+
+#	define swab32(x) (x)
+
+#else
+
+#	if 0 &amp;&amp; defined (__i386__)
+
+#	define swab32(x) __i386_swab32(x)
+	static inline const uint32_t __i386_swab32(uint32_t x)
+	{
+		__asm__(&quot;bswap %0&quot; : &quot;=r&quot; (x) : &quot;0&quot; (x));
+		return x;
+	}
+
+#	else
+
+#	define swab32(x)\
+((((uint8_t*)&amp;x)[0] &lt;&lt; 24) | (((uint8_t*)&amp;x)[1] &lt;&lt; 16) |  \
+ (((uint8_t*)&amp;x)[2] &lt;&lt; 8)  | (((uint8_t*)&amp;x)[3]))
+
+#	endif
+#endif
+
+void a52_bitstream_set_ptr (a52_state_t * state, uint8_t * buf);
+uint32_t a52_bitstream_get_bh (a52_state_t * state, uint32_t num_bits);
+int32_t a52_bitstream_get_bh_2 (a52_state_t * state, uint32_t num_bits);
+
+static inline uint32_t bitstream_get (a52_state_t * state, uint32_t num_bits)
+{
+    uint32_t result;
+	
+    if (num_bits &lt; state-&gt;bits_left) {
+	result = (state-&gt;current_word &lt;&lt; (32 - state-&gt;bits_left)) &gt;&gt; (32 - num_bits);
+	state-&gt;bits_left -= num_bits;
+	return result;
+    }
+
+    return a52_bitstream_get_bh (state, num_bits);
+}
+
+static inline int32_t bitstream_get_2 (a52_state_t * state, uint32_t num_bits)
+{
+    int32_t result;
+	
+    if (num_bits &lt; state-&gt;bits_left) {
+	result = (((int32_t)state-&gt;current_word) &lt;&lt; (32 - state-&gt;bits_left)) &gt;&gt; (32 - num_bits);
+	state-&gt;bits_left -= num_bits;
+	return result;
+    }
+
+    return a52_bitstream_get_bh_2 (state, num_bits);
+}

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/downmix.c (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/downmix.c)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/downmix.c	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/downmix.c	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,655 @@
+/*
+ * downmix.c
+ * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file is part of a52dec, a free ATSC A-52 stream decoder.
+ * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
+ *
+ * a52dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * a52dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include &quot;config.h&quot;
+
+#include &lt;string.h&gt;
+#include &lt;inttypes.h&gt;
+
+#include &quot;a52.h&quot;
+#include &quot;a52_internal.h&quot;
+
+#define CONVERT(acmod,output) (((output) &lt;&lt; 3) + (acmod))
+
+int a52_downmix_init (int input, int flags, sample_t * level,
+		      sample_t clev, sample_t slev)
+{
+    static uint8_t table[11][8] = {
+	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_STEREO,
+	 A52_STEREO,	A52_STEREO,	A52_STEREO,	A52_STEREO},
+	{A52_MONO,	A52_MONO,	A52_MONO,	A52_MONO,
+	 A52_MONO,	A52_MONO,	A52_MONO,	A52_MONO},
+	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_STEREO,
+	 A52_STEREO,	A52_STEREO,	A52_STEREO,	A52_STEREO},
+	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_3F,
+	 A52_STEREO,	A52_3F,		A52_STEREO,	A52_3F},
+	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_STEREO,
+	 A52_2F1R,	A52_2F1R,	A52_2F1R,	A52_2F1R},
+	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_STEREO,
+	 A52_2F1R,	A52_3F1R,	A52_2F1R,	A52_3F1R},
+	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_3F,
+	 A52_2F2R,	A52_2F2R,	A52_2F2R,	A52_2F2R},
+	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_3F,
+	 A52_2F2R,	A52_3F2R,	A52_2F2R,	A52_3F2R},
+	{A52_CHANNEL1,	A52_MONO,	A52_MONO,	A52_MONO,
+	 A52_MONO,	A52_MONO,	A52_MONO,	A52_MONO},
+	{A52_CHANNEL2,	A52_MONO,	A52_MONO,	A52_MONO,
+	 A52_MONO,	A52_MONO,	A52_MONO,	A52_MONO},
+	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_DOLBY,
+	 A52_DOLBY,	A52_DOLBY,	A52_DOLBY,	A52_DOLBY}
+    };
+    int output;
+
+    output = flags &amp; A52_CHANNEL_MASK;
+    if (output &gt; A52_DOLBY)
+	return -1;
+
+    output = table[output][input &amp; 7];
+
+    if ((output == A52_STEREO) &amp;&amp;
+	((input == A52_DOLBY) || ((input == A52_3F) &amp;&amp; (clev == LEVEL_3DB))))
+	output = A52_DOLBY;
+
+    if (flags &amp; A52_ADJUST_LEVEL)
+	switch (CONVERT (input &amp; 7, output)) {
+
+	case CONVERT (A52_3F, A52_MONO):
+	    *level *= LEVEL_3DB / (1 + clev);
+	    break;
+
+	case CONVERT (A52_STEREO, A52_MONO):
+	case CONVERT (A52_2F2R, A52_2F1R):
+	case CONVERT (A52_3F2R, A52_3F1R):
+	level_3db:
+	    *level *= LEVEL_3DB;
+	    break;
+
+	case CONVERT (A52_3F2R, A52_2F1R):
+	    if (clev &lt; LEVEL_PLUS3DB - 1)
+		goto level_3db;
+	    /* break thru */
+	case CONVERT (A52_3F, A52_STEREO):
+	case CONVERT (A52_3F1R, A52_2F1R):
+	case CONVERT (A52_3F1R, A52_2F2R):
+	case CONVERT (A52_3F2R, A52_2F2R):
+	    *level /= 1 + clev;
+	    break;
+
+	case CONVERT (A52_2F1R, A52_MONO):
+	    *level *= LEVEL_PLUS3DB / (2 + slev);
+	    break;
+
+	case CONVERT (A52_2F1R, A52_STEREO):
+	case CONVERT (A52_3F1R, A52_3F):
+	    *level /= 1 + slev * LEVEL_3DB;
+	    break;
+
+	case CONVERT (A52_3F1R, A52_MONO):
+	    *level *= LEVEL_3DB / (1 + clev + 0.5 * slev);
+	    break;
+
+	case CONVERT (A52_3F1R, A52_STEREO):
+	    *level /= 1 + clev + slev * LEVEL_3DB;
+	    break;
+
+	case CONVERT (A52_2F2R, A52_MONO):
+	    *level *= LEVEL_3DB / (1 + slev);
+	    break;
+
+	case CONVERT (A52_2F2R, A52_STEREO):
+	case CONVERT (A52_3F2R, A52_3F):
+	    *level /= 1 + slev;
+	    break;
+
+	case CONVERT (A52_3F2R, A52_MONO):
+	    *level *= LEVEL_3DB / (1 + clev + slev);
+	    break;
+
+	case CONVERT (A52_3F2R, A52_STEREO):
+	    *level /= 1 + clev + slev;
+	    break;
+
+	case CONVERT (A52_MONO, A52_DOLBY):
+	    *level *= LEVEL_PLUS3DB;
+	    break;
+
+	case CONVERT (A52_3F, A52_DOLBY):
+	case CONVERT (A52_2F1R, A52_DOLBY):
+	    *level *= 1 / (1 + LEVEL_3DB);
+	    break;
+
+	case CONVERT (A52_3F1R, A52_DOLBY):
+	case CONVERT (A52_2F2R, A52_DOLBY):
+	    *level *= 1 / (1 + 2 * LEVEL_3DB);
+	    break;
+
+	case CONVERT (A52_3F2R, A52_DOLBY):
+	    *level *= 1 / (1 + 3 * LEVEL_3DB);
+	    break;
+	}
+
+    return output;
+}
+
+int a52_downmix_coeff (sample_t * coeff, int acmod, int output, sample_t level,
+		       sample_t clev, sample_t slev)
+{
+    switch (CONVERT (acmod, output &amp; A52_CHANNEL_MASK)) {
+
+    case CONVERT (A52_CHANNEL, A52_CHANNEL):
+    case CONVERT (A52_MONO, A52_MONO):
+    case CONVERT (A52_STEREO, A52_STEREO):
+    case CONVERT (A52_3F, A52_3F):
+    case CONVERT (A52_2F1R, A52_2F1R):
+    case CONVERT (A52_3F1R, A52_3F1R):
+    case CONVERT (A52_2F2R, A52_2F2R):
+    case CONVERT (A52_3F2R, A52_3F2R):
+    case CONVERT (A52_STEREO, A52_DOLBY):
+	coeff[0] = coeff[1] = coeff[2] = coeff[3] = coeff[4] = level;
+	return 0;
+
+    case CONVERT (A52_CHANNEL, A52_MONO):
+	coeff[0] = coeff[1] = level * LEVEL_6DB;
+	return 3;
+
+    case CONVERT (A52_STEREO, A52_MONO):
+	coeff[0] = coeff[1] = level * LEVEL_3DB;
+	return 3;
+
+    case CONVERT (A52_3F, A52_MONO):
+	coeff[0] = coeff[2] = level * LEVEL_3DB;
+	coeff[1] = level * clev * LEVEL_PLUS3DB;
+	return 7;
+
+    case CONVERT (A52_2F1R, A52_MONO):
+	coeff[0] = coeff[1] = level * LEVEL_3DB;
+	coeff[2] = level * slev * LEVEL_3DB;
+	return 7;
+
+    case CONVERT (A52_2F2R, A52_MONO):
+	coeff[0] = coeff[1] = level * LEVEL_3DB;
+	coeff[2] = coeff[3] = level * slev * LEVEL_3DB;
+	return 15;
+
+    case CONVERT (A52_3F1R, A52_MONO):
+	coeff[0] = coeff[2] = level * LEVEL_3DB;
+	coeff[1] = level * clev * LEVEL_PLUS3DB;
+	coeff[3] = level * slev * LEVEL_3DB;
+	return 15;
+
+    case CONVERT (A52_3F2R, A52_MONO):
+	coeff[0] = coeff[2] = level * LEVEL_3DB;
+	coeff[1] = level * clev * LEVEL_PLUS3DB;
+	coeff[3] = coeff[4] = level * slev * LEVEL_3DB;
+	return 31;
+
+    case CONVERT (A52_MONO, A52_DOLBY):
+	coeff[0] = level * LEVEL_3DB;
+	return 0;
+
+    case CONVERT (A52_3F, A52_DOLBY):
+	clev = LEVEL_3DB;
+    case CONVERT (A52_3F, A52_STEREO):
+    case CONVERT (A52_3F1R, A52_2F1R):
+    case CONVERT (A52_3F2R, A52_2F2R):
+	coeff[0] = coeff[2] = coeff[3] = coeff[4] = level;
+	coeff[1] = level * clev;
+	return 7;
+
+    case CONVERT (A52_2F1R, A52_DOLBY):
+	slev = 1;
+    case CONVERT (A52_2F1R, A52_STEREO):
+	coeff[0] = coeff[1] = level;
+	coeff[2] = level * slev * LEVEL_3DB;
+	return 7;
+
+    case CONVERT (A52_3F1R, A52_DOLBY):
+	clev = LEVEL_3DB;
+	slev = 1;
+    case CONVERT (A52_3F1R, A52_STEREO):
+	coeff[0] = coeff[2] = level;
+	coeff[1] = level * clev;
+	coeff[3] = level * slev * LEVEL_3DB;
+	return 15;
+
+    case CONVERT (A52_2F2R, A52_DOLBY):
+	slev = LEVEL_3DB;
+    case CONVERT (A52_2F2R, A52_STEREO):
+	coeff[0] = coeff[1] = level;
+	coeff[2] = coeff[3] = level * slev;
+	return 15;
+
+    case CONVERT (A52_3F2R, A52_DOLBY):
+	clev = LEVEL_3DB;
+    case CONVERT (A52_3F2R, A52_2F1R):
+	slev = LEVEL_3DB;
+    case CONVERT (A52_3F2R, A52_STEREO):
+	coeff[0] = coeff[2] = level;
+	coeff[1] = level * clev;
+	coeff[3] = coeff[4] = level * slev;
+	return 31;
+
+    case CONVERT (A52_3F1R, A52_3F):
+	coeff[0] = coeff[1] = coeff[2] = level;
+	coeff[3] = level * slev * LEVEL_3DB;
+	return 13;
+
+    case CONVERT (A52_3F2R, A52_3F):
+	coeff[0] = coeff[1] = coeff[2] = level;
+	coeff[3] = coeff[4] = level * slev;
+	return 29;
+
+    case CONVERT (A52_2F2R, A52_2F1R):
+	coeff[0] = coeff[1] = level;
+	coeff[2] = coeff[3] = level * LEVEL_3DB;
+	return 12;
+
+    case CONVERT (A52_3F2R, A52_3F1R):
+	coeff[0] = coeff[1] = coeff[2] = level;
+	coeff[3] = coeff[4] = level * LEVEL_3DB;
+	return 24;
+
+    case CONVERT (A52_2F1R, A52_2F2R):
+	coeff[0] = coeff[1] = level;
+	coeff[2] = level * LEVEL_3DB;
+	return 0;
+
+    case CONVERT (A52_3F1R, A52_2F2R):
+	coeff[0] = coeff[2] = level;
+	coeff[1] = level * clev;
+	coeff[3] = level * LEVEL_3DB;
+	return 7;
+
+    case CONVERT (A52_3F1R, A52_3F2R):
+	coeff[0] = coeff[1] = coeff[2] = level;
+	coeff[3] = level * LEVEL_3DB;
+	return 0;
+
+    case CONVERT (A52_CHANNEL, A52_CHANNEL1):
+	coeff[0] = level;
+	coeff[1] = 0;
+	return 0;
+
+    case CONVERT (A52_CHANNEL, A52_CHANNEL2):
+	coeff[0] = 0;
+	coeff[1] = level;
+	return 0;
+    }
+
+    return -1;	/* NOTREACHED */
+}
+
+static void mix2to1 (sample_t * dest, sample_t * src, sample_t bias)
+{
+    int i;
+
+    for (i = 0; i &lt; 256; i++)
+	dest[i] += src[i] + bias;
+}
+
+static void mix3to1 (sample_t * samples, sample_t bias)
+{
+    int i;
+
+    for (i = 0; i &lt; 256; i++)
+	samples[i] += samples[i + 256] + samples[i + 512] + bias;
+}
+
+static void mix4to1 (sample_t * samples, sample_t bias)
+{
+    int i;
+
+    for (i = 0; i &lt; 256; i++)
+	samples[i] += (samples[i + 256] + samples[i + 512] +
+		       samples[i + 768] + bias);
+}
+
+static void mix5to1 (sample_t * samples, sample_t bias)
+{
+    int i;
+
+    for (i = 0; i &lt; 256; i++)
+	samples[i] += (samples[i + 256] + samples[i + 512] +
+		       samples[i + 768] + samples[i + 1024] + bias);
+}
+
+static void mix3to2 (sample_t * samples, sample_t bias)
+{
+    int i;
+    sample_t common;
+
+    for (i = 0; i &lt; 256; i++) {
+	common = samples[i + 256] + bias;
+	samples[i] += common;
+	samples[i + 256] = samples[i + 512] + common;
+    }
+}
+
+static void mix21to2 (sample_t * left, sample_t * right, sample_t bias)
+{
+    int i;
+    sample_t common;
+
+    for (i = 0; i &lt; 256; i++) {
+	common = right[i + 256] + bias;
+	left[i] += common;
+	right[i] += common;
+    }
+}
+
+static void mix21toS (sample_t * samples, sample_t bias)
+{
+    int i;
+    sample_t surround;
+
+    for (i = 0; i &lt; 256; i++) {
+	surround = samples[i + 512];
+	samples[i] += bias - surround;
+	samples[i + 256] += bias + surround;
+    }
+}
+
+static void mix31to2 (sample_t * samples, sample_t bias)
+{
+    int i;
+    sample_t common;
+
+    for (i = 0; i &lt; 256; i++) {
+	common = samples[i + 256] + samples[i + 768] + bias;
+	samples[i] += common;
+	samples[i + 256] = samples[i + 512] + common;
+    }
+}
+
+static void mix31toS (sample_t * samples, sample_t bias)
+{
+    int i;
+    sample_t common, surround;
+
+    for (i = 0; i &lt; 256; i++) {
+	common = samples[i + 256] + bias;
+	surround = samples[i + 768];
+	samples[i] += common - surround;
+	samples[i + 256] = samples[i + 512] + common + surround;
+    }
+}
+
+static void mix22toS (sample_t * samples, sample_t bias)
+{
+    int i;
+    sample_t surround;
+
+    for (i = 0; i &lt; 256; i++) {
+	surround = samples[i + 512] + samples[i + 768];
+	samples[i] += bias - surround;
+	samples[i + 256] += bias + surround;
+    }
+}
+
+static void mix32to2 (sample_t * samples, sample_t bias)
+{
+    int i;
+    sample_t common;
+
+    for (i = 0; i &lt; 256; i++) {
+	common = samples[i + 256] + bias;
+	samples[i] += common + samples[i + 768];
+	samples[i + 256] = common + samples[i + 512] + samples[i + 1024];
+    }
+}
+
+static void mix32toS (sample_t * samples, sample_t bias)
+{
+    int i;
+    sample_t common, surround;
+
+    for (i = 0; i &lt; 256; i++) {
+	common = samples[i + 256] + bias;
+	surround = samples[i + 768] + samples[i + 1024];
+	samples[i] += common - surround;
+	samples[i + 256] = samples[i + 512] + common + surround;
+    }
+}
+
+static void move2to1 (sample_t * src, sample_t * dest, sample_t bias)
+{
+    int i;
+
+    for (i = 0; i &lt; 256; i++)
+	dest[i] = src[i] + src[i + 256] + bias;
+}
+
+static void zero (sample_t * samples)
+{
+    int i;
+
+    for (i = 0; i &lt; 256; i++)
+	samples[i] = 0;
+}
+
+void a52_downmix (sample_t * samples, int acmod, int output, sample_t bias,
+		  sample_t clev, sample_t slev)
+{
+    switch (CONVERT (acmod, output &amp; A52_CHANNEL_MASK)) {
+
+    case CONVERT (A52_CHANNEL, A52_CHANNEL2):
+	memcpy (samples, samples + 256, 256 * sizeof (sample_t));
+	break;
+
+    case CONVERT (A52_CHANNEL, A52_MONO):
+    case CONVERT (A52_STEREO, A52_MONO):
+    mix_2to1:
+	mix2to1 (samples, samples + 256, bias);
+	break;
+
+    case CONVERT (A52_2F1R, A52_MONO):
+	if (slev == 0)
+	    goto mix_2to1;
+    case CONVERT (A52_3F, A52_MONO):
+    mix_3to1:
+	mix3to1 (samples, bias);
+	break;
+
+    case CONVERT (A52_3F1R, A52_MONO):
+	if (slev == 0)
+	    goto mix_3to1;
+    case CONVERT (A52_2F2R, A52_MONO):
+	if (slev == 0)
+	    goto mix_2to1;
+	mix4to1 (samples, bias);
+	break;
+
+    case CONVERT (A52_3F2R, A52_MONO):
+	if (slev == 0)
+	    goto mix_3to1;
+	mix5to1 (samples, bias);
+	break;
+
+    case CONVERT (A52_MONO, A52_DOLBY):
+	memcpy (samples + 256, samples, 256 * sizeof (sample_t));
+	break;
+
+    case CONVERT (A52_3F, A52_STEREO):
+    case CONVERT (A52_3F, A52_DOLBY):
+    mix_3to2:
+	mix3to2 (samples, bias);
+	break;
+
+    case CONVERT (A52_2F1R, A52_STEREO):
+	if (slev == 0)
+	    break;
+	mix21to2 (samples, samples + 256, bias);
+	break;
+
+    case CONVERT (A52_2F1R, A52_DOLBY):
+	mix21toS (samples, bias);
+	break;
+
+    case CONVERT (A52_3F1R, A52_STEREO):
+	if (slev == 0)
+	    goto mix_3to2;
+	mix31to2 (samples, bias);
+	break;
+
+    case CONVERT (A52_3F1R, A52_DOLBY):
+	mix31toS (samples, bias);
+	break;
+
+    case CONVERT (A52_2F2R, A52_STEREO):
+	if (slev == 0)
+	    break;
+	mix2to1 (samples, samples + 512, bias);
+	mix2to1 (samples + 256, samples + 768, bias);
+	break;
+
+    case CONVERT (A52_2F2R, A52_DOLBY):
+	mix22toS (samples, bias);
+	break;
+
+    case CONVERT (A52_3F2R, A52_STEREO):
+	if (slev == 0)
+	    goto mix_3to2;
+	mix32to2 (samples, bias);
+	break;
+
+    case CONVERT (A52_3F2R, A52_DOLBY):
+	mix32toS (samples, bias);
+	break;
+
+    case CONVERT (A52_3F1R, A52_3F):
+	if (slev == 0)
+	    break;
+	mix21to2 (samples, samples + 512, bias);
+	break;
+
+    case CONVERT (A52_3F2R, A52_3F):
+	if (slev == 0)
+	    break;
+	mix2to1 (samples, samples + 768, bias);
+	mix2to1 (samples + 512, samples + 1024, bias);
+	break;
+
+    case CONVERT (A52_3F1R, A52_2F1R):
+	mix3to2 (samples, bias);
+	memcpy (samples + 512, samples + 768, 256 * sizeof (sample_t));
+	break;
+
+    case CONVERT (A52_2F2R, A52_2F1R):
+	mix2to1 (samples + 512, samples + 768, bias);
+	break;
+
+    case CONVERT (A52_3F2R, A52_2F1R):
+	mix3to2 (samples, bias);
+	move2to1 (samples + 768, samples + 512, bias);
+	break;
+
+    case CONVERT (A52_3F2R, A52_3F1R):
+	mix2to1 (samples + 768, samples + 1024, bias);
+	break;
+
+    case CONVERT (A52_2F1R, A52_2F2R):
+	memcpy (samples + 768, samples + 512, 256 * sizeof (sample_t));
+	break;
+
+    case CONVERT (A52_3F1R, A52_2F2R):
+	mix3to2 (samples, bias);
+	memcpy (samples + 512, samples + 768, 256 * sizeof (sample_t));
+	break;
+
+    case CONVERT (A52_3F2R, A52_2F2R):
+	mix3to2 (samples, bias);
+	memcpy (samples + 512, samples + 768, 256 * sizeof (sample_t));
+	memcpy (samples + 768, samples + 1024, 256 * sizeof (sample_t));
+	break;
+
+    case CONVERT (A52_3F1R, A52_3F2R):
+	memcpy (samples + 1027, samples + 768, 256 * sizeof (sample_t));
+	break;
+    }
+}
+
+void a52_upmix (sample_t * samples, int acmod, int output)
+{
+    switch (CONVERT (acmod, output &amp; A52_CHANNEL_MASK)) {
+
+    case CONVERT (A52_CHANNEL, A52_CHANNEL2):
+	memcpy (samples + 256, samples, 256 * sizeof (sample_t));
+	break;
+
+    case CONVERT (A52_3F2R, A52_MONO):
+	zero (samples + 1024);
+    case CONVERT (A52_3F1R, A52_MONO):
+    case CONVERT (A52_2F2R, A52_MONO):
+	zero (samples + 768);
+    case CONVERT (A52_3F, A52_MONO):
+    case CONVERT (A52_2F1R, A52_MONO):
+	zero (samples + 512);
+    case CONVERT (A52_CHANNEL, A52_MONO):
+    case CONVERT (A52_STEREO, A52_MONO):
+	zero (samples + 256);
+	break;
+
+    case CONVERT (A52_3F2R, A52_STEREO):
+    case CONVERT (A52_3F2R, A52_DOLBY):
+	zero (samples + 1024);
+    case CONVERT (A52_3F1R, A52_STEREO):
+    case CONVERT (A52_3F1R, A52_DOLBY):
+	zero (samples + 768);
+    case CONVERT (A52_3F, A52_STEREO):
+    case CONVERT (A52_3F, A52_DOLBY):
+    mix_3to2:
+	memcpy (samples + 512, samples + 256, 256 * sizeof (sample_t));
+	zero (samples + 256);
+	break;
+
+    case CONVERT (A52_2F2R, A52_STEREO):
+    case CONVERT (A52_2F2R, A52_DOLBY):
+	zero (samples + 768);
+    case CONVERT (A52_2F1R, A52_STEREO):
+    case CONVERT (A52_2F1R, A52_DOLBY):
+	zero (samples + 512);
+	break;
+
+    case CONVERT (A52_3F2R, A52_3F):
+	zero (samples + 1024);
+    case CONVERT (A52_3F1R, A52_3F):
+    case CONVERT (A52_2F2R, A52_2F1R):
+	zero (samples + 768);
+	break;
+
+    case CONVERT (A52_3F2R, A52_3F1R):
+	zero (samples + 1024);
+	break;
+
+    case CONVERT (A52_3F2R, A52_2F1R):
+	zero (samples + 1024);
+    case CONVERT (A52_3F1R, A52_2F1R):
+    mix_31to21:
+	memcpy (samples + 768, samples + 512, 256 * sizeof (sample_t));
+	goto mix_3to2;
+
+    case CONVERT (A52_3F2R, A52_2F2R):
+	memcpy (samples + 1024, samples + 768, 256 * sizeof (sample_t));
+	goto mix_31to21;
+    }
+}

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/imdct.c (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/imdct.c)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/imdct.c	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/imdct.c	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,432 @@
+/*
+ * imdct.c
+ * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * The ifft algorithms in this file have been largely inspired by Dan
+ * Bernstein's work, djbfft, available at <A HREF="http://cr.yp.to/djbfft.html">http://cr.yp.to/djbfft.html</A>
+ *
+ * This file is part of a52dec, a free ATSC A-52 stream decoder.
+ * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
+ *
+ * a52dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * a52dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include &quot;config.h&quot;
+
+#include &lt;math.h&gt;
+#include &lt;stdio.h&gt;
+#ifdef LIBA52_DJBFFT
+#include &lt;fftc4.h&gt;
+#endif
+#ifndef M_PI
+#define M_PI 3.1415926535897932384626433832795029
+#endif
+#include &lt;inttypes.h&gt;
+
+#include &quot;a52.h&quot;
+#include &quot;a52_internal.h&quot;
+#include &quot;mm_accel.h&quot;
+
+typedef struct complex_s {
+    sample_t real;
+    sample_t imag;
+} complex_t;
+
+static uint8_t fftorder[] = {
+      0,128, 64,192, 32,160,224, 96, 16,144, 80,208,240,112, 48,176,
+      8,136, 72,200, 40,168,232,104,248,120, 56,184, 24,152,216, 88,
+      4,132, 68,196, 36,164,228,100, 20,148, 84,212,244,116, 52,180,
+    252,124, 60,188, 28,156,220, 92, 12,140, 76,204,236,108, 44,172,
+      2,130, 66,194, 34,162,226, 98, 18,146, 82,210,242,114, 50,178,
+     10,138, 74,202, 42,170,234,106,250,122, 58,186, 26,154,218, 90,
+    254,126, 62,190, 30,158,222, 94, 14,142, 78,206,238,110, 46,174,
+      6,134, 70,198, 38,166,230,102,246,118, 54,182, 22,150,214, 86
+};
+
+/* Root values for IFFT */
+static sample_t roots16[3];
+static sample_t roots32[7];
+static sample_t roots64[15];
+static sample_t roots128[31];
+
+/* Twiddle factors for IMDCT */
+static complex_t pre1[128];
+static complex_t post1[64];
+static complex_t pre2[64];
+static complex_t post2[32];
+
+static sample_t a52_imdct_window[256];
+
+static void (* ifft128) (complex_t * buf);
+static void (* ifft64) (complex_t * buf);
+
+static inline void ifft2 (complex_t * buf)
+{
+    double r, i;
+
+    r = buf[0].real;
+    i = buf[0].imag;
+    buf[0].real += buf[1].real;
+    buf[0].imag += buf[1].imag;
+    buf[1].real = r - buf[1].real;
+    buf[1].imag = i - buf[1].imag;
+}
+
+static inline void ifft4 (complex_t * buf)
+{
+    double tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
+
+    tmp1 = buf[0].real + buf[1].real;
+    tmp2 = buf[3].real + buf[2].real;
+    tmp3 = buf[0].imag + buf[1].imag;
+    tmp4 = buf[2].imag + buf[3].imag;
+    tmp5 = buf[0].real - buf[1].real;
+    tmp6 = buf[0].imag - buf[1].imag;
+    tmp7 = buf[2].imag - buf[3].imag;
+    tmp8 = buf[3].real - buf[2].real;
+
+    buf[0].real = tmp1 + tmp2;
+    buf[0].imag = tmp3 + tmp4;
+    buf[2].real = tmp1 - tmp2;
+    buf[2].imag = tmp3 - tmp4;
+    buf[1].real = tmp5 + tmp7;
+    buf[1].imag = tmp6 + tmp8;
+    buf[3].real = tmp5 - tmp7;
+    buf[3].imag = tmp6 - tmp8;
+}
+
+/* the basic split-radix ifft butterfly */
+
+#define BUTTERFLY(a0,a1,a2,a3,wr,wi) do {	\
+    tmp5 = a2.real * wr + a2.imag * wi;		\
+    tmp6 = a2.imag * wr - a2.real * wi;		\
+    tmp7 = a3.real * wr - a3.imag * wi;		\
+    tmp8 = a3.imag * wr + a3.real * wi;		\
+    tmp1 = tmp5 + tmp7;				\
+    tmp2 = tmp6 + tmp8;				\
+    tmp3 = tmp6 - tmp8;				\
+    tmp4 = tmp7 - tmp5;				\
+    a2.real = a0.real - tmp1;			\
+    a2.imag = a0.imag - tmp2;			\
+    a3.real = a1.real - tmp3;			\
+    a3.imag = a1.imag - tmp4;			\
+    a0.real += tmp1;				\
+    a0.imag += tmp2;				\
+    a1.real += tmp3;				\
+    a1.imag += tmp4;				\
+} while (0)
+
+/* split-radix ifft butterfly, specialized for wr=1 wi=0 */
+
+#define BUTTERFLY_ZERO(a0,a1,a2,a3) do {	\
+    tmp1 = a2.real + a3.real;			\
+    tmp2 = a2.imag + a3.imag;			\
+    tmp3 = a2.imag - a3.imag;			\
+    tmp4 = a3.real - a2.real;			\
+    a2.real = a0.real - tmp1;			\
+    a2.imag = a0.imag - tmp2;			\
+    a3.real = a1.real - tmp3;			\
+    a3.imag = a1.imag - tmp4;			\
+    a0.real += tmp1;				\
+    a0.imag += tmp2;				\
+    a1.real += tmp3;				\
+    a1.imag += tmp4;				\
+} while (0)
+
+/* split-radix ifft butterfly, specialized for wr=wi */
+
+#define BUTTERFLY_HALF(a0,a1,a2,a3,w) do {	\
+    tmp5 = (a2.real + a2.imag) * w;		\
+    tmp6 = (a2.imag - a2.real) * w;		\
+    tmp7 = (a3.real - a3.imag) * w;		\
+    tmp8 = (a3.imag + a3.real) * w;		\
+    tmp1 = tmp5 + tmp7;				\
+    tmp2 = tmp6 + tmp8;				\
+    tmp3 = tmp6 - tmp8;				\
+    tmp4 = tmp7 - tmp5;				\
+    a2.real = a0.real - tmp1;			\
+    a2.imag = a0.imag - tmp2;			\
+    a3.real = a1.real - tmp3;			\
+    a3.imag = a1.imag - tmp4;			\
+    a0.real += tmp1;				\
+    a0.imag += tmp2;				\
+    a1.real += tmp3;				\
+    a1.imag += tmp4;				\
+} while (0)
+
+static inline void ifft8 (complex_t * buf)
+{
+    double tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
+
+    ifft4 (buf);
+    ifft2 (buf + 4);
+    ifft2 (buf + 6);
+    BUTTERFLY_ZERO (buf[0], buf[2], buf[4], buf[6]);
+    BUTTERFLY_HALF (buf[1], buf[3], buf[5], buf[7], roots16[1]);
+}
+
+static void ifft_pass (complex_t * buf, sample_t * weight, int n)
+{
+    complex_t * buf1;
+    complex_t * buf2;
+    complex_t * buf3;
+    double tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
+    int i;
+
+    buf++;
+    buf1 = buf + n;
+    buf2 = buf + 2 * n;
+    buf3 = buf + 3 * n;
+
+    BUTTERFLY_ZERO (buf[-1], buf1[-1], buf2[-1], buf3[-1]);
+
+    i = n - 1;
+
+    do {
+	BUTTERFLY (buf[0], buf1[0], buf2[0], buf3[0], weight[n], weight[2*i]);
+	buf++;
+	buf1++;
+	buf2++;
+	buf3++;
+	weight++;
+    } while (--i);
+}
+
+static void ifft16 (complex_t * buf)
+{
+    ifft8 (buf);
+    ifft4 (buf + 8);
+    ifft4 (buf + 12);
+    ifft_pass (buf, roots16 - 4, 4);
+}
+
+static void ifft32 (complex_t * buf)
+{
+    ifft16 (buf);
+    ifft8 (buf + 16);
+    ifft8 (buf + 24);
+    ifft_pass (buf, roots32 - 8, 8);
+}
+
+static void ifft64_c (complex_t * buf)
+{
+    ifft32 (buf);
+    ifft16 (buf + 32);
+    ifft16 (buf + 48);
+    ifft_pass (buf, roots64 - 16, 16);
+}
+
+static void ifft128_c (complex_t * buf)
+{
+    ifft32 (buf);
+    ifft16 (buf + 32);
+    ifft16 (buf + 48);
+    ifft_pass (buf, roots64 - 16, 16);
+
+    ifft32 (buf + 64);
+    ifft32 (buf + 96);
+    ifft_pass (buf, roots128 - 32, 32);
+}
+
+void a52_imdct_512 (sample_t * data, sample_t * delay, sample_t bias)
+{
+    int i, k;
+    sample_t t_r, t_i, a_r, a_i, b_r, b_i, w_1, w_2;
+    const sample_t * window = a52_imdct_window;
+    complex_t buf[128];
+	
+    for (i = 0; i &lt; 128; i++) {
+	k = fftorder[i];
+	t_r = pre1[i].real;
+	t_i = pre1[i].imag;
+
+	buf[i].real = t_i * data[255-k] + t_r * data[k];
+	buf[i].imag = t_r * data[255-k] - t_i * data[k];
+    }
+
+    ifft128 (buf);
+
+    /* Post IFFT complex multiply plus IFFT complex conjugate*/
+    /* Window and convert to real valued signal */
+    for (i = 0; i &lt; 64; i++) {
+	/* y[n] = z[n] * (xcos1[n] + j * xsin1[n]) ; */
+	t_r = post1[i].real;
+	t_i = post1[i].imag;
+
+	a_r = t_r * buf[i].real     + t_i * buf[i].imag;
+	a_i = t_i * buf[i].real     - t_r * buf[i].imag;
+	b_r = t_i * buf[127-i].real + t_r * buf[127-i].imag;
+	b_i = t_r * buf[127-i].real - t_i * buf[127-i].imag;
+
+	w_1 = window[2*i];
+	w_2 = window[255-2*i];
+	data[2*i]     = delay[2*i] * w_2 - a_r * w_1 + bias;
+	data[255-2*i] = delay[2*i] * w_1 + a_r * w_2 + bias;
+	delay[2*i] = a_i;
+
+	w_1 = window[2*i+1];
+	w_2 = window[254-2*i];
+	data[2*i+1]   = delay[2*i+1] * w_2 + b_r * w_1 + bias;
+	data[254-2*i] = delay[2*i+1] * w_1 - b_r * w_2 + bias;
+	delay[2*i+1] = b_i;
+    }
+}
+
+void a52_imdct_256(sample_t * data, sample_t * delay, sample_t bias)
+{
+    int i, k;
+    sample_t t_r, t_i, a_r, a_i, b_r, b_i, c_r, c_i, d_r, d_i, w_1, w_2;
+    const sample_t * window = a52_imdct_window;
+    complex_t buf1[64], buf2[64];
+
+    /* Pre IFFT complex multiply plus IFFT cmplx conjugate */
+    for (i = 0; i &lt; 64; i++) {
+	k = fftorder[i];
+	t_r = pre2[i].real;
+	t_i = pre2[i].imag;
+
+	buf1[i].real = t_i * data[254-k] + t_r * data[k];
+	buf1[i].imag = t_r * data[254-k] - t_i * data[k];
+
+	buf2[i].real = t_i * data[255-k] + t_r * data[k+1];
+	buf2[i].imag = t_r * data[255-k] - t_i * data[k+1];
+    }
+
+    ifft64 (buf1);
+    ifft64 (buf2);
+
+    /* Post IFFT complex multiply */
+    /* Window and convert to real valued signal */
+    for (i = 0; i &lt; 32; i++) {
+	/* y1[n] = z1[n] * (xcos2[n] + j * xs in2[n]) ; */ 
+	t_r = post2[i].real;
+	t_i = post2[i].imag;
+
+	a_r = t_r * buf1[i].real    + t_i * buf1[i].imag;
+	a_i = t_i * buf1[i].real    - t_r * buf1[i].imag;
+	b_r = t_i * buf1[63-i].real + t_r * buf1[63-i].imag;
+	b_i = t_r * buf1[63-i].real - t_i * buf1[63-i].imag;
+
+	c_r = t_r * buf2[i].real    + t_i * buf2[i].imag;
+	c_i = t_i * buf2[i].real    - t_r * buf2[i].imag;
+	d_r = t_i * buf2[63-i].real + t_r * buf2[63-i].imag;
+	d_i = t_r * buf2[63-i].real - t_i * buf2[63-i].imag;
+
+	w_1 = window[2*i];
+	w_2 = window[255-2*i];
+	data[2*i]     = delay[2*i] * w_2 - a_r * w_1 + bias;
+	data[255-2*i] = delay[2*i] * w_1 + a_r * w_2 + bias;
+	delay[2*i] = c_i;
+
+	w_1 = window[128+2*i];
+	w_2 = window[127-2*i];
+	data[128+2*i] = delay[127-2*i] * w_2 + a_i * w_1 + bias;
+	data[127-2*i] = delay[127-2*i] * w_1 - a_i * w_2 + bias;
+	delay[127-2*i] = c_r;
+
+	w_1 = window[2*i+1];
+	w_2 = window[254-2*i];
+	data[2*i+1]   = delay[2*i+1] * w_2 - b_i * w_1 + bias;
+	data[254-2*i] = delay[2*i+1] * w_1 + b_i * w_2 + bias;
+	delay[2*i+1] = d_r;
+
+	w_1 = window[129+2*i];
+	w_2 = window[126-2*i];
+	data[129+2*i] = delay[126-2*i] * w_2 + b_r * w_1 + bias;
+	data[126-2*i] = delay[126-2*i] * w_1 - b_r * w_2 + bias;
+	delay[126-2*i] = d_i;
+    }
+}
+
+static double besselI0 (double x)
+{
+    double bessel = 1;
+    int i = 100;
+
+    do
+	bessel = bessel * x / (i * i) + 1;
+    while (--i);
+    return bessel;
+}
+
+void a52_imdct_init (uint32_t mm_accel)
+{
+    int i, k;
+    double sum;
+
+    /* compute imdct window - kaiser-bessel derived window, alpha = 5.0 */
+    sum = 0;
+    for (i = 0; i &lt; 256; i++) {
+	sum += besselI0 (i * (256 - i) * (5 * M_PI / 256) * (5 * M_PI / 256));
+	a52_imdct_window[i] = sum;
+    }
+    sum++;
+    for (i = 0; i &lt; 256; i++)
+	a52_imdct_window[i] = sqrt (a52_imdct_window[i] / sum);
+
+    for (i = 0; i &lt; 3; i++)
+	roots16[i] = cos ((M_PI / 8) * (i + 1));
+
+    for (i = 0; i &lt; 7; i++)
+	roots32[i] = cos ((M_PI / 16) * (i + 1));
+
+    for (i = 0; i &lt; 15; i++)
+	roots64[i] = cos ((M_PI / 32) * (i + 1));
+
+    for (i = 0; i &lt; 31; i++)
+	roots128[i] = cos ((M_PI / 64) * (i + 1));
+
+    for (i = 0; i &lt; 64; i++) {
+	k = fftorder[i] / 2 + 64;
+	pre1[i].real = cos ((M_PI / 256) * (k - 0.25));
+	pre1[i].imag = sin ((M_PI / 256) * (k - 0.25));
+    }
+
+    for (i = 64; i &lt; 128; i++) {
+	k = fftorder[i] / 2 + 64;
+	pre1[i].real = -cos ((M_PI / 256) * (k - 0.25));
+	pre1[i].imag = -sin ((M_PI / 256) * (k - 0.25));
+    }
+
+    for (i = 0; i &lt; 64; i++) {
+	post1[i].real = cos ((M_PI / 256) * (i + 0.5));
+	post1[i].imag = sin ((M_PI / 256) * (i + 0.5));
+    }
+
+    for (i = 0; i &lt; 64; i++) {
+	k = fftorder[i] / 4;
+	pre2[i].real = cos ((M_PI / 128) * (k - 0.25));
+	pre2[i].imag = sin ((M_PI / 128) * (k - 0.25));
+    }
+
+    for (i = 0; i &lt; 32; i++) {
+	post2[i].real = cos ((M_PI / 128) * (i + 0.5));
+	post2[i].imag = sin ((M_PI / 128) * (i + 0.5));
+    }
+
+#ifdef LIBA52_DJBFFT
+    if (mm_accel &amp; MM_ACCEL_DJBFFT) {
+	fprintf (stderr, &quot;Using djbfft for IMDCT transform\n&quot;);
+	ifft128 = (void (*) (complex_t *)) fftc4_un128;
+	ifft64 = (void (*) (complex_t *)) fftc4_un64;
+    } else
+#endif
+    {
+	fprintf (stderr, &quot;No accelerated IMDCT transform found\n&quot;);
+	ifft128 = ifft128_c;
+	ifft64 = ifft64_c;
+    }
+}

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/mm_accel.h (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/mm_accel.h)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/mm_accel.h	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/mm_accel.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,37 @@
+/*
+ * mm_accel.h
+ * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file is part of a52dec, a free ATSC A-52 stream decoder.
+ * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
+ *
+ * a52dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * a52dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MM_ACCEL_H
+#define MM_ACCEL_H
+
+/* generic accelerations */
+#define MM_ACCEL_DJBFFT		0x00000001
+
+/* x86 accelerations */
+#define MM_ACCEL_X86_MMX	0x80000000
+#define MM_ACCEL_X86_3DNOW	0x40000000
+#define MM_ACCEL_X86_MMXEXT	0x20000000
+
+uint32_t mm_accel (void);
+
+#endif /* MM_ACCEL_H */

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/parse.c (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/parse.c)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/parse.c	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/parse.c	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,905 @@
+/*
+ * parse.c
+ * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file is part of a52dec, a free ATSC A-52 stream decoder.
+ * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
+ *
+ * a52dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * a52dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+//MEANX
+#define ADM_LEGACY_PROGGY
+#include &quot;ADM_default.h&quot;
+// /MEANX
+
+    
+#include &quot;a52.h&quot;
+#include &quot;a52_internal.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;tables.h&quot;
+
+
+#ifdef HAVE_MEMALIGN
+/* some systems have memalign() but no declaration for it */
+void * memalign (size_t align, size_t size);
+#else
+/* assume malloc alignment is sufficient */
+#define memalign(align,size) malloc (size)
+#endif
+
+
+
+typedef struct {
+    sample_t q1[2];
+    sample_t q2[2];
+    sample_t q4;
+    int q1_ptr;
+    int q2_ptr;
+    int q4_ptr;
+} quantizer_t;
+
+static uint8_t halfrate[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3};
+
+a52_state_t * a52_init (uint32_t mm_accel)
+{
+    a52_state_t * state;
+    int i;
+
+    state = malloc (sizeof (a52_state_t));
+    if (state == NULL)
+	return NULL;
+
+    state-&gt;samples = memalign (16, 256 * 12 * sizeof (sample_t));
+    if (state-&gt;samples == NULL) {
+	free (state);
+	return NULL;
+    }
+
+    for (i = 0; i &lt; 256 * 12; i++)
+	state-&gt;samples[i] = 0;
+
+    state-&gt;downmixed = 1;
+
+    state-&gt;lfsr_state = 1;
+
+    a52_imdct_init (mm_accel);
+
+    return state;
+}
+
+sample_t * a52_samples (a52_state_t * state)
+{
+    return state-&gt;samples;
+}
+
+int a52_syncinfo (uint8_t * buf, int * flags,
+		  int * sample_rate, int * bit_rate)
+{
+    static int rate[] = { 32,  40,  48,  56,  64,  80,  96, 112,
+			 128, 160, 192, 224, 256, 320, 384, 448,
+			 512, 576, 640};
+    static uint8_t lfeon[8] = {0x10, 0x10, 0x04, 0x04, 0x04, 0x01, 0x04, 0x01};
+    int frmsizecod;
+    int bitrate;
+    int half;
+    int acmod;
+
+    if ((buf[0] != 0x0b) || (buf[1] != 0x77))	/* syncword */
+	return 0;
+
+    if (buf[5] &gt;= 0x60)		/* bsid &gt;= 12 */
+	return 0;
+    half = halfrate[buf[5] &gt;&gt; 3];
+
+    /* acmod, dsurmod and lfeon */
+    acmod = buf[6] &gt;&gt; 5;
+    *flags = ((((buf[6] &amp; 0xf8) == 0x50) ? A52_DOLBY : acmod) |
+	      ((buf[6] &amp; lfeon[acmod]) ? A52_LFE : 0));
+
+    frmsizecod = buf[4] &amp; 63;
+    if (frmsizecod &gt;= 38)
+	return 0;
+    bitrate = rate [frmsizecod &gt;&gt; 1];
+    *bit_rate = (bitrate * 1000) &gt;&gt; half;
+
+    switch (buf[4] &amp; 0xc0) {
+    case 0:
+	*sample_rate = 48000 &gt;&gt; half;
+	return 4 * bitrate;
+    case 0x40:
+	*sample_rate = 44100 &gt;&gt; half;
+	return 2 * (320 * bitrate / 147 + (frmsizecod &amp; 1));
+    case 0x80:
+	*sample_rate = 32000 &gt;&gt; half;
+	return 6 * bitrate;
+    default:
+	return 0;
+    }
+}
+
+int a52_frame (a52_state_t * state, uint8_t * buf, int * flags,
+	       sample_t * level, sample_t bias)
+{
+    static sample_t clev[4] = {LEVEL_3DB, LEVEL_45DB, LEVEL_6DB, LEVEL_45DB};
+    static sample_t slev[4] = {LEVEL_3DB, LEVEL_6DB, 0, LEVEL_6DB};
+    int chaninfo;
+    int acmod;
+
+    state-&gt;fscod = buf[4] &gt;&gt; 6;
+    state-&gt;halfrate = halfrate[buf[5] &gt;&gt; 3];
+    state-&gt;acmod = acmod = buf[6] &gt;&gt; 5;
+
+    a52_bitstream_set_ptr (state, buf + 6);
+    bitstream_get (state, 3);	/* skip acmod we already parsed */
+
+    if ((acmod == 2) &amp;&amp; (bitstream_get (state, 2) == 2))	/* dsurmod */
+	acmod = A52_DOLBY;
+
+    if ((acmod &amp; 1) &amp;&amp; (acmod != 1))
+	state-&gt;clev = clev[bitstream_get (state, 2)];	/* cmixlev */
+
+    if (acmod &amp; 4)
+	state-&gt;slev = slev[bitstream_get (state, 2)];	/* surmixlev */
+
+    state-&gt;lfeon = bitstream_get (state, 1);
+
+    state-&gt;output = a52_downmix_init (acmod, *flags, level,
+				      state-&gt;clev, state-&gt;slev);
+    if (state-&gt;output &lt; 0)
+	return 1;
+    if (state-&gt;lfeon &amp;&amp; (*flags &amp; A52_LFE))
+	state-&gt;output |= A52_LFE;
+    *flags = state-&gt;output;
+    /* the 2* compensates for differences in imdct */
+    state-&gt;dynrng = state-&gt;level = 2 * *level;
+    state-&gt;bias = bias;
+    state-&gt;dynrnge = 1;
+    state-&gt;dynrngcall = NULL;
+    state-&gt;cplba.deltbae = DELTA_BIT_NONE;
+    state-&gt;ba[0].deltbae = state-&gt;ba[1].deltbae = state-&gt;ba[2].deltbae =
+	state-&gt;ba[3].deltbae = state-&gt;ba[4].deltbae = DELTA_BIT_NONE;
+
+    chaninfo = !acmod;
+    do {
+	bitstream_get (state, 5);	/* dialnorm */
+	if (bitstream_get (state, 1))	/* compre */
+	    bitstream_get (state, 8);	/* compr */
+	if (bitstream_get (state, 1))	/* langcode */
+	    bitstream_get (state, 8);	/* langcod */
+	if (bitstream_get (state, 1))	/* audprodie */
+	    bitstream_get (state, 7);	/* mixlevel + roomtyp */
+    } while (chaninfo--);
+
+    bitstream_get (state, 2);		/* copyrightb + origbs */
+
+    if (bitstream_get (state, 1))	/* timecod1e */
+	bitstream_get (state, 14);	/* timecod1 */
+    if (bitstream_get (state, 1))	/* timecod2e */
+	bitstream_get (state, 14);	/* timecod2 */
+
+    if (bitstream_get (state, 1)) {	/* addbsie */
+	int addbsil;
+
+	addbsil = bitstream_get (state, 6);
+	do {
+	    bitstream_get (state, 8);	/* addbsi */
+	} while (addbsil--);
+    }
+
+    return 0;
+}
+
+void a52_dynrng (a52_state_t * state,
+		 sample_t (* call) (sample_t, void *), void * data)
+{
+    state-&gt;dynrnge = 0;
+    if (call) {
+	state-&gt;dynrnge = 1;
+	state-&gt;dynrngcall = call;
+	state-&gt;dynrngdata = data;
+    }
+}
+
+static int parse_exponents (a52_state_t * state, int expstr, int ngrps,
+			    uint8_t exponent, uint8_t * dest)
+{
+    int exps;
+
+    while (ngrps--) {
+	exps = bitstream_get (state, 7);
+
+	exponent += exp_1[exps];
+	if (exponent &gt; 24)
+	    return 1;
+
+	switch (expstr) {
+	case EXP_D45:
+	    *(dest++) = exponent;
+	    *(dest++) = exponent;
+	case EXP_D25:
+	    *(dest++) = exponent;
+	case EXP_D15:
+	    *(dest++) = exponent;
+	}
+
+	exponent += exp_2[exps];
+	if (exponent &gt; 24)
+	    return 1;
+
+	switch (expstr) {
+	case EXP_D45:
+	    *(dest++) = exponent;
+	    *(dest++) = exponent;
+	case EXP_D25:
+	    *(dest++) = exponent;
+	case EXP_D15:
+	    *(dest++) = exponent;
+	}
+
+	exponent += exp_3[exps];
+	if (exponent &gt; 24)
+	    return 1;
+
+	switch (expstr) {
+	case EXP_D45:
+	    *(dest++) = exponent;
+	    *(dest++) = exponent;
+	case EXP_D25:
+	    *(dest++) = exponent;
+	case EXP_D15:
+	    *(dest++) = exponent;
+	}
+    }	
+
+    return 0;
+}
+
+static int parse_deltba (a52_state_t * state, int8_t * deltba)
+{
+    int deltnseg, deltlen, delta, j;
+
+    memset (deltba, 0, 50);
+
+    deltnseg = bitstream_get (state, 3);
+    j = 0;
+    do {
+	j += bitstream_get (state, 5);
+	deltlen = bitstream_get (state, 4);
+	delta = bitstream_get (state, 3);
+	delta -= (delta &gt;= 4) ? 3 : 4;
+	if (!deltlen)
+	    continue;
+	if (j + deltlen &gt;= 50)
+	    return 1;
+	while (deltlen--)
+	    deltba[j++] = delta;
+    } while (deltnseg--);
+
+    return 0;
+}
+
+static inline int zero_snr_offsets (int nfchans, a52_state_t * state)
+{
+    int i;
+
+    if ((state-&gt;csnroffst) ||
+	(state-&gt;chincpl &amp;&amp; state-&gt;cplba.bai &gt;&gt; 3) ||	/* cplinu, fsnroffst */
+	(state-&gt;lfeon &amp;&amp; state-&gt;lfeba.bai &gt;&gt; 3))	/* fsnroffst */
+	return 0;
+    for (i = 0; i &lt; nfchans; i++)
+	if (state-&gt;ba[i].bai &gt;&gt; 3)			/* fsnroffst */
+	    return 0;
+    return 1;
+}
+
+static inline int16_t dither_gen (a52_state_t * state)
+{
+    int16_t nstate;
+
+    nstate = dither_lut[state-&gt;lfsr_state &gt;&gt; 8] ^ (state-&gt;lfsr_state &lt;&lt; 8);
+	
+    state-&gt;lfsr_state = (uint16_t) nstate;
+
+    return nstate;
+}
+
+static void coeff_get (a52_state_t * state, sample_t * coeff,
+		       expbap_t * expbap, quantizer_t * quantizer,
+		       sample_t level, int dither, int end)
+{
+    int i;
+    uint8_t * exp;
+    int8_t * bap;
+    sample_t factor[25];
+
+    for (i = 0; i &lt;= 24; i++)
+	factor[i] = scale_factor[i] * level;
+
+    exp = expbap-&gt;exp;
+    bap = expbap-&gt;bap;
+
+    for (i = 0; i &lt; end; i++) {
+	int bapi;
+
+	bapi = bap[i];
+	switch (bapi) {
+	case 0:
+	    if (dither) {
+		coeff[i] = dither_gen (state) * LEVEL_3DB * factor[exp[i]];
+		continue;
+	    } else {
+		coeff[i] = 0;
+		continue;
+	    }
+
+	case -1:
+	    if (quantizer-&gt;q1_ptr &gt;= 0) {
+		coeff[i] = quantizer-&gt;q1[quantizer-&gt;q1_ptr--] * factor[exp[i]];
+		continue;
+	    } else {
+		int code;
+
+		code = bitstream_get (state, 5);
+
+		quantizer-&gt;q1_ptr = 1;
+		quantizer-&gt;q1[0] = q_1_2[code];
+		quantizer-&gt;q1[1] = q_1_1[code];
+		coeff[i] = q_1_0[code] * factor[exp[i]];
+		continue;
+	    }
+
+	case -2:
+	    if (quantizer-&gt;q2_ptr &gt;= 0) {
+		coeff[i] = quantizer-&gt;q2[quantizer-&gt;q2_ptr--] * factor[exp[i]];
+		continue;
+	    } else {
+		int code;
+
+		code = bitstream_get (state, 7);
+
+		quantizer-&gt;q2_ptr = 1;
+		quantizer-&gt;q2[0] = q_2_2[code];
+		quantizer-&gt;q2[1] = q_2_1[code];
+		coeff[i] = q_2_0[code] * factor[exp[i]];
+		continue;
+	    }
+
+	case 3:
+	    coeff[i] = q_3[bitstream_get (state, 3)] * factor[exp[i]];
+	    continue;
+
+	case -3:
+	    if (quantizer-&gt;q4_ptr == 0) {
+		quantizer-&gt;q4_ptr = -1;
+		coeff[i] = quantizer-&gt;q4 * factor[exp[i]];
+		continue;
+	    } else {
+		int code;
+
+		code = bitstream_get (state, 7);
+
+		quantizer-&gt;q4_ptr = 0;
+		quantizer-&gt;q4 = q_4_1[code];
+		coeff[i] = q_4_0[code] * factor[exp[i]];
+		continue;
+	    }
+
+	case 4:
+	    coeff[i] = q_5[bitstream_get (state, 4)] * factor[exp[i]];
+	    continue;
+
+	default:
+	    coeff[i] = ((bitstream_get_2 (state, bapi) &lt;&lt; (16 - bapi)) *
+			  factor[exp[i]]);
+	}
+    }
+}
+
+static void coeff_get_coupling (a52_state_t * state, int nfchans,
+				sample_t * coeff, sample_t (* samples)[256],
+				quantizer_t * quantizer, uint8_t dithflag[5])
+{
+    int cplbndstrc, bnd, i, i_end, ch;
+    uint8_t * exp;
+    int8_t * bap;
+    sample_t cplco[5];
+
+    exp = state-&gt;cpl_expbap.exp;
+    bap = state-&gt;cpl_expbap.bap;
+    bnd = 0;
+    cplbndstrc = state-&gt;cplbndstrc;
+    i = state-&gt;cplstrtmant;
+    while (i &lt; state-&gt;cplendmant) {
+	i_end = i + 12;
+	while (cplbndstrc &amp; 1) {
+	    cplbndstrc &gt;&gt;= 1;
+	    i_end += 12;
+	}
+	cplbndstrc &gt;&gt;= 1;
+	for (ch = 0; ch &lt; nfchans; ch++)
+	    cplco[ch] = state-&gt;cplco[ch][bnd] * coeff[ch];
+	bnd++;
+
+	while (i &lt; i_end) {
+	    sample_t cplcoeff;
+	    int bapi;
+
+	    bapi = bap[i];
+	    switch (bapi) {
+	    case 0:
+		cplcoeff = LEVEL_3DB * scale_factor[exp[i]];
+		for (ch = 0; ch &lt; nfchans; ch++)
+		    if ((state-&gt;chincpl &gt;&gt; ch) &amp; 1) {
+			if (dithflag[ch])
+			    samples[ch][i] = (cplcoeff * cplco[ch] *
+					      dither_gen (state));
+			else
+			    samples[ch][i] = 0;
+		    }
+		i++;
+		continue;
+
+	    case -1:
+		if (quantizer-&gt;q1_ptr &gt;= 0) {
+		    cplcoeff = quantizer-&gt;q1[quantizer-&gt;q1_ptr--];
+		    break;
+		} else {
+		    int code;
+
+		    code = bitstream_get (state, 5);
+
+		    quantizer-&gt;q1_ptr = 1;
+		    quantizer-&gt;q1[0] = q_1_2[code];
+		    quantizer-&gt;q1[1] = q_1_1[code];
+		    cplcoeff = q_1_0[code];
+		    break;
+		}
+
+	    case -2:
+		if (quantizer-&gt;q2_ptr &gt;= 0) {
+		    cplcoeff = quantizer-&gt;q2[quantizer-&gt;q2_ptr--];
+		    break;
+		} else {
+		    int code;
+
+		    code = bitstream_get (state, 7);
+
+		    quantizer-&gt;q2_ptr = 1;
+		    quantizer-&gt;q2[0] = q_2_2[code];
+		    quantizer-&gt;q2[1] = q_2_1[code];
+		    cplcoeff = q_2_0[code];
+		    break;
+		}
+
+	    case 3:
+		cplcoeff = q_3[bitstream_get (state, 3)];
+		break;
+
+	    case -3:
+		if (quantizer-&gt;q4_ptr == 0) {
+		    quantizer-&gt;q4_ptr = -1;
+		    cplcoeff = quantizer-&gt;q4;
+		    break;
+		} else {
+		    int code;
+
+		    code = bitstream_get (state, 7);
+
+		    quantizer-&gt;q4_ptr = 0;
+		    quantizer-&gt;q4 = q_4_1[code];
+		    cplcoeff = q_4_0[code];
+		    break;
+		}
+
+	    case 4:
+		cplcoeff = q_5[bitstream_get (state, 4)];
+		break;
+
+	    default:
+		cplcoeff = bitstream_get_2 (state, bapi) &lt;&lt; (16 - bapi);
+	    }
+
+	    cplcoeff *= scale_factor[exp[i]];
+	    for (ch = 0; ch &lt; nfchans; ch++)
+		if ((state-&gt;chincpl &gt;&gt; ch) &amp; 1)
+		    samples[ch][i] = cplcoeff * cplco[ch];
+	    i++;
+	}
+    }
+}
+
+int a52_block (a52_state_t * state)
+{
+    static const uint8_t nfchans_tbl[] = {2, 1, 2, 3, 3, 4, 4, 5, 1, 1, 2};
+    static int rematrix_band[4] = {25, 37, 61, 253};
+    int i, nfchans, chaninfo;
+    uint8_t cplexpstr, chexpstr[5], lfeexpstr, do_bit_alloc, done_cpl;
+    uint8_t blksw[5], dithflag[5];
+    sample_t coeff[5];
+    int chanbias;
+    quantizer_t quantizer;
+    sample_t * samples;
+
+    nfchans = nfchans_tbl[state-&gt;acmod];
+
+    for (i = 0; i &lt; nfchans; i++)
+	blksw[i] = bitstream_get (state, 1);
+
+    for (i = 0; i &lt; nfchans; i++)
+	dithflag[i] = bitstream_get (state, 1);
+
+    chaninfo = !state-&gt;acmod;
+    do {
+	if (bitstream_get (state, 1)) {	/* dynrnge */
+	    int dynrng;
+
+	    dynrng = bitstream_get_2 (state, 8);
+	    if (state-&gt;dynrnge) {
+		sample_t range;
+
+		range = ((((dynrng &amp; 0x1f) | 0x20) &lt;&lt; 13) *
+			 scale_factor[3 - (dynrng &gt;&gt; 5)]);
+		if (state-&gt;dynrngcall)
+		    range = state-&gt;dynrngcall (range, state-&gt;dynrngdata);
+		state-&gt;dynrng = state-&gt;level * range;
+	    }
+	}
+    } while (chaninfo--);
+
+    if (bitstream_get (state, 1)) {	/* cplstre */
+	state-&gt;chincpl = 0;
+	if (bitstream_get (state, 1)) {	/* cplinu */
+	    static uint8_t bndtab[16] = {31, 35, 37, 39, 41, 42, 43, 44,
+					 45, 45, 46, 46, 47, 47, 48, 48};
+	    int cplbegf;
+	    int cplendf;
+	    int ncplsubnd;
+
+	    for (i = 0; i &lt; nfchans; i++)
+		state-&gt;chincpl |= bitstream_get (state, 1) &lt;&lt; i;
+	    switch (state-&gt;acmod) {
+	    case 0: case 1:
+		return 1;
+	    case 2:
+		state-&gt;phsflginu = bitstream_get (state, 1);
+	    }
+	    cplbegf = bitstream_get (state, 4);
+	    cplendf = bitstream_get (state, 4);
+
+	    if (cplendf + 3 - cplbegf &lt; 0)
+		return 1;
+	    state-&gt;ncplbnd = ncplsubnd = cplendf + 3 - cplbegf;
+	    state-&gt;cplstrtbnd = bndtab[cplbegf];
+	    state-&gt;cplstrtmant = cplbegf * 12 + 37;
+	    state-&gt;cplendmant = cplendf * 12 + 73;
+
+	    state-&gt;cplbndstrc = 0;
+	    for (i = 0; i &lt; ncplsubnd - 1; i++)
+		if (bitstream_get (state, 1)) {
+		    state-&gt;cplbndstrc |= 1 &lt;&lt; i;
+		    state-&gt;ncplbnd--;
+		}
+	}
+    }
+
+    if (state-&gt;chincpl) {	/* cplinu */
+	int j, cplcoe;
+
+	cplcoe = 0;
+	for (i = 0; i &lt; nfchans; i++)
+	    if ((state-&gt;chincpl) &gt;&gt; i &amp; 1)
+		if (bitstream_get (state, 1)) {	/* cplcoe */
+		    int mstrcplco, cplcoexp, cplcomant;
+
+		    cplcoe = 1;
+		    mstrcplco = 3 * bitstream_get (state, 2);
+		    for (j = 0; j &lt; state-&gt;ncplbnd; j++) {
+			cplcoexp = bitstream_get (state, 4);
+			cplcomant = bitstream_get (state, 4);
+			if (cplcoexp == 15)
+			    cplcomant &lt;&lt;= 14;
+			else
+			    cplcomant = (cplcomant | 0x10) &lt;&lt; 13;
+			state-&gt;cplco[i][j] =
+			    cplcomant * scale_factor[cplcoexp + mstrcplco];
+		    }
+		}
+	if ((state-&gt;acmod == 2) &amp;&amp; state-&gt;phsflginu &amp;&amp; cplcoe)
+	    for (j = 0; j &lt; state-&gt;ncplbnd; j++)
+		if (bitstream_get (state, 1))	/* phsflg */
+		    state-&gt;cplco[1][j] = -state-&gt;cplco[1][j];
+    }
+
+    if ((state-&gt;acmod == 2) &amp;&amp; (bitstream_get (state, 1))) {	/* rematstr */
+	int end;
+
+	state-&gt;rematflg = 0;
+	end = (state-&gt;chincpl) ? state-&gt;cplstrtmant : 253;	/* cplinu */
+	i = 0;
+	do
+	    state-&gt;rematflg |= bitstream_get (state, 1) &lt;&lt; i;
+	while (rematrix_band[i++] &lt; end);
+    }
+
+    cplexpstr = EXP_REUSE;
+    lfeexpstr = EXP_REUSE;
+    if (state-&gt;chincpl)	/* cplinu */
+	cplexpstr = bitstream_get (state, 2);
+    for (i = 0; i &lt; nfchans; i++)
+	chexpstr[i] = bitstream_get (state, 2);
+    if (state-&gt;lfeon) 
+	lfeexpstr = bitstream_get (state, 1);
+
+    for (i = 0; i &lt; nfchans; i++)
+	if (chexpstr[i] != EXP_REUSE) {
+	    if ((state-&gt;chincpl &gt;&gt; i) &amp; 1)
+		state-&gt;endmant[i] = state-&gt;cplstrtmant;
+	    else {
+		int chbwcod;
+
+		chbwcod = bitstream_get (state, 6);
+		if (chbwcod &gt; 60)
+		    return 1;
+		state-&gt;endmant[i] = chbwcod * 3 + 73;
+	    }
+	}
+
+    do_bit_alloc = 0;
+
+    if (cplexpstr != EXP_REUSE) {
+	int cplabsexp, ncplgrps;
+
+	do_bit_alloc = 64;
+	ncplgrps = ((state-&gt;cplendmant - state-&gt;cplstrtmant) /
+		    (3 &lt;&lt; (cplexpstr - 1)));
+	cplabsexp = bitstream_get (state, 4) &lt;&lt; 1;
+	if (parse_exponents (state, cplexpstr, ncplgrps, cplabsexp,
+			     state-&gt;cpl_expbap.exp + state-&gt;cplstrtmant))
+	    return 1;
+    }
+    for (i = 0; i &lt; nfchans; i++)
+	if (chexpstr[i] != EXP_REUSE) {
+	    int grp_size, nchgrps;
+
+	    do_bit_alloc |= 1 &lt;&lt; i;
+	    grp_size = 3 &lt;&lt; (chexpstr[i] - 1);
+	    nchgrps = (state-&gt;endmant[i] + grp_size - 4) / grp_size;
+	    state-&gt;fbw_expbap[i].exp[0] = bitstream_get (state, 4);
+	    if (parse_exponents (state, chexpstr[i], nchgrps,
+				 state-&gt;fbw_expbap[i].exp[0],
+				 state-&gt;fbw_expbap[i].exp + 1))
+		return 1;
+	    bitstream_get (state, 2);	/* gainrng */
+	}
+    if (lfeexpstr != EXP_REUSE) {
+	do_bit_alloc |= 32;
+	state-&gt;lfe_expbap.exp[0] = bitstream_get (state, 4);
+	if (parse_exponents (state, lfeexpstr, 2, state-&gt;lfe_expbap.exp[0],
+			     state-&gt;lfe_expbap.exp + 1))
+	    return 1;
+    }
+
+    if (bitstream_get (state, 1)) {	/* baie */
+	do_bit_alloc = -1;
+	state-&gt;bai = bitstream_get (state, 11);
+    }
+    if (bitstream_get (state, 1)) {	/* snroffste */
+	do_bit_alloc = -1;
+	state-&gt;csnroffst = bitstream_get (state, 6);
+	if (state-&gt;chincpl)	/* cplinu */
+	    state-&gt;cplba.bai = bitstream_get (state, 7);
+	for (i = 0; i &lt; nfchans; i++)
+	    state-&gt;ba[i].bai = bitstream_get (state, 7);
+	if (state-&gt;lfeon)
+	    state-&gt;lfeba.bai = bitstream_get (state, 7);
+    }
+    if ((state-&gt;chincpl) &amp;&amp; (bitstream_get (state, 1))) { /* cplleake */
+	do_bit_alloc |= 64;
+	state-&gt;cplfleak = 9 - bitstream_get (state, 3);
+	state-&gt;cplsleak = 9 - bitstream_get (state, 3);
+    }
+
+    if (bitstream_get (state, 1)) {	/* deltbaie */
+	do_bit_alloc = -1;
+	if (state-&gt;chincpl)	/* cplinu */
+	    state-&gt;cplba.deltbae = bitstream_get (state, 2);
+	for (i = 0; i &lt; nfchans; i++)
+	    state-&gt;ba[i].deltbae = bitstream_get (state, 2);
+	if (state-&gt;chincpl &amp;&amp;	/* cplinu */
+	    (state-&gt;cplba.deltbae == DELTA_BIT_NEW) &amp;&amp;
+	    parse_deltba (state, state-&gt;cplba.deltba))
+	    return 1;
+	for (i = 0; i &lt; nfchans; i++)
+	    if ((state-&gt;ba[i].deltbae == DELTA_BIT_NEW) &amp;&amp;
+		parse_deltba (state, state-&gt;ba[i].deltba))
+		return 1;
+    }
+
+    if (do_bit_alloc) {
+	if (zero_snr_offsets (nfchans, state)) {
+	    memset (state-&gt;cpl_expbap.bap, 0, sizeof (state-&gt;cpl_expbap.bap));
+	    for (i = 0; i &lt; nfchans; i++)
+		memset (state-&gt;fbw_expbap[i].bap, 0,
+			sizeof (state-&gt;fbw_expbap[i].bap));
+	    memset (state-&gt;lfe_expbap.bap, 0, sizeof (state-&gt;lfe_expbap.bap));
+	} else {
+	    if (state-&gt;chincpl &amp;&amp; (do_bit_alloc &amp; 64))	/* cplinu */
+		a52_bit_allocate (state, &amp;state-&gt;cplba, state-&gt;cplstrtbnd,
+				  state-&gt;cplstrtmant, state-&gt;cplendmant,
+				  state-&gt;cplfleak &lt;&lt; 8, state-&gt;cplsleak &lt;&lt; 8,
+				  &amp;state-&gt;cpl_expbap);
+	    for (i = 0; i &lt; nfchans; i++)
+		if (do_bit_alloc &amp; (1 &lt;&lt; i))
+		    a52_bit_allocate (state, state-&gt;ba + i, 0, 0,
+				      state-&gt;endmant[i], 0, 0,
+				      state-&gt;fbw_expbap +i);
+	    if (state-&gt;lfeon &amp;&amp; (do_bit_alloc &amp; 32)) {
+		state-&gt;lfeba.deltbae = DELTA_BIT_NONE;
+		a52_bit_allocate (state, &amp;state-&gt;lfeba, 0, 0, 7, 0, 0,
+				  &amp;state-&gt;lfe_expbap);
+	    }
+	}
+    }
+
+    if (bitstream_get (state, 1)) {	/* skiple */
+	i = bitstream_get (state, 9);	/* skipl */
+	while (i--)
+	    bitstream_get (state, 8);
+    }
+
+    samples = state-&gt;samples;
+    if (state-&gt;output &amp; A52_LFE)
+	samples += 256;	/* shift for LFE channel */
+
+    chanbias = a52_downmix_coeff (coeff, state-&gt;acmod, state-&gt;output,
+				  state-&gt;dynrng, state-&gt;clev, state-&gt;slev);
+
+    quantizer.q1_ptr = quantizer.q2_ptr = quantizer.q4_ptr = -1;
+    done_cpl = 0;
+
+    for (i = 0; i &lt; nfchans; i++) {
+	int j;
+
+	coeff_get (state, samples + 256 * i, state-&gt;fbw_expbap +i, &amp;quantizer,
+		   coeff[i], dithflag[i], state-&gt;endmant[i]);
+
+	if ((state-&gt;chincpl &gt;&gt; i) &amp; 1) {
+	    if (!done_cpl) {
+		done_cpl = 1;
+		coeff_get_coupling (state, nfchans, coeff,
+				    (sample_t (*)[256])samples, &amp;quantizer,
+				    dithflag);
+	    }
+	    j = state-&gt;cplendmant;
+	} else
+	    j = state-&gt;endmant[i];
+	do
+	    (samples + 256 * i)[j] = 0;
+	while (++j &lt; 256);
+    }
+
+    if (state-&gt;acmod == 2) {
+	int j, end, band, rematflg;
+
+	end = ((state-&gt;endmant[0] &lt; state-&gt;endmant[1]) ?
+	       state-&gt;endmant[0] : state-&gt;endmant[1]);
+
+	i = 0;
+	j = 13;
+	rematflg = state-&gt;rematflg;
+	do {
+	    if (! (rematflg &amp; 1)) {
+		rematflg &gt;&gt;= 1;
+		j = rematrix_band[i++];
+		continue;
+	    }
+	    rematflg &gt;&gt;= 1;
+	    band = rematrix_band[i++];
+	    if (band &gt; end)
+		band = end;
+	    do {
+		sample_t tmp0, tmp1;
+
+		tmp0 = samples[j];
+		tmp1 = (samples+256)[j];
+		samples[j] = tmp0 + tmp1;
+		(samples+256)[j] = tmp0 - tmp1;
+	    } while (++j &lt; band);
+	} while (j &lt; end);
+    }
+
+    if (state-&gt;lfeon) {
+	if (state-&gt;output &amp; A52_LFE) {
+	    coeff_get (state, samples - 256, &amp;state-&gt;lfe_expbap, &amp;quantizer,
+		       state-&gt;dynrng, 0, 7);
+	    for (i = 7; i &lt; 256; i++)
+		(samples-256)[i] = 0;
+	    a52_imdct_512 (samples - 256, samples + 1536 - 256, state-&gt;bias);
+	} else {
+	    /* just skip the LFE coefficients */
+	    coeff_get (state, samples + 1280, &amp;state-&gt;lfe_expbap, &amp;quantizer,
+		       0, 0, 7);
+	}
+    }
+
+    i = 0;
+    if (nfchans_tbl[state-&gt;output &amp; A52_CHANNEL_MASK] &lt; nfchans)
+	for (i = 1; i &lt; nfchans; i++)
+	    if (blksw[i] != blksw[0])
+		break;
+
+    if (i &lt; nfchans) {
+	if (state-&gt;downmixed) {
+	    state-&gt;downmixed = 0;
+	    a52_upmix (samples + 1536, state-&gt;acmod, state-&gt;output);
+	}
+
+	for (i = 0; i &lt; nfchans; i++) {
+	    sample_t bias;
+
+	    bias = 0;
+	    if (!(chanbias &amp; (1 &lt;&lt; i)))
+		bias = state-&gt;bias;
+
+	    if (coeff[i]) {
+		if (blksw[i])
+		    a52_imdct_256 (samples + 256 * i, samples + 1536 + 256 * i,
+				   bias);
+		else 
+		    a52_imdct_512 (samples + 256 * i, samples + 1536 + 256 * i,
+				   bias);
+	    } else {
+		int j;
+
+		for (j = 0; j &lt; 256; j++)
+		    (samples + 256 * i)[j] = bias;
+	    }
+	}
+
+	a52_downmix (samples, state-&gt;acmod, state-&gt;output, state-&gt;bias,
+		     state-&gt;clev, state-&gt;slev);
+    } else {
+	nfchans = nfchans_tbl[state-&gt;output &amp; A52_CHANNEL_MASK];
+
+	a52_downmix (samples, state-&gt;acmod, state-&gt;output, 0,
+		     state-&gt;clev, state-&gt;slev);
+
+	if (!state-&gt;downmixed) {
+	    state-&gt;downmixed = 1;
+	    a52_downmix (samples + 1536, state-&gt;acmod, state-&gt;output, 0,
+			 state-&gt;clev, state-&gt;slev);
+	}
+
+	if (blksw[0])
+	    for (i = 0; i &lt; nfchans; i++)
+		a52_imdct_256 (samples + 256 * i, samples + 1536 + 256 * i,
+			       state-&gt;bias);
+	else 
+	    for (i = 0; i &lt; nfchans; i++)
+		a52_imdct_512 (samples + 256 * i, samples + 1536 + 256 * i,
+			       state-&gt;bias);
+    }
+
+    return 0;
+}
+
+void a52_free (a52_state_t * state)
+{
+    free (state-&gt;samples);
+    free (state);
+}

Copied: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/tables.h (from rev 3841, branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/tables.h)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_libraries/ADM_liba52/tables.h	2008-03-07 06:54:27 UTC (rev 3841)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/ADM_liba52/tables.h	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,246 @@
+/*
+ * tables.h
+ * Copyright (C) 2000-2002 Michel Lespinasse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">walken at zoy.org</A>&gt;
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file is part of a52dec, a free ATSC A-52 stream decoder.
+ * See <A HREF="http://liba52.sourceforge.net/">http://liba52.sourceforge.net/</A> for updates.
+ *
+ * a52dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * a52dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+static const int8_t exp_1[128] = {
+    -2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+    25,25,25
+};
+static const int8_t exp_2[128] = {
+    -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
+    -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
+    -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
+    -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
+    -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
+    25,25,25
+};
+static const int8_t exp_3[128] = {
+    -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,
+    -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,
+    -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,
+    -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,
+    -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,
+    25,25,25
+};
+
+#define Q0 ((-2 &lt;&lt; 15) / 3.0)
+#define Q1 (0)
+#define Q2 ((2 &lt;&lt; 15) / 3.0)
+
+static const sample_t q_1_0[32] = {
+    Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,
+    Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,
+    Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,
+    0,0,0,0,0
+};
+
+static const sample_t q_1_1[32] = {
+    Q0,Q0,Q0,Q1,Q1,Q1,Q2,Q2,Q2,
+    Q0,Q0,Q0,Q1,Q1,Q1,Q2,Q2,Q2,
+    Q0,Q0,Q0,Q1,Q1,Q1,Q2,Q2,Q2,
+    0,0,0,0,0
+};
+
+static const sample_t q_1_2[32] = {
+    Q0,Q1,Q2,Q0,Q1,Q2,Q0,Q1,Q2,
+    Q0,Q1,Q2,Q0,Q1,Q2,Q0,Q1,Q2,
+    Q0,Q1,Q2,Q0,Q1,Q2,Q0,Q1,Q2,
+    0,0,0,0,0
+};
+
+#undef Q0
+#undef Q1
+#undef Q2
+
+#define Q0 ((-4 &lt;&lt; 15) / 5.0)
+#define Q1 ((-2 &lt;&lt; 15) / 5.0)
+#define Q2 (0)
+#define Q3 ((2 &lt;&lt; 15) / 5.0)
+#define Q4 ((4 &lt;&lt; 15) / 5.0)
+
+static const sample_t q_2_0[128] = {
+    Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,
+    Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,
+    Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,
+    Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,Q3,
+    Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,Q4,
+    0,0,0
+};
+
+static const sample_t q_2_1[128] = {
+    Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
+    Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
+    Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
+    Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
+    Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
+    0,0,0
+};
+
+static const sample_t q_2_2[128] = {
+    Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
+    Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
+    Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
+    Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
+    Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
+    0,0,0
+};
+
+#undef Q0
+#undef Q1
+#undef Q2
+#undef Q3
+#undef Q4
+
+static const sample_t q_3[8] = {
+    (-6 &lt;&lt; 15)/7.0, (-4 &lt;&lt; 15)/7.0, (-2 &lt;&lt; 15)/7.0, 0,
+    ( 2 &lt;&lt; 15)/7.0, ( 4 &lt;&lt; 15)/7.0, ( 6 &lt;&lt; 15)/7.0, 0
+};
+
+#define Q0 ((-10 &lt;&lt; 15) / 11.0)
+#define Q1 ((-8 &lt;&lt; 15) / 11.0)
+#define Q2 ((-6 &lt;&lt; 15) / 11.0)
+#define Q3 ((-4 &lt;&lt; 15) / 11.0)
+#define Q4 ((-2 &lt;&lt; 15) / 11.0)
+#define Q5 (0)
+#define Q6 ((2 &lt;&lt; 15) / 11.0)
+#define Q7 ((4 &lt;&lt; 15) / 11.0)
+#define Q8 ((6 &lt;&lt; 15) / 11.0)
+#define Q9 ((8 &lt;&lt; 15) / 11.0)
+#define QA ((10 &lt;&lt; 15) / 11.0)
+
+static const sample_t q_4_0[128] = {
+    Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0,
+    Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1,
+    Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2,
+    Q3, Q3, Q3, Q3, Q3, Q3, Q3, Q3, Q3, Q3, Q3,
+    Q4, Q4, Q4, Q4, Q4, Q4, Q4, Q4, Q4, Q4, Q4,
+    Q5, Q5, Q5, Q5, Q5, Q5, Q5, Q5, Q5, Q5, Q5,
+    Q6, Q6, Q6, Q6, Q6, Q6, Q6, Q6, Q6, Q6, Q6,
+    Q7, Q7, Q7, Q7, Q7, Q7, Q7, Q7, Q7, Q7, Q7,
+    Q8, Q8, Q8, Q8, Q8, Q8, Q8, Q8, Q8, Q8, Q8,
+    Q9, Q9, Q9, Q9, Q9, Q9, Q9, Q9, Q9, Q9, Q9,
+    QA, QA, QA, QA, QA, QA, QA, QA, QA, QA, QA,
+    0,  0,  0,  0,  0,  0,  0
+};
+
+static const sample_t q_4_1[128] = {
+    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
+    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
+    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
+    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
+    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
+    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
+    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
+    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
+    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
+    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
+    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
+    0,  0,  0,  0,  0,  0,  0
+};
+
+#undef Q0
+#undef Q1
+#undef Q2
+#undef Q3
+#undef Q4
+#undef Q5
+#undef Q6
+#undef Q7
+#undef Q8
+#undef Q9
+#undef QA
+
+static const sample_t q_5[16] = {
+    (-14 &lt;&lt; 15)/15.0,(-12 &lt;&lt; 15)/15.0,(-10 &lt;&lt; 15)/15.0,
+    ( -8 &lt;&lt; 15)/15.0,( -6 &lt;&lt; 15)/15.0,( -4 &lt;&lt; 15)/15.0,
+    ( -2 &lt;&lt; 15)/15.0,   0            ,(  2 &lt;&lt; 15)/15.0,
+    (  4 &lt;&lt; 15)/15.0,(  6 &lt;&lt; 15)/15.0,(  8 &lt;&lt; 15)/15.0,
+    ( 10 &lt;&lt; 15)/15.0,( 12 &lt;&lt; 15)/15.0,( 14 &lt;&lt; 15)/15.0,
+    0
+};
+
+static const sample_t scale_factor[25] = {
+    0.000030517578125,
+    0.0000152587890625,
+    0.00000762939453125,
+    0.000003814697265625,
+    0.0000019073486328125,
+    0.00000095367431640625,
+    0.000000476837158203125,
+    0.0000002384185791015625,
+    0.00000011920928955078125,
+    0.000000059604644775390625,
+    0.0000000298023223876953125,
+    0.00000001490116119384765625,
+    0.000000007450580596923828125,
+    0.0000000037252902984619140625,
+    0.00000000186264514923095703125,
+    0.000000000931322574615478515625,
+    0.0000000004656612873077392578125,
+    0.00000000023283064365386962890625,
+    0.000000000116415321826934814453125,
+    0.0000000000582076609134674072265625,
+    0.00000000002910383045673370361328125,
+    0.000000000014551915228366851806640625,
+    0.0000000000072759576141834259033203125,
+    0.00000000000363797880709171295166015625,
+    0.000000000001818989403545856475830078125
+};
+
+static const uint16_t dither_lut[256] = {
+    0x0000, 0xa011, 0xe033, 0x4022, 0x6077, 0xc066, 0x8044, 0x2055,
+    0xc0ee, 0x60ff, 0x20dd, 0x80cc, 0xa099, 0x0088, 0x40aa, 0xe0bb,
+    0x21cd, 0x81dc, 0xc1fe, 0x61ef, 0x41ba, 0xe1ab, 0xa189, 0x0198,
+    0xe123, 0x4132, 0x0110, 0xa101, 0x8154, 0x2145, 0x6167, 0xc176,
+    0x439a, 0xe38b, 0xa3a9, 0x03b8, 0x23ed, 0x83fc, 0xc3de, 0x63cf,
+    0x8374, 0x2365, 0x6347, 0xc356, 0xe303, 0x4312, 0x0330, 0xa321,
+    0x6257, 0xc246, 0x8264, 0x2275, 0x0220, 0xa231, 0xe213, 0x4202,
+    0xa2b9, 0x02a8, 0x428a, 0xe29b, 0xc2ce, 0x62df, 0x22fd, 0x82ec,
+    0x8734, 0x2725, 0x6707, 0xc716, 0xe743, 0x4752, 0x0770, 0xa761,
+    0x47da, 0xe7cb, 0xa7e9, 0x07f8, 0x27ad, 0x87bc, 0xc79e, 0x678f,
+    0xa6f9, 0x06e8, 0x46ca, 0xe6db, 0xc68e, 0x669f, 0x26bd, 0x86ac,
+    0x6617, 0xc606, 0x8624, 0x2635, 0x0660, 0xa671, 0xe653, 0x4642,
+    0xc4ae, 0x64bf, 0x249d, 0x848c, 0xa4d9, 0x04c8, 0x44ea, 0xe4fb,
+    0x0440, 0xa451, 0xe473, 0x4462, 0x6437, 0xc426, 0x8404, 0x2415,
+    0xe563, 0x4572, 0x0550, 0xa541, 0x8514, 0x2505, 0x6527, 0xc536,
+    0x258d, 0x859c, 0xc5be, 0x65af, 0x45fa, 0xe5eb, 0xa5c9, 0x05d8,
+    0xae79, 0x0e68, 0x4e4a, 0xee5b, 0xce0e, 0x6e1f, 0x2e3d, 0x8e2c,
+    0x6e97, 0xce86, 0x8ea4, 0x2eb5, 0x0ee0, 0xaef1, 0xeed3, 0x4ec2,
+    0x8fb4, 0x2fa5, 0x6f87, 0xcf96, 0xefc3, 0x4fd2, 0x0ff0, 0xafe1,
+    0x4f5a, 0xef4b, 0xaf69, 0x0f78, 0x2f2d, 0x8f3c, 0xcf1e, 0x6f0f,
+    0xede3, 0x4df2, 0x0dd0, 0xadc1, 0x8d94, 0x2d85, 0x6da7, 0xcdb6,
+    0x2d0d, 0x8d1c, 0xcd3e, 0x6d2f, 0x4d7a, 0xed6b, 0xad49, 0x0d58,
+    0xcc2e, 0x6c3f, 0x2c1d, 0x8c0c, 0xac59, 0x0c48, 0x4c6a, 0xec7b,
+    0x0cc0, 0xacd1, 0xecf3, 0x4ce2, 0x6cb7, 0xcca6, 0x8c84, 0x2c95,
+    0x294d, 0x895c, 0xc97e, 0x696f, 0x493a, 0xe92b, 0xa909, 0x0918,
+    0xe9a3, 0x49b2, 0x0990, 0xa981, 0x89d4, 0x29c5, 0x69e7, 0xc9f6,
+    0x0880, 0xa891, 0xe8b3, 0x48a2, 0x68f7, 0xc8e6, 0x88c4, 0x28d5,
+    0xc86e, 0x687f, 0x285d, 0x884c, 0xa819, 0x0808, 0x482a, 0xe83b,
+    0x6ad7, 0xcac6, 0x8ae4, 0x2af5, 0x0aa0, 0xaab1, 0xea93, 0x4a82,
+    0xaa39, 0x0a28, 0x4a0a, 0xea1b, 0xca4e, 0x6a5f, 0x2a7d, 0x8a6c,
+    0x4b1a, 0xeb0b, 0xab29, 0x0b38, 0x2b6d, 0x8b7c, 0xcb5e, 0x6b4f,
+    0x8bf4, 0x2be5, 0x6bc7, 0xcbd6, 0xeb83, 0x4b92, 0x0bb0, 0xaba1
+};

Added: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/CMakeLists.txt	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_ac3/CMakeLists.txt	2008-03-07 18:34:14 UTC (rev 3843)
@@ -0,0 +1,17 @@
+##
+##
+##
+
+subdirs(PREORDER ADM_liba52)
+
+
+
+include_directories(../../)
+include_directories(../../../ADM_audiocodec)
+include_directories(ADM_liba52)
+
+SET(ADM_ad_a52_SRCS         ADM_ad_a52.cpp )
+
+ADD_LIBRARY(ADM_ad_a52 SHARED ${ADM_ad_a52_SRCS})
+TARGET_LINK_LIBRARIES(ADM_ad_a52 ADM_liba52)
+

Modified: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_mad/ADM_ad_mad.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_mad/ADM_ad_mad.cpp	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/ADM_ad_mad/ADM_ad_mad.cpp	2008-03-07 18:34:14 UTC (rev 3843)
@@ -37,7 +37,7 @@
 		void *_synth;
 
 	public:
-		ADM_AudiocodecMP3(uint32_t fourcc);
+		ADM_AudiocodecMP3(uint32_t fourcc,WAVHeader *info,uint32_t extraLength,uint8_t *extraData);
 		virtual	~ADM_AudiocodecMP3() ;
 		virtual	uint8_t beginDecompress(void);
 		virtual	uint8_t endDecompress(void);
@@ -45,49 +45,19 @@
 		virtual	uint8_t isCompressed(void) {return 1;}
 		virtual	uint8_t isDecompressable(void) {return 1;}
 };
+// Supported formats + declare our plugin
+//*******************************************************
+uint32_t Formats[]={WAV_MP3,WAV_MP2};
+DECLARE_AUDIO_DECODER(ADM_AudiocodecMP3,						// Class
+			0,0,1, 												// Major, minor,patch 
+			Formats, 											// Supported formats
+			&quot;LibMad decoder plugin for avidemux (c) Mean\n&quot;); 	// Desc
 //********************************************************
-extern &quot;C&quot; { 
-ADM_Audiocodec *create(uint32_t fourcc,	WAVHeader *info,uint32_t extraLength,uint8_t *extraData) 
-{ 
-	return new ADM_AudiocodecMP3(fourcc);
-}
-ADM_Audiocodec *destroy(ADM_Audiocodec *codec) 
-{ 
-	ADM_AudiocodecMP3 *a=(ADM_AudiocodecMP3 *)codec;
-	delete a;
-}
-bool supportedFormat(uint32_t audioFourcc) 
-{ 
-	switch(audioFourcc)
-	{
-	case WAV_MP2:
-	case WAV_MP3: return true;
-	default:
-		return false;
-	}
-}
-uint32_t getApiVersion(void)
-{
-		return AD_API_VERSION;
-}
 
-bool getDecoderVersion(uint32_t *major,uint32_t *minor, uint32_t *patch)
+ADM_AudiocodecMP3::ADM_AudiocodecMP3( uint32_t fourcc,WAVHeader *info,uint32_t extraLength,uint8_t *extraData) :   ADM_Audiocodec(fourcc)
 {
-	*major=*minor=0;
-	*patch=1;
-	return true;
-}
-const char *getInfo(void)
-{
-	return &quot;LibMad decoder plugin for avidemux (c) Mean\n&quot;;
-}
-}
-//********************************************************
-
-ADM_AudiocodecMP3::ADM_AudiocodecMP3( uint32_t fourcc) :   ADM_Audiocodec(fourcc)
-{
         if((fourcc!=WAV_MP3) &amp;&amp; (fourcc!=WAV_MP2))
-            ADM_assert(0);
+            ADM_assert(0); 
         if(fourcc==WAV_MP2) printf(&quot;Mpeg1/2 audio codec created\n&quot;);
         _stream=(void *)ADM_alloc(sizeof( mad_stream));
         _frame=(void *)ADM_alloc(sizeof( mad_frame));

Modified: branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/CMakeLists.txt	2008-03-07 11:18:41 UTC (rev 3842)
+++ branches/avidemux_2.5_branch_mean/avidemux/plugins/ADM_audiodecoder/CMakeLists.txt	2008-03-07 18:34:14 UTC (rev 3843)
@@ -1 +1,2 @@
+subdirs(PREORDER ADM_ad_ac3)
 subdirs(PREORDER ADM_ad_mad)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001106.html">[Avidemux-svn-commit] r3842 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_libraries/ADM_mplex ADM_osSupport
</A></li>
	<LI>Next message: <A HREF="001108.html">[Avidemux-svn-commit] r3844 - in	branches/avidemux_2.5_branch_mean/avidemux: ADM_audiocodec	plugins/ADM_audiodecoder plugins/ADM_audiodecoder/ADM_ad_faad	plugins/ADM_audiodecoder/ADM_ad_vorbis
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1107">[ date ]</a>
              <a href="thread.html#1107">[ thread ]</a>
              <a href="subject.html#1107">[ subject ]</a>
              <a href="author.html#1107">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
