<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3891 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_core/include ADM_core/src	ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3891%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%0A%09ADM_core/include%20ADM_core/src%0A%09ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk&In-Reply-To=%3C200803140205.m2E25XNc014518%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001153.html">
   <LINK REL="Next"  HREF="001155.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3891 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_core/include ADM_core/src	ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3891%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%0A%09ADM_core/include%20ADM_core/src%0A%09ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk&In-Reply-To=%3C200803140205.m2E25XNc014518%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3891 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_core/include ADM_core/src	ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk">gruntster at mail.berlios.de
       </A><BR>
    <I>Fri Mar 14 03:05:33 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001153.html">[Avidemux-svn-commit] r3890 -	branches/avidemux_2.5_branch_gruntster/cmake
</A></li>
        <LI>Next message: <A HREF="001155.html">[Avidemux-svn-commit] r3892 - in	branches/avidemux_2.5_branch_gruntster: avidemux	avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2	avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk cmake
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1154">[ date ]</a>
              <a href="thread.html#1154">[ thread ]</a>
              <a href="subject.html#1154">[ subject ]</a>
              <a href="author.html#1154">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2008-03-14 03:05:29 +0100 (Fri, 14 Mar 2008)
New Revision: 3891

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_assert.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/TLK_filesel.cpp
Log:
[Core] remove ADM_core's GLib dependency on Win32

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_assert.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_assert.h	2008-03-13 18:40:35 UTC (rev 3890)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_assert.h	2008-03-14 02:05:29 UTC (rev 3891)
@@ -40,8 +40,6 @@
 int             ADM_fclose (FILE *file);
 uint8_t         ADM_fileExist(char *name);
 uint8_t         ADM_mkdir(const char *name);
-//char            *ADM_rindex(const char *s, int c);
-//char            *ADM_index(const char *s, int c);
 
 /* Replacements for memory allocation functions */
 extern void     *ADM_alloc(size_t size);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp	2008-03-13 18:40:35 UTC (rev 3890)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp	2008-03-14 02:05:29 UTC (rev 3891)
@@ -27,10 +27,6 @@
 #include &lt;Carbon/Carbon.h&gt;
 #endif
 
-#ifdef __MINGW32__
-#include &lt;glib.h&gt;
-#endif
-
 #include &quot;ADM_default.h&quot;
 #include &quot;ADM_toolkit/filesel.h&quot;
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
@@ -65,15 +61,18 @@
 
 FILE *ADM_fopen(const char *file, const char *mode)
 {
-	FILE *f;
-
 #ifdef __MINGW32__
-	gchar *retval = g_locale_from_utf8 (file, -1, NULL, NULL, NULL);
-	f=fopen(retval,mode);
-	g_free (retval);
-	return f;
+	int nFileLen = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, file, -1, NULL, 0);
+	int nModeLen = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, mode, -1, NULL, 0);
+	wchar_t wFile[nFileLen + 1];
+	wchar_t wMode[nModeLen + 1];
+
+	MultiByteToWideChar(CP_UTF8, 0, mode, -1, wMode, nModeLen + 1);
+	MultiByteToWideChar(CP_UTF8, 0, file, -1, wFile, nFileLen + 1);
+
+	return _wfopen(wFile, wMode);
 #else
-	return fopen(file,mode); 
+	return fopen(file, mode);
 #endif
 }
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt	2008-03-13 18:40:35 UTC (rev 3890)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt	2008-03-14 02:05:29 UTC (rev 3891)
@@ -6,9 +6,6 @@
 ADD_TARGET_DEFINITIONS(ADM_core ADM_DEBUG FIND_LEAKS)
 
 IF (MINGW)
-	ADD_SOURCE_CFLAGS(ADM_fileio.cpp ${GLIB_CFLAGS})
-
-	ADD_TARGET_LDFLAGS(ADM_core ${GLIB_LDFLAGS})
 	TARGET_LINK_LIBRARIES(ADM_core pthreadGC2 imagehlp wsock32)
 ELSEIF (APPLE)
 	ADD_TARGET_LDFLAGS(ADM_core &quot;-framework Carbon&quot;)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/TLK_filesel.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/TLK_filesel.cpp	2008-03-13 18:40:35 UTC (rev 3890)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/TLK_filesel.cpp	2008-03-14 02:05:29 UTC (rev 3891)
@@ -1,376 +1,384 @@
 /***************************************************************************
-                          TLK_filesel.cpp  -  description
-                             -------------------
-	New version of file selector
+TLK_filesel.cpp  -  description
+-------------------
+New version of file selector
 
-    begin                : Fri Sep 20 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
+begin                : Fri Sep 20 2002
+copyright            : (C) 2002 by mean
+email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+***************************************************************************/
 
 /***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+***************************************************************************/
 
 #include &quot;toolkit_gtk.h&quot;
+
 #include &lt;errno.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;sys/stat.h&gt;
 #include &lt;dirent.h&gt;
 
+#include &quot;ADM_default.h&quot;
 #include &quot;avi_vars.h&quot;
 
-
 #include &quot;ADM_toolkit/filesel.h&quot;
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 #include &quot;prefs.h&quot;
+
 #define TH_READ 1
 #define TH_WRITE 2
 
-extern char * actual_workbench_file;
+extern char *actual_workbench_file;
 
-static void GUI_FileSel(const char *label, SELFILE_CB * cb, int rw, char **name=NULL);
-char            *ADM_PathCanonize(const char *tmpname);
-void            ADM_PathStripName(char *str);
-uint8_t         initFileSelector(void);
+static void GUI_FileSel(const char *label, SELFILE_CB *cb, int rw, char **name = NULL);
+uint8_t initFileSelector(void);
 
-static GtkFileFilter   *filter_avi=NULL,*filter_mpeg=NULL,*filter_image=NULL,*filter_all=NULL;
-static uint8_t          setFilter( GtkWidget *dialog);
+static GtkFileFilter *filter_avi = NULL, *filter_mpeg = NULL, *filter_image = NULL, *filter_all = NULL;
+static uint8_t setFilter(GtkWidget *dialog);
 
 /**
-    \fn FileSel_SelectRead(const char *title,char *target,uint32_t max, const char *source)
-    \brief allow to select a file
-    @return 0 on failure, 1 on success
-    @param title : window title 
-    @param target : where to copy the result (must be allocated by caller)
-    @param max : Max # of bytes that target can hold
-    @param source : where we start from
+\fn FileSel_SelectRead(const char *title,char *target,uint32_t max, const char *source)
+\brief allow to select a file
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at return</A> 0 on failure, 1 on success
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> title : window title 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> target : where to copy the result (must be allocated by caller)
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> max : Max # of bytes that target can hold
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> source : where we start from
 */
-uint8_t FileSel_SelectRead(const char *title,char *target,uint32_t max, const char *source)
+uint8_t FileSel_SelectRead(const char *title, char *target, uint32_t max, const char *source)
 {
-	
-GtkWidget *dialog;
-uint8_t ret=0;
-gchar *selected_filename;
-gchar last;
-char *dupe=NULL,*tmpname=NULL;
-DIR *dir=NULL;
-	
-	dialog = gtk_file_chooser_dialog_new (&quot;Open File&quot;,
-                                      NULL,
-                                      GTK_FILE_CHOOSER_ACTION_OPEN,
-                                      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-                                      GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
-                                      NULL);
-	gtk_window_set_title (GTK_WINDOW (dialog),title);
-        initFileSelector();
-        setFilter(dialog);
-        gtk_register_dialog(dialog);
-//	gtk_transient(dialog);
+	GtkWidget *dialog;
+	uint8_t ret = 0;
+	gchar *selected_filename, last;
+	char *dupe = NULL, *tmpname = NULL;
+	DIR *dir = NULL;
+
+	dialog = gtk_file_chooser_dialog_new(&quot;Open File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_OPEN,
+		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,	NULL);
+
+	gtk_window_set_title(GTK_WINDOW(dialog), title);
+	initFileSelector();
+	setFilter(dialog);
+	gtk_register_dialog(dialog);
+
 	if (source &amp;&amp; *source)
-	{
-		gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog),(gchar *)source);
-	}
+		gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog), (gchar*)source);
 	else	//use pref
+		if (prefs-&gt;get(LASTDIR_READ, (ADM_filename**)&amp;tmpname))
+			gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), (gchar*)tmpname);
+
+	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
 	{
-		if( prefs-&gt;get(LASTDIR_READ,(ADM_filename **)&amp;tmpname))
+		selected_filename = (gchar *)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+
+		if (strlen(selected_filename))
 		{
-			gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog),(gchar *)tmpname);
-		}
-	}
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_ACCEPT)
-	{
-			selected_filename= (gchar *) 	gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
-			if(strlen(selected_filename))
+			last = selected_filename[strlen(selected_filename) - 1]; 
+
+			if (last == '/' || last =='\\' )
 			{
-			last=selected_filename[strlen(selected_filename) - 1]; 
-			 if (last == '/' || last =='\\' )
-			 {
-                           GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
-						return 0;
+				GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
+				return 0;
 			}
 			else
 			{
 				// Check we can read it ..
-				
-					FILE *fd;
-					fd=fopen(selected_filename,&quot;rb&quot;);
-					if(fd)
-					{	
-						fclose(fd);
-						strncpy(target,(char *)selected_filename,max);
-						// Finally we accept it :)
-						ret=1;
-					}
+				FILE *fd;
+
+				fd = fopen(selected_filename,&quot;rb&quot;);
+
+				if (fd)
+				{
+					fclose(fd);
+					strncpy(target, (char*)selected_filename, max);
+					// Finally we accept it :)
+					ret = 1;
+				}
 			}
-			}
-	}	
-        gtk_unregister_dialog(dialog);
+		}
+	}
+
+	gtk_unregister_dialog(dialog);
 	gtk_widget_destroy(dialog);
+
 	return ret;
 }
 /**
-    \fn FileSel_SelectWrite(const char *title,char *target,uint32_t max, const char *source)
-    \brief allow to select a file
-    @return 0 on failure, 1 on success
-    @param title : window title 
-    @param target : where to copy the result (must be allocated by caller)
-    @param max : Max # of bytes that target can hold
-    @param source : where we start from
+\fn FileSel_SelectWrite(const char *title,char *target,uint32_t max, const char *source)
+\brief allow to select a file
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at return</A> 0 on failure, 1 on success
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> title : window title 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> target : where to copy the result (must be allocated by caller)
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> max : Max # of bytes that target can hold
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> source : where we start from
 */
-uint8_t FileSel_SelectWrite(const char *title,char *target,uint32_t max, const char *source)
+uint8_t FileSel_SelectWrite(const char *title, char *target, uint32_t max, const char *source)
 {
-	
-GtkWidget *dialog;
-uint8_t ret=0;
-gchar *selected_filename;
-gchar last;
-char *dupe=NULL,*tmpname=NULL;
-DIR *dir=NULL;
-	
-	dialog = gtk_file_chooser_dialog_new (&quot;Write to File&quot;,
-                                      NULL,
-                                      GTK_FILE_CHOOSER_ACTION_SAVE,
-                                      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-                                      GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
-                                      NULL);
-	gtk_window_set_title (GTK_WINDOW (dialog),title);
-        initFileSelector();
-        setFilter(dialog);
-        gtk_register_dialog(dialog);
-//	gtk_transient(dialog);
+	GtkWidget *dialog;
+	uint8_t ret = 0;
+	gchar *selected_filename;
+	gchar last;
+	char *dupe = NULL, *tmpname = NULL;
+	DIR *dir = NULL;
+
+	dialog = gtk_file_chooser_dialog_new(&quot;Write to File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_SAVE,
+		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);
+
+	gtk_window_set_title(GTK_WINDOW(dialog), title);
+	initFileSelector();
+	setFilter(dialog);
+	gtk_register_dialog(dialog);
+
 	if (source &amp;&amp; *source)
 	{
 #if 0
-// well, this is what they say to do, but then you can't easily edit the
-// name...
+		// well, this is what they say to do, but then you can't easily edit the
+		// name...
 
-                // the following sequence is per GTK docs for gtk_file_chooser_set_filename()
-                if (access (source, W_OK) == 0) // if file exists
-                {
-                    gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog),(gchar *)source);
-                    // printf (&quot;FileSel_SelectWrite: existing %s\n&quot;, source);
-                }
-                else // new file
+		// the following sequence is per GTK docs for gtk_file_chooser_set_filename()
+		if (access (source, W_OK) == 0) // if file exists
+			gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog),(gchar *)source);
+		else // new file
 #endif
-                {
-                    dupe=ADM_PathCanonize(source);
-                    ADM_PathStripName(dupe);
-                    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog),(gchar *)dupe);
-                    gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(dialog),
-                                                      (gchar *)(source + strlen(dupe)));
-                    // printf (&quot;FileSel_SelectWrite: folder %s, name %s\n&quot;, dupe, source + strlen(dupe));
-                    delete [] dupe;
-                }
-	
+		{
+			dupe = ADM_PathCanonize(source);
+			ADM_PathStripName(dupe);
+
+			gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), (gchar*)dupe);
+			gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(dialog),
+				(gchar*)(source + strlen(dupe)));
+
+			delete [] dupe;
+		}
 	}
 	else	//use pref
 	{
-		if( prefs-&gt;get(LASTDIR_WRITE,(ADM_filename **)&amp;tmpname))
+		if (prefs-&gt;get(LASTDIR_WRITE,(ADM_filename **)&amp;tmpname))
 		{
-			
-			dupe=ADM_PathCanonize(tmpname);
+			dupe = ADM_PathCanonize(tmpname);
 
-			if( (dir=opendir(dupe)) )
+			if (dir = opendir(dupe))
 			{
 				closedir(dir);
-				gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog),(gchar *)tmpname);
+				gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), (gchar*)tmpname);
 			}
+
 			delete [] dupe;
 		}
 	}
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_ACCEPT)
+	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
 	{
-			selected_filename= (gchar *) 	gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
-			if(strlen(selected_filename))
+		selected_filename = (gchar*)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+
+		if (strlen(selected_filename))
+		{
+			last = selected_filename[strlen(selected_filename) - 1];
+
+			if (last == '/' || last =='\\')
 			{
-			last=selected_filename[strlen(selected_filename) - 1]; 
-			 if (last == '/' || last =='\\' )
-			 {
-                           GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
-						return 0;
+				GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
+				return 0;
 			}
 			else
 			{
-                              strncpy(target,(char *)selected_filename,max);
-                              // Finally we accept it :)
-                              ret=1;
-					
+				strncpy(target, (char*)selected_filename, max);
+				// Finally we accept it :)
+				ret = 1;
 			}
-			}
-	}	
-        gtk_unregister_dialog(dialog);
+		}
+	}
+
+	gtk_unregister_dialog(dialog);
 	gtk_widget_destroy(dialog);
+
 	return ret;
 }
+
 /**
-    \fn FileSel_SelectDir(const char *title,char *target,uint32_t max, const char *source)
-    \brief allow to select a directory
-    @return 0 on failure, 1 on success
-    @param title : window title 
-    @param target : where to copy the result (must be allocated by caller)
-    @param max : Max # of bytes that target can hold
-    @param source : where we start from
+\fn FileSel_SelectDir(const char *title,char *target,uint32_t max, const char *source)
+\brief allow to select a directory
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at return</A> 0 on failure, 1 on success
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> title : window title 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> target : where to copy the result (must be allocated by caller)
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> max : Max # of bytes that target can hold
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> source : where we start from
 */
-uint8_t FileSel_SelectDir(const char *title,char *target,uint32_t max, const char *source)
+uint8_t FileSel_SelectDir(const char *title, char *target, uint32_t max, const char *source)
 {
-	
-GtkWidget *dialog;
-uint8_t ret=0;
-gchar *selected_filename;
-gchar last;
-char *dupe=NULL,*tmpname=NULL;
-DIR *dir=NULL;
-	
-        dialog = gtk_file_chooser_dialog_new (&quot;Open File&quot;,
-                                      NULL,
-                                      GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
-                                      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-                                      GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
-                                      NULL);
-        gtk_window_set_title (GTK_WINDOW (dialog),title);
-        gtk_register_dialog(dialog);
-        /* Set default dir if provided ..*/
-        if(source)
-        {
-                dupe=ADM_PathCanonize(source);
-                ADM_PathStripName(dupe);
-                if( (dir=opendir(dupe)) )
-                        {
-                                closedir(dir);
-                                gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog),(gchar *)source);
-                        }
-                delete [] dupe;
-        
-        }
-        else	//use pref
-        {
-                if( prefs-&gt;get(LASTDIR_READ,(ADM_filename **)&amp;tmpname))
-                {
-                        
-        
-                        dupe=ADM_PathCanonize(tmpname);
-                        ADM_PathStripName(dupe);
-  
-                        if( (dir=opendir(dupe)) )
-                        {
-                                closedir(dir);
-                                gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog),(gchar *)dupe);
-                        }
-                        delete [] dupe;
-                }
-        }
+	GtkWidget *dialog;
+	uint8_t ret = 0;
+	gchar *selected_filename;
+	gchar last;
+	char *dupe = NULL, *tmpname = NULL;
+	DIR *dir = NULL;
 
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_ACCEPT)
-        {
-          selected_filename= (gchar *) 	gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
-          if(strlen(selected_filename))  /* Nothing selected */
-          {
-            /* Check it is a dir ...*/
-            printf(&quot;&lt;%s&gt;\n&quot;,selected_filename);; 
-            strncpy(target,selected_filename,max);
-            target[max-1]=0;
-            ret=1;
-          }
-        }	
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        return ret;
+	dialog = gtk_file_chooser_dialog_new(&quot;Open File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
+		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);
+
+	gtk_window_set_title(GTK_WINDOW(dialog), title);
+	gtk_register_dialog(dialog);
+
+	/* Set default dir if provided ..*/
+	if (source)
+	{
+		dupe = ADM_PathCanonize(source);
+		ADM_PathStripName(dupe);
+
+		if (dir = opendir(dupe))
+		{
+			closedir(dir);
+			gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog), (gchar*)source);
+		}
+
+		delete [] dupe;
+	}
+	else	//use pref
+	{
+		if (prefs-&gt;get(LASTDIR_READ, (ADM_filename **)&amp;tmpname))
+		{
+			dupe = ADM_PathCanonize(tmpname);
+			ADM_PathStripName(dupe);
+
+			if (dir = opendir(dupe))
+			{
+				closedir(dir);
+				gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog), (gchar*)dupe);
+			}
+
+			delete [] dupe;
+		}
+	}
+
+	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
+	{
+		selected_filename = (gchar*)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+
+		if (strlen(selected_filename))  /* Nothing selected */
+		{
+			/* Check it is a dir ...*/
+			printf(&quot;&lt;%s&gt;\n&quot;, selected_filename);
+			strncpy(target, selected_filename, max);
+			target[max-1] = 0;
+			ret = 1;
+		}
+	}
+
+	gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+
+	return ret;
 }
 
 void GUI_FileSelWrite(const char *label, SELFILE_CB * cb)
-{				/* Create the selector */
-    GUI_FileSel(label, cb, 1);
+{
+	/* Create the selector */
+	GUI_FileSel(label, cb, 1);
 }
 
 void GUI_FileSelRead(const char *label, SELFILE_CB * cb)
-{				/* Create the selector */
-    GUI_FileSel(label, cb, 0);
+{
+	/* Create the selector */
+	GUI_FileSel(label, cb, 0);
 }
 void GUI_FileSelRead(const char *label, char * * name)
-{				/* Create the selector */
-    GUI_FileSel(label, NULL, 0,name);
+{
+	/* Create the selector */
+	GUI_FileSel(label, NULL, 0, name);
 }
 void GUI_FileSelWrite(const char *label, char * * name)
-{				/* Create the selector */
-    GUI_FileSel(label, NULL, 1,name);
+{
+	/* Create the selector */
+	GUI_FileSel(label, NULL, 1, name);
 }
 
 // CYB 2005.02.23: DND
 void fileReadWrite(SELFILE_CB *cb, int rw, char *name)
 {
-
-	if(name)
+	if (name)
 	{
-		if(cb)
+		if (cb)
 		{
 			FILE *fd;
-			fd=fopen(name,&quot;rb&quot;);
-			if(rw==0) // read
+			fd = fopen(name, &quot;rb&quot;);
+
+			if (rw == 0) // read
 			{
 				// try to open it..
-				if(!fd)
+				if (!fd)
 				{
-                                  GUI_Error_HIG(QT_TR_NOOP(&quot;File error&quot;), QT_TR_NOOP(&quot;Cannot open \&quot;%s\&quot;.&quot;), name);
+					GUI_Error_HIG(QT_TR_NOOP(&quot;File error&quot;), QT_TR_NOOP(&quot;Cannot open \&quot;%s\&quot;.&quot;), name);
 					return;
 				}
 			}
 			else // write
 			{
-				if(fd){
-				  struct stat buf;
-				  int fdino;
+				if (fd)
+				{
+					struct stat buf;
+					int fdino;
+					char msg[300];
+
 					fclose(fd);
 
-					char msg[300];
-
 					snprintf(msg, 300, QT_TR_NOOP(&quot;%s already exists.\n\nDo you want to replace it?&quot;), ADM_GetFileName(name));
 
-                                        if(!GUI_Question(msg))
+					if (!GUI_Question(msg))
 						return;
-	                                /*
-	                                ** JSC Fri Feb 10 00:07:30 CET 2006
-	                                ** compare existing output file inode against each current open files inode
-	                                ** i'm ignoring st_dev, so we may get false positives
-	                                ** i'm testing until fd=1024, should be MAXFD computed by configure
-	                                ** keep in mind:
-	                                ** you can overwrite .idx files, they are loaded into memory and closed soon
-	                                ** you cannot overwrite segment data files, all files are kept open and
-	                                ** are detected here
-	                                */
+
+					/*
+					** JSC Fri Feb 10 00:07:30 CET 2006
+					** compare existing output file inode against each current open files inode
+					** i'm ignoring st_dev, so we may get false positives
+					** i'm testing until fd=1024, should be MAXFD computed by configure
+					** keep in mind:
+					** you can overwrite .idx files, they are loaded into memory and closed soon
+					** you cannot overwrite segment data files, all files are kept open and
+					** are detected here
+					*/
 #ifndef __WIN32
-					if( stat(name,&amp;buf) == -1 ){
-						fprintf(stderr,&quot;stat(%s) failed\n&quot;,name);
+					if (stat(name,&amp;buf) == -1)
+					{
+						fprintf(stderr, &quot;stat(%s) failed\n&quot;, name);
 						return;
 					}
 #endif
 					fdino = buf.st_ino;
-					for(int i=0;i&lt;1024;i++){
-						if( fstat(i,&amp;buf) != -1 ){
-							if( buf.st_ino == fdino ){
-							  char str[512];
-								snprintf(str,512,&quot;File \&quot;%s\&quot; exists and is opened by Avidemux&quot;,name);
-								GUI_Error_HIG(str,
-                                                                    QT_TR_NOOP(&quot;It is possible that you are trying to overwrite an input file!&quot;));
+					for (int i = 0; i &lt; 1024; i++)
+					{
+						if (fstat(i, &amp;buf) != -1)
+						{
+							if (buf.st_ino == fdino)
+							{
+								char str[512];
+
+								snprintf(str, 512, &quot;File \&quot;%s\&quot; exists and is opened by Avidemux&quot;, name);
+								GUI_Error_HIG(str, QT_TR_NOOP(&quot;It is possible that you are trying to overwrite an input file!&quot;));
+
 								return;
 							}
 						}
 					}
 					/*
-	                                ** compare output file against actual EMCAscript file
+					** compare output file against actual EMCAscript file
 					** need to stat() to avoid symlink (/home/x.js) vs. real file (/export/home/x.js) case
-	                                */
-					if( actual_workbench_file ){
-						if( stat(actual_workbench_file,&amp;buf) != -1 ){
-							if( buf.st_ino == fdino ){
-							  char str[512];
-								snprintf(str,512,&quot;File \&quot;%s\&quot; exists and is the actual ECMAscript file&quot;,name);
-                                                                GUI_Error_HIG(str,QT_TR_NOOP(&quot;It is possible that you are trying to overwrite an input file!&quot;));
+					*/
+					if (actual_workbench_file)
+					{
+						if (stat(actual_workbench_file, &amp;buf) != -1)
+						{
+							if (buf.st_ino == fdino)
+							{
+								char str[512];
+
+								snprintf(str, 512, &quot;File \&quot;%s\&quot; exists and is the actual ECMAscript file&quot;, name);
+								GUI_Error_HIG(str, QT_TR_NOOP(&quot;It is possible that you are trying to overwrite an input file!&quot;));
+
 								return;
 							}
 						}
@@ -378,13 +386,16 @@
 				}
 
 				// check we have right access to it
-				fd=fopen(name,&quot;wb&quot;);
-				if(!fd)
+				fd = fopen(name, &quot;wb&quot;);
+
+				if (!fd)
 				{
-                                  GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot write the file&quot;),QT_TR_NOOP( &quot;No write access to \&quot;%s\&quot;.&quot;), name);
+					GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot write the file&quot;), QT_TR_NOOP(&quot;No write access to \&quot;%s\&quot;.&quot;), name);
+
 					return;
 				}
 			}
+
 			fclose(fd);
 			cb(name);
 		} // no callback -&gt; return value
@@ -394,152 +405,143 @@
 
 
 void GUI_FileSel(const char *label, SELFILE_CB * cb, int rw,char **rname)
-{				/* Create the selector */
-
-    	GtkWidget *dialog;
-	char *name=NULL;
+{
+	/* Create the selector */
+	GtkWidget *dialog;
+	char *name = NULL;
 	char *tmpname;
 	gchar *selected_filename;
-        uint8_t res;
+	uint8_t res;
 
-       
-	if(rname)
-		*rname=NULL;
+	if (rname)
+		*rname = NULL;
 
-        if(rw)
-        {
-                        dialog = gtk_file_chooser_dialog_new (&quot;Save&quot;,
-                                      NULL,
-                                      GTK_FILE_CHOOSER_ACTION_SAVE,
-                                      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-                                      GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT,
-                                      NULL);
-                        
-        }
-        else
-        {
-          dialog = gtk_file_chooser_dialog_new (&quot;Open File&quot;,
-                                      NULL,
-                                      GTK_FILE_CHOOSER_ACTION_OPEN,
-                                      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-                                      GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
-                                      NULL);
-        }
-		gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_ACCEPT);
-        /**********/
-        initFileSelector();
-        setFilter(dialog);
-        /**********/
-        gtk_window_set_title (GTK_WINDOW (dialog),label);
-        gtk_register_dialog(dialog);
-        if(rw)
-                res=prefs-&gt;get(LASTDIR_WRITE,(ADM_filename **)&amp;tmpname); 
-        else
-               res=prefs-&gt;get(LASTDIR_READ,(ADM_filename **)&amp;tmpname); 
-        if(res)
+	if (rw)
+		dialog = gtk_file_chooser_dialog_new (&quot;Save&quot;, NULL, GTK_FILE_CHOOSER_ACTION_SAVE,
+			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT, NULL);
+	else
+		dialog = gtk_file_chooser_dialog_new (&quot;Open File&quot;, NULL, GTK_FILE_CHOOSER_ACTION_OPEN, 
+			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);
+
+	gtk_dialog_set_default_response (GTK_DIALOG(dialog), GTK_RESPONSE_ACCEPT);
+
+	initFileSelector();
+	setFilter(dialog);
+
+	gtk_window_set_title (GTK_WINDOW(dialog), label);
+	gtk_register_dialog(dialog);
+
+	if (rw)
+		res = prefs-&gt;get(LASTDIR_WRITE,(ADM_filename **)&amp;tmpname);
+	else
+		res = prefs-&gt;get(LASTDIR_READ,(ADM_filename **)&amp;tmpname);
+
+	if (res)
 	{
-                DIR *dir;
-                char *str=ADM_PathCanonize(tmpname);
-                ADM_PathStripName(str);
+		DIR *dir;
+		char *str = ADM_PathCanonize(tmpname);
 
-                /* LASTDIR may have gone; then do nothing and use current dir instead (implied) */
-                if( (dir=opendir(str)) )
-                {
-                        closedir(dir);
-                        gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog),(gchar *)str);
-                }
-                delete [] str;
-        }
-		ADM_dealloc(tmpname);
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_ACCEPT)
+		ADM_PathStripName(str);
+
+		/* LASTDIR may have gone; then do nothing and use current dir instead (implied) */
+		if (dir = opendir(str))
+		{
+			closedir(dir);
+			gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog),(gchar *)str);
+		}
+
+		delete [] str;
+	}
+
+	ADM_dealloc(tmpname);
+
+	if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
 	{
+		selected_filename = (gchar *)gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
 
-                        selected_filename= (gchar *) 	gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
 #ifdef __WIN32
-                        if (*(selected_filename + strlen(selected_filename) - 1) == '\\'){
-#else			
-                        if (*(selected_filename + strlen(selected_filename) - 1) == '/'){
-#endif	 
-                        GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
-                }
-                else
-                {
-                        name=ADM_strdup(selected_filename);
+		if (*(selected_filename + strlen(selected_filename) - 1) == '\\'){
+#else
+		if (*(selected_filename + strlen(selected_filename) - 1) == '/'){
+#endif
+			GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open directory as a file&quot;), NULL);
+		}
+		else
+		{
+			name = ADM_strdup(selected_filename);
 
-                        char *str=ADM_PathCanonize(name);
-                        ADM_PathStripName(str);
-                        if(rw)
-                                prefs-&gt;set(LASTDIR_WRITE,(ADM_filename *)str);			
-                        else
-                                prefs-&gt;set(LASTDIR_READ,(ADM_filename *)str);                        
-                        delete [] str;
+			char *str = ADM_PathCanonize(name);
 
-                }
-        }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
+			ADM_PathStripName(str);
 
-// CYB 2005.02.23
-        if(cb)
-        {
-                fileReadWrite(cb, rw, name);
-				ADM_dealloc(name);
-        }
-        else
-        {
-                *rname=name;  
-        }
+			if (rw)
+				prefs-&gt;set(LASTDIR_WRITE, (ADM_filename*)str);
+			else
+				prefs-&gt;set(LASTDIR_READ, (ADM_filename*)str);
+
+			delete [] str;
+		}
+	}
+
+	gtk_unregister_dialog(dialog);
+	gtk_widget_destroy(dialog);
+
+	// CYB 2005.02.23
+	if (cb)
+	{
+		fileReadWrite(cb, rw, name);
+		ADM_dealloc(name);
+	}
+	else
+		*rname = name;
 }
 
 
-
 /* Mean:It seems it is attached to the dialog &amp; destroyed with it
-   As it leads to crash if we don't recreate them each time....*/
-uint8_t         initFileSelector(void)
+As it leads to crash if we don't recreate them each time....*/
+uint8_t initFileSelector(void)
 {
-
 #define ADD_PAT(x,y) gtk_file_filter_add_pattern(x,&quot;*.&quot;#y);
-        
-        filter_avi=gtk_file_filter_new();
-        gtk_file_filter_set_name(filter_avi,&quot;Avi (*.avi)&quot;);
-        ADD_PAT(filter_avi,avi);
-        ADD_PAT(filter_avi,AVI);
-        
-        filter_mpeg=gtk_file_filter_new();
-        gtk_file_filter_set_name(filter_mpeg,&quot;Mpeg (*.m*,*.vob)&quot;);
-        ADD_PAT(filter_mpeg,[mM][12][Vv]);
-        ADD_PAT(filter_mpeg,[Mm][pP][gG]);
-        ADD_PAT(filter_mpeg,[Vv][Oo][Bb]);
-        ADD_PAT(filter_mpeg,ts);
-        ADD_PAT(filter_mpeg,TS);
 
-       
-        filter_image=gtk_file_filter_new();
-        gtk_file_filter_set_name(filter_image,QT_TR_NOOP(&quot;Images&quot;));
-        ADD_PAT(filter_image,png);
-        ADD_PAT(filter_image,bmp);
-        ADD_PAT(filter_image,jpg);
+	filter_avi=gtk_file_filter_new();
+	gtk_file_filter_set_name(filter_avi, &quot;AVI (*.avi)&quot;);
+	ADD_PAT(filter_avi, avi);
+	ADD_PAT(filter_avi, AVI);
 
-        ADD_PAT(filter_image,PNG);
-        ADD_PAT(filter_image,BMP);
-        ADD_PAT(filter_image,JPG);
+	filter_mpeg=gtk_file_filter_new();
+	gtk_file_filter_set_name(filter_mpeg, &quot;MPEG (*.m*,*.vob)&quot;);
+	ADD_PAT(filter_mpeg, [mM][12][Vv]);
+	ADD_PAT(filter_mpeg, [Mm][pP][gG]);
+	ADD_PAT(filter_mpeg, [Vv][Oo][Bb]);
+	ADD_PAT(filter_mpeg, ts);
+	ADD_PAT(filter_mpeg, TS);
 
+	filter_image = gtk_file_filter_new();
 
-        
-        filter_all=gtk_file_filter_new();
-        gtk_file_filter_set_name(filter_all,QT_TR_NOOP(&quot;All&quot;));
-        gtk_file_filter_add_pattern (filter_all, &quot;*&quot;);
+	gtk_file_filter_set_name(filter_image, QT_TR_NOOP(&quot;Images&quot;));
+	ADD_PAT(filter_image, png);
+	ADD_PAT(filter_image, bmp);
+	ADD_PAT(filter_image, jpg);
 
-        return 1;
+	ADD_PAT(filter_image, PNG);
+	ADD_PAT(filter_image, BMP);
+	ADD_PAT(filter_image, JPG);
+
+	filter_all = gtk_file_filter_new();
+
+	gtk_file_filter_set_name(filter_all, QT_TR_NOOP(&quot;All&quot;));
+	gtk_file_filter_add_pattern(filter_all, &quot;*&quot;);
+
+	return 1;
 }
 
-uint8_t setFilter( GtkWidget *dialog)
+uint8_t setFilter(GtkWidget *dialog)
 {
-        gtk_file_chooser_add_filter     (GTK_FILE_CHOOSER(dialog), filter_all);
-        gtk_file_chooser_add_filter     (GTK_FILE_CHOOSER(dialog), filter_avi);
-        gtk_file_chooser_add_filter     (GTK_FILE_CHOOSER(dialog), filter_mpeg);
-        gtk_file_chooser_add_filter     (GTK_FILE_CHOOSER(dialog), filter_image);
-        
-        return 1;
+	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_all);
+	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_avi);
+	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_mpeg);
+	gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter_image);
+
+	return 1;
 }
 //EOF


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001153.html">[Avidemux-svn-commit] r3890 -	branches/avidemux_2.5_branch_gruntster/cmake
</A></li>
	<LI>Next message: <A HREF="001155.html">[Avidemux-svn-commit] r3892 - in	branches/avidemux_2.5_branch_gruntster: avidemux	avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2	avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk cmake
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1154">[ date ]</a>
              <a href="thread.html#1154">[ thread ]</a>
              <a href="subject.html#1154">[ subject ]</a>
              <a href="author.html#1154">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
