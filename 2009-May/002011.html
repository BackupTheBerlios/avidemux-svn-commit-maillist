<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4787 - in	branches/avidemux_2.6_branch_mean/avidemux: ADM_core/src	ADM_libraries/ADM_ffmpeg ADM_libraries/ADM_ffmpeg/libavcodec	ADM_libraries/ADM_ffmpeg/libavformat	ADM_libraries/ADM_ffmpeg/libavutil	ADM_libraries/ADM_ffmpeg/libswscale
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4787%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux%3A%20ADM_core/src%0A%09ADM_libraries/ADM_ffmpeg%20ADM_libraries/ADM_ffmpeg/libavcodec%0A%09ADM_libraries/ADM_ffmpeg/libavformat%0A%09ADM_libraries/ADM_ffmpeg/libavutil%0A%09ADM_libraries/ADM_ffmpeg/libswscale&In-Reply-To=%3C200905021354.n42DsHD6011030%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002010.html">
   <LINK REL="Next"  HREF="002012.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4787 - in	branches/avidemux_2.6_branch_mean/avidemux: ADM_core/src	ADM_libraries/ADM_ffmpeg ADM_libraries/ADM_ffmpeg/libavcodec	ADM_libraries/ADM_ffmpeg/libavformat	ADM_libraries/ADM_ffmpeg/libavutil	ADM_libraries/ADM_ffmpeg/libswscale</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4787%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux%3A%20ADM_core/src%0A%09ADM_libraries/ADM_ffmpeg%20ADM_libraries/ADM_ffmpeg/libavcodec%0A%09ADM_libraries/ADM_ffmpeg/libavformat%0A%09ADM_libraries/ADM_ffmpeg/libavutil%0A%09ADM_libraries/ADM_ffmpeg/libswscale&In-Reply-To=%3C200905021354.n42DsHD6011030%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4787 - in	branches/avidemux_2.6_branch_mean/avidemux: ADM_core/src	ADM_libraries/ADM_ffmpeg ADM_libraries/ADM_ffmpeg/libavcodec	ADM_libraries/ADM_ffmpeg/libavformat	ADM_libraries/ADM_ffmpeg/libavutil	ADM_libraries/ADM_ffmpeg/libswscale">mean at mail.berlios.de
       </A><BR>
    <I>Sat May  2 15:54:17 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002010.html">[Avidemux-svn-commit] r4786 -	branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec
</A></li>
        <LI>Next message: <A HREF="002012.html">[Avidemux-svn-commit] r4788 - in	branches/avidemux_2.6_branch_mean/avidemux:	ADM_audioParser/src ADM_libraries/ADM_ffmpeg/libavcodec	ADM_libraries/ADM_ffmpeg/libavformat	ADM_libraries/ADM_ffmpeg/libavutil
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2011">[ date ]</a>
              <a href="thread.html#2011">[ thread ]</a>
              <a href="subject.html#2011">[ subject ]</a>
              <a href="author.html#2011">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-05-02 15:54:13 +0200 (Sat, 02 May 2009)
New Revision: 4787

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_cpuCap.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_memcpy.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/dopatch.sh
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/avcodec.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/ffv1.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/h263dec.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/h264.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpeg12.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpeg12enc.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpegvideo.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/utils.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/file.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/flvenc.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/isom.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/matroskaenc.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/movenc.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/movenc.c.orig
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/avutil.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/internal.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/mem.c
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libswscale/swscale_internal.h
Log:
[FFmpeg] Applied 1set of patches

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_cpuCap.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_cpuCap.cpp	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_cpuCap.cpp	2009-05-02 13:54:13 UTC (rev 4787)
@@ -37,7 +37,7 @@
 #ifdef ADM_CPU_X86
 extern &quot;C&quot; 
 {
-#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavcodec/dsputil_cpu.h&quot;
+#include &quot;ADM_libraries/ADM_ffmpeg/libavcodec/avcodec.h&quot;
 }
 #endif
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_memcpy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_memcpy.cpp	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_memcpy.cpp	2009-05-02 13:54:13 UTC (rev 4787)
@@ -38,7 +38,7 @@
 
 extern &quot;C&quot;
 {
-	#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavcodec/dsputil_cpu.h&quot;
+	#include &quot;ADM_libraries/ADM_ffmpeg/libavcodec/avcodec.h&quot;
 
 adm_fast_memcpy myAdmMemcpy=NULL;
 /* Original comments from mplayer (file: aclib.c)
@@ -389,14 +389,14 @@
 #if defined(ADM_CPU_X86)
   { &quot;linux kernel memcpy()&quot;, linux_kernel_memcpy, 0, 0 },
 #if defined(ADM_CPU_X86)
-  { &quot;MMX optimized memcpy()&quot;, mmx_memcpy, 0, MM_MMX },
-  { &quot;MMXEXT optimized memcpy()&quot;, mmx2_memcpy, 0, MM_MMXEXT },
-  { &quot;SSE optimized memcpy()&quot;, sse_memcpy, 0, MM_MMXEXT|MM_SSE },
+  { &quot;MMX optimized memcpy()&quot;, mmx_memcpy, 0, FF_MM_MMX },
+  { &quot;MMXEXT optimized memcpy()&quot;, mmx2_memcpy, 0, FF_MM_MMXEXT },
+  { &quot;SSE optimized memcpy()&quot;, sse_memcpy, 0, FF_MM_MMXEXT|FF_MM_SSE },
 #endif
 #endif /* ARCH_X86 */
 #if 0 &amp;&amp; defined(ADM_CPU_PPC) &amp;&amp; !defined (__APPLE__)
   { &quot;ppcasm_memcpy()&quot;, ppcasm_memcpy, 0, 0 },
-  { &quot;ppcasm_cacheable_memcpy()&quot;, ppcasm_cacheable_memcpy, 0, MM_ACCEL_PPC_CACHE32 },
+  { &quot;ppcasm_cacheable_memcpy()&quot;, ppcasm_cacheable_memcpy, 0, FF_MM_ACCEL_PPC_CACHE32 },
 #endif /* ARCH_PPC &amp;&amp; !HOST_OS_DARWIN */
   { NULL, NULL, 0, 0 }
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/dopatch.sh
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/dopatch.sh	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/dopatch.sh	2009-05-02 13:54:13 UTC (rev 4787)
@@ -2,7 +2,7 @@
 
 for i in patches/*.patch ; do
         echo $i
-        patch -p0 --dry-run &lt; $i
+        patch -p0  &lt; $i
 done
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/avcodec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/avcodec.h	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/avcodec.h	2009-05-02 13:54:13 UTC (rev 4787)
@@ -511,6 +511,8 @@
 #define CODEC_FLAG2_CHUNKS        0x00008000 ///&lt; Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.
 #define CODEC_FLAG2_NON_LINEAR_QUANT 0x00010000 ///&lt; Use MPEG-2 nonlinear quantizer.
 #define CODEC_FLAG2_BIT_RESERVOIR 0x00020000 ///&lt; Use a bit reservoir when encoding if possible
+//MEANX: NEVER EVER USE CLOSED GOP ?
+#define CODEC_FLAG2_32_PULLDOWN   0x80000000 
 
 /* Unsupported options :
  *              Syntax Arithmetic coding (SAC)
@@ -1357,6 +1359,7 @@
      * - decoding: unused
      */
     int rc_max_rate;
+    int rc_max_rate_header; /*&lt; That one is set in the header MEANX */
 
     /**
      * minimum bitrate
@@ -1371,6 +1374,8 @@
      * - decoding: unused
      */
     int rc_buffer_size;
+    int rc_buffer_size_header;  /*&lt; That one is set in the header MEANX*/
+
     float rc_buffer_aggressivity;
 
     /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/ffv1.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/ffv1.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/ffv1.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -1072,6 +1072,8 @@
         clear_state(f);
     }else{
         p-&gt;key_frame= 0;
+         p-&gt;pict_type= FF_P_TYPE; // MEANX : looks more like a P to me as user
+
     }
     if(!f-&gt;plane[0].state &amp;&amp; !f-&gt;plane[0].vlc_state)
         return -1;

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/h263dec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/h263dec.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/h263dec.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -120,7 +120,24 @@
 
     return 0;
 }
+/* MeanX : Ugly patch to detect vo ppacked stuff ... */
+int av_is_voppacked(AVCodecContext *avctx, int *vop_packed, int *gmc, int *qpel)
+{
+    MpegEncContext *s = avctx-&gt;priv_data;
+    // set sane default
+    *vop_packed=0;
+    *gmc=0;
+    *qpel=0;
+    if(avctx-&gt;codec-&gt;id!=CODEC_ID_MPEG4) return 0;
+    	
+  	*vop_packed=(s-&gt;divx_packed);
+	*qpel=s-&gt;quarter_sample;
+	*gmc=0;	// FIXME
+	return 1;
 
+  }
+  /* MeanX */
+
 av_cold int ff_h263_decode_end(AVCodecContext *avctx)
 {
     MpegEncContext *s = avctx-&gt;priv_data;
@@ -420,6 +437,12 @@
     } else {
         ret = h263_decode_picture_header(s);
     }
+	//MEANX we need to do it here also for quicktime file / ctts atom 
+        // we need the correct frame type, and qt file may contain 
+        // vop not coded frame.
+        pict-&gt;pict_type=s-&gt;current_picture.pict_type= s-&gt;pict_type;
+        pict-&gt;key_frame=s-&gt;current_picture.key_frame= s-&gt;pict_type == FF_I_TYPE;
+        //MEANX
 
     if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_size);
 
@@ -710,6 +733,14 @@
 
 assert(s-&gt;current_picture.pict_type == s-&gt;current_picture_ptr-&gt;pict_type);
 assert(s-&gt;current_picture.pict_type == s-&gt;pict_type);
+/* MEANX */
+  if(s-&gt;current_picture_ptr)
+      s-&gt;current_picture_ptr-&gt;opaque=pict-&gt;opaque;
+/* MEANX */
+
+
+
+
     if (s-&gt;pict_type == FF_B_TYPE || s-&gt;low_delay) {
         *pict= *(AVFrame*)s-&gt;current_picture_ptr;
     } else if (s-&gt;last_picture_ptr != NULL) {

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/h264.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/h264.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/h264.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -8130,7 +8130,18 @@
     return 0;
 }
 
+/* MEANX */
+int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc)
+{
+      H264Context *h = avctx-&gt;priv_data;
+      assert(h);
+      *nalSize=h-&gt;nal_length_size;
+      *isAvc=h-&gt;is_avc;
+	return 1;
 
+  }
+/* MeanX */
+
 AVCodec h264_decoder = {
     &quot;h264&quot;,
     CODEC_TYPE_VIDEO,

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpeg12.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpeg12.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpeg12.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -1947,7 +1947,12 @@
         ff_er_frame_end(s);
 
         MPV_frame_end(s);
+/* MEANX */
+  if(s-&gt;current_picture_ptr)
+      s-&gt;current_picture_ptr-&gt;opaque=pict-&gt;opaque;
+/* MEANX */
 
+
         if (s-&gt;pict_type == FF_B_TYPE || s-&gt;low_delay) {
             *pict= *(AVFrame*)s-&gt;current_picture_ptr;
             ff_print_debug_info(s, pict);

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpeg12enc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpeg12enc.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpeg12enc.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -127,10 +127,19 @@
             s-&gt;frame_rate_index= i;
         }
     }
+ /* MEANX 
+
     if(dmin)
         return -1;
     else
         return 0;
+  */
+        if(dmin&gt;4)
+   {
+        av_log(0,AV_LOG_ERROR,&quot;We did a roundup ! Expect async!\n&quot;);
+   }
+        return 0; //MEANX
+
 }
 
 static av_cold int encode_init(AVCodecContext *avctx)
@@ -209,6 +218,7 @@
             put_sbits(&amp;s-&gt;pb, 12, s-&gt;width );
             put_sbits(&amp;s-&gt;pb, 12, s-&gt;height);
 
+#if 0 //MEANX
             for(i=1; i&lt;15; i++){
                 float error= aspect_ratio;
                 if(s-&gt;codec_id == CODEC_ID_MPEG1VIDEO || i &lt;=1)
@@ -223,20 +233,44 @@
                     s-&gt;aspect_ratio_info= i;
                 }
             }
+#endif // MEANX
+            //MEANX put_bits(&amp;s-&gt;pb, 4, s-&gt;aspect_ratio_info);
+            //MEANX put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
+ // MEANX 4:3
+  if(s-&gt;avctx-&gt;sample_aspect_ratio.num==16 &amp;&amp; s-&gt;avctx-&gt;sample_aspect_ratio.den==9)
+            {
+                //printf(&quot;FFmpeg : Wide\n&quot;);
+                put_bits(&amp;s-&gt;pb,4,3); //16:9
+            }
+            else        //4:3
+            {
+              if(s-&gt;codec_id == CODEC_ID_MPEG2VIDEO)
+                put_bits(&amp;s-&gt;pb, 4, 2);
+              else
+                put_bits(&amp;s-&gt;pb, 4, 12); // MPEG1
+            }
+// /MEANX
 
-            put_bits(&amp;s-&gt;pb, 4, s-&gt;aspect_ratio_info);
-            put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
+// //MEANX PULLDOWN            put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
+if((s-&gt;flags2 &amp; CODEC_FLAG2_32_PULLDOWN) &amp;&amp; (s-&gt;codec_id == CODEC_ID_MPEG2VIDEO))
+            {           
+                put_bits(&amp;s-&gt;pb, 4,4);
+            }
+            else
+            {                                  
+                put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
+            } //MEANX pulldown
 
-            if(s-&gt;avctx-&gt;rc_max_rate){
-                v = (s-&gt;avctx-&gt;rc_max_rate + 399) / 400;
+            if(s-&gt;avctx-&gt;rc_max_rate_header){ //MEANX we use header
+                v = (s-&gt;avctx-&gt;rc_max_rate_header + 399) / 400;
                 if (v &gt; 0x3ffff &amp;&amp; s-&gt;codec_id == CODEC_ID_MPEG1VIDEO)
                     v = 0x3ffff;
             }else{
                 v= 0x3FFFF;
             }
 
-            if(s-&gt;avctx-&gt;rc_buffer_size)
-                vbv_buffer_size = s-&gt;avctx-&gt;rc_buffer_size;
+            if(s-&gt;avctx-&gt;rc_buffer_size_header) // MEANX we use header
+                vbv_buffer_size = s-&gt;avctx-&gt;rc_buffer_size_header;
             else
                 /* VBV calculation: Scaled so that a VCD has the proper VBV size of 40 kilobytes */
                 vbv_buffer_size = (( 20 * s-&gt;bit_rate) / (1151929 / 2)) * 8 * 1024;
@@ -269,8 +303,17 @@
 
                 put_bits(&amp;s-&gt;pb, 3, s-&gt;avctx-&gt;profile); //profile
                 put_bits(&amp;s-&gt;pb, 4, s-&gt;avctx-&gt;level); //level
+   // MEANX pulldown put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_sequence);
+  // MEANX Pulldown
+ if(s-&gt;flags2 &amp; CODEC_FLAG2_32_PULLDOWN) //MEANX
+                        put_bits(&amp;s-&gt;pb, 1, 0);
+                else
+                        put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_sequence);
 
-                put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_sequence);
+
+// /MEANX
+
+
                 put_bits(&amp;s-&gt;pb, 2, s-&gt;chroma_format);
                 put_bits(&amp;s-&gt;pb, 2, s-&gt;width &gt;&gt;12);
                 put_bits(&amp;s-&gt;pb, 2, s-&gt;height&gt;&gt;12);
@@ -334,6 +377,8 @@
 
 void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
 {
+	int tff,rff; //MEANX
+
     mpeg1_encode_sequence_header(s);
 
     /* mpeg1 picture header */
@@ -370,6 +415,49 @@
 
     s-&gt;frame_pred_frame_dct = 1;
     if(s-&gt;codec_id == CODEC_ID_MPEG2VIDEO){
+ /* MEANX -- Pulldown */
+        if(s-&gt;flags2 &amp; CODEC_FLAG2_32_PULLDOWN)
+        {
+        
+                switch((s-&gt;picture_number - 
+                          s-&gt;gop_picture_number)&amp;3)
+                {
+                        case 0:
+                        default:
+                                rff=1;
+                                tff=1;
+                                break;
+                        case 1:
+                                rff=0;
+                                tff=0;
+                                break;
+                        case 2:
+                                rff=1;
+                                tff=0;
+                                break;
+                        case 3:
+                                rff=0;
+                                tff=1;
+                                break;
+                }               
+           }
+        else
+        {
+                if (s-&gt;progressive_sequence) 
+                {
+                        tff=0; /* no repeat */
+                } else 
+                {
+                        tff= s-&gt;current_picture_ptr-&gt;top_field_first;
+                }
+                rff=s-&gt;repeat_first_field;
+        
+        }
+
+//               /MEANX pulldown
+
+
+
         put_header(s, EXT_START_CODE);
         put_bits(&amp;s-&gt;pb, 4, 8); //pic ext
         if (s-&gt;pict_type == FF_P_TYPE || s-&gt;pict_type == FF_B_TYPE) {
@@ -388,11 +476,16 @@
 
         assert(s-&gt;picture_structure == PICT_FRAME);
         put_bits(&amp;s-&gt;pb, 2, s-&gt;picture_structure);
+#if 0 //MEANX
+
         if (s-&gt;progressive_sequence) {
             put_bits(&amp;s-&gt;pb, 1, 0); /* no repeat */
         } else {
             put_bits(&amp;s-&gt;pb, 1, s-&gt;current_picture_ptr-&gt;top_field_first);
         }
+#endif
+         put_bits(&amp;s-&gt;pb, 1, tff);  //MEANX PULLDOWN
+
         /* XXX: optimize the generation of this flag with entropy
            measures */
         s-&gt;frame_pred_frame_dct = s-&gt;progressive_sequence;
@@ -402,7 +495,10 @@
         put_bits(&amp;s-&gt;pb, 1, s-&gt;q_scale_type);
         put_bits(&amp;s-&gt;pb, 1, s-&gt;intra_vlc_format);
         put_bits(&amp;s-&gt;pb, 1, s-&gt;alternate_scan);
-        put_bits(&amp;s-&gt;pb, 1, s-&gt;repeat_first_field);
+ // MEANX put_bits(&amp;s-&gt;pb, 1, s-&gt;repeat_first_field);
+	put_bits(&amp;s-&gt;pb, 1, rff);
+      // /MEANX
+
         s-&gt;progressive_frame = s-&gt;progressive_sequence;
         put_bits(&amp;s-&gt;pb, 1, s-&gt;chroma_format == CHROMA_420 ? s-&gt;progressive_frame : 0); /* chroma_420_type */
         put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_frame);

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpegvideo.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpegvideo.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpegvideo.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -610,7 +610,11 @@
     CHECKED_ALLOCZ(s-&gt;prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE);
 
     s-&gt;parse_context.state= -1;
-    if((s-&gt;avctx-&gt;debug&amp;(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s-&gt;avctx-&gt;debug_mv)){
+ //MEANX: Allocate them always, as they may be free when we decode 1st image
+
+    // MEANXif((s-&gt;avctx-&gt;debug&amp;(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s-&gt;avctx-&gt;debug_mv)){
+if(1){ // MEANX
+
        s-&gt;visualization_buffer[0] = av_malloc((s-&gt;mb_width*16 + 2*EDGE_WIDTH) * s-&gt;mb_height*16 + 2*EDGE_WIDTH);
        s-&gt;visualization_buffer[1] = av_malloc((s-&gt;mb_width*16 + 2*EDGE_WIDTH) * s-&gt;mb_height*16 + 2*EDGE_WIDTH);
        s-&gt;visualization_buffer[2] = av_malloc((s-&gt;mb_width*16 + 2*EDGE_WIDTH) * s-&gt;mb_height*16 + 2*EDGE_WIDTH);

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpegvideo_enc.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/mpegvideo_enc.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -349,12 +349,14 @@
 
         av_log(avctx, AV_LOG_INFO, &quot;Warning vbv_delay will be set to 0xFFFF (=VBR) as the specified vbv buffer is too large for the given bitrate!\n&quot;);
     }
+#if 0 //MEANX
 
     if((s-&gt;flags &amp; CODEC_FLAG_4MV) &amp;&amp; s-&gt;codec_id != CODEC_ID_MPEG4
        &amp;&amp; s-&gt;codec_id != CODEC_ID_H263 &amp;&amp; s-&gt;codec_id != CODEC_ID_H263P &amp;&amp; s-&gt;codec_id != CODEC_ID_FLV1){
         av_log(avctx, AV_LOG_ERROR, &quot;4MV not supported by codec\n&quot;);
         return -1;
     }
+#endif
 
     if(s-&gt;obmc &amp;&amp; s-&gt;avctx-&gt;mb_decision != FF_MB_DECISION_SIMPLE){
         av_log(avctx, AV_LOG_ERROR, &quot;OBMC is only supported with simple mb decision\n&quot;);
@@ -387,10 +389,12 @@
         return -1;
     }
 
+#if 0 //MEANX
     if(s-&gt;mpeg_quant &amp;&amp; s-&gt;codec_id != CODEC_ID_MPEG4){ //FIXME mpeg2 uses that too
         av_log(avctx, AV_LOG_ERROR, &quot;mpeg2 style quantization not supported by codec\n&quot;);
         return -1;
     }
+#endif
 
     if((s-&gt;flags &amp; CODEC_FLAG_CBP_RD) &amp;&amp; !avctx-&gt;trellis){
         av_log(avctx, AV_LOG_ERROR, &quot;CBP RD needs trellis quant\n&quot;);

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/utils.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec/utils.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -596,10 +596,12 @@
 
     if((avctx-&gt;codec-&gt;capabilities &amp; CODEC_CAP_DELAY) || avpkt-&gt;size){
         //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
+#if 0 // MEANX : Silence
         if(*frame_size_ptr &lt; AVCODEC_MAX_AUDIO_FRAME_SIZE){
             av_log(avctx, AV_LOG_ERROR, &quot;buffer smaller than AVCODEC_MAX_AUDIO_FRAME_SIZE\n&quot;);
             return -1;
         }
+#endif
         if(*frame_size_ptr &lt; FF_MIN_BUFFER_SIZE ||
         *frame_size_ptr &lt; avctx-&gt;channels * avctx-&gt;frame_size * sizeof(int16_t)){
             av_log(avctx, AV_LOG_ERROR, &quot;buffer %d too small\n&quot;, *frame_size_ptr);
@@ -1023,7 +1025,7 @@
         return -1;
     }
 #if !HAVE_MKSTEMP
-    fd = open(*filename, O_RDWR | O_BINARY | O_CREAT, 0444);
+    fd = open(*filename, O_RDWR /* MEANX | O_BINARY*/ | O_CREAT, 0444);
 #else
     snprintf(*filename, len, &quot;/tmp/%sXXXXXX&quot;, prefix);
     fd = mkstemp(*filename);

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/file.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/file.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/file.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -30,7 +30,73 @@
 #include &lt;stdlib.h&gt;
 #include &quot;os_support.h&quot;
 
+// GRUNTSTER start
+#ifdef __WIN32
+#include &lt;windows.h&gt;
 
+int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString)
+{
+	int wideCharStringLength = MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, NULL, 0);
+
+	if (wideCharString)
+		MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, wideCharString, wideCharStringLength);
+
+	return wideCharStringLength;
+}
+
+int ADM_open(const char *path, int oflag, ...)
+{
+	int fileNameLength = utf8StringToWideChar(path, -1, NULL);
+	wchar_t wcFile[fileNameLength];
+	int creation = 0, access = 0;
+	HANDLE hFile;
+
+	utf8StringToWideChar(path, -1, wcFile);
+
+	if (oflag &amp; O_WRONLY || oflag &amp; O_RDWR)
+	{
+		access = GENERIC_WRITE;
+
+		if (oflag &amp; O_RDWR)
+			access |= GENERIC_READ;
+
+		if (oflag &amp; O_CREAT)
+		{
+			if (oflag &amp; O_EXCL)
+				creation = CREATE_NEW;
+			else if (oflag &amp; O_TRUNC)
+				creation = CREATE_ALWAYS;
+			else
+				creation = OPEN_ALWAYS;
+		}
+		else if (oflag &amp; O_TRUNC)
+			creation = TRUNCATE_EXISTING;
+	}
+	else if (oflag &amp; O_RDONLY)
+		creation = OPEN_EXISTING;
+
+	if (creation &amp; GENERIC_WRITE)
+	{
+		hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
+
+		if (hFile == INVALID_HANDLE_VALUE)
+			return -1;
+		else
+			CloseHandle(hFile);
+	}
+
+	hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
+
+	if (hFile == INVALID_HANDLE_VALUE)
+		return -1;
+	else
+		return _open_osfhandle((intptr_t)hFile, oflag);
+}
+
+#define open ADM_open
+#endif
+// GRUNTSTER end
+
 /* standard file protocol */
 
 static int file_open(URLContext *h, const char *filename, int flags)

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/flvenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/flvenc.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/flvenc.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -389,7 +389,8 @@
     &quot;video/x-flv&quot;,
     &quot;flv&quot;,
     sizeof(FLVContext),
-#if CONFIG_LIBMP3LAME
+//MEANX #if CONFIG_LIBMP3LAME
+#ifdef HAVE_LIBMP3LAME
     CODEC_ID_MP3,
 #else // CONFIG_LIBMP3LAME
     CODEC_ID_ADPCM_SWF,
@@ -401,3 +402,9 @@
     .codec_tag= (const AVCodecTag* const []){flv_video_codec_ids, flv_audio_codec_ids, 0},
     .flags= AVFMT_GLOBALHEADER,
 };
+// MEANX
+int flvenc_init(void)
+{
+    av_register_output_format(&amp;flv_muxer);
+    return 0;
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/isom.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/isom.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/isom.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -187,7 +187,10 @@
     { CODEC_ID_MACE3, MKTAG('M', 'A', 'C', '3') }, /* Macintosh Audio Compression and Expansion 3:1 */
     { CODEC_ID_MACE6, MKTAG('M', 'A', 'C', '6') }, /* Macintosh Audio Compression and Expansion 6:1 */
 
-    { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at <A HREF="http://www.3ivx.com/showcase.html">http://www.3ivx.com/showcase.html</A> use this tag */
+    //MEANX { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at <A HREF="http://www.3ivx.com/showcase.html">http://www.3ivx.com/showcase.html</A> use this tag */
+     { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
+     { CODEC_ID_MP2, MKTAG( 'm', 'p', '4', 'a') },
+    // /MEANX
     { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
 
 /*  { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at <A HREF="http://heroinewarrior.com/xmovie.php3">http://heroinewarrior.com/xmovie.php3</A> use this tag */

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/matroskaenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/matroskaenc.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/matroskaenc.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -395,6 +395,7 @@
 
 static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec)
 {
+#if 0 // MEANX avidemux does thing differently
     uint8_t *header_start[3];
     int header_len[3];
     int first_header_size;
@@ -419,6 +420,28 @@
         put_buffer(pb, header_start[j], header_len[j]);
 
     return 0;
+#else
+   // Not endian safe....
+      uint32_t packetLen[3],*ptr=(uint32_t *)codec-&gt;extradata;
+      uint8_t *data[3],i,j;
+      if( 3*4+ptr[0]+ptr[1]+ptr[2]!=codec-&gt;extradata_size)
+      {
+        av_log(s, AV_LOG_ERROR, &quot;Broken avidemux xiph header.\n&quot;);
+        return -1;
+      }
+      data[0]=codec-&gt;extradata+3*4;
+      data[1]=data[0]+ptr[0];
+      data[2]=data[1]+ptr[1];
+      put_byte(pb, 2);                    // number packets - 1
+      for (j = 0; j &lt; 2; j++) 
+      {
+          put_xiph_size(pb, ptr[j]);
+      }
+      for (j = 0; j &lt; 3; j++)
+        put_buffer(pb, data[j], ptr[j]);
+      
+      return 0; // /MEANX
+#endif
 }
 
 static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
@@ -534,6 +557,23 @@
         put_ebml_uint (pb, MATROSKA_ID_TRACKNUMBER     , i + 1);
         put_ebml_uint (pb, MATROSKA_ID_TRACKUID        , i + 1);
         put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
+/**  MEANX : Add a default duration for video **/
+        if(codec-&gt;codec_type==CODEC_TYPE_VIDEO)
+        {
+          if(codec-&gt;time_base.den &amp;&amp; codec-&gt;time_base.num)
+          {
+            int num=codec-&gt;time_base.num;
+            int den=codec-&gt;time_base.den;
+            unsigned int default_duration;
+            float period=num;
+                  period/=den;
+                  period*=1000*1000*1000; // in ns
+                  default_duration=(unsigned int)floor(period);
+                  put_ebml_uint (pb, MATROSKA_ID_TRACKDEFAULTDURATION ,default_duration);
+          }
+        }
+        
+/**  MEANX : Add a default duration for video **/
 
         if ((tag = av_metadata_get(st-&gt;metadata, &quot;description&quot;, NULL, 0)))
             put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag-&gt;value);
@@ -907,3 +947,13 @@
     .flags = AVFMT_GLOBALHEADER,
     .codec_tag = (const AVCodecTag* const []){codec_wav_tags, 0},
 };
+// MEANX
+//
+int matroskaenc_init(void)
+{
+    av_register_output_format(&amp;matroska_muxer);
+    return 0;
+}
+// /MEANX
+
+

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/movenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/movenc.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/movenc.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -2017,3 +2017,15 @@
     .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
 };
 #endif
+/* MEANX */
+int movenc_init(void)
+{
+    av_register_output_format(&amp;mov_muxer);
+    av_register_output_format(&amp;tgp_muxer);
+    av_register_output_format(&amp;mp4_muxer);
+    av_register_output_format(&amp;psp_muxer);
+    av_register_output_format(&amp;tg2_muxer);
+    av_register_output_format(&amp;ipod_muxer);
+    return 0;
+}
+/* MEANX */

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/movenc.c.orig
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/movenc.c.orig	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavformat/movenc.c.orig	2009-05-02 13:54:13 UTC (rev 4787)
@@ -26,12 +26,8 @@
 #include &quot;avio.h&quot;
 #include &quot;isom.h&quot;
 #include &quot;avc.h&quot;
-&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:libavformat/movenc.c
-#include &quot;ADM_lavcodec/bitstream.h&quot;
-=======
 #include &quot;libavcodec/get_bits.h&quot;
 #include &quot;libavcodec/put_bits.h&quot;
-&gt;&gt;&gt;&gt;&gt;&gt;&gt; master:libavformat/movenc.c
 
 #undef NDEBUG
 #include &lt;assert.h&gt;
@@ -1140,11 +1136,8 @@
 
     put_be32(pb, av_rescale_rnd(track-&gt;trackDuration, globalTimescale, track-&gt;timescale, AV_ROUND_UP)); /* duration   ... doesn't seem to effect psp */
 
-    // MEANX : NO put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
-    // MEANX : NO put_be32(pb, 0x00010000);
- put_be32(pb, 0x00000000);
- put_be32(pb, 0x00000001);
-
+    put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
+    put_be32(pb, 0x00010000);
     return 0x24;
 }
 
@@ -2024,15 +2017,3 @@
     .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
 };
 #endif
-/* MEANX */
-int movenc_init(void)
-{
-    av_register_output_format(&amp;mov_muxer);
-    av_register_output_format(&amp;tgp_muxer);
-    av_register_output_format(&amp;mp4_muxer);
-    av_register_output_format(&amp;psp_muxer);
-    av_register_output_format(&amp;tg2_muxer);
-    // FIXME av_register_output_format(&amp;ipod_muxer);
-    return 0;
-}
-/* MEANX */

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/avutil.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/avutil.h	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/avutil.h	2009-05-02 13:54:13 UTC (rev 4787)
@@ -26,7 +26,14 @@
  * external API header
  */
 
+/* MEANX
+ * - */
+#define ASMALIGN(ZEROBITS) &quot;.p2align &quot; #ZEROBITS &quot;\n\t&quot;
+/* /MEANX
+ */
 
+
+
 #define AV_STRINGIFY(s)         AV_TOSTRING(s)
 #define AV_TOSTRING(s) #s
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/internal.h	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/internal.h	2009-05-02 13:54:13 UTC (rev 4787)
@@ -215,12 +215,14 @@
 #endif
 
 /* avoid usage of dangerous/inappropriate system functions */
+#if 0 //MEANX
 #undef  malloc
 #define malloc please_use_av_malloc
 #undef  free
 #define free please_use_av_free
 #undef  realloc
 #define realloc please_use_av_realloc
+#endif
 #undef  time
 #define time time_is_forbidden_due_to_security_issues
 #undef  rand

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/mem.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/mem.c	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavutil/mem.c	2009-05-02 13:54:13 UTC (rev 4787)
@@ -46,87 +46,110 @@
 
 void *av_malloc(unsigned int size)
 {
-    void *ptr = NULL;
-#if CONFIG_MEMALIGN_HACK
-    long diff;
-#endif
+#ifdef __APPLE__
+	return malloc(size);
+#else
+	char *c;
 
-    /* let's disallow possible ambiguous cases */
-    if(size &gt; (INT_MAX-16) )
-        return NULL;
+	uint64_t l, lorg;
+	uint32_t *backdoor;
 
-#if CONFIG_MEMALIGN_HACK
-    ptr = malloc(size+16);
-    if(!ptr)
-        return ptr;
-    diff= ((-(long)ptr - 1)&amp;15) + 1;
-    ptr = (char*)ptr + diff;
-    ((char*)ptr)[-1]= diff;
-#elif HAVE_POSIX_MEMALIGN
-    if (posix_memalign(&amp;ptr,16,size))
-        ptr = NULL;
-#elif HAVE_MEMALIGN
-    ptr = memalign(16,size);
-    /* Why 64?
-       Indeed, we should align it:
-         on 4 for 386
-         on 16 for 486
-         on 32 for 586, PPro - K6-III
-         on 64 for K7 (maybe for P3 too).
-       Because L1 and L2 caches are aligned on those values.
-       But I don't want to code such logic here!
-     */
-     /* Why 16?
-        Because some CPUs need alignment, for example SSE2 on P4, &amp; most RISC CPUs
-        it will just trigger an exception and the unaligned load will be done in the
-        exception handler or it will just segfault (SSE2 on P4).
-        Why not larger? Because I did not see a difference in benchmarks ...
-     */
-     /* benchmarks with P3
-        memalign(64)+1          3071,3051,3032
-        memalign(64)+2          3051,3032,3041
-        memalign(64)+4          2911,2896,2915
-        memalign(64)+8          2545,2554,2550
-        memalign(64)+16         2543,2572,2563
-        memalign(64)+32         2546,2545,2571
-        memalign(64)+64         2570,2533,2558
+	l = (uint64_t)malloc(size + 32);
 
-        BTW, malloc seems to do 8-byte alignment by default here.
-     */
-#else
-    ptr = malloc(size);
+	// Get next boundary
+	lorg = l;
+	l = (l + 15) &amp; 0xfffffffffffffff0LL;
+	l += 16;
+	c = (char*)l;
+	backdoor = (uint32_t*)(c - 8);
+	*backdoor = (0xdead &lt;&lt; 16) + l - lorg;
+	backdoor[1] = size;
+
+	return c;
 #endif
-    return ptr;
 }
 
-void *av_realloc(void *ptr, unsigned int size)
+void *av_realloc(void *ptr, unsigned int newsize)
 {
-#if CONFIG_MEMALIGN_HACK
-    int diff;
-#endif
+#ifdef __APPLE__
+	if (!ptr)
+		return av_malloc(newsize);
 
-    /* let's disallow possible ambiguous cases */
-    if(size &gt; (INT_MAX-16) )
-        return NULL;
+	if (!newsize)
+	{
+		av_free(ptr);
+		return NULL;
+	}
 
-#if CONFIG_MEMALIGN_HACK
-    //FIXME this isn't aligned correctly, though it probably isn't needed
-    if(!ptr) return av_malloc(size);
-    diff= ((char*)ptr)[-1];
-    return (char*)realloc((char*)ptr - diff, size + diff) + diff;
+	return realloc(ptr, newsize);
 #else
-    return realloc(ptr, size);
+	void *nalloc;
+
+	if (!ptr)
+		return av_malloc(newsize);
+
+	if (!newsize) 
+	{
+		av_free(ptr);
+		return NULL;
+	}
+
+	// now we either shrink them or expand them
+	// in case of shrink, we do nothing
+	// in case of expand we have to copy
+	// Do copy everytime (slower)
+	uint32_t *backdoor;
+	uint32_t size, offset;
+	char *c = (char*)ptr;
+
+	backdoor = (uint32_t*)ptr;
+	backdoor -= 2;
+
+	assert(((*backdoor) &gt;&gt; 16) == 0xdead);
+
+	offset = backdoor[0] &amp; 0xffff;
+	size = backdoor[1];
+
+	if(size &gt;= newsize) // do nothing
+		return ptr;
+
+	// Allocate a new one
+	nalloc = av_malloc(newsize);
+	memcpy(nalloc, ptr, size);
+	av_free(ptr);
+
+	return nalloc;
 #endif
 }
 
 void av_free(void *ptr)
 {
-    /* XXX: this test should not be needed on most libcs */
-    if (ptr)
-#if CONFIG_MEMALIGN_HACK
-        free((char*)ptr - ((char*)ptr)[-1]);
+#ifdef __APPLE__
+	if (!ptr)
+		return;
+
+	free(ptr);
 #else
-        free(ptr);
+	uint32_t *backdoor;
+	uint32_t size, offset;
+	char *c = (char*)ptr;
+
+	if (!ptr)
+		return;
+
+	backdoor = (uint32_t*)ptr;
+	backdoor -= 2;
+
+	if (*backdoor == 0xbeefbeef)
+		assert(0);
+
+	assert(((*backdoor) &gt;&gt; 16) == 0xdead);
+
+	offset = backdoor[0] &amp; 0xffff;
+	size = backdoor[1];
+	*backdoor = 0xbeefbeef; // Scratch sig
+
+	free(c - offset);
 #endif
 }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libswscale/swscale_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libswscale/swscale_internal.h	2009-05-02 13:54:11 UTC (rev 4786)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libswscale/swscale_internal.h	2009-05-02 13:54:13 UTC (rev 4787)
@@ -33,7 +33,7 @@
 
 #define MAX_FILTER_SIZE 256
 
-#define VOFW 2048
+#define VOFW 4096
 #define VOF  (VOFW*2)
 
 #ifdef WORDS_BIGENDIAN


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002010.html">[Avidemux-svn-commit] r4786 -	branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_ffmpeg/libavcodec
</A></li>
	<LI>Next message: <A HREF="002012.html">[Avidemux-svn-commit] r4788 - in	branches/avidemux_2.6_branch_mean/avidemux:	ADM_audioParser/src ADM_libraries/ADM_ffmpeg/libavcodec	ADM_libraries/ADM_ffmpeg/libavformat	ADM_libraries/ADM_ffmpeg/libavutil
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2011">[ date ]</a>
              <a href="thread.html#2011">[ thread ]</a>
              <a href="subject.html#2011">[ subject ]</a>
              <a href="author.html#2011">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
