<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3646 - in	branches/avidemux_2.4_branch/avidemux: .	ADM_userInterfaces/ADM_GTK/ADM_gui2	ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-October/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3646%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20.%0A%09ADM_userInterfaces/ADM_GTK/ADM_gui2%0A%09ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk&In-Reply-To=%3C200710140814.l9E8EMJg012778%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000916.html">
   <LINK REL="Next"  HREF="000918.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3646 - in	branches/avidemux_2.4_branch/avidemux: .	ADM_userInterfaces/ADM_GTK/ADM_gui2	ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3646%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20.%0A%09ADM_userInterfaces/ADM_GTK/ADM_gui2%0A%09ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk&In-Reply-To=%3C200710140814.l9E8EMJg012778%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3646 - in	branches/avidemux_2.4_branch/avidemux: .	ADM_userInterfaces/ADM_GTK/ADM_gui2	ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk">mean at mail.berlios.de
       </A><BR>
    <I>Sun Oct 14 10:14:22 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000916.html">[Avidemux-svn-commit] r3645 - branches/avidemux_2.4_branch/po
</A></li>
        <LI>Next message: <A HREF="000918.html">[Avidemux-svn-commit] r3647 - in branches/avidemux_2.4_branch: .	debian
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#917">[ date ]</a>
              <a href="thread.html#917">[ thread ]</a>
              <a href="subject.html#917">[ subject ]</a>
              <a href="author.html#917">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-10-14 10:14:21 +0200 (Sun, 14 Oct 2007)
New Revision: 3646

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.c
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.h
   branches/avidemux_2.4_branch/avidemux/button_mapping
   branches/avidemux_2.4_branch/avidemux/gui_action.names
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/jogshuttle.c
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/jogshuttle.h
   branches/avidemux_2.4_branch/avidemux/avi_vars.h
   branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp
   branches/avidemux_2.4_branch/avidemux/gtkgui.h
   branches/avidemux_2.4_branch/avidemux/gui_action.hxx
   branches/avidemux_2.4_branch/avidemux/gui_navigate.cpp
Log:
[JugShuttle] Chris Mac Gregor : Handle physical jugshuttle

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2007-10-14 08:14:21 UTC (rev 3646)
@@ -13,8 +13,9 @@
  *   the Free Software Foundation; either version 2 of the License, or     *
  *   (at your option) any later version.                                   *
  ***************************************************************************/
-#include &quot;config.h&quot;
 
+#include &quot;default.h&quot;
+
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
@@ -24,7 +25,6 @@
 #include &lt;gtk/gtk.h&gt;
 
 #include &quot;../ADM_assert.h&quot;
-#include &quot;default.h&quot;
 #include &quot;ADM_commonUI/GUI_render.h&quot;
 #include &quot;../gui_action.hxx&quot;
 
@@ -43,6 +43,7 @@
 #include &quot;../prefs.h&quot;
 #include &quot;../ADM_toolkit_gtk/gtkmarkscale.h&quot;
 #include &quot;../ADM_toolkit_gtk/jogshuttle.h&quot;
+#include &quot;../ADM_toolkit_gtk/ADM_jogshuttle.h&quot;
 
 uint8_t UI_getPhysicalScreenSize(uint32_t *w,uint32_t *h);
 
@@ -153,6 +154,7 @@
 gboolean UI_returnFocus(GtkWidget *widget, GdkEventButton *event, gpointer user_data);
 // Global
 GtkAccelGroup *accel_group;
+PhysicalJogShuttle *physical_jog_shuttle;
 //
 void guiCallback(GtkMenuItem * menuitem, gpointer user_data);
 
@@ -225,8 +227,9 @@
                 UI_getPhysicalScreenSize(&amp;w,&amp;h); //gtk_widget_get_parent_window (guiRootWindow));
                 printf(&quot;The screen seems to be %u x %u px\n&quot;,w,h);
  
-                 GUI_gtk_grow_off(1);
+                GUI_gtk_grow_off(1);
 
+                physical_jog_shuttle = &amp;(PhysicalJogShuttle::getInstance());
                
 	return ret;
 }
@@ -237,6 +240,8 @@
 
 	for(int i=0;i&lt;ADM_nbCustom;i++)
 		delete(customNames[i]);
+
+        delete physical_jog_shuttle;
 }
 
 /**
@@ -580,6 +585,11 @@
         
 }
 
+GtkWidget * lookup_jog_shuttle_widget (void)
+{
+    return lookup_widget(guiRootWindow,&quot;jogg&quot;);
+}
+
 void UI_setTitle(const char *name)
 {
         char title[1024];
@@ -1189,15 +1199,15 @@
  * */
 static uint32_t jogScale[10]={
 50,
-50,
 40,
-40,
-20,
+30,
 20,  // 5
 10,
 5,
 3,
-2
+2,
+1,
+0
 };
 static int nbTimer=0;
 static int jogLock=0;
@@ -1222,6 +1232,7 @@
     v=UI_readJog();
     r=abs(v);
     r=r/10;
+    //printf (&quot;r %d v %d\n&quot;, r, v);
     if(!r)
     {
       return FALSE;
@@ -1230,6 +1241,7 @@
     if(count)     count--;
     if(count)     return TRUE;
     count=tickToTime(r);
+    //printf (&quot;r %d v %d count %d\n&quot;, r, v, count);
     if(jogLock) return FALSE;
     
     jogLock++;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp	2007-10-14 08:14:21 UTC (rev 3646)
@@ -1195,8 +1195,8 @@
   jogg = jog_shuttle_new ();gtk_widget_set_size_request (jogg, -1, 16); 
   gtk_widget_show (jogg);
   gtk_table_attach (GTK_TABLE (table2), jogg, 1, 2, 0, 1,
-                    (GtkAttachOptions) (0),
-                    (GtkAttachOptions) (0), 0, 0);
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (GTK_EXPAND), 0, 0);
   GTK_WIDGET_UNSET_FLAGS (jogg, GTK_CAN_FOCUS);
   GTK_WIDGET_UNSET_FLAGS (jogg, GTK_CAN_DEFAULT);
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h	2007-10-14 08:14:21 UTC (rev 3646)
@@ -87,7 +87,7 @@
 CALLBACK(toolbar1                              ,ACT_ViewMain);
 CALLBACK(sidebar1                              ,ACT_ViewSide);
 //CALLBACK(preview1                              ,ACT_PreviewToggle);
-//CALLBACK(display_output1                       ,ACT_OuputToggle);
+//CALLBACK(display_output1                       ,ACT_OutputToggle);
 CALLBACK(second_audio_track1                   ,ACT_SecondAudioTrack);
 
 CALLBACK(vcd1                                   ,ACT_AUTO_VCD);

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.cpp	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.cpp	2007-10-14 08:14:21 UTC (rev 3646)
@@ -0,0 +1,489 @@
+// $Id: jogshuttle.cc,v 1.22 2007/02/20 06:32:05 ddennedy Exp $
+/*
+ * Copyright (C) 2001 Tomoaki Hayasaka &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">hayasakas at postman.riken.go.jp</A>&gt;
+ * Copyright (C) 2001-2007 Dan Dennedy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">dan at dennedy.org</A>&gt;
+ * Taken from Kino 1.1.1, with permission, and hacked severely by
+ * Chris MacGregor &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.dom</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/// Support for special USB Jog/Shuttle input controllers
+
+// TODO:
+// * What happens for someone who has a device not listed in the
+//   supported_devices[] table in mediactrl.c?  They should at least be able
+//   to try pretending that it is one of the supported devices, in case that
+//   works, and really they should be able to specify various parameters in a
+//   config file of some sort (device code and name; key mappings; input
+//   ranges (min/max wheel range, etc.); which translation function to use
+//   (contour or compliant)).
+// * There should be a mode or something where the user can explore their
+//   device (see what code is returned for each button, test the value ranges,
+//   etc.) so they have the data for the config file.
+// * Button mapping: the ideal would be a dialog where they can match buttons
+//   to actions, and then save it to a config file.  I don't have time to
+//   implement that now.  The next best thing would be just the config file,
+//   and they have to edit it directly.  Maybe I can do that...
+
+//#include &quot;default.h&quot; // avi_vars.h includes this
+#include &quot;avi_vars.h&quot;
+
+#include &lt;math.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;linux/input.h&gt;
+#include &lt;cctype&gt;
+
+#include &quot;gtkgui.h&quot;
+
+#include &quot;gui_action.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+#include &quot;jogshuttle.h&quot;
+#include &quot;ADM_jogshuttle.h&quot;
+
+GtkWidget * lookup_jog_shuttle_widget (void); // GUI_bindings.cpp
+
+#include &lt;string&gt;
+using std::string;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+using std::ifstream;
+
+/// PhysicalJogShuttle
+
+/** The global PhysicalJogShuttle object.
+	 
+    It is accessible to other classes via the getInstance method.
+*/
+
+PhysicalJogShuttle * PhysicalJogShuttle::_instance = NULL;
+
+/** Singleton getInstance method. Standard pattern. Non-threadsafe, but
+    first instance gets called from the commands.cc which should be OK.
+*/
+
+PhysicalJogShuttle &amp; PhysicalJogShuttle::getInstance()
+{
+    if (_instance == 0)
+        _instance = new PhysicalJogShuttle();
+    return *_instance;
+}
+
+/** Constructor
+ */
+PhysicalJogShuttle::PhysicalJogShuttle() :
+    _callback (0),
+    input_ (-1),
+    monitorTag_ (-1),
+    _modifier_code (0),
+    show_buttons (getenv (&quot;SHOW_BUTTONS&quot;) != 0)
+{
+    _ctrl.device = 0;
+    if (!start())
+        return;
+
+    const char * home = getenv (&quot;HOME&quot;);
+    if (!home)
+        return;
+
+    string buttonfile = home;
+    buttonfile += &quot;/.avidemux/button_mapping&quot;;
+    const char * filename = buttonfile.c_str();
+    ifstream inputStream (filename);
+    if (!inputStream)
+    {
+        if (errno != ENOENT)
+            perror (filename);
+        return;
+    }
+
+    printf (&quot;Reading jog shuttle device button mappings from %s:\n&quot;,
+            filename);
+
+    int linenum = 0;
+    while (inputStream)
+    {
+        const int BUFFER_SIZE = 100;
+        char buffer [BUFFER_SIZE];
+        inputStream.getline (buffer, BUFFER_SIZE);
+        char * cptr = buffer;
+        ++linenum;
+        while (isspace (*cptr))
+            ++cptr;
+        if (*cptr == '\0' || *cptr == '#')
+            continue;
+        if (strncmp (cptr, &quot;help&quot;, 4) == 0)
+        {
+            dumpActionNames (filename);
+            continue;
+        }
+        if (!isdigit (*cptr))
+        {
+            printf (&quot;%s line %d: expecting a button number first, &quot;
+                    &quot;found \&quot;%s\&quot;\n&quot;, filename, linenum, cptr);
+            continue;
+        }
+        int button_num = atoi (cptr);
+        if (button_num == 0)
+        {
+            printf (&quot;%s line %d: %d is not a valid button number\n&quot;,
+                    filename, linenum, button_num);
+            continue;
+        }
+        while (isdigit (*cptr))
+            ++cptr;
+        while (isspace (*cptr))
+            ++cptr;
+        if (!isalpha (*cptr))
+        {
+            printf (&quot;%s line %d: expecting an action name following button &quot;
+                    &quot;number, found \&quot;%s\&quot;\n&quot;, filename, linenum, cptr);
+            continue;
+        }
+        const char * name = cptr;
+        while (isalnum (*cptr) || *cptr == '_')
+            ++cptr;
+        char * name_end = cptr;
+        while (isspace (*cptr))
+            ++cptr;
+        if (*cptr)
+            printf (&quot;%s line %d: ignoring unexpected stuff (\&quot;%s\&quot;) &quot;
+                    &quot;following action name\n&quot;, filename, linenum, cptr);
+        *name_end = '\0';
+
+        Action act = lookupActionByName (name);
+        if (act == ACT_INVALID)
+        {
+            if (strcasecmp (name, &quot;help&quot;) == 0)
+                dumpActionNames (filename);
+            else
+                printf (&quot;%s line %d: %s is not a valid action name &quot;
+                        &quot;(try \&quot;help\&quot;)\n&quot;, filename, linenum, name);
+        }
+        else
+        {
+            // printf (&quot;mapping button %d to action %s (%d)\n&quot;,
+            printf (&quot;mapping button %d to action %s\n&quot;,
+                    button_num, getActionName (act), act);
+            button_action_map [button_num] = act;
+        }
+    }
+}
+
+/** Destructor
+ 
+    Remove the callback function from the GDK input handler.
+*/
+PhysicalJogShuttle::~PhysicalJogShuttle ()
+{
+    stop();
+    if (input_ &gt;= 0)
+    {
+        gdk_input_remove (monitorTag_);
+        media_ctrl_close (&amp;_ctrl);
+    }
+}
+
+/// A static wrappper for the GDK input handler callback
+void PhysicalJogShuttle::inputCallback (gpointer data, gint source,
+                                        GdkInputCondition condition)
+{
+    PhysicalJogShuttle * js = static_cast &lt;PhysicalJogShuttle *&gt; (data);
+    g_return_if_fail (js != NULL);
+    js-&gt;inputCallback (source, condition);
+}
+
+/** Start the GDK input handler if enabled.
+
+    \return a boolean indicating if not started due to not enabled or device
+    open failed.
+*/
+bool PhysicalJogShuttle::start ()
+{
+    stop();
+    media_ctrl_open (&amp;_ctrl);
+    if (_ctrl.device) 
+    {
+        monitorTag_ = gdk_input_add (_ctrl.fd, GDK_INPUT_READ,
+                                     inputCallback, (gpointer) this);
+        printf (&quot;Physical Jog/Shuttle device enabled.\n&quot;);
+        return true;
+    }
+
+    printf (&quot;No physical Jog/Shuttle device found.\n&quot;);
+    return false;
+}
+
+/** Stop the GDK input handler.
+ */
+void PhysicalJogShuttle::stop()
+{
+    if (monitorTag_ != -1)
+    {
+        gdk_input_remove (monitorTag_);
+        monitorTag_ = -1;
+    }
+    if (_ctrl.device)
+        media_ctrl_close (&amp;_ctrl);
+}
+
+#if 0
+/** Register callback
+ 
+    Register an interest in getting notification when buttons are pressed
+    
+    \param callback Function to call
+*/
+void PhysicalJogShuttle::registerCallback (void * user, JogShuttleCallback callback)
+{
+    if (_callback)
+        g_warning (&quot;PhysicalJogShuttle::registerCallback - already registered\n&quot;);
+    _callback = callback;
+    _callbackdata = user;
+}
+
+/** Deregister callback
+ 
+    Deregister an interest in getting notification when buttons are pressed
+    
+    \param callback Function to stop calling
+*/
+void PhysicalJogShuttle::deregisterCallback ()
+{
+    if (_callback == NULL)
+        g_warning( &quot;PhysicalJogShuttle::deregisterCallback - not registered\n&quot;);
+    _callback = 0;
+}
+#endif
+
+struct media_ctrl_key *PhysicalJogShuttle::getKeyset ()
+{
+    if (_ctrl.device != 0)
+        return _ctrl.device-&gt;keys;
+    else
+        return 0;
+}
+
+
+/** Handle movement on the jog dial.
+ 
+    \param dir A number from -x to x to specify the offset from the current frame.
+    A negative number moves backward. Typically, x is 1 to step frame-by-frame.
+*/
+void PhysicalJogShuttle::jog (int offs)
+{
+    gdk_threads_enter();
+    // printf (&quot;jog %d\n&quot;, offs);
+    if (offs &lt; 0)
+        GUI_PrevFrame (uint32_t (-offs));
+    else
+        GUI_NextFrame (uint32_t (offs));
+    gdk_threads_leave();
+}
+
+/** Handle movement of the shuttle ring.
+ 
+    \param angle A number from -15 to +15 that specifies a direction and speed.
+*/
+void PhysicalJogShuttle::shuttle (gfloat angle)
+{
+    gdk_threads_enter();
+    // printf (&quot;shuttle %f\n&quot;, angle);
+    GtkWidget * jsw = lookup_jog_shuttle_widget();
+    if (jsw)
+        jog_shuttle_set_value (jsw, angle);
+    gdk_threads_leave();
+}
+
+// This is part of a hack to allow the user to attach the Play and Stop
+// actions to buttons.  The problem is that once we launch the Play action,
+// HandleAction() doesn't return to its caller until avidemux stops playing,
+// so if HandleAction() is called directly from the event handler, there is no
+// way for the Stop button to be seen until something else has already stopped
+// it.  However, if we have the event handler just set up a timer, which
+// launches the play action, it's only the timer that is locked up, and since
+// we only use the timer for the Play action (and not any of the other
+// buttons), then everything (including the Stop button) works just fine.
+// A GTK expert might know of a better way to solve this problem, but I'm not
+// convinced that one exists in current GTK (2.10 on my FC7 system, but we
+// need to support older ones, too).
+
+gint
+on_PlayButtonHackTimer (gpointer data)
+{
+   gdk_threads_enter();
+   HandleAction (ACT_PlayAvi);
+   gdk_threads_leave();
+   return 0;
+}
+
+
+/** Handle key press
+ 
+    \param ev The key event
+    Modifier keys - we maintain the state of the first key that is
+    pressed down. This is a &quot;poor man&quot;s way of doing modifier
+    keys. It means that we can press a single key, keep it down, and
+    press a number of others. Any key can be used as a modifier key,
+    although you would probably want to not assign an action to a
+    modifier key when first pressed. There is no way to react to multiple
+    modifier keys though.
+
+*/
+void PhysicalJogShuttle::button (struct media_ctrl_event *ev)
+{
+    /* Figure out what codes to use */
+    unsigned short first;
+    unsigned short second;
+
+    // Note: the modifier stuff is carried over from kino, but not currently
+    // in use here.  I've left it here just in case someone decides to enable
+    // it some day.  However, it doesn't seem to work the way I would expect.
+
+    /* 
+       Release may need to clear a modifier key
+    */
+    if (ev-&gt;value == KEY_RELEASE &amp;&amp; _modifier_code != 0)
+    {
+        _modifier_code = 0;
+        return;
+    }
+
+    /* Do a callback or action based command */
+    if (_callback != 0)
+    {
+        /* This is a key press - if there are no modifier, make sure that
+           this is saved */
+        if (_modifier_code == 0)
+            _modifier_code = ev-&gt;index + 1;
+
+        if (_modifier_code != ev-&gt;index + 1)
+        {
+            first = _modifier_code - 1;
+            second = ev-&gt;index + 1;
+        }
+        else
+        {
+            first = ev-&gt;index; /* Same as modifier */
+            second = 0;
+        }
+        _callback (_callbackdata, first, second);
+    }
+    else
+    {
+        /* This is a key press - if there are no modifier, make sure that
+           this is saved */
+        if (_modifier_code == 0)
+            _modifier_code = ev-&gt;code;
+
+        if (_modifier_code != ev-&gt;code)
+        {
+            first = _modifier_code;
+            second = ev-&gt;code;
+        }
+        else
+        {
+            first = ev-&gt;code; /* Same as modifier */
+            second = 0;
+        }
+		
+        gdk_threads_enter();
+
+        ButtonActionIter it = button_action_map.find (first);
+        if (it != button_action_map.end())
+        {
+            if (show_buttons)
+                printf (&quot;button pressed: %d -&gt; %s\n&quot;,
+                        first, getActionName (it-&gt;second));
+            // hack alert: see comment for on_PlayButtonHackTimer(), above
+            if (it-&gt;second == ACT_PlayAvi)
+                g_timeout_add (10, on_PlayButtonHackTimer, NULL);
+            else
+                HandleAction (it-&gt;second);
+        }
+        else if (show_buttons)
+            printf (&quot;button pressed: %d (not mapped)\n&quot;, first);
+
+        gdk_threads_leave();
+    }
+}
+
+
+/** The GDK input callback function.
+ 
+    GDK calls this whenever input is received. It is hooked into the system
+    during object construction.
+*/
+void PhysicalJogShuttle::inputCallback (gint source, GdkInputCondition condition)
+{
+    g_return_if_fail (this != 0);
+    if (condition != GDK_INPUT_READ)
+        stop();
+    g_return_if_fail (condition == GDK_INPUT_READ);
+
+    struct media_ctrl_event ev;
+	
+    ev.type = MEDIA_CTRL_EVENT_NONE;
+    media_ctrl_read_event (&amp;_ctrl, &amp;ev);
+
+    /* We can get four &quot;kinds&quot; of events:
+
+       ev.type == MEDIA_CTRL_EVENT_NONE (0x00)
+       An event that actually isn't one... Since we read every event
+       from the input subsystem, we sometimes get double events 
+       (e.g. the shuttlepro reports its state approx. every second.)
+       libmediactrl translates these events to none-events.
+	
+	
+       ev.type == MEDIA_CTRL_EVENT_KEY (0x01)
+       This is a button press. The whole event will be handled in the
+       button method..
+
+       ev.type == MEDIA_CTRL_EVENT_JOG (0x02)
+       This event is issued when ever the dial position changes. 
+       ev.value is the offset to the current jog position.
+
+
+       - ev.code == MEDIA_CTRL_EVENT_SHUTTLE (0x02) 
+       the outer wheel ev.value indicates the position, with positive 
+       values from 0x01 to 0x0f (inclusive) indicating clockwise twist, 
+       and negative values from -1 to -15 indicating counterclockwise 
+       twist.  A 0 value is reported. 
+
+    */
+
+    if (ev.type == MEDIA_CTRL_EVENT_NONE)
+        return;
+#if 0
+    printf (&quot;PhysicalJogShuttle: %02x %02x %02d\n&quot;, ev.type, ev.code, ev.value);
+#endif
+
+    if (ev.type == MEDIA_CTRL_EVENT_JOG) 
+    {
+        this-&gt;jog (ev.value);
+    } 
+    else if (ev.type == MEDIA_CTRL_EVENT_SHUTTLE)
+    {
+        this-&gt;shuttle (ev.fvalue);
+    }
+    else if (ev.type == MEDIA_CTRL_EVENT_KEY)
+    {
+        this-&gt;button (&amp;ev);
+    }
+    else
+    {
+        return;
+    }
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.h	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.h	2007-10-14 08:14:21 UTC (rev 3646)
@@ -0,0 +1,97 @@
+// $Id: jogshuttle.h,v 1.12 2007/02/20 06:32:05 ddennedy Exp $
+
+/*
+ * Copyright (C) 2001 Tomoaki Hayasaka &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">hayasakas at postman.riken.go.jp</A>&gt;
+ * Copyright (C) 2001-2007 Dan Dennedy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">dan at dennedy.org</A>&gt;
+ * Taken from Kino 1.1.1, with permission, and hacked severely by
+ * Chris MacGregor &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.dom</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef JOGSHUTTLE_H
+#define JOGSHUTTLE_H
+
+#include &lt;map&gt;
+
+#include &lt;gtk/gtk.h&gt;
+#include &quot;mediactrl.h&quot;
+
+/** 
+ * Type for JogShuttle event callbacks.
+ *
+ * The callback system is mainly used by the preference dialog to get
+ * a notification when an event is received, instead of the usual
+ * case, which is to perform a command. */
+
+typedef void (* JogShuttleCallback) (void *, unsigned short, unsigned short);
+
+/**
+ * Class to encapsulate an abstract JogShuttle device.
+ * 
+ * This class is used by the kino core to interact with a JogShuttle
+ * device.  (Also used by the preference dialog for configuration).
+ * It depends on the GDK input system, and uses the libmediactrl stuff
+ * to translate different (more or less broken) devices events into
+ * something that resembles the linux event system.  It also keeps
+ * track of modifier keys, that is, up to two keys pressed in succession. */
+
+class PhysicalJogShuttle
+{ 
+private: 
+    /** Singleton pattern. */
+    static PhysicalJogShuttle *_instance; 
+    /** Placeholder for callbacks. */
+    JogShuttleCallback _callback; 
+    /** Any client supplied callbackdata is here. */
+    void * _callbackdata;
+
+protected:
+    static void inputCallback (gpointer data, gint source,
+                               GdkInputCondition condition);
+    void inputCallback (gint source, GdkInputCondition condition);
+    PhysicalJogShuttle();
+
+public:
+    ~PhysicalJogShuttle();
+    bool start();
+    void stop();
+    static PhysicalJogShuttle &amp; getInstance();
+    void registerCallback (void * user, JogShuttleCallback callback);
+    void deregisterCallback();
+    struct media_ctrl_key *getKeyset();
+
+private:
+    void jog (int dir);
+    void shuttle (gfloat angle);
+    void button (struct media_ctrl_event *);
+    void button_old (int code);
+
+    typedef std::map &lt;unsigned short, Action&gt; ButtonActionMap;
+    typedef ButtonActionMap::iterator ButtonActionIter;
+
+    struct media_ctrl _ctrl;
+    int input_;
+    gint monitorTag_;
+
+    /* Used to keep track of &quot;modifier&quot; keys - only the buttons
+       can be used, only the code is used */
+    unsigned short _modifier_code;
+//    media_ctrl_key *_modifier;
+    ButtonActionMap button_action_map;
+    bool show_buttons;
+};
+
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/CMakeLists.txt	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/CMakeLists.txt	2007-10-14 08:14:21 UTC (rev 3646)
@@ -6,7 +6,7 @@
 #
 SET(${ADM_LIB}_SRCS
 ADM_gladeSupport.cpp  ADM_tray_gtk.cpp  choice.cpp  TLK_filesel.cpp  toolkit.cpp  toolkit_dialog.cpp 
-                                        eggtrayicon.c eggtray_win32.c gtkmarkscale.c jogshuttle.c
+    eggtrayicon.c eggtray_win32.c gtkmarkscale.c jogshuttle.c ADM_jogshuttle.cpp  mediactrl.c
 )
 ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
 ADD_ADM_LIB(${ADM_LIB} ADM_libraries)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/Makefile.am	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/Makefile.am	2007-10-14 08:14:21 UTC (rev 3646)
@@ -9,7 +9,7 @@
 libADM_toolkit_gtk_a_METASOURCES = AUTO
 
 libADM_toolkit_gtk_a_SOURCES = ADM_gladeSupport.cpp  ADM_tray_gtk.cpp  choice.cpp  TLK_filesel.cpp  toolkit.cpp  toolkit_dialog.cpp \
-					eggtrayicon.c eggtray_win32.c gtkmarkscale.c jogshuttle.c
+		eggtrayicon.c eggtray_win32.c gtkmarkscale.c jogshuttle.c ADM_jogshuttle.cpp mediactrl.c
 
 
 EXTRA_DIST = 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/jogshuttle.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/jogshuttle.c	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/jogshuttle.c	2007-10-14 08:14:21 UTC (rev 3646)
@@ -1,3 +1,7 @@
+// This is for the simulated jog/shuttle control on the main window, but it
+// can also be controlled by jog/shuttle controllers that exist in the
+// physical world (which are handled in ADM_jogshuttle.cpp).
+
 #include &lt;gtk/gtk.h&gt;
 #include &quot;jogshuttle.h&quot;
 
@@ -16,6 +20,7 @@
 {
 	gfloat pos[6];
 	gboolean pressed;
+	gboolean external_control;
 	gfloat start;
 	gfloat offset;
 	gfloat value;
@@ -62,6 +67,7 @@
 	priv = JOG_SHUTTLE_GET_PRIVATE (wheel);
 	
 	priv-&gt;pressed = FALSE;
+	priv-&gt;external_control = FALSE;
 	priv-&gt;offset = 0;
 	priv-&gt;value = 0;
 	gtk_widget_add_events (GTK_WIDGET (wheel), GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK);
@@ -307,6 +313,7 @@
 	}
 	
 	priv-&gt;value = (priv-&gt;pos[3]-middle) / middle;
+        //printf (&quot;pos[3] = %f\n&quot;, priv-&gt;pos[3]);
  	emit_value_changed_signal (JOG_SHUTTLE(wheel));
 }
 
@@ -316,7 +323,7 @@
 	JogShuttlePrivate *priv;
 	priv = JOG_SHUTTLE_GET_PRIVATE (wheel);
 	
-	if (!priv-&gt;pressed)
+	if (!priv-&gt;pressed &amp;&amp; !priv-&gt;external_control)
 	{
 		reset(wheel);
 	}
@@ -339,12 +346,45 @@
 gfloat 
 jog_shuttle_get_value (GtkWidget *wheel)
 {
+	if (!wheel)
+	    return 0;
 	JogShuttlePrivate *priv;
 	priv = JOG_SHUTTLE_GET_PRIVATE (wheel);
-        if(priv-&gt;pressed==FALSE) return 0;
+        if (!priv-&gt;pressed &amp;&amp; !priv-&gt;external_control)
+            return 0;
 	return (priv-&gt;value);
 }
 
+void
+jog_shuttle_set_value (GtkWidget *wheel, gfloat value)
+{
+	JogShuttlePrivate *priv;
+	priv = JOG_SHUTTLE_GET_PRIVATE (wheel);
+        priv-&gt;external_control = (value &lt; -0.001 || value &gt; 0.001);
+	priv-&gt;offset = 0;
+
+	gfloat width = wheel-&gt;allocation.width;
+        gfloat offset = value * (width / 2);
+	
+        gfloat was = priv-&gt;pos[3];
+	int i;
+	for (i=0; i&lt;6; i++)
+	{
+		priv-&gt;pos[i] = width / 6 * i + offset;
+	}
+
+        //printf (&quot;value = %f, offset = %f, pos[3] = %f (was %f)\n&quot;, value, offset, priv-&gt;pos[3], was);
+
+	GtkWidget * widget = GTK_WIDGET (wheel);
+	if (!widget-&gt;window)
+            return;
+
+	GdkRegion * region = gdk_drawable_get_clip_region (widget-&gt;window);
+	gdk_window_invalidate_region (widget-&gt;window, region, TRUE);
+	gdk_window_process_updates (widget-&gt;window, TRUE);
+	gdk_region_destroy (region);
+}
+
 GtkWidget *
 jog_shuttle_new (void)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/jogshuttle.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/jogshuttle.h	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/jogshuttle.h	2007-10-14 08:14:21 UTC (rev 3646)
@@ -28,6 +28,7 @@
 
 GtkWidget *jog_shuttle_new (void);
 gfloat jog_shuttle_get_value (GtkWidget *wheel);
+void jog_shuttle_set_value (GtkWidget *wheel, gfloat value);
 
 G_END_DECLS
 

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.c	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.c	2007-10-14 08:14:21 UTC (rev 3646)
@@ -0,0 +1,467 @@
+/*
+* mediactrl.c -- Jog Shuttle device support
+* Copyright (C) 2001-2007 Dan Dennedy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">dan at dennedy.org</A>&gt;
+* Taken from Kino 1.1.1, with permission.
+* Modified by Chris MacGregor &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>&gt; to change the
+* shuttle ring value range to -1.0 to +1.0, among other things.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software Foundation,
+* Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;sys/ioctl.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;sys/time.h&gt;
+#include &lt;asm/types.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;stdint.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+
+#include &lt;linux/input.h&gt;
+#include &quot;mediactrl.h&quot;
+
+
+static char *_shuttle_name = &quot;Shuttle&quot;;
+static char *_jog_name = &quot;Jog&quot;;
+
+/* Dan D. had a funny button numbering scheme that I think will just confuse
+ * people, so I've changed the tables below to what I believe will make the
+ * buttons come out the way people will expect.  I only have a Contour Shuttle
+ * Pro to test with, though.
+ * P.S. I didn't touch the X-Keys table because it was too confusing.
+ *         -- Chris MacGregor &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>&gt;
+ */
+
+/*
+	ShuttlePro keys
+*/
+static struct  media_ctrl_key mc_shuttle_pro_keys[] =
+{
+	{ 0x100, &quot;Button 1&quot;, MEDIA_CTRL_F1 },
+	{ 0x101, &quot;Button 2&quot;, MEDIA_CTRL_F2 },
+	{ 0x102, &quot;Button 3&quot;, MEDIA_CTRL_F3 },
+	{ 0x103, &quot;Button 4&quot;, MEDIA_CTRL_F4 },
+	{ 0x104, &quot;Button 5&quot;, MEDIA_CTRL_B1 },
+	{ 0x105, &quot;Button 6&quot;, MEDIA_CTRL_B2 },
+	{ 0x106, &quot;Button 7&quot;, MEDIA_CTRL_B3 },
+	{ 0x107, &quot;Button 8&quot;, MEDIA_CTRL_B4 },
+	{ 0x108, &quot;Button 9&quot;, MEDIA_CTRL_B5},
+	{ 0x109, &quot;Button 10&quot;, MEDIA_CTRL_B6 },
+	{ 0x10a, &quot;Button 11&quot;, MEDIA_CTRL_B7 },
+	{ 0x10b, &quot;Button 12&quot;, MEDIA_CTRL_B8 },
+	{ 0x10c, &quot;Button 13&quot;, MEDIA_CTRL_B9 },
+	{ 0, NULL, 0 }
+};
+
+
+/*
+	ShuttleXPress keys
+*/
+static struct  media_ctrl_key mc_shuttle_xpress_keys[] =
+{
+	{ 0x104, &quot;Button B4&quot;, MEDIA_CTRL_B1 },
+	{ 0x105, &quot;Button B2&quot;, MEDIA_CTRL_B2 },
+	{ 0x106, &quot;Button B1&quot;, MEDIA_CTRL_B3 },
+	{ 0x107, &quot;Button B3&quot;, MEDIA_CTRL_B4 },
+	{ 0x108, &quot;Button B5&quot;, MEDIA_CTRL_B5 },
+	{ 0, NULL, 0 }
+};
+
+
+/*
+	JLCooper MCS3 Keys
+*/
+static struct  media_ctrl_key mc_jlcooper_mcs3_keys[] =
+{
+	{ 0x107, &quot;F1&quot;, MEDIA_CTRL_F1 },
+	{ 0x101, &quot;F2&quot;, MEDIA_CTRL_F2 },
+	{ 0x105, &quot;F3&quot;, MEDIA_CTRL_F3 },
+	{ 0x102, &quot;F4&quot;, MEDIA_CTRL_F4 },
+	{ 0x103, &quot;F5&quot;, MEDIA_CTRL_F5 },
+	{ 0x104, &quot;F6&quot;, MEDIA_CTRL_F6 },
+	{ 0x10d, &quot;W1&quot;, MEDIA_CTRL_B1 },
+	{ 0x10e, &quot;W2&quot;, MEDIA_CTRL_B2 },
+	{ 0x100, &quot;W3&quot;, MEDIA_CTRL_B3 },
+	{ 0x106, &quot;W4&quot;, MEDIA_CTRL_B4 },
+	{ 0x110, &quot;W5&quot;, MEDIA_CTRL_B5 },
+	{ 0x111, &quot;W6&quot;, MEDIA_CTRL_B6 },
+	{ 0x115, &quot;W7&quot;, MEDIA_CTRL_B7 },
+	{ 0x116, &quot;STICK_LEFT&quot;, MEDIA_CTRL_STICK_LEFT },
+	{ 0x113, &quot;STICK_RIGHT&quot;, MEDIA_CTRL_STICK_RIGHT },
+	{ 0x114, &quot;STICK_UP&quot;, MEDIA_CTRL_STICK_UP },
+	{ 0x112, &quot;STICK_DOWN&quot;, MEDIA_CTRL_STICK_DOWN },
+	{ 0x10f, &quot;Rewind&quot;, MEDIA_CTRL_REWIND },
+	{ 0x108, &quot;Fast Forward&quot;, MEDIA_CTRL_FAST_FORWARD },
+	{ 0x109, &quot;Stop&quot;, MEDIA_CTRL_STOP },
+	{ 0x10a, &quot;Play&quot;, MEDIA_CTRL_PLAY },
+	{ 0x10b, &quot;Record&quot;, MEDIA_CTRL_RECORD },
+	{ 0, NULL, 0 }
+};
+
+
+/*
+	Griffin PowerMate
+*/
+static struct media_ctrl_key mc_powermate_keys[] =
+{
+	{ BTN_0, &quot;Button&quot;, MEDIA_CTRL_B1 },
+	{ 0, NULL, 0 }
+};
+
+
+/*
+	X-Keys Jog/Shuttle
+*/
+static struct  media_ctrl_key mc_x_keys[] =
+{
+	{ 0x102, &quot;Button L1&quot;, MEDIA_CTRL_F1 },
+	{ 0x103, &quot;Button L2&quot;, MEDIA_CTRL_F9 },
+	{ 0x104, &quot;Button L3&quot;, MEDIA_CTRL_B1 },
+	{ 0x105, &quot;Button L4&quot;, MEDIA_CTRL_B3 },
+	{ 0x106, &quot;Button L5&quot;, MEDIA_CTRL_B5 },
+	{ 0x10a, &quot;Button L6&quot;, MEDIA_CTRL_F2 },
+	{ 0x10b, &quot;Button L7&quot;, MEDIA_CTRL_F10 },
+	{ 0x10c, &quot;Button L8&quot;, MEDIA_CTRL_B2 },
+	{ 0x10d, &quot;Button L9&quot;, MEDIA_CTRL_B4 },
+	{ 0x10e, &quot;Button L10&quot;, MEDIA_CTRL_B6 },
+	{ 0x112, &quot;Button C1&quot;, MEDIA_CTRL_F3 },
+	{ 0x11a, &quot;Button C2&quot;, MEDIA_CTRL_F4 },
+	{ 0x122, &quot;Button C3&quot;, MEDIA_CTRL_F5 },
+	{ 0x12a, &quot;Button C4&quot;, MEDIA_CTRL_F6 },
+	{ 0x113, &quot;Button C5&quot;, MEDIA_CTRL_F11 },
+	{ 0x11b, &quot;Button C6&quot;, MEDIA_CTRL_F12 },
+	{ 0x123, &quot;Button C7&quot;, MEDIA_CTRL_F13 },
+	{ 0x12b, &quot;Button C8&quot;, MEDIA_CTRL_F14 },
+	{ 0x132, &quot;Button R1&quot;, MEDIA_CTRL_F7 },
+	{ 0x133, &quot;Button R2&quot;, MEDIA_CTRL_F15 },
+	{ 0x134, &quot;Button R3&quot;, MEDIA_CTRL_B7 },
+	{ 0x135, &quot;Button R4&quot;, MEDIA_CTRL_B9 },
+	{ 0x136, &quot;Button R5&quot;, MEDIA_CTRL_B11 },
+	{ 0x13a, &quot;Button R6&quot;, MEDIA_CTRL_F8 },
+	{ 0x13b, &quot;Button R7&quot;, MEDIA_CTRL_F16 },
+	{ 0x13c, &quot;Button R8&quot;, MEDIA_CTRL_B8 },
+	{ 0x13d, &quot;Button R9&quot;, MEDIA_CTRL_B10 },
+	{ 0x13e, &quot;Button R10&quot;, MEDIA_CTRL_B12 },
+	{ 0, NULL, 0 }
+};
+
+struct  media_ctrl_key *media_ctrl_get_key(struct media_ctrl *ctrl, int code, int *index)
+{
+	int i = 0;
+	struct media_ctrl_key *keys = ctrl-&gt;device-&gt;keys;
+	
+	while ( keys[i].key != 0 ) {
+		if (keys[i].key == code) {
+			if (index != NULL)
+				*index = i;
+			return &amp;keys[i];
+		}
+		i++;
+	}
+	
+	return NULL;
+}
+
+
+void translate_contour_hid_event(struct media_ctrl *ctrl, struct input_event *ev,
+                                 struct media_ctrl_event *me) 
+{
+	
+	int lv, cv;
+	
+	me-&gt;type = MEDIA_CTRL_EVENT_NONE;
+	
+	if (ev-&gt;type == EV_REL) {
+		/* First check the outer dial */
+		if (ev-&gt;code == REL_WHEEL) {
+			
+			cv = (signed int)ev-&gt;value;
+                        // I don't know why the following line is there, but
+                        // it makes the wheel less responsive.  If it's too
+                        // touchy, I think it'd be better to reduce the
+                        // absolute value of cv by 1 instead (so we don't go
+                        // straight from 0 to -2 or +2, which is what happens
+                        // with the line below).
+                        // -- Chris MacGregor &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>&gt;
+			//if (cv == 1 || cv == -1 ) cv = 0;
+                        // Aha, now I understand: the silly Contour ShuttlePro
+                        // (at least, and perhaps its brethren) never returns
+                        // a 0 when the shuttle ring is returned to its home
+                        // position - you can only get -7 to -1 and 1 to 7 out
+                        // of it, so if you DON'T ignore -1 and 1, you will
+                        // always appear to be in motion.  :-(  I don't know
+                        // how they figured it was smart to not return 0 for
+                        // the home position...Oh, well, back to ignoring -1
+                        // and 1.  But I'm going to do it in a way that leaves
+                        // the remaining values proportionate.
+				
+			if ( cv == ctrl-&gt;lastshu ) return;
+			ctrl-&gt;lastshu = cv;
+				
+			//printf(&quot;Shuttle: %d\n&quot;, cv);
+			me-&gt;type  = MEDIA_CTRL_EVENT_SHUTTLE;
+                        if (cv &lt; 0)
+                            cv += 1;
+                        else if (cv &gt; 0)
+                            cv -= 1;
+
+                        me-&gt;fvalue = cv / 6.0;
+                        me-&gt;value = me-&gt;fvalue * 15;
+			me-&gt;name = _shuttle_name;
+			
+		} else if  (ev-&gt;code == REL_DIAL) {
+			
+			if ( ctrl-&gt;lastval == -1 ) ctrl-&gt;lastval = ev-&gt;value;
+			lv = ctrl-&gt;lastval;
+			cv = ev-&gt;value;
+
+			if ( lv == cv ) return;
+				
+			ctrl-&gt;lastval = cv;
+			
+			if (cv &lt; 10 &amp;&amp; lv &gt; 0xF0) cv +=0x100;
+			if (lv &lt; 10 &amp;&amp; cv &gt; 0xF0) lv +=0x100;
+			
+			me-&gt;type  = MEDIA_CTRL_EVENT_JOG;
+			me-&gt;value = cv-lv;
+			me-&gt;name = _jog_name;
+			
+			ctrl-&gt;jogpos += me-&gt;value;
+			//printf(&quot;Jog: %06ld (%d)\n&quot;, ctrl-&gt;jogpos, me-&gt;value);
+     		}
+		return;
+	} else if (ev-&gt;type == EV_KEY) {
+		int index;
+		struct media_ctrl_key *key = media_ctrl_get_key(ctrl, ev-&gt;code, &amp;index);
+		if ( key == NULL ) return;
+		
+		me-&gt;type  = MEDIA_CTRL_EVENT_KEY;
+		me-&gt;code = key-&gt;code;
+		me-&gt;value = ev-&gt;value;
+		me-&gt;name = ( char* )key-&gt;name;
+		me-&gt;index = index;
+		 
+		//printf(&quot;Key: %04x %02x: %s\n&quot;, ev-&gt;code, ev-&gt;value, key-&gt;name);
+		
+	}
+	
+}
+
+void translate_compliant(struct media_ctrl *ctrl, struct input_event *ev, struct media_ctrl_event *me) 
+{
+	me-&gt;type = 0;
+	
+	// printf(&quot;Translate %02x %02x\n&quot;, ev-&gt;type, ev-&gt;code );
+	
+	if (ev-&gt;type == EV_REL) {
+		if  (ev-&gt;code == REL_DIAL) {
+			
+			me-&gt;type  = MEDIA_CTRL_EVENT_JOG;
+			me-&gt;value = (signed int)ev-&gt;value;
+			me-&gt;name = _jog_name;
+			
+			ctrl-&gt;jogpos += me-&gt;value;
+			//printf(&quot;Jog: %06ld (%d)\n&quot;, ctrl-&gt;jogpos, me-&gt;value);
+     	}
+		return;
+	} else if (ev-&gt;type == EV_ABS) {
+		// printf(&quot;ABS\n&quot; );
+		if  ( ev-&gt;code == 0x1c || ev-&gt;code == ABS_THROTTLE ) {
+			//printf(&quot;ABS_MISC\n&quot; );
+			me-&gt;type  = MEDIA_CTRL_EVENT_SHUTTLE;
+			me-&gt;value = (signed int)ev-&gt;value;
+                        me-&gt;fvalue = me-&gt;value / 15.0;
+			me-&gt;name = _shuttle_name;
+			
+			ctrl-&gt;shuttlepos = me-&gt;value;
+			//printf(&quot;Shuttle: %06d (%d)\n&quot;, ctrl-&gt;shuttlepos, me-&gt;value);
+		}
+	} else if (ev-&gt;type == EV_KEY) {
+		int index;
+		struct media_ctrl_key *key = media_ctrl_get_key(ctrl, ev-&gt;code, &amp;index);
+		if ( key == NULL ) return;
+		
+		me-&gt;type  = MEDIA_CTRL_EVENT_KEY;
+		me-&gt;code = key-&gt;code;
+		me-&gt;value = ev-&gt;value;
+		me-&gt;name = ( char* )key-&gt;name;
+		me-&gt;index = index;
+		 
+		//printf(&quot;Key: %04x %02x: %s\n&quot;, ev-&gt;code, ev-&gt;value, key-&gt;name);
+		
+	}
+}
+
+struct media_ctrl_device supported_devices[] = {
+	{ 0x0b33, 0x0030, &quot;Contour ShuttlePRO v2&quot;, mc_shuttle_pro_keys, translate_contour_hid_event },
+	{ 0x0b33, 0x0020, &quot;Contour ShuttleXPress&quot;, mc_shuttle_xpress_keys, translate_contour_hid_event },
+	{ 0x0b33, 0x0010, &quot;Contour ShuttlePro&quot;, mc_shuttle_pro_keys, translate_contour_hid_event },
+	{ 0x0b33, 0x0011, &quot;Contour ShuttlePro&quot;, mc_shuttle_pro_keys, translate_contour_hid_event }, /* Hercules OEM */
+	{ 0x05f3, 0x0240, &quot;Contour ShuttlePro&quot;, mc_shuttle_pro_keys, translate_contour_hid_event },
+	{ 0x0760, 0x0001, &quot;JLCooper MCS3&quot;, mc_jlcooper_mcs3_keys, translate_compliant },
+	{ 0x077d, 0x0410, &quot;Griffin PowerMate&quot;, mc_powermate_keys, translate_compliant },
+	{ 0x05f3, 0x0241, &quot;X-Keys Editor&quot;, mc_x_keys, translate_contour_hid_event },
+	{ 0, 0, 0 }
+};
+
+
+void media_ctrl_translate(struct media_ctrl *ctrl, struct input_event *ev, struct media_ctrl_event *me) 
+{
+	if ( ctrl-&gt;device ) ctrl-&gt;device-&gt;translate(ctrl, ev, me);
+}
+
+
+void media_ctrl_read_event(struct media_ctrl *ctrl, struct media_ctrl_event *me) 
+{
+	ssize_t n;
+	struct input_event ev;
+		
+	// struct media_ctrl_event me;
+	
+	if ( ctrl-&gt;fd &gt; 0 ) {
+		n = read(ctrl-&gt;fd, &amp;ev, sizeof(ev));
+	} else {
+		return;
+	}
+	
+	if (n != sizeof(ev)) {
+		//printf(&quot;JogShuttle::inputCallback: read: (%d) %s\n&quot;, errno, strerror(errno));
+		close(ctrl-&gt;fd);
+		ctrl-&gt;fd = 0;
+		return;
+	}
+	
+	if ( ctrl-&gt;device &amp;&amp; ctrl-&gt;device-&gt;translate)
+		ctrl-&gt;device-&gt;translate(ctrl, &amp;ev, me);
+	else
+		me-&gt;type = 0;
+	
+	if ( me-&gt;type  == MEDIA_CTRL_EVENT_JOG ) {
+		struct timeval timev;
+		gettimeofday(&amp;timev, NULL);
+		unsigned long now = (unsigned long)timev.tv_usec + (1000000*(unsigned long)timev.tv_sec);
+		if ( now &lt; ctrl-&gt;last_jog_time + 40000 ) {
+			//printf(&quot;*** Fast Jog %02d %05d ***\n&quot;, me-&gt;value, now - ctrl-&gt;last_jog_time);
+			ctrl-&gt;jogrel = me-&gt;value;
+			me-&gt;type = MEDIA_CTRL_EVENT_NONE;
+		} else {
+			me-&gt;value += ctrl-&gt;jogrel;
+			ctrl-&gt;jogrel = 0;
+			ctrl-&gt;last_jog_time = now;
+			// printf(&quot;*** Jog %02d ***\n&quot;, me-&gt;value);
+		}
+	}
+	
+	return;
+	
+}
+
+
+int probe_device(struct media_ctrl *mc, const char * devname)
+{
+	short devinfo[4];
+	int i = 0;
+	  
+        /* suck out the name information 
+         * return value is the length of the name, for success 
+         * or -EFAULT for failure
+         */
+        char name[256] = &quot;Unknown&quot;;
+	if (ioctl(mc-&gt;fd, EVIOCGNAME(sizeof(name)), name) &lt; 0) {
+		fprintf(stderr, &quot;%s: &quot;, devname);
+		perror(&quot;EVIOCGNAME&quot;);
+	}
+
+	if ( ioctl(mc-&gt;fd, EVIOCGID, &amp;devinfo) ) {
+		fprintf(stderr, &quot;%s: &quot;, devname);
+		perror(&quot;EVIOCGID&quot;);
+		return 0;
+	}
+	
+	do {
+		if ( supported_devices[i].vendor == devinfo[1] 
+			&amp;&amp; supported_devices[i].product == devinfo[2] ) {
+				
+			mc-&gt;device = &amp;supported_devices[i];
+			printf(&quot;Success on %s: %s: %s\n&quot;,
+                               devname, name, mc-&gt;device-&gt;name);
+			// mc-&gt;fd = fd;
+			// mc-&gt;translate = mc-&gt;device.translate_function;
+			// mc = malloc(sizeof(struct media_ctrl));
+			mc-&gt;jogrel  = 0;
+			mc-&gt;jogpos  = 0;
+			mc-&gt;lastval = -1;
+			mc-&gt;last_jog_time = 0;
+			return 1;
+		} else {
+			//mc-&gt;device = NULL;
+		}
+	
+	} while ( supported_devices[++i].vendor != 0 );
+			
+        printf(&quot;Not interested in %s: %s\n&quot;, devname, name);
+	return 0;
+}
+
+
+void media_ctrl_get_device_list() 
+{
+	// TBD
+}
+
+
+
+void find_first_device(struct media_ctrl *mc) 
+{
+	char buf[256];
+	int fd, i;
+	
+	for ( i = 0; i &lt; 32; i++ ) {
+		sprintf(buf, &quot;/dev/input/event%d&quot;, i); 
+		fd = open( buf, O_RDONLY );
+		if ( fd &lt; 0 ) {
+			if (errno != ENOENT)
+				perror(buf);
+		} else {
+			mc-&gt;fd = fd;
+			mc-&gt;eventno = i;
+			if( probe_device(mc, buf) ) {
+				return;
+			} else {		
+				close(fd);
+				mc-&gt;fd = -1;
+			}
+		}
+	}
+	return;
+}
+
+
+void media_ctrl_close(struct media_ctrl *mc)
+{
+	if (mc-&gt;fd &gt; 0)
+		close( mc-&gt;fd );
+	memset( mc, 0, sizeof( struct media_ctrl ) );
+}
+
+
+void media_ctrl_open(struct media_ctrl *mc) 
+{
+	find_first_device(mc);
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.h	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.h	2007-10-14 08:14:21 UTC (rev 3646)
@@ -0,0 +1,160 @@
+/*
+* mediactrl.c -- Jog Shuttle device support
+* Copyright (C) 2001-2007 Dan Dennedy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">dan at dennedy.org</A>&gt;
+* Taken from Kino 1.1.1, with permission.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software Foundation,
+* Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+#ifndef _MEDIA_CTRL_H
+#define _MEDIA_CTRL_H
+
+// just to make the code more readable
+#define KEY_RELEASE			0x00
+#define KEY_PRESS			0x01
+
+// not used yet
+#define MEDIA_ST_ACTIVE	 		0x02
+#define MEDIA_ST_INACTIVE	 	0x01
+
+// media ctrl event types
+#define MEDIA_CTRL_EVENT_NONE		0x00
+#define MEDIA_CTRL_EVENT_KEY		0x01
+#define MEDIA_CTRL_EVENT_JOG		0x02
+#define MEDIA_CTRL_EVENT_SHUTTLE	0x03
+#define MEDIA_CTRL_EVENT_STICK		0x04
+
+// the disconnect event - not used yet
+#define MEDIA_CTRL_DISCONNECT	 	0x01
+
+#define MEDIA_CTRL_SHIFT	 	0x01
+
+#define MEDIA_CTRL_PLAY	 		0x10
+#define MEDIA_CTRL_PLAY_FWD	 	0x10
+#define MEDIA_CTRL_REVERSE 		0x11
+#define MEDIA_CTRL_PLAY_REV 		0x11
+#define MEDIA_CTRL_STOP 		0x12
+#define MEDIA_CTRL_PAUSE 		0x13
+#define MEDIA_CTRL_NEXT 		0x14
+#define MEDIA_CTRL_PREV 		0x15
+#define MEDIA_CTRL_RECORD 		0x16
+#define MEDIA_CTRL_FAST_FORWARD		0x17
+#define MEDIA_CTRL_REWIND		0x18
+
+#define MEDIA_CTRL_STICK_LEFT		0x20
+#define MEDIA_CTRL_STICK_RIGHT		0x21
+#define MEDIA_CTRL_STICK_UP		0x22
+#define MEDIA_CTRL_STICK_DOWN		0x23
+
+/* function keys, usually at top of device */
+#define MEDIA_CTRL_F1			0x100
+#define MEDIA_CTRL_F2			0x101
+#define MEDIA_CTRL_F3			0x102
+#define MEDIA_CTRL_F4			0x103
+#define MEDIA_CTRL_F5			0x104
+#define MEDIA_CTRL_F6			0x105
+#define MEDIA_CTRL_F7			0x106
+#define MEDIA_CTRL_F8			0x107
+#define MEDIA_CTRL_F9			0x108
+#define MEDIA_CTRL_F10			0x109
+#define MEDIA_CTRL_F11			0x10a
+#define MEDIA_CTRL_F12			0x10b
+#define MEDIA_CTRL_F13			0x10c
+#define MEDIA_CTRL_F14			0x10d
+#define MEDIA_CTRL_F15			0x10e
+#define MEDIA_CTRL_F16			0x10f
+
+#define MEDIA_CTRL_B1			0x110
+#define MEDIA_CTRL_B2			0x111
+#define MEDIA_CTRL_B3			0x112
+#define MEDIA_CTRL_B4			0x113
+#define MEDIA_CTRL_B5			0x114
+#define MEDIA_CTRL_B6			0x115
+#define MEDIA_CTRL_B7			0x116
+#define MEDIA_CTRL_B8			0x117
+#define MEDIA_CTRL_B9			0x118
+#define MEDIA_CTRL_B10			0x119
+#define MEDIA_CTRL_B11			0x11a
+#define MEDIA_CTRL_B12			0x11b
+#define MEDIA_CTRL_B13			0x11c
+#define MEDIA_CTRL_B14			0x11d
+#define MEDIA_CTRL_B15			0x11e
+#define MEDIA_CTRL_B16			0x11f
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+struct media_ctrl_device;
+
+struct media_ctrl_key
+{
+	int key;  // internal keycode - do not use
+	const char *name;
+	int code; // eventcode
+	int action;
+};
+
+struct media_ctrl_event
+{
+	struct timeval time;
+	unsigned short type;
+	unsigned short code;
+	char *name;
+	int value;
+	float fvalue;  // only defined for MEDIA_CTRL_EVENT_SHUTTLE
+	unsigned short index;
+};
+
+struct media_ctrl
+{
+	int fd;
+	int eventno;
+	
+	int status;
+
+	struct media_ctrl_device *device;
+
+	long jogpos;
+	int  shuttlepos;
+	
+	int lastval;
+	int lastshu;
+	
+	int jogrel; // accumulate relative values if events come too fast
+	unsigned long last_jog_time; // last jog event
+
+};
+
+struct media_ctrl_device
+{
+	int vendor;
+	int product;
+	const char *name;
+	struct media_ctrl_key *keys;
+	void (*translate)(struct media_ctrl *ctrl, struct input_event *ev, struct media_ctrl_event *me);
+};
+
+void media_ctrl_open(struct media_ctrl *);
+void media_ctrl_close(struct media_ctrl *);
+void media_ctrl_read_event(struct media_ctrl *, struct media_ctrl_event *);
+
+struct  media_ctrl_key *media_ctrl_get_keys(struct media_ctrl *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/avi_vars.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/avi_vars.h	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/avi_vars.h	2007-10-14 08:14:21 UTC (rev 3646)
@@ -1,11 +1,8 @@
 #ifndef __AVI_VARS
 #define __AVI_VARS
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
+#include &quot;default.h&quot;
 #include &lt;assert.h&gt;
 #include &quot;fourcc.h&quot;
-#include &quot;config.h&quot;
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 //----------------------
 

Added: branches/avidemux_2.4_branch/avidemux/button_mapping
===================================================================
--- branches/avidemux_2.4_branch/avidemux/button_mapping	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/button_mapping	2007-10-14 08:14:21 UTC (rev 3646)
@@ -0,0 +1,177 @@
+# This is a sample button mapping file.  If you copy it to
+# ~/.avidemux/button_mapping, avidemux will read it at startup and use it
+# to map buttons on a jog shuttle device to actions in the avidemux user
+# interface.
+#
+# Each line to map a button should contain a number, at least one space or
+# tab character, and then an action name (see below for list).
+#
+# If you aren't sure what button numbers are produced by your device, set
+# the environment variable SHOW_BUTTONS (e.g., &quot;export SHOW_BUTTONS=1&quot; if
+# you're using the bash shell).  Then, watch the window from which you
+# started avidemux, and press the buttons, and it will tell you the number
+# for each one you press.
+#
+# Action names (which can be used in ~/.avidemux/button_mapping, 
+# though some should not be):
+#
+#     About
+#     ADD_JOB
+#     AllBlackFrames
+#     AppendAvi
+#     AudioCodec
+#     AudioCodecChanged
+#     AudioConfigure
+#     AudioFilters
+#     AudioMap
+#     AudioModeCopy
+#     AudioModeProcess
+#     AudioModeToggle
+#     AudioSourceAC3
+#     AudioSourceAvi
+#     AudioSourceMP3
+#     AudioSourceNone
+#     AudioSourceWAV
+#     AUTO_DVD
+#     AUTO_FLV
+#     AUTO_PSP
+#     AUTO_PSP_H264
+#     AUTO_SVCD
+#     AUTO_VCD
+#     AviInfo
+#     AVS_PROXY
+#     Back25Frames
+#     Back50Frames
+#     Begin
+#     Bitrate
+#     BitRate
+#     BrokenAvi
+#     BUILT_IN
+#     ChangeFPS
+#     CLOSE
+#     Copy
+#     Cut
+#     CutWizard
+#     DecoderOption
+#     Delete
+#     DVB_Ocr
+#     End
+#     Exit
+#     Fast
+#     Forward25Frames
+#     Forward50Frames
+#     GLYPHEDIT
+#     Goto
+#     GotoMarkA
+#     GotoMarkB
+#     GotoTime
+#     HANDLE_JOB
+#     HEX_DUMP
+#     JOG
+#     JumpToFrame
+#     JumpToTime
+#     MarkA
+#     MarkB
+#     MpegIndex
+#     NextBlackFrame
+#     NextFrame
+#     NextKFrame
+#     Ocr
+#     OpenAvi
+#     OuputToggle
+#     Paste
+#     Pipe2Lame
+#     Pipe2Other
+#     PipeLame
+#     PlayAvi
+#     Pref
+#     PrevBlackFrame
+#     PreviewChanged
+#     PreviewToggle
+#     PreviousFrame
+#     PreviousKFrame
+#     RebuildKF
+#     RECENT0
+#     RECENT1
+#     RECENT2
+#     RECENT3
+#     RecentFiles
+#     Requant
+#     ResetSegments
+#     RunScript
+#     SaveAvi
+#     SaveBunchJPG
+#     SaveCurrentWork
+#     SaveDualAudio
+#     SaveDVDPS
+#     SaveImg
+#     SaveJPG
+#     SaveMpeg1vcd
+#     SaveMpeg2dvd
+#     SaveMpeg2svcd
+#     SaveOGM
+#     SavePref
+#     SaveRaw
+#     SaveUnpackedMpeg4
+#     SaveWave
+#     SaveWork
+#     Scale
+#     SecondAudioTrack
+#     SelectDevALSA
+#     SelectDevArts
+#     SelectDevDummy
+#     SelectDevOSS
+#     SelectEncoder
+#     SelectTrack1
+#     SetLogFile
+#     SetMuxParam
+#     SetPostProcessing
+#     StopAvi
+#     TimeShift
+#     V2V
+#     VideoCheck
+#     VideoCodec
+#     VideoCodecChanged
+#     VideoConfigure
+#     VideoModeCopy
+#     VideoModeProcess
+#     VideoModeToggle
+#     VideoParameter
+#     ViewMain
+#     ViewSide
+#     XVCD
+#     ZOOM_1_1
+#     ZOOM_1_2
+#     ZOOM_1_4
+#     ZOOM_2_1
+#     ZOOM_4_1
+
+# To get an up-to-date version of the preceding list, uncomment the
+# following line, and watch the output from avidemux as it starts up:
+#    help
+
+# The following button setup is for a Contour ShuttlePRO (though of course
+# you may want different mappings even if you have the same device):
+
+# first row:
+256 PlayAvi
+257 StopAvi
+258 MarkA
+259 MarkB
+
+# second row:
+272 VideoParameter
+273 SaveAvi
+274 SaveWork
+275 GotoMarkA
+276 GotoMarkB
+
+# left rear:
+277 Back100Frames
+279 Begin
+
+# right rear:
+278 Forward100Frames
+280 End
+
+

Modified: branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp	2007-10-14 08:14:21 UTC (rev 3646)
@@ -168,8 +168,136 @@
 uint8_t GUI_close(void);
 extern void A_jog(void);
 extern void DIA_glyphEdit(void);
+
+struct ActionNameNum
+{
+    const Action num;
+    const char * const name;
+};
+
+// The getActionName() function assumes that the following array is sorted by
+// action number, and further that it can be indexed by action number based on
+// the action number of the first entry.
+
+const ActionNameNum action_names [] =
+{
+#define ACT(_name) { ACT_ ## _name, # _name },
+#include &quot;gui_action.names&quot;
+#undef ACT
+    //   { ACT_INVALID, 0 }
+};
+
+const int ACTION_NAME_COUNT = sizeof (action_names) / sizeof (action_names[0]);
+
+// One might think to use a map here, instead of a vector (and in fact I did),
+// but Scott Meyers in _Effective STL_ advises (in item 23) that it is more
+// efficient to use a sorted vector when we are doing a bunch of insertions
+// followed by mostly (in our case exclusively) lookups.
+
+#include &lt;vector&gt;
+using std::vector;
+#include &lt;utility&gt;
+using std::pair;
+using std::make_pair;
+#include &lt;iterator&gt;
+using std::back_inserter;
+#include &lt;algorithm&gt;
+using std::transform;
+using std::sort;
+using std::equal_range;
+
+typedef pair &lt;const char *, Action&gt; ActionNamePair;
+typedef vector &lt;ActionNamePair&gt; ActionNameVec;
+typedef ActionNameVec::iterator ActionNameIter;
+
+class ActionNameCompare
+{
+public:
+    bool operator () (const ActionNamePair &amp; lhs, // for sorting
+                      const ActionNamePair &amp; rhs) const
+    {
+        return doLess (lhs.first, rhs.first);
+    }
+
+    bool operator () (const ActionNamePair &amp; lhs, // for lookups 1
+                      const ActionNamePair::first_type &amp; rhs) const
+    {
+        return doLess (lhs.first, rhs);
+    }
+
+    bool operator () (const ActionNamePair::first_type &amp; lhs, // for lookups 2
+                      const ActionNamePair &amp; rhs) const
+    {
+        return doLess (lhs, rhs.first);
+    }
+
+private:
+
+    bool doLess (const ActionNamePair::first_type &amp; lhs,
+                 const ActionNamePair::first_type &amp; rhs) const
+    {
+        return (strcasecmp (lhs, rhs) &lt; 0);
+    }
+};
+
+class MakeActionNamePair
+{
+public:
+    ActionNamePair operator () (const ActionNameNum &amp; ann)
+    {
+        return make_pair (ann.name, ann.num);
+    }
+};
+
+static ActionNameVec action_name_vec;
+
+void initActionNameVec (void)
+{
+    action_name_vec.reserve (ACTION_NAME_COUNT);
+    transform (action_names, action_names + ACTION_NAME_COUNT,
+               back_inserter (action_name_vec), MakeActionNamePair());
+    sort (action_name_vec.begin(), action_name_vec.end(),
+          ActionNameCompare());
+}
+
+Action lookupActionByName (const char * name)
+{
+    if (action_name_vec.empty())
+        initActionNameVec();
+
+    pair &lt;ActionNameIter, ActionNameIter&gt; range
+        = equal_range (action_name_vec.begin(),
+                       action_name_vec.end(), name,
+                       ActionNameCompare());
+    if (range.first == range.second)
+        return ACT_INVALID;
+    else
+        return range.first-&gt;second;
+}
+
+const char * getActionName (Action act)
+{
+    uint32_t index = act - action_names [0].num;
+    return (action_names [index].name);
+}
+
+void dumpActionNames (const char * filename)
+{
+    if (action_name_vec.empty())
+        initActionNameVec();
+
+    printf (&quot;# Action names (which can be used in %s, &quot;
+            &quot;though some should not be):\n&quot;, filename);
+    ActionNameIter it = action_name_vec.begin();
+    while (it != action_name_vec.end())
+    {
+        printf (&quot;#     %s\n&quot;, it-&gt;first);
+        ++it;
+    }
+}
+
 //___________________________________________
-// serialization of user event throught gui
+// serialization of user event through gui
 //
 // Independant from the toolkit used
 // QT or other port should be easy

Modified: branches/avidemux_2.4_branch/avidemux/gtkgui.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gtkgui.h	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/gtkgui.h	2007-10-14 08:14:21 UTC (rev 3646)
@@ -25,8 +25,8 @@
 
 
 
-void GUI_NextFrame( void );
-void GUI_PrevFrame( void );
+void GUI_NextFrame( uint32_t frameCount = 1 );
+void GUI_PrevFrame( uint32_t frameCount = 1 );
 void GUI_NextKeyFrame( void ) ;
 void GUI_NextPrevBlackFrame( int ) ;
 void GUI_PreviousKeyFrame( void );

Modified: branches/avidemux_2.4_branch/avidemux/gui_action.hxx
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gui_action.hxx	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/gui_action.hxx	2007-10-14 08:14:21 UTC (rev 3646)
@@ -18,188 +18,22 @@
 #ifndef __GUI_ACTION
 #define __GUI_ACTION
 #define ADM_MAC_CUSTOM_SCRIPT 10
-typedef enum
+enum Action
 {
-  
-  ACT_OpenAvi = 1,
-  ACT_AppendAvi,
-  ACT_BrokenAvi ,
-  ACT_AviInfo,
-  ACT_CLOSE,
-  ACT_Exit,
-  ACT_PlayAvi,
-  ACT_StopAvi,
-  ACT_SaveImg,
-  ACT_SaveOGM,
-  ACT_SaveJPG,
-  ACT_SaveBunchJPG,
-  ACT_SaveDVDPS,
-  ACT_SaveUnpackedMpeg4,
-  ACT_RecentFiles,
+    ACT_INVALID = 0,
 
-  ACT_SaveDualAudio,
-  ACT_SaveAvi,
-  ACT_SaveWave,
-  ACT_Pipe2Lame,
-  ACT_PipeLame,
-  ACT_Pipe2Other,
+#define ACT(_name) ACT_ ## _name,
+#include &quot;gui_action.names&quot;
+#undef ACT
 
-  
- ACT_SaveMpeg1vcd,
- ACT_SaveMpeg2svcd, 
- ACT_SaveMpeg2dvd,
- 
- ACT_SaveRaw,
- 
- ACT_XVCD,
-
-  
-  ACT_SetPostProcessing,
-  ACT_NextFrame,
-  ACT_Back100Frames,
-  ACT_Back50Frames,
-  ACT_Back25Frames,
-  ACT_Forward100Frames,
-  ACT_Forward50Frames,
-  ACT_Forward25Frames,
-  ACT_NextKFrame,
-  ACT_PreviousKFrame,
-  ACT_PreviousFrame,
-  ACT_PrevBlackFrame,
-  ACT_NextBlackFrame,
-  ACT_AllBlackFrames,
-   
-  ACT_Scale,
-  
-  ACT_Goto,
-  ACT_GotoTime,
-  
-
-  ACT_Begin,
-  ACT_End,
-  
-  ACT_AudioSourceAvi,
-  ACT_AudioSourceMP3,
-  ACT_AudioSourceWAV,
-  ACT_AudioSourceAC3,
-  ACT_AudioSourceNone,
-
-  ACT_MarkA,
-  ACT_MarkB,
-  ACT_GotoMarkA,
-  ACT_GotoMarkB,
-
-
-
- 
-  ACT_AudioModeProcess,
-  ACT_AudioModeCopy,
-  ACT_AudioModeToggle,
-  ACT_AudioFilters,
-
-  ACT_AudioMap      ,
-  
-   
-   
-ACT_VideoModeCopy,
-ACT_VideoModeProcess,
-ACT_VideoParameter,
-ACT_VideoModeToggle,
-
-ACT_Copy,
-ACT_Cut,
-ACT_Paste,
-ACT_Delete                           ,
-ACT_PreviewToggle    ,
-
-ACT_RebuildKF  ,
-ACT_BitRate,
-ACT_ChangeFPS  ,
-ACT_SetMuxParam   ,
-ACT_DecoderOption   ,
-
-ACT_SelectEncoder,
-ACT_Fast,
-
-ACT_SecondAudioTrack,
-
-ACT_SelectDevOSS,
-ACT_SelectDevDummy,
-ACT_SelectDevArts,
-ACT_SelectDevALSA,
-
-ACT_CutWizard,
-
-ACT_MpegIndex,
-ACT_VideoCheck,
-
-
-ACT_AudioConfigure,
-
-ACT_OuputToggle,
-
-ACT_VideoConfigure,
-
-ACT_SaveWork,
-ACT_SaveCurrentWork,
-ACT_ResetSegments,
-
-ACT_SetLogFile,
-ACT_SavePref,
-
-ACT_VideoCodec,
-ACT_AudioCodec,
-ACT_About,
-
-ACT_Pref,
-
-ACT_Requant,
-ACT_JumpToFrame,
-ACT_JumpToTime,
-ACT_RunScript,
-ACT_AudioCodecChanged,
-ACT_VideoCodecChanged,
-ACT_PreviewChanged,
-ACT_Bitrate,
-ACT_Ocr,
-ACT_DVB_Ocr,
-ACT_SelectTrack1,
-ACT_ViewMain,
-ACT_ViewSide,
-ACT_TimeShift,
-ACT_RECENT0,
-ACT_RECENT1,
-ACT_RECENT2,
-ACT_RECENT3,
-
-ACT_AUTO_VCD,
-ACT_AUTO_SVCD,
-ACT_AUTO_DVD,
-ACT_AUTO_PSP,
-ACT_AUTO_PSP_H264,
-ACT_AUTO_IPOD,
-ACT_AUTO_FLV,
-
-ACT_ADD_JOB,
-ACT_HANDLE_JOB,
-ACT_V2V,
-
-ACT_ZOOM_1_4,
-ACT_ZOOM_1_2,
-ACT_ZOOM_1_1,
-ACT_ZOOM_2_1,
-ACT_ZOOM_4_1,
-ACT_BUILT_IN,
-ACT_HEX_DUMP,
-ACT_AVS_PROXY,
-ACT_JOG,
-ACT_GLYPHEDIT,
 ACT_CUSTOM_BASE,
 ACT_CUSTOM_END=ACT_CUSTOM_BASE+ADM_MAC_CUSTOM_SCRIPT,
 ACT_DUMMY
+};
 
+void HandleAction (Action action);
+Action lookupActionByName (const char * name);
+const char * getActionName (Action act);
+void dumpActionNames (const char * filename);
 
-}
-Action;
-
 #endif

Added: branches/avidemux_2.4_branch/avidemux/gui_action.names
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gui_action.names	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/gui_action.names	2007-10-14 08:14:21 UTC (rev 3646)
@@ -0,0 +1,164 @@
+ACT(OpenAvi)
+ACT(AppendAvi)
+ACT(BrokenAvi)
+ACT(AviInfo)
+ACT(CLOSE)
+ACT(Exit)
+ACT(PlayAvi)
+ACT(StopAvi)
+ACT(SaveImg)
+ACT(SaveOGM)
+ACT(SaveJPG)
+ACT(SaveBunchJPG)
+ACT(SaveDVDPS)
+ACT(SaveUnpackedMpeg4)
+ACT(RecentFiles)
+
+ACT(SaveDualAudio)
+ACT(SaveAvi)
+ACT(SaveWave)
+ACT(Pipe2Lame)
+ACT(PipeLame)
+ACT(Pipe2Other)
+
+ACT(SaveMpeg1vcd)
+ACT(SaveMpeg2svcd)
+ACT(SaveMpeg2dvd)
+
+ACT(SaveRaw)
+
+ACT(XVCD)
+
+ACT(SetPostProcessing)
+ACT(NextFrame)
+ACT(Back100Frames)
+ACT(Back50Frames)
+ACT(Back25Frames)
+ACT(Forward100Frames)
+ACT(Forward50Frames)
+ACT(Forward25Frames)
+ACT(NextKFrame)
+ACT(PreviousKFrame)
+ACT(PreviousFrame)
+ACT(PrevBlackFrame)
+ACT(NextBlackFrame)
+ACT(AllBlackFrames)
+
+ACT(Scale)
+
+ACT(Goto)
+ACT(GotoTime)
+
+ACT(Begin)
+ACT(End)
+
+ACT(AudioSourceAvi)
+ACT(AudioSourceMP3)
+ACT(AudioSourceWAV)
+ACT(AudioSourceAC3)
+ACT(AudioSourceNone)
+
+ACT(MarkA)
+ACT(MarkB)
+ACT(GotoMarkA)
+ACT(GotoMarkB)
+
+ACT(AudioModeProcess)
+ACT(AudioModeCopy)
+ACT(AudioModeToggle)
+ACT(AudioFilters)
+
+ACT(AudioMap)
+
+ACT(VideoModeCopy)
+ACT(VideoModeProcess)
+ACT(VideoParameter)
+ACT(VideoModeToggle)
+
+ACT(Copy)
+ACT(Cut)
+ACT(Paste)
+ACT(Delete)
+ACT(PreviewToggle)
+
+ACT(RebuildKF)
+ACT(BitRate)
+ACT(ChangeFPS)
+ACT(SetMuxParam)
+ACT(DecoderOption)
+
+ACT(SelectEncoder)
+ACT(Fast)
+
+ACT(SecondAudioTrack)
+
+ACT(SelectDevOSS)
+ACT(SelectDevDummy)
+ACT(SelectDevArts)
+ACT(SelectDevALSA)
+
+ACT(CutWizard)
+
+ACT(MpegIndex)
+ACT(VideoCheck)
+
+ACT(AudioConfigure)
+
+ACT(OutputToggle)
+
+ACT(VideoConfigure)
+
+ACT(SaveWork)
+ACT(SaveCurrentWork)
+ACT(ResetSegments)
+
+ACT(SetLogFile)
+ACT(SavePref)
+
+ACT(VideoCodec)
+ACT(AudioCodec)
+ACT(About)
+
+ACT(Pref)
+
+ACT(Requant)
+ACT(JumpToFrame)
+ACT(JumpToTime)
+ACT(RunScript)
+ACT(AudioCodecChanged)
+ACT(VideoCodecChanged)
+ACT(PreviewChanged)
+ACT(Bitrate)
+ACT(Ocr)
+ACT(DVB_Ocr)
+ACT(SelectTrack1)
+ACT(ViewMain)
+ACT(ViewSide)
+ACT(TimeShift)
+ACT(RECENT0)
+ACT(RECENT1)
+ACT(RECENT2)
+ACT(RECENT3)
+
+ACT(AUTO_VCD)
+ACT(AUTO_SVCD)
+ACT(AUTO_DVD)
+ACT(AUTO_PSP)
+ACT(AUTO_PSP_H264)
+ACT(AUTO_IPOD)
+ACT(AUTO_FLV)
+
+ACT(ADD_JOB)
+ACT(HANDLE_JOB)
+ACT(V2V)
+
+ACT(ZOOM_1_4)
+ACT(ZOOM_1_2)
+ACT(ZOOM_1_1)
+ACT(ZOOM_2_1)
+ACT(ZOOM_4_1)
+ACT(BUILT_IN)
+ACT(HEX_DUMP)
+ACT(AVS_PROXY)
+ACT(JOG)
+ACT(GLYPHEDIT)

Modified: branches/avidemux_2.4_branch/avidemux/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gui_navigate.cpp	2007-10-14 08:01:30 UTC (rev 3645)
+++ branches/avidemux_2.4_branch/avidemux/gui_navigate.cpp	2007-10-14 08:14:21 UTC (rev 3646)
@@ -18,14 +18,11 @@
  *                                                                         *
  ***************************************************************************/
 
-#include &quot;config.h&quot;
+//#include &quot;default.h&quot; // avi_vars.h includes this
+#include &quot;avi_vars.h&quot;
 
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
 #include &lt;math.h&gt;
 
-#include &quot;fourcc.h&quot;
-#include &quot;avi_vars.h&quot;
 #include &quot;ADM_toolkit/filesel.h&quot;
 
 #include &quot;ADM_assert.h&quot;
@@ -36,7 +33,6 @@
 #include &quot;ADM_audiofilter/audioprocess.hxx&quot;
 #include &quot;gui_action.hxx&quot;
 #include &quot;gtkgui.h&quot;
-#include &quot;gui_action.hxx&quot;
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 //#include &quot;ADM_toolkit/toolkit_gtk.h&quot;
 #include &quot;GUI_render.h&quot;
@@ -59,25 +55,26 @@
 
 
 }
-void GUI_NextFrame(void)
+void GUI_NextFrame(uint32_t frameCount)
 {
 //    uint8_t *ptr;
 uint32_t flags;
     if (playing)
 	return;
 
-    if( avifileinfo &amp;&amp; curframe + 1 == avifileinfo-&gt;nb_frames )
+    if( avifileinfo &amp;&amp; curframe + frameCount &gt;= avifileinfo-&gt;nb_frames )
 	return;
 
     if (avifileinfo)
       {
-        if( !GUI_getFrame(curframe + 1,&amp;flags))
+        uint32_t newframe = curframe + frameCount;
+        if( !GUI_getFrame(newframe,&amp;flags))
         	{
                   GUI_Error_HIG(QT_TR_NOOP(&quot;Decompressing error&quot;),QT_TR_NOOP( &quot;Cannot decode next frame.&quot;));
            	}
            else
             {
-                  curframe++;
+                  curframe = newframe;
                   admPreview::update( curframe) ;
                   update_status_bar();
   
@@ -444,14 +441,14 @@
     \fn GUI_PrevFrame
     \brief Go to current frame -1
 */
-void        GUI_PrevFrame(void )
+void        GUI_PrevFrame(uint32_t frameCount)
 {
-      if (curframe)
+      if (int (curframe) - int (frameCount) &gt;= 0)
         {
           
-          DIA_StartBusy ();
-          GUI_GoToFrame (curframe - 1);
-          DIA_StopBusy ();
+          // DIA_StartBusy ();
+          GUI_GoToFrame (curframe - frameCount);
+          // DIA_StopBusy ();
         }
 }
 /**
@@ -515,4 +512,3 @@
   jog--;
 }
 //EOF
-        


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000916.html">[Avidemux-svn-commit] r3645 - branches/avidemux_2.4_branch/po
</A></li>
	<LI>Next message: <A HREF="000918.html">[Avidemux-svn-commit] r3647 - in branches/avidemux_2.4_branch: .	debian
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#917">[ date ]</a>
              <a href="thread.html#917">[ thread ]</a>
              <a href="subject.html#917">[ subject ]</a>
              <a href="author.html#917">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
