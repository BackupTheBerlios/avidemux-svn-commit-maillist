<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4740 - in	branches/avidemux_2.5_branch_gruntster/avidemux: . ADM_script
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4740%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%20.%20ADM_script&In-Reply-To=%3C200904201559.n3KFx3gM008167%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001967.html">
   <LINK REL="Next"  HREF="001969.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4740 - in	branches/avidemux_2.5_branch_gruntster/avidemux: . ADM_script</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4740%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%20.%20ADM_script&In-Reply-To=%3C200904201559.n3KFx3gM008167%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4740 - in	branches/avidemux_2.5_branch_gruntster/avidemux: . ADM_script">gruntster at mail.berlios.de
       </A><BR>
    <I>Mon Apr 20 17:59:03 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001967.html">[Avidemux-svn-commit] r4739 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_coreAudio/include ADM_userInterfaces/ADM_commonUI
</A></li>
        <LI>Next message: <A HREF="001969.html">[Avidemux-svn-commit] r4741 - in	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_script	scripts/auto
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1968">[ date ]</a>
              <a href="thread.html#1968">[ thread ]</a>
              <a href="subject.html#1968">[ subject ]</a>
              <a href="author.html#1968">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2009-04-20 17:58:54 +0200 (Mon, 20 Apr 2009)
New Revision: 4740

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
Log:
[script] add AudioTrackInfo class and sourceTrackInfo/targetTrackInfo properties to Audio class

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.cpp	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.cpp	2009-04-20 15:58:54 UTC (rev 4740)
@@ -0,0 +1,123 @@
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_JSAudioTrackInfo.h&quot;
+
+extern const char *getStrFromAudioCodec(uint32_t codec);
+
+JSPropertySpec ADM_JSAudioTrackInfo::properties[] = 
+{
+	{ &quot;codec&quot;, codecProperty, JSPROP_ENUMERATE },
+	{ &quot;bitrate&quot;, bitrateProperty, JSPROP_ENUMERATE },
+	{ &quot;channelCount&quot;, channelCountProperty, JSPROP_ENUMERATE },
+	{ &quot;frequency&quot;, frequencyProperty, JSPROP_ENUMERATE },
+	{ &quot;sourceIndex&quot;, sourceIndexProperty, JSPROP_ENUMERATE },
+	{ &quot;targetIndex&quot;, targetIndexProperty, JSPROP_ENUMERATE },
+	{ 0 }
+};
+
+JSClass ADM_JSAudioTrackInfo::m_audioTrackInfo = 
+{
+	&quot;AudioTrackInfo&quot;, JSCLASS_HAS_PRIVATE,
+	JS_PropertyStub, JS_PropertyStub,
+	ADM_JSAudioTrackInfo::JSGetProperty, JS_PropertyStub,
+	JS_EnumerateStub, JS_ResolveStub, 
+	JS_ConvertStub, ADM_JSAudioTrackInfo::JSDestructor
+};
+
+ADM_JSAudioTrackInfo::ADM_JSAudioTrackInfo(int sourceIndex, uint32_t encoding, int bitrate, int channelCount, int frequency)
+{
+	this-&gt;sourceIndex = sourceIndex;
+	this-&gt;targetIndex = -1;
+	this-&gt;bitrate = bitrate;
+	this-&gt;channelCount = channelCount;
+	this-&gt;frequency = frequency;
+	this-&gt;encoding = encoding;
+}
+
+ADM_JSAudioTrackInfo::ADM_JSAudioTrackInfo(int sourceIndex, int targetIndex, uint32_t encoding, int bitrate, int channelCount, int frequency)
+{
+	this-&gt;sourceIndex = sourceIndex;
+	this-&gt;targetIndex = targetIndex;
+	this-&gt;bitrate = bitrate;
+	this-&gt;channelCount = channelCount;
+	this-&gt;frequency = frequency;
+	this-&gt;encoding = encoding;
+}
+
+ADM_JSAudioTrackInfo::~ADM_JSAudioTrackInfo(void)
+{
+
+}
+
+JSObject *ADM_JSAudioTrackInfo::JSInit(JSContext *cx, JSObject *obj, JSObject *proto, int sourceIndex, audioInfo* info)
+{
+	JSObject *newObj = JS_InitClass(cx, obj, proto, &amp;m_audioTrackInfo, NULL,
+		0, ADM_JSAudioTrackInfo::properties, NULL, NULL, NULL);
+	ADM_JSAudioTrackInfo *p = new ADM_JSAudioTrackInfo(
+		sourceIndex, info-&gt;encoding, info-&gt;bitrate, info-&gt;channels, info-&gt;frequency);
+
+	JS_SetPrivate(cx, newObj, p);
+
+	return newObj;
+}
+
+JSObject *ADM_JSAudioTrackInfo::JSInit(JSContext *cx, JSObject *obj, JSObject *proto, int sourceIndex, int targetIndex, WAVHeader* header)
+{
+	JSObject *newObj = JS_InitClass(
+		cx, obj, proto, &amp;m_audioTrackInfo, NULL, 0, ADM_JSAudioTrackInfo::properties, NULL, NULL, NULL);
+	ADM_JSAudioTrackInfo *p = new ADM_JSAudioTrackInfo(
+		sourceIndex, targetIndex, header-&gt;encoding, (header-&gt;byterate * 8) / 1000, 
+		header-&gt;channels, header-&gt;frequency);
+
+	JS_SetPrivate(cx, newObj, p);
+
+	return newObj;
+}
+
+void ADM_JSAudioTrackInfo::JSDestructor(JSContext *cx, JSObject *obj)
+{
+
+}
+
+JSBool ADM_JSAudioTrackInfo::JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+	ADM_JSAudioTrackInfo *p = (ADM_JSAudioTrackInfo *)JS_GetPrivate(cx, obj);
+
+	if (JSVAL_IS_INT(id))
+	{
+		switch(JSVAL_TO_INT(id))
+		{
+			case sourceIndexProperty:
+			{
+				*vp = INT_TO_JSVAL(p-&gt;sourceIndex);
+				break;
+			}
+			case targetIndexProperty:
+			{
+				*vp = INT_TO_JSVAL(p-&gt;targetIndex);
+				break;
+			}
+			case codecProperty:
+			{
+				*vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, getStrFromAudioCodec(p-&gt;encoding)));
+				break;
+			}
+			case bitrateProperty:
+			{
+				*vp = INT_TO_JSVAL(p-&gt;bitrate);
+				break;
+			}
+			case channelCountProperty:
+			{
+				*vp = INT_TO_JSVAL(p-&gt;channelCount);
+				break;
+			}
+			case frequencyProperty:
+			{
+				*vp = INT_TO_JSVAL(p-&gt;frequency);
+				break;
+			}
+		}
+	}
+
+	return JS_TRUE;
+}

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h	2009-04-20 15:58:54 UTC (rev 4740)
@@ -0,0 +1,43 @@
+#ifndef _ADM_JSAUDIOTRACKINFO_H
+#define _ADM_JSAUDIOTRACKINFO_H
+
+#include &quot;ADM_libraries/ADM_smjs/jsapi.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+
+class ADM_JSAudioTrackInfo
+{
+public:
+	virtual ~ADM_JSAudioTrackInfo(void);
+	static JSObject *JSInit(JSContext *cx, JSObject *obj, JSObject *proto, int sourceIndex, audioInfo* info);
+	static JSObject *JSInit(JSContext *cx, JSObject *obj, JSObject *proto, int sourceIndex, int targetIndex, WAVHeader* header);
+
+	enum
+	{
+		codecProperty,
+		bitrateProperty,
+		channelCountProperty,
+		frequencyProperty,
+		sourceIndexProperty,
+		targetIndexProperty
+	};
+
+protected:
+	ADM_JSAudioTrackInfo(int sourceIndex, uint32_t encoding, int bitrate, int channelCount, int frequency);
+	ADM_JSAudioTrackInfo(int sourceIndex, int targetIndex, uint32_t encoding, int bitrate, int channelCount, int frequency);
+
+private:
+	int bitrate;
+	int channelCount;
+	int frequency;
+	int sourceIndex, targetIndex;
+	uint32_t encoding;
+
+	static JSBool JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+	static void JSDestructor(JSContext *cx, JSObject *obj);
+
+	static JSPropertySpec properties[];
+	static JSClass m_audioTrackInfo;
+};
+
+#endif
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-04-20 15:58:54 UTC (rev 4740)
@@ -1,503 +1,490 @@
-// C++ Interface: Spider Monkey interface
-//
-// Description: 
-//
-//
-// Author: Anish Mistry
-//      Some modification by mean
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#include &quot;ADM_default.h&quot;
-#include &quot;config.h&quot;
-#include &quot;ADM_JSGlobal.h&quot;
-#include &quot;ADM_JSAvidemuxAudio.h&quot;
-
-#include &quot;../ADM_userInterfaces/ADM_commonUI/GUI_ui.h&quot;
-#include &quot;ADM_audiofilter/audioeng_buildfilters.h&quot;
-#include &quot;avi_vars.h&quot;
-#include &quot;gui_action.hxx&quot;
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-
-extern int A_audioSave(char *name);
-extern int A_loadAC3 (char *name);
-extern int A_loadMP3 (char *name);
-extern int A_loadWave (char *name);
-extern void HandleAction(Action act);
-extern uint8_t A_setSecondAudioTrack(const AudioSource nw,char *name);
-
-JSPropertySpec ADM_JSAvidemuxAudio::properties[] = {
-        { &quot;process&quot;, audioprocess_prop, JSPROP_ENUMERATE },        // process audio when saving
-        { &quot;resample&quot;, resample_prop, JSPROP_ENUMERATE },	// resample
-        { &quot;delay&quot;, delay_prop, JSPROP_ENUMERATE },	// set audio delay
-        { &quot;film2Pal&quot;, film2pal_prop, JSPROP_ENUMERATE },	// convert film to pal
-        { &quot;pal2Film&quot;, pal2film_prop, JSPROP_ENUMERATE },	// convert pal to film
-        { &quot;normalizeMode&quot;, normalizemode_prop, JSPROP_ENUMERATE },	//
-        { &quot;drc&quot;, drc_prop, JSPROP_ENUMERATE },	//
-        { &quot;normalizeValue&quot;, normalizevalue_prop, JSPROP_ENUMERATE },	//
-		{ &quot;mixer&quot;, mixerProperty, JSPROP_ENUMERATE },	//
-        { 0 }
-};
-
-JSFunctionSpec ADM_JSAvidemuxAudio::methods[] = {
-        { &quot;scanVbr&quot;, ScanVBR, 0, 0, 0 },	// scan variable bit rate audio
-        { &quot;save&quot;, Save, 1, 0, 0 },	// save audio stream
-        { &quot;load&quot;, Load, 2, 0, 0 },	// load audio stream
-        { &quot;reset&quot;, Reset, 0, 0, 0 },	// reset audio stream
-        { &quot;codec&quot;, Codec, 4, 0, 0 },	// set output codec
-        { &quot;getTrackCount&quot;, getNbTracks, 0, 0, 0 },    // set output codec
-        { &quot;setTrack&quot;, setTrack, 1, 0, 0 },    // set output codec
-        { &quot;secondAudioTrack&quot;, secondAudioTrack, 2, 0, 0 },    // set audio track
-        { &quot;getChannelCount&quot;, getNbChannels, 1, 0, 0 },
-        { &quot;getBitrate&quot;, getBitrate, 1, 0, 0 },
-        { 0 }
-};
-
-JSClass ADM_JSAvidemuxAudio::m_classAvidemuxAudio = 
-{
-        &quot;AvidemuxAudio&quot;, JSCLASS_HAS_PRIVATE,
-        JS_PropertyStub, JS_PropertyStub,
-        ADM_JSAvidemuxAudio::JSGetProperty, ADM_JSAvidemuxAudio::JSSetProperty,
-        JS_EnumerateStub, JS_ResolveStub, 
-        JS_ConvertStub, ADM_JSAvidemuxAudio::JSDestructor
-};
-
-ADM_JSAvidemuxAudio::~ADM_JSAvidemuxAudio(void)
-{
-        if(m_pObject != NULL)
-                delete m_pObject;
-        m_pObject = NULL;
-}
-
-void ADM_JSAvidemuxAudio::setObject(ADM_AvidemuxAudio *pObject)
-{
-        m_pObject = pObject; 
-}
-        
-ADM_AvidemuxAudio *ADM_JSAvidemuxAudio::getObject()
-{
-        return m_pObject; 
-}
-
-JSObject *ADM_JSAvidemuxAudio::JSInit(JSContext *cx, JSObject *obj, JSObject *proto)
-{
-	JSObject *newObj = JS_InitClass(cx, obj, proto, &amp;m_classAvidemuxAudio, NULL, 0,
-		ADM_JSAvidemuxAudio::properties, ADM_JSAvidemuxAudio::methods, NULL, NULL);
-	ADM_JSAvidemuxAudio *p = new ADM_JSAvidemuxAudio();
-
-	p-&gt;setObject(new ADM_AvidemuxAudio());
-	JS_SetPrivate(cx, newObj, p);
-
-	return newObj;
-}
-
-void ADM_JSAvidemuxAudio::JSDestructor(JSContext *cx, JSObject *obj)
-{
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        if(p != NULL)
-                delete p;
-        p = NULL;
-}
-
-JSBool ADM_JSAvidemuxAudio::JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
-{
-        if (JSVAL_IS_INT(id)) 
-        {
-                ADM_JSAvidemuxAudio *priv = (ADM_JSAvidemuxAudio *) JS_GetPrivate(cx, obj);
-                switch(JSVAL_TO_INT(id))
-                {
-                        case audioprocess_prop:
-                                *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_bAudioProcess);
-                                break;
-                        case resample_prop:
-                                *vp = INT_TO_JSVAL(priv-&gt;getObject()-&gt;m_nResample);
-                                break;
-                        case delay_prop:
-                                *vp = INT_TO_JSVAL(priv-&gt;getObject()-&gt;m_nDelay);
-                                break;
-                        case film2pal_prop:
-                                *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_bFilm2PAL);
-                                break;
-                        case pal2film_prop:
-                                *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_bPAL2Film);
-                                break;
-                        case normalizemode_prop:
-                              *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_nNormalizeMode);
-                              break;
-                        case normalizevalue_prop:
-                          *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_nNormalizeValue);
-                          break;
-                        case drc_prop:
-                            *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_bDRC);
-                            break;
-						case mixerProperty:
-							*vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, getCurrentMixerString()));
-							break;
-                }
-        }
-        return JS_TRUE;
-}
-
-JSBool ADM_JSAvidemuxAudio::JSSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
-{
-        if (JSVAL_IS_INT(id)) 
-        {
-                
-                ADM_JSAvidemuxAudio *priv = (ADM_JSAvidemuxAudio *) JS_GetPrivate(cx, obj);
-                switch(JSVAL_TO_INT(id))
-                {
-                        case audioprocess_prop:
-                        {
-                                if(JSVAL_IS_BOOLEAN(*vp) == false)
-                                        break;
-                                priv-&gt;getObject()-&gt;m_bNormalize = JSVAL_TO_BOOLEAN(*vp);
-                                enterLock();
-                                UI_setAProcessToggleStatus(priv-&gt;getObject()-&gt;m_bAudioProcess);
-                                leaveLock();
-                                break;
-                        }
-                        case drc_prop:
-                        {
-                                if(JSVAL_IS_BOOLEAN(*vp) == false)
-                                        break;
-                                priv-&gt;getObject()-&gt;m_bDRC = JSVAL_TO_BOOLEAN(*vp);
-                                enterLock();
-                                audioFilterDrc(priv-&gt;getObject()-&gt;m_bDRC);
-                                leaveLock();
-                                break;
-                        }
-                        case resample_prop:
-                        {
-                                if(JSVAL_IS_INT(*vp) == false)
-                                        break;
-                                priv-&gt;getObject()-&gt;m_nResample = JSVAL_TO_INT(*vp);
-                                enterLock();
-                                audioFilterResample(priv-&gt;getObject()-&gt;m_nResample);
-                                leaveLock();
-                                break;
-                        }
-                        case delay_prop:
-                        {
-                                if(JSVAL_IS_INT(*vp) == false)
-                                        break;
-                                priv-&gt;getObject()-&gt;m_nDelay = JSVAL_TO_INT(*vp);
-                                //audioFilterDelay(priv-&gt;getObject()-&gt;m_nDelay);
-                                enterLock();
-                                UI_setTimeShift(1, priv-&gt;getObject()-&gt;m_nDelay); 
-                                leaveLock();
-                                break;
-                        }
-                        case film2pal_prop:
-                        {
-                                if(JSVAL_IS_BOOLEAN(*vp) == false)
-                                        break;
-                                priv-&gt;getObject()-&gt;m_bFilm2PAL = JSVAL_TO_BOOLEAN(*vp);
-                                enterLock();
-                                audioFilterFilm2Pal(priv-&gt;getObject()-&gt;m_bFilm2PAL);
-                                leaveLock();
-                                break;
-                        }
-                        case pal2film_prop:
-                        {
-                                if(JSVAL_IS_BOOLEAN(*vp) == false)
-                                        break;
-                                priv-&gt;getObject()-&gt;m_bPAL2Film = JSVAL_TO_BOOLEAN(*vp);
-                                enterLock();
-                                audioFilterPal2Film(priv-&gt;getObject()-&gt;m_bPAL2Film);
-                                leaveLock();
-                                break;
-                        }
-                        case normalizemode_prop:
-                        {
-                                  enterLock();
-                                  priv-&gt;getObject()-&gt;m_nNormalizeMode = JSVAL_TO_INT(*vp);
-                                  audioFilterNormalizeMode(priv-&gt;getObject()-&gt;m_nNormalizeMode);
-                                  leaveLock();
-                                  break;
-                        }
-                        case normalizevalue_prop:
-                        {
-                                  priv-&gt;getObject()-&gt;m_nNormalizeValue = JSVAL_TO_INT(*vp);
-                                  enterLock();
-                                  audioFilterNormalizeValue(priv-&gt;getObject()-&gt;m_nNormalizeValue);
-                                  leaveLock();
-                                  break;
-                        }
-						case mixerProperty:
-						{
-							const char *mixer = JS_GetStringBytes(JSVAL_TO_STRING(*vp));
-
-							setCurrentMixerFromString(mixer);
-							break;
-						}
-                        default : printf(&quot;UNKNOWN AUDIO PROP\n&quot;);
-                        return JS_FALSE;
-                }
-        }
-        return JS_TRUE;
-}
-
-JSBool ADM_JSAvidemuxAudio::ScanVBR(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{// begin ScanVBR
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 0)
-                return JS_FALSE;
-        printf(&quot;Scaning Audio... \n&quot;);
-        enterLock();
-        HandleAction(ACT_AudioMap);
-        leaveLock()
-        *rval = BOOLEAN_TO_JSVAL(true);
-        return JS_TRUE;
-}// end ScanVBR
-
-JSBool ADM_JSAvidemuxAudio::Save(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{// begin Save
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 1)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false)
-                return JS_FALSE;
-        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        printf(&quot;Saving Audio \&quot;%s\&quot;\n&quot;,pTempStr);
-        enterLock();
-        *rval = INT_TO_JSVAL(A_audioSave(pTempStr));
-        leaveLock();
-        return JS_TRUE;
-}// end Save
-
-JSBool ADM_JSAvidemuxAudio::Load(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{// begin Load
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 2)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_STRING(argv[1]) == false)
-                return JS_FALSE;
-        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[1]));
-        char *pArg0 = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        printf(&quot;Loading Audio \&quot;%s\&quot;\n&quot;,pTempStr);
-
-        // 1st arg is type
-        AudioSource src;
-        int result=0;
-        
-        src=audioSourceFromString(pArg0);
-        if(!src) {printf(&quot;[Script]Invalid audiosource type\n&quot;);return JS_FALSE;}
-        enterLock();
-        switch(src)
-        {
-                case AudioAvi:
-                        result = A_changeAudioStream (aviaudiostream, AudioAvi,NULL);
-                        break;
-                case AudioMP3:
-                        result = A_loadMP3(pTempStr);
-                        break;
-                case AudioWav:
-                        result = A_loadWave(pTempStr);
-                        break;
-                case AudioAC3:
-                        result = A_loadAC3(pTempStr);
-                        break;
-                case AudioNone:
-                        result = A_changeAudioStream(NULL,AudioNone,NULL);
-                        break;
-                default:
-                        ADM_assert(0);
-                        break;
-        }
-        leaveLock()
-        printf(&quot;[script] &quot;);
-        
-        if(!result)
-                printf(&quot;failed :&quot;);
-        else
-                printf(&quot;succeed :&quot;);
-        printf(&quot; external source %d (%s) \n&quot;, src,pTempStr);
-
-        *rval = INT_TO_JSVAL(result);
-        return JS_TRUE;
-}// end Load
-
-JSBool ADM_JSAvidemuxAudio::Reset(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{// begin Reset
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 0)
-                return JS_FALSE;
-        enterLock();
-        audioReset();
-        leaveLock()
-        *rval = BOOLEAN_TO_JSVAL(true);
-        return JS_TRUE;
-}// end Reset
-// app.audio.codec(&quot;lame&quot;,128,8,&quot;00 00 00 00 01 00 00 00 &quot;);
-extern uint8_t mk_hex (uint8_t a, uint8_t b);
-JSBool ADM_JSAvidemuxAudio::Codec(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{// begin Codec
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 4)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false || JSVAL_IS_INT(argv[2]) == false  ||  JSVAL_IS_STRING(argv[3]) == false  )
-                return JS_FALSE;
-        char *name = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        ADM_LowerCase(name);
-        enterLock();
-        // First search the codec by its name
-        if(!audioCodecSetByName(name))
-                *rval = BOOLEAN_TO_JSVAL(false);
-        else
-        {// begin set bitrate
-        //audioFilter_SetBitrate(JSVAL_TO_INT(argv[1]));
-          uint32_t bitrate,size;
-          char  *extra;
-          uint8_t *data=NULL;
-                bitrate=JSVAL_TO_INT(argv[1]);
-                size=JSVAL_TO_INT(argv[2]);
-                extra=JS_GetStringBytes(JSVAL_TO_STRING(argv[3])); 
-                if(size)
-                {
-                          data=new uint8_t[size];
-                          for (uint32_t k = 0; k &lt; size; k++)
-                            {
-                              data[k] = mk_hex (*extra, *(extra + 1));
-                              extra += 3;
-                            }
-                        setAudioExtraConf(bitrate,size,data);
-                        delete [] data; 
-                }
-
-                *rval = BOOLEAN_TO_JSVAL(true);
-        }// end set bitrate
-        leaveLock();
-        return JS_TRUE;
-}// end Codec
-JSBool ADM_JSAvidemuxAudio::getNbTracks(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{
-uint32_t nb=0;
-audioInfo *infos=NULL;
-        // default return value
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        if(argc != 0)
-                return JS_FALSE;
-        // default return value
-      
-        enterLock();
-        video_body-&gt;getAudioStreamsInfo(0,&amp;nb, &amp;infos);
-        leaveLock();
-        if(infos)
-                delete [] infos;
-        *rval = INT_TO_JSVAL(nb);
-        return JS_TRUE;
-}// end Codec
-JSBool ADM_JSAvidemuxAudio::setTrack(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{
-uint32_t nb=0,nw=0;
-audioInfo *infos=NULL;
-        // default return value
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-
-        // default return value
-      if(argc != 1)
-                return JS_FALSE;
-        if(JSVAL_IS_INT(argv[0]) == false)
-                return JS_FALSE;
-        video_body-&gt;getAudioStreamsInfo(0,&amp;nb, &amp;infos);
-        delete [] infos;
-        nw=(JSVAL_TO_INT(argv[0]));
-        if(nw&gt;nb) return JS_FALSE;
-        enterLock();
-        video_body-&gt;changeAudioStream(0,nw);
-        leaveLock();
-        return JS_TRUE;
-}// end Codec
-JSBool ADM_JSAvidemuxAudio::secondAudioTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        if(argc != 2)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_STRING(argv[1]) == false)
-                return JS_FALSE;
-        // First arg is MP3 etc...
-        char *name = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        ADM_LowerCase(name);
-        // First search the codec by its name
-        AudioSource source;
-        if(AudioInvalid==(source=audioSourceFromString(name)))
-                return JS_FALSE;
-        // Now get the name
-        name = JS_GetStringBytes(JSVAL_TO_STRING(argv[1]));
-        enterLock();
-        if(A_setSecondAudioTrack(source,name))
-        {
-                leaveLock();
-                return JS_TRUE;
-        }
-        leaveLock();
-      return JS_FALSE;
-}
-
-JSBool ADM_JSAvidemuxAudio::getNbChannels(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{
-uint32_t nb=0, nw=0;
-audioInfo *infos=NULL;
-        // default return value
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        if(argc != 1)
-                return JS_FALSE;
-        // default return value
-      
-        if(JSVAL_IS_INT(argv[0]) == false)
-                return JS_FALSE;
-        enterLock();
-        video_body-&gt;getAudioStreamsInfo(0,&amp;nb, &amp;infos);
-        leaveLock()
-        nw=(JSVAL_TO_INT(argv[0]));
-        if(nw&gt;nb)
-                return JS_FALSE;
-        *rval = INT_TO_JSVAL(infos[nw].channels);
-        delete [] infos;
-        return JS_TRUE;
-}// end Codec
-
-JSBool ADM_JSAvidemuxAudio::getBitrate(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{
-uint32_t nb=0, nw=0;
-audioInfo *infos=NULL;
-        // default return value
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        if(argc != 1)
-                return JS_FALSE;
-        // default return value
-      
-        if(JSVAL_IS_INT(argv[0]) == false)
-                return JS_FALSE;
-        enterLock();
-        video_body-&gt;getAudioStreamsInfo(0,&amp;nb, &amp;infos);
-        leaveLock()
-        nw=(JSVAL_TO_INT(argv[0]));
-        if(nw&gt;nb)
-                return JS_FALSE;
-        *rval = INT_TO_JSVAL(infos[nw].bitrate);
-        delete [] infos;
-        return JS_TRUE;
-}// end Codec
-
+// C++ Interface: Spider Monkey interface
+//
+// Description: 
+//
+//
+// Author: Anish Mistry
+//      Some modification by mean
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include &quot;ADM_default.h&quot;
+#include &quot;config.h&quot;
+#include &quot;ADM_JSGlobal.h&quot;
+#include &quot;ADM_JSAvidemuxAudio.h&quot;
+
+#include &quot;../ADM_userInterfaces/ADM_commonUI/GUI_ui.h&quot;
+#include &quot;gui_action.hxx&quot;
+#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
+#include &quot;ADM_JSAudioTrackInfo.h&quot;
+
+extern int A_audioSave(char *name);
+extern int A_loadAC3 (char *name);
+extern int A_loadMP3 (char *name);
+extern int A_loadWave (char *name);
+extern AudioSource currentAudioSource;
+extern AudioSource secondAudioSource;
+extern void HandleAction(Action act);
+extern uint8_t A_setSecondAudioTrack(const AudioSource nw,char *name);
+
+JSPropertySpec ADM_JSAvidemuxAudio::properties[] = {
+        { &quot;process&quot;, audioprocess_prop, JSPROP_ENUMERATE },        // process audio when saving
+        { &quot;resample&quot;, resample_prop, JSPROP_ENUMERATE },	// resample
+        { &quot;delay&quot;, delay_prop, JSPROP_ENUMERATE },	// set audio delay
+        { &quot;film2Pal&quot;, film2pal_prop, JSPROP_ENUMERATE },	// convert film to pal
+        { &quot;pal2Film&quot;, pal2film_prop, JSPROP_ENUMERATE },	// convert pal to film
+        { &quot;normalizeMode&quot;, normalizemode_prop, JSPROP_ENUMERATE },	//
+        { &quot;drc&quot;, drc_prop, JSPROP_ENUMERATE },	//
+        { &quot;normalizeValue&quot;, normalizevalue_prop, JSPROP_ENUMERATE },	//
+		{ &quot;mixer&quot;, mixerProperty, JSPROP_ENUMERATE },	//
+		{ &quot;sourceTrackInfo&quot;, sourceTrackInfoProperty, JSPROP_ENUMERATE },
+		{ &quot;targetTrackInfo&quot;, targetTrackInfoProperty, JSPROP_ENUMERATE },
+        { 0 }
+};
+
+JSFunctionSpec ADM_JSAvidemuxAudio::methods[] = {
+        { &quot;scanVbr&quot;, ScanVBR, 0, 0, 0 },	// scan variable bit rate audio
+        { &quot;save&quot;, Save, 1, 0, 0 },	// save audio stream
+        { &quot;load&quot;, Load, 2, 0, 0 },	// load audio stream
+        { &quot;reset&quot;, Reset, 0, 0, 0 },	// reset audio stream
+        { &quot;codec&quot;, Codec, 4, 0, 0 },	// set output codec
+        { &quot;setTrack&quot;, setTrack, 1, 0, 0 },    // set output codec
+        { &quot;secondAudioTrack&quot;, secondAudioTrack, 2, 0, 0 },    // set audio track
+        { 0 }
+};
+
+JSClass ADM_JSAvidemuxAudio::m_classAvidemuxAudio = 
+{
+        &quot;AvidemuxAudio&quot;, JSCLASS_HAS_PRIVATE,
+        JS_PropertyStub, JS_PropertyStub,
+        ADM_JSAvidemuxAudio::JSGetProperty, ADM_JSAvidemuxAudio::JSSetProperty,
+        JS_EnumerateStub, JS_ResolveStub, 
+        JS_ConvertStub, ADM_JSAvidemuxAudio::JSDestructor
+};
+
+ADM_JSAvidemuxAudio::~ADM_JSAvidemuxAudio(void)
+{
+        if(m_pObject != NULL)
+                delete m_pObject;
+        m_pObject = NULL;
+}
+
+void ADM_JSAvidemuxAudio::setObject(ADM_AvidemuxAudio *pObject)
+{
+        m_pObject = pObject; 
+}
+        
+ADM_AvidemuxAudio *ADM_JSAvidemuxAudio::getObject()
+{
+        return m_pObject; 
+}
+
+JSObject *ADM_JSAvidemuxAudio::JSInit(JSContext *cx, JSObject *obj, JSObject *proto)
+{
+	JSObject *newObj = JS_InitClass(cx, obj, proto, &amp;m_classAvidemuxAudio, NULL, 0,
+		ADM_JSAvidemuxAudio::properties, ADM_JSAvidemuxAudio::methods, NULL, NULL);
+	ADM_JSAvidemuxAudio *p = new ADM_JSAvidemuxAudio();
+
+	p-&gt;setObject(new ADM_AvidemuxAudio());
+	JS_SetPrivate(cx, newObj, p);
+
+	return newObj;
+}
+
+void ADM_JSAvidemuxAudio::JSDestructor(JSContext *cx, JSObject *obj)
+{
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        if(p != NULL)
+                delete p;
+        p = NULL;
+}
+
+JSBool ADM_JSAvidemuxAudio::JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+        if (JSVAL_IS_INT(id)) 
+        {
+                ADM_JSAvidemuxAudio *priv = (ADM_JSAvidemuxAudio *) JS_GetPrivate(cx, obj);
+                switch(JSVAL_TO_INT(id))
+                {
+                        case audioprocess_prop:
+                                *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_bAudioProcess);
+                                break;
+                        case resample_prop:
+                                *vp = INT_TO_JSVAL(priv-&gt;getObject()-&gt;m_nResample);
+                                break;
+                        case delay_prop:
+                                *vp = INT_TO_JSVAL(priv-&gt;getObject()-&gt;m_nDelay);
+                                break;
+                        case film2pal_prop:
+                                *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_bFilm2PAL);
+                                break;
+                        case pal2film_prop:
+                                *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_bPAL2Film);
+                                break;
+                        case normalizemode_prop:
+                              *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_nNormalizeMode);
+                              break;
+                        case normalizevalue_prop:
+                          *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_nNormalizeValue);
+                          break;
+                        case drc_prop:
+                            *vp = BOOLEAN_TO_JSVAL(priv-&gt;getObject()-&gt;m_bDRC);
+                            break;
+						case mixerProperty:
+							*vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, getCurrentMixerString()));
+							break;
+						case sourceTrackInfoProperty:
+						{
+							JSObject *tracks = JS_NewArrayObject(cx, 0, NULL);
+							jsval sourceTrack;
+
+							audioInfo *audioInfos = NULL;
+							uint32_t trackCount = 0;
+
+							*vp = OBJECT_TO_JSVAL(tracks);
+							video_body-&gt;getAudioStreamsInfo(0, &amp;trackCount, &amp;audioInfos);
+
+							for (int infoIndex = 0; infoIndex &lt; trackCount; infoIndex++)
+							{
+								sourceTrack = OBJECT_TO_JSVAL(ADM_JSAudioTrackInfo::JSInit(cx, obj, NULL, infoIndex, (&amp;audioInfos)[infoIndex]));
+								JS_SetElement(cx, tracks, infoIndex, &amp;sourceTrack);
+							}
+
+							if(audioInfos)
+								delete [] audioInfos;
+
+							break;
+						}
+						case targetTrackInfoProperty:
+						{
+							JSObject *tracks = JS_NewArrayObject(cx, 0, NULL);
+							jsval targetTrack;
+
+							*vp = OBJECT_TO_JSVAL(tracks);
+
+							AddAudioSourceToJSArray(cx, obj, 0, currentAudioSource, currentaudiostream, tracks);
+							AddAudioSourceToJSArray(cx, obj, 1, secondAudioSource, secondaudiostream, tracks);
+
+							break;
+						}
+				}
+
+				return JS_TRUE;
+		}
+}
+
+void ADM_JSAvidemuxAudio::AddAudioSourceToJSArray(JSContext *cx, JSObject *obj, int trackIndex, AudioSource audioSource, 
+												  AVDMGenericAudioStream *audioStream, JSObject *tracks)
+{
+	if (audioSource != AudioNone)
+	{
+		WAVHeader *trackHeader = audioStream-&gt;getInfo();
+
+		jsval targetTrack = OBJECT_TO_JSVAL(ADM_JSAudioTrackInfo::JSInit(
+			cx, obj, NULL, 
+			audioSource == AudioAvi ? video_body-&gt;getCurrentAudioStreamNumber(trackIndex) : -1,
+			trackIndex, trackHeader));
+		jsuint length;
+
+		JS_GetArrayLength(cx, tracks, &amp;length);
+		JS_SetElement(cx, tracks, length, &amp;targetTrack);
+	}
+}
+
+JSBool ADM_JSAvidemuxAudio::JSSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+        if (JSVAL_IS_INT(id)) 
+        {
+                
+                ADM_JSAvidemuxAudio *priv = (ADM_JSAvidemuxAudio *) JS_GetPrivate(cx, obj);
+                switch(JSVAL_TO_INT(id))
+                {
+                        case audioprocess_prop:
+                        {
+                                if(JSVAL_IS_BOOLEAN(*vp) == false)
+                                        break;
+                                priv-&gt;getObject()-&gt;m_bNormalize = JSVAL_TO_BOOLEAN(*vp);
+                                enterLock();
+                                UI_setAProcessToggleStatus(priv-&gt;getObject()-&gt;m_bAudioProcess);
+                                leaveLock();
+                                break;
+                        }
+                        case drc_prop:
+                        {
+                                if(JSVAL_IS_BOOLEAN(*vp) == false)
+                                        break;
+                                priv-&gt;getObject()-&gt;m_bDRC = JSVAL_TO_BOOLEAN(*vp);
+                                enterLock();
+                                audioFilterDrc(priv-&gt;getObject()-&gt;m_bDRC);
+                                leaveLock();
+                                break;
+                        }
+                        case resample_prop:
+                        {
+                                if(JSVAL_IS_INT(*vp) == false)
+                                        break;
+                                priv-&gt;getObject()-&gt;m_nResample = JSVAL_TO_INT(*vp);
+                                enterLock();
+                                audioFilterResample(priv-&gt;getObject()-&gt;m_nResample);
+                                leaveLock();
+                                break;
+                        }
+                        case delay_prop:
+                        {
+                                if(JSVAL_IS_INT(*vp) == false)
+                                        break;
+                                priv-&gt;getObject()-&gt;m_nDelay = JSVAL_TO_INT(*vp);
+                                //audioFilterDelay(priv-&gt;getObject()-&gt;m_nDelay);
+                                enterLock();
+                                UI_setTimeShift(1, priv-&gt;getObject()-&gt;m_nDelay); 
+                                leaveLock();
+                                break;
+                        }
+                        case film2pal_prop:
+                        {
+                                if(JSVAL_IS_BOOLEAN(*vp) == false)
+                                        break;
+                                priv-&gt;getObject()-&gt;m_bFilm2PAL = JSVAL_TO_BOOLEAN(*vp);
+                                enterLock();
+                                audioFilterFilm2Pal(priv-&gt;getObject()-&gt;m_bFilm2PAL);
+                                leaveLock();
+                                break;
+                        }
+                        case pal2film_prop:
+                        {
+                                if(JSVAL_IS_BOOLEAN(*vp) == false)
+                                        break;
+                                priv-&gt;getObject()-&gt;m_bPAL2Film = JSVAL_TO_BOOLEAN(*vp);
+                                enterLock();
+                                audioFilterPal2Film(priv-&gt;getObject()-&gt;m_bPAL2Film);
+                                leaveLock();
+                                break;
+                        }
+                        case normalizemode_prop:
+                        {
+                                  enterLock();
+                                  priv-&gt;getObject()-&gt;m_nNormalizeMode = JSVAL_TO_INT(*vp);
+                                  audioFilterNormalizeMode(priv-&gt;getObject()-&gt;m_nNormalizeMode);
+                                  leaveLock();
+                                  break;
+                        }
+                        case normalizevalue_prop:
+                        {
+                                  priv-&gt;getObject()-&gt;m_nNormalizeValue = JSVAL_TO_INT(*vp);
+                                  enterLock();
+                                  audioFilterNormalizeValue(priv-&gt;getObject()-&gt;m_nNormalizeValue);
+                                  leaveLock();
+                                  break;
+                        }
+						case mixerProperty:
+						{
+							const char *mixer = JS_GetStringBytes(JSVAL_TO_STRING(*vp));
+
+							setCurrentMixerFromString(mixer);
+							break;
+						}
+                        default : printf(&quot;UNKNOWN AUDIO PROP\n&quot;);
+                        return JS_FALSE;
+                }
+        }
+        return JS_TRUE;
+}
+
+JSBool ADM_JSAvidemuxAudio::ScanVBR(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{// begin ScanVBR
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 0)
+                return JS_FALSE;
+        printf(&quot;Scaning Audio... \n&quot;);
+        enterLock();
+        HandleAction(ACT_AudioMap);
+        leaveLock()
+        *rval = BOOLEAN_TO_JSVAL(true);
+        return JS_TRUE;
+}// end ScanVBR
+
+JSBool ADM_JSAvidemuxAudio::Save(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{// begin Save
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 1)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false)
+                return JS_FALSE;
+        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        printf(&quot;Saving Audio \&quot;%s\&quot;\n&quot;,pTempStr);
+        enterLock();
+        *rval = INT_TO_JSVAL(A_audioSave(pTempStr));
+        leaveLock();
+        return JS_TRUE;
+}// end Save
+
+JSBool ADM_JSAvidemuxAudio::Load(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{// begin Load
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 2)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_STRING(argv[1]) == false)
+                return JS_FALSE;
+        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[1]));
+        char *pArg0 = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        printf(&quot;Loading Audio \&quot;%s\&quot;\n&quot;,pTempStr);
+
+        // 1st arg is type
+        AudioSource src;
+        int result=0;
+        
+        src=audioSourceFromString(pArg0);
+        if(!src) {printf(&quot;[Script]Invalid audiosource type\n&quot;);return JS_FALSE;}
+        enterLock();
+        switch(src)
+        {
+                case AudioAvi:
+                        result = A_changeAudioStream (aviaudiostream, AudioAvi,NULL);
+                        break;
+                case AudioMP3:
+                        result = A_loadMP3(pTempStr);
+                        break;
+                case AudioWav:
+                        result = A_loadWave(pTempStr);
+                        break;
+                case AudioAC3:
+                        result = A_loadAC3(pTempStr);
+                        break;
+                case AudioNone:
+                        result = A_changeAudioStream(NULL,AudioNone,NULL);
+                        break;
+                default:
+                        ADM_assert(0);
+                        break;
+        }
+        leaveLock()
+        printf(&quot;[script] &quot;);
+        
+        if(!result)
+                printf(&quot;failed :&quot;);
+        else
+                printf(&quot;succeed :&quot;);
+        printf(&quot; external source %d (%s) \n&quot;, src,pTempStr);
+
+        *rval = INT_TO_JSVAL(result);
+        return JS_TRUE;
+}// end Load
+
+JSBool ADM_JSAvidemuxAudio::Reset(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{// begin Reset
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 0)
+                return JS_FALSE;
+        enterLock();
+        audioReset();
+        leaveLock()
+        *rval = BOOLEAN_TO_JSVAL(true);
+        return JS_TRUE;
+}// end Reset
+// app.audio.codec(&quot;lame&quot;,128,8,&quot;00 00 00 00 01 00 00 00 &quot;);
+extern uint8_t mk_hex (uint8_t a, uint8_t b);
+JSBool ADM_JSAvidemuxAudio::Codec(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{// begin Codec
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 4)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false || JSVAL_IS_INT(argv[2]) == false  ||  JSVAL_IS_STRING(argv[3]) == false  )
+                return JS_FALSE;
+        char *name = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        ADM_LowerCase(name);
+        enterLock();
+        // First search the codec by its name
+        if(!audioCodecSetByName(name))
+                *rval = BOOLEAN_TO_JSVAL(false);
+        else
+        {// begin set bitrate
+        //audioFilter_SetBitrate(JSVAL_TO_INT(argv[1]));
+          uint32_t bitrate,size;
+          char  *extra;
+          uint8_t *data=NULL;
+                bitrate=JSVAL_TO_INT(argv[1]);
+                size=JSVAL_TO_INT(argv[2]);
+                extra=JS_GetStringBytes(JSVAL_TO_STRING(argv[3])); 
+                if(size)
+                {
+                          data=new uint8_t[size];
+                          for (uint32_t k = 0; k &lt; size; k++)
+                            {
+                              data[k] = mk_hex (*extra, *(extra + 1));
+                              extra += 3;
+                            }
+                        setAudioExtraConf(bitrate,size,data);
+                        delete [] data; 
+                }
+
+                *rval = BOOLEAN_TO_JSVAL(true);
+        }// end set bitrate
+        leaveLock();
+        return JS_TRUE;
+}// end Codec
+
+JSBool ADM_JSAvidemuxAudio::setTrack(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{
+uint32_t nb=0,nw=0;
+audioInfo *infos=NULL;
+        // default return value
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+
+        // default return value
+      if(argc != 1)
+                return JS_FALSE;
+        if(JSVAL_IS_INT(argv[0]) == false)
+                return JS_FALSE;
+        video_body-&gt;getAudioStreamsInfo(0,&amp;nb, &amp;infos);
+        delete [] infos;
+        nw=(JSVAL_TO_INT(argv[0]));
+        if(nw&gt;nb) return JS_FALSE;
+        enterLock();
+        video_body-&gt;changeAudioStream(0,nw);
+        leaveLock();
+        return JS_TRUE;
+}// end Codec
+
+JSBool ADM_JSAvidemuxAudio::secondAudioTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        if(argc != 2)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_STRING(argv[1]) == false)
+                return JS_FALSE;
+        // First arg is MP3 etc...
+        char *name = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        ADM_LowerCase(name);
+        // First search the codec by its name
+        AudioSource source;
+        if(AudioInvalid==(source=audioSourceFromString(name)))
+                return JS_FALSE;
+        // Now get the name
+        name = JS_GetStringBytes(JSVAL_TO_STRING(argv[1]));
+        enterLock();
+        if(A_setSecondAudioTrack(source,name))
+        {
+                leaveLock();
+                return JS_TRUE;
+        }
+        leaveLock();
+      return JS_FALSE;
+}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h	2009-04-20 15:58:54 UTC (rev 4740)
@@ -8,6 +8,8 @@
 // Spidermonkey
 #include &quot;ADM_libraries/ADM_smjs/jsapi.h&quot;
 #include &quot;ADM_AvidemuxAudio.h&quot;
+#include &quot;avi_vars.h&quot;
+#include &quot;ADM_audiofilter/audioeng_buildfilters.h&quot;
 
 class ADM_JSAvidemuxAudio
 {
@@ -25,7 +27,9 @@
 		normalizemode_prop,
 		normalizevalue_prop,
 		drc_prop,
-		mixerProperty
+		mixerProperty,
+		sourceTrackInfoProperty,
+		targetTrackInfoProperty
 	};
 
 private:
@@ -46,11 +50,9 @@
 	static JSBool Load(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool Reset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool Codec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool getNbTracks(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static void AddAudioSourceToJSArray(JSContext *cx, JSObject *obj, int trackIndex, AudioSource audioSource, AVDMGenericAudioStream *audioStream, JSObject *tracks);
 	static JSBool setTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool secondAudioTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool getNbChannels(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool getBitrate(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 };
 
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt	2009-04-20 15:58:54 UTC (rev 4740)
@@ -1,7 +1,7 @@
 SET(ADM_script_SRCS
 	ADM_AvidemuxAudio.cpp  ADM_AvidemuxVideo.cpp    ADM_JSAvidemux.cpp       ADM_JSDirectorySearch.cpp  ADM_JSGlobal.cpp
 	ADM_Avidemux.cpp       ADM_JSAvidemuxAudio.cpp  ADM_JSAvidemuxVideo.cpp  ADM_JSFunctions.cpp        DirectorySearch.cpp
-	ADM_JSDialogFactory.cpp  ADM_JSDFMenu.cpp  ADM_JSAppliedVideoFilter.cpp)
+	ADM_JSDialogFactory.cpp  ADM_JSDFMenu.cpp  ADM_JSAppliedVideoFilter.cpp  ADM_JSAudioTrackInfo.cpp)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_script ${ADM_script_SRCS})
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2009-04-20 15:58:54 UTC (rev 4740)
@@ -61,10 +61,10 @@
 #include &quot;ADM_libraries/ADM_libmpeg2enc/ADM_mpeg2enc.h&quot;
 #include &quot;ADM_video/ADM_vidMisc.h&quot;
 #include &quot;ADM_preview.h&quot;
-static AudioSource currentAudioSource = AudioAvi;
-static AudioSource secondAudioSource = AudioNone;
-static char *currentAudioName = NULL;
-static char *secondAudioName = NULL;
+AudioSource currentAudioSource = AudioAvi;
+AudioSource secondAudioSource = AudioNone;
+char *currentAudioName = NULL;
+char *secondAudioName = NULL;
 
 void A_handleSecondTrack (int tracktype);
 int A_delete(uint32_t start, uint32_t end);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001967.html">[Avidemux-svn-commit] r4739 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_coreAudio/include ADM_userInterfaces/ADM_commonUI
</A></li>
	<LI>Next message: <A HREF="001969.html">[Avidemux-svn-commit] r4741 - in	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_script	scripts/auto
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1968">[ date ]</a>
              <a href="thread.html#1968">[ thread ]</a>
              <a href="subject.html#1968">[ subject ]</a>
              <a href="author.html#1968">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
