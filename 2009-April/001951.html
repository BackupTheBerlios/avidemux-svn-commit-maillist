<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4723 - in branches/avidemux_2.6_branch_mean:	avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers	plugins/ADM_demuxers/MpegTS
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4723%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/ADM_coreDemuxerMpeg/include%0A%09avidemux/ADM_coreDemuxerMpeg/src%20plugins/ADM_demuxers%0A%09plugins/ADM_demuxers/MpegTS&In-Reply-To=%3C200904070539.n375dpDA009673%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001950.html">
   <LINK REL="Next"  HREF="001952.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4723 - in branches/avidemux_2.6_branch_mean:	avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers	plugins/ADM_demuxers/MpegTS</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4723%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/ADM_coreDemuxerMpeg/include%0A%09avidemux/ADM_coreDemuxerMpeg/src%20plugins/ADM_demuxers%0A%09plugins/ADM_demuxers/MpegTS&In-Reply-To=%3C200904070539.n375dpDA009673%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4723 - in branches/avidemux_2.6_branch_mean:	avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers	plugins/ADM_demuxers/MpegTS">mean at mail.berlios.de
       </A><BR>
    <I>Tue Apr  7 07:39:51 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001950.html">[Avidemux-svn-commit] r4722 -	branches/avidemux_2.6_branch_mean/avidemux
</A></li>
        <LI>Next message: <A HREF="001952.html">[Avidemux-svn-commit] r4724 -	branches/avidemux_2.6_branch_mean/avidemux
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1951">[ date ]</a>
              <a href="thread.html#1951">[ thread ]</a>
              <a href="subject.html#1951">[ subject ]</a>
              <a href="author.html#1951">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-04-07 07:39:51 +0200 (Tue, 07 Apr 2009)
New Revision: 4723

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/CMakeLists.txt
Log:
[Demuxer:MpegTs] Skeleton

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,96 @@
+/**
+    dmxPSPacket.cpp
+
+*/
+
+#ifndef DMXPSPACKET_H
+#define DMXPSPACKET_H
+
+#include &quot;dmxPacket.h&quot;
+#include &quot;ADM_Video.h&quot;
+
+
+
+/**
+    \class psPacket
+*/
+class psPacket : public ADMMpegPacket
+{
+protected:
+    uint8_t             getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
+public:
+                        psPacket(void);
+    virtual            ~psPacket();
+    virtual bool        open(const char *filenames,FP_TYPE append);
+    virtual bool        close(void);
+    virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
+    virtual uint64_t    getPos(void);
+    virtual bool        setPos(uint64_t pos);
+};
+/**
+    \class psPacketLinear
+*/
+#define ADM_PACKET_LINEAR 10*1024
+
+class psPacketLinear : public psPacket
+{
+protected:
+        uint8_t  myPid;
+        uint64_t startAt;
+        uint32_t bufferLen;
+        uint64_t bufferPts;
+        uint64_t bufferDts;
+        uint32_t bufferIndex;
+        uint8_t  buffer[ADM_PACKET_LINEAR];
+        bool     eof;
+        bool     refill(void);
+        uint64_t oldStartAt;
+        uint32_t oldBufferLen;
+        uint64_t oldBufferPts;
+        uint64_t oldBufferDts;
+        uint32_t consumed;
+
+public:
+                psPacketLinear(uint8_t pid);
+                ~psPacketLinear();
+        uint32_t getConsumed(void);
+        uint8_t  readi8();
+        uint16_t readi16();
+        uint32_t readi32();
+        bool     sync(uint8_t *pid);
+        bool    read(uint32_t len, uint8_t *buffer);
+        bool    forward(uint32_t v);
+        bool    stillOk(void) {return !eof;};
+        bool    getInfo(dmxPacketInfo *info);
+        bool    seek(uint64_t packetStart, uint32_t offset);
+        bool    changePid(uint32_t pid) ;
+};
+/**
+    \class psPacketLinearTracker
+*/
+typedef struct
+{
+    uint32_t count;
+    uint32_t size;
+    
+    uint64_t startAt;
+    uint32_t startCount;
+    uint32_t startSize;
+    uint64_t startDts;
+}packetStats;
+
+class psPacketLinearTracker : public psPacketLinear
+{
+protected:
+      packetStats stats[256];
+
+public:
+                        psPacketLinearTracker(uint8_t pid);
+                        ~psPacketLinearTracker();
+         packetStats    *getStat(int intdex);
+         bool           resetStats(void);
+virtual  bool           getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
+};
+
+
+#endif
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,653 @@
+/**
+    \file dmxPSPacket
+    \brief Packet demuxer for mpeg PS
+    copyright            : (C) 2005-2008 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+
+#include &quot;dmxPSPacket.h&quot;
+#include &quot;dmx_mpegstartcode.h&quot;
+
+/**
+    \fn psPacket
+    \brief ctor
+*/
+psPacket::psPacket(void) 
+{
+
+}
+/**
+    \fn psPacket
+    \brief dtor
+*/
+psPacket::~psPacket()
+{
+    close();
+}
+/**
+    \fn open
+    \brief dtor
+*/
+bool psPacket::open(const char *filenames,FP_TYPE append)
+{
+    _file=new fileParser();
+    if(!_file-&gt;open(filenames,&amp;append))
+    {
+        printf(&quot;[DmxPS] cannot open %s\n&quot;,filenames);
+        delete _file;
+        _file=NULL;
+        return false;
+    }
+    _size=_file-&gt;getSize();
+    return true;
+}
+/**
+    \fn close
+    \brief dtor
+*/
+bool psPacket::close(void)
+{
+    if(_file)
+    {
+        delete _file;
+        _file=NULL;
+    }
+    return true;
+}
+/**
+    \fn getPos
+*/
+uint64_t    psPacket::getPos(void)
+{
+    return 0;
+}
+/**
+    \fn setPos
+*/
+
+bool    psPacket::setPos(uint64_t pos)
+{
+    if(!_file-&gt;setpos(pos))
+    {
+        printf(&quot;[psPacket] Cannot seek to %&quot;LLX&quot;\n&quot;, pos);
+        return false;
+    }
+}
+
+/**
+    \fn getPacket
+*/      
+bool        psPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)
+{
+uint32_t globstream,len;
+uint8_t  stream,substream;
+uint64_t pts,dts;
+        // Resync on our stream
+_again2:
+        *pid=0;
+        if(!_file-&gt;sync(&amp;stream)) 
+        {
+                uint64_t pos;
+                _file-&gt;getpos(&amp;pos);
+                printf(&quot;[DmxPS] cannot sync  at &quot;LLU&quot;/&quot;LLU&quot;\n&quot;,pos,_size);
+                return false;
+        }
+// Position of this packet just before startcode
+        _file-&gt;getpos(startAt);
+        *startAt-=4;
+// Handle out of band stuff        
+        if(stream==PACK_START_CODE) 
+        {
+        		_file-&gt;forward(8);
+        		goto _again2;
+        }
+        if( stream==PADDING_CODE ||stream==SYSTEM_START_CODE) 
+        {
+                        len=_file-&gt;read16i();
+                        //printf(&quot;\tForwarding %lu bytes\n&quot;,len);
+        		_file-&gt;forward(len);
+        		goto _again2;
+        }
+        // Only keep relevant parts
+        // i.e. a/v : C0 C9 E0 E9
+        // subs 20-29
+        // private data 1/2
+#define INSIDE(min,max) (stream&gt;=min &amp;&amp; stream&lt;max)
+        if(!(  INSIDE(0xC0,0xC9) || INSIDE(0xE0,0xE9) || INSIDE(0x20,0x29) || stream==PRIVATE_STREAM_1 || stream==PRIVATE_STREAM_2
+        			)) goto _again2;
+        // Ok we got a candidate
+        if(!getPacketInfo(stream,&amp;substream,&amp;len,&amp;pts,&amp;dts))   
+        {
+                goto _again2;
+        }
+        
+        //printf(&quot;Main Stream :%x substream :%x\n&quot;,stream,substream);
+        if(stream==PRIVATE_STREAM_1) globstream=0xFF00+substream;
+                else                 globstream=stream;
+
+        *pid=globstream;
+        *opts=pts;
+        *odts=dts;
+        *packetSize=len;
+        if(len&gt;     maxSize)
+        {
+                printf(&quot;[DmxPS] Packet too big %d vs %d\n&quot;,len,maxSize);
+        }
+        if(!_file-&gt;read32(len,buffer)) return false;
+        return true;
+       
+}
+/**
+
+    \fn getPacketInfo
+    \brief       Retrieve info about the packet we just met.It is assumed that parser is just after the packet startcode
+
+*/
+
+uint8_t psPacket::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
+{
+
+//uint32_t un ,deux;
+uint64_t size=0;
+uint8_t c,d;
+uint8_t align=0;
+                        
+                *substream=0xff;
+                *opts=ADM_NO_PTS;
+                *odts=ADM_NO_PTS;
+                
+                                        
+                size=_file-&gt;read16i();
+                if((stream==PADDING_CODE) || 
+                	 (stream==PRIVATE_STREAM_2)
+                        ||(stream==SYSTEM_START_CODE) //?
+                        ) // special case, no header
+                        {
+                                *olen=size;      
+                                return 1;
+                        }
+                                
+                        //      remove padding if any                                           
+        
+                while((c=_file-&gt;read8i()) == 0xff) 
+                {
+                        size--;
+                }
+//----------------------------------------------------------------------------
+//-------------------------------MPEG-2 PES packet style----------------------
+//----------------------------------------------------------------------------
+                if(((c&amp;0xC0)==0x80))
+                {
+                        uint32_t ptsdts,len;
+                        //printf(&quot;\n mpeg2 type \n&quot;);
+                        //_muxTypeMpeg2=1;
+                        // c= copyright and stuff       
+                        //printf(&quot; %x align\n&quot;,c);      
+                        if(c &amp; 4) align=1;      
+                        c=_file-&gt;read8i();     // PTS/DTS
+                        //printf(&quot;%x ptsdts\n&quot;,c
+                        ptsdts=c&gt;&gt;6;
+                        // header len
+                        len=_file-&gt;read8i();
+                        size-=3;  
+
+                        switch(ptsdts)
+                        {
+                                case 2: // PTS=1 DTS=0
+                                        if(len&gt;=5)
+                                        {
+                                                uint64_t pts1,pts2,pts0;
+                                                //      printf(&quot;\n PTS10\n&quot;);
+                                                        pts0=_file-&gt;read8i();  
+                                                        pts1=_file-&gt;read16i(); 
+                                                        pts2=_file-&gt;read16i();                 
+                                                        len-=5;
+                                                        size-=5;
+                                                        *opts=(pts1&gt;&gt;1)&lt;&lt;15;
+                                                        *opts+=pts2&gt;&gt;1;
+                                                        *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
+                                        }
+                                        break;
+                                case 3: // PTS=1 DTS=1
+                                                #define PTS11_ADV 10 // nut monkey
+                                                if(len&gt;=PTS11_ADV)
+                                                {
+                                                        uint32_t skip=PTS11_ADV;
+                                                        uint64_t pts1,pts2,dts,pts0;
+                                                                //      printf(&quot;\n PTS10\n&quot;);
+                                                                pts0=_file-&gt;read8i();  
+                                                                pts1=_file-&gt;read16i(); 
+                                                                pts2=_file-&gt;read16i(); 
+                                                                                        
+                                                                *opts=(pts1&gt;&gt;1)&lt;&lt;15;
+                                                                *opts+=pts2&gt;&gt;1;
+                                                                *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
+                                                                pts0=_file-&gt;read8i();  
+                                                                pts1=_file-&gt;read16i(); 
+                                                                pts2=_file-&gt;read16i();                 
+                                                                dts=(pts1&gt;&gt;1)&lt;&lt;15;
+                                                                dts+=pts2&gt;&gt;1;
+                                                                dts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
+                                                                len-=skip;
+                                                                size-=skip;
+                                                                *odts=dts;
+                                                                        //printf(&quot;DTS: %lx\n&quot;,dts);                
+                                                   }
+                                                   break;               
+                                case 1:
+                                                return 0;//ADM_assert(0); // forbidden !
+                                                break;
+                                case 0: 
+                                                // printf(&quot;\n PTS00\n&quot;);
+                                                break; // no pts nor dts
+                                                                                
+                                                            
+                        }  
+// Extension bit        
+// &gt;stealthdave&lt;                                
+
+                        // Skip remaining headers if any
+                        if(len) 
+                        {
+                                _file-&gt;forward(len);
+                                size=size-len;
+                        }
+                                
+                if(stream==PRIVATE_STREAM_1)
+                {
+                        if(size&gt;5)
+                        {
+                        // read sub id
+                               *substream=_file-&gt;read8i();
+  //                    printf(&quot;\n Subid : %x&quot;,*subid);
+                                switch(*substream)
+                                {
+                                // DTS
+                                        case 0x88:case 0x89:case 0x8A:case 0x8B:
+                                        
+                                                *substream=*substream-0x48;
+                                                break;
+
+                                //AC3
+                                        case 0x80:case 0x81:case 0x82:case 0x83:
+                                        case 0x84:case 0x85:case 0x86:case 0x87:
+                                                *substream=*substream-0x80;
+                                                break;
+                                // PCM
+                                        case 0xA0:case 0xA1:case 0xa2:case 0xa3:
+                                        case 0xA4:case 0xA5:case 0xa6:case 0xa7:
+                                                // we have an additionnal header
+                                                // of 3 bytes
+                                                _file-&gt;forward(3);
+                                                size-=3;
+                                                break;
+                                // Subs
+                                case 0x20:case 0x21:case 0x22:case 0x23:
+                                case 0x24:case 0x25:case 0x26:case 0x27:
+                                                break;
+                             
+                                default:
+                                                doNoComplainAnyMore++;
+                                                if(doNoComplainAnyMore&lt;10)
+                                                    printf(&quot;[DmxPS]Unkown substream %x\n&quot;,*substream);
+                                                *substream=0xff;
+                                }
+                                // skip audio header (if not sub)
+                                if(*substream&gt;0x26 || *substream&lt;0x20)
+                                {
+                                        _file-&gt;forward(3);
+                                        size-=3;
+                                }
+                                size--;
+                        }
+                }
+               //    printf(&quot; pid %x size : %x len %x\n&quot;,sid,size,len);
+                *olen=size;
+                return 1;
+        }
+//----------------------------------------------------------------------------------------------                
+//-------------------------------MPEG-1 PES packet style----------------------                                  
+//----------------------------------------------------------------------------------------------                                        
+           if(0) //_muxTypeMpeg2)
+                {
+                        printf(&quot;[DmxPS]*** packet type 1 inside type 2 ?????*****\n&quot;);
+                        return 0; // mmmm                       
+                }
+          // now look at  STD buffer size if present
+          // 01xxxxxxxxx
+          if ((c&gt;&gt;6) == 1) 
+          {       // 01
+                        size-=2;
+                        _file-&gt;read8i();                       // skip one byte
+                        c=_file-&gt;read8i();   // then another
+           }                       
+           // PTS/DTS
+           switch(c&gt;&gt;4)
+           {
+                case 2:
+                {
+                        // 0010 xxxx PTS only
+                        uint64_t pts1,pts2,pts0;
+                                        size -= 4;
+                                        pts0=(c&gt;&gt;1) &amp;7;
+                                        pts1=_file-&gt;read16i()&gt;&gt;1;
+                                        pts2=_file-&gt;read16i()&gt;&gt;1;
+                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
+                                        break;
+                  }
+                  case 3:
+                  {               // 0011 xxxx
+                        uint64_t pts1,pts2,pts0;
+                                        size -= 9;
+                                                                        
+                                        pts0=(c&gt;&gt;1) &amp;7;
+                                        pts1=_file-&gt;read16i()&gt;&gt;1;
+                                        pts2=_file-&gt;read16i()&gt;&gt;1;
+                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
+                                        _file-&gt;forward(5);
+                   }                                                               
+                   break;
+                   
+                case 1:
+                        // 0001 xxx             
+                        // PTSDTS=01 not allowed                        
+                                return 0;
+                                break; 
+                }
+                                                                
+
+                if(!align)      
+                        size--;         
+        *olen=size;
+        return 1;
+}
+//************************************************************************************
+
+#define ADM_PACKET_LINEAR 10*1024
+/**
+    \fn psPacket
+*/
+psPacketLinear::psPacketLinear(uint8_t pid) : psPacket()
+{
+    oldStartAt=startAt=0xfffffff;
+    oldBufferLen=bufferLen=0;
+    bufferIndex=0;
+    myPid=pid;
+    eof=false;
+}
+/**
+    \fn ~psPacket
+*/
+psPacketLinear::~psPacketLinear() 
+{
+}
+/**
+    \fn refill
+*/
+bool psPacketLinear::refill(void) 
+{
+// In case a startcode spawns across 2 packets
+// we have to keep track of the old one
+        oldBufferDts=bufferDts;
+        oldBufferPts=bufferPts;
+        oldStartAt=startAt;
+        oldBufferLen=bufferLen;
+        if( false== getPacketOfType(myPid,ADM_PACKET_LINEAR, &amp;bufferLen,&amp;bufferPts,&amp;bufferDts,buffer,&amp;startAt)) 
+        {
+            printf(&quot;[PsPacketLinear] Refill failed for pid :%x\n&quot;,myPid);
+            bufferIndex=bufferLen=0;
+            return false;
+        }
+        //printf(&quot;Refill : At :%&quot;LLX&quot; size :%&quot;LD&quot;\n&quot;,startAt,bufferLen);
+        bufferIndex=0;
+        return true;
+}
+/**
+    \fn readi8
+*/
+uint8_t psPacketLinear::readi8(void)
+{
+    consumed++;
+    if(bufferIndex&lt;bufferLen)
+    {
+        return buffer[bufferIndex++];
+    }
+    if(false==refill()) 
+    {
+        eof=1;
+        return 0;
+    }
+    ADM_assert(bufferLen);
+    bufferIndex=1;
+    return buffer[0];
+    
+}
+/**
+    \fn readi16
+*/
+uint16_t psPacketLinear::readi16(void)
+{
+    if(bufferIndex+1&lt;bufferLen)
+    {
+        uint16_t v=(buffer[bufferIndex]&lt;&lt;8)+buffer[bufferIndex+1];;
+        bufferIndex+=2;
+        consumed+=2;
+        return v;
+    }
+    return (readi8()&lt;&lt;8)+readi8();
+}
+/**
+    \fn readi32
+*/
+uint32_t psPacketLinear::readi32(void)
+{
+    if(bufferIndex+3&lt;bufferLen)
+    {
+        uint8_t *p=buffer+bufferIndex;
+        uint32_t v=(p[0]&lt;&lt;24)+(p[1]&lt;&lt;16)+(p[2]&lt;&lt;8)+p[3];
+        bufferIndex+=4;
+        consumed+=4;
+        return v;
+    }
+    return (readi16()&lt;&lt;16)+readi16();
+}
+/**
+    \fn forward
+*/
+bool psPacketLinear::forward(uint32_t v)
+{
+next:
+ uint32_t delta=bufferLen-bufferIndex;
+    if(v&gt;100*1000)
+    {
+        ADM_assert(0);
+    }
+    if(v&lt;=delta)
+    {
+        bufferIndex+=v;
+        consumed+=v;
+        return true;
+    }
+    // v&gt;delta
+    v-=delta;
+    if(!refill()) return false;
+    goto next;
+}
+
+/**
+    \fn bool    read(uint32_t len, uint8_t *buffer);
+    \brief
+*/
+bool    psPacketLinear::read(uint32_t len, uint8_t *out)
+{
+    // Enough already ?
+    while(len)
+    {
+        uint32_t avail=bufferLen-bufferIndex;
+        uint32_t chunk=avail;
+        if(chunk&gt;len) chunk=len;
+#if 0
+        printf(&quot;len:%ld avail:%ld chunk %ld index:%d size:%d\n&quot;,
+                len,avail,chunk,bufferIndex,bufferLen);
+#endif
+        memcpy(out,buffer+bufferIndex,chunk);
+        bufferIndex+=chunk;
+        len-=chunk;
+        out+=chunk;
+        consumed+=chunk;
+        if(bufferIndex==bufferLen)
+        {
+            //printf(&quot;Refill\n&quot;);
+            if(false==refill()) return false;
+        }
+    }
+    return true;
+}
+/**
+        \fn getInfo
+        \brief Returns info about the current (or previous if it spawns) packet.
+            It is expected that the caller will do -4 to the index to get the start of the 
+            startCode
+*/
+bool    psPacketLinear::getInfo(dmxPacketInfo *info)
+{
+    if(bufferIndex&lt;4)
+    {
+        info-&gt;startAt=this-&gt;oldStartAt;
+        info-&gt;offset=oldBufferLen+bufferIndex;
+        info-&gt;pts=oldBufferPts;
+        info-&gt;dts=oldBufferDts;
+
+    }else
+    {
+        info-&gt;startAt=this-&gt;startAt;
+        info-&gt;offset=bufferIndex;
+        info-&gt;pts=bufferPts;
+        info-&gt;dts=bufferDts;
+    }
+    return true;
+
+};
+/**
+    \fn seek
+    \brief Async jump
+*/
+bool    psPacketLinear::seek(uint64_t packetStart, uint32_t offset)
+{
+    if(!_file-&gt;setpos(packetStart))
+    {
+        printf(&quot;[psPacket] Cannot seek to %&quot;LLX&quot;\n&quot;,packetStart);
+        return 0;
+    }
+    if(!refill())
+    {
+        printf(&quot;[PsPacketLinear] Seek to %&quot;LLX&quot;:%&quot;LX&quot; failed\n&quot;,packetStart,offset);
+        return false;
+    }
+    ADM_assert(offset&lt;bufferLen);
+    bufferIndex=offset;
+    
+    return true;
+}
+/**
+    \fn getConsumed
+    \brief returns the # of bytes consumed since the last call
+*/
+uint32_t psPacketLinear::getConsumed(void)
+{
+    uint32_t c=consumed;
+    consumed=0;
+    return c;
+}
+/**
+    \fn changePid
+    \brief change the pid of the stream we read (used when probing all tracks)
+*/
+bool    psPacketLinear::changePid(uint32_t pid) 
+{
+    myPid=(pid&amp;0xff);
+    bufferLen=bufferIndex=0;
+    return true;
+}
+/* ********************************************************* */
+/**
+    \fn psPacketLinearTracker
+*/
+ psPacketLinearTracker::psPacketLinearTracker(uint8_t pid)  : psPacketLinear(pid)
+{
+   resetStats();
+}
+/**
+    \fn ~psPacketLinearTracker
+*/
+psPacketLinearTracker::~psPacketLinearTracker()
+{
+
+    
+}
+/**
+        \fn getStat
+*/
+packetStats    *psPacketLinearTracker::getStat(int index)
+{   
+    if(index&lt;0 || index&gt;=256) ADM_assert(0);
+    return stats+index;
+}
+/**
+    \fn getPacketgetPacketOfType
+    \brief Keep track of all the packets we have seen so far.
+    Usefull to detect the streams present and to look up the PTS/DTS of audio streams for the audio part of the index
+*/
+bool           psPacketLinearTracker::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
+{
+ bool xit=false;
+    uint8_t tmppid;
+    while(1)
+    {
+        if(true!=getPacket(maxSize,&amp;tmppid,packetSize,pts,dts,buffer,startAt))
+                return false;
+        else
+        {
+                // Update 
+                ADM_assert(tmppid&lt;0x100);
+                packetStats *p=stats+tmppid;
+                uint64_t ts=*pts;
+                if(ts==ADM_NO_PTS) ts=*dts;
+                if(ts!=ADM_NO_PTS)
+                {
+                    p-&gt;startCount=p-&gt;count;
+                    p-&gt;startAt=*startAt;
+                    p-&gt;startSize=p-&gt;size;
+                    p-&gt;startDts=ts;
+                }
+                p-&gt;count++;
+                p-&gt;size+=*packetSize;
+                if(tmppid==pid) return true;
+        }
+    }
+    return false;
+}
+/**
+    \fn resetStats
+*/
+bool           psPacketLinearTracker::resetStats(void)
+{
+    memset(stats,0,sizeof(stats));
+    for(int i=0;i&lt;256;i++)
+    {
+        packetStats *p=stats+i;
+        p-&gt;startDts=ADM_NO_PTS;
+    }
+}
+//EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/CMakeLists.txt	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/CMakeLists.txt	2009-04-07 05:39:51 UTC (rev 4723)
@@ -4,4 +4,5 @@
 ADD_SUBDIRECTORY(Matroska)
 ADD_SUBDIRECTORY(OpenDml)
 ADD_SUBDIRECTORY(MpegPS)
+ADD_SUBDIRECTORY(MpegTS)
 #

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,353 @@
+/***************************************************************************
+    copyright            : (C) 2007/2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+    
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_indexFile.h&quot;
+#include &quot;ADM_ps.h&quot;
+
+#include &lt;math.h&gt;
+
+uint32_t ADM_UsecFromFps1000(uint32_t fps1000);
+
+/**
+      \fn open
+      \brief open the flv file, gather infos and build index(es).
+*/
+
+uint8_t psHeader::open(const char *name)
+{
+    char idxName[strlen(name)+4];
+    bool r=false;
+    FP_TYPE appendType=FP_DONT_APPEND;
+    uint32_t append;
+    char *type;
+    uint64_t startDts;
+
+    sprintf(idxName,&quot;%s.idx&quot;,name);
+    indexFile index;
+    if(!index.open(idxName))
+    {
+        printf(&quot;[psDemux] Cannot open index file %s\n&quot;,idxName);
+        return false;
+    }
+    if(!index.readSection(&quot;System&quot;))
+    {
+        printf(&quot;[psDemux] Cannot read system section\n&quot;);
+        goto abt;
+    }
+    type=index.getAsString(&quot;Type&quot;);
+    if(!type || type[0]!='P')
+    {
+        printf(&quot;[psDemux] Incorrect or not found type\n&quot;);
+        goto abt;
+    }
+    append=index.getAsUint32(&quot;Append&quot;);
+    printf(&quot;[psDemux] Append=%&quot;LU&quot;\n&quot;,append);
+    if(append) appendType=FP_APPEND;
+    if(!parser.open(name,&amp;appendType))
+    {
+        printf(&quot;[psDemux] Cannot open root file\n&quot;,name);
+        goto abt;
+    }
+    if(!readVideo(&amp;index)) 
+    {
+        printf(&quot;[psDemux] Cannot read Video section of %s\n&quot;,idxName);
+        goto abt;
+    }
+    if(!readAudio(&amp;index,name)) 
+    {
+        printf(&quot;[psDemux] Cannot read Audio section of %s =&gt; No audio\n&quot;,idxName);
+    }
+    if(!readIndex(&amp;index))
+    {
+        printf(&quot;[psDemux] Cannot read index for file %s\n&quot;,idxName);
+        goto abt;
+    }
+    updatePtsDts();
+    _videostream.dwLength= _mainaviheader.dwTotalFrames=ListOfFrames.size();
+    printf(&quot;[psDemux] Found %d video frames\n&quot;,_videostream.dwLength);
+    if(_videostream.dwLength)_isvideopresent=1;
+//***********
+    
+    psPacket=new psPacketLinear(0xE0);
+    if(psPacket-&gt;open(name,appendType)==false) 
+    {
+        printf(&quot;psDemux] Cannot psPacket open the file\n&quot;);
+        goto abt;
+    }
+    r=true;
+    for(int i=0;i&lt;listOfAudioTracks.size();i++)
+    {
+        ADM_psTrackDescriptor *desc=listOfAudioTracks[i];
+        ADM_audioStream *audioStream=ADM_audioCreateStream(&amp;desc-&gt;header,desc-&gt;access);
+        if(!audioStream)
+        {
+            
+        }else       
+        {
+                desc-&gt;stream=audioStream;
+        }
+    }
+abt:
+    index.close();
+    printf(&quot;[psDemuxer] Loaded %d\n&quot;,r);
+    return r;
+}
+/**
+        \fn getVideoDuration
+        \brief Returns duration of video in us
+*/
+uint64_t psHeader::getVideoDuration(void)
+{
+    float f;
+        f=1000*1000*1000;
+        f/=_videostream.dwRate; // in uss
+        
+        f*=ListOfFrames.size();
+     return (uint64_t)f;
+}
+
+
+/**
+    \fn getAudioInfo
+    \brief returns wav header for stream i (=0)
+*/
+WAVHeader *psHeader::getAudioInfo(uint32_t i )
+{
+        if(!listOfAudioTracks.size()) return NULL;
+      ADM_assert(i&lt;listOfAudioTracks.size());
+      return listOfAudioTracks[i]-&gt;stream-&gt;getInfo();
+      
+}
+/**
+   \fn getAudioStream
+*/
+
+uint8_t   psHeader::getAudioStream(uint32_t i,ADM_audioStream  **audio)
+{
+    if(!listOfAudioTracks.size())
+    {
+            *audio=NULL;
+            return true;
+    }
+  ADM_assert(i&lt;listOfAudioTracks.size());
+  *audio=listOfAudioTracks[i]-&gt;stream;
+  return true; 
+}
+/**
+    \fn getNbAudioStreams
+
+*/
+uint8_t   psHeader::getNbAudioStreams(void)
+{
+ 
+  return listOfAudioTracks.size(); 
+}
+/*
+    __________________________________________________________
+*/
+
+void psHeader::Dump(void)
+{
+ 
+}
+/**
+    \fn close
+    \brief cleanup
+*/
+
+uint8_t psHeader::close(void)
+{
+    // Destroy index
+    while(ListOfFrames.size())
+    {
+        delete ListOfFrames[0];
+        ListOfFrames.erase(ListOfFrames.begin());
+    }
+    if(psPacket)
+    {
+        psPacket-&gt;close();
+        delete psPacket;
+        psPacket=NULL;
+    }
+}
+/**
+    \fn psHeader
+    \brief constructor
+*/
+
+ psHeader::psHeader( void ) : vidHeader()
+{ 
+    interlaced=false;
+    lastFrame=0xffffffff;
+    
+}
+/**
+    \fn psHeader
+    \brief destructor
+*/
+
+ psHeader::~psHeader(  )
+{
+  close();
+}
+
+
+/**
+    \fn setFlag
+    \brief Returns timestamp in us of frame &quot;frame&quot; (PTS)
+*/
+
+  uint8_t  psHeader::setFlag(uint32_t frame,uint32_t flags)
+{
+   
+     uint32_t f=2;
+     if(flags &amp; AVI_KEY_FRAME) f=1;
+     if(flags &amp; AVI_B_FRAME) f=3;
+     if(frame&gt;=ListOfFrames.size()) return 0;
+      ListOfFrames[frame]-&gt;type=f;
+    return 1;
+}
+/**
+    \fn getFlags
+    \brief Returns timestamp in us of frame &quot;frame&quot; (PTS)
+*/
+
+uint32_t psHeader::getFlags(uint32_t frame,uint32_t *flags)
+{
+    if(frame&gt;=ListOfFrames.size()) return 0;
+    uint32_t f=ListOfFrames[frame]-&gt;type;
+    switch(f)
+    {
+        case 1: *flags=AVI_KEY_FRAME;break;
+        case 2: *flags=0;break;
+        case 3: *flags=AVI_B_FRAME;break;
+    }
+    return  1;
+}
+
+/**
+    \fn getTime
+    \brief Returns timestamp in us of frame &quot;frame&quot; (PTS)
+*/
+uint64_t psHeader::getTime(uint32_t frame)
+{
+   if(frame&gt;=ListOfFrames.size()) return 0;
+    uint64_t pts=ListOfFrames[frame]-&gt;pts;
+    return pts;
+}
+/**
+    \fn timeConvert
+    \brief FIXME
+*/
+uint64_t psHeader::timeConvert(uint64_t x)
+{
+    if(x==ADM_NO_PTS) return ADM_NO_PTS;
+    x=x-ListOfFrames[0]-&gt;dts;
+    x=x*1000;
+    x/=90;
+    return x;
+
+}
+/**
+        \fn getFrame
+*/
+
+uint8_t  psHeader::getFrame(uint32_t frame,ADMCompressedImage *img)
+{
+    if(frame&gt;=ListOfFrames.size()) return 0;
+    dmxFrame *pk=ListOfFrames[frame];
+    if(frame==(lastFrame+1) &amp;&amp; pk-&gt;type!=1)
+    {
+        lastFrame++;
+        bool r=psPacket-&gt;read(pk-&gt;len,img-&gt;data);
+             img-&gt;dataLength=pk-&gt;len;
+             img-&gt;demuxerFrameNo=frame;
+             img-&gt;demuxerDts=pk-&gt;dts;
+             img-&gt;demuxerPts=pk-&gt;pts;
+             //printf(&quot;[&gt;&gt;&gt;] %d:%02x %02x %02x %02x\n&quot;,frame,img-&gt;data[0],img-&gt;data[1],img-&gt;data[2],img-&gt;data[3]);
+             getFlags(frame,&amp;(img-&gt;flags));
+             return r;
+    }
+    if(pk-&gt;type==1)
+    {
+        if(!psPacket-&gt;seek(pk-&gt;startAt,pk-&gt;index)) return false;
+         bool r=psPacket-&gt;read(pk-&gt;len,img-&gt;data);
+             img-&gt;dataLength=pk-&gt;len;
+             img-&gt;demuxerFrameNo=frame;
+             img-&gt;demuxerDts=pk-&gt;dts;
+             img-&gt;demuxerPts=pk-&gt;pts;
+             getFlags(frame,&amp;(img-&gt;flags));
+             //printf(&quot;[&gt;&gt;&gt;] %d:%02x %02x %02x %02x\n&quot;,frame,img-&gt;data[0],img-&gt;data[1],img-&gt;data[2],img-&gt;data[3]);
+             lastFrame=frame;
+             return r;
+
+    }
+    printf(&quot; [PsDemux] lastFrame :%d this frame :%d\n&quot;,lastFrame,frame);
+    return false;
+}
+/**
+        \fn getExtraHeaderData
+*/
+uint8_t  psHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
+{
+                *len=0; //_tracks[0].extraDataLen;
+                *data=NULL; //_tracks[0].extraData;
+                return true;            
+}
+
+/**
+      \fn getFrameSize
+      \brief return the size of frame frame
+*/
+uint8_t psHeader::getFrameSize (uint32_t frame, uint32_t * size)
+{
+    if(frame&gt;=ListOfFrames.size()) return 0;
+    *size=ListOfFrames[frame]-&gt;len;
+    return true;
+}
+
+/**
+    \fn getPtsDts
+*/
+bool    psHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+    if(frame&gt;=ListOfFrames.size()) return false;
+    dmxFrame *pk=ListOfFrames[frame];
+
+    *dts=pk-&gt;dts;
+    *pts=pk-&gt;pts;
+    return true;
+}
+/**
+        \fn setPtsDts
+*/
+bool    psHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+      if(frame&gt;=ListOfFrames.size()) return false;
+    dmxFrame *pk=ListOfFrames[frame];
+
+    pk-&gt;dts=dts;
+    pk-&gt;pts=pts;
+    return true;
+
+
+}
+
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,180 @@
+/***************************************************************************
+                         ADM_PS
+                             -------------------
+    begin                : Mon Jun 3 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+
+
+#ifndef ADM_PS_H
+#define ADM_PS_H
+
+#include &quot;ADM_Video.h&quot;
+#include &quot;ADM_audioStream.h&quot;
+#include &quot;dmx_io.h&quot;
+#include &quot;ADM_indexFile.h&quot;
+#include &quot;dmxPSPacket.h&quot;
+#include &lt;vector&gt;
+using std::vector;
+/**
+    \struct dmxFrame
+*/
+typedef struct 
+{
+    uint64_t  startAt;
+    uint32_t  index;
+    uint8_t   type; // 1=I 2=P 3=B
+    uint64_t  pts;
+    uint64_t  dts;
+    uint32_t  len;
+}dmxFrame;
+/**
+    \struct ADM_psAudioSeekPoint
+    \brief The dts are stored in rescaled us. Warning the low level getpacket is getting absolute 90 khzTick
+*/
+typedef struct
+{            
+      uint64_t position;
+      uint64_t dts;
+      uint32_t size;
+
+}ADM_psAudioSeekPoint;
+
+/**
+    \fn ADM_psAccess
+*/
+class ADM_psAccess : public ADM_audioAccess
+{
+protected:
+                
+                psPacket        demuxer;
+                uint8_t         pid;
+                uint64_t        dtsOffset;
+                
+public:
+                bool            setTimeOffset(uint64_t of) {dtsOffset=of;return true;}
+                vector          &lt;ADM_psAudioSeekPoint &gt;seekPoints;
+                                  ADM_psAccess(const char *name,uint8_t pid,bool append); 
+                virtual           ~ADM_psAccess();
+                                    /// Hint, the stream is pure CBR (AC3,MP2,MP3)
+                virtual bool      isCBR(void) { return true;}
+                                    /// Return true if the demuxer can seek in time
+                virtual bool      canSeekTime(void) {return true;};
+                                    /// Return true if the demuxer can seek by offser
+                virtual bool      canSeekOffset(void) {return false;};
+                                    /// Return true if we can have the audio duration
+                virtual bool      canGetDuration(void) {return true;};
+                                    /// Returns audio duration in us
+                virtual uint64_t  getDurationInUs(void) ;
+                                    /// Go to a given time
+                virtual bool      goToTime(uint64_t timeUs) ;
+                                    /// Get a packet
+                virtual bool      getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts);
+
+                        bool      push(uint64_t at, uint64_t dts,uint32_t size);
+                                    /// Convert raw timestamp to scaled timestamp in us
+                uint64_t          timeConvert(uint64_t x);
+
+                virtual uint32_t  getLength(void);
+
+};
+/**
+    \class ADM_psTrackDescriptor
+*/
+class ADM_psTrackDescriptor
+{
+public:
+        ADM_audioStream *stream;
+        ADM_psAccess    *access;
+        WAVHeader       header;
+        ADM_psTrackDescriptor()
+            {
+                stream=NULL;
+                access=NULL;
+            }
+        ~ADM_psTrackDescriptor()
+            {
+                if(stream) delete stream;
+                stream=NULL;
+                if(access) delete access;
+                access=NULL;
+            }
+
+
+};
+
+/**
+    \Class psHeader
+    \brief mpeg ps demuxer
+
+*/
+class psHeader         :public vidHeader
+{
+  protected:
+    
+    bool    interlaced;
+    bool    readVideo(indexFile *index);
+    bool    readAudio(indexFile *index,const char *name);
+    bool    readIndex(indexFile *index);
+
+    bool    processVideoIndex(char *buffer);
+    bool    processAudioIndex(char *buffer);
+
+    std::vector &lt;dmxFrame *&gt; ListOfFrames;      
+    fileParser      parser;
+    uint32_t       lastFrame;
+    psPacketLinear *psPacket;
+    uint64_t        timeConvert(uint64_t x);
+    bool            updatePtsDts(void);
+protected:
+    vector &lt;ADM_psTrackDescriptor *&gt;listOfAudioTracks;
+  public:
+
+
+    virtual   void          Dump(void);
+
+            psHeader( void ) ;
+   virtual  ~psHeader(  ) ;
+// AVI io
+    virtual uint8_t  open(const char *name);
+    virtual uint8_t  close(void) ;
+  //__________________________
+  //  Info
+  //__________________________
+
+  //__________________________
+  //  Audio
+  //__________________________
+virtual 	WAVHeader              *getAudioInfo(uint32_t i )  ;
+virtual 	uint8_t                 getAudioStream(uint32_t i,ADM_audioStream  **audio);
+virtual     uint8_t                 getNbAudioStreams(void);
+// Frames
+  //__________________________
+  //  video
+  //__________________________
+
+    virtual uint8_t  setFlag(uint32_t frame,uint32_t flags);
+    virtual uint32_t getFlags(uint32_t frame,uint32_t *flags);
+    virtual uint8_t  getFrame(uint32_t framenum,ADMCompressedImage *img);
+    virtual uint64_t getTime(uint32_t frame);
+            uint8_t  getExtraHeaderData(uint32_t *len, uint8_t **data);
+    virtual uint64_t getVideoDuration(void);
+    virtual uint8_t  getFrameSize(uint32_t frame,uint32_t *size) ;
+virtual   bool       getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+virtual   bool       setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
+
+};
+#endif
+
+

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,138 @@
+/***************************************************************************
+    \file ADM_psAudio.cpp
+
+    copyright            : (C) 2006/2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_Video.h&quot;
+
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;ADM_ps.h&quot;
+
+#if 0
+    #define aprintf printf
+#else
+    #define aprintf(...) {}
+#endif
+
+/**
+    \fn ADM_psAccess
+*/
+ADM_psAccess::ADM_psAccess(const char *name,uint8_t pid,bool append)
+{
+FP_TYPE fp=FP_DONT_APPEND;
+        if(append) fp=FP_APPEND;
+        this-&gt;pid=pid;
+        if(!demuxer.open(name,fp)) ADM_assert(0);
+}
+
+/**
+    \fn ~ADM_psAccess
+*/
+ADM_psAccess::~ADM_psAccess()
+{
+    demuxer.close();
+}
+/**
+    \fn push
+    \brief add a seek point.
+*/
+bool      ADM_psAccess::push(uint64_t at, uint64_t dts,uint32_t size)
+{
+ADM_psAudioSeekPoint s;
+            s.position=at;
+            s.dts=dts;
+            s.size=size;
+            seekPoints.push_back(s);
+            return true;
+}
+/**
+    \fn getLength
+*/
+uint32_t  ADM_psAccess::getLength(void)
+{
+  return (seekPoints[seekPoints.size()-1].size);
+
+}
+/**
+    \fn getDurationInUs
+*/
+uint64_t  ADM_psAccess::getDurationInUs(void)
+{
+    // Take last seek point; should be accurate enough
+    return timeConvert(seekPoints[seekPoints.size()-1].dts);
+}
+/**
+    \fn goToTime
+    \brief Rememember seekPoint.dts time is already scaled and in us
+*/                              
+bool      ADM_psAccess::goToTime(uint64_t timeUs)
+{
+    // Convert time in us to scaled 90 kHz tick
+    
+    if(timeUs&lt;seekPoints[0].dts)
+    {
+            aprintf(&quot;[PsAudio] Requested %&quot;LU&quot; tick before 1st seek point at :%&quot;LU&quot;\n&quot;,(uint32_t)timeUs/1000,(uint32_t)seekPoints[0].dts/1000);
+            demuxer.setPos(seekPoints[0].position);
+            return true;
+    }
+
+    for(int i=1;i&lt;seekPoints.size();i++)
+    {
+        if(seekPoints[i].dts &gt;=timeUs )
+        {
+            aprintf(&quot;[PsAudio] Requested %&quot;LU&quot; tick seeking to  at :%&quot;LU&quot; us (next is %&quot;LU&quot;ms \n&quot;,(uint32_t)timeUs/1000,
+                    (uint32_t)seekPoints[i-1].dts/1000,
+                    (uint32_t)seekPoints[i].dts/1000);
+            demuxer.setPos(seekPoints[i-1].position);
+            return true;
+        }
+    }
+    return false;
+}
+/**
+    \fn timeConvert
+    \brief Convert time in ticks raw from the stream to avidemux time in us starting from the beginning of the file
+*/
+uint64_t ADM_psAccess::timeConvert(uint64_t x)
+{
+    if(x==ADM_NO_PTS) return ADM_NO_PTS;
+    x=x-dtsOffset;
+    x=x*1000;
+    x/=90;
+    return x;
+
+}
+/**
+    \fn getPacket
+*/
+bool      ADM_psAccess::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
+{
+uint64_t p,d,start;
+    if(false==demuxer.getPacketOfType(pid,maxSize,size,&amp;p,&amp;d,buffer,&amp;start)) return false;
+    if(d==ADM_NO_PTS) *dts=p;
+            else *dts=d;
+    *dts=timeConvert(*dts);
+    if(*dts!=ADM_NO_PTS) 
+    {
+        aprintf(&quot;[psAudio] getPacket dts = %&quot;LU&quot; ms\n&quot;,(uint32_t)*dts/1000);
+    }
+
+    return true;
+}
+
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,234 @@
+/**
+    \file ADM_psAudioProbe.cpp
+    \brief Handle index file reading
+    copyright            : (C) 2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_audiodef.h&quot;
+#include &quot;dmxPSPacket.h&quot;
+#include &quot;ADM_psAudioProbe.h&quot;
+//
+#include &quot;ADM_a52info.h&quot;
+#include &quot;ADM_mp3info.h&quot;
+#include &quot;ADM_dcainfo.h&quot;
+// Number of video packet seen to be enough to sample the audio tracks
+#define PROBE_PACKET_VIDEO_COUNT 500
+// Max size of a packet. Usually it is a bit more than 2300, so 10000 should be safe
+#define PACKET_PROBE_SIZE 10000
+// Minimum of packet seen to declare it valid
+#define PROBE_MIN_PACKET 5
+#define PROBE_MIN_SIZE   5000
+
+#define MP2_AUDIO_VALUE 0xC0
+#define LPCM_AUDIO_VALUE 0xA0
+#define DTS_AC3_AUDIO_VALUE 0x00
+
+static bool addAudioTrack(int pid, listOfPsAudioTracks *list, psPacketLinearTracker *p);
+static bool psCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize);
+/**
+    \fn listOfPsAudioTracks
+    \brief returns a list of audio track found, null if none found
+
+*/
+listOfPsAudioTracks *psProbeAudio(const char *fileName)
+{
+    uint32_t size;
+    uint64_t dts,pts,startAt;
+    uint8_t buffer[PACKET_PROBE_SIZE];
+    uint64_t fileSize;
+
+    listOfPsAudioTracks *tracks=new listOfPsAudioTracks;
+    psPacketLinearTracker *packet=new psPacketLinearTracker(0xE0);
+
+    printf(&quot;[MpegPS] Probing audio for %s\n&quot;,fileName);
+
+    if(!packet-&gt;open(fileName,FP_APPEND)) goto end;
+    fileSize=packet-&gt;getSize();
+
+    packet-&gt;setPos(fileSize/2); // Jump in the middle of the stream
+
+    while(packet-&gt;getPacketOfType(0xE0,PACKET_PROBE_SIZE,&amp;size,&amp;dts,&amp;pts,buffer,&amp;startAt))
+    {
+        packetStats *stat=packet-&gt;getStat(0xE0);
+        if(stat-&gt;count &gt; PROBE_PACKET_VIDEO_COUNT)
+                break;
+    }
+    // Now synthetize
+    for(int i=0x0;i&lt;0xFF;i++)   
+    {
+        packetStats *stat=packet-&gt;getStat(i);
+        if(stat-&gt;count)
+        {
+            printf(&quot;[PsProbeAudo] Pid:%x count:%&quot;LX&quot; size:%&quot;LD&quot;\n&quot;,i,stat-&gt;count,stat-&gt;size);
+        }
+
+         if(stat-&gt;count&gt;=PROBE_MIN_PACKET &amp;&amp; stat-&gt;size&gt;PROBE_MIN_SIZE)
+         {
+                packet-&gt;setPos(fileSize/2); 
+                addAudioTrack(i,tracks,packet);
+         }
+
+    }
+
+end:
+    printf(&quot;[PsDemux] Audio probe done, found %lu tracks\n&quot;,tracks-&gt;size());
+    delete packet;
+    
+    if(tracks-&gt;size()==0) 
+    {   
+        delete tracks;
+        return NULL;
+    }
+    return tracks;
+}
+/**
+    \fn addAudioTrack
+    \brief gather information about audio &amp; add audio track to the list
+
+*/
+bool addAudioTrack(int pid, listOfPsAudioTracks *list, psPacketLinearTracker *p)
+{
+#define PROBE_ANALYZE_SIZE 6000 // Should be enough in all cases (need ~ 2 blocks)
+uint8_t audioBuffer[PROBE_ANALYZE_SIZE];
+        uint64_t pts,dts,startAt;
+        uint32_t packetSize;
+
+        //
+        int masked=pid&amp;0xF0;
+        if(masked!=MP2_AUDIO_VALUE &amp;&amp;  // MP2
+            masked!=LPCM_AUDIO_VALUE &amp;&amp; // PCM
+            masked!=DTS_AC3_AUDIO_VALUE  // AC3 &amp; DTS
+            ) return false;
+
+        // Go back where we were
+        p-&gt;changePid(pid); 
+        p-&gt;getPacketOfType(pid,PROBE_ANALYZE_SIZE, &amp;packetSize,&amp;pts,&amp;dts,audioBuffer,&amp;startAt);
+        //Realign
+        p-&gt;seek(startAt,0);
+        int rd=PROBE_ANALYZE_SIZE;
+        if(!p-&gt;read(PROBE_ANALYZE_SIZE,audioBuffer))
+            return false;
+        psAudioTrackInfo *info=new psAudioTrackInfo;
+        info-&gt;esID=pid;
+        uint32_t fq,br,chan,off;
+        switch(pid &amp; 0xF0)
+        {
+            case LPCM_AUDIO_VALUE: // LPCM
+                            info-&gt;header.frequency=48000;
+                            info-&gt;header.channels=2;
+                            info-&gt;header.byterate=48000*4;
+                            info-&gt;header.encoding=WAV_LPCM;
+                            break;
+            case MP2_AUDIO_VALUE: // MP2
+                            {
+                                if(! psCheckMp2Audio(&amp;(info-&gt;header),audioBuffer,rd))
+                                {
+                                    printf(&quot;[PsProbeAudio] Failed to get info on track :%x (MP2)\n&quot;,pid);
+                                    goto er;
+                                }
+                            }
+                            break;
+            case DTS_AC3_AUDIO_VALUE: // AC3 or DTS
+                            if(pid&gt;=0x8) // DTS
+                            {
+                                info-&gt;header.encoding=WAV_DTS;
+                                uint32_t flags,nbSample;
+                                if(!ADM_DCAGetInfo(audioBuffer, rd, &amp;fq, &amp;br, &amp;chan,&amp;off,&amp;flags,&amp;nbSample))
+                                {
+                                        printf(&quot;[PsProbeAudio] Failed to get info on track :%x\n&quot;,pid);
+                                        goto er;
+                                }
+                                info-&gt;header.frequency=fq;
+                                info-&gt;header.channels=chan;
+                                info-&gt;header.byterate=(br);
+                                break;
+                            }else // AC3
+                            {
+                                info-&gt;header.encoding=WAV_AC3;
+                                if(!ADM_AC3GetInfo(audioBuffer, rd, &amp;fq, &amp;br, &amp;chan,&amp;off))
+                                {
+                                        printf(&quot;[PsProbeAudio] Failed to get info on track :%x\n&quot;,pid);
+                                        goto er;
+                                }
+                                info-&gt;header.frequency=fq;
+                                info-&gt;header.channels=chan;
+                                info-&gt;header.byterate=(br);
+                                break;
+                            }
+                            
+            default:
+                        ADM_assert(0);
+
+        }
+        list-&gt;push_back(info);
+        return true;
+er:
+        delete info;
+        return false;
+}
+/**
+        \fn DestroyListOfPsAudioTracks
+        \brief cleanly destroy it
+*/
+bool DestroyListOfPsAudioTracks(listOfPsAudioTracks *list)
+{
+    while( list-&gt;size())
+    {
+        delete (*list)[0];
+        list-&gt;erase(list-&gt;begin());
+    }
+    delete list;
+    return true;
+}
+/**
+    \fn psCheckMp2Audio
+    \brief Wait to have 2 audio packets to make sure it is not a false detection (that happens with mp2/mp3 audio)
+*/
+bool psCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize)
+{
+    MpegAudioInfo mpeg,first;
+    uint32_t off2,off;
+
+    hdr-&gt;encoding=WAV_MP2;
+again:
+    if(!getMpegFrameInfo(data, dataSize, &amp;first,NULL,&amp;off))
+    {
+            return false;
+    }
+    if(dataSize&lt;(off+first.size))
+    {
+        return false;
+    }
+    if(!getMpegFrameInfo(data+off+first.size, dataSize-off-first.size, &amp;mpeg,NULL,&amp;off2))
+    {
+            return false;
+    }
+    if(off2) // false detectio ?
+    {
+        printf(&quot;[psAudioProbe] Mp2 : False MP2 header at %&quot;LU&quot;\n&quot;,off);
+        if(dataSize&lt;4) return false;
+        data+=3;
+        dataSize-=3;
+        goto again;
+    }
+    hdr-&gt;frequency=mpeg.samplerate;
+    if(mpeg.mode==3)
+        hdr-&gt;channels=1;
+    else
+        hdr-&gt;channels=2;
+    hdr-&gt;byterate=(mpeg.bitrate*1000)&gt;&gt;3;
+    return true;
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,34 @@
+/**
+    \file ADM_psAudioProbe.h
+    \brief Probe audio tracks by brute force analysus of the file
+    copyright            : (C) 2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_PS_AUDIO_PROBE_H
+#define ADM_PS_AUDIO_PROBE_H
+#include &lt;vector&gt;
+using std::vector;
+typedef struct
+{
+    WAVHeader header;
+    uint8_t   esID;
+}psAudioTrackInfo;
+
+typedef vector &lt;psAudioTrackInfo*&gt; listOfPsAudioTracks;
+
+/// Returns a list of audio tracks found in the file.
+listOfPsAudioTracks *psProbeAudio(const char *fileName);
+bool DestroyListOfPsAudioTracks(listOfPsAudioTracks *list);
+
+
+#endif
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,181 @@
+/**
+    \fn ComputeTimeStamp
+    \brief Compute and fill the missing PTS/DTS
+
+*/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_indexFile.h&quot;
+#include &quot;ADM_ps.h&quot;
+
+#include &lt;math.h&gt;
+
+#define DMX_RECOMPUTE_PTS_DTS_MAX 20
+
+#if 1
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+/**
+        \fn updatePtsDts
+        \brief Update the PTS/DTS
+
+TODO / FIXME : Handle wrap
+TODO / FIXME : Handle PTS reordering 
+*/
+
+bool psHeader::updatePtsDts(void)
+{
+        uint64_t lastDts=0,lastPts=0,dtsIncrement=0;
+
+
+        // For audio, The first packet in the seekpoints happens a bit after the action
+        // It means some audio may have been seen since we locked on video.
+        // So we compute the DTS of the first real packet
+        // by using the size field and byterate and arbitrarily make it begins
+        // at video
+        for(int i=0;i&lt;listOfAudioTracks.size();i++)
+        {
+            vector          &lt;ADM_psAudioSeekPoint &gt; *seekPoints=&amp;(listOfAudioTracks[i]-&gt;access-&gt;seekPoints);
+            uint64_t secondDts=(*seekPoints)[0].dts;
+            uint64_t secondSize=(*seekPoints)[0].size;
+            if(secondSize &amp;&amp; listOfAudioTracks[i]-&gt;header.byterate)
+            {
+                    // it is actually an offset in time to the 2nd packet Dts
+                double  firstFloatDts=secondSize*1000*1000.; 
+                        firstFloatDts/=listOfAudioTracks[i]-&gt;header.byterate; // in us
+                uint64_t firstDts=(uint64_t)firstFloatDts;
+
+                        if(firstDts&gt;secondDts) firstDts=0;
+                            else firstDts=secondDts-firstDts;
+
+                // Now add our seek point
+                ADM_psAudioSeekPoint sk;
+                sk.dts=firstDts;
+                sk.size=0;
+                sk.position=ListOfFrames[0]-&gt;startAt;
+                (*seekPoints).insert( (*seekPoints).begin(),sk);
+
+            }
+        }
+
+
+        // Make sure everyone starts at 0
+        // Search first timestamp (audio/video)
+
+        switch( _videostream.dwRate)
+        {
+            case 25000:   dtsIncrement=40000;break;
+            case 23976:   dtsIncrement=41708;break;
+            case 29970:   dtsIncrement=33367;break;
+            default : dtsIncrement=1;
+                    printf(&quot;[psDemux] Fps not handled for DTS increment\n&quot;);
+
+        }
+        uint64_t startDts=ListOfFrames[0]-&gt;dts;
+        uint64_t startPts=ListOfFrames[0]-&gt;pts;
+        // Special case when we dont have DTS but only PTS
+        if(startDts==ADM_NO_PTS) // Do we have DTS ?
+        {
+            if(startPts!=ADM_NO_PTS)
+            {
+                if(startPts&gt;=2*dtsIncrement)
+                {
+                    startDts=startPts-2*dtsIncrement;
+                } else startDts=0;
+                ListOfFrames[0]-&gt;dts=startDts;
+            }
+        }
+        for(int i=0;i&lt;listOfAudioTracks.size();i++)
+        {
+            uint64_t a=listOfAudioTracks[i]-&gt;access-&gt;seekPoints[0].dts;
+            if(a&lt;startDts) startDts=a;
+        }
+        // Rescale all so that it starts ~ 0
+        // Video..
+        for(int i=0;i&lt;ListOfFrames.size();i++)
+        {
+            dmxFrame *f=ListOfFrames[i];
+            if(f-&gt;pts!=ADM_NO_PTS) f-&gt;pts-=startDts;
+            if(f-&gt;dts!=ADM_NO_PTS) f-&gt;dts-=startDts;
+        }
+        // Audio start at 0 too
+        for(int i=0;i&lt;listOfAudioTracks.size();i++)
+        {
+            ADM_psTrackDescriptor *track=listOfAudioTracks[i];
+            ADM_psAccess    *access=track-&gt;access;
+            access-&gt;setTimeOffset(startDts);
+        }
+
+        // Now fill in the missing timestamp and convert to us
+        // for video
+        // We are sure to have both PTS &amp; DTS for 1st image
+        // Guess missing DTS/PTS for video
+        int noUpdate=0;
+        for(int i=0;i&lt;ListOfFrames.size();i++)
+        {
+            dmxFrame *frame=ListOfFrames[i];
+            aprintf(&quot;[psUpdate] frame:%d raw DTS: %&quot;LLD&quot; PTS:%&quot;LLD&quot;\n&quot;,i,frame-&gt;dts,frame-&gt;pts);
+            if(frame-&gt;pts==ADM_NO_PTS || frame-&gt;dts==ADM_NO_PTS)
+            {
+                noUpdate++;
+                // We have PTS or DTS and it has been a long time we did not have both
+                if(noUpdate&gt;DMX_RECOMPUTE_PTS_DTS_MAX &amp;&amp; frame-&gt;type==1 &amp;&amp; (frame-&gt;pts!=ADM_NO_PTS || frame-&gt;dts!=ADM_NO_PTS))
+                {
+                    if(frame-&gt;pts!=ADM_NO_PTS)
+                    {
+                        frame-&gt;dts=frame-&gt;pts-2*dtsIncrement;
+                    }else   
+                    {
+                        frame-&gt;pts=frame-&gt;dts+2*dtsIncrement;
+                    }
+                    uint64_t oldDts=lastDts;
+                    frame-&gt;dts=lastDts=timeConvert(frame-&gt;dts);
+                    frame-&gt;pts=lastPts=timeConvert(frame-&gt;pts);
+                    if(oldDts&gt;lastDts) printf(&quot;[psRead] Warning DTS going backward frame %d, old:%&quot;LLD&quot; new:%&quot;LLD&quot; delta=%&quot;LLD&quot;\n&quot;,
+                                                       i,oldDts/1000,lastDts/1000,(oldDts-lastDts)/1000);
+
+                }else
+                {
+                    lastDts+=dtsIncrement;
+                    lastPts+=dtsIncrement;
+                    frame-&gt;dts=lastDts;
+                    frame-&gt;pts=ADM_NO_PTS;
+                }
+            }else    // We got both, use them  
+            {
+                
+                frame-&gt;dts=lastDts=timeConvert(frame-&gt;dts);
+                frame-&gt;pts=lastPts=timeConvert(frame-&gt;pts);
+            }
+        }
+        // convert to us for Audio tracks (seek points)
+        for(int i=0;i&lt;listOfAudioTracks.size();i++)
+        {
+            ADM_psTrackDescriptor *track=listOfAudioTracks[i];
+            ADM_psAccess    *access=track-&gt;access;
+            
+            for(int j=0;j&lt;access-&gt;seekPoints.size();j++)
+            {
+                if( access-&gt;seekPoints[j].dts!=ADM_NO_PTS) 
+                    access-&gt;seekPoints[j].dts=access-&gt;timeConvert( access-&gt;seekPoints[j].dts);
+            }
+        }
+#if 0
+        for(int i=0;i&lt;ListOfFrames.size();i++)
+        {
+            dmxFrame *frame=ListOfFrames[i];
+            int64_t pts,dts;
+            pts=frame-&gt;pts;
+            dts=frame-&gt;dts;
+            if(pts!=ADM_NO_PTS) pts/=1000;
+            if(dts!=ADM_NO_PTS) dts/=1000;
+            printf(&quot;[psVideo] Framex %d PTS:%&quot;LLD&quot; ms DTS:%&quot;LLD&quot; ms, delta %&quot;LLD&quot; ms\n&quot;,i,pts,dts,pts-dts);
+        }
+#endif
+        return 1;
+                    
+}

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,408 @@
+/***************************************************************************
+                        Mpeg2 in PS indexer                                            
+                             
+    
+    copyright            : (C) 2005/2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_demuxerInternal.h&quot;
+#include &quot;fourcc.h&quot;
+
+#include &quot;dmxPSPacket.h&quot;
+
+#include &quot;avidemutils.h&quot;
+#include &quot;ADM_quota.h&quot;
+#include &quot;ADM_psAudioProbe.h&quot;
+#include &quot;DIA_working.h&quot;
+
+static const char Type[5]={'X','I','P','B','P'};
+
+static const uint32_t FPS[16]={
+                0,                      // 0
+                23976,          // 1 (23.976 fps) - FILM
+                24000,          // 2 (24.000 fps)
+                25000,          // 3 (25.000 fps) - PAL
+                29970,          // 4 (29.970 fps) - NTSC
+                30000,          // 5 (30.000 fps)
+                50000,          // 6 (50.000 fps) - PAL noninterlaced
+                59940,          // 7 (59.940 fps) - NTSC noninterlaced
+                60000,          // 8 (60.000 fps)
+                0,                      // 9
+                0,                      // 10
+                0,                      // 11
+                0,                      // 12
+                0,                      // 13
+                0,                      // 14
+                0                       // 15
+        };
+
+typedef struct
+{
+    uint32_t w;
+    uint32_t h;
+    uint32_t fps;
+    uint32_t interlaced;
+    uint32_t ar;
+}PSVideo;
+
+typedef enum
+{
+    idx_startAtImage,
+    idx_startAtGopOrSeq
+}indexerState;
+typedef struct
+{
+    uint64_t pts,dts,startAt;
+    uint32_t offset;
+    uint32_t frameType;
+    uint32_t nbPics;
+    indexerState state;
+    psPacketLinear *pkt;
+    int32_t        nextOffset;
+}indexerData;
+
+typedef enum
+{
+    markStart,
+    markEnd,
+    markNow
+}markType;
+
+/**
+    \class PsIndexer
+*/
+class PsIndexer
+{
+protected:
+        FILE *index;
+        psPacketLinearTracker *pkt;
+        listOfPsAudioTracks *audioTracks;
+        DIA_workingBase  *ui;
+public:
+                PsIndexer(void);
+                ~PsIndexer();
+        bool    run(const char *file);
+        bool    writeVideo(PSVideo *video);
+        bool    writeAudio(void);
+        bool    writeSystem(const char *filename,bool append);
+        bool    Mark(indexerData *data,dmxPacketInfo *s,markType update);
+
+};
+/**
+      \fn psIndexer 
+      \brief main indexing loop for mpeg2 payload
+*/
+uint8_t   psIndexer(const char *file)
+{
+bool r;
+    PsIndexer *dx=new PsIndexer;
+    r=dx-&gt;run(file);
+    delete dx;
+    return r;
+}
+
+/**
+    \fn PsIndexer
+*/
+PsIndexer::PsIndexer(void)
+{
+    index=NULL;
+    pkt=NULL;
+    audioTracks=NULL;
+    ui=createWorking (&quot;Indexing&quot;);
+}
+
+/**
+    \fn ~PsIndexer
+*/
+PsIndexer::~PsIndexer()
+{
+    if(index) qfclose(index);
+    if(pkt) delete pkt;
+    if( audioTracks) DestroyListOfPsAudioTracks(audioTracks);
+    if(ui) delete ui;
+    ui=NULL;
+}
+/**
+    \fn run
+*/  
+bool PsIndexer::run(const char *file)
+{
+uint32_t temporal_ref,val;
+uint64_t fullSize;
+uint8_t buffer[50*1024];
+bool seq_found=false;
+
+PSVideo video;
+indexerData  data;    
+dmxPacketInfo info;
+
+    memset(&amp;data,0,sizeof(data));
+    char indexName[strlen(file)+5];
+    sprintf(indexName,&quot;%s.idx&quot;,file);
+    index=qfopen(indexName,&quot;wt&quot;);
+    if(!index)
+    {
+        printf(&quot;[PsIndex] Cannot create %s\n&quot;,indexName);
+        return false;
+    }
+    writeSystem(file,true);
+    pkt=new psPacketLinearTracker(0xE0);
+
+    audioTracks=psProbeAudio(file);
+    if(audioTracks)
+    {
+        for(int i=0;i&lt;audioTracks-&gt;size();i++)
+        {
+                printf(&quot;[PsProbe] Found audio Track %d, pid=%x\n&quot;,i,(*audioTracks)[i]-&gt;esID);
+                WAVHeader *hdr=&amp;((*audioTracks)[i]-&gt;header);
+                printf(&quot;[PsProbe] codec    : 0x%x \n&quot;,hdr-&gt;encoding);
+                printf(&quot;[PsProbe] frequency: %&quot;LU&quot; Hz\n&quot;,hdr-&gt;frequency);
+                printf(&quot;[PsProbe] channel  : %&quot;LU&quot; \n&quot;,hdr-&gt;channels);
+                printf(&quot;[PsProbe] byterate : %&quot;LU&quot; Byte/s\n&quot;,hdr-&gt;byterate);
+
+        }
+
+    }
+
+    FP_TYPE append=FP_APPEND;
+    pkt-&gt;open(file,append);
+    data.pkt=pkt;
+    fullSize=pkt-&gt;getSize();
+      while(1)
+      {
+        uint32_t code=0xffff+0xffff0000;
+        while((code&amp;0x00ffffff)!=1 &amp;&amp; pkt-&gt;stillOk())
+        {
+            code=(code&lt;&lt;8)+pkt-&gt;readi8();
+        }
+        if(!pkt-&gt;stillOk()) break;
+        uint8_t startCode=pkt-&gt;readi8();
+
+        pkt-&gt;getInfo(&amp;info);
+        info.offset-=4;
+
+          switch(startCode)
+                  {
+                  case 0xB3: // sequence start
+                          Mark(&amp;data,&amp;info,markStart);
+                          data.state=idx_startAtGopOrSeq;
+                          if(seq_found)
+                          {
+                                  pkt-&gt;forward(8);  // Ignore
+                                  continue;
+                          }
+                          //
+                          seq_found=1;
+                          val=pkt-&gt;readi32();
+                          video.w=val&gt;&gt;20;
+                          video.w=((video.w+15)&amp;~15);
+                          video.h= (((val&gt;&gt;8) &amp; 0xfff)+15)&amp; ~15;
+
+                          video.ar = (val &gt;&gt; 4) &amp; 0xf;
+
+                          
+                          video.fps= FPS[val &amp; 0xf];
+                          pkt-&gt;forward(4);
+                          writeVideo(&amp;video);
+                          writeAudio();
+                          pkt-&gt;resetStats();
+                          qfprintf(index,&quot;[Data]&quot;);
+                          break;
+                  case 0xb8: // GOP
+                          // Update ui
+                            {
+                                float pos=data.startAt;
+                                pos=pos/(float)fullSize;
+                                pos*=100;
+                                ui-&gt;update( (uint32_t)pos);
+
+                            }
+
+                          if(!seq_found) continue;
+                          if(data.state==idx_startAtGopOrSeq) 
+                          {         
+                                  continue;;
+                          }
+                          
+                          Mark(&amp;data,&amp;info,markStart);
+                          data.state=idx_startAtGopOrSeq;
+                          break;
+                  case 0x00 : // picture
+                        {
+                          int type;
+                          markType update=markNow;
+                          if(!seq_found)
+                          { 
+                                  continue;
+                                  printf(&quot;[psIndexer]No sequence start yet, skipping..\n&quot;);
+                          }
+                          
+                          val=pkt-&gt;readi16();
+                          temporal_ref=val&gt;&gt;6;
+                          type=7 &amp; (val&gt;&gt;3);
+                          if( type&lt;1 ||  type&gt;3)
+                          {
+                                  printf(&quot;[Indexer]Met illegal pic at %&quot;LLX&quot; + %&quot;LX&quot;\n&quot;,
+                                                  info.startAt,info.offset);
+                                  continue;
+                          }
+                          
+                          
+                          if(data.state==idx_startAtGopOrSeq) 
+                          {
+                                update=markEnd;
+                          }
+                          data.frameType=type;
+                          Mark(&amp;data,&amp;info,update);
+                          data.state=idx_startAtImage;
+                          data.nbPics++;
+                        }
+                          break;
+                  default:
+                    break;
+                  }
+      }
+    
+        printf(&quot;\n&quot;);
+        Mark(&amp;data,&amp;info,markStart);
+        qfprintf(index,&quot;\n[End]\n&quot;);
+        qfclose(index);
+        index=NULL;
+        if(audioTracks) DestroyListOfPsAudioTracks( audioTracks);
+        audioTracks=NULL;
+        delete pkt;
+        pkt=NULL;
+        return 1; 
+}
+/**
+    \fn   Mark
+    \brief update the file
+
+    The offset part is due to the fact that we read 2 bytes from the pic header to know the pic type.
+    So when going from a pic to a pic, it is self cancelling.
+    If the beginning is not a pic, but a gop start for example, we had to add/remove those.
+
+*/
+bool  PsIndexer::Mark(indexerData *data,dmxPacketInfo *info,markType update)
+{
+    int offset=data-&gt;nextOffset;
+    data-&gt;nextOffset=0;
+    
+     if( update==markStart)
+     {
+                offset=2;
+     }
+    if(update==markStart || update==markNow)
+    {
+        if(data-&gt;nbPics)
+        {
+            // Write previous image data (size) : TODO
+            qfprintf(index,&quot;:%06&quot;LX&quot; &quot;,data-&gt;pkt-&gt;getConsumed()+offset); // Size
+        }
+        else data-&gt;pkt-&gt;getConsumed();
+    }
+    if(update==markEnd || update==markNow)
+    {
+        if(data-&gt;frameType==1)
+        {
+            // If audio, also dump audio
+            if(audioTracks)
+            {
+                qfprintf(index,&quot;\nAudio bf:%08&quot;LLX&quot; &quot;,data-&gt;startAt);
+                for(int i=0;i&lt;audioTracks-&gt;size();i++)
+                {
+                    uint8_t e=(*audioTracks)[i]-&gt;esID;
+                    packetStats *s=pkt-&gt;getStat(e);
+                    
+                    qfprintf(index,&quot;Pes:%x:%08&quot;LLX&quot;:%&quot;LD&quot;:%&quot;LLD&quot; &quot;,e,s-&gt;startAt,s-&gt;startSize,s-&gt;startDts);
+                }
+                
+            }
+            // start a new line
+            qfprintf(index,&quot;\nVideo at:%08&quot;LLX&quot;:%04&quot;LX&quot; Pts:%08&quot;LLD&quot;:%08&quot;LLD&quot; &quot;,data-&gt;startAt,data-&gt;offset,info-&gt;pts,info-&gt;dts);
+            data-&gt;nextOffset=-2;
+        }
+    
+        qfprintf(index,&quot;%c&quot;,Type[data-&gt;frameType]);
+    }
+    if(update==markEnd || update==markNow)
+    {
+        data-&gt;pts=info-&gt;pts;
+        data-&gt;dts=info-&gt;dts;
+    }
+    if(update==markStart || update==markNow)
+    {
+        data-&gt;startAt=info-&gt;startAt;
+        data-&gt;offset=info-&gt;offset;
+    }
+}
+
+/**
+    \fn writeVideo
+    \brief Write Video section of index file
+*/
+bool PsIndexer::writeVideo(PSVideo *video)
+{
+    qfprintf(index,&quot;[Video]\n&quot;);
+    qfprintf(index,&quot;Width=%d\n&quot;,video-&gt;w);
+    qfprintf(index,&quot;Height=%d\n&quot;,video-&gt;h);
+    qfprintf(index,&quot;Fps=%d\n&quot;,video-&gt;fps);
+    qfprintf(index,&quot;Interlaced=%d\n&quot;,video-&gt;interlaced);
+    qfprintf(index,&quot;AR=%d\n&quot;,video-&gt;ar);
+    return true;
+}
+/**
+    \fn writeSystem
+    \brief Write system part of index file
+*/
+bool PsIndexer::writeSystem(const char *filename,bool append)
+{
+    qfprintf(index,&quot;PSD1\n&quot;);
+    qfprintf(index,&quot;[System]\n&quot;);
+    qfprintf(index,&quot;Type=P\n&quot;);
+    qfprintf(index,&quot;File=%s\n&quot;,filename);
+    qfprintf(index,&quot;Append=%d\n&quot;,append);
+    return true;
+}
+/**
+    \fn     writeAudio
+    \brief  Write audio headers
+*/
+bool PsIndexer::writeAudio(void)
+{
+    if(!audioTracks) return false;
+    qfprintf(index,&quot;[Audio]\n&quot;);
+    qfprintf(index,&quot;Tracks=%d\n&quot;,audioTracks-&gt;size());
+    for(int i=0;i&lt;audioTracks-&gt;size();i++)
+    {
+        char head[30];
+        psAudioTrackInfo *t=(*audioTracks)[i];
+        sprintf(head,&quot;Track%1d&quot;,i);
+        qfprintf(index,&quot;%s.pid=%x\n&quot;,head,t-&gt;esID);
+        qfprintf(index,&quot;%s.codec=%d\n&quot;,head,t-&gt;header.encoding);
+        qfprintf(index,&quot;%s.fq=%d\n&quot;,head,t-&gt;header.frequency);
+        qfprintf(index,&quot;%s.chan=%d\n&quot;,head,t-&gt;header.channels);
+        qfprintf(index,&quot;%s.br=%d\n&quot;,head,t-&gt;header.byterate);
+    }
+    return true;
+}
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+
+//
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,98 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+    
+      See lavformat/flv[dec/env].c for detail
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_ps.h&quot;
+#include &quot;ADM_demuxerInternal.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avidemutils.h&quot;
+
+ADM_DEMUXER_BEGIN( psHeader,
+                    1,0,0,
+                    &quot;ps&quot;,
+                    &quot;mpeg ps demuxer plugin (c) Mean 2007/2008&quot;
+                );
+
+static bool detectPs(const char *file);
+uint8_t   psIndexer(const char *file);
+/**
+    \fn Probe
+*/
+
+extern &quot;C&quot;  uint32_t         probe(uint32_t magic, const char *fileName)
+{
+char index[strlen(fileName)+4];
+int count=0;
+    if(!detectPs(fileName))
+    {
+        printf(&quot; [PS Demuxer] Not a ps file\n&quot;);
+        return false;
+    }
+
+    sprintf(index,&quot;%s.idx&quot;,fileName);
+again:    
+    if(ADM_fileExist(index)) 
+    {
+        printf(&quot; [PS Demuxer] There is an index for that file \n&quot;);
+        FILE *f=fopen(index,&quot;rt&quot;);
+        char signature[10];
+        fread(signature,4,1,f);
+        signature[4]=0;
+        fclose(f);
+        if(!strcmp(signature,&quot;PSD1&quot;)) return 50;
+        printf(&quot;[PsDemuxer] Not a valid index\n&quot;);
+        return false;
+    }
+    if(count) return false;
+    printf(&quot;[PSDemuxer] Creating index..\n&quot;);
+    count++;
+    if(true==psIndexer(fileName)) goto again;
+    printf(&quot;[PSDemuxer] Failed..\n&quot;);
+   return 0;
+}
+#define PROBE_SIZE (1024*1024)
+/**
+    \fn detectPs
+    \brief returns true if the file seems to be mpeg PS
+
+*/
+bool detectPs(const char *file)
+{
+    uint8_t *buffer=new uint8_t [PROBE_SIZE];
+    uint32_t bufferSize;
+    uint32_t nbPacket,nbMatch=0;
+
+    FILE *f=fopen(file,&quot;rb&quot;);
+    if(!f) return false;
+    bufferSize=fread(buffer,1,PROBE_SIZE,f);
+    fclose(f);
+    nbPacket=bufferSize/2300;
+    uint8_t *head,*tail;
+    head=buffer;
+    tail=buffer+bufferSize;
+    uint8_t code;
+    uint32_t offset;
+    while(ADM_findMpegStartCode(head,tail,&amp;code,&amp;offset))
+    {
+        head+=offset;
+        if(code==0xE0) nbMatch++;
+    }
+    printf(&quot; match :%d / %d (probeSize:%d)\n&quot;,nbMatch,nbPacket,bufferSize);
+    if(nbMatch&gt;nbPacket/3)
+        return true;
+    return false;
+    
+
+}
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,237 @@
+/***************************************************************************
+    copyright            : (C) 2007/2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+    
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_indexFile.h&quot;
+#include &quot;ADM_ps.h&quot;
+
+#include &lt;math.h&gt;
+/**
+        \fn readIndex
+        \brief Read the [video] section of the index file
+
+*/
+bool    psHeader::readIndex(indexFile *index)
+{
+char buffer[2000];
+bool firstAudio=true;
+        printf(&quot;[psDemuxer] Reading index\n&quot;);
+        if(!index-&gt;goToSection(&quot;Data&quot;)) return false;
+      
+        while(1)
+        {
+            if(!index-&gt;readString(2000,(uint8_t *)buffer)) return true;
+            if(buffer[0]=='[') return true;
+            if(buffer[0]==0xa || buffer[0]==0xd) continue; // blank line
+            // Now split the line
+            if(!strncmp(buffer,&quot;Video &quot;,6))
+            {
+                processVideoIndex(buffer+6);
+            }
+            if(!strncmp(buffer,&quot;Audio &quot;,6))
+            {
+                if(firstAudio) 
+                    firstAudio=false; // Ignore first line
+                else
+                    processAudioIndex(buffer+6);
+            }
+        }
+    return true;
+}
+/**
+    \fn processAudioIndex
+    \brief process audio seek points from a line from the index file
+*/
+bool psHeader::processAudioIndex(char *buffer)
+{
+    int64_t startAt,dts;
+    uint32_t size;
+    uint32_t pes;
+    char *head,*tail;
+    int trackNb=0;
+        sscanf(buffer,&quot;bf:%&quot;LLX,&amp;startAt);
+        head=strstr(buffer,&quot; &quot;);
+        if(!head) return false;
+        head++;
+        while(tail=strstr(head,&quot; &quot;))
+        {
+            if(4!=sscanf(head,&quot;Pes:%&quot;LX&quot;:%&quot;LLX&quot;:%&quot;LD&quot;:%&quot;LLD&quot; &quot;,&amp;pes,&amp;startAt,&amp;size,&amp;dts))
+            {
+// qfprintf(index,&quot;Pes:%x:%08&quot;LLX&quot;:%&quot;LD&quot;:%LLD &quot;,e,s-&gt;startAt,s-&gt;startSize,s-&gt;startDts);
+                printf(&quot;[PsHeader::processAudioIndex] Reading index %s failed\n&quot;,buffer);
+            }
+            head=tail+1;
+            ADM_psAccess *track=listOfAudioTracks[trackNb]-&gt;access;
+            track-&gt;push(startAt,dts,size);
+
+            trackNb++;
+            //printf(&quot;[%s] =&gt; %&quot;LX&quot; Dts:%&quot;LLD&quot; Size:%&quot;LLD&quot;\n&quot;,buffer,pes,dts,size);
+            if(strlen(head)&lt;4) break;
+        }
+        return true;
+
+}
+
+/**
+    \fn processVideoIndex
+    \brief process an mpeg index entry from a line from the index file
+*/
+bool psHeader::processVideoIndex(char *buffer)
+{
+            char *head=buffer;
+            uint64_t pts,dts,startAt;
+            uint32_t offset;
+            if(4!=sscanf(head,&quot;at:%&quot;LLX&quot;:%&quot;LX&quot; Pts:%&quot;LLD&quot;:%&quot;LLD,&amp;startAt,&amp;offset,&amp;pts,&amp;dts))
+            {
+                    printf(&quot;[psDemuxer] cannot read fields in  :%s\n&quot;,buffer);
+                    return false;
+            }
+            
+            char *start=strstr(buffer,&quot; I:&quot;);
+            if(!start) return true;
+            start+=1;
+            int count=0;
+            while(1)
+            {
+                char *cur=start;
+                char type=1;
+                char *next;
+                uint32_t len;
+                type=*cur;
+                if(type==0x0a || type==0x0d) break;
+                cur++;
+                if(*(cur)!=':')
+                {
+                    printf(&quot;[psDemux]  instead of : (%c %x %x):\n&quot;,*cur,*(cur-1),*cur);
+                }
+                *cur++;
+                next=strstr(start,&quot; &quot;);
+                ADM_assert(1==sscanf(cur,&quot;%&quot;LX,&amp;len));
+                
+                
+                dmxFrame *frame=new dmxFrame;
+                if(!count)
+                {
+                    frame-&gt;pts=pts;
+                    frame-&gt;dts=dts;
+
+                    frame-&gt;startAt=startAt;
+                    frame-&gt;index=offset;
+
+                }else       
+                {
+                    frame-&gt;pts=ADM_NO_PTS;
+                    frame-&gt;dts=ADM_NO_PTS;
+                    frame-&gt;startAt=0;
+                    frame-&gt;index=0;
+                }
+                switch(type)
+                {
+                    case 'I': frame-&gt;type=1;break;
+                    case 'P': frame-&gt;type=2;break;
+                    case 'B': frame-&gt;type=3;break;
+                    default: ADM_assert(0);
+                }
+                frame-&gt;len=len;
+                ListOfFrames.push_back(frame);
+                count++;
+                if(!next) 
+                {
+                    break;
+                }
+                start=next+1;
+            }
+
+        return true;
+}
+
+/**
+        \fn readVideo
+        \brief Read the [video] section of the index file
+
+*/
+bool    psHeader::readVideo(indexFile *index)
+{
+    printf(&quot;[psDemuxer] Reading Video\n&quot;);
+    if(!index-&gt;readSection(&quot;Video&quot;)) return false;
+    uint32_t w,h,fps,ar;
+    
+    w=index-&gt;getAsUint32(&quot;Width&quot;);
+    h=index-&gt;getAsUint32(&quot;height&quot;);
+    fps=index-&gt;getAsUint32(&quot;Fps&quot;);
+
+    if(!w || !h || !fps) return false;
+
+    interlaced=index-&gt;getAsUint32(&quot;Interlaced&quot;);
+    
+    _video_bih.biWidth=_mainaviheader.dwWidth=w ;
+    _video_bih.biHeight=_mainaviheader.dwHeight=h;             
+    _videostream.dwScale=1000;
+    _videostream.dwRate=fps;
+
+    _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)&quot;MPEG&quot;);
+
+    return true;
+}
+/**
+        \fn readAudio
+        \brief Read the [Audio] section of the index file
+
+*/
+bool    psHeader::readAudio(indexFile *index,const char *name)
+{
+    printf(&quot;[psDemuxer] Reading Audio\n&quot;);
+    if(!index-&gt;readSection(&quot;Audio&quot;)) return false;
+    uint32_t nbTracks;
+    
+    nbTracks=index-&gt;getAsUint32(&quot;Tracks&quot;);
+    if(!nbTracks)
+    {
+        printf(&quot;[PsDemux] No audio\n&quot;);
+        return true;
+    }
+    for(int i=0;i&lt;nbTracks;i++)
+    {
+        char header[40];
+        char body[40];
+        uint32_t fq,chan,br,codec,pid;
+        sprintf(header,&quot;Track%d.&quot;,i);
+#define readInt(x,y) {sprintf(body,&quot;%s&quot;#y,header);x=index-&gt;getAsUint32(body);printf(&quot;%02d:&quot;#y&quot;=%&quot;LU&quot;\n&quot;,i,x);}
+#define readHex(x,y) {sprintf(body,&quot;%s&quot;#y,header);x=index-&gt;getAsHex(body);printf(&quot;%02x:&quot;#y&quot;=%&quot;LU&quot;\n&quot;,i,x);}
+        readInt(fq,fq);
+        readInt(br,br);
+        readInt(chan,chan);
+        readInt(codec,codec);
+        readHex(pid,pid);
+        WAVHeader hdr;
+            hdr.frequency=fq;
+            hdr.byterate=br;
+            hdr.channels=chan;
+            hdr.encoding=codec;
+        ADM_psAccess *access=new ADM_psAccess(name,pid,true);
+            ADM_psTrackDescriptor *desc=new ADM_psTrackDescriptor;
+            desc-&gt;stream=NULL;
+            desc-&gt;access=access;
+            memcpy(&amp;(desc-&gt;header),&amp;hdr,sizeof(hdr));
+            listOfAudioTracks.push_back(desc);
+
+
+    }
+    return true;
+}
+//EOF
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,18 @@
+include(dm_plugin)
+SET(ADM_ts_SRCS 
+	ADM_ts.cpp
+	ADM_tsPlugin.cpp
+	ADM_tsIndex.cpp
+	ADM_tsReadIndex.cpp
+	ADM_tsAudio.cpp
+	ADM_tsAudioProbe.cpp
+	ADM_tsAudioProbe.h
+        ADM_tsComputeTimeStamp.cpp
+)
+
+ADD_LIBRARY(ADM_dm_ts SHARED ${ADM_ts_SRCS})
+TARGET_LINK_LIBRARIES(ADM_dm_ts ADM_coreDemuxerMpeg ADM_audioParser)
+INCLUDE_DIRECTORIES(&quot;${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreDemuxerMpeg/include&quot;)
+
+INIT_DEMUXER(ADM_dm_ts)
+INSTALL_DEMUXER(ADM_dm_ts)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001950.html">[Avidemux-svn-commit] r4722 -	branches/avidemux_2.6_branch_mean/avidemux
</A></li>
	<LI>Next message: <A HREF="001952.html">[Avidemux-svn-commit] r4724 -	branches/avidemux_2.6_branch_mean/avidemux
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1951">[ date ]</a>
              <a href="thread.html#1951">[ thread ]</a>
              <a href="subject.html#1951">[ subject ]</a>
              <a href="author.html#1951">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
