<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4746 - in	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src:	. ADM_libsamplerate
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4746%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src%3A%0A%09.%20ADM_libsamplerate&In-Reply-To=%3C200904211615.n3LGFxjk013637%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001973.html">
   <LINK REL="Next"  HREF="001975.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4746 - in	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src:	. ADM_libsamplerate</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4746%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src%3A%0A%09.%20ADM_libsamplerate&In-Reply-To=%3C200904211615.n3LGFxjk013637%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4746 - in	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src:	. ADM_libsamplerate">gruntster at mail.berlios.de
       </A><BR>
    <I>Tue Apr 21 18:15:59 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001973.html">[Avidemux-svn-commit] r4745 - in	branches/avidemux_2.5_branch_gruntster/scripts/auto: . Apple
</A></li>
        <LI>Next message: <A HREF="001975.html">[Avidemux-svn-commit] r4747 -	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1974">[ date ]</a>
              <a href="thread.html#1974">[ thread ]</a>
              <a href="subject.html#1974">[ subject ]</a>
              <a href="author.html#1974">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2009-04-21 18:15:51 +0200 (Tue, 21 Apr 2009)
New Revision: 4746

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/config.h
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/common.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/float_cast.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/samplerate.c
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_linear.c
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_sinc.c
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_zoh.c
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
Log:
[src] update Secret Rabbit Code to 0.1.7 for speed improvements

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp	2009-04-21 16:15:51 UTC (rev 4746)
@@ -48,7 +48,7 @@
     fromFrequency=from;
     toFrequency=to;
     nbChannels=channel;
-    context=(void *)src_new (SRC_SINC_FASTEST*0+1*SRC_SINC_MEDIUM_QUALITY, channel, &amp;er) ;
+    context=(void *)src_new (SRC_SINC_MEDIUM_QUALITY, channel, &amp;er) ;
     if(!context) 
     {
         printf(&quot;[SRC] Error :%d\n&quot;,er);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/common.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/common.h	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/common.h	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,148 +1,157 @@
-/*
-** Copyright (C) 2002-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/*
-** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
-** use license for this code is available, please see:
-**		<A HREF="http://www.mega-nerd.com/SRC/procedure.html">http://www.mega-nerd.com/SRC/procedure.html</A>
-*/
-
-#ifndef COMMON_H_INCLUDED
-#define COMMON_H_INCLUDED
-
-#ifdef HAVE_STDINT_H
-#include &lt;stdint.h&gt;
-#elif (SIZEOF_INT == 4)
-typedef	int		int32_t ;
-#elif (SIZEOF_LONG == 4)
-typedef	long	int32_t ;
-#endif
-
-#define	SRC_MAX_RATIO			256
-#define	SRC_MIN_RATIO_DIFF		(1e-20)
-
-#define	MAX(a,b)	(((a) &gt; (b)) ? (a) : (b))
-#define	MIN(a,b)	(((a) &lt; (b)) ? (a) : (b))
-
-#define	ARRAY_LEN(x)			((int) (sizeof (x) / sizeof ((x) [0])))
-#define OFFSETOF(type,member)	((int) (&amp;((type*) 0)-&gt;member))
-
-#define	MAKE_MAGIC(a,b,c,d,e,f)	((a) + ((b) &lt;&lt; 4) + ((c) &lt;&lt; 8) + ((d) &lt;&lt; 12) + ((e) &lt;&lt; 16) + ((f) &lt;&lt; 20))
-
-
-#include &quot;samplerate.h&quot;
-
-enum
-{	SRC_FALSE	= 0,
-	SRC_TRUE	= 1,
-
-	SRC_MODE_PROCESS	= 555,
-	SRC_MODE_CALLBACK	= 556
-} ;
-
-enum
-{	SRC_ERR_NO_ERROR = 0,
-
-	SRC_ERR_MALLOC_FAILED,
-	SRC_ERR_BAD_STATE,
-	SRC_ERR_BAD_DATA,
-	SRC_ERR_BAD_DATA_PTR,
-	SRC_ERR_NO_PRIVATE,
-	SRC_ERR_BAD_SRC_RATIO,
-	SRC_ERR_BAD_PROC_PTR,
-	SRC_ERR_SHIFT_BITS,
-	SRC_ERR_FILTER_LEN,
-	SRC_ERR_BAD_CONVERTER,
-	SRC_ERR_BAD_CHANNEL_COUNT,
-	SRC_ERR_SINC_BAD_BUFFER_LEN,
-	SRC_ERR_SIZE_INCOMPATIBILITY,
-	SRC_ERR_BAD_PRIV_PTR,
-	SRC_ERR_BAD_SINC_STATE,
-	SRC_ERR_DATA_OVERLAP,
-	SRC_ERR_BAD_CALLBACK,
-	SRC_ERR_BAD_MODE,
-	SRC_ERR_NULL_CALLBACK,
-	SRC_ERR_NO_VARIABLE_RATIO,
-
-	/* This must be the last error number. */
-	SRC_ERR_MAX_ERROR
-} ;
-
-typedef struct SRC_PRIVATE_tag
-{	double	last_ratio, last_position ;
-
-	int		error ;
-	int		channels ;
-
-	/* SRC_MODE_PROCESS or SRC_MODE_CALLBACK */
-	int		mode ;
-
-	/* Pointer to data to converter specific data. */
-	void	*private_data ;
-
-	/* Varispeed process function. */
-	int		(*vari_process) (struct SRC_PRIVATE_tag *psrc, SRC_DATA *data) ;
-
-	/* Constant speed process function. */
-	int		(*const_process) (struct SRC_PRIVATE_tag *psrc, SRC_DATA *data) ;
-
-	/* State reset. */
-	void	(*reset) (struct SRC_PRIVATE_tag *psrc) ;
-
-	/* Data specific to SRC_MODE_CALLBACK. */
-	src_callback_t	callback_func ;
-	void			*user_callback_data ;
-	long			saved_frames ;
-	float			*saved_data ;
-} SRC_PRIVATE ;
-
-/* In src_sinc.c */
-const char* sinc_get_name (int src_enum) ;
-const char* sinc_get_description (int src_enum) ;
-
-int sinc_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
-
-/* In src_linear.c */
-const char* linear_get_name (int src_enum) ;
-const char* linear_get_description (int src_enum) ;
-
-int linear_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
-
-/* In src_zoh.c */
-const char* zoh_get_name (int src_enum) ;
-const char* zoh_get_description (int src_enum) ;
-
-int zoh_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
-
-/*----------------------------------------------------------
-**	Common static inline functions.
-*/
-
-static inline double
-fmod_one (double x)
-{	double res ;
-
-	res = x - lrint (x) ;
-	if (res &lt; 0.0)
-		return res + 1.0 ;
-
-	return res ;
-} /* fmod_one */
-
-#endif	/* COMMON_H_INCLUDED */
-
+/*
+** Copyright (C) 2002-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/*
+** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
+** use license for this code is available, please see:
+**		<A HREF="http://www.mega-nerd.com/SRC/procedure.html">http://www.mega-nerd.com/SRC/procedure.html</A>
+*/
+
+#ifndef COMMON_H_INCLUDED
+#define COMMON_H_INCLUDED
+
+#ifdef HAVE_STDINT_H
+#include &lt;stdint.h&gt;
+#elif (SIZEOF_INT == 4)
+typedef	int		int32_t ;
+#elif (SIZEOF_LONG == 4)
+typedef	long	int32_t ;
+#endif
+
+#define	SRC_MAX_RATIO			256
+#define	SRC_MAX_RATIO_STR		&quot;256&quot;
+
+#define	SRC_MIN_RATIO_DIFF		(1e-20)
+
+#define	MAX(a,b)	(((a) &gt; (b)) ? (a) : (b))
+#define	MIN(a,b)	(((a) &lt; (b)) ? (a) : (b))
+
+#define	ARRAY_LEN(x)			((int) (sizeof (x) / sizeof ((x) [0])))
+#define OFFSETOF(type,member)	((int) (&amp;((type*) 0)-&gt;member))
+
+#define	MAKE_MAGIC(a,b,c,d,e,f)	((a) + ((b) &lt;&lt; 4) + ((c) &lt;&lt; 8) + ((d) &lt;&lt; 12) + ((e) &lt;&lt; 16) + ((f) &lt;&lt; 20))
+
+#ifdef __GNUC__
+#	define WARN_UNUSED	__attribute__ ((warn_unused_result))
+#else
+#	define WARN_UNUSED
+#endif
+
+
+#include &quot;samplerate.h&quot;
+
+enum
+{	SRC_FALSE	= 0,
+	SRC_TRUE	= 1,
+
+	SRC_MODE_PROCESS	= 555,
+	SRC_MODE_CALLBACK	= 556
+} ;
+
+enum
+{	SRC_ERR_NO_ERROR = 0,
+
+	SRC_ERR_MALLOC_FAILED,
+	SRC_ERR_BAD_STATE,
+	SRC_ERR_BAD_DATA,
+	SRC_ERR_BAD_DATA_PTR,
+	SRC_ERR_NO_PRIVATE,
+	SRC_ERR_BAD_SRC_RATIO,
+	SRC_ERR_BAD_PROC_PTR,
+	SRC_ERR_SHIFT_BITS,
+	SRC_ERR_FILTER_LEN,
+	SRC_ERR_BAD_CONVERTER,
+	SRC_ERR_BAD_CHANNEL_COUNT,
+	SRC_ERR_SINC_BAD_BUFFER_LEN,
+	SRC_ERR_SIZE_INCOMPATIBILITY,
+	SRC_ERR_BAD_PRIV_PTR,
+	SRC_ERR_BAD_SINC_STATE,
+	SRC_ERR_DATA_OVERLAP,
+	SRC_ERR_BAD_CALLBACK,
+	SRC_ERR_BAD_MODE,
+	SRC_ERR_NULL_CALLBACK,
+	SRC_ERR_NO_VARIABLE_RATIO,
+	SRC_ERR_SINC_PREPARE_DATA_BAD_LEN,
+
+	/* This must be the last error number. */
+	SRC_ERR_MAX_ERROR
+} ;
+
+typedef struct SRC_PRIVATE_tag
+{	double	last_ratio, last_position ;
+
+	int		error ;
+	int		channels ;
+
+	/* SRC_MODE_PROCESS or SRC_MODE_CALLBACK */
+	int		mode ;
+
+	/* Pointer to data to converter specific data. */
+	void	*private_data ;
+
+	/* Varispeed process function. */
+	int		(*vari_process) (struct SRC_PRIVATE_tag *psrc, SRC_DATA *data) ;
+
+	/* Constant speed process function. */
+	int		(*const_process) (struct SRC_PRIVATE_tag *psrc, SRC_DATA *data) ;
+
+	/* State reset. */
+	void	(*reset) (struct SRC_PRIVATE_tag *psrc) ;
+
+	/* Data specific to SRC_MODE_CALLBACK. */
+	src_callback_t	callback_func ;
+	void			*user_callback_data ;
+	long			saved_frames ;
+	float			*saved_data ;
+} SRC_PRIVATE ;
+
+/* In src_sinc.c */
+const char* sinc_get_name (int src_enum) ;
+const char* sinc_get_description (int src_enum) ;
+
+int sinc_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
+
+/* In src_linear.c */
+const char* linear_get_name (int src_enum) ;
+const char* linear_get_description (int src_enum) ;
+
+int linear_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
+
+/* In src_zoh.c */
+const char* zoh_get_name (int src_enum) ;
+const char* zoh_get_description (int src_enum) ;
+
+int zoh_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
+
+/*----------------------------------------------------------
+**	Common static inline functions.
+*/
+
+static inline double
+fmod_one (double x)
+{	double res ;
+
+	res = x - lrint (x) ;
+	if (res &lt; 0.0)
+		return res + 1.0 ;
+
+	return res ;
+} /* fmod_one */
+
+#endif	/* COMMON_H_INCLUDED */
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/config.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/config.h	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/config.h	2009-04-21 16:15:51 UTC (rev 4746)
@@ -0,0 +1,10 @@
+#include &quot;ADM_default.h&quot;
+
+#define HAVE_LRINT 1
+#define HAVE_LRINTF 1
+
+#define CPU_CLIPS_NEGATIVE 0
+#define CPU_CLIPS_POSITIVE 0
+
+#define PACKAGE &quot;libsamplerate&quot;
+#define VERSION &quot;0.1.7&quot;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/float_cast.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/float_cast.h	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/float_cast.h	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,255 +1,255 @@
-/*
-** Copyright (C) 2001-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU Lesser General Public License as published by
-** the Free Software Foundation; either version 2.1 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU Lesser General Public License for more details.
-**
-** You should have received a copy of the GNU Lesser General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/* Version 1.4 */
-
-#ifndef FLOAT_CAST_HEADER
-#define FLOAT_CAST_HEADER
-
-/*============================================================================
-**	On Intel Pentium processors (especially PIII and probably P4), converting
-**	from float to int is very slow. To meet the C specs, the code produced by
-**	most C compilers targeting Pentium needs to change the FPU rounding mode
-**	before the float to int conversion is performed.
-**
-**	Changing the FPU rounding mode causes the FPU pipeline to be flushed. It
-**	is this flushing of the pipeline which is so slow.
-**
-**	Fortunately the ISO C99 specifications define the functions lrint, lrintf,
-**	llrint and llrintf which fix this problem as a side effect.
-**
-**	On Unix-like systems, the configure process should have detected the
-**	presence of these functions. If they weren't found we have to replace them
-**	here with a standard C cast.
-*/
-
-/*
-**	The C99 prototypes for lrint and lrintf are as follows:
-**
-**		long int lrintf (float x) ;
-**		long int lrint  (double x) ;
-*/
-
-// MEANX #include &quot;config.h&quot;
-
-/*
-**	The presence of the required functions are detected during the configure
-**	process and the values HAVE_LRINT and HAVE_LRINTF are set accordingly in
-**	the config.h file.
-*/
-
-#define		HAVE_LRINT_REPLACEMENT	0
-
-#if (HAVE_LRINT &amp;&amp; HAVE_LRINTF)
-
-	/*
-	**	These defines enable functionality introduced with the 1999 ISO C
-	**	standard. They must be defined before the inclusion of math.h to
-	**	engage them. If optimisation is enabled, these functions will be
-	**	inlined. With optimisation switched off, you have to link in the
-	**	maths library using -lm.
-	*/
-
-	#define	_ISOC9X_SOURCE	1
-	#define _ISOC99_SOURCE	1
-
-	#define	__USE_ISOC9X	1
-	#define	__USE_ISOC99	1
-
-	#include	&lt;math.h&gt;
-
-#elif (defined (__CYGWIN__))
-
-	#include	&lt;math.h&gt;
-
-	#undef		HAVE_LRINT_REPLACEMENT
-	#define		HAVE_LRINT_REPLACEMENT	1
-
-	#undef	lrint
-	#undef	lrintf
-
-	#define	lrint	double2int
-	#define	lrintf	float2int
-
-	/*
-	**	The native CYGWIN lrint and lrintf functions are buggy:
-	**		<A HREF="http://sourceware.org/ml/cygwin/2005-06/msg00153.html">http://sourceware.org/ml/cygwin/2005-06/msg00153.html</A>
-	**		<A HREF="http://sourceware.org/ml/cygwin/2005-09/msg00047.html">http://sourceware.org/ml/cygwin/2005-09/msg00047.html</A>
-	**	and slow.
-	**	These functions (pulled from the Public Domain MinGW math.h header)
-	**	replace the native versions.
-	*/
-
-	static inline long double2int (double in)
-	{	long retval ;
-
-		__asm__ __volatile__
-		(	&quot;fistpl %0&quot;
-			: &quot;=m&quot; (retval)
-			: &quot;t&quot; (in)
-			: &quot;st&quot;
-			) ;
-
-		return retval ;
-	} /* double2int */
-
-	static inline long float2int (float in)
-	{	long retval ;
-
-		__asm__ __volatile__
-		(	&quot;fistpl %0&quot;
-			: &quot;=m&quot; (retval)
-			: &quot;t&quot; (in)
-			: &quot;st&quot;
-			) ;
-
-		return retval ;
-	} /* float2int */
-
-#elif (defined (WIN32) || defined (_WIN32))
-
-	#undef		HAVE_LRINT_REPLACEMENT
-	#define		HAVE_LRINT_REPLACEMENT	1
-
-	#include	&lt;math.h&gt;
-
-	/*
-	**	Win32 doesn't seem to have these functions.
-	**	Therefore implement inline versions of these functions here.
-	*/
-
-	__inline long int
-	lrint (double flt)
-	{	int intgr ;
-
-		_asm
-		{	fld flt
-			fistp intgr
-			} ;
-
-		return intgr ;
-	}
-
-	__inline long int
-	lrintf (float flt)
-	{	int intgr ;
-
-		_asm
-		{	fld flt
-			fistp intgr
-			} ;
-
-		return intgr ;
-	}
-
-#elif (defined (__MWERKS__) &amp;&amp; defined (macintosh))
-
-	/* This MacOS 9 solution was provided by Stephane Letz */
-
-	#undef		HAVE_LRINT_REPLACEMENT
-	#define		HAVE_LRINT_REPLACEMENT	1
-	#include	&lt;math.h&gt;
-
-	#undef	lrint
-	#undef	lrintf
-
-	#define	lrint	double2int
-	#define	lrintf	float2int
-
-	inline int
-	float2int (register float in)
-	{	long res [2] ;
-
-		asm
-		{	fctiw	in, in
-			stfd	 in, res
-		}
-		return res [1] ;
-	} /* float2int */
-
-	inline int
-	double2int (register double in)
-	{	long res [2] ;
-
-		asm
-		{	fctiw	in, in
-			stfd	 in, res
-		}
-		return res [1] ;
-	} /* double2int */
-
-#elif (defined (__MACH__) &amp;&amp; defined (__APPLE__))
-
-	/* For Apple MacOSX. */
-
-	#undef		HAVE_LRINT_REPLACEMENT
-	#define		HAVE_LRINT_REPLACEMENT	1
-	#include	&lt;math.h&gt;
-
-	#undef lrint
-	#undef lrintf
-
-	#define lrint	double2int
-	#define lrintf	float2int
-
-	inline static long
-	float2int (register float in)
-	{	int res [2] ;
-
-		__asm__ __volatile__
-		(	&quot;fctiw	%1, %1\n\t&quot;
-			&quot;stfd	%1, %0&quot;
-			: &quot;=m&quot; (res)	/* Output */
-			: &quot;f&quot; (in)		/* Input */
-			: &quot;memory&quot;
-			) ;
-
-		return res [1] ;
-	} /* lrintf */
-
-	inline static long
-	double2int (register double in)
-	{	int res [2] ;
-
-		__asm__ __volatile__
-		(	&quot;fctiw	%1, %1\n\t&quot;
-			&quot;stfd	%1, %0&quot;
-			: &quot;=m&quot; (res)	/* Output */
-			: &quot;f&quot; (in)		/* Input */
-			: &quot;memory&quot;
-			) ;
-
-		return res [1] ;
-	} /* lrint */
-
-#else
-	#ifndef __sgi
-	#warning &quot;Don't have the functions lrint() and lrintf().&quot;
-	#warning &quot;Replacing these functions with a standard C cast.&quot;
-	#endif
-
-	#include	&lt;math.h&gt;
-
-	#define	lrint(dbl)		((long) (dbl))
-	#define	lrintf(flt)		((long) (flt))
-
-#endif
-
-
-#endif /* FLOAT_CAST_HEADER */
-
+/*
+** Copyright (C) 2001-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU Lesser General Public License as published by
+** the Free Software Foundation; either version 2.1 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU Lesser General Public License for more details.
+**
+** You should have received a copy of the GNU Lesser General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/* Version 1.4 */
+
+#ifndef FLOAT_CAST_HEADER
+#define FLOAT_CAST_HEADER
+
+/*============================================================================
+**	On Intel Pentium processors (especially PIII and probably P4), converting
+**	from float to int is very slow. To meet the C specs, the code produced by
+**	most C compilers targeting Pentium needs to change the FPU rounding mode
+**	before the float to int conversion is performed.
+**
+**	Changing the FPU rounding mode causes the FPU pipeline to be flushed. It
+**	is this flushing of the pipeline which is so slow.
+**
+**	Fortunately the ISO C99 specifications define the functions lrint, lrintf,
+**	llrint and llrintf which fix this problem as a side effect.
+**
+**	On Unix-like systems, the configure process should have detected the
+**	presence of these functions. If they weren't found we have to replace them
+**	here with a standard C cast.
+*/
+
+/*
+**	The C99 prototypes for lrint and lrintf are as follows:
+**
+**		long int lrintf (float x) ;
+**		long int lrint  (double x) ;
+*/
+
+#include &quot;config.h&quot;
+
+/*
+**	The presence of the required functions are detected during the configure
+**	process and the values HAVE_LRINT and HAVE_LRINTF are set accordingly in
+**	the config.h file.
+*/
+
+#define		HAVE_LRINT_REPLACEMENT	0
+
+#if (HAVE_LRINT &amp;&amp; HAVE_LRINTF)
+
+	/*
+	**	These defines enable functionality introduced with the 1999 ISO C
+	**	standard. They must be defined before the inclusion of math.h to
+	**	engage them. If optimisation is enabled, these functions will be
+	**	inlined. With optimisation switched off, you have to link in the
+	**	maths library using -lm.
+	*/
+
+	#define	_ISOC9X_SOURCE	1
+	#define _ISOC99_SOURCE	1
+
+	#define	__USE_ISOC9X	1
+	#define	__USE_ISOC99	1
+
+	#include	&lt;math.h&gt;
+
+#elif (defined (__CYGWIN__))
+
+	#include	&lt;math.h&gt;
+
+	#undef		HAVE_LRINT_REPLACEMENT
+	#define		HAVE_LRINT_REPLACEMENT	1
+
+	#undef	lrint
+	#undef	lrintf
+
+	#define	lrint	double2int
+	#define	lrintf	float2int
+
+	/*
+	**	The native CYGWIN lrint and lrintf functions are buggy:
+	**		<A HREF="http://sourceware.org/ml/cygwin/2005-06/msg00153.html">http://sourceware.org/ml/cygwin/2005-06/msg00153.html</A>
+	**		<A HREF="http://sourceware.org/ml/cygwin/2005-09/msg00047.html">http://sourceware.org/ml/cygwin/2005-09/msg00047.html</A>
+	**	and slow.
+	**	These functions (pulled from the Public Domain MinGW math.h header)
+	**	replace the native versions.
+	*/
+
+	static inline long double2int (double in)
+	{	long retval ;
+
+		__asm__ __volatile__
+		(	&quot;fistpl %0&quot;
+			: &quot;=m&quot; (retval)
+			: &quot;t&quot; (in)
+			: &quot;st&quot;
+			) ;
+
+		return retval ;
+	} /* double2int */
+
+	static inline long float2int (float in)
+	{	long retval ;
+
+		__asm__ __volatile__
+		(	&quot;fistpl %0&quot;
+			: &quot;=m&quot; (retval)
+			: &quot;t&quot; (in)
+			: &quot;st&quot;
+			) ;
+
+		return retval ;
+	} /* float2int */
+
+#elif (defined (WIN32) || defined (_WIN32))
+
+	#undef		HAVE_LRINT_REPLACEMENT
+	#define		HAVE_LRINT_REPLACEMENT	1
+
+	#include	&lt;math.h&gt;
+
+	/*
+	**	Win32 doesn't seem to have these functions.
+	**	Therefore implement inline versions of these functions here.
+	*/
+
+	__inline long int
+	lrint (double flt)
+	{	int intgr ;
+
+		_asm
+		{	fld flt
+			fistp intgr
+			} ;
+
+		return intgr ;
+	}
+
+	__inline long int
+	lrintf (float flt)
+	{	int intgr ;
+
+		_asm
+		{	fld flt
+			fistp intgr
+			} ;
+
+		return intgr ;
+	}
+
+#elif (defined (__MWERKS__) &amp;&amp; defined (macintosh))
+
+	/* This MacOS 9 solution was provided by Stephane Letz */
+
+	#undef		HAVE_LRINT_REPLACEMENT
+	#define		HAVE_LRINT_REPLACEMENT	1
+	#include	&lt;math.h&gt;
+
+	#undef	lrint
+	#undef	lrintf
+
+	#define	lrint	double2int
+	#define	lrintf	float2int
+
+	inline int
+	float2int (register float in)
+	{	long res [2] ;
+
+		asm
+		{	fctiw	in, in
+			stfd	 in, res
+		}
+		return res [1] ;
+	} /* float2int */
+
+	inline int
+	double2int (register double in)
+	{	long res [2] ;
+
+		asm
+		{	fctiw	in, in
+			stfd	 in, res
+		}
+		return res [1] ;
+	} /* double2int */
+
+#elif (defined (__MACH__) &amp;&amp; defined (__APPLE__))
+
+	/* For Apple MacOSX. */
+
+	#undef		HAVE_LRINT_REPLACEMENT
+	#define		HAVE_LRINT_REPLACEMENT	1
+	#include	&lt;math.h&gt;
+
+	#undef lrint
+	#undef lrintf
+
+	#define lrint	double2int
+	#define lrintf	float2int
+
+	inline static long
+	float2int (register float in)
+	{	int res [2] ;
+
+		__asm__ __volatile__
+		(	&quot;fctiw	%1, %1\n\t&quot;
+			&quot;stfd	%1, %0&quot;
+			: &quot;=m&quot; (res)	/* Output */
+			: &quot;f&quot; (in)		/* Input */
+			: &quot;memory&quot;
+			) ;
+
+		return res [1] ;
+	} /* lrintf */
+
+	inline static long
+	double2int (register double in)
+	{	int res [2] ;
+
+		__asm__ __volatile__
+		(	&quot;fctiw	%1, %1\n\t&quot;
+			&quot;stfd	%1, %0&quot;
+			: &quot;=m&quot; (res)	/* Output */
+			: &quot;f&quot; (in)		/* Input */
+			: &quot;memory&quot;
+			) ;
+
+		return res [1] ;
+	} /* lrint */
+
+#else
+	#ifndef __sgi
+	#warning &quot;Don't have the functions lrint() and lrintf().&quot;
+	#warning &quot;Replacing these functions with a standard C cast.&quot;
+	#endif
+
+	#include	&lt;math.h&gt;
+
+	#define	lrint(dbl)		((long) (dbl))
+	#define	lrintf(flt)		((long) (flt))
+
+#endif
+
+
+#endif /* FLOAT_CAST_HEADER */
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/samplerate.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/samplerate.c	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/samplerate.c	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,541 +1,545 @@
-/*
-** Copyright (C) 2002-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/*
-** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
-** use license for this code is available, please see:
-**		<A HREF="http://www.mega-nerd.com/SRC/procedure.html">http://www.mega-nerd.com/SRC/procedure.html</A>
-*/
-#if 0 // MEANX
-#include	&lt;stdio.h&gt;
-#include	&lt;stdlib.h&gt;
-#include	&lt;string.h&gt;
-
-#include	&quot;config.h&quot;
-#else
-#include &quot;ADM_default.h&quot;
-#endif
-#include	&quot;samplerate.h&quot;
-#include	&quot;float_cast.h&quot;
-#include	&quot;common.h&quot;
-
-static int psrc_set_converter (SRC_PRIVATE	*psrc, int converter_type) ;
-
-
-static inline int
-is_bad_src_ratio (double ratio)
-{	return (ratio &lt; (1.0 / SRC_MAX_RATIO) || ratio &gt; (1.0 * SRC_MAX_RATIO)) ;
-} /* is_bad_src_ratio */
-
-SRC_STATE *
-src_new (int converter_type, int channels, int *error)
-{	SRC_PRIVATE	*psrc ;
-
-	if (error)
-		*error = SRC_ERR_NO_ERROR ;
-
-	if (channels &lt; 1)
-	{	if (error)
-			*error = SRC_ERR_BAD_CHANNEL_COUNT ;
-		return NULL ;
-		} ;
-
-	if ((psrc = calloc (1, sizeof (*psrc))) == NULL)
-	{	if (error)
-			*error = SRC_ERR_MALLOC_FAILED ;
-		return NULL ;
-		} ;
-
-	psrc-&gt;channels = channels ;
-	psrc-&gt;mode = SRC_MODE_PROCESS ;
-
-	if (psrc_set_converter (psrc, converter_type) != SRC_ERR_NO_ERROR)
-	{	if (error)
-			*error = SRC_ERR_BAD_CONVERTER ;
-		free (psrc) ;
-		psrc = NULL ;
-		} ;
-
-	src_reset ((SRC_STATE*) psrc) ;
-
-	return (SRC_STATE*) psrc ;
-} /* src_new */
-
-SRC_STATE*
-src_callback_new (src_callback_t func, int converter_type, int channels, int *error, void* cb_data)
-{	SRC_STATE	*src_state ;
-
-	if (func == NULL)
-	{	if (error)
-			*error = SRC_ERR_BAD_CALLBACK ;
-		return NULL ;
-		} ;
-
-	if (error != NULL)
-		*error = 0 ;
-
-	src_state = src_new (converter_type, channels, error) ;
-
-	src_reset (src_state) ;
-
-	((SRC_PRIVATE*) src_state)-&gt;mode = SRC_MODE_CALLBACK ;
-	((SRC_PRIVATE*) src_state)-&gt;callback_func = func ;
-	((SRC_PRIVATE*) src_state)-&gt;user_callback_data = cb_data ;
-
-	return src_state ;
-} /* src_callback_new */
-
-SRC_STATE *
-src_delete (SRC_STATE *state)
-{	SRC_PRIVATE *psrc ;
-
-	psrc = (SRC_PRIVATE*) state ;
-	if (psrc)
-	{	if (psrc-&gt;private_data)
-			free (psrc-&gt;private_data) ;
-		memset (psrc, 0, sizeof (SRC_PRIVATE)) ;
-		free (psrc) ;
-		} ;
-
-	return NULL ;
-} /* src_state */
-
-int
-src_process (SRC_STATE *state, SRC_DATA *data)
-{	SRC_PRIVATE *psrc ;
-	int error ;
-
-	psrc = (SRC_PRIVATE*) state ;
-
-	if (psrc == NULL)
-		return SRC_ERR_BAD_STATE ;
-	if (psrc-&gt;vari_process == NULL || psrc-&gt;const_process == NULL)
-		return SRC_ERR_BAD_PROC_PTR ;
-
-	if (psrc-&gt;mode != SRC_MODE_PROCESS)
-		return SRC_ERR_BAD_MODE ;
-
-	/* Check for valid SRC_DATA first. */
-	if (data == NULL)
-		return SRC_ERR_BAD_DATA ;
-
-	/* Check src_ratio is in range. */
-	if (is_bad_src_ratio (data-&gt;src_ratio))
-		return SRC_ERR_BAD_SRC_RATIO ;
-
-	/* And that data_in and data_out are valid. */
-	if (data-&gt;data_in == NULL || data-&gt;data_out == NULL)
-		return SRC_ERR_BAD_DATA_PTR ;
-
-	if (data-&gt;data_in == NULL)
-		data-&gt;input_frames = 0 ;
-
-	if (data-&gt;input_frames &lt; 0)
-		data-&gt;input_frames = 0 ;
-	if (data-&gt;output_frames &lt; 0)
-		data-&gt;output_frames = 0 ;
-
-	if (data-&gt;data_in &lt; data-&gt;data_out)
-	{	if (data-&gt;data_in + data-&gt;input_frames * psrc-&gt;channels &gt; data-&gt;data_out)
-		{	/*-printf (&quot;\n\ndata_in: %p    data_out: %p\n&quot;,
-				(void*) (data-&gt;data_in + data-&gt;input_frames * psrc-&gt;channels), (void*) data-&gt;data_out) ;-*/
-			return SRC_ERR_DATA_OVERLAP ;
-			} ;
-		}
-	else if (data-&gt;data_out + data-&gt;output_frames * psrc-&gt;channels &gt; data-&gt;data_in)
-	{	/*-printf (&quot;\n\ndata_in : %p   ouput frames: %ld    data_out: %p\n&quot;, (void*) data-&gt;data_in, data-&gt;output_frames, (void*) data-&gt;data_out) ;
-
-		printf (&quot;data_out: %p (%p)    data_in: %p\n&quot;, (void*) data-&gt;data_out,
-			(void*) (data-&gt;data_out + data-&gt;input_frames * psrc-&gt;channels), (void*) data-&gt;data_in) ;-*/
-		return SRC_ERR_DATA_OVERLAP ;
-		} ;
-
-	/* Set the input and output counts to zero. */
-	data-&gt;input_frames_used = 0 ;
-	data-&gt;output_frames_gen = 0 ;
-
-	/* Special case for when last_ratio has not been set. */
-	if (psrc-&gt;last_ratio &lt; (1.0 / SRC_MAX_RATIO))
-		psrc-&gt;last_ratio = data-&gt;src_ratio ;
-
-	/* Now process. */
-	if (fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &lt; 1e-15)
-		error = psrc-&gt;const_process (psrc, data) ;
-	else
-		error = psrc-&gt;vari_process (psrc, data) ;
-
-	return error ;
-} /* src_process */
-
-long
-src_callback_read (SRC_STATE *state, double src_ratio, long frames, float *data)
-{	SRC_PRIVATE	*psrc ;
-	SRC_DATA	src_data ;
-
-	long	output_frames_gen ;
-	int		error = 0 ;
-
-	if (state == NULL)
-		return 0 ;
-
-	if (frames &lt;= 0)
-		return 0 ;
-
-	psrc = (SRC_PRIVATE*) state ;
-
-	if (psrc-&gt;mode != SRC_MODE_CALLBACK)
-	{	psrc-&gt;error = SRC_ERR_BAD_MODE ;
-		return 0 ;
-		} ;
-
-	if (psrc-&gt;callback_func == NULL)
-	{	psrc-&gt;error = SRC_ERR_NULL_CALLBACK ;
-		return 0 ;
-		} ;
-
-	memset (&amp;src_data, 0, sizeof (src_data)) ;
-
-	/* Check src_ratio is in range. */
-	if (is_bad_src_ratio (src_ratio))
-	{	psrc-&gt;error = SRC_ERR_BAD_SRC_RATIO ;
-		return 0 ;
-		} ;
-
-	/* Switch modes temporarily. */
-	src_data.src_ratio = src_ratio ;
-	src_data.data_out = data ;
-	src_data.output_frames = frames ;
-
-	src_data.data_in = psrc-&gt;saved_data ;
-	src_data.input_frames = psrc-&gt;saved_frames ;
-
-	output_frames_gen = 0 ;
-	while (output_frames_gen &lt; frames)
-	{
-		if (src_data.input_frames == 0)
-		{	float *ptr ;
-
-			src_data.input_frames = psrc-&gt;callback_func (psrc-&gt;user_callback_data, &amp;ptr) ;
-			src_data.data_in = ptr ;
-
-			if (src_data.input_frames == 0)
-				src_data.end_of_input = 1 ;
-			} ;
-
-		/*
-		** Now call process function. However, we need to set the mode
-		** to SRC_MODE_PROCESS first and when we return set it back to
-		** SRC_MODE_CALLBACK.
-		*/
-		psrc-&gt;mode = SRC_MODE_PROCESS ;
-		error = src_process (state, &amp;src_data) ;
-		psrc-&gt;mode = SRC_MODE_CALLBACK ;
-
-		if (error != 0)
-			break ;
-
-		src_data.data_in += src_data.input_frames_used * psrc-&gt;channels ;
-		src_data.input_frames -= src_data.input_frames_used ;
-
-		src_data.data_out += src_data.output_frames_gen * psrc-&gt;channels ;
-		src_data.output_frames -= src_data.output_frames_gen ;
-
-		output_frames_gen += src_data.output_frames_gen ;
-
-		if (src_data.end_of_input == SRC_TRUE &amp;&amp; src_data.output_frames_gen == 0)
-			break ;
-		} ;
-
-	psrc-&gt;saved_data = src_data.data_in ;
-	psrc-&gt;saved_frames = src_data.input_frames ;
-
-	if (error != 0)
-	{	psrc-&gt;error = error ;
-	 	return 0 ;
-		} ;
-
-	return output_frames_gen ;
-} /* src_callback_read */
-
-/*==========================================================================
-*/
-
-int
-src_set_ratio (SRC_STATE *state, double new_ratio)
-{	SRC_PRIVATE *psrc ;
-
-	psrc = (SRC_PRIVATE*) state ;
-
-	if (psrc == NULL)
-		return SRC_ERR_BAD_STATE ;
-	if (psrc-&gt;vari_process == NULL || psrc-&gt;const_process == NULL)
-		return SRC_ERR_BAD_PROC_PTR ;
-
-	if (is_bad_src_ratio (new_ratio))
-		return SRC_ERR_BAD_SRC_RATIO ;
-
-	psrc-&gt;last_ratio = new_ratio ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* src_set_ratio */
-
-int
-src_reset (SRC_STATE *state)
-{	SRC_PRIVATE *psrc ;
-
-	if ((psrc = (SRC_PRIVATE*) state) == NULL)
-		return SRC_ERR_BAD_STATE ;
-
-	if (psrc-&gt;reset != NULL)
-		psrc-&gt;reset (psrc) ;
-
-	psrc-&gt;last_position = 0.0 ;
-	psrc-&gt;last_ratio = 0.0 ;
-
-	psrc-&gt;saved_data = NULL ;
-	psrc-&gt;saved_frames = 0 ;
-
-	psrc-&gt;error = SRC_ERR_NO_ERROR ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* src_reset */
-
-/*==============================================================================
-**	Control functions.
-*/
-
-const char *
-src_get_name (int converter_type)
-{	const char *desc ;
-
-	if ((desc = sinc_get_name (converter_type)) != NULL)
-		return desc ;
-
-	if ((desc = zoh_get_name (converter_type)) != NULL)
-		return desc ;
-
-	if ((desc = linear_get_name (converter_type)) != NULL)
-		return desc ;
-
-	return NULL ;
-} /* src_get_name */
-
-const char *
-src_get_description (int converter_type)
-{	const char *desc ;
-
-	if ((desc = sinc_get_description (converter_type)) != NULL)
-		return desc ;
-
-	if ((desc = zoh_get_description (converter_type)) != NULL)
-		return desc ;
-
-	if ((desc = linear_get_description (converter_type)) != NULL)
-		return desc ;
-
-	return NULL ;
-} /* src_get_description */
-
-const char *
-src_get_version (void)
-{	return PACKAGE &quot;-&quot; VERSION &quot; (c) 2002-2008 Erik de Castro Lopo&quot; ;
-} /* src_get_version */
-
-int
-src_is_valid_ratio (double ratio)
-{
-	if (is_bad_src_ratio (ratio))
-		return SRC_FALSE ;
-
-	return SRC_TRUE ;
-} /* src_is_valid_ratio */
-
-/*==============================================================================
-**	Error reporting functions.
-*/
-
-int
-src_error (SRC_STATE *state)
-{	if (state)
-		return ((SRC_PRIVATE*) state)-&gt;error ;
-	return SRC_ERR_NO_ERROR ;
-} /* src_error */
-
-const char*
-src_strerror (int error)
-{
-	switch (error)
-	{	case SRC_ERR_NO_ERROR :
-				return &quot;No error.&quot; ;
-		case SRC_ERR_MALLOC_FAILED :
-				return &quot;Malloc failed.&quot; ;
-		case SRC_ERR_BAD_STATE :
-				return &quot;SRC_STATE pointer is NULL.&quot; ;
-		case SRC_ERR_BAD_DATA :
-				return &quot;SRC_DATA pointer is NULL.&quot; ;
-		case SRC_ERR_BAD_DATA_PTR :
-				return &quot;SRC_DATA-&gt;data_out is NULL.&quot; ;
-		case SRC_ERR_NO_PRIVATE :
-				return &quot;Internal error. No private data.&quot; ;
-		case SRC_ERR_BAD_SRC_RATIO :
-				return &quot;SRC ratio outside [1/12, 12] range.&quot; ;
-		case SRC_ERR_BAD_SINC_STATE :
-				return &quot;src_process() called without reset after end_of_input.&quot; ;
-		case SRC_ERR_BAD_PROC_PTR :
-				return &quot;Internal error. No process pointer.&quot; ;
-		case SRC_ERR_SHIFT_BITS :
-				return &quot;Internal error. SHIFT_BITS too large.&quot; ;
-		case SRC_ERR_FILTER_LEN :
-				return &quot;Internal error. Filter length too large.&quot; ;
-		case SRC_ERR_BAD_CONVERTER :
-				return &quot;Bad converter number.&quot; ;
-		case SRC_ERR_BAD_CHANNEL_COUNT :
-				return &quot;Channel count must be &gt;= 1.&quot; ;
-		case SRC_ERR_SINC_BAD_BUFFER_LEN :
-				return &quot;Internal error. Bad buffer length. Please report this.&quot; ;
-		case SRC_ERR_SIZE_INCOMPATIBILITY :
-				return &quot;Internal error. Input data / internal buffer size difference. Please report this.&quot; ;
-		case SRC_ERR_BAD_PRIV_PTR :
-				return &quot;Internal error. Private pointer is NULL. Please report this.&quot; ;
-		case SRC_ERR_DATA_OVERLAP :
-				return &quot;Input and output data arrays overlap.&quot; ;
-		case SRC_ERR_BAD_CALLBACK :
-				return &quot;Supplied callback function pointer is NULL.&quot; ;
-		case SRC_ERR_BAD_MODE :
-				return &quot;Calling mode differs from initialisation mode (ie process v callback).&quot; ;
-		case SRC_ERR_NULL_CALLBACK :
-				return &quot;Callback function pointer is NULL in src_callback_read ().&quot; ;
-		case SRC_ERR_NO_VARIABLE_RATIO :
-				return &quot;This converter only allows constant conversion ratios.&quot; ;
-
-		case SRC_ERR_MAX_ERROR :
-				return &quot;Placeholder. No error defined for this error number.&quot; ;
-
-		default : 						break ;
-		}
-
-	return NULL ;
-} /* src_strerror */
-
-/*==============================================================================
-**	Simple interface for performing a single conversion from input buffer to
-**	output buffer at a fixed conversion ratio.
-*/
-
-int
-src_simple (SRC_DATA *src_data, int converter, int channels)
-{	SRC_STATE	*src_state ;
-	int 		error ;
-
-	if ((src_state = src_new (converter, channels, &amp;error)) == NULL)
-		return error ;
-
-	src_data-&gt;end_of_input = 1 ; /* Only one buffer worth of input. */
-
-	error = src_process (src_state, src_data) ;
-
-	src_state = src_delete (src_state) ;
-
-	return error ;
-} /* src_simple */
-
-void
-src_short_to_float_array (const short *in, float *out, int len)
-{
-	while (len)
-	{	len -- ;
-		out [len] = (float) (in [len] / (1.0 * 0x8000)) ;
-		} ;
-
-	return ;
-} /* src_short_to_float_array */
-
-void
-src_float_to_short_array (const float *in, short *out, int len)
-{	double scaled_value ;
-
-	while (len)
-	{	len -- ;
-
-		scaled_value = in [len] * (8.0 * 0x10000000) ;
-		if (CPU_CLIPS_POSITIVE == 0 &amp;&amp; scaled_value &gt;= (1.0 * 0x7FFFFFFF))
-		{	out [len] = 32767 ;
-			continue ;
-			} ;
-		if (CPU_CLIPS_NEGATIVE == 0 &amp;&amp; scaled_value &lt;= (-8.0 * 0x10000000))
-		{	out [len] = -32768 ;
-			continue ;
-			} ;
-
-		out [len] = (short) (lrint (scaled_value) &gt;&gt; 16) ;
-		} ;
-
-} /* src_float_to_short_array */
-
-void
-src_int_to_float_array (const int *in, float *out, int len)
-{
-	while (len)
-	{	len -- ;
-		out [len] = (float) (in [len] / (8.0 * 0x10000000)) ;
-		} ;
-
-	return ;
-} /* src_int_to_float_array */
-
-void
-src_float_to_int_array (const float *in, int *out, int len)
-{	double scaled_value ;
-
-	while (len)
-	{	len -- ;
-
-		scaled_value = in [len] * (8.0 * 0x10000000) ;
-		if (CPU_CLIPS_POSITIVE == 0 &amp;&amp; scaled_value &gt;= (1.0 * 0x7FFFFFFF))
-		{	out [len] = 0x7fffffff ;
-			continue ;
-			} ;
-		if (CPU_CLIPS_NEGATIVE == 0 &amp;&amp; scaled_value &lt;= (-8.0 * 0x10000000))
-		{	out [len] = -1 - 0x7fffffff ;
-			continue ;
-			} ;
-
-		out [len] = lrint (scaled_value) ;
-		} ;
-
-} /* src_float_to_int_array */
-
-/*==============================================================================
-**	Private functions.
-*/
-
-static int
-psrc_set_converter (SRC_PRIVATE	*psrc, int converter_type)
-{
-	if (sinc_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
-		return SRC_ERR_NO_ERROR ;
-
-	if (zoh_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
-		return SRC_ERR_NO_ERROR ;
-
-	if (linear_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
-		return SRC_ERR_NO_ERROR ;
-
-	return SRC_ERR_BAD_CONVERTER ;
-} /* psrc_set_converter */
-
+/*
+** Copyright (C) 2002-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/*
+** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
+** use license for this code is available, please see:
+**		<A HREF="http://www.mega-nerd.com/SRC/procedure.html">http://www.mega-nerd.com/SRC/procedure.html</A>
+*/
+
+#include	&lt;stdio.h&gt;
+#include	&lt;stdlib.h&gt;
+#include	&lt;string.h&gt;
+
+#include	&quot;config.h&quot;
+
+#include	&quot;samplerate.h&quot;
+#include	&quot;float_cast.h&quot;
+#include	&quot;common.h&quot;
+
+static int psrc_set_converter (SRC_PRIVATE	*psrc, int converter_type) ;
+
+
+static inline int
+is_bad_src_ratio (double ratio)
+{	return (ratio &lt; (1.0 / SRC_MAX_RATIO) || ratio &gt; (1.0 * SRC_MAX_RATIO)) ;
+} /* is_bad_src_ratio */
+
+SRC_STATE *
+src_new (int converter_type, int channels, int *error)
+{	SRC_PRIVATE	*psrc ;
+
+	if (error)
+		*error = SRC_ERR_NO_ERROR ;
+
+	if (channels &lt; 1)
+	{	if (error)
+			*error = SRC_ERR_BAD_CHANNEL_COUNT ;
+		return NULL ;
+		} ;
+
+	if ((psrc = calloc (1, sizeof (*psrc))) == NULL)
+	{	if (error)
+			*error = SRC_ERR_MALLOC_FAILED ;
+		return NULL ;
+		} ;
+
+	psrc-&gt;channels = channels ;
+	psrc-&gt;mode = SRC_MODE_PROCESS ;
+
+	if (psrc_set_converter (psrc, converter_type) != SRC_ERR_NO_ERROR)
+	{	if (error)
+			*error = SRC_ERR_BAD_CONVERTER ;
+		free (psrc) ;
+		psrc = NULL ;
+		} ;
+
+	src_reset ((SRC_STATE*) psrc) ;
+
+	return (SRC_STATE*) psrc ;
+} /* src_new */
+
+SRC_STATE*
+src_callback_new (src_callback_t func, int converter_type, int channels, int *error, void* cb_data)
+{	SRC_STATE	*src_state ;
+
+	if (func == NULL)
+	{	if (error)
+			*error = SRC_ERR_BAD_CALLBACK ;
+		return NULL ;
+		} ;
+
+	if (error != NULL)
+		*error = 0 ;
+
+	if ((src_state = src_new (converter_type, channels, error)) == NULL)
+		return NULL ;
+
+	src_reset (src_state) ;
+
+	((SRC_PRIVATE*) src_state)-&gt;mode = SRC_MODE_CALLBACK ;
+	((SRC_PRIVATE*) src_state)-&gt;callback_func = func ;
+	((SRC_PRIVATE*) src_state)-&gt;user_callback_data = cb_data ;
+
+	return src_state ;
+} /* src_callback_new */
+
+SRC_STATE *
+src_delete (SRC_STATE *state)
+{	SRC_PRIVATE *psrc ;
+
+	psrc = (SRC_PRIVATE*) state ;
+	if (psrc)
+	{	if (psrc-&gt;private_data)
+			free (psrc-&gt;private_data) ;
+		memset (psrc, 0, sizeof (SRC_PRIVATE)) ;
+		free (psrc) ;
+		} ;
+
+	return NULL ;
+} /* src_state */
+
+int
+src_process (SRC_STATE *state, SRC_DATA *data)
+{	SRC_PRIVATE *psrc ;
+	int error ;
+
+	psrc = (SRC_PRIVATE*) state ;
+
+	if (psrc == NULL)
+		return SRC_ERR_BAD_STATE ;
+	if (psrc-&gt;vari_process == NULL || psrc-&gt;const_process == NULL)
+		return SRC_ERR_BAD_PROC_PTR ;
+
+	if (psrc-&gt;mode != SRC_MODE_PROCESS)
+		return SRC_ERR_BAD_MODE ;
+
+	/* Check for valid SRC_DATA first. */
+	if (data == NULL)
+		return SRC_ERR_BAD_DATA ;
+
+	/* And that data_in and data_out are valid. */
+	if (data-&gt;data_in == NULL || data-&gt;data_out == NULL)
+		return SRC_ERR_BAD_DATA_PTR ;
+
+	/* Check src_ratio is in range. */
+	if (is_bad_src_ratio (data-&gt;src_ratio))
+		return SRC_ERR_BAD_SRC_RATIO ;
+
+	if (data-&gt;input_frames &lt; 0)
+		data-&gt;input_frames = 0 ;
+	if (data-&gt;output_frames &lt; 0)
+		data-&gt;output_frames = 0 ;
+
+	if (data-&gt;data_in &lt; data-&gt;data_out)
+	{	if (data-&gt;data_in + data-&gt;input_frames * psrc-&gt;channels &gt; data-&gt;data_out)
+		{	/*-printf (&quot;\n\ndata_in: %p    data_out: %p\n&quot;,
+				(void*) (data-&gt;data_in + data-&gt;input_frames * psrc-&gt;channels), (void*) data-&gt;data_out) ;-*/
+			return SRC_ERR_DATA_OVERLAP ;
+			} ;
+		}
+	else if (data-&gt;data_out + data-&gt;output_frames * psrc-&gt;channels &gt; data-&gt;data_in)
+	{	/*-printf (&quot;\n\ndata_in : %p   ouput frames: %ld    data_out: %p\n&quot;, (void*) data-&gt;data_in, data-&gt;output_frames, (void*) data-&gt;data_out) ;
+
+		printf (&quot;data_out: %p (%p)    data_in: %p\n&quot;, (void*) data-&gt;data_out,
+			(void*) (data-&gt;data_out + data-&gt;input_frames * psrc-&gt;channels), (void*) data-&gt;data_in) ;-*/
+		return SRC_ERR_DATA_OVERLAP ;
+		} ;
+
+	/* Set the input and output counts to zero. */
+	data-&gt;input_frames_used = 0 ;
+	data-&gt;output_frames_gen = 0 ;
+
+	/* Special case for when last_ratio has not been set. */
+	if (psrc-&gt;last_ratio &lt; (1.0 / SRC_MAX_RATIO))
+		psrc-&gt;last_ratio = data-&gt;src_ratio ;
+
+	/* Now process. */
+	if (fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &lt; 1e-15)
+		error = psrc-&gt;const_process (psrc, data) ;
+	else
+		error = psrc-&gt;vari_process (psrc, data) ;
+
+	return error ;
+} /* src_process */
+
+long
+src_callback_read (SRC_STATE *state, double src_ratio, long frames, float *data)
+{	SRC_PRIVATE	*psrc ;
+	SRC_DATA	src_data ;
+
+	long	output_frames_gen ;
+	int		error = 0 ;
+
+	if (state == NULL)
+		return 0 ;
+
+	if (frames &lt;= 0)
+		return 0 ;
+
+	psrc = (SRC_PRIVATE*) state ;
+
+	if (psrc-&gt;mode != SRC_MODE_CALLBACK)
+	{	psrc-&gt;error = SRC_ERR_BAD_MODE ;
+		return 0 ;
+		} ;
+
+	if (psrc-&gt;callback_func == NULL)
+	{	psrc-&gt;error = SRC_ERR_NULL_CALLBACK ;
+		return 0 ;
+		} ;
+
+	memset (&amp;src_data, 0, sizeof (src_data)) ;
+
+	/* Check src_ratio is in range. */
+	if (is_bad_src_ratio (src_ratio))
+	{	psrc-&gt;error = SRC_ERR_BAD_SRC_RATIO ;
+		return 0 ;
+		} ;
+
+	/* Switch modes temporarily. */
+	src_data.src_ratio = src_ratio ;
+	src_data.data_out = data ;
+	src_data.output_frames = frames ;
+
+	src_data.data_in = psrc-&gt;saved_data ;
+	src_data.input_frames = psrc-&gt;saved_frames ;
+
+	output_frames_gen = 0 ;
+	while (output_frames_gen &lt; frames)
+	{	/*	Use a dummy array for the case where the callback function
+		**	returns without setting the ptr.
+		*/
+		float dummy [1] ;
+
+		if (src_data.input_frames == 0)
+		{	float *ptr = dummy ;
+
+			src_data.input_frames = psrc-&gt;callback_func (psrc-&gt;user_callback_data, &amp;ptr) ;
+			src_data.data_in = ptr ;
+
+			if (src_data.input_frames == 0)
+				src_data.end_of_input = 1 ;
+			} ;
+
+		/*
+		** Now call process function. However, we need to set the mode
+		** to SRC_MODE_PROCESS first and when we return set it back to
+		** SRC_MODE_CALLBACK.
+		*/
+		psrc-&gt;mode = SRC_MODE_PROCESS ;
+		error = src_process (state, &amp;src_data) ;
+		psrc-&gt;mode = SRC_MODE_CALLBACK ;
+
+		if (error != 0)
+			break ;
+
+		src_data.data_in += src_data.input_frames_used * psrc-&gt;channels ;
+		src_data.input_frames -= src_data.input_frames_used ;
+
+		src_data.data_out += src_data.output_frames_gen * psrc-&gt;channels ;
+		src_data.output_frames -= src_data.output_frames_gen ;
+
+		output_frames_gen += src_data.output_frames_gen ;
+
+		if (src_data.end_of_input == SRC_TRUE &amp;&amp; src_data.output_frames_gen == 0)
+			break ;
+		} ;
+
+	psrc-&gt;saved_data = src_data.data_in ;
+	psrc-&gt;saved_frames = src_data.input_frames ;
+
+	if (error != 0)
+	{	psrc-&gt;error = error ;
+	 	return 0 ;
+		} ;
+
+	return output_frames_gen ;
+} /* src_callback_read */
+
+/*==========================================================================
+*/
+
+int
+src_set_ratio (SRC_STATE *state, double new_ratio)
+{	SRC_PRIVATE *psrc ;
+
+	psrc = (SRC_PRIVATE*) state ;
+
+	if (psrc == NULL)
+		return SRC_ERR_BAD_STATE ;
+	if (psrc-&gt;vari_process == NULL || psrc-&gt;const_process == NULL)
+		return SRC_ERR_BAD_PROC_PTR ;
+
+	if (is_bad_src_ratio (new_ratio))
+		return SRC_ERR_BAD_SRC_RATIO ;
+
+	psrc-&gt;last_ratio = new_ratio ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* src_set_ratio */
+
+int
+src_reset (SRC_STATE *state)
+{	SRC_PRIVATE *psrc ;
+
+	if ((psrc = (SRC_PRIVATE*) state) == NULL)
+		return SRC_ERR_BAD_STATE ;
+
+	if (psrc-&gt;reset != NULL)
+		psrc-&gt;reset (psrc) ;
+
+	psrc-&gt;last_position = 0.0 ;
+	psrc-&gt;last_ratio = 0.0 ;
+
+	psrc-&gt;saved_data = NULL ;
+	psrc-&gt;saved_frames = 0 ;
+
+	psrc-&gt;error = SRC_ERR_NO_ERROR ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* src_reset */
+
+/*==============================================================================
+**	Control functions.
+*/
+
+const char *
+src_get_name (int converter_type)
+{	const char *desc ;
+
+	if ((desc = sinc_get_name (converter_type)) != NULL)
+		return desc ;
+
+	if ((desc = zoh_get_name (converter_type)) != NULL)
+		return desc ;
+
+	if ((desc = linear_get_name (converter_type)) != NULL)
+		return desc ;
+
+	return NULL ;
+} /* src_get_name */
+
+const char *
+src_get_description (int converter_type)
+{	const char *desc ;
+
+	if ((desc = sinc_get_description (converter_type)) != NULL)
+		return desc ;
+
+	if ((desc = zoh_get_description (converter_type)) != NULL)
+		return desc ;
+
+	if ((desc = linear_get_description (converter_type)) != NULL)
+		return desc ;
+
+	return NULL ;
+} /* src_get_description */
+
+const char *
+src_get_version (void)
+{	return PACKAGE &quot;-&quot; VERSION &quot; (c) 2002-2008 Erik de Castro Lopo&quot; ;
+} /* src_get_version */
+
+int
+src_is_valid_ratio (double ratio)
+{
+	if (is_bad_src_ratio (ratio))
+		return SRC_FALSE ;
+
+	return SRC_TRUE ;
+} /* src_is_valid_ratio */
+
+/*==============================================================================
+**	Error reporting functions.
+*/
+
+int
+src_error (SRC_STATE *state)
+{	if (state)
+		return ((SRC_PRIVATE*) state)-&gt;error ;
+	return SRC_ERR_NO_ERROR ;
+} /* src_error */
+
+const char*
+src_strerror (int error)
+{
+	switch (error)
+	{	case SRC_ERR_NO_ERROR :
+				return &quot;No error.&quot; ;
+		case SRC_ERR_MALLOC_FAILED :
+				return &quot;Malloc failed.&quot; ;
+		case SRC_ERR_BAD_STATE :
+				return &quot;SRC_STATE pointer is NULL.&quot; ;
+		case SRC_ERR_BAD_DATA :
+				return &quot;SRC_DATA pointer is NULL.&quot; ;
+		case SRC_ERR_BAD_DATA_PTR :
+				return &quot;SRC_DATA-&gt;data_out is NULL.&quot; ;
+		case SRC_ERR_NO_PRIVATE :
+				return &quot;Internal error. No private data.&quot; ;
+
+		case SRC_ERR_BAD_SRC_RATIO :
+				return &quot;SRC ratio outside [1/&quot; SRC_MAX_RATIO_STR &quot;, &quot; SRC_MAX_RATIO_STR &quot;] range.&quot; ;
+
+		case SRC_ERR_BAD_SINC_STATE :
+				return &quot;src_process() called without reset after end_of_input.&quot; ;
+		case SRC_ERR_BAD_PROC_PTR :
+				return &quot;Internal error. No process pointer.&quot; ;
+		case SRC_ERR_SHIFT_BITS :
+				return &quot;Internal error. SHIFT_BITS too large.&quot; ;
+		case SRC_ERR_FILTER_LEN :
+				return &quot;Internal error. Filter length too large.&quot; ;
+		case SRC_ERR_BAD_CONVERTER :
+				return &quot;Bad converter number.&quot; ;
+		case SRC_ERR_BAD_CHANNEL_COUNT :
+				return &quot;Channel count must be &gt;= 1.&quot; ;
+		case SRC_ERR_SINC_BAD_BUFFER_LEN :
+				return &quot;Internal error. Bad buffer length. Please report this.&quot; ;
+		case SRC_ERR_SIZE_INCOMPATIBILITY :
+				return &quot;Internal error. Input data / internal buffer size difference. Please report this.&quot; ;
+		case SRC_ERR_BAD_PRIV_PTR :
+				return &quot;Internal error. Private pointer is NULL. Please report this.&quot; ;
+		case SRC_ERR_DATA_OVERLAP :
+				return &quot;Input and output data arrays overlap.&quot; ;
+		case SRC_ERR_BAD_CALLBACK :
+				return &quot;Supplied callback function pointer is NULL.&quot; ;
+		case SRC_ERR_BAD_MODE :
+				return &quot;Calling mode differs from initialisation mode (ie process v callback).&quot; ;
+		case SRC_ERR_NULL_CALLBACK :
+				return &quot;Callback function pointer is NULL in src_callback_read ().&quot; ;
+		case SRC_ERR_NO_VARIABLE_RATIO :
+				return &quot;This converter only allows constant conversion ratios.&quot; ;
+		case SRC_ERR_SINC_PREPARE_DATA_BAD_LEN :
+				return &quot;Internal error : Bad length in prepare_data ().&quot; ;
+
+		case SRC_ERR_MAX_ERROR :
+				return &quot;Placeholder. No error defined for this error number.&quot; ;
+
+		default : 						break ;
+		}
+
+	return NULL ;
+} /* src_strerror */
+
+/*==============================================================================
+**	Simple interface for performing a single conversion from input buffer to
+**	output buffer at a fixed conversion ratio.
+*/
+
+int
+src_simple (SRC_DATA *src_data, int converter, int channels)
+{	SRC_STATE	*src_state ;
+	int 		error ;
+
+	if ((src_state = src_new (converter, channels, &amp;error)) == NULL)
+		return error ;
+
+	src_data-&gt;end_of_input = 1 ; /* Only one buffer worth of input. */
+
+	error = src_process (src_state, src_data) ;
+
+	src_state = src_delete (src_state) ;
+
+	return error ;
+} /* src_simple */
+
+void
+src_short_to_float_array (const short *in, float *out, int len)
+{
+	while (len)
+	{	len -- ;
+		out [len] = (float) (in [len] / (1.0 * 0x8000)) ;
+		} ;
+
+	return ;
+} /* src_short_to_float_array */
+
+void
+src_float_to_short_array (const float *in, short *out, int len)
+{	double scaled_value ;
+
+	while (len)
+	{	len -- ;
+
+		scaled_value = in [len] * (8.0 * 0x10000000) ;
+		if (CPU_CLIPS_POSITIVE == 0 &amp;&amp; scaled_value &gt;= (1.0 * 0x7FFFFFFF))
+		{	out [len] = 32767 ;
+			continue ;
+			} ;
+		if (CPU_CLIPS_NEGATIVE == 0 &amp;&amp; scaled_value &lt;= (-8.0 * 0x10000000))
+		{	out [len] = -32768 ;
+			continue ;
+			} ;
+
+		out [len] = (short) (lrint (scaled_value) &gt;&gt; 16) ;
+		} ;
+
+} /* src_float_to_short_array */
+
+void
+src_int_to_float_array (const int *in, float *out, int len)
+{
+	while (len)
+	{	len -- ;
+		out [len] = (float) (in [len] / (8.0 * 0x10000000)) ;
+		} ;
+
+	return ;
+} /* src_int_to_float_array */
+
+void
+src_float_to_int_array (const float *in, int *out, int len)
+{	double scaled_value ;
+
+	while (len)
+	{	len -- ;
+
+		scaled_value = in [len] * (8.0 * 0x10000000) ;
+		if (CPU_CLIPS_POSITIVE == 0 &amp;&amp; scaled_value &gt;= (1.0 * 0x7FFFFFFF))
+		{	out [len] = 0x7fffffff ;
+			continue ;
+			} ;
+		if (CPU_CLIPS_NEGATIVE == 0 &amp;&amp; scaled_value &lt;= (-8.0 * 0x10000000))
+		{	out [len] = -1 - 0x7fffffff ;
+			continue ;
+			} ;
+
+		out [len] = lrint (scaled_value) ;
+		} ;
+
+} /* src_float_to_int_array */
+
+/*==============================================================================
+**	Private functions.
+*/
+
+static int
+psrc_set_converter (SRC_PRIVATE	*psrc, int converter_type)
+{
+	if (sinc_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
+		return SRC_ERR_NO_ERROR ;
+
+	if (zoh_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
+		return SRC_ERR_NO_ERROR ;
+
+	if (linear_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
+		return SRC_ERR_NO_ERROR ;
+
+	return SRC_ERR_BAD_CONVERTER ;
+} /* psrc_set_converter */
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_linear.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_linear.c	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_linear.c	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,222 +1,217 @@
-/*
-** Copyright (C) 2002-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/*
-** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
-** use license for this code is available, please see:
-**		<A HREF="http://www.mega-nerd.com/SRC/procedure.html">http://www.mega-nerd.com/SRC/procedure.html</A>
-*/
-#if 0 // MEANX
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &quot;config.h&quot;
-#else
-#include &quot;ADM_default.h&quot;
-#endif
-#include &quot;float_cast.h&quot;
-#include &quot;common.h&quot;
-
-static int linear_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
-static void linear_reset (SRC_PRIVATE *psrc) ;
-
-/*========================================================================================
-*/
-
-#define	LINEAR_MAGIC_MARKER	MAKE_MAGIC ('l', 'i', 'n', 'e', 'a', 'r')
-
-#define	SRC_DEBUG	0
-
-typedef struct
-{	int		linear_magic_marker ;
-	int		channels ;
-	int		reset ;
-	long	in_count, in_used ;
-	long	out_count, out_gen ;
-	float	last_value [1] ;
-} LINEAR_DATA ;
-
-/*----------------------------------------------------------------------------------------
-*/
-
-static int
-linear_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
-{	LINEAR_DATA *linear ;
-	double		src_ratio, input_index, rem ;
-	int			ch ;
-
-	if (psrc-&gt;private_data == NULL)
-		return SRC_ERR_NO_PRIVATE ;
-
-	linear = (LINEAR_DATA*) psrc-&gt;private_data ;
-
-	if (linear-&gt;reset)
-	{	/* If we have just been reset, set the last_value data. */
-		for (ch = 0 ; ch &lt; linear-&gt;channels ; ch++)
-			linear-&gt;last_value [ch] = data-&gt;data_in [ch] ;
-		linear-&gt;reset = 0 ;
-		} ;
-
-	linear-&gt;in_count = data-&gt;input_frames * linear-&gt;channels ;
-	linear-&gt;out_count = data-&gt;output_frames * linear-&gt;channels ;
-	linear-&gt;in_used = linear-&gt;out_gen = 0 ;
-
-	src_ratio = psrc-&gt;last_ratio ;
-	input_index = psrc-&gt;last_position ;
-
-	/* Calculate samples before first sample in input array. */
-	while (input_index &lt; 1.0 &amp;&amp; linear-&gt;out_gen &lt; linear-&gt;out_count)
-	{
-		if (linear-&gt;in_used + linear-&gt;channels * input_index &gt; linear-&gt;in_count)
-			break ;
-
-		if (linear-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; SRC_MIN_RATIO_DIFF)
-			src_ratio = psrc-&gt;last_ratio + linear-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / linear-&gt;out_count ;
-
-		for (ch = 0 ; ch &lt; linear-&gt;channels ; ch++)
-		{	data-&gt;data_out [linear-&gt;out_gen] = (float) (linear-&gt;last_value [ch] + input_index *
-										(data-&gt;data_in [ch] - linear-&gt;last_value [ch])) ;
-			linear-&gt;out_gen ++ ;
-			} ;
-
-		/* Figure out the next index. */
-		input_index += 1.0 / src_ratio ;
-		} ;
-
-	rem = fmod_one (input_index) ;
-	linear-&gt;in_used += linear-&gt;channels * lrint (input_index - rem) ;
-	input_index = rem ;
-
-	/* Main processing loop. */
-	while (linear-&gt;out_gen &lt; linear-&gt;out_count &amp;&amp; linear-&gt;in_used + linear-&gt;channels * input_index &lt;= linear-&gt;in_count)
-	{
-		if (linear-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; SRC_MIN_RATIO_DIFF)
-			src_ratio = psrc-&gt;last_ratio + linear-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / linear-&gt;out_count ;
-
-		if (SRC_DEBUG &amp;&amp; linear-&gt;in_used &lt; linear-&gt;channels &amp;&amp; input_index &lt; 1.0)
-		{	printf (&quot;Whoops!!!!   in_used : %ld     channels : %d     input_index : %f\n&quot;, linear-&gt;in_used, linear-&gt;channels, input_index) ;
-			exit (1) ;
-			} ;
-
-		for (ch = 0 ; ch &lt; linear-&gt;channels ; ch++)
-		{	data-&gt;data_out [linear-&gt;out_gen] = (float) (data-&gt;data_in [linear-&gt;in_used - linear-&gt;channels + ch] + input_index *
-						(data-&gt;data_in [linear-&gt;in_used + ch] - data-&gt;data_in [linear-&gt;in_used - linear-&gt;channels + ch])) ;
-			linear-&gt;out_gen ++ ;
-			} ;
-
-		/* Figure out the next index. */
-		input_index += 1.0 / src_ratio ;
-		rem = fmod_one (input_index) ;
-
-		linear-&gt;in_used += linear-&gt;channels * lrint (input_index - rem) ;
-		input_index = rem ;
-		} ;
-
-	if (linear-&gt;in_used &gt; linear-&gt;in_count)
-	{	input_index += (linear-&gt;in_used - linear-&gt;in_count) / linear-&gt;channels ;
-		linear-&gt;in_used = linear-&gt;in_count ;
-		} ;
-
-	psrc-&gt;last_position = input_index ;
-
-	if (linear-&gt;in_used &gt; 0)
-		for (ch = 0 ; ch &lt; linear-&gt;channels ; ch++)
-			linear-&gt;last_value [ch] = data-&gt;data_in [linear-&gt;in_used - linear-&gt;channels + ch] ;
-
-	/* Save current ratio rather then target ratio. */
-	psrc-&gt;last_ratio = src_ratio ;
-
-	data-&gt;input_frames_used = linear-&gt;in_used / linear-&gt;channels ;
-	data-&gt;output_frames_gen = linear-&gt;out_gen / linear-&gt;channels ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* linear_vari_process */
-
-/*------------------------------------------------------------------------------
-*/
-
-const char*
-linear_get_name (int src_enum)
-{
-	if (src_enum == SRC_LINEAR)
-		return &quot;Linear Interpolator&quot; ;
-
-	return NULL ;
-} /* linear_get_name */
-
-const char*
-linear_get_description (int src_enum)
-{
-	if (src_enum == SRC_LINEAR)
-		return &quot;Linear interpolator, very fast, poor quality.&quot; ;
-
-	return NULL ;
-} /* linear_get_descrition */
-
-int
-linear_set_converter (SRC_PRIVATE *psrc, int src_enum)
-{	LINEAR_DATA *linear = NULL ;
-
-	if (src_enum != SRC_LINEAR)
-		return SRC_ERR_BAD_CONVERTER ;
-
-	if (psrc-&gt;private_data != NULL)
-	{	linear = (LINEAR_DATA*) psrc-&gt;private_data ;
-		if (linear-&gt;linear_magic_marker != LINEAR_MAGIC_MARKER)
-		{	free (psrc-&gt;private_data) ;
-			psrc-&gt;private_data = NULL ;
-			} ;
-		} ;
-
-	if (psrc-&gt;private_data == NULL)
-	{	linear = calloc (1, sizeof (*linear) + psrc-&gt;channels * sizeof (float)) ;
-		if (linear == NULL)
-			return SRC_ERR_MALLOC_FAILED ;
-		psrc-&gt;private_data = linear ;
-		} ;
-
-	linear-&gt;linear_magic_marker = LINEAR_MAGIC_MARKER ;
-	linear-&gt;channels = psrc-&gt;channels ;
-
-	psrc-&gt;const_process = linear_vari_process ;
-	psrc-&gt;vari_process = linear_vari_process ;
-	psrc-&gt;reset = linear_reset ;
-
-	linear_reset (psrc) ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* linear_set_converter */
-
-/*===================================================================================
-*/
-
-static void
-linear_reset (SRC_PRIVATE *psrc)
-{	LINEAR_DATA *linear = NULL ;
-
-	linear = (LINEAR_DATA*) psrc-&gt;private_data ;
-	if (linear == NULL)
-		return ;
-
-	linear-&gt;channels = psrc-&gt;channels ;
-	linear-&gt;reset = 1 ;
-
-	memset (linear-&gt;last_value, 0, sizeof (linear-&gt;last_value [0]) * linear-&gt;channels) ;
-} /* linear_reset */
-
+/*
+** Copyright (C) 2002-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/*
+** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
+** use license for this code is available, please see:
+**		<A HREF="http://www.mega-nerd.com/SRC/procedure.html">http://www.mega-nerd.com/SRC/procedure.html</A>
+*/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;float_cast.h&quot;
+#include &quot;common.h&quot;
+
+static int linear_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static void linear_reset (SRC_PRIVATE *psrc) ;
+
+/*========================================================================================
+*/
+
+#define	LINEAR_MAGIC_MARKER	MAKE_MAGIC ('l', 'i', 'n', 'e', 'a', 'r')
+
+#define	SRC_DEBUG	0
+
+typedef struct
+{	int		linear_magic_marker ;
+	int		channels ;
+	int		reset ;
+	long	in_count, in_used ;
+	long	out_count, out_gen ;
+	float	last_value [1] ;
+} LINEAR_DATA ;
+
+/*----------------------------------------------------------------------------------------
+*/
+
+static int
+linear_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	LINEAR_DATA *priv ;
+	double		src_ratio, input_index, rem ;
+	int			ch ;
+
+	if (psrc-&gt;private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	priv = (LINEAR_DATA*) psrc-&gt;private_data ;
+
+	if (priv-&gt;reset)
+	{	/* If we have just been reset, set the last_value data. */
+		for (ch = 0 ; ch &lt; priv-&gt;channels ; ch++)
+			priv-&gt;last_value [ch] = data-&gt;data_in [ch] ;
+		priv-&gt;reset = 0 ;
+		} ;
+
+	priv-&gt;in_count = data-&gt;input_frames * priv-&gt;channels ;
+	priv-&gt;out_count = data-&gt;output_frames * priv-&gt;channels ;
+	priv-&gt;in_used = priv-&gt;out_gen = 0 ;
+
+	src_ratio = psrc-&gt;last_ratio ;
+	input_index = psrc-&gt;last_position ;
+
+	/* Calculate samples before first sample in input array. */
+	while (input_index &lt; 1.0 &amp;&amp; priv-&gt;out_gen &lt; priv-&gt;out_count)
+	{
+		if (priv-&gt;in_used + priv-&gt;channels * (1.0 + input_index) &gt;= priv-&gt;in_count)
+			break ;
+
+		if (priv-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; SRC_MIN_RATIO_DIFF)
+			src_ratio = psrc-&gt;last_ratio + priv-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / priv-&gt;out_count ;
+
+		for (ch = 0 ; ch &lt; priv-&gt;channels ; ch++)
+		{	data-&gt;data_out [priv-&gt;out_gen] = (float) (priv-&gt;last_value [ch] + input_index *
+										(data-&gt;data_in [ch] - priv-&gt;last_value [ch])) ;
+			priv-&gt;out_gen ++ ;
+			} ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		} ;
+
+	rem = fmod_one (input_index) ;
+	priv-&gt;in_used += priv-&gt;channels * lrint (input_index - rem) ;
+	input_index = rem ;
+
+	/* Main processing loop. */
+	while (priv-&gt;out_gen &lt; priv-&gt;out_count &amp;&amp; priv-&gt;in_used + priv-&gt;channels * input_index &lt; priv-&gt;in_count)
+	{
+		if (priv-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; SRC_MIN_RATIO_DIFF)
+			src_ratio = psrc-&gt;last_ratio + priv-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / priv-&gt;out_count ;
+
+		if (SRC_DEBUG &amp;&amp; priv-&gt;in_used &lt; priv-&gt;channels &amp;&amp; input_index &lt; 1.0)
+		{	printf (&quot;Whoops!!!!   in_used : %ld     channels : %d     input_index : %f\n&quot;, priv-&gt;in_used, priv-&gt;channels, input_index) ;
+			exit (1) ;
+			} ;
+
+		for (ch = 0 ; ch &lt; priv-&gt;channels ; ch++)
+		{	data-&gt;data_out [priv-&gt;out_gen] = (float) (data-&gt;data_in [priv-&gt;in_used - priv-&gt;channels + ch] + input_index *
+						(data-&gt;data_in [priv-&gt;in_used + ch] - data-&gt;data_in [priv-&gt;in_used - priv-&gt;channels + ch])) ;
+			priv-&gt;out_gen ++ ;
+			} ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		priv-&gt;in_used += priv-&gt;channels * lrint (input_index - rem) ;
+		input_index = rem ;
+		} ;
+
+	if (priv-&gt;in_used &gt; priv-&gt;in_count)
+	{	input_index += (priv-&gt;in_used - priv-&gt;in_count) / priv-&gt;channels ;
+		priv-&gt;in_used = priv-&gt;in_count ;
+		} ;
+
+	psrc-&gt;last_position = input_index ;
+
+	if (priv-&gt;in_used &gt; 0)
+		for (ch = 0 ; ch &lt; priv-&gt;channels ; ch++)
+			priv-&gt;last_value [ch] = data-&gt;data_in [priv-&gt;in_used - priv-&gt;channels + ch] ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc-&gt;last_ratio = src_ratio ;
+
+	data-&gt;input_frames_used = priv-&gt;in_used / priv-&gt;channels ;
+	data-&gt;output_frames_gen = priv-&gt;out_gen / priv-&gt;channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* linear_vari_process */
+
+/*------------------------------------------------------------------------------
+*/
+
+const char*
+linear_get_name (int src_enum)
+{
+	if (src_enum == SRC_LINEAR)
+		return &quot;Linear Interpolator&quot; ;
+
+	return NULL ;
+} /* linear_get_name */
+
+const char*
+linear_get_description (int src_enum)
+{
+	if (src_enum == SRC_LINEAR)
+		return &quot;Linear interpolator, very fast, poor quality.&quot; ;
+
+	return NULL ;
+} /* linear_get_descrition */
+
+int
+linear_set_converter (SRC_PRIVATE *psrc, int src_enum)
+{	LINEAR_DATA *priv = NULL ;
+
+	if (src_enum != SRC_LINEAR)
+		return SRC_ERR_BAD_CONVERTER ;
+
+	if (psrc-&gt;private_data != NULL)
+	{	free (psrc-&gt;private_data) ;
+		psrc-&gt;private_data = NULL ;
+		} ;
+
+	if (psrc-&gt;private_data == NULL)
+	{	priv = calloc (1, sizeof (*priv) + psrc-&gt;channels * sizeof (float)) ;
+		if (priv == NULL)
+			return SRC_ERR_MALLOC_FAILED ;
+		psrc-&gt;private_data = priv ;
+		} ;
+
+	priv-&gt;linear_magic_marker = LINEAR_MAGIC_MARKER ;
+	priv-&gt;channels = psrc-&gt;channels ;
+
+	psrc-&gt;const_process = linear_vari_process ;
+	psrc-&gt;vari_process = linear_vari_process ;
+	psrc-&gt;reset = linear_reset ;
+
+	linear_reset (psrc) ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* linear_set_converter */
+
+/*===================================================================================
+*/
+
+static void
+linear_reset (SRC_PRIVATE *psrc)
+{	LINEAR_DATA *priv = NULL ;
+
+	priv = (LINEAR_DATA*) psrc-&gt;private_data ;
+	if (priv == NULL)
+		return ;
+
+	priv-&gt;channels = psrc-&gt;channels ;
+	priv-&gt;reset = 1 ;
+	memset (priv-&gt;last_value, 0, sizeof (priv-&gt;last_value [0]) * priv-&gt;channels) ;
+
+	return ;
+} /* linear_reset */
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_sinc.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_sinc.c	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_sinc.c	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,471 +1,1204 @@
-/*
-** Copyright (C) 2002-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/*
-** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
-** use license for this code is available, please see:
-**		<A HREF="http://www.mega-nerd.com/SRC/procedure.html">http://www.mega-nerd.com/SRC/procedure.html</A>
-*/
-#if 0 // MEANX
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &quot;config.h&quot;
-#else
-#include &quot;ADM_default.h&quot;
-#endif
-#include &quot;float_cast.h&quot;
-#include &quot;common.h&quot;
-
-#define	SINC_MAGIC_MARKER	MAKE_MAGIC (' ', 's', 'i', 'n', 'c', ' ')
-
-/*========================================================================================
-*/
-
-#define MAKE_INCREMENT_T(x) 	((increment_t) (x))
-
-#define	SHIFT_BITS				12
-#define	FP_ONE					((double) (((increment_t) 1) &lt;&lt; SHIFT_BITS))
-#define	INV_FP_ONE				(1.0 / FP_ONE)
-
-/*========================================================================================
-*/
-
-typedef int32_t increment_t ;
-typedef float	coeff_t ;
-
-#include &quot;fastest_coeffs.h&quot;
-#include &quot;mid_qual_coeffs.h&quot;
-#include &quot;high_qual_coeffs.h&quot;
-
-typedef struct
-{	int		sinc_magic_marker ;
-
-	int		channels ;
-	long	in_count, in_used ;
-	long	out_count, out_gen ;
-
-	int		coeff_half_len, index_inc ;
-
-	double	src_ratio, input_index ;
-
-	coeff_t const	*coeffs ;
-
-	int		b_current, b_end, b_real_end, b_len ;
-	float	buffer [1] ;
-} SINC_FILTER ;
-
-static int sinc_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
-
-static double calc_output (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, int ch) ;
-
-static void prepare_data (SINC_FILTER *filter, SRC_DATA *data, int half_filter_chan_len) ;
-
-static void sinc_reset (SRC_PRIVATE *psrc) ;
-
-static inline increment_t
-double_to_fp (double x)
-{	if (sizeof (increment_t) == 8)
-		return (llrint ((x) * FP_ONE)) ;
-	return (lrint ((x) * FP_ONE)) ;
-} /* double_to_fp */
-
-static inline increment_t
-int_to_fp (int x)
-{	return (((increment_t) (x)) &lt;&lt; SHIFT_BITS) ;
-} /* int_to_fp */
-
-static inline int
-fp_to_int (increment_t x)
-{	return (((x) &gt;&gt; SHIFT_BITS)) ;
-} /* fp_to_int */
-
-static inline increment_t
-fp_fraction_part (increment_t x)
-{	return ((x) &amp; ((((increment_t) 1) &lt;&lt; SHIFT_BITS) - 1)) ;
-} /* fp_fraction_part */
-
-static inline double
-fp_to_double (increment_t x)
-{	return fp_fraction_part (x) * INV_FP_ONE ;
-} /* fp_to_double */
-
-
-/*----------------------------------------------------------------------------------------
-*/
-
-const char*
-sinc_get_name (int src_enum)
-{
-	switch (src_enum)
-	{	case SRC_SINC_BEST_QUALITY :
-			return &quot;Best Sinc Interpolator&quot; ;
-
-		case SRC_SINC_MEDIUM_QUALITY :
-			return &quot;Medium Sinc Interpolator&quot; ;
-
-		case SRC_SINC_FASTEST :
-			return &quot;Fastest Sinc Interpolator&quot; ;
-
-		default: break ;
-		} ;
-
-	return NULL ;
-} /* sinc_get_descrition */
-
-const char*
-sinc_get_description (int src_enum)
-{
-	switch (src_enum)
-	{	case SRC_SINC_FASTEST :
-			return &quot;Band limited sinc interpolation, fastest, 97dB SNR, 80% BW.&quot; ;
-
-		case SRC_SINC_MEDIUM_QUALITY :
-			return &quot;Band limited sinc interpolation, medium quality, 121dB SNR, 90% BW.&quot; ;
-
-		case SRC_SINC_BEST_QUALITY :
-			return &quot;Band limited sinc interpolation, best quality, 145dB SNR, 96% BW.&quot; ;
-
-		default :
-			break ;
-		} ;
-
-	return NULL ;
-} /* sinc_get_descrition */
-
-int
-sinc_set_converter (SRC_PRIVATE *psrc, int src_enum)
-{	SINC_FILTER *filter, temp_filter ;
-	increment_t count ;
-	int bits ;
-
-	/* Quick sanity check. */
-	if (SHIFT_BITS &gt;= sizeof (increment_t) * 8 - 1)
-		return SRC_ERR_SHIFT_BITS ;
-
-	if (psrc-&gt;private_data != NULL)
-	{	filter = (SINC_FILTER*) psrc-&gt;private_data ;
-		if (filter-&gt;sinc_magic_marker != SINC_MAGIC_MARKER)
-		{	free (psrc-&gt;private_data) ;
-			psrc-&gt;private_data = NULL ;
-			} ;
-		} ;
-
-	memset (&amp;temp_filter, 0, sizeof (temp_filter)) ;
-
-	temp_filter.sinc_magic_marker = SINC_MAGIC_MARKER ;
-	temp_filter.channels = psrc-&gt;channels ;
-
-	psrc-&gt;const_process = sinc_vari_process ;
-	psrc-&gt;vari_process = sinc_vari_process ;
-	psrc-&gt;reset = sinc_reset ;
-
-	switch (src_enum)
-	{	case SRC_SINC_FASTEST :
-				temp_filter.coeffs = fastest_coeffs.coeffs ;
-				temp_filter.coeff_half_len = ARRAY_LEN (fastest_coeffs.coeffs) - 1 ;
-				temp_filter.index_inc = fastest_coeffs.increment ;
-				break ;
-
-		case SRC_SINC_MEDIUM_QUALITY :
-				temp_filter.coeffs = slow_mid_qual_coeffs.coeffs ;
-				temp_filter.coeff_half_len = ARRAY_LEN (slow_mid_qual_coeffs.coeffs) - 1 ;
-				temp_filter.index_inc = slow_mid_qual_coeffs.increment ;
-				break ;
-
-		case SRC_SINC_BEST_QUALITY :
-				temp_filter.coeffs = slow_high_qual_coeffs.coeffs ;
-				temp_filter.coeff_half_len = ARRAY_LEN (slow_high_qual_coeffs.coeffs) - 1 ;
-				temp_filter.index_inc = slow_high_qual_coeffs.increment ;
-				break ;
-
-		default :
-				return SRC_ERR_BAD_CONVERTER ;
-		} ;
-
-	/*
-	** FIXME : This needs to be looked at more closely to see if there is
-	** a better way. Need to look at prepare_data () at the same time.
-	*/
-
-	temp_filter.b_len = 2 * lrint (1.0 + temp_filter.coeff_half_len / (temp_filter.index_inc * 1.0) * SRC_MAX_RATIO) ;
-	temp_filter.b_len = MAX (temp_filter.b_len, 4096) ;
-	temp_filter.b_len *= temp_filter.channels ;
-
-	if ((filter = calloc (1, sizeof (SINC_FILTER) + sizeof (filter-&gt;buffer [0]) * (temp_filter.b_len + temp_filter.channels))) == NULL)
-		return SRC_ERR_MALLOC_FAILED ;
-
-	*filter = temp_filter ;
-	memset (&amp;temp_filter, 0xEE, sizeof (temp_filter)) ;
-
-	psrc-&gt;private_data = filter ;
-
-	sinc_reset (psrc) ;
-
-	count = filter-&gt;coeff_half_len ;
-	for (bits = 0 ; (MAKE_INCREMENT_T (1) &lt;&lt; bits) &lt; count ; bits++)
-		count |= (MAKE_INCREMENT_T (1) &lt;&lt; bits) ;
-
-	if (bits + SHIFT_BITS - 1 &gt;= (int) (sizeof (increment_t) * 8))
-		return SRC_ERR_FILTER_LEN ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* sinc_set_converter */
-
-static void
-sinc_reset (SRC_PRIVATE *psrc)
-{	SINC_FILTER *filter ;
-
-	filter = (SINC_FILTER*) psrc-&gt;private_data ;
-	if (filter == NULL)
-		return ;
-
-	filter-&gt;b_current = filter-&gt;b_end = 0 ;
-	filter-&gt;b_real_end = -1 ;
-
-	filter-&gt;src_ratio = filter-&gt;input_index = 0.0 ;
-
-	memset (filter-&gt;buffer, 0, filter-&gt;b_len * sizeof (filter-&gt;buffer [0])) ;
-
-	/* Set this for a sanity check */
-	memset (filter-&gt;buffer + filter-&gt;b_len, 0xAA, filter-&gt;channels * sizeof (filter-&gt;buffer [0])) ;
-} /* sinc_reset */
-
-/*========================================================================================
-**	Beware all ye who dare pass this point. There be dragons here.
-*/
-
-static int
-sinc_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
-{	SINC_FILTER *filter ;
-	double		input_index, src_ratio, count, float_increment, terminate, rem ;
-	increment_t	increment, start_filter_index ;
-	int			half_filter_chan_len, samples_in_hand, ch ;
-
-	if (psrc-&gt;private_data == NULL)
-		return SRC_ERR_NO_PRIVATE ;
-
-	filter = (SINC_FILTER*) psrc-&gt;private_data ;
-
-	/* If there is not a problem, this will be optimised out. */
-	if (sizeof (filter-&gt;buffer [0]) != sizeof (data-&gt;data_in [0]))
-		return SRC_ERR_SIZE_INCOMPATIBILITY ;
-
-	filter-&gt;in_count = data-&gt;input_frames * filter-&gt;channels ;
-	filter-&gt;out_count = data-&gt;output_frames * filter-&gt;channels ;
-	filter-&gt;in_used = filter-&gt;out_gen = 0 ;
-
-	src_ratio = psrc-&gt;last_ratio ;
-
-	/* Check the sample rate ratio wrt the buffer len. */
-	count = (filter-&gt;coeff_half_len + 2.0) / filter-&gt;index_inc ;
-	if (MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) &lt; 1.0)
-		count /= MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) ;
-
-	/* Maximum coefficientson either side of center point. */
-	half_filter_chan_len = filter-&gt;channels * (lrint (count) + 1) ;
-
-	input_index = psrc-&gt;last_position ;
-	float_increment = filter-&gt;index_inc ;
-
-	rem = fmod_one (input_index) ;
-	filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
-	input_index = rem ;
-
-	terminate = 1.0 / src_ratio + 1e-20 ;
-
-	/* Main processing loop. */
-	while (filter-&gt;out_gen &lt; filter-&gt;out_count)
-	{
-		/* Need to reload buffer? */
-		samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
-
-		if (samples_in_hand &lt;= half_filter_chan_len)
-		{	prepare_data (filter, data, half_filter_chan_len) ;
-
-			samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
-			if (samples_in_hand &lt;= half_filter_chan_len)
-				break ;
-			} ;
-
-		/* This is the termination condition. */
-		if (filter-&gt;b_real_end &gt;= 0)
-		{	if (filter-&gt;b_current + input_index + terminate &gt;= filter-&gt;b_real_end)
-				break ;
-			} ;
-
-		if (filter-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; 1e-10)
-			src_ratio = psrc-&gt;last_ratio + filter-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / filter-&gt;out_count ;
-
-		float_increment = filter-&gt;index_inc * 1.0 ;
-		if (src_ratio &lt; 1.0)
-			float_increment = filter-&gt;index_inc * src_ratio ;
-
-		increment = double_to_fp (float_increment) ;
-
-		start_filter_index = double_to_fp (input_index * float_increment) ;
-
-		for (ch = 0 ; ch &lt; filter-&gt;channels ; ch++)
-		{	data-&gt;data_out [filter-&gt;out_gen] = (float) ((float_increment / filter-&gt;index_inc) *
-											calc_output (filter, increment, start_filter_index, ch)) ;
-			filter-&gt;out_gen ++ ;
-			} ;
-
-		/* Figure out the next index. */
-		input_index += 1.0 / src_ratio ;
-		rem = fmod_one (input_index) ;
-
-		filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
-		input_index = rem ;
-		} ;
-
-	psrc-&gt;last_position = input_index ;
-
-	/* Save current ratio rather then target ratio. */
-	psrc-&gt;last_ratio = src_ratio ;
-
-	data-&gt;input_frames_used = filter-&gt;in_used / filter-&gt;channels ;
-	data-&gt;output_frames_gen = filter-&gt;out_gen / filter-&gt;channels ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* sinc_vari_process */
-
-/*----------------------------------------------------------------------------------------
-*/
-
-static void
-prepare_data (SINC_FILTER *filter, SRC_DATA *data, int half_filter_chan_len)
-{	int len = 0 ;
-
-	if (filter-&gt;b_real_end &gt;= 0)
-		return ;	/* This doesn't make sense, so return. */
-
-	if (filter-&gt;b_current == 0)
-	{	/* Initial state. Set up zeros at the start of the buffer and
-		** then load new data after that.
-		*/
-		len = filter-&gt;b_len - 2 * half_filter_chan_len ;
-
-		filter-&gt;b_current = filter-&gt;b_end = half_filter_chan_len ;
-		}
-	else if (filter-&gt;b_end + half_filter_chan_len + filter-&gt;channels &lt; filter-&gt;b_len)
-	{	/*  Load data at current end position. */
-		len = MAX (filter-&gt;b_len - filter-&gt;b_current - half_filter_chan_len, 0) ;
-		}
-	else
-	{	/* Move data at end of buffer back to the start of the buffer. */
-		len = filter-&gt;b_end - filter-&gt;b_current ;
-		memmove (filter-&gt;buffer, filter-&gt;buffer + filter-&gt;b_current - half_filter_chan_len,
-						(half_filter_chan_len + len) * sizeof (filter-&gt;buffer [0])) ;
-
-		filter-&gt;b_current = half_filter_chan_len ;
-		filter-&gt;b_end = filter-&gt;b_current + len ;
-
-		/* Now load data at current end of buffer. */
-		len = MAX (filter-&gt;b_len - filter-&gt;b_current - half_filter_chan_len, 0) ;
-		} ;
-
-	len = MIN (filter-&gt;in_count - filter-&gt;in_used, len) ;
-	len -= (len % filter-&gt;channels) ;
-
-	memcpy (filter-&gt;buffer + filter-&gt;b_end, data-&gt;data_in + filter-&gt;in_used,
-						len * sizeof (filter-&gt;buffer [0])) ;
-
-	filter-&gt;b_end += len ;
-	filter-&gt;in_used += len ;
-
-	if (filter-&gt;in_used == filter-&gt;in_count &amp;&amp;
-			filter-&gt;b_end - filter-&gt;b_current &lt; 2 * half_filter_chan_len &amp;&amp; data-&gt;end_of_input)
-	{	/* Handle the case where all data in the current buffer has been
-		** consumed and this is the last buffer.
-		*/
-
-		if (filter-&gt;b_len - filter-&gt;b_end &lt; half_filter_chan_len + 5)
-		{	/* If necessary, move data down to the start of the buffer. */
-			len = filter-&gt;b_end - filter-&gt;b_current ;
-			memmove (filter-&gt;buffer, filter-&gt;buffer + filter-&gt;b_current - half_filter_chan_len,
-							(half_filter_chan_len + len) * sizeof (filter-&gt;buffer [0])) ;
-
-			filter-&gt;b_current = half_filter_chan_len ;
-			filter-&gt;b_end = filter-&gt;b_current + len ;
-			} ;
-
-		filter-&gt;b_real_end = filter-&gt;b_end ;
-		len = half_filter_chan_len + 5 ;
-
-		memset (filter-&gt;buffer + filter-&gt;b_end, 0, len * sizeof (filter-&gt;buffer [0])) ;
-		filter-&gt;b_end += len ;
-		} ;
-
-	return ;
-} /* prepare_data */
-
-
-static double
-calc_output (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, int ch)
-{	double		fraction, left, right, icoeff ;
-	increment_t	filter_index, max_filter_index ;
-	int			data_index, coeff_count, indx ;
-
-	/* Convert input parameters into fixed point. */
-	max_filter_index = int_to_fp (filter-&gt;coeff_half_len) ;
-
-	/* First apply the left half of the filter. */
-	filter_index = start_filter_index ;
-	coeff_count = (max_filter_index - filter_index) / increment ;
-	filter_index = filter_index + coeff_count * increment ;
-	data_index = filter-&gt;b_current - filter-&gt;channels * coeff_count + ch ;
-
-	left = 0.0 ;
-	do
-	{	fraction = fp_to_double (filter_index) ;
-		indx = fp_to_int (filter_index) ;
-
-		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
-
-		left += icoeff * filter-&gt;buffer [data_index] ;
-
-		filter_index -= increment ;
-		data_index = data_index + filter-&gt;channels ;
-		}
-	while (filter_index &gt;= MAKE_INCREMENT_T (0)) ;
-
-	/* Now apply the right half of the filter. */
-	filter_index = increment - start_filter_index ;
-	coeff_count = (max_filter_index - filter_index) / increment ;
-	filter_index = filter_index + coeff_count * increment ;
-	data_index = filter-&gt;b_current + filter-&gt;channels * (1 + coeff_count) + ch ;
-
-	right = 0.0 ;
-	do
-	{	fraction = fp_to_double (filter_index) ;
-		indx = fp_to_int (filter_index) ;
-
-		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
-
-		right += icoeff * filter-&gt;buffer [data_index] ;
-
-		filter_index -= increment ;
-		data_index = data_index - filter-&gt;channels ;
-		}
-	while (filter_index &gt; MAKE_INCREMENT_T (0)) ;
-
-	return (left + right) ;
-} /* calc_output */
-
+/*
+** Copyright (C) 2002-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/*
+** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
+** use license for this code is available, please see:
+**		<A HREF="http://www.mega-nerd.com/SRC/procedure.html">http://www.mega-nerd.com/SRC/procedure.html</A>
+*/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;float_cast.h&quot;
+#include &quot;common.h&quot;
+
+#define	SINC_MAGIC_MARKER	MAKE_MAGIC (' ', 's', 'i', 'n', 'c', ' ')
+
+/*========================================================================================
+*/
+
+#define MAKE_INCREMENT_T(x) 	((increment_t) (x))
+
+#define	SHIFT_BITS				12
+#define	FP_ONE					((double) (((increment_t) 1) &lt;&lt; SHIFT_BITS))
+#define	INV_FP_ONE				(1.0 / FP_ONE)
+
+/*========================================================================================
+*/
+
+typedef int32_t increment_t ;
+typedef float	coeff_t ;
+
+#include &quot;fastest_coeffs.h&quot;
+#include &quot;mid_qual_coeffs.h&quot;
+#include &quot;high_qual_coeffs.h&quot;
+
+typedef struct
+{	int		sinc_magic_marker ;
+
+	int		channels ;
+	long	in_count, in_used ;
+	long	out_count, out_gen ;
+
+	int		coeff_half_len, index_inc ;
+
+	double	src_ratio, input_index ;
+
+	coeff_t const	*coeffs ;
+
+	int		b_current, b_end, b_real_end, b_len ;
+
+	/* Sure hope noone does more than 128 channels at once. */
+	double left_calc [128], right_calc [128] ;
+
+	/* C99 struct flexible array. */
+	float	buffer [] ;
+} SINC_FILTER ;
+
+static int sinc_multichan_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static int sinc_hex_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static int sinc_quad_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static int sinc_stereo_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static int sinc_mono_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+
+static int prepare_data (SINC_FILTER *filter, SRC_DATA *data, int half_filter_chan_len) WARN_UNUSED ;
+
+static void sinc_reset (SRC_PRIVATE *psrc) ;
+
+static inline increment_t
+double_to_fp (double x)
+{	return (lrint ((x) * FP_ONE)) ;
+} /* double_to_fp */
+
+static inline increment_t
+int_to_fp (int x)
+{	return (((increment_t) (x)) &lt;&lt; SHIFT_BITS) ;
+} /* int_to_fp */
+
+static inline int
+fp_to_int (increment_t x)
+{	return (((x) &gt;&gt; SHIFT_BITS)) ;
+} /* fp_to_int */
+
+static inline increment_t
+fp_fraction_part (increment_t x)
+{	return ((x) &amp; ((((increment_t) 1) &lt;&lt; SHIFT_BITS) - 1)) ;
+} /* fp_fraction_part */
+
+static inline double
+fp_to_double (increment_t x)
+{	return fp_fraction_part (x) * INV_FP_ONE ;
+} /* fp_to_double */
+
+
+/*----------------------------------------------------------------------------------------
+*/
+
+const char*
+sinc_get_name (int src_enum)
+{
+	switch (src_enum)
+	{	case SRC_SINC_BEST_QUALITY :
+			return &quot;Best Sinc Interpolator&quot; ;
+
+		case SRC_SINC_MEDIUM_QUALITY :
+			return &quot;Medium Sinc Interpolator&quot; ;
+
+		case SRC_SINC_FASTEST :
+			return &quot;Fastest Sinc Interpolator&quot; ;
+
+		default: break ;
+		} ;
+
+	return NULL ;
+} /* sinc_get_descrition */
+
+const char*
+sinc_get_description (int src_enum)
+{
+	switch (src_enum)
+	{	case SRC_SINC_FASTEST :
+			return &quot;Band limited sinc interpolation, fastest, 97dB SNR, 80% BW.&quot; ;
+
+		case SRC_SINC_MEDIUM_QUALITY :
+			return &quot;Band limited sinc interpolation, medium quality, 121dB SNR, 90% BW.&quot; ;
+
+		case SRC_SINC_BEST_QUALITY :
+			return &quot;Band limited sinc interpolation, best quality, 145dB SNR, 96% BW.&quot; ;
+
+		default :
+			break ;
+		} ;
+
+	return NULL ;
+} /* sinc_get_descrition */
+
+int
+sinc_set_converter (SRC_PRIVATE *psrc, int src_enum)
+{	SINC_FILTER *filter, temp_filter ;
+	increment_t count ;
+	int bits ;
+
+	/* Quick sanity check. */
+	if (SHIFT_BITS &gt;= sizeof (increment_t) * 8 - 1)
+		return SRC_ERR_SHIFT_BITS ;
+
+	if (psrc-&gt;private_data != NULL)
+	{	free (psrc-&gt;private_data) ;
+		psrc-&gt;private_data = NULL ;
+		} ;
+
+	memset (&amp;temp_filter, 0, sizeof (temp_filter)) ;
+
+	temp_filter.sinc_magic_marker = SINC_MAGIC_MARKER ;
+	temp_filter.channels = psrc-&gt;channels ;
+
+	if (psrc-&gt;channels &gt; ARRAY_LEN (temp_filter.left_calc))
+		return SRC_ERR_BAD_CHANNEL_COUNT ;
+	else if (psrc-&gt;channels == 1)
+	{	psrc-&gt;const_process = sinc_mono_vari_process ;
+		psrc-&gt;vari_process = sinc_mono_vari_process ;
+		}
+	else
+	if (psrc-&gt;channels == 2)
+	{	psrc-&gt;const_process = sinc_stereo_vari_process ;
+		psrc-&gt;vari_process = sinc_stereo_vari_process ;
+		}
+	else
+	if (psrc-&gt;channels == 4)
+	{	psrc-&gt;const_process = sinc_quad_vari_process ;
+		psrc-&gt;vari_process = sinc_quad_vari_process ;
+		}
+	else
+	if (psrc-&gt;channels == 6)
+	{	psrc-&gt;const_process = sinc_hex_vari_process ;
+		psrc-&gt;vari_process = sinc_hex_vari_process ;
+		}
+	else
+	{	psrc-&gt;const_process = sinc_multichan_vari_process ;
+		psrc-&gt;vari_process = sinc_multichan_vari_process ;
+		} ;
+	psrc-&gt;reset = sinc_reset ;
+
+	switch (src_enum)
+	{	case SRC_SINC_FASTEST :
+				temp_filter.coeffs = fastest_coeffs.coeffs ;
+				temp_filter.coeff_half_len = ARRAY_LEN (fastest_coeffs.coeffs) - 1 ;
+				temp_filter.index_inc = fastest_coeffs.increment ;
+				break ;
+
+		case SRC_SINC_MEDIUM_QUALITY :
+				temp_filter.coeffs = slow_mid_qual_coeffs.coeffs ;
+				temp_filter.coeff_half_len = ARRAY_LEN (slow_mid_qual_coeffs.coeffs) - 1 ;
+				temp_filter.index_inc = slow_mid_qual_coeffs.increment ;
+				break ;
+
+		case SRC_SINC_BEST_QUALITY :
+				temp_filter.coeffs = slow_high_qual_coeffs.coeffs ;
+				temp_filter.coeff_half_len = ARRAY_LEN (slow_high_qual_coeffs.coeffs) - 1 ;
+				temp_filter.index_inc = slow_high_qual_coeffs.increment ;
+				break ;
+
+		default :
+				return SRC_ERR_BAD_CONVERTER ;
+		} ;
+
+	/*
+	** FIXME : This needs to be looked at more closely to see if there is
+	** a better way. Need to look at prepare_data () at the same time.
+	*/
+
+	temp_filter.b_len = lrint (2.5 * temp_filter.coeff_half_len / (temp_filter.index_inc * 1.0) * SRC_MAX_RATIO) ;
+	temp_filter.b_len = MAX (temp_filter.b_len, 4096) ;
+	temp_filter.b_len *= temp_filter.channels ;
+
+	if ((filter = calloc (1, sizeof (SINC_FILTER) + sizeof (filter-&gt;buffer [0]) * (temp_filter.b_len + temp_filter.channels))) == NULL)
+		return SRC_ERR_MALLOC_FAILED ;
+
+	*filter = temp_filter ;
+	memset (&amp;temp_filter, 0xEE, sizeof (temp_filter)) ;
+
+	psrc-&gt;private_data = filter ;
+
+	sinc_reset (psrc) ;
+
+	count = filter-&gt;coeff_half_len ;
+	for (bits = 0 ; (MAKE_INCREMENT_T (1) &lt;&lt; bits) &lt; count ; bits++)
+		count |= (MAKE_INCREMENT_T (1) &lt;&lt; bits) ;
+
+	if (bits + SHIFT_BITS - 1 &gt;= (int) (sizeof (increment_t) * 8))
+		return SRC_ERR_FILTER_LEN ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_set_converter */
+
+static void
+sinc_reset (SRC_PRIVATE *psrc)
+{	SINC_FILTER *filter ;
+
+	filter = (SINC_FILTER*) psrc-&gt;private_data ;
+	if (filter == NULL)
+		return ;
+
+	filter-&gt;b_current = filter-&gt;b_end = 0 ;
+	filter-&gt;b_real_end = -1 ;
+
+	filter-&gt;src_ratio = filter-&gt;input_index = 0.0 ;
+
+	memset (filter-&gt;buffer, 0, filter-&gt;b_len * sizeof (filter-&gt;buffer [0])) ;
+
+	/* Set this for a sanity check */
+	memset (filter-&gt;buffer + filter-&gt;b_len, 0xAA, filter-&gt;channels * sizeof (filter-&gt;buffer [0])) ;
+} /* sinc_reset */
+
+/*========================================================================================
+**	Beware all ye who dare pass this point. There be dragons here.
+*/
+
+static inline double
+calc_output_single (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index)
+{	double		fraction, left, right, icoeff ;
+	increment_t	filter_index, max_filter_index ;
+	int			data_index, coeff_count, indx ;
+
+	/* Convert input parameters into fixed point. */
+	max_filter_index = int_to_fp (filter-&gt;coeff_half_len) ;
+
+	/* First apply the left half of the filter. */
+	filter_index = start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter-&gt;b_current - coeff_count ;
+
+	left = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
+
+		left += icoeff * filter-&gt;buffer [data_index] ;
+
+		filter_index -= increment ;
+		data_index = data_index + 1 ;
+		}
+	while (filter_index &gt;= MAKE_INCREMENT_T (0)) ;
+
+	/* Now apply the right half of the filter. */
+	filter_index = increment - start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter-&gt;b_current + 1 + coeff_count ;
+
+	right = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
+
+		right += icoeff * filter-&gt;buffer [data_index] ;
+
+		filter_index -= increment ;
+		data_index = data_index - 1 ;
+		}
+	while (filter_index &gt; MAKE_INCREMENT_T (0)) ;
+
+	return (left + right) ;
+} /* calc_output_single */
+
+static int
+sinc_mono_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc-&gt;private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc-&gt;private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter-&gt;buffer [0]) != sizeof (data-&gt;data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter-&gt;in_count = data-&gt;input_frames * filter-&gt;channels ;
+	filter-&gt;out_count = data-&gt;output_frames * filter-&gt;channels ;
+	filter-&gt;in_used = filter-&gt;out_gen = 0 ;
+
+	src_ratio = psrc-&gt;last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter-&gt;coeff_half_len + 2.0) / filter-&gt;index_inc ;
+	if (MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) &lt; 1.0)
+		count /= MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter-&gt;channels * (lrint (count) + 1) ;
+
+	input_index = psrc-&gt;last_position ;
+	float_increment = filter-&gt;index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter-&gt;out_gen &lt; filter-&gt;out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
+
+		if (samples_in_hand &lt;= half_filter_chan_len)
+		{	if ((psrc-&gt;error = prepare_data (filter, data, half_filter_chan_len)) != 0)
+				return psrc-&gt;error ;
+
+			samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
+			if (samples_in_hand &lt;= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter-&gt;b_real_end &gt;= 0)
+		{	if (filter-&gt;b_current + input_index + terminate &gt;= filter-&gt;b_real_end)
+				break ;
+			} ;
+
+		if (filter-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; 1e-10)
+			src_ratio = psrc-&gt;last_ratio + filter-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / filter-&gt;out_count ;
+
+		float_increment = filter-&gt;index_inc * 1.0 ;
+		if (src_ratio &lt; 1.0)
+			float_increment = filter-&gt;index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		data-&gt;data_out [filter-&gt;out_gen] = (float) ((float_increment / filter-&gt;index_inc) *
+										calc_output_single (filter, increment, start_filter_index)) ;
+		filter-&gt;out_gen ++ ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc-&gt;last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc-&gt;last_ratio = src_ratio ;
+
+	data-&gt;input_frames_used = filter-&gt;in_used / filter-&gt;channels ;
+	data-&gt;output_frames_gen = filter-&gt;out_gen / filter-&gt;channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_mono_vari_process */
+
+static inline void
+calc_output_stereo (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, double scale, float * output)
+{	double		fraction, left [2], right [2], icoeff ;
+	increment_t	filter_index, max_filter_index ;
+	int			data_index, coeff_count, indx ;
+
+	/* Convert input parameters into fixed point. */
+	max_filter_index = int_to_fp (filter-&gt;coeff_half_len) ;
+
+	/* First apply the left half of the filter. */
+	filter_index = start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter-&gt;b_current - filter-&gt;channels * coeff_count ;
+
+	left [0] = left [1] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
+
+		left [0] += icoeff * filter-&gt;buffer [data_index] ;
+		left [1] += icoeff * filter-&gt;buffer [data_index + 1] ;
+
+		filter_index -= increment ;
+		data_index = data_index + 2 ;
+		}
+	while (filter_index &gt;= MAKE_INCREMENT_T (0)) ;
+
+	/* Now apply the right half of the filter. */
+	filter_index = increment - start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter-&gt;b_current + filter-&gt;channels * (1 + coeff_count) ;
+
+	right [0] = right [1] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
+
+		right [0] += icoeff * filter-&gt;buffer [data_index] ;
+		right [1] += icoeff * filter-&gt;buffer [data_index + 1] ;
+
+		filter_index -= increment ;
+		data_index = data_index - 2 ;
+		}
+	while (filter_index &gt; MAKE_INCREMENT_T (0)) ;
+
+	output [0] = scale * (left [0] + right [0]) ;
+	output [1] = scale * (left [1] + right [1]) ;
+} /* calc_output_stereo */
+
+static int
+sinc_stereo_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc-&gt;private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc-&gt;private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter-&gt;buffer [0]) != sizeof (data-&gt;data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter-&gt;in_count = data-&gt;input_frames * filter-&gt;channels ;
+	filter-&gt;out_count = data-&gt;output_frames * filter-&gt;channels ;
+	filter-&gt;in_used = filter-&gt;out_gen = 0 ;
+
+	src_ratio = psrc-&gt;last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter-&gt;coeff_half_len + 2.0) / filter-&gt;index_inc ;
+	if (MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) &lt; 1.0)
+		count /= MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter-&gt;channels * (lrint (count) + 1) ;
+
+	input_index = psrc-&gt;last_position ;
+	float_increment = filter-&gt;index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter-&gt;out_gen &lt; filter-&gt;out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
+
+		if (samples_in_hand &lt;= half_filter_chan_len)
+		{	if ((psrc-&gt;error = prepare_data (filter, data, half_filter_chan_len)) != 0)
+				return psrc-&gt;error ;
+
+			samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
+			if (samples_in_hand &lt;= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter-&gt;b_real_end &gt;= 0)
+		{	if (filter-&gt;b_current + input_index + terminate &gt;= filter-&gt;b_real_end)
+				break ;
+			} ;
+
+		if (filter-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; 1e-10)
+			src_ratio = psrc-&gt;last_ratio + filter-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / filter-&gt;out_count ;
+
+		float_increment = filter-&gt;index_inc * 1.0 ;
+		if (src_ratio &lt; 1.0)
+			float_increment = filter-&gt;index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		calc_output_stereo (filter, increment, start_filter_index, float_increment / filter-&gt;index_inc, data-&gt;data_out + filter-&gt;out_gen) ;
+		filter-&gt;out_gen += 2 ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc-&gt;last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc-&gt;last_ratio = src_ratio ;
+
+	data-&gt;input_frames_used = filter-&gt;in_used / filter-&gt;channels ;
+	data-&gt;output_frames_gen = filter-&gt;out_gen / filter-&gt;channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_stereo_vari_process */
+
+static inline void
+calc_output_quad (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, double scale, float * output)
+{	double		fraction, left [4], right [4], icoeff ;
+	increment_t	filter_index, max_filter_index ;
+	int			data_index, coeff_count, indx ;
+
+	/* Convert input parameters into fixed point. */
+	max_filter_index = int_to_fp (filter-&gt;coeff_half_len) ;
+
+	/* First apply the left half of the filter. */
+	filter_index = start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter-&gt;b_current - filter-&gt;channels * coeff_count ;
+
+	left [0] = left [1] = left [2] = left [3] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
+
+		left [0] += icoeff * filter-&gt;buffer [data_index] ;
+		left [1] += icoeff * filter-&gt;buffer [data_index + 1] ;
+		left [2] += icoeff * filter-&gt;buffer [data_index + 2] ;
+		left [3] += icoeff * filter-&gt;buffer [data_index + 3] ;
+
+		filter_index -= increment ;
+		data_index = data_index + 4 ;
+		}
+	while (filter_index &gt;= MAKE_INCREMENT_T (0)) ;
+
+	/* Now apply the right half of the filter. */
+	filter_index = increment - start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter-&gt;b_current + filter-&gt;channels * (1 + coeff_count) ;
+
+	right [0] = right [1] = right [2] = right [3] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
+
+		right [0] += icoeff * filter-&gt;buffer [data_index] ;
+		right [1] += icoeff * filter-&gt;buffer [data_index + 1] ;
+		right [2] += icoeff * filter-&gt;buffer [data_index + 2] ;
+		right [3] += icoeff * filter-&gt;buffer [data_index + 3] ;
+
+		filter_index -= increment ;
+		data_index = data_index - 4 ;
+		}
+	while (filter_index &gt; MAKE_INCREMENT_T (0)) ;
+
+	output [0] = scale * (left [0] + right [0]) ;
+	output [1] = scale * (left [1] + right [1]) ;
+	output [2] = scale * (left [2] + right [2]) ;
+	output [3] = scale * (left [3] + right [3]) ;
+} /* calc_output_quad */
+
+static int
+sinc_quad_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc-&gt;private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc-&gt;private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter-&gt;buffer [0]) != sizeof (data-&gt;data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter-&gt;in_count = data-&gt;input_frames * filter-&gt;channels ;
+	filter-&gt;out_count = data-&gt;output_frames * filter-&gt;channels ;
+	filter-&gt;in_used = filter-&gt;out_gen = 0 ;
+
+	src_ratio = psrc-&gt;last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter-&gt;coeff_half_len + 2.0) / filter-&gt;index_inc ;
+	if (MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) &lt; 1.0)
+		count /= MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter-&gt;channels * (lrint (count) + 1) ;
+
+	input_index = psrc-&gt;last_position ;
+	float_increment = filter-&gt;index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter-&gt;out_gen &lt; filter-&gt;out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
+
+		if (samples_in_hand &lt;= half_filter_chan_len)
+		{	if ((psrc-&gt;error = prepare_data (filter, data, half_filter_chan_len)) != 0)
+				return psrc-&gt;error ;
+
+			samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
+			if (samples_in_hand &lt;= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter-&gt;b_real_end &gt;= 0)
+		{	if (filter-&gt;b_current + input_index + terminate &gt;= filter-&gt;b_real_end)
+				break ;
+			} ;
+
+		if (filter-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; 1e-10)
+			src_ratio = psrc-&gt;last_ratio + filter-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / filter-&gt;out_count ;
+
+		float_increment = filter-&gt;index_inc * 1.0 ;
+		if (src_ratio &lt; 1.0)
+			float_increment = filter-&gt;index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		calc_output_quad (filter, increment, start_filter_index, float_increment / filter-&gt;index_inc, data-&gt;data_out + filter-&gt;out_gen) ;
+		filter-&gt;out_gen += 4 ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc-&gt;last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc-&gt;last_ratio = src_ratio ;
+
+	data-&gt;input_frames_used = filter-&gt;in_used / filter-&gt;channels ;
+	data-&gt;output_frames_gen = filter-&gt;out_gen / filter-&gt;channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_quad_vari_process */
+
+static inline void
+calc_output_hex (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, double scale, float * output)
+{	double		fraction, left [6], right [6], icoeff ;
+	increment_t	filter_index, max_filter_index ;
+	int			data_index, coeff_count, indx ;
+
+	/* Convert input parameters into fixed point. */
+	max_filter_index = int_to_fp (filter-&gt;coeff_half_len) ;
+
+	/* First apply the left half of the filter. */
+	filter_index = start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter-&gt;b_current - filter-&gt;channels * coeff_count ;
+
+	left [0] = left [1] = left [2] = left [3] = left [4] = left [5] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
+
+		left [0] += icoeff * filter-&gt;buffer [data_index] ;
+		left [1] += icoeff * filter-&gt;buffer [data_index + 1] ;
+		left [2] += icoeff * filter-&gt;buffer [data_index + 2] ;
+		left [3] += icoeff * filter-&gt;buffer [data_index + 3] ;
+		left [4] += icoeff * filter-&gt;buffer [data_index + 4] ;
+		left [5] += icoeff * filter-&gt;buffer [data_index + 5] ;
+
+		filter_index -= increment ;
+		data_index = data_index + 6 ;
+		}
+	while (filter_index &gt;= MAKE_INCREMENT_T (0)) ;
+
+	/* Now apply the right half of the filter. */
+	filter_index = increment - start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter-&gt;b_current + filter-&gt;channels * (1 + coeff_count) ;
+
+	right [0] = right [1] = right [2] = right [3] = right [4] = right [5] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
+
+		right [0] += icoeff * filter-&gt;buffer [data_index] ;
+		right [1] += icoeff * filter-&gt;buffer [data_index + 1] ;
+		right [2] += icoeff * filter-&gt;buffer [data_index + 2] ;
+		right [3] += icoeff * filter-&gt;buffer [data_index + 3] ;
+		right [4] += icoeff * filter-&gt;buffer [data_index + 4] ;
+		right [5] += icoeff * filter-&gt;buffer [data_index + 5] ;
+
+		filter_index -= increment ;
+		data_index = data_index - 6 ;
+		}
+	while (filter_index &gt; MAKE_INCREMENT_T (0)) ;
+
+	output [0] = scale * (left [0] + right [0]) ;
+	output [1] = scale * (left [1] + right [1]) ;
+	output [2] = scale * (left [2] + right [2]) ;
+	output [3] = scale * (left [3] + right [3]) ;
+	output [4] = scale * (left [4] + right [4]) ;
+	output [5] = scale * (left [5] + right [5]) ;
+} /* calc_output_hex */
+
+static int
+sinc_hex_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc-&gt;private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc-&gt;private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter-&gt;buffer [0]) != sizeof (data-&gt;data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter-&gt;in_count = data-&gt;input_frames * filter-&gt;channels ;
+	filter-&gt;out_count = data-&gt;output_frames * filter-&gt;channels ;
+	filter-&gt;in_used = filter-&gt;out_gen = 0 ;
+
+	src_ratio = psrc-&gt;last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter-&gt;coeff_half_len + 2.0) / filter-&gt;index_inc ;
+	if (MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) &lt; 1.0)
+		count /= MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter-&gt;channels * (lrint (count) + 1) ;
+
+	input_index = psrc-&gt;last_position ;
+	float_increment = filter-&gt;index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter-&gt;out_gen &lt; filter-&gt;out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
+
+		if (samples_in_hand &lt;= half_filter_chan_len)
+		{	if ((psrc-&gt;error = prepare_data (filter, data, half_filter_chan_len)) != 0)
+				return psrc-&gt;error ;
+
+			samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
+			if (samples_in_hand &lt;= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter-&gt;b_real_end &gt;= 0)
+		{	if (filter-&gt;b_current + input_index + terminate &gt;= filter-&gt;b_real_end)
+				break ;
+			} ;
+
+		if (filter-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; 1e-10)
+			src_ratio = psrc-&gt;last_ratio + filter-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / filter-&gt;out_count ;
+
+		float_increment = filter-&gt;index_inc * 1.0 ;
+		if (src_ratio &lt; 1.0)
+			float_increment = filter-&gt;index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		calc_output_hex (filter, increment, start_filter_index, float_increment / filter-&gt;index_inc, data-&gt;data_out + filter-&gt;out_gen) ;
+		filter-&gt;out_gen += 6 ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc-&gt;last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc-&gt;last_ratio = src_ratio ;
+
+	data-&gt;input_frames_used = filter-&gt;in_used / filter-&gt;channels ;
+	data-&gt;output_frames_gen = filter-&gt;out_gen / filter-&gt;channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_hex_vari_process */
+
+static inline void
+calc_output_multi (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, int channels, double scale, float * output)
+{	double		fraction, icoeff ;
+	/* The following line is 1999 ISO Standard C. If your compiler complains, get a better compiler. */
+	double		*left, *right ;
+	increment_t	filter_index, max_filter_index ;
+	int			data_index, coeff_count, indx, ch ;
+
+	left = filter-&gt;left_calc ;
+	right = filter-&gt;right_calc ;
+
+	/* Convert input parameters into fixed point. */
+	max_filter_index = int_to_fp (filter-&gt;coeff_half_len) ;
+
+	/* First apply the left half of the filter. */
+	filter_index = start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter-&gt;b_current - channels * coeff_count ;
+
+	memset (left, 0, sizeof (left [0]) * channels) ;
+
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
+
+		/*
+		**	Duff's Device.
+		**	See : <A HREF="http://en.wikipedia.org/wiki/Duff">http://en.wikipedia.org/wiki/Duff</A>'s_device
+		*/
+		ch = channels ;
+		do
+		{
+			switch (ch % 8)
+			{	default :
+					ch -- ;
+					left [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 7 :
+					ch -- ;
+					left [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 6 :
+					ch -- ;
+					left [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 5 :
+					ch -- ;
+					left [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 4 :
+					ch -- ;
+					left [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 3 :
+					ch -- ;
+					left [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 2 :
+					ch -- ;
+					left [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 1 :
+					ch -- ;
+					left [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				} ;
+			}
+		while (ch &gt; 0) ;
+
+		filter_index -= increment ;
+		data_index = data_index + channels ;
+		}
+	while (filter_index &gt;= MAKE_INCREMENT_T (0)) ;
+
+	/* Now apply the right half of the filter. */
+	filter_index = increment - start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter-&gt;b_current + channels * (1 + coeff_count) ;
+
+	memset (right, 0, sizeof (right [0]) * channels) ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter-&gt;coeffs [indx] + fraction * (filter-&gt;coeffs [indx + 1] - filter-&gt;coeffs [indx]) ;
+
+		ch = channels ;
+		do
+		{
+			switch (ch % 8)
+			{	default :
+					ch -- ;
+					right [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 7 :
+					ch -- ;
+					right [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 6 :
+					ch -- ;
+					right [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 5 :
+					ch -- ;
+					right [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 4 :
+					ch -- ;
+					right [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 3 :
+					ch -- ;
+					right [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 2 :
+					ch -- ;
+					right [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				case 1 :
+					ch -- ;
+					right [ch] += icoeff * filter-&gt;buffer [data_index + ch] ;
+				} ;
+			}
+		while (ch &gt; 0) ;
+
+		filter_index -= increment ;
+		data_index = data_index - channels ;
+		}
+	while (filter_index &gt; MAKE_INCREMENT_T (0)) ;
+
+	ch = channels ;
+	do
+	{
+		switch (ch % 8)
+		{	default :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 7 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 6 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 5 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 4 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 3 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 2 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 1 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			} ;
+		}
+	while (ch &gt; 0) ;
+
+	return ;
+} /* calc_output_multi */
+
+static int
+sinc_multichan_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc-&gt;private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc-&gt;private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter-&gt;buffer [0]) != sizeof (data-&gt;data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter-&gt;in_count = data-&gt;input_frames * filter-&gt;channels ;
+	filter-&gt;out_count = data-&gt;output_frames * filter-&gt;channels ;
+	filter-&gt;in_used = filter-&gt;out_gen = 0 ;
+
+	src_ratio = psrc-&gt;last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter-&gt;coeff_half_len + 2.0) / filter-&gt;index_inc ;
+	if (MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) &lt; 1.0)
+		count /= MIN (psrc-&gt;last_ratio, data-&gt;src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter-&gt;channels * (lrint (count) + 1) ;
+
+	input_index = psrc-&gt;last_position ;
+	float_increment = filter-&gt;index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter-&gt;out_gen &lt; filter-&gt;out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
+
+		if (samples_in_hand &lt;= half_filter_chan_len)
+		{	if ((psrc-&gt;error = prepare_data (filter, data, half_filter_chan_len)) != 0)
+				return psrc-&gt;error ;
+
+			samples_in_hand = (filter-&gt;b_end - filter-&gt;b_current + filter-&gt;b_len) % filter-&gt;b_len ;
+			if (samples_in_hand &lt;= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter-&gt;b_real_end &gt;= 0)
+		{	if (filter-&gt;b_current + input_index + terminate &gt;= filter-&gt;b_real_end)
+				break ;
+			} ;
+
+		if (filter-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; 1e-10)
+			src_ratio = psrc-&gt;last_ratio + filter-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / filter-&gt;out_count ;
+
+		float_increment = filter-&gt;index_inc * 1.0 ;
+		if (src_ratio &lt; 1.0)
+			float_increment = filter-&gt;index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		calc_output_multi (filter, increment, start_filter_index, filter-&gt;channels, float_increment / filter-&gt;index_inc, data-&gt;data_out + filter-&gt;out_gen) ;
+		filter-&gt;out_gen += psrc-&gt;channels ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter-&gt;b_current = (filter-&gt;b_current + filter-&gt;channels * lrint (input_index - rem)) % filter-&gt;b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc-&gt;last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc-&gt;last_ratio = src_ratio ;
+
+	data-&gt;input_frames_used = filter-&gt;in_used / filter-&gt;channels ;
+	data-&gt;output_frames_gen = filter-&gt;out_gen / filter-&gt;channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_multichan_vari_process */
+
+/*----------------------------------------------------------------------------------------
+*/
+
+static int
+prepare_data (SINC_FILTER *filter, SRC_DATA *data, int half_filter_chan_len)
+{	int len = 0 ;
+
+	if (filter-&gt;b_real_end &gt;= 0)
+		return 0 ;	/* Should be terminating. Just return. */
+
+	if (filter-&gt;b_current == 0)
+	{	/* Initial state. Set up zeros at the start of the buffer and
+		** then load new data after that.
+		*/
+		len = filter-&gt;b_len - 2 * half_filter_chan_len ;
+
+		filter-&gt;b_current = filter-&gt;b_end = half_filter_chan_len ;
+		}
+	else if (filter-&gt;b_end + half_filter_chan_len + filter-&gt;channels &lt; filter-&gt;b_len)
+	{	/*  Load data at current end position. */
+		len = MAX (filter-&gt;b_len - filter-&gt;b_current - half_filter_chan_len, 0) ;
+		}
+	else
+	{	/* Move data at end of buffer back to the start of the buffer. */
+		len = filter-&gt;b_end - filter-&gt;b_current ;
+		memmove (filter-&gt;buffer, filter-&gt;buffer + filter-&gt;b_current - half_filter_chan_len,
+						(half_filter_chan_len + len) * sizeof (filter-&gt;buffer [0])) ;
+
+		filter-&gt;b_current = half_filter_chan_len ;
+		filter-&gt;b_end = filter-&gt;b_current + len ;
+
+		/* Now load data at current end of buffer. */
+		len = MAX (filter-&gt;b_len - filter-&gt;b_current - half_filter_chan_len, 0) ;
+		} ;
+
+	len = MIN (filter-&gt;in_count - filter-&gt;in_used, len) ;
+	len -= (len % filter-&gt;channels) ;
+
+	if  (len &lt; 0 || filter-&gt;b_end + len &gt; filter-&gt;b_len)
+		return SRC_ERR_SINC_PREPARE_DATA_BAD_LEN ;
+
+	memcpy (filter-&gt;buffer + filter-&gt;b_end, data-&gt;data_in + filter-&gt;in_used,
+						len * sizeof (filter-&gt;buffer [0])) ;
+
+	filter-&gt;b_end += len ;
+	filter-&gt;in_used += len ;
+
+	if (filter-&gt;in_used == filter-&gt;in_count &amp;&amp;
+			filter-&gt;b_end - filter-&gt;b_current &lt; 2 * half_filter_chan_len &amp;&amp; data-&gt;end_of_input)
+	{	/* Handle the case where all data in the current buffer has been
+		** consumed and this is the last buffer.
+		*/
+
+		if (filter-&gt;b_len - filter-&gt;b_end &lt; half_filter_chan_len + 5)
+		{	/* If necessary, move data down to the start of the buffer. */
+			len = filter-&gt;b_end - filter-&gt;b_current ;
+			memmove (filter-&gt;buffer, filter-&gt;buffer + filter-&gt;b_current - half_filter_chan_len,
+							(half_filter_chan_len + len) * sizeof (filter-&gt;buffer [0])) ;
+
+			filter-&gt;b_current = half_filter_chan_len ;
+			filter-&gt;b_end = filter-&gt;b_current + len ;
+			} ;
+
+		filter-&gt;b_real_end = filter-&gt;b_end ;
+		len = half_filter_chan_len + 5 ;
+
+		memset (filter-&gt;buffer + filter-&gt;b_end, 0, len * sizeof (filter-&gt;buffer [0])) ;
+		filter-&gt;b_end += len ;
+		} ;
+
+	return 0 ;
+} /* prepare_data */
+
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_zoh.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_zoh.c	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_zoh.c	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,214 +1,208 @@
-/*
-** Copyright (C) 2002-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/*
-** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
-** use license for this code is available, please see:
-**		<A HREF="http://www.mega-nerd.com/SRC/procedure.html">http://www.mega-nerd.com/SRC/procedure.html</A>
-*/
-#if 0 // MEANX
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &quot;config.h&quot;
-#else
-#include &quot;ADM_default.h&quot;
-#endif
-#include &quot;float_cast.h&quot;
-#include &quot;common.h&quot;
-
-static int zoh_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
-static void zoh_reset (SRC_PRIVATE *psrc) ;
-
-/*========================================================================================
-*/
-
-#define	ZOH_MAGIC_MARKER	MAKE_MAGIC ('s', 'r', 'c', 'z', 'o', 'h')
-
-typedef struct
-{	int		zoh_magic_marker ;
-	int		channels ;
-	int		reset ;
-	long	in_count, in_used ;
-	long	out_count, out_gen ;
-	float	last_value [1] ;
-} ZOH_DATA ;
-
-/*----------------------------------------------------------------------------------------
-*/
-
-static int
-zoh_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
-{	ZOH_DATA 	*zoh ;
-	double		src_ratio, input_index, rem ;
-	int			ch ;
-
-	if (psrc-&gt;private_data == NULL)
-		return SRC_ERR_NO_PRIVATE ;
-
-	zoh = (ZOH_DATA*) psrc-&gt;private_data ;
-
-	if (zoh-&gt;reset)
-	{	/* If we have just been reset, set the last_value data. */
-		for (ch = 0 ; ch &lt; zoh-&gt;channels ; ch++)
-			zoh-&gt;last_value [ch] = data-&gt;data_in [ch] ;
-		zoh-&gt;reset = 0 ;
-		} ;
-
-	zoh-&gt;in_count = data-&gt;input_frames * zoh-&gt;channels ;
-	zoh-&gt;out_count = data-&gt;output_frames * zoh-&gt;channels ;
-	zoh-&gt;in_used = zoh-&gt;out_gen = 0 ;
-
-	src_ratio = psrc-&gt;last_ratio ;
-	input_index = psrc-&gt;last_position ;
-
-	/* Calculate samples before first sample in input array. */
-	while (input_index &lt; 1.0 &amp;&amp; zoh-&gt;out_gen &lt; zoh-&gt;out_count)
-	{
-		if (zoh-&gt;in_used + zoh-&gt;channels * input_index &gt;= zoh-&gt;in_count)
-			break ;
-
-		if (zoh-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; SRC_MIN_RATIO_DIFF)
-			src_ratio = psrc-&gt;last_ratio + zoh-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / zoh-&gt;out_count ;
-
-		for (ch = 0 ; ch &lt; zoh-&gt;channels ; ch++)
-		{	data-&gt;data_out [zoh-&gt;out_gen] = zoh-&gt;last_value [ch] ;
-			zoh-&gt;out_gen ++ ;
-			} ;
-
-		/* Figure out the next index. */
-		input_index += 1.0 / src_ratio ;
-		} ;
-
-	rem = fmod_one (input_index) ;
-	zoh-&gt;in_used += zoh-&gt;channels * lrint (input_index - rem) ;
-	input_index = rem ;
-
-	/* Main processing loop. */
-	while (zoh-&gt;out_gen &lt; zoh-&gt;out_count &amp;&amp; zoh-&gt;in_used + zoh-&gt;channels * input_index &lt;= zoh-&gt;in_count)
-	{
-		if (zoh-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; SRC_MIN_RATIO_DIFF)
-			src_ratio = psrc-&gt;last_ratio + zoh-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / zoh-&gt;out_count ;
-
-		for (ch = 0 ; ch &lt; zoh-&gt;channels ; ch++)
-		{	data-&gt;data_out [zoh-&gt;out_gen] = data-&gt;data_in [zoh-&gt;in_used - zoh-&gt;channels + ch] ;
-			zoh-&gt;out_gen ++ ;
-			} ;
-
-		/* Figure out the next index. */
-		input_index += 1.0 / src_ratio ;
-		rem = fmod_one (input_index) ;
-
-		zoh-&gt;in_used += zoh-&gt;channels * lrint (input_index - rem) ;
-		input_index = rem ;
-		} ;
-
-	if (zoh-&gt;in_used &gt; zoh-&gt;in_count)
-	{	input_index += (zoh-&gt;in_used - zoh-&gt;in_count) / zoh-&gt;channels ;
-		zoh-&gt;in_used = zoh-&gt;in_count ;
-		} ;
-
-	psrc-&gt;last_position = input_index ;
-
-	if (zoh-&gt;in_used &gt; 0)
-		for (ch = 0 ; ch &lt; zoh-&gt;channels ; ch++)
-			zoh-&gt;last_value [ch] = data-&gt;data_in [zoh-&gt;in_used - zoh-&gt;channels + ch] ;
-
-	/* Save current ratio rather then target ratio. */
-	psrc-&gt;last_ratio = src_ratio ;
-
-	data-&gt;input_frames_used = zoh-&gt;in_used / zoh-&gt;channels ;
-	data-&gt;output_frames_gen = zoh-&gt;out_gen / zoh-&gt;channels ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* zoh_vari_process */
-
-/*------------------------------------------------------------------------------
-*/
-
-const char*
-zoh_get_name (int src_enum)
-{
-	if (src_enum == SRC_ZERO_ORDER_HOLD)
-		return &quot;ZOH Interpolator&quot; ;
-
-	return NULL ;
-} /* zoh_get_name */
-
-const char*
-zoh_get_description (int src_enum)
-{
-	if (src_enum == SRC_ZERO_ORDER_HOLD)
-		return &quot;Zero order hold interpolator, very fast, poor quality.&quot; ;
-
-	return NULL ;
-} /* zoh_get_descrition */
-
-int
-zoh_set_converter (SRC_PRIVATE *psrc, int src_enum)
-{	ZOH_DATA *zoh = NULL ;
-
-	if (src_enum != SRC_ZERO_ORDER_HOLD)
-		return SRC_ERR_BAD_CONVERTER ;
-
-	if (psrc-&gt;private_data != NULL)
-	{	zoh = (ZOH_DATA*) psrc-&gt;private_data ;
-		if (zoh-&gt;zoh_magic_marker != ZOH_MAGIC_MARKER)
-		{	free (psrc-&gt;private_data) ;
-			psrc-&gt;private_data = NULL ;
-			} ;
-		} ;
-
-	if (psrc-&gt;private_data == NULL)
-	{	zoh = calloc (1, sizeof (*zoh) + psrc-&gt;channels * sizeof (float)) ;
-		if (zoh == NULL)
-			return SRC_ERR_MALLOC_FAILED ;
-		psrc-&gt;private_data = zoh ;
-		} ;
-
-	zoh-&gt;zoh_magic_marker = ZOH_MAGIC_MARKER ;
-	zoh-&gt;channels = psrc-&gt;channels ;
-
-	psrc-&gt;const_process = zoh_vari_process ;
-	psrc-&gt;vari_process = zoh_vari_process ;
-	psrc-&gt;reset = zoh_reset ;
-
-	zoh_reset (psrc) ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* zoh_set_converter */
-
-/*===================================================================================
-*/
-
-static void
-zoh_reset (SRC_PRIVATE *psrc)
-{	ZOH_DATA *zoh ;
-
-	zoh = (ZOH_DATA*) psrc-&gt;private_data ;
-	if (zoh == NULL)
-		return ;
-
-	zoh-&gt;channels = psrc-&gt;channels ;
-	zoh-&gt;reset = 1 ;
-	memset (zoh-&gt;last_value, 0, sizeof (zoh-&gt;last_value [0]) * zoh-&gt;channels) ;
-
-	return ;
-} /* zoh_reset */
-
+/*
+** Copyright (C) 2002-2008 Erik de Castro Lopo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">erikd at mega-nerd.com</A>&gt;
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/*
+** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
+** use license for this code is available, please see:
+**		<A HREF="http://www.mega-nerd.com/SRC/procedure.html">http://www.mega-nerd.com/SRC/procedure.html</A>
+*/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;float_cast.h&quot;
+#include &quot;common.h&quot;
+
+static int zoh_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static void zoh_reset (SRC_PRIVATE *psrc) ;
+
+/*========================================================================================
+*/
+
+#define	ZOH_MAGIC_MARKER	MAKE_MAGIC ('s', 'r', 'c', 'z', 'o', 'h')
+
+typedef struct
+{	int		zoh_magic_marker ;
+	int		channels ;
+	int		reset ;
+	long	in_count, in_used ;
+	long	out_count, out_gen ;
+	float	last_value [1] ;
+} ZOH_DATA ;
+
+/*----------------------------------------------------------------------------------------
+*/
+
+static int
+zoh_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	ZOH_DATA 	*priv ;
+	double		src_ratio, input_index, rem ;
+	int			ch ;
+
+	if (psrc-&gt;private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	priv = (ZOH_DATA*) psrc-&gt;private_data ;
+
+	if (priv-&gt;reset)
+	{	/* If we have just been reset, set the last_value data. */
+		for (ch = 0 ; ch &lt; priv-&gt;channels ; ch++)
+			priv-&gt;last_value [ch] = data-&gt;data_in [ch] ;
+		priv-&gt;reset = 0 ;
+		} ;
+
+	priv-&gt;in_count = data-&gt;input_frames * priv-&gt;channels ;
+	priv-&gt;out_count = data-&gt;output_frames * priv-&gt;channels ;
+	priv-&gt;in_used = priv-&gt;out_gen = 0 ;
+
+	src_ratio = psrc-&gt;last_ratio ;
+	input_index = psrc-&gt;last_position ;
+
+	/* Calculate samples before first sample in input array. */
+	while (input_index &lt; 1.0 &amp;&amp; priv-&gt;out_gen &lt; priv-&gt;out_count)
+	{
+		if (priv-&gt;in_used + priv-&gt;channels * input_index &gt;= priv-&gt;in_count)
+			break ;
+
+		if (priv-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; SRC_MIN_RATIO_DIFF)
+			src_ratio = psrc-&gt;last_ratio + priv-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / priv-&gt;out_count ;
+
+		for (ch = 0 ; ch &lt; priv-&gt;channels ; ch++)
+		{	data-&gt;data_out [priv-&gt;out_gen] = priv-&gt;last_value [ch] ;
+			priv-&gt;out_gen ++ ;
+			} ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		} ;
+
+	rem = fmod_one (input_index) ;
+	priv-&gt;in_used += priv-&gt;channels * lrint (input_index - rem) ;
+	input_index = rem ;
+
+	/* Main processing loop. */
+	while (priv-&gt;out_gen &lt; priv-&gt;out_count &amp;&amp; priv-&gt;in_used + priv-&gt;channels * input_index &lt;= priv-&gt;in_count)
+	{
+		if (priv-&gt;out_count &gt; 0 &amp;&amp; fabs (psrc-&gt;last_ratio - data-&gt;src_ratio) &gt; SRC_MIN_RATIO_DIFF)
+			src_ratio = psrc-&gt;last_ratio + priv-&gt;out_gen * (data-&gt;src_ratio - psrc-&gt;last_ratio) / priv-&gt;out_count ;
+
+		for (ch = 0 ; ch &lt; priv-&gt;channels ; ch++)
+		{	data-&gt;data_out [priv-&gt;out_gen] = data-&gt;data_in [priv-&gt;in_used - priv-&gt;channels + ch] ;
+			priv-&gt;out_gen ++ ;
+			} ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		priv-&gt;in_used += priv-&gt;channels * lrint (input_index - rem) ;
+		input_index = rem ;
+		} ;
+
+	if (priv-&gt;in_used &gt; priv-&gt;in_count)
+	{	input_index += (priv-&gt;in_used - priv-&gt;in_count) / priv-&gt;channels ;
+		priv-&gt;in_used = priv-&gt;in_count ;
+		} ;
+
+	psrc-&gt;last_position = input_index ;
+
+	if (priv-&gt;in_used &gt; 0)
+		for (ch = 0 ; ch &lt; priv-&gt;channels ; ch++)
+			priv-&gt;last_value [ch] = data-&gt;data_in [priv-&gt;in_used - priv-&gt;channels + ch] ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc-&gt;last_ratio = src_ratio ;
+
+	data-&gt;input_frames_used = priv-&gt;in_used / priv-&gt;channels ;
+	data-&gt;output_frames_gen = priv-&gt;out_gen / priv-&gt;channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* zoh_vari_process */
+
+/*------------------------------------------------------------------------------
+*/
+
+const char*
+zoh_get_name (int src_enum)
+{
+	if (src_enum == SRC_ZERO_ORDER_HOLD)
+		return &quot;ZOH Interpolator&quot; ;
+
+	return NULL ;
+} /* zoh_get_name */
+
+const char*
+zoh_get_description (int src_enum)
+{
+	if (src_enum == SRC_ZERO_ORDER_HOLD)
+		return &quot;Zero order hold interpolator, very fast, poor quality.&quot; ;
+
+	return NULL ;
+} /* zoh_get_descrition */
+
+int
+zoh_set_converter (SRC_PRIVATE *psrc, int src_enum)
+{	ZOH_DATA *priv = NULL ;
+
+	if (src_enum != SRC_ZERO_ORDER_HOLD)
+		return SRC_ERR_BAD_CONVERTER ;
+
+	if (psrc-&gt;private_data != NULL)
+	{	free (psrc-&gt;private_data) ;
+		psrc-&gt;private_data = NULL ;
+		} ;
+
+	if (psrc-&gt;private_data == NULL)
+	{	priv = calloc (1, sizeof (*priv) + psrc-&gt;channels * sizeof (float)) ;
+		if (priv == NULL)
+			return SRC_ERR_MALLOC_FAILED ;
+		psrc-&gt;private_data = priv ;
+		} ;
+
+	priv-&gt;zoh_magic_marker = ZOH_MAGIC_MARKER ;
+	priv-&gt;channels = psrc-&gt;channels ;
+
+	psrc-&gt;const_process = zoh_vari_process ;
+	psrc-&gt;vari_process = zoh_vari_process ;
+	psrc-&gt;reset = zoh_reset ;
+
+	zoh_reset (psrc) ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* zoh_set_converter */
+
+/*===================================================================================
+*/
+
+static void
+zoh_reset (SRC_PRIVATE *psrc)
+{	ZOH_DATA *priv ;
+
+	priv = (ZOH_DATA*) psrc-&gt;private_data ;
+	if (priv == NULL)
+		return ;
+
+	priv-&gt;channels = psrc-&gt;channels ;
+	priv-&gt;reset = 1 ;
+	memset (priv-&gt;last_value, 0, sizeof (priv-&gt;last_value [0]) * priv-&gt;channels) ;
+
+	return ;
+} /* zoh_reset */
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-04-21 16:15:51 UTC (rev 4746)
@@ -9,14 +9,10 @@
 ADM_libsamplerate/src_sinc.c
 ADM_libsamplerate/src_zoh.c
 )	
-#*************************************************
+
 ADD_DEFINITIONS(-DADM_LEGACY_PROGGY)
-ADD_DEFINITIONS(-DHAVE_LRINT -DHAVE_LRINTF)
-ADD_DEFINITIONS(-DCPU_CLIPS_POSITIVE=0 -DCPU_CLIPS_NEGATIVE=0)
 ADD_DEFINITIONS(-I${CMAKE_CURRENT_SOURCE_DIR})
-ADD_DEFINITIONS(-DPACKAGE=&quot;SRC&quot;)
-ADD_DEFINITIONS(-DVERSION=&quot;0.1.4&quot;)
-#*************************************************
+
 ADD_LIBRARY(ADM_coreAudio SHARED ${ADMaudioCore_SRCS})
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
 TARGET_LINK_LIBRARIES(ADM_coreAudio ADM_core)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001973.html">[Avidemux-svn-commit] r4745 - in	branches/avidemux_2.5_branch_gruntster/scripts/auto: . Apple
</A></li>
	<LI>Next message: <A HREF="001975.html">[Avidemux-svn-commit] r4747 -	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1974">[ date ]</a>
              <a href="thread.html#1974">[ thread ]</a>
              <a href="subject.html#1974">[ subject ]</a>
              <a href="author.html#1974">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
