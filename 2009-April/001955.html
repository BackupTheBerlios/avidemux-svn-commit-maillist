<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4727 - in branches/avidemux_2.6_branch_mean:	avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegTS
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4727%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/ADM_coreDemuxerMpeg/include%0A%09avidemux/ADM_coreDemuxerMpeg/src%20plugins/ADM_demuxers/MpegTS&In-Reply-To=%3C200904070540.n375e7DW009769%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001954.html">
   <LINK REL="Next"  HREF="001956.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4727 - in branches/avidemux_2.6_branch_mean:	avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegTS</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4727%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/ADM_coreDemuxerMpeg/include%0A%09avidemux/ADM_coreDemuxerMpeg/src%20plugins/ADM_demuxers/MpegTS&In-Reply-To=%3C200904070540.n375e7DW009769%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4727 - in branches/avidemux_2.6_branch_mean:	avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegTS">mean at mail.berlios.de
       </A><BR>
    <I>Tue Apr  7 07:40:07 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001954.html">[Avidemux-svn-commit] r4726 - in	branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg:	include src
</A></li>
        <LI>Next message: <A HREF="001956.html">[Avidemux-svn-commit] r4728 - in branches/avidemux_2.6_branch_mean:	avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegTS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1955">[ date ]</a>
              <a href="thread.html#1955">[ thread ]</a>
              <a href="subject.html#1955">[ subject ]</a>
              <a href="author.html#1955">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-04-07 07:40:06 +0200 (Tue, 07 Apr 2009)
New Revision: 4727

Added:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
Log:
[TSdemuxer] Rename PS one to start

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:40:06 UTC (rev 4727)
@@ -1,96 +0,0 @@
-/**
-    dmxtsPacket.cpp
-
-*/
-
-#ifndef DMXtsPacket_H
-#define DMXtsPacket_H
-
-#include &quot;dmxPacket.h&quot;
-#include &quot;ADM_Video.h&quot;
-
-
-
-/**
-    \class tsPacket
-*/
-class tsPacket : public ADMMpegPacket
-{
-protected:
-    uint8_t             getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
-public:
-                        tsPacket(void);
-    virtual            ~tsPacket();
-    virtual bool        open(const char *filenames,FP_TYPE append);
-    virtual bool        close(void);
-    virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
-    virtual uint64_t    getPos(void);
-    virtual bool        setPos(uint64_t pos);
-};
-/**
-    \class tsPacketLinear
-*/
-#define ADM_PACKET_LINEAR 10*1024
-
-class tsPacketLinear : public tsPacket
-{
-protected:
-        uint8_t  myPid;
-        uint64_t startAt;
-        uint32_t bufferLen;
-        uint64_t bufferPts;
-        uint64_t bufferDts;
-        uint32_t bufferIndex;
-        uint8_t  buffer[ADM_PACKET_LINEAR];
-        bool     eof;
-        bool     refill(void);
-        uint64_t oldStartAt;
-        uint32_t oldBufferLen;
-        uint64_t oldBufferPts;
-        uint64_t oldBufferDts;
-        uint32_t consumed;
-
-public:
-                tsPacketLinear(uint8_t pid);
-                ~tsPacketLinear();
-        uint32_t getConsumed(void);
-        uint8_t  readi8();
-        uint16_t readi16();
-        uint32_t readi32();
-        bool     sync(uint8_t *pid);
-        bool    read(uint32_t len, uint8_t *buffer);
-        bool    forward(uint32_t v);
-        bool    stillOk(void) {return !eof;};
-        bool    getInfo(dmxPacketInfo *info);
-        bool    seek(uint64_t packetStart, uint32_t offset);
-        bool    changePid(uint32_t pid) ;
-};
-/**
-    \class tsPacketLinearTracker
-*/
-typedef struct
-{
-    uint32_t count;
-    uint32_t size;
-    
-    uint64_t startAt;
-    uint32_t startCount;
-    uint32_t startSize;
-    uint64_t startDts;
-}packetStats;
-
-class tsPacketLinearTracker : public tsPacketLinear
-{
-protected:
-      packetStats stats[256];
-
-public:
-                        tsPacketLinearTracker(uint8_t pid);
-                        ~tsPacketLinearTracker();
-         packetStats    *getStat(int intdex);
-         bool           resetStats(void);
-virtual  bool           getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
-};
-
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt	2009-04-07 05:40:06 UTC (rev 4727)
@@ -8,7 +8,6 @@
 dmx_io.cpp
 dmxPacket.cpp
 dmxPSPacket.cpp
-dmxTSPacket.cpp
 )	
 #*************************************************
 ADD_LIBRARY(ADM_coreDemuxerMpeg SHARED ${ADMcoreDemuxerMpeg_SRCS})

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -1,653 +0,0 @@
-/**
-    \file dmxtsPacket
-    \brief Packet demuxer for mpeg TS
-    copyright            : (C) 2005-2009 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-        
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_default.h&quot;
-
-#include &quot;dmxTSPacket.h&quot;
-#include &quot;dmx_mpegstartcode.h&quot;
-
-/**
-    \fn tsPacket
-    \brief ctor
-*/
-tsPacket::tsPacket(void) 
-{
-
-}
-/**
-    \fn tsPacket
-    \brief dtor
-*/
-tsPacket::~tsPacket()
-{
-    close();
-}
-/**
-    \fn open
-    \brief dtor
-*/
-bool tsPacket::open(const char *filenames,FP_TYPE append)
-{
-    _file=new fileParser();
-    if(!_file-&gt;open(filenames,&amp;append))
-    {
-        printf(&quot;[DmxPS] cannot open %s\n&quot;,filenames);
-        delete _file;
-        _file=NULL;
-        return false;
-    }
-    _size=_file-&gt;getSize();
-    return true;
-}
-/**
-    \fn close
-    \brief dtor
-*/
-bool tsPacket::close(void)
-{
-    if(_file)
-    {
-        delete _file;
-        _file=NULL;
-    }
-    return true;
-}
-/**
-    \fn getPos
-*/
-uint64_t    tsPacket::getPos(void)
-{
-    return 0;
-}
-/**
-    \fn setPos
-*/
-
-bool    tsPacket::setPos(uint64_t pos)
-{
-    if(!_file-&gt;setpos(pos))
-    {
-        printf(&quot;[tsPacket] Cannot seek to %&quot;LLX&quot;\n&quot;, pos);
-        return false;
-    }
-}
-
-/**
-    \fn getPacket
-*/      
-bool        tsPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)
-{
-uint32_t globstream,len;
-uint8_t  stream,substream;
-uint64_t pts,dts;
-        // Resync on our stream
-_again2:
-        *pid=0;
-        if(!_file-&gt;sync(&amp;stream)) 
-        {
-                uint64_t pos;
-                _file-&gt;getpos(&amp;pos);
-                printf(&quot;[DmxPS] cannot sync  at &quot;LLU&quot;/&quot;LLU&quot;\n&quot;,pos,_size);
-                return false;
-        }
-// Position of this packet just before startcode
-        _file-&gt;getpos(startAt);
-        *startAt-=4;
-// Handle out of band stuff        
-        if(stream==PACK_START_CODE) 
-        {
-        		_file-&gt;forward(8);
-        		goto _again2;
-        }
-        if( stream==PADDING_CODE ||stream==SYSTEM_START_CODE) 
-        {
-                        len=_file-&gt;read16i();
-                        //printf(&quot;\tForwarding %lu bytes\n&quot;,len);
-        		_file-&gt;forward(len);
-        		goto _again2;
-        }
-        // Only keep relevant parts
-        // i.e. a/v : C0 C9 E0 E9
-        // subs 20-29
-        // private data 1/2
-#define INSIDE(min,max) (stream&gt;=min &amp;&amp; stream&lt;max)
-        if(!(  INSIDE(0xC0,0xC9) || INSIDE(0xE0,0xE9) || INSIDE(0x20,0x29) || stream==PRIVATE_STREAM_1 || stream==PRIVATE_STREAM_2
-        			)) goto _again2;
-        // Ok we got a candidate
-        if(!getPacketInfo(stream,&amp;substream,&amp;len,&amp;pts,&amp;dts))   
-        {
-                goto _again2;
-        }
-        
-        //printf(&quot;Main Stream :%x substream :%x\n&quot;,stream,substream);
-        if(stream==PRIVATE_STREAM_1) globstream=0xFF00+substream;
-                else                 globstream=stream;
-
-        *pid=globstream;
-        *opts=pts;
-        *odts=dts;
-        *packetSize=len;
-        if(len&gt;     maxSize)
-        {
-                printf(&quot;[DmxPS] Packet too big %d vs %d\n&quot;,len,maxSize);
-        }
-        if(!_file-&gt;read32(len,buffer)) return false;
-        return true;
-       
-}
-/**
-
-    \fn getPacketInfo
-    \brief       Retrieve info about the packet we just met.It is assumed that parser is just after the packet startcode
-
-*/
-
-uint8_t tsPacket::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
-{
-
-//uint32_t un ,deux;
-uint64_t size=0;
-uint8_t c,d;
-uint8_t align=0;
-                        
-                *substream=0xff;
-                *opts=ADM_NO_PTS;
-                *odts=ADM_NO_PTS;
-                
-                                        
-                size=_file-&gt;read16i();
-                if((stream==PADDING_CODE) || 
-                	 (stream==PRIVATE_STREAM_2)
-                        ||(stream==SYSTEM_START_CODE) //?
-                        ) // special case, no header
-                        {
-                                *olen=size;      
-                                return 1;
-                        }
-                                
-                        //      remove padding if any                                           
-        
-                while((c=_file-&gt;read8i()) == 0xff) 
-                {
-                        size--;
-                }
-//----------------------------------------------------------------------------
-//-------------------------------MPEG-2 PES packet style----------------------
-//----------------------------------------------------------------------------
-                if(((c&amp;0xC0)==0x80))
-                {
-                        uint32_t ptsdts,len;
-                        //printf(&quot;\n mpeg2 type \n&quot;);
-                        //_muxTypeMpeg2=1;
-                        // c= copyright and stuff       
-                        //printf(&quot; %x align\n&quot;,c);      
-                        if(c &amp; 4) align=1;      
-                        c=_file-&gt;read8i();     // PTS/DTS
-                        //printf(&quot;%x ptsdts\n&quot;,c
-                        ptsdts=c&gt;&gt;6;
-                        // header len
-                        len=_file-&gt;read8i();
-                        size-=3;  
-
-                        switch(ptsdts)
-                        {
-                                case 2: // PTS=1 DTS=0
-                                        if(len&gt;=5)
-                                        {
-                                                uint64_t pts1,pts2,pts0;
-                                                //      printf(&quot;\n PTS10\n&quot;);
-                                                        pts0=_file-&gt;read8i();  
-                                                        pts1=_file-&gt;read16i(); 
-                                                        pts2=_file-&gt;read16i();                 
-                                                        len-=5;
-                                                        size-=5;
-                                                        *opts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                        *opts+=pts2&gt;&gt;1;
-                                                        *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                        }
-                                        break;
-                                case 3: // PTS=1 DTS=1
-                                                #define PTS11_ADV 10 // nut monkey
-                                                if(len&gt;=PTS11_ADV)
-                                                {
-                                                        uint32_t skip=PTS11_ADV;
-                                                        uint64_t pts1,pts2,dts,pts0;
-                                                                //      printf(&quot;\n PTS10\n&quot;);
-                                                                pts0=_file-&gt;read8i();  
-                                                                pts1=_file-&gt;read16i(); 
-                                                                pts2=_file-&gt;read16i(); 
-                                                                                        
-                                                                *opts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                                *opts+=pts2&gt;&gt;1;
-                                                                *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                                                pts0=_file-&gt;read8i();  
-                                                                pts1=_file-&gt;read16i(); 
-                                                                pts2=_file-&gt;read16i();                 
-                                                                dts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                                dts+=pts2&gt;&gt;1;
-                                                                dts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                                                len-=skip;
-                                                                size-=skip;
-                                                                *odts=dts;
-                                                                        //printf(&quot;DTS: %lx\n&quot;,dts);                
-                                                   }
-                                                   break;               
-                                case 1:
-                                                return 0;//ADM_assert(0); // forbidden !
-                                                break;
-                                case 0: 
-                                                // printf(&quot;\n PTS00\n&quot;);
-                                                break; // no pts nor dts
-                                                                                
-                                                            
-                        }  
-// Extension bit        
-// &gt;stealthdave&lt;                                
-
-                        // Skip remaining headers if any
-                        if(len) 
-                        {
-                                _file-&gt;forward(len);
-                                size=size-len;
-                        }
-                                
-                if(stream==PRIVATE_STREAM_1)
-                {
-                        if(size&gt;5)
-                        {
-                        // read sub id
-                               *substream=_file-&gt;read8i();
-  //                    printf(&quot;\n Subid : %x&quot;,*subid);
-                                switch(*substream)
-                                {
-                                // DTS
-                                        case 0x88:case 0x89:case 0x8A:case 0x8B:
-                                        
-                                                *substream=*substream-0x48;
-                                                break;
-
-                                //AC3
-                                        case 0x80:case 0x81:case 0x82:case 0x83:
-                                        case 0x84:case 0x85:case 0x86:case 0x87:
-                                                *substream=*substream-0x80;
-                                                break;
-                                // PCM
-                                        case 0xA0:case 0xA1:case 0xa2:case 0xa3:
-                                        case 0xA4:case 0xA5:case 0xa6:case 0xa7:
-                                                // we have an additionnal header
-                                                // of 3 bytes
-                                                _file-&gt;forward(3);
-                                                size-=3;
-                                                break;
-                                // Subs
-                                case 0x20:case 0x21:case 0x22:case 0x23:
-                                case 0x24:case 0x25:case 0x26:case 0x27:
-                                                break;
-                             
-                                default:
-                                                doNoComplainAnyMore++;
-                                                if(doNoComplainAnyMore&lt;10)
-                                                    printf(&quot;[DmxPS]Unkown substream %x\n&quot;,*substream);
-                                                *substream=0xff;
-                                }
-                                // skip audio header (if not sub)
-                                if(*substream&gt;0x26 || *substream&lt;0x20)
-                                {
-                                        _file-&gt;forward(3);
-                                        size-=3;
-                                }
-                                size--;
-                        }
-                }
-               //    printf(&quot; pid %x size : %x len %x\n&quot;,sid,size,len);
-                *olen=size;
-                return 1;
-        }
-//----------------------------------------------------------------------------------------------                
-//-------------------------------MPEG-1 PES packet style----------------------                                  
-//----------------------------------------------------------------------------------------------                                        
-           if(0) //_muxTypeMpeg2)
-                {
-                        printf(&quot;[DmxPS]*** packet type 1 inside type 2 ?????*****\n&quot;);
-                        return 0; // mmmm                       
-                }
-          // now look at  STD buffer size if present
-          // 01xxxxxxxxx
-          if ((c&gt;&gt;6) == 1) 
-          {       // 01
-                        size-=2;
-                        _file-&gt;read8i();                       // skip one byte
-                        c=_file-&gt;read8i();   // then another
-           }                       
-           // PTS/DTS
-           switch(c&gt;&gt;4)
-           {
-                case 2:
-                {
-                        // 0010 xxxx PTS only
-                        uint64_t pts1,pts2,pts0;
-                                        size -= 4;
-                                        pts0=(c&gt;&gt;1) &amp;7;
-                                        pts1=_file-&gt;read16i()&gt;&gt;1;
-                                        pts2=_file-&gt;read16i()&gt;&gt;1;
-                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
-                                        break;
-                  }
-                  case 3:
-                  {               // 0011 xxxx
-                        uint64_t pts1,pts2,pts0;
-                                        size -= 9;
-                                                                        
-                                        pts0=(c&gt;&gt;1) &amp;7;
-                                        pts1=_file-&gt;read16i()&gt;&gt;1;
-                                        pts2=_file-&gt;read16i()&gt;&gt;1;
-                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
-                                        _file-&gt;forward(5);
-                   }                                                               
-                   break;
-                   
-                case 1:
-                        // 0001 xxx             
-                        // PTSDTS=01 not allowed                        
-                                return 0;
-                                break; 
-                }
-                                                                
-
-                if(!align)      
-                        size--;         
-        *olen=size;
-        return 1;
-}
-//************************************************************************************
-
-#define ADM_PACKET_LINEAR 10*1024
-/**
-    \fn tsPacket
-*/
-tsPacketLinear::tsPacketLinear(uint8_t pid) : tsPacket()
-{
-    oldStartAt=startAt=0xfffffff;
-    oldBufferLen=bufferLen=0;
-    bufferIndex=0;
-    myPid=pid;
-    eof=false;
-}
-/**
-    \fn ~tsPacket
-*/
-tsPacketLinear::~tsPacketLinear() 
-{
-}
-/**
-    \fn refill
-*/
-bool tsPacketLinear::refill(void) 
-{
-// In case a startcode spawns across 2 packets
-// we have to keep track of the old one
-        oldBufferDts=bufferDts;
-        oldBufferPts=bufferPts;
-        oldStartAt=startAt;
-        oldBufferLen=bufferLen;
-        if( false== getPacketOfType(myPid,ADM_PACKET_LINEAR, &amp;bufferLen,&amp;bufferPts,&amp;bufferDts,buffer,&amp;startAt)) 
-        {
-            printf(&quot;[tsPacketLinear] Refill failed for pid :%x\n&quot;,myPid);
-            bufferIndex=bufferLen=0;
-            return false;
-        }
-        //printf(&quot;Refill : At :%&quot;LLX&quot; size :%&quot;LD&quot;\n&quot;,startAt,bufferLen);
-        bufferIndex=0;
-        return true;
-}
-/**
-    \fn readi8
-*/
-uint8_t tsPacketLinear::readi8(void)
-{
-    consumed++;
-    if(bufferIndex&lt;bufferLen)
-    {
-        return buffer[bufferIndex++];
-    }
-    if(false==refill()) 
-    {
-        eof=1;
-        return 0;
-    }
-    ADM_assert(bufferLen);
-    bufferIndex=1;
-    return buffer[0];
-    
-}
-/**
-    \fn readi16
-*/
-uint16_t tsPacketLinear::readi16(void)
-{
-    if(bufferIndex+1&lt;bufferLen)
-    {
-        uint16_t v=(buffer[bufferIndex]&lt;&lt;8)+buffer[bufferIndex+1];;
-        bufferIndex+=2;
-        consumed+=2;
-        return v;
-    }
-    return (readi8()&lt;&lt;8)+readi8();
-}
-/**
-    \fn readi32
-*/
-uint32_t tsPacketLinear::readi32(void)
-{
-    if(bufferIndex+3&lt;bufferLen)
-    {
-        uint8_t *p=buffer+bufferIndex;
-        uint32_t v=(p[0]&lt;&lt;24)+(p[1]&lt;&lt;16)+(p[2]&lt;&lt;8)+p[3];
-        bufferIndex+=4;
-        consumed+=4;
-        return v;
-    }
-    return (readi16()&lt;&lt;16)+readi16();
-}
-/**
-    \fn forward
-*/
-bool tsPacketLinear::forward(uint32_t v)
-{
-next:
- uint32_t delta=bufferLen-bufferIndex;
-    if(v&gt;100*1000)
-    {
-        ADM_assert(0);
-    }
-    if(v&lt;=delta)
-    {
-        bufferIndex+=v;
-        consumed+=v;
-        return true;
-    }
-    // v&gt;delta
-    v-=delta;
-    if(!refill()) return false;
-    goto next;
-}
-
-/**
-    \fn bool    read(uint32_t len, uint8_t *buffer);
-    \brief
-*/
-bool    tsPacketLinear::read(uint32_t len, uint8_t *out)
-{
-    // Enough already ?
-    while(len)
-    {
-        uint32_t avail=bufferLen-bufferIndex;
-        uint32_t chunk=avail;
-        if(chunk&gt;len) chunk=len;
-#if 0
-        printf(&quot;len:%ld avail:%ld chunk %ld index:%d size:%d\n&quot;,
-                len,avail,chunk,bufferIndex,bufferLen);
-#endif
-        memcpy(out,buffer+bufferIndex,chunk);
-        bufferIndex+=chunk;
-        len-=chunk;
-        out+=chunk;
-        consumed+=chunk;
-        if(bufferIndex==bufferLen)
-        {
-            //printf(&quot;Refill\n&quot;);
-            if(false==refill()) return false;
-        }
-    }
-    return true;
-}
-/**
-        \fn getInfo
-        \brief Returns info about the current (or previous if it spawns) packet.
-            It is expected that the caller will do -4 to the index to get the start of the 
-            startCode
-*/
-bool    tsPacketLinear::getInfo(dmxPacketInfo *info)
-{
-    if(bufferIndex&lt;4)
-    {
-        info-&gt;startAt=this-&gt;oldStartAt;
-        info-&gt;offset=oldBufferLen+bufferIndex;
-        info-&gt;pts=oldBufferPts;
-        info-&gt;dts=oldBufferDts;
-
-    }else
-    {
-        info-&gt;startAt=this-&gt;startAt;
-        info-&gt;offset=bufferIndex;
-        info-&gt;pts=bufferPts;
-        info-&gt;dts=bufferDts;
-    }
-    return true;
-
-};
-/**
-    \fn seek
-    \brief Async jump
-*/
-bool    tsPacketLinear::seek(uint64_t packetStart, uint32_t offset)
-{
-    if(!_file-&gt;setpos(packetStart))
-    {
-        printf(&quot;[tsPacket] Cannot seek to %&quot;LLX&quot;\n&quot;,packetStart);
-        return 0;
-    }
-    if(!refill())
-    {
-        printf(&quot;[tsPacketLinear] Seek to %&quot;LLX&quot;:%&quot;LX&quot; failed\n&quot;,packetStart,offset);
-        return false;
-    }
-    ADM_assert(offset&lt;bufferLen);
-    bufferIndex=offset;
-    
-    return true;
-}
-/**
-    \fn getConsumed
-    \brief returns the # of bytes consumed since the last call
-*/
-uint32_t tsPacketLinear::getConsumed(void)
-{
-    uint32_t c=consumed;
-    consumed=0;
-    return c;
-}
-/**
-    \fn changePid
-    \brief change the pid of the stream we read (used when probing all tracks)
-*/
-bool    tsPacketLinear::changePid(uint32_t pid) 
-{
-    myPid=(pid&amp;0xff);
-    bufferLen=bufferIndex=0;
-    return true;
-}
-/* ********************************************************* */
-/**
-    \fn tsPacketLinearTracker
-*/
- tsPacketLinearTracker::tsPacketLinearTracker(uint8_t pid)  : tsPacketLinear(pid)
-{
-   resetStats();
-}
-/**
-    \fn ~tsPacketLinearTracker
-*/
-tsPacketLinearTracker::~tsPacketLinearTracker()
-{
-
-    
-}
-/**
-        \fn getStat
-*/
-packetStats    *tsPacketLinearTracker::getStat(int index)
-{   
-    if(index&lt;0 || index&gt;=256) ADM_assert(0);
-    return stats+index;
-}
-/**
-    \fn getPacketgetPacketOfType
-    \brief Keep track of all the packets we have seen so far.
-    Usefull to detect the streams present and to look up the PTS/DTS of audio streams for the audio part of the index
-*/
-bool           tsPacketLinearTracker::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
-{
- bool xit=false;
-    uint8_t tmppid;
-    while(1)
-    {
-        if(true!=getPacket(maxSize,&amp;tmppid,packetSize,pts,dts,buffer,startAt))
-                return false;
-        else
-        {
-                // Update 
-                ADM_assert(tmppid&lt;0x100);
-                packetStats *p=stats+tmppid;
-                uint64_t ts=*pts;
-                if(ts==ADM_NO_PTS) ts=*dts;
-                if(ts!=ADM_NO_PTS)
-                {
-                    p-&gt;startCount=p-&gt;count;
-                    p-&gt;startAt=*startAt;
-                    p-&gt;startSize=p-&gt;size;
-                    p-&gt;startDts=ts;
-                }
-                p-&gt;count++;
-                p-&gt;size+=*packetSize;
-                if(tmppid==pid) return true;
-        }
-    }
-    return false;
-}
-/**
-    \fn resetStats
-*/
-bool           tsPacketLinearTracker::resetStats(void)
-{
-    memset(stats,0,sizeof(stats));
-    for(int i=0;i&lt;256;i++)
-    {
-        packetStats *p=stats+i;
-        p-&gt;startDts=ADM_NO_PTS;
-    }
-}
-//EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -18,7 +18,7 @@
 #include &quot;fourcc.h&quot;
 #include &quot;DIA_coreToolkit.h&quot;
 #include &quot;ADM_indexFile.h&quot;
-#include &quot;ADM_ps.h&quot;
+#include &quot;ADM_ts.h&quot;
 
 #include &lt;math.h&gt;
 
@@ -29,7 +29,7 @@
       \brief open the flv file, gather infos and build index(es).
 */
 
-uint8_t psHeader::open(const char *name)
+uint8_t tsHeader::open(const char *name)
 {
     char idxName[strlen(name)+4];
     bool r=false;
@@ -84,16 +84,16 @@
     if(_videostream.dwLength)_isvideopresent=1;
 //***********
     
-    psPacket=new psPacketLinear(0xE0);
-    if(psPacket-&gt;open(name,appendType)==false) 
+    tsPacket=new tsPacketLinear(0xE0);
+    if(tsPacket-&gt;open(name,appendType)==false) 
     {
-        printf(&quot;psDemux] Cannot psPacket open the file\n&quot;);
+        printf(&quot;psDemux] Cannot tsPacket open the file\n&quot;);
         goto abt;
     }
     r=true;
     for(int i=0;i&lt;listOfAudioTracks.size();i++)
     {
-        ADM_psTrackDescriptor *desc=listOfAudioTracks[i];
+        ADM_tsTrackDescriptor *desc=listOfAudioTracks[i];
         ADM_audioStream *audioStream=ADM_audioCreateStream(&amp;desc-&gt;header,desc-&gt;access);
         if(!audioStream)
         {
@@ -112,7 +112,7 @@
         \fn getVideoDuration
         \brief Returns duration of video in us
 */
-uint64_t psHeader::getVideoDuration(void)
+uint64_t tsHeader::getVideoDuration(void)
 {
     float f;
         f=1000*1000*1000;
@@ -127,7 +127,7 @@
     \fn getAudioInfo
     \brief returns wav header for stream i (=0)
 */
-WAVHeader *psHeader::getAudioInfo(uint32_t i )
+WAVHeader *tsHeader::getAudioInfo(uint32_t i )
 {
         if(!listOfAudioTracks.size()) return NULL;
       ADM_assert(i&lt;listOfAudioTracks.size());
@@ -138,7 +138,7 @@
    \fn getAudioStream
 */
 
-uint8_t   psHeader::getAudioStream(uint32_t i,ADM_audioStream  **audio)
+uint8_t   tsHeader::getAudioStream(uint32_t i,ADM_audioStream  **audio)
 {
     if(!listOfAudioTracks.size())
     {
@@ -153,7 +153,7 @@
     \fn getNbAudioStreams
 
 */
-uint8_t   psHeader::getNbAudioStreams(void)
+uint8_t   tsHeader::getNbAudioStreams(void)
 {
  
   return listOfAudioTracks.size(); 
@@ -162,7 +162,7 @@
     __________________________________________________________
 */
 
-void psHeader::Dump(void)
+void tsHeader::Dump(void)
 {
  
 }
@@ -171,7 +171,7 @@
     \brief cleanup
 */
 
-uint8_t psHeader::close(void)
+uint8_t tsHeader::close(void)
 {
     // Destroy index
     while(ListOfFrames.size())
@@ -179,30 +179,30 @@
         delete ListOfFrames[0];
         ListOfFrames.erase(ListOfFrames.begin());
     }
-    if(psPacket)
+    if(tsPacket)
     {
-        psPacket-&gt;close();
-        delete psPacket;
-        psPacket=NULL;
+        tsPacket-&gt;close();
+        delete tsPacket;
+        tsPacket=NULL;
     }
 }
 /**
-    \fn psHeader
+    \fn tsHeader
     \brief constructor
 */
 
- psHeader::psHeader( void ) : vidHeader()
+ tsHeader::tsHeader( void ) : vidHeader()
 { 
     interlaced=false;
     lastFrame=0xffffffff;
     
 }
 /**
-    \fn psHeader
+    \fn tsHeader
     \brief destructor
 */
 
- psHeader::~psHeader(  )
+ tsHeader::~tsHeader(  )
 {
   close();
 }
@@ -213,7 +213,7 @@
     \brief Returns timestamp in us of frame &quot;frame&quot; (PTS)
 */
 
-  uint8_t  psHeader::setFlag(uint32_t frame,uint32_t flags)
+  uint8_t  tsHeader::setFlag(uint32_t frame,uint32_t flags)
 {
    
      uint32_t f=2;
@@ -228,7 +228,7 @@
     \brief Returns timestamp in us of frame &quot;frame&quot; (PTS)
 */
 
-uint32_t psHeader::getFlags(uint32_t frame,uint32_t *flags)
+uint32_t tsHeader::getFlags(uint32_t frame,uint32_t *flags)
 {
     if(frame&gt;=ListOfFrames.size()) return 0;
     uint32_t f=ListOfFrames[frame]-&gt;type;
@@ -245,7 +245,7 @@
     \fn getTime
     \brief Returns timestamp in us of frame &quot;frame&quot; (PTS)
 */
-uint64_t psHeader::getTime(uint32_t frame)
+uint64_t tsHeader::getTime(uint32_t frame)
 {
    if(frame&gt;=ListOfFrames.size()) return 0;
     uint64_t pts=ListOfFrames[frame]-&gt;pts;
@@ -255,7 +255,7 @@
     \fn timeConvert
     \brief FIXME
 */
-uint64_t psHeader::timeConvert(uint64_t x)
+uint64_t tsHeader::timeConvert(uint64_t x)
 {
     if(x==ADM_NO_PTS) return ADM_NO_PTS;
     x=x-ListOfFrames[0]-&gt;dts;
@@ -268,14 +268,14 @@
         \fn getFrame
 */
 
-uint8_t  psHeader::getFrame(uint32_t frame,ADMCompressedImage *img)
+uint8_t  tsHeader::getFrame(uint32_t frame,ADMCompressedImage *img)
 {
     if(frame&gt;=ListOfFrames.size()) return 0;
     dmxFrame *pk=ListOfFrames[frame];
     if(frame==(lastFrame+1) &amp;&amp; pk-&gt;type!=1)
     {
         lastFrame++;
-        bool r=psPacket-&gt;read(pk-&gt;len,img-&gt;data);
+        bool r=tsPacket-&gt;read(pk-&gt;len,img-&gt;data);
              img-&gt;dataLength=pk-&gt;len;
              img-&gt;demuxerFrameNo=frame;
              img-&gt;demuxerDts=pk-&gt;dts;
@@ -286,8 +286,8 @@
     }
     if(pk-&gt;type==1)
     {
-        if(!psPacket-&gt;seek(pk-&gt;startAt,pk-&gt;index)) return false;
-         bool r=psPacket-&gt;read(pk-&gt;len,img-&gt;data);
+        if(!tsPacket-&gt;seek(pk-&gt;startAt,pk-&gt;index)) return false;
+         bool r=tsPacket-&gt;read(pk-&gt;len,img-&gt;data);
              img-&gt;dataLength=pk-&gt;len;
              img-&gt;demuxerFrameNo=frame;
              img-&gt;demuxerDts=pk-&gt;dts;
@@ -304,7 +304,7 @@
 /**
         \fn getExtraHeaderData
 */
-uint8_t  psHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
+uint8_t  tsHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
 {
                 *len=0; //_tracks[0].extraDataLen;
                 *data=NULL; //_tracks[0].extraData;
@@ -315,7 +315,7 @@
       \fn getFrameSize
       \brief return the size of frame frame
 */
-uint8_t psHeader::getFrameSize (uint32_t frame, uint32_t * size)
+uint8_t tsHeader::getFrameSize (uint32_t frame, uint32_t * size)
 {
     if(frame&gt;=ListOfFrames.size()) return 0;
     *size=ListOfFrames[frame]-&gt;len;
@@ -325,7 +325,7 @@
 /**
     \fn getPtsDts
 */
-bool    psHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+bool    tsHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
 {
     if(frame&gt;=ListOfFrames.size()) return false;
     dmxFrame *pk=ListOfFrames[frame];
@@ -337,7 +337,7 @@
 /**
         \fn setPtsDts
 */
-bool    psHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+bool    tsHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
 {
       if(frame&gt;=ListOfFrames.size()) return false;
     dmxFrame *pk=ListOfFrames[frame];

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-07 05:40:06 UTC (rev 4727)
@@ -1,7 +1,7 @@
 /***************************************************************************
-                         ADM_PS
+                         ADM_PT
                              -------------------
-    begin                : Mon Jun 3 2002
+    
     copyright            : (C) 2002 by mean
     email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
  ***************************************************************************/
@@ -17,14 +17,14 @@
  
 
 
-#ifndef ADM_PS_H
-#define ADM_PS_H
+#ifndef ADM_TS_H
+#define ADM_TS_H
 
 #include &quot;ADM_Video.h&quot;
 #include &quot;ADM_audioStream.h&quot;
 #include &quot;dmx_io.h&quot;
 #include &quot;ADM_indexFile.h&quot;
-#include &quot;dmxPSPacket.h&quot;
+#include &quot;dmxTSPacket.h&quot;
 #include &lt;vector&gt;
 using std::vector;
 /**
@@ -49,24 +49,24 @@
       uint64_t dts;
       uint32_t size;
 
-}ADM_psAudioSeekPoint;
+}ADM_tsAudioSeekPoint;
 
 /**
     \fn ADM_psAccess
 */
-class ADM_psAccess : public ADM_audioAccess
+class ADM_tsAccess : public ADM_audioAccess
 {
 protected:
                 
-                psPacket        demuxer;
+                tsPacket        demuxer;
                 uint8_t         pid;
                 uint64_t        dtsOffset;
                 
 public:
                 bool            setTimeOffset(uint64_t of) {dtsOffset=of;return true;}
-                vector          &lt;ADM_psAudioSeekPoint &gt;seekPoints;
-                                  ADM_psAccess(const char *name,uint8_t pid,bool append); 
-                virtual           ~ADM_psAccess();
+                vector          &lt;ADM_tsAudioSeekPoint &gt;seekPoints;
+                                  ADM_tsAccess(const char *name,uint8_t pid,bool append); 
+                virtual           ~ADM_tsAccess();
                                     /// Hint, the stream is pure CBR (AC3,MP2,MP3)
                 virtual bool      isCBR(void) { return true;}
                                     /// Return true if the demuxer can seek in time
@@ -92,18 +92,18 @@
 /**
     \class ADM_psTrackDescriptor
 */
-class ADM_psTrackDescriptor
+class ADM_tsTrackDescriptor
 {
 public:
         ADM_audioStream *stream;
-        ADM_psAccess    *access;
+        ADM_tsAccess    *access;
         WAVHeader       header;
-        ADM_psTrackDescriptor()
+        ADM_tsTrackDescriptor()
             {
                 stream=NULL;
                 access=NULL;
             }
-        ~ADM_psTrackDescriptor()
+        ~ADM_tsTrackDescriptor()
             {
                 if(stream) delete stream;
                 stream=NULL;
@@ -119,7 +119,7 @@
     \brief mpeg ps demuxer
 
 */
-class psHeader         :public vidHeader
+class tsHeader         :public vidHeader
 {
   protected:
     
@@ -134,18 +134,18 @@
     std::vector &lt;dmxFrame *&gt; ListOfFrames;      
     fileParser      parser;
     uint32_t       lastFrame;
-    psPacketLinear *psPacket;
+    tsPacketLinear *tsPacket;
     uint64_t        timeConvert(uint64_t x);
     bool            updatePtsDts(void);
 protected:
-    vector &lt;ADM_psTrackDescriptor *&gt;listOfAudioTracks;
+    vector &lt;ADM_tsTrackDescriptor *&gt;listOfAudioTracks;
   public:
 
 
     virtual   void          Dump(void);
 
-            psHeader( void ) ;
-   virtual  ~psHeader(  ) ;
+            tsHeader( void ) ;
+   virtual  ~tsHeader(  ) ;
 // AVI io
     virtual uint8_t  open(const char *name);
     virtual uint8_t  close(void) ;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -20,7 +20,7 @@
 #include &lt;string.h&gt;
 #include &lt;math.h&gt;
 
-#include &quot;ADM_ps.h&quot;
+#include &quot;ADM_ts.h&quot;
 
 #if 0
     #define aprintf printf
@@ -29,9 +29,9 @@
 #endif
 
 /**
-    \fn ADM_psAccess
+    \fn ADM_tsAccess
 */
-ADM_psAccess::ADM_psAccess(const char *name,uint8_t pid,bool append)
+ADM_tsAccess::ADM_tsAccess(const char *name,uint8_t pid,bool append)
 {
 FP_TYPE fp=FP_DONT_APPEND;
         if(append) fp=FP_APPEND;
@@ -40,9 +40,9 @@
 }
 
 /**
-    \fn ~ADM_psAccess
+    \fn ~ADM_tsAccess
 */
-ADM_psAccess::~ADM_psAccess()
+ADM_tsAccess::~ADM_tsAccess()
 {
     demuxer.close();
 }
@@ -50,9 +50,9 @@
     \fn push
     \brief add a seek point.
 */
-bool      ADM_psAccess::push(uint64_t at, uint64_t dts,uint32_t size)
+bool      ADM_tsAccess::push(uint64_t at, uint64_t dts,uint32_t size)
 {
-ADM_psAudioSeekPoint s;
+ADM_tsAudioSeekPoint s;
             s.position=at;
             s.dts=dts;
             s.size=size;
@@ -62,7 +62,7 @@
 /**
     \fn getLength
 */
-uint32_t  ADM_psAccess::getLength(void)
+uint32_t  ADM_tsAccess::getLength(void)
 {
   return (seekPoints[seekPoints.size()-1].size);
 
@@ -70,7 +70,7 @@
 /**
     \fn getDurationInUs
 */
-uint64_t  ADM_psAccess::getDurationInUs(void)
+uint64_t  ADM_tsAccess::getDurationInUs(void)
 {
     // Take last seek point; should be accurate enough
     return timeConvert(seekPoints[seekPoints.size()-1].dts);
@@ -79,7 +79,7 @@
     \fn goToTime
     \brief Rememember seekPoint.dts time is already scaled and in us
 */                              
-bool      ADM_psAccess::goToTime(uint64_t timeUs)
+bool      ADM_tsAccess::goToTime(uint64_t timeUs)
 {
     // Convert time in us to scaled 90 kHz tick
     
@@ -107,7 +107,7 @@
     \fn timeConvert
     \brief Convert time in ticks raw from the stream to avidemux time in us starting from the beginning of the file
 */
-uint64_t ADM_psAccess::timeConvert(uint64_t x)
+uint64_t ADM_tsAccess::timeConvert(uint64_t x)
 {
     if(x==ADM_NO_PTS) return ADM_NO_PTS;
     x=x-dtsOffset;
@@ -119,7 +119,7 @@
 /**
     \fn getPacket
 */
-bool      ADM_psAccess::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
+bool      ADM_tsAccess::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
 {
 uint64_t p,d,start;
     if(false==demuxer.getPacketOfType(pid,maxSize,size,&amp;p,&amp;d,buffer,&amp;start)) return false;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -17,8 +17,8 @@
 
 #include &quot;ADM_default.h&quot;
 #include &quot;ADM_audiodef.h&quot;
-#include &quot;dmxPSPacket.h&quot;
-#include &quot;ADM_psAudioProbe.h&quot;
+#include &quot;dmxTSPacket.h&quot;
+#include &quot;ADM_tsAudioProbe.h&quot;
 //
 #include &quot;ADM_a52info.h&quot;
 #include &quot;ADM_mp3info.h&quot;
@@ -35,22 +35,22 @@
 #define LPCM_AUDIO_VALUE 0xA0
 #define DTS_AC3_AUDIO_VALUE 0x00
 
-static bool addAudioTrack(int pid, listOfPsAudioTracks *list, psPacketLinearTracker *p);
-static bool psCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize);
+static bool addAudioTrack(int pid, listOfTsAudioTracks *list, tsPacketLinearTracker *p);
+static bool tsCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize);
 /**
     \fn listOfPsAudioTracks
     \brief returns a list of audio track found, null if none found
 
 */
-listOfPsAudioTracks *psProbeAudio(const char *fileName)
+listOfTsAudioTracks *tsProbeAudio(const char *fileName)
 {
     uint32_t size;
     uint64_t dts,pts,startAt;
     uint8_t buffer[PACKET_PROBE_SIZE];
     uint64_t fileSize;
 
-    listOfPsAudioTracks *tracks=new listOfPsAudioTracks;
-    psPacketLinearTracker *packet=new psPacketLinearTracker(0xE0);
+    listOfTsAudioTracks *tracks=new listOfTsAudioTracks;
+    tsPacketLinearTracker *packet=new tsPacketLinearTracker(0xE0);
 
     printf(&quot;[MpegPS] Probing audio for %s\n&quot;,fileName);
 
@@ -98,7 +98,7 @@
     \brief gather information about audio &amp; add audio track to the list
 
 */
-bool addAudioTrack(int pid, listOfPsAudioTracks *list, psPacketLinearTracker *p)
+bool addAudioTrack(int pid, listOfTsAudioTracks *list, tsPacketLinearTracker *p)
 {
 #define PROBE_ANALYZE_SIZE 6000 // Should be enough in all cases (need ~ 2 blocks)
 uint8_t audioBuffer[PROBE_ANALYZE_SIZE];
@@ -120,7 +120,7 @@
         int rd=PROBE_ANALYZE_SIZE;
         if(!p-&gt;read(PROBE_ANALYZE_SIZE,audioBuffer))
             return false;
-        psAudioTrackInfo *info=new psAudioTrackInfo;
+        tsAudioTrackInfo *info=new tsAudioTrackInfo;
         info-&gt;esID=pid;
         uint32_t fq,br,chan,off;
         switch(pid &amp; 0xF0)
@@ -133,7 +133,7 @@
                             break;
             case MP2_AUDIO_VALUE: // MP2
                             {
-                                if(! psCheckMp2Audio(&amp;(info-&gt;header),audioBuffer,rd))
+                                if(! tsCheckMp2Audio(&amp;(info-&gt;header),audioBuffer,rd))
                                 {
                                     printf(&quot;[PsProbeAudio] Failed to get info on track :%x (MP2)\n&quot;,pid);
                                     goto er;
@@ -182,7 +182,7 @@
         \fn DestroyListOfPsAudioTracks
         \brief cleanly destroy it
 */
-bool DestroyListOfPsAudioTracks(listOfPsAudioTracks *list)
+bool DestroyListOfTsAudioTracks(listOfTsAudioTracks *list)
 {
     while( list-&gt;size())
     {
@@ -196,7 +196,7 @@
     \fn psCheckMp2Audio
     \brief Wait to have 2 audio packets to make sure it is not a false detection (that happens with mp2/mp3 audio)
 */
-bool psCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize)
+bool tsCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize)
 {
     MpegAudioInfo mpeg,first;
     uint32_t off2,off;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-07 05:40:06 UTC (rev 4727)
@@ -14,21 +14,21 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#ifndef ADM_PS_AUDIO_PROBE_H
-#define ADM_PS_AUDIO_PROBE_H
+#ifndef ADM_TS_AUDIO_PROBE_H
+#define ADM_TS_AUDIO_PROBE_H
 #include &lt;vector&gt;
 using std::vector;
 typedef struct
 {
     WAVHeader header;
     uint8_t   esID;
-}psAudioTrackInfo;
+}tsAudioTrackInfo;
 
-typedef vector &lt;psAudioTrackInfo*&gt; listOfPsAudioTracks;
+typedef vector &lt;tsAudioTrackInfo*&gt; listOfTsAudioTracks;
 
 /// Returns a list of audio tracks found in the file.
-listOfPsAudioTracks *psProbeAudio(const char *fileName);
-bool DestroyListOfPsAudioTracks(listOfPsAudioTracks *list);
+listOfTsAudioTracks *tsProbeAudio(const char *fileName);
+bool DestroyListOfTsAudioTracks(listOfTsAudioTracks *list);
 
 
 #endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -8,7 +8,7 @@
 #include &quot;fourcc.h&quot;
 #include &quot;DIA_coreToolkit.h&quot;
 #include &quot;ADM_indexFile.h&quot;
-#include &quot;ADM_ps.h&quot;
+#include &quot;ADM_ts.h&quot;
 
 #include &lt;math.h&gt;
 
@@ -27,7 +27,7 @@
 TODO / FIXME : Handle PTS reordering 
 */
 
-bool psHeader::updatePtsDts(void)
+bool tsHeader::updatePtsDts(void)
 {
         uint64_t lastDts=0,lastPts=0,dtsIncrement=0;
 
@@ -39,7 +39,7 @@
         // at video
         for(int i=0;i&lt;listOfAudioTracks.size();i++)
         {
-            vector          &lt;ADM_psAudioSeekPoint &gt; *seekPoints=&amp;(listOfAudioTracks[i]-&gt;access-&gt;seekPoints);
+            vector          &lt;ADM_tsAudioSeekPoint &gt; *seekPoints=&amp;(listOfAudioTracks[i]-&gt;access-&gt;seekPoints);
             uint64_t secondDts=(*seekPoints)[0].dts;
             uint64_t secondSize=(*seekPoints)[0].size;
             if(secondSize &amp;&amp; listOfAudioTracks[i]-&gt;header.byterate)
@@ -53,7 +53,7 @@
                             else firstDts=secondDts-firstDts;
 
                 // Now add our seek point
-                ADM_psAudioSeekPoint sk;
+                ADM_tsAudioSeekPoint sk;
                 sk.dts=firstDts;
                 sk.size=0;
                 sk.position=ListOfFrames[0]-&gt;startAt;
@@ -105,8 +105,8 @@
         // Audio start at 0 too
         for(int i=0;i&lt;listOfAudioTracks.size();i++)
         {
-            ADM_psTrackDescriptor *track=listOfAudioTracks[i];
-            ADM_psAccess    *access=track-&gt;access;
+            ADM_tsTrackDescriptor *track=listOfAudioTracks[i];
+            ADM_tsAccess    *access=track-&gt;access;
             access-&gt;setTimeOffset(startDts);
         }
 
@@ -155,8 +155,8 @@
         // convert to us for Audio tracks (seek points)
         for(int i=0;i&lt;listOfAudioTracks.size();i++)
         {
-            ADM_psTrackDescriptor *track=listOfAudioTracks[i];
-            ADM_psAccess    *access=track-&gt;access;
+            ADM_tsTrackDescriptor *track=listOfAudioTracks[i];
+            ADM_tsAccess    *access=track-&gt;access;
             
             for(int j=0;j&lt;access-&gt;seekPoints.size();j++)
             {

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -19,11 +19,11 @@
 #include &quot;ADM_demuxerInternal.h&quot;
 #include &quot;fourcc.h&quot;
 
-#include &quot;dmxPSPacket.h&quot;
+#include &quot;dmxTSPacket.h&quot;
 
 #include &quot;avidemutils.h&quot;
 #include &quot;ADM_quota.h&quot;
-#include &quot;ADM_psAudioProbe.h&quot;
+#include &quot;ADM_tsAudioProbe.h&quot;
 #include &quot;DIA_working.h&quot;
 
 static const char Type[5]={'X','I','P','B','P'};
@@ -68,7 +68,7 @@
     uint32_t frameType;
     uint32_t nbPics;
     indexerState state;
-    psPacketLinear *pkt;
+    tsPacketLinear *pkt;
     int32_t        nextOffset;
 }indexerData;
 
@@ -80,18 +80,18 @@
 }markType;
 
 /**
-    \class PsIndexer
+    \class TsIndexer
 */
-class PsIndexer
+class TsIndexer
 {
 protected:
         FILE *index;
-        psPacketLinearTracker *pkt;
-        listOfPsAudioTracks *audioTracks;
+        tsPacketLinearTracker *pkt;
+        listOfTsAudioTracks *audioTracks;
         DIA_workingBase  *ui;
 public:
-                PsIndexer(void);
-                ~PsIndexer();
+                TsIndexer(void);
+                ~TsIndexer();
         bool    run(const char *file);
         bool    writeVideo(PSVideo *video);
         bool    writeAudio(void);
@@ -100,22 +100,22 @@
 
 };
 /**
-      \fn psIndexer 
+      \fn TsIndexer 
       \brief main indexing loop for mpeg2 payload
 */
-uint8_t   psIndexer(const char *file)
+uint8_t   tsIndexer(const char *file)
 {
 bool r;
-    PsIndexer *dx=new PsIndexer;
+    TsIndexer *dx=new TsIndexer;
     r=dx-&gt;run(file);
     delete dx;
     return r;
 }
 
 /**
-    \fn PsIndexer
+    \fn TsIndexer
 */
-PsIndexer::PsIndexer(void)
+TsIndexer::TsIndexer(void)
 {
     index=NULL;
     pkt=NULL;
@@ -124,20 +124,20 @@
 }
 
 /**
-    \fn ~PsIndexer
+    \fn ~TsIndexer
 */
-PsIndexer::~PsIndexer()
+TsIndexer::~TsIndexer()
 {
     if(index) qfclose(index);
     if(pkt) delete pkt;
-    if( audioTracks) DestroyListOfPsAudioTracks(audioTracks);
+    if( audioTracks) DestroyListOfTsAudioTracks(audioTracks);
     if(ui) delete ui;
     ui=NULL;
 }
 /**
     \fn run
 */  
-bool PsIndexer::run(const char *file)
+bool TsIndexer::run(const char *file)
 {
 uint32_t temporal_ref,val;
 uint64_t fullSize;
@@ -158,9 +158,9 @@
         return false;
     }
     writeSystem(file,true);
-    pkt=new psPacketLinearTracker(0xE0);
+    pkt=new tsPacketLinearTracker(0xE0);
 
-    audioTracks=psProbeAudio(file);
+    audioTracks=tsProbeAudio(file);
     if(audioTracks)
     {
         for(int i=0;i&lt;audioTracks-&gt;size();i++)
@@ -246,7 +246,7 @@
                           if(!seq_found)
                           { 
                                   continue;
-                                  printf(&quot;[psIndexer]No sequence start yet, skipping..\n&quot;);
+                                  printf(&quot;[TsIndexer]No sequence start yet, skipping..\n&quot;);
                           }
                           
                           val=pkt-&gt;readi16();
@@ -280,7 +280,7 @@
         qfprintf(index,&quot;\n[End]\n&quot;);
         qfclose(index);
         index=NULL;
-        if(audioTracks) DestroyListOfPsAudioTracks( audioTracks);
+        if(audioTracks) DestroyListOfTsAudioTracks( audioTracks);
         audioTracks=NULL;
         delete pkt;
         pkt=NULL;
@@ -295,7 +295,7 @@
     If the beginning is not a pic, but a gop start for example, we had to add/remove those.
 
 */
-bool  PsIndexer::Mark(indexerData *data,dmxPacketInfo *info,markType update)
+bool  TsIndexer::Mark(indexerData *data,dmxPacketInfo *info,markType update)
 {
     int offset=data-&gt;nextOffset;
     data-&gt;nextOffset=0;
@@ -353,7 +353,7 @@
     \fn writeVideo
     \brief Write Video section of index file
 */
-bool PsIndexer::writeVideo(PSVideo *video)
+bool TsIndexer::writeVideo(PSVideo *video)
 {
     qfprintf(index,&quot;[Video]\n&quot;);
     qfprintf(index,&quot;Width=%d\n&quot;,video-&gt;w);
@@ -367,7 +367,7 @@
     \fn writeSystem
     \brief Write system part of index file
 */
-bool PsIndexer::writeSystem(const char *filename,bool append)
+bool TsIndexer::writeSystem(const char *filename,bool append)
 {
     qfprintf(index,&quot;PSD1\n&quot;);
     qfprintf(index,&quot;[System]\n&quot;);
@@ -380,7 +380,7 @@
     \fn     writeAudio
     \brief  Write audio headers
 */
-bool PsIndexer::writeAudio(void)
+bool TsIndexer::writeAudio(void)
 {
     if(!audioTracks) return false;
     qfprintf(index,&quot;[Audio]\n&quot;);
@@ -388,7 +388,7 @@
     for(int i=0;i&lt;audioTracks-&gt;size();i++)
     {
         char head[30];
-        psAudioTrackInfo *t=(*audioTracks)[i];
+        tsAudioTrackInfo *t=(*audioTracks)[i];
         sprintf(head,&quot;Track%1d&quot;,i);
         qfprintf(index,&quot;%s.pid=%x\n&quot;,head,t-&gt;esID);
         qfprintf(index,&quot;%s.codec=%d\n&quot;,head,t-&gt;header.encoding);

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -14,19 +14,19 @@
  *                                                                         *
  ***************************************************************************/
 #include &quot;ADM_default.h&quot;
-#include &quot;ADM_ps.h&quot;
+#include &quot;ADM_ts.h&quot;
 #include &quot;ADM_demuxerInternal.h&quot;
 #include &quot;fourcc.h&quot;
 #include &quot;avidemutils.h&quot;
 
-ADM_DEMUXER_BEGIN( psHeader,
+ADM_DEMUXER_BEGIN( tsHeader,
                     1,0,0,
-                    &quot;ps&quot;,
-                    &quot;mpeg ps demuxer plugin (c) Mean 2007/2008&quot;
+                    &quot;ts&quot;,
+                    &quot;mpeg ps demuxer plugin (c) Mean 2007/2009&quot;
                 );
 
-static bool detectPs(const char *file);
-uint8_t   psIndexer(const char *file);
+static bool detectTs(const char *file);
+uint8_t   tsIndexer(const char *file);
 /**
     \fn Probe
 */
@@ -35,7 +35,7 @@
 {
 char index[strlen(fileName)+4];
 int count=0;
-    if(!detectPs(fileName))
+    if(!detectTs(fileName))
     {
         printf(&quot; [PS Demuxer] Not a ps file\n&quot;);
         return false;
@@ -52,14 +52,14 @@
         signature[4]=0;
         fclose(f);
         if(!strcmp(signature,&quot;PSD1&quot;)) return 50;
-        printf(&quot;[PsDemuxer] Not a valid index\n&quot;);
+        printf(&quot;[TSDemuxer] Not a valid index\n&quot;);
         return false;
     }
     if(count) return false;
-    printf(&quot;[PSDemuxer] Creating index..\n&quot;);
+    printf(&quot;[TSDemuxer] Creating index..\n&quot;);
     count++;
-    if(true==psIndexer(fileName)) goto again;
-    printf(&quot;[PSDemuxer] Failed..\n&quot;);
+    if(true==tsIndexer(fileName)) goto again;
+    printf(&quot;[TSDemuxer] Failed..\n&quot;);
    return 0;
 }
 #define PROBE_SIZE (1024*1024)
@@ -68,7 +68,7 @@
     \brief returns true if the file seems to be mpeg PS
 
 */
-bool detectPs(const char *file)
+bool detectTs(const char *file)
 {
     uint8_t *buffer=new uint8_t [PROBE_SIZE];
     uint32_t bufferSize;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -18,7 +18,7 @@
 #include &quot;fourcc.h&quot;
 #include &quot;DIA_coreToolkit.h&quot;
 #include &quot;ADM_indexFile.h&quot;
-#include &quot;ADM_ps.h&quot;
+#include &quot;ADM_ts.h&quot;
 
 #include &lt;math.h&gt;
 /**
@@ -26,7 +26,7 @@
         \brief Read the [video] section of the index file
 
 */
-bool    psHeader::readIndex(indexFile *index)
+bool    tsHeader::readIndex(indexFile *index)
 {
 char buffer[2000];
 bool firstAudio=true;
@@ -57,7 +57,7 @@
     \fn processAudioIndex
     \brief process audio seek points from a line from the index file
 */
-bool psHeader::processAudioIndex(char *buffer)
+bool tsHeader::processAudioIndex(char *buffer)
 {
     int64_t startAt,dts;
     uint32_t size;
@@ -73,10 +73,10 @@
             if(4!=sscanf(head,&quot;Pes:%&quot;LX&quot;:%&quot;LLX&quot;:%&quot;LD&quot;:%&quot;LLD&quot; &quot;,&amp;pes,&amp;startAt,&amp;size,&amp;dts))
             {
 // qfprintf(index,&quot;Pes:%x:%08&quot;LLX&quot;:%&quot;LD&quot;:%LLD &quot;,e,s-&gt;startAt,s-&gt;startSize,s-&gt;startDts);
-                printf(&quot;[PsHeader::processAudioIndex] Reading index %s failed\n&quot;,buffer);
+                printf(&quot;[tsHeader::processAudioIndex] Reading index %s failed\n&quot;,buffer);
             }
             head=tail+1;
-            ADM_psAccess *track=listOfAudioTracks[trackNb]-&gt;access;
+            ADM_tsAccess *track=listOfAudioTracks[trackNb]-&gt;access;
             track-&gt;push(startAt,dts,size);
 
             trackNb++;
@@ -91,7 +91,7 @@
     \fn processVideoIndex
     \brief process an mpeg index entry from a line from the index file
 */
-bool psHeader::processVideoIndex(char *buffer)
+bool tsHeader::processVideoIndex(char *buffer)
 {
             char *head=buffer;
             uint64_t pts,dts,startAt;
@@ -165,7 +165,7 @@
         \brief Read the [video] section of the index file
 
 */
-bool    psHeader::readVideo(indexFile *index)
+bool    tsHeader::readVideo(indexFile *index)
 {
     printf(&quot;[psDemuxer] Reading Video\n&quot;);
     if(!index-&gt;readSection(&quot;Video&quot;)) return false;
@@ -193,7 +193,7 @@
         \brief Read the [Audio] section of the index file
 
 */
-bool    psHeader::readAudio(indexFile *index,const char *name)
+bool    tsHeader::readAudio(indexFile *index,const char *name)
 {
     printf(&quot;[psDemuxer] Reading Audio\n&quot;);
     if(!index-&gt;readSection(&quot;Audio&quot;)) return false;
@@ -223,8 +223,8 @@
             hdr.byterate=br;
             hdr.channels=chan;
             hdr.encoding=codec;
-        ADM_psAccess *access=new ADM_psAccess(name,pid,true);
-            ADM_psTrackDescriptor *desc=new ADM_psTrackDescriptor;
+        ADM_tsAccess *access=new ADM_tsAccess(name,pid,true);
+            ADM_tsTrackDescriptor *desc=new ADM_tsTrackDescriptor;
             desc-&gt;stream=NULL;
             desc-&gt;access=access;
             memcpy(&amp;(desc-&gt;header),&amp;hdr,sizeof(hdr));

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-07 05:40:06 UTC (rev 4727)
@@ -8,6 +8,7 @@
 	ADM_tsAudioProbe.cpp
 	ADM_tsAudioProbe.h
         ADM_tsComputeTimeStamp.cpp
+        dmxTSPacket.cpp
 )
 
 ADD_LIBRARY(ADM_dm_ts SHARED ${ADM_ts_SRCS})

Copied: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp (from rev 4726, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -0,0 +1,653 @@
+/**
+    \file dmxtsPacket
+    \brief Packet demuxer for mpeg TS
+    copyright            : (C) 2005-2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+
+#include &quot;dmxTSPacket.h&quot;
+#include &quot;dmx_mpegstartcode.h&quot;
+
+/**
+    \fn tsPacket
+    \brief ctor
+*/
+tsPacket::tsPacket(void) 
+{
+
+}
+/**
+    \fn tsPacket
+    \brief dtor
+*/
+tsPacket::~tsPacket()
+{
+    close();
+}
+/**
+    \fn open
+    \brief dtor
+*/
+bool tsPacket::open(const char *filenames,FP_TYPE append)
+{
+    _file=new fileParser();
+    if(!_file-&gt;open(filenames,&amp;append))
+    {
+        printf(&quot;[DmxPS] cannot open %s\n&quot;,filenames);
+        delete _file;
+        _file=NULL;
+        return false;
+    }
+    _size=_file-&gt;getSize();
+    return true;
+}
+/**
+    \fn close
+    \brief dtor
+*/
+bool tsPacket::close(void)
+{
+    if(_file)
+    {
+        delete _file;
+        _file=NULL;
+    }
+    return true;
+}
+/**
+    \fn getPos
+*/
+uint64_t    tsPacket::getPos(void)
+{
+    return 0;
+}
+/**
+    \fn setPos
+*/
+
+bool    tsPacket::setPos(uint64_t pos)
+{
+    if(!_file-&gt;setpos(pos))
+    {
+        printf(&quot;[tsPacket] Cannot seek to %&quot;LLX&quot;\n&quot;, pos);
+        return false;
+    }
+}
+
+/**
+    \fn getPacket
+*/      
+bool        tsPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)
+{
+uint32_t globstream,len;
+uint8_t  stream,substream;
+uint64_t pts,dts;
+        // Resync on our stream
+_again2:
+        *pid=0;
+        if(!_file-&gt;sync(&amp;stream)) 
+        {
+                uint64_t pos;
+                _file-&gt;getpos(&amp;pos);
+                printf(&quot;[DmxPS] cannot sync  at &quot;LLU&quot;/&quot;LLU&quot;\n&quot;,pos,_size);
+                return false;
+        }
+// Position of this packet just before startcode
+        _file-&gt;getpos(startAt);
+        *startAt-=4;
+// Handle out of band stuff        
+        if(stream==PACK_START_CODE) 
+        {
+        		_file-&gt;forward(8);
+        		goto _again2;
+        }
+        if( stream==PADDING_CODE ||stream==SYSTEM_START_CODE) 
+        {
+                        len=_file-&gt;read16i();
+                        //printf(&quot;\tForwarding %lu bytes\n&quot;,len);
+        		_file-&gt;forward(len);
+        		goto _again2;
+        }
+        // Only keep relevant parts
+        // i.e. a/v : C0 C9 E0 E9
+        // subs 20-29
+        // private data 1/2
+#define INSIDE(min,max) (stream&gt;=min &amp;&amp; stream&lt;max)
+        if(!(  INSIDE(0xC0,0xC9) || INSIDE(0xE0,0xE9) || INSIDE(0x20,0x29) || stream==PRIVATE_STREAM_1 || stream==PRIVATE_STREAM_2
+        			)) goto _again2;
+        // Ok we got a candidate
+        if(!getPacketInfo(stream,&amp;substream,&amp;len,&amp;pts,&amp;dts))   
+        {
+                goto _again2;
+        }
+        
+        //printf(&quot;Main Stream :%x substream :%x\n&quot;,stream,substream);
+        if(stream==PRIVATE_STREAM_1) globstream=0xFF00+substream;
+                else                 globstream=stream;
+
+        *pid=globstream;
+        *opts=pts;
+        *odts=dts;
+        *packetSize=len;
+        if(len&gt;     maxSize)
+        {
+                printf(&quot;[DmxPS] Packet too big %d vs %d\n&quot;,len,maxSize);
+        }
+        if(!_file-&gt;read32(len,buffer)) return false;
+        return true;
+       
+}
+/**
+
+    \fn getPacketInfo
+    \brief       Retrieve info about the packet we just met.It is assumed that parser is just after the packet startcode
+
+*/
+
+uint8_t tsPacket::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
+{
+
+//uint32_t un ,deux;
+uint64_t size=0;
+uint8_t c,d;
+uint8_t align=0;
+                        
+                *substream=0xff;
+                *opts=ADM_NO_PTS;
+                *odts=ADM_NO_PTS;
+                
+                                        
+                size=_file-&gt;read16i();
+                if((stream==PADDING_CODE) || 
+                	 (stream==PRIVATE_STREAM_2)
+                        ||(stream==SYSTEM_START_CODE) //?
+                        ) // special case, no header
+                        {
+                                *olen=size;      
+                                return 1;
+                        }
+                                
+                        //      remove padding if any                                           
+        
+                while((c=_file-&gt;read8i()) == 0xff) 
+                {
+                        size--;
+                }
+//----------------------------------------------------------------------------
+//-------------------------------MPEG-2 PES packet style----------------------
+//----------------------------------------------------------------------------
+                if(((c&amp;0xC0)==0x80))
+                {
+                        uint32_t ptsdts,len;
+                        //printf(&quot;\n mpeg2 type \n&quot;);
+                        //_muxTypeMpeg2=1;
+                        // c= copyright and stuff       
+                        //printf(&quot; %x align\n&quot;,c);      
+                        if(c &amp; 4) align=1;      
+                        c=_file-&gt;read8i();     // PTS/DTS
+                        //printf(&quot;%x ptsdts\n&quot;,c
+                        ptsdts=c&gt;&gt;6;
+                        // header len
+                        len=_file-&gt;read8i();
+                        size-=3;  
+
+                        switch(ptsdts)
+                        {
+                                case 2: // PTS=1 DTS=0
+                                        if(len&gt;=5)
+                                        {
+                                                uint64_t pts1,pts2,pts0;
+                                                //      printf(&quot;\n PTS10\n&quot;);
+                                                        pts0=_file-&gt;read8i();  
+                                                        pts1=_file-&gt;read16i(); 
+                                                        pts2=_file-&gt;read16i();                 
+                                                        len-=5;
+                                                        size-=5;
+                                                        *opts=(pts1&gt;&gt;1)&lt;&lt;15;
+                                                        *opts+=pts2&gt;&gt;1;
+                                                        *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
+                                        }
+                                        break;
+                                case 3: // PTS=1 DTS=1
+                                                #define PTS11_ADV 10 // nut monkey
+                                                if(len&gt;=PTS11_ADV)
+                                                {
+                                                        uint32_t skip=PTS11_ADV;
+                                                        uint64_t pts1,pts2,dts,pts0;
+                                                                //      printf(&quot;\n PTS10\n&quot;);
+                                                                pts0=_file-&gt;read8i();  
+                                                                pts1=_file-&gt;read16i(); 
+                                                                pts2=_file-&gt;read16i(); 
+                                                                                        
+                                                                *opts=(pts1&gt;&gt;1)&lt;&lt;15;
+                                                                *opts+=pts2&gt;&gt;1;
+                                                                *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
+                                                                pts0=_file-&gt;read8i();  
+                                                                pts1=_file-&gt;read16i(); 
+                                                                pts2=_file-&gt;read16i();                 
+                                                                dts=(pts1&gt;&gt;1)&lt;&lt;15;
+                                                                dts+=pts2&gt;&gt;1;
+                                                                dts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
+                                                                len-=skip;
+                                                                size-=skip;
+                                                                *odts=dts;
+                                                                        //printf(&quot;DTS: %lx\n&quot;,dts);                
+                                                   }
+                                                   break;               
+                                case 1:
+                                                return 0;//ADM_assert(0); // forbidden !
+                                                break;
+                                case 0: 
+                                                // printf(&quot;\n PTS00\n&quot;);
+                                                break; // no pts nor dts
+                                                                                
+                                                            
+                        }  
+// Extension bit        
+// &gt;stealthdave&lt;                                
+
+                        // Skip remaining headers if any
+                        if(len) 
+                        {
+                                _file-&gt;forward(len);
+                                size=size-len;
+                        }
+                                
+                if(stream==PRIVATE_STREAM_1)
+                {
+                        if(size&gt;5)
+                        {
+                        // read sub id
+                               *substream=_file-&gt;read8i();
+  //                    printf(&quot;\n Subid : %x&quot;,*subid);
+                                switch(*substream)
+                                {
+                                // DTS
+                                        case 0x88:case 0x89:case 0x8A:case 0x8B:
+                                        
+                                                *substream=*substream-0x48;
+                                                break;
+
+                                //AC3
+                                        case 0x80:case 0x81:case 0x82:case 0x83:
+                                        case 0x84:case 0x85:case 0x86:case 0x87:
+                                                *substream=*substream-0x80;
+                                                break;
+                                // PCM
+                                        case 0xA0:case 0xA1:case 0xa2:case 0xa3:
+                                        case 0xA4:case 0xA5:case 0xa6:case 0xa7:
+                                                // we have an additionnal header
+                                                // of 3 bytes
+                                                _file-&gt;forward(3);
+                                                size-=3;
+                                                break;
+                                // Subs
+                                case 0x20:case 0x21:case 0x22:case 0x23:
+                                case 0x24:case 0x25:case 0x26:case 0x27:
+                                                break;
+                             
+                                default:
+                                                doNoComplainAnyMore++;
+                                                if(doNoComplainAnyMore&lt;10)
+                                                    printf(&quot;[DmxPS]Unkown substream %x\n&quot;,*substream);
+                                                *substream=0xff;
+                                }
+                                // skip audio header (if not sub)
+                                if(*substream&gt;0x26 || *substream&lt;0x20)
+                                {
+                                        _file-&gt;forward(3);
+                                        size-=3;
+                                }
+                                size--;
+                        }
+                }
+               //    printf(&quot; pid %x size : %x len %x\n&quot;,sid,size,len);
+                *olen=size;
+                return 1;
+        }
+//----------------------------------------------------------------------------------------------                
+//-------------------------------MPEG-1 PES packet style----------------------                                  
+//----------------------------------------------------------------------------------------------                                        
+           if(0) //_muxTypeMpeg2)
+                {
+                        printf(&quot;[DmxPS]*** packet type 1 inside type 2 ?????*****\n&quot;);
+                        return 0; // mmmm                       
+                }
+          // now look at  STD buffer size if present
+          // 01xxxxxxxxx
+          if ((c&gt;&gt;6) == 1) 
+          {       // 01
+                        size-=2;
+                        _file-&gt;read8i();                       // skip one byte
+                        c=_file-&gt;read8i();   // then another
+           }                       
+           // PTS/DTS
+           switch(c&gt;&gt;4)
+           {
+                case 2:
+                {
+                        // 0010 xxxx PTS only
+                        uint64_t pts1,pts2,pts0;
+                                        size -= 4;
+                                        pts0=(c&gt;&gt;1) &amp;7;
+                                        pts1=_file-&gt;read16i()&gt;&gt;1;
+                                        pts2=_file-&gt;read16i()&gt;&gt;1;
+                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
+                                        break;
+                  }
+                  case 3:
+                  {               // 0011 xxxx
+                        uint64_t pts1,pts2,pts0;
+                                        size -= 9;
+                                                                        
+                                        pts0=(c&gt;&gt;1) &amp;7;
+                                        pts1=_file-&gt;read16i()&gt;&gt;1;
+                                        pts2=_file-&gt;read16i()&gt;&gt;1;
+                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
+                                        _file-&gt;forward(5);
+                   }                                                               
+                   break;
+                   
+                case 1:
+                        // 0001 xxx             
+                        // PTSDTS=01 not allowed                        
+                                return 0;
+                                break; 
+                }
+                                                                
+
+                if(!align)      
+                        size--;         
+        *olen=size;
+        return 1;
+}
+//************************************************************************************
+
+#define ADM_PACKET_LINEAR 10*1024
+/**
+    \fn tsPacket
+*/
+tsPacketLinear::tsPacketLinear(uint8_t pid) : tsPacket()
+{
+    oldStartAt=startAt=0xfffffff;
+    oldBufferLen=bufferLen=0;
+    bufferIndex=0;
+    myPid=pid;
+    eof=false;
+}
+/**
+    \fn ~tsPacket
+*/
+tsPacketLinear::~tsPacketLinear() 
+{
+}
+/**
+    \fn refill
+*/
+bool tsPacketLinear::refill(void) 
+{
+// In case a startcode spawns across 2 packets
+// we have to keep track of the old one
+        oldBufferDts=bufferDts;
+        oldBufferPts=bufferPts;
+        oldStartAt=startAt;
+        oldBufferLen=bufferLen;
+        if( false== getPacketOfType(myPid,ADM_PACKET_LINEAR, &amp;bufferLen,&amp;bufferPts,&amp;bufferDts,buffer,&amp;startAt)) 
+        {
+            printf(&quot;[tsPacketLinear] Refill failed for pid :%x\n&quot;,myPid);
+            bufferIndex=bufferLen=0;
+            return false;
+        }
+        //printf(&quot;Refill : At :%&quot;LLX&quot; size :%&quot;LD&quot;\n&quot;,startAt,bufferLen);
+        bufferIndex=0;
+        return true;
+}
+/**
+    \fn readi8
+*/
+uint8_t tsPacketLinear::readi8(void)
+{
+    consumed++;
+    if(bufferIndex&lt;bufferLen)
+    {
+        return buffer[bufferIndex++];
+    }
+    if(false==refill()) 
+    {
+        eof=1;
+        return 0;
+    }
+    ADM_assert(bufferLen);
+    bufferIndex=1;
+    return buffer[0];
+    
+}
+/**
+    \fn readi16
+*/
+uint16_t tsPacketLinear::readi16(void)
+{
+    if(bufferIndex+1&lt;bufferLen)
+    {
+        uint16_t v=(buffer[bufferIndex]&lt;&lt;8)+buffer[bufferIndex+1];;
+        bufferIndex+=2;
+        consumed+=2;
+        return v;
+    }
+    return (readi8()&lt;&lt;8)+readi8();
+}
+/**
+    \fn readi32
+*/
+uint32_t tsPacketLinear::readi32(void)
+{
+    if(bufferIndex+3&lt;bufferLen)
+    {
+        uint8_t *p=buffer+bufferIndex;
+        uint32_t v=(p[0]&lt;&lt;24)+(p[1]&lt;&lt;16)+(p[2]&lt;&lt;8)+p[3];
+        bufferIndex+=4;
+        consumed+=4;
+        return v;
+    }
+    return (readi16()&lt;&lt;16)+readi16();
+}
+/**
+    \fn forward
+*/
+bool tsPacketLinear::forward(uint32_t v)
+{
+next:
+ uint32_t delta=bufferLen-bufferIndex;
+    if(v&gt;100*1000)
+    {
+        ADM_assert(0);
+    }
+    if(v&lt;=delta)
+    {
+        bufferIndex+=v;
+        consumed+=v;
+        return true;
+    }
+    // v&gt;delta
+    v-=delta;
+    if(!refill()) return false;
+    goto next;
+}
+
+/**
+    \fn bool    read(uint32_t len, uint8_t *buffer);
+    \brief
+*/
+bool    tsPacketLinear::read(uint32_t len, uint8_t *out)
+{
+    // Enough already ?
+    while(len)
+    {
+        uint32_t avail=bufferLen-bufferIndex;
+        uint32_t chunk=avail;
+        if(chunk&gt;len) chunk=len;
+#if 0
+        printf(&quot;len:%ld avail:%ld chunk %ld index:%d size:%d\n&quot;,
+                len,avail,chunk,bufferIndex,bufferLen);
+#endif
+        memcpy(out,buffer+bufferIndex,chunk);
+        bufferIndex+=chunk;
+        len-=chunk;
+        out+=chunk;
+        consumed+=chunk;
+        if(bufferIndex==bufferLen)
+        {
+            //printf(&quot;Refill\n&quot;);
+            if(false==refill()) return false;
+        }
+    }
+    return true;
+}
+/**
+        \fn getInfo
+        \brief Returns info about the current (or previous if it spawns) packet.
+            It is expected that the caller will do -4 to the index to get the start of the 
+            startCode
+*/
+bool    tsPacketLinear::getInfo(dmxPacketInfo *info)
+{
+    if(bufferIndex&lt;4)
+    {
+        info-&gt;startAt=this-&gt;oldStartAt;
+        info-&gt;offset=oldBufferLen+bufferIndex;
+        info-&gt;pts=oldBufferPts;
+        info-&gt;dts=oldBufferDts;
+
+    }else
+    {
+        info-&gt;startAt=this-&gt;startAt;
+        info-&gt;offset=bufferIndex;
+        info-&gt;pts=bufferPts;
+        info-&gt;dts=bufferDts;
+    }
+    return true;
+
+};
+/**
+    \fn seek
+    \brief Async jump
+*/
+bool    tsPacketLinear::seek(uint64_t packetStart, uint32_t offset)
+{
+    if(!_file-&gt;setpos(packetStart))
+    {
+        printf(&quot;[tsPacket] Cannot seek to %&quot;LLX&quot;\n&quot;,packetStart);
+        return 0;
+    }
+    if(!refill())
+    {
+        printf(&quot;[tsPacketLinear] Seek to %&quot;LLX&quot;:%&quot;LX&quot; failed\n&quot;,packetStart,offset);
+        return false;
+    }
+    ADM_assert(offset&lt;bufferLen);
+    bufferIndex=offset;
+    
+    return true;
+}
+/**
+    \fn getConsumed
+    \brief returns the # of bytes consumed since the last call
+*/
+uint32_t tsPacketLinear::getConsumed(void)
+{
+    uint32_t c=consumed;
+    consumed=0;
+    return c;
+}
+/**
+    \fn changePid
+    \brief change the pid of the stream we read (used when probing all tracks)
+*/
+bool    tsPacketLinear::changePid(uint32_t pid) 
+{
+    myPid=(pid&amp;0xff);
+    bufferLen=bufferIndex=0;
+    return true;
+}
+/* ********************************************************* */
+/**
+    \fn tsPacketLinearTracker
+*/
+ tsPacketLinearTracker::tsPacketLinearTracker(uint8_t pid)  : tsPacketLinear(pid)
+{
+   resetStats();
+}
+/**
+    \fn ~tsPacketLinearTracker
+*/
+tsPacketLinearTracker::~tsPacketLinearTracker()
+{
+
+    
+}
+/**
+        \fn getStat
+*/
+packetStats    *tsPacketLinearTracker::getStat(int index)
+{   
+    if(index&lt;0 || index&gt;=256) ADM_assert(0);
+    return stats+index;
+}
+/**
+    \fn getPacketgetPacketOfType
+    \brief Keep track of all the packets we have seen so far.
+    Usefull to detect the streams present and to look up the PTS/DTS of audio streams for the audio part of the index
+*/
+bool           tsPacketLinearTracker::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
+{
+ bool xit=false;
+    uint8_t tmppid;
+    while(1)
+    {
+        if(true!=getPacket(maxSize,&amp;tmppid,packetSize,pts,dts,buffer,startAt))
+                return false;
+        else
+        {
+                // Update 
+                ADM_assert(tmppid&lt;0x100);
+                packetStats *p=stats+tmppid;
+                uint64_t ts=*pts;
+                if(ts==ADM_NO_PTS) ts=*dts;
+                if(ts!=ADM_NO_PTS)
+                {
+                    p-&gt;startCount=p-&gt;count;
+                    p-&gt;startAt=*startAt;
+                    p-&gt;startSize=p-&gt;size;
+                    p-&gt;startDts=ts;
+                }
+                p-&gt;count++;
+                p-&gt;size+=*packetSize;
+                if(tmppid==pid) return true;
+        }
+    }
+    return false;
+}
+/**
+    \fn resetStats
+*/
+bool           tsPacketLinearTracker::resetStats(void)
+{
+    memset(stats,0,sizeof(stats));
+    for(int i=0;i&lt;256;i++)
+    {
+        packetStats *p=stats+i;
+        p-&gt;startDts=ADM_NO_PTS;
+    }
+}
+//EOF

Copied: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h (from rev 4726, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-07 05:40:06 UTC (rev 4727)
@@ -0,0 +1,98 @@
+/**
+   \file dmxtsPacket.h
+    \brief demuxer for TS stream
+    (C) Mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> 2003-2009
+
+*/
+
+#ifndef DMXtsPacket_H
+#define DMXtsPacket_H
+
+#include &quot;dmxPacket.h&quot;
+#include &quot;ADM_Video.h&quot;
+
+
+
+/**
+    \class tsPacket
+*/
+class tsPacket : public ADMMpegPacket
+{
+protected:
+    uint8_t             getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
+public:
+                        tsPacket(void);
+    virtual            ~tsPacket();
+    virtual bool        open(const char *filenames,FP_TYPE append);
+    virtual bool        close(void);
+    virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
+    virtual uint64_t    getPos(void);
+    virtual bool        setPos(uint64_t pos);
+};
+/**
+    \class tsPacketLinear
+*/
+#define ADM_PACKET_LINEAR 10*1024
+
+class tsPacketLinear : public tsPacket
+{
+protected:
+        uint8_t  myPid;
+        uint64_t startAt;
+        uint32_t bufferLen;
+        uint64_t bufferPts;
+        uint64_t bufferDts;
+        uint32_t bufferIndex;
+        uint8_t  buffer[ADM_PACKET_LINEAR];
+        bool     eof;
+        bool     refill(void);
+        uint64_t oldStartAt;
+        uint32_t oldBufferLen;
+        uint64_t oldBufferPts;
+        uint64_t oldBufferDts;
+        uint32_t consumed;
+
+public:
+                tsPacketLinear(uint8_t pid);
+                ~tsPacketLinear();
+        uint32_t getConsumed(void);
+        uint8_t  readi8();
+        uint16_t readi16();
+        uint32_t readi32();
+        bool     sync(uint8_t *pid);
+        bool    read(uint32_t len, uint8_t *buffer);
+        bool    forward(uint32_t v);
+        bool    stillOk(void) {return !eof;};
+        bool    getInfo(dmxPacketInfo *info);
+        bool    seek(uint64_t packetStart, uint32_t offset);
+        bool    changePid(uint32_t pid) ;
+};
+/**
+    \class tsPacketLinearTracker
+*/
+typedef struct
+{
+    uint32_t count;
+    uint32_t size;
+    
+    uint64_t startAt;
+    uint32_t startCount;
+    uint32_t startSize;
+    uint64_t startDts;
+}packetStats;
+
+class tsPacketLinearTracker : public tsPacketLinear
+{
+protected:
+      packetStats stats[256];
+
+public:
+                        tsPacketLinearTracker(uint8_t pid);
+                        ~tsPacketLinearTracker();
+         packetStats    *getStat(int intdex);
+         bool           resetStats(void);
+virtual  bool           getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
+};
+
+
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001954.html">[Avidemux-svn-commit] r4726 - in	branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg:	include src
</A></li>
	<LI>Next message: <A HREF="001956.html">[Avidemux-svn-commit] r4728 - in branches/avidemux_2.6_branch_mean:	avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegTS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1955">[ date ]</a>
              <a href="thread.html#1955">[ thread ]</a>
              <a href="subject.html#1955">[ subject ]</a>
              <a href="author.html#1955">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
