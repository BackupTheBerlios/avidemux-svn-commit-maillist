<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6588 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-September/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6588%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass&In-Reply-To=%3C20100906102319.15D90481051%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003773.html">
   <LINK REL="Next"  HREF="003775.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6588 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6588%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass&In-Reply-To=%3C20100906102319.15D90481051%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6588 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass">mean at mail.berlios.de
       </A><BR>
    <I>Mon Sep  6 12:23:18 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003773.html">[Avidemux-svn-commit] r6587 - in	branches/avidemux_2.5_branch_gruntster: avidemux	platforms/windows/build_scripts	platforms/windows/build_scripts/avidemux platforms/windows/installer
</A></li>
        <LI>Next message: <A HREF="003775.html">[Avidemux-svn-commit] r6589 - in	branches/avidemux_2.6_branch_mean/avidemux: common	common/ADM_toolkit qt4/ADM_userInterfaces/ADM_gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3774">[ date ]</a>
              <a href="thread.html#3774">[ thread ]</a>
              <a href="subject.html#3774">[ subject ]</a>
              <a href="author.html#3774">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-09-06 12:23:18 +0200 (Mon, 06 Sep 2010)
New Revision: 6588

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache_template.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_drawing.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_drawing.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_parse.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_parse.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render_api.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_strtod.c
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_types.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.h
Log:
[filter/ass] update libass

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/CMakeLists.txt	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/CMakeLists.txt	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,19 +1,30 @@
 INCLUDE(admCheckFontConfig)
 checkFontConfig()
 
+#CONFIG_FONTCONFIG
+#CONFIG_ENCA
+#CONFIG_ICONV
+#
+#
+#
+
 SET(ADM_LIB ADM_libass)
 
 SET(${ADM_LIB}_SRCS 
-ass_bitmap.c  ass.c  ass_cache.c  ass_fontconfig.c  ass_library.c   ass_render.c  ass_utils.c  mputils.c
-ass_font.c)
+ass_bitmap.c  ass.c  ass_cache.c  ass_fontconfig.c  ass_library.c   ass_render.c  ass_utils.c
+ass_font.c ass_parse.c ass_drawing.c ass_render_api.c ass_strtod.c)
+#  mputils.c
 
 ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
 ADD_DEFINITIONS(${FREETYPE2_CFLAGS} &quot;-I${LIBICONV_INCLUDE_DIR}&quot;)
 
 IF (FONTCONFIG_FOUND)
-	ADD_DEFINITIONS(${FONTCONFIG_CFLAGS} &quot;-DHAVE_FONTCONFIG=1&quot;)
+	ADD_DEFINITIONS(${FONTCONFIG_CFLAGS} &quot;-DCONFIG_FONTCONFIG=1&quot;)
 ENDIF (FONTCONFIG_FOUND)
 
+# ?
+ADD_DEFINITIONS(${FONTCONFIG_CFLAGS} &quot;-DCONFIG_ICONV=1&quot;)
+
 IF (UNIX)
 	ADD_TARGET_CFLAGS(${ADM_LIB} -fPIC)
-ENDIF (UNIX)
\ No newline at end of file
+ENDIF (UNIX)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.c	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,28 +1,29 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#include &quot;ADM_coreConfig.h&quot;
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include &quot;config.h&quot;
-
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
+#include &lt;strings.h&gt;
 #include &lt;assert.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;sys/types.h&gt;
@@ -30,124 +31,138 @@
 #include &lt;unistd.h&gt;
 #include &lt;inttypes.h&gt;
 
-#ifdef USE_ICONV
+#ifdef CONFIG_ICONV
 #include &lt;iconv.h&gt;
 #endif
 
 #include &quot;ass.h&quot;
 #include &quot;ass_utils.h&quot;
 #include &quot;ass_library.h&quot;
-#include &quot;mputils.h&quot;
 
-typedef enum {PST_UNKNOWN = 0, PST_INFO, PST_STYLES, PST_EVENTS, PST_FONTS} parser_state_t;
+#define ass_atof(STR) (ass_strtod((STR),NULL))
 
-struct parser_priv_s {
-	parser_state_t state;
-	char* fontname;
-	char* fontdata;
-	int fontdata_size;
-	int fontdata_used;
+typedef enum {
+    PST_UNKNOWN = 0,
+    PST_INFO,
+    PST_STYLES,
+    PST_EVENTS,
+    PST_FONTS
+} ParserState;
+
+struct parser_priv {
+    ParserState state;
+    char *fontname;
+    char *fontdata;
+    int fontdata_size;
+    int fontdata_used;
 };
 
 #define ASS_STYLES_ALLOC 20
 #define ASS_EVENTS_ALLOC 200
 
-void ass_free_track(ass_track_t* track) {
-	int i;
-	
-	if (track-&gt;parser_priv) {
-		if (track-&gt;parser_priv-&gt;fontname)
-			free(track-&gt;parser_priv-&gt;fontname);
-		if (track-&gt;parser_priv-&gt;fontdata)
-			free(track-&gt;parser_priv-&gt;fontdata);
-		free(track-&gt;parser_priv);
-	}
-	if (track-&gt;style_format)
-		free(track-&gt;style_format);
-	if (track-&gt;event_format)
-		free(track-&gt;event_format);
-	if (track-&gt;styles) {
-		for (i = 0; i &lt; track-&gt;n_styles; ++i)
-			ass_free_style(track, i);
-		free(track-&gt;styles);
-	}
-	if (track-&gt;events) {
-		for (i = 0; i &lt; track-&gt;n_events; ++i)
-			ass_free_event(track, i);
-		free(track-&gt;events);
-	}
+void ass_free_track(ASS_Track *track)
+{
+    int i;
+
+    if (track-&gt;parser_priv) {
+        free(track-&gt;parser_priv-&gt;fontname);
+        free(track-&gt;parser_priv-&gt;fontdata);
+        free(track-&gt;parser_priv);
+    }
+    free(track-&gt;style_format);
+    free(track-&gt;event_format);
+    if (track-&gt;styles) {
+        for (i = 0; i &lt; track-&gt;n_styles; ++i)
+            ass_free_style(track, i);
+    }
+    free(track-&gt;styles);
+    if (track-&gt;events) {
+        for (i = 0; i &lt; track-&gt;n_events; ++i)
+            ass_free_event(track, i);
+    }
+    free(track-&gt;events);
+    free(track-&gt;name);
+    free(track);
 }
 
 /// \brief Allocate a new style struct
 /// \param track track
 /// \return style id
-int ass_alloc_style(ass_track_t* track) {
-	int sid;
-	
-	assert(track-&gt;n_styles &lt;= track-&gt;max_styles);
+int ass_alloc_style(ASS_Track *track)
+{
+    int sid;
 
-	if (track-&gt;n_styles == track-&gt;max_styles) {
-		track-&gt;max_styles += ASS_STYLES_ALLOC;
-		track-&gt;styles = (ass_style_t*)realloc(track-&gt;styles, sizeof(ass_style_t)*track-&gt;max_styles);
-	}
-	
-	sid = track-&gt;n_styles++;
-	memset(track-&gt;styles + sid, 0, sizeof(ass_style_t));
-	return sid;
+    assert(track-&gt;n_styles &lt;= track-&gt;max_styles);
+
+    if (track-&gt;n_styles == track-&gt;max_styles) {
+        track-&gt;max_styles += ASS_STYLES_ALLOC;
+        track-&gt;styles =
+            (ASS_Style *) realloc(track-&gt;styles,
+                                  sizeof(ASS_Style) *
+                                  track-&gt;max_styles);
+    }
+
+    sid = track-&gt;n_styles++;
+    memset(track-&gt;styles + sid, 0, sizeof(ASS_Style));
+    return sid;
 }
 
 /// \brief Allocate a new event struct
 /// \param track track
 /// \return event id
-int ass_alloc_event(ass_track_t* track) {
-	int eid;
-	
-	assert(track-&gt;n_events &lt;= track-&gt;max_events);
+int ass_alloc_event(ASS_Track *track)
+{
+    int eid;
 
-	if (track-&gt;n_events == track-&gt;max_events) {
-		track-&gt;max_events += ASS_EVENTS_ALLOC;
-		track-&gt;events = (ass_event_t*)realloc(track-&gt;events, sizeof(ass_event_t)*track-&gt;max_events);
-	}
-	
-	eid = track-&gt;n_events++;
-	memset(track-&gt;events + eid, 0, sizeof(ass_event_t));
-	return eid;
+    assert(track-&gt;n_events &lt;= track-&gt;max_events);
+
+    if (track-&gt;n_events == track-&gt;max_events) {
+        track-&gt;max_events += ASS_EVENTS_ALLOC;
+        track-&gt;events =
+            (ASS_Event *) realloc(track-&gt;events,
+                                  sizeof(ASS_Event) *
+                                  track-&gt;max_events);
+    }
+
+    eid = track-&gt;n_events++;
+    memset(track-&gt;events + eid, 0, sizeof(ASS_Event));
+    return eid;
 }
 
-void ass_free_event(ass_track_t* track, int eid) {
-	ass_event_t* event = track-&gt;events + eid;
-	if (event-&gt;Name)
-		free(event-&gt;Name);
-	if (event-&gt;Effect)
-		free(event-&gt;Effect);
-	if (event-&gt;Text)
-		free(event-&gt;Text);
-	if (event-&gt;render_priv)
-		free(event-&gt;render_priv);
+void ass_free_event(ASS_Track *track, int eid)
+{
+    ASS_Event *event = track-&gt;events + eid;
+
+    free(event-&gt;Name);
+    free(event-&gt;Effect);
+    free(event-&gt;Text);
+    free(event-&gt;render_priv);
 }
 
-void ass_free_style(ass_track_t* track, int sid) {
-	ass_style_t* style = track-&gt;styles + sid;
-	if (style-&gt;Name)
-		free(style-&gt;Name);
-	if (style-&gt;FontName)
-		free(style-&gt;FontName);
+void ass_free_style(ASS_Track *track, int sid)
+{
+    ASS_Style *style = track-&gt;styles + sid;
+
+    free(style-&gt;Name);
+    free(style-&gt;FontName);
 }
 
 // ==============================================================================================
 
-static void skip_spaces(char** str) {
-	char* p = *str;
-	while ((*p==' ') || (*p=='\t'))
-		++p;
-	*str = p;
+static void skip_spaces(char **str)
+{
+    char *p = *str;
+    while ((*p == ' ') || (*p == '\t'))
+        ++p;
+    *str = p;
 }
 
-static void rskip_spaces(char** str, char* limit) {
-	char* p = *str;
-	while ((p &gt;= limit) &amp;&amp; ((*p==' ') || (*p=='\t')))
-		--p;
-	*str = p;
+static void rskip_spaces(char **str, char *limit)
+{
+    char *p = *str;
+    while ((p &gt;= limit) &amp;&amp; ((*p == ' ') || (*p == '\t')))
+        --p;
+    *str = p;
 }
 
 /**
@@ -158,47 +173,55 @@
  * Returnes 0 if no styles found =&gt; expects at least 1 style.
  * Parsing code always adds &quot;Default&quot; style in the end.
  */
-static int lookup_style(ass_track_t* track, char* name) {
-	int i;
-	if (*name == '*') ++name; // FIXME: what does '*' really mean ?
-	for (i=0; i&lt;track-&gt;n_styles; ++i) {
-		// FIXME: mb strcasecmp ?
-		if (strcmp(track-&gt;styles[i].Name, name) == 0)
-			return i;
-	}
-	i = track-&gt;default_style;
-	mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoStyleNamedXFoundUsingY, track, name, track-&gt;styles[i].Name);
-	return i; // use the first style
+static int lookup_style(ASS_Track *track, char *name)
+{
+    int i;
+    if (*name == '*')
+        ++name;                 // FIXME: what does '*' really mean ?
+    for (i = track-&gt;n_styles - 1; i &gt;= 0; --i) {
+        // FIXME: mb strcasecmp ?
+        if (strcmp(track-&gt;styles[i].Name, name) == 0)
+            return i;
+    }
+    i = track-&gt;default_style;
+    ass_msg(track-&gt;library, MSGL_WARN,
+            &quot;[%p]: Warning: no style named '%s' found, using '%s'&quot;,
+            track, name, track-&gt;styles[i].Name);
+    return i;                   // use the first style
 }
 
-static uint32_t string2color(char* p) {
-	uint32_t tmp;
-	(void)strtocolor(&amp;p, &amp;tmp);
-	return tmp;
+static uint32_t string2color(ASS_Library *library, char *p)
+{
+    uint32_t tmp;
+    (void) strtocolor(library, &amp;p, &amp;tmp, 0);
+    return tmp;
 }
 
-static long long string2timecode(char* p) {
-	unsigned h, m, s, ms;
-	long long tm;
-	int res = sscanf(p, &quot;%1d:%2d:%2d.%2d&quot;, &amp;h, &amp;m, &amp;s, &amp;ms);
-	if (res &lt; 4) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_BadTimestamp);
-		return 0;
-	}
-	tm = ((h * 60 + m) * 60 + s) * 1000 + ms * 10;
-	return tm;
+static long long string2timecode(ASS_Library *library, char *p)
+{
+    unsigned h, m, s, ms;
+    long long tm;
+    int res = sscanf(p, &quot;%1d:%2d:%2d.%2d&quot;, &amp;h, &amp;m, &amp;s, &amp;ms);
+    if (res &lt; 4) {
+        ass_msg(library, MSGL_WARN, &quot;Bad timestamp&quot;);
+        return 0;
+    }
+    tm = ((h * 60 + m) * 60 + s) * 1000 + ms * 10;
+    return tm;
 }
 
 /**
  * \brief converts numpad-style align to align.
  */
-static int numpad2align(int val) {
-	int res, v;
-	v = (val - 1) / 3; // 0, 1 or 2 for vertical alignment
-	if (v != 0) v = 3 - v;
-	res = ((val - 1) % 3) + 1; // horizontal alignment
-	res += v*4;
-	return res;
+static int numpad2align(int val)
+{
+    int res, v;
+    v = (val - 1) / 3;          // 0, 1 or 2 for vertical alignment
+    if (v != 0)
+        v = 3 - v;
+    res = ((val - 1) % 3) + 1;  // horizontal alignment
+    res += v * 4;
+    return res;
 }
 
 #define NEXT(str,token) \
@@ -208,113 +231,125 @@
 #define ANYVAL(name,func) \
 	} else if (strcasecmp(tname, #name) == 0) { \
 		target-&gt;name = func(token); \
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;%s = %s\n&quot;, #name, token);
+		ass_msg(track-&gt;library, MSGL_DBG2, &quot;%s = %s&quot;, #name, token);
 
 #define STRVAL(name) \
 	} else if (strcasecmp(tname, #name) == 0) { \
 		if (target-&gt;name != NULL) free(target-&gt;name); \
 		target-&gt;name = strdup(token); \
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;%s = %s\n&quot;, #name, token);
-		
-#define COLORVAL(name) ANYVAL(name,string2color)
+		ass_msg(track-&gt;library, MSGL_DBG2, &quot;%s = %s&quot;, #name, token);
+
+#define COLORVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target-&gt;name = string2color(track-&gt;library, token); \
+		ass_msg(track-&gt;library, MSGL_DBG2, &quot;%s = %s&quot;, #name, token);
+
 #define INTVAL(name) ANYVAL(name,atoi)
-#define FPVAL(name) ANYVAL(name,atof)
-#define TIMEVAL(name) ANYVAL(name,string2timecode)
+#define FPVAL(name) ANYVAL(name,ass_atof)
+#define TIMEVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target-&gt;name = string2timecode(track-&gt;library, token); \
+		ass_msg(track-&gt;library, MSGL_DBG2, &quot;%s = %s&quot;, #name, token);
+
 #define STYLEVAL(name) \
 	} else if (strcasecmp(tname, #name) == 0) { \
 		target-&gt;name = lookup_style(track, token); \
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;%s = %s\n&quot;, #name, token);
+		ass_msg(track-&gt;library, MSGL_DBG2, &quot;%s = %s&quot;, #name, token);
 
 #define ALIAS(alias,name) \
 	if (strcasecmp(tname, #alias) == 0) {tname = #name;}
 
-static char* next_token(char** str) {
-	char* p = *str;
-	char* start;
-	skip_spaces(&amp;p);
-	if (*p == '\0') {
-		*str = p;
-		return 0;
-	}
-	start = p; // start of the token
-	for (; (*p != '\0') &amp;&amp; (*p != ','); ++p) {}
-	if (*p == '\0') {
-		*str = p; // eos found, str will point to '\0' at exit
-	} else {
-		*p = '\0';
-		*str = p + 1; // ',' found, str will point to the next char (beginning of the next token)
-	}
-	--p; // end of current token
-	rskip_spaces(&amp;p, start);
-	if (p &lt; start)
-		p = start; // empty token
-	else
-		++p; // the first space character, or '\0'
-	*p = '\0';
-	return start;
+static char *next_token(char **str)
+{
+    char *p = *str;
+    char *start;
+    skip_spaces(&amp;p);
+    if (*p == '\0') {
+        *str = p;
+        return 0;
+    }
+    start = p;                  // start of the token
+    for (; (*p != '\0') &amp;&amp; (*p != ','); ++p) {
+    }
+    if (*p == '\0') {
+        *str = p;               // eos found, str will point to '\0' at exit
+    } else {
+        *p = '\0';
+        *str = p + 1;           // ',' found, str will point to the next char (beginning of the next token)
+    }
+    --p;                        // end of current token
+    rskip_spaces(&amp;p, start);
+    if (p &lt; start)
+        p = start;              // empty token
+    else
+        ++p;                    // the first space character, or '\0'
+    *p = '\0';
+    return start;
 }
+
 /**
  * \brief Parse the tail of Dialogue line
  * \param track track
  * \param event parsed data goes here
  * \param str string to parse, zero-terminated
  * \param n_ignored number of format options to skip at the beginning
-*/ 
-static int process_event_tail(ass_track_t* track, ass_event_t* event, char* str, int n_ignored)
+*/
+static int process_event_tail(ASS_Track *track, ASS_Event *event,
+                              char *str, int n_ignored)
 {
-	char* token;
-	char* tname;
-	char* p = str;
-	int i;
-	ass_event_t* target = event;
+    char *token;
+    char *tname;
+    char *p = str;
+    int i;
+    ASS_Event *target = event;
 
-	char* format = strdup(track-&gt;event_format);
-	char* q = format; // format scanning pointer
+    char *format = strdup(track-&gt;event_format);
+    char *q = format;           // format scanning pointer
 
-	if (track-&gt;n_styles == 0) {
-		// add &quot;Default&quot; style to the end
-		// will be used if track does not contain a default style (or even does not contain styles at all)
-		int sid = ass_alloc_style(track);
-		track-&gt;styles[sid].Name = strdup(&quot;Default&quot;);
-		track-&gt;styles[sid].FontName = strdup(&quot;Arial&quot;);
-	}
+    if (track-&gt;n_styles == 0) {
+        // add &quot;Default&quot; style to the end
+        // will be used if track does not contain a default style (or even does not contain styles at all)
+        int sid = ass_alloc_style(track);
+        track-&gt;styles[sid].Name = strdup(&quot;Default&quot;);
+        track-&gt;styles[sid].FontName = strdup(&quot;Arial&quot;);
+    }
 
-	for (i = 0; i &lt; n_ignored; ++i) {
-		NEXT(q, tname);
-	}
+    for (i = 0; i &lt; n_ignored; ++i) {
+        NEXT(q, tname);
+    }
 
-	while (1) {
-		NEXT(q, tname);
-		if (strcasecmp(tname, &quot;Text&quot;) == 0) {
-			char* last;
-			event-&gt;Text = strdup(p);
-			if (*event-&gt;Text != 0) {
-				last = event-&gt;Text + strlen(event-&gt;Text) - 1;
-				if (last &gt;= event-&gt;Text &amp;&amp; *last == '\r')
-					*last = 0;
-			}
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;Text = %s\n&quot;, event-&gt;Text);
-			event-&gt;Duration -= event-&gt;Start;
-			free(format);
-			return 0; // &quot;Text&quot; is always the last
-		}
-		NEXT(p, token);
+    while (1) {
+        NEXT(q, tname);
+        if (strcasecmp(tname, &quot;Text&quot;) == 0) {
+            char *last;
+            event-&gt;Text = strdup(p);
+            if (*event-&gt;Text != 0) {
+                last = event-&gt;Text + strlen(event-&gt;Text) - 1;
+                if (last &gt;= event-&gt;Text &amp;&amp; *last == '\r')
+                    *last = 0;
+            }
+            ass_msg(track-&gt;library, MSGL_DBG2, &quot;Text = %s&quot;, event-&gt;Text);
+            event-&gt;Duration -= event-&gt;Start;
+            free(format);
+            return 0;           // &quot;Text&quot; is always the last
+        }
+        NEXT(p, token);
 
-		ALIAS(End,Duration) // temporarily store end timecode in event-&gt;Duration
-		if (0) { // cool ;)
-			INTVAL(Layer)
-			STYLEVAL(Style)
-			STRVAL(Name)
-			STRVAL(Effect)
-			INTVAL(MarginL)
-			INTVAL(MarginR)
-			INTVAL(MarginV)
-			TIMEVAL(Start)
-			TIMEVAL(Duration)
-		}
-	}
-	free(format);
-	return 1;
+        ALIAS(End, Duration)    // temporarily store end timecode in event-&gt;Duration
+        if (0) {            // cool ;)
+            INTVAL(Layer)
+            STYLEVAL(Style)
+            STRVAL(Name)
+            STRVAL(Effect)
+            INTVAL(MarginL)
+            INTVAL(MarginR)
+            INTVAL(MarginV)
+            TIMEVAL(Start)
+            TIMEVAL(Duration)
+        }
+    }
+    free(format);
+    return 1;
 }
 
 /**
@@ -322,62 +357,79 @@
  * \param track track to apply overrides to
  * The format for overrides is [StyleName.]Field=Value
  */
-void process_force_style(ass_track_t* track) {
-	char **fs, *eq, *dt, *style, *tname, *token;
-	ass_style_t* target;
-	int sid;
-	char** list = track-&gt;library-&gt;style_overrides;
-	
-	if (!list) return;
-	
-	for (fs = list; *fs; ++fs) {
-		eq = strrchr(*fs, '=');
-		if (!eq)
-			continue;
-		*eq = '\0';
-		token = eq + 1;
+void ass_process_force_style(ASS_Track *track)
+{
+    char **fs, *eq, *dt, *style, *tname, *token;
+    ASS_Style *target;
+    int sid;
+    char **list = track-&gt;library-&gt;style_overrides;
 
-		dt = strrchr(*fs, '.');
-		if (dt) {
-			*dt = '\0';
-			style = *fs;
-			tname = dt + 1;
-		} else {
-			style = NULL;
-			tname = *fs;
-		}
-		for (sid = 0; sid &lt; track-&gt;n_styles; ++sid) {
-			if (style == NULL || strcasecmp(track-&gt;styles[sid].Name, style) == 0) {
-				target = track-&gt;styles + sid;
-				if (0) {
-					STRVAL(FontName)
-					COLORVAL(PrimaryColour)
-					COLORVAL(SecondaryColour)
-					COLORVAL(OutlineColour)
-					COLORVAL(BackColour)
-					FPVAL(FontSize)
-					INTVAL(Bold)
-					INTVAL(Italic)
-					INTVAL(Underline)
-					INTVAL(StrikeOut)
-					FPVAL(Spacing)
-					INTVAL(Angle)
-					INTVAL(BorderStyle)
-					INTVAL(Alignment)
-					INTVAL(MarginL)
-					INTVAL(MarginR)
-					INTVAL(MarginV)
-					INTVAL(Encoding)
-					FPVAL(ScaleX)
-					FPVAL(ScaleY)
-					FPVAL(Outline)
-					FPVAL(Shadow)
-				}
-			}
-		}
-		*eq = '=';
-		if (dt) *dt = '.';
-	}
+    if (!list)
+        return;
+
+    for (fs = list; *fs; ++fs) {
+        eq = strrchr(*fs, '=');
+        if (!eq)
+            continue;
+        *eq = '\0';
+        token = eq + 1;
+
+        if (!strcasecmp(*fs, &quot;PlayResX&quot;))
+            track-&gt;PlayResX = atoi(token);
+        else if (!strcasecmp(*fs, &quot;PlayResY&quot;))
+            track-&gt;PlayResY = atoi(token);
+        else if (!strcasecmp(*fs, &quot;Timer&quot;))
+            track-&gt;Timer = ass_atof(token);
+        else if (!strcasecmp(*fs, &quot;WrapStyle&quot;))
+            track-&gt;WrapStyle = atoi(token);
+        else if (!strcasecmp(*fs, &quot;ScaledBorderAndShadow&quot;))
+            track-&gt;ScaledBorderAndShadow = parse_bool(token);
+        else if (!strcasecmp(*fs, &quot;Kerning&quot;))
+            track-&gt;Kerning = parse_bool(token);
+
+        dt = strrchr(*fs, '.');
+        if (dt) {
+            *dt = '\0';
+            style = *fs;
+            tname = dt + 1;
+        } else {
+            style = NULL;
+            tname = *fs;
+        }
+        for (sid = 0; sid &lt; track-&gt;n_styles; ++sid) {
+            if (style == NULL
+                || strcasecmp(track-&gt;styles[sid].Name, style) == 0) {
+                target = track-&gt;styles + sid;
+                if (0) {
+                    STRVAL(FontName)
+                    COLORVAL(PrimaryColour)
+                    COLORVAL(SecondaryColour)
+                    COLORVAL(OutlineColour)
+                    COLORVAL(BackColour)
+                    FPVAL(FontSize)
+                    INTVAL(Bold)
+                    INTVAL(Italic)
+                    INTVAL(Underline)
+                    INTVAL(StrikeOut)
+                    FPVAL(Spacing)
+                    INTVAL(Angle)
+                    INTVAL(BorderStyle)
+                    INTVAL(Alignment)
+                    INTVAL(MarginL)
+                    INTVAL(MarginR)
+                    INTVAL(MarginV)
+                    INTVAL(Encoding)
+                    FPVAL(ScaleX)
+                    FPVAL(ScaleY)
+                    FPVAL(Outline)
+                    FPVAL(Shadow)
+                }
+            }
+        }
+        *eq = '=';
+        if (dt)
+            *dt = '.';
+    }
 }
 
 /**
@@ -385,481 +437,559 @@
  * \param track track
  * \param str string to parse, zero-terminated
  * Allocates a new style struct.
-*/ 
-static int process_style(ass_track_t* track, char *str)
+*/
+static int process_style(ASS_Track *track, char *str)
 {
 
-	char* token;
-	char* tname;
-	char* p = str;
-	char* format;
-	char* q; // format scanning pointer
-	int sid;
-	ass_style_t* style;
-	ass_style_t* target;
+    char *token;
+    char *tname;
+    char *p = str;
+    char *format;
+    char *q;                    // format scanning pointer
+    int sid;
+    ASS_Style *style;
+    ASS_Style *target;
 
-	if (!track-&gt;style_format) {
-		// no style format header
-		// probably an ancient script version
-		if (track-&gt;track_type == TRACK_TYPE_SSA)
-			track-&gt;style_format = strdup(&quot;Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,&quot;
-					&quot;TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline,&quot;
-					&quot;Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding&quot;);
-		else
-			track-&gt;style_format = strdup(&quot;Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,&quot;
-					&quot;OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut,&quot;
-					&quot;ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow,&quot;
-					&quot;Alignment, MarginL, MarginR, MarginV, Encoding&quot;);
-	}
+    if (!track-&gt;style_format) {
+        // no style format header
+        // probably an ancient script version
+        if (track-&gt;track_type == TRACK_TYPE_SSA)
+            track-&gt;style_format =
+                strdup
+                (&quot;Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,&quot;
+                 &quot;TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline,&quot;
+                 &quot;Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding&quot;);
+        else
+            track-&gt;style_format =
+                strdup
+                (&quot;Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,&quot;
+                 &quot;OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut,&quot;
+                 &quot;ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow,&quot;
+                 &quot;Alignment, MarginL, MarginR, MarginV, Encoding&quot;);
+    }
 
-	q = format = strdup(track-&gt;style_format);
-	
-	mp_msg(MSGT_ASS, MSGL_V, &quot;[%p] Style: %s\n&quot;, track, str);
-	
-	sid = ass_alloc_style(track);
+    q = format = strdup(track-&gt;style_format);
 
-	style = track-&gt;styles + sid;
-	target = style;
-// fill style with some default values
-	style-&gt;ScaleX = 100.;
-	style-&gt;ScaleY = 100.;
-	
-	while (1) {
-		NEXT(q, tname);
-		NEXT(p, token);
-		
-//		ALIAS(TertiaryColour,OutlineColour) // ignore TertiaryColour; it appears only in SSA, and is overridden by BackColour
-			
-		if (0) { // cool ;)
-			STRVAL(Name)
-				if ((strcmp(target-&gt;Name, &quot;Default&quot;)==0) || (strcmp(target-&gt;Name, &quot;*Default&quot;)==0))
-					track-&gt;default_style = sid;
-			STRVAL(FontName)
-			COLORVAL(PrimaryColour)
-			COLORVAL(SecondaryColour)
-			COLORVAL(OutlineColour) // TertiaryColor
-			COLORVAL(BackColour)
-				// SSA uses BackColour for both outline and shadow
-				// this will destroy SSA's TertiaryColour, but i'm not going to use it anyway
-				if (track-&gt;track_type == TRACK_TYPE_SSA)
-					target-&gt;OutlineColour = target-&gt;BackColour;
-			FPVAL(FontSize)
-			INTVAL(Bold)
-			INTVAL(Italic)
-			INTVAL(Underline)
-			INTVAL(StrikeOut)
-			FPVAL(Spacing)
-			INTVAL(Angle)
-			INTVAL(BorderStyle)
-			INTVAL(Alignment)
-				if (track-&gt;track_type == TRACK_TYPE_ASS)
-					target-&gt;Alignment = numpad2align(target-&gt;Alignment);
-			INTVAL(MarginL)
-			INTVAL(MarginR)
-			INTVAL(MarginV)
-			INTVAL(Encoding)
-			FPVAL(ScaleX)
-			FPVAL(ScaleY)
-			FPVAL(Outline)
-			FPVAL(Shadow)
-		}
-	}
-	style-&gt;ScaleX /= 100.;
-	style-&gt;ScaleY /= 100.;
-	style-&gt;Bold = !!style-&gt;Bold;
-	style-&gt;Italic = !!style-&gt;Italic;
-	style-&gt;Underline = !!style-&gt;Underline;
-	if (!style-&gt;Name)
-		style-&gt;Name = strdup(&quot;Default&quot;);
-	if (!style-&gt;FontName)
-		style-&gt;FontName = strdup(&quot;Arial&quot;);
-	free(format);
-	return 0;
-	
+    ass_msg(track-&gt;library, MSGL_V, &quot;[%p] Style: %s&quot;, track, str);
+
+    sid = ass_alloc_style(track);
+
+    style = track-&gt;styles + sid;
+    target = style;
+
+    // fill style with some default values
+    style-&gt;ScaleX = 100.;
+    style-&gt;ScaleY = 100.;
+
+    while (1) {
+        NEXT(q, tname);
+        NEXT(p, token);
+
+        if (0) {                // cool ;)
+            STRVAL(Name)
+            if ((strcmp(target-&gt;Name, &quot;Default&quot;) == 0)
+                || (strcmp(target-&gt;Name, &quot;*Default&quot;) == 0))
+            track-&gt;default_style = sid;
+            STRVAL(FontName)
+            COLORVAL(PrimaryColour)
+            COLORVAL(SecondaryColour)
+            COLORVAL(OutlineColour) // TertiaryColor
+            COLORVAL(BackColour)
+            // SSA uses BackColour for both outline and shadow
+            // this will destroy SSA's TertiaryColour, but i'm not going to use it anyway
+            if (track-&gt;track_type == TRACK_TYPE_SSA)
+                target-&gt;OutlineColour = target-&gt;BackColour;
+            FPVAL(FontSize)
+            INTVAL(Bold)
+            INTVAL(Italic)
+            INTVAL(Underline)
+            INTVAL(StrikeOut)
+            FPVAL(Spacing)
+            INTVAL(Angle)
+            INTVAL(BorderStyle)
+            INTVAL(Alignment)
+            if (track-&gt;track_type == TRACK_TYPE_ASS)
+                target-&gt;Alignment = numpad2align(target-&gt;Alignment);
+            INTVAL(MarginL)
+            INTVAL(MarginR)
+            INTVAL(MarginV)
+            INTVAL(Encoding)
+            FPVAL(ScaleX)
+            FPVAL(ScaleY)
+            FPVAL(Outline)
+            FPVAL(Shadow)
+        }
+    }
+    style-&gt;ScaleX /= 100.;
+    style-&gt;ScaleY /= 100.;
+    style-&gt;Bold = !!style-&gt;Bold;
+    style-&gt;Italic = !!style-&gt;Italic;
+    style-&gt;Underline = !!style-&gt;Underline;
+    if (!style-&gt;Name)
+        style-&gt;Name = strdup(&quot;Default&quot;);
+    if (!style-&gt;FontName)
+        style-&gt;FontName = strdup(&quot;Arial&quot;);
+    free(format);
+    return 0;
+
 }
 
-static int process_styles_line(ass_track_t* track, char *str)
+static int process_styles_line(ASS_Track *track, char *str)
 {
-	if (!strncmp(str,&quot;Format:&quot;, 7)) {
-		char* p = str + 7;
-		skip_spaces(&amp;p);
-		track-&gt;style_format = strdup(p);
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;Style format: %s\n&quot;, track-&gt;style_format);
-	} else if (!strncmp(str,&quot;Style:&quot;, 6)) {
-		char* p = str + 6;
-		skip_spaces(&amp;p);
-		process_style(track, p);
-	}
-	return 0;
+    if (!strncmp(str, &quot;Format:&quot;, 7)) {
+        char *p = str + 7;
+        skip_spaces(&amp;p);
+        track-&gt;style_format = strdup(p);
+        ass_msg(track-&gt;library, MSGL_DBG2, &quot;Style format: %s&quot;,
+               track-&gt;style_format);
+    } else if (!strncmp(str, &quot;Style:&quot;, 6)) {
+        char *p = str + 6;
+        skip_spaces(&amp;p);
+        process_style(track, p);
+    }
+    return 0;
 }
 
-static int process_info_line(ass_track_t* track, char *str)
+static int process_info_line(ASS_Track *track, char *str)
 {
-	if (!strncmp(str, &quot;PlayResX:&quot;, 9)) {
-		track-&gt;PlayResX = atoi(str + 9);
-	} else if (!strncmp(str,&quot;PlayResY:&quot;, 9)) {
-		track-&gt;PlayResY = atoi(str + 9);
-	} else if (!strncmp(str,&quot;Timer:&quot;, 6)) {
-		track-&gt;Timer = atof(str + 6);
-	} else if (!strncmp(str,&quot;WrapStyle:&quot;, 10)) {
-		track-&gt;WrapStyle = atoi(str + 10);
-	}
-	return 0;
+    if (!strncmp(str, &quot;PlayResX:&quot;, 9)) {
+        track-&gt;PlayResX = atoi(str + 9);
+    } else if (!strncmp(str, &quot;PlayResY:&quot;, 9)) {
+        track-&gt;PlayResY = atoi(str + 9);
+    } else if (!strncmp(str, &quot;Timer:&quot;, 6)) {
+        track-&gt;Timer = ass_atof(str + 6);
+    } else if (!strncmp(str, &quot;WrapStyle:&quot;, 10)) {
+        track-&gt;WrapStyle = atoi(str + 10);
+    } else if (!strncmp(str, &quot;ScaledBorderAndShadow:&quot;, 22)) {
+        track-&gt;ScaledBorderAndShadow = parse_bool(str + 22);
+    } else if (!strncmp(str, &quot;Kerning:&quot;, 8)) {
+        track-&gt;Kerning = parse_bool(str + 8);
+    }
+    return 0;
 }
 
-static int process_events_line(ass_track_t* track, char *str)
+static void event_format_fallback(ASS_Track *track)
 {
-	if (!strncmp(str, &quot;Format:&quot;, 7)) {
-		char* p = str + 7;
-		skip_spaces(&amp;p);
-		track-&gt;event_format = strdup(p);
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;Event format: %s\n&quot;, track-&gt;event_format);
-	} else if (!strncmp(str, &quot;Dialogue:&quot;, 9)) {
-		// This should never be reached for embedded subtitles.
-		// They have slightly different format and are parsed in ass_process_chunk,
-		// called directly from demuxer
-		int eid;
-		ass_event_t* event;
-		
-		str += 9;
-		skip_spaces(&amp;str);
+    track-&gt;parser_priv-&gt;state = PST_EVENTS;
+    if (track-&gt;track_type == TRACK_TYPE_SSA)
+        track-&gt;event_format = strdup(&quot;Format: Marked, Start, End, Style, &quot;
+            &quot;Name, MarginL, MarginR, MarginV, Effect, Text&quot;);
+    else
+        track-&gt;event_format = strdup(&quot;Format: Layer, Start, End, Style, &quot;
+            &quot;Actor, MarginL, MarginR, MarginV, Effect, Text&quot;);
+    ass_msg(track-&gt;library, MSGL_V,
+            &quot;No event format found, using fallback&quot;);
+}
 
-		eid = ass_alloc_event(track);
-		event = track-&gt;events + eid;
+static int process_events_line(ASS_Track *track, char *str)
+{
+    if (!strncmp(str, &quot;Format:&quot;, 7)) {
+        char *p = str + 7;
+        skip_spaces(&amp;p);
+        free(track-&gt;event_format);
+        track-&gt;event_format = strdup(p);
+        ass_msg(track-&gt;library, MSGL_DBG2, &quot;Event format: %s&quot;, track-&gt;event_format);
+    } else if (!strncmp(str, &quot;Dialogue:&quot;, 9)) {
+        // This should never be reached for embedded subtitles.
+        // They have slightly different format and are parsed in ass_process_chunk,
+        // called directly from demuxer
+        int eid;
+        ASS_Event *event;
 
-		process_event_tail(track, event, str, 0);
-	} else {
-		mp_msg(MSGT_ASS, MSGL_V, &quot;Not understood: %s  \n&quot;, str);
-	}
-	return 0;
+        str += 9;
+        skip_spaces(&amp;str);
+
+        eid = ass_alloc_event(track);
+        event = track-&gt;events + eid;
+
+        // We can't parse events with event_format
+        if (!track-&gt;event_format)
+            event_format_fallback(track);
+
+        process_event_tail(track, event, str, 0);
+    } else {
+        ass_msg(track-&gt;library, MSGL_V, &quot;Not understood: '%.30s'&quot;, str);
+    }
+    return 0;
 }
 
 // Copied from mkvtoolnix
-static unsigned char* decode_chars(unsigned char c1, unsigned char c2,
-		unsigned char c3, unsigned char c4, unsigned char* dst, int cnt)
+static unsigned char *decode_chars(unsigned char c1, unsigned char c2,
+                                   unsigned char c3, unsigned char c4,
+                                   unsigned char *dst, int cnt)
 {
-	uint32_t value;
-	unsigned char bytes[3];
-	int i;
+    uint32_t value;
+    unsigned char bytes[3];
+    int i;
 
-	value = ((c1 - 33) &lt;&lt; 18) + ((c2 - 33) &lt;&lt; 12) + ((c3 - 33) &lt;&lt; 6) + (c4 - 33);
-	bytes[2] = value &amp; 0xff;
-	bytes[1] = (value &amp; 0xff00) &gt;&gt; 8;
-	bytes[0] = (value &amp; 0xff0000) &gt;&gt; 16;
+    value =
+        ((c1 - 33) &lt;&lt; 18) + ((c2 - 33) &lt;&lt; 12) + ((c3 - 33) &lt;&lt; 6) + (c4 -
+                                                                    33);
+    bytes[2] = value &amp; 0xff;
+    bytes[1] = (value &amp; 0xff00) &gt;&gt; 8;
+    bytes[0] = (value &amp; 0xff0000) &gt;&gt; 16;
 
-	for (i = 0; i &lt; cnt; ++i)
-		*dst++ = bytes[i];
-	return dst;
+    for (i = 0; i &lt; cnt; ++i)
+        *dst++ = bytes[i];
+    return dst;
 }
 
-static int decode_font(ass_track_t* track)
+static int decode_font(ASS_Track *track)
 {
-	unsigned char* p;
-	unsigned char* q;
-	int i;
-	int size; // original size
-	int dsize; // decoded size
-	unsigned char* buf = 0;
+    unsigned char *p;
+    unsigned char *q;
+    int i;
+    int size;                   // original size
+    int dsize;                  // decoded size
+    unsigned char *buf = 0;
 
-	mp_msg(MSGT_ASS, MSGL_V, &quot;font: %d bytes encoded data \n&quot;, track-&gt;parser_priv-&gt;fontdata_used);
-	size = track-&gt;parser_priv-&gt;fontdata_used;
-	if (size % 4 == 1) {
-		mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_BadEncodedDataSize);
-		goto error_decode_font;
-	}
-	buf = malloc(size / 4 * 3 + 2);
-	q = buf;
-	for (i = 0, p = (unsigned char*)track-&gt;parser_priv-&gt;fontdata; i &lt; size / 4; i++, p+=4) {
-		q = decode_chars(p[0], p[1], p[2], p[3], q, 3);
-	}
-	if (size % 4 == 2) {
-		q = decode_chars(p[0], p[1], 0, 0, q, 1);
-	} else if (size % 4 == 3) {
-		q = decode_chars(p[0], p[1], p[2], 0, q, 2);
-	}
-	dsize = q - buf;
-	assert(dsize &lt;= size / 4 * 3 + 2);
-	
-	if (track-&gt;library-&gt;extract_fonts) {
-		ass_add_font(track-&gt;library, track-&gt;parser_priv-&gt;fontname, (char*)buf, dsize);
-		buf = 0;
-	}
+    ass_msg(track-&gt;library, MSGL_V, &quot;Font: %d bytes encoded data&quot;,
+            track-&gt;parser_priv-&gt;fontdata_used);
+    size = track-&gt;parser_priv-&gt;fontdata_used;
+    if (size % 4 == 1) {
+        ass_msg(track-&gt;library, MSGL_ERR, &quot;Bad encoded data size&quot;);
+        goto error_decode_font;
+    }
+    buf = malloc(size / 4 * 3 + 2);
+    q = buf;
+    for (i = 0, p = (unsigned char *) track-&gt;parser_priv-&gt;fontdata;
+         i &lt; size / 4; i++, p += 4) {
+        q = decode_chars(p[0], p[1], p[2], p[3], q, 3);
+    }
+    if (size % 4 == 2) {
+        q = decode_chars(p[0], p[1], 0, 0, q, 1);
+    } else if (size % 4 == 3) {
+        q = decode_chars(p[0], p[1], p[2], 0, q, 2);
+    }
+    dsize = q - buf;
+    assert(dsize &lt;= size / 4 * 3 + 2);
 
+    if (track-&gt;library-&gt;extract_fonts) {
+        ass_add_font(track-&gt;library, track-&gt;parser_priv-&gt;fontname,
+                     (char *) buf, dsize);
+    }
+
 error_decode_font:
-	if (buf) free(buf);
-	free(track-&gt;parser_priv-&gt;fontname);
-	free(track-&gt;parser_priv-&gt;fontdata);
-	track-&gt;parser_priv-&gt;fontname = 0;
-	track-&gt;parser_priv-&gt;fontdata = 0;
-	track-&gt;parser_priv-&gt;fontdata_size = 0;
-	track-&gt;parser_priv-&gt;fontdata_used = 0;
-	return 0;
+    free(buf);
+    free(track-&gt;parser_priv-&gt;fontname);
+    free(track-&gt;parser_priv-&gt;fontdata);
+    track-&gt;parser_priv-&gt;fontname = 0;
+    track-&gt;parser_priv-&gt;fontdata = 0;
+    track-&gt;parser_priv-&gt;fontdata_size = 0;
+    track-&gt;parser_priv-&gt;fontdata_used = 0;
+    return 0;
 }
 
-static int process_fonts_line(ass_track_t* track, char *str)
+static int process_fonts_line(ASS_Track *track, char *str)
 {
-	int len;
+    int len;
 
-	if (!strncmp(str, &quot;fontname:&quot;, 9)) {
-		char* p = str + 9;
-		skip_spaces(&amp;p);
-		if (track-&gt;parser_priv-&gt;fontname) {
-			decode_font(track);
-		}
-		track-&gt;parser_priv-&gt;fontname = strdup(p);
-		mp_msg(MSGT_ASS, MSGL_V, &quot;fontname: %s\n&quot;, track-&gt;parser_priv-&gt;fontname);
-		return 0;
-	}
-	
-	if (!track-&gt;parser_priv-&gt;fontname) {
-		mp_msg(MSGT_ASS, MSGL_V, &quot;Not understood: %s  \n&quot;, str);
-		return 0;
-	}
+    if (!strncmp(str, &quot;fontname:&quot;, 9)) {
+        char *p = str + 9;
+        skip_spaces(&amp;p);
+        if (track-&gt;parser_priv-&gt;fontname) {
+            decode_font(track);
+        }
+        track-&gt;parser_priv-&gt;fontname = strdup(p);
+        ass_msg(track-&gt;library, MSGL_V, &quot;Fontname: %s&quot;,
+               track-&gt;parser_priv-&gt;fontname);
+        return 0;
+    }
 
-	len = strlen(str);
-	if (len &gt; 80) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FontLineTooLong, len, str);
-		return 0;
-	}
-	if (track-&gt;parser_priv-&gt;fontdata_used + len &gt; track-&gt;parser_priv-&gt;fontdata_size) {
-		track-&gt;parser_priv-&gt;fontdata_size += 100 * 1024;
-		track-&gt;parser_priv-&gt;fontdata = realloc(track-&gt;parser_priv-&gt;fontdata, track-&gt;parser_priv-&gt;fontdata_size);
-	}
-	memcpy(track-&gt;parser_priv-&gt;fontdata + track-&gt;parser_priv-&gt;fontdata_used, str, len);
-	track-&gt;parser_priv-&gt;fontdata_used += len;
-	
-	return 0;
+    if (!track-&gt;parser_priv-&gt;fontname) {
+        ass_msg(track-&gt;library, MSGL_V, &quot;Not understood: '%s'&quot;, str);
+        return 0;
+    }
+
+    len = strlen(str);
+    if (len &gt; 80) {
+        ass_msg(track-&gt;library, MSGL_WARN, &quot;Font line too long: %d, %s&quot;,
+                len, str);
+        return 0;
+    }
+    if (track-&gt;parser_priv-&gt;fontdata_used + len &gt;
+        track-&gt;parser_priv-&gt;fontdata_size) {
+        track-&gt;parser_priv-&gt;fontdata_size += 100 * 1024;
+        track-&gt;parser_priv-&gt;fontdata =
+            realloc(track-&gt;parser_priv-&gt;fontdata,
+                    track-&gt;parser_priv-&gt;fontdata_size);
+    }
+    memcpy(track-&gt;parser_priv-&gt;fontdata + track-&gt;parser_priv-&gt;fontdata_used,
+           str, len);
+    track-&gt;parser_priv-&gt;fontdata_used += len;
+
+    return 0;
 }
 
 /**
  * \brief Parse a header line
  * \param track track
  * \param str string to parse, zero-terminated
-*/ 
-static int process_line(ass_track_t* track, char *str)
+*/
+static int process_line(ASS_Track *track, char *str)
 {
-	if (strstr(str, &quot;[Script Info]&quot;)) { // FIXME: strstr to skip possible BOM at the beginning of the script
-		track-&gt;parser_priv-&gt;state = PST_INFO;
-	} else if (!strncmp(str, &quot;[V4 Styles]&quot;, 11)) {
-		track-&gt;parser_priv-&gt;state = PST_STYLES;
-		track-&gt;track_type = TRACK_TYPE_SSA;
-	} else if (!strncmp(str, &quot;[V4+ Styles]&quot;, 12)) {
-		track-&gt;parser_priv-&gt;state = PST_STYLES;
-		track-&gt;track_type = TRACK_TYPE_ASS;
-	} else if (!strncmp(str, &quot;[Events]&quot;, 8)) {
-		track-&gt;parser_priv-&gt;state = PST_EVENTS;
-	} else if (!strncmp(str, &quot;[Fonts]&quot;, 7)) {
-		track-&gt;parser_priv-&gt;state = PST_FONTS;
-	} else {
-		switch (track-&gt;parser_priv-&gt;state) {
-		case PST_INFO:
-			process_info_line(track, str);
-			break;
-		case PST_STYLES:
-			process_styles_line(track, str);
-			break;
-		case PST_EVENTS:
-			process_events_line(track, str);
-			break;
-		case PST_FONTS:
-			process_fonts_line(track, str);
-			break;
-		default:
-			break;
-		}
-	}
+    if (!strncasecmp(str, &quot;[Script Info]&quot;, 13)) {
+        track-&gt;parser_priv-&gt;state = PST_INFO;
+    } else if (!strncasecmp(str, &quot;[V4 Styles]&quot;, 11)) {
+        track-&gt;parser_priv-&gt;state = PST_STYLES;
+        track-&gt;track_type = TRACK_TYPE_SSA;
+    } else if (!strncasecmp(str, &quot;[V4+ Styles]&quot;, 12)) {
+        track-&gt;parser_priv-&gt;state = PST_STYLES;
+        track-&gt;track_type = TRACK_TYPE_ASS;
+    } else if (!strncasecmp(str, &quot;[Events]&quot;, 8)) {
+        track-&gt;parser_priv-&gt;state = PST_EVENTS;
+    } else if (!strncasecmp(str, &quot;[Fonts]&quot;, 7)) {
+        track-&gt;parser_priv-&gt;state = PST_FONTS;
+    } else {
+        switch (track-&gt;parser_priv-&gt;state) {
+        case PST_INFO:
+            process_info_line(track, str);
+            break;
+        case PST_STYLES:
+            process_styles_line(track, str);
+            break;
+        case PST_EVENTS:
+            process_events_line(track, str);
+            break;
+        case PST_FONTS:
+            process_fonts_line(track, str);
+            break;
+        default:
+            break;
+        }
+    }
 
-	// there is no explicit end-of-font marker in ssa/ass
-	if ((track-&gt;parser_priv-&gt;state != PST_FONTS) &amp;&amp; (track-&gt;parser_priv-&gt;fontname))
-		decode_font(track);
+    // there is no explicit end-of-font marker in ssa/ass
+    if ((track-&gt;parser_priv-&gt;state != PST_FONTS)
+        &amp;&amp; (track-&gt;parser_priv-&gt;fontname))
+        decode_font(track);
 
-	return 0;
+    return 0;
 }
 
-static int process_text(ass_track_t* track, char* str)
+static int process_text(ASS_Track *track, char *str)
 {
-	char* p = str;
-	while(1) {
-		char* q;
-		for (;((*p=='\r')||(*p=='\n'));++p) {}
-		for (q=p; ((*q!='\0')&amp;&amp;(*q!='\r')&amp;&amp;(*q!='\n')); ++q) {};
-		if (q==p)
-			break;
-		if (*q != '\0')
-			*(q++) = '\0';
-		process_line(track, p);
-		if (*q == '\0')
-			break;
-		p = q;
-	}
-	return 0;
+    char *p = str;
+    while (1) {
+        char *q;
+        while (1) {
+            if ((*p == '\r') || (*p == '\n'))
+                ++p;
+            else if (p[0] == '\xef' &amp;&amp; p[1] == '\xbb' &amp;&amp; p[2] == '\xbf')
+                p += 3;         // U+FFFE (BOM)
+            else
+                break;
+        }
+        for (q = p; ((*q != '\0') &amp;&amp; (*q != '\r') &amp;&amp; (*q != '\n')); ++q) {
+        };
+        if (q == p)
+            break;
+        if (*q != '\0')
+            *(q++) = '\0';
+        process_line(track, p);
+        if (*q == '\0')
+            break;
+        p = q;
+    }
+    return 0;
 }
 
 /**
+ * \brief Process a chunk of subtitle stream data.
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+*/
+void ass_process_data(ASS_Track *track, char *data, int size)
+{
+    char *str = malloc(size + 1);
+
+    memcpy(str, data, size);
+    str[size] = '\0';
+
+    ass_msg(track-&gt;library, MSGL_V, &quot;Event: %s&quot;, str);
+    process_text(track, str);
+    free(str);
+}
+
+/**
  * \brief Process CodecPrivate section of subtitle stream
  * \param track track
  * \param data string to parse
  * \param size length of data
  CodecPrivate section contains [Stream Info] and [V4+ Styles] ([V4 Styles] for SSA) sections
-*/ 
-void ass_process_codec_private(ass_track_t* track, char *data, int size)
+*/
+void ass_process_codec_private(ASS_Track *track, char *data, int size)
 {
-	char* str = malloc(size + 1);
+    ass_process_data(track, data, size);
 
-	memcpy(str, data, size);
-	str[size] = '\0';
+    // probably an mkv produced by ancient mkvtoolnix
+    // such files don't have [Events] and Format: headers
+    if (!track-&gt;event_format)
+        event_format_fallback(track);
 
-	process_text(track, str);
-	free(str);
-
-	if (!track-&gt;event_format) {
-		// probably an mkv produced by ancient mkvtoolnix
-		// such files don't have [Events] and Format: headers
-		track-&gt;parser_priv-&gt;state = PST_EVENTS;
-		if (track-&gt;track_type == TRACK_TYPE_SSA)
-			track-&gt;event_format = strdup(&quot;Format: Marked, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text&quot;);
-		else
-			track-&gt;event_format = strdup(&quot;Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text&quot;);
-	}
-
-	process_force_style(track);
+    ass_process_force_style(track);
 }
 
-static int check_duplicate_event(ass_track_t* track, int ReadOrder)
+static int check_duplicate_event(ASS_Track *track, int ReadOrder)
 {
-	int i;
-	for (i = 0; i&lt;track-&gt;n_events - 1; ++i) // ignoring last event, it is the one we are comparing with
-		if (track-&gt;events[i].ReadOrder == ReadOrder)
-			return 1;
-	return 0;
+    int i;
+    for (i = 0; i &lt; track-&gt;n_events - 1; ++i)   // ignoring last event, it is the one we are comparing with
+        if (track-&gt;events[i].ReadOrder == ReadOrder)
+            return 1;
+    return 0;
 }
 
 /**
- * \brief Process a chunk of subtitle stream data. In matroska, this containes exactly 1 event (or a commentary)
+ * \brief Process a chunk of subtitle stream data. In Matroska, this contains exactly 1 event (or a commentary).
  * \param track track
  * \param data string to parse
  * \param size length of data
  * \param timecode starting time of the event (milliseconds)
  * \param duration duration of the event (milliseconds)
-*/ 
-void ass_process_chunk(ass_track_t* track, char *data, int size, long long timecode, long long duration)
+*/
+void ass_process_chunk(ASS_Track *track, char *data, int size,
+                       long long timecode, long long duration)
 {
-	char* str;
-	int eid;
-	char* p;
-	char* token;
-	ass_event_t* event;
+    char *str;
+    int eid;
+    char *p;
+    char *token;
+    ASS_Event *event;
 
-	if (!track-&gt;event_format) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EventFormatHeaderMissing);
-		return;
-	}
-	
-	str = malloc(size + 1);
-	memcpy(str, data, size);
-	str[size] = '\0';
-	mp_msg(MSGT_ASS, MSGL_V, &quot;event at %&quot; PRId64 &quot;, +%&quot; PRId64 &quot;: %s  \n&quot;, (int64_t)timecode, (int64_t)duration, str);
+    if (!track-&gt;event_format) {
+        ass_msg(track-&gt;library, MSGL_WARN, &quot;Event format header missing&quot;);
+        return;
+    }
 
-	eid = ass_alloc_event(track);
-	event = track-&gt;events + eid;
+    str = malloc(size + 1);
+    memcpy(str, data, size);
+    str[size] = '\0';
+    ass_msg(track-&gt;library, MSGL_V, &quot;Event at %&quot; PRId64 &quot;, +%&quot; PRId64 &quot;: %s&quot;,
+           (int64_t) timecode, (int64_t) duration, str);
 
-	p = str;
-	
-	do { 
-		NEXT(p, token);
-		event-&gt;ReadOrder = atoi(token);
-		if (check_duplicate_event(track, event-&gt;ReadOrder))
-			break;
+    eid = ass_alloc_event(track);
+    event = track-&gt;events + eid;
 
-		NEXT(p, token);
-		event-&gt;Layer = atoi(token);
+    p = str;
 
-		process_event_tail(track, event, p, 3);
+    do {
+        NEXT(p, token);
+        event-&gt;ReadOrder = atoi(token);
+        if (check_duplicate_event(track, event-&gt;ReadOrder))
+            break;
 
-		event-&gt;Start = timecode;
-		event-&gt;Duration = duration;
-		
-		free(str);
-		return;
-//		dump_events(tid);
-	} while (0);
-	// some error
-	ass_free_event(track, eid);
-	track-&gt;n_events--;
-	free(str);
+        NEXT(p, token);
+        event-&gt;Layer = atoi(token);
+
+        process_event_tail(track, event, p, 3);
+
+        event-&gt;Start = timecode;
+        event-&gt;Duration = duration;
+
+        free(str);
+        return;
+//              dump_events(tid);
+    } while (0);
+    // some error
+    ass_free_event(track, eid);
+    track-&gt;n_events--;
+    free(str);
 }
 
-#ifdef USE_ICONV
+/**
+ * \brief Flush buffered events.
+ * \param track track
+*/
+void ass_flush_events(ASS_Track *track)
+{
+    if (track-&gt;events) {
+        int eid;
+        for (eid = 0; eid &lt; track-&gt;n_events; eid++)
+            ass_free_event(track, eid);
+        track-&gt;n_events = 0;
+    }
+}
+
+#ifdef CONFIG_ICONV
 /** \brief recode buffer to utf-8
  * constraint: codepage != 0
  * \param data pointer to text buffer
  * \param size buffer size
  * \return a pointer to recoded buffer, caller is responsible for freeing it
 **/
-static char* sub_recode(char* data, size_t size, char* codepage)
+static char *sub_recode(ASS_Library *library, char *data, size_t size,
+                        char *codepage)
 {
-	static iconv_t icdsc = (iconv_t)(-1);
-	char* tocp = &quot;UTF-8&quot;;
-	char* outbuf;
-	assert(codepage);
+    iconv_t icdsc;
+    char *tocp = &quot;UTF-8&quot;;
+    char *outbuf;
+    assert(codepage);
 
-	{
-		char* cp_tmp = codepage ? strdup(codepage) : 0;
-#ifdef HAVE_ENCA
-		char enca_lang[3], enca_fallback[100];
-		if (sscanf(codepage, &quot;enca:%2s:%99s&quot;, enca_lang, enca_fallback) == 2
-				|| sscanf(codepage, &quot;ENCA:%2s:%99s&quot;, enca_lang, enca_fallback) == 2) {
-			cp_tmp = guess_buffer_cp((unsigned char*)data, size, enca_lang, enca_fallback);
-		}
+    {
+        const char *cp_tmp = codepage;
+#ifdef CONFIG_ENCA
+        char enca_lang[3], enca_fallback[100];
+        if (sscanf(codepage, &quot;enca:%2s:%99s&quot;, enca_lang, enca_fallback) == 2
+            || sscanf(codepage, &quot;ENCA:%2s:%99s&quot;, enca_lang,
+                      enca_fallback) == 2) {
+            cp_tmp =
+                ass_guess_buffer_cp(library, (unsigned char *) data, size,
+                                    enca_lang, enca_fallback);
+        }
 #endif
-		if ((icdsc = iconv_open (tocp, cp_tmp)) != (iconv_t)(-1)){
-			mp_msg(MSGT_ASS,MSGL_V,&quot;LIBSUB: opened iconv descriptor.\n&quot;);
-		} else
-			mp_msg(MSGT_ASS,MSGL_ERR,MSGTR_LIBASS_ErrorOpeningIconvDescriptor);
-#ifdef HAVE_ENCA
-		if (cp_tmp) free(cp_tmp);
-#endif
-	}
+        if ((icdsc = iconv_open(tocp, cp_tmp)) != (iconv_t) (-1)) {
+            ass_msg(library, MSGL_V, &quot;Opened iconv descriptor&quot;);
+        } else
+            ass_msg(library, MSGL_ERR, &quot;Error opening iconv descriptor&quot;);
+    }
 
-	{
-		size_t osize = size;
-		size_t ileft = size;
-		size_t oleft = size - 1;
-		char* ip;
-		char* op;
-		size_t rc;
-		
-		outbuf = malloc(size);
-		ip = data;
-		op = outbuf;
-		
-		while (ileft) {
-			rc = iconv(icdsc, &amp;ip, &amp;ileft, &amp;op, &amp;oleft);
-			if (rc == (size_t)(-1)) {
-				if (errno == E2BIG) {
-					int offset = op - outbuf;
-					outbuf = (char*)realloc(outbuf, osize + size);
-					op = outbuf + offset;
-					osize += size;
-					oleft += size;
-				} else {
-					mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorRecodingFile);
-					return NULL;
-				}
-			}
-		}
-		outbuf[osize - oleft - 1] = 0;
-	}
+    {
+        size_t osize = size;
+        size_t ileft = size;
+        size_t oleft = size - 1;
+        char *ip;
+        char *op;
+        size_t rc;
+        int clear = 0;
 
-	if (icdsc != (iconv_t)(-1)) {
-		(void)iconv_close(icdsc);
-		icdsc = (iconv_t)(-1);
-		mp_msg(MSGT_ASS,MSGL_V,&quot;LIBSUB: closed iconv descriptor.\n&quot;);
-	}
-	
-	return outbuf;
+        outbuf = malloc(osize);
+        ip = data;
+        op = outbuf;
+
+        while (1) {
+            if (ileft)
+                rc = iconv(icdsc, &amp;ip, &amp;ileft, &amp;op, &amp;oleft);
+            else {              // clear the conversion state and leave
+                clear = 1;
+                rc = iconv(icdsc, NULL, NULL, &amp;op, &amp;oleft);
+            }
+            if (rc == (size_t) (-1)) {
+                if (errno == E2BIG) {
+                    size_t offset = op - outbuf;
+                    outbuf = (char *) realloc(outbuf, osize + size);
+                    op = outbuf + offset;
+                    osize += size;
+                    oleft += size;
+                } else {
+                    ass_msg(library, MSGL_WARN, &quot;Error recoding file&quot;);
+                    return NULL;
+                }
+            } else if (clear)
+                break;
+        }
+        outbuf[osize - oleft - 1] = 0;
+    }
+
+    if (icdsc != (iconv_t) (-1)) {
+        (void) iconv_close(icdsc);
+        icdsc = (iconv_t) (-1);
+        ass_msg(library, MSGL_V, &quot;Closed iconv descriptor&quot;);
+    }
+
+    return outbuf;
 }
-#endif // ICONV
+#endif                          // ICONV
 
 /**
  * \brief read file contents into newly allocated buffer
@@ -867,86 +997,83 @@
  * \param bufsize out: file size
  * \return pointer to file contents. Caller is responsible for its deallocation.
  */
-static char* read_file(char* fname, size_t *bufsize)
+static char *read_file(ASS_Library *library, char *fname, size_t *bufsize)
 {
-	int res;
-	long sz;
-	long bytes_read;
-	char* buf;
+    int res;
+    long sz;
+    long bytes_read;
+    char *buf;
 
-	FILE* fp = fopen(fname, &quot;rb&quot;);
-	if (!fp) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FopenFailed, fname);
-		return 0;
-	}
-	res = fseek(fp, 0, SEEK_END);
-	if (res == -1) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FseekFailed, fname);
-		fclose(fp);
-		return 0;
-	}
-	
-	sz = ftell(fp);
-	rewind(fp);
+    FILE *fp = fopen(fname, &quot;rb&quot;);
+    if (!fp) {
+        ass_msg(library, MSGL_WARN,
+                &quot;ass_read_file(%s): fopen failed&quot;, fname);
+        return 0;
+    }
+    res = fseek(fp, 0, SEEK_END);
+    if (res == -1) {
+        ass_msg(library, MSGL_WARN,
+                &quot;ass_read_file(%s): fseek failed&quot;, fname);
+        fclose(fp);
+        return 0;
+    }
 
-	if (sz &gt; 10*1024*1024) {
-		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_RefusingToLoadSubtitlesLargerThan10M, fname);
-		fclose(fp);
-		return 0;
-	}
-	
-	mp_msg(MSGT_ASS, MSGL_V, &quot;file size: %ld\n&quot;, sz);
-	
-	buf = malloc(sz + 1);
-	assert(buf);
-	bytes_read = 0;
-	do {
-		res = fread(buf + bytes_read, 1, sz - bytes_read, fp);
-		if (res &lt;= 0) {
-			mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_ReadFailed, errno, strerror(errno));
-			fclose(fp);
-			free(buf);
-			return 0;
-		}
-		bytes_read += res;
-	} while (sz - bytes_read &gt; 0);
-	buf[sz] = '\0';
-	fclose(fp);
-	
-	if (bufsize)
-		*bufsize = sz;
-	return buf;
+    sz = ftell(fp);
+    rewind(fp);
+
+    ass_msg(library, MSGL_V, &quot;File size: %ld&quot;, sz);
+
+    buf = malloc(sz + 1);
+    assert(buf);
+    bytes_read = 0;
+    do {
+        res = fread(buf + bytes_read, 1, sz - bytes_read, fp);
+        if (res &lt;= 0) {
+            ass_msg(library, MSGL_INFO, &quot;Read failed, %d: %s&quot;, errno,
+                    strerror(errno));
+            fclose(fp);
+            free(buf);
+            return 0;
+        }
+        bytes_read += res;
+    } while (sz - bytes_read &gt; 0);
+    buf[sz] = '\0';
+    fclose(fp);
+
+    if (bufsize)
+        *bufsize = sz;
+    return buf;
 }
 
 /*
  * \param buf pointer to subtitle text in utf-8
  */
-static ass_track_t* parse_memory(ass_library_t* library, char* buf)
+static ASS_Track *parse_memory(ASS_Library *library, char *buf)
 {
-	ass_track_t* track;
-	int i;
-	
-	track = ass_new_track(library);
-	
-	// process header
-	process_text(track, buf);
+    ASS_Track *track;
+    int i;
 
-	// external SSA/ASS subs does not have ReadOrder field
-	for (i = 0; i &lt; track-&gt;n_events; ++i)
-		track-&gt;events[i].ReadOrder = i;
+    track = ass_new_track(library);
 
-	// there is no explicit end-of-font marker in ssa/ass
-	if (track-&gt;parser_priv-&gt;fontname)
-		decode_font(track);
+    // process header
+    process_text(track, buf);
 
-	if (track-&gt;track_type == TRACK_TYPE_UNKNOWN) {
-		ass_free_track(track);
-		return 0;
-	}
+    // external SSA/ASS subs does not have ReadOrder field
+    for (i = 0; i &lt; track-&gt;n_events; ++i)
+        track-&gt;events[i].ReadOrder = i;
 
-	process_force_style(track);
+    // there is no explicit end-of-font marker in ssa/ass
+    if (track-&gt;parser_priv-&gt;fontname)
+        decode_font(track);
 
-	return track;
+    if (track-&gt;track_type == TRACK_TYPE_UNKNOWN) {
+        ass_free_track(track);
+        return 0;
+    }
+
+    ass_process_force_style(track);
+
+    return track;
 }
 
 /**
@@ -956,52 +1083,57 @@
  * \param bufsize size of buffer
  * \param codepage recode buffer contents from given codepage
  * \return newly allocated track
-*/ 
-ass_track_t* ass_read_memory(ass_library_t* library, char* buf, size_t bufsize, char* codepage)
+*/
+ASS_Track *ass_read_memory(ASS_Library *library, char *buf,
+                           size_t bufsize, char *codepage)
 {
-	ass_track_t* track;
-	int need_free = 0;
-	
-	if (!buf)
-		return 0;
-	
-#ifdef USE_ICONV
-	if (codepage)
-		buf = sub_recode(buf, bufsize, codepage);
-	if (!buf)
-		return 0;
-	else
-		need_free = 1;
+    ASS_Track *track;
+    int need_free = 0;
+
+    if (!buf)
+        return 0;
+
+#ifdef CONFIG_ICONV
+    if (codepage) {
+        buf = sub_recode(library, buf, bufsize, codepage);
+        if (!buf)
+            return 0;
+        else
+            need_free = 1;
+    }
 #endif
-	track = parse_memory(library, buf);
-	if (need_free)
-		free(buf);
-	if (!track)
-		return 0;
+    track = parse_memory(library, buf);
+    if (need_free)
+        free(buf);
+    if (!track)
+        return 0;
 
-	mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_AddedSubtitleFileMemory, track-&gt;n_styles, track-&gt;n_events);
-	return track;
+    ass_msg(library, MSGL_INFO, &quot;Added subtitle file: &quot;
+            &quot;&lt;memory&gt; (%d styles, %d events)&quot;,
+            track-&gt;n_styles, track-&gt;n_events);
+    return track;
 }
 
-char* read_file_recode(char* fname, char* codepage, int* size)
+static char *read_file_recode(ASS_Library *library, char *fname,
+                              char *codepage, size_t *size)
 {
-	char* buf;
-	size_t bufsize;
-	
-	buf = read_file(fname, &amp;bufsize);
-	if (!buf)
-		return 0;
-#ifdef USE_ICONV
-	if (codepage) {
-		 char* tmpbuf = sub_recode(buf, bufsize, codepage);
-		 free(buf);
-		 buf = tmpbuf;
-	}
-	if (!buf)
-		return 0;
+    char *buf;
+    size_t bufsize;
+
+    buf = read_file(library, fname, &amp;bufsize);
+    if (!buf)
+        return 0;
+#ifdef CONFIG_ICONV
+    if (codepage) {
+        char *tmpbuf = sub_recode(library, buf, bufsize, codepage);
+        free(buf);
+        buf = tmpbuf;
+    }
+    if (!buf)
+        return 0;
 #endif
-	*size = bufsize;
-	return buf;
+    *size = bufsize;
+    return buf;
 }
 
 /**
@@ -1010,83 +1142,99 @@
  * \param fname file name
  * \param codepage recode buffer contents from given codepage
  * \return newly allocated track
-*/ 
-ass_track_t* ass_read_file(ass_library_t* library, char* fname, char* codepage)
+*/
+ASS_Track *ass_read_file(ASS_Library *library, char *fname,
+                         char *codepage)
 {
-	char* buf;
-	ass_track_t* track;
-	size_t bufsize;
+    char *buf;
+    ASS_Track *track;
+    size_t bufsize;
 
-	buf = read_file_recode(fname, codepage, &amp;bufsize);
-	if (!buf)
-		return 0;
-	track = parse_memory(library, buf);
-	free(buf);
-	if (!track)
-		return 0;
-	
-	track-&gt;name = strdup(fname);
+    buf = read_file_recode(library, fname, codepage, &amp;bufsize);
+    if (!buf)
+        return 0;
+    track = parse_memory(library, buf);
+    free(buf);
+    if (!track)
+        return 0;
 
-	mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_AddedSubtitleFileFname, fname, track-&gt;n_styles, track-&gt;n_events);
-	
-//	dump_events(forced_tid);
-	return track;
+    track-&gt;name = strdup(fname);
+
+    ass_msg(library, MSGL_INFO,
+            &quot;Added subtitle file: '%s' (%d styles, %d events)&quot;,
+            fname, track-&gt;n_styles, track-&gt;n_events);
+
+    return track;
 }
 
 /**
  * \brief read styles from file into already initialized track
  */
-int ass_read_styles(ass_track_t* track, char* fname, char* codepage)
+int ass_read_styles(ASS_Track *track, char *fname, char *codepage)
 {
-	char* buf;
-	parser_state_t old_state;
-	size_t sz;
+    char *buf;
+    ParserState old_state;
+    size_t sz;
 
-	buf = read_file(fname, &amp;sz);
-	if (!buf)
-		return 1;
-#ifdef USE_ICONV
-	if (codepage) {
-		char* tmpbuf;
-		tmpbuf = sub_recode(buf, sz, codepage);
-		free(buf);
-		buf = tmpbuf;
-	}
-	if (!buf)
-		return 0;
+    buf = read_file(track-&gt;library, fname, &amp;sz);
+    if (!buf)
+        return 1;
+#ifdef CONFIG_ICONV
+    if (codepage) {
+        char *tmpbuf;
+        tmpbuf = sub_recode(track-&gt;library, buf, sz, codepage);
+        free(buf);
+        buf = tmpbuf;
+    }
+    if (!buf)
+        return 0;
 #endif
 
-	old_state = track-&gt;parser_priv-&gt;state;
-	track-&gt;parser_priv-&gt;state = PST_STYLES;
-	process_text(track, buf);
-	track-&gt;parser_priv-&gt;state = old_state;
+    old_state = track-&gt;parser_priv-&gt;state;
+    track-&gt;parser_priv-&gt;state = PST_STYLES;
+    process_text(track, buf);
+    track-&gt;parser_priv-&gt;state = old_state;
 
-	return 0;
+    return 0;
 }
 
-long long ass_step_sub(ass_track_t* track, long long now, int movement) {
-	int i;
+long long ass_step_sub(ASS_Track *track, long long now, int movement)
+{
+    int i;
 
-	if (movement == 0) return 0;
-	if (track-&gt;n_events == 0) return 0;
-	
-	if (movement &lt; 0)
-		for (i = 0; (i &lt; track-&gt;n_events) &amp;&amp; ((long long)(track-&gt;events[i].Start + track-&gt;events[i].Duration) &lt;= now); ++i) {}
-	else
-		for (i = track-&gt;n_events - 1; (i &gt;= 0) &amp;&amp; ((long long)(track-&gt;events[i].Start) &gt; now); --i) {}
-	
-	// -1 and n_events are ok
-	assert(i &gt;= -1); assert(i &lt;= track-&gt;n_events);
-	i += movement;
-	if (i &lt; 0) i = 0;
-	if (i &gt;= track-&gt;n_events) i = track-&gt;n_events - 1;
-	return ((long long)track-&gt;events[i].Start) - now;
+    if (movement == 0)
+        return 0;
+    if (track-&gt;n_events == 0)
+        return 0;
+
+    if (movement &lt; 0)
+        for (i = 0;
+             (i &lt; track-&gt;n_events)
+             &amp;&amp;
+             ((long long) (track-&gt;events[i].Start +
+                           track-&gt;events[i].Duration) &lt;= now); ++i) {
+    } else
+        for (i = track-&gt;n_events - 1;
+             (i &gt;= 0) &amp;&amp; ((long long) (track-&gt;events[i].Start) &gt; now);
+             --i) {
+        }
+
+    // -1 and n_events are ok
+    assert(i &gt;= -1);
+    assert(i &lt;= track-&gt;n_events);
+    i += movement;
+    if (i &lt; 0)
+        i = 0;
+    if (i &gt;= track-&gt;n_events)
+        i = track-&gt;n_events - 1;
+    return ((long long) track-&gt;events[i].Start) - now;
 }
 
-ass_track_t* ass_new_track(ass_library_t* library) {
-	ass_track_t* track = calloc(1, sizeof(ass_track_t));
-	track-&gt;library = library;
-	track-&gt;parser_priv = calloc(1, sizeof(parser_priv_t));
-	return track;
+ASS_Track *ass_new_track(ASS_Library *library)
+{
+    ASS_Track *track = calloc(1, sizeof(ASS_Track));
+    track-&gt;library = library;
+    track-&gt;ScaledBorderAndShadow = 1;
+    track-&gt;parser_priv = calloc(1, sizeof(ASS_ParserPriv));
+    return track;
 }
-

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.h	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,209 +1,385 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#ifndef LIBASS_ASS_H
+#define LIBASS_ASS_H
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_H
-#define ASS_H
-
+#include &lt;stdio.h&gt;
+#include &lt;stdarg.h&gt;
 #include &quot;ass_types.h&quot;
 
-/// Libass renderer object. Contents are private.
-typedef struct ass_renderer_s ass_renderer_t;
+#define LIBASS_VERSION 0x00911000
 
-/// a linked list of images produced by ass renderer
-typedef struct ass_image_s {
-	int w, h; // bitmap width/height
-	int stride; // bitmap stride
-	unsigned char* bitmap; // 1bpp stride*h alpha buffer
-	uint32_t color; // RGBA
-	int dst_x, dst_y; // bitmap placement inside the video frame
+/*
+ * A linked list of images produced by an ass renderer.
+ *
+ * These images have to be rendered in-order for the correct screen
+ * composition.  The libass renderer clips these bitmaps to the frame size.
+ * w/h can be zero, in this case the bitmap should not be rendered at all.
+ * The last bitmap row is not guaranteed to be padded up to stride size,
+ * e.g. in the worst case a bitmap has the size stride * (h - 1) + w.
+ */
+typedef struct ass_image {
+    int w, h;                   // Bitmap width/height
+    int stride;                 // Bitmap stride
+    unsigned char *bitmap;      // 1bpp stride*h alpha buffer
+                                // Note: the last row may not be padded to
+                                // bitmap stride!
+    uint32_t color;             // Bitmap color and alpha, RGBA
+    int dst_x, dst_y;           // Bitmap placement inside the video frame
 
-	struct ass_image_s* next; // linked list
-} ass_image_t;
+    struct ass_image *next;   // Next image, or NULL
+} ASS_Image;
 
-/// Hinting type
-typedef enum {ASS_HINTING_NONE = 0,
-	      ASS_HINTING_LIGHT,
-	      ASS_HINTING_NORMAL,
-	      ASS_HINTING_NATIVE
-} ass_hinting_t;
+/*
+ * Hinting type. (see ass_set_hinting below)
+ *
+ * FreeType's native hinter is still buggy sometimes and it is recommended
+ * to use the light autohinter, ASS_HINTING_LIGHT, instead.  For best
+ * compatibility with problematic fonts, disable hinting.
+ */
+typedef enum {
+    ASS_HINTING_NONE = 0,
+    ASS_HINTING_LIGHT,
+    ASS_HINTING_NORMAL,
+    ASS_HINTING_NATIVE
+} ASS_Hinting;
 
 /**
- * \brief initialize the library
+ * \brief Initialize the library.
  * \return library handle or NULL if failed
  */
-ass_library_t* ass_library_init(void);
+ASS_Library *ass_library_init(void);
 
 /**
- * \brief finalize the library
+ * \brief Finalize the library
  * \param priv library handle
  */
-void ass_library_done(ass_library_t*);
+void ass_library_done(ASS_Library *priv);
 
 /**
- * \brief set private font directory
- * It is used for saving embedded fonts and also in font lookup.
+ * \brief Set additional fonts directory.
+ * Optional directory that will be scanned for fonts recursively.  The fonts
+ * found are used for font lookup.
+ * NOTE: A valid font directory is not needed to support embedded fonts.
+ *
+ * \param priv library handle
+ * \param fonts_dir directory with additional fonts
  */
-void ass_set_fonts_dir(ass_library_t* priv, const char* fonts_dir);
+void ass_set_fonts_dir(ASS_Library *priv, const char *fonts_dir);
 
-void ass_set_extract_fonts(ass_library_t* priv, int extract);
+/**
+ * \brief Whether fonts should be extracted from track data.
+ * \param priv library handle
+ * \param extract whether to extract fonts
+ */
+void ass_set_extract_fonts(ASS_Library *priv, int extract);
 
-void ass_set_style_overrides(ass_library_t* priv, char** list);
+/**
+ * \brief Register style overrides with a library instance.
+ * The overrides should have the form [Style.]Param=Value, e.g.
+ *   SomeStyle.Font=Arial
+ *   ScaledBorderAndShadow=yes
+ *
+ * \param priv library handle
+ * \param list NULL-terminated list of strings
+ */
+void ass_set_style_overrides(ASS_Library *priv, char **list);
 
 /**
- * \brief initialize the renderer
+ * \brief Explicitly process style overrides for a track.
+ * \param track track handle
+ */
+void ass_process_force_style(ASS_Track *track);
+
+/**
+ * \brief Register a callback for debug/info messages.
+ * If a callback is registered, it is called for every message emitted by
+ * libass.  The callback receives a format string and a list of arguments,
+ * to be used for the printf family of functions. Additionally, a log level
+ * from 0 (FATAL errors) to 7 (verbose DEBUG) is passed.  Usually, level 5
+ * should be used by applications.
+ * If no callback is set, all messages level &lt; 5 are printed to stderr,
+ * prefixed with [ass].
+ *
  * \param priv library handle
+ * \param msg_cb pointer to callback function
+ * \param data additional data, will be passed to callback
+ */
+void ass_set_message_cb(ASS_Library *priv, void (*msg_cb)
+                        (int level, const char *fmt, va_list args, void *data),
+                        void *data);
+
+/**
+ * \brief Initialize the renderer.
+ * \param priv library handle
  * \return renderer handle or NULL if failed
  */
-ass_renderer_t* ass_renderer_init(ass_library_t*);
+ASS_Renderer *ass_renderer_init(ASS_Library *);
 
 /**
- * \brief finalize the renderer
+ * \brief Finalize the renderer.
  * \param priv renderer handle
  */
-void ass_renderer_done(ass_renderer_t* priv);
+void ass_renderer_done(ASS_Renderer *priv);
 
-void ass_set_frame_size(ass_renderer_t* priv, int w, int h);
-void ass_set_margins(ass_renderer_t* priv, int t, int b, int l, int r);
-void ass_set_use_margins(ass_renderer_t* priv, int use);
-void ass_set_aspect_ratio(ass_renderer_t* priv, double ar);
-void ass_set_font_scale(ass_renderer_t* priv, double font_scale);
-void ass_set_hinting(ass_renderer_t* priv, ass_hinting_t ht);
-void ass_set_line_spacing(ass_renderer_t* priv, double line_spacing);
+/**
+ * \brief Set the frame size in pixels, including margins.
+ * \param priv renderer handle
+ * \param w width
+ * \param h height
+ */
+void ass_set_frame_size(ASS_Renderer *priv, int w, int h);
 
 /**
- * \brief set font lookup defaults
+ * \brief Set frame margins.  These values may be negative if pan-and-scan
+ * is used.
+ * \param priv renderer handle
+ * \param t top margin
+ * \param b bottom margin
+ * \param l left margin
+ * \param r right margin
  */
-int  ass_set_fonts(ass_renderer_t* priv, const char* default_font, const char* default_family);
+void ass_set_margins(ASS_Renderer *priv, int t, int b, int l, int r);
 
 /**
- * \brief render a frame, producing a list of ass_image_t
- * \param priv library
+ * \brief Whether margins should be used for placing regular events.
+ * \param priv renderer handle
+ * \param use whether to use the margins
+ */
+void ass_set_use_margins(ASS_Renderer *priv, int use);
+
+/**
+ * \brief Set aspect ratio parameters.
+ * \param priv renderer handle
+ * \param dar display aspect ratio (DAR), prescaled for output PAR
+ * \param sar storage aspect ratio (SAR)
+ */
+void ass_set_aspect_ratio(ASS_Renderer *priv, double dar, double sar);
+
+/**
+ * \brief Set a fixed font scaling factor.
+ * \param priv renderer handle
+ * \param font_scale scaling factor, default is 1.0
+ */
+void ass_set_font_scale(ASS_Renderer *priv, double font_scale);
+
+/**
+ * \brief Set font hinting method.
+ * \param priv renderer handle
+ * \param ht hinting method
+ */
+void ass_set_hinting(ASS_Renderer *priv, ASS_Hinting ht);
+
+/**
+ * \brief Set line spacing. Will not be scaled with frame size.
+ * \param priv renderer handle
+ * \param line_spacing line spacing in pixels
+ */
+void ass_set_line_spacing(ASS_Renderer *priv, double line_spacing);
+
+/**
+ * \brief Set font lookup defaults.
+ * \param default_font path to default font to use. Must be supplied if
+ * fontconfig is disabled or unavailable.
+ * \param default_family fallback font family for fontconfig, or NULL
+ * \param fc whether to use fontconfig
+ * \param config path to fontconfig configuration file, or NULL.  Only relevant
+ * if fontconfig is used.
+ * \param update whether fontconfig cache should be built/updated now.  Only
+ * relevant if fontconfig is used.
+ *
+ * NOTE: font lookup must be configured before an ASS_Renderer can be used.
+ */
+void ass_set_fonts(ASS_Renderer *priv, const char *default_font,
+                   const char *default_family, int fc, const char *config,
+                   int update);
+
+/**
+ * \brief Update/build font cache.  This needs to be called if it was
+ * disabled when ass_set_fonts was set.
+ *
+ * \param priv renderer handle
+ * \return success
+ */
+int ass_fonts_update(ASS_Renderer *priv);
+
+/**
+ * \brief Set hard cache limits.  Do not set, or set to zero, for reasonable
+ * defaults.
+ *
+ * \param priv renderer handle
+ * \param glyph_max maximum number of cached glyphs
+ * \param bitmap_max_size maximum bitmap cache size (in MB)
+ */
+void ass_set_cache_limits(ASS_Renderer *priv, int glyph_max,
+                          int bitmap_max_size);
+
+/**
+ * \brief Render a frame, producing a list of ASS_Image.
+ * \param priv renderer handle
  * \param track subtitle track
  * \param now video timestamp in milliseconds
+ * \param detect_change will be set to 1 if a change occured compared
+ * to the last invocation
  */
-ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now, int* detect_change);
+ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
+                            long long now, int *detect_change);
 
 
-// The following functions operate on track objects and do not need an ass_renderer //
+/*
+ * The following functions operate on track objects and do not need
+ * an ass_renderer
+ */
 
 /**
- * \brief allocate a new empty track object
+ * \brief Allocate a new empty track object.
+ * \param library handle
  * \return pointer to empty track
  */
-ass_track_t* ass_new_track(ass_library_t*);
+ASS_Track *ass_new_track(ASS_Library *);
 
 /**
- * \brief deallocate track and all its child objects (styles and events)
+ * \brief Deallocate track and all its child objects (styles and events).
  * \param track track to deallocate
  */
-void ass_free_track(ass_track_t* track);
+void ass_free_track(ASS_Track *track);
 
 /**
- * \brief allocate new style
+ * \brief Allocate new style.
  * \param track track
  * \return newly allocated style id
  */
-int ass_alloc_style(ass_track_t* track);
+int ass_alloc_style(ASS_Track *track);
 
 /**
- * \brief allocate new event
+ * \brief Allocate new event.
  * \param track track
  * \return newly allocated event id
  */
-int ass_alloc_event(ass_track_t* track);
+int ass_alloc_event(ASS_Track *track);
 
 /**
- * \brief delete a style
+ * \brief Delete a style.
  * \param track track
  * \param sid style id
  * Deallocates style data. Does not modify track-&gt;n_styles.
  */
-void ass_free_style(ass_track_t* track, int sid);
+void ass_free_style(ASS_Track *track, int sid);
 
 /**
- * \brief delete an event
+ * \brief Delete an event.
  * \param track track
  * \param eid event id
  * Deallocates event data. Does not modify track-&gt;n_events.
  */
-void ass_free_event(ass_track_t* track, int eid);
+void ass_free_event(ASS_Track *track, int eid);
 
 /**
- * \brief Process Codec Private section of subtitle stream
+ * \brief Parse a chunk of subtitle stream data.
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ */
+void ass_process_data(ASS_Track *track, char *data, int size);
+
+/**
+ * \brief Parse Codec Private section of the subtitle stream, in Matroska
+ * format.  See the Matroska specification for details.
  * \param track target track
  * \param data string to parse
  * \param size length of data
  */
-void ass_process_codec_private(ass_track_t* track, char *data, int size);
+void ass_process_codec_private(ASS_Track *track, char *data, int size);
 
 /**
- * \brief Process a chunk of subtitle stream data. In matroska, this containes exactly 1 event (or a commentary)
+ * \brief Parse a chunk of subtitle stream data. A chunk contains exactly one
+ * event in Matroska format.  See the Matroska specification for details.
  * \param track track
  * \param data string to parse
  * \param size length of data
  * \param timecode starting time of the event (milliseconds)
  * \param duration duration of the event (milliseconds)
+ */
+void ass_process_chunk(ASS_Track *track, char *data, int size,
+                       long long timecode, long long duration);
+
+/**
+ * \brief Flush buffered events.
+ * \param track track
 */
-void ass_process_chunk(ass_track_t* track, char *data, int size, long long timecode, long long duration);
+void ass_flush_events(ASS_Track *track);
 
-char* read_file_recode(char* fname, char* codepage, int* size);
-
 /**
  * \brief Read subtitles from file.
+ * \param library library handle
  * \param fname file name
+ * \param codepage encoding (iconv format)
  * \return newly allocated track
 */
-ass_track_t* ass_read_file(ass_library_t* library, char* fname, char* codepage);
+ASS_Track *ass_read_file(ASS_Library *library, char *fname,
+                         char *codepage);
 
 /**
  * \brief Read subtitles from memory.
- * \param library libass library object
+ * \param library library handle
  * \param buf pointer to subtitles text
  * \param bufsize size of buffer
- * \param codepage recode buffer contents from given codepage
+ * \param codepage encoding (iconv format)
  * \return newly allocated track
-*/ 
-ass_track_t* ass_read_memory(ass_library_t* library, char* buf, size_t bufsize, char* codepage);
+*/
+ASS_Track *ass_read_memory(ASS_Library *library, char *buf,
+                           size_t bufsize, char *codepage);
 /**
- * \brief read styles from file into already initialized track
+ * \brief Read styles from file into already initialized track.
+ * \param fname file name
+ * \param codepage encoding (iconv format)
  * \return 0 on success
  */
-int ass_read_styles(ass_track_t* track, char* fname, char* codepage);
+int ass_read_styles(ASS_Track *track, char *fname, char *codepage);
 
 /**
  * \brief Add a memory font.
+ * \param library library handle
  * \param name attachment name
  * \param data binary font data
  * \param data_size data size
 */
-void ass_add_font(ass_library_t* library, char* name, char* data, int data_size);
+void ass_add_font(ASS_Library *library, char *name, char *data,
+                  int data_size);
 
 /**
- * \brief Calculates timeshift from now to the start of some other subtitle event, depending on movement parameter
+ * \brief Remove all fonts stored in an ass_library object.
+ * \param library library handle
+ */
+void ass_clear_fonts(ASS_Library *library);
+
+/**
+ * \brief Calculates timeshift from now to the start of some other subtitle
+ * event, depending on movement parameter.
  * \param track subtitle track
- * \param now current time, ms
+ * \param now current time in milliseconds
  * \param movement how many events to skip from the one currently displayed
  * +2 means &quot;the one after the next&quot;, -1 means &quot;previous&quot;
- * \return timeshift, ms
+ * \return timeshift in milliseconds
  */
-long long ass_step_sub(ass_track_t* track, long long now, int movement);
+long long ass_step_sub(ASS_Track *track, long long now, int movement);
 
-#endif
-
+#endif /* LIBASS_ASS_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.c	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,23 +1,23 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 #include &lt;math.h&gt;
@@ -25,248 +25,506 @@
 #include &lt;ft2build.h&gt;
 #include FT_GLYPH_H
 
-#include &quot;mputils.h&quot;
+#include &quot;ass_utils.h&quot;
 #include &quot;ass_bitmap.h&quot;
 
-struct ass_synth_priv_s {
-	int tmp_w, tmp_h;
-	unsigned short* tmp;
+struct ass_synth_priv {
+    int tmp_w, tmp_h;
+    unsigned short *tmp;
 
-	int g_r;
-	int g_w;
+    int g_r;
+    int g_w;
 
-	unsigned *g;
-	unsigned *gt2;
+    unsigned *g;
+    unsigned *gt2;
+
+    double radius;
 };
 
 static const unsigned int maxcolor = 255;
 static const unsigned base = 256;
-static const double blur_radius = 1.5;
 
-static int generate_tables(ass_synth_priv_t* priv, double radius)
+static int generate_tables(ASS_SynthPriv *priv, double radius)
 {
-	double A = log(1.0/base)/(radius*radius*2);
-	int mx, i;
-	double volume_diff, volume_factor = 0;
-	unsigned volume;
+    double A = log(1.0 / base) / (radius * radius * 2);
+    int mx, i;
+    double volume_diff, volume_factor = 0;
+    unsigned volume;
 
-	priv-&gt;g_r = ceil(radius);
-	priv-&gt;g_w = 2*priv-&gt;g_r+1;
+    if (priv-&gt;radius == radius)
+        return 0;
+    else
+        priv-&gt;radius = radius;
 
-	if (priv-&gt;g_r) {
-		priv-&gt;g = malloc(priv-&gt;g_w * sizeof(unsigned));
-		priv-&gt;gt2 = malloc(256 * priv-&gt;g_w * sizeof(unsigned));
-		if (priv-&gt;g==NULL || priv-&gt;gt2==NULL) {
-			return -1;
-		}
-	}
+    priv-&gt;g_r = ceil(radius);
+    priv-&gt;g_w = 2 * priv-&gt;g_r + 1;
 
-	if (priv-&gt;g_r) {
-		// gaussian curve with volume = 256
-		for (volume_diff=10000000; volume_diff&gt;0.0000001; volume_diff*=0.5){
-			volume_factor+= volume_diff;
-			volume=0;
-			for (i = 0; i&lt;priv-&gt;g_w; ++i) {
-				priv-&gt;g[i] = (unsigned)(exp(A * (i-priv-&gt;g_r)*(i-priv-&gt;g_r)) * volume_factor + .5);
-				volume+= priv-&gt;g[i];
-			}
-			if(volume&gt;256) volume_factor-= volume_diff;
-		}
-		volume=0;
-		for (i = 0; i&lt;priv-&gt;g_w; ++i) {
-			priv-&gt;g[i] = (unsigned)(exp(A * (i-priv-&gt;g_r)*(i-priv-&gt;g_r)) * volume_factor + .5);
-			volume+= priv-&gt;g[i];
-		}
+    if (priv-&gt;g_r) {
+        priv-&gt;g = realloc(priv-&gt;g, priv-&gt;g_w * sizeof(unsigned));
+        priv-&gt;gt2 = realloc(priv-&gt;gt2, 256 * priv-&gt;g_w * sizeof(unsigned));
+        if (priv-&gt;g == NULL || priv-&gt;gt2 == NULL) {
+            return -1;
+        }
+    }
 
-		// gauss table:
-		for(mx=0;mx&lt;priv-&gt;g_w;mx++){
-			for(i=0;i&lt;256;i++){
-				priv-&gt;gt2[mx+i*priv-&gt;g_w] = i*priv-&gt;g[mx];
-			}
-		}
-	}
+    if (priv-&gt;g_r) {
+        // gaussian curve with volume = 256
+        for (volume_diff = 10000000; volume_diff &gt; 0.0000001;
+             volume_diff *= 0.5) {
+            volume_factor += volume_diff;
+            volume = 0;
+            for (i = 0; i &lt; priv-&gt;g_w; ++i) {
+                priv-&gt;g[i] =
+                    (unsigned) (exp(A * (i - priv-&gt;g_r) * (i - priv-&gt;g_r)) *
+                                volume_factor + .5);
+                volume += priv-&gt;g[i];
+            }
+            if (volume &gt; 256)
+                volume_factor -= volume_diff;
+        }
+        volume = 0;
+        for (i = 0; i &lt; priv-&gt;g_w; ++i) {
+            priv-&gt;g[i] =
+                (unsigned) (exp(A * (i - priv-&gt;g_r) * (i - priv-&gt;g_r)) *
+                            volume_factor + .5);
+            volume += priv-&gt;g[i];
+        }
 
-	return 0;
+        // gauss table:
+        for (mx = 0; mx &lt; priv-&gt;g_w; mx++) {
+            for (i = 0; i &lt; 256; i++) {
+                priv-&gt;gt2[mx + i * priv-&gt;g_w] = i * priv-&gt;g[mx];
+            }
+        }
+    }
+
+    return 0;
 }
 
-static void resize_tmp(ass_synth_priv_t* priv, int w, int h)
+static void resize_tmp(ASS_SynthPriv *priv, int w, int h)
 {
-	if (priv-&gt;tmp_w &gt;= w &amp;&amp; priv-&gt;tmp_h &gt;= h)
-		return;
-	if (priv-&gt;tmp_w == 0)
-		priv-&gt;tmp_w = 64;
-	if (priv-&gt;tmp_h == 0)
-		priv-&gt;tmp_h = 64;
-	while (priv-&gt;tmp_w &lt; w) priv-&gt;tmp_w *= 2;
-	while (priv-&gt;tmp_h &lt; h) priv-&gt;tmp_h *= 2;
-	if (priv-&gt;tmp)
-		free(priv-&gt;tmp);
-	priv-&gt;tmp = malloc((priv-&gt;tmp_w + 1) * priv-&gt;tmp_h * sizeof(short));
+    if (priv-&gt;tmp_w &gt;= w &amp;&amp; priv-&gt;tmp_h &gt;= h)
+        return;
+    if (priv-&gt;tmp_w == 0)
+        priv-&gt;tmp_w = 64;
+    if (priv-&gt;tmp_h == 0)
+        priv-&gt;tmp_h = 64;
+    while (priv-&gt;tmp_w &lt; w)
+        priv-&gt;tmp_w *= 2;
+    while (priv-&gt;tmp_h &lt; h)
+        priv-&gt;tmp_h *= 2;
+    free(priv-&gt;tmp);
+    priv-&gt;tmp = malloc((priv-&gt;tmp_w + 1) * priv-&gt;tmp_h * sizeof(short));
 }
 
-ass_synth_priv_t* ass_synth_init(void)
+ASS_SynthPriv *ass_synth_init(double radius)
 {
-	ass_synth_priv_t* priv = calloc(1, sizeof(ass_synth_priv_t));
-	generate_tables(priv, blur_radius);
-	return priv;
+    ASS_SynthPriv *priv = calloc(1, sizeof(ASS_SynthPriv));
+    generate_tables(priv, radius);
+    return priv;
 }
 
-void ass_synth_done(ass_synth_priv_t* priv)
+void ass_synth_done(ASS_SynthPriv *priv)
 {
-	if (priv-&gt;tmp)
-		free(priv-&gt;tmp);
-	if (priv-&gt;g)
-		free(priv-&gt;g);
-	if (priv-&gt;gt2)
-		free(priv-&gt;gt2);
-	free(priv);
+    free(priv-&gt;tmp);
+    free(priv-&gt;g);
+    free(priv-&gt;gt2);
+    free(priv);
 }
 
-static bitmap_t* alloc_bitmap(int w, int h)
+static Bitmap *alloc_bitmap(int w, int h)
 {
-	bitmap_t* bm;
-	bm = calloc(1, sizeof(bitmap_t));
-	bm-&gt;buffer = malloc(w*h);
-	bm-&gt;w = w;
-	bm-&gt;h = h;
-	bm-&gt;left = bm-&gt;top = 0;
-	return bm;
+    Bitmap *bm;
+    bm = malloc(sizeof(Bitmap));
+    bm-&gt;buffer = calloc(w, h);
+    bm-&gt;w = w;
+    bm-&gt;h = h;
+    bm-&gt;left = bm-&gt;top = 0;
+    return bm;
 }
 
-void ass_free_bitmap(bitmap_t* bm)
+void ass_free_bitmap(Bitmap *bm)
 {
-	if (bm) {
-		if (bm-&gt;buffer) free(bm-&gt;buffer);
-		free(bm);
-	}
+    if (bm)
+        free(bm-&gt;buffer);
+    free(bm);
 }
 
-static bitmap_t* copy_bitmap(const bitmap_t* src)
+static Bitmap *copy_bitmap(const Bitmap *src)
 {
-	bitmap_t* dst = alloc_bitmap(src-&gt;w, src-&gt;h);
-	dst-&gt;left = src-&gt;left;
-	dst-&gt;top = src-&gt;top;
-	memcpy(dst-&gt;buffer, src-&gt;buffer, src-&gt;w * src-&gt;h);
-	return dst;
+    Bitmap *dst = alloc_bitmap(src-&gt;w, src-&gt;h);
+    dst-&gt;left = src-&gt;left;
+    dst-&gt;top = src-&gt;top;
+    memcpy(dst-&gt;buffer, src-&gt;buffer, src-&gt;w * src-&gt;h);
+    return dst;
 }
 
-static bitmap_t* glyph_to_bitmap_internal(FT_Glyph glyph, int bord)
+int check_glyph_area(ASS_Library *library, FT_Glyph glyph)
 {
-	FT_BitmapGlyph bg;
-	FT_Bitmap* bit;
-	bitmap_t* bm;
-	int w, h;
-	unsigned char* src;
-	unsigned char* dst;
-	int i;
-	int error;
+    FT_BBox bbox;
+    long long dx, dy;
+    FT_Glyph_Get_CBox(glyph, FT_GLYPH_BBOX_TRUNCATE, &amp;bbox);
+    dx = bbox.xMax - bbox.xMin;
+    dy = bbox.yMax - bbox.yMin;
+    if (dx * dy &gt; 8000000) {
+        ass_msg(library, MSGL_WARN, &quot;Glyph bounding box too large: %dx%dpx&quot;,
+               (int) dx, (int) dy);
+        return 1;
+    } else
+        return 0;
+}
 
-	error = FT_Glyph_To_Bitmap(&amp;glyph, FT_RENDER_MODE_NORMAL, 0, 0);
-	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FT_Glyph_To_BitmapError, error);
-		return 0;
-	}
+static Bitmap *glyph_to_bitmap_internal(ASS_Library *library,
+                                          FT_Glyph glyph, int bord)
+{
+    FT_BitmapGlyph bg;
+    FT_Bitmap *bit;
+    Bitmap *bm;
+    int w, h;
+    unsigned char *src;
+    unsigned char *dst;
+    int i;
+    int error;
 
-	bg = (FT_BitmapGlyph)glyph;
-	bit = &amp;(bg-&gt;bitmap);
-	if (bit-&gt;pixel_mode != FT_PIXEL_MODE_GRAY) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UnsupportedPixelMode, (int)(bit-&gt;pixel_mode));
-		FT_Done_Glyph(glyph);
-		return 0;
-	}
+    if (check_glyph_area(library, glyph))
+        return 0;
+    error = FT_Glyph_To_Bitmap(&amp;glyph, FT_RENDER_MODE_NORMAL, 0, 0);
+    if (error) {
+        ass_msg(library, MSGL_WARN, &quot;FT_Glyph_To_Bitmap error %d&quot;,
+               error);
+        return 0;
+    }
 
-	w = bit-&gt;width;
-	h = bit-&gt;rows;
-	bm = alloc_bitmap(w + 2*bord, h + 2*bord);
-	memset(bm-&gt;buffer, 0, bm-&gt;w * bm-&gt;h);
-	bm-&gt;left = bg-&gt;left - bord;
-	bm-&gt;top = - bg-&gt;top - bord;
+    bg = (FT_BitmapGlyph) glyph;
+    bit = &amp;(bg-&gt;bitmap);
+    if (bit-&gt;pixel_mode != FT_PIXEL_MODE_GRAY) {
+        ass_msg(library, MSGL_WARN, &quot;Unsupported pixel mode: %d&quot;,
+               (int) (bit-&gt;pixel_mode));
+        FT_Done_Glyph(glyph);
+        return 0;
+    }
 
-	src = bit-&gt;buffer;
-	dst = bm-&gt;buffer + bord + bm-&gt;w * bord;
-	for (i = 0; i &lt; h; ++i) {
-		memcpy(dst, src, w);
-		src += bit-&gt;pitch;
-		dst += bm-&gt;w;
-	}
+    w = bit-&gt;width;
+    h = bit-&gt;rows;
+    bm = alloc_bitmap(w + 2 * bord, h + 2 * bord);
+    bm-&gt;left = bg-&gt;left - bord;
+    bm-&gt;top = -bg-&gt;top - bord;
 
-	return bm;
+    src = bit-&gt;buffer;
+    dst = bm-&gt;buffer + bord + bm-&gt;w * bord;
+    for (i = 0; i &lt; h; ++i) {
+        memcpy(dst, src, w);
+        src += bit-&gt;pitch;
+        dst += bm-&gt;w;
+    }
+
+    FT_Done_Glyph(glyph);
+    return bm;
 }
 
 /**
- * \brief fix outline bitmap and generate shadow bitmap
- * Two things are done here:
- * 1. Glyph bitmap is subtracted from outline bitmap. This way looks much better in some cases.
- * 2. Shadow bitmap is created as a sum of glyph and outline bitmaps.
+ * \brief fix outline bitmap
+ *
+ * The glyph bitmap is subtracted from outline bitmap. This way looks much
+ * better in some cases.
  */
-static bitmap_t* fix_outline_and_shadow(bitmap_t* bm_g, bitmap_t* bm_o)
+static void fix_outline(Bitmap *bm_g, Bitmap *bm_o)
 {
-	int x, y;
-	const int l = bm_o-&gt;left &gt; bm_g-&gt;left ? bm_o-&gt;left : bm_g-&gt;left;
-	const int t = bm_o-&gt;top &gt; bm_g-&gt;top ? bm_o-&gt;top : bm_g-&gt;top;
-	const int r = bm_o-&gt;left + bm_o-&gt;w &lt; bm_g-&gt;left + bm_g-&gt;w ? bm_o-&gt;left + bm_o-&gt;w : bm_g-&gt;left + bm_g-&gt;w;
-	const int b = bm_o-&gt;top + bm_o-&gt;h &lt; bm_g-&gt;top + bm_g-&gt;h ? bm_o-&gt;top + bm_o-&gt;h : bm_g-&gt;top + bm_g-&gt;h;
+    int x, y;
+    const int l = bm_o-&gt;left &gt; bm_g-&gt;left ? bm_o-&gt;left : bm_g-&gt;left;
+    const int t = bm_o-&gt;top &gt; bm_g-&gt;top ? bm_o-&gt;top : bm_g-&gt;top;
+    const int r =
+        bm_o-&gt;left + bm_o-&gt;w &lt;
+        bm_g-&gt;left + bm_g-&gt;w ? bm_o-&gt;left + bm_o-&gt;w : bm_g-&gt;left + bm_g-&gt;w;
+    const int b =
+        bm_o-&gt;top + bm_o-&gt;h &lt;
+        bm_g-&gt;top + bm_g-&gt;h ? bm_o-&gt;top + bm_o-&gt;h : bm_g-&gt;top + bm_g-&gt;h;
 
-	bitmap_t* bm_s = copy_bitmap(bm_o);
+    unsigned char *g =
+        bm_g-&gt;buffer + (t - bm_g-&gt;top) * bm_g-&gt;w + (l - bm_g-&gt;left);
+    unsigned char *o =
+        bm_o-&gt;buffer + (t - bm_o-&gt;top) * bm_o-&gt;w + (l - bm_o-&gt;left);
 
-	unsigned char* g = bm_g-&gt;buffer + (t - bm_g-&gt;top) * bm_g-&gt;w + (l - bm_g-&gt;left);
-	unsigned char* o = bm_o-&gt;buffer + (t - bm_o-&gt;top) * bm_o-&gt;w + (l - bm_o-&gt;left);
-	unsigned char* s = bm_s-&gt;buffer + (t - bm_s-&gt;top) * bm_s-&gt;w + (l - bm_s-&gt;left);
-	
-	for (y = 0; y &lt; b - t; ++y) {
-		for (x = 0; x &lt; r - l; ++x) {
-			unsigned char c_g, c_o;
-			c_g = g[x];
-			c_o = o[x];
-			o[x] = (c_o &gt; c_g) ? c_o : 0;
-			s[x] = (c_o &lt; 0xFF - c_g) ? c_o + c_g : 0xFF;
-		}
-		g += bm_g-&gt;w;
-		o += bm_o-&gt;w;
-		s += bm_s-&gt;w;
-	}
+    for (y = 0; y &lt; b - t; ++y) {
+        for (x = 0; x &lt; r - l; ++x) {
+            unsigned char c_g, c_o;
+            c_g = g[x];
+            c_o = o[x];
+            o[x] = (c_o &gt; c_g) ? c_o - (c_g / 2) : 0;
+        }
+        g += bm_g-&gt;w;
+        o += bm_o-&gt;w;
+    }
+}
 
-	assert(bm_s);
-	return bm_s;
+/**
+ * \brief Shift a bitmap by the fraction of a pixel in x and y direction
+ * expressed in 26.6 fixed point
+ */
+static void shift_bitmap(unsigned char *buf, int w, int h, int shift_x,
+                         int shift_y)
+{
+    int x, y, b;
+
+    // Shift in x direction
+    if (shift_x &gt; 0) {
+        for (y = 0; y &lt; h; y++) {
+            for (x = w - 1; x &gt; 0; x--) {
+                b = (buf[x + y * w - 1] * shift_x) &gt;&gt; 6;
+                buf[x + y * w - 1] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    } else if (shift_x &lt; 0) {
+        shift_x = -shift_x;
+        for (y = 0; y &lt; h; y++) {
+            for (x = 0; x &lt; w - 1; x++) {
+                b = (buf[x + y * w + 1] * shift_x) &gt;&gt; 6;
+                buf[x + y * w + 1] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    }
+
+    // Shift in y direction
+    if (shift_y &gt; 0) {
+        for (x = 0; x &lt; w; x++) {
+            for (y = h - 1; y &gt; 0; y--) {
+                b = (buf[x + (y - 1) * w] * shift_y) &gt;&gt; 6;
+                buf[x + (y - 1) * w] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    } else if (shift_y &lt; 0) {
+        shift_y = -shift_y;
+        for (x = 0; x &lt; w; x++) {
+            for (y = 0; y &lt; h - 1; y++) {
+                b = (buf[x + (y + 1) * w] * shift_y) &gt;&gt; 6;
+                buf[x + (y + 1) * w] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    }
 }
 
-int glyph_to_bitmap(ass_synth_priv_t* priv, FT_Glyph glyph, FT_Glyph outline_glyph,
-		bitmap_t** bm_g, bitmap_t** bm_o, bitmap_t** bm_s, int be)
+/*
+ * Gaussian blur.  An fast pure C implementation from MPlayer.
+ */
+static void ass_gauss_blur(unsigned char *buffer, unsigned short *tmp2,
+                           int width, int height, int stride, int *m2,
+                           int r, int mwidth)
 {
-	const int bord = be ? ceil(blur_radius) : 0;
 
-	assert(bm_g &amp;&amp; bm_o &amp;&amp; bm_s);
+    int x, y;
 
-	*bm_g = *bm_o = *bm_s = 0;
+    unsigned char *s = buffer;
+    unsigned short *t = tmp2 + 1;
+    for (y = 0; y &lt; height; y++) {
+        memset(t - 1, 0, (width + 1) * sizeof(short));
 
-	if (glyph)
-		*bm_g = glyph_to_bitmap_internal(glyph, bord);
-	if (!*bm_g)
-		return 1;
+        for (x = 0; x &lt; r; x++) {
+            const int src = s[x];
+            if (src) {
+                register unsigned short *dstp = t + x - r;
+                int mx;
+                unsigned *m3 = (unsigned *) (m2 + src * mwidth);
+                for (mx = r - x; mx &lt; mwidth; mx++) {
+                    dstp[mx] += m3[mx];
+                }
+            }
+        }
 
-	if (outline_glyph) {
-		*bm_o = glyph_to_bitmap_internal(outline_glyph, bord);
-		if (!*bm_o) {
-			ass_free_bitmap(*bm_g);
-			return 1;
-		}
-	}
-	if (*bm_o)
-		resize_tmp(priv, (*bm_o)-&gt;w, (*bm_o)-&gt;h);
-	resize_tmp(priv, (*bm_g)-&gt;w, (*bm_g)-&gt;h);
-	
-	if (be) {
-		blur((*bm_g)-&gt;buffer, priv-&gt;tmp, (*bm_g)-&gt;w, (*bm_g)-&gt;h, (*bm_g)-&gt;w, (int*)priv-&gt;gt2, priv-&gt;g_r, priv-&gt;g_w);
-		if (*bm_o)
-			blur((*bm_o)-&gt;buffer, priv-&gt;tmp, (*bm_o)-&gt;w, (*bm_o)-&gt;h, (*bm_o)-&gt;w, (int*)priv-&gt;gt2, priv-&gt;g_r, priv-&gt;g_w);
-	}
+        for (; x &lt; width - r; x++) {
+            const int src = s[x];
+            if (src) {
+                register unsigned short *dstp = t + x - r;
+                int mx;
+                unsigned *m3 = (unsigned *) (m2 + src * mwidth);
+                for (mx = 0; mx &lt; mwidth; mx++) {
+                    dstp[mx] += m3[mx];
+                }
+            }
+        }
 
-	if (*bm_o)
-		*bm_s = fix_outline_and_shadow(*bm_g, *bm_o);
-	else
-		*bm_s = copy_bitmap(*bm_g);
+        for (; x &lt; width; x++) {
+            const int src = s[x];
+            if (src) {
+                register unsigned short *dstp = t + x - r;
+                int mx;
+                const int x2 = r + width - x;
+                unsigned *m3 = (unsigned *) (m2 + src * mwidth);
+                for (mx = 0; mx &lt; x2; mx++) {
+                    dstp[mx] += m3[mx];
+                }
+            }
+        }
 
-	assert(bm_s);
-	return 0;
+        s += stride;
+        t += width + 1;
+    }
+
+    t = tmp2;
+    for (x = 0; x &lt; width; x++) {
+        for (y = 0; y &lt; r; y++) {
+            unsigned short *srcp = t + y * (width + 1) + 1;
+            int src = *srcp;
+            if (src) {
+                register unsigned short *dstp = srcp - 1 + width + 1;
+                const int src2 = (src + 128) &gt;&gt; 8;
+                unsigned *m3 = (unsigned *) (m2 + src2 * mwidth);
+
+                int mx;
+                *srcp = 128;
+                for (mx = r - 1; mx &lt; mwidth; mx++) {
+                    *dstp += m3[mx];
+                    dstp += width + 1;
+                }
+            }
+        }
+        for (; y &lt; height - r; y++) {
+            unsigned short *srcp = t + y * (width + 1) + 1;
+            int src = *srcp;
+            if (src) {
+                register unsigned short *dstp = srcp - 1 - r * (width + 1);
+                const int src2 = (src + 128) &gt;&gt; 8;
+                unsigned *m3 = (unsigned *) (m2 + src2 * mwidth);
+
+                int mx;
+                *srcp = 128;
+                for (mx = 0; mx &lt; mwidth; mx++) {
+                    *dstp += m3[mx];
+                    dstp += width + 1;
+                }
+            }
+        }
+        for (; y &lt; height; y++) {
+            unsigned short *srcp = t + y * (width + 1) + 1;
+            int src = *srcp;
+            if (src) {
+                const int y2 = r + height - y;
+                register unsigned short *dstp = srcp - 1 - r * (width + 1);
+                const int src2 = (src + 128) &gt;&gt; 8;
+                unsigned *m3 = (unsigned *) (m2 + src2 * mwidth);
+
+                int mx;
+                *srcp = 128;
+                for (mx = 0; mx &lt; y2; mx++) {
+                    *dstp += m3[mx];
+                    dstp += width + 1;
+                }
+            }
+        }
+        t++;
+    }
+
+    t = tmp2;
+    s = buffer;
+    for (y = 0; y &lt; height; y++) {
+        for (x = 0; x &lt; width; x++) {
+            s[x] = t[x] &gt;&gt; 8;
+        }
+        s += stride;
+        t += width + 1;
+    }
 }
 
+/**
+ * \brief Blur with [[1,2,1]. [2,4,2], [1,2,1]] kernel
+ * This blur is the same as the one employed by vsfilter.
+ */
+static void be_blur(unsigned char *buf, int w, int h)
+{
+    unsigned int x, y;
+    unsigned int old_sum, new_sum;
+
+    for (y = 0; y &lt; h; y++) {
+        old_sum = 2 * buf[y * w];
+        for (x = 0; x &lt; w - 1; x++) {
+            new_sum = buf[y * w + x] + buf[y * w + x + 1];
+            buf[y * w + x] = (old_sum + new_sum) &gt;&gt; 2;
+            old_sum = new_sum;
+        }
+    }
+
+    for (x = 0; x &lt; w; x++) {
+        old_sum = 2 * buf[x];
+        for (y = 0; y &lt; h - 1; y++) {
+            new_sum = buf[y * w + x] + buf[(y + 1) * w + x];
+            buf[y * w + x] = (old_sum + new_sum) &gt;&gt; 2;
+            old_sum = new_sum;
+        }
+    }
+}
+
+int glyph_to_bitmap(ASS_Library *library, ASS_SynthPriv *priv_blur,
+                    FT_Glyph glyph, FT_Glyph outline_glyph,
+                    Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset,
+                    int border_style)
+{
+    blur_radius *= 2;
+    int bbord = be &gt; 0 ? sqrt(2 * be) : 0;
+    int gbord = blur_radius &gt; 0.0 ? blur_radius + 1 : 0;
+    int bord = FFMAX(bbord, gbord);
+    if (bord == 0 &amp;&amp; (shadow_offset.x || shadow_offset.y))
+        bord = 1;
+
+    assert(bm_g &amp;&amp; bm_o &amp;&amp; bm_s);
+
+    *bm_g = *bm_o = *bm_s = 0;
+
+    if (glyph)
+        *bm_g = glyph_to_bitmap_internal(library, glyph, bord);
+    if (!*bm_g)
+        return 1;
+
+    if (outline_glyph) {
+        *bm_o = glyph_to_bitmap_internal(library, outline_glyph, bord);
+        if (!*bm_o) {
+            return 1;
+        }
+    }
+
+    // Apply box blur (multiple passes, if requested)
+    while (be--) {
+        if (*bm_o)
+            be_blur((*bm_o)-&gt;buffer, (*bm_o)-&gt;w, (*bm_o)-&gt;h);
+        else
+            be_blur((*bm_g)-&gt;buffer, (*bm_g)-&gt;w, (*bm_g)-&gt;h);
+    }
+
+    // Apply gaussian blur
+    if (blur_radius &gt; 0.0) {
+        if (*bm_o)
+            resize_tmp(priv_blur, (*bm_o)-&gt;w, (*bm_o)-&gt;h);
+        else
+            resize_tmp(priv_blur, (*bm_g)-&gt;w, (*bm_g)-&gt;h);
+        generate_tables(priv_blur, blur_radius);
+        if (*bm_o)
+            ass_gauss_blur((*bm_o)-&gt;buffer, priv_blur-&gt;tmp,
+                           (*bm_o)-&gt;w, (*bm_o)-&gt;h, (*bm_o)-&gt;w,
+                           (int *) priv_blur-&gt;gt2, priv_blur-&gt;g_r,
+                           priv_blur-&gt;g_w);
+        else
+            ass_gauss_blur((*bm_g)-&gt;buffer, priv_blur-&gt;tmp,
+                           (*bm_g)-&gt;w, (*bm_g)-&gt;h, (*bm_g)-&gt;w,
+                           (int *) priv_blur-&gt;gt2, priv_blur-&gt;g_r,
+                           priv_blur-&gt;g_w);
+    }
+
+    // Create shadow and fix outline as needed
+    if (*bm_o &amp;&amp; border_style != 3) {
+        *bm_s = copy_bitmap(*bm_o);
+        fix_outline(*bm_g, *bm_o);
+    } else if (*bm_o) {
+        *bm_s = copy_bitmap(*bm_o);
+    } else
+        *bm_s = copy_bitmap(*bm_g);
+
+    assert(bm_s);
+
+    shift_bitmap((*bm_s)-&gt;buffer, (*bm_s)-&gt;w,(*bm_s)-&gt;h,
+                 shadow_offset.x, shadow_offset.y);
+
+    return 0;
+}

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.h	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,37 +1,42 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#ifndef LIBASS_BITMAP_H
+#define LIBASS_BITMAP_H
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
 
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
+#include &quot;ass.h&quot;
 
-#ifndef ASS_BITMAP_H
-#define ASS_BITMAP_H
+typedef struct ass_synth_priv ASS_SynthPriv;
 
-typedef struct ass_synth_priv_s ass_synth_priv_t;
+ASS_SynthPriv *ass_synth_init(double);
+void ass_synth_done(ASS_SynthPriv *priv);
 
-ass_synth_priv_t* ass_synth_init(void);
-void ass_synth_done(ass_synth_priv_t* priv);
+typedef struct {
+    int left, top;
+    int w, h;                   // width, height
+    unsigned char *buffer;      // w x h buffer
+} Bitmap;
 
-typedef struct bitmap_s {
-	int left, top;
-	int w, h; // width, height
-	unsigned char* buffer; // w x h buffer
-} bitmap_t;
-
 /**
  * \brief perform glyph rendering
  * \param glyph original glyph
@@ -41,9 +46,13 @@
  * \param bm_g out: pointer to the bitmap of glyph shadow is returned here
  * \param be 1 = produces blurred bitmaps, 0 = normal bitmaps
  */
-int glyph_to_bitmap(ass_synth_priv_t* priv, FT_Glyph glyph, FT_Glyph outline_glyph, bitmap_t** bm_g, bitmap_t** bm_o, bitmap_t** bm_s, int be);
+int glyph_to_bitmap(ASS_Library *library, ASS_SynthPriv *priv_blur,
+                    FT_Glyph glyph, FT_Glyph outline_glyph,
+                    Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset,
+                    int border_style);
 
-void ass_free_bitmap(bitmap_t* bm);
+void ass_free_bitmap(Bitmap *bm);
+int check_glyph_area(ASS_Library *library, FT_Glyph glyph);
 
-#endif
-
+#endif                          /* LIBASS_BITMAP_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.c	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,25 +1,25 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#include &quot;ADM_coreConfig.h&quot;
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include &quot;config.h&quot;
-
 #include &lt;inttypes.h&gt;
 #include &lt;ft2build.h&gt;
 #include FT_FREETYPE_H
@@ -27,298 +27,361 @@
 
 #include &lt;assert.h&gt;
 
-#include &quot;mputils.h&quot;
+#include &quot;ass_utils.h&quot;
 #include &quot;ass.h&quot;
 #include &quot;ass_fontconfig.h&quot;
 #include &quot;ass_font.h&quot;
 #include &quot;ass_bitmap.h&quot;
 #include &quot;ass_cache.h&quot;
 
-
-typedef struct hashmap_item_s {
-	void* key;
-	void* value;
-	struct hashmap_item_s* next;
-} hashmap_item_t;
-typedef hashmap_item_t* hashmap_item_p;
-
-struct hashmap_s {
-	int nbuckets;
-	size_t key_size, value_size;
-	hashmap_item_p* root;
-	hashmap_item_dtor_t item_dtor; // a destructor for hashmap key/value pairs
-	hashmap_key_compare_t key_compare;
-	hashmap_hash_t hash;
-	// stats
-	int hit_count;
-	int miss_count;
-	int count;
-};
-
-#define FNV1_32A_INIT (unsigned)0x811c9dc5
-
-static inline unsigned fnv_32a_buf(void* buf, size_t len, unsigned hval)
+static unsigned hashmap_hash(void *buf, size_t len)
 {
-	unsigned char *bp = buf;
-	unsigned char *be = bp + len;
-	while (bp &lt; be) {
-		hval ^= (unsigned)*bp++;
-		hval += (hval&lt;&lt;1) + (hval&lt;&lt;4) + (hval&lt;&lt;7) + (hval&lt;&lt;8) + (hval&lt;&lt;24);
-	}
-	return hval;
+    return fnv_32a_buf(buf, len, FNV1_32A_INIT);
 }
-static inline unsigned fnv_32a_str(char* str, unsigned hval)
-{
-	unsigned char* s = (unsigned char*)str;
-	while (*s) {
-		hval ^= (unsigned)*s++;
-		hval += (hval&lt;&lt;1) + (hval&lt;&lt;4) + (hval&lt;&lt;7) + (hval&lt;&lt;8) + (hval&lt;&lt;24);
-	}
-	return hval;
-}
 
-static unsigned hashmap_hash(void* buf, size_t len)
+static int hashmap_key_compare(void *a, void *b, size_t size)
 {
-	return fnv_32a_buf(buf, len, FNV1_32A_INIT);
+    return memcmp(a, b, size) == 0;
 }
 
-static int hashmap_key_compare(void* a, void* b, size_t size)
+static void hashmap_item_dtor(void *key, size_t key_size, void *value,
+                              size_t value_size)
 {
-	return (memcmp(a, b, size) == 0);
+    free(key);
+    free(value);
 }
 
-static void hashmap_item_dtor(void* key, size_t key_size, void* value, size_t value_size)
+Hashmap *hashmap_init(ASS_Library *library, size_t key_size,
+                      size_t value_size, int nbuckets,
+                      HashmapItemDtor item_dtor,
+                      HashmapKeyCompare key_compare,
+                      HashmapHash hash)
 {
-	free(key);
-	free(value);
+    Hashmap *map = calloc(1, sizeof(Hashmap));
+    map-&gt;library = library;
+    map-&gt;nbuckets = nbuckets;
+    map-&gt;key_size = key_size;
+    map-&gt;value_size = value_size;
+    map-&gt;root = calloc(nbuckets, sizeof(hashmap_item_p));
+    map-&gt;item_dtor = item_dtor ? item_dtor : hashmap_item_dtor;
+    map-&gt;key_compare = key_compare ? key_compare : hashmap_key_compare;
+    map-&gt;hash = hash ? hash : hashmap_hash;
+    return map;
 }
 
-hashmap_t* hashmap_init(size_t key_size, size_t value_size, int nbuckets,
-			hashmap_item_dtor_t item_dtor, hashmap_key_compare_t key_compare,
-			hashmap_hash_t hash)
+void hashmap_done(Hashmap *map)
 {
-	hashmap_t* map = calloc(1, sizeof(hashmap_t));
-	map-&gt;nbuckets = nbuckets;
-	map-&gt;key_size = key_size;
-	map-&gt;value_size = value_size;
-	map-&gt;root = calloc(nbuckets, sizeof(hashmap_item_p));
-	map-&gt;item_dtor = item_dtor ? item_dtor : hashmap_item_dtor;
-	map-&gt;key_compare = key_compare ? key_compare : hashmap_key_compare;
-	map-&gt;hash = hash ? hash : hashmap_hash;
-	return map;
-}
+    int i;
+    // print stats
+    if (map-&gt;count &gt; 0 || map-&gt;hit_count + map-&gt;miss_count &gt; 0)
+        ass_msg(map-&gt;library, MSGL_V,
+               &quot;cache statistics: \n  total accesses: %d\n  hits: %d\n  &quot;
+               &quot;misses: %d\n  object count: %d&quot;,
+               map-&gt;hit_count + map-&gt;miss_count, map-&gt;hit_count,
+               map-&gt;miss_count, map-&gt;count);
 
-void hashmap_done(hashmap_t* map)
-{
-	int i;
-	// print stats
-	if (map-&gt;count &gt; 0 || map-&gt;hit_count + map-&gt;miss_count &gt; 0)
-		mp_msg(MSGT_ASS, MSGL_V, &quot;cache statistics: \n  total accesses: %d\n  hits: %d\n  misses: %d\n  object count: %d\n&quot;,
-		       map-&gt;hit_count + map-&gt;miss_count, map-&gt;hit_count, map-&gt;miss_count, map-&gt;count);
-	
-	for (i = 0; i &lt; map-&gt;nbuckets; ++i) {
-		hashmap_item_t* item = map-&gt;root[i];
-		while (item) {
-			hashmap_item_t* next = item-&gt;next;
-			map-&gt;item_dtor(item-&gt;key, map-&gt;key_size, item-&gt;value, map-&gt;value_size);
-			free(item);
-			item = next;
-		}
-	}
-	free(map-&gt;root);
-	free(map);
+    for (i = 0; i &lt; map-&gt;nbuckets; ++i) {
+        HashmapItem *item = map-&gt;root[i];
+        while (item) {
+            HashmapItem *next = item-&gt;next;
+            map-&gt;item_dtor(item-&gt;key, map-&gt;key_size, item-&gt;value,
+                           map-&gt;value_size);
+            free(item);
+            item = next;
+        }
+    }
+    free(map-&gt;root);
+    free(map);
 }
 
 // does nothing if key already exists
-void* hashmap_insert(hashmap_t* map, void* key, void* value)
+void *hashmap_insert(Hashmap *map, void *key, void *value)
 {
-	unsigned hash = map-&gt;hash(key, map-&gt;key_size);
-	hashmap_item_t** next = map-&gt;root + (hash % map-&gt;nbuckets);
-	while (*next) {
-		if (map-&gt;key_compare(key, (*next)-&gt;key, map-&gt;key_size))
-			return (*next)-&gt;value;
-		next = &amp;((*next)-&gt;next);
-		assert(next);
-	}
-	(*next) = malloc(sizeof(hashmap_item_t));
-	(*next)-&gt;key = malloc(map-&gt;key_size);
-	(*next)-&gt;value = malloc(map-&gt;value_size);
-	memcpy((*next)-&gt;key, key, map-&gt;key_size);
-	memcpy((*next)-&gt;value, value, map-&gt;value_size);
-	(*next)-&gt;next = 0;
+    unsigned hash = map-&gt;hash(key, map-&gt;key_size);
+    HashmapItem **next = map-&gt;root + (hash % map-&gt;nbuckets);
+    while (*next) {
+        if (map-&gt;key_compare(key, (*next)-&gt;key, map-&gt;key_size))
+            return (*next)-&gt;value;
+        next = &amp;((*next)-&gt;next);
+        assert(next);
+    }
+    (*next) = malloc(sizeof(HashmapItem));
+    (*next)-&gt;key = malloc(map-&gt;key_size);
+    (*next)-&gt;value = malloc(map-&gt;value_size);
+    memcpy((*next)-&gt;key, key, map-&gt;key_size);
+    memcpy((*next)-&gt;value, value, map-&gt;value_size);
+    (*next)-&gt;next = 0;
 
-	map-&gt;count ++;
-	return (*next)-&gt;value;
+    map-&gt;count++;
+    return (*next)-&gt;value;
 }
 
-void* hashmap_find(hashmap_t* map, void* key)
+void *hashmap_find(Hashmap *map, void *key)
 {
-	unsigned hash = map-&gt;hash(key, map-&gt;key_size);
-	hashmap_item_t* item = map-&gt;root[hash % map-&gt;nbuckets];
-	while (item) {
-		if (map-&gt;key_compare(key, item-&gt;key, map-&gt;key_size)) {
-			map-&gt;hit_count++;
-			return item-&gt;value;
-		}
-		item = item-&gt;next;
-	}
-	map-&gt;miss_count++;
-	return 0;
+    unsigned hash = map-&gt;hash(key, map-&gt;key_size);
+    HashmapItem *item = map-&gt;root[hash % map-&gt;nbuckets];
+    while (item) {
+        if (map-&gt;key_compare(key, item-&gt;key, map-&gt;key_size)) {
+            map-&gt;hit_count++;
+            return item-&gt;value;
+        }
+        item = item-&gt;next;
+    }
+    map-&gt;miss_count++;
+    return 0;
 }
 
 //---------------------------------
 // font cache
 
-hashmap_t* font_cache;
-
-static unsigned font_desc_hash(void* buf, size_t len)
+static unsigned font_desc_hash(void *buf, size_t len)
 {
-	ass_font_desc_t* desc = buf;
-	unsigned hval;
-	hval = fnv_32a_str(desc-&gt;family, FNV1_32A_INIT);
-	hval = fnv_32a_buf(&amp;desc-&gt;bold, sizeof(desc-&gt;bold), hval);
-	hval = fnv_32a_buf(&amp;desc-&gt;italic, sizeof(desc-&gt;italic), hval);
-	return hval;
+    ASS_FontDesc *desc = buf;
+    unsigned hval;
+    hval = fnv_32a_str(desc-&gt;family, FNV1_32A_INIT);
+    hval = fnv_32a_buf(&amp;desc-&gt;bold, sizeof(desc-&gt;bold), hval);
+    hval = fnv_32a_buf(&amp;desc-&gt;italic, sizeof(desc-&gt;italic), hval);
+    return hval;
 }
 
-static int font_compare(void* key1, void* key2, size_t key_size) {
-	ass_font_desc_t* a = key1;
-	ass_font_desc_t* b = key2;
-	if (strcmp(a-&gt;family, b-&gt;family) != 0)
-		return 0;
-	if (a-&gt;bold != b-&gt;bold)
-		return 0;
-	if (a-&gt;italic != b-&gt;italic)
-		return 0;
-	return 1;
+static int font_compare(void *key1, void *key2, size_t key_size)
+{
+    ASS_FontDesc *a = key1;
+    ASS_FontDesc *b = key2;
+    if (strcmp(a-&gt;family, b-&gt;family) != 0)
+        return 0;
+    if (a-&gt;bold != b-&gt;bold)
+        return 0;
+    if (a-&gt;italic != b-&gt;italic)
+        return 0;
+    if (a-&gt;treat_family_as_pattern != b-&gt;treat_family_as_pattern)
+        return 0;
+    if (a-&gt;vertical != b-&gt;vertical)
+        return 0;
+    return 1;
 }
 
-static void font_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
+static void font_hash_dtor(void *key, size_t key_size, void *value,
+                           size_t value_size)
 {
-	ass_font_free(value);
-	free(key);
+    ass_font_free(value);
+    free(key);
 }
 
-ass_font_t* ass_font_cache_find(ass_font_desc_t* desc)
+ASS_Font *ass_font_cache_find(Hashmap *font_cache,
+                              ASS_FontDesc *desc)
 {
-	return hashmap_find(font_cache, desc);
+    return hashmap_find(font_cache, desc);
 }
 
 /**
  * \brief Add a face struct to cache.
  * \param font font struct
 */
-void* ass_font_cache_add(ass_font_t* font)
+void *ass_font_cache_add(Hashmap *font_cache, ASS_Font *font)
 {
-	return hashmap_insert(font_cache, &amp;(font-&gt;desc), font);
+    return hashmap_insert(font_cache, &amp;(font-&gt;desc), font);
 }
 
-void ass_font_cache_init(void)
+Hashmap *ass_font_cache_init(ASS_Library *library)
 {
-	font_cache = hashmap_init(sizeof(ass_font_desc_t),
-				  sizeof(ass_font_t),
-				  1000,
-				  font_hash_dtor, font_compare, font_desc_hash);
+    Hashmap *font_cache;
+    font_cache = hashmap_init(library, sizeof(ASS_FontDesc),
+                              sizeof(ASS_Font),
+                              1000,
+                              font_hash_dtor, font_compare, font_desc_hash);
+    return font_cache;
 }
 
-void ass_font_cache_done(void)
+void ass_font_cache_done(Hashmap *font_cache)
 {
-	hashmap_done(font_cache);
+    hashmap_done(font_cache);
 }
 
+
+// Create hash/compare functions for bitmap and glyph
+#define CREATE_HASH_FUNCTIONS
+#include &quot;ass_cache_template.h&quot;
+#define CREATE_COMPARISON_FUNCTIONS
+#include &quot;ass_cache_template.h&quot;
+
 //---------------------------------
 // bitmap cache
 
-hashmap_t* bitmap_cache;
-
-static void bitmap_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
+static void bitmap_hash_dtor(void *key, size_t key_size, void *value,
+                             size_t value_size)
 {
-	bitmap_hash_val_t* v = value;
-	if (v-&gt;bm) ass_free_bitmap(v-&gt;bm);
-	if (v-&gt;bm_o) ass_free_bitmap(v-&gt;bm_o);
-	if (v-&gt;bm_s) ass_free_bitmap(v-&gt;bm_s);
-	free(key);
-	free(value);
+    BitmapHashValue *v = value;
+    if (v-&gt;bm)
+        ass_free_bitmap(v-&gt;bm);
+    if (v-&gt;bm_o)
+        ass_free_bitmap(v-&gt;bm_o);
+    if (v-&gt;bm_s)
+        ass_free_bitmap(v-&gt;bm_s);
+    free(key);
+    free(value);
 }
 
-void* cache_add_bitmap(bitmap_hash_key_t* key, bitmap_hash_val_t* val)
+void *cache_add_bitmap(Hashmap *bitmap_cache, BitmapHashKey *key,
+                       BitmapHashValue *val)
 {
-	return hashmap_insert(bitmap_cache, key, val);
+    // Note: this is only an approximation
+    if (val-&gt;bm_o)
+        bitmap_cache-&gt;cache_size += val-&gt;bm_o-&gt;w * val-&gt;bm_o-&gt;h * 3;
+    else if (val-&gt;bm)
+        bitmap_cache-&gt;cache_size += val-&gt;bm-&gt;w * val-&gt;bm-&gt;h * 3;
+
+    return hashmap_insert(bitmap_cache, key, val);
 }
 
 /**
  * \brief Get a bitmap from bitmap cache.
  * \param key hash key
  * \return requested hash val or 0 if not found
-*/ 
-bitmap_hash_val_t* cache_find_bitmap(bitmap_hash_key_t* key)
+*/
+BitmapHashValue *cache_find_bitmap(Hashmap *bitmap_cache,
+                                   BitmapHashKey *key)
 {
-	return hashmap_find(bitmap_cache, key);
+    return hashmap_find(bitmap_cache, key);
 }
 
-void ass_bitmap_cache_init(void)
+Hashmap *ass_bitmap_cache_init(ASS_Library *library)
 {
-	bitmap_cache = hashmap_init(sizeof(bitmap_hash_key_t),
-				   sizeof(bitmap_hash_val_t),
-				   0xFFFF + 13,
-				   bitmap_hash_dtor, NULL, NULL);
+    Hashmap *bitmap_cache;
+    bitmap_cache = hashmap_init(library,
+                                sizeof(BitmapHashKey),
+                                sizeof(BitmapHashValue),
+                                0xFFFF + 13,
+                                bitmap_hash_dtor, bitmap_compare,
+                                bitmap_hash);
+    return bitmap_cache;
 }
 
-void ass_bitmap_cache_done(void)
+void ass_bitmap_cache_done(Hashmap *bitmap_cache)
 {
-	hashmap_done(bitmap_cache);
+    hashmap_done(bitmap_cache);
 }
 
-void ass_bitmap_cache_reset(void)
+Hashmap *ass_bitmap_cache_reset(Hashmap *bitmap_cache)
 {
-	ass_bitmap_cache_done();
-	ass_bitmap_cache_init();
+    ASS_Library *lib = bitmap_cache-&gt;library;
+
+    ass_bitmap_cache_done(bitmap_cache);
+    return ass_bitmap_cache_init(lib);
 }
 
 //---------------------------------
 // glyph cache
 
-hashmap_t* glyph_cache;
-
-static void glyph_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
+static void glyph_hash_dtor(void *key, size_t key_size, void *value,
+                            size_t value_size)
 {
-	glyph_hash_val_t* v = value;
-	if (v-&gt;glyph) FT_Done_Glyph(v-&gt;glyph);
-	if (v-&gt;outline_glyph) FT_Done_Glyph(v-&gt;outline_glyph);
-	free(key);
-	free(value);
+    GlyphHashValue *v = value;
+    if (v-&gt;glyph)
+        FT_Done_Glyph(v-&gt;glyph);
+    if (v-&gt;outline_glyph)
+        FT_Done_Glyph(v-&gt;outline_glyph);
+    free(key);
+    free(value);
 }
 
-void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val)
+void *cache_add_glyph(Hashmap *glyph_cache, GlyphHashKey *key,
+                      GlyphHashValue *val)
 {
-	return hashmap_insert(glyph_cache, key, val);
+	if (val-&gt;glyph &amp;&amp; val-&gt;glyph-&gt;format == FT_GLYPH_FORMAT_BITMAP) {
+		FT_Bitmap *bitmap = &amp;((FT_BitmapGlyph) val-&gt;glyph)-&gt;bitmap;
+		glyph_cache-&gt;cache_size += bitmap-&gt;rows * bitmap-&gt;pitch;
+	}
+
+    return hashmap_insert(glyph_cache, key, val);
 }
 
 /**
  * \brief Get a glyph from glyph cache.
  * \param key hash key
  * \return requested hash val or 0 if not found
-*/ 
-glyph_hash_val_t* cache_find_glyph(glyph_hash_key_t* key)
+*/
+GlyphHashValue *cache_find_glyph(Hashmap *glyph_cache,
+                                 GlyphHashKey *key)
 {
-	return hashmap_find(glyph_cache, key);
+    return hashmap_find(glyph_cache, key);
 }
 
-void ass_glyph_cache_init(void)
+Hashmap *ass_glyph_cache_init(ASS_Library *library)
 {
-	glyph_cache = hashmap_init(sizeof(glyph_hash_key_t),
-				   sizeof(glyph_hash_val_t),
-				   0xFFFF + 13,
-				   glyph_hash_dtor, NULL, NULL);
+    Hashmap *glyph_cache;
+    glyph_cache = hashmap_init(library, sizeof(GlyphHashKey),
+                               sizeof(GlyphHashValue),
+                               0xFFFF + 13,
+                               glyph_hash_dtor, glyph_compare, glyph_hash);
+    return glyph_cache;
 }
 
-void ass_glyph_cache_done(void)
+void ass_glyph_cache_done(Hashmap *glyph_cache)
 {
-	hashmap_done(glyph_cache);
+    hashmap_done(glyph_cache);
 }
 
-void ass_glyph_cache_reset(void)
+Hashmap *ass_glyph_cache_reset(Hashmap *glyph_cache)
 {
-	ass_glyph_cache_done();
-	ass_glyph_cache_init();
+    ASS_Library *lib = glyph_cache-&gt;library;
+
+    ass_glyph_cache_done(glyph_cache);
+    return ass_glyph_cache_init(lib);
 }
+
+
+//---------------------------------
+// composite cache
+
+static void composite_hash_dtor(void *key, size_t key_size, void *value,
+                                size_t value_size)
+{
+    CompositeHashValue *v = value;
+    free(v-&gt;a);
+    free(v-&gt;b);
+    free(key);
+    free(value);
+}
+
+void *cache_add_composite(Hashmap *composite_cache,
+                          CompositeHashKey *key,
+                          CompositeHashValue *val)
+{
+    return hashmap_insert(composite_cache, key, val);
+}
+
+/**
+ * \brief Get a composite bitmap from composite cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/
+CompositeHashValue *cache_find_composite(Hashmap *composite_cache,
+                                         CompositeHashKey *key)
+{
+    return hashmap_find(composite_cache, key);
+}
+
+Hashmap *ass_composite_cache_init(ASS_Library *library)
+{
+    Hashmap *composite_cache;
+    composite_cache = hashmap_init(library, sizeof(CompositeHashKey),
+                                   sizeof(CompositeHashValue),
+                                   0xFFFF + 13,
+                                   composite_hash_dtor, composite_compare,
+                                   composite_hash);
+    return composite_cache;
+}
+
+void ass_composite_cache_done(Hashmap *composite_cache)
+{
+    hashmap_done(composite_cache);
+}
+
+Hashmap *ass_composite_cache_reset(Hashmap *composite_cache)
+{
+    ASS_Library *lib = composite_cache-&gt;library;
+
+    ass_composite_cache_done(composite_cache);
+    return ass_composite_cache_init(lib);
+}

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.h	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,98 +1,119 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#ifndef LIBASS_CACHE_H
+#define LIBASS_CACHE_H
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
+#include &quot;ass.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_bitmap.h&quot;
 
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
+typedef void (*HashmapItemDtor) (void *key, size_t key_size,
+                                 void *value, size_t value_size);
+typedef int (*HashmapKeyCompare) (void *key1, void *key2,
+                                  size_t key_size);
+typedef unsigned (*HashmapHash) (void *key, size_t key_size);
 
-#ifndef ASS_CACHE_H
-#define ASS_CACHE_H
+typedef struct hashmap_item {
+    void *key;
+    void *value;
+    struct hashmap_item *next;
+} HashmapItem;
+typedef HashmapItem *hashmap_item_p;
 
-void ass_font_cache_init(void);
-ass_font_t* ass_font_cache_find(ass_font_desc_t* desc);
-void* ass_font_cache_add(ass_font_t* font);
-void ass_font_cache_done(void);
+typedef struct {
+    int nbuckets;
+    size_t key_size, value_size;
+    hashmap_item_p *root;
+    HashmapItemDtor item_dtor;      // a destructor for hashmap key/value pairs
+    HashmapKeyCompare key_compare;
+    HashmapHash hash;
+    size_t cache_size;
+    // stats
+    int hit_count;
+    int miss_count;
+    int count;
+    ASS_Library *library;
+} Hashmap;
 
+Hashmap *hashmap_init(ASS_Library *library, size_t key_size,
+                      size_t value_size, int nbuckets,
+                      HashmapItemDtor item_dtor,
+                      HashmapKeyCompare key_compare,
+                      HashmapHash hash);
+void hashmap_done(Hashmap *map);
+void *hashmap_insert(Hashmap *map, void *key, void *value);
+void *hashmap_find(Hashmap *map, void *key);
 
-// describes a bitmap; bitmaps with equivalents structs are considered identical
-typedef struct bitmap_hash_key_s {
-	char bitmap; // bool : true = bitmap, false = outline
-	ass_font_t* font;
-	double size; // font size
-	uint32_t ch; // character code
-	unsigned outline; // border width, 16.16 fixed point value
-	int bold, italic;
-	char be; // blur edges
+Hashmap *ass_font_cache_init(ASS_Library *library);
+ASS_Font *ass_font_cache_find(Hashmap *, ASS_FontDesc *desc);
+void *ass_font_cache_add(Hashmap *, ASS_Font *font);
+void ass_font_cache_done(Hashmap *);
 
-	unsigned scale_x, scale_y; // 16.16
-	int frx, fry, frz; // signed 16.16
-	int shift_x, shift_y; // shift vector that was added to glyph before applying rotation
-	                      // = 0, if frx = fry = frx = 0
-	                      // = (glyph base point) - (rotation origin), otherwise
-	
-	FT_Vector advance; // subpixel shift vector
-} bitmap_hash_key_t;
+// Create definitions for bitmap_hash_key and glyph_hash_key
+#define CREATE_STRUCT_DEFINITIONS
+#include &quot;ass_cache_template.h&quot;
 
-typedef struct bitmap_hash_val_s {
-	bitmap_t* bm; // the actual bitmaps
-	bitmap_t* bm_o;
-	bitmap_t* bm_s;
-} bitmap_hash_val_t;
+typedef struct {
+    Bitmap *bm;               // the actual bitmaps
+    Bitmap *bm_o;
+    Bitmap *bm_s;
+} BitmapHashValue;
 
-void ass_bitmap_cache_init(void);
-void* cache_add_bitmap(bitmap_hash_key_t* key, bitmap_hash_val_t* val);
-bitmap_hash_val_t* cache_find_bitmap(bitmap_hash_key_t* key);
-void ass_bitmap_cache_reset(void);
-void ass_bitmap_cache_done(void);
+Hashmap *ass_bitmap_cache_init(ASS_Library *library);
+void *cache_add_bitmap(Hashmap *, BitmapHashKey *key,
+                       BitmapHashValue *val);
+BitmapHashValue *cache_find_bitmap(Hashmap *bitmap_cache,
+                                   BitmapHashKey *key);
+Hashmap *ass_bitmap_cache_reset(Hashmap *bitmap_cache);
+void ass_bitmap_cache_done(Hashmap *bitmap_cache);
 
-// describes an outline glyph
-typedef struct glyph_hash_key_s {
-	ass_font_t* font;
-	double size; // font size
-	uint32_t ch; // character code
-	int bold, italic;
-	unsigned scale_x, scale_y; // 16.16
-	FT_Vector advance; // subpixel shift vector
-	unsigned outline; // border width, 16.16
-} glyph_hash_key_t;
 
-typedef struct glyph_hash_val_s {
-	FT_Glyph glyph;
-	FT_Glyph outline_glyph;
-	FT_BBox bbox_scaled; // bbox after scaling, but before rotation
-	FT_Vector advance; // 26.6, advance distance to the next bitmap in line
-} glyph_hash_val_t;
+typedef struct {
+    unsigned char *a;
+    unsigned char *b;
+} CompositeHashValue;
 
-void ass_glyph_cache_init(void);
-void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val);
-glyph_hash_val_t* cache_find_glyph(glyph_hash_key_t* key);
-void ass_glyph_cache_reset(void);
-void ass_glyph_cache_done(void);
+Hashmap *ass_composite_cache_init(ASS_Library *library);
+void *cache_add_composite(Hashmap *, CompositeHashKey *key,
+                          CompositeHashValue *val);
+CompositeHashValue *cache_find_composite(Hashmap *composite_cache,
+                                         CompositeHashKey *key);
+Hashmap *ass_composite_cache_reset(Hashmap *composite_cache);
+void ass_composite_cache_done(Hashmap *composite_cache);
 
-typedef struct hashmap_s hashmap_t; 
-typedef void (*hashmap_item_dtor_t)(void* key, size_t key_size, void* value, size_t value_size);
-typedef int (*hashmap_key_compare_t)(void* key1, void* key2, size_t key_size);
-typedef unsigned (*hashmap_hash_t)(void* key, size_t key_size);
 
-hashmap_t* hashmap_init(size_t key_size, size_t value_size, int nbuckets,
-			hashmap_item_dtor_t item_dtor, hashmap_key_compare_t key_compare,
-			hashmap_hash_t hash);
-void hashmap_done(hashmap_t* map);
-void* hashmap_insert(hashmap_t* map, void* key, void* value);
-void* hashmap_find(hashmap_t* map, void* key);
+typedef struct {
+    FT_Glyph glyph;
+    FT_Glyph outline_glyph;
+    FT_BBox bbox_scaled;        // bbox after scaling, but before rotation
+    FT_Vector advance;          // 26.6, advance distance to the next bitmap in line
+    int asc, desc;              // ascender/descender of a drawing
+} GlyphHashValue;
 
-#endif
+Hashmap *ass_glyph_cache_init(ASS_Library *library);
+void *cache_add_glyph(Hashmap *, GlyphHashKey *key,
+                      GlyphHashValue *val);
+GlyphHashValue *cache_find_glyph(Hashmap *glyph_cache,
+                                 GlyphHashKey *key);
+Hashmap *ass_glyph_cache_reset(Hashmap *glyph_cache);
+void ass_glyph_cache_done(Hashmap *glyph_cache);
 
+#endif                          /* LIBASS_CACHE_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache_template.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache_template.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache_template.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -0,0 +1,122 @@
+#ifdef CREATE_STRUCT_DEFINITIONS
+#undef CREATE_STRUCT_DEFINITIONS
+#define START(funcname, structname) \
+    typedef struct structname {
+#define GENERIC(type, member) \
+        type member;
+#define FTVECTOR(member) \
+        FT_Vector member;
+#define BITMAPHASHKEY(member) \
+        BitmapHashKey member;
+#define END(typedefnamename) \
+    } typedefnamename;
+
+#elif defined(CREATE_COMPARISON_FUNCTIONS)
+#undef CREATE_COMPARISON_FUNCTIONS
+#define START(funcname, structname) \
+    static int funcname##_compare(void *key1, void *key2, size_t key_size) \
+    { \
+        struct structname *a = key1; \
+        struct structname *b = key2; \
+        return // conditions follow
+#define GENERIC(type, member) \
+            a-&gt;member == b-&gt;member &amp;&amp;
+#define FTVECTOR(member) \
+            a-&gt;member.x == b-&gt;member.x &amp;&amp; a-&gt;member.y == b-&gt;member.y &amp;&amp;
+#define BITMAPHASHKEY(member) \
+            bitmap_compare(&amp;a-&gt;member, &amp;b-&gt;member, sizeof(a-&gt;member)) &amp;&amp;
+#define END(typedefname) \
+            1; \
+    }
+
+#elif defined(CREATE_HASH_FUNCTIONS)
+#undef CREATE_HASH_FUNCTIONS
+#define START(funcname, structname) \
+    static unsigned funcname##_hash(void *buf, size_t len) \
+    { \
+        struct structname *p = buf; \
+        unsigned hval = FNV1_32A_INIT;
+#define GENERIC(type, member) \
+        hval = fnv_32a_buf(&amp;p-&gt;member, sizeof(p-&gt;member), hval);
+#define FTVECTOR(member) GENERIC(, member.x); GENERIC(, member.y);
+#define BITMAPHASHKEY(member) { \
+        unsigned temp = bitmap_hash(&amp;p-&gt;member, sizeof(p-&gt;member)); \
+        hval = fnv_32a_buf(&amp;temp, sizeof(temp), hval); \
+        }
+#define END(typedefname) \
+        return hval; \
+    }
+
+#else
+#error missing defines
+#endif
+
+
+
+// describes a bitmap; bitmaps with equivalents structs are considered identical
+START(bitmap, bitmap_hash_key)
+    GENERIC(char, bitmap) // bool : true = bitmap, false = outline
+    GENERIC(ASS_Font *, font)
+    GENERIC(double, size) // font size
+    GENERIC(uint32_t, ch) // character code
+    FTVECTOR(outline) // border width, 16.16 fixed point value
+    GENERIC(int, bold)
+    GENERIC(int, italic)
+    GENERIC(char, be) // blur edges
+    GENERIC(double, blur) // gaussian blur
+    GENERIC(unsigned, scale_x) // 16.16
+    GENERIC(unsigned, scale_y) // 16.16
+    GENERIC(int, frx) // signed 16.16
+    GENERIC(int, fry) // signed 16.16
+    GENERIC(int, frz) // signed 16.16
+    GENERIC(int, fax) // signed 16.16
+    GENERIC(int, fay) // signed 16.16
+    // shift vector that was added to glyph before applying rotation
+    // = 0, if frx = fry = frx = 0
+    // = (glyph base point) - (rotation origin), otherwise
+    GENERIC(int, shift_x)
+    GENERIC(int, shift_y)
+    FTVECTOR(advance) // subpixel shift vector
+    FTVECTOR(shadow_offset) // shadow subpixel shift
+    GENERIC(unsigned, drawing_hash) // hashcode of a drawing
+    GENERIC(unsigned, flags)    // glyph decoration
+    GENERIC(unsigned, border_style)
+END(BitmapHashKey)
+
+// describes an outline glyph
+START(glyph, glyph_hash_key)
+    GENERIC(ASS_Font *, font)
+    GENERIC(double, size) // font size
+    GENERIC(uint32_t, ch) // character code
+    GENERIC(int, bold)
+    GENERIC(int, italic)
+    GENERIC(unsigned, scale_x) // 16.16
+    GENERIC(unsigned, scale_y) // 16.16
+    FTVECTOR(outline) // border width, 16.16
+    GENERIC(unsigned, drawing_hash) // hashcode of a drawing
+    GENERIC(unsigned, flags)    // glyph decoration flags
+    GENERIC(unsigned, border_style)
+END(GlyphHashKey)
+
+// Cache for composited bitmaps
+START(composite, composite_hash_key)
+    GENERIC(int, aw)
+    GENERIC(int, ah)
+    GENERIC(int, bw)
+    GENERIC(int, bh)
+    GENERIC(int, ax)
+    GENERIC(int, ay)
+    GENERIC(int, bx)
+    GENERIC(int, by)
+    GENERIC(int, as)
+    GENERIC(int, bs)
+    GENERIC(unsigned char *, a)
+    GENERIC(unsigned char *, b)
+END(CompositeHashKey)
+
+
+#undef START
+#undef GENERIC
+#undef FTVECTOR
+#undef BITMAPHASHKEY
+#undef END

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_drawing.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_drawing.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_drawing.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -0,0 +1,488 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at geekmind.org</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
+#include FT_OUTLINE_H
+#include FT_BBOX_H
+#include &lt;math.h&gt;
+
+#include &quot;ass_utils.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_drawing.h&quot;
+
+#define CURVE_ACCURACY 64.0
+#define GLYPH_INITIAL_POINTS 100
+#define GLYPH_INITIAL_CONTOURS 5
+
+/*
+ * \brief Get and prepare a FreeType glyph
+ */
+static void drawing_make_glyph(ASS_Drawing *drawing, void *fontconfig_priv,
+                               ASS_Font *font)
+{
+    FT_OutlineGlyph glyph;
+
+    // This is hacky...
+    glyph = (FT_OutlineGlyph) ass_font_get_glyph(fontconfig_priv, font,
+                                                 (uint32_t) ' ', 0, 0);
+    if (glyph) {
+        FT_Outline_Done(drawing-&gt;ftlibrary, &amp;glyph-&gt;outline);
+        FT_Outline_New(drawing-&gt;ftlibrary, GLYPH_INITIAL_POINTS,
+                       GLYPH_INITIAL_CONTOURS, &amp;glyph-&gt;outline);
+
+        glyph-&gt;outline.n_contours = 0;
+        glyph-&gt;outline.n_points = 0;
+        glyph-&gt;root.advance.x = glyph-&gt;root.advance.y = 0;
+    }
+    drawing-&gt;glyph = glyph;
+}
+
+/*
+ * \brief Add a single point to a contour.
+ */
+static inline void drawing_add_point(ASS_Drawing *drawing,
+                                     FT_Vector *point)
+{
+    FT_Outline *ol = &amp;drawing-&gt;glyph-&gt;outline;
+
+    if (ol-&gt;n_points &gt;= drawing-&gt;max_points) {
+        drawing-&gt;max_points *= 2;
+        ol-&gt;points = realloc(ol-&gt;points, sizeof(FT_Vector) *
+                             drawing-&gt;max_points);
+        ol-&gt;tags = realloc(ol-&gt;tags, drawing-&gt;max_points);
+    }
+
+    ol-&gt;points[ol-&gt;n_points].x = point-&gt;x;
+    ol-&gt;points[ol-&gt;n_points].y = point-&gt;y;
+    ol-&gt;tags[ol-&gt;n_points] = 1;
+    ol-&gt;n_points++;
+}
+
+/*
+ * \brief Close a contour and check glyph size overflow.
+ */
+static inline void drawing_close_shape(ASS_Drawing *drawing)
+{
+    FT_Outline *ol = &amp;drawing-&gt;glyph-&gt;outline;
+
+    if (ol-&gt;n_contours &gt;= drawing-&gt;max_contours) {
+        drawing-&gt;max_contours *= 2;
+        ol-&gt;contours = realloc(ol-&gt;contours, sizeof(short) *
+                               drawing-&gt;max_contours);
+    }
+
+    if (ol-&gt;n_points) {
+        ol-&gt;contours[ol-&gt;n_contours] = ol-&gt;n_points - 1;
+        ol-&gt;n_contours++;
+    }
+}
+
+/*
+ * \brief Prepare drawing for parsing.  This just sets a few parameters.
+ */
+static void drawing_prepare(ASS_Drawing *drawing)
+{
+    // Scaling parameters
+    drawing-&gt;point_scale_x = drawing-&gt;scale_x *
+                             64.0 / (1 &lt;&lt; (drawing-&gt;scale - 1));
+    drawing-&gt;point_scale_y = drawing-&gt;scale_y *
+                             64.0 / (1 &lt;&lt; (drawing-&gt;scale - 1));
+}
+
+/*
+ * \brief Finish a drawing.  This only sets the horizontal advance according
+ * to the glyph's bbox at the moment.
+ */
+static void drawing_finish(ASS_Drawing *drawing, int raw_mode)
+{
+    int i, offset;
+    FT_BBox bbox = drawing-&gt;cbox;
+    FT_Outline *ol = &amp;drawing-&gt;glyph-&gt;outline;
+
+    // Close the last contour
+    drawing_close_shape(drawing);
+
+    ass_msg(drawing-&gt;library, MSGL_V,
+            &quot;Parsed drawing with %d points and %d contours&quot;, ol-&gt;n_points,
+            ol-&gt;n_contours);
+
+    if (raw_mode)
+        return;
+
+    drawing-&gt;glyph-&gt;root.advance.x = d6_to_d16(bbox.xMax - bbox.xMin);
+
+    drawing-&gt;desc = double_to_d6(-drawing-&gt;pbo * drawing-&gt;scale_y);
+    drawing-&gt;asc = bbox.yMax - bbox.yMin + drawing-&gt;desc;
+
+    // Place it onto the baseline
+    offset = (bbox.yMax - bbox.yMin) + double_to_d6(-drawing-&gt;pbo *
+                                                    drawing-&gt;scale_y);
+    for (i = 0; i &lt; ol-&gt;n_points; i++)
+        ol-&gt;points[i].y += offset;
+}
+
+/*
+ * \brief Check whether a number of items on the list is available
+ */
+static int token_check_values(ASS_DrawingToken *token, int i, int type)
+{
+    int j;
+    for (j = 0; j &lt; i; j++) {
+        if (!token || token-&gt;type != type) return 0;
+        token = token-&gt;next;
+    }
+
+    return 1;
+}
+
+/*
+ * \brief Tokenize a drawing string into a list of ASS_DrawingToken
+ * This also expands points for closing b-splines
+ */
+static ASS_DrawingToken *drawing_tokenize(char *str)
+{
+    char *p = str;
+    int i, val, type = -1, is_set = 0;
+    FT_Vector point = {0, 0};
+
+    ASS_DrawingToken *root = NULL, *tail = NULL, *spline_start = NULL;
+
+    while (*p) {
+        if (*p == 'c' &amp;&amp; spline_start) {
+            // Close b-splines: add the first three points of the b-spline
+            // back to the end
+            if (token_check_values(spline_start-&gt;next, 2, TOKEN_B_SPLINE)) {
+                for (i = 0; i &lt; 3; i++) {
+                    tail-&gt;next = calloc(1, sizeof(ASS_DrawingToken));
+                    tail-&gt;next-&gt;prev = tail;
+                    tail = tail-&gt;next;
+                    tail-&gt;type = TOKEN_B_SPLINE;
+                    tail-&gt;point = spline_start-&gt;point;
+                    spline_start = spline_start-&gt;next;
+                }
+                spline_start = NULL;
+            }
+        } else if (!is_set &amp;&amp; mystrtoi(&amp;p, &amp;val)) {
+            point.x = val;
+            is_set = 1;
+            p--;
+        } else if (is_set == 1 &amp;&amp; mystrtoi(&amp;p, &amp;val)) {
+            point.y = val;
+            is_set = 2;
+            p--;
+        } else if (*p == 'm')
+            type = TOKEN_MOVE;
+        else if (*p == 'n')
+            type = TOKEN_MOVE_NC;
+        else if (*p == 'l')
+            type = TOKEN_LINE;
+        else if (*p == 'b')
+            type = TOKEN_CUBIC_BEZIER;
+        else if (*p == 'q')
+            type = TOKEN_CONIC_BEZIER;
+        else if (*p == 's')
+            type = TOKEN_B_SPLINE;
+        // We're simply ignoring TOKEN_EXTEND_B_SPLINE here.
+        // This is not harmful at all, since it can be ommitted with
+        // similar result (the spline is extended anyway).
+
+        if (type != -1 &amp;&amp; is_set == 2) {
+            if (root) {
+                tail-&gt;next = calloc(1, sizeof(ASS_DrawingToken));
+                tail-&gt;next-&gt;prev = tail;
+                tail = tail-&gt;next;
+            } else
+                root = tail = calloc(1, sizeof(ASS_DrawingToken));
+            tail-&gt;type = type;
+            tail-&gt;point = point;
+            is_set = 0;
+            if (type == TOKEN_B_SPLINE &amp;&amp; !spline_start)
+                spline_start = tail-&gt;prev;
+        }
+        p++;
+    }
+
+    return root;
+}
+
+/*
+ * \brief Free a list of tokens
+ */
+static void drawing_free_tokens(ASS_DrawingToken *token)
+{
+    while (token) {
+        ASS_DrawingToken *at = token;
+        token = token-&gt;next;
+        free(at);
+    }
+}
+
+/*
+ * \brief Update drawing cbox
+ */
+static inline void update_cbox(ASS_Drawing *drawing, FT_Vector *point)
+{
+    FT_BBox *box = &amp;drawing-&gt;cbox;
+
+    box-&gt;xMin = FFMIN(box-&gt;xMin, point-&gt;x);
+    box-&gt;xMax = FFMAX(box-&gt;xMax, point-&gt;x);
+    box-&gt;yMin = FFMIN(box-&gt;yMin, point-&gt;y);
+    box-&gt;yMax = FFMAX(box-&gt;yMax, point-&gt;y);
+}
+
+/*
+ * \brief Translate and scale a point coordinate according to baseline
+ * offset and scale.
+ */
+static inline void translate_point(ASS_Drawing *drawing, FT_Vector *point)
+{
+    point-&gt;x = drawing-&gt;point_scale_x * point-&gt;x;
+    point-&gt;y = drawing-&gt;point_scale_y * -point-&gt;y;
+
+    update_cbox(drawing, point);
+}
+
+/*
+ * \brief Evaluate a curve into lines
+ * This curve evaluator is also used in VSFilter (RTS.cpp); it's a simple
+ * implementation of the De Casteljau algorithm.
+ */
+static void drawing_evaluate_curve(ASS_Drawing *drawing,
+                                   ASS_DrawingToken *token, char spline,
+                                   int started)
+{
+    double cx3, cx2, cx1, cx0, cy3, cy2, cy1, cy0;
+    double t, h, max_accel, max_accel1, max_accel2;
+    FT_Vector cur = {0, 0};
+
+    cur = token-&gt;point;
+    translate_point(drawing, &amp;cur);
+    int x0 = cur.x;
+    int y0 = cur.y;
+    token = token-&gt;next;
+    cur = token-&gt;point;
+    translate_point(drawing, &amp;cur);
+    int x1 = cur.x;
+    int y1 = cur.y;
+    token = token-&gt;next;
+    cur = token-&gt;point;
+    translate_point(drawing, &amp;cur);
+    int x2 = cur.x;
+    int y2 = cur.y;
+    token = token-&gt;next;
+    cur = token-&gt;point;
+    translate_point(drawing, &amp;cur);
+    int x3 = cur.x;
+    int y3 = cur.y;
+
+    if (spline) {
+        // 1   [-1 +3 -3 +1]
+        // - * [+3 -6 +3  0]
+        // 6   [-3  0 +3  0]
+        //	   [+1 +4 +1  0]
+
+        double div6 = 1.0/6.0;
+
+        cx3 = div6*(-  x0+3*x1-3*x2+x3);
+        cx2 = div6*( 3*x0-6*x1+3*x2);
+        cx1 = div6*(-3*x0	   +3*x2);
+        cx0 = div6*(   x0+4*x1+1*x2);
+
+        cy3 = div6*(-  y0+3*y1-3*y2+y3);
+        cy2 = div6*( 3*y0-6*y1+3*y2);
+        cy1 = div6*(-3*y0     +3*y2);
+        cy0 = div6*(   y0+4*y1+1*y2);
+    } else {
+        // [-1 +3 -3 +1]
+        // [+3 -6 +3  0]
+        // [-3 +3  0  0]
+        // [+1  0  0  0]
+
+        cx3 = -  x0+3*x1-3*x2+x3;
+        cx2 =  3*x0-6*x1+3*x2;
+        cx1 = -3*x0+3*x1;
+        cx0 =    x0;
+
+        cy3 = -  y0+3*y1-3*y2+y3;
+        cy2 =  3*y0-6*y1+3*y2;
+        cy1 = -3*y0+3*y1;
+        cy0 =    y0;
+    }
+
+    max_accel1 = fabs(2 * cy2) + fabs(6 * cy3);
+    max_accel2 = fabs(2 * cx2) + fabs(6 * cx3);
+
+    max_accel = FFMAX(max_accel1, max_accel2);
+    h = 1.0;
+
+    if (max_accel &gt; CURVE_ACCURACY)
+        h = sqrt(CURVE_ACCURACY / max_accel);
+
+    if (!started) {
+        cur.x = cx0;
+        cur.y = cy0;
+        drawing_add_point(drawing, &amp;cur);
+    }
+
+    for (t = 0; t &lt; 1.0; t += h) {
+        cur.x = cx0 + t * (cx1 + t * (cx2 + t * cx3));
+        cur.y = cy0 + t * (cy1 + t * (cy2 + t * cy3));
+        drawing_add_point(drawing, &amp;cur);
+    }
+
+    cur.x = cx0 + cx1 + cx2 + cx3;
+    cur.y = cy0 + cy1 + cy2 + cy3;
+    drawing_add_point(drawing, &amp;cur);
+}
+
+/*
+ * \brief Create and initialize a new drawing and return it
+ */
+ASS_Drawing *ass_drawing_new(void *fontconfig_priv, ASS_Font *font,
+                             FT_Library lib)
+{
+    ASS_Drawing *drawing;
+
+    drawing = calloc(1, sizeof(*drawing));
+    drawing-&gt;text = calloc(1, DRAWING_INITIAL_SIZE);
+    drawing-&gt;size = DRAWING_INITIAL_SIZE;
+    drawing-&gt;cbox.xMin = drawing-&gt;cbox.yMin = INT_MAX;
+    drawing-&gt;cbox.xMax = drawing-&gt;cbox.yMax = INT_MIN;
+    drawing-&gt;fontconfig_priv = fontconfig_priv;
+    drawing-&gt;font = font;
+    drawing-&gt;ftlibrary = lib;
+    drawing-&gt;library = font-&gt;library;
+
+    drawing-&gt;scale_x = 1.;
+    drawing-&gt;scale_y = 1.;
+    drawing-&gt;max_contours = GLYPH_INITIAL_CONTOURS;
+    drawing-&gt;max_points = GLYPH_INITIAL_POINTS;
+
+    return drawing;
+}
+
+/*
+ * \brief Free a drawing
+ */
+void ass_drawing_free(ASS_Drawing* drawing)
+{
+    if (drawing) {
+        free(drawing-&gt;text);
+    }
+    free(drawing);
+}
+
+/*
+ * \brief Add one ASCII character to the drawing text buffer
+ */
+void ass_drawing_add_char(ASS_Drawing* drawing, char symbol)
+{
+    drawing-&gt;text[drawing-&gt;i++] = symbol;
+    drawing-&gt;text[drawing-&gt;i] = 0;
+
+    if (drawing-&gt;i + 1 &gt;= drawing-&gt;size) {
+        drawing-&gt;size *= 2;
+        drawing-&gt;text = realloc(drawing-&gt;text, drawing-&gt;size);
+    }
+}
+
+/*
+ * \brief Create a hashcode for the drawing
+ * XXX: To avoid collisions a better hash algorithm might be useful.
+ */
+void ass_drawing_hash(ASS_Drawing* drawing)
+{
+    drawing-&gt;hash = fnv_32a_str(drawing-&gt;text, FNV1_32A_INIT);
+}
+
+/*
+ * \brief Convert token list to outline.  Calls the line and curve evaluators.
+ */
+FT_OutlineGlyph *ass_drawing_parse(ASS_Drawing *drawing, int raw_mode)
+{
+    int started = 0;
+    ASS_DrawingToken *token;
+    FT_Vector pen = {0, 0};
+
+    if (drawing-&gt;font)
+        drawing_make_glyph(drawing, drawing-&gt;fontconfig_priv, drawing-&gt;font);
+    if (!drawing-&gt;glyph)
+        return NULL;
+
+    drawing-&gt;tokens = drawing_tokenize(drawing-&gt;text);
+    drawing_prepare(drawing);
+
+    token = drawing-&gt;tokens;
+    while (token) {
+        // Draw something according to current command
+        switch (token-&gt;type) {
+        case TOKEN_MOVE_NC:
+            pen = token-&gt;point;
+            translate_point(drawing, &amp;pen);
+            token = token-&gt;next;
+            break;
+        case TOKEN_MOVE:
+            pen = token-&gt;point;
+            translate_point(drawing, &amp;pen);
+            if (started) {
+                drawing_close_shape(drawing);
+                started = 0;
+            }
+            token = token-&gt;next;
+            break;
+        case TOKEN_LINE: {
+            FT_Vector to;
+            to = token-&gt;point;
+            translate_point(drawing, &amp;to);
+            if (!started) drawing_add_point(drawing, &amp;pen);
+            drawing_add_point(drawing, &amp;to);
+            started = 1;
+            token = token-&gt;next;
+            break;
+        }
+        case TOKEN_CUBIC_BEZIER:
+            if (token_check_values(token, 3, TOKEN_CUBIC_BEZIER) &amp;&amp;
+                token-&gt;prev) {
+                drawing_evaluate_curve(drawing, token-&gt;prev, 0, started);
+                token = token-&gt;next;
+                token = token-&gt;next;
+                token = token-&gt;next;
+                started = 1;
+            } else
+                token = token-&gt;next;
+            break;
+        case TOKEN_B_SPLINE:
+            if (token_check_values(token, 3, TOKEN_B_SPLINE) &amp;&amp;
+                token-&gt;prev) {
+                drawing_evaluate_curve(drawing, token-&gt;prev, 1, started);
+                token = token-&gt;next;
+                started = 1;
+            } else
+                token = token-&gt;next;
+            break;
+        default:
+            token = token-&gt;next;
+            break;
+        }
+    }
+
+    drawing_finish(drawing, raw_mode);
+    drawing_free_tokens(drawing-&gt;tokens);
+    return &amp;drawing-&gt;glyph;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_drawing.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_drawing.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_drawing.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at geekmind.org</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef LIBASS_DRAWING_H
+#define LIBASS_DRAWING_H
+
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
+
+#include &quot;ass.h&quot;
+
+#define DRAWING_INITIAL_SIZE 256
+
+typedef enum {
+    TOKEN_MOVE,
+    TOKEN_MOVE_NC,
+    TOKEN_LINE,
+    TOKEN_CUBIC_BEZIER,
+    TOKEN_CONIC_BEZIER,
+    TOKEN_B_SPLINE,
+    TOKEN_EXTEND_SPLINE,
+    TOKEN_CLOSE
+} ASS_TokenType;
+
+typedef struct ass_drawing_token {
+    ASS_TokenType type;
+    FT_Vector point;
+    struct ass_drawing_token *next;
+    struct ass_drawing_token *prev;
+} ASS_DrawingToken;
+
+typedef struct {
+    char *text; // drawing string
+    int i;      // text index
+    int scale;  // scale (1-64) for subpixel accuracy
+    double pbo; // drawing will be shifted in y direction by this amount
+    double scale_x;     // FontScaleX
+    double scale_y;     // FontScaleY
+    int asc;            // ascender
+    int desc;           // descender
+    FT_OutlineGlyph glyph;  // the &quot;fake&quot; glyph created for later rendering
+    int hash;           // hash value (for caching)
+
+    // private
+    FT_Library ftlibrary;   // needed for font ops
+    ASS_Font *font;         // dito
+    void *fontconfig_priv;  // dito
+    ASS_Library *library;
+    int size;           // current buffer size
+    ASS_DrawingToken *tokens;    // tokenized drawing
+    int max_points;     // current maximum size
+    int max_contours;
+    double point_scale_x;
+    double point_scale_y;
+    FT_BBox cbox;   // bounding box, or let's say... VSFilter's idea of it
+} ASS_Drawing;
+
+ASS_Drawing *ass_drawing_new(void *fontconfig_priv, ASS_Font *font,
+                             FT_Library lib);
+void ass_drawing_free(ASS_Drawing* drawing);
+void ass_drawing_add_char(ASS_Drawing* drawing, char symbol);
+void ass_drawing_hash(ASS_Drawing* drawing);
+FT_OutlineGlyph *ass_drawing_parse(ASS_Drawing *drawing, int raw_mode);
+
+#endif /* LIBASS_DRAWING_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.c	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,31 +1,33 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#include &quot;ADM_coreConfig.h&quot;
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include &quot;config.h&quot;
-
 #include &lt;inttypes.h&gt;
 #include &lt;ft2build.h&gt;
 #include FT_FREETYPE_H
 #include FT_SYNTHESIS_H
 #include FT_GLYPH_H
 #include FT_TRUETYPE_TABLES_H
+#include FT_OUTLINE_H
+#include &lt;strings.h&gt;
 
 #include &quot;ass.h&quot;
 #include &quot;ass_library.h&quot;
@@ -34,207 +36,225 @@
 #include &quot;ass_cache.h&quot;
 #include &quot;ass_fontconfig.h&quot;
 #include &quot;ass_utils.h&quot;
-#include &quot;mputils.h&quot;
 
+#define VERTICAL_LOWER_BOUND 0x02f1
+
 /**
- * Select Microfost Unicode CharMap, if the font has one.
+ * Select a good charmap, prefer Microsoft Unicode charmaps.
  * Otherwise, let FreeType decide.
  */
-static void charmap_magic(FT_Face face)
+static void charmap_magic(ASS_Library *library, FT_Face face)
 {
-	int i;
-	for (i = 0; i &lt; face-&gt;num_charmaps; ++i) {
-		FT_CharMap cmap = face-&gt;charmaps[i];
-		unsigned pid = cmap-&gt;platform_id;
-		unsigned eid = cmap-&gt;encoding_id;
-		if (pid == 3 /*microsoft*/ &amp;&amp; (eid == 1 /*unicode bmp*/ || eid == 10 /*full unicode*/)) {
-			FT_Set_Charmap(face, cmap);
-			return;
-		}
-	}
+    int i;
+    int ms_cmap = -1;
 
-	if (!face-&gt;charmap) {
-		if (face-&gt;num_charmaps == 0) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoCharmaps);
-			return;
-		}
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoCharmapAutodetected);
-		FT_Set_Charmap(face, face-&gt;charmaps[0]);
-		return;
-	}
-}
+    // Search for a Microsoft Unicode cmap
+    for (i = 0; i &lt; face-&gt;num_charmaps; ++i) {
+        FT_CharMap cmap = face-&gt;charmaps[i];
+        unsigned pid = cmap-&gt;platform_id;
+        unsigned eid = cmap-&gt;encoding_id;
+        if (pid == 3 /*microsoft */
+            &amp;&amp; (eid == 1 /*unicode bmp */
+                || eid == 10 /*full unicode */ )) {
+            FT_Set_Charmap(face, cmap);
+            return;
+        } else if (pid == 3 &amp;&amp; ms_cmap &lt; 0)
+            ms_cmap = i;
+    }
 
-static void update_transform(ass_font_t* font)
-{
-	int i;
-	FT_Matrix m;
-	m.xx = double_to_d16(font-&gt;scale_x);
-	m.yy = double_to_d16(font-&gt;scale_y);
-	m.xy = m.yx = 0;
-	for (i = 0; i &lt; font-&gt;n_faces; ++i)
-		FT_Set_Transform(font-&gt;faces[i], &amp;m, &amp;font-&gt;v);
+    // Try the first Microsoft cmap if no Microsoft Unicode cmap was found
+    if (ms_cmap &gt;= 0) {
+        FT_CharMap cmap = face-&gt;charmaps[ms_cmap];
+        FT_Set_Charmap(face, cmap);
+        return;
+    }
+
+    if (!face-&gt;charmap) {
+        if (face-&gt;num_charmaps == 0) {
+            ass_msg(library, MSGL_WARN, &quot;Font face with no charmaps&quot;);
+            return;
+        }
+        ass_msg(library, MSGL_WARN,
+                &quot;No charmap autodetected, trying the first one&quot;);
+        FT_Set_Charmap(face, face-&gt;charmaps[0]);
+        return;
+    }
 }
 
 /**
  * \brief find a memory font by name
  */
-static int find_font(ass_library_t* library, char* name)
+static int find_font(ASS_Library *library, char *name)
 {
-	int i;
-	for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
-		if (strcasecmp(name, library-&gt;fontdata[i].name) == 0)
-			return i;
-	return -1;
+    int i;
+    for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
+        if (strcasecmp(name, library-&gt;fontdata[i].name) == 0)
+            return i;
+    return -1;
 }
 
 static void face_set_size(FT_Face face, double size);
 
 static void buggy_font_workaround(FT_Face face)
 {
-	// Some fonts have zero Ascender/Descender fields in 'hhea' table.
-	// In this case, get the information from 'os2' table or, as
-	// a last resort, from face.bbox.
-	if (face-&gt;ascender + face-&gt;descender == 0 || face-&gt;height == 0) {
-		TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
-		if (os2) {
-			face-&gt;ascender = os2-&gt;sTypoAscender;
-			face-&gt;descender = os2-&gt;sTypoDescender;
-			face-&gt;height = face-&gt;ascender - face-&gt;descender;
-		} else {
-			face-&gt;ascender = face-&gt;bbox.yMax;
-			face-&gt;descender = face-&gt;bbox.yMin;
-			face-&gt;height = face-&gt;ascender - face-&gt;descender;
-		}
-	}
+    // Some fonts have zero Ascender/Descender fields in 'hhea' table.
+    // In this case, get the information from 'os2' table or, as
+    // a last resort, from face.bbox.
+    if (face-&gt;ascender + face-&gt;descender == 0 || face-&gt;height == 0) {
+        TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+        if (os2) {
+            face-&gt;ascender = os2-&gt;sTypoAscender;
+            face-&gt;descender = os2-&gt;sTypoDescender;
+            face-&gt;height = face-&gt;ascender - face-&gt;descender;
+        } else {
+            face-&gt;ascender = face-&gt;bbox.yMax;
+            face-&gt;descender = face-&gt;bbox.yMin;
+            face-&gt;height = face-&gt;ascender - face-&gt;descender;
+        }
+    }
 }
 
 /**
- * \brief Select a face with the given charcode and add it to ass_font_t
+ * \brief Select a face with the given charcode and add it to ASS_Font
  * \return index of the new face in font-&gt;faces, -1 if failed
  */
-static int add_face(void* fc_priv, ass_font_t* font, uint32_t ch)
+static int add_face(void *fc_priv, ASS_Font *font, uint32_t ch)
 {
-	char* path;
-	int index;
-	FT_Face face;
-	int error;
-	int mem_idx;
-	
-	if (font-&gt;n_faces == ASS_FONT_MAX_FACES)
-		return -1;
-	
-	path = fontconfig_select(fc_priv, font-&gt;desc.family, font-&gt;desc.bold,
-					      font-&gt;desc.italic, &amp;index, ch);
+    char *path;
+    int index;
+    FT_Face face;
+    int error;
+    int mem_idx;
 
-	mem_idx = find_font(font-&gt;library, path);
-	if (mem_idx &gt;= 0) {
-		error = FT_New_Memory_Face(font-&gt;ftlibrary, (unsigned char*)font-&gt;library-&gt;fontdata[mem_idx].data,
-					   font-&gt;library-&gt;fontdata[mem_idx].size, 0, &amp;face);
-		if (error) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningMemoryFont, path);
-			return -1;
-		}
-	} else {
-		error = FT_New_Face(font-&gt;ftlibrary, path, index, &amp;face);
-		if (error) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningFont, path, index);
-			return -1;
-		}
-	}
-	charmap_magic(face);
-	buggy_font_workaround(face);
-	
-	font-&gt;faces[font-&gt;n_faces++] = face;
-	update_transform(font);
-	face_set_size(face, font-&gt;size);
-	return font-&gt;n_faces - 1;
+    if (font-&gt;n_faces == ASS_FONT_MAX_FACES)
+        return -1;
+
+    path =
+        fontconfig_select(font-&gt;library, fc_priv, font-&gt;desc.family,
+                          font-&gt;desc.treat_family_as_pattern,
+                          font-&gt;desc.bold, font-&gt;desc.italic, &amp;index, ch);
+    if (!path)
+        return -1;
+
+    mem_idx = find_font(font-&gt;library, path);
+    if (mem_idx &gt;= 0) {
+        error =
+            FT_New_Memory_Face(font-&gt;ftlibrary,
+                               (unsigned char *) font-&gt;library-&gt;
+                               fontdata[mem_idx].data,
+                               font-&gt;library-&gt;fontdata[mem_idx].size, index,
+                               &amp;face);
+        if (error) {
+            ass_msg(font-&gt;library, MSGL_WARN,
+                    &quot;Error opening memory font: '%s'&quot;, path);
+            free(path);
+            return -1;
+        }
+    } else {
+        error = FT_New_Face(font-&gt;ftlibrary, path, index, &amp;face);
+        if (error) {
+            ass_msg(font-&gt;library, MSGL_WARN,
+                    &quot;Error opening font: '%s', %d&quot;, path, index);
+            free(path);
+            return -1;
+        }
+    }
+    charmap_magic(font-&gt;library, face);
+    buggy_font_workaround(face);
+
+    font-&gt;faces[font-&gt;n_faces++] = face;
+    face_set_size(face, font-&gt;size);
+    free(path);
+    return font-&gt;n_faces - 1;
 }
 
 /**
- * \brief Create a new ass_font_t according to &quot;desc&quot; argument
+ * \brief Create a new ASS_Font according to &quot;desc&quot; argument
  */
-ass_font_t* ass_font_new(ass_library_t* library, FT_Library ftlibrary, void* fc_priv, ass_font_desc_t* desc)
+ASS_Font *ass_font_new(void *font_cache, ASS_Library *library,
+                       FT_Library ftlibrary, void *fc_priv,
+                       ASS_FontDesc *desc)
 {
-	int error;
-	ass_font_t* fontp;
-	ass_font_t font;
+    int error;
+    ASS_Font *fontp;
+    ASS_Font font;
 
-	fontp = ass_font_cache_find(desc);
-	if (fontp)
-		return fontp;
-	
-	font.library = library;
-	font.ftlibrary = ftlibrary;
-	font.n_faces = 0;
-	font.desc.family = strdup(desc-&gt;family);
-	font.desc.bold = desc-&gt;bold;
-	font.desc.italic = desc-&gt;italic;
+    fontp = ass_font_cache_find((Hashmap *) font_cache, desc);
+    if (fontp)
+        return fontp;
 
-	font.scale_x = font.scale_y = 1.;
-	font.v.x = font.v.y = 0;
-	font.size = 0.;
+    font.library = library;
+    font.ftlibrary = ftlibrary;
+    font.n_faces = 0;
+    font.desc.family = strdup(desc-&gt;family);
+    font.desc.treat_family_as_pattern = desc-&gt;treat_family_as_pattern;
+    font.desc.bold = desc-&gt;bold;
+    font.desc.italic = desc-&gt;italic;
+    font.desc.vertical = desc-&gt;vertical;
 
-	error = add_face(fc_priv, &amp;font, 0);
-	if (error == -1) {
-		free(font.desc.family);
-		return 0;
-	} else
-		return ass_font_cache_add(&amp;font);
+    font.scale_x = font.scale_y = 1.;
+    font.v.x = font.v.y = 0;
+    font.size = 0.;
+
+    error = add_face(fc_priv, &amp;font, 0);
+    if (error == -1) {
+        free(font.desc.family);
+        return 0;
+    } else
+        return ass_font_cache_add((Hashmap *) font_cache, &amp;font);
 }
 
 /**
  * \brief Set font transformation matrix and shift vector
  **/
-void ass_font_set_transform(ass_font_t* font, double scale_x, double scale_y, FT_Vector* v)
+void ass_font_set_transform(ASS_Font *font, double scale_x,
+                            double scale_y, FT_Vector *v)
 {
-	font-&gt;scale_x = scale_x;
-	font-&gt;scale_y = scale_y;
-	font-&gt;v.x = v-&gt;x;
-	font-&gt;v.y = v-&gt;y;
-	update_transform(font);
+    font-&gt;scale_x = scale_x;
+    font-&gt;scale_y = scale_y;
+    if (v) {
+        font-&gt;v.x = v-&gt;x;
+        font-&gt;v.y = v-&gt;y;
+    }
 }
 
 static void face_set_size(FT_Face face, double size)
 {
-#if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
-	TT_HoriHeader *hori = FT_Get_Sfnt_Table(face, ft_sfnt_hhea);
-	TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
-	double mscale = 1.;
-	FT_Size_RequestRec rq;
-	FT_Size_Metrics *m = &amp;face-&gt;size-&gt;metrics;
-	// VSFilter uses metrics from TrueType OS/2 table
-	// The idea was borrowed from asa (<A HREF="http://asa.diac24.net">http://asa.diac24.net</A>)
-	if (hori &amp;&amp; os2) {
-		int hori_height = hori-&gt;Ascender - hori-&gt;Descender;
-		int os2_height = os2-&gt;usWinAscent + os2-&gt;usWinDescent;
-		if (hori_height &amp;&amp; os2_height)
-			mscale = (double)hori_height / os2_height;
-	}
-	memset(&amp;rq, 0, sizeof(rq));
-	rq.type = FT_SIZE_REQUEST_TYPE_REAL_DIM;
-	rq.width = 0;
-	rq.height = double_to_d6(size * mscale);
-	rq.horiResolution = rq.vertResolution = 0;
-	FT_Request_Size(face, &amp;rq);
-	m-&gt;ascender /= mscale;
-	m-&gt;descender /= mscale;
-	m-&gt;height /= mscale;
-#else
-	FT_Set_Char_Size(face, 0, double_to_d6(size), 0, 0);
-#endif
+    TT_HoriHeader *hori = FT_Get_Sfnt_Table(face, ft_sfnt_hhea);
+    TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+    double mscale = 1.;
+    FT_Size_RequestRec rq;
+    FT_Size_Metrics *m = &amp;face-&gt;size-&gt;metrics;
+    // VSFilter uses metrics from TrueType OS/2 table
+    // The idea was borrowed from asa (<A HREF="http://asa.diac24.net">http://asa.diac24.net</A>)
+    if (hori &amp;&amp; os2) {
+        int hori_height = hori-&gt;Ascender - hori-&gt;Descender;
+        int os2_height = os2-&gt;usWinAscent + os2-&gt;usWinDescent;
+        if (hori_height &amp;&amp; os2_height)
+            mscale = (double) hori_height / os2_height;
+    }
+    memset(&amp;rq, 0, sizeof(rq));
+    rq.type = FT_SIZE_REQUEST_TYPE_REAL_DIM;
+    rq.width = 0;
+    rq.height = double_to_d6(size * mscale);
+    rq.horiResolution = rq.vertResolution = 0;
+    FT_Request_Size(face, &amp;rq);
+    m-&gt;ascender /= mscale;
+    m-&gt;descender /= mscale;
+    m-&gt;height /= mscale;
 }
 
 /**
  * \brief Set font size
  **/
-void ass_font_set_size(ass_font_t* font, double size)
+void ass_font_set_size(ASS_Font *font, double size)
 {
-	int i;
-	if (font-&gt;size != size) {
-		font-&gt;size = size;
-		for (i = 0; i &lt; font-&gt;n_faces; ++i)
-			face_set_size(font-&gt;faces[i], size);
-	}
+    int i;
+    if (font-&gt;size != size) {
+        font-&gt;size = size;
+        for (i = 0; i &lt; font-&gt;n_faces; ++i)
+            face_set_size(font-&gt;faces[i], size);
+    }
 }
 
 /**
@@ -242,129 +262,433 @@
  * \param ch character code
  * The values are extracted from the font face that provides glyphs for the given character
  **/
-void ass_font_get_asc_desc(ass_font_t* font, uint32_t ch, int* asc, int* desc)
+void ass_font_get_asc_desc(ASS_Font *font, uint32_t ch, int *asc,
+                           int *desc)
 {
-	int i;
-	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
-		FT_Face face = font-&gt;faces[i];
-		if (FT_Get_Char_Index(face, ch)) {
-			int v, v2;
-			v = face-&gt;size-&gt;metrics.ascender;
-			v2 = FT_MulFix(face-&gt;bbox.yMax, face-&gt;size-&gt;metrics.y_scale);
-			*asc = (v &gt; v2 * 0.9) ? v : v2;
-				
-			v = - face-&gt;size-&gt;metrics.descender;
-			v2 = - FT_MulFix(face-&gt;bbox.yMin, face-&gt;size-&gt;metrics.y_scale);
-			*desc = (v &gt; v2 * 0.9) ? v : v2;
-			return;
-		}
-	}
-	
-	*asc = *desc = 0;
+    int i;
+    for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+        FT_Face face = font-&gt;faces[i];
+        TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+        if (FT_Get_Char_Index(face, ch)) {
+            int y_scale = face-&gt;size-&gt;metrics.y_scale;
+            if (os2) {
+                *asc = FT_MulFix(os2-&gt;usWinAscent, y_scale);
+                *desc = FT_MulFix(os2-&gt;usWinDescent, y_scale);
+            } else {
+                *asc = FT_MulFix(face-&gt;ascender, y_scale);
+                *desc = FT_MulFix(-face-&gt;descender, y_scale);
+            }
+            if (font-&gt;desc.vertical &amp;&amp; ch &gt;= VERTICAL_LOWER_BOUND) {
+                *asc = FT_MulFix(face-&gt;max_advance_width, y_scale);
+            }
+            return;
+        }
+    }
+
+    *asc = *desc = 0;
 }
 
+/*
+ * Strike a glyph with a horizontal line; it's possible to underline it
+ * and/or strike through it.  For the line's position and size, truetype
+ * tables are consulted.  Obviously this relies on the data in the tables
+ * being accurate.
+ *
+ */
+static int ass_strike_outline_glyph(FT_Face face, ASS_Font *font,
+                                    FT_Glyph glyph, int under, int through)
+{
+    TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+    TT_Postscript *ps = FT_Get_Sfnt_Table(face, ft_sfnt_post);
+    FT_Outline *ol = &amp;((FT_OutlineGlyph) glyph)-&gt;outline;
+    int bear, advance, y_scale, i, dir;
+
+    if (!under &amp;&amp; !through)
+        return 0;
+
+    // Grow outline
+    i = (under ? 4 : 0) + (through ? 4 : 0);
+    ol-&gt;points = realloc(ol-&gt;points, sizeof(FT_Vector) *
+                         (ol-&gt;n_points + i));
+    ol-&gt;tags = realloc(ol-&gt;tags, ol-&gt;n_points + i);
+    i = !!under + !!through;
+    ol-&gt;contours = realloc(ol-&gt;contours, sizeof(short) *
+                           (ol-&gt;n_contours + i));
+
+    // If the bearing is negative, the glyph starts left of the current
+    // pen position
+    bear = FFMIN(face-&gt;glyph-&gt;metrics.horiBearingX, 0);
+    // We're adding half a pixel to avoid small gaps
+    advance = d16_to_d6(glyph-&gt;advance.x) + 32;
+    y_scale = face-&gt;size-&gt;metrics.y_scale;
+
+    // Reverse drawing direction for non-truetype fonts
+    dir = FT_Outline_Get_Orientation(ol);
+
+    // Add points to the outline
+    if (under &amp;&amp; ps) {
+        int pos, size;
+        pos = FT_MulFix(ps-&gt;underlinePosition, y_scale * font-&gt;scale_y);
+        size = FT_MulFix(ps-&gt;underlineThickness,
+                         y_scale * font-&gt;scale_y / 2);
+
+        if (pos &gt; 0 || size &lt;= 0)
+            return 1;
+
+        FT_Vector points[4] = {
+            {.x = bear,      .y = pos + size},
+            {.x = advance,   .y = pos + size},
+            {.x = advance,   .y = pos - size},
+            {.x = bear,      .y = pos - size},
+        };
+
+        if (dir == FT_ORIENTATION_TRUETYPE) {
+            for (i = 0; i &lt; 4; i++) {
+                ol-&gt;points[ol-&gt;n_points] = points[i];
+                ol-&gt;tags[ol-&gt;n_points++] = 1;
+            }
+        } else {
+            for (i = 3; i &gt;= 0; i--) {
+                ol-&gt;points[ol-&gt;n_points] = points[i];
+                ol-&gt;tags[ol-&gt;n_points++] = 1;
+            }
+        }
+
+        ol-&gt;contours[ol-&gt;n_contours++] = ol-&gt;n_points - 1;
+    }
+
+    if (through &amp;&amp; os2) {
+        int pos, size;
+        pos = FT_MulFix(os2-&gt;yStrikeoutPosition, y_scale * font-&gt;scale_y);
+        size = FT_MulFix(os2-&gt;yStrikeoutSize, y_scale * font-&gt;scale_y / 2);
+
+        if (pos &lt; 0 || size &lt;= 0)
+            return 1;
+
+        FT_Vector points[4] = {
+            {.x = bear,      .y = pos + size},
+            {.x = advance,   .y = pos + size},
+            {.x = advance,   .y = pos - size},
+            {.x = bear,      .y = pos - size},
+        };
+
+        if (dir == FT_ORIENTATION_TRUETYPE) {
+            for (i = 0; i &lt; 4; i++) {
+                ol-&gt;points[ol-&gt;n_points] = points[i];
+                ol-&gt;tags[ol-&gt;n_points++] = 1;
+            }
+        } else {
+            for (i = 3; i &gt;= 0; i--) {
+                ol-&gt;points[ol-&gt;n_points] = points[i];
+                ol-&gt;tags[ol-&gt;n_points++] = 1;
+            }
+        }
+
+        ol-&gt;contours[ol-&gt;n_contours++] = ol-&gt;n_points - 1;
+    }
+
+    return 0;
+}
+
 /**
+ * Slightly embold a glyph without touching its metrics
+ */
+static void ass_glyph_embolden(FT_GlyphSlot slot)
+{
+    int str;
+
+    if (slot-&gt;format != FT_GLYPH_FORMAT_OUTLINE)
+        return;
+
+    str = FT_MulFix(slot-&gt;face-&gt;units_per_EM,
+                    slot-&gt;face-&gt;size-&gt;metrics.y_scale) / 64;
+
+    FT_Outline_Embolden(&amp;slot-&gt;outline, str);
+}
+
+/**
  * \brief Get a glyph
  * \param ch character code
  **/
-FT_Glyph ass_font_get_glyph(void* fontconfig_priv, ass_font_t* font, uint32_t ch, ass_hinting_t hinting)
+FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ASS_Font *font,
+                            uint32_t ch, ASS_Hinting hinting, int deco)
 {
-	int error;
-	int index = 0;
-	int i;
-	FT_Glyph glyph;
-	FT_Face face = 0;
-	int flags = 0;
+    int error;
+    int index = 0;
+    int i;
+    FT_Glyph glyph;
+    FT_Face face = 0;
+    int flags = 0;
+    int vertical = font-&gt;desc.vertical;
 
-	if (ch &lt; 0x20)
-		return 0;
-	if (font-&gt;n_faces == 0)
-		return 0;
+    if (ch &lt; 0x20)
+        return 0;
+    // Handle NBSP like a regular space when rendering the glyph
+    if (ch == 0xa0)
+        ch = ' ';
+    if (font-&gt;n_faces == 0)
+        return 0;
 
-	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
-		face = font-&gt;faces[i];
-		index = FT_Get_Char_Index(face, ch);
-		if (index)
-			break;
-	}
+    for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+        face = font-&gt;faces[i];
+        index = FT_Get_Char_Index(face, ch);
+        if (index)
+            break;
+    }
 
-#ifdef HAVE_FONTCONFIG
-	if (index == 0) {
-		int face_idx;
-		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_GlyphNotFoundReselectingFont,
-		       ch, font-&gt;desc.family, font-&gt;desc.bold, font-&gt;desc.italic);
-		face_idx = add_face(fontconfig_priv, font, ch);
-		face = font-&gt;faces[face_idx];
-		index = FT_Get_Char_Index(face, ch);
-		if (index == 0) {
-			mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_GlyphNotFound,
-			       ch, font-&gt;desc.family, font-&gt;desc.bold, font-&gt;desc.italic);
-		}
-	}
+#ifdef CONFIG_FONTCONFIG
+    if (index == 0) {
+        int face_idx;
+        ass_msg(font-&gt;library, MSGL_INFO,
+                &quot;Glyph 0x%X not found, selecting one more &quot;
+                &quot;font for (%s, %d, %d)&quot;, ch, font-&gt;desc.family,
+                font-&gt;desc.bold, font-&gt;desc.italic);
+        face_idx = add_face(fontconfig_priv, font, ch);
+        if (face_idx &gt;= 0) {
+            face = font-&gt;faces[face_idx];
+            index = FT_Get_Char_Index(face, ch);
+            if (index == 0 &amp;&amp; face-&gt;num_charmaps &gt; 0) {
+                ass_msg(font-&gt;library, MSGL_WARN,
+                    &quot;Glyph 0x%X not found, falling back to first charmap&quot;, ch);
+                FT_CharMap cur = face-&gt;charmap;
+                FT_Set_Charmap(face, face-&gt;charmaps[0]);
+                index = FT_Get_Char_Index(face, ch);
+                FT_Set_Charmap(face, cur);
+            }
+            if (index == 0) {
+                ass_msg(font-&gt;library, MSGL_ERR,
+                        &quot;Glyph 0x%X not found in font for (%s, %d, %d)&quot;,
+                        ch, font-&gt;desc.family, font-&gt;desc.bold,
+                        font-&gt;desc.italic);
+            }
+        }
+    }
 #endif
 
-	switch (hinting) {
-	case ASS_HINTING_NONE: flags = FT_LOAD_NO_HINTING; break;
-	case ASS_HINTING_LIGHT: flags = FT_LOAD_FORCE_AUTOHINT | FT_LOAD_TARGET_LIGHT; break;
-	case ASS_HINTING_NORMAL: flags = FT_LOAD_FORCE_AUTOHINT; break;
-	case ASS_HINTING_NATIVE: flags = 0; break;
-	}
-	
-	error = FT_Load_Glyph(face, index, FT_LOAD_NO_BITMAP | flags);
-	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
-		return 0;
-	}
-	
-#if (FREETYPE_MAJOR &gt; 2) || \
-    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt;= 2)) || \
-    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR == 1) &amp;&amp; (FREETYPE_PATCH &gt;= 10))
-// FreeType &gt;= 2.1.10 required
-	if (!(face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC) &amp;&amp; 
-			(font-&gt;desc.italic &gt; 55)) {
-		FT_GlyphSlot_Oblique(face-&gt;glyph);
-	}
-#endif
-	error = FT_Get_Glyph(face-&gt;glyph, &amp;glyph);
-	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
-		return 0;
-	}
-	
-	return glyph;
+    flags = FT_LOAD_NO_BITMAP | FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH
+            | FT_LOAD_IGNORE_TRANSFORM;
+    switch (hinting) {
+    case ASS_HINTING_NONE:
+        flags |= FT_LOAD_NO_HINTING;
+        break;
+    case ASS_HINTING_LIGHT:
+        flags |= FT_LOAD_FORCE_AUTOHINT | FT_LOAD_TARGET_LIGHT;
+        break;
+    case ASS_HINTING_NORMAL:
+        flags |= FT_LOAD_FORCE_AUTOHINT;
+        break;
+    case ASS_HINTING_NATIVE:
+        break;
+    }
+
+    error = FT_Load_Glyph(face, index, flags);
+    if (error) {
+        ass_msg(font-&gt;library, MSGL_WARN, &quot;Error loading glyph, index %d&quot;,
+                index);
+        return 0;
+    }
+    if (!(face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC) &amp;&amp;
+        (font-&gt;desc.italic &gt; 55)) {
+        FT_GlyphSlot_Oblique(face-&gt;glyph);
+    }
+
+    if (!(face-&gt;style_flags &amp; FT_STYLE_FLAG_BOLD) &amp;&amp;
+        (font-&gt;desc.bold &gt; 80)) {
+        ass_glyph_embolden(face-&gt;glyph);
+    }
+    error = FT_Get_Glyph(face-&gt;glyph, &amp;glyph);
+    if (error) {
+        ass_msg(font-&gt;library, MSGL_WARN, &quot;Error loading glyph, index %d&quot;,
+                index);
+        return 0;
+    }
+
+    // Rotate glyph, if needed
+    if (vertical &amp;&amp; ch &gt;= VERTICAL_LOWER_BOUND) {
+        FT_Matrix m = { 0, double_to_d16(-1.0), double_to_d16(1.0), 0 };
+        FT_Outline_Transform(&amp;((FT_OutlineGlyph) glyph)-&gt;outline, &amp;m);
+        FT_Outline_Translate(&amp;((FT_OutlineGlyph) glyph)-&gt;outline,
+                             face-&gt;glyph-&gt;metrics.vertAdvance,
+                             0);
+        glyph-&gt;advance.x = face-&gt;glyph-&gt;linearVertAdvance;
+    }
+
+    // Apply scaling and shift
+    FT_Matrix scale = { double_to_d16(font-&gt;scale_x), 0, 0,
+                        double_to_d16(font-&gt;scale_y) };
+    FT_Outline *outl = &amp;((FT_OutlineGlyph) glyph)-&gt;outline;
+    FT_Outline_Transform(outl, &amp;scale);
+    FT_Outline_Translate(outl, font-&gt;v.x, font-&gt;v.y);
+    glyph-&gt;advance.x *= font-&gt;scale_x;
+
+    ass_strike_outline_glyph(face, font, glyph, deco &amp; DECO_UNDERLINE,
+                             deco &amp; DECO_STRIKETHROUGH);
+
+    return glyph;
 }
 
 /**
  * \brief Get kerning for the pair of glyphs.
  **/
-FT_Vector ass_font_get_kerning(ass_font_t* font, uint32_t c1, uint32_t c2)
+FT_Vector ass_font_get_kerning(ASS_Font *font, uint32_t c1, uint32_t c2)
 {
-	FT_Vector v = {0, 0};
-	int i;
+    FT_Vector v = { 0, 0 };
+    int i;
 
-	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
-		FT_Face face = font-&gt;faces[i];
-		int i1 = FT_Get_Char_Index(face, c1);
-		int i2 = FT_Get_Char_Index(face, c2);
-		if (i1 &amp;&amp; i2) {
-			if (FT_HAS_KERNING(face))
-				FT_Get_Kerning(face, i1, i2, FT_KERNING_DEFAULT, &amp;v);
-			return v;
-		}
-		if (i1 || i2) // these glyphs are from different font faces, no kerning information
-			return v;
-	}
-	return v;
+    if (font-&gt;desc.vertical)
+        return v;
+
+    for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+        FT_Face face = font-&gt;faces[i];
+        int i1 = FT_Get_Char_Index(face, c1);
+        int i2 = FT_Get_Char_Index(face, c2);
+        if (i1 &amp;&amp; i2) {
+            if (FT_HAS_KERNING(face))
+                FT_Get_Kerning(face, i1, i2, FT_KERNING_DEFAULT, &amp;v);
+            return v;
+        }
+        if (i1 || i2)           // these glyphs are from different font faces, no kerning information
+            return v;
+    }
+    return v;
 }
 
 /**
- * \brief Deallocate ass_font_t
+ * \brief Deallocate ASS_Font
  **/
-void ass_font_free(ass_font_t* font)
+void ass_font_free(ASS_Font *font)
 {
-	int i;
-	for (i = 0; i &lt; font-&gt;n_faces; ++i)
-		if (font-&gt;faces[i]) FT_Done_Face(font-&gt;faces[i]);
-	if (font-&gt;desc.family) free(font-&gt;desc.family);
-	free(font);
+    int i;
+    for (i = 0; i &lt; font-&gt;n_faces; ++i)
+        if (font-&gt;faces[i])
+            FT_Done_Face(font-&gt;faces[i]);
+    free(font-&gt;desc.family);
+    free(font);
 }
+
+/**
+ * \brief Calculate the cbox of a series of points
+ */
+static void
+get_contour_cbox(FT_BBox *box, FT_Vector *points, int start, int end)
+{
+    box-&gt;xMin = box-&gt;yMin = INT_MAX;
+    box-&gt;xMax = box-&gt;yMax = INT_MIN;
+    int i;
+
+    for (i = start; i &lt;= end; i++) {
+        box-&gt;xMin = (points[i].x &lt; box-&gt;xMin) ? points[i].x : box-&gt;xMin;
+        box-&gt;xMax = (points[i].x &gt; box-&gt;xMax) ? points[i].x : box-&gt;xMax;
+        box-&gt;yMin = (points[i].y &lt; box-&gt;yMin) ? points[i].y : box-&gt;yMin;
+        box-&gt;yMax = (points[i].y &gt; box-&gt;yMax) ? points[i].y : box-&gt;yMax;
+    }
+}
+
+/**
+ * \brief Determine winding direction of a contour
+ * \return direction; 0 = clockwise
+ */
+static int get_contour_direction(FT_Vector *points, int start, int end)
+{
+    int i;
+    long long sum = 0;
+    int x = points[start].x;
+    int y = points[start].y;
+    for (i = start + 1; i &lt;= end; i++) {
+        sum += x * (points[i].y - y) - y * (points[i].x - x);
+        x = points[i].x;
+        y = points[i].y;
+    }
+    sum += x * (points[start].y - y) - y * (points[start].x - x);
+    return sum &gt; 0;
+}
+
+/**
+ * \brief Fix-up stroker result for huge borders by removing inside contours
+ * that would reverse in size
+ */
+void fix_freetype_stroker(FT_OutlineGlyph glyph, int border_x, int border_y)
+{
+    int nc = glyph-&gt;outline.n_contours;
+    int begin, stop;
+    char modified = 0;
+    char *valid_cont = malloc(nc);
+    int start = 0;
+    int end = -1;
+    FT_BBox *boxes = malloc(nc * sizeof(FT_BBox));
+    int i, j;
+    int inside_direction;
+
+    inside_direction = FT_Outline_Get_Orientation(&amp;glyph-&gt;outline) ==
+        FT_ORIENTATION_TRUETYPE;
+
+    // create a list of cboxes of the contours
+    for (i = 0; i &lt; nc; i++) {
+        start = end + 1;
+        end = glyph-&gt;outline.contours[i];
+        get_contour_cbox(&amp;boxes[i], glyph-&gt;outline.points, start, end);
+    }
+
+    // for each contour, check direction and whether it's &quot;outside&quot;
+    // or contained in another contour
+    end = -1;
+    for (i = 0; i &lt; nc; i++) {
+        start = end + 1;
+        end = glyph-&gt;outline.contours[i];
+        int dir = get_contour_direction(glyph-&gt;outline.points, start, end);
+        valid_cont[i] = 1;
+        if (dir == inside_direction) {
+            for (j = 0; j &lt; nc; j++) {
+                if (i == j)
+                    continue;
+                if (boxes[i].xMin &gt;= boxes[j].xMin &amp;&amp;
+                    boxes[i].xMax &lt;= boxes[j].xMax &amp;&amp;
+                    boxes[i].yMin &gt;= boxes[j].yMin &amp;&amp;
+                    boxes[i].yMax &lt;= boxes[j].yMax)
+                    goto check_inside;
+            }
+            /* &quot;inside&quot; contour but we can't find anything it could be
+             * inside of - assume the font is buggy and it should be
+             * an &quot;outside&quot; contour, and reverse it */
+            for (j = 0; j &lt; (end + 1 - start) / 2; j++) {
+                FT_Vector temp = glyph-&gt;outline.points[start + j];
+                char temp2 = glyph-&gt;outline.tags[start + j];
+                glyph-&gt;outline.points[start + j] = glyph-&gt;outline.points[end - j];
+                glyph-&gt;outline.points[end - j] = temp;
+                glyph-&gt;outline.tags[start + j] = glyph-&gt;outline.tags[end - j];
+                glyph-&gt;outline.tags[end - j] = temp2;
+            }
+            dir ^= 1;
+        }
+        check_inside:
+        if (dir == inside_direction) {
+            FT_BBox box;
+            get_contour_cbox(&amp;box, glyph-&gt;outline.points, start, end);
+            int width = box.xMax - box.xMin;
+            int height = box.yMax - box.yMin;
+            if (width &lt; border_x * 2 || height &lt; border_y * 2) {
+                valid_cont[i] = 0;
+                modified = 1;
+            }
+        }
+    }
+
+    // zero-out contours that can be removed; much simpler than copying
+    if (modified) {
+        for (i = 0; i &lt; nc; i++) {
+            if (valid_cont[i])
+                continue;
+            begin = (i == 0) ? 0 : glyph-&gt;outline.contours[i - 1] + 1;
+            stop = glyph-&gt;outline.contours[i];
+            for (j = begin; j &lt;= stop; j++) {
+                glyph-&gt;outline.points[j].x = 0;
+                glyph-&gt;outline.points[j].y = 0;
+                glyph-&gt;outline.tags[j] = 0;
+            }
+        }
+    }
+
+    free(boxes);
+    free(valid_cont);
+}
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.h	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,51 +1,68 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#ifndef LIBASS_FONT_H
+#define LIBASS_FONT_H
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
+#include &lt;stdint.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
+#include &quot;ass.h&quot;
+#include &quot;ass_types.h&quot;
 
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
+#define ASS_FONT_MAX_FACES 10
+#define DECO_UNDERLINE 1
+#define DECO_STRIKETHROUGH 2
 
-#ifndef ASS_FONT_H
-#define ASS_FONT_H
+typedef struct {
+    char *family;
+    unsigned bold;
+    unsigned italic;
+    int treat_family_as_pattern;
+    int vertical;               // @font vertical layout
+} ASS_FontDesc;
 
-typedef struct ass_font_desc_s {
-	char* family;
-	unsigned bold;
-	unsigned italic;
-} ass_font_desc_t;
+typedef struct {
+    ASS_FontDesc desc;
+    ASS_Library *library;
+    FT_Library ftlibrary;
+    FT_Face faces[ASS_FONT_MAX_FACES];
+    int n_faces;
+    double scale_x, scale_y;    // current transform
+    FT_Vector v;                // current shift
+    double size;
+} ASS_Font;
 
-#define ASS_FONT_MAX_FACES 10
+// FIXME: passing the hashmap via a void pointer is very ugly.
+ASS_Font *ass_font_new(void *font_cache, ASS_Library *library,
+                       FT_Library ftlibrary, void *fc_priv,
+                       ASS_FontDesc *desc);
+void ass_font_set_transform(ASS_Font *font, double scale_x,
+                            double scale_y, FT_Vector *v);
+void ass_font_set_size(ASS_Font *font, double size);
+void ass_font_get_asc_desc(ASS_Font *font, uint32_t ch, int *asc,
+                           int *desc);
+FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ASS_Font *font,
+                            uint32_t ch, ASS_Hinting hinting, int flags);
+FT_Vector ass_font_get_kerning(ASS_Font *font, uint32_t c1, uint32_t c2);
+void ass_font_free(ASS_Font *font);
+void fix_freetype_stroker(FT_OutlineGlyph glyph, int border_x, int border_y);
 
-typedef struct ass_font_s {
-	ass_font_desc_t desc;
-	ass_library_t* library;
-	FT_Library ftlibrary;
-	FT_Face faces[ASS_FONT_MAX_FACES];
-	int n_faces;
-	double scale_x, scale_y; // current transform
-	FT_Vector v; // current shift
-	double size;
-} ass_font_t;
-
-ass_font_t* ass_font_new(ass_library_t* library, FT_Library ftlibrary, void* fc_priv, ass_font_desc_t* desc);
-void ass_font_set_transform(ass_font_t* font, double scale_x, double scale_y, FT_Vector* v);
-void ass_font_set_size(ass_font_t* font, double size);
-void ass_font_get_asc_desc(ass_font_t* font, uint32_t ch, int* asc, int* desc);
-FT_Glyph ass_font_get_glyph(void* fontconfig_priv, ass_font_t* font, uint32_t ch, ass_hinting_t hinting);
-FT_Vector ass_font_get_kerning(ass_font_t* font, uint32_t c1, uint32_t c2);
-void ass_font_free(ass_font_t* font);
-
-#endif
+#endif                          /* LIBASS_FONT_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.c	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,308 +1,413 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#include &quot;ADM_coreConfig.h&quot;
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include &quot;config.h&quot;
-
 #include &lt;stdlib.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;assert.h&gt;
 #include &lt;string.h&gt;
+#include &lt;strings.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;sys/stat.h&gt;
 #include &lt;inttypes.h&gt;
 #include &lt;ft2build.h&gt;
 #include FT_FREETYPE_H
 
-#include &quot;mputils.h&quot;
+#include &quot;ass_utils.h&quot;
 #include &quot;ass.h&quot;
 #include &quot;ass_library.h&quot;
 #include &quot;ass_fontconfig.h&quot;
 
-#ifdef HAVE_FONTCONFIG
+#ifdef CONFIG_FONTCONFIG
 #include &lt;fontconfig/fontconfig.h&gt;
 #include &lt;fontconfig/fcfreetype.h&gt;
 #endif
 
-struct fc_instance_s {
-#ifdef HAVE_FONTCONFIG
-	FcConfig* config;
+struct fc_instance {
+#ifdef CONFIG_FONTCONFIG
+    FcConfig *config;
 #endif
-	char* family_default;
-	char* path_default;
-	int index_default;
+    char *family_default;
+    char *path_default;
+    int index_default;
 };
 
-#ifdef HAVE_FONTCONFIG
+#ifdef CONFIG_FONTCONFIG
+
 /**
+ * \brief Case-insensitive match ASS/SSA font family against full name. (also
+ * known as &quot;name for humans&quot;)
+ *
+ * \param lib library instance
+ * \param priv fontconfig instance
+ * \param family font fullname
+ * \param bold weight attribute
+ * \param italic italic attribute
+ * \return font set
+ */
+static FcFontSet *
+match_fullname(ASS_Library *lib, FCInstance *priv, const char *family,
+               unsigned bold, unsigned italic)
+{
+    FcFontSet *sets[2];
+    FcFontSet *result = FcFontSetCreate();
+    int nsets = 0;
+    int i, fi;
+
+    if ((sets[nsets] = FcConfigGetFonts(priv-&gt;config, FcSetSystem)))
+        nsets++;
+    if ((sets[nsets] = FcConfigGetFonts(priv-&gt;config, FcSetApplication)))
+        nsets++;
+
+    // Run over font sets and patterns and try to match against full name
+    for (i = 0; i &lt; nsets; i++) {
+        FcFontSet *set = sets[i];
+        for (fi = 0; fi &lt; set-&gt;nfont; fi++) {
+            FcPattern *pat = set-&gt;fonts[fi];
+            char *fullname;
+            int pi = 0, at;
+            FcBool ol;
+            while (FcPatternGetString(pat, FC_FULLNAME, pi++,
+                   (FcChar8 **) &amp;fullname) == FcResultMatch) {
+                if (FcPatternGetBool(pat, FC_OUTLINE, 0, &amp;ol) != FcResultMatch
+                    || ol != FcTrue)
+                    continue;
+                if (FcPatternGetInteger(pat, FC_SLANT, 0, &amp;at) != FcResultMatch
+                    || at &lt; italic)
+                    continue;
+                if (FcPatternGetInteger(pat, FC_WEIGHT, 0, &amp;at) != FcResultMatch
+                    || at &lt; bold)
+                    continue;
+                if (strcasecmp(fullname, family) == 0) {
+                    FcFontSetAdd(result, FcPatternDuplicate(pat));
+                    break;
+                }
+            }
+        }
+    }
+
+    return result;
+}
+
+/**
  * \brief Low-level font selection.
  * \param priv private data
  * \param family font family
+ * \param treat_family_as_pattern treat family as fontconfig pattern
  * \param bold font weight value
  * \param italic font slant value
  * \param index out: font index inside a file
  * \param code: the character that should be present in the font, can be 0
  * \return font file path
-*/ 
-static char* _select_font(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
-			  uint32_t code)
+*/
+static char *select_font(ASS_Library *library, FCInstance *priv,
+                          const char *family, int treat_family_as_pattern,
+                          unsigned bold, unsigned italic, int *index,
+                          uint32_t code)
 {
-	FcBool rc;
-	FcResult result;
-	FcPattern *pat = 0, *rpat;
-	int val_i;
-	FcChar8* val_s;
-	FcBool val_b;
-	FcCharSet* val_cs;
-	FcFontSet* fset = 0;
-	int curf;
-	char* retval = 0;
-	
-	*index = 0;
+    FcBool rc;
+    FcResult result;
+    FcPattern *pat = NULL, *rpat = NULL;
+    int r_index, r_slant, r_weight;
+    FcChar8 *r_family, *r_style, *r_file, *r_fullname;
+    FcBool r_outline, r_embolden;
+    FcCharSet *r_charset;
+    FcFontSet *ffullname = NULL, *fsorted = NULL, *fset = NULL;
+    int curf;
+    char *retval = NULL;
+    int family_cnt = 0;
 
-	pat = FcPatternCreate();
-	if (!pat)
-		goto error;
-	
-	FcPatternAddString(pat, FC_FAMILY, (const FcChar8*)family);
-	FcPatternAddBool(pat, FC_OUTLINE, FcTrue);
-	FcPatternAddInteger(pat, FC_SLANT, italic);
-	FcPatternAddInteger(pat, FC_WEIGHT, bold);
+    *index = 0;
 
-	FcDefaultSubstitute(pat);
-	
-	rc = FcConfigSubstitute(priv-&gt;config, pat, FcMatchPattern);
-	if (!rc)
-		goto error;
+    if (treat_family_as_pattern)
+        pat = FcNameParse((const FcChar8 *) family);
+    else
+        pat = FcPatternCreate();
 
-	fset = FcFontSort(priv-&gt;config, pat, FcTrue, NULL, &amp;result);
+    if (!pat)
+        goto error;
 
-	for (curf = 0; curf &lt; fset-&gt;nfont; ++curf) {
-		rpat = fset-&gt;fonts[curf];
-		
-		result = FcPatternGetBool(rpat, FC_OUTLINE, 0, &amp;val_b);
-		if (result != FcResultMatch)
-			continue;
-		if (val_b != FcTrue)
-			continue;
-		if (!code)
-			break;
-		result = FcPatternGetCharSet(rpat, FC_CHARSET, 0, &amp;val_cs);
-		if (result != FcResultMatch)
-			continue;
-		if (FcCharSetHasChar(val_cs, code))
-			break;
-	}
+    if (!treat_family_as_pattern) {
+        FcPatternAddString(pat, FC_FAMILY, (const FcChar8 *) family);
 
-	if (curf &gt;= fset-&gt;nfont)
-		goto error;
+        // In SSA/ASS fonts are sometimes referenced by their &quot;full name&quot;,
+        // which is usually a concatenation of family name and font
+        // style (ex. Ottawa Bold). Full name is available from
+        // FontConfig pattern element FC_FULLNAME, but it is never
+        // used for font matching.
+        // Therefore, I'm removing words from the end of the name one
+        // by one, and adding shortened names to the pattern. It seems
+        // that the first value (full name in this case) has
+        // precedence in matching.
+        // An alternative approach could be to reimplement FcFontSort
+        // using FC_FULLNAME instead of FC_FAMILY.
+        family_cnt = 1;
+        {
+            char *s = strdup(family);
+            char *p = s + strlen(s);
+            while (--p &gt; s)
+                if (*p == ' ' || *p == '-') {
+                    *p = '\0';
+                    FcPatternAddString(pat, FC_FAMILY, (const FcChar8 *) s);
+                    ++family_cnt;
+                }
+            free(s);
+        }
+    }
+    FcPatternAddBool(pat, FC_OUTLINE, FcTrue);
+    FcPatternAddInteger(pat, FC_SLANT, italic);
+    FcPatternAddInteger(pat, FC_WEIGHT, bold);
 
-	rpat = fset-&gt;fonts[curf];
-	
-	result = FcPatternGetInteger(rpat, FC_INDEX, 0, &amp;val_i);
-	if (result != FcResultMatch)
-		goto error;
-	*index = val_i;
+    FcDefaultSubstitute(pat);
 
-	result = FcPatternGetString(rpat, FC_FAMILY, 0, &amp;val_s);
-	if (result != FcResultMatch)
-		goto error;
+    rc = FcConfigSubstitute(priv-&gt;config, pat, FcMatchPattern);
+    if (!rc)
+        goto error;
 
-	if (strcasecmp((const char*)val_s, family) != 0)
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_SelectedFontFamilyIsNotTheRequestedOne,
-				(const char*)val_s, family);
+    fsorted = FcFontSort(priv-&gt;config, pat, FcTrue, NULL, &amp;result);
+    ffullname = match_fullname(library, priv, family, bold, italic);
+    if (!fsorted || !ffullname)
+        goto error;
 
-	result = FcPatternGetString(rpat, FC_FILE, 0, &amp;val_s);
-	if (result != FcResultMatch)
-		goto error;
-	
-	retval = strdup((const char*)val_s);
- error:
-	if (pat) FcPatternDestroy(pat);
-	if (fset) FcFontSetDestroy(fset);
-	return retval;
+    fset = FcFontSetCreate();
+    for (curf = 0; curf &lt; ffullname-&gt;nfont; ++curf) {
+        FcPattern *curp = ffullname-&gt;fonts[curf];
+        FcPatternReference(curp);
+        FcFontSetAdd(fset, curp);
+    }
+    for (curf = 0; curf &lt; fsorted-&gt;nfont; ++curf) {
+        FcPattern *curp = fsorted-&gt;fonts[curf];
+        FcPatternReference(curp);
+        FcFontSetAdd(fset, curp);
+    }
+
+    for (curf = 0; curf &lt; fset-&gt;nfont; ++curf) {
+        FcPattern *curp = fset-&gt;fonts[curf];
+
+        result = FcPatternGetBool(curp, FC_OUTLINE, 0, &amp;r_outline);
+        if (result != FcResultMatch)
+            continue;
+        if (r_outline != FcTrue)
+            continue;
+        if (!code)
+            break;
+        result = FcPatternGetCharSet(curp, FC_CHARSET, 0, &amp;r_charset);
+        if (result != FcResultMatch)
+            continue;
+        if (FcCharSetHasChar(r_charset, code))
+            break;
+    }
+
+    if (curf &gt;= fset-&gt;nfont)
+        goto error;
+
+    if (!treat_family_as_pattern) {
+        // Remove all extra family names from original pattern.
+        // After this, FcFontRenderPrepare will select the most relevant family
+        // name in case there are more than one of them.
+        for (; family_cnt &gt; 1; --family_cnt)
+            FcPatternRemove(pat, FC_FAMILY, family_cnt - 1);
+    }
+
+    rpat = FcFontRenderPrepare(priv-&gt;config, pat, fset-&gt;fonts[curf]);
+    if (!rpat)
+        goto error;
+
+    result = FcPatternGetInteger(rpat, FC_INDEX, 0, &amp;r_index);
+    if (result != FcResultMatch)
+        goto error;
+    *index = r_index;
+
+    result = FcPatternGetString(rpat, FC_FILE, 0, &amp;r_file);
+    if (result != FcResultMatch)
+        goto error;
+    retval = strdup((const char *) r_file);
+
+    result = FcPatternGetString(rpat, FC_FAMILY, 0, &amp;r_family);
+    if (result != FcResultMatch)
+        r_family = NULL;
+
+    result = FcPatternGetString(rpat, FC_FULLNAME, 0, &amp;r_fullname);
+    if (result != FcResultMatch)
+        r_fullname = NULL;
+
+    if (!treat_family_as_pattern &amp;&amp;
+        !(r_family &amp;&amp; strcasecmp((const char *) r_family, family) == 0) &amp;&amp;
+        !(r_fullname &amp;&amp; strcasecmp((const char *) r_fullname, family) == 0))
+        ass_msg(library, MSGL_WARN,
+               &quot;fontconfig: Selected font is not the requested one: &quot;
+               &quot;'%s' != '%s'&quot;,
+               (const char *) (r_fullname ? r_fullname : r_family), family);
+
+    result = FcPatternGetString(rpat, FC_STYLE, 0, &amp;r_style);
+    if (result != FcResultMatch)
+        r_style = NULL;
+
+    result = FcPatternGetInteger(rpat, FC_SLANT, 0, &amp;r_slant);
+    if (result != FcResultMatch)
+        r_slant = 0;
+
+    result = FcPatternGetInteger(rpat, FC_WEIGHT, 0, &amp;r_weight);
+    if (result != FcResultMatch)
+        r_weight = 0;
+
+    result = FcPatternGetBool(rpat, FC_EMBOLDEN, 0, &amp;r_embolden);
+    if (result != FcResultMatch)
+        r_embolden = 0;
+
+    ass_msg(library, MSGL_V,
+           &quot;Font info: family '%s', style '%s', fullname '%s',&quot;
+           &quot; slant %d, weight %d%s&quot;, (const char *) r_family,
+           (const char *) r_style, (const char *) r_fullname, r_slant,
+           r_weight, r_embolden ? &quot;, embolden&quot; : &quot;&quot;);
+
+  error:
+    if (pat)
+        FcPatternDestroy(pat);
+    if (rpat)
+        FcPatternDestroy(rpat);
+    if (fsorted)
+        FcFontSetDestroy(fsorted);
+    if (ffullname)
+        FcFontSetDestroy(ffullname);
+    if (fset)
+        FcFontSetDestroy(fset);
+    return retval;
 }
 
 /**
  * \brief Find a font. Use default family or path if necessary.
  * \param priv_ private data
  * \param family font family
+ * \param treat_family_as_pattern treat family as fontconfig pattern
  * \param bold font weight value
  * \param italic font slant value
  * \param index out: font index inside a file
  * \param code: the character that should be present in the font, can be 0
  * \return font file path
-*/ 
-char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
-			uint32_t code)
+*/
+char *fontconfig_select(ASS_Library *library, FCInstance *priv,
+                        const char *family, int treat_family_as_pattern,
+                        unsigned bold, unsigned italic, int *index,
+                        uint32_t code)
 {
-	char* res = 0;
-	if (family &amp;&amp; *family)
-		res = _select_font(priv, family, bold, italic, index, code);
-	if (!res &amp;&amp; priv-&gt;family_default) {
-		res = _select_font(priv, priv-&gt;family_default, bold, italic, index, code);
-		if (res)
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFontFamily, 
-					family, bold, italic, res, *index);
-	}
-	if (!res &amp;&amp; priv-&gt;path_default) {
-		res = priv-&gt;path_default;
-		*index = priv-&gt;index_default;
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFont, 
-		       family, bold, italic, res, *index);
-	}
-	if (!res) {
-		res = _select_font(priv, &quot;Arial&quot;, bold, italic, index, code);
-		if (res)
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingArialFontFamily, 
-					family, bold, italic, res, *index);
-	}
-	if (res)
-		mp_msg(MSGT_ASS, MSGL_V, &quot;fontconfig_select: (%s, %d, %d) -&gt; %s, %d\n&quot;, 
-				family, bold, italic, res, *index);
-	return res;
+    char *res = 0;
+    if (!priv-&gt;config) {
+        *index = priv-&gt;index_default;
+        res = priv-&gt;path_default ? strdup(priv-&gt;path_default) : 0;
+        return res;
+    }
+    if (family &amp;&amp; *family)
+        res =
+            select_font(library, priv, family, treat_family_as_pattern,
+                         bold, italic, index, code);
+    if (!res &amp;&amp; priv-&gt;family_default) {
+        res =
+            select_font(library, priv, priv-&gt;family_default, 0, bold,
+                         italic, index, code);
+        if (res)
+            ass_msg(library, MSGL_WARN, &quot;fontconfig_select: Using default &quot;
+                    &quot;font family: (%s, %d, %d) -&gt; %s, %d&quot;,
+                    family, bold, italic, res, *index);
+    }
+    if (!res &amp;&amp; priv-&gt;path_default) {
+        res = strdup(priv-&gt;path_default);
+        *index = priv-&gt;index_default;
+        ass_msg(library, MSGL_WARN, &quot;fontconfig_select: Using default font: &quot;
+                &quot;(%s, %d, %d) -&gt; %s, %d&quot;, family, bold, italic,
+                res, *index);
+    }
+    if (!res) {
+        res = select_font(library, priv, &quot;Arial&quot;, 0, bold, italic,
+                           index, code);
+        if (res)
+            ass_msg(library, MSGL_WARN, &quot;fontconfig_select: Using 'Arial' &quot;
+                    &quot;font family: (%s, %d, %d) -&gt; %s, %d&quot;, family, bold,
+                    italic, res, *index);
+    }
+    if (res)
+        ass_msg(library, MSGL_V,
+                &quot;fontconfig_select: (%s, %d, %d) -&gt; %s, %d&quot;, family, bold,
+                italic, res, *index);
+    return res;
 }
 
-#if (FC_VERSION &lt; 20402)
-static char* validate_fname(char* name)
-{
-	char* fname;
-	char* p;
-	char* q;
-	unsigned code;
-	int sz = strlen(name);
-
-	q = fname = malloc(sz + 1);
-	p = name;
-	while (*p) {
-		code = utf8_get_char(&amp;p);
-		if (code == 0)
-			break;
-		if (	(code &gt; 0x7F) ||
-			(code == '\\') ||
-			(code == '/') ||
-			(code == ':') ||
-			(code == '*') ||
-			(code == '?') ||
-			(code == '&lt;') ||
-			(code == '&gt;') ||
-			(code == '|') ||
-			(code == 0))
-		{
-			*q++ = '_';
-		} else {
-			*q++ = code;
-		}
-		if (p - name &gt; sz)
-			break;
-	}
-	*q = 0;
-	return fname;
-}
-#endif
-
 /**
  * \brief Process memory font.
  * \param priv private data
  * \param library library object
  * \param ftlibrary freetype library object
  * \param idx index of the processed font in library-&gt;fontdata
- * With FontConfig &gt;= 2.4.2, builds a font pattern in memory via FT_New_Memory_Face/FcFreeTypeQueryFace.
- * With older FontConfig versions, save the font to ~/.mplayer/fonts.
-*/ 
-static void process_fontdata(fc_instance_t* priv, ass_library_t* library, FT_Library ftlibrary, int idx)
+ *
+ * Builds a font pattern in memory via FT_New_Memory_Face/FcFreeTypeQueryFace.
+*/
+static void process_fontdata(FCInstance *priv, ASS_Library *library,
+                             FT_Library ftlibrary, int idx)
 {
-	int rc;
-	const char* name = library-&gt;fontdata[idx].name;
-	const char* data = library-&gt;fontdata[idx].data;
-	int data_size = library-&gt;fontdata[idx].size;
+    int rc;
+    const char *name = library-&gt;fontdata[idx].name;
+    const char *data = library-&gt;fontdata[idx].data;
+    int data_size = library-&gt;fontdata[idx].size;
 
-#if (FC_VERSION &lt; 20402)
-	struct stat st;
-	char* fname;
-	const char* fonts_dir = library-&gt;fonts_dir;
-	char buf[1000];
-	FILE* fp = 0;
+    FT_Face face;
+    FcPattern *pattern;
+    FcFontSet *fset;
+    FcBool res;
+    int face_index, num_faces = 1;
 
-	if (!fonts_dir)
-		return;
-	rc = stat(fonts_dir, &amp;st);
-	if (rc) {
-		int res;
-#ifndef __MINGW32__
-		res = mkdir(fonts_dir, 0700);
-#else
-		res = mkdir(fonts_dir);
-#endif
-		if (res) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FailedToCreateDirectory, fonts_dir);
-		}
-	} else if (!S_ISDIR(st.st_mode)) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NotADirectory, fonts_dir);
-	}
-	
-	fname = validate_fname((char*)name);
+    for (face_index = 0; face_index &lt; num_faces; ++face_index) {
+        rc = FT_New_Memory_Face(ftlibrary, (unsigned char *) data,
+                                data_size, face_index, &amp;face);
+        if (rc) {
+            ass_msg(library, MSGL_WARN, &quot;Error opening memory font: %s&quot;,
+                   name);
+            return;
+        }
+        num_faces = face-&gt;num_faces;
 
-	snprintf(buf, 1000, &quot;%s/%s&quot;, fonts_dir, fname);
-	free(fname);
+        pattern =
+            FcFreeTypeQueryFace(face, (unsigned char *) name, face_index,
+                                FcConfigGetBlanks(priv-&gt;config));
+        if (!pattern) {
+            ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcFreeTypeQueryFace&quot;);
+            FT_Done_Face(face);
+            return;
+        }
 
-	fp = fopen(buf, &quot;wb&quot;);
-	if (!fp) return;
+        fset = FcConfigGetFonts(priv-&gt;config, FcSetSystem);     // somehow it failes when asked for FcSetApplication
+        if (!fset) {
+            ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcConfigGetFonts&quot;);
+            FT_Done_Face(face);
+            return;
+        }
 
-	fwrite(data, data_size, 1, fp);
-	fclose(fp);
+        res = FcFontSetAdd(fset, pattern);
+        if (!res) {
+            ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcFontSetAdd&quot;);
+            FT_Done_Face(face);
+            return;
+        }
 
-#else // (FC_VERSION &gt;= 20402)
-	FT_Face face;
-	FcPattern* pattern;
-	FcFontSet* fset;
-	FcBool res;
-
-	rc = FT_New_Memory_Face(ftlibrary, (unsigned char*)data, data_size, 0, &amp;face);
-	if (rc) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningMemoryFont, name);
-		return;
-	}
-
-	pattern = FcFreeTypeQueryFace(face, (unsigned char*)name, 0, FcConfigGetBlanks(priv-&gt;config));
-	if (!pattern) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcFreeTypeQueryFace&quot;);
-		FT_Done_Face(face);
-		return;
-	}
-
-	fset = FcConfigGetFonts(priv-&gt;config, FcSetSystem); // somehow it failes when asked for FcSetApplication
-	if (!fset) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcConfigGetFonts&quot;);
-		FT_Done_Face(face);
-		return;
-	}
-
-	res = FcFontSetAdd(fset, pattern);
-	if (!res) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcFontSetAdd&quot;);
-		FT_Done_Face(face);
-		return;
-	}
-
-	FT_Done_Face(face);
-#endif
+        FT_Done_Face(face);
+    }
 }
 
 /**
@@ -311,103 +416,118 @@
  * \param ftlibrary freetype library object
  * \param family default font family
  * \param path default font path
+ * \param fc whether fontconfig should be used
+ * \param config path to a fontconfig configuration file, or NULL
+ * \param update whether the fontconfig cache should be built/updated
  * \return pointer to fontconfig private data
-*/ 
-fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path)
+*/
+FCInstance *fontconfig_init(ASS_Library *library,
+                            FT_Library ftlibrary, const char *family,
+                            const char *path, int fc, const char *config,
+                            int update)
 {
-	int rc;
-	fc_instance_t* priv = calloc(1, sizeof(fc_instance_t));
-	const char* dir = library-&gt;fonts_dir;
-	int i;
-	
-	rc = FcInit();
-	assert(rc);
+    int rc;
+    FCInstance *priv = calloc(1, sizeof(FCInstance));
+    const char *dir = library-&gt;fonts_dir;
+    int i;
 
-	priv-&gt;config = FcConfigGetCurrent();
-	if (!priv-&gt;config) {
-		mp_msg(MSGT_ASS, MSGL_FATAL, MSGTR_LIBASS_FcInitLoadConfigAndFontsFailed);
-		return 0;
-	}
+    if (!fc) {
+        ass_msg(library, MSGL_WARN,
+               &quot;Fontconfig disabled, only default font will be used.&quot;);
+        goto exit;
+    }
 
-	for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
-		process_fontdata(priv, library, ftlibrary, i);
+    priv-&gt;config = FcConfigCreate();
+    rc = FcConfigParseAndLoad(priv-&gt;config, (unsigned char *) config, FcTrue);
+    if (!rc) {
+        ass_msg(library, MSGL_WARN, &quot;No usable fontconfig configuration &quot;
+                &quot;file found, using fallback.&quot;);
+        FcConfigDestroy(priv-&gt;config);
+        priv-&gt;config = FcInitLoadConfig();
+        rc++;
+    }
+    if (rc &amp;&amp; update) {
+        FcConfigBuildFonts(priv-&gt;config);
+    }
 
-	if (FcDirCacheValid((const FcChar8 *)dir) == FcFalse)
-	{
-		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_UpdatingFontCache);
-		if (FcGetVersion() &gt;= 20390 &amp;&amp; FcGetVersion() &lt; 20400)
-			mp_msg(MSGT_ASS, MSGL_WARN,
-			       MSGTR_LIBASS_BetaVersionsOfFontconfigAreNotSupported);
-		// FontConfig &gt;= 2.4.0 updates cache automatically in FcConfigAppFontAddDir()
-		if (FcGetVersion() &lt; 20390) {
-			FcFontSet* fcs;
-			FcStrSet* fss;
-			fcs = FcFontSetCreate();
-			fss = FcStrSetCreate();
-			rc = FcStrSetAdd(fss, (const FcChar8*)dir);
-			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcStrSetAddFailed);
-				goto ErrorFontCache;
-			}
+    if (!rc || !priv-&gt;config) {
+        ass_msg(library, MSGL_FATAL,
+                &quot;No valid fontconfig configuration found!&quot;);
+        FcConfigDestroy(priv-&gt;config);
+        goto exit;
+    }
 
-			rc = FcDirScan(fcs, fss, NULL, FcConfigGetBlanks(priv-&gt;config), (const FcChar8 *)dir, FcFalse);
-			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcDirScanFailed);
-				goto ErrorFontCache;
-			}
+    for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
+        process_fontdata(priv, library, ftlibrary, i);
 
-			rc = FcDirSave(fcs, fss, (const FcChar8 *)dir);
-			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcDirSave);
-				goto ErrorFontCache;
-			}
-		ErrorFontCache:
-			;
-		}
-	}
+    if (dir) {
+        ass_msg(library, MSGL_V, &quot;Updating font cache&quot;);
 
-	rc = FcConfigAppFontAddDir(priv-&gt;config, (const FcChar8*)dir);
-	if (!rc) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcConfigAppFontAddDirFailed);
-	}
+        rc = FcConfigAppFontAddDir(priv-&gt;config, (const FcChar8 *) dir);
+        if (!rc) {
+            ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcConfigAppFontAddDir&quot;);
+        }
+    }
 
-	priv-&gt;family_default = family ? strdup(family) : 0;
-	priv-&gt;path_default = path ? strdup(path) : 0;
-	priv-&gt;index_default = 0;
+    priv-&gt;family_default = family ? strdup(family) : NULL;
+exit:
+    priv-&gt;path_default = path ? strdup(path) : NULL;
+    priv-&gt;index_default = 0;
 
-	return priv;
+    return priv;
 }
 
-#else // HAVE_FONTCONFIG
+int fontconfig_update(FCInstance *priv)
+{
+        return FcConfigBuildFonts(priv-&gt;config);
+}
 
-char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
-			uint32_t code)
+#else                           /* CONFIG_FONTCONFIG */
+
+char *fontconfig_select(ASS_Library *library, FCInstance *priv,
+                        const char *family, int treat_family_as_pattern,
+                        unsigned bold, unsigned italic, int *index,
+                        uint32_t code)
 {
-	*index = priv-&gt;index_default;
-	return priv-&gt;path_default;
+    *index = priv-&gt;index_default;
+    char* res = priv-&gt;path_default ? strdup(priv-&gt;path_default) : 0;
+    return res;
 }
 
-fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path)
+FCInstance *fontconfig_init(ASS_Library *library,
+                            FT_Library ftlibrary, const char *family,
+                            const char *path, int fc, const char *config,
+                            int update)
 {
-	fc_instance_t* priv;
+    FCInstance *priv;
 
-	mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FontconfigDisabledDefaultFontWillBeUsed);
-	
-	priv = calloc(1, sizeof(fc_instance_t));
-	
-	priv-&gt;path_default = strdup(path);
-	priv-&gt;index_default = 0;
-	return priv;
+    ass_msg(library, MSGL_WARN,
+        &quot;Fontconfig disabled, only default font will be used.&quot;);
+
+    priv = calloc(1, sizeof(FCInstance));
+
+    priv-&gt;path_default = path ? strdup(path) : 0;
+    priv-&gt;index_default = 0;
+    return priv;
 }
 
+int fontconfig_update(FCInstance *priv)
+{
+    // Do nothing
+    return 1;
+}
+
 #endif
 
-void fontconfig_done(fc_instance_t* priv)
+void fontconfig_done(FCInstance *priv)
 {
-	// don't call FcFini() here, library can still be used by some code
-	if (priv &amp;&amp; priv-&gt;path_default) free(priv-&gt;path_default);
-	if (priv &amp;&amp; priv-&gt;family_default) free(priv-&gt;family_default);
-	if (priv) free(priv);
+
+    if (priv) {
+#ifdef CONFIG_FONTCONFIG
+        FcConfigDestroy(priv-&gt;config);
+#endif
+        free(priv-&gt;path_default);
+        free(priv-&gt;family_default);
+    }
+    free(priv);
 }
-
-

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.h	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,35 +1,47 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#ifndef LIBASS_FONTCONFIG_H
+#define LIBASS_FONTCONFIG_H
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
+#include &lt;stdint.h&gt;
+#include &quot;ass_types.h&quot;
+#include &quot;ass.h&quot;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
 
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_FONTCONFIG_H
-#define ASS_FONTCONFIG_H
-
-#ifdef HAVE_FONTCONFIG
+#ifdef CONFIG_FONTCONFIG
 #include &lt;fontconfig/fontconfig.h&gt;
 #endif
 
-typedef struct fc_instance_s fc_instance_t;
+typedef struct fc_instance FCInstance;
 
-fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path);
-char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index, uint32_t code);
-void fontconfig_done(fc_instance_t* priv);
+FCInstance *fontconfig_init(ASS_Library *library,
+                            FT_Library ftlibrary, const char *family,
+                            const char *path, int fc, const char *config,
+                            int update);
+char *fontconfig_select(ASS_Library *library, FCInstance *priv,
+                        const char *family, int treat_family_as_pattern,
+                        unsigned bold, unsigned italic, int *index,
+                        uint32_t code);
+void fontconfig_done(FCInstance *priv);
+int fontconfig_update(FCInstance *priv);
 
-#endif
-
+#endif                          /* LIBASS_FONTCONFIG_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.c	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,93 +1,148 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#include &quot;ADM_coreConfig.h&quot;
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
 #include &lt;inttypes.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
+#include &lt;stdarg.h&gt;
 
 #include &quot;ass.h&quot;
 #include &quot;ass_library.h&quot;
+#include &quot;ass_utils.h&quot;
 
+static void ass_msg_handler(int level, const char *fmt, va_list va, void *data)
+{
+    if (level &gt; MSGL_INFO)
+        return;
+    fprintf(stderr, &quot;[ass] &quot;);
+    vfprintf(stderr, fmt, va);
+    fprintf(stderr, &quot;\n&quot;);
+}
 
-ass_library_t* ass_library_init(void)
+ASS_Library *ass_library_init(void)
 {
-	return calloc(1, sizeof(ass_library_t));
+    ASS_Library* lib = calloc(1, sizeof(*lib));
+    lib-&gt;msg_callback = ass_msg_handler;
+
+    return lib;
 }
 
-void ass_library_done(ass_library_t* priv)
+void ass_library_done(ASS_Library *priv)
 {
-	if (priv) {
-		ass_set_fonts_dir(priv, NULL);
-		ass_set_style_overrides(priv, NULL);
-		free(priv);
-	}
+    if (priv) {
+        ass_set_fonts_dir(priv, NULL);
+        ass_set_style_overrides(priv, NULL);
+        ass_clear_fonts(priv);
+        free(priv);
+    }
 }
 
-void ass_set_fonts_dir(ass_library_t* priv, const char* fonts_dir)
+void ass_set_fonts_dir(ASS_Library *priv, const char *fonts_dir)
 {
-	if (priv-&gt;fonts_dir)
-		free(priv-&gt;fonts_dir);
+    free(priv-&gt;fonts_dir);
 
-	priv-&gt;fonts_dir = fonts_dir ? strdup(fonts_dir) : 0;
+    priv-&gt;fonts_dir = fonts_dir ? strdup(fonts_dir) : 0;
 }
 
-void ass_set_extract_fonts(ass_library_t* priv, int extract)
+void ass_set_extract_fonts(ASS_Library *priv, int extract)
 {
-	priv-&gt;extract_fonts = !!extract;
+    priv-&gt;extract_fonts = !!extract;
 }
 
-void ass_set_style_overrides(ass_library_t* priv, char** list)
+void ass_set_style_overrides(ASS_Library *priv, char **list)
 {
-	char** p;
-	char** q;
-	int cnt;
-	
-	if (priv-&gt;style_overrides) {
-		for (p = priv-&gt;style_overrides; *p; ++p)
-			free(*p);
-		free(priv-&gt;style_overrides);
-	}
-	
-	if (!list) return;
+    char **p;
+    char **q;
+    int cnt;
 
-	for (p = list, cnt = 0; *p; ++p, ++cnt) {}
+    if (priv-&gt;style_overrides) {
+        for (p = priv-&gt;style_overrides; *p; ++p)
+            free(*p);
+    }
+    free(priv-&gt;style_overrides);
 
-	priv-&gt;style_overrides = malloc((cnt + 1) * sizeof(char*));
-	for (p = list, q = priv-&gt;style_overrides; *p; ++p, ++q)
-		*q = strdup(*p);
-	priv-&gt;style_overrides[cnt] = NULL;
+    if (!list)
+        return;
+
+    for (p = list, cnt = 0; *p; ++p, ++cnt) {
+    }
+
+    priv-&gt;style_overrides = malloc((cnt + 1) * sizeof(char *));
+    for (p = list, q = priv-&gt;style_overrides; *p; ++p, ++q)
+        *q = strdup(*p);
+    priv-&gt;style_overrides[cnt] = NULL;
 }
 
 static void grow_array(void **array, int nelem, size_t elsize)
 {
-	if (!(nelem &amp; 31))
-		*array = realloc(*array, (nelem + 32) * elsize);
+    if (!(nelem &amp; 31))
+        *array = realloc(*array, (nelem + 32) * elsize);
 }
 
-void ass_add_font(ass_library_t* priv, char* name, char* data, int size)
+void ass_add_font(ASS_Library *priv, char *name, char *data, int size)
 {
-	grow_array((void**)&amp;priv-&gt;fontdata, priv-&gt;num_fontdata, sizeof(*priv-&gt;fontdata));
-	priv-&gt;fontdata[priv-&gt;num_fontdata].name = name;
-	priv-&gt;fontdata[priv-&gt;num_fontdata].data = data;
-	priv-&gt;fontdata[priv-&gt;num_fontdata].size = size;
-	priv-&gt;num_fontdata ++;
+    int idx = priv-&gt;num_fontdata;
+    if (!name || !data || !size)
+        return;
+    grow_array((void **) &amp;priv-&gt;fontdata, priv-&gt;num_fontdata,
+               sizeof(*priv-&gt;fontdata));
+
+    priv-&gt;fontdata[idx].name = strdup(name);
+
+    priv-&gt;fontdata[idx].data = malloc(size);
+    memcpy(priv-&gt;fontdata[idx].data, data, size);
+
+    priv-&gt;fontdata[idx].size = size;
+
+    priv-&gt;num_fontdata++;
 }
 
+void ass_clear_fonts(ASS_Library *priv)
+{
+    int i;
+    for (i = 0; i &lt; priv-&gt;num_fontdata; ++i) {
+        free(priv-&gt;fontdata[i].name);
+        free(priv-&gt;fontdata[i].data);
+    }
+    free(priv-&gt;fontdata);
+    priv-&gt;fontdata = NULL;
+    priv-&gt;num_fontdata = 0;
+}
+
+/*
+ * Register a message callback function with libass.  Without setting one,
+ * a default handler is used which prints everything with MSGL_INFO or
+ * higher to the standard output.
+ *
+ * \param msg_cb the callback function
+ * \param data additional data that will be passed to the callback
+ */
+void ass_set_message_cb(ASS_Library *priv,
+                        void (*msg_cb)(int, const char *, va_list, void *),
+                        void *data)
+{
+    if (msg_cb) {
+        priv-&gt;msg_callback = msg_cb;
+        priv-&gt;msg_callback_data = data;
+    }
+}

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.h	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,40 +1,43 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#ifndef LIBASS_LIBRARY_H
+#define LIBASS_LIBRARY_H
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
+#include &lt;stdarg.h&gt;
 
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
+typedef struct {
+    char *name;
+    char *data;
+    int size;
+} ASS_Fontdata;
 
-#ifndef ASS_LIBRARY_H
-#define ASS_LIBRARY_H
+struct ass_library {
+    char *fonts_dir;
+    int extract_fonts;
+    char **style_overrides;
 
-typedef struct ass_fontdata_s {
-	char* name;
-	char* data;
-	int size;
-} ass_fontdata_t;
-
-struct ass_library_s {
-	char* fonts_dir;
-	int extract_fonts;
-	char** style_overrides;
-
-	ass_fontdata_t* fontdata;
-	int num_fontdata;
+    ASS_Fontdata *fontdata;
+    int num_fontdata;
+    void (*msg_callback)(int, const char *, va_list, void *);
+    void *msg_callback_data;
 };
 
-#endif
-
+#endif                          /* LIBASS_LIBRARY_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_parse.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_parse.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_parse.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -0,0 +1,927 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at geekmind.org</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include &quot;ADM_coreConfig.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;ass_render.h&quot;
+#include &quot;ass_parse.h&quot;
+
+#define MAX_BE 127
+#define NBSP 0xa0   // unicode non-breaking space character
+
+#define skip_to(x) while ((*p != (x)) &amp;&amp; (*p != '}') &amp;&amp; (*p != 0)) { ++p;}
+#define skip(x) if (*p == (x)) ++p; else { return p; }
+#define skipopt(x) if (*p == (x)) { ++p; }
+
+/**
+ * \brief Check if starting part of (*p) matches sample.
+ * If true, shift p to the first symbol after the matching part.
+ */
+static inline int mystrcmp(char **p, const char *sample)
+{
+    int len = strlen(sample);
+    if (strncmp(*p, sample, len) == 0) {
+        (*p) += len;
+        return 1;
+    } else
+        return 0;
+}
+
+static void change_font_size(ASS_Renderer *render_priv, double sz)
+{
+    double size = sz * render_priv-&gt;font_scale;
+
+    if (size &lt; 1)
+        size = 1;
+    else if (size &gt; render_priv-&gt;height * 2)
+        size = render_priv-&gt;height * 2;
+
+    ass_font_set_size(render_priv-&gt;state.font, size);
+
+    render_priv-&gt;state.font_size = sz;
+}
+
+/**
+ * \brief Change current font, using setting from render_priv-&gt;state.
+ */
+void update_font(ASS_Renderer *render_priv)
+{
+    unsigned val;
+    ASS_FontDesc desc;
+    desc.treat_family_as_pattern = render_priv-&gt;state.treat_family_as_pattern;
+
+    if (render_priv-&gt;state.family[0] == '@') {
+        desc.vertical = 1;
+        desc.family = strdup(render_priv-&gt;state.family + 1);
+    } else {
+        desc.vertical = 0;
+        desc.family = strdup(render_priv-&gt;state.family);
+    }
+
+    val = render_priv-&gt;state.bold;
+    // 0 = normal, 1 = bold, &gt;1 = exact weight
+    if (val == 1 || val == -1)
+        val = 200;              // bold
+    else if (val &lt;= 0)
+        val = 80;               // normal
+    desc.bold = val;
+
+    val = render_priv-&gt;state.italic;
+    if (val == 1 || val == -1)
+        val = 110;              // italic
+    else if (val &lt;= 0)
+        val = 0;                // normal
+    desc.italic = val;
+
+    render_priv-&gt;state.font =
+        ass_font_new(render_priv-&gt;cache.font_cache, render_priv-&gt;library,
+                     render_priv-&gt;ftlibrary, render_priv-&gt;fontconfig_priv,
+                     &amp;desc);
+    free(desc.family);
+
+    if (render_priv-&gt;state.font)
+        change_font_size(render_priv, render_priv-&gt;state.font_size);
+}
+
+/**
+ * \brief Change border width
+ * negative value resets border to style value
+ */
+void change_border(ASS_Renderer *render_priv, double border_x,
+                   double border_y)
+{
+    int bord;
+    if (!render_priv-&gt;state.font)
+        return;
+
+    if (border_x &lt; 0 &amp;&amp; border_y &lt; 0) {
+        if (render_priv-&gt;state.style-&gt;BorderStyle == 1 ||
+            render_priv-&gt;state.style-&gt;BorderStyle == 3)
+            border_x = border_y = render_priv-&gt;state.style-&gt;Outline;
+        else
+            border_x = border_y = 1.;
+    }
+
+    render_priv-&gt;state.border_x = border_x;
+    render_priv-&gt;state.border_y = border_y;
+
+    bord = 64 * border_x * render_priv-&gt;border_scale;
+    if (bord &gt; 0 &amp;&amp; border_x == border_y) {
+        if (!render_priv-&gt;state.stroker) {
+            int error;
+            error =
+                FT_Stroker_New(render_priv-&gt;ftlibrary,
+                               &amp;render_priv-&gt;state.stroker);
+            if (error) {
+                ass_msg(render_priv-&gt;library, MSGL_V,
+                        &quot;failed to get stroker&quot;);
+                render_priv-&gt;state.stroker = 0;
+            }
+        }
+        if (render_priv-&gt;state.stroker)
+            FT_Stroker_Set(render_priv-&gt;state.stroker, bord,
+                           FT_STROKER_LINECAP_ROUND,
+                           FT_STROKER_LINEJOIN_ROUND, 0);
+    } else {
+        FT_Stroker_Done(render_priv-&gt;state.stroker);
+        render_priv-&gt;state.stroker = 0;
+    }
+}
+
+/**
+ * \brief Calculate a weighted average of two colors
+ * calculates c1*(1-a) + c2*a, but separately for each component except alpha
+ */
+static void change_color(uint32_t *var, uint32_t new, double pwr)
+{
+    (*var) = ((uint32_t) (_r(*var) * (1 - pwr) + _r(new) * pwr) &lt;&lt; 24) +
+        ((uint32_t) (_g(*var) * (1 - pwr) + _g(new) * pwr) &lt;&lt; 16) +
+        ((uint32_t) (_b(*var) * (1 - pwr) + _b(new) * pwr) &lt;&lt; 8) + _a(*var);
+}
+
+// like change_color, but for alpha component only
+inline void change_alpha(uint32_t *var, uint32_t new, double pwr)
+{
+    *var =
+        (_r(*var) &lt;&lt; 24) + (_g(*var) &lt;&lt; 16) + (_b(*var) &lt;&lt; 8) +
+        (uint32_t) (_a(*var) * (1 - pwr) + _a(new) * pwr);
+}
+
+/**
+ * \brief Multiply two alpha values
+ * \param a first value
+ * \param b second value
+ * \return result of multiplication
+ * Parameters and result are limited by 0xFF.
+ */
+inline uint32_t mult_alpha(uint32_t a, uint32_t b)
+{
+    return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;
+}
+
+/**
+ * \brief Calculate alpha value by piecewise linear function
+ * Used for \fad, \fade implementation.
+ */
+static unsigned
+interpolate_alpha(long long now, long long t1, long long t2, long long t3,
+                  long long t4, unsigned a1, unsigned a2, unsigned a3)
+{
+    unsigned a;
+    double cf;
+    if (now &lt;= t1) {
+        a = a1;
+    } else if (now &gt;= t4) {
+        a = a3;
+    } else if (now &lt; t2) {      // and &gt; t1
+        cf = ((double) (now - t1)) / (t2 - t1);
+        a = a1 * (1 - cf) + a2 * cf;
+    } else if (now &gt; t3) {
+        cf = ((double) (now - t3)) / (t4 - t3);
+        a = a2 * (1 - cf) + a3 * cf;
+    } else {                    // t2 &lt;= now &lt;= t3
+        a = a2;
+    }
+
+    return a;
+}
+
+/**
+ * Parse a vector clip into an outline, using the proper scaling
+ * parameters.  Translate it to correct for screen borders, if needed.
+ */
+static char *parse_vector_clip(ASS_Renderer *render_priv, char *p)
+{
+    int scale = 1;
+    int res = 0;
+    ASS_Drawing *drawing = render_priv-&gt;state.clip_drawing;
+
+    if (drawing &amp;&amp; drawing-&gt;glyph)
+        FT_Done_Glyph((FT_Glyph) drawing-&gt;glyph);
+    ass_drawing_free(drawing);
+    render_priv-&gt;state.clip_drawing = ass_drawing_new(
+        render_priv-&gt;fontconfig_priv,
+        render_priv-&gt;state.font,
+        render_priv-&gt;ftlibrary);
+    drawing = render_priv-&gt;state.clip_drawing;
+    skipopt('(');
+    res = mystrtoi(&amp;p, &amp;scale);
+    skipopt(',')
+    if (!res)
+        scale = 1;
+    drawing-&gt;scale = scale;
+    drawing-&gt;scale_x = render_priv-&gt;font_scale_x * render_priv-&gt;font_scale;
+    drawing-&gt;scale_y = render_priv-&gt;font_scale;
+    while (*p != ')' &amp;&amp; *p != '}' &amp;&amp; p != 0)
+        ass_drawing_add_char(drawing, *p++);
+    skipopt(')');
+
+    return p;
+}
+
+/**
+ * \brief Parse style override tag.
+ * \param p string to parse
+ * \param pwr multiplier for some tag effects (comes from \t tags)
+ */
+static char *parse_tag(ASS_Renderer *render_priv, char *p, double pwr)
+{
+    skip_to('\\');
+    skip('\\');
+    if ((*p == '}') || (*p == 0))
+        return p;
+
+    // New tags introduced in vsfilter 2.39
+    if (mystrcmp(&amp;p, &quot;xbord&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.border_x * (1 - pwr) + val * pwr;
+        else
+            val = -1.;
+        change_border(render_priv, val, render_priv-&gt;state.border_y);
+    } else if (mystrcmp(&amp;p, &quot;ybord&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.border_y * (1 - pwr) + val * pwr;
+        else
+            val = -1.;
+        change_border(render_priv, render_priv-&gt;state.border_x, val);
+    } else if (mystrcmp(&amp;p, &quot;xshad&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.shadow_x * (1 - pwr) + val * pwr;
+        else
+            val = 0.;
+        render_priv-&gt;state.shadow_x = val;
+    } else if (mystrcmp(&amp;p, &quot;yshad&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.shadow_y * (1 - pwr) + val * pwr;
+        else
+            val = 0.;
+        render_priv-&gt;state.shadow_y = val;
+    } else if (mystrcmp(&amp;p, &quot;fax&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.fax =
+                val * pwr + render_priv-&gt;state.fax * (1 - pwr);
+        else
+            render_priv-&gt;state.fax = 0.;
+    } else if (mystrcmp(&amp;p, &quot;fay&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.fay =
+                val * pwr + render_priv-&gt;state.fay * (1 - pwr);
+        else
+            render_priv-&gt;state.fay = 0.;
+    } else if (mystrcmp(&amp;p, &quot;iclip&quot;)) {
+        int x0, y0, x1, y1;
+        int res = 1;
+        char *start = p;
+        skipopt('(');
+        res &amp;= mystrtoi(&amp;p, &amp;x0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;x1);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y1);
+        skipopt(')');
+        if (res) {
+            render_priv-&gt;state.clip_x0 =
+                render_priv-&gt;state.clip_x0 * (1 - pwr) + x0 * pwr;
+            render_priv-&gt;state.clip_x1 =
+                render_priv-&gt;state.clip_x1 * (1 - pwr) + x1 * pwr;
+            render_priv-&gt;state.clip_y0 =
+                render_priv-&gt;state.clip_y0 * (1 - pwr) + y0 * pwr;
+            render_priv-&gt;state.clip_y1 =
+                render_priv-&gt;state.clip_y1 * (1 - pwr) + y1 * pwr;
+            render_priv-&gt;state.clip_mode = 1;
+        } else if (!render_priv-&gt;state.clip_drawing) {
+            p = parse_vector_clip(render_priv, start);
+            render_priv-&gt;state.clip_drawing_mode = 1;
+        } else
+            render_priv-&gt;state.clip_mode = 0;
+    } else if (mystrcmp(&amp;p, &quot;blur&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val = render_priv-&gt;state.blur * (1 - pwr) + val * pwr;
+            val = (val &lt; 0) ? 0 : val;
+            val = (val &gt; BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;
+            render_priv-&gt;state.blur = val;
+        } else
+            render_priv-&gt;state.blur = 0.0;
+        // ASS standard tags
+    } else if (mystrcmp(&amp;p, &quot;fsc&quot;)) {
+        char tp = *p++;
+        double val;
+        if (tp == 'x') {
+            if (mystrtod(&amp;p, &amp;val)) {
+                val /= 100;
+                render_priv-&gt;state.scale_x =
+                    render_priv-&gt;state.scale_x * (1 - pwr) + val * pwr;
+            } else
+                render_priv-&gt;state.scale_x =
+                    render_priv-&gt;state.style-&gt;ScaleX;
+        } else if (tp == 'y') {
+            if (mystrtod(&amp;p, &amp;val)) {
+                val /= 100;
+                render_priv-&gt;state.scale_y =
+                    render_priv-&gt;state.scale_y * (1 - pwr) + val * pwr;
+            } else
+                render_priv-&gt;state.scale_y =
+                    render_priv-&gt;state.style-&gt;ScaleY;
+        }
+    } else if (mystrcmp(&amp;p, &quot;fsp&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.hspacing =
+                render_priv-&gt;state.hspacing * (1 - pwr) + val * pwr;
+        else
+            render_priv-&gt;state.hspacing = render_priv-&gt;state.style-&gt;Spacing;
+    } else if (mystrcmp(&amp;p, &quot;fs&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.font_size * (1 - pwr) + val * pwr;
+        else
+            val = render_priv-&gt;state.style-&gt;FontSize;
+        if (render_priv-&gt;state.font)
+            change_font_size(render_priv, val);
+    } else if (mystrcmp(&amp;p, &quot;bord&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            if (render_priv-&gt;state.border_x == render_priv-&gt;state.border_y)
+                val = render_priv-&gt;state.border_x * (1 - pwr) + val * pwr;
+        } else
+            val = -1.;          // reset to default
+        change_border(render_priv, val, val);
+    } else if (mystrcmp(&amp;p, &quot;move&quot;)) {
+        double x1, x2, y1, y2;
+        long long t1, t2, delta_t, t;
+        double x, y;
+        double k;
+        skip('(');
+        mystrtod(&amp;p, &amp;x1);
+        skip(',');
+        mystrtod(&amp;p, &amp;y1);
+        skip(',');
+        mystrtod(&amp;p, &amp;x2);
+        skip(',');
+        mystrtod(&amp;p, &amp;y2);
+        if (*p == ',') {
+            skip(',');
+            mystrtoll(&amp;p, &amp;t1);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t2);
+            ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                   &quot;movement6: (%f, %f) -&gt; (%f, %f), (%&quot; PRId64 &quot; .. %&quot;
+                   PRId64 &quot;)\n&quot;, x1, y1, x2, y2, (int64_t) t1,
+                   (int64_t) t2);
+        } else {
+            t1 = 0;
+            t2 = render_priv-&gt;state.event-&gt;Duration;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                   &quot;movement: (%f, %f) -&gt; (%f, %f)&quot;, x1, y1, x2, y2);
+        }
+        skip(')');
+        delta_t = t2 - t1;
+        t = render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start;
+        if (t &lt; t1)
+            k = 0.;
+        else if (t &gt; t2)
+            k = 1.;
+        else
+            k = ((double) (t - t1)) / delta_t;
+        x = k * (x2 - x1) + x1;
+        y = k * (y2 - y1) + y1;
+        if (render_priv-&gt;state.evt_type != EVENT_POSITIONED) {
+            render_priv-&gt;state.pos_x = x;
+            render_priv-&gt;state.pos_y = y;
+            render_priv-&gt;state.detect_collisions = 0;
+            render_priv-&gt;state.evt_type = EVENT_POSITIONED;
+        }
+    } else if (mystrcmp(&amp;p, &quot;frx&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val *= M_PI / 180;
+            render_priv-&gt;state.frx =
+                val * pwr + render_priv-&gt;state.frx * (1 - pwr);
+        } else
+            render_priv-&gt;state.frx = 0.;
+    } else if (mystrcmp(&amp;p, &quot;fry&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val *= M_PI / 180;
+            render_priv-&gt;state.fry =
+                val * pwr + render_priv-&gt;state.fry * (1 - pwr);
+        } else
+            render_priv-&gt;state.fry = 0.;
+    } else if (mystrcmp(&amp;p, &quot;frz&quot;) || mystrcmp(&amp;p, &quot;fr&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val *= M_PI / 180;
+            render_priv-&gt;state.frz =
+                val * pwr + render_priv-&gt;state.frz * (1 - pwr);
+        } else
+            render_priv-&gt;state.frz =
+                M_PI * render_priv-&gt;state.style-&gt;Angle / 180.;
+    } else if (mystrcmp(&amp;p, &quot;fn&quot;)) {
+        char *start = p;
+        char *family;
+        skip_to('\\');
+        if (p &gt; start) {
+            family = malloc(p - start + 1);
+            strncpy(family, start, p - start);
+            family[p - start] = '\0';
+        } else
+            family = strdup(render_priv-&gt;state.style-&gt;FontName);
+        free(render_priv-&gt;state.family);
+        render_priv-&gt;state.family = family;
+        update_font(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;alpha&quot;)) {
+        uint32_t val;
+        int i;
+        int hex = render_priv-&gt;track-&gt;track_type == TRACK_TYPE_ASS;
+        if (strtocolor(render_priv-&gt;library, &amp;p, &amp;val, hex)) {
+            unsigned char a = val &gt;&gt; 24;
+            for (i = 0; i &lt; 4; ++i)
+                change_alpha(&amp;render_priv-&gt;state.c[i], a, pwr);
+        } else {
+            change_alpha(&amp;render_priv-&gt;state.c[0],
+                         render_priv-&gt;state.style-&gt;PrimaryColour, pwr);
+            change_alpha(&amp;render_priv-&gt;state.c[1],
+                         render_priv-&gt;state.style-&gt;SecondaryColour, pwr);
+            change_alpha(&amp;render_priv-&gt;state.c[2],
+                         render_priv-&gt;state.style-&gt;OutlineColour, pwr);
+            change_alpha(&amp;render_priv-&gt;state.c[3],
+                         render_priv-&gt;state.style-&gt;BackColour, pwr);
+        }
+        // FIXME: simplify
+    } else if (mystrcmp(&amp;p, &quot;an&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val) {
+            int v = (val - 1) / 3;      // 0, 1 or 2 for vertical alignment
+            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;an %d&quot;, val);
+            if (v != 0)
+                v = 3 - v;
+            val = ((val - 1) % 3) + 1;  // horizontal alignment
+            val += v * 4;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;align %d&quot;, val);
+            render_priv-&gt;state.alignment = val;
+        } else
+            render_priv-&gt;state.alignment =
+                render_priv-&gt;state.style-&gt;Alignment;
+    } else if (mystrcmp(&amp;p, &quot;a&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
+            // take care of a vsfilter quirk: handle illegal \a8 like \a5
+            render_priv-&gt;state.alignment = (val == 8) ? 5 : val;
+        else
+            render_priv-&gt;state.alignment =
+                render_priv-&gt;state.style-&gt;Alignment;
+    } else if (mystrcmp(&amp;p, &quot;pos&quot;)) {
+        double v1, v2;
+        skip('(');
+        mystrtod(&amp;p, &amp;v1);
+        skip(',');
+        mystrtod(&amp;p, &amp;v2);
+        skip(')');
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;pos(%f, %f)&quot;, v1, v2);
+        if (render_priv-&gt;state.evt_type == EVENT_POSITIONED) {
+            ass_msg(render_priv-&gt;library, MSGL_V, &quot;Subtitle has a new \\pos &quot;
+                   &quot;after \\move or \\pos, ignoring&quot;);
+        } else {
+            render_priv-&gt;state.evt_type = EVENT_POSITIONED;
+            render_priv-&gt;state.detect_collisions = 0;
+            render_priv-&gt;state.pos_x = v1;
+            render_priv-&gt;state.pos_y = v2;
+        }
+    } else if (mystrcmp(&amp;p, &quot;fad&quot;)) {
+        int a1, a2, a3;
+        long long t1, t2, t3, t4;
+        if (*p == 'e')
+            ++p;                // either \fad or \fade
+        skip('(');
+        mystrtoi(&amp;p, &amp;a1);
+        skip(',');
+        mystrtoi(&amp;p, &amp;a2);
+        if (*p == ')') {
+            // 2-argument version (\fad, according to specs)
+            // a1 and a2 are fade-in and fade-out durations
+            t1 = 0;
+            t4 = render_priv-&gt;state.event-&gt;Duration;
+            t2 = a1;
+            t3 = t4 - a2;
+            a1 = 0xFF;
+            a2 = 0;
+            a3 = 0xFF;
+        } else {
+            // 6-argument version (\fade)
+            // a1 and a2 (and a3) are opacity values
+            skip(',');
+            mystrtoi(&amp;p, &amp;a3);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t1);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t2);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t3);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t4);
+        }
+        skip(')');
+        render_priv-&gt;state.fade =
+            interpolate_alpha(render_priv-&gt;time -
+                              render_priv-&gt;state.event-&gt;Start, t1, t2,
+                              t3, t4, a1, a2, a3);
+    } else if (mystrcmp(&amp;p, &quot;org&quot;)) {
+        int v1, v2;
+        skip('(');
+        mystrtoi(&amp;p, &amp;v1);
+        skip(',');
+        mystrtoi(&amp;p, &amp;v2);
+        skip(')');
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;org(%d, %d)&quot;, v1, v2);
+        if (!render_priv-&gt;state.have_origin) {
+            render_priv-&gt;state.org_x = v1;
+            render_priv-&gt;state.org_y = v2;
+            render_priv-&gt;state.have_origin = 1;
+            render_priv-&gt;state.detect_collisions = 0;
+        }
+    } else if (mystrcmp(&amp;p, &quot;t&quot;)) {
+        double v[3];
+        int v1, v2;
+        double v3;
+        int cnt;
+        long long t1, t2, t, delta_t;
+        double k;
+        skip('(');
+        for (cnt = 0; cnt &lt; 3; ++cnt) {
+            if (*p == '\\')
+                break;
+            mystrtod(&amp;p, &amp;v[cnt]);
+            skip(',');
+        }
+        if (cnt == 3) {
+            v1 = v[0];
+            v2 = (v[1] &lt; v1) ? render_priv-&gt;state.event-&gt;Duration : v[1];
+            v3 = v[2];
+        } else if (cnt == 2) {
+            v1 = v[0];
+            v2 = (v[1] &lt; v1) ? render_priv-&gt;state.event-&gt;Duration : v[1];
+            v3 = 1.;
+        } else if (cnt == 1) {
+            v1 = 0;
+            v2 = render_priv-&gt;state.event-&gt;Duration;
+            v3 = v[0];
+        } else {                // cnt == 0
+            v1 = 0;
+            v2 = render_priv-&gt;state.event-&gt;Duration;
+            v3 = 1.;
+        }
+        render_priv-&gt;state.detect_collisions = 0;
+        t1 = v1;
+        t2 = v2;
+        delta_t = v2 - v1;
+        if (v3 &lt; 0.)
+            v3 = 0.;
+        t = render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start;        // FIXME: move to render_context
+        if (t &lt;= t1)
+            k = 0.;
+        else if (t &gt;= t2)
+            k = 1.;
+        else {
+            assert(delta_t != 0.);
+            k = pow(((double) (t - t1)) / delta_t, v3);
+        }
+        while (*p == '\\')
+            p = parse_tag(render_priv, p, k);   // maybe k*pwr ? no, specs forbid nested \t's
+        skip_to(')');           // in case there is some unknown tag or a comment
+        skip(')');
+    } else if (mystrcmp(&amp;p, &quot;clip&quot;)) {
+        char *start = p;
+        int x0, y0, x1, y1;
+        int res = 1;
+        skipopt('(');
+        res &amp;= mystrtoi(&amp;p, &amp;x0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;x1);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y1);
+        skipopt(')');
+        if (res) {
+            render_priv-&gt;state.clip_x0 =
+                render_priv-&gt;state.clip_x0 * (1 - pwr) + x0 * pwr;
+            render_priv-&gt;state.clip_x1 =
+                render_priv-&gt;state.clip_x1 * (1 - pwr) + x1 * pwr;
+            render_priv-&gt;state.clip_y0 =
+                render_priv-&gt;state.clip_y0 * (1 - pwr) + y0 * pwr;
+            render_priv-&gt;state.clip_y1 =
+                render_priv-&gt;state.clip_y1 * (1 - pwr) + y1 * pwr;
+        // Might be a vector clip
+        } else if (!render_priv-&gt;state.clip_drawing) {
+            p = parse_vector_clip(render_priv, start);
+            render_priv-&gt;state.clip_drawing_mode = 0;
+        } else {
+            render_priv-&gt;state.clip_x0 = 0;
+            render_priv-&gt;state.clip_y0 = 0;
+            render_priv-&gt;state.clip_x1 = render_priv-&gt;track-&gt;PlayResX;
+            render_priv-&gt;state.clip_y1 = render_priv-&gt;track-&gt;PlayResY;
+        }
+    } else if (mystrcmp(&amp;p, &quot;c&quot;)) {
+        uint32_t val;
+        int hex = render_priv-&gt;track-&gt;track_type == TRACK_TYPE_ASS;
+        if (!strtocolor(render_priv-&gt;library, &amp;p, &amp;val, hex))
+            val = render_priv-&gt;state.style-&gt;PrimaryColour;
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;color: %X&quot;, val);
+        change_color(&amp;render_priv-&gt;state.c[0], val, pwr);
+    } else if ((*p &gt;= '1') &amp;&amp; (*p &lt;= '4') &amp;&amp; (++p)
+               &amp;&amp; (mystrcmp(&amp;p, &quot;c&quot;) || mystrcmp(&amp;p, &quot;a&quot;))) {
+        char n = *(p - 2);
+        int cidx = n - '1';
+        char cmd = *(p - 1);
+        uint32_t val;
+        int hex = render_priv-&gt;track-&gt;track_type == TRACK_TYPE_ASS;
+        assert((n &gt;= '1') &amp;&amp; (n &lt;= '4'));
+        if (!strtocolor(render_priv-&gt;library, &amp;p, &amp;val, hex))
+            switch (n) {
+            case '1':
+                val = render_priv-&gt;state.style-&gt;PrimaryColour;
+                break;
+            case '2':
+                val = render_priv-&gt;state.style-&gt;SecondaryColour;
+                break;
+            case '3':
+                val = render_priv-&gt;state.style-&gt;OutlineColour;
+                break;
+            case '4':
+                val = render_priv-&gt;state.style-&gt;BackColour;
+                break;
+            default:
+                val = 0;
+                break;          // impossible due to assert; avoid compilation warning
+            }
+        switch (cmd) {
+        case 'c':
+            change_color(render_priv-&gt;state.c + cidx, val, pwr);
+            break;
+        case 'a':
+            change_alpha(render_priv-&gt;state.c + cidx, val &gt;&gt; 24, pwr);
+            break;
+        default:
+            ass_msg(render_priv-&gt;library, MSGL_WARN, &quot;Bad command: %c%c&quot;,
+                    n, cmd);
+            break;
+        }
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;single c/a at %f: %c%c = %X&quot;,
+               pwr, n, cmd, render_priv-&gt;state.c[cidx]);
+    } else if (mystrcmp(&amp;p, &quot;r&quot;)) {
+        reset_render_context(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;be&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val)) {
+            // Clamp to a safe upper limit, since high values need excessive CPU
+            val = (val &lt; 0) ? 0 : val;
+            val = (val &gt; MAX_BE) ? MAX_BE : val;
+            render_priv-&gt;state.be = val;
+        } else
+            render_priv-&gt;state.be = 0;
+    } else if (mystrcmp(&amp;p, &quot;b&quot;)) {
+        int b;
+        if (mystrtoi(&amp;p, &amp;b)) {
+            if (pwr &gt;= .5)
+                render_priv-&gt;state.bold = b;
+        } else
+            render_priv-&gt;state.bold = render_priv-&gt;state.style-&gt;Bold;
+        update_font(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;i&quot;)) {
+        int i;
+        if (mystrtoi(&amp;p, &amp;i)) {
+            if (pwr &gt;= .5)
+                render_priv-&gt;state.italic = i;
+        } else
+            render_priv-&gt;state.italic = render_priv-&gt;state.style-&gt;Italic;
+        update_font(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;kf&quot;) || mystrcmp(&amp;p, &quot;K&quot;)) {
+        int val = 0;
+        mystrtoi(&amp;p, &amp;val);
+        render_priv-&gt;state.effect_type = EF_KARAOKE_KF;
+        if (render_priv-&gt;state.effect_timing)
+            render_priv-&gt;state.effect_skip_timing +=
+                render_priv-&gt;state.effect_timing;
+        render_priv-&gt;state.effect_timing = val * 10;
+    } else if (mystrcmp(&amp;p, &quot;ko&quot;)) {
+        int val = 0;
+        mystrtoi(&amp;p, &amp;val);
+        render_priv-&gt;state.effect_type = EF_KARAOKE_KO;
+        if (render_priv-&gt;state.effect_timing)
+            render_priv-&gt;state.effect_skip_timing +=
+                render_priv-&gt;state.effect_timing;
+        render_priv-&gt;state.effect_timing = val * 10;
+    } else if (mystrcmp(&amp;p, &quot;k&quot;)) {
+        int val = 0;
+        mystrtoi(&amp;p, &amp;val);
+        render_priv-&gt;state.effect_type = EF_KARAOKE;
+        if (render_priv-&gt;state.effect_timing)
+            render_priv-&gt;state.effect_skip_timing +=
+                render_priv-&gt;state.effect_timing;
+        render_priv-&gt;state.effect_timing = val * 10;
+    } else if (mystrcmp(&amp;p, &quot;shad&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            if (render_priv-&gt;state.shadow_x == render_priv-&gt;state.shadow_y)
+                val = render_priv-&gt;state.shadow_x * (1 - pwr) + val * pwr;
+        } else
+            val = 0.;
+        render_priv-&gt;state.shadow_x = render_priv-&gt;state.shadow_y = val;
+    } else if (mystrcmp(&amp;p, &quot;s&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
+            render_priv-&gt;state.flags |= DECO_STRIKETHROUGH;
+        else
+            render_priv-&gt;state.flags &amp;= ~DECO_STRIKETHROUGH;
+    } else if (mystrcmp(&amp;p, &quot;u&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
+            render_priv-&gt;state.flags |= DECO_UNDERLINE;
+        else
+            render_priv-&gt;state.flags &amp;= ~DECO_UNDERLINE;
+    } else if (mystrcmp(&amp;p, &quot;pbo&quot;)) {
+        double val = 0;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.drawing-&gt;pbo = val;
+    } else if (mystrcmp(&amp;p, &quot;p&quot;)) {
+        int val;
+        if (!mystrtoi(&amp;p, &amp;val))
+            val = 0;
+        if (val)
+            render_priv-&gt;state.drawing-&gt;scale = val;
+        render_priv-&gt;state.drawing_mode = !!val;
+    } else if (mystrcmp(&amp;p, &quot;q&quot;)) {
+        int val;
+        if (!mystrtoi(&amp;p, &amp;val))
+            val = render_priv-&gt;track-&gt;WrapStyle;
+        render_priv-&gt;state.wrap_style = val;
+    }
+
+    return p;
+}
+
+void apply_transition_effects(ASS_Renderer *render_priv, ASS_Event *event)
+{
+    int v[4];
+    int cnt;
+    char *p = event-&gt;Effect;
+
+    if (!p || !*p)
+        return;
+
+    cnt = 0;
+    while (cnt &lt; 4 &amp;&amp; (p = strchr(p, ';'))) {
+        v[cnt++] = atoi(++p);
+    }
+
+    if (strncmp(event-&gt;Effect, &quot;Banner;&quot;, 7) == 0) {
+        int delay;
+        if (cnt &lt; 1) {
+            ass_msg(render_priv-&gt;library, MSGL_V,
+                    &quot;Error parsing effect: '%s'&quot;, event-&gt;Effect);
+            return;
+        }
+        if (cnt &gt;= 2 &amp;&amp; v[1] == 0)      // right-to-left
+            render_priv-&gt;state.scroll_direction = SCROLL_RL;
+        else                    // left-to-right
+            render_priv-&gt;state.scroll_direction = SCROLL_LR;
+
+        delay = v[0];
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv-&gt;state.scroll_shift =
+            (render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start) / delay;
+        render_priv-&gt;state.evt_type = EVENT_HSCROLL;
+        return;
+    }
+
+    if (strncmp(event-&gt;Effect, &quot;Scroll up;&quot;, 10) == 0) {
+        render_priv-&gt;state.scroll_direction = SCROLL_BT;
+    } else if (strncmp(event-&gt;Effect, &quot;Scroll down;&quot;, 12) == 0) {
+        render_priv-&gt;state.scroll_direction = SCROLL_TB;
+    } else {
+        ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                &quot;Unknown transition effect: '%s'&quot;, event-&gt;Effect);
+        return;
+    }
+    // parse scroll up/down parameters
+    {
+        int delay;
+        int y0, y1;
+        if (cnt &lt; 3) {
+            ass_msg(render_priv-&gt;library, MSGL_V,
+                    &quot;Error parsing effect: '%s'&quot;, event-&gt;Effect);
+            return;
+        }
+        delay = v[2];
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv-&gt;state.scroll_shift =
+            (render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start) / delay;
+        if (v[0] &lt; v[1]) {
+            y0 = v[0];
+            y1 = v[1];
+        } else {
+            y0 = v[1];
+            y1 = v[0];
+        }
+        if (y1 == 0)
+            y1 = render_priv-&gt;track-&gt;PlayResY;  // y0=y1=0 means fullscreen scrolling
+        render_priv-&gt;state.clip_y0 = y0;
+        render_priv-&gt;state.clip_y1 = y1;
+        render_priv-&gt;state.evt_type = EVENT_VSCROLL;
+        render_priv-&gt;state.detect_collisions = 0;
+    }
+
+}
+
+/**
+ * \brief Get next ucs4 char from string, parsing and executing style overrides
+ * \param str string pointer
+ * \return ucs4 code of the next char
+ * On return str points to the unparsed part of the string
+ */
+unsigned get_next_char(ASS_Renderer *render_priv, char **str)
+{
+    char *p = *str;
+    unsigned chr;
+    if (*p == '{') {            // '\0' goes here
+        p++;
+        while (1) {
+            p = parse_tag(render_priv, p, 1.);
+            if (*p == '}') {    // end of tag
+                p++;
+                if (*p == '{') {
+                    p++;
+                    continue;
+                } else
+                    break;
+            } else if (*p != '\\')
+                ass_msg(render_priv-&gt;library, MSGL_V,
+                        &quot;Unable to parse: '%.30s'&quot;, p);
+            if (*p == 0)
+                break;
+        }
+    }
+    if (*p == '\t') {
+        ++p;
+        *str = p;
+        return ' ';
+    }
+    if (*p == '\\') {
+        if ((p[1] == 'N') || ((p[1] == 'n') &amp;&amp;
+                              (render_priv-&gt;state.wrap_style == 2))) {
+            p += 2;
+            *str = p;
+            return '\n';
+        } else if (p[1] == 'n') {
+            p += 2;
+            *str = p;
+            return ' ';
+        } else if (p[1] == 'h') {
+            p += 2;
+            *str = p;
+            return NBSP;
+        } else if (p[1] == '{') {
+            p += 2;
+            *str = p;
+            return '{';
+        } else if (p[1] == '}') {
+            p += 2;
+            *str = p;
+            return '}';
+        }
+    }
+    chr = ass_utf8_get_char((char **) &amp;p);
+    *str = p;
+    return chr;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_parse.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_parse.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_parse.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at geekmind.org</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef LIBASS_PARSE_H
+#define LIBASS_PARSE_H
+
+#define BLUR_MAX_RADIUS 100.0
+
+#define _r(c)   ((c) &gt;&gt; 24)
+#define _g(c)   (((c) &gt;&gt; 16) &amp; 0xFF)
+#define _b(c)   (((c) &gt;&gt; 8) &amp; 0xFF)
+#define _a(c)   ((c) &amp; 0xFF)
+
+void update_font(ASS_Renderer *render_priv);
+void change_border(ASS_Renderer *render_priv, double border_x,
+                   double border_y);
+void apply_transition_effects(ASS_Renderer *render_priv, ASS_Event *event);
+unsigned get_next_char(ASS_Renderer *render_priv, char **str);
+extern void change_alpha(uint32_t *var, uint32_t new, double pwr);
+extern uint32_t mult_alpha(uint32_t a, uint32_t b);
+
+
+#endif /* LIBASS_PARSE_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.c	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,308 +1,358 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#include &quot;ADM_coreConfig.h&quot;
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
+#include &lt;assert.h&gt;
+#include &lt;math.h&gt;
 
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
+#include &quot;ass_render.h&quot;
+#include &quot;ass_parse.h&quot;
 
-//#include &quot;config.h&quot;
+#define MAX_GLYPHS_INITIAL 1024
+#define MAX_LINES_INITIAL 64
+#define SUBPIXEL_MASK 63
+#define SUBPIXEL_ACCURACY 7
 
-#include &lt;assert.h&gt;
-#include &lt;math.h&gt;
-#include &lt;inttypes.h&gt;
-#include &lt;ft2build.h&gt;
-#include FT_FREETYPE_H
-#include FT_STROKER_H
-#include FT_GLYPH_H
-#include FT_SYNTHESIS_H
+static void ass_lazy_track_init(ASS_Renderer *render_priv)
+{
+    ASS_Track *track = render_priv-&gt;track;
 
-#include &quot;mputils.h&quot;
+    if (track-&gt;PlayResX &amp;&amp; track-&gt;PlayResY)
+        return;
+    if (!track-&gt;PlayResX &amp;&amp; !track-&gt;PlayResY) {
+        ass_msg(render_priv-&gt;library, MSGL_WARN,
+               &quot;Neither PlayResX nor PlayResY defined. Assuming 384x288&quot;);
+        track-&gt;PlayResX = 384;
+        track-&gt;PlayResY = 288;
+    } else {
+        if (!track-&gt;PlayResY &amp;&amp; track-&gt;PlayResX == 1280) {
+            track-&gt;PlayResY = 1024;
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                   &quot;PlayResY undefined, setting to %d&quot;, track-&gt;PlayResY);
+        } else if (!track-&gt;PlayResY) {
+            track-&gt;PlayResY = track-&gt;PlayResX * 3 / 4;
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                   &quot;PlayResY undefined, setting to %d&quot;, track-&gt;PlayResY);
+        } else if (!track-&gt;PlayResX &amp;&amp; track-&gt;PlayResY == 1024) {
+            track-&gt;PlayResX = 1280;
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                   &quot;PlayResX undefined, setting to %d&quot;, track-&gt;PlayResX);
+        } else if (!track-&gt;PlayResX) {
+            track-&gt;PlayResX = track-&gt;PlayResY * 4 / 3;
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                   &quot;PlayResX undefined, setting to %d&quot;, track-&gt;PlayResX);
+        }
+    }
+}
 
-#include &quot;ass.h&quot;
-#include &quot;ass_font.h&quot;
-#include &quot;ass_bitmap.h&quot;
-#include &quot;ass_cache.h&quot;
-#include &quot;ass_utils.h&quot;
-#include &quot;ass_fontconfig.h&quot;
-#include &quot;ass_library.h&quot;
+ASS_Renderer *ass_renderer_init(ASS_Library *library)
+{
+    int error;
+    FT_Library ft;
+    ASS_Renderer *priv = 0;
+    int vmajor, vminor, vpatch;
 
-#define MAX_GLYPHS 1000
-#define MAX_LINES 100
+    error = FT_Init_FreeType(&amp;ft);
+    if (error) {
+        ass_msg(library, MSGL_FATAL, &quot;%s failed&quot;, &quot;FT_Init_FreeType&quot;);
+        goto ass_init_exit;
+    }
 
-static int last_render_id = 0;
+    FT_Library_Version(ft, &amp;vmajor, &amp;vminor, &amp;vpatch);
+    ass_msg(library, MSGL_V, &quot;FreeType library version: %d.%d.%d&quot;,
+           vmajor, vminor, vpatch);
+    ass_msg(library, MSGL_V, &quot;FreeType headers version: %d.%d.%d&quot;,
+           FREETYPE_MAJOR, FREETYPE_MINOR, FREETYPE_PATCH);
 
-typedef struct ass_settings_s {
-	int frame_width;
-	int frame_height;
-	double font_size_coeff; // font size multiplier
-	double line_spacing; // additional line spacing (in frame pixels)
-	int top_margin; // height of top margin. Everything except toptitles is shifted down by top_margin.
-	int bottom_margin; // height of bottom margin. (frame_height - top_margin - bottom_margin) is original video height.
-	int left_margin;
-	int right_margin;
-	int use_margins; // 0 - place all subtitles inside original frame
-	                 // 1 - use margins for placing toptitles and subtitles
-	double aspect; // frame aspect ratio, d_width / d_height.
-	ass_hinting_t hinting;
+    priv = calloc(1, sizeof(ASS_Renderer));
+    if (!priv) {
+        FT_Done_FreeType(ft);
+        goto ass_init_exit;
+    }
 
-	char* default_font;
-	char* default_family;
-} ass_settings_t;
+    priv-&gt;synth_priv = ass_synth_init(BLUR_MAX_RADIUS);
 
-// a rendered event
-typedef struct event_images_s {
-	ass_image_t* imgs;
-	int top, height;
-	int detect_collisions;
-	int shift_direction;
-	ass_event_t* event;
-} event_images_t;
+    priv-&gt;library = library;
+    priv-&gt;ftlibrary = ft;
+    // images_root and related stuff is zero-filled in calloc
 
-struct ass_renderer_s {
-	ass_library_t* library;
-	FT_Library ftlibrary;
-	fc_instance_t* fontconfig_priv;
-	ass_settings_t settings;
-	int render_id;
-	ass_synth_priv_t* synth_priv;
+    priv-&gt;cache.font_cache = ass_font_cache_init(library);
+    priv-&gt;cache.bitmap_cache = ass_bitmap_cache_init(library);
+    priv-&gt;cache.composite_cache = ass_composite_cache_init(library);
+    priv-&gt;cache.glyph_cache = ass_glyph_cache_init(library);
+    priv-&gt;cache.glyph_max = GLYPH_CACHE_MAX;
+    priv-&gt;cache.bitmap_max_size = BITMAP_CACHE_MAX_SIZE;
 
-	ass_image_t* images_root; // rendering result is stored here
-	ass_image_t* prev_images_root;
+    priv-&gt;text_info.max_glyphs = MAX_GLYPHS_INITIAL;
+    priv-&gt;text_info.max_lines = MAX_LINES_INITIAL;
+    priv-&gt;text_info.glyphs = calloc(MAX_GLYPHS_INITIAL, sizeof(GlyphInfo));
+    priv-&gt;text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(LineInfo));
 
-	event_images_t* eimg; // temporary buffer for sorting rendered events
-	int eimg_size; // allocated buffer size
-};
+    priv-&gt;settings.font_size_coeff = 1.;
 
-typedef enum {EF_NONE = 0, EF_KARAOKE, EF_KARAOKE_KF, EF_KARAOKE_KO} effect_t;
+  ass_init_exit:
+    if (priv)
+        ass_msg(library, MSGL_V, &quot;Init&quot;);
+    else
+        ass_msg(library, MSGL_ERR, &quot;Init failed&quot;);
 
-// describes a glyph
-// glyph_info_t and text_info_t are used for text centering and word-wrapping operations
-typedef struct glyph_info_s {
-	unsigned symbol;
-	FT_Glyph glyph;
-	FT_Glyph outline_glyph;
-	bitmap_t* bm; // glyph bitmap
-	bitmap_t* bm_o; // outline bitmap
-	bitmap_t* bm_s; // shadow bitmap
-	FT_BBox bbox;
-	FT_Vector pos;
-	char linebreak; // the first (leading) glyph of some line ?
-	uint32_t c[4]; // colors
-	FT_Vector advance; // 26.6
-	effect_t effect_type;
-	int effect_timing; // time duration of current karaoke word
-	                   // after process_karaoke_effects: distance in pixels from the glyph origin.
-	                   // part of the glyph to the left of it is displayed in a different color.
-	int effect_skip_timing; // delay after the end of last karaoke word
-	int asc, desc; // font max ascender and descender
-//	int height;
-	int be; // blur edges
-	int shadow;
-	double frx, fry, frz; // rotation
-	
-	bitmap_hash_key_t hash_key;
-} glyph_info_t;
+    return priv;
+}
 
-typedef struct line_info_s {
-	int asc, desc;
-} line_info_t;
+static void free_list_clear(ASS_Renderer *render_priv)
+{
+    if (render_priv-&gt;free_head) {
+        FreeList *item = render_priv-&gt;free_head;
+        while(item) {
+            FreeList *oi = item;
+            free(item-&gt;object);
+            item = item-&gt;next;
+            free(oi);
+        }
+        render_priv-&gt;free_head = NULL;
+    }
+}
 
-typedef struct text_info_s {
-	glyph_info_t* glyphs;
-	int length;
-	line_info_t lines[MAX_LINES];
-	int n_lines;
-	int height;
-} text_info_t;
+void ass_renderer_done(ASS_Renderer *render_priv)
+{
+    ass_font_cache_done(render_priv-&gt;cache.font_cache);
+    ass_bitmap_cache_done(render_priv-&gt;cache.bitmap_cache);
+    ass_composite_cache_done(render_priv-&gt;cache.composite_cache);
+    ass_glyph_cache_done(render_priv-&gt;cache.glyph_cache);
 
+    ass_free_images(render_priv-&gt;images_root);
+    ass_free_images(render_priv-&gt;prev_images_root);
 
-// Renderer state.
-// Values like current font face, color, screen position, clipping and so on are stored here.
-typedef struct render_context_s {
-	ass_event_t* event;
-	ass_style_t* style;
-	
-	ass_font_t* font;
-	char* font_path;
-	double font_size;
-	
-	FT_Stroker stroker;
-	int alignment; // alignment overrides go here; if zero, style value will be used
-	double frx, fry, frz;
-	enum {	EVENT_NORMAL, // &quot;normal&quot; top-, sub- or mid- title
-		EVENT_POSITIONED, // happens after pos(,), margins are ignored
-		EVENT_HSCROLL, // &quot;Banner&quot; transition effect, text_width is unlimited
-		EVENT_VSCROLL // &quot;Scroll up&quot;, &quot;Scroll down&quot; transition effects
-		} evt_type;
-	int pos_x, pos_y; // position
-	int org_x, org_y; // origin
-	char have_origin; // origin is explicitly defined; if 0, get_base_point() is used
-	double scale_x, scale_y;
-	double hspacing; // distance between letters, in pixels
-	double border; // outline width
-	uint32_t c[4]; // colors(Primary, Secondary, so on) in RGBA
-	int clip_x0, clip_y0, clip_x1, clip_y1;
-	char detect_collisions;
-	uint32_t fade; // alpha from \fad
-	char be; // blur edges
-	int shadow;
+    if (render_priv-&gt;state.stroker) {
+        FT_Stroker_Done(render_priv-&gt;state.stroker);
+        render_priv-&gt;state.stroker = 0;
+    }
+    if (render_priv-&gt;ftlibrary)
+        FT_Done_FreeType(render_priv-&gt;ftlibrary);
+    if (render_priv-&gt;fontconfig_priv)
+        fontconfig_done(render_priv-&gt;fontconfig_priv);
+    if (render_priv-&gt;synth_priv)
+        ass_synth_done(render_priv-&gt;synth_priv);
+    free(render_priv-&gt;eimg);
+    free(render_priv-&gt;text_info.glyphs);
+    free(render_priv-&gt;text_info.lines);
 
-	effect_t effect_type;
-	int effect_timing;
-	int effect_skip_timing;
+    free(render_priv-&gt;settings.default_font);
+    free(render_priv-&gt;settings.default_family);
 
-	enum { SCROLL_LR, // left-to-right
-	       SCROLL_RL,
-	       SCROLL_TB, // top-to-bottom
-	       SCROLL_BT
-	       } scroll_direction; // for EVENT_HSCROLL, EVENT_VSCROLL
-	int scroll_shift;
+    free_list_clear(render_priv);
+    free(render_priv);
+}
 
-	// face properties
-	char* family;
-	unsigned bold;
-	unsigned italic;
-	
-} render_context_t;
+/**
+ * \brief Create a new ASS_Image
+ * Parameters are the same as ASS_Image fields.
+ */
+static ASS_Image *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,
+                                 int bitmap_h, int stride, int dst_x,
+                                 int dst_y, uint32_t color)
+{
+    ASS_Image *img = malloc(sizeof(ASS_Image));
 
-// frame-global data
-typedef struct frame_context_s {
-	ass_renderer_t* ass_priv;
-	int width, height; // screen dimensions
-	int orig_height; // frame height ( = screen height - margins )
-	int orig_width; // frame width ( = screen width - margins )
-	ass_track_t* track;
-	long long time; // frame's timestamp, ms
-	double font_scale;
-	double font_scale_x; // x scale applied to all glyphs to preserve text aspect ratio
-	double border_scale;
-} frame_context_t;
+    if (img) {
+        img-&gt;w = bitmap_w;
+        img-&gt;h = bitmap_h;
+        img-&gt;stride = stride;
+        img-&gt;bitmap = bitmap;
+        img-&gt;color = color;
+        img-&gt;dst_x = dst_x;
+        img-&gt;dst_y = dst_y;
+    }
 
-static ass_renderer_t* ass_renderer;
-static ass_settings_t* global_settings;
-static text_info_t text_info;
-static render_context_t render_context;
-static frame_context_t frame_context;
+    return img;
+}
 
-struct render_priv_s {
-	int top, height;
-	int render_id;
-};
+/**
+ * \brief Mapping between script and screen coordinates
+ */
+static double x2scr(ASS_Renderer *render_priv, double x)
+{
+    return x * render_priv-&gt;orig_width_nocrop / render_priv-&gt;font_scale_x /
+        render_priv-&gt;track-&gt;PlayResX +
+        FFMAX(render_priv-&gt;settings.left_margin, 0);
+}
+static double x2scr_pos(ASS_Renderer *render_priv, double x)
+{
+    return x * render_priv-&gt;orig_width / render_priv-&gt;font_scale_x / render_priv-&gt;track-&gt;PlayResX +
+        render_priv-&gt;settings.left_margin;
+}
+static double x2scr_scaled(ASS_Renderer *render_priv, double x)
+{
+    return x * render_priv-&gt;orig_width_nocrop /
+        render_priv-&gt;track-&gt;PlayResX +
+        FFMAX(render_priv-&gt;settings.left_margin, 0);
+}
+static double x2scr_pos_scaled(ASS_Renderer *render_priv, double x)
+{
+    return x * render_priv-&gt;orig_width / render_priv-&gt;track-&gt;PlayResX +
+        render_priv-&gt;settings.left_margin;
+}
+/**
+ * \brief Mapping between script and screen coordinates
+ */
+static double y2scr(ASS_Renderer *render_priv, double y)
+{
+    return y * render_priv-&gt;orig_height_nocrop /
+        render_priv-&gt;track-&gt;PlayResY +
+        FFMAX(render_priv-&gt;settings.top_margin, 0);
+}
+static double y2scr_pos(ASS_Renderer *render_priv, double y)
+{
+    return y * render_priv-&gt;orig_height / render_priv-&gt;track-&gt;PlayResY +
+        render_priv-&gt;settings.top_margin;
+}
 
-static void ass_lazy_track_init(void)
+// the same for toptitles
+static double y2scr_top(ASS_Renderer *render_priv, double y)
 {
-	ass_track_t* track = frame_context.track;
-	if (track-&gt;PlayResX &amp;&amp; track-&gt;PlayResY)
-		return;
-	if (!track-&gt;PlayResX &amp;&amp; !track-&gt;PlayResY) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NeitherPlayResXNorPlayResYDefined);
-		track-&gt;PlayResX = 384;
-		track-&gt;PlayResY = 288;
-	} else {
-		double orig_aspect = (global_settings-&gt;aspect * frame_context.height * frame_context.orig_width) /
-			frame_context.orig_height / frame_context.width;
-		if (!track-&gt;PlayResY) {
-			track-&gt;PlayResY = track-&gt;PlayResX / orig_aspect + .5;
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_PlayResYUndefinedSettingY, track-&gt;PlayResY);
-		} else if (!track-&gt;PlayResX) {
-			track-&gt;PlayResX = track-&gt;PlayResY * orig_aspect + .5;
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_PlayResXUndefinedSettingX, track-&gt;PlayResX);
-		}
-	}
+    if (render_priv-&gt;settings.use_margins)
+        return y * render_priv-&gt;orig_height_nocrop /
+            render_priv-&gt;track-&gt;PlayResY;
+    else
+        return y * render_priv-&gt;orig_height_nocrop /
+            render_priv-&gt;track-&gt;PlayResY +
+            FFMAX(render_priv-&gt;settings.top_margin, 0);
 }
+// the same for subtitles
+static double y2scr_sub(ASS_Renderer *render_priv, double y)
+{
+    if (render_priv-&gt;settings.use_margins)
+        return y * render_priv-&gt;orig_height_nocrop /
+            render_priv-&gt;track-&gt;PlayResY +
+            FFMAX(render_priv-&gt;settings.top_margin, 0)
+            + FFMAX(render_priv-&gt;settings.bottom_margin, 0);
+    else
+        return y * render_priv-&gt;orig_height_nocrop /
+            render_priv-&gt;track-&gt;PlayResY +
+            FFMAX(render_priv-&gt;settings.top_margin, 0);
+}
 
-ass_renderer_t* ass_renderer_init(ass_library_t* library)
+/*
+ * \brief Convert bitmap glyphs into ASS_Image list with inverse clipping
+ *
+ * Inverse clipping with the following strategy:
+ * - find rectangle from (x0, y0) to (cx0, y1)
+ * - find rectangle from (cx0, y0) to (cx1, cy0)
+ * - find rectangle from (cx0, cy1) to (cx1, y1)
+ * - find rectangle from (cx1, y0) to (x1, y1)
+ * These rectangles can be invalid and in this case are discarded.
+ * Afterwards, they are clipped against the screen coordinates.
+ * In an additional pass, the rectangles need to be split up left/right for
+ * karaoke effects.  This can result in a lot of bitmaps (6 to be exact).
+ */
+static ASS_Image **render_glyph_i(ASS_Renderer *render_priv,
+                                  Bitmap *bm, int dst_x, int dst_y,
+                                  uint32_t color, uint32_t color2, int brk,
+                                  ASS_Image **tail)
 {
-	int error;
-	FT_Library ft;
-	ass_renderer_t* priv = 0;
-	
-	memset(&amp;render_context, 0, sizeof(render_context));
-	memset(&amp;frame_context, 0, sizeof(frame_context));
-	memset(&amp;text_info, 0, sizeof(text_info));
+    int i, j, x0, y0, x1, y1, cx0, cy0, cx1, cy1, sx, sy, zx, zy;
+    Rect r[4];
+    ASS_Image *img;
 
-	error = FT_Init_FreeType( &amp;ft );
-	if ( error ) { 
-		mp_msg(MSGT_ASS, MSGL_FATAL, MSGTR_LIBASS_FT_Init_FreeTypeFailed);
-		goto ass_init_exit;
-	}
+    dst_x += bm-&gt;left;
+    dst_y += bm-&gt;top;
 
-	priv = calloc(1, sizeof(ass_renderer_t));
-	if (!priv) {
-		FT_Done_FreeType(ft);
-		goto ass_init_exit;
-	}
+    // we still need to clip against screen boundaries
+    zx = x2scr_pos_scaled(render_priv, 0);
+    zy = y2scr_pos(render_priv, 0);
+    sx = x2scr_pos_scaled(render_priv, render_priv-&gt;track-&gt;PlayResX);
+    sy = y2scr_pos(render_priv, render_priv-&gt;track-&gt;PlayResY);
 
-	priv-&gt;synth_priv = ass_synth_init();
+    x0 = 0;
+    y0 = 0;
+    x1 = bm-&gt;w;
+    y1 = bm-&gt;h;
+    cx0 = render_priv-&gt;state.clip_x0 - dst_x;
+    cy0 = render_priv-&gt;state.clip_y0 - dst_y;
+    cx1 = render_priv-&gt;state.clip_x1 - dst_x;
+    cy1 = render_priv-&gt;state.clip_y1 - dst_y;
 
-	priv-&gt;library = library;
-	priv-&gt;ftlibrary = ft;
-	// images_root and related stuff is zero-filled in calloc
-	
-	ass_font_cache_init();
-	ass_bitmap_cache_init();
-	ass_glyph_cache_init();
+    // calculate rectangles and discard invalid ones while we're at it.
+    i = 0;
+    r[i].x0 = x0;
+    r[i].y0 = y0;
+    r[i].x1 = (cx0 &gt; x1) ? x1 : cx0;
+    r[i].y1 = y1;
+    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
+    r[i].x0 = (cx0 &lt; 0) ? x0 : cx0;
+    r[i].y0 = y0;
+    r[i].x1 = (cx1 &gt; x1) ? x1 : cx1;
+    r[i].y1 = (cy0 &gt; y1) ? y1 : cy0;
+    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
+    r[i].x0 = (cx0 &lt; 0) ? x0 : cx0;
+    r[i].y0 = (cy1 &lt; 0) ? y0 : cy1;
+    r[i].x1 = (cx1 &gt; x1) ? x1 : cx1;
+    r[i].y1 = y1;
+    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
+    r[i].x0 = (cx1 &lt; 0) ? x0 : cx1;
+    r[i].y0 = y0;
+    r[i].x1 = x1;
+    r[i].y1 = y1;
+    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
 
-	text_info.glyphs = calloc(MAX_GLYPHS, sizeof(glyph_info_t));
-	
-ass_init_exit:
-	if (priv) mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_Init);
-	else mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_InitFailed);
+    // clip each rectangle to screen coordinates
+    for (j = 0; j &lt; i; j++) {
+        r[j].x0 = (r[j].x0 + dst_x &lt; zx) ? zx - dst_x : r[j].x0;
+        r[j].y0 = (r[j].y0 + dst_y &lt; zy) ? zy - dst_y : r[j].y0;
+        r[j].x1 = (r[j].x1 + dst_x &gt; sx) ? sx - dst_x : r[j].x1;
+        r[j].y1 = (r[j].y1 + dst_y &gt; sy) ? sy - dst_y : r[j].y1;
+    }
 
-	return priv;
-}
+    // draw the rectangles
+    for (j = 0; j &lt; i; j++) {
+        int lbrk = brk;
+        // kick out rectangles that are invalid now
+        if (r[j].x1 &lt;= r[j].x0 || r[j].y1 &lt;= r[j].y0)
+            continue;
+        // split up into left and right for karaoke, if needed
+        if (lbrk &gt; r[j].x0) {
+            if (lbrk &gt; r[j].x1) lbrk = r[j].x1;
+            img = my_draw_bitmap(bm-&gt;buffer + r[j].y0 * bm-&gt;w + r[j].x0,
+                lbrk - r[j].x0, r[j].y1 - r[j].y0,
+                bm-&gt;w, dst_x + r[j].x0, dst_y + r[j].y0, color);
+            if (!img) break;
+            *tail = img;
+            tail = &amp;img-&gt;next;
+        }
+        if (lbrk &lt; r[j].x1) {
+            if (lbrk &lt; r[j].x0) lbrk = r[j].x0;
+            img = my_draw_bitmap(bm-&gt;buffer + r[j].y0 * bm-&gt;w + lbrk,
+                r[j].x1 - lbrk, r[j].y1 - r[j].y0,
+                bm-&gt;w, dst_x + lbrk, dst_y + r[j].y0, color2);
+            if (!img) break;
+            *tail = img;
+            tail = &amp;img-&gt;next;
+        }
+    }
 
-void ass_renderer_done(ass_renderer_t* priv)
-{
-	ass_font_cache_done();
-	ass_bitmap_cache_done();
-	ass_glyph_cache_done();
-	if (render_context.stroker) {
-		FT_Stroker_Done(render_context.stroker);
-		render_context.stroker = 0;
-	}
-	if (priv &amp;&amp; priv-&gt;ftlibrary) FT_Done_FreeType(priv-&gt;ftlibrary);
-	if (priv &amp;&amp; priv-&gt;fontconfig_priv) fontconfig_done(priv-&gt;fontconfig_priv);
-	if (priv &amp;&amp; priv-&gt;synth_priv) ass_synth_done(priv-&gt;synth_priv);
-	if (priv &amp;&amp; priv-&gt;eimg) free(priv-&gt;eimg);
-	if (priv) free(priv);
-	if (text_info.glyphs) free(text_info.glyphs);
+    return tail;
 }
 
 /**
- * \brief Create a new ass_image_t
- * Parameters are the same as ass_image_t fields.
- */
-static ass_image_t* my_draw_bitmap(unsigned char* bitmap, int bitmap_w, int bitmap_h, int stride, int dst_x, int dst_y, uint32_t color)
-{
-	ass_image_t* img = calloc(1, sizeof(ass_image_t));
-	
-	img-&gt;w = bitmap_w;
-	img-&gt;h = bitmap_h;
-	img-&gt;stride = stride;
-	img-&gt;bitmap = bitmap;
-	img-&gt;color = color;
-	img-&gt;dst_x = dst_x;
-	img-&gt;dst_y = dst_y;
-
-	return img;
-}
-
-/**
- * \brief convert bitmap glyph into ass_image_t struct(s)
+ * \brief convert bitmap glyph into ASS_Image struct(s)
  * \param bit freetype bitmap glyph, FT_PIXEL_MODE_GRAY
  * \param dst_x bitmap x coordinate in video frame
  * \param dst_y bitmap y coordinate in video frame
@@ -313,954 +363,865 @@
  * \return pointer to the new list tail
  * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.
  */
-static ass_image_t** render_glyph(bitmap_t* bm, int dst_x, int dst_y, uint32_t color, uint32_t color2, int brk, ass_image_t** tail)
+static ASS_Image **
+render_glyph(ASS_Renderer *render_priv, Bitmap *bm, int dst_x, int dst_y,
+             uint32_t color, uint32_t color2, int brk, ASS_Image **tail)
 {
-	// brk is relative to dst_x
-	// color = color left of brk
-	// color2 = color right of brk
-	int b_x0, b_y0, b_x1, b_y1; // visible part of the bitmap
-	int clip_x0, clip_y0, clip_x1, clip_y1;
-	int tmp;
-	ass_image_t* img;
+    // Inverse clipping in use?
+    if (render_priv-&gt;state.clip_mode)
+        return render_glyph_i(render_priv, bm, dst_x, dst_y, color, color2,
+                              brk, tail);
 
-	dst_x += bm-&gt;left;
-	dst_y += bm-&gt;top;
-	brk -= bm-&gt;left;
-	
-	// clipping
-	clip_x0 = render_context.clip_x0;
-	clip_y0 = render_context.clip_y0;
-	clip_x1 = render_context.clip_x1;
-	clip_y1 = render_context.clip_y1;
-	b_x0 = 0;
-	b_y0 = 0;
-	b_x1 = bm-&gt;w;
-	b_y1 = bm-&gt;h;
-	
-	tmp = dst_x - clip_x0;
-	if (tmp &lt; 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip left\n&quot;);
-		b_x0 = - tmp;
-	}
-	tmp = dst_y - clip_y0;
-	if (tmp &lt; 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip top\n&quot;);
-		b_y0 = - tmp;
-	}
-	tmp = clip_x1 - dst_x - bm-&gt;w;
-	if (tmp &lt; 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip right\n&quot;);
-		b_x1 = bm-&gt;w + tmp;
-	}
-	tmp = clip_y1 - dst_y - bm-&gt;h;
-	if (tmp &lt; 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip bottom\n&quot;);
-		b_y1 = bm-&gt;h + tmp;
-	}
-	
-	if ((b_y0 &gt;= b_y1) || (b_x0 &gt;= b_x1))
-		return tail;
+    // brk is relative to dst_x
+    // color = color left of brk
+    // color2 = color right of brk
+    int b_x0, b_y0, b_x1, b_y1; // visible part of the bitmap
+    int clip_x0, clip_y0, clip_x1, clip_y1;
+    int tmp;
+    ASS_Image *img;
 
-	if (brk &gt; b_x0) { // draw left part
-		if (brk &gt; b_x1) brk = b_x1;
-		img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;w * b_y0 + b_x0, 
-			brk - b_x0, b_y1 - b_y0, bm-&gt;w,
-			dst_x + b_x0, dst_y + b_y0, color);
-		*tail = img;
-		tail = &amp;img-&gt;next;
-	}
-	if (brk &lt; b_x1) { // draw right part
-		if (brk &lt; b_x0) brk = b_x0;
-		img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;w * b_y0 + brk, 
-			b_x1 - brk, b_y1 - b_y0, bm-&gt;w,
-			dst_x + brk, dst_y + b_y0, color2);
-		*tail = img;
-		tail = &amp;img-&gt;next;
-	}
-	return tail;
+    dst_x += bm-&gt;left;
+    dst_y += bm-&gt;top;
+    brk -= bm-&gt;left;
+
+    // clipping
+    clip_x0 = FFMINMAX(render_priv-&gt;state.clip_x0, 0, render_priv-&gt;width);
+    clip_y0 = FFMINMAX(render_priv-&gt;state.clip_y0, 0, render_priv-&gt;height);
+    clip_x1 = FFMINMAX(render_priv-&gt;state.clip_x1, 0, render_priv-&gt;width);
+    clip_y1 = FFMINMAX(render_priv-&gt;state.clip_y1, 0, render_priv-&gt;height);
+    b_x0 = 0;
+    b_y0 = 0;
+    b_x1 = bm-&gt;w;
+    b_y1 = bm-&gt;h;
+
+    tmp = dst_x - clip_x0;
+    if (tmp &lt; 0) {
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;clip left&quot;);
+        b_x0 = -tmp;
+    }
+    tmp = dst_y - clip_y0;
+    if (tmp &lt; 0) {
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;clip top&quot;);
+        b_y0 = -tmp;
+    }
+    tmp = clip_x1 - dst_x - bm-&gt;w;
+    if (tmp &lt; 0) {
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;clip right&quot;);
+        b_x1 = bm-&gt;w + tmp;
+    }
+    tmp = clip_y1 - dst_y - bm-&gt;h;
+    if (tmp &lt; 0) {
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;clip bottom&quot;);
+        b_y1 = bm-&gt;h + tmp;
+    }
+
+    if ((b_y0 &gt;= b_y1) || (b_x0 &gt;= b_x1))
+        return tail;
+
+    if (brk &gt; b_x0) {           // draw left part
+        if (brk &gt; b_x1)
+            brk = b_x1;
+        img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;w * b_y0 + b_x0,
+                             brk - b_x0, b_y1 - b_y0, bm-&gt;w,
+                             dst_x + b_x0, dst_y + b_y0, color);
+        if (!img) return tail;
+        *tail = img;
+        tail = &amp;img-&gt;next;
+    }
+    if (brk &lt; b_x1) {           // draw right part
+        if (brk &lt; b_x0)
+            brk = b_x0;
+        img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;w * b_y0 + brk,
+                             b_x1 - brk, b_y1 - b_y0, bm-&gt;w,
+                             dst_x + brk, dst_y + b_y0, color2);
+        if (!img) return tail;
+        *tail = img;
+        tail = &amp;img-&gt;next;
+    }
+    return tail;
 }
 
 /**
- * \brief Convert text_info_t struct to ass_image_t list
- * Splits glyphs in halves when needed (for \kf karaoke).
+ * \brief Replace the bitmap buffer in ASS_Image with a copy
+ * \param img ASS_Image to operate on
+ * \return pointer to old bitmap buffer
  */
-static ass_image_t* render_text(text_info_t* text_info, int dst_x, int dst_y)
+static unsigned char *clone_bitmap_buffer(ASS_Image *img)
 {
-	int pen_x, pen_y;
-	int i;
-	bitmap_t* bm;
-	ass_image_t* head;
-	ass_image_t** tail = &head;
+    unsigned char *old_bitmap = img-&gt;bitmap;
+    int size = img-&gt;stride * (img-&gt;h - 1) + img-&gt;w;
+    img-&gt;bitmap = malloc(size);
+    memcpy(img-&gt;bitmap, old_bitmap, size);
+    return old_bitmap;
+}
 
-	for (i = 0; i &lt; text_info-&gt;length; ++i) {
-		glyph_info_t* info = text_info-&gt;glyphs + i;
-		if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_s || (info-&gt;shadow == 0))
-			continue;
+/**
+ * \brief Calculate overlapping area of two consecutive bitmaps and in case they
+ * overlap, blend them together
+ * Mainly useful for translucent glyphs and especially borders, to avoid the
+ * luminance adding up where they overlap (which looks ugly)
+ */
+static void
+render_overlap(ASS_Renderer *render_priv, ASS_Image **last_tail,
+               ASS_Image **tail)
+{
+    int left, top, bottom, right;
+    int old_left, old_top, w, h, cur_left, cur_top;
+    int x, y, opos, cpos;
+    char m;
+    CompositeHashKey hk;
+    CompositeHashValue *hv;
+    CompositeHashValue chv;
+    int ax = (*last_tail)-&gt;dst_x;
+    int ay = (*last_tail)-&gt;dst_y;
+    int aw = (*last_tail)-&gt;w;
+    int as = (*last_tail)-&gt;stride;
+    int ah = (*last_tail)-&gt;h;
+    int bx = (*tail)-&gt;dst_x;
+    int by = (*tail)-&gt;dst_y;
+    int bw = (*tail)-&gt;w;
+    int bs = (*tail)-&gt;stride;
+    int bh = (*tail)-&gt;h;
+    unsigned char *a;
+    unsigned char *b;
 
-		pen_x = dst_x + info-&gt;pos.x + info-&gt;shadow;
-		pen_y = dst_y + info-&gt;pos.y + info-&gt;shadow;
-		bm = info-&gt;bm_s;
+    if ((*last_tail)-&gt;bitmap == (*tail)-&gt;bitmap)
+        return;
 
-		tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[3], 0, 1000000, tail);
-	}
+    if ((*last_tail)-&gt;color != (*tail)-&gt;color)
+        return;
 
-	for (i = 0; i &lt; text_info-&gt;length; ++i) {
-		glyph_info_t* info = text_info-&gt;glyphs + i;
-		if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_o)
-			continue;
+    // Calculate overlap coordinates
+    left = (ax &gt; bx) ? ax : bx;
+    top = (ay &gt; by) ? ay : by;
+    right = ((ax + aw) &lt; (bx + bw)) ? (ax + aw) : (bx + bw);
+    bottom = ((ay + ah) &lt; (by + bh)) ? (ay + ah) : (by + bh);
+    if ((right &lt;= left) || (bottom &lt;= top))
+        return;
+    old_left = left - ax;
+    old_top = top - ay;
+    w = right - left;
+    h = bottom - top;
+    cur_left = left - bx;
+    cur_top = top - by;
 
-		pen_x = dst_x + info-&gt;pos.x;
-		pen_y = dst_y + info-&gt;pos.y;
-		bm = info-&gt;bm_o;
-		
-		if ((info-&gt;effect_type == EF_KARAOKE_KO) &amp;&amp; (info-&gt;effect_timing &lt;= info-&gt;bbox.xMax)) {
-			// do nothing
-		} else
-			tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[2], 0, 1000000, tail);
-	}
-	for (i = 0; i &lt; text_info-&gt;length; ++i) {
-		glyph_info_t* info = text_info-&gt;glyphs + i;
-		if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm)
-			continue;
+    // Query cache
+    hk.a = (*last_tail)-&gt;bitmap;
+    hk.b = (*tail)-&gt;bitmap;
+    hk.aw = aw;
+    hk.ah = ah;
+    hk.bw = bw;
+    hk.bh = bh;
+    hk.ax = ax;
+    hk.ay = ay;
+    hk.bx = bx;
+    hk.by = by;
+    hk.as = as;
+    hk.bs = bs;
+    hv = cache_find_composite(render_priv-&gt;cache.composite_cache, &amp;hk);
+    if (hv) {
+        (*last_tail)-&gt;bitmap = hv-&gt;a;
+        (*tail)-&gt;bitmap = hv-&gt;b;
+        return;
+    }
+    // Allocate new bitmaps and copy over data
+    a = clone_bitmap_buffer(*last_tail);
+    b = clone_bitmap_buffer(*tail);
 
-		pen_x = dst_x + info-&gt;pos.x;
-		pen_y = dst_y + info-&gt;pos.y;
-		bm = info-&gt;bm;
+    // Blend overlapping area
+    for (y = 0; y &lt; h; y++)
+        for (x = 0; x &lt; w; x++) {
+            opos = (old_top + y) * (as) + (old_left + x);
+            cpos = (cur_top + y) * (bs) + (cur_left + x);
+            m = FFMIN(a[opos] + b[cpos], 0xff);
+            (*last_tail)-&gt;bitmap[opos] = 0;
+            (*tail)-&gt;bitmap[cpos] = m;
+        }
 
-		if ((info-&gt;effect_type == EF_KARAOKE) || (info-&gt;effect_type == EF_KARAOKE_KO)) {
-			if (info-&gt;effect_timing &gt; info-&gt;bbox.xMax)
-				tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[0], 0, 1000000, tail);
-			else
-				tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[1], 0, 1000000, tail);
-		} else if (info-&gt;effect_type == EF_KARAOKE_KF) {
-			tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[0], info-&gt;c[1], info-&gt;effect_timing, tail);
-		} else
-			tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[0], 0, 1000000, tail);
-	}
+    // Insert bitmaps into the cache
+    chv.a = (*last_tail)-&gt;bitmap;
+    chv.b = (*tail)-&gt;bitmap;
+    cache_add_composite(render_priv-&gt;cache.composite_cache, &amp;hk, &amp;chv);
+}
 
-	*tail = 0;
-	return head;
+static void free_list_add(ASS_Renderer *render_priv, void *object)
+{
+    if (!render_priv-&gt;free_head) {
+        render_priv-&gt;free_head = calloc(1, sizeof(FreeList));
+        render_priv-&gt;free_head-&gt;object = object;
+        render_priv-&gt;free_tail = render_priv-&gt;free_head;
+    } else {
+        FreeList *l = calloc(1, sizeof(FreeList));
+        l-&gt;object = object;
+        render_priv-&gt;free_tail-&gt;next = l;
+        render_priv-&gt;free_tail = render_priv-&gt;free_tail-&gt;next;
+    }
 }
 
 /**
- * \brief Mapping between script and screen coordinates
+ * Iterate through a list of bitmaps and blend with clip vector, if
+ * applicable. The blended bitmaps are added to a free list which is freed
+ * at the start of a new frame.
  */
-static int x2scr(int x) {
-	return x*frame_context.orig_width / frame_context.track-&gt;PlayResX + global_settings-&gt;left_margin;
-}
-/**
- * \brief Mapping between script and screen coordinates
- */
-static int y2scr(int y) {
-	return y * frame_context.orig_height / frame_context.track-&gt;PlayResY + global_settings-&gt;top_margin;
-}
-// the same for toptitles
-static int y2scr_top(int y) {
-	if (global_settings-&gt;use_margins)
-		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY;
-	else
-		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY + global_settings-&gt;top_margin;
-}
-// the same for subtitles
-static int y2scr_sub(int y) {
-	if (global_settings-&gt;use_margins)
-		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY +
-		       global_settings-&gt;top_margin + global_settings-&gt;bottom_margin;
-	else
-		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY + global_settings-&gt;top_margin;
-}
+static void blend_vector_clip(ASS_Renderer *render_priv,
+                              ASS_Image *head)
+{
+    FT_Glyph glyph;
+    FT_BitmapGlyph clip_bm;
+    ASS_Image *cur;
+    ASS_Drawing *drawing = render_priv-&gt;state.clip_drawing;
+    GlyphHashKey key;
+    GlyphHashValue *val;
+    int error;
 
-static void compute_string_bbox( text_info_t* info, FT_BBox *abbox ) {
-	FT_BBox bbox;
-	int i;
-	
-	if (text_info.length &gt; 0) {
-		bbox.xMin = 32000;
-		bbox.xMax = -32000;
-		bbox.yMin = - d6_to_int(text_info.lines[0].asc) + text_info.glyphs[0].pos.y;
-		bbox.yMax = d6_to_int(text_info.height - text_info.lines[0].asc) + text_info.glyphs[0].pos.y;
+    if (!drawing)
+        return;
 
-		for (i = 0; i &lt; text_info.length; ++i) {
-			int s = text_info.glyphs[i].pos.x;
-			int e = s + d6_to_int(text_info.glyphs[i].advance.x);
-			bbox.xMin = FFMIN(bbox.xMin, s);
-			bbox.xMax = FFMAX(bbox.xMax, e);
-		}
-	} else
-		bbox.xMin = bbox.xMax = bbox.yMin = bbox.yMax = 0;
+    // Try to get mask from cache
+    ass_drawing_hash(drawing);
+    memset(&amp;key, 0, sizeof(key));
+    key.ch = -2;
+    key.drawing_hash = drawing-&gt;hash;
+    val = cache_find_glyph(render_priv-&gt;cache.glyph_cache, &amp;key);
 
-	/* return string bbox */
-	*abbox = bbox;
-}
+    if (val) {
+        clip_bm = (FT_BitmapGlyph) val-&gt;glyph;
+    } else {
+        GlyphHashValue v;
 
+        // Not found in cache, parse and rasterize it
+        glyph = (FT_Glyph) *ass_drawing_parse(drawing, 1);
+        if (!glyph) {
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                    &quot;Clip vector parsing failed. Skipping.&quot;);
+            goto blend_vector_error;
+        }
 
-/**
- * \brief Check if starting part of (*p) matches sample. If true, shift p to the first symbol after the matching part.
- */
-static inline int mystrcmp(char** p, const char* sample) {
-	int len = strlen(sample);
-	if (strncmp(*p, sample, len) == 0) {
-		(*p) += len;
-		return 1;
-	} else
-		return 0;
-}
+        // We need to translate the clip according to screen borders
+        if (render_priv-&gt;settings.left_margin != 0 ||
+            render_priv-&gt;settings.top_margin != 0) {
+            FT_Vector trans = {
+                .x = int_to_d6(render_priv-&gt;settings.left_margin),
+                .y = -int_to_d6(render_priv-&gt;settings.top_margin),
+            };
+            FT_Outline_Translate(&amp;drawing-&gt;glyph-&gt;outline,
+                                 trans.x, trans.y);
+        }
 
-static void change_font_size(double sz)
-{
-	double size = sz * frame_context.font_scale;
+        // Check glyph bounding box size
+        if (check_glyph_area(render_priv-&gt;library, glyph)) {
+            FT_Done_Glyph(glyph);
+            glyph = 0;
+            goto blend_vector_error;
+        }
 
-	if (size &lt; 1)
-		size = 1;
-	else if (size &gt; frame_context.height * 2)
-		size = frame_context.height * 2;
+        ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                &quot;Parsed vector clip: scales (%f, %f) string [%s]\n&quot;,
+                drawing-&gt;scale_x, drawing-&gt;scale_y, drawing-&gt;text);
 
-	ass_font_set_size(render_context.font, size);
+        error = FT_Glyph_To_Bitmap(&amp;glyph, FT_RENDER_MODE_NORMAL, 0, 1);
+        if (error) {
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                &quot;Clip vector rasterization failed: %d. Skipping.&quot;, error);
+            FT_Done_Glyph(glyph);
+            glyph = 0;
+        }
 
-	render_context.font_size = sz;
-}
+blend_vector_error:
+        clip_bm = (FT_BitmapGlyph) glyph;
 
-/**
- * \brief Change current font, using setting from render_context.
- */
-static void update_font(void)
-{
-	unsigned val;
-	ass_renderer_t* priv = frame_context.ass_priv;
-	ass_font_desc_t desc;
-	desc.family = strdup(render_context.family);
+        // Add to cache
+        memset(&amp;v, 0, sizeof(v));
+        v.glyph = glyph;
+        cache_add_glyph(render_priv-&gt;cache.glyph_cache, &amp;key, &amp;v);
+    }
 
-	val = render_context.bold;
-	// 0 = normal, 1 = bold, &gt;1 = exact weight
-	if (val == 0) val = 80; // normal
-	else if (val == 1) val = 200; // bold
-	desc.bold = val;
+    if (!clip_bm) goto blend_vector_exit;
 
-	val = render_context.italic;
-	if (val == 0) val = 0; // normal
-	else if (val == 1) val = 110; //italic
-	desc.italic = val;
+    // Iterate through bitmaps and blend/clip them
+    for (cur = head; cur; cur = cur-&gt;next) {
+        int left, top, right, bottom, apos, bpos, y, x, w, h;
+        int ax, ay, aw, ah, as;
+        int bx, by, bw, bh, bs;
+        int aleft, atop, bleft, btop;
+        unsigned char *abuffer, *bbuffer, *nbuffer;
 
-	render_context.font = ass_font_new(priv-&gt;library, priv-&gt;ftlibrary, priv-&gt;fontconfig_priv, &amp;desc);
-	free(desc.family);
-	
-	if (render_context.font)
-		change_font_size(render_context.font_size);
+        abuffer = cur-&gt;bitmap;
+        bbuffer = clip_bm-&gt;bitmap.buffer;
+        ax = cur-&gt;dst_x;
+        ay = cur-&gt;dst_y;
+        aw = cur-&gt;w;
+        ah = cur-&gt;h;
+        as = cur-&gt;stride;
+        bx = clip_bm-&gt;left;
+        by = -clip_bm-&gt;top;
+        bw = clip_bm-&gt;bitmap.width;
+        bh = clip_bm-&gt;bitmap.rows;
+        bs = clip_bm-&gt;bitmap.pitch;
+
+        // Calculate overlap coordinates
+        left = (ax &gt; bx) ? ax : bx;
+        top = (ay &gt; by) ? ay : by;
+        right = ((ax + aw) &lt; (bx + bw)) ? (ax + aw) : (bx + bw);
+        bottom = ((ay + ah) &lt; (by + bh)) ? (ay + ah) : (by + bh);
+        aleft = left - ax;
+        atop = top - ay;
+        w = right - left;
+        h = bottom - top;
+        bleft = left - bx;
+        btop = top - by;
+
+        if (render_priv-&gt;state.clip_drawing_mode) {
+            // Inverse clip
+            if (ax + aw &lt; bx || ay + ah &lt; by || ax &gt; bx + bw ||
+                ay &gt; by + bh) {
+                continue;
+            }
+
+            // Allocate new buffer and add to free list
+            nbuffer = malloc(as * ah);
+            if (!nbuffer) goto blend_vector_exit;
+            free_list_add(render_priv, nbuffer);
+
+            // Blend together
+            memcpy(nbuffer, abuffer, as * (ah - 1) + aw);
+            for (y = 0; y &lt; h; y++)
+                for (x = 0; x &lt; w; x++) {
+                    apos = (atop + y) * as + aleft + x;
+                    bpos = (btop + y) * bs + bleft + x;
+                    nbuffer[apos] = FFMAX(0, abuffer[apos] - bbuffer[bpos]);
+                }
+        } else {
+            // Regular clip
+            if (ax + aw &lt; bx || ay + ah &lt; by || ax &gt; bx + bw ||
+                ay &gt; by + bh) {
+                cur-&gt;w = cur-&gt;h = 0;
+                continue;
+            }
+
+            // Allocate new buffer and add to free list
+            nbuffer = calloc(as, ah);
+            if (!nbuffer) goto blend_vector_exit;
+            free_list_add(render_priv, nbuffer);
+
+            // Blend together
+            for (y = 0; y &lt; h; y++)
+                for (x = 0; x &lt; w; x++) {
+                    apos = (atop + y) * as + aleft + x;
+                    bpos = (btop + y) * bs + bleft + x;
+                    nbuffer[apos] = (abuffer[apos] * bbuffer[bpos] + 255) &gt;&gt; 8;
+                }
+        }
+        cur-&gt;bitmap = nbuffer;
+    }
+
+blend_vector_exit:
+    ass_drawing_free(render_priv-&gt;state.clip_drawing);
+    render_priv-&gt;state.clip_drawing = 0;
 }
 
 /**
- * \brief Change border width
- * negative value resets border to style value
+ * \brief Convert TextInfo struct to ASS_Image list
+ * Splits glyphs in halves when needed (for \kf karaoke).
  */
-static void change_border(double border)
+static ASS_Image *render_text(ASS_Renderer *render_priv, int dst_x, int dst_y)
 {
-	int b;
-	if (!render_context.font) return;
+    int pen_x, pen_y;
+    int i;
+    Bitmap *bm;
+    ASS_Image *head;
+    ASS_Image **tail = &head;
+    ASS_Image **last_tail = 0;
+    ASS_Image **here_tail = 0;
+    TextInfo *text_info = &amp;render_priv-&gt;text_info;
 
-	if (border &lt; 0) {
-		if (render_context.style-&gt;BorderStyle == 1) {
-			if (render_context.style-&gt;Outline == 0 &amp;&amp; render_context.style-&gt;Shadow &gt; 0)
-				border = 1.;
-			else
-				border = render_context.style-&gt;Outline;
-		} else
-			border = 1.;
-	}
-	render_context.border = border;
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        GlyphInfo *info = text_info-&gt;glyphs + i;
+        if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_s
+            || (info-&gt;shadow_x == 0 &amp;&amp; info-&gt;shadow_y == 0) || info-&gt;skip)
+            continue;
 
-	b = 64 * border * frame_context.border_scale;
-	if (b &gt; 0) {
-		if (!render_context.stroker) {
-			int error;
-#if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
-			error = FT_Stroker_New( ass_renderer-&gt;ftlibrary, &amp;render_context.stroker );
-#else // &lt; 2.2
-			error = FT_Stroker_New( render_context.font-&gt;faces[0]-&gt;memory, &amp;render_context.stroker );
-#endif
-			if (error) {
-				mp_msg(MSGT_ASS, MSGL_V, &quot;failed to get stroker\n&quot;);
-				render_context.stroker = 0;
-			}
-		}
-		if (render_context.stroker)
-			FT_Stroker_Set( render_context.stroker, b,
-					FT_STROKER_LINECAP_ROUND,
-					FT_STROKER_LINEJOIN_ROUND,
-					0 );
-	} else {
-		FT_Stroker_Done(render_context.stroker);
-		render_context.stroker = 0;
-	}
-}
+        pen_x =
+            dst_x + (info-&gt;pos.x &gt;&gt; 6) +
+            (int) (info-&gt;shadow_x * render_priv-&gt;border_scale);
+        pen_y =
+            dst_y + (info-&gt;pos.y &gt;&gt; 6) +
+            (int) (info-&gt;shadow_y * render_priv-&gt;border_scale);
+        bm = info-&gt;bm_s;
 
-#define _r(c)  ((c)&gt;&gt;24)
-#define _g(c)  (((c)&gt;&gt;16)&amp;0xFF)
-#define _b(c)  (((c)&gt;&gt;8)&amp;0xFF)
-#define _a(c)  ((c)&amp;0xFF)
+        here_tail = tail;
+        tail =
+            render_glyph(render_priv, bm, pen_x, pen_y, info-&gt;c[3], 0,
+                         1000000, tail);
+        if (last_tail &amp;&amp; tail != here_tail &amp;&amp; ((info-&gt;c[3] &amp; 0xff) &gt; 0))
+            render_overlap(render_priv, last_tail, here_tail);
 
-/**
- * \brief Calculate a weighted average of two colors
- * calculates c1*(1-a) + c2*a, but separately for each component except alpha
- */
-static void change_color(uint32_t* var, uint32_t new, double pwr)
-{
-	(*var)= ((uint32_t)(_r(*var) * (1 - pwr) + _r(new) * pwr) &lt;&lt; 24) +
-		((uint32_t)(_g(*var) * (1 - pwr) + _g(new) * pwr) &lt;&lt; 16) +
-		((uint32_t)(_b(*var) * (1 - pwr) + _b(new) * pwr) &lt;&lt; 8) +
-		_a(*var);
+        last_tail = here_tail;
+    }
+
+    last_tail = 0;
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        GlyphInfo *info = text_info-&gt;glyphs + i;
+        if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_o
+            || info-&gt;skip)
+            continue;
+
+        pen_x = dst_x + (info-&gt;pos.x &gt;&gt; 6);
+        pen_y = dst_y + (info-&gt;pos.y &gt;&gt; 6);
+        bm = info-&gt;bm_o;
+
+        if ((info-&gt;effect_type == EF_KARAOKE_KO)
+            &amp;&amp; (info-&gt;effect_timing &lt;= (info-&gt;bbox.xMax &gt;&gt; 6))) {
+            // do nothing
+        } else {
+            here_tail = tail;
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info-&gt;c[2],
+                             0, 1000000, tail);
+            if (last_tail &amp;&amp; tail != here_tail &amp;&amp; ((info-&gt;c[2] &amp; 0xff) &gt; 0))
+                render_overlap(render_priv, last_tail, here_tail);
+
+            last_tail = here_tail;
+        }
+    }
+
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        GlyphInfo *info = text_info-&gt;glyphs + i;
+        if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm
+            || info-&gt;skip)
+            continue;
+
+        pen_x = dst_x + (info-&gt;pos.x &gt;&gt; 6);
+        pen_y = dst_y + (info-&gt;pos.y &gt;&gt; 6);
+        bm = info-&gt;bm;
+
+        if ((info-&gt;effect_type == EF_KARAOKE)
+            || (info-&gt;effect_type == EF_KARAOKE_KO)) {
+            if (info-&gt;effect_timing &gt; (info-&gt;bbox.xMax &gt;&gt; 6))
+                tail =
+                    render_glyph(render_priv, bm, pen_x, pen_y,
+                                 info-&gt;c[0], 0, 1000000, tail);
+            else
+                tail =
+                    render_glyph(render_priv, bm, pen_x, pen_y,
+                                 info-&gt;c[1], 0, 1000000, tail);
+        } else if (info-&gt;effect_type == EF_KARAOKE_KF) {
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info-&gt;c[0],
+                             info-&gt;c[1], info-&gt;effect_timing, tail);
+        } else
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info-&gt;c[0],
+                             0, 1000000, tail);
+    }
+
+    *tail = 0;
+    blend_vector_clip(render_priv, head);
+
+    return head;
 }
 
-// like change_color, but for alpha component only
-static void change_alpha(uint32_t* var, uint32_t new, double pwr)
+static void compute_string_bbox(TextInfo *info, DBBox *bbox)
 {
-	*var = (_r(*var) &lt;&lt; 24) + (_g(*var) &lt;&lt; 16) + (_b(*var) &lt;&lt; 8) + (_a(*var) * (1 - pwr) + _a(new) * pwr);
-}
+    int i;
 
-/**
- * \brief Multiply two alpha values
- * \param a first value
- * \param b second value
- * \return result of multiplication
- * Parameters and result are limited by 0xFF.
- */
-static uint32_t mult_alpha(uint32_t a, uint32_t b)
-{
-	return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;
+    if (info-&gt;length &gt; 0) {
+        bbox-&gt;xMin = 32000;
+        bbox-&gt;xMax = -32000;
+        bbox-&gt;yMin = -1 * info-&gt;lines[0].asc + d6_to_double(info-&gt;glyphs[0].pos.y);
+        bbox-&gt;yMax = info-&gt;height - info-&gt;lines[0].asc +
+                     d6_to_double(info-&gt;glyphs[0].pos.y);
+
+        for (i = 0; i &lt; info-&gt;length; ++i) {
+            if (info-&gt;glyphs[i].skip) continue;
+            double s = d6_to_double(info-&gt;glyphs[i].pos.x);
+            double e = s + d6_to_double(info-&gt;glyphs[i].advance.x);
+            bbox-&gt;xMin = FFMIN(bbox-&gt;xMin, s);
+            bbox-&gt;xMax = FFMAX(bbox-&gt;xMax, e);
+        }
+    } else
+        bbox-&gt;xMin = bbox-&gt;xMax = bbox-&gt;yMin = bbox-&gt;yMax = 0.;
 }
 
 /**
- * \brief Calculate alpha value by piecewise linear function
- * Used for \fad, \fade implementation.
+ * \brief partially reset render_context to style values
+ * Works like {\r}: resets some style overrides
  */
-static unsigned interpolate_alpha(long long now, 
-		long long t1, long long t2, long long t3, long long t4,
-		unsigned a1, unsigned a2, unsigned a3)
+void reset_render_context(ASS_Renderer *render_priv)
 {
-	unsigned a;
-	double cf;
-	if (now &lt;= t1) {
-		a = a1;
-	} else if (now &gt;= t4) {
-		a = a3;
-	} else if (now &lt; t2) { // and &gt; t1
-		cf = ((double)(now - t1)) / (t2 - t1);
-		a = a1 * (1 - cf) + a2 * cf;
-	} else if (now &gt; t3) {
-		cf = ((double)(now - t3)) / (t4 - t3);
-		a = a2 * (1 - cf) + a3 * cf;
-	} else { // t2 &lt;= now &lt;= t3
-		a = a2;
-	}
+    render_priv-&gt;state.c[0] = render_priv-&gt;state.style-&gt;PrimaryColour;
+    render_priv-&gt;state.c[1] = render_priv-&gt;state.style-&gt;SecondaryColour;
+    render_priv-&gt;state.c[2] = render_priv-&gt;state.style-&gt;OutlineColour;
+    render_priv-&gt;state.c[3] = render_priv-&gt;state.style-&gt;BackColour;
+    render_priv-&gt;state.flags =
+        (render_priv-&gt;state.style-&gt;Underline ? DECO_UNDERLINE : 0) |
+        (render_priv-&gt;state.style-&gt;StrikeOut ? DECO_STRIKETHROUGH : 0);
+    render_priv-&gt;state.font_size = render_priv-&gt;state.style-&gt;FontSize;
 
-	return a;
+    free(render_priv-&gt;state.family);
+    render_priv-&gt;state.family = NULL;
+    render_priv-&gt;state.family = strdup(render_priv-&gt;state.style-&gt;FontName);
+    render_priv-&gt;state.treat_family_as_pattern =
+        render_priv-&gt;state.style-&gt;treat_fontname_as_pattern;
+    render_priv-&gt;state.bold = render_priv-&gt;state.style-&gt;Bold;
+    render_priv-&gt;state.italic = render_priv-&gt;state.style-&gt;Italic;
+    update_font(render_priv);
+
+    change_border(render_priv, -1., -1.);
+    render_priv-&gt;state.scale_x = render_priv-&gt;state.style-&gt;ScaleX;
+    render_priv-&gt;state.scale_y = render_priv-&gt;state.style-&gt;ScaleY;
+    render_priv-&gt;state.hspacing = render_priv-&gt;state.style-&gt;Spacing;
+    render_priv-&gt;state.be = 0;
+    render_priv-&gt;state.blur = 0.0;
+    render_priv-&gt;state.shadow_x = render_priv-&gt;state.style-&gt;Shadow;
+    render_priv-&gt;state.shadow_y = render_priv-&gt;state.style-&gt;Shadow;
+    render_priv-&gt;state.frx = render_priv-&gt;state.fry = 0.;
+    render_priv-&gt;state.frz = M_PI * render_priv-&gt;state.style-&gt;Angle / 180.;
+    render_priv-&gt;state.fax = render_priv-&gt;state.fay = 0.;
+    render_priv-&gt;state.wrap_style = render_priv-&gt;track-&gt;WrapStyle;
 }
 
-static void reset_render_context(void);
-
 /**
- * \brief Parse style override tag.
- * \param p string to parse
- * \param pwr multiplier for some tag effects (comes from \t tags)
+ * \brief Start new event. Reset render_priv-&gt;state.
  */
-static char* parse_tag(char* p, double pwr) {
-#define skip_all(x) if (*p == (x)) ++p; else { \
-	while ((*p != (x)) &amp;&amp; (*p != '}') &amp;&amp; (*p != 0)) {++p;} }
-#define skip(x) if (*p == (x)) ++p; else { return p; }
-	
-	skip_all('\\');
-	if ((*p == '}') || (*p == 0))
-		return p;
+static void
+init_render_context(ASS_Renderer *render_priv, ASS_Event *event)
+{
+    render_priv-&gt;state.event = event;
+    render_priv-&gt;state.style = render_priv-&gt;track-&gt;styles + event-&gt;Style;
 
-	if (mystrcmp(&amp;p, &quot;fsc&quot;)) {
-		char tp = *p++;
-		double val;
-		if (tp == 'x') {
-			if (mystrtod(&amp;p, &amp;val)) {
-				val /= 100;
-				render_context.scale_x = render_context.scale_x * ( 1 - pwr) + val * pwr;
-			} else
-				render_context.scale_x = render_context.style-&gt;ScaleX;
-		} else if (tp == 'y') {
-			if (mystrtod(&amp;p, &amp;val)) {
-				val /= 100;
-				render_context.scale_y = render_context.scale_y * ( 1 - pwr) + val * pwr;
-			} else
-				render_context.scale_y = render_context.style-&gt;ScaleY;
-		}
-	} else if (mystrcmp(&amp;p, &quot;fsp&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val))
-			render_context.hspacing = render_context.hspacing * ( 1 - pwr ) + val * pwr;
-		else
-			render_context.hspacing = render_context.style-&gt;Spacing;
-	} else if (mystrcmp(&amp;p, &quot;fs&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val))
-			val = render_context.font_size * ( 1 - pwr ) + val * pwr;
-		else
-			val = render_context.style-&gt;FontSize;
-		if (render_context.font)
-			change_font_size(val);
-	} else if (mystrcmp(&amp;p, &quot;bord&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val))
-			val = render_context.border * ( 1 - pwr ) + val * pwr;
-		else
-			val = -1.; // reset to default
-		change_border(val);
-	} else if (mystrcmp(&amp;p, &quot;move&quot;)) {
-		int x1, x2, y1, y2;
-		long long t1, t2, delta_t, t;
-		int x, y;
-		double k;
-		skip('(');
-		x1 = strtol(p, &amp;p, 10);
-		skip(',');
-		y1 = strtol(p, &amp;p, 10);
-		skip(',');
-		x2 = strtol(p, &amp;p, 10);
-		skip(',');
-		y2 = strtol(p, &amp;p, 10);
-		if (*p == ',') {
-			skip(',');
-			t1 = strtoll(p, &amp;p, 10);
-			skip(',');
-			t2 = strtoll(p, &amp;p, 10);
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;movement6: (%d, %d) -&gt; (%d, %d), (%&quot; PRId64 &quot; .. %&quot; PRId64 &quot;)\n&quot;, 
-				x1, y1, x2, y2, (int64_t)t1, (int64_t)t2);
-		} else {
-			t1 = 0;
-			t2 = render_context.event-&gt;Duration;
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;movement: (%d, %d) -&gt; (%d, %d)\n&quot;, x1, y1, x2, y2);
-		}
-		skip(')');
-		delta_t = t2 - t1;
-		t = frame_context.time - render_context.event-&gt;Start;
-		if (t &lt; t1)
-			k = 0.;
-		else if (t &gt; t2)
-			k = 1.;
-		else k = ((double)(t - t1)) / delta_t;
-		x = k * (x2 - x1) + x1;
-		y = k * (y2 - y1) + y1;
-		render_context.pos_x = x;
-		render_context.pos_y = y;
-		render_context.detect_collisions = 0;
-		render_context.evt_type = EVENT_POSITIONED;
-	} else if (mystrcmp(&amp;p, &quot;frx&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val)) {
-			val *= M_PI / 180;
-			render_context.frx = val * pwr + render_context.frx * (1-pwr);
-		} else
-			render_context.frx = 0.;
-	} else if (mystrcmp(&amp;p, &quot;fry&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val)) {
-			val *= M_PI / 180;
-			render_context.fry = val * pwr + render_context.fry * (1-pwr);
-		} else
-			render_context.fry = 0.;
-	} else if (mystrcmp(&amp;p, &quot;frz&quot;) || mystrcmp(&amp;p, &quot;fr&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val)) {
-			val *= M_PI / 180;
-			render_context.frz = val * pwr + render_context.frz * (1-pwr);
-		} else
-			render_context.frz = M_PI * render_context.style-&gt;Angle / 180.;
-	} else if (mystrcmp(&amp;p, &quot;fn&quot;)) {
-		char* start = p;
-		char* family;
-		skip_all('\\');
-		if (p &gt; start) {
-			family = malloc(p - start + 1);
-			strncpy(family, start, p - start);
-			family[p - start] = '\0';
-		} else
-			family = strdup(render_context.style-&gt;FontName);
-		if (render_context.family)
-			free(render_context.family);
-		render_context.family = family;
-		update_font();
-	} else if (mystrcmp(&amp;p, &quot;alpha&quot;)) {
-		uint32_t val;
-		int i;
-		if (strtocolor(&amp;p, &amp;val)) {
-			unsigned char a = val &gt;&gt; 24;
-			for (i = 0; i &lt; 4; ++i)
-				change_alpha(&amp;render_context.c[i], a, pwr);
-		} else {
-			change_alpha(&amp;render_context.c[0], render_context.style-&gt;PrimaryColour, pwr);
-			change_alpha(&amp;render_context.c[1], render_context.style-&gt;SecondaryColour, pwr);
-			change_alpha(&amp;render_context.c[2], render_context.style-&gt;OutlineColour, pwr);
-			change_alpha(&amp;render_context.c[3], render_context.style-&gt;BackColour, pwr);
-		}
-		// FIXME: simplify
-	} else if (mystrcmp(&amp;p, &quot;an&quot;)) {
-		int val;
-		if (mystrtoi(&amp;p, 10, &amp;val) &amp;&amp; val) {
-			int v = (val - 1) / 3; // 0, 1 or 2 for vertical alignment
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;an %d\n&quot;, val);
-			if (v != 0) v = 3 - v;
-			val = ((val - 1) % 3) + 1; // horizontal alignment
-			val += v*4;
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;align %d\n&quot;, val);
-			render_context.alignment = val;
-		} else
-			render_context.alignment = render_context.style-&gt;Alignment;
-	} else if (mystrcmp(&amp;p, &quot;a&quot;)) {
-		int val;
-		if (mystrtoi(&amp;p, 10, &amp;val) &amp;&amp; val)
-			render_context.alignment = val;
-		else
-			render_context.alignment = render_context.style-&gt;Alignment;
-	} else if (mystrcmp(&amp;p, &quot;pos&quot;)) {
-		int v1, v2;
-		skip('(');
-		v1 = strtol(p, &amp;p, 10);
-		skip(',');
-		v2 = strtol(p, &amp;p, 10);
-		skip(')');
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;pos(%d, %d)\n&quot;, v1, v2);
-		render_context.evt_type = EVENT_POSITIONED;
-		render_context.detect_collisions = 0;
-		render_context.pos_x = v1;
-		render_context.pos_y = v2;
-	} else if (mystrcmp(&amp;p, &quot;fad&quot;)) {
-		int a1, a2, a3;
-		long long t1, t2, t3, t4;
-		if (*p == 'e') ++p; // either \fad or \fade
-		skip('(');
-		a1 = strtol(p, &amp;p, 10);
-		skip(',');
-		a2 = strtol(p, &amp;p, 10);
-		if (*p == ')') {
-			// 2-argument version (\fad, according to specs)
-			// a1 and a2 are fade-in and fade-out durations
-			t1 = 0;
-			t4 = render_context.event-&gt;Duration;
-			t2 = a1;
-			t3 = t4 - a2;
-			a1 = 0xFF;
-			a2 = 0;
-			a3 = 0xFF;
-		} else {
-			// 6-argument version (\fade)
-			// a1 and a2 (and a3) are opacity values
-			skip(',');
-			a3 = strtol(p, &amp;p, 10);
-			skip(',');
-			t1 = strtoll(p, &amp;p, 10);
-			skip(',');
-			t2 = strtoll(p, &amp;p, 10);
-			skip(',');
-			t3 = strtoll(p, &amp;p, 10);
-			skip(',');
-			t4 = strtoll(p, &amp;p, 10);
-		}
-		skip(')');
-		render_context.fade = interpolate_alpha(frame_context.time - render_context.event-&gt;Start, t1, t2, t3, t4, a1, a2, a3);
-	} else if (mystrcmp(&amp;p, &quot;org&quot;)) {
-		int v1, v2;
-		skip('(');
-		v1 = strtol(p, &amp;p, 10);
-		skip(',');
-		v2 = strtol(p, &amp;p, 10);
-		skip(')');
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;org(%d, %d)\n&quot;, v1, v2);
-		//				render_context.evt_type = EVENT_POSITIONED;
-		render_context.org_x = v1;
-		render_context.org_y = v2;
-		render_context.have_origin = 1;
-	} else if (mystrcmp(&amp;p, &quot;t&quot;)) {
-		double v[3];
-		int v1, v2;
-		double v3;
-		int cnt;
-		long long t1, t2, t, delta_t;
-		double k;
-		skip('(');
-		for (cnt = 0; cnt &lt; 3; ++cnt) {
-			if (*p == '\\')
-				break;
-			v[cnt] = strtod(p, &amp;p);
-			skip(',');
-		}
-		if (cnt == 3) {
-			v1 = v[0]; v2 = v[1]; v3 = v[2];
-		} else if (cnt == 2) {
-			v1 = v[0]; v2 = v[1]; v3 = 1.;
-		} else if (cnt == 1) {
-			v1 = 0; v2 = render_context.event-&gt;Duration; v3 = v[0];
-		} else { // cnt == 0
-			v1 = 0; v2 = render_context.event-&gt;Duration; v3 = 1.;
-		}
-		render_context.detect_collisions = 0;
-		t1 = v1;
-		t2 = v2;
-		delta_t = v2 - v1;
-		if (v3 &lt; 0.)
-			v3 = 0.;
-		t = frame_context.time - render_context.event-&gt;Start; // FIXME: move to render_context
-		if (t &lt;= t1)
-			k = 0.;
-		else if (t &gt;= t2)
-			k = 1.;
-		else {
-			assert(delta_t != 0.);
-			k = pow(((double)(t - t1)) / delta_t, v3);
-		}
-		while (*p == '\\')
-			p = parse_tag(p, k); // maybe k*pwr ? no, specs forbid nested \t's 
-		skip_all(')'); // FIXME: better skip(')'), but much more tags support required
-	} else if (mystrcmp(&amp;p, &quot;clip&quot;)) {
-		int x0, y0, x1, y1;
-		int res = 1;
-		skip('(');
-		res &amp;= mystrtoi(&amp;p, 10, &amp;x0);
-		skip(',');
-		res &amp;= mystrtoi(&amp;p, 10, &amp;y0);
-		skip(',');
-		res &amp;= mystrtoi(&amp;p, 10, &amp;x1);
-		skip(',');
-		res &amp;= mystrtoi(&amp;p, 10, &amp;y1);
-		skip(')');
-		if (res) {
-			render_context.clip_x0 = render_context.clip_x0 * (1-pwr) + x0 * pwr;
-			render_context.clip_x1 = render_context.clip_x1 * (1-pwr) + x1 * pwr;
-			render_context.clip_y0 = render_context.clip_y0 * (1-pwr) + y0 * pwr;
-			render_context.clip_y1 = render_context.clip_y1 * (1-pwr) + y1 * pwr;
-		} else {
-			render_context.clip_x0 = 0;
-			render_context.clip_y0 = 0;
-			render_context.clip_x1 = frame_context.track-&gt;PlayResX;
-			render_context.clip_y1 = frame_context.track-&gt;PlayResY;
-		}
-	} else if (mystrcmp(&amp;p, &quot;c&quot;)) {
-		uint32_t val;
-		if (!strtocolor(&amp;p, &amp;val))
-			val = render_context.style-&gt;PrimaryColour;
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;color: %X\n&quot;, val);
-		change_color(&amp;render_context.c[0], val, pwr);
-	} else if ((*p &gt;= '1') &amp;&amp; (*p &lt;= '4') &amp;&amp; (++p) &amp;&amp; (mystrcmp(&amp;p, &quot;c&quot;) || mystrcmp(&amp;p, &quot;a&quot;))) {
-		char n = *(p-2);
-		int cidx = n - '1';
-		char cmd = *(p-1);
-		uint32_t val;
-		assert((n &gt;= '1') &amp;&amp; (n &lt;= '4'));
-		if (!strtocolor(&amp;p, &amp;val))
-			switch(n) {
-				case '1': val = render_context.style-&gt;PrimaryColour; break;
-				case '2': val = render_context.style-&gt;SecondaryColour; break;
-				case '3': val = render_context.style-&gt;OutlineColour; break;
-				case '4': val = render_context.style-&gt;BackColour; break;
-				default : val = 0; break; // impossible due to assert; avoid compilation warning
-			}
-		switch (cmd) {
-			case 'c': change_color(render_context.c + cidx, val, pwr); break;
-			case 'a': change_alpha(render_context.c + cidx, val &gt;&gt; 24, pwr); break;
-			default: mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_BadCommand, n, cmd); break;
-		}
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;single c/a at %f: %c%c = %X   \n&quot;, pwr, n, cmd, render_context.c[cidx]);
-	} else if (mystrcmp(&amp;p, &quot;r&quot;)) {
-		reset_render_context();
-	} else if (mystrcmp(&amp;p, &quot;be&quot;)) {
-		int val;
-		if (mystrtoi(&amp;p, 10, &amp;val))
-			render_context.be = val ? 1 : 0;
-		else
-			render_context.be = 0;
-	} else if (mystrcmp(&amp;p, &quot;b&quot;)) {
-		int b;
-		if (mystrtoi(&amp;p, 10, &amp;b)) {
-			if (pwr &gt;= .5)
-				render_context.bold = b;
-		} else
-			render_context.bold = render_context.style-&gt;Bold;
-		update_font();
-	} else if (mystrcmp(&amp;p, &quot;i&quot;)) {
-		int i;
-		if (mystrtoi(&amp;p, 10, &amp;i)) {
-			if (pwr &gt;= .5)
-				render_context.italic = i;
-		} else
-			render_context.italic = render_context.style-&gt;Italic;
-		update_font();
-	} else if (mystrcmp(&amp;p, &quot;kf&quot;) || mystrcmp(&amp;p, &quot;K&quot;)) {
-		int val = strtol(p, &amp;p, 10);
-		render_context.effect_type = EF_KARAOKE_KF;
-		if (render_context.effect_timing)
-			render_context.effect_skip_timing += render_context.effect_timing;
-		render_context.effect_timing = val * 10;
-	} else if (mystrcmp(&amp;p, &quot;ko&quot;)) {
-		int val = strtol(p, &amp;p, 10);
-		render_context.effect_type = EF_KARAOKE_KO;
-		if (render_context.effect_timing)
-			render_context.effect_skip_timing += render_context.effect_timing;
-		render_context.effect_timing = val * 10;
-	} else if (mystrcmp(&amp;p, &quot;k&quot;)) {
-		int val = strtol(p, &amp;p, 10);
-		render_context.effect_type = EF_KARAOKE;
-		if (render_context.effect_timing)
-			render_context.effect_skip_timing += render_context.effect_timing;
-		render_context.effect_timing = val * 10;
-	} else if (mystrcmp(&amp;p, &quot;shad&quot;)) {
-		int val;
-		if (mystrtoi(&amp;p, 10, &amp;val))
-			render_context.shadow = val;
-		else
-			render_context.shadow = render_context.style-&gt;Shadow;
-	}
+    reset_render_context(render_priv);
 
-	return p;
+    render_priv-&gt;state.evt_type = EVENT_NORMAL;
+    render_priv-&gt;state.alignment = render_priv-&gt;state.style-&gt;Alignment;
+    render_priv-&gt;state.pos_x = 0;
+    render_priv-&gt;state.pos_y = 0;
+    render_priv-&gt;state.org_x = 0;
+    render_priv-&gt;state.org_y = 0;
+    render_priv-&gt;state.have_origin = 0;
+    render_priv-&gt;state.clip_x0 = 0;
+    render_priv-&gt;state.clip_y0 = 0;
+    render_priv-&gt;state.clip_x1 = render_priv-&gt;track-&gt;PlayResX;
+    render_priv-&gt;state.clip_y1 = render_priv-&gt;track-&gt;PlayResY;
+    render_priv-&gt;state.clip_mode = 0;
+    render_priv-&gt;state.detect_collisions = 1;
+    render_priv-&gt;state.fade = 0;
+    render_priv-&gt;state.drawing_mode = 0;
+    render_priv-&gt;state.effect_type = EF_NONE;
+    render_priv-&gt;state.effect_timing = 0;
+    render_priv-&gt;state.effect_skip_timing = 0;
+    ass_drawing_free(render_priv-&gt;state.drawing);
+    render_priv-&gt;state.drawing = ass_drawing_new(render_priv-&gt;fontconfig_priv,
+                                                 render_priv-&gt;state.font,
+                                                 render_priv-&gt;ftlibrary);
 
-#undef skip
-#undef skip_all
+    apply_transition_effects(render_priv, event);
 }
 
-/**
- * \brief Get next ucs4 char from string, parsing and executing style overrides
- * \param str string pointer
- * \return ucs4 code of the next char
- * On return str points to the unparsed part of the string
- */
-static unsigned get_next_char(char** str)
+static void free_render_context(ASS_Renderer *render_priv)
 {
-	char* p = *str;
-	unsigned chr;
-	if (*p == '{') { // '\0' goes here
-		p++;
-		while (1) {
-			p = parse_tag(p, 1.);
-			if (*p == '}') { // end of tag
-				p++;
-				if (*p == '{') {
-					p++;
-					continue;
-				} else
-					break;
-			} else if (*p != '\\')
-				mp_msg(MSGT_ASS, MSGL_V, &quot;Unable to parse: \&quot;%s\&quot; \n&quot;, p);
-			if (*p == 0)
-				break;
-		}
-	}
-	if (*p == '\t') {
-		++p;
-		*str = p;
-		return ' ';
-	}
-	if (*p == '\\') {
-		if ((*(p+1) == 'N') || ((*(p+1) == 'n') &amp;&amp; (frame_context.track-&gt;WrapStyle == 2))) {
-			p += 2;
-			*str = p;
-			return '\n';
-		} else if (*(p+1) == 'n') {
-			p += 2;
-			*str = p;
-			return ' ';
-		}
-	}
-	chr = utf8_get_char(&amp;p);
-	*str = p;
-	return chr;
+    free(render_priv-&gt;state.family);
+    ass_drawing_free(render_priv-&gt;state.drawing);
+
+    render_priv-&gt;state.family = NULL;
+    render_priv-&gt;state.drawing = NULL;
 }
 
-static void apply_transition_effects(ass_event_t* event)
+/*
+ * Replace the outline of a glyph by a contour which makes up a simple
+ * opaque rectangle.
+ */
+static void draw_opaque_box(ASS_Renderer *render_priv, uint32_t ch,
+                            FT_Glyph glyph, int sx, int sy)
 {
-	int v[4];
-	int cnt;
-	char* p = event-&gt;Effect;
+    int asc = 0, desc = 0;
+    int i;
+    int adv = d16_to_d6(glyph-&gt;advance.x);
+    double scale_y = render_priv-&gt;state.scale_y;
+    double scale_x = render_priv-&gt;state.scale_x;
+    FT_OutlineGlyph og = (FT_OutlineGlyph) glyph;
+    FT_Outline *ol;
 
-	if (!p || !*p) return;
+    // to avoid gaps
+    sx = FFMAX(64, sx);
+    sy = FFMAX(64, sy);
 
-	cnt = 0;
-	while (cnt &lt; 4 &amp;&amp; (p = strchr(p, ';'))) {
-		v[cnt++] = atoi(++p);
-	}
-	
-	if (strncmp(event-&gt;Effect, &quot;Banner;&quot;, 7) == 0) {
-		int delay;
-		if (cnt &lt; 1) {
-			mp_msg(MSGT_ASS, MSGL_V, &quot;Error parsing effect: %s \n&quot;, event-&gt;Effect);
-			return;
-		}
-		if (cnt &gt;= 2 &amp;&amp; v[1] == 0) // right-to-left
-			render_context.scroll_direction = SCROLL_RL;
-		else // left-to-right
-			render_context.scroll_direction = SCROLL_LR;
+    if (ch == -1) {
+        asc = render_priv-&gt;state.drawing-&gt;asc;
+        desc = render_priv-&gt;state.drawing-&gt;desc;
+    } else {
+        ass_font_get_asc_desc(render_priv-&gt;state.font, ch, &amp;asc, &amp;desc);
+        asc  *= scale_y;
+        desc *= scale_y;
+    }
 
-		delay = v[0];
-		if (delay == 0) delay = 1; // ?
-		render_context.scroll_shift = (frame_context.time - render_context.event-&gt;Start) / delay;
-		render_context.evt_type = EVENT_HSCROLL;
-		return;
-	}
+    // Emulate the WTFish behavior of VSFilter, i.e. double-scale
+    // the sizes of the opaque box.
+    adv += double_to_d6(render_priv-&gt;state.hspacing * render_priv-&gt;font_scale
+                        * scale_x);
+    adv *= scale_x;
+    sx *= scale_x;
+    sy *= scale_y;
+    desc *= scale_y;
+    desc += asc * (scale_y - 1.0);
 
-	if (strncmp(event-&gt;Effect, &quot;Scroll up;&quot;, 10) == 0) {
-		render_context.scroll_direction = SCROLL_BT;
-	} else if (strncmp(event-&gt;Effect, &quot;Scroll down;&quot;, 12) == 0) {
-		render_context.scroll_direction = SCROLL_TB;
-	} else {
-		mp_msg(MSGT_ASS, MSGL_V, &quot;Unknown transition effect: %s \n&quot;, event-&gt;Effect);
-		return;
-	}
-	// parse scroll up/down parameters
-	{
-		int delay;
-		int y0, y1;
-		if (cnt &lt; 3) {
-			mp_msg(MSGT_ASS, MSGL_V, &quot;Error parsing effect: %s \n&quot;, event-&gt;Effect);
-			return;
-		}
-		delay = v[2];
-		if (delay == 0) delay = 1; // ?
-		render_context.scroll_shift = (frame_context.time - render_context.event-&gt;Start) / delay;
-		if (v[0] &lt; v[1]) {
-			y0 = v[0]; y1 = v[1];
-		} else {
-			y0 = v[1]; y1 = v[0];
-		}
-		if (y1 == 0)
-			y1 = frame_context.track-&gt;PlayResY; // y0=y1=0 means fullscreen scrolling
-		render_context.clip_y0 = y0;
-		render_context.clip_y1 = y1;
-		render_context.evt_type = EVENT_VSCROLL;
-		render_context.detect_collisions = 0;
-	}
+    FT_Vector points[4] = {
+        { .x = -sx,         .y = asc + sy },
+        { .x = adv + sx,    .y = asc + sy },
+        { .x = adv + sx,    .y = -desc - sy },
+        { .x = -sx,         .y = -desc - sy },
+    };
 
+    FT_Outline_Done(render_priv-&gt;ftlibrary, &amp;og-&gt;outline);
+    FT_Outline_New(render_priv-&gt;ftlibrary, 4, 1, &amp;og-&gt;outline);
+
+    ol = &amp;og-&gt;outline;
+    ol-&gt;n_points = ol-&gt;n_contours = 0;
+    for (i = 0; i &lt; 4; i++) {
+        ol-&gt;points[ol-&gt;n_points] = points[i];
+        ol-&gt;tags[ol-&gt;n_points++] = 1;
+    }
+    ol-&gt;contours[ol-&gt;n_contours++] = ol-&gt;n_points - 1;
 }
 
-/**
- * \brief partially reset render_context to style values
- * Works like {\r}: resets some style overrides
+/*
+ * Stroke an outline glyph in x/y direction.  Applies various fixups to get
+ * around limitations of the FreeType stroker.
  */
-static void reset_render_context(void)
+static void stroke_outline_glyph(ASS_Renderer *render_priv,
+                                 FT_OutlineGlyph *glyph, int sx, int sy)
 {
-	render_context.c[0] = render_context.style-&gt;PrimaryColour;
-	render_context.c[1] = render_context.style-&gt;SecondaryColour;
-	render_context.c[2] = render_context.style-&gt;OutlineColour;
-	render_context.c[3] = render_context.style-&gt;BackColour;
-	render_context.font_size = render_context.style-&gt;FontSize;
+    if (sx &lt;= 0 &amp;&amp; sy &lt;= 0)
+        return;
 
-	if (render_context.family)
-		free(render_context.family);
-	render_context.family = strdup(render_context.style-&gt;FontName);
-	render_context.bold = render_context.style-&gt;Bold;
-	render_context.italic = render_context.style-&gt;Italic;
-	update_font();
+    fix_freetype_stroker(*glyph, sx, sy);
 
-	change_border(-1.);
-	render_context.scale_x = render_context.style-&gt;ScaleX;
-	render_context.scale_y = render_context.style-&gt;ScaleY;
-	render_context.hspacing = render_context.style-&gt;Spacing;
-	render_context.be = 0;
-	render_context.shadow = render_context.style-&gt;Shadow;
-	render_context.frx = render_context.fry = 0.;
-	render_context.frz = M_PI * render_context.style-&gt;Angle / 180.;
+    // Borders are equal; use the regular stroker
+    if (sx == sy &amp;&amp; render_priv-&gt;state.stroker) {
+        int error;
+        error = FT_Glyph_StrokeBorder((FT_Glyph *) glyph,
+                                      render_priv-&gt;state.stroker, 0, 1);
+        if (error)
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                    &quot;FT_Glyph_Stroke error: %d&quot;, error);
 
-	// FIXME: does not reset unsupported attributes.
-}
+    // &quot;Stroke&quot; with the outline emboldener in two passes.
+    // The outlines look uglier, but the emboldening never adds any points
+    } else {
+        int i;
+        FT_Outline *ol = &amp;(*glyph)-&gt;outline;
+        FT_Outline nol;
+        FT_Outline_New(render_priv-&gt;ftlibrary, ol-&gt;n_points,
+                       ol-&gt;n_contours, &amp;nol);
+        FT_Outline_Copy(ol, &amp;nol);
 
-/**
- * \brief Start new event. Reset render_context.
- */
-static void init_render_context(ass_event_t* event)
-{
-	render_context.event = event;
-	render_context.style = frame_context.track-&gt;styles + event-&gt;Style;
+        FT_Outline_Embolden(ol, sx * 2);
+        FT_Outline_Translate(ol, -sx, -sx);
+        FT_Outline_Embolden(&amp;nol, sy * 2);
+        FT_Outline_Translate(&amp;nol, -sy, -sy);
 
-	reset_render_context();
+        for (i = 0; i &lt; ol-&gt;n_points; i++)
+            ol-&gt;points[i].y = nol.points[i].y;
 
-	render_context.evt_type = EVENT_NORMAL;
-	render_context.alignment = render_context.style-&gt;Alignment;
-	render_context.pos_x = 0;
-	render_context.pos_y = 0;
-	render_context.org_x = 0;
-	render_context.org_y = 0;
-	render_context.have_origin = 0;
-	render_context.clip_x0 = 0;
-	render_context.clip_y0 = 0;
-	render_context.clip_x1 = frame_context.track-&gt;PlayResX;
-	render_context.clip_y1 = frame_context.track-&gt;PlayResY;
-	render_context.detect_collisions = 1;
-	render_context.fade = 0;
-	render_context.effect_type = EF_NONE;
-	render_context.effect_timing = 0;
-	render_context.effect_skip_timing = 0;
-	
-	apply_transition_effects(event);
+        FT_Outline_Done(render_priv-&gt;ftlibrary, &amp;nol);
+    }
 }
 
-static void free_render_context(void)
+/**
+ * \brief Prepare glyph hash
+ */
+static void
+fill_glyph_hash(ASS_Renderer *priv, GlyphHashKey *key,
+                ASS_Drawing *drawing, uint32_t ch)
 {
+    if (drawing-&gt;hash) {
+        key-&gt;scale_x = double_to_d16(priv-&gt;state.scale_x);
+        key-&gt;scale_y = double_to_d16(priv-&gt;state.scale_y);
+        key-&gt;outline.x = priv-&gt;state.border_x * 0xFFFF;
+        key-&gt;outline.y = priv-&gt;state.border_y * 0xFFFF;
+        key-&gt;border_style = priv-&gt;state.style-&gt;BorderStyle;
+        key-&gt;drawing_hash = drawing-&gt;hash;
+        // not very clean, but works
+        key-&gt;size = drawing-&gt;scale;
+        key-&gt;ch = -1;
+    } else {
+        key-&gt;font = priv-&gt;state.font;
+        key-&gt;size = priv-&gt;state.font_size;
+        key-&gt;ch = ch;
+        key-&gt;bold = priv-&gt;state.bold;
+        key-&gt;italic = priv-&gt;state.italic;
+        key-&gt;scale_x = double_to_d16(priv-&gt;state.scale_x);
+        key-&gt;scale_y = double_to_d16(priv-&gt;state.scale_y);
+        key-&gt;outline.x = priv-&gt;state.border_x * 0xFFFF;
+        key-&gt;outline.y = priv-&gt;state.border_y * 0xFFFF;
+        key-&gt;flags = priv-&gt;state.flags;
+        key-&gt;border_style = priv-&gt;state.style-&gt;BorderStyle;
+    }
 }
 
 /**
  * \brief Get normal and outline (border) glyphs
  * \param symbol ucs4 char
  * \param info out: struct filled with extracted data
- * \param advance subpixel shift vector used for cache lookup
  * Tries to get both glyphs from cache.
  * If they can't be found, gets a glyph from font face, generates outline with FT_Stroker,
  * and add them to cache.
  * The glyphs are returned in info-&gt;glyph and info-&gt;outline_glyph
  */
-static void get_outline_glyph(int symbol, glyph_info_t* info, FT_Vector* advance)
+static void
+get_outline_glyph(ASS_Renderer *render_priv, int symbol, GlyphInfo *info,
+                  ASS_Drawing *drawing)
 {
-	int error;
-	glyph_hash_val_t* val;
-	glyph_hash_key_t key;
-	key.font = render_context.font;
-	key.size = render_context.font_size;
-	key.ch = symbol;
-	key.scale_x = (render_context.scale_x * 0xFFFF);
-	key.scale_y = (render_context.scale_y * 0xFFFF);
-	key.advance = *advance;
-	key.bold = render_context.bold;
-	key.italic = render_context.italic;
-	key.outline = render_context.border * 0xFFFF;
+    GlyphHashValue *val;
+    GlyphHashKey key;
 
-	info-&gt;glyph = info-&gt;outline_glyph = 0;
+    memset(&amp;key, 0, sizeof(key));
+    memset(info, 0, sizeof(GlyphInfo));
 
-	val = cache_find_glyph(&amp;key);
-	if (val) {
-		FT_Glyph_Copy(val-&gt;glyph, &amp;info-&gt;glyph);
-		if (val-&gt;outline_glyph)
-			FT_Glyph_Copy(val-&gt;outline_glyph, &amp;info-&gt;outline_glyph);
-		info-&gt;bbox = val-&gt;bbox_scaled;
-		info-&gt;advance.x = val-&gt;advance.x;
-		info-&gt;advance.y = val-&gt;advance.y;
-	} else {
-		glyph_hash_val_t v;
-		info-&gt;glyph = ass_font_get_glyph(frame_context.ass_priv-&gt;fontconfig_priv, render_context.font, symbol, global_settings-&gt;hinting);
-		if (!info-&gt;glyph)
-			return;
-		info-&gt;advance.x = d16_to_d6(info-&gt;glyph-&gt;advance.x);
-		info-&gt;advance.y = d16_to_d6(info-&gt;glyph-&gt;advance.y);
-		FT_Glyph_Get_CBox( info-&gt;glyph, FT_GLYPH_BBOX_PIXELS, &amp;info-&gt;bbox);
+    fill_glyph_hash(render_priv, &amp;key, drawing, symbol);
+    val = cache_find_glyph(render_priv-&gt;cache.glyph_cache, &amp;key);
+    if (val) {
+        info-&gt;glyph = val-&gt;glyph;
+        info-&gt;outline_glyph = val-&gt;outline_glyph;
+        info-&gt;bbox = val-&gt;bbox_scaled;
+        info-&gt;advance.x = val-&gt;advance.x;
+        info-&gt;advance.y = val-&gt;advance.y;
+        if (drawing-&gt;hash) {
+            drawing-&gt;asc = val-&gt;asc;
+            drawing-&gt;desc = val-&gt;desc;
+        }
+    } else {
+        GlyphHashValue v;
+        if (drawing-&gt;hash) {
+            if(!ass_drawing_parse(drawing, 0))
+                return;
+            info-&gt;glyph = (FT_Glyph) drawing-&gt;glyph;
+        } else {
+            info-&gt;glyph =
+                ass_font_get_glyph(render_priv-&gt;fontconfig_priv,
+                                   render_priv-&gt;state.font, symbol,
+                                   render_priv-&gt;settings.hinting,
+                                   render_priv-&gt;state.flags);
+        }
+        if (!info-&gt;glyph)
+            return;
 
-		if (render_context.stroker) {
-			info-&gt;outline_glyph = info-&gt;glyph;
-			error = FT_Glyph_StrokeBorder( &amp;(info-&gt;outline_glyph), render_context.stroker, 0 , 0 ); // don't destroy original
-			if (error) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FT_Glyph_Stroke_Error, error);
-			}
-		}
+        info-&gt;advance.x = d16_to_d6(info-&gt;glyph-&gt;advance.x);
+        info-&gt;advance.y = d16_to_d6(info-&gt;glyph-&gt;advance.y);
+        FT_Glyph_Get_CBox(info-&gt;glyph, FT_GLYPH_BBOX_SUBPIXELS, &amp;info-&gt;bbox);
 
-		memset(&amp;v, 0, sizeof(v));
-		FT_Glyph_Copy(info-&gt;glyph, &amp;v.glyph);
-		if (info-&gt;outline_glyph)
-			FT_Glyph_Copy(info-&gt;outline_glyph, &amp;v.outline_glyph);
-		v.advance = info-&gt;advance;
-		v.bbox_scaled = info-&gt;bbox;
-		cache_add_glyph(&amp;key, &amp;v);
-	}
+        if (render_priv-&gt;state.style-&gt;BorderStyle == 3 &amp;&amp;
+            (render_priv-&gt;state.border_x &gt; 0||
+             render_priv-&gt;state.border_y &gt; 0)) {
+            FT_Glyph_Copy(info-&gt;glyph, &amp;info-&gt;outline_glyph);
+            draw_opaque_box(render_priv, symbol, info-&gt;outline_glyph,
+                            double_to_d6(render_priv-&gt;state.border_x *
+                                         render_priv-&gt;border_scale),
+                            double_to_d6(render_priv-&gt;state.border_y *
+                                         render_priv-&gt;border_scale));
+        } else if ((render_priv-&gt;state.border_x &gt; 0
+                    || render_priv-&gt;state.border_y &gt; 0)
+                   &amp;&amp; key.scale_x &amp;&amp; key.scale_y) {
+
+            FT_Glyph_Copy(info-&gt;glyph, &amp;info-&gt;outline_glyph);
+            stroke_outline_glyph(render_priv,
+                                 (FT_OutlineGlyph *) &amp;info-&gt;outline_glyph,
+                                 double_to_d6(render_priv-&gt;state.border_x *
+                                              render_priv-&gt;border_scale),
+                                 double_to_d6(render_priv-&gt;state.border_y *
+                                              render_priv-&gt;border_scale));
+        }
+
+        memset(&amp;v, 0, sizeof(v));
+        v.glyph = info-&gt;glyph;
+        v.outline_glyph = info-&gt;outline_glyph;
+        v.advance = info-&gt;advance;
+        v.bbox_scaled = info-&gt;bbox;
+        if (drawing-&gt;hash) {
+            v.asc = drawing-&gt;asc;
+            v.desc = drawing-&gt;desc;
+        }
+        cache_add_glyph(render_priv-&gt;cache.glyph_cache, &amp;key, &amp;v);
+    }
 }
 
-static void transform_3d(FT_Vector shift, FT_Glyph* glyph, FT_Glyph* glyph2, double frx, double fry, double frz);
+/**
+ * \brief Apply transformation to outline points of a glyph
+ * Applies rotations given by frx, fry and frz and projects the points back
+ * onto the screen plane.
+ */
+static void
+transform_3d_points(FT_Vector shift, FT_Glyph glyph, double frx, double fry,
+                    double frz, double fax, double fay, double scale,
+                    int yshift)
+{
+    double sx = sin(frx);
+    double sy = sin(fry);
+    double sz = sin(frz);
+    double cx = cos(frx);
+    double cy = cos(fry);
+    double cz = cos(frz);
+    FT_Outline *outline = &amp;((FT_OutlineGlyph) glyph)-&gt;outline;
+    FT_Vector *p = outline-&gt;points;
+    double x, y, z, xx, yy, zz;
+    int i, dist;
 
+    dist = 20000 * scale;
+    for (i = 0; i &lt; outline-&gt;n_points; i++) {
+        x = (double) p[i].x + shift.x + (fax * (yshift - p[i].y));
+        y = (double) p[i].y + shift.y + (-fay * p[i].x);
+        z = 0.;
+
+        xx = x * cz + y * sz;
+        yy = -(x * sz - y * cz);
+        zz = z;
+
+        x = xx;
+        y = yy * cx + zz * sx;
+        z = yy * sx - zz * cx;
+
+        xx = x * cy + z * sy;
+        yy = y;
+        zz = x * sy - z * cy;
+
+        zz = FFMAX(zz, 1000 - dist);
+
+        x = (xx * dist) / (zz + dist);
+        y = (yy * dist) / (zz + dist);
+        p[i].x = x - shift.x + 0.5;
+        p[i].y = y - shift.y + 0.5;
+    }
+}
+
 /**
+ * \brief Apply 3d transformation to several objects
+ * \param shift FreeType vector
+ * \param glyph FreeType glyph
+ * \param glyph2 FreeType glyph
+ * \param frx x-axis rotation angle
+ * \param fry y-axis rotation angle
+ * \param frz z-axis rotation angle
+ * Rotates both glyphs by frx, fry and frz. Shift vector is added before rotation and subtracted after it.
+ */
+static void
+transform_3d(FT_Vector shift, FT_Glyph *glyph, FT_Glyph *glyph2,
+             double frx, double fry, double frz, double fax, double fay,
+             double scale, int yshift)
+{
+    frx = -frx;
+    frz = -frz;
+    if (frx != 0. || fry != 0. || frz != 0. || fax != 0. || fay != 0.) {
+        if (glyph &amp;&amp; *glyph)
+            transform_3d_points(shift, *glyph, frx, fry, frz,
+                                fax, fay, scale, yshift);
+
+        if (glyph2 &amp;&amp; *glyph2)
+            transform_3d_points(shift, *glyph2, frx, fry, frz,
+                                fax, fay, scale, yshift);
+    }
+}
+
+/**
  * \brief Get bitmaps for a glyph
  * \param info glyph info
  * Tries to get glyph bitmaps from bitmap cache.
@@ -1268,50 +1229,81 @@
  * After that, bitmaps are added to the cache.
  * They are returned in info-&gt;bm (glyph), info-&gt;bm_o (outline) and info-&gt;bm_s (shadow).
  */
-static void get_bitmap_glyph(glyph_info_t* info)
+static void
+get_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info)
 {
-	bitmap_hash_val_t* val;
-	bitmap_hash_key_t* key = &amp;info-&gt;hash_key;
-	
-	val = cache_find_bitmap(key);
-/* 	val = 0; */
-	
-	if (val) {
-		info-&gt;bm = val-&gt;bm;
-		info-&gt;bm_o = val-&gt;bm_o;
-		info-&gt;bm_s = val-&gt;bm_s;
-	} else {
-		FT_Vector shift;
-		bitmap_hash_val_t hash_val;
-		int error;
-		info-&gt;bm = info-&gt;bm_o = info-&gt;bm_s = 0;
-		if (info-&gt;glyph &amp;&amp; info-&gt;symbol != '\n' &amp;&amp; info-&gt;symbol != 0) {
-			// calculating rotation shift vector (from rotation origin to the glyph basepoint)
-			shift.x = int_to_d6(info-&gt;hash_key.shift_x);
-			shift.y = int_to_d6(info-&gt;hash_key.shift_y);
-			// apply rotation
-			transform_3d(shift, &amp;info-&gt;glyph, &amp;info-&gt;outline_glyph, info-&gt;frx, info-&gt;fry, info-&gt;frz);
+    BitmapHashValue *val;
+    BitmapHashKey *key = &amp;info-&gt;hash_key;
 
-			// render glyph
-			error = glyph_to_bitmap(ass_renderer-&gt;synth_priv,
-					info-&gt;glyph, info-&gt;outline_glyph,
-					&amp;info-&gt;bm, &amp;info-&gt;bm_o,
-					&amp;info-&gt;bm_s, info-&gt;be);
-			if (error)
-				info-&gt;symbol = 0;
+    val = cache_find_bitmap(render_priv-&gt;cache.bitmap_cache, key);
 
-			// add bitmaps to cache
-			hash_val.bm_o = info-&gt;bm_o;
-			hash_val.bm = info-&gt;bm;
-			hash_val.bm_s = info-&gt;bm_s;
-			cache_add_bitmap(&amp;(info-&gt;hash_key), &amp;hash_val);
-		}
-	}
-	// deallocate glyphs
-	if (info-&gt;glyph)
-		FT_Done_Glyph(info-&gt;glyph);
-	if (info-&gt;outline_glyph)
-		FT_Done_Glyph(info-&gt;outline_glyph);
+    if (val) {
+        info-&gt;bm = val-&gt;bm;
+        info-&gt;bm_o = val-&gt;bm_o;
+        info-&gt;bm_s = val-&gt;bm_s;
+    } else {
+        FT_Vector shift;
+        BitmapHashValue hash_val;
+        int error;
+        double fax_scaled, fay_scaled;
+        info-&gt;bm = info-&gt;bm_o = info-&gt;bm_s = 0;
+        if (info-&gt;glyph &amp;&amp; info-&gt;symbol != '\n' &amp;&amp; info-&gt;symbol != 0
+            &amp;&amp; !info-&gt;skip) {
+            FT_Glyph glyph;
+            FT_Glyph outline;
+            double scale_x = render_priv-&gt;font_scale_x;
+
+            FT_Glyph_Copy(info-&gt;glyph, &amp;glyph);
+            FT_Glyph_Copy(info-&gt;outline_glyph, &amp;outline);
+            // calculating rotation shift vector (from rotation origin to the glyph basepoint)
+            shift.x = key-&gt;shift_x;
+            shift.y = key-&gt;shift_y;
+            fax_scaled = info-&gt;fax *
+                         render_priv-&gt;state.scale_x;
+            fay_scaled = info-&gt;fay * render_priv-&gt;state.scale_y;
+            // apply rotation
+            transform_3d(shift, &amp;glyph, &amp;outline,
+                         info-&gt;frx, info-&gt;fry, info-&gt;frz, fax_scaled,
+                         fay_scaled, render_priv-&gt;font_scale, info-&gt;asc);
+
+            // PAR correction scaling
+            FT_Matrix m = { double_to_d16(scale_x), 0,
+                            0, double_to_d16(1.0) };
+
+            // subpixel shift
+            if (glyph) {
+                FT_Outline *outl = &amp;((FT_OutlineGlyph) glyph)-&gt;outline;
+                if (scale_x != 1.0)
+                    FT_Outline_Transform(outl, &amp;m);
+                FT_Outline_Translate(outl, key-&gt;advance.x, -key-&gt;advance.y);
+            }
+            if (outline) {
+                FT_Outline *outl = &amp;((FT_OutlineGlyph) outline)-&gt;outline;
+                if (scale_x != 1.0)
+                    FT_Outline_Transform(outl, &amp;m);
+                FT_Outline_Translate(outl, key-&gt;advance.x, -key-&gt;advance.y);
+            }
+            // render glyph
+            error = glyph_to_bitmap(render_priv-&gt;library,
+                                    render_priv-&gt;synth_priv,
+                                    glyph, outline,
+                                    &amp;info-&gt;bm, &amp;info-&gt;bm_o,
+                                    &amp;info-&gt;bm_s, info-&gt;be,
+                                    info-&gt;blur * render_priv-&gt;border_scale,
+                                    key-&gt;shadow_offset, key-&gt;border_style);
+            if (error)
+                info-&gt;symbol = 0;
+
+            // add bitmaps to cache
+            hash_val.bm_o = info-&gt;bm_o;
+            hash_val.bm = info-&gt;bm;
+            hash_val.bm_s = info-&gt;bm_s;
+            cache_add_bitmap(render_priv-&gt;cache.bitmap_cache, key, &amp;hash_val);
+
+            FT_Done_Glyph(glyph);
+            FT_Done_Glyph(outline);
+        }
+    }
 }
 
 /**
@@ -1322,31 +1314,100 @@
  *   lines[].asc
  *   lines[].desc
  */
-static void measure_text(void)
+static void measure_text(ASS_Renderer *render_priv)
 {
-	int cur_line = 0, max_asc = 0, max_desc = 0;
-	int i;
-	text_info.height = 0;
-	for (i = 0; i &lt; text_info.length + 1; ++i) {
-		if ((i == text_info.length) || text_info.glyphs[i].linebreak) {
-			text_info.lines[cur_line].asc = max_asc;
-			text_info.lines[cur_line].desc = max_desc;
-			text_info.height += max_asc + max_desc;
-			cur_line ++;
-			max_asc = max_desc = 0;
-		}
-		if (i &lt; text_info.length) {
-			glyph_info_t* cur = text_info.glyphs + i;
-			if (cur-&gt;asc &gt; max_asc)
-				max_asc = cur-&gt;asc;
-			if (cur-&gt;desc &gt; max_desc)
-				max_desc = cur-&gt;desc;
-		}
-	}
-	text_info.height += (text_info.n_lines - 1) * double_to_d6(global_settings-&gt;line_spacing);
+    TextInfo *text_info = &amp;render_priv-&gt;text_info;
+    int cur_line = 0;
+    double max_asc = 0., max_desc = 0.;
+    GlyphInfo *last = NULL;
+    int i;
+    int empty_line = 1;
+    text_info-&gt;height = 0.;
+    for (i = 0; i &lt; text_info-&gt;length + 1; ++i) {
+        if ((i == text_info-&gt;length) || text_info-&gt;glyphs[i].linebreak) {
+            if (empty_line &amp;&amp; cur_line &gt; 0 &amp;&amp; last &amp;&amp; i &lt; text_info-&gt;length) {
+                max_asc = d6_to_double(last-&gt;asc) / 2.0;
+                max_desc = d6_to_double(last-&gt;desc) / 2.0;
+            }
+            text_info-&gt;lines[cur_line].asc = max_asc;
+            text_info-&gt;lines[cur_line].desc = max_desc;
+            text_info-&gt;height += max_asc + max_desc;
+            cur_line++;
+            max_asc = max_desc = 0.;
+            empty_line = 1;
+        } else
+            empty_line = 0;
+        if (i &lt; text_info-&gt;length) {
+            GlyphInfo *cur = text_info-&gt;glyphs + i;
+            if (d6_to_double(cur-&gt;asc) &gt; max_asc)
+                max_asc = d6_to_double(cur-&gt;asc);
+            if (d6_to_double(cur-&gt;desc) &gt; max_desc)
+                max_desc = d6_to_double(cur-&gt;desc);
+            if (cur-&gt;symbol != '\n' &amp;&amp; cur-&gt;symbol != 0)
+                last = cur;
+        }
+    }
+    text_info-&gt;height +=
+        (text_info-&gt;n_lines -
+         1) * render_priv-&gt;settings.line_spacing;
 }
 
 /**
+ * Mark extra whitespace for later removal.
+ */
+#define IS_WHITESPACE(x) ((x-&gt;symbol == ' ' || x-&gt;symbol == '\n') \
+                          &amp;&amp; !x-&gt;linebreak)
+static void trim_whitespace(ASS_Renderer *render_priv)
+{
+    int i, j;
+    GlyphInfo *cur;
+    TextInfo *ti = &amp;render_priv-&gt;text_info;
+
+    // Mark trailing spaces
+    i = ti-&gt;length - 1;
+    cur = ti-&gt;glyphs + i;
+    while (i &amp;&amp; IS_WHITESPACE(cur)) {
+        cur-&gt;skip++;
+        cur = ti-&gt;glyphs + --i;
+    }
+
+    // Mark leading whitespace
+    i = 0;
+    cur = ti-&gt;glyphs;
+    while (i &lt; ti-&gt;length &amp;&amp; IS_WHITESPACE(cur)) {
+        cur-&gt;skip++;
+        cur = ti-&gt;glyphs + ++i;
+    }
+
+    // Mark all extraneous whitespace inbetween
+    for (i = 0; i &lt; ti-&gt;length; ++i) {
+        cur = ti-&gt;glyphs + i;
+        if (cur-&gt;linebreak) {
+            // Mark whitespace before
+            j = i - 1;
+            cur = ti-&gt;glyphs + j;
+            while (j &amp;&amp; IS_WHITESPACE(cur)) {
+                cur-&gt;skip++;
+                cur = ti-&gt;glyphs + --j;
+            }
+            // A break itself can contain a whitespace, too
+            cur = ti-&gt;glyphs + i;
+            if (cur-&gt;symbol == ' ')
+                cur-&gt;skip++;
+            // Mark whitespace after
+            j = i + 1;
+            cur = ti-&gt;glyphs + j;
+            while (j &lt; ti-&gt;length &amp;&amp; IS_WHITESPACE(cur)) {
+                cur-&gt;skip++;
+                cur = ti-&gt;glyphs + ++j;
+            }
+            i = j - 1;
+        }
+    }
+}
+#undef IS_WHITESPACE
+
+/**
  * \brief rearrange text between lines
  * \param max_text_width maximal text line width in pixels
  * The algo is similar to the one in libvo/sub.c:
@@ -1354,199 +1415,237 @@
  * 2. Try moving words from the end of a line to the beginning of the next one while it reduces
  * the difference in lengths between this two lines.
  * The result may not be optimal, but usually is good enough.
+ *
+ * FIXME: implement style 0 and 3 correctly
  */
-static void wrap_lines_smart(int max_text_width)
+static void
+wrap_lines_smart(ASS_Renderer *render_priv, double max_text_width)
 {
-	int i, j;
-	glyph_info_t *cur, *s1, *e1, *s2, *s3, *w;
-	int last_space;
-	int break_type;
-	int exit;
-	int pen_shift_x;
-	int pen_shift_y;
-	int cur_line;
+    int i;
+    GlyphInfo *cur, *s1, *e1, *s2, *s3, *w;
+    int last_space;
+    int break_type;
+    int exit;
+    double pen_shift_x;
+    double pen_shift_y;
+    int cur_line;
+    TextInfo *text_info = &amp;render_priv-&gt;text_info;
 
-	last_space = -1;
-	text_info.n_lines = 1;
-	break_type = 0;
-	s1 = text_info.glyphs; // current line start
-	for (i = 0; i &lt; text_info.length; ++i) {
-		int break_at, s_offset, len;
-		cur = text_info.glyphs + i;
-		break_at = -1;
-		s_offset = s1-&gt;bbox.xMin + s1-&gt;pos.x;
-		len = (cur-&gt;bbox.xMax + cur-&gt;pos.x) - s_offset;
+    last_space = -1;
+    text_info-&gt;n_lines = 1;
+    break_type = 0;
+    s1 = text_info-&gt;glyphs;     // current line start
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        int break_at;
+        double s_offset, len;
+        cur = text_info-&gt;glyphs + i;
+        break_at = -1;
+        s_offset = d6_to_double(s1-&gt;bbox.xMin + s1-&gt;pos.x);
+        len = d6_to_double(cur-&gt;bbox.xMax + cur-&gt;pos.x) - s_offset;
 
-		if (cur-&gt;symbol == '\n') {
-			break_type = 2;
-			break_at = i;
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;forced line break at %d\n&quot;, break_at);
-		}
-		
-		if (len &gt;= max_text_width) {
-			break_type = 1;
-			break_at = last_space;
-			if (break_at == -1)
-				break_at = i - 1;
-			if (break_at == -1)
-				break_at = 0;
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;overfill at %d\n&quot;, i);
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;line break at %d\n&quot;, break_at);
-		}
+        if (cur-&gt;symbol == '\n') {
+            break_type = 2;
+            break_at = i;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                    &quot;forced line break at %d&quot;, break_at);
+        }
 
-		if (break_at != -1) {
-			// need to use one more line
-			// marking break_at+1 as start of a new line
-			int lead = break_at + 1; // the first symbol of the new line
-			if (text_info.n_lines &gt;= MAX_LINES) {
-				// to many lines ! 
-				// no more linebreaks
-				for (j = lead; j &lt; text_info.length; ++j)
-					text_info.glyphs[j].linebreak = 0;
-				break;
-			}
-			if (lead &lt; text_info.length)
-				text_info.glyphs[lead].linebreak = break_type;
-			last_space = -1;
-			s1 = text_info.glyphs + lead;
-			s_offset = s1-&gt;bbox.xMin + s1-&gt;pos.x;
-			text_info.n_lines ++;
-		}
-		
-		if (cur-&gt;symbol == ' ')
-			last_space = i;
+        if ((len &gt;= max_text_width)
+            &amp;&amp; (render_priv-&gt;state.wrap_style != 2)) {
+            break_type = 1;
+            break_at = last_space;
+            if (break_at == -1)
+                break_at = i - 1;
+            if (break_at == -1)
+                break_at = 0;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;overfill at %d&quot;, i);
+            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;line break at %d&quot;,
+                    break_at);
+        }
 
-		// make sure the hard linebreak is not forgotten when
-		// there was a new soft linebreak just inserted
-		if (cur-&gt;symbol == '\n' &amp;&amp; break_type == 1)
-			i--;
-	}
+        if (break_at != -1) {
+            // need to use one more line
+            // marking break_at+1 as start of a new line
+            int lead = break_at + 1;    // the first symbol of the new line
+            if (text_info-&gt;n_lines &gt;= text_info-&gt;max_lines) {
+                // Raise maximum number of lines
+                text_info-&gt;max_lines *= 2;
+                text_info-&gt;lines = realloc(text_info-&gt;lines,
+                                           sizeof(LineInfo) *
+                                           text_info-&gt;max_lines);
+            }
+            if (lead &lt; text_info-&gt;length)
+                text_info-&gt;glyphs[lead].linebreak = break_type;
+            last_space = -1;
+            s1 = text_info-&gt;glyphs + lead;
+            s_offset = d6_to_double(s1-&gt;bbox.xMin + s1-&gt;pos.x);
+            text_info-&gt;n_lines++;
+        }
+
+        if (cur-&gt;symbol == ' ')
+            last_space = i;
+
+        // make sure the hard linebreak is not forgotten when
+        // there was a new soft linebreak just inserted
+        if (cur-&gt;symbol == '\n' &amp;&amp; break_type == 1)
+            i--;
+    }
 #define DIFF(x,y) (((x) &lt; (y)) ? (y - x) : (x - y))
-	exit = 0;
-	while (!exit) {
-		exit = 1;
-		w = s3 = text_info.glyphs;
-		s1 = s2 = 0;
-		for (i = 0; i &lt;= text_info.length; ++i) {
-			cur = text_info.glyphs + i;
-			if ((i == text_info.length) || cur-&gt;linebreak) {
-				s1 = s2;
-				s2 = s3;
-				s3 = cur;
-				if (s1 &amp;&amp; (s2-&gt;linebreak == 1)) { // have at least 2 lines, and linebreak is 'soft'
-					int l1, l2, l1_new, l2_new;
+    exit = 0;
+    while (!exit &amp;&amp; render_priv-&gt;state.wrap_style != 1) {
+        exit = 1;
+        w = s3 = text_info-&gt;glyphs;
+        s1 = s2 = 0;
+        for (i = 0; i &lt;= text_info-&gt;length; ++i) {
+            cur = text_info-&gt;glyphs + i;
+            if ((i == text_info-&gt;length) || cur-&gt;linebreak) {
+                s1 = s2;
+                s2 = s3;
+                s3 = cur;
+                if (s1 &amp;&amp; (s2-&gt;linebreak == 1)) {       // have at least 2 lines, and linebreak is 'soft'
+                    double l1, l2, l1_new, l2_new;
 
-					w = s2;
-					do { --w; } while ((w &gt; s1) &amp;&amp; (w-&gt;symbol == ' '));
-					while ((w &gt; s1) &amp;&amp; (w-&gt;symbol != ' ')) { --w; }
-					e1 = w;
-					while ((e1 &gt; s1) &amp;&amp; (e1-&gt;symbol == ' ')) { --e1; }
-					if (w-&gt;symbol == ' ') ++w;
+                    w = s2;
+                    do {
+                        --w;
+                    } while ((w &gt; s1) &amp;&amp; (w-&gt;symbol == ' '));
+                    while ((w &gt; s1) &amp;&amp; (w-&gt;symbol != ' ')) {
+                        --w;
+                    }
+                    e1 = w;
+                    while ((e1 &gt; s1) &amp;&amp; (e1-&gt;symbol == ' ')) {
+                        --e1;
+                    }
+                    if (w-&gt;symbol == ' ')
+                        ++w;
 
-					l1 = ((s2-1)-&gt;bbox.xMax + (s2-1)-&gt;pos.x) - (s1-&gt;bbox.xMin + s1-&gt;pos.x);
-					l2 = ((s3-1)-&gt;bbox.xMax + (s3-1)-&gt;pos.x) - (s2-&gt;bbox.xMin + s2-&gt;pos.x);
-					l1_new = (e1-&gt;bbox.xMax + e1-&gt;pos.x) - (s1-&gt;bbox.xMin + s1-&gt;pos.x);
-					l2_new = ((s3-1)-&gt;bbox.xMax + (s3-1)-&gt;pos.x) - (w-&gt;bbox.xMin + w-&gt;pos.x);
+                    l1 = d6_to_double(((s2 - 1)-&gt;bbox.xMax + (s2 - 1)-&gt;pos.x) -
+                        (s1-&gt;bbox.xMin + s1-&gt;pos.x));
+                    l2 = d6_to_double(((s3 - 1)-&gt;bbox.xMax + (s3 - 1)-&gt;pos.x) -
+                        (s2-&gt;bbox.xMin + s2-&gt;pos.x));
+                    l1_new = d6_to_double(
+                        (e1-&gt;bbox.xMax + e1-&gt;pos.x) -
+                        (s1-&gt;bbox.xMin + s1-&gt;pos.x));
+                    l2_new = d6_to_double(
+                        ((s3 - 1)-&gt;bbox.xMax + (s3 - 1)-&gt;pos.x) -
+                        (w-&gt;bbox.xMin + w-&gt;pos.x));
 
-					if (DIFF(l1_new, l2_new) &lt; DIFF(l1, l2)) {
-						w-&gt;linebreak = 1;
-						s2-&gt;linebreak = 0;
-						exit = 0;
-					}
-				}
-			}
-			if (i == text_info.length)
-				break;
-		}
-		
-	}
-	assert(text_info.n_lines &gt;= 1);
+                    if (DIFF(l1_new, l2_new) &lt; DIFF(l1, l2)) {
+                        w-&gt;linebreak = 1;
+                        s2-&gt;linebreak = 0;
+                        exit = 0;
+                    }
+                }
+            }
+            if (i == text_info-&gt;length)
+                break;
+        }
+
+    }
+    assert(text_info-&gt;n_lines &gt;= 1);
 #undef DIFF
-	
-	measure_text();
 
-	pen_shift_x = 0;
-	pen_shift_y = 0;
-	cur_line = 1;
-	for (i = 0; i &lt; text_info.length; ++i) {
-		cur = text_info.glyphs + i;
-		if (cur-&gt;linebreak) {
-			int height = text_info.lines[cur_line - 1].desc + text_info.lines[cur_line].asc;
-			cur_line ++;
-			pen_shift_x = - cur-&gt;pos.x;
-			pen_shift_y += d6_to_int(height + double_to_d6(global_settings-&gt;line_spacing));
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;shifting from %d to %d by (%d, %d)\n&quot;, i, text_info.length - 1, pen_shift_x, pen_shift_y);
-		}
-		cur-&gt;pos.x += pen_shift_x;
-		cur-&gt;pos.y += pen_shift_y;
-	}
+    measure_text(render_priv);
+    trim_whitespace(render_priv);
+
+    pen_shift_x = 0.;
+    pen_shift_y = 0.;
+    cur_line = 1;
+
+    i = 0;
+    cur = text_info-&gt;glyphs + i;
+    while (i &lt; text_info-&gt;length &amp;&amp; cur-&gt;skip)
+        cur = text_info-&gt;glyphs + ++i;
+    pen_shift_x = d6_to_double(-cur-&gt;pos.x);
+
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        cur = text_info-&gt;glyphs + i;
+        if (cur-&gt;linebreak) {
+            while (i &lt; text_info-&gt;length &amp;&amp; cur-&gt;skip &amp;&amp; cur-&gt;symbol != '\n')
+                cur = text_info-&gt;glyphs + ++i;
+            double height =
+                text_info-&gt;lines[cur_line - 1].desc +
+                text_info-&gt;lines[cur_line].asc;
+            cur_line++;
+            pen_shift_x = d6_to_double(-cur-&gt;pos.x);
+            pen_shift_y += height + render_priv-&gt;settings.line_spacing;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                   &quot;shifting from %d to %d by (%f, %f)&quot;, i,
+                   text_info-&gt;length - 1, pen_shift_x, pen_shift_y);
+        }
+        cur-&gt;pos.x += double_to_d6(pen_shift_x);
+        cur-&gt;pos.y += double_to_d6(pen_shift_y);
+    }
 }
 
 /**
  * \brief determine karaoke effects
  * Karaoke effects cannot be calculated during parse stage (get_next_char()),
  * so they are done in a separate step.
- * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's 
+ * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's
  * (the first glyph of the karaoke word)'s effect_type and effect_timing.
  * This function:
  * 1. sets effect_type for all glyphs in the word (_karaoke_ word)
  * 2. sets effect_timing for all glyphs to x coordinate of the border line between the left and right karaoke parts
  * (left part is filled with PrimaryColour, right one - with SecondaryColour).
  */
-static void process_karaoke_effects(void)
+static void process_karaoke_effects(ASS_Renderer *render_priv)
 {
-	glyph_info_t *cur, *cur2;
-	glyph_info_t *s1, *e1; // start and end of the current word
-	glyph_info_t *s2; // start of the next word
-	int i;
-	int timing; // current timing
-	int tm_start, tm_end; // timings at start and end of the current word
-	int tm_current;
-	double dt;
-	int x;
-	int x_start, x_end;
+    GlyphInfo *cur, *cur2;
+    GlyphInfo *s1, *e1;      // start and end of the current word
+    GlyphInfo *s2;           // start of the next word
+    int i;
+    int timing;                 // current timing
+    int tm_start, tm_end;       // timings at start and end of the current word
+    int tm_current;
+    double dt;
+    int x;
+    int x_start, x_end;
 
-	tm_current = frame_context.time - render_context.event-&gt;Start;
-	timing = 0;
-	s1 = s2 = 0;
-	for (i = 0; i &lt;= text_info.length; ++i) {
-		cur = text_info.glyphs + i;
-		if ((i == text_info.length) || (cur-&gt;effect_type != EF_NONE)) {
-			s1 = s2;
-			s2 = cur;
-			if (s1) {
-				e1 = s2 - 1;
-				tm_start = timing + s1-&gt;effect_skip_timing;
-				tm_end = tm_start + s1-&gt;effect_timing;
-				timing = tm_end;
-				x_start = 1000000;
-				x_end = -1000000;
-				for (cur2 = s1; cur2 &lt;= e1; ++cur2) {
-					x_start = FFMIN(x_start, cur2-&gt;bbox.xMin + cur2-&gt;pos.x);
-					x_end = FFMAX(x_end, cur2-&gt;bbox.xMax + cur2-&gt;pos.x);
-				}
+    tm_current = render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start;
+    timing = 0;
+    s1 = s2 = 0;
+    for (i = 0; i &lt;= render_priv-&gt;text_info.length; ++i) {
+        cur = render_priv-&gt;text_info.glyphs + i;
+        if ((i == render_priv-&gt;text_info.length)
+            || (cur-&gt;effect_type != EF_NONE)) {
+            s1 = s2;
+            s2 = cur;
+            if (s1) {
+                e1 = s2 - 1;
+                tm_start = timing + s1-&gt;effect_skip_timing;
+                tm_end = tm_start + s1-&gt;effect_timing;
+                timing = tm_end;
+                x_start = 1000000;
+                x_end = -1000000;
+                for (cur2 = s1; cur2 &lt;= e1; ++cur2) {
+                    x_start = FFMIN(x_start, d6_to_int(cur2-&gt;bbox.xMin + cur2-&gt;pos.x));
+                    x_end = FFMAX(x_end, d6_to_int(cur2-&gt;bbox.xMax + cur2-&gt;pos.x));
+                }
 
-				dt = (tm_current - tm_start);
-				if ((s1-&gt;effect_type == EF_KARAOKE) || (s1-&gt;effect_type == EF_KARAOKE_KO)) {
-					if (dt &gt; 0)
-						x = x_end + 1;
-					else
-						x = x_start;
-				} else if (s1-&gt;effect_type == EF_KARAOKE_KF) {
-					dt /= (tm_end - tm_start);
-					x = x_start + (x_end - x_start) * dt;
-				} else {
-					mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_UnknownEffectType_InternalError);
-					continue;
-				}
+                dt = (tm_current - tm_start);
+                if ((s1-&gt;effect_type == EF_KARAOKE)
+                    || (s1-&gt;effect_type == EF_KARAOKE_KO)) {
+                    if (dt &gt; 0)
+                        x = x_end + 1;
+                    else
+                        x = x_start;
+                } else if (s1-&gt;effect_type == EF_KARAOKE_KF) {
+                    dt /= (tm_end - tm_start);
+                    x = x_start + (x_end - x_start) * dt;
+                } else {
+                    ass_msg(render_priv-&gt;library, MSGL_ERR,
+                            &quot;Unknown effect type&quot;);
+                    continue;
+                }
 
-				for (cur2 = s1; cur2 &lt;= e1; ++cur2) {
-					cur2-&gt;effect_type = s1-&gt;effect_type;
-					cur2-&gt;effect_timing = x - cur2-&gt;pos.x;
-				}
-			}
-		}
-	}
+                for (cur2 = s1; cur2 &lt;= e1; ++cur2) {
+                    cur2-&gt;effect_type = s1-&gt;effect_type;
+                    cur2-&gt;effect_timing = x - d6_to_int(cur2-&gt;pos.x);
+                }
+            }
+        }
+    }
 }
 
 /**
@@ -1555,723 +1654,755 @@
  * \param alignment alignment
  * \param bx, by out: base point coordinates
  */
-static void get_base_point(FT_BBox bbox, int alignment, int* bx, int* by)
+static void get_base_point(DBBox *bbox, int alignment, double *bx, double *by)
 {
-	const int halign = alignment &amp; 3;
-	const int valign = alignment &amp; 12;
-	if (bx)
-		switch(halign) {
-		case HALIGN_LEFT:
-			*bx = bbox.xMin;
-			break;
-		case HALIGN_CENTER:
-			*bx = (bbox.xMax + bbox.xMin) / 2;
-			break;
-		case HALIGN_RIGHT:
-			*bx = bbox.xMax;
-			break;
-		}
-	if (by)
-		switch(valign) {
-		case VALIGN_TOP:
-			*by = bbox.yMin;
-			break;
-		case VALIGN_CENTER:
-			*by = (bbox.yMax + bbox.yMin) / 2;
-			break;
-		case VALIGN_SUB:
-			*by = bbox.yMax;
-			break;
-		}
+    const int halign = alignment &amp; 3;
+    const int valign = alignment &amp; 12;
+    if (bx)
+        switch (halign) {
+        case HALIGN_LEFT:
+            *bx = bbox-&gt;xMin;
+            break;
+        case HALIGN_CENTER:
+            *bx = (bbox-&gt;xMax + bbox-&gt;xMin) / 2.0;
+            break;
+        case HALIGN_RIGHT:
+            *bx = bbox-&gt;xMax;
+            break;
+        }
+    if (by)
+        switch (valign) {
+        case VALIGN_TOP:
+            *by = bbox-&gt;yMin;
+            break;
+        case VALIGN_CENTER:
+            *by = (bbox-&gt;yMax + bbox-&gt;yMin) / 2.0;
+            break;
+        case VALIGN_SUB:
+            *by = bbox-&gt;yMax;
+            break;
+        }
 }
 
 /**
- * \brief Multiply 4-vector by 4-matrix
- * \param a 4-vector
- * \param m 4-matrix]
- * \param b out: 4-vector
- * Calculates a * m and stores result in b
+ * Prepare bitmap hash key of a glyph
  */
-static inline void transform_point_3d(double *a, double *m, double *b)
+static void
+fill_bitmap_hash(ASS_Renderer *priv, BitmapHashKey *hash_key,
+                 ASS_Drawing *drawing, FT_Vector pen, uint32_t code)
 {
-	b[0] = a[0] * m[0] + a[1] * m[4] + a[2] * m[8] +  a[3] * m[12];
-	b[1] = a[0] * m[1] + a[1] * m[5] + a[2] * m[9] +  a[3] * m[13];
-	b[2] = a[0] * m[2] + a[1] * m[6] + a[2] * m[10] + a[3] * m[14];
-	b[3] = a[0] * m[3] + a[1] * m[7] + a[2] * m[11] + a[3] * m[15];
+    if (!drawing-&gt;hash) {
+        hash_key-&gt;font = priv-&gt;state.font;
+        hash_key-&gt;size = priv-&gt;state.font_size;
+        hash_key-&gt;bold = priv-&gt;state.bold;
+        hash_key-&gt;italic = priv-&gt;state.italic;
+    } else {
+        hash_key-&gt;drawing_hash = drawing-&gt;hash;
+        hash_key-&gt;size = drawing-&gt;scale;
+    }
+    hash_key-&gt;ch = code;
+    hash_key-&gt;outline.x = double_to_d16(priv-&gt;state.border_x);
+    hash_key-&gt;outline.y = double_to_d16(priv-&gt;state.border_y);
+    hash_key-&gt;scale_x = double_to_d16(priv-&gt;state.scale_x);
+    hash_key-&gt;scale_y = double_to_d16(priv-&gt;state.scale_y);
+    hash_key-&gt;frx = rot_key(priv-&gt;state.frx);
+    hash_key-&gt;fry = rot_key(priv-&gt;state.fry);
+    hash_key-&gt;frz = rot_key(priv-&gt;state.frz);
+    hash_key-&gt;fax = double_to_d16(priv-&gt;state.fax);
+    hash_key-&gt;fay = double_to_d16(priv-&gt;state.fay);
+    hash_key-&gt;be = priv-&gt;state.be;
+    hash_key-&gt;blur = priv-&gt;state.blur;
+    hash_key-&gt;border_style = priv-&gt;state.style-&gt;BorderStyle;
+    hash_key-&gt;shadow_offset.x = double_to_d6(
+            priv-&gt;state.shadow_x * priv-&gt;border_scale -
+            (int) (priv-&gt;state.shadow_x * priv-&gt;border_scale));
+    hash_key-&gt;shadow_offset.y = double_to_d6(
+            priv-&gt;state.shadow_y * priv-&gt;border_scale -
+            (int) (priv-&gt;state.shadow_y * priv-&gt;border_scale));
+    hash_key-&gt;flags = priv-&gt;state.flags;
 }
 
 /**
- * \brief Apply 3d transformation to a vector
- * \param v FreeType vector (2d)
- * \param m 4-matrix
- * Transforms v by m, projects the result back to the screen plane
- * Result is returned in v.
+ * \brief Main ass rendering function, glues everything together
+ * \param event event to render
+ * \param event_images struct containing resulting images, will also be initialized
+ * Process event, appending resulting ASS_Image's to images_root.
  */
-static inline void transform_vector_3d(FT_Vector* v, double *m) {
-	const double camera = 2500 * frame_context.border_scale; // camera distance
-	double a[4], b[4];
-	a[0] = d6_to_double(v-&gt;x);
-	a[1] = d6_to_double(v-&gt;y);
-	a[2] = 0.;
-	a[3] = 1.;
-	transform_point_3d(a, m, b);
-	/* Apply perspective projection with the following matrix:
-	   2500     0     0     0
-	      0  2500     0     0
-	      0     0     0     0
-	      0     0     8     2500
-	   where 2500 is camera distance, 8 - z-axis scale.
-	   Camera is always located in (org_x, org_y, -2500). This means
-	   that different subtitle events can be displayed at the same time
-	   using different cameras. */
-	b[0] *= camera;
-	b[1] *= camera;
-	b[3] = 8 * b[2] + camera;
-	if (b[3] &lt; 0.001 &amp;&amp; b[3] &gt; -0.001)
-		b[3] = b[3] &lt; 0. ? -0.001 : 0.001;
-	v-&gt;x = double_to_d6(b[0] / b[3]);
-	v-&gt;y = double_to_d6(b[1] / b[3]);
-}
+static int
+ass_render_event(ASS_Renderer *render_priv, ASS_Event *event,
+                 EventImages *event_images)
+{
+    char *p;
+    FT_UInt previous;
+    FT_UInt num_glyphs;
+    FT_Vector pen;
+    unsigned code;
+    DBBox bbox;
+    int i, j;
+    int MarginL, MarginR, MarginV;
+    int last_break;
+    int alignment, halign, valign;
+    int kern = render_priv-&gt;track-&gt;Kerning;
+    double device_x = 0;
+    double device_y = 0;
+    TextInfo *text_info = &amp;render_priv-&gt;text_info;
+    GlyphInfo *glyphs = render_priv-&gt;text_info.glyphs;
+    ASS_Drawing *drawing;
 
-/**
- * \brief Apply 3d transformation to a glyph
- * \param glyph FreeType glyph
- * \param m 4-matrix
- * Transforms glyph by m, projects the result back to the screen plane
- * Result is returned in glyph.
- */
-static inline void transform_glyph_3d(FT_Glyph glyph, double *m, FT_Vector shift) {
-	int i;
-	FT_Outline* outline = &amp;((FT_OutlineGlyph)glyph)-&gt;outline;
-	FT_Vector* p = outline-&gt;points;
+    if (event-&gt;Style &gt;= render_priv-&gt;track-&gt;n_styles) {
+        ass_msg(render_priv-&gt;library, MSGL_WARN, &quot;No style found&quot;);
+        return 1;
+    }
+    if (!event-&gt;Text) {
+        ass_msg(render_priv-&gt;library, MSGL_WARN, &quot;Empty event&quot;);
+        return 1;
+    }
 
-	for (i=0; i&lt;outline-&gt;n_points; i++) {
-		p[i].x += shift.x;
-		p[i].y += shift.y;
-		transform_vector_3d(p + i, m);
-		p[i].x -= shift.x;
-		p[i].y -= shift.y;
-	}
+    init_render_context(render_priv, event);
 
-	//transform_vector_3d(&amp;glyph-&gt;advance, m);
-}
+    drawing = render_priv-&gt;state.drawing;
+    text_info-&gt;length = 0;
+    pen.x = 0;
+    pen.y = 0;
+    previous = 0;
+    num_glyphs = 0;
+    p = event-&gt;Text;
+    // Event parsing.
+    while (1) {
+        // get next char, executing style override
+        // this affects render_context
+        do {
+            code = get_next_char(render_priv, &amp;p);
+            if (render_priv-&gt;state.drawing_mode &amp;&amp; code)
+                ass_drawing_add_char(drawing, (char) code);
+        } while (code &amp;&amp; render_priv-&gt;state.drawing_mode);      // skip everything in drawing mode
 
-/**
- * \brief Apply 3d transformation to several objects
- * \param shift FreeType vector
- * \param glyph FreeType glyph
- * \param glyph2 FreeType glyph
- * \param frx x-axis rotation angle
- * \param fry y-axis rotation angle
- * \param frz z-axis rotation angle
- * Rotates both glyphs by frx, fry and frz. Shift vector is added before rotation and subtracted after it.
- */
-static void transform_3d(FT_Vector shift, FT_Glyph* glyph, FT_Glyph* glyph2, double frx, double fry, double frz)
-{
-	fry = - fry; // FreeType's y axis goes in the opposite direction
-	if (frx != 0. || fry != 0. || frz != 0.) {
-		double m[16];
-		double sx = sin(frx);
-		double sy = sin(fry);
- 		double sz = sin(frz);
-		double cx = cos(frx);
-		double cy = cos(fry);
-		double cz = cos(frz);
-		m[0] = cy * cz;            m[1] = cy*sz;              m[2]  = -sy;    m[3] = 0.0;
-		m[4] = -cx*sz + sx*sy*cz;  m[5] = cx*cz + sx*sy*sz;   m[6]  = sx*cy;  m[7] = 0.0;
-		m[8] = sx*sz + cx*sy*cz;   m[9] = -sx*cz + cx*sy*sz;  m[10] = cx*cy;  m[11] = 0.0;
-		m[12] = 0.0;               m[13] = 0.0;               m[14] = 0.0;    m[15] = 1.0;
+        // Parse drawing
+        if (drawing-&gt;i) {
+            drawing-&gt;scale_x = render_priv-&gt;state.scale_x *
+                                     render_priv-&gt;font_scale;
+            drawing-&gt;scale_y = render_priv-&gt;state.scale_y *
+                                     render_priv-&gt;font_scale;
+            ass_drawing_hash(drawing);
+            p--;
+            code = -1;
+        }
 
-		if (glyph &amp;&amp; *glyph)
-			transform_glyph_3d(*glyph, m, shift);
+        // face could have been changed in get_next_char
+        if (!render_priv-&gt;state.font) {
+            free_render_context(render_priv);
+            return 1;
+        }
 
-		if (glyph2 &amp;&amp; *glyph2)
-			transform_glyph_3d(*glyph2, m, shift);
-	}
-}
+        if (code == 0)
+            break;
 
-/**
- * \brief Main ass rendering function, glues everything together
- * \param event event to render
- * Process event, appending resulting ass_image_t's to images_root.
- */
-static int ass_render_event(ass_event_t* event, event_images_t* event_images)
-{
-	char* p;
-	FT_UInt previous; 
-	FT_UInt num_glyphs;
-	FT_Vector pen;
-	unsigned code;
-	FT_BBox bbox;
-	int i, j;
-	FT_Vector shift;
-	int MarginL, MarginR, MarginV;
-	int last_break;
-	int alignment, halign, valign;
-	int device_x = 0, device_y = 0;
+        if (text_info-&gt;length &gt;= text_info-&gt;max_glyphs) {
+            // Raise maximum number of glyphs
+            text_info-&gt;max_glyphs *= 2;
+            text_info-&gt;glyphs = glyphs =
+                realloc(text_info-&gt;glyphs,
+                        sizeof(GlyphInfo) * text_info-&gt;max_glyphs);
+        }
 
-	if (event-&gt;Style &gt;= frame_context.track-&gt;n_styles) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoStyleFound);
-		return 1;
-	}
-	if (!event-&gt;Text) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EmptyEvent);
-		return 1;
-	}
+        // Add kerning to pen
+        if (kern &amp;&amp; previous &amp;&amp; code &amp;&amp; !drawing-&gt;hash) {
+            FT_Vector delta;
+            delta =
+                ass_font_get_kerning(render_priv-&gt;state.font, previous,
+                                     code);
+            pen.x += delta.x * render_priv-&gt;state.scale_x;
+            pen.y += delta.y * render_priv-&gt;state.scale_y;
+        }
 
-	init_render_context(event);
+        ass_font_set_transform(render_priv-&gt;state.font,
+                               render_priv-&gt;state.scale_x,
+                               render_priv-&gt;state.scale_y, NULL);
 
-	text_info.length = 0;
-	pen.x = 0;
-	pen.y = 0;
-	previous = 0;
-	num_glyphs = 0;
-	p = event-&gt;Text;
-	// Event parsing.
-	while (1) {
-		// get next char, executing style override
-		// this affects render_context
-		code = get_next_char(&amp;p);
-		
-		// face could have been changed in get_next_char
-		if (!render_context.font) {
-			free_render_context();
-			return 1;
-		}
+        get_outline_glyph(render_priv, code,
+                          glyphs + text_info-&gt;length, drawing);
 
-		if (code == 0)
-			break;
+        // Add additional space after italic to non-italic style changes
+        if (text_info-&gt;length &amp;&amp;
+            glyphs[text_info-&gt;length - 1].hash_key.italic &amp;&amp;
+            !render_priv-&gt;state.italic) {
+            int back = text_info-&gt;length - 1;
+            GlyphInfo *og = &amp;glyphs[back];
+            while (back &amp;&amp; og-&gt;bbox.xMax - og-&gt;bbox.xMin == 0
+                   &amp;&amp; og-&gt;hash_key.italic)
+                og = &amp;glyphs[--back];
+            if (og-&gt;bbox.xMax &gt; og-&gt;advance.x) {
+                // The FreeType oblique slants by 6/16
+                pen.x += og-&gt;bbox.yMax * 0.375;
+            }
+        }
 
-		if (text_info.length &gt;= MAX_GLYPHS) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_MAX_GLYPHS_Reached, 
-					(int)(event - frame_context.track-&gt;events), event-&gt;Start, event-&gt;Duration, event-&gt;Text);
-			break;
-		}
+        glyphs[text_info-&gt;length].pos.x = pen.x;
+        glyphs[text_info-&gt;length].pos.y = pen.y;
 
-		if ( previous &amp;&amp; code ) {
-			FT_Vector delta;
-			delta = ass_font_get_kerning(render_context.font, previous, code);
-			pen.x += delta.x * render_context.scale_x;
-			pen.y += delta.y * render_context.scale_y;
-		}
+        pen.x += glyphs[text_info-&gt;length].advance.x;
+        pen.x += double_to_d6(render_priv-&gt;state.hspacing *
+                              render_priv-&gt;font_scale
+                              * render_priv-&gt;state.scale_x);
+        pen.y += glyphs[text_info-&gt;length].advance.y;
+        pen.y += (render_priv-&gt;state.fay * render_priv-&gt;state.scale_y) *
+                 glyphs[text_info-&gt;length].advance.x;
 
-		shift.x = pen.x &amp; 63;
-		shift.y = pen.y &amp; 63;
+        previous = code;
 
-		ass_font_set_transform(render_context.font,
-				       render_context.scale_x * frame_context.font_scale_x,
-				       render_context.scale_y,
-				       &amp;shift );
+        glyphs[text_info-&gt;length].symbol = code;
+        glyphs[text_info-&gt;length].linebreak = 0;
+        for (i = 0; i &lt; 4; ++i) {
+            uint32_t clr = render_priv-&gt;state.c[i];
+            change_alpha(&amp;clr,
+                         mult_alpha(_a(clr), render_priv-&gt;state.fade), 1.);
+            glyphs[text_info-&gt;length].c[i] = clr;
+        }
+        glyphs[text_info-&gt;length].effect_type = render_priv-&gt;state.effect_type;
+        glyphs[text_info-&gt;length].effect_timing =
+            render_priv-&gt;state.effect_timing;
+        glyphs[text_info-&gt;length].effect_skip_timing =
+            render_priv-&gt;state.effect_skip_timing;
+        glyphs[text_info-&gt;length].be = render_priv-&gt;state.be;
+        glyphs[text_info-&gt;length].blur = render_priv-&gt;state.blur;
+        glyphs[text_info-&gt;length].shadow_x = render_priv-&gt;state.shadow_x;
+        glyphs[text_info-&gt;length].shadow_y = render_priv-&gt;state.shadow_y;
+        glyphs[text_info-&gt;length].frx = render_priv-&gt;state.frx;
+        glyphs[text_info-&gt;length].fry = render_priv-&gt;state.fry;
+        glyphs[text_info-&gt;length].frz = render_priv-&gt;state.frz;
+        glyphs[text_info-&gt;length].fax = render_priv-&gt;state.fax;
+        glyphs[text_info-&gt;length].fay = render_priv-&gt;state.fay;
+        if (drawing-&gt;hash) {
+            glyphs[text_info-&gt;length].asc = drawing-&gt;asc;
+            glyphs[text_info-&gt;length].desc = drawing-&gt;desc;
+        } else {
+            ass_font_get_asc_desc(render_priv-&gt;state.font, code,
+                                  &amp;glyphs[text_info-&gt;length].asc,
+                                  &amp;glyphs[text_info-&gt;length].desc);
 
-		get_outline_glyph(code, text_info.glyphs + text_info.length, &amp;shift);
-		
-		text_info.glyphs[text_info.length].pos.x = pen.x &gt;&gt; 6;
-		text_info.glyphs[text_info.length].pos.y = pen.y &gt;&gt; 6;
-		
-		pen.x += text_info.glyphs[text_info.length].advance.x;
-		pen.x += double_to_d6(render_context.hspacing);
-		pen.y += text_info.glyphs[text_info.length].advance.y;
-		
-		previous = code;
+            glyphs[text_info-&gt;length].asc *= render_priv-&gt;state.scale_y;
+            glyphs[text_info-&gt;length].desc *= render_priv-&gt;state.scale_y;
+        }
 
-		text_info.glyphs[text_info.length].symbol = code;
-		text_info.glyphs[text_info.length].linebreak = 0;
-		for (i = 0; i &lt; 4; ++i) {
-			uint32_t clr = render_context.c[i];
-			change_alpha(&amp;clr, mult_alpha(_a(clr), render_context.fade), 1.);
-			text_info.glyphs[text_info.length].c[i] = clr;
-		}
-		text_info.glyphs[text_info.length].effect_type = render_context.effect_type;
-		text_info.glyphs[text_info.length].effect_timing = render_context.effect_timing;
-		text_info.glyphs[text_info.length].effect_skip_timing = render_context.effect_skip_timing;
-		text_info.glyphs[text_info.length].be = render_context.be;
-		text_info.glyphs[text_info.length].shadow = render_context.shadow;
-		text_info.glyphs[text_info.length].frx = render_context.frx;
-		text_info.glyphs[text_info.length].fry = render_context.fry;
-		text_info.glyphs[text_info.length].frz = render_context.frz;
-		ass_font_get_asc_desc(render_context.font, code,
-				      &amp;text_info.glyphs[text_info.length].asc,
-				      &amp;text_info.glyphs[text_info.length].desc);
-		text_info.glyphs[text_info.length].asc *= render_context.scale_y;
-		text_info.glyphs[text_info.length].desc *= render_context.scale_y;
+        // fill bitmap hash
+        fill_bitmap_hash(render_priv, &amp;glyphs[text_info-&gt;length].hash_key,
+                         drawing, pen, code);
 
-		// fill bitmap_hash_key
-		text_info.glyphs[text_info.length].hash_key.font = render_context.font;
-		text_info.glyphs[text_info.length].hash_key.size = render_context.font_size;
-		text_info.glyphs[text_info.length].hash_key.outline = render_context.border * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.scale_x = render_context.scale_x * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.scale_y = render_context.scale_y * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.frx = render_context.frx * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.fry = render_context.fry * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.frz = render_context.frz * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.bold = render_context.bold;
-		text_info.glyphs[text_info.length].hash_key.italic = render_context.italic;
-		text_info.glyphs[text_info.length].hash_key.ch = code;
-		text_info.glyphs[text_info.length].hash_key.advance = shift;
-		text_info.glyphs[text_info.length].hash_key.be = render_context.be;
+        text_info-&gt;length++;
 
-		text_info.length++;
+        render_priv-&gt;state.effect_type = EF_NONE;
+        render_priv-&gt;state.effect_timing = 0;
+        render_priv-&gt;state.effect_skip_timing = 0;
 
-		render_context.effect_type = EF_NONE;
-		render_context.effect_timing = 0;
-		render_context.effect_skip_timing = 0;
-	}
-	
-	if (text_info.length == 0) {
-		// no valid symbols in the event; this can be smth like {comment}
-		free_render_context();
-		return 1;
-	}
-	
-	// depends on glyph x coordinates being monotonous, so it should be done before line wrap
-	process_karaoke_effects();
-	
-	// alignments
-	alignment = render_context.alignment;
-	halign = alignment &amp; 3;
-	valign = alignment &amp; 12;
+        if (drawing-&gt;hash) {
+            ass_drawing_free(drawing);
+            drawing = render_priv-&gt;state.drawing =
+                ass_drawing_new(render_priv-&gt;fontconfig_priv,
+                    render_priv-&gt;state.font,
+                    render_priv-&gt;ftlibrary);
+        }
+    }
 
-	MarginL = (event-&gt;MarginL) ? event-&gt;MarginL : render_context.style-&gt;MarginL; 
-	MarginR = (event-&gt;MarginR) ? event-&gt;MarginR : render_context.style-&gt;MarginR; 
-	MarginV = (event-&gt;MarginV) ? event-&gt;MarginV : render_context.style-&gt;MarginV;
 
-	if (render_context.evt_type != EVENT_HSCROLL) {
-		int max_text_width;
+    if (text_info-&gt;length == 0) {
+        // no valid symbols in the event; this can be smth like {comment}
+        free_render_context(render_priv);
+        return 1;
+    }
 
-		// calculate max length of a line
-		max_text_width = x2scr(frame_context.track-&gt;PlayResX - MarginR) - x2scr(MarginL);
+    // depends on glyph x coordinates being monotonous, so it should be done before line wrap
+    process_karaoke_effects(render_priv);
 
-		// rearrange text in several lines
-		wrap_lines_smart(max_text_width);
+    // alignments
+    alignment = render_priv-&gt;state.alignment;
+    halign = alignment &amp; 3;
+    valign = alignment &amp; 12;
 
-		// align text
-		last_break = -1;
-		for (i = 1; i &lt; text_info.length + 1; ++i) { // (text_info.length + 1) is the end of the last line
-			if ((i == text_info.length) || text_info.glyphs[i].linebreak) {
-				int width, shift = 0;
-				glyph_info_t* first_glyph = text_info.glyphs + last_break + 1;
-				glyph_info_t* last_glyph = text_info.glyphs + i - 1;
+    MarginL =
+        (event-&gt;MarginL) ? event-&gt;MarginL : render_priv-&gt;state.style-&gt;MarginL;
+    MarginR =
+        (event-&gt;MarginR) ? event-&gt;MarginR : render_priv-&gt;state.style-&gt;MarginR;
+    MarginV =
+        (event-&gt;MarginV) ? event-&gt;MarginV : render_priv-&gt;state.style-&gt;MarginV;
 
-				while ((last_glyph &gt; first_glyph) &amp;&amp; ((last_glyph-&gt;symbol == '\n') || (last_glyph-&gt;symbol == 0)))
-					last_glyph --;
+    if (render_priv-&gt;state.evt_type != EVENT_HSCROLL) {
+        double max_text_width;
 
-				width = last_glyph-&gt;pos.x + d6_to_int(last_glyph-&gt;advance.x) - first_glyph-&gt;pos.x;
-				if (halign == HALIGN_LEFT) { // left aligned, no action
-					shift = 0;
-				} else if (halign == HALIGN_RIGHT) { // right aligned
-					shift = max_text_width - width;
-				} else if (halign == HALIGN_CENTER) { // centered
-					shift = (max_text_width - width) / 2;
-				}
-				for (j = last_break + 1; j &lt; i; ++j) {
-					text_info.glyphs[j].pos.x += shift;
-				}
-				last_break = i - 1;
-			}
-		}
-	} else { // render_context.evt_type == EVENT_HSCROLL
-		measure_text();
-	}
-	
-	// determing text bounding box
-	compute_string_bbox(&amp;text_info, &amp;bbox);
-	
-	// determine device coordinates for text
-	
-	// x coordinate for everything except positioned events
-	if (render_context.evt_type == EVENT_NORMAL ||
-	    render_context.evt_type == EVENT_VSCROLL) {
-		device_x = x2scr(MarginL);
-	} else if (render_context.evt_type == EVENT_HSCROLL) {
-		if (render_context.scroll_direction == SCROLL_RL)
-			device_x = x2scr(frame_context.track-&gt;PlayResX - render_context.scroll_shift);
-		else if (render_context.scroll_direction == SCROLL_LR)
-			device_x = x2scr(render_context.scroll_shift) - (bbox.xMax - bbox.xMin);
-	}
+        // calculate max length of a line
+        max_text_width =
+            x2scr(render_priv,
+                  render_priv-&gt;track-&gt;PlayResX - MarginR) -
+            x2scr(render_priv, MarginL);
 
-	// y coordinate for everything except positioned events
-	if (render_context.evt_type == EVENT_NORMAL ||
-	    render_context.evt_type == EVENT_HSCROLL) {
-		if (valign == VALIGN_TOP) { // toptitle
-			device_y = y2scr_top(MarginV) + d6_to_int(text_info.lines[0].asc);
-		} else if (valign == VALIGN_CENTER) { // midtitle
-			int scr_y = y2scr(frame_context.track-&gt;PlayResY / 2);
-			device_y = scr_y - (bbox.yMax - bbox.yMin) / 2;
-		} else { // subtitle
-			int scr_y;
-			if (valign != VALIGN_SUB)
-				mp_msg(MSGT_ASS, MSGL_V, &quot;Invalid valign, supposing 0 (subtitle)\n&quot;);
-			scr_y = y2scr_sub(frame_context.track-&gt;PlayResY - MarginV);
-			device_y = scr_y;
-			device_y -= d6_to_int(text_info.height);
-			device_y += d6_to_int(text_info.lines[0].asc);
-		}
-	} else if (render_context.evt_type == EVENT_VSCROLL) {
-		if (render_context.scroll_direction == SCROLL_TB)
-			device_y = y2scr(render_context.clip_y0 + render_context.scroll_shift) - (bbox.yMax - bbox.yMin);
-		else if (render_context.scroll_direction == SCROLL_BT)
-			device_y = y2scr(render_context.clip_y1 - render_context.scroll_shift);
-	}
+        // rearrange text in several lines
+        wrap_lines_smart(render_priv, max_text_width);
 
-	// positioned events are totally different
-	if (render_context.evt_type == EVENT_POSITIONED) {
-		int base_x = 0;
-		int base_y = 0;
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;positioned event at %d, %d\n&quot;, render_context.pos_x, render_context.pos_y);
-		get_base_point(bbox, alignment, &amp;base_x, &amp;base_y);
-		device_x = x2scr(render_context.pos_x) - base_x;
-		device_y = y2scr(render_context.pos_y) - base_y;
-	}
-	
-	// fix clip coordinates (they depend on alignment)
-	render_context.clip_x0 = x2scr(render_context.clip_x0);
-	render_context.clip_x1 = x2scr(render_context.clip_x1);
-	if (render_context.evt_type == EVENT_NORMAL ||
-	    render_context.evt_type == EVENT_HSCROLL ||
-	    render_context.evt_type == EVENT_VSCROLL) {
-		if (valign == VALIGN_TOP) {
-			render_context.clip_y0 = y2scr_top(render_context.clip_y0);
-			render_context.clip_y1 = y2scr_top(render_context.clip_y1);
-		} else if (valign == VALIGN_CENTER) {
-			render_context.clip_y0 = y2scr(render_context.clip_y0);
-			render_context.clip_y1 = y2scr(render_context.clip_y1);
-		} else if (valign == VALIGN_SUB) {
-			render_context.clip_y0 = y2scr_sub(render_context.clip_y0);
-			render_context.clip_y1 = y2scr_sub(render_context.clip_y1);
-		}
-	} else if (render_context.evt_type == EVENT_POSITIONED) {
-		render_context.clip_y0 = y2scr(render_context.clip_y0);
-		render_context.clip_y1 = y2scr(render_context.clip_y1);
-	}
+        // align text
+        last_break = -1;
+        for (i = 1; i &lt; text_info-&gt;length + 1; ++i) {   // (text_info-&gt;length + 1) is the end of the last line
+            if ((i == text_info-&gt;length)
+                || glyphs[i].linebreak) {
+                double width, shift = 0;
+                GlyphInfo *first_glyph =
+                    glyphs + last_break + 1;
+                GlyphInfo *last_glyph = glyphs + i - 1;
 
-	// calculate rotation parameters
-	{
-		FT_Vector center;
-		
-		if (render_context.have_origin) {
-			center.x = x2scr(render_context.org_x);
-			center.y = y2scr(render_context.org_y);
-		} else {
-			int bx, by;
-			get_base_point(bbox, alignment, &amp;bx, &amp;by);
-			center.x = device_x + bx;
-			center.y = device_y + by;
-		}
+                while (first_glyph &lt; last_glyph &amp;&amp; first_glyph-&gt;skip)
+                    first_glyph++;
 
-		for (i = 0; i &lt; text_info.length; ++i) {
-			glyph_info_t* info = text_info.glyphs + i;
+                while ((last_glyph &gt; first_glyph)
+                       &amp;&amp; ((last_glyph-&gt;symbol == '\n')
+                           || (last_glyph-&gt;symbol == 0)
+                           || (last_glyph-&gt;skip)))
+                    last_glyph--;
 
-			if (info-&gt;hash_key.frx || info-&gt;hash_key.fry || info-&gt;hash_key.frz) {
-				info-&gt;hash_key.shift_x = info-&gt;pos.x + device_x - center.x;
-				info-&gt;hash_key.shift_y = - (info-&gt;pos.y + device_y - center.y);
-			} else {
-				info-&gt;hash_key.shift_x = 0;
-				info-&gt;hash_key.shift_y = 0;
-			}
-		}
-	}
+                width = d6_to_double(
+                    last_glyph-&gt;pos.x + last_glyph-&gt;advance.x -
+                    first_glyph-&gt;pos.x);
+                if (halign == HALIGN_LEFT) {    // left aligned, no action
+                    shift = 0;
+                } else if (halign == HALIGN_RIGHT) {    // right aligned
+                    shift = max_text_width - width;
+                } else if (halign == HALIGN_CENTER) {   // centered
+                    shift = (max_text_width - width) / 2.0;
+                }
+                for (j = last_break + 1; j &lt; i; ++j) {
+                    glyphs[j].pos.x += double_to_d6(shift);
+                }
+                last_break = i - 1;
+            }
+        }
+    } else {                    // render_priv-&gt;state.evt_type == EVENT_HSCROLL
+        measure_text(render_priv);
+    }
 
-	// convert glyphs to bitmaps
-	for (i = 0; i &lt; text_info.length; ++i)
-		get_bitmap_glyph(text_info.glyphs + i);
+    // determing text bounding box
+    compute_string_bbox(text_info, &amp;bbox);
 
-	event_images-&gt;top = device_y - d6_to_int(text_info.lines[0].asc);
-	event_images-&gt;height = d6_to_int(text_info.height);
-	event_images-&gt;detect_collisions = render_context.detect_collisions;
-	event_images-&gt;shift_direction = (valign == VALIGN_TOP) ? 1 : -1;
-	event_images-&gt;event = event;
-	event_images-&gt;imgs = render_text(&amp;text_info, device_x, device_y);
+    // determine device coordinates for text
 
-	free_render_context();
-	
-	return 0;
+    // x coordinate for everything except positioned events
+    if (render_priv-&gt;state.evt_type == EVENT_NORMAL ||
+        render_priv-&gt;state.evt_type == EVENT_VSCROLL) {
+        device_x = x2scr(render_priv, MarginL);
+    } else if (render_priv-&gt;state.evt_type == EVENT_HSCROLL) {
+        if (render_priv-&gt;state.scroll_direction == SCROLL_RL)
+            device_x =
+                x2scr(render_priv,
+                      render_priv-&gt;track-&gt;PlayResX -
+                      render_priv-&gt;state.scroll_shift);
+        else if (render_priv-&gt;state.scroll_direction == SCROLL_LR)
+            device_x =
+                x2scr(render_priv,
+                      render_priv-&gt;state.scroll_shift) - (bbox.xMax -
+                                                          bbox.xMin);
+    }
+
+    // y coordinate for everything except positioned events
+    if (render_priv-&gt;state.evt_type == EVENT_NORMAL ||
+        render_priv-&gt;state.evt_type == EVENT_HSCROLL) {
+        if (valign == VALIGN_TOP) {     // toptitle
+            device_y =
+                y2scr_top(render_priv,
+                          MarginV) + text_info-&gt;lines[0].asc;
+        } else if (valign == VALIGN_CENTER) {   // midtitle
+            double scr_y =
+                y2scr(render_priv, render_priv-&gt;track-&gt;PlayResY / 2.0);
+            device_y = scr_y - (bbox.yMax + bbox.yMin) / 2.0;
+        } else {                // subtitle
+            double scr_y;
+            if (valign != VALIGN_SUB)
+                ass_msg(render_priv-&gt;library, MSGL_V,
+                       &quot;Invalid valign, assuming 0 (subtitle)&quot;);
+            scr_y =
+                y2scr_sub(render_priv,
+                          render_priv-&gt;track-&gt;PlayResY - MarginV);
+            device_y = scr_y;
+            device_y -= text_info-&gt;height;
+            device_y += text_info-&gt;lines[0].asc;
+        }
+    } else if (render_priv-&gt;state.evt_type == EVENT_VSCROLL) {
+        if (render_priv-&gt;state.scroll_direction == SCROLL_TB)
+            device_y =
+                y2scr(render_priv,
+                      render_priv-&gt;state.clip_y0 +
+                      render_priv-&gt;state.scroll_shift) - (bbox.yMax -
+                                                          bbox.yMin);
+        else if (render_priv-&gt;state.scroll_direction == SCROLL_BT)
+            device_y =
+                y2scr(render_priv,
+                      render_priv-&gt;state.clip_y1 -
+                      render_priv-&gt;state.scroll_shift);
+    }
+
+    // positioned events are totally different
+    if (render_priv-&gt;state.evt_type == EVENT_POSITIONED) {
+        double base_x = 0;
+        double base_y = 0;
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;positioned event at %f, %f&quot;,
+               render_priv-&gt;state.pos_x, render_priv-&gt;state.pos_y);
+        get_base_point(&amp;bbox, alignment, &amp;base_x, &amp;base_y);
+        device_x =
+            x2scr_pos(render_priv, render_priv-&gt;state.pos_x) - base_x;
+        device_y =
+            y2scr_pos(render_priv, render_priv-&gt;state.pos_y) - base_y;
+    }
+
+    // fix clip coordinates (they depend on alignment)
+    if (render_priv-&gt;state.evt_type == EVENT_NORMAL ||
+        render_priv-&gt;state.evt_type == EVENT_HSCROLL ||
+        render_priv-&gt;state.evt_type == EVENT_VSCROLL) {
+        render_priv-&gt;state.clip_x0 =
+            x2scr_scaled(render_priv, render_priv-&gt;state.clip_x0);
+        render_priv-&gt;state.clip_x1 =
+            x2scr_scaled(render_priv, render_priv-&gt;state.clip_x1);
+        if (valign == VALIGN_TOP) {
+            render_priv-&gt;state.clip_y0 =
+                y2scr_top(render_priv, render_priv-&gt;state.clip_y0);
+            render_priv-&gt;state.clip_y1 =
+                y2scr_top(render_priv, render_priv-&gt;state.clip_y1);
+        } else if (valign == VALIGN_CENTER) {
+            render_priv-&gt;state.clip_y0 =
+                y2scr(render_priv, render_priv-&gt;state.clip_y0);
+            render_priv-&gt;state.clip_y1 =
+                y2scr(render_priv, render_priv-&gt;state.clip_y1);
+        } else if (valign == VALIGN_SUB) {
+            render_priv-&gt;state.clip_y0 =
+                y2scr_sub(render_priv, render_priv-&gt;state.clip_y0);
+            render_priv-&gt;state.clip_y1 =
+                y2scr_sub(render_priv, render_priv-&gt;state.clip_y1);
+        }
+    } else if (render_priv-&gt;state.evt_type == EVENT_POSITIONED) {
+        render_priv-&gt;state.clip_x0 =
+            x2scr_pos_scaled(render_priv, render_priv-&gt;state.clip_x0);
+        render_priv-&gt;state.clip_x1 =
+            x2scr_pos_scaled(render_priv, render_priv-&gt;state.clip_x1);
+        render_priv-&gt;state.clip_y0 =
+            y2scr_pos(render_priv, render_priv-&gt;state.clip_y0);
+        render_priv-&gt;state.clip_y1 =
+            y2scr_pos(render_priv, render_priv-&gt;state.clip_y1);
+    }
+
+    // calculate rotation parameters
+    {
+        DVector center;
+
+        if (render_priv-&gt;state.have_origin) {
+            center.x = x2scr(render_priv, render_priv-&gt;state.org_x);
+            center.y = y2scr(render_priv, render_priv-&gt;state.org_y);
+        } else {
+            double bx = 0., by = 0.;
+            get_base_point(&amp;bbox, alignment, &amp;bx, &amp;by);
+            center.x = device_x + bx;
+            center.y = device_y + by;
+        }
+
+        for (i = 0; i &lt; text_info-&gt;length; ++i) {
+            GlyphInfo *info = glyphs + i;
+
+            if (info-&gt;hash_key.frx || info-&gt;hash_key.fry
+                || info-&gt;hash_key.frz || info-&gt;hash_key.fax
+                || info-&gt;hash_key.fay) {
+                info-&gt;hash_key.shift_x = info-&gt;pos.x + double_to_d6(device_x - center.x);
+                info-&gt;hash_key.shift_y =
+                    -(info-&gt;pos.y + double_to_d6(device_y - center.y));
+            } else {
+                info-&gt;hash_key.shift_x = 0;
+                info-&gt;hash_key.shift_y = 0;
+            }
+        }
+    }
+
+    // convert glyphs to bitmaps
+    device_x *= render_priv-&gt;font_scale_x;
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        GlyphInfo *g = glyphs + i;
+        g-&gt;pos.x *= render_priv-&gt;font_scale_x;
+        g-&gt;hash_key.advance.x =
+            double_to_d6(device_x - (int) device_x +
+            d6_to_double(g-&gt;pos.x &amp; SUBPIXEL_MASK)) &amp; ~SUBPIXEL_ACCURACY;
+        g-&gt;hash_key.advance.y =
+            double_to_d6(device_y - (int) device_y +
+            d6_to_double(g-&gt;pos.y &amp; SUBPIXEL_MASK)) &amp; ~SUBPIXEL_ACCURACY;
+        get_bitmap_glyph(render_priv, glyphs + i);
+    }
+
+    memset(event_images, 0, sizeof(*event_images));
+    event_images-&gt;top = device_y - text_info-&gt;lines[0].asc;
+    event_images-&gt;height = text_info-&gt;height;
+    event_images-&gt;left =
+        (device_x + bbox.xMin * render_priv-&gt;font_scale_x) + 0.5;
+    event_images-&gt;width =
+        (bbox.xMax - bbox.xMin) * render_priv-&gt;font_scale_x + 0.5;
+    event_images-&gt;detect_collisions = render_priv-&gt;state.detect_collisions;
+    event_images-&gt;shift_direction = (valign == VALIGN_TOP) ? 1 : -1;
+    event_images-&gt;event = event;
+    event_images-&gt;imgs = render_text(render_priv, (int) device_x, (int) device_y);
+
+    free_render_context(render_priv);
+
+    return 0;
 }
 
 /**
  * \brief deallocate image list
  * \param img list pointer
  */
-void ass_free_images(ass_image_t* img)
+void ass_free_images(ASS_Image *img)
 {
-	while (img) {
-		ass_image_t* next = img-&gt;next;
-		free(img);
-		img = next;
-	}
+    while (img) {
+        ASS_Image *next = img-&gt;next;
+        free(img);
+        img = next;
+    }
 }
 
-static void ass_reconfigure(ass_renderer_t* priv)
+/**
+ * \brief Check cache limits and reset cache if they are exceeded
+ */
+static void check_cache_limits(ASS_Renderer *priv, CacheStore *cache)
 {
-	priv-&gt;render_id = ++last_render_id;
-	ass_glyph_cache_reset();
-	ass_bitmap_cache_reset();
-	ass_free_images(priv-&gt;prev_images_root);
-	priv-&gt;prev_images_root = 0;
-}
+    if (cache-&gt;bitmap_cache-&gt;cache_size &gt; cache-&gt;bitmap_max_size) {
+        ass_msg(priv-&gt;library, MSGL_V,
+                &quot;Hitting hard bitmap cache limit (was: %ld bytes), &quot;
+                &quot;resetting.&quot;, (long) cache-&gt;bitmap_cache-&gt;cache_size);
+        cache-&gt;bitmap_cache = ass_bitmap_cache_reset(cache-&gt;bitmap_cache);
+        cache-&gt;composite_cache = ass_composite_cache_reset(
+            cache-&gt;composite_cache);
+        ass_free_images(priv-&gt;prev_images_root);
+        priv-&gt;prev_images_root = 0;
+    }
 
-void ass_set_frame_size(ass_renderer_t* priv, int w, int h)
-{
-	if (priv-&gt;settings.frame_width != w || priv-&gt;settings.frame_height != h) {
-		priv-&gt;settings.frame_width = w;
-		priv-&gt;settings.frame_height = h;
-		if (priv-&gt;settings.aspect == 0.)
-			priv-&gt;settings.aspect = ((double)w) / h;
-		ass_reconfigure(priv);
-	}
+    if (cache-&gt;glyph_cache-&gt;count &gt; cache-&gt;glyph_max
+        || cache-&gt;glyph_cache-&gt;cache_size &gt; cache-&gt;bitmap_max_size) {
+        ass_msg(priv-&gt;library, MSGL_V,
+            &quot;Hitting hard glyph cache limit (was: %d glyphs, %ld bytes), &quot;
+            &quot;resetting.&quot;,
+            cache-&gt;glyph_cache-&gt;count, (long) cache-&gt;glyph_cache-&gt;cache_size);
+        cache-&gt;glyph_cache = ass_glyph_cache_reset(cache-&gt;glyph_cache);
+    }
 }
 
-void ass_set_margins(ass_renderer_t* priv, int t, int b, int l, int r)
+/**
+ * \brief Start a new frame
+ */
+static int
+ass_start_frame(ASS_Renderer *render_priv, ASS_Track *track,
+                long long now)
 {
-	if (priv-&gt;settings.left_margin != l ||
-	    priv-&gt;settings.right_margin != r ||
-	    priv-&gt;settings.top_margin != t ||
-	    priv-&gt;settings.bottom_margin != b) {
-		priv-&gt;settings.left_margin = l;
-		priv-&gt;settings.right_margin = r;
-		priv-&gt;settings.top_margin = t;
-		priv-&gt;settings.bottom_margin = b;
-		ass_reconfigure(priv);
-	}
-}
+    ASS_Settings *settings_priv = &amp;render_priv-&gt;settings;
 
-void ass_set_use_margins(ass_renderer_t* priv, int use)
-{
-	priv-&gt;settings.use_margins = use;
-}
+    if (!render_priv-&gt;settings.frame_width
+        &amp;&amp; !render_priv-&gt;settings.frame_height)
+        return 1;               // library not initialized
 
-void ass_set_aspect_ratio(ass_renderer_t* priv, double ar)
-{
-	if (priv-&gt;settings.aspect != ar) {
-		priv-&gt;settings.aspect = ar;
-		ass_reconfigure(priv);
-	}
-}
+    if (render_priv-&gt;library != track-&gt;library)
+        return 1;
 
-void ass_set_font_scale(ass_renderer_t* priv, double font_scale)
-{
-	if (priv-&gt;settings.font_size_coeff != font_scale) {
-		priv-&gt;settings.font_size_coeff = font_scale;
-		ass_reconfigure(priv);
-	}
-}
+    if (!render_priv-&gt;fontconfig_priv)
+        return 1;
 
-void ass_set_hinting(ass_renderer_t* priv, ass_hinting_t ht)
-{
-	if (priv-&gt;settings.hinting != ht) {
-		priv-&gt;settings.hinting = ht;
-		ass_reconfigure(priv);
-	}
-}
+    free_list_clear(render_priv);
 
-void ass_set_line_spacing(ass_renderer_t* priv, double line_spacing)
-{
-	priv-&gt;settings.line_spacing = line_spacing;
-}
+    if (track-&gt;n_events == 0)
+        return 1;               // nothing to do
 
-int ass_set_fonts(ass_renderer_t* priv, const char* default_font, const char* default_family)
-{
-	if (priv-&gt;settings.default_font)
-		free(priv-&gt;settings.default_font);
-	if (priv-&gt;settings.default_family)
-		free(priv-&gt;settings.default_family);
+    render_priv-&gt;track = track;
+    render_priv-&gt;time = now;
 
-	priv-&gt;settings.default_font = default_font ? strdup(default_font) : 0;
-	priv-&gt;settings.default_family = default_family ? strdup(default_family) : 0;
+    ass_lazy_track_init(render_priv);
 
-	if (priv-&gt;fontconfig_priv)
-		fontconfig_done(priv-&gt;fontconfig_priv);
-	priv-&gt;fontconfig_priv = fontconfig_init(priv-&gt;library, priv-&gt;ftlibrary, default_family, default_font);
+    render_priv-&gt;font_scale = settings_priv-&gt;font_size_coeff *
+        render_priv-&gt;orig_height / render_priv-&gt;track-&gt;PlayResY;
+    if (render_priv-&gt;track-&gt;ScaledBorderAndShadow)
+        render_priv-&gt;border_scale =
+            ((double) render_priv-&gt;orig_height) /
+            render_priv-&gt;track-&gt;PlayResY;
+    else
+        render_priv-&gt;border_scale = 1.;
 
-	return !!priv-&gt;fontconfig_priv;
-}
+    // PAR correction
+    render_priv-&gt;font_scale_x = render_priv-&gt;settings.aspect /
+                                render_priv-&gt;settings.storage_aspect;
 
-/**
- * \brief Start a new frame
- */
-static int ass_start_frame(ass_renderer_t *priv, ass_track_t* track, long long now)
-{
-	ass_renderer = priv;
-	global_settings = &amp;priv-&gt;settings;
+    render_priv-&gt;prev_images_root = render_priv-&gt;images_root;
+    render_priv-&gt;images_root = 0;
 
-	if (!priv-&gt;settings.frame_width &amp;&amp; !priv-&gt;settings.frame_height)
-		return 1; // library not initialized
-	
-	frame_context.ass_priv = priv;
-	frame_context.width = global_settings-&gt;frame_width;
-	frame_context.height = global_settings-&gt;frame_height;
-	frame_context.orig_width = global_settings-&gt;frame_width - global_settings-&gt;left_margin - global_settings-&gt;right_margin;
-	frame_context.orig_height = global_settings-&gt;frame_height - global_settings-&gt;top_margin - global_settings-&gt;bottom_margin;
-	frame_context.track = track;
-	frame_context.time = now;
+    check_cache_limits(render_priv, &amp;render_priv-&gt;cache);
 
-	ass_lazy_track_init();
-	
-	frame_context.font_scale = global_settings-&gt;font_size_coeff *
-	                           frame_context.orig_height / frame_context.track-&gt;PlayResY;
-	frame_context.border_scale = ((double)frame_context.orig_height) / frame_context.track-&gt;PlayResY;
-
-	if (frame_context.orig_width * track-&gt;PlayResY == frame_context.orig_height * track-&gt;PlayResX)
-		frame_context.font_scale_x = 1.;
-	else
-		frame_context.font_scale_x = ((double)(frame_context.orig_width * track-&gt;PlayResY)) / (frame_context.orig_height * track-&gt;PlayResX);
-
-	priv-&gt;prev_images_root = priv-&gt;images_root;
-	priv-&gt;images_root = 0;
-
-	return 0;
+    return 0;
 }
 
-static int cmp_event_layer(const void* p1, const void* p2)
+static int cmp_event_layer(const void *p1, const void *p2)
 {
-	ass_event_t* e1 = ((event_images_t*)p1)-&gt;event;
-	ass_event_t* e2 = ((event_images_t*)p2)-&gt;event;
-	if (e1-&gt;Layer &lt; e2-&gt;Layer)
-		return -1;
-	if (e1-&gt;Layer &gt; e2-&gt;Layer)
-		return 1;
-	if (e1-&gt;ReadOrder &lt; e2-&gt;ReadOrder)
-		return -1;
-	if (e1-&gt;ReadOrder &gt; e2-&gt;ReadOrder)
-		return 1;
-	return 0;
+    ASS_Event *e1 = ((EventImages *) p1)-&gt;event;
+    ASS_Event *e2 = ((EventImages *) p2)-&gt;event;
+    if (e1-&gt;Layer &lt; e2-&gt;Layer)
+        return -1;
+    if (e1-&gt;Layer &gt; e2-&gt;Layer)
+        return 1;
+    if (e1-&gt;ReadOrder &lt; e2-&gt;ReadOrder)
+        return -1;
+    if (e1-&gt;ReadOrder &gt; e2-&gt;ReadOrder)
+        return 1;
+    return 0;
 }
 
-#define MAX_EVENTS 100
+static ASS_RenderPriv *get_render_priv(ASS_Renderer *render_priv,
+                                       ASS_Event *event)
+{
+    if (!event-&gt;render_priv)
+        event-&gt;render_priv = calloc(1, sizeof(ASS_RenderPriv));
+    if (render_priv-&gt;render_id != event-&gt;render_priv-&gt;render_id) {
+        memset(event-&gt;render_priv, 0, sizeof(ASS_RenderPriv));
+        event-&gt;render_priv-&gt;render_id = render_priv-&gt;render_id;
+    }
 
-static render_priv_t* get_render_priv(ass_event_t* event)
-{
-	if (!event-&gt;render_priv)
-		event-&gt;render_priv = calloc(1, sizeof(render_priv_t));
-	// FIXME: check render_id
-	if (ass_renderer-&gt;render_id != event-&gt;render_priv-&gt;render_id) {
-		memset(event-&gt;render_priv, 0, sizeof(render_priv_t));
-		event-&gt;render_priv-&gt;render_id = ass_renderer-&gt;render_id;
-	}
-	return event-&gt;render_priv;
+    return event-&gt;render_priv;
 }
 
-typedef struct segment_s {
-	int a, b; // top and height
-} segment_t;
-
-static int overlap(segment_t* s1, segment_t* s2)
+static int overlap(Segment *s1, Segment *s2)
 {
-	if (s1-&gt;a &gt;= s2-&gt;b || s2-&gt;a &gt;= s1-&gt;b)
-		return 0;
-	return 1;
+    if (s1-&gt;a &gt;= s2-&gt;b || s2-&gt;a &gt;= s1-&gt;b ||
+        s1-&gt;ha &gt;= s2-&gt;hb || s2-&gt;ha &gt;= s1-&gt;hb)
+        return 0;
+    return 1;
 }
 
-static int cmp_segment(const void* p1, const void* p2)
+static int cmp_segment(const void *p1, const void *p2)
 {
-	return ((segment_t*)p1)-&gt;a - ((segment_t*)p2)-&gt;a;
+    return ((Segment *) p1)-&gt;a - ((Segment *) p2)-&gt;a;
 }
 
-static void shift_event(event_images_t* ei, int shift)
+static void
+shift_event(ASS_Renderer *render_priv, EventImages *ei, int shift)
 {
-	ass_image_t* cur = ei-&gt;imgs;
-	while (cur) {
-		cur-&gt;dst_y += shift;
-		// clip top and bottom
-		if (cur-&gt;dst_y &lt; 0) {
-			int clip = - cur-&gt;dst_y;
-			cur-&gt;h -= clip;
-			cur-&gt;bitmap += clip * cur-&gt;stride;
-			cur-&gt;dst_y = 0;
-		}
-		if (cur-&gt;dst_y + cur-&gt;h &gt;= frame_context.height) {
-			int clip = cur-&gt;dst_y + cur-&gt;h - frame_context.height;
-			cur-&gt;h -= clip;
-		}
-		if (cur-&gt;h &lt;= 0) {
-			cur-&gt;h = 0;
-			cur-&gt;dst_y = 0;
-		}
-		cur = cur-&gt;next;
-	}
-	ei-&gt;top += shift;
+    ASS_Image *cur = ei-&gt;imgs;
+    while (cur) {
+        cur-&gt;dst_y += shift;
+        // clip top and bottom
+        if (cur-&gt;dst_y &lt; 0) {
+            int clip = -cur-&gt;dst_y;
+            cur-&gt;h -= clip;
+            cur-&gt;bitmap += clip * cur-&gt;stride;
+            cur-&gt;dst_y = 0;
+        }
+        if (cur-&gt;dst_y + cur-&gt;h &gt;= render_priv-&gt;height) {
+            int clip = cur-&gt;dst_y + cur-&gt;h - render_priv-&gt;height;
+            cur-&gt;h -= clip;
+        }
+        if (cur-&gt;h &lt;= 0) {
+            cur-&gt;h = 0;
+            cur-&gt;dst_y = 0;
+        }
+        cur = cur-&gt;next;
+    }
+    ei-&gt;top += shift;
 }
 
 // dir: 1 - move down
 //      -1 - move up
-static int fit_segment(segment_t* s, segment_t* fixed, int* cnt, int dir)
+static int fit_segment(Segment *s, Segment *fixed, int *cnt, int dir)
 {
-	int i;
-	int shift = 0;
+    int i;
+    int shift = 0;
 
-	if (dir == 1) // move down
-		for (i = 0; i &lt; *cnt; ++i) {
-			if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
-				continue;
-			shift = fixed[i].b - s-&gt;a;
-		}
-	else // dir == -1, move up
-		for (i = *cnt-1; i &gt;= 0; --i) {
-			if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
-				continue;
-			shift = fixed[i].a - s-&gt;b;
-		}
+    if (dir == 1)               // move down
+        for (i = 0; i &lt; *cnt; ++i) {
+            if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b ||
+                s-&gt;hb &lt;= fixed[i].ha || s-&gt;ha &gt;= fixed[i].hb)
+                continue;
+            shift = fixed[i].b - s-&gt;a;
+    } else                      // dir == -1, move up
+        for (i = *cnt - 1; i &gt;= 0; --i) {
+            if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b ||
+                s-&gt;hb &lt;= fixed[i].ha || s-&gt;ha &gt;= fixed[i].hb)
+                continue;
+            shift = fixed[i].a - s-&gt;b;
+        }
 
-	fixed[*cnt].a = s-&gt;a + shift;
-	fixed[*cnt].b = s-&gt;b + shift;
-	(*cnt)++;
-	qsort(fixed, *cnt, sizeof(segment_t), cmp_segment);
-	
-	return shift;
+    fixed[*cnt].a = s-&gt;a + shift;
+    fixed[*cnt].b = s-&gt;b + shift;
+    fixed[*cnt].ha = s-&gt;ha;
+    fixed[*cnt].hb = s-&gt;hb;
+    (*cnt)++;
+    qsort(fixed, *cnt, sizeof(Segment), cmp_segment);
+
+    return shift;
 }
 
-static void fix_collisions(event_images_t* imgs, int cnt)
+static void
+fix_collisions(ASS_Renderer *render_priv, EventImages *imgs, int cnt)
 {
-	segment_t used[MAX_EVENTS];
-	int cnt_used = 0;
-	int i, j;
+    Segment *used = malloc(cnt * sizeof(*used));
+    int cnt_used = 0;
+    int i, j;
 
-	// fill used[] with fixed events
-	for (i = 0; i &lt; cnt; ++i) {
-		render_priv_t* priv;
-		if (!imgs[i].detect_collisions) continue;
-		priv = get_render_priv(imgs[i].event);
-		if (priv-&gt;height &gt; 0) { // it's a fixed event
-			segment_t s;
-			s.a = priv-&gt;top;
-			s.b = priv-&gt;top + priv-&gt;height;
-			if (priv-&gt;height != imgs[i].height) { // no, it's not
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EventHeightHasChanged);
-				priv-&gt;top = 0;
-				priv-&gt;height = 0;
-			}
-			for (j = 0; j &lt; cnt_used; ++j)
-				if (overlap(&amp;s, used + j)) { // no, it's not
-					priv-&gt;top = 0;
-					priv-&gt;height = 0;
-				}
-			if (priv-&gt;height &gt; 0) { // still a fixed event
-				used[cnt_used].a = priv-&gt;top;
-				used[cnt_used].b = priv-&gt;top + priv-&gt;height;
-				cnt_used ++;
-				shift_event(imgs + i, priv-&gt;top - imgs[i].top);
-			}
-		}
-	}
-	qsort(used, cnt_used, sizeof(segment_t), cmp_segment);
+    // fill used[] with fixed events
+    for (i = 0; i &lt; cnt; ++i) {
+        ASS_RenderPriv *priv;
+        if (!imgs[i].detect_collisions)
+            continue;
+        priv = get_render_priv(render_priv, imgs[i].event);
+        if (priv-&gt;height &gt; 0) { // it's a fixed event
+            Segment s;
+            s.a = priv-&gt;top;
+            s.b = priv-&gt;top + priv-&gt;height;
+            s.ha = priv-&gt;left;
+            s.hb = priv-&gt;left + priv-&gt;width;
+            if (priv-&gt;height != imgs[i].height) {       // no, it's not
+                ass_msg(render_priv-&gt;library, MSGL_WARN,
+                        &quot;Event height has changed&quot;);
+                priv-&gt;top = 0;
+                priv-&gt;height = 0;
+                priv-&gt;left = 0;
+                priv-&gt;width = 0;
+            }
+            for (j = 0; j &lt; cnt_used; ++j)
+                if (overlap(&amp;s, used + j)) {    // no, it's not
+                    priv-&gt;top = 0;
+                    priv-&gt;height = 0;
+                    priv-&gt;left = 0;
+                    priv-&gt;width = 0;
+                }
+            if (priv-&gt;height &gt; 0) {     // still a fixed event
+                used[cnt_used].a = priv-&gt;top;
+                used[cnt_used].b = priv-&gt;top + priv-&gt;height;
+                used[cnt_used].ha = priv-&gt;left;
+                used[cnt_used].hb = priv-&gt;left + priv-&gt;width;
+                cnt_used++;
+                shift_event(render_priv, imgs + i, priv-&gt;top - imgs[i].top);
+            }
+        }
+    }
+    qsort(used, cnt_used, sizeof(Segment), cmp_segment);
 
-	// try to fit other events in free spaces
-	for (i = 0; i &lt; cnt; ++i) {
-		render_priv_t* priv;
-		if (!imgs[i].detect_collisions) continue;
-		priv = get_render_priv(imgs[i].event);
-		if (priv-&gt;height == 0) { // not a fixed event
-			int shift;
-			segment_t s;
-			s.a = imgs[i].top;
-			s.b = imgs[i].top + imgs[i].height;
-			shift = fit_segment(&amp;s, used, &amp;cnt_used, imgs[i].shift_direction);
-			if (shift) shift_event(imgs + i, shift);
-			// make it fixed
-			priv-&gt;top = imgs[i].top;
-			priv-&gt;height = imgs[i].height;
-		}
-		
-	}
+    // try to fit other events in free spaces
+    for (i = 0; i &lt; cnt; ++i) {
+        ASS_RenderPriv *priv;
+        if (!imgs[i].detect_collisions)
+            continue;
+        priv = get_render_priv(render_priv, imgs[i].event);
+        if (priv-&gt;height == 0) {        // not a fixed event
+            int shift;
+            Segment s;
+            s.a = imgs[i].top;
+            s.b = imgs[i].top + imgs[i].height;
+            s.ha = imgs[i].left;
+            s.hb = imgs[i].left + imgs[i].width;
+            shift = fit_segment(&amp;s, used, &amp;cnt_used, imgs[i].shift_direction);
+            if (shift)
+                shift_event(render_priv, imgs + i, shift);
+            // make it fixed
+            priv-&gt;top = imgs[i].top;
+            priv-&gt;height = imgs[i].height;
+            priv-&gt;left = imgs[i].left;
+            priv-&gt;width = imgs[i].width;
+        }
+
+    }
+
+    free(used);
 }
 
 /**
@@ -2280,17 +2411,23 @@
  * \param i2 second image
  * \return 0 if identical, 1 if different positions, 2 if different content
  */
-int ass_image_compare(ass_image_t *i1, ass_image_t *i2)
+static int ass_image_compare(ASS_Image *i1, ASS_Image *i2)
 {
-	if (i1-&gt;w != i2-&gt;w) return 2;
-	if (i1-&gt;h != i2-&gt;h) return 2;
-	if (i1-&gt;stride != i2-&gt;stride) return 2;
-	if (i1-&gt;color != i2-&gt;color) return 2;
-	if (i1-&gt;bitmap != i2-&gt;bitmap)
-		return 2;
-	if (i1-&gt;dst_x != i2-&gt;dst_x) return 1;
-	if (i1-&gt;dst_y != i2-&gt;dst_y) return 1;
-	return 0;
+    if (i1-&gt;w != i2-&gt;w)
+        return 2;
+    if (i1-&gt;h != i2-&gt;h)
+        return 2;
+    if (i1-&gt;stride != i2-&gt;stride)
+        return 2;
+    if (i1-&gt;color != i2-&gt;color)
+        return 2;
+    if (i1-&gt;bitmap != i2-&gt;bitmap)
+        return 2;
+    if (i1-&gt;dst_x != i2-&gt;dst_x)
+        return 1;
+    if (i1-&gt;dst_y != i2-&gt;dst_y)
+        return 1;
+    return 0;
 }
 
 /**
@@ -2298,35 +2435,36 @@
  * \param priv library handle
  * \return 0 if identical, 1 if different positions, 2 if different content
  */
-int ass_detect_change(ass_renderer_t *priv)
+static int ass_detect_change(ASS_Renderer *priv)
 {
-	ass_image_t* img, *img2;
-	int diff;
+    ASS_Image *img, *img2;
+    int diff;
 
-	img = priv-&gt;prev_images_root;
-	img2 = priv-&gt;images_root;
-	diff = 0;
-	while (img &amp;&amp; diff &lt; 2) {
-		ass_image_t* next, *next2;
-		next = img-&gt;next;
-		if (img2) {
-			int d = ass_image_compare(img, img2);
-			if (d &gt; diff) diff = d;
-			next2 = img2-&gt;next;
-		} else {
-			// previous list is shorter
-			diff = 2;
-			break;
-		}
-		img = next;
-		img2 = next2;
-	}
+    img = priv-&gt;prev_images_root;
+    img2 = priv-&gt;images_root;
+    diff = 0;
+    while (img &amp;&amp; diff &lt; 2) {
+        ASS_Image *next, *next2;
+        next = img-&gt;next;
+        if (img2) {
+            int d = ass_image_compare(img, img2);
+            if (d &gt; diff)
+                diff = d;
+            next2 = img2-&gt;next;
+        } else {
+            // previous list is shorter
+            diff = 2;
+            break;
+        }
+        img = next;
+        img2 = next2;
+    }
 
-	// is the previous list longer?
-	if (img2)
-		diff = 2;
+    // is the previous list longer?
+    if (img2)
+        diff = 2;
 
-	return diff;
+    return diff;
 }
 
 /**
@@ -2338,62 +2476,66 @@
  *        0 if identical, 1 if different positions, 2 if different content.
  *        Can be NULL, in that case no detection is performed.
  */
-ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now, int* detect_change)
+ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
+                            long long now, int *detect_change)
 {
-	int i, cnt, rc;
-	event_images_t* last;
-	ass_image_t** tail;
-	
-	// init frame
-	rc = ass_start_frame(priv, track, now);
-	if (rc != 0)
-		return 0;
+    int i, cnt, rc;
+    EventImages *last;
+    ASS_Image **tail;
 
-	// render events separately
-	cnt = 0;
-	for (i = 0; i &lt; track-&gt;n_events; ++i) {
-		ass_event_t* event = track-&gt;events + i;
-		if ( (event-&gt;Start &lt;= now) &amp;&amp; (now &lt; (event-&gt;Start + event-&gt;Duration)) ) {
-			if (cnt &gt;= priv-&gt;eimg_size) {
-				priv-&gt;eimg_size += 100;
-				priv-&gt;eimg = realloc(priv-&gt;eimg, priv-&gt;eimg_size * sizeof(event_images_t));
-			}
-			rc = ass_render_event(event, priv-&gt;eimg + cnt);
-			if (!rc) ++cnt;
-		}
-	}
+    // init frame
+    rc = ass_start_frame(priv, track, now);
+    if (rc != 0)
+        return 0;
 
-	// sort by layer
-	qsort(priv-&gt;eimg, cnt, sizeof(event_images_t), cmp_event_layer);
+    // render events separately
+    cnt = 0;
+    for (i = 0; i &lt; track-&gt;n_events; ++i) {
+        ASS_Event *event = track-&gt;events + i;
+        if ((event-&gt;Start &lt;= now)
+            &amp;&amp; (now &lt; (event-&gt;Start + event-&gt;Duration))) {
+            if (cnt &gt;= priv-&gt;eimg_size) {
+                priv-&gt;eimg_size += 100;
+                priv-&gt;eimg =
+                    realloc(priv-&gt;eimg,
+                            priv-&gt;eimg_size * sizeof(EventImages));
+            }
+            rc = ass_render_event(priv, event, priv-&gt;eimg + cnt);
+            if (!rc)
+                ++cnt;
+        }
+    }
 
-	// call fix_collisions for each group of events with the same layer
-	last = priv-&gt;eimg;
-	for (i = 1; i &lt; cnt; ++i)
-		if (last-&gt;event-&gt;Layer != priv-&gt;eimg[i].event-&gt;Layer) {
-			fix_collisions(last, priv-&gt;eimg + i - last);
-			last = priv-&gt;eimg + i;
-		}
-	if (cnt &gt; 0)
-		fix_collisions(last, priv-&gt;eimg + cnt - last);
+    // sort by layer
+    qsort(priv-&gt;eimg, cnt, sizeof(EventImages), cmp_event_layer);
 
-	// concat lists
-	tail = &amp;ass_renderer-&gt;images_root;
-	for (i = 0; i &lt; cnt; ++i) {
-		ass_image_t* cur = priv-&gt;eimg[i].imgs;
-		while (cur) {
-			*tail = cur;
-			tail = &amp;cur-&gt;next;
-			cur = cur-&gt;next;
-		}
-	}
+    // call fix_collisions for each group of events with the same layer
+    last = priv-&gt;eimg;
+    for (i = 1; i &lt; cnt; ++i)
+        if (last-&gt;event-&gt;Layer != priv-&gt;eimg[i].event-&gt;Layer) {
+            fix_collisions(priv, last, priv-&gt;eimg + i - last);
+            last = priv-&gt;eimg + i;
+        }
+    if (cnt &gt; 0)
+        fix_collisions(priv, last, priv-&gt;eimg + cnt - last);
 
-	if (detect_change)
-		*detect_change = ass_detect_change(priv);
-	
-	// free the previous image list
-	ass_free_images(priv-&gt;prev_images_root);
-	priv-&gt;prev_images_root = 0;
+    // concat lists
+    tail = &amp;priv-&gt;images_root;
+    for (i = 0; i &lt; cnt; ++i) {
+        ASS_Image *cur = priv-&gt;eimg[i].imgs;
+        while (cur) {
+            *tail = cur;
+            tail = &amp;cur-&gt;next;
+            cur = cur-&gt;next;
+        }
+    }
 
-	return ass_renderer-&gt;images_root;
+    if (detect_change)
+        *detect_change = ass_detect_change(priv);
+
+    // free the previous image list
+    ass_free_images(priv-&gt;prev_images_root);
+    priv-&gt;prev_images_root = 0;
+
+    return priv-&gt;images_root;
 }
-

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2009 Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at geekmind.org</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_RENDER_H
+#define LIBASS_RENDER_H
+
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+#include FT_STROKER_H
+#include FT_GLYPH_H
+#include FT_SYNTHESIS_H
+
+#include &quot;ass.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_bitmap.h&quot;
+#include &quot;ass_cache.h&quot;
+#include &quot;ass_utils.h&quot;
+#include &quot;ass_fontconfig.h&quot;
+#include &quot;ass_library.h&quot;
+#include &quot;ass_drawing.h&quot;
+
+#define GLYPH_CACHE_MAX 1000
+#define BITMAP_CACHE_MAX_SIZE 30 * 1048576
+
+typedef struct {
+    double xMin;
+    double xMax;
+    double yMin;
+    double yMax;
+} DBBox;
+
+typedef struct {
+    double x;
+    double y;
+} DVector;
+
+typedef struct free_list {
+    void *object;
+    struct free_list *next;
+} FreeList;
+
+typedef struct {
+    int frame_width;
+    int frame_height;
+    double font_size_coeff;     // font size multiplier
+    double line_spacing;        // additional line spacing (in frame pixels)
+    int top_margin;             // height of top margin. Everything except toptitles is shifted down by top_margin.
+    int bottom_margin;          // height of bottom margin. (frame_height - top_margin - bottom_margin) is original video height.
+    int left_margin;
+    int right_margin;
+    int use_margins;            // 0 - place all subtitles inside original frame
+    // 1 - use margins for placing toptitles and subtitles
+    double aspect;              // frame aspect ratio, d_width / d_height.
+    double storage_aspect;      // pixel ratio of the source image
+    ASS_Hinting hinting;
+
+    char *default_font;
+    char *default_family;
+} ASS_Settings;
+
+// a rendered event
+typedef struct {
+    ASS_Image *imgs;
+    int top, height, left, width;
+    int detect_collisions;
+    int shift_direction;
+    ASS_Event *event;
+} EventImages;
+
+typedef enum {
+    EF_NONE = 0,
+    EF_KARAOKE,
+    EF_KARAOKE_KF,
+    EF_KARAOKE_KO
+} Effect;
+
+// describes a glyph
+// GlyphInfo and TextInfo are used for text centering and word-wrapping operations
+typedef struct {
+    unsigned symbol;
+    unsigned skip;              // skip glyph when layouting text
+    FT_Glyph glyph;
+    FT_Glyph outline_glyph;
+    Bitmap *bm;                 // glyph bitmap
+    Bitmap *bm_o;               // outline bitmap
+    Bitmap *bm_s;               // shadow bitmap
+    FT_BBox bbox;
+    FT_Vector pos;
+    char linebreak;             // the first (leading) glyph of some line ?
+    uint32_t c[4];              // colors
+    FT_Vector advance;          // 26.6
+    Effect effect_type;
+    int effect_timing;          // time duration of current karaoke word
+    // after process_karaoke_effects: distance in pixels from the glyph origin.
+    // part of the glyph to the left of it is displayed in a different color.
+    int effect_skip_timing;     // delay after the end of last karaoke word
+    int asc, desc;              // font max ascender and descender
+    int be;                     // blur edges
+    double blur;                // gaussian blur
+    double shadow_x;
+    double shadow_y;
+    double frx, fry, frz;       // rotation
+    double fax, fay;            // text shearing
+
+    BitmapHashKey hash_key;
+} GlyphInfo;
+
+typedef struct {
+    double asc, desc;
+} LineInfo;
+
+typedef struct {
+    GlyphInfo *glyphs;
+    int length;
+    LineInfo *lines;
+    int n_lines;
+    double height;
+    int max_glyphs;
+    int max_lines;
+} TextInfo;
+
+// Renderer state.
+// Values like current font face, color, screen position, clipping and so on are stored here.
+typedef struct {
+    ASS_Event *event;
+    ASS_Style *style;
+
+    ASS_Font *font;
+    char *font_path;
+    double font_size;
+    int flags;                  // decoration flags (underline/strike-through)
+
+    FT_Stroker stroker;
+    int alignment;              // alignment overrides go here; if zero, style value will be used
+    double frx, fry, frz;
+    double fax, fay;            // text shearing
+    enum {
+        EVENT_NORMAL,           // &quot;normal&quot; top-, sub- or mid- title
+        EVENT_POSITIONED,       // happens after pos(,), margins are ignored
+        EVENT_HSCROLL,          // &quot;Banner&quot; transition effect, text_width is unlimited
+        EVENT_VSCROLL           // &quot;Scroll up&quot;, &quot;Scroll down&quot; transition effects
+    } evt_type;
+    double pos_x, pos_y;        // position
+    double org_x, org_y;        // origin
+    char have_origin;           // origin is explicitly defined; if 0, get_base_point() is used
+    double scale_x, scale_y;
+    double hspacing;            // distance between letters, in pixels
+    double border_x;            // outline width
+    double border_y;
+    uint32_t c[4];              // colors(Primary, Secondary, so on) in RGBA
+    int clip_x0, clip_y0, clip_x1, clip_y1;
+    char clip_mode;             // 1 = iclip
+    char detect_collisions;
+    uint32_t fade;              // alpha from \fad
+    char be;                    // blur edges
+    double blur;                // gaussian blur
+    double shadow_x;
+    double shadow_y;
+    int drawing_mode;           // not implemented; when != 0 text is discarded, except for style override tags
+    ASS_Drawing *drawing;       // current drawing
+    ASS_Drawing *clip_drawing;  // clip vector
+    int clip_drawing_mode;      // 0 = regular clip, 1 = inverse clip
+
+    Effect effect_type;
+    int effect_timing;
+    int effect_skip_timing;
+
+    enum {
+        SCROLL_LR,              // left-to-right
+        SCROLL_RL,
+        SCROLL_TB,              // top-to-bottom
+        SCROLL_BT
+    } scroll_direction;         // for EVENT_HSCROLL, EVENT_VSCROLL
+    int scroll_shift;
+
+    // face properties
+    char *family;
+    unsigned bold;
+    unsigned italic;
+    int treat_family_as_pattern;
+    int wrap_style;
+} RenderContext;
+
+typedef struct {
+    Hashmap *font_cache;
+    Hashmap *glyph_cache;
+    Hashmap *bitmap_cache;
+    Hashmap *composite_cache;
+    size_t glyph_max;
+    size_t bitmap_max_size;
+} CacheStore;
+
+struct ass_renderer {
+    ASS_Library *library;
+    FT_Library ftlibrary;
+    FCInstance *fontconfig_priv;
+    ASS_Settings settings;
+    int render_id;
+    ASS_SynthPriv *synth_priv;
+
+    ASS_Image *images_root;     // rendering result is stored here
+    ASS_Image *prev_images_root;
+
+    EventImages *eimg;          // temporary buffer for sorting rendered events
+    int eimg_size;              // allocated buffer size
+
+    // frame-global data
+    int width, height;          // screen dimensions
+    int orig_height;            // frame height ( = screen height - margins )
+    int orig_width;             // frame width ( = screen width - margins )
+    int orig_height_nocrop;     // frame height ( = screen height - margins + cropheight)
+    int orig_width_nocrop;      // frame width ( = screen width - margins + cropwidth)
+    ASS_Track *track;
+    long long time;             // frame's timestamp, ms
+    double font_scale;
+    double font_scale_x;        // x scale applied to all glyphs to preserve text aspect ratio
+    double border_scale;
+
+    RenderContext state;
+    TextInfo text_info;
+    CacheStore cache;
+
+    FreeList *free_head;
+    FreeList *free_tail;
+};
+
+typedef struct render_priv {
+    int top, height, left, width;
+    int render_id;
+} RenderPriv;
+
+typedef struct {
+    int x0;
+    int y0;
+    int x1;
+    int y1;
+} Rect;
+
+typedef struct {
+    int a, b;                   // top and height
+    int ha, hb;                 // left and width
+} Segment;
+
+void reset_render_context(ASS_Renderer *render_priv);
+void ass_free_images(ASS_Image *img);
+
+#endif /* LIBASS_RENDER_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render_api.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render_api.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render_api.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2010 Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at geekmind.org</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include &quot;ADM_coreConfig.h&quot;
+#include &quot;ass_render.h&quot;
+
+static void ass_reconfigure(ASS_Renderer *priv)
+{
+    ASS_Settings *settings = &amp;priv-&gt;settings;
+
+    priv-&gt;render_id++;
+    priv-&gt;cache.glyph_cache =
+        ass_glyph_cache_reset(priv-&gt;cache.glyph_cache);
+    priv-&gt;cache.bitmap_cache =
+        ass_bitmap_cache_reset(priv-&gt;cache.bitmap_cache);
+    priv-&gt;cache.composite_cache =
+        ass_composite_cache_reset(priv-&gt;cache.composite_cache);
+    ass_free_images(priv-&gt;prev_images_root);
+    priv-&gt;prev_images_root = 0;
+
+    priv-&gt;width = settings-&gt;frame_width;
+    priv-&gt;height = settings-&gt;frame_height;
+    priv-&gt;orig_width = settings-&gt;frame_width - settings-&gt;left_margin -
+        settings-&gt;right_margin;
+    priv-&gt;orig_height = settings-&gt;frame_height - settings-&gt;top_margin -
+        settings-&gt;bottom_margin;
+    priv-&gt;orig_width_nocrop =
+        settings-&gt;frame_width - FFMAX(settings-&gt;left_margin, 0) -
+        FFMAX(settings-&gt;right_margin, 0);
+    priv-&gt;orig_height_nocrop =
+        settings-&gt;frame_height - FFMAX(settings-&gt;top_margin, 0) -
+        FFMAX(settings-&gt;bottom_margin, 0);
+}
+
+void ass_set_frame_size(ASS_Renderer *priv, int w, int h)
+{
+    if (priv-&gt;settings.frame_width != w || priv-&gt;settings.frame_height != h) {
+        priv-&gt;settings.frame_width = w;
+        priv-&gt;settings.frame_height = h;
+        if (priv-&gt;settings.aspect == 0.) {
+            priv-&gt;settings.aspect = ((double) w) / h;
+            priv-&gt;settings.storage_aspect = ((double) w) / h;
+        }
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_margins(ASS_Renderer *priv, int t, int b, int l, int r)
+{
+    if (priv-&gt;settings.left_margin != l || priv-&gt;settings.right_margin != r ||
+        priv-&gt;settings.top_margin != t || priv-&gt;settings.bottom_margin != b) {
+        priv-&gt;settings.left_margin = l;
+        priv-&gt;settings.right_margin = r;
+        priv-&gt;settings.top_margin = t;
+        priv-&gt;settings.bottom_margin = b;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_use_margins(ASS_Renderer *priv, int use)
+{
+    priv-&gt;settings.use_margins = use;
+}
+
+void ass_set_aspect_ratio(ASS_Renderer *priv, double dar, double sar)
+{
+    if (priv-&gt;settings.aspect != dar || priv-&gt;settings.storage_aspect != sar) {
+        priv-&gt;settings.aspect = dar;
+        priv-&gt;settings.storage_aspect = sar;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_font_scale(ASS_Renderer *priv, double font_scale)
+{
+    if (priv-&gt;settings.font_size_coeff != font_scale) {
+        priv-&gt;settings.font_size_coeff = font_scale;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_hinting(ASS_Renderer *priv, ASS_Hinting ht)
+{
+    if (priv-&gt;settings.hinting != ht) {
+        priv-&gt;settings.hinting = ht;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_line_spacing(ASS_Renderer *priv, double line_spacing)
+{
+    priv-&gt;settings.line_spacing = line_spacing;
+}
+
+void ass_set_fonts(ASS_Renderer *priv, const char *default_font,
+                   const char *default_family, int fc, const char *config,
+                   int update)
+{
+    free(priv-&gt;settings.default_font);
+    free(priv-&gt;settings.default_family);
+    priv-&gt;settings.default_font = default_font ? strdup(default_font) : 0;
+    priv-&gt;settings.default_family =
+        default_family ? strdup(default_family) : 0;
+
+    if (priv-&gt;fontconfig_priv)
+        fontconfig_done(priv-&gt;fontconfig_priv);
+    priv-&gt;fontconfig_priv =
+        fontconfig_init(priv-&gt;library, priv-&gt;ftlibrary, default_family,
+                        default_font, fc, config, update);
+}
+
+int ass_fonts_update(ASS_Renderer *render_priv)
+{
+    return fontconfig_update(render_priv-&gt;fontconfig_priv);
+}
+
+void ass_set_cache_limits(ASS_Renderer *render_priv, int glyph_max,
+                          int bitmap_max)
+{
+    render_priv-&gt;cache.glyph_max = glyph_max ? glyph_max : GLYPH_CACHE_MAX;
+    render_priv-&gt;cache.bitmap_max_size = bitmap_max ? 1048576 * bitmap_max :
+                                         BITMAP_CACHE_MAX_SIZE;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_strtod.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_strtod.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_strtod.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -0,0 +1,249 @@
+/*
+ * Copyright (c) 1988-1993 The Regents of the University of California.
+ * Copyright (c) 1994 Sun Microsystems, Inc.
+ *
+ * Permission to use, copy, modify, and distribute this
+ * software and its documentation for any purpose and without
+ * fee is hereby granted, provided that the above copyright
+ * notice appear in all copies.  The University of California
+ * makes no representations about the suitability of this
+ * software for any purpose.  It is provided &quot;as is&quot; without
+ * express or implied warranty.
+ *
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;errno.h&gt;
+
+const
+static int maxExponent = 511;   /* Largest possible base 10 exponent.  Any
+                                 * exponent larger than this will already
+                                 * produce underflow or overflow, so there's
+                                 * no need to worry about additional digits.
+                                 */
+
+const
+static double powersOf10[] = {  /* Table giving binary powers of 10.  Entry */
+    10.,                        /* is 10^2^i.  Used to convert decimal */
+    100.,                       /* exponents into floating-point numbers. */
+    1.0e4,
+    1.0e8,
+    1.0e16,
+    1.0e32,
+    1.0e64,
+    1.0e128,
+    1.0e256
+};
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * strtod --
+ *
+ * This procedure converts a floating-point number from an ASCII
+ * decimal representation to internal double-precision format.
+ *
+ * Results:
+ * The return value is the double-precision floating-point
+ * representation of the characters in string.  If endPtr isn't
+ * NULL, then *endPtr is filled in with the address of the
+ * next character after the last one that was part of the
+ * floating-point number.
+ *
+ * Side effects:
+ * None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+double
+ass_strtod(string, endPtr)
+    const char *string;     /* A decimal ASCII floating-point number,
+                             * optionally preceded by white space.
+                             * Must have form &quot;-I.FE-X&quot;, where I is the
+                             * integer part of the mantissa, F is the
+                             * fractional part of the mantissa, and X
+                             * is the exponent.  Either of the signs
+                             * may be &quot;+&quot;, &quot;-&quot;, or omitted.  Either I
+                             * or F may be omitted, or both.  The decimal
+                             * point isn't necessary unless F is present.
+                             * The &quot;E&quot; may actually be an &quot;e&quot;.  E and X
+                             * may both be omitted (but not just one).
+                             */
+    char **endPtr;          /* If non-NULL, store terminating character's
+                             * address here. */
+{
+    int sign, expSign = 0;
+    double fraction, dblExp, *d;
+    register const char *p;
+    register int c;
+    int exp = 0;            /* Exponent read from &quot;EX&quot; field. */
+    int fracExp = 0;        /* Exponent that derives from the fractional
+                             * part.  Under normal circumstatnces, it is
+                             * the negative of the number of digits in F.
+                             * However, if I is very long, the last digits
+                             * of I get dropped (otherwise a long I with a
+                             * large negative exponent could cause an
+                             * unnecessary overflow on I alone).  In this
+                             * case, fracExp is incremented one for each
+                             * dropped digit. */
+    int mantSize;       /* Number of digits in mantissa. */
+    int decPt;          /* Number of mantissa digits BEFORE decimal
+                         * point. */
+    const char *pExp;       /* Temporarily holds location of exponent
+                             * in string. */
+
+    /*
+     * Strip off leading blanks and check for a sign.
+     */
+
+    p = string;
+    while (isspace(*p)) {
+        p += 1;
+    }
+    if (*p == '-') {
+        sign = 1;
+        p += 1;
+    } else {
+        if (*p == '+') {
+            p += 1;
+        }
+        sign = 0;
+    }
+
+    /*
+     * Count the number of digits in the mantissa (including the decimal
+     * point), and also locate the decimal point.
+     */
+
+    decPt = -1;
+    for (mantSize = 0; ; mantSize += 1)
+    {
+        c = *p;
+        if (!isdigit(c)) {
+            if ((c != '.') || (decPt &gt;= 0)) {
+                break;
+            }
+            decPt = mantSize;
+        }
+        p += 1;
+    }
+
+    /*
+     * Now suck up the digits in the mantissa.  Use two integers to
+     * collect 9 digits each (this is faster than using floating-point).
+     * If the mantissa has more than 18 digits, ignore the extras, since
+     * they can't affect the value anyway.
+     */
+
+    pExp  = p;
+    p -= mantSize;
+    if (decPt &lt; 0) {
+        decPt = mantSize;
+    } else {
+        mantSize -= 1;      /* One of the digits was the point. */
+    }
+    if (mantSize &gt; 18) {
+        fracExp = decPt - 18;
+        mantSize = 18;
+    } else {
+        fracExp = decPt - mantSize;
+    }
+    if (mantSize == 0) {
+        fraction = 0.0;
+        p = string;
+        goto done;
+    } else {
+        int frac1, frac2;
+        frac1 = 0;
+        for ( ; mantSize &gt; 9; mantSize -= 1)
+        {
+            c = *p;
+            p += 1;
+            if (c == '.') {
+                c = *p;
+                p += 1;
+            }
+            frac1 = 10*frac1 + (c - '0');
+        }
+        frac2 = 0;
+        for (; mantSize &gt; 0; mantSize -= 1)
+        {
+            c = *p;
+            p += 1;
+            if (c == '.') {
+                c = *p;
+                p += 1;
+            }
+            frac2 = 10*frac2 + (c - '0');
+        }
+        fraction = (1.0e9 * frac1) + frac2;
+    }
+
+    /*
+     * Skim off the exponent.
+     */
+
+    p = pExp;
+    if ((*p == 'E') || (*p == 'e')) {
+        p += 1;
+        if (*p == '-') {
+            expSign = 1;
+            p += 1;
+        } else {
+            if (*p == '+') {
+                p += 1;
+            }
+            expSign = 0;
+        }
+        while (isdigit(*p)) {
+            exp = exp * 10 + (*p - '0');
+            p += 1;
+        }
+    }
+    if (expSign) {
+        exp = fracExp - exp;
+    } else {
+        exp = fracExp + exp;
+    }
+
+    /*
+     * Generate a floating-point number that represents the exponent.
+     * Do this by processing the exponent one bit at a time to combine
+     * many powers of 2 of 10. Then combine the exponent with the
+     * fraction.
+     */
+
+    if (exp &lt; 0) {
+        expSign = 1;
+        exp = -exp;
+    } else {
+        expSign = 0;
+    }
+    if (exp &gt; maxExponent) {
+        exp = maxExponent;
+        errno = ERANGE;
+    }
+    dblExp = 1.0;
+    for (d = (double *) powersOf10; exp != 0; exp &gt;&gt;= 1, d += 1) {
+        if (exp &amp; 01) {
+            dblExp *= *d;
+        }
+    }
+    if (expSign) {
+        fraction /= dblExp;
+    } else {
+        fraction *= dblExp;
+    }
+
+done:
+    if (endPtr != NULL) {
+        *endPtr = (char *) p;
+    }
+
+    if (sign) {
+        return -fraction;
+    }
+    return fraction;
+}

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_types.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_types.h	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_types.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,26 +1,28 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#ifndef LIBASS_TYPES_H
+#define LIBASS_TYPES_H
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
+#include &lt;stdint.h&gt;
 
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_TYPES_H
-#define ASS_TYPES_H
-
 #define VALIGN_SUB 0
 #define VALIGN_CENTER 8
 #define VALIGN_TOP 4
@@ -28,87 +30,96 @@
 #define HALIGN_CENTER 2
 #define HALIGN_RIGHT 3
 
-/// ass Style: line
-typedef struct ass_style_s {
-	char* Name;
-	char* FontName;
-	double FontSize;
-	uint32_t PrimaryColour;
-	uint32_t SecondaryColour;
-	uint32_t OutlineColour;
-	uint32_t BackColour;
-	int Bold;
-	int Italic;
-	int Underline;
-	int StrikeOut;
-	double ScaleX;
-	double ScaleY;
-	double Spacing;
-	int Angle;
-	int BorderStyle;
-	double Outline;
-	double Shadow;
-	int Alignment;
-	int MarginL;
-	int MarginR;
-	int MarginV;
-//        int AlphaLevel;
-	int Encoding;
-} ass_style_t;
+/* Opaque objects internally used by libass.  Contents are private. */
+typedef struct ass_renderer ASS_Renderer;
+typedef struct render_priv ASS_RenderPriv;
+typedef struct parser_priv ASS_ParserPriv;
+typedef struct ass_library ASS_Library;
 
-typedef struct render_priv_s render_priv_t;
+/* ASS Style: line */
+typedef struct ass_style {
+    char *Name;
+    char *FontName;
+    double FontSize;
+    uint32_t PrimaryColour;
+    uint32_t SecondaryColour;
+    uint32_t OutlineColour;
+    uint32_t BackColour;
+    int Bold;
+    int Italic;
+    int Underline;
+    int StrikeOut;
+    double ScaleX;
+    double ScaleY;
+    double Spacing;
+    int Angle;
+    int BorderStyle;
+    double Outline;
+    double Shadow;
+    int Alignment;
+    int MarginL;
+    int MarginR;
+    int MarginV;
+    int Encoding;
+    int treat_fontname_as_pattern;
+} ASS_Style;
 
-/// ass_event_t corresponds to a single Dialogue line
-/// Text is stored as-is, style overrides will be parsed later
-typedef struct ass_event_s {
-	long long Start; // ms
-	long long Duration; // ms
+/*
+ * ASS_Event corresponds to a single Dialogue line;
+ * text is stored as-is, style overrides will be parsed later.
+ */
+typedef struct ass_event {
+    long long Start;            // ms
+    long long Duration;         // ms
 
-	int ReadOrder;
-	int Layer;
-	int Style;
-	char* Name;
-	int MarginL;
-	int MarginR;
-	int MarginV;
-	char* Effect;
-	char* Text;
+    int ReadOrder;
+    int Layer;
+    int Style;
+    char *Name;
+    int MarginL;
+    int MarginR;
+    int MarginV;
+    char *Effect;
+    char *Text;
 
-	render_priv_t* render_priv;
-} ass_event_t;
+    ASS_RenderPriv *render_priv;
+} ASS_Event;
 
-typedef struct parser_priv_s parser_priv_t;
+/*
+ * ass track represent either an external script or a matroska subtitle stream
+ * (no real difference between them); it can be used in rendering after the
+ * headers are parsed (i.e. events format line read).
+ */
+typedef struct ass_track {
+    int n_styles;           // amount used
+    int max_styles;         // amount allocated
+    int n_events;
+    int max_events;
+    ASS_Style *styles;    // array of styles, max_styles length, n_styles used
+    ASS_Event *events;    // the same as styles
 
-typedef struct ass_library_s ass_library_t;
+    char *style_format;     // style format line (everything after &quot;Format: &quot;)
+    char *event_format;     // event format line
 
-/// ass track represent either an external script or a matroska subtitle stream (no real difference between them)
-/// it can be used in rendering after the headers are parsed (i.e. events format line read)
-typedef struct ass_track_s {
-	int n_styles; // amount used
-	int max_styles; // amount allocated
-	int n_events;
-	int max_events;
-	ass_style_t* styles; // array of styles, max_styles length, n_styles used
-	ass_event_t* events; // the same as styles
+    enum {
+        TRACK_TYPE_UNKNOWN = 0,
+        TRACK_TYPE_ASS,
+        TRACK_TYPE_SSA
+    } track_type;
 
-	char* style_format; // style format line (everything after &quot;Format: &quot;)
-	char* event_format; // event format line
+    // Script header fields
+    int PlayResX;
+    int PlayResY;
+    double Timer;
+    int WrapStyle;
+    int ScaledBorderAndShadow;
+    int Kerning;
 
-	enum {TRACK_TYPE_UNKNOWN = 0, TRACK_TYPE_ASS, TRACK_TYPE_SSA} track_type;
-	
-	// script header fields
-	int PlayResX;
-	int PlayResY;
-	double Timer;
-	int WrapStyle;
+    int default_style;      // index of default style
+    char *name;             // file name in case of external subs, 0 for streams
 
-	
-	int default_style; // index of default style
-	char* name; // file name in case of external subs, 0 for streams
+    ASS_Library *library;
+    ASS_ParserPriv *parser_priv;
+} ASS_Track;
 
-	ass_library_t* library;
-	parser_priv_t* parser_priv;
-} ass_track_t;
-
-#endif
-
+#endif /* LIBASS_TYPES_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.c	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,81 +1,208 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#include &quot;ADM_coreConfig.h&quot;
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include &quot;config.h&quot;
-
 #include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
 #include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
+#include &lt;strings.h&gt;
 
-#include &quot;mputils.h&quot;
+#include &quot;ass_library.h&quot;
+#include &quot;ass.h&quot;
 #include &quot;ass_utils.h&quot;
 
-int mystrtoi(char** p, int base, int* res)
+int mystrtoi(char **p, int *res)
 {
-	char* start = *p;
-	*res = strtol(*p, p, base);
-	if (*p != start) return 1;
-	else return 0;
+    double temp_res;
+    char *start = *p;
+    temp_res = ass_strtod(*p, p);
+    *res = (int) (temp_res + (temp_res &gt; 0 ? 0.5 : -0.5));
+    if (*p != start)
+        return 1;
+    else
+        return 0;
 }
 
-int mystrtou32(char** p, int base, uint32_t* res)
+int mystrtoll(char **p, long long *res)
 {
-	char* start = *p;
-	*res = strtoll(*p, p, base);
-	if (*p != start) return 1;
-	else return 0;
+    double temp_res;
+    char *start = *p;
+    temp_res = ass_strtod(*p, p);
+    *res = (int) (temp_res + (temp_res &gt; 0 ? 0.5 : -0.5));
+    if (*p != start)
+        return 1;
+    else
+        return 0;
 }
 
-int mystrtod(char** p, double* res)
+int mystrtou32(char **p, int base, uint32_t *res)
 {
-	char* start = *p;
-	*res = strtod(*p, p);
-	if (*p != start) return 1;
-	else return 0;
+    char *start = *p;
+    *res = strtoll(*p, p, base);
+    if (*p != start)
+        return 1;
+    else
+        return 0;
 }
 
-int strtocolor(char** q, uint32_t* res)
+int mystrtod(char **p, double *res)
 {
-	uint32_t color = 0;
-	int result;
-	char* p = *q;
-	
-	if (*p == '&amp;') ++p; 
-	else mp_msg(MSGT_ASS, MSGL_DBG2, &quot;suspicious color format: \&quot;%s\&quot;\n&quot;, p);
-	
-	if (*p == 'H' || *p == 'h') { 
-		++p;
-		result = mystrtou32(&amp;p, 16, &amp;color);
-	} else {
-		result = mystrtou32(&amp;p, 0, &amp;color);
-	}
-	
-	{
-		unsigned char* tmp = (unsigned char*)(&amp;color);
-		unsigned char b;
-		b = tmp[0]; tmp[0] = tmp[3]; tmp[3] = b;
-		b = tmp[1]; tmp[1] = tmp[2]; tmp[2] = b;
-	}
-	if (*p == '&amp;') ++p;
-	*q = p;
+    char *start = *p;
+    *res = ass_strtod(*p, p);
+    if (*p != start)
+        return 1;
+    else
+        return 0;
+}
 
-	*res = color;
-	return result;
+int strtocolor(ASS_Library *library, char **q, uint32_t *res, int hex)
+{
+    uint32_t color = 0;
+    int result;
+    char *p = *q;
+    int base = hex ? 16 : 10;
+
+    if (*p == '&amp;')
+        ++p;
+    else
+        ass_msg(library, MSGL_DBG2, &quot;suspicious color format: \&quot;%s\&quot;\n&quot;, p);
+
+    if (*p == 'H' || *p == 'h') {
+        ++p;
+        result = mystrtou32(&amp;p, 16, &amp;color);
+    } else {
+        result = mystrtou32(&amp;p, base, &amp;color);
+    }
+
+    {
+        unsigned char *tmp = (unsigned char *) (&amp;color);
+        unsigned char b;
+        b = tmp[0];
+        tmp[0] = tmp[3];
+        tmp[3] = b;
+        b = tmp[1];
+        tmp[1] = tmp[2];
+        tmp[2] = b;
+    }
+    if (*p == '&amp;')
+        ++p;
+    *q = p;
+
+    *res = color;
+    return result;
 }
 
+// Return a boolean value for a string
+char parse_bool(char *str)
+{
+    while (*str == ' ' || *str == '\t')
+        str++;
+    if (!strncasecmp(str, &quot;yes&quot;, 3))
+        return 1;
+    else if (strtol(str, NULL, 10) &gt; 0)
+        return 1;
+    return 0;
+}
+
+void ass_msg(ASS_Library *priv, int lvl, char *fmt, ...)
+{
+    va_list va;
+    va_start(va, fmt);
+    priv-&gt;msg_callback(lvl, fmt, va, priv-&gt;msg_callback_data);
+    va_end(va);
+}
+
+unsigned ass_utf8_get_char(char **str)
+{
+    uint8_t *strp = (uint8_t *) * str;
+    unsigned c = *strp++;
+    unsigned mask = 0x80;
+    int len = -1;
+    while (c &amp; mask) {
+        mask &gt;&gt;= 1;
+        len++;
+    }
+    if (len &lt;= 0 || len &gt; 4)
+        goto no_utf8;
+    c &amp;= mask - 1;
+    while ((*strp &amp; 0xc0) == 0x80) {
+        if (len-- &lt;= 0)
+            goto no_utf8;
+        c = (c &lt;&lt; 6) | (*strp++ &amp; 0x3f);
+    }
+    if (len)
+        goto no_utf8;
+    *str = (char *) strp;
+    return c;
+
+  no_utf8:
+    strp = (uint8_t *) * str;
+    c = *strp++;
+    *str = (char *) strp;
+    return c;
+}
+
+#ifdef CONFIG_ENCA
+void *ass_guess_buffer_cp(ASS_Library *library, unsigned char *buffer,
+                          int buflen, char *preferred_language,
+                          char *fallback)
+{
+    const char **languages;
+    size_t langcnt;
+    EncaAnalyser analyser;
+    EncaEncoding encoding;
+    char *detected_sub_cp = NULL;
+    int i;
+
+    languages = enca_get_languages(&amp;langcnt);
+    ass_msg(library, MSGL_V, &quot;ENCA supported languages&quot;);
+    for (i = 0; i &lt; langcnt; i++) {
+        ass_msg(library, MSGL_V, &quot;lang %s&quot;, languages[i]);
+    }
+
+    for (i = 0; i &lt; langcnt; i++) {
+        const char *tmp;
+
+        if (strcasecmp(languages[i], preferred_language) != 0)
+            continue;
+        analyser = enca_analyser_alloc(languages[i]);
+        encoding = enca_analyse_const(analyser, buffer, buflen);
+        tmp = enca_charset_name(encoding.charset, ENCA_NAME_STYLE_ICONV);
+        if (tmp &amp;&amp; encoding.charset != ENCA_CS_UNKNOWN) {
+            detected_sub_cp = strdup(tmp);
+            ass_msg(library, MSGL_INFO, &quot;ENCA detected charset: %s&quot;, tmp);
+        }
+        enca_analyser_free(analyser);
+    }
+
+    free(languages);
+
+    if (!detected_sub_cp) {
+        detected_sub_cp = strdup(fallback);
+        ass_msg(library, MSGL_INFO,
+               &quot;ENCA detection failed: fallback to %s&quot;, fallback);
+    }
+
+    return detected_sub_cp;
+}
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.h	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,61 +1,147 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
 /*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
+#ifndef LIBASS_UTILS_H
+#define LIBASS_UTILS_H
 
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
+#include &lt;stdio.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdint.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
 
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
+#ifdef CONFIG_ENCA
+#include &lt;enca.h&gt;
+#endif
 
-#ifndef ASS_UTILS_H
-#define ASS_UTILS_H
+#include &quot;ass.h&quot;
 
-int mystrtoi(char** p, int base, int* res);
-int mystrtou32(char** p, int base, uint32_t* res);
-int mystrtod(char** p, double* res);
-int strtocolor(char** q, uint32_t* res);
+#define MSGL_FATAL 0
+#define MSGL_ERR 1
+#define MSGL_WARN 2
+#define MSGL_INFO 4
+#define MSGL_V 6
+#define MSGL_DBG2 7
 
-static inline int d6_to_int(int x) {
-	return (x + 32) &gt;&gt; 6;
+#define FFMAX(a,b) ((a) &gt; (b) ? (a) : (b))
+#define FFMIN(a,b) ((a) &gt; (b) ? (b) : (a))
+#define FFMINMAX(c,a,b) FFMIN(FFMAX(c, a), b)
+
+int mystrtoi(char **p, int *res);
+int mystrtoll(char **p, long long *res);
+int mystrtou32(char **p, int base, uint32_t *res);
+int mystrtod(char **p, double *res);
+int strtocolor(ASS_Library *library, char **q, uint32_t *res, int hex);
+char parse_bool(char *str);
+unsigned ass_utf8_get_char(char **str);
+void ass_msg(ASS_Library *priv, int lvl, char *fmt, ...);
+#ifdef CONFIG_ENCA
+void *ass_guess_buffer_cp(ASS_Library *library, unsigned char *buffer,
+                          int buflen, char *preferred_language,
+                          char *fallback);
+#endif
+
+/* defined in ass_strtod.c */
+double ass_strtod(const char *string, char **endPtr);
+
+static inline int d6_to_int(int x)
+{
+    return (x + 32) &gt;&gt; 6;
 }
-static inline int d16_to_int(int x) {
-	return (x + 32768) &gt;&gt; 16;
+static inline int d16_to_int(int x)
+{
+    return (x + 32768) &gt;&gt; 16;
 }
-static inline int int_to_d6(int x) {
-	return x &lt;&lt; 6;
+static inline int int_to_d6(int x)
+{
+    return x &lt;&lt; 6;
 }
-static inline int int_to_d16(int x) {
-	return x &lt;&lt; 16;
+static inline int int_to_d16(int x)
+{
+    return x &lt;&lt; 16;
 }
-static inline int d16_to_d6(int x) {
-	return (x + 512) &gt;&gt; 10;
+static inline int d16_to_d6(int x)
+{
+    return (x + 512) &gt;&gt; 10;
 }
-static inline int d6_to_d16(int x) {
-	return x &lt;&lt; 10;
+static inline int d6_to_d16(int x)
+{
+    return x &lt;&lt; 10;
 }
-static inline double d6_to_double(int x) {
-	return x / 64.;
+static inline double d6_to_double(int x)
+{
+    return x / 64.;
 }
-static inline int double_to_d6(double x) {
-	return (int)(x * 64);
+static inline int double_to_d6(double x)
+{
+    return (int) (x * 64);
 }
-static inline double d16_to_double(int x) {
-	return ((double)x) / 0x10000;
+static inline double d16_to_double(int x)
+{
+    return ((double) x) / 0x10000;
 }
-static inline int double_to_d16(double x) {
-	return (int)(x * 0x10000);
+static inline int double_to_d16(double x)
+{
+    return (int) (x * 0x10000);
 }
+static inline double d22_to_double(int x)
+{
+    return ((double) x) / 0x400000;
+}
+static inline int double_to_d22(double x)
+{
+    return (int) (x * 0x400000);
+}
 
-#endif
+// Calculate cache key for a rotational angle in degrees
+static inline int rot_key(double a)
+{
+    const int m = double_to_d22(360.0);
+    return double_to_d22(a) % m;
+}
 
+#define FNV1_32A_INIT (unsigned)0x811c9dc5
+
+static inline unsigned fnv_32a_buf(void *buf, size_t len, unsigned hval)
+{
+    unsigned char *bp = buf;
+    unsigned char *be = bp + len;
+    while (bp &lt; be) {
+        hval ^= (unsigned) *bp++;
+        hval +=
+            (hval &lt;&lt; 1) + (hval &lt;&lt; 4) + (hval &lt;&lt; 7) + (hval &lt;&lt; 8) +
+            (hval &lt;&lt; 24);
+    }
+    return hval;
+}
+static inline unsigned fnv_32a_str(char *str, unsigned hval)
+{
+    unsigned char *s = (unsigned char *) str;
+    while (*s) {
+        hval ^= (unsigned) *s++;
+        hval +=
+            (hval &lt;&lt; 1) + (hval &lt;&lt; 4) + (hval &lt;&lt; 7) + (hval &lt;&lt; 8) +
+            (hval &lt;&lt; 24);
+    }
+    return hval;
+}
+
+#endif                          /* LIBASS_UTILS_H */

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.c	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.c	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,218 +0,0 @@
-//#include &quot;config.h&quot;
-
-#include &quot;mputils.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;stdint.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;assert.h&gt;
-
-#ifdef HAVE_ENCA
-#include &lt;enca.h&gt;
-#endif
-
-void my_mp_msg(int lvl, char *lvl_str, char *fmt, ...) {
-	va_list va;
-	if(lvl &gt; MSGL_V) return;
-	printf(&quot;[ass] **%s**: &quot;, lvl_str);
-	va_start(va, fmt);
-	vprintf(fmt, va);
-	va_end(va);
-}
-
-unsigned utf8_get_char(char **str) {
-  uint8_t *strp = (uint8_t *)*str;
-  unsigned c = *strp++;
-  unsigned mask = 0x80;
-  int len = -1;
-  while (c &amp; mask) {
-    mask &gt;&gt;= 1;
-    len++;
-  }
-  if (len &lt;= 0 || len &gt; 4)
-    goto no_utf8;
-  c &amp;= mask - 1;
-  while ((*strp &amp; 0xc0) == 0x80) {
-    if (len-- &lt;= 0)
-      goto no_utf8;
-    c = (c &lt;&lt; 6) | (*strp++ &amp; 0x3f);
-  }
-  if (len)
-    goto no_utf8;
-  *str = (char *)strp;
-  return c;
-
-no_utf8:
-  strp = (uint8_t *)*str;
-  c = *strp++;
-  *str = (char *)strp;
-  return c;
-}
-
-// gaussian blur
-void blur(
-	unsigned char *buffer,
-	unsigned short *tmp2,
-	int width,
-	int height,
-	int stride,
-	int *m2,
-	int r,
-	int mwidth) {
-
-    int x, y;
-
-    unsigned char  *s = buffer;
-    unsigned short *t = tmp2+1;
-    for(y=0; y&lt;height; y++){
-	memset(t-1, 0, (width+1)*sizeof(short));
-
-	for(x=0; x&lt;r; x++){
-	    const int src= s[x];
-	    if(src){
-		register unsigned short *dstp= t + x-r;
-		int mx;
-		unsigned *m3= m2 + src*mwidth;
-		for(mx=r-x; mx&lt;mwidth; mx++){
-		    dstp[mx]+= m3[mx];
-		}
-	    }
-	}
-
-	for(; x&lt;width-r; x++){
-	    const int src= s[x];
-	    if(src){
-		register unsigned short *dstp= t + x-r;
-		int mx;
-		unsigned *m3= m2 + src*mwidth;
-		for(mx=0; mx&lt;mwidth; mx++){
-		    dstp[mx]+= m3[mx];
-		}
-	    }
-	}
-
-	for(; x&lt;width; x++){
-	    const int src= s[x];
-	    if(src){
-		register unsigned short *dstp= t + x-r;
-		int mx;
-		const int x2= r+width -x;
-		unsigned *m3= m2 + src*mwidth;
-		for(mx=0; mx&lt;x2; mx++){
-		    dstp[mx]+= m3[mx];
-		}
-	    }
-	}
-
-	s+= stride;
-	t+= width + 1;
-    }
-
-    t = tmp2;
-    for(x=0; x&lt;width; x++){
-	for(y=0; y&lt;r; y++){
-	    unsigned short *srcp= t + y*(width+1) + 1;
-	    int src= *srcp;
-	    if(src){
-		register unsigned short *dstp= srcp - 1 + width+1;
-		const int src2= (src + 128)&gt;&gt;8;
-		unsigned *m3= m2 + src2*mwidth;
-
-		int mx;
-		*srcp= 128;
-		for(mx=r-1; mx&lt;mwidth; mx++){
-		    *dstp += m3[mx];
-		    dstp+= width+1;
-		}
-	    }
-	}
-	for(; y&lt;height-r; y++){
-	    unsigned short *srcp= t + y*(width+1) + 1;
-	    int src= *srcp;
-	    if(src){
-		register unsigned short *dstp= srcp - 1 - r*(width+1);
-		const int src2= (src + 128)&gt;&gt;8;
-		unsigned *m3= m2 + src2*mwidth;
-
-		int mx;
-		*srcp= 128;
-		for(mx=0; mx&lt;mwidth; mx++){
-		    *dstp += m3[mx];
-		    dstp+= width+1;
-		}
-	    }
-	}
-	for(; y&lt;height; y++){
-	    unsigned short *srcp= t + y*(width+1) + 1;
-	    int src= *srcp;
-	    if(src){
-		const int y2=r+height-y;
-		register unsigned short *dstp= srcp - 1 - r*(width+1);
-		const int src2= (src + 128)&gt;&gt;8;
-		unsigned *m3= m2 + src2*mwidth;
-
-		int mx;
-		*srcp= 128;
-		for(mx=0; mx&lt;y2; mx++){
-		    *dstp += m3[mx];
-		    dstp+= width+1;
-		}
-	    }
-	}
-	t++;
-    }
-
-    t = tmp2;
-    s = buffer;
-    for(y=0; y&lt;height; y++){
-	for(x=0; x&lt;width; x++){
-	    s[x]= t[x]&gt;&gt;8;
-	}
-	s+= stride;
-	t+= width + 1;
-    }
-}
-
-#ifdef HAVE_ENCA
-void* guess_buffer_cp(unsigned char* buffer, int buflen, char *preferred_language, char *fallback)
-{
-    const char **languages;
-    size_t langcnt;
-    EncaAnalyser analyser;
-    EncaEncoding encoding;
-    char *detected_sub_cp = NULL;
-    int i;
-
-    languages = enca_get_languages(&amp;langcnt);
-    mp_msg(MSGT_ASS, MSGL_V, &quot;ENCA supported languages: &quot;);
-    for (i = 0; i &lt; langcnt; i++) {
-	mp_msg(MSGT_ASS, MSGL_V, &quot;%s &quot;, languages[i]);
-    }
-    mp_msg(MSGT_ASS, MSGL_V, &quot;\n&quot;);
-    
-    for (i = 0; i &lt; langcnt; i++) {
-	const char *tmp;
-	
-	if (strcasecmp(languages[i], preferred_language) != 0) continue;
-	analyser = enca_analyser_alloc(languages[i]);
-	encoding = enca_analyse_const(analyser, buffer, buflen);
-	tmp = enca_charset_name(encoding.charset, ENCA_NAME_STYLE_ICONV);
-	if (tmp &amp;&amp; encoding.charset != ENCA_CS_UNKNOWN) {
-	    detected_sub_cp = strdup(tmp);
-	    mp_msg(MSGT_ASS, MSGL_INFO, &quot;ENCA detected charset: %s\n&quot;, tmp);
-	}
-	enca_analyser_free(analyser);
-    }
-    
-    free(languages);
-
-    if (!detected_sub_cp) {
-	detected_sub_cp = strdup(fallback);
-	mp_msg(MSGT_ASS, MSGL_INFO, &quot;ENCA detection failed: fallback to %s\n&quot;, fallback);
-    }
-
-    return detected_sub_cp;
-}
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.h	2010-09-05 11:57:01 UTC (rev 6587)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.h	2010-09-06 10:23:18 UTC (rev 6588)
@@ -1,35 +0,0 @@
-#ifndef __MPUTILS_H__
-#define __MPUTILS_H__
-
-#include &quot;help_mp.h&quot;
-
-unsigned utf8_get_char(char **str);
-
-void my_mp_msg(int lvl, char *lvl_str, char *fmt, ...);
-
-#ifdef __VISUALC__
-static void mp_msg(int mod, int level, const char *fmt, ...) {
-	// MSVC doesn't like the # used all around for mp_msg, so it breaks va_arg
-}
-#else
-#define mp_msg(mod, level, args...) my_mp_msg(level, #level, args)
-#endif
-
-#define MSGT_ASS 43
-
-#define MSGL_FATAL 0
-#define MSGL_ERR 1
-#define MSGL_WARN 2
-#define MSGL_INFO 4
-#define MSGL_V 6
-#define MSGL_DBG2 7
-
-void blur(unsigned char *buffer, unsigned short *tmp2, int width, int height,
-          int stride, int *m2, int r, int mwidth);
-
-void* guess_buffer_cp(unsigned char* buffer, int buflen, char *preferred_language, char *fallback);
-
-#define FFMAX(a,b) ((a) &gt; (b) ? (a) : (b))
-#define FFMIN(a,b) ((a) &gt; (b) ? (b) : (a))
-
-#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003773.html">[Avidemux-svn-commit] r6587 - in	branches/avidemux_2.5_branch_gruntster: avidemux	platforms/windows/build_scripts	platforms/windows/build_scripts/avidemux platforms/windows/installer
</A></li>
	<LI>Next message: <A HREF="003775.html">[Avidemux-svn-commit] r6589 - in	branches/avidemux_2.6_branch_mean/avidemux: common	common/ADM_toolkit qt4/ADM_userInterfaces/ADM_gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3774">[ date ]</a>
              <a href="thread.html#3774">[ thread ]</a>
              <a href="subject.html#3774">[ subject ]</a>
              <a href="author.html#3774">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
