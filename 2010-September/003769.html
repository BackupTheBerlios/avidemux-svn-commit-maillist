<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6583 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. ass ass/ADM_libass
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-September/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6583%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6%3A%0A%09.%20ass%20ass/ADM_libass&In-Reply-To=%3C20100904163333.C645048102A%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003768.html">
   <LINK REL="Next"  HREF="003770.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6583 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. ass ass/ADM_libass</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6583%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6%3A%0A%09.%20ass%20ass/ADM_libass&In-Reply-To=%3C20100904163333.C645048102A%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6583 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. ass ass/ADM_libass">mean at mail.berlios.de
       </A><BR>
    <I>Sat Sep  4 18:33:33 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003768.html">[Avidemux-svn-commit] r6582 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml
</A></li>
        <LI>Next message: <A HREF="003770.html">[Avidemux-svn-commit] r6584 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3769">[ date ]</a>
              <a href="thread.html#3769">[ thread ]</a>
              <a href="subject.html#3769">[ subject ]</a>
              <a href="author.html#3769">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-09-04 18:33:33 +0200 (Sat, 04 Sep 2010)
New Revision: 6583

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_types.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/help_mp.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_vidASS.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa_desc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
Log:
[VideoFilter] First import of Ass/ssa filter + libass

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-09-04 09:34:35 UTC (rev 6582)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-09-04 16:33:33 UTC (rev 6583)
@@ -1,5 +1,5 @@
 ADD_SUBDIRECTORY(addBorder)
-#ADD_SUBDIRECTORY(ass)
+ADD_SUBDIRECTORY(ass)
 ADD_SUBDIRECTORY(blackenBorder)
 ADD_SUBDIRECTORY(crop)
 ADD_SUBDIRECTORY(dummy)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/CMakeLists.txt	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,19 @@
+INCLUDE(admCheckFontConfig)
+checkFontConfig()
+
+SET(ADM_LIB ADM_libass)
+
+SET(${ADM_LIB}_SRCS 
+ass_bitmap.c  ass.c  ass_cache.c  ass_fontconfig.c  ass_library.c   ass_render.c  ass_utils.c  mputils.c
+ass_font.c)
+
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_DEFINITIONS(${FREETYPE2_CFLAGS} &quot;-I${LIBICONV_INCLUDE_DIR}&quot;)
+
+IF (FONTCONFIG_FOUND)
+	ADD_DEFINITIONS(${FONTCONFIG_CFLAGS} &quot;-DHAVE_FONTCONFIG=1&quot;)
+ENDIF (FONTCONFIG_FOUND)
+
+IF (UNIX)
+	ADD_TARGET_CFLAGS(${ADM_LIB} -fPIC)
+ENDIF (UNIX)
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.c	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,1092 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+//#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;inttypes.h&gt;
+
+#ifdef USE_ICONV
+#include &lt;iconv.h&gt;
+#endif
+
+#include &quot;ass.h&quot;
+#include &quot;ass_utils.h&quot;
+#include &quot;ass_library.h&quot;
+#include &quot;mputils.h&quot;
+
+typedef enum {PST_UNKNOWN = 0, PST_INFO, PST_STYLES, PST_EVENTS, PST_FONTS} parser_state_t;
+
+struct parser_priv_s {
+	parser_state_t state;
+	char* fontname;
+	char* fontdata;
+	int fontdata_size;
+	int fontdata_used;
+};
+
+#define ASS_STYLES_ALLOC 20
+#define ASS_EVENTS_ALLOC 200
+
+void ass_free_track(ass_track_t* track) {
+	int i;
+	
+	if (track-&gt;parser_priv) {
+		if (track-&gt;parser_priv-&gt;fontname)
+			free(track-&gt;parser_priv-&gt;fontname);
+		if (track-&gt;parser_priv-&gt;fontdata)
+			free(track-&gt;parser_priv-&gt;fontdata);
+		free(track-&gt;parser_priv);
+	}
+	if (track-&gt;style_format)
+		free(track-&gt;style_format);
+	if (track-&gt;event_format)
+		free(track-&gt;event_format);
+	if (track-&gt;styles) {
+		for (i = 0; i &lt; track-&gt;n_styles; ++i)
+			ass_free_style(track, i);
+		free(track-&gt;styles);
+	}
+	if (track-&gt;events) {
+		for (i = 0; i &lt; track-&gt;n_events; ++i)
+			ass_free_event(track, i);
+		free(track-&gt;events);
+	}
+}
+
+/// \brief Allocate a new style struct
+/// \param track track
+/// \return style id
+int ass_alloc_style(ass_track_t* track) {
+	int sid;
+	
+	assert(track-&gt;n_styles &lt;= track-&gt;max_styles);
+
+	if (track-&gt;n_styles == track-&gt;max_styles) {
+		track-&gt;max_styles += ASS_STYLES_ALLOC;
+		track-&gt;styles = (ass_style_t*)realloc(track-&gt;styles, sizeof(ass_style_t)*track-&gt;max_styles);
+	}
+	
+	sid = track-&gt;n_styles++;
+	memset(track-&gt;styles + sid, 0, sizeof(ass_style_t));
+	return sid;
+}
+
+/// \brief Allocate a new event struct
+/// \param track track
+/// \return event id
+int ass_alloc_event(ass_track_t* track) {
+	int eid;
+	
+	assert(track-&gt;n_events &lt;= track-&gt;max_events);
+
+	if (track-&gt;n_events == track-&gt;max_events) {
+		track-&gt;max_events += ASS_EVENTS_ALLOC;
+		track-&gt;events = (ass_event_t*)realloc(track-&gt;events, sizeof(ass_event_t)*track-&gt;max_events);
+	}
+	
+	eid = track-&gt;n_events++;
+	memset(track-&gt;events + eid, 0, sizeof(ass_event_t));
+	return eid;
+}
+
+void ass_free_event(ass_track_t* track, int eid) {
+	ass_event_t* event = track-&gt;events + eid;
+	if (event-&gt;Name)
+		free(event-&gt;Name);
+	if (event-&gt;Effect)
+		free(event-&gt;Effect);
+	if (event-&gt;Text)
+		free(event-&gt;Text);
+	if (event-&gt;render_priv)
+		free(event-&gt;render_priv);
+}
+
+void ass_free_style(ass_track_t* track, int sid) {
+	ass_style_t* style = track-&gt;styles + sid;
+	if (style-&gt;Name)
+		free(style-&gt;Name);
+	if (style-&gt;FontName)
+		free(style-&gt;FontName);
+}
+
+// ==============================================================================================
+
+static void skip_spaces(char** str) {
+	char* p = *str;
+	while ((*p==' ') || (*p=='\t'))
+		++p;
+	*str = p;
+}
+
+static void rskip_spaces(char** str, char* limit) {
+	char* p = *str;
+	while ((p &gt;= limit) &amp;&amp; ((*p==' ') || (*p=='\t')))
+		--p;
+	*str = p;
+}
+
+/**
+ * \brief find style by name
+ * \param track track
+ * \param name style name
+ * \return index in track-&gt;styles
+ * Returnes 0 if no styles found =&gt; expects at least 1 style.
+ * Parsing code always adds &quot;Default&quot; style in the end.
+ */
+static int lookup_style(ass_track_t* track, char* name) {
+	int i;
+	if (*name == '*') ++name; // FIXME: what does '*' really mean ?
+	for (i=0; i&lt;track-&gt;n_styles; ++i) {
+		// FIXME: mb strcasecmp ?
+		if (strcmp(track-&gt;styles[i].Name, name) == 0)
+			return i;
+	}
+	i = track-&gt;default_style;
+	mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoStyleNamedXFoundUsingY, track, name, track-&gt;styles[i].Name);
+	return i; // use the first style
+}
+
+static uint32_t string2color(char* p) {
+	uint32_t tmp;
+	(void)strtocolor(&amp;p, &amp;tmp);
+	return tmp;
+}
+
+static long long string2timecode(char* p) {
+	unsigned h, m, s, ms;
+	long long tm;
+	int res = sscanf(p, &quot;%1d:%2d:%2d.%2d&quot;, &amp;h, &amp;m, &amp;s, &amp;ms);
+	if (res &lt; 4) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_BadTimestamp);
+		return 0;
+	}
+	tm = ((h * 60 + m) * 60 + s) * 1000 + ms * 10;
+	return tm;
+}
+
+/**
+ * \brief converts numpad-style align to align.
+ */
+static int numpad2align(int val) {
+	int res, v;
+	v = (val - 1) / 3; // 0, 1 or 2 for vertical alignment
+	if (v != 0) v = 3 - v;
+	res = ((val - 1) % 3) + 1; // horizontal alignment
+	res += v*4;
+	return res;
+}
+
+#define NEXT(str,token) \
+	token = next_token(&amp;str); \
+	if (!token) break;
+
+#define ANYVAL(name,func) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target-&gt;name = func(token); \
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;%s = %s\n&quot;, #name, token);
+
+#define STRVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		if (target-&gt;name != NULL) free(target-&gt;name); \
+		target-&gt;name = strdup(token); \
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;%s = %s\n&quot;, #name, token);
+		
+#define COLORVAL(name) ANYVAL(name,string2color)
+#define INTVAL(name) ANYVAL(name,atoi)
+#define FPVAL(name) ANYVAL(name,atof)
+#define TIMEVAL(name) ANYVAL(name,string2timecode)
+#define STYLEVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target-&gt;name = lookup_style(track, token); \
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;%s = %s\n&quot;, #name, token);
+
+#define ALIAS(alias,name) \
+	if (strcasecmp(tname, #alias) == 0) {tname = #name;}
+
+static char* next_token(char** str) {
+	char* p = *str;
+	char* start;
+	skip_spaces(&amp;p);
+	if (*p == '\0') {
+		*str = p;
+		return 0;
+	}
+	start = p; // start of the token
+	for (; (*p != '\0') &amp;&amp; (*p != ','); ++p) {}
+	if (*p == '\0') {
+		*str = p; // eos found, str will point to '\0' at exit
+	} else {
+		*p = '\0';
+		*str = p + 1; // ',' found, str will point to the next char (beginning of the next token)
+	}
+	--p; // end of current token
+	rskip_spaces(&amp;p, start);
+	if (p &lt; start)
+		p = start; // empty token
+	else
+		++p; // the first space character, or '\0'
+	*p = '\0';
+	return start;
+}
+/**
+ * \brief Parse the tail of Dialogue line
+ * \param track track
+ * \param event parsed data goes here
+ * \param str string to parse, zero-terminated
+ * \param n_ignored number of format options to skip at the beginning
+*/ 
+static int process_event_tail(ass_track_t* track, ass_event_t* event, char* str, int n_ignored)
+{
+	char* token;
+	char* tname;
+	char* p = str;
+	int i;
+	ass_event_t* target = event;
+
+	char* format = strdup(track-&gt;event_format);
+	char* q = format; // format scanning pointer
+
+	if (track-&gt;n_styles == 0) {
+		// add &quot;Default&quot; style to the end
+		// will be used if track does not contain a default style (or even does not contain styles at all)
+		int sid = ass_alloc_style(track);
+		track-&gt;styles[sid].Name = strdup(&quot;Default&quot;);
+		track-&gt;styles[sid].FontName = strdup(&quot;Arial&quot;);
+	}
+
+	for (i = 0; i &lt; n_ignored; ++i) {
+		NEXT(q, tname);
+	}
+
+	while (1) {
+		NEXT(q, tname);
+		if (strcasecmp(tname, &quot;Text&quot;) == 0) {
+			char* last;
+			event-&gt;Text = strdup(p);
+			if (*event-&gt;Text != 0) {
+				last = event-&gt;Text + strlen(event-&gt;Text) - 1;
+				if (last &gt;= event-&gt;Text &amp;&amp; *last == '\r')
+					*last = 0;
+			}
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;Text = %s\n&quot;, event-&gt;Text);
+			event-&gt;Duration -= event-&gt;Start;
+			free(format);
+			return 0; // &quot;Text&quot; is always the last
+		}
+		NEXT(p, token);
+
+		ALIAS(End,Duration) // temporarily store end timecode in event-&gt;Duration
+		if (0) { // cool ;)
+			INTVAL(Layer)
+			STYLEVAL(Style)
+			STRVAL(Name)
+			STRVAL(Effect)
+			INTVAL(MarginL)
+			INTVAL(MarginR)
+			INTVAL(MarginV)
+			TIMEVAL(Start)
+			TIMEVAL(Duration)
+		}
+	}
+	free(format);
+	return 1;
+}
+
+/**
+ * \brief Parse command line style overrides (--ass-force-style option)
+ * \param track track to apply overrides to
+ * The format for overrides is [StyleName.]Field=Value
+ */
+void process_force_style(ass_track_t* track) {
+	char **fs, *eq, *dt, *style, *tname, *token;
+	ass_style_t* target;
+	int sid;
+	char** list = track-&gt;library-&gt;style_overrides;
+	
+	if (!list) return;
+	
+	for (fs = list; *fs; ++fs) {
+		eq = strrchr(*fs, '=');
+		if (!eq)
+			continue;
+		*eq = '\0';
+		token = eq + 1;
+
+		dt = strrchr(*fs, '.');
+		if (dt) {
+			*dt = '\0';
+			style = *fs;
+			tname = dt + 1;
+		} else {
+			style = NULL;
+			tname = *fs;
+		}
+		for (sid = 0; sid &lt; track-&gt;n_styles; ++sid) {
+			if (style == NULL || strcasecmp(track-&gt;styles[sid].Name, style) == 0) {
+				target = track-&gt;styles + sid;
+				if (0) {
+					STRVAL(FontName)
+					COLORVAL(PrimaryColour)
+					COLORVAL(SecondaryColour)
+					COLORVAL(OutlineColour)
+					COLORVAL(BackColour)
+					FPVAL(FontSize)
+					INTVAL(Bold)
+					INTVAL(Italic)
+					INTVAL(Underline)
+					INTVAL(StrikeOut)
+					FPVAL(Spacing)
+					INTVAL(Angle)
+					INTVAL(BorderStyle)
+					INTVAL(Alignment)
+					INTVAL(MarginL)
+					INTVAL(MarginR)
+					INTVAL(MarginV)
+					INTVAL(Encoding)
+					FPVAL(ScaleX)
+					FPVAL(ScaleY)
+					FPVAL(Outline)
+					FPVAL(Shadow)
+				}
+			}
+		}
+		*eq = '=';
+		if (dt) *dt = '.';
+	}
+}
+
+/**
+ * \brief Parse the Style line
+ * \param track track
+ * \param str string to parse, zero-terminated
+ * Allocates a new style struct.
+*/ 
+static int process_style(ass_track_t* track, char *str)
+{
+
+	char* token;
+	char* tname;
+	char* p = str;
+	char* format;
+	char* q; // format scanning pointer
+	int sid;
+	ass_style_t* style;
+	ass_style_t* target;
+
+	if (!track-&gt;style_format) {
+		// no style format header
+		// probably an ancient script version
+		if (track-&gt;track_type == TRACK_TYPE_SSA)
+			track-&gt;style_format = strdup(&quot;Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,&quot;
+					&quot;TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline,&quot;
+					&quot;Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding&quot;);
+		else
+			track-&gt;style_format = strdup(&quot;Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,&quot;
+					&quot;OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut,&quot;
+					&quot;ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow,&quot;
+					&quot;Alignment, MarginL, MarginR, MarginV, Encoding&quot;);
+	}
+
+	q = format = strdup(track-&gt;style_format);
+	
+	mp_msg(MSGT_ASS, MSGL_V, &quot;[%p] Style: %s\n&quot;, track, str);
+	
+	sid = ass_alloc_style(track);
+
+	style = track-&gt;styles + sid;
+	target = style;
+// fill style with some default values
+	style-&gt;ScaleX = 100.;
+	style-&gt;ScaleY = 100.;
+	
+	while (1) {
+		NEXT(q, tname);
+		NEXT(p, token);
+		
+//		ALIAS(TertiaryColour,OutlineColour) // ignore TertiaryColour; it appears only in SSA, and is overridden by BackColour
+			
+		if (0) { // cool ;)
+			STRVAL(Name)
+				if ((strcmp(target-&gt;Name, &quot;Default&quot;)==0) || (strcmp(target-&gt;Name, &quot;*Default&quot;)==0))
+					track-&gt;default_style = sid;
+			STRVAL(FontName)
+			COLORVAL(PrimaryColour)
+			COLORVAL(SecondaryColour)
+			COLORVAL(OutlineColour) // TertiaryColor
+			COLORVAL(BackColour)
+				// SSA uses BackColour for both outline and shadow
+				// this will destroy SSA's TertiaryColour, but i'm not going to use it anyway
+				if (track-&gt;track_type == TRACK_TYPE_SSA)
+					target-&gt;OutlineColour = target-&gt;BackColour;
+			FPVAL(FontSize)
+			INTVAL(Bold)
+			INTVAL(Italic)
+			INTVAL(Underline)
+			INTVAL(StrikeOut)
+			FPVAL(Spacing)
+			INTVAL(Angle)
+			INTVAL(BorderStyle)
+			INTVAL(Alignment)
+				if (track-&gt;track_type == TRACK_TYPE_ASS)
+					target-&gt;Alignment = numpad2align(target-&gt;Alignment);
+			INTVAL(MarginL)
+			INTVAL(MarginR)
+			INTVAL(MarginV)
+			INTVAL(Encoding)
+			FPVAL(ScaleX)
+			FPVAL(ScaleY)
+			FPVAL(Outline)
+			FPVAL(Shadow)
+		}
+	}
+	style-&gt;ScaleX /= 100.;
+	style-&gt;ScaleY /= 100.;
+	style-&gt;Bold = !!style-&gt;Bold;
+	style-&gt;Italic = !!style-&gt;Italic;
+	style-&gt;Underline = !!style-&gt;Underline;
+	if (!style-&gt;Name)
+		style-&gt;Name = strdup(&quot;Default&quot;);
+	if (!style-&gt;FontName)
+		style-&gt;FontName = strdup(&quot;Arial&quot;);
+	free(format);
+	return 0;
+	
+}
+
+static int process_styles_line(ass_track_t* track, char *str)
+{
+	if (!strncmp(str,&quot;Format:&quot;, 7)) {
+		char* p = str + 7;
+		skip_spaces(&amp;p);
+		track-&gt;style_format = strdup(p);
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;Style format: %s\n&quot;, track-&gt;style_format);
+	} else if (!strncmp(str,&quot;Style:&quot;, 6)) {
+		char* p = str + 6;
+		skip_spaces(&amp;p);
+		process_style(track, p);
+	}
+	return 0;
+}
+
+static int process_info_line(ass_track_t* track, char *str)
+{
+	if (!strncmp(str, &quot;PlayResX:&quot;, 9)) {
+		track-&gt;PlayResX = atoi(str + 9);
+	} else if (!strncmp(str,&quot;PlayResY:&quot;, 9)) {
+		track-&gt;PlayResY = atoi(str + 9);
+	} else if (!strncmp(str,&quot;Timer:&quot;, 6)) {
+		track-&gt;Timer = atof(str + 6);
+	} else if (!strncmp(str,&quot;WrapStyle:&quot;, 10)) {
+		track-&gt;WrapStyle = atoi(str + 10);
+	}
+	return 0;
+}
+
+static int process_events_line(ass_track_t* track, char *str)
+{
+	if (!strncmp(str, &quot;Format:&quot;, 7)) {
+		char* p = str + 7;
+		skip_spaces(&amp;p);
+		track-&gt;event_format = strdup(p);
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;Event format: %s\n&quot;, track-&gt;event_format);
+	} else if (!strncmp(str, &quot;Dialogue:&quot;, 9)) {
+		// This should never be reached for embedded subtitles.
+		// They have slightly different format and are parsed in ass_process_chunk,
+		// called directly from demuxer
+		int eid;
+		ass_event_t* event;
+		
+		str += 9;
+		skip_spaces(&amp;str);
+
+		eid = ass_alloc_event(track);
+		event = track-&gt;events + eid;
+
+		process_event_tail(track, event, str, 0);
+	} else {
+		mp_msg(MSGT_ASS, MSGL_V, &quot;Not understood: %s  \n&quot;, str);
+	}
+	return 0;
+}
+
+// Copied from mkvtoolnix
+static unsigned char* decode_chars(unsigned char c1, unsigned char c2,
+		unsigned char c3, unsigned char c4, unsigned char* dst, int cnt)
+{
+	uint32_t value;
+	unsigned char bytes[3];
+	int i;
+
+	value = ((c1 - 33) &lt;&lt; 18) + ((c2 - 33) &lt;&lt; 12) + ((c3 - 33) &lt;&lt; 6) + (c4 - 33);
+	bytes[2] = value &amp; 0xff;
+	bytes[1] = (value &amp; 0xff00) &gt;&gt; 8;
+	bytes[0] = (value &amp; 0xff0000) &gt;&gt; 16;
+
+	for (i = 0; i &lt; cnt; ++i)
+		*dst++ = bytes[i];
+	return dst;
+}
+
+static int decode_font(ass_track_t* track)
+{
+	unsigned char* p;
+	unsigned char* q;
+	int i;
+	int size; // original size
+	int dsize; // decoded size
+	unsigned char* buf = 0;
+
+	mp_msg(MSGT_ASS, MSGL_V, &quot;font: %d bytes encoded data \n&quot;, track-&gt;parser_priv-&gt;fontdata_used);
+	size = track-&gt;parser_priv-&gt;fontdata_used;
+	if (size % 4 == 1) {
+		mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_BadEncodedDataSize);
+		goto error_decode_font;
+	}
+	buf = malloc(size / 4 * 3 + 2);
+	q = buf;
+	for (i = 0, p = (unsigned char*)track-&gt;parser_priv-&gt;fontdata; i &lt; size / 4; i++, p+=4) {
+		q = decode_chars(p[0], p[1], p[2], p[3], q, 3);
+	}
+	if (size % 4 == 2) {
+		q = decode_chars(p[0], p[1], 0, 0, q, 1);
+	} else if (size % 4 == 3) {
+		q = decode_chars(p[0], p[1], p[2], 0, q, 2);
+	}
+	dsize = q - buf;
+	assert(dsize &lt;= size / 4 * 3 + 2);
+	
+	if (track-&gt;library-&gt;extract_fonts) {
+		ass_add_font(track-&gt;library, track-&gt;parser_priv-&gt;fontname, (char*)buf, dsize);
+		buf = 0;
+	}
+
+error_decode_font:
+	if (buf) free(buf);
+	free(track-&gt;parser_priv-&gt;fontname);
+	free(track-&gt;parser_priv-&gt;fontdata);
+	track-&gt;parser_priv-&gt;fontname = 0;
+	track-&gt;parser_priv-&gt;fontdata = 0;
+	track-&gt;parser_priv-&gt;fontdata_size = 0;
+	track-&gt;parser_priv-&gt;fontdata_used = 0;
+	return 0;
+}
+
+static int process_fonts_line(ass_track_t* track, char *str)
+{
+	int len;
+
+	if (!strncmp(str, &quot;fontname:&quot;, 9)) {
+		char* p = str + 9;
+		skip_spaces(&amp;p);
+		if (track-&gt;parser_priv-&gt;fontname) {
+			decode_font(track);
+		}
+		track-&gt;parser_priv-&gt;fontname = strdup(p);
+		mp_msg(MSGT_ASS, MSGL_V, &quot;fontname: %s\n&quot;, track-&gt;parser_priv-&gt;fontname);
+		return 0;
+	}
+	
+	if (!track-&gt;parser_priv-&gt;fontname) {
+		mp_msg(MSGT_ASS, MSGL_V, &quot;Not understood: %s  \n&quot;, str);
+		return 0;
+	}
+
+	len = strlen(str);
+	if (len &gt; 80) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FontLineTooLong, len, str);
+		return 0;
+	}
+	if (track-&gt;parser_priv-&gt;fontdata_used + len &gt; track-&gt;parser_priv-&gt;fontdata_size) {
+		track-&gt;parser_priv-&gt;fontdata_size += 100 * 1024;
+		track-&gt;parser_priv-&gt;fontdata = realloc(track-&gt;parser_priv-&gt;fontdata, track-&gt;parser_priv-&gt;fontdata_size);
+	}
+	memcpy(track-&gt;parser_priv-&gt;fontdata + track-&gt;parser_priv-&gt;fontdata_used, str, len);
+	track-&gt;parser_priv-&gt;fontdata_used += len;
+	
+	return 0;
+}
+
+/**
+ * \brief Parse a header line
+ * \param track track
+ * \param str string to parse, zero-terminated
+*/ 
+static int process_line(ass_track_t* track, char *str)
+{
+	if (strstr(str, &quot;[Script Info]&quot;)) { // FIXME: strstr to skip possible BOM at the beginning of the script
+		track-&gt;parser_priv-&gt;state = PST_INFO;
+	} else if (!strncmp(str, &quot;[V4 Styles]&quot;, 11)) {
+		track-&gt;parser_priv-&gt;state = PST_STYLES;
+		track-&gt;track_type = TRACK_TYPE_SSA;
+	} else if (!strncmp(str, &quot;[V4+ Styles]&quot;, 12)) {
+		track-&gt;parser_priv-&gt;state = PST_STYLES;
+		track-&gt;track_type = TRACK_TYPE_ASS;
+	} else if (!strncmp(str, &quot;[Events]&quot;, 8)) {
+		track-&gt;parser_priv-&gt;state = PST_EVENTS;
+	} else if (!strncmp(str, &quot;[Fonts]&quot;, 7)) {
+		track-&gt;parser_priv-&gt;state = PST_FONTS;
+	} else {
+		switch (track-&gt;parser_priv-&gt;state) {
+		case PST_INFO:
+			process_info_line(track, str);
+			break;
+		case PST_STYLES:
+			process_styles_line(track, str);
+			break;
+		case PST_EVENTS:
+			process_events_line(track, str);
+			break;
+		case PST_FONTS:
+			process_fonts_line(track, str);
+			break;
+		default:
+			break;
+		}
+	}
+
+	// there is no explicit end-of-font marker in ssa/ass
+	if ((track-&gt;parser_priv-&gt;state != PST_FONTS) &amp;&amp; (track-&gt;parser_priv-&gt;fontname))
+		decode_font(track);
+
+	return 0;
+}
+
+static int process_text(ass_track_t* track, char* str)
+{
+	char* p = str;
+	while(1) {
+		char* q;
+		for (;((*p=='\r')||(*p=='\n'));++p) {}
+		for (q=p; ((*q!='\0')&amp;&amp;(*q!='\r')&amp;&amp;(*q!='\n')); ++q) {};
+		if (q==p)
+			break;
+		if (*q != '\0')
+			*(q++) = '\0';
+		process_line(track, p);
+		if (*q == '\0')
+			break;
+		p = q;
+	}
+	return 0;
+}
+
+/**
+ * \brief Process CodecPrivate section of subtitle stream
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ CodecPrivate section contains [Stream Info] and [V4+ Styles] ([V4 Styles] for SSA) sections
+*/ 
+void ass_process_codec_private(ass_track_t* track, char *data, int size)
+{
+	char* str = malloc(size + 1);
+
+	memcpy(str, data, size);
+	str[size] = '\0';
+
+	process_text(track, str);
+	free(str);
+
+	if (!track-&gt;event_format) {
+		// probably an mkv produced by ancient mkvtoolnix
+		// such files don't have [Events] and Format: headers
+		track-&gt;parser_priv-&gt;state = PST_EVENTS;
+		if (track-&gt;track_type == TRACK_TYPE_SSA)
+			track-&gt;event_format = strdup(&quot;Format: Marked, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text&quot;);
+		else
+			track-&gt;event_format = strdup(&quot;Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text&quot;);
+	}
+
+	process_force_style(track);
+}
+
+static int check_duplicate_event(ass_track_t* track, int ReadOrder)
+{
+	int i;
+	for (i = 0; i&lt;track-&gt;n_events - 1; ++i) // ignoring last event, it is the one we are comparing with
+		if (track-&gt;events[i].ReadOrder == ReadOrder)
+			return 1;
+	return 0;
+}
+
+/**
+ * \brief Process a chunk of subtitle stream data. In matroska, this containes exactly 1 event (or a commentary)
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ * \param timecode starting time of the event (milliseconds)
+ * \param duration duration of the event (milliseconds)
+*/ 
+void ass_process_chunk(ass_track_t* track, char *data, int size, long long timecode, long long duration)
+{
+	char* str;
+	int eid;
+	char* p;
+	char* token;
+	ass_event_t* event;
+
+	if (!track-&gt;event_format) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EventFormatHeaderMissing);
+		return;
+	}
+	
+	str = malloc(size + 1);
+	memcpy(str, data, size);
+	str[size] = '\0';
+	mp_msg(MSGT_ASS, MSGL_V, &quot;event at %&quot; PRId64 &quot;, +%&quot; PRId64 &quot;: %s  \n&quot;, (int64_t)timecode, (int64_t)duration, str);
+
+	eid = ass_alloc_event(track);
+	event = track-&gt;events + eid;
+
+	p = str;
+	
+	do { 
+		NEXT(p, token);
+		event-&gt;ReadOrder = atoi(token);
+		if (check_duplicate_event(track, event-&gt;ReadOrder))
+			break;
+
+		NEXT(p, token);
+		event-&gt;Layer = atoi(token);
+
+		process_event_tail(track, event, p, 3);
+
+		event-&gt;Start = timecode;
+		event-&gt;Duration = duration;
+		
+		free(str);
+		return;
+//		dump_events(tid);
+	} while (0);
+	// some error
+	ass_free_event(track, eid);
+	track-&gt;n_events--;
+	free(str);
+}
+
+#ifdef USE_ICONV
+/** \brief recode buffer to utf-8
+ * constraint: codepage != 0
+ * \param data pointer to text buffer
+ * \param size buffer size
+ * \return a pointer to recoded buffer, caller is responsible for freeing it
+**/
+static char* sub_recode(char* data, size_t size, char* codepage)
+{
+	static iconv_t icdsc = (iconv_t)(-1);
+	char* tocp = &quot;UTF-8&quot;;
+	char* outbuf;
+	assert(codepage);
+
+	{
+		char* cp_tmp = codepage ? strdup(codepage) : 0;
+#ifdef HAVE_ENCA
+		char enca_lang[3], enca_fallback[100];
+		if (sscanf(codepage, &quot;enca:%2s:%99s&quot;, enca_lang, enca_fallback) == 2
+				|| sscanf(codepage, &quot;ENCA:%2s:%99s&quot;, enca_lang, enca_fallback) == 2) {
+			cp_tmp = guess_buffer_cp((unsigned char*)data, size, enca_lang, enca_fallback);
+		}
+#endif
+		if ((icdsc = iconv_open (tocp, cp_tmp)) != (iconv_t)(-1)){
+			mp_msg(MSGT_ASS,MSGL_V,&quot;LIBSUB: opened iconv descriptor.\n&quot;);
+		} else
+			mp_msg(MSGT_ASS,MSGL_ERR,MSGTR_LIBASS_ErrorOpeningIconvDescriptor);
+#ifdef HAVE_ENCA
+		if (cp_tmp) free(cp_tmp);
+#endif
+	}
+
+	{
+		size_t osize = size;
+		size_t ileft = size;
+		size_t oleft = size - 1;
+		char* ip;
+		char* op;
+		size_t rc;
+		
+		outbuf = malloc(size);
+		ip = data;
+		op = outbuf;
+		
+		while (ileft) {
+			rc = iconv(icdsc, &amp;ip, &amp;ileft, &amp;op, &amp;oleft);
+			if (rc == (size_t)(-1)) {
+				if (errno == E2BIG) {
+					int offset = op - outbuf;
+					outbuf = (char*)realloc(outbuf, osize + size);
+					op = outbuf + offset;
+					osize += size;
+					oleft += size;
+				} else {
+					mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorRecodingFile);
+					return NULL;
+				}
+			}
+		}
+		outbuf[osize - oleft - 1] = 0;
+	}
+
+	if (icdsc != (iconv_t)(-1)) {
+		(void)iconv_close(icdsc);
+		icdsc = (iconv_t)(-1);
+		mp_msg(MSGT_ASS,MSGL_V,&quot;LIBSUB: closed iconv descriptor.\n&quot;);
+	}
+	
+	return outbuf;
+}
+#endif // ICONV
+
+/**
+ * \brief read file contents into newly allocated buffer
+ * \param fname file name
+ * \param bufsize out: file size
+ * \return pointer to file contents. Caller is responsible for its deallocation.
+ */
+static char* read_file(char* fname, size_t *bufsize)
+{
+	int res;
+	long sz;
+	long bytes_read;
+	char* buf;
+
+	FILE* fp = fopen(fname, &quot;rb&quot;);
+	if (!fp) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FopenFailed, fname);
+		return 0;
+	}
+	res = fseek(fp, 0, SEEK_END);
+	if (res == -1) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FseekFailed, fname);
+		fclose(fp);
+		return 0;
+	}
+	
+	sz = ftell(fp);
+	rewind(fp);
+
+	if (sz &gt; 10*1024*1024) {
+		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_RefusingToLoadSubtitlesLargerThan10M, fname);
+		fclose(fp);
+		return 0;
+	}
+	
+	mp_msg(MSGT_ASS, MSGL_V, &quot;file size: %ld\n&quot;, sz);
+	
+	buf = malloc(sz + 1);
+	assert(buf);
+	bytes_read = 0;
+	do {
+		res = fread(buf + bytes_read, 1, sz - bytes_read, fp);
+		if (res &lt;= 0) {
+			mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_ReadFailed, errno, strerror(errno));
+			fclose(fp);
+			free(buf);
+			return 0;
+		}
+		bytes_read += res;
+	} while (sz - bytes_read &gt; 0);
+	buf[sz] = '\0';
+	fclose(fp);
+	
+	if (bufsize)
+		*bufsize = sz;
+	return buf;
+}
+
+/*
+ * \param buf pointer to subtitle text in utf-8
+ */
+static ass_track_t* parse_memory(ass_library_t* library, char* buf)
+{
+	ass_track_t* track;
+	int i;
+	
+	track = ass_new_track(library);
+	
+	// process header
+	process_text(track, buf);
+
+	// external SSA/ASS subs does not have ReadOrder field
+	for (i = 0; i &lt; track-&gt;n_events; ++i)
+		track-&gt;events[i].ReadOrder = i;
+
+	// there is no explicit end-of-font marker in ssa/ass
+	if (track-&gt;parser_priv-&gt;fontname)
+		decode_font(track);
+
+	if (track-&gt;track_type == TRACK_TYPE_UNKNOWN) {
+		ass_free_track(track);
+		return 0;
+	}
+
+	process_force_style(track);
+
+	return track;
+}
+
+/**
+ * \brief Read subtitles from memory.
+ * \param library libass library object
+ * \param buf pointer to subtitles text
+ * \param bufsize size of buffer
+ * \param codepage recode buffer contents from given codepage
+ * \return newly allocated track
+*/ 
+ass_track_t* ass_read_memory(ass_library_t* library, char* buf, size_t bufsize, char* codepage)
+{
+	ass_track_t* track;
+	int need_free = 0;
+	
+	if (!buf)
+		return 0;
+	
+#ifdef USE_ICONV
+	if (codepage)
+		buf = sub_recode(buf, bufsize, codepage);
+	if (!buf)
+		return 0;
+	else
+		need_free = 1;
+#endif
+	track = parse_memory(library, buf);
+	if (need_free)
+		free(buf);
+	if (!track)
+		return 0;
+
+	mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_AddedSubtitleFileMemory, track-&gt;n_styles, track-&gt;n_events);
+	return track;
+}
+
+char* read_file_recode(char* fname, char* codepage, int* size)
+{
+	char* buf;
+	size_t bufsize;
+	
+	buf = read_file(fname, &amp;bufsize);
+	if (!buf)
+		return 0;
+#ifdef USE_ICONV
+	if (codepage) {
+		 char* tmpbuf = sub_recode(buf, bufsize, codepage);
+		 free(buf);
+		 buf = tmpbuf;
+	}
+	if (!buf)
+		return 0;
+#endif
+	*size = bufsize;
+	return buf;
+}
+
+/**
+ * \brief Read subtitles from file.
+ * \param library libass library object
+ * \param fname file name
+ * \param codepage recode buffer contents from given codepage
+ * \return newly allocated track
+*/ 
+ass_track_t* ass_read_file(ass_library_t* library, char* fname, char* codepage)
+{
+	char* buf;
+	ass_track_t* track;
+	size_t bufsize;
+
+	buf = read_file_recode(fname, codepage, &amp;bufsize);
+	if (!buf)
+		return 0;
+	track = parse_memory(library, buf);
+	free(buf);
+	if (!track)
+		return 0;
+	
+	track-&gt;name = strdup(fname);
+
+	mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_AddedSubtitleFileFname, fname, track-&gt;n_styles, track-&gt;n_events);
+	
+//	dump_events(forced_tid);
+	return track;
+}
+
+/**
+ * \brief read styles from file into already initialized track
+ */
+int ass_read_styles(ass_track_t* track, char* fname, char* codepage)
+{
+	char* buf;
+	parser_state_t old_state;
+	size_t sz;
+
+	buf = read_file(fname, &amp;sz);
+	if (!buf)
+		return 1;
+#ifdef USE_ICONV
+	if (codepage) {
+		char* tmpbuf;
+		tmpbuf = sub_recode(buf, sz, codepage);
+		free(buf);
+		buf = tmpbuf;
+	}
+	if (!buf)
+		return 0;
+#endif
+
+	old_state = track-&gt;parser_priv-&gt;state;
+	track-&gt;parser_priv-&gt;state = PST_STYLES;
+	process_text(track, buf);
+	track-&gt;parser_priv-&gt;state = old_state;
+
+	return 0;
+}
+
+long long ass_step_sub(ass_track_t* track, long long now, int movement) {
+	int i;
+
+	if (movement == 0) return 0;
+	if (track-&gt;n_events == 0) return 0;
+	
+	if (movement &lt; 0)
+		for (i = 0; (i &lt; track-&gt;n_events) &amp;&amp; ((long long)(track-&gt;events[i].Start + track-&gt;events[i].Duration) &lt;= now); ++i) {}
+	else
+		for (i = track-&gt;n_events - 1; (i &gt;= 0) &amp;&amp; ((long long)(track-&gt;events[i].Start) &gt; now); --i) {}
+	
+	// -1 and n_events are ok
+	assert(i &gt;= -1); assert(i &lt;= track-&gt;n_events);
+	i += movement;
+	if (i &lt; 0) i = 0;
+	if (i &gt;= track-&gt;n_events) i = track-&gt;n_events - 1;
+	return ((long long)track-&gt;events[i].Start) - now;
+}
+
+ass_track_t* ass_new_track(ass_library_t* library) {
+	ass_track_t* track = calloc(1, sizeof(ass_track_t));
+	track-&gt;library = library;
+	track-&gt;parser_priv = calloc(1, sizeof(parser_priv_t));
+	return track;
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass.h	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,209 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#ifndef ASS_H
+#define ASS_H
+
+#include &quot;ass_types.h&quot;
+
+/// Libass renderer object. Contents are private.
+typedef struct ass_renderer_s ass_renderer_t;
+
+/// a linked list of images produced by ass renderer
+typedef struct ass_image_s {
+	int w, h; // bitmap width/height
+	int stride; // bitmap stride
+	unsigned char* bitmap; // 1bpp stride*h alpha buffer
+	uint32_t color; // RGBA
+	int dst_x, dst_y; // bitmap placement inside the video frame
+
+	struct ass_image_s* next; // linked list
+} ass_image_t;
+
+/// Hinting type
+typedef enum {ASS_HINTING_NONE = 0,
+	      ASS_HINTING_LIGHT,
+	      ASS_HINTING_NORMAL,
+	      ASS_HINTING_NATIVE
+} ass_hinting_t;
+
+/**
+ * \brief initialize the library
+ * \return library handle or NULL if failed
+ */
+ass_library_t* ass_library_init(void);
+
+/**
+ * \brief finalize the library
+ * \param priv library handle
+ */
+void ass_library_done(ass_library_t*);
+
+/**
+ * \brief set private font directory
+ * It is used for saving embedded fonts and also in font lookup.
+ */
+void ass_set_fonts_dir(ass_library_t* priv, const char* fonts_dir);
+
+void ass_set_extract_fonts(ass_library_t* priv, int extract);
+
+void ass_set_style_overrides(ass_library_t* priv, char** list);
+
+/**
+ * \brief initialize the renderer
+ * \param priv library handle
+ * \return renderer handle or NULL if failed
+ */
+ass_renderer_t* ass_renderer_init(ass_library_t*);
+
+/**
+ * \brief finalize the renderer
+ * \param priv renderer handle
+ */
+void ass_renderer_done(ass_renderer_t* priv);
+
+void ass_set_frame_size(ass_renderer_t* priv, int w, int h);
+void ass_set_margins(ass_renderer_t* priv, int t, int b, int l, int r);
+void ass_set_use_margins(ass_renderer_t* priv, int use);
+void ass_set_aspect_ratio(ass_renderer_t* priv, double ar);
+void ass_set_font_scale(ass_renderer_t* priv, double font_scale);
+void ass_set_hinting(ass_renderer_t* priv, ass_hinting_t ht);
+void ass_set_line_spacing(ass_renderer_t* priv, double line_spacing);
+
+/**
+ * \brief set font lookup defaults
+ */
+int  ass_set_fonts(ass_renderer_t* priv, const char* default_font, const char* default_family);
+
+/**
+ * \brief render a frame, producing a list of ass_image_t
+ * \param priv library
+ * \param track subtitle track
+ * \param now video timestamp in milliseconds
+ */
+ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now, int* detect_change);
+
+
+// The following functions operate on track objects and do not need an ass_renderer //
+
+/**
+ * \brief allocate a new empty track object
+ * \return pointer to empty track
+ */
+ass_track_t* ass_new_track(ass_library_t*);
+
+/**
+ * \brief deallocate track and all its child objects (styles and events)
+ * \param track track to deallocate
+ */
+void ass_free_track(ass_track_t* track);
+
+/**
+ * \brief allocate new style
+ * \param track track
+ * \return newly allocated style id
+ */
+int ass_alloc_style(ass_track_t* track);
+
+/**
+ * \brief allocate new event
+ * \param track track
+ * \return newly allocated event id
+ */
+int ass_alloc_event(ass_track_t* track);
+
+/**
+ * \brief delete a style
+ * \param track track
+ * \param sid style id
+ * Deallocates style data. Does not modify track-&gt;n_styles.
+ */
+void ass_free_style(ass_track_t* track, int sid);
+
+/**
+ * \brief delete an event
+ * \param track track
+ * \param eid event id
+ * Deallocates event data. Does not modify track-&gt;n_events.
+ */
+void ass_free_event(ass_track_t* track, int eid);
+
+/**
+ * \brief Process Codec Private section of subtitle stream
+ * \param track target track
+ * \param data string to parse
+ * \param size length of data
+ */
+void ass_process_codec_private(ass_track_t* track, char *data, int size);
+
+/**
+ * \brief Process a chunk of subtitle stream data. In matroska, this containes exactly 1 event (or a commentary)
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ * \param timecode starting time of the event (milliseconds)
+ * \param duration duration of the event (milliseconds)
+*/
+void ass_process_chunk(ass_track_t* track, char *data, int size, long long timecode, long long duration);
+
+char* read_file_recode(char* fname, char* codepage, int* size);
+
+/**
+ * \brief Read subtitles from file.
+ * \param fname file name
+ * \return newly allocated track
+*/
+ass_track_t* ass_read_file(ass_library_t* library, char* fname, char* codepage);
+
+/**
+ * \brief Read subtitles from memory.
+ * \param library libass library object
+ * \param buf pointer to subtitles text
+ * \param bufsize size of buffer
+ * \param codepage recode buffer contents from given codepage
+ * \return newly allocated track
+*/ 
+ass_track_t* ass_read_memory(ass_library_t* library, char* buf, size_t bufsize, char* codepage);
+/**
+ * \brief read styles from file into already initialized track
+ * \return 0 on success
+ */
+int ass_read_styles(ass_track_t* track, char* fname, char* codepage);
+
+/**
+ * \brief Add a memory font.
+ * \param name attachment name
+ * \param data binary font data
+ * \param data_size data size
+*/
+void ass_add_font(ass_library_t* library, char* name, char* data, int data_size);
+
+/**
+ * \brief Calculates timeshift from now to the start of some other subtitle event, depending on movement parameter
+ * \param track subtitle track
+ * \param now current time, ms
+ * \param movement how many events to skip from the one currently displayed
+ * +2 means &quot;the one after the next&quot;, -1 means &quot;previous&quot;
+ * \return timeshift, ms
+ */
+long long ass_step_sub(ass_track_t* track, long long now, int movement);
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.c	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,272 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
+
+#include &quot;mputils.h&quot;
+#include &quot;ass_bitmap.h&quot;
+
+struct ass_synth_priv_s {
+	int tmp_w, tmp_h;
+	unsigned short* tmp;
+
+	int g_r;
+	int g_w;
+
+	unsigned *g;
+	unsigned *gt2;
+};
+
+static const unsigned int maxcolor = 255;
+static const unsigned base = 256;
+static const double blur_radius = 1.5;
+
+static int generate_tables(ass_synth_priv_t* priv, double radius)
+{
+	double A = log(1.0/base)/(radius*radius*2);
+	int mx, i;
+	double volume_diff, volume_factor = 0;
+	unsigned volume;
+
+	priv-&gt;g_r = ceil(radius);
+	priv-&gt;g_w = 2*priv-&gt;g_r+1;
+
+	if (priv-&gt;g_r) {
+		priv-&gt;g = malloc(priv-&gt;g_w * sizeof(unsigned));
+		priv-&gt;gt2 = malloc(256 * priv-&gt;g_w * sizeof(unsigned));
+		if (priv-&gt;g==NULL || priv-&gt;gt2==NULL) {
+			return -1;
+		}
+	}
+
+	if (priv-&gt;g_r) {
+		// gaussian curve with volume = 256
+		for (volume_diff=10000000; volume_diff&gt;0.0000001; volume_diff*=0.5){
+			volume_factor+= volume_diff;
+			volume=0;
+			for (i = 0; i&lt;priv-&gt;g_w; ++i) {
+				priv-&gt;g[i] = (unsigned)(exp(A * (i-priv-&gt;g_r)*(i-priv-&gt;g_r)) * volume_factor + .5);
+				volume+= priv-&gt;g[i];
+			}
+			if(volume&gt;256) volume_factor-= volume_diff;
+		}
+		volume=0;
+		for (i = 0; i&lt;priv-&gt;g_w; ++i) {
+			priv-&gt;g[i] = (unsigned)(exp(A * (i-priv-&gt;g_r)*(i-priv-&gt;g_r)) * volume_factor + .5);
+			volume+= priv-&gt;g[i];
+		}
+
+		// gauss table:
+		for(mx=0;mx&lt;priv-&gt;g_w;mx++){
+			for(i=0;i&lt;256;i++){
+				priv-&gt;gt2[mx+i*priv-&gt;g_w] = i*priv-&gt;g[mx];
+			}
+		}
+	}
+
+	return 0;
+}
+
+static void resize_tmp(ass_synth_priv_t* priv, int w, int h)
+{
+	if (priv-&gt;tmp_w &gt;= w &amp;&amp; priv-&gt;tmp_h &gt;= h)
+		return;
+	if (priv-&gt;tmp_w == 0)
+		priv-&gt;tmp_w = 64;
+	if (priv-&gt;tmp_h == 0)
+		priv-&gt;tmp_h = 64;
+	while (priv-&gt;tmp_w &lt; w) priv-&gt;tmp_w *= 2;
+	while (priv-&gt;tmp_h &lt; h) priv-&gt;tmp_h *= 2;
+	if (priv-&gt;tmp)
+		free(priv-&gt;tmp);
+	priv-&gt;tmp = malloc((priv-&gt;tmp_w + 1) * priv-&gt;tmp_h * sizeof(short));
+}
+
+ass_synth_priv_t* ass_synth_init(void)
+{
+	ass_synth_priv_t* priv = calloc(1, sizeof(ass_synth_priv_t));
+	generate_tables(priv, blur_radius);
+	return priv;
+}
+
+void ass_synth_done(ass_synth_priv_t* priv)
+{
+	if (priv-&gt;tmp)
+		free(priv-&gt;tmp);
+	if (priv-&gt;g)
+		free(priv-&gt;g);
+	if (priv-&gt;gt2)
+		free(priv-&gt;gt2);
+	free(priv);
+}
+
+static bitmap_t* alloc_bitmap(int w, int h)
+{
+	bitmap_t* bm;
+	bm = calloc(1, sizeof(bitmap_t));
+	bm-&gt;buffer = malloc(w*h);
+	bm-&gt;w = w;
+	bm-&gt;h = h;
+	bm-&gt;left = bm-&gt;top = 0;
+	return bm;
+}
+
+void ass_free_bitmap(bitmap_t* bm)
+{
+	if (bm) {
+		if (bm-&gt;buffer) free(bm-&gt;buffer);
+		free(bm);
+	}
+}
+
+static bitmap_t* copy_bitmap(const bitmap_t* src)
+{
+	bitmap_t* dst = alloc_bitmap(src-&gt;w, src-&gt;h);
+	dst-&gt;left = src-&gt;left;
+	dst-&gt;top = src-&gt;top;
+	memcpy(dst-&gt;buffer, src-&gt;buffer, src-&gt;w * src-&gt;h);
+	return dst;
+}
+
+static bitmap_t* glyph_to_bitmap_internal(FT_Glyph glyph, int bord)
+{
+	FT_BitmapGlyph bg;
+	FT_Bitmap* bit;
+	bitmap_t* bm;
+	int w, h;
+	unsigned char* src;
+	unsigned char* dst;
+	int i;
+	int error;
+
+	error = FT_Glyph_To_Bitmap(&amp;glyph, FT_RENDER_MODE_NORMAL, 0, 0);
+	if (error) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FT_Glyph_To_BitmapError, error);
+		return 0;
+	}
+
+	bg = (FT_BitmapGlyph)glyph;
+	bit = &amp;(bg-&gt;bitmap);
+	if (bit-&gt;pixel_mode != FT_PIXEL_MODE_GRAY) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UnsupportedPixelMode, (int)(bit-&gt;pixel_mode));
+		FT_Done_Glyph(glyph);
+		return 0;
+	}
+
+	w = bit-&gt;width;
+	h = bit-&gt;rows;
+	bm = alloc_bitmap(w + 2*bord, h + 2*bord);
+	memset(bm-&gt;buffer, 0, bm-&gt;w * bm-&gt;h);
+	bm-&gt;left = bg-&gt;left - bord;
+	bm-&gt;top = - bg-&gt;top - bord;
+
+	src = bit-&gt;buffer;
+	dst = bm-&gt;buffer + bord + bm-&gt;w * bord;
+	for (i = 0; i &lt; h; ++i) {
+		memcpy(dst, src, w);
+		src += bit-&gt;pitch;
+		dst += bm-&gt;w;
+	}
+
+	return bm;
+}
+
+/**
+ * \brief fix outline bitmap and generate shadow bitmap
+ * Two things are done here:
+ * 1. Glyph bitmap is subtracted from outline bitmap. This way looks much better in some cases.
+ * 2. Shadow bitmap is created as a sum of glyph and outline bitmaps.
+ */
+static bitmap_t* fix_outline_and_shadow(bitmap_t* bm_g, bitmap_t* bm_o)
+{
+	int x, y;
+	const int l = bm_o-&gt;left &gt; bm_g-&gt;left ? bm_o-&gt;left : bm_g-&gt;left;
+	const int t = bm_o-&gt;top &gt; bm_g-&gt;top ? bm_o-&gt;top : bm_g-&gt;top;
+	const int r = bm_o-&gt;left + bm_o-&gt;w &lt; bm_g-&gt;left + bm_g-&gt;w ? bm_o-&gt;left + bm_o-&gt;w : bm_g-&gt;left + bm_g-&gt;w;
+	const int b = bm_o-&gt;top + bm_o-&gt;h &lt; bm_g-&gt;top + bm_g-&gt;h ? bm_o-&gt;top + bm_o-&gt;h : bm_g-&gt;top + bm_g-&gt;h;
+
+	bitmap_t* bm_s = copy_bitmap(bm_o);
+
+	unsigned char* g = bm_g-&gt;buffer + (t - bm_g-&gt;top) * bm_g-&gt;w + (l - bm_g-&gt;left);
+	unsigned char* o = bm_o-&gt;buffer + (t - bm_o-&gt;top) * bm_o-&gt;w + (l - bm_o-&gt;left);
+	unsigned char* s = bm_s-&gt;buffer + (t - bm_s-&gt;top) * bm_s-&gt;w + (l - bm_s-&gt;left);
+	
+	for (y = 0; y &lt; b - t; ++y) {
+		for (x = 0; x &lt; r - l; ++x) {
+			unsigned char c_g, c_o;
+			c_g = g[x];
+			c_o = o[x];
+			o[x] = (c_o &gt; c_g) ? c_o : 0;
+			s[x] = (c_o &lt; 0xFF - c_g) ? c_o + c_g : 0xFF;
+		}
+		g += bm_g-&gt;w;
+		o += bm_o-&gt;w;
+		s += bm_s-&gt;w;
+	}
+
+	assert(bm_s);
+	return bm_s;
+}
+
+int glyph_to_bitmap(ass_synth_priv_t* priv, FT_Glyph glyph, FT_Glyph outline_glyph,
+		bitmap_t** bm_g, bitmap_t** bm_o, bitmap_t** bm_s, int be)
+{
+	const int bord = be ? ceil(blur_radius) : 0;
+
+	assert(bm_g &amp;&amp; bm_o &amp;&amp; bm_s);
+
+	*bm_g = *bm_o = *bm_s = 0;
+
+	if (glyph)
+		*bm_g = glyph_to_bitmap_internal(glyph, bord);
+	if (!*bm_g)
+		return 1;
+
+	if (outline_glyph) {
+		*bm_o = glyph_to_bitmap_internal(outline_glyph, bord);
+		if (!*bm_o) {
+			ass_free_bitmap(*bm_g);
+			return 1;
+		}
+	}
+	if (*bm_o)
+		resize_tmp(priv, (*bm_o)-&gt;w, (*bm_o)-&gt;h);
+	resize_tmp(priv, (*bm_g)-&gt;w, (*bm_g)-&gt;h);
+	
+	if (be) {
+		blur((*bm_g)-&gt;buffer, priv-&gt;tmp, (*bm_g)-&gt;w, (*bm_g)-&gt;h, (*bm_g)-&gt;w, (int*)priv-&gt;gt2, priv-&gt;g_r, priv-&gt;g_w);
+		if (*bm_o)
+			blur((*bm_o)-&gt;buffer, priv-&gt;tmp, (*bm_o)-&gt;w, (*bm_o)-&gt;h, (*bm_o)-&gt;w, (int*)priv-&gt;gt2, priv-&gt;g_r, priv-&gt;g_w);
+	}
+
+	if (*bm_o)
+		*bm_s = fix_outline_and_shadow(*bm_g, *bm_o);
+	else
+		*bm_s = copy_bitmap(*bm_g);
+
+	assert(bm_s);
+	return 0;
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_bitmap.h	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,49 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#ifndef ASS_BITMAP_H
+#define ASS_BITMAP_H
+
+typedef struct ass_synth_priv_s ass_synth_priv_t;
+
+ass_synth_priv_t* ass_synth_init(void);
+void ass_synth_done(ass_synth_priv_t* priv);
+
+typedef struct bitmap_s {
+	int left, top;
+	int w, h; // width, height
+	unsigned char* buffer; // w x h buffer
+} bitmap_t;
+
+/**
+ * \brief perform glyph rendering
+ * \param glyph original glyph
+ * \param outline_glyph &quot;border&quot; glyph, produced from original by FreeType's glyph stroker
+ * \param bm_g out: pointer to the bitmap of original glyph is returned here
+ * \param bm_o out: pointer to the bitmap of outline (border) glyph is returned here
+ * \param bm_g out: pointer to the bitmap of glyph shadow is returned here
+ * \param be 1 = produces blurred bitmaps, 0 = normal bitmaps
+ */
+int glyph_to_bitmap(ass_synth_priv_t* priv, FT_Glyph glyph, FT_Glyph outline_glyph, bitmap_t** bm_g, bitmap_t** bm_o, bitmap_t** bm_s, int be);
+
+void ass_free_bitmap(bitmap_t* bm);
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.c	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,324 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+//#include &quot;config.h&quot;
+
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+#include FT_GLYPH_H
+
+#include &lt;assert.h&gt;
+
+#include &quot;mputils.h&quot;
+#include &quot;ass.h&quot;
+#include &quot;ass_fontconfig.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_bitmap.h&quot;
+#include &quot;ass_cache.h&quot;
+
+
+typedef struct hashmap_item_s {
+	void* key;
+	void* value;
+	struct hashmap_item_s* next;
+} hashmap_item_t;
+typedef hashmap_item_t* hashmap_item_p;
+
+struct hashmap_s {
+	int nbuckets;
+	size_t key_size, value_size;
+	hashmap_item_p* root;
+	hashmap_item_dtor_t item_dtor; // a destructor for hashmap key/value pairs
+	hashmap_key_compare_t key_compare;
+	hashmap_hash_t hash;
+	// stats
+	int hit_count;
+	int miss_count;
+	int count;
+};
+
+#define FNV1_32A_INIT (unsigned)0x811c9dc5
+
+static inline unsigned fnv_32a_buf(void* buf, size_t len, unsigned hval)
+{
+	unsigned char *bp = buf;
+	unsigned char *be = bp + len;
+	while (bp &lt; be) {
+		hval ^= (unsigned)*bp++;
+		hval += (hval&lt;&lt;1) + (hval&lt;&lt;4) + (hval&lt;&lt;7) + (hval&lt;&lt;8) + (hval&lt;&lt;24);
+	}
+	return hval;
+}
+static inline unsigned fnv_32a_str(char* str, unsigned hval)
+{
+	unsigned char* s = (unsigned char*)str;
+	while (*s) {
+		hval ^= (unsigned)*s++;
+		hval += (hval&lt;&lt;1) + (hval&lt;&lt;4) + (hval&lt;&lt;7) + (hval&lt;&lt;8) + (hval&lt;&lt;24);
+	}
+	return hval;
+}
+
+static unsigned hashmap_hash(void* buf, size_t len)
+{
+	return fnv_32a_buf(buf, len, FNV1_32A_INIT);
+}
+
+static int hashmap_key_compare(void* a, void* b, size_t size)
+{
+	return (memcmp(a, b, size) == 0);
+}
+
+static void hashmap_item_dtor(void* key, size_t key_size, void* value, size_t value_size)
+{
+	free(key);
+	free(value);
+}
+
+hashmap_t* hashmap_init(size_t key_size, size_t value_size, int nbuckets,
+			hashmap_item_dtor_t item_dtor, hashmap_key_compare_t key_compare,
+			hashmap_hash_t hash)
+{
+	hashmap_t* map = calloc(1, sizeof(hashmap_t));
+	map-&gt;nbuckets = nbuckets;
+	map-&gt;key_size = key_size;
+	map-&gt;value_size = value_size;
+	map-&gt;root = calloc(nbuckets, sizeof(hashmap_item_p));
+	map-&gt;item_dtor = item_dtor ? item_dtor : hashmap_item_dtor;
+	map-&gt;key_compare = key_compare ? key_compare : hashmap_key_compare;
+	map-&gt;hash = hash ? hash : hashmap_hash;
+	return map;
+}
+
+void hashmap_done(hashmap_t* map)
+{
+	int i;
+	// print stats
+	if (map-&gt;count &gt; 0 || map-&gt;hit_count + map-&gt;miss_count &gt; 0)
+		mp_msg(MSGT_ASS, MSGL_V, &quot;cache statistics: \n  total accesses: %d\n  hits: %d\n  misses: %d\n  object count: %d\n&quot;,
+		       map-&gt;hit_count + map-&gt;miss_count, map-&gt;hit_count, map-&gt;miss_count, map-&gt;count);
+	
+	for (i = 0; i &lt; map-&gt;nbuckets; ++i) {
+		hashmap_item_t* item = map-&gt;root[i];
+		while (item) {
+			hashmap_item_t* next = item-&gt;next;
+			map-&gt;item_dtor(item-&gt;key, map-&gt;key_size, item-&gt;value, map-&gt;value_size);
+			free(item);
+			item = next;
+		}
+	}
+	free(map-&gt;root);
+	free(map);
+}
+
+// does nothing if key already exists
+void* hashmap_insert(hashmap_t* map, void* key, void* value)
+{
+	unsigned hash = map-&gt;hash(key, map-&gt;key_size);
+	hashmap_item_t** next = map-&gt;root + (hash % map-&gt;nbuckets);
+	while (*next) {
+		if (map-&gt;key_compare(key, (*next)-&gt;key, map-&gt;key_size))
+			return (*next)-&gt;value;
+		next = &amp;((*next)-&gt;next);
+		assert(next);
+	}
+	(*next) = malloc(sizeof(hashmap_item_t));
+	(*next)-&gt;key = malloc(map-&gt;key_size);
+	(*next)-&gt;value = malloc(map-&gt;value_size);
+	memcpy((*next)-&gt;key, key, map-&gt;key_size);
+	memcpy((*next)-&gt;value, value, map-&gt;value_size);
+	(*next)-&gt;next = 0;
+
+	map-&gt;count ++;
+	return (*next)-&gt;value;
+}
+
+void* hashmap_find(hashmap_t* map, void* key)
+{
+	unsigned hash = map-&gt;hash(key, map-&gt;key_size);
+	hashmap_item_t* item = map-&gt;root[hash % map-&gt;nbuckets];
+	while (item) {
+		if (map-&gt;key_compare(key, item-&gt;key, map-&gt;key_size)) {
+			map-&gt;hit_count++;
+			return item-&gt;value;
+		}
+		item = item-&gt;next;
+	}
+	map-&gt;miss_count++;
+	return 0;
+}
+
+//---------------------------------
+// font cache
+
+hashmap_t* font_cache;
+
+static unsigned font_desc_hash(void* buf, size_t len)
+{
+	ass_font_desc_t* desc = buf;
+	unsigned hval;
+	hval = fnv_32a_str(desc-&gt;family, FNV1_32A_INIT);
+	hval = fnv_32a_buf(&amp;desc-&gt;bold, sizeof(desc-&gt;bold), hval);
+	hval = fnv_32a_buf(&amp;desc-&gt;italic, sizeof(desc-&gt;italic), hval);
+	return hval;
+}
+
+static int font_compare(void* key1, void* key2, size_t key_size) {
+	ass_font_desc_t* a = key1;
+	ass_font_desc_t* b = key2;
+	if (strcmp(a-&gt;family, b-&gt;family) != 0)
+		return 0;
+	if (a-&gt;bold != b-&gt;bold)
+		return 0;
+	if (a-&gt;italic != b-&gt;italic)
+		return 0;
+	return 1;
+}
+
+static void font_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
+{
+	ass_font_free(value);
+	free(key);
+}
+
+ass_font_t* ass_font_cache_find(ass_font_desc_t* desc)
+{
+	return hashmap_find(font_cache, desc);
+}
+
+/**
+ * \brief Add a face struct to cache.
+ * \param font font struct
+*/
+void* ass_font_cache_add(ass_font_t* font)
+{
+	return hashmap_insert(font_cache, &amp;(font-&gt;desc), font);
+}
+
+void ass_font_cache_init(void)
+{
+	font_cache = hashmap_init(sizeof(ass_font_desc_t),
+				  sizeof(ass_font_t),
+				  1000,
+				  font_hash_dtor, font_compare, font_desc_hash);
+}
+
+void ass_font_cache_done(void)
+{
+	hashmap_done(font_cache);
+}
+
+//---------------------------------
+// bitmap cache
+
+hashmap_t* bitmap_cache;
+
+static void bitmap_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
+{
+	bitmap_hash_val_t* v = value;
+	if (v-&gt;bm) ass_free_bitmap(v-&gt;bm);
+	if (v-&gt;bm_o) ass_free_bitmap(v-&gt;bm_o);
+	if (v-&gt;bm_s) ass_free_bitmap(v-&gt;bm_s);
+	free(key);
+	free(value);
+}
+
+void* cache_add_bitmap(bitmap_hash_key_t* key, bitmap_hash_val_t* val)
+{
+	return hashmap_insert(bitmap_cache, key, val);
+}
+
+/**
+ * \brief Get a bitmap from bitmap cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/ 
+bitmap_hash_val_t* cache_find_bitmap(bitmap_hash_key_t* key)
+{
+	return hashmap_find(bitmap_cache, key);
+}
+
+void ass_bitmap_cache_init(void)
+{
+	bitmap_cache = hashmap_init(sizeof(bitmap_hash_key_t),
+				   sizeof(bitmap_hash_val_t),
+				   0xFFFF + 13,
+				   bitmap_hash_dtor, NULL, NULL);
+}
+
+void ass_bitmap_cache_done(void)
+{
+	hashmap_done(bitmap_cache);
+}
+
+void ass_bitmap_cache_reset(void)
+{
+	ass_bitmap_cache_done();
+	ass_bitmap_cache_init();
+}
+
+//---------------------------------
+// glyph cache
+
+hashmap_t* glyph_cache;
+
+static void glyph_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
+{
+	glyph_hash_val_t* v = value;
+	if (v-&gt;glyph) FT_Done_Glyph(v-&gt;glyph);
+	if (v-&gt;outline_glyph) FT_Done_Glyph(v-&gt;outline_glyph);
+	free(key);
+	free(value);
+}
+
+void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val)
+{
+	return hashmap_insert(glyph_cache, key, val);
+}
+
+/**
+ * \brief Get a glyph from glyph cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/ 
+glyph_hash_val_t* cache_find_glyph(glyph_hash_key_t* key)
+{
+	return hashmap_find(glyph_cache, key);
+}
+
+void ass_glyph_cache_init(void)
+{
+	glyph_cache = hashmap_init(sizeof(glyph_hash_key_t),
+				   sizeof(glyph_hash_val_t),
+				   0xFFFF + 13,
+				   glyph_hash_dtor, NULL, NULL);
+}
+
+void ass_glyph_cache_done(void)
+{
+	hashmap_done(glyph_cache);
+}
+
+void ass_glyph_cache_reset(void)
+{
+	ass_glyph_cache_done();
+	ass_glyph_cache_init();
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_cache.h	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,98 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#ifndef ASS_CACHE_H
+#define ASS_CACHE_H
+
+void ass_font_cache_init(void);
+ass_font_t* ass_font_cache_find(ass_font_desc_t* desc);
+void* ass_font_cache_add(ass_font_t* font);
+void ass_font_cache_done(void);
+
+
+// describes a bitmap; bitmaps with equivalents structs are considered identical
+typedef struct bitmap_hash_key_s {
+	char bitmap; // bool : true = bitmap, false = outline
+	ass_font_t* font;
+	double size; // font size
+	uint32_t ch; // character code
+	unsigned outline; // border width, 16.16 fixed point value
+	int bold, italic;
+	char be; // blur edges
+
+	unsigned scale_x, scale_y; // 16.16
+	int frx, fry, frz; // signed 16.16
+	int shift_x, shift_y; // shift vector that was added to glyph before applying rotation
+	                      // = 0, if frx = fry = frx = 0
+	                      // = (glyph base point) - (rotation origin), otherwise
+	
+	FT_Vector advance; // subpixel shift vector
+} bitmap_hash_key_t;
+
+typedef struct bitmap_hash_val_s {
+	bitmap_t* bm; // the actual bitmaps
+	bitmap_t* bm_o;
+	bitmap_t* bm_s;
+} bitmap_hash_val_t;
+
+void ass_bitmap_cache_init(void);
+void* cache_add_bitmap(bitmap_hash_key_t* key, bitmap_hash_val_t* val);
+bitmap_hash_val_t* cache_find_bitmap(bitmap_hash_key_t* key);
+void ass_bitmap_cache_reset(void);
+void ass_bitmap_cache_done(void);
+
+// describes an outline glyph
+typedef struct glyph_hash_key_s {
+	ass_font_t* font;
+	double size; // font size
+	uint32_t ch; // character code
+	int bold, italic;
+	unsigned scale_x, scale_y; // 16.16
+	FT_Vector advance; // subpixel shift vector
+	unsigned outline; // border width, 16.16
+} glyph_hash_key_t;
+
+typedef struct glyph_hash_val_s {
+	FT_Glyph glyph;
+	FT_Glyph outline_glyph;
+	FT_BBox bbox_scaled; // bbox after scaling, but before rotation
+	FT_Vector advance; // 26.6, advance distance to the next bitmap in line
+} glyph_hash_val_t;
+
+void ass_glyph_cache_init(void);
+void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val);
+glyph_hash_val_t* cache_find_glyph(glyph_hash_key_t* key);
+void ass_glyph_cache_reset(void);
+void ass_glyph_cache_done(void);
+
+typedef struct hashmap_s hashmap_t; 
+typedef void (*hashmap_item_dtor_t)(void* key, size_t key_size, void* value, size_t value_size);
+typedef int (*hashmap_key_compare_t)(void* key1, void* key2, size_t key_size);
+typedef unsigned (*hashmap_hash_t)(void* key, size_t key_size);
+
+hashmap_t* hashmap_init(size_t key_size, size_t value_size, int nbuckets,
+			hashmap_item_dtor_t item_dtor, hashmap_key_compare_t key_compare,
+			hashmap_hash_t hash);
+void hashmap_done(hashmap_t* map);
+void* hashmap_insert(hashmap_t* map, void* key, void* value);
+void* hashmap_find(hashmap_t* map, void* key);
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.c	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,370 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+//#include &quot;config.h&quot;
+
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+#include FT_SYNTHESIS_H
+#include FT_GLYPH_H
+#include FT_TRUETYPE_TABLES_H
+
+#include &quot;ass.h&quot;
+#include &quot;ass_library.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_bitmap.h&quot;
+#include &quot;ass_cache.h&quot;
+#include &quot;ass_fontconfig.h&quot;
+#include &quot;ass_utils.h&quot;
+#include &quot;mputils.h&quot;
+
+/**
+ * Select Microfost Unicode CharMap, if the font has one.
+ * Otherwise, let FreeType decide.
+ */
+static void charmap_magic(FT_Face face)
+{
+	int i;
+	for (i = 0; i &lt; face-&gt;num_charmaps; ++i) {
+		FT_CharMap cmap = face-&gt;charmaps[i];
+		unsigned pid = cmap-&gt;platform_id;
+		unsigned eid = cmap-&gt;encoding_id;
+		if (pid == 3 /*microsoft*/ &amp;&amp; (eid == 1 /*unicode bmp*/ || eid == 10 /*full unicode*/)) {
+			FT_Set_Charmap(face, cmap);
+			return;
+		}
+	}
+
+	if (!face-&gt;charmap) {
+		if (face-&gt;num_charmaps == 0) {
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoCharmaps);
+			return;
+		}
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoCharmapAutodetected);
+		FT_Set_Charmap(face, face-&gt;charmaps[0]);
+		return;
+	}
+}
+
+static void update_transform(ass_font_t* font)
+{
+	int i;
+	FT_Matrix m;
+	m.xx = double_to_d16(font-&gt;scale_x);
+	m.yy = double_to_d16(font-&gt;scale_y);
+	m.xy = m.yx = 0;
+	for (i = 0; i &lt; font-&gt;n_faces; ++i)
+		FT_Set_Transform(font-&gt;faces[i], &amp;m, &amp;font-&gt;v);
+}
+
+/**
+ * \brief find a memory font by name
+ */
+static int find_font(ass_library_t* library, char* name)
+{
+	int i;
+	for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
+		if (strcasecmp(name, library-&gt;fontdata[i].name) == 0)
+			return i;
+	return -1;
+}
+
+static void face_set_size(FT_Face face, double size);
+
+static void buggy_font_workaround(FT_Face face)
+{
+	// Some fonts have zero Ascender/Descender fields in 'hhea' table.
+	// In this case, get the information from 'os2' table or, as
+	// a last resort, from face.bbox.
+	if (face-&gt;ascender + face-&gt;descender == 0 || face-&gt;height == 0) {
+		TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+		if (os2) {
+			face-&gt;ascender = os2-&gt;sTypoAscender;
+			face-&gt;descender = os2-&gt;sTypoDescender;
+			face-&gt;height = face-&gt;ascender - face-&gt;descender;
+		} else {
+			face-&gt;ascender = face-&gt;bbox.yMax;
+			face-&gt;descender = face-&gt;bbox.yMin;
+			face-&gt;height = face-&gt;ascender - face-&gt;descender;
+		}
+	}
+}
+
+/**
+ * \brief Select a face with the given charcode and add it to ass_font_t
+ * \return index of the new face in font-&gt;faces, -1 if failed
+ */
+static int add_face(void* fc_priv, ass_font_t* font, uint32_t ch)
+{
+	char* path;
+	int index;
+	FT_Face face;
+	int error;
+	int mem_idx;
+	
+	if (font-&gt;n_faces == ASS_FONT_MAX_FACES)
+		return -1;
+	
+	path = fontconfig_select(fc_priv, font-&gt;desc.family, font-&gt;desc.bold,
+					      font-&gt;desc.italic, &amp;index, ch);
+
+	mem_idx = find_font(font-&gt;library, path);
+	if (mem_idx &gt;= 0) {
+		error = FT_New_Memory_Face(font-&gt;ftlibrary, (unsigned char*)font-&gt;library-&gt;fontdata[mem_idx].data,
+					   font-&gt;library-&gt;fontdata[mem_idx].size, 0, &amp;face);
+		if (error) {
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningMemoryFont, path);
+			return -1;
+		}
+	} else {
+		error = FT_New_Face(font-&gt;ftlibrary, path, index, &amp;face);
+		if (error) {
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningFont, path, index);
+			return -1;
+		}
+	}
+	charmap_magic(face);
+	buggy_font_workaround(face);
+	
+	font-&gt;faces[font-&gt;n_faces++] = face;
+	update_transform(font);
+	face_set_size(face, font-&gt;size);
+	return font-&gt;n_faces - 1;
+}
+
+/**
+ * \brief Create a new ass_font_t according to &quot;desc&quot; argument
+ */
+ass_font_t* ass_font_new(ass_library_t* library, FT_Library ftlibrary, void* fc_priv, ass_font_desc_t* desc)
+{
+	int error;
+	ass_font_t* fontp;
+	ass_font_t font;
+
+	fontp = ass_font_cache_find(desc);
+	if (fontp)
+		return fontp;
+	
+	font.library = library;
+	font.ftlibrary = ftlibrary;
+	font.n_faces = 0;
+	font.desc.family = strdup(desc-&gt;family);
+	font.desc.bold = desc-&gt;bold;
+	font.desc.italic = desc-&gt;italic;
+
+	font.scale_x = font.scale_y = 1.;
+	font.v.x = font.v.y = 0;
+	font.size = 0.;
+
+	error = add_face(fc_priv, &amp;font, 0);
+	if (error == -1) {
+		free(font.desc.family);
+		return 0;
+	} else
+		return ass_font_cache_add(&amp;font);
+}
+
+/**
+ * \brief Set font transformation matrix and shift vector
+ **/
+void ass_font_set_transform(ass_font_t* font, double scale_x, double scale_y, FT_Vector* v)
+{
+	font-&gt;scale_x = scale_x;
+	font-&gt;scale_y = scale_y;
+	font-&gt;v.x = v-&gt;x;
+	font-&gt;v.y = v-&gt;y;
+	update_transform(font);
+}
+
+static void face_set_size(FT_Face face, double size)
+{
+#if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
+	TT_HoriHeader *hori = FT_Get_Sfnt_Table(face, ft_sfnt_hhea);
+	TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+	double mscale = 1.;
+	FT_Size_RequestRec rq;
+	FT_Size_Metrics *m = &amp;face-&gt;size-&gt;metrics;
+	// VSFilter uses metrics from TrueType OS/2 table
+	// The idea was borrowed from asa (<A HREF="http://asa.diac24.net">http://asa.diac24.net</A>)
+	if (hori &amp;&amp; os2) {
+		int hori_height = hori-&gt;Ascender - hori-&gt;Descender;
+		int os2_height = os2-&gt;usWinAscent + os2-&gt;usWinDescent;
+		if (hori_height &amp;&amp; os2_height)
+			mscale = (double)hori_height / os2_height;
+	}
+	memset(&amp;rq, 0, sizeof(rq));
+	rq.type = FT_SIZE_REQUEST_TYPE_REAL_DIM;
+	rq.width = 0;
+	rq.height = double_to_d6(size * mscale);
+	rq.horiResolution = rq.vertResolution = 0;
+	FT_Request_Size(face, &amp;rq);
+	m-&gt;ascender /= mscale;
+	m-&gt;descender /= mscale;
+	m-&gt;height /= mscale;
+#else
+	FT_Set_Char_Size(face, 0, double_to_d6(size), 0, 0);
+#endif
+}
+
+/**
+ * \brief Set font size
+ **/
+void ass_font_set_size(ass_font_t* font, double size)
+{
+	int i;
+	if (font-&gt;size != size) {
+		font-&gt;size = size;
+		for (i = 0; i &lt; font-&gt;n_faces; ++i)
+			face_set_size(font-&gt;faces[i], size);
+	}
+}
+
+/**
+ * \brief Get maximal font ascender and descender.
+ * \param ch character code
+ * The values are extracted from the font face that provides glyphs for the given character
+ **/
+void ass_font_get_asc_desc(ass_font_t* font, uint32_t ch, int* asc, int* desc)
+{
+	int i;
+	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+		FT_Face face = font-&gt;faces[i];
+		if (FT_Get_Char_Index(face, ch)) {
+			int v, v2;
+			v = face-&gt;size-&gt;metrics.ascender;
+			v2 = FT_MulFix(face-&gt;bbox.yMax, face-&gt;size-&gt;metrics.y_scale);
+			*asc = (v &gt; v2 * 0.9) ? v : v2;
+				
+			v = - face-&gt;size-&gt;metrics.descender;
+			v2 = - FT_MulFix(face-&gt;bbox.yMin, face-&gt;size-&gt;metrics.y_scale);
+			*desc = (v &gt; v2 * 0.9) ? v : v2;
+			return;
+		}
+	}
+	
+	*asc = *desc = 0;
+}
+
+/**
+ * \brief Get a glyph
+ * \param ch character code
+ **/
+FT_Glyph ass_font_get_glyph(void* fontconfig_priv, ass_font_t* font, uint32_t ch, ass_hinting_t hinting)
+{
+	int error;
+	int index = 0;
+	int i;
+	FT_Glyph glyph;
+	FT_Face face = 0;
+	int flags = 0;
+
+	if (ch &lt; 0x20)
+		return 0;
+	if (font-&gt;n_faces == 0)
+		return 0;
+
+	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+		face = font-&gt;faces[i];
+		index = FT_Get_Char_Index(face, ch);
+		if (index)
+			break;
+	}
+
+#ifdef HAVE_FONTCONFIG
+	if (index == 0) {
+		int face_idx;
+		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_GlyphNotFoundReselectingFont,
+		       ch, font-&gt;desc.family, font-&gt;desc.bold, font-&gt;desc.italic);
+		face_idx = add_face(fontconfig_priv, font, ch);
+		face = font-&gt;faces[face_idx];
+		index = FT_Get_Char_Index(face, ch);
+		if (index == 0) {
+			mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_GlyphNotFound,
+			       ch, font-&gt;desc.family, font-&gt;desc.bold, font-&gt;desc.italic);
+		}
+	}
+#endif
+
+	switch (hinting) {
+	case ASS_HINTING_NONE: flags = FT_LOAD_NO_HINTING; break;
+	case ASS_HINTING_LIGHT: flags = FT_LOAD_FORCE_AUTOHINT | FT_LOAD_TARGET_LIGHT; break;
+	case ASS_HINTING_NORMAL: flags = FT_LOAD_FORCE_AUTOHINT; break;
+	case ASS_HINTING_NATIVE: flags = 0; break;
+	}
+	
+	error = FT_Load_Glyph(face, index, FT_LOAD_NO_BITMAP | flags);
+	if (error) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
+		return 0;
+	}
+	
+#if (FREETYPE_MAJOR &gt; 2) || \
+    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt;= 2)) || \
+    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR == 1) &amp;&amp; (FREETYPE_PATCH &gt;= 10))
+// FreeType &gt;= 2.1.10 required
+	if (!(face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC) &amp;&amp; 
+			(font-&gt;desc.italic &gt; 55)) {
+		FT_GlyphSlot_Oblique(face-&gt;glyph);
+	}
+#endif
+	error = FT_Get_Glyph(face-&gt;glyph, &amp;glyph);
+	if (error) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
+		return 0;
+	}
+	
+	return glyph;
+}
+
+/**
+ * \brief Get kerning for the pair of glyphs.
+ **/
+FT_Vector ass_font_get_kerning(ass_font_t* font, uint32_t c1, uint32_t c2)
+{
+	FT_Vector v = {0, 0};
+	int i;
+
+	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+		FT_Face face = font-&gt;faces[i];
+		int i1 = FT_Get_Char_Index(face, c1);
+		int i2 = FT_Get_Char_Index(face, c2);
+		if (i1 &amp;&amp; i2) {
+			if (FT_HAS_KERNING(face))
+				FT_Get_Kerning(face, i1, i2, FT_KERNING_DEFAULT, &amp;v);
+			return v;
+		}
+		if (i1 || i2) // these glyphs are from different font faces, no kerning information
+			return v;
+	}
+	return v;
+}
+
+/**
+ * \brief Deallocate ass_font_t
+ **/
+void ass_font_free(ass_font_t* font)
+{
+	int i;
+	for (i = 0; i &lt; font-&gt;n_faces; ++i)
+		if (font-&gt;faces[i]) FT_Done_Face(font-&gt;faces[i]);
+	if (font-&gt;desc.family) free(font-&gt;desc.family);
+	free(font);
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_font.h	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,51 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#ifndef ASS_FONT_H
+#define ASS_FONT_H
+
+typedef struct ass_font_desc_s {
+	char* family;
+	unsigned bold;
+	unsigned italic;
+} ass_font_desc_t;
+
+#define ASS_FONT_MAX_FACES 10
+
+typedef struct ass_font_s {
+	ass_font_desc_t desc;
+	ass_library_t* library;
+	FT_Library ftlibrary;
+	FT_Face faces[ASS_FONT_MAX_FACES];
+	int n_faces;
+	double scale_x, scale_y; // current transform
+	FT_Vector v; // current shift
+	double size;
+} ass_font_t;
+
+ass_font_t* ass_font_new(ass_library_t* library, FT_Library ftlibrary, void* fc_priv, ass_font_desc_t* desc);
+void ass_font_set_transform(ass_font_t* font, double scale_x, double scale_y, FT_Vector* v);
+void ass_font_set_size(ass_font_t* font, double size);
+void ass_font_get_asc_desc(ass_font_t* font, uint32_t ch, int* asc, int* desc);
+FT_Glyph ass_font_get_glyph(void* fontconfig_priv, ass_font_t* font, uint32_t ch, ass_hinting_t hinting);
+FT_Vector ass_font_get_kerning(ass_font_t* font, uint32_t c1, uint32_t c2);
+void ass_font_free(ass_font_t* font);
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.c	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,413 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+//#include &quot;config.h&quot;
+
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+
+#include &quot;mputils.h&quot;
+#include &quot;ass.h&quot;
+#include &quot;ass_library.h&quot;
+#include &quot;ass_fontconfig.h&quot;
+
+#ifdef HAVE_FONTCONFIG
+#include &lt;fontconfig/fontconfig.h&gt;
+#include &lt;fontconfig/fcfreetype.h&gt;
+#endif
+
+struct fc_instance_s {
+#ifdef HAVE_FONTCONFIG
+	FcConfig* config;
+#endif
+	char* family_default;
+	char* path_default;
+	int index_default;
+};
+
+#ifdef HAVE_FONTCONFIG
+/**
+ * \brief Low-level font selection.
+ * \param priv private data
+ * \param family font family
+ * \param bold font weight value
+ * \param italic font slant value
+ * \param index out: font index inside a file
+ * \param code: the character that should be present in the font, can be 0
+ * \return font file path
+*/ 
+static char* _select_font(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
+			  uint32_t code)
+{
+	FcBool rc;
+	FcResult result;
+	FcPattern *pat = 0, *rpat;
+	int val_i;
+	FcChar8* val_s;
+	FcBool val_b;
+	FcCharSet* val_cs;
+	FcFontSet* fset = 0;
+	int curf;
+	char* retval = 0;
+	
+	*index = 0;
+
+	pat = FcPatternCreate();
+	if (!pat)
+		goto error;
+	
+	FcPatternAddString(pat, FC_FAMILY, (const FcChar8*)family);
+	FcPatternAddBool(pat, FC_OUTLINE, FcTrue);
+	FcPatternAddInteger(pat, FC_SLANT, italic);
+	FcPatternAddInteger(pat, FC_WEIGHT, bold);
+
+	FcDefaultSubstitute(pat);
+	
+	rc = FcConfigSubstitute(priv-&gt;config, pat, FcMatchPattern);
+	if (!rc)
+		goto error;
+
+	fset = FcFontSort(priv-&gt;config, pat, FcTrue, NULL, &amp;result);
+
+	for (curf = 0; curf &lt; fset-&gt;nfont; ++curf) {
+		rpat = fset-&gt;fonts[curf];
+		
+		result = FcPatternGetBool(rpat, FC_OUTLINE, 0, &amp;val_b);
+		if (result != FcResultMatch)
+			continue;
+		if (val_b != FcTrue)
+			continue;
+		if (!code)
+			break;
+		result = FcPatternGetCharSet(rpat, FC_CHARSET, 0, &amp;val_cs);
+		if (result != FcResultMatch)
+			continue;
+		if (FcCharSetHasChar(val_cs, code))
+			break;
+	}
+
+	if (curf &gt;= fset-&gt;nfont)
+		goto error;
+
+	rpat = fset-&gt;fonts[curf];
+	
+	result = FcPatternGetInteger(rpat, FC_INDEX, 0, &amp;val_i);
+	if (result != FcResultMatch)
+		goto error;
+	*index = val_i;
+
+	result = FcPatternGetString(rpat, FC_FAMILY, 0, &amp;val_s);
+	if (result != FcResultMatch)
+		goto error;
+
+	if (strcasecmp((const char*)val_s, family) != 0)
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_SelectedFontFamilyIsNotTheRequestedOne,
+				(const char*)val_s, family);
+
+	result = FcPatternGetString(rpat, FC_FILE, 0, &amp;val_s);
+	if (result != FcResultMatch)
+		goto error;
+	
+	retval = strdup((const char*)val_s);
+ error:
+	if (pat) FcPatternDestroy(pat);
+	if (fset) FcFontSetDestroy(fset);
+	return retval;
+}
+
+/**
+ * \brief Find a font. Use default family or path if necessary.
+ * \param priv_ private data
+ * \param family font family
+ * \param bold font weight value
+ * \param italic font slant value
+ * \param index out: font index inside a file
+ * \param code: the character that should be present in the font, can be 0
+ * \return font file path
+*/ 
+char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
+			uint32_t code)
+{
+	char* res = 0;
+	if (family &amp;&amp; *family)
+		res = _select_font(priv, family, bold, italic, index, code);
+	if (!res &amp;&amp; priv-&gt;family_default) {
+		res = _select_font(priv, priv-&gt;family_default, bold, italic, index, code);
+		if (res)
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFontFamily, 
+					family, bold, italic, res, *index);
+	}
+	if (!res &amp;&amp; priv-&gt;path_default) {
+		res = priv-&gt;path_default;
+		*index = priv-&gt;index_default;
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFont, 
+		       family, bold, italic, res, *index);
+	}
+	if (!res) {
+		res = _select_font(priv, &quot;Arial&quot;, bold, italic, index, code);
+		if (res)
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingArialFontFamily, 
+					family, bold, italic, res, *index);
+	}
+	if (res)
+		mp_msg(MSGT_ASS, MSGL_V, &quot;fontconfig_select: (%s, %d, %d) -&gt; %s, %d\n&quot;, 
+				family, bold, italic, res, *index);
+	return res;
+}
+
+#if (FC_VERSION &lt; 20402)
+static char* validate_fname(char* name)
+{
+	char* fname;
+	char* p;
+	char* q;
+	unsigned code;
+	int sz = strlen(name);
+
+	q = fname = malloc(sz + 1);
+	p = name;
+	while (*p) {
+		code = utf8_get_char(&amp;p);
+		if (code == 0)
+			break;
+		if (	(code &gt; 0x7F) ||
+			(code == '\\') ||
+			(code == '/') ||
+			(code == ':') ||
+			(code == '*') ||
+			(code == '?') ||
+			(code == '&lt;') ||
+			(code == '&gt;') ||
+			(code == '|') ||
+			(code == 0))
+		{
+			*q++ = '_';
+		} else {
+			*q++ = code;
+		}
+		if (p - name &gt; sz)
+			break;
+	}
+	*q = 0;
+	return fname;
+}
+#endif
+
+/**
+ * \brief Process memory font.
+ * \param priv private data
+ * \param library library object
+ * \param ftlibrary freetype library object
+ * \param idx index of the processed font in library-&gt;fontdata
+ * With FontConfig &gt;= 2.4.2, builds a font pattern in memory via FT_New_Memory_Face/FcFreeTypeQueryFace.
+ * With older FontConfig versions, save the font to ~/.mplayer/fonts.
+*/ 
+static void process_fontdata(fc_instance_t* priv, ass_library_t* library, FT_Library ftlibrary, int idx)
+{
+	int rc;
+	const char* name = library-&gt;fontdata[idx].name;
+	const char* data = library-&gt;fontdata[idx].data;
+	int data_size = library-&gt;fontdata[idx].size;
+
+#if (FC_VERSION &lt; 20402)
+	struct stat st;
+	char* fname;
+	const char* fonts_dir = library-&gt;fonts_dir;
+	char buf[1000];
+	FILE* fp = 0;
+
+	if (!fonts_dir)
+		return;
+	rc = stat(fonts_dir, &amp;st);
+	if (rc) {
+		int res;
+#ifndef __MINGW32__
+		res = mkdir(fonts_dir, 0700);
+#else
+		res = mkdir(fonts_dir);
+#endif
+		if (res) {
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FailedToCreateDirectory, fonts_dir);
+		}
+	} else if (!S_ISDIR(st.st_mode)) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NotADirectory, fonts_dir);
+	}
+	
+	fname = validate_fname((char*)name);
+
+	snprintf(buf, 1000, &quot;%s/%s&quot;, fonts_dir, fname);
+	free(fname);
+
+	fp = fopen(buf, &quot;wb&quot;);
+	if (!fp) return;
+
+	fwrite(data, data_size, 1, fp);
+	fclose(fp);
+
+#else // (FC_VERSION &gt;= 20402)
+	FT_Face face;
+	FcPattern* pattern;
+	FcFontSet* fset;
+	FcBool res;
+
+	rc = FT_New_Memory_Face(ftlibrary, (unsigned char*)data, data_size, 0, &amp;face);
+	if (rc) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningMemoryFont, name);
+		return;
+	}
+
+	pattern = FcFreeTypeQueryFace(face, (unsigned char*)name, 0, FcConfigGetBlanks(priv-&gt;config));
+	if (!pattern) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcFreeTypeQueryFace&quot;);
+		FT_Done_Face(face);
+		return;
+	}
+
+	fset = FcConfigGetFonts(priv-&gt;config, FcSetSystem); // somehow it failes when asked for FcSetApplication
+	if (!fset) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcConfigGetFonts&quot;);
+		FT_Done_Face(face);
+		return;
+	}
+
+	res = FcFontSetAdd(fset, pattern);
+	if (!res) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcFontSetAdd&quot;);
+		FT_Done_Face(face);
+		return;
+	}
+
+	FT_Done_Face(face);
+#endif
+}
+
+/**
+ * \brief Init fontconfig.
+ * \param library libass library object
+ * \param ftlibrary freetype library object
+ * \param family default font family
+ * \param path default font path
+ * \return pointer to fontconfig private data
+*/ 
+fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path)
+{
+	int rc;
+	fc_instance_t* priv = calloc(1, sizeof(fc_instance_t));
+	const char* dir = library-&gt;fonts_dir;
+	int i;
+	
+	rc = FcInit();
+	assert(rc);
+
+	priv-&gt;config = FcConfigGetCurrent();
+	if (!priv-&gt;config) {
+		mp_msg(MSGT_ASS, MSGL_FATAL, MSGTR_LIBASS_FcInitLoadConfigAndFontsFailed);
+		return 0;
+	}
+
+	for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
+		process_fontdata(priv, library, ftlibrary, i);
+
+	if (FcDirCacheValid((const FcChar8 *)dir) == FcFalse)
+	{
+		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_UpdatingFontCache);
+		if (FcGetVersion() &gt;= 20390 &amp;&amp; FcGetVersion() &lt; 20400)
+			mp_msg(MSGT_ASS, MSGL_WARN,
+			       MSGTR_LIBASS_BetaVersionsOfFontconfigAreNotSupported);
+		// FontConfig &gt;= 2.4.0 updates cache automatically in FcConfigAppFontAddDir()
+		if (FcGetVersion() &lt; 20390) {
+			FcFontSet* fcs;
+			FcStrSet* fss;
+			fcs = FcFontSetCreate();
+			fss = FcStrSetCreate();
+			rc = FcStrSetAdd(fss, (const FcChar8*)dir);
+			if (!rc) {
+				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcStrSetAddFailed);
+				goto ErrorFontCache;
+			}
+
+			rc = FcDirScan(fcs, fss, NULL, FcConfigGetBlanks(priv-&gt;config), (const FcChar8 *)dir, FcFalse);
+			if (!rc) {
+				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcDirScanFailed);
+				goto ErrorFontCache;
+			}
+
+			rc = FcDirSave(fcs, fss, (const FcChar8 *)dir);
+			if (!rc) {
+				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcDirSave);
+				goto ErrorFontCache;
+			}
+		ErrorFontCache:
+			;
+		}
+	}
+
+	rc = FcConfigAppFontAddDir(priv-&gt;config, (const FcChar8*)dir);
+	if (!rc) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcConfigAppFontAddDirFailed);
+	}
+
+	priv-&gt;family_default = family ? strdup(family) : 0;
+	priv-&gt;path_default = path ? strdup(path) : 0;
+	priv-&gt;index_default = 0;
+
+	return priv;
+}
+
+#else // HAVE_FONTCONFIG
+
+char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
+			uint32_t code)
+{
+	*index = priv-&gt;index_default;
+	return priv-&gt;path_default;
+}
+
+fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path)
+{
+	fc_instance_t* priv;
+
+	mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FontconfigDisabledDefaultFontWillBeUsed);
+	
+	priv = calloc(1, sizeof(fc_instance_t));
+	
+	priv-&gt;path_default = strdup(path);
+	priv-&gt;index_default = 0;
+	return priv;
+}
+
+#endif
+
+void fontconfig_done(fc_instance_t* priv)
+{
+	// don't call FcFini() here, library can still be used by some code
+	if (priv &amp;&amp; priv-&gt;path_default) free(priv-&gt;path_default);
+	if (priv &amp;&amp; priv-&gt;family_default) free(priv-&gt;family_default);
+	if (priv) free(priv);
+}
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_fontconfig.h	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,35 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#ifndef ASS_FONTCONFIG_H
+#define ASS_FONTCONFIG_H
+
+#ifdef HAVE_FONTCONFIG
+#include &lt;fontconfig/fontconfig.h&gt;
+#endif
+
+typedef struct fc_instance_s fc_instance_t;
+
+fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path);
+char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index, uint32_t code);
+void fontconfig_done(fc_instance_t* priv);
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.c	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,93 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include &lt;inttypes.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;ass.h&quot;
+#include &quot;ass_library.h&quot;
+
+
+ass_library_t* ass_library_init(void)
+{
+	return calloc(1, sizeof(ass_library_t));
+}
+
+void ass_library_done(ass_library_t* priv)
+{
+	if (priv) {
+		ass_set_fonts_dir(priv, NULL);
+		ass_set_style_overrides(priv, NULL);
+		free(priv);
+	}
+}
+
+void ass_set_fonts_dir(ass_library_t* priv, const char* fonts_dir)
+{
+	if (priv-&gt;fonts_dir)
+		free(priv-&gt;fonts_dir);
+
+	priv-&gt;fonts_dir = fonts_dir ? strdup(fonts_dir) : 0;
+}
+
+void ass_set_extract_fonts(ass_library_t* priv, int extract)
+{
+	priv-&gt;extract_fonts = !!extract;
+}
+
+void ass_set_style_overrides(ass_library_t* priv, char** list)
+{
+	char** p;
+	char** q;
+	int cnt;
+	
+	if (priv-&gt;style_overrides) {
+		for (p = priv-&gt;style_overrides; *p; ++p)
+			free(*p);
+		free(priv-&gt;style_overrides);
+	}
+	
+	if (!list) return;
+
+	for (p = list, cnt = 0; *p; ++p, ++cnt) {}
+
+	priv-&gt;style_overrides = malloc((cnt + 1) * sizeof(char*));
+	for (p = list, q = priv-&gt;style_overrides; *p; ++p, ++q)
+		*q = strdup(*p);
+	priv-&gt;style_overrides[cnt] = NULL;
+}
+
+static void grow_array(void **array, int nelem, size_t elsize)
+{
+	if (!(nelem &amp; 31))
+		*array = realloc(*array, (nelem + 32) * elsize);
+}
+
+void ass_add_font(ass_library_t* priv, char* name, char* data, int size)
+{
+	grow_array((void**)&amp;priv-&gt;fontdata, priv-&gt;num_fontdata, sizeof(*priv-&gt;fontdata));
+	priv-&gt;fontdata[priv-&gt;num_fontdata].name = name;
+	priv-&gt;fontdata[priv-&gt;num_fontdata].data = data;
+	priv-&gt;fontdata[priv-&gt;num_fontdata].size = size;
+	priv-&gt;num_fontdata ++;
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_library.h	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,40 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#ifndef ASS_LIBRARY_H
+#define ASS_LIBRARY_H
+
+typedef struct ass_fontdata_s {
+	char* name;
+	char* data;
+	int size;
+} ass_fontdata_t;
+
+struct ass_library_s {
+	char* fonts_dir;
+	int extract_fonts;
+	char** style_overrides;
+
+	ass_fontdata_t* fontdata;
+	int num_fontdata;
+};
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_render.c	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,2399 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+//#include &quot;config.h&quot;
+
+#include &lt;assert.h&gt;
+#include &lt;math.h&gt;
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+#include FT_STROKER_H
+#include FT_GLYPH_H
+#include FT_SYNTHESIS_H
+
+#include &quot;mputils.h&quot;
+
+#include &quot;ass.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_bitmap.h&quot;
+#include &quot;ass_cache.h&quot;
+#include &quot;ass_utils.h&quot;
+#include &quot;ass_fontconfig.h&quot;
+#include &quot;ass_library.h&quot;
+
+#define MAX_GLYPHS 1000
+#define MAX_LINES 100
+
+static int last_render_id = 0;
+
+typedef struct ass_settings_s {
+	int frame_width;
+	int frame_height;
+	double font_size_coeff; // font size multiplier
+	double line_spacing; // additional line spacing (in frame pixels)
+	int top_margin; // height of top margin. Everything except toptitles is shifted down by top_margin.
+	int bottom_margin; // height of bottom margin. (frame_height - top_margin - bottom_margin) is original video height.
+	int left_margin;
+	int right_margin;
+	int use_margins; // 0 - place all subtitles inside original frame
+	                 // 1 - use margins for placing toptitles and subtitles
+	double aspect; // frame aspect ratio, d_width / d_height.
+	ass_hinting_t hinting;
+
+	char* default_font;
+	char* default_family;
+} ass_settings_t;
+
+// a rendered event
+typedef struct event_images_s {
+	ass_image_t* imgs;
+	int top, height;
+	int detect_collisions;
+	int shift_direction;
+	ass_event_t* event;
+} event_images_t;
+
+struct ass_renderer_s {
+	ass_library_t* library;
+	FT_Library ftlibrary;
+	fc_instance_t* fontconfig_priv;
+	ass_settings_t settings;
+	int render_id;
+	ass_synth_priv_t* synth_priv;
+
+	ass_image_t* images_root; // rendering result is stored here
+	ass_image_t* prev_images_root;
+
+	event_images_t* eimg; // temporary buffer for sorting rendered events
+	int eimg_size; // allocated buffer size
+};
+
+typedef enum {EF_NONE = 0, EF_KARAOKE, EF_KARAOKE_KF, EF_KARAOKE_KO} effect_t;
+
+// describes a glyph
+// glyph_info_t and text_info_t are used for text centering and word-wrapping operations
+typedef struct glyph_info_s {
+	unsigned symbol;
+	FT_Glyph glyph;
+	FT_Glyph outline_glyph;
+	bitmap_t* bm; // glyph bitmap
+	bitmap_t* bm_o; // outline bitmap
+	bitmap_t* bm_s; // shadow bitmap
+	FT_BBox bbox;
+	FT_Vector pos;
+	char linebreak; // the first (leading) glyph of some line ?
+	uint32_t c[4]; // colors
+	FT_Vector advance; // 26.6
+	effect_t effect_type;
+	int effect_timing; // time duration of current karaoke word
+	                   // after process_karaoke_effects: distance in pixels from the glyph origin.
+	                   // part of the glyph to the left of it is displayed in a different color.
+	int effect_skip_timing; // delay after the end of last karaoke word
+	int asc, desc; // font max ascender and descender
+//	int height;
+	int be; // blur edges
+	int shadow;
+	double frx, fry, frz; // rotation
+	
+	bitmap_hash_key_t hash_key;
+} glyph_info_t;
+
+typedef struct line_info_s {
+	int asc, desc;
+} line_info_t;
+
+typedef struct text_info_s {
+	glyph_info_t* glyphs;
+	int length;
+	line_info_t lines[MAX_LINES];
+	int n_lines;
+	int height;
+} text_info_t;
+
+
+// Renderer state.
+// Values like current font face, color, screen position, clipping and so on are stored here.
+typedef struct render_context_s {
+	ass_event_t* event;
+	ass_style_t* style;
+	
+	ass_font_t* font;
+	char* font_path;
+	double font_size;
+	
+	FT_Stroker stroker;
+	int alignment; // alignment overrides go here; if zero, style value will be used
+	double frx, fry, frz;
+	enum {	EVENT_NORMAL, // &quot;normal&quot; top-, sub- or mid- title
+		EVENT_POSITIONED, // happens after pos(,), margins are ignored
+		EVENT_HSCROLL, // &quot;Banner&quot; transition effect, text_width is unlimited
+		EVENT_VSCROLL // &quot;Scroll up&quot;, &quot;Scroll down&quot; transition effects
+		} evt_type;
+	int pos_x, pos_y; // position
+	int org_x, org_y; // origin
+	char have_origin; // origin is explicitly defined; if 0, get_base_point() is used
+	double scale_x, scale_y;
+	double hspacing; // distance between letters, in pixels
+	double border; // outline width
+	uint32_t c[4]; // colors(Primary, Secondary, so on) in RGBA
+	int clip_x0, clip_y0, clip_x1, clip_y1;
+	char detect_collisions;
+	uint32_t fade; // alpha from \fad
+	char be; // blur edges
+	int shadow;
+
+	effect_t effect_type;
+	int effect_timing;
+	int effect_skip_timing;
+
+	enum { SCROLL_LR, // left-to-right
+	       SCROLL_RL,
+	       SCROLL_TB, // top-to-bottom
+	       SCROLL_BT
+	       } scroll_direction; // for EVENT_HSCROLL, EVENT_VSCROLL
+	int scroll_shift;
+
+	// face properties
+	char* family;
+	unsigned bold;
+	unsigned italic;
+	
+} render_context_t;
+
+// frame-global data
+typedef struct frame_context_s {
+	ass_renderer_t* ass_priv;
+	int width, height; // screen dimensions
+	int orig_height; // frame height ( = screen height - margins )
+	int orig_width; // frame width ( = screen width - margins )
+	ass_track_t* track;
+	long long time; // frame's timestamp, ms
+	double font_scale;
+	double font_scale_x; // x scale applied to all glyphs to preserve text aspect ratio
+	double border_scale;
+} frame_context_t;
+
+static ass_renderer_t* ass_renderer;
+static ass_settings_t* global_settings;
+static text_info_t text_info;
+static render_context_t render_context;
+static frame_context_t frame_context;
+
+struct render_priv_s {
+	int top, height;
+	int render_id;
+};
+
+static void ass_lazy_track_init(void)
+{
+	ass_track_t* track = frame_context.track;
+	if (track-&gt;PlayResX &amp;&amp; track-&gt;PlayResY)
+		return;
+	if (!track-&gt;PlayResX &amp;&amp; !track-&gt;PlayResY) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NeitherPlayResXNorPlayResYDefined);
+		track-&gt;PlayResX = 384;
+		track-&gt;PlayResY = 288;
+	} else {
+		double orig_aspect = (global_settings-&gt;aspect * frame_context.height * frame_context.orig_width) /
+			frame_context.orig_height / frame_context.width;
+		if (!track-&gt;PlayResY) {
+			track-&gt;PlayResY = track-&gt;PlayResX / orig_aspect + .5;
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_PlayResYUndefinedSettingY, track-&gt;PlayResY);
+		} else if (!track-&gt;PlayResX) {
+			track-&gt;PlayResX = track-&gt;PlayResY * orig_aspect + .5;
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_PlayResXUndefinedSettingX, track-&gt;PlayResX);
+		}
+	}
+}
+
+ass_renderer_t* ass_renderer_init(ass_library_t* library)
+{
+	int error;
+	FT_Library ft;
+	ass_renderer_t* priv = 0;
+	
+	memset(&amp;render_context, 0, sizeof(render_context));
+	memset(&amp;frame_context, 0, sizeof(frame_context));
+	memset(&amp;text_info, 0, sizeof(text_info));
+
+	error = FT_Init_FreeType( &amp;ft );
+	if ( error ) { 
+		mp_msg(MSGT_ASS, MSGL_FATAL, MSGTR_LIBASS_FT_Init_FreeTypeFailed);
+		goto ass_init_exit;
+	}
+
+	priv = calloc(1, sizeof(ass_renderer_t));
+	if (!priv) {
+		FT_Done_FreeType(ft);
+		goto ass_init_exit;
+	}
+
+	priv-&gt;synth_priv = ass_synth_init();
+
+	priv-&gt;library = library;
+	priv-&gt;ftlibrary = ft;
+	// images_root and related stuff is zero-filled in calloc
+	
+	ass_font_cache_init();
+	ass_bitmap_cache_init();
+	ass_glyph_cache_init();
+
+	text_info.glyphs = calloc(MAX_GLYPHS, sizeof(glyph_info_t));
+	
+ass_init_exit:
+	if (priv) mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_Init);
+	else mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_InitFailed);
+
+	return priv;
+}
+
+void ass_renderer_done(ass_renderer_t* priv)
+{
+	ass_font_cache_done();
+	ass_bitmap_cache_done();
+	ass_glyph_cache_done();
+	if (render_context.stroker) {
+		FT_Stroker_Done(render_context.stroker);
+		render_context.stroker = 0;
+	}
+	if (priv &amp;&amp; priv-&gt;ftlibrary) FT_Done_FreeType(priv-&gt;ftlibrary);
+	if (priv &amp;&amp; priv-&gt;fontconfig_priv) fontconfig_done(priv-&gt;fontconfig_priv);
+	if (priv &amp;&amp; priv-&gt;synth_priv) ass_synth_done(priv-&gt;synth_priv);
+	if (priv &amp;&amp; priv-&gt;eimg) free(priv-&gt;eimg);
+	if (priv) free(priv);
+	if (text_info.glyphs) free(text_info.glyphs);
+}
+
+/**
+ * \brief Create a new ass_image_t
+ * Parameters are the same as ass_image_t fields.
+ */
+static ass_image_t* my_draw_bitmap(unsigned char* bitmap, int bitmap_w, int bitmap_h, int stride, int dst_x, int dst_y, uint32_t color)
+{
+	ass_image_t* img = calloc(1, sizeof(ass_image_t));
+	
+	img-&gt;w = bitmap_w;
+	img-&gt;h = bitmap_h;
+	img-&gt;stride = stride;
+	img-&gt;bitmap = bitmap;
+	img-&gt;color = color;
+	img-&gt;dst_x = dst_x;
+	img-&gt;dst_y = dst_y;
+
+	return img;
+}
+
+/**
+ * \brief convert bitmap glyph into ass_image_t struct(s)
+ * \param bit freetype bitmap glyph, FT_PIXEL_MODE_GRAY
+ * \param dst_x bitmap x coordinate in video frame
+ * \param dst_y bitmap y coordinate in video frame
+ * \param color first color, RGBA
+ * \param color2 second color, RGBA
+ * \param brk x coordinate relative to glyph origin, color is used to the left of brk, color2 - to the right
+ * \param tail pointer to the last image's next field, head of the generated list should be stored here
+ * \return pointer to the new list tail
+ * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.
+ */
+static ass_image_t** render_glyph(bitmap_t* bm, int dst_x, int dst_y, uint32_t color, uint32_t color2, int brk, ass_image_t** tail)
+{
+	// brk is relative to dst_x
+	// color = color left of brk
+	// color2 = color right of brk
+	int b_x0, b_y0, b_x1, b_y1; // visible part of the bitmap
+	int clip_x0, clip_y0, clip_x1, clip_y1;
+	int tmp;
+	ass_image_t* img;
+
+	dst_x += bm-&gt;left;
+	dst_y += bm-&gt;top;
+	brk -= bm-&gt;left;
+	
+	// clipping
+	clip_x0 = render_context.clip_x0;
+	clip_y0 = render_context.clip_y0;
+	clip_x1 = render_context.clip_x1;
+	clip_y1 = render_context.clip_y1;
+	b_x0 = 0;
+	b_y0 = 0;
+	b_x1 = bm-&gt;w;
+	b_y1 = bm-&gt;h;
+	
+	tmp = dst_x - clip_x0;
+	if (tmp &lt; 0) {
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip left\n&quot;);
+		b_x0 = - tmp;
+	}
+	tmp = dst_y - clip_y0;
+	if (tmp &lt; 0) {
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip top\n&quot;);
+		b_y0 = - tmp;
+	}
+	tmp = clip_x1 - dst_x - bm-&gt;w;
+	if (tmp &lt; 0) {
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip right\n&quot;);
+		b_x1 = bm-&gt;w + tmp;
+	}
+	tmp = clip_y1 - dst_y - bm-&gt;h;
+	if (tmp &lt; 0) {
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip bottom\n&quot;);
+		b_y1 = bm-&gt;h + tmp;
+	}
+	
+	if ((b_y0 &gt;= b_y1) || (b_x0 &gt;= b_x1))
+		return tail;
+
+	if (brk &gt; b_x0) { // draw left part
+		if (brk &gt; b_x1) brk = b_x1;
+		img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;w * b_y0 + b_x0, 
+			brk - b_x0, b_y1 - b_y0, bm-&gt;w,
+			dst_x + b_x0, dst_y + b_y0, color);
+		*tail = img;
+		tail = &amp;img-&gt;next;
+	}
+	if (brk &lt; b_x1) { // draw right part
+		if (brk &lt; b_x0) brk = b_x0;
+		img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;w * b_y0 + brk, 
+			b_x1 - brk, b_y1 - b_y0, bm-&gt;w,
+			dst_x + brk, dst_y + b_y0, color2);
+		*tail = img;
+		tail = &amp;img-&gt;next;
+	}
+	return tail;
+}
+
+/**
+ * \brief Convert text_info_t struct to ass_image_t list
+ * Splits glyphs in halves when needed (for \kf karaoke).
+ */
+static ass_image_t* render_text(text_info_t* text_info, int dst_x, int dst_y)
+{
+	int pen_x, pen_y;
+	int i;
+	bitmap_t* bm;
+	ass_image_t* head;
+	ass_image_t** tail = &head;
+
+	for (i = 0; i &lt; text_info-&gt;length; ++i) {
+		glyph_info_t* info = text_info-&gt;glyphs + i;
+		if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_s || (info-&gt;shadow == 0))
+			continue;
+
+		pen_x = dst_x + info-&gt;pos.x + info-&gt;shadow;
+		pen_y = dst_y + info-&gt;pos.y + info-&gt;shadow;
+		bm = info-&gt;bm_s;
+
+		tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[3], 0, 1000000, tail);
+	}
+
+	for (i = 0; i &lt; text_info-&gt;length; ++i) {
+		glyph_info_t* info = text_info-&gt;glyphs + i;
+		if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_o)
+			continue;
+
+		pen_x = dst_x + info-&gt;pos.x;
+		pen_y = dst_y + info-&gt;pos.y;
+		bm = info-&gt;bm_o;
+		
+		if ((info-&gt;effect_type == EF_KARAOKE_KO) &amp;&amp; (info-&gt;effect_timing &lt;= info-&gt;bbox.xMax)) {
+			// do nothing
+		} else
+			tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[2], 0, 1000000, tail);
+	}
+	for (i = 0; i &lt; text_info-&gt;length; ++i) {
+		glyph_info_t* info = text_info-&gt;glyphs + i;
+		if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm)
+			continue;
+
+		pen_x = dst_x + info-&gt;pos.x;
+		pen_y = dst_y + info-&gt;pos.y;
+		bm = info-&gt;bm;
+
+		if ((info-&gt;effect_type == EF_KARAOKE) || (info-&gt;effect_type == EF_KARAOKE_KO)) {
+			if (info-&gt;effect_timing &gt; info-&gt;bbox.xMax)
+				tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[0], 0, 1000000, tail);
+			else
+				tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[1], 0, 1000000, tail);
+		} else if (info-&gt;effect_type == EF_KARAOKE_KF) {
+			tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[0], info-&gt;c[1], info-&gt;effect_timing, tail);
+		} else
+			tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[0], 0, 1000000, tail);
+	}
+
+	*tail = 0;
+	return head;
+}
+
+/**
+ * \brief Mapping between script and screen coordinates
+ */
+static int x2scr(int x) {
+	return x*frame_context.orig_width / frame_context.track-&gt;PlayResX + global_settings-&gt;left_margin;
+}
+/**
+ * \brief Mapping between script and screen coordinates
+ */
+static int y2scr(int y) {
+	return y * frame_context.orig_height / frame_context.track-&gt;PlayResY + global_settings-&gt;top_margin;
+}
+// the same for toptitles
+static int y2scr_top(int y) {
+	if (global_settings-&gt;use_margins)
+		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY;
+	else
+		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY + global_settings-&gt;top_margin;
+}
+// the same for subtitles
+static int y2scr_sub(int y) {
+	if (global_settings-&gt;use_margins)
+		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY +
+		       global_settings-&gt;top_margin + global_settings-&gt;bottom_margin;
+	else
+		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY + global_settings-&gt;top_margin;
+}
+
+static void compute_string_bbox( text_info_t* info, FT_BBox *abbox ) {
+	FT_BBox bbox;
+	int i;
+	
+	if (text_info.length &gt; 0) {
+		bbox.xMin = 32000;
+		bbox.xMax = -32000;
+		bbox.yMin = - d6_to_int(text_info.lines[0].asc) + text_info.glyphs[0].pos.y;
+		bbox.yMax = d6_to_int(text_info.height - text_info.lines[0].asc) + text_info.glyphs[0].pos.y;
+
+		for (i = 0; i &lt; text_info.length; ++i) {
+			int s = text_info.glyphs[i].pos.x;
+			int e = s + d6_to_int(text_info.glyphs[i].advance.x);
+			bbox.xMin = FFMIN(bbox.xMin, s);
+			bbox.xMax = FFMAX(bbox.xMax, e);
+		}
+	} else
+		bbox.xMin = bbox.xMax = bbox.yMin = bbox.yMax = 0;
+
+	/* return string bbox */
+	*abbox = bbox;
+}
+
+
+/**
+ * \brief Check if starting part of (*p) matches sample. If true, shift p to the first symbol after the matching part.
+ */
+static inline int mystrcmp(char** p, const char* sample) {
+	int len = strlen(sample);
+	if (strncmp(*p, sample, len) == 0) {
+		(*p) += len;
+		return 1;
+	} else
+		return 0;
+}
+
+static void change_font_size(double sz)
+{
+	double size = sz * frame_context.font_scale;
+
+	if (size &lt; 1)
+		size = 1;
+	else if (size &gt; frame_context.height * 2)
+		size = frame_context.height * 2;
+
+	ass_font_set_size(render_context.font, size);
+
+	render_context.font_size = sz;
+}
+
+/**
+ * \brief Change current font, using setting from render_context.
+ */
+static void update_font(void)
+{
+	unsigned val;
+	ass_renderer_t* priv = frame_context.ass_priv;
+	ass_font_desc_t desc;
+	desc.family = strdup(render_context.family);
+
+	val = render_context.bold;
+	// 0 = normal, 1 = bold, &gt;1 = exact weight
+	if (val == 0) val = 80; // normal
+	else if (val == 1) val = 200; // bold
+	desc.bold = val;
+
+	val = render_context.italic;
+	if (val == 0) val = 0; // normal
+	else if (val == 1) val = 110; //italic
+	desc.italic = val;
+
+	render_context.font = ass_font_new(priv-&gt;library, priv-&gt;ftlibrary, priv-&gt;fontconfig_priv, &amp;desc);
+	free(desc.family);
+	
+	if (render_context.font)
+		change_font_size(render_context.font_size);
+}
+
+/**
+ * \brief Change border width
+ * negative value resets border to style value
+ */
+static void change_border(double border)
+{
+	int b;
+	if (!render_context.font) return;
+
+	if (border &lt; 0) {
+		if (render_context.style-&gt;BorderStyle == 1) {
+			if (render_context.style-&gt;Outline == 0 &amp;&amp; render_context.style-&gt;Shadow &gt; 0)
+				border = 1.;
+			else
+				border = render_context.style-&gt;Outline;
+		} else
+			border = 1.;
+	}
+	render_context.border = border;
+
+	b = 64 * border * frame_context.border_scale;
+	if (b &gt; 0) {
+		if (!render_context.stroker) {
+			int error;
+#if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
+			error = FT_Stroker_New( ass_renderer-&gt;ftlibrary, &amp;render_context.stroker );
+#else // &lt; 2.2
+			error = FT_Stroker_New( render_context.font-&gt;faces[0]-&gt;memory, &amp;render_context.stroker );
+#endif
+			if (error) {
+				mp_msg(MSGT_ASS, MSGL_V, &quot;failed to get stroker\n&quot;);
+				render_context.stroker = 0;
+			}
+		}
+		if (render_context.stroker)
+			FT_Stroker_Set( render_context.stroker, b,
+					FT_STROKER_LINECAP_ROUND,
+					FT_STROKER_LINEJOIN_ROUND,
+					0 );
+	} else {
+		FT_Stroker_Done(render_context.stroker);
+		render_context.stroker = 0;
+	}
+}
+
+#define _r(c)  ((c)&gt;&gt;24)
+#define _g(c)  (((c)&gt;&gt;16)&amp;0xFF)
+#define _b(c)  (((c)&gt;&gt;8)&amp;0xFF)
+#define _a(c)  ((c)&amp;0xFF)
+
+/**
+ * \brief Calculate a weighted average of two colors
+ * calculates c1*(1-a) + c2*a, but separately for each component except alpha
+ */
+static void change_color(uint32_t* var, uint32_t new, double pwr)
+{
+	(*var)= ((uint32_t)(_r(*var) * (1 - pwr) + _r(new) * pwr) &lt;&lt; 24) +
+		((uint32_t)(_g(*var) * (1 - pwr) + _g(new) * pwr) &lt;&lt; 16) +
+		((uint32_t)(_b(*var) * (1 - pwr) + _b(new) * pwr) &lt;&lt; 8) +
+		_a(*var);
+}
+
+// like change_color, but for alpha component only
+static void change_alpha(uint32_t* var, uint32_t new, double pwr)
+{
+	*var = (_r(*var) &lt;&lt; 24) + (_g(*var) &lt;&lt; 16) + (_b(*var) &lt;&lt; 8) + (_a(*var) * (1 - pwr) + _a(new) * pwr);
+}
+
+/**
+ * \brief Multiply two alpha values
+ * \param a first value
+ * \param b second value
+ * \return result of multiplication
+ * Parameters and result are limited by 0xFF.
+ */
+static uint32_t mult_alpha(uint32_t a, uint32_t b)
+{
+	return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;
+}
+
+/**
+ * \brief Calculate alpha value by piecewise linear function
+ * Used for \fad, \fade implementation.
+ */
+static unsigned interpolate_alpha(long long now, 
+		long long t1, long long t2, long long t3, long long t4,
+		unsigned a1, unsigned a2, unsigned a3)
+{
+	unsigned a;
+	double cf;
+	if (now &lt;= t1) {
+		a = a1;
+	} else if (now &gt;= t4) {
+		a = a3;
+	} else if (now &lt; t2) { // and &gt; t1
+		cf = ((double)(now - t1)) / (t2 - t1);
+		a = a1 * (1 - cf) + a2 * cf;
+	} else if (now &gt; t3) {
+		cf = ((double)(now - t3)) / (t4 - t3);
+		a = a2 * (1 - cf) + a3 * cf;
+	} else { // t2 &lt;= now &lt;= t3
+		a = a2;
+	}
+
+	return a;
+}
+
+static void reset_render_context(void);
+
+/**
+ * \brief Parse style override tag.
+ * \param p string to parse
+ * \param pwr multiplier for some tag effects (comes from \t tags)
+ */
+static char* parse_tag(char* p, double pwr) {
+#define skip_all(x) if (*p == (x)) ++p; else { \
+	while ((*p != (x)) &amp;&amp; (*p != '}') &amp;&amp; (*p != 0)) {++p;} }
+#define skip(x) if (*p == (x)) ++p; else { return p; }
+	
+	skip_all('\\');
+	if ((*p == '}') || (*p == 0))
+		return p;
+
+	if (mystrcmp(&amp;p, &quot;fsc&quot;)) {
+		char tp = *p++;
+		double val;
+		if (tp == 'x') {
+			if (mystrtod(&amp;p, &amp;val)) {
+				val /= 100;
+				render_context.scale_x = render_context.scale_x * ( 1 - pwr) + val * pwr;
+			} else
+				render_context.scale_x = render_context.style-&gt;ScaleX;
+		} else if (tp == 'y') {
+			if (mystrtod(&amp;p, &amp;val)) {
+				val /= 100;
+				render_context.scale_y = render_context.scale_y * ( 1 - pwr) + val * pwr;
+			} else
+				render_context.scale_y = render_context.style-&gt;ScaleY;
+		}
+	} else if (mystrcmp(&amp;p, &quot;fsp&quot;)) {
+		double val;
+		if (mystrtod(&amp;p, &amp;val))
+			render_context.hspacing = render_context.hspacing * ( 1 - pwr ) + val * pwr;
+		else
+			render_context.hspacing = render_context.style-&gt;Spacing;
+	} else if (mystrcmp(&amp;p, &quot;fs&quot;)) {
+		double val;
+		if (mystrtod(&amp;p, &amp;val))
+			val = render_context.font_size * ( 1 - pwr ) + val * pwr;
+		else
+			val = render_context.style-&gt;FontSize;
+		if (render_context.font)
+			change_font_size(val);
+	} else if (mystrcmp(&amp;p, &quot;bord&quot;)) {
+		double val;
+		if (mystrtod(&amp;p, &amp;val))
+			val = render_context.border * ( 1 - pwr ) + val * pwr;
+		else
+			val = -1.; // reset to default
+		change_border(val);
+	} else if (mystrcmp(&amp;p, &quot;move&quot;)) {
+		int x1, x2, y1, y2;
+		long long t1, t2, delta_t, t;
+		int x, y;
+		double k;
+		skip('(');
+		x1 = strtol(p, &amp;p, 10);
+		skip(',');
+		y1 = strtol(p, &amp;p, 10);
+		skip(',');
+		x2 = strtol(p, &amp;p, 10);
+		skip(',');
+		y2 = strtol(p, &amp;p, 10);
+		if (*p == ',') {
+			skip(',');
+			t1 = strtoll(p, &amp;p, 10);
+			skip(',');
+			t2 = strtoll(p, &amp;p, 10);
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;movement6: (%d, %d) -&gt; (%d, %d), (%&quot; PRId64 &quot; .. %&quot; PRId64 &quot;)\n&quot;, 
+				x1, y1, x2, y2, (int64_t)t1, (int64_t)t2);
+		} else {
+			t1 = 0;
+			t2 = render_context.event-&gt;Duration;
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;movement: (%d, %d) -&gt; (%d, %d)\n&quot;, x1, y1, x2, y2);
+		}
+		skip(')');
+		delta_t = t2 - t1;
+		t = frame_context.time - render_context.event-&gt;Start;
+		if (t &lt; t1)
+			k = 0.;
+		else if (t &gt; t2)
+			k = 1.;
+		else k = ((double)(t - t1)) / delta_t;
+		x = k * (x2 - x1) + x1;
+		y = k * (y2 - y1) + y1;
+		render_context.pos_x = x;
+		render_context.pos_y = y;
+		render_context.detect_collisions = 0;
+		render_context.evt_type = EVENT_POSITIONED;
+	} else if (mystrcmp(&amp;p, &quot;frx&quot;)) {
+		double val;
+		if (mystrtod(&amp;p, &amp;val)) {
+			val *= M_PI / 180;
+			render_context.frx = val * pwr + render_context.frx * (1-pwr);
+		} else
+			render_context.frx = 0.;
+	} else if (mystrcmp(&amp;p, &quot;fry&quot;)) {
+		double val;
+		if (mystrtod(&amp;p, &amp;val)) {
+			val *= M_PI / 180;
+			render_context.fry = val * pwr + render_context.fry * (1-pwr);
+		} else
+			render_context.fry = 0.;
+	} else if (mystrcmp(&amp;p, &quot;frz&quot;) || mystrcmp(&amp;p, &quot;fr&quot;)) {
+		double val;
+		if (mystrtod(&amp;p, &amp;val)) {
+			val *= M_PI / 180;
+			render_context.frz = val * pwr + render_context.frz * (1-pwr);
+		} else
+			render_context.frz = M_PI * render_context.style-&gt;Angle / 180.;
+	} else if (mystrcmp(&amp;p, &quot;fn&quot;)) {
+		char* start = p;
+		char* family;
+		skip_all('\\');
+		if (p &gt; start) {
+			family = malloc(p - start + 1);
+			strncpy(family, start, p - start);
+			family[p - start] = '\0';
+		} else
+			family = strdup(render_context.style-&gt;FontName);
+		if (render_context.family)
+			free(render_context.family);
+		render_context.family = family;
+		update_font();
+	} else if (mystrcmp(&amp;p, &quot;alpha&quot;)) {
+		uint32_t val;
+		int i;
+		if (strtocolor(&amp;p, &amp;val)) {
+			unsigned char a = val &gt;&gt; 24;
+			for (i = 0; i &lt; 4; ++i)
+				change_alpha(&amp;render_context.c[i], a, pwr);
+		} else {
+			change_alpha(&amp;render_context.c[0], render_context.style-&gt;PrimaryColour, pwr);
+			change_alpha(&amp;render_context.c[1], render_context.style-&gt;SecondaryColour, pwr);
+			change_alpha(&amp;render_context.c[2], render_context.style-&gt;OutlineColour, pwr);
+			change_alpha(&amp;render_context.c[3], render_context.style-&gt;BackColour, pwr);
+		}
+		// FIXME: simplify
+	} else if (mystrcmp(&amp;p, &quot;an&quot;)) {
+		int val;
+		if (mystrtoi(&amp;p, 10, &amp;val) &amp;&amp; val) {
+			int v = (val - 1) / 3; // 0, 1 or 2 for vertical alignment
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;an %d\n&quot;, val);
+			if (v != 0) v = 3 - v;
+			val = ((val - 1) % 3) + 1; // horizontal alignment
+			val += v*4;
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;align %d\n&quot;, val);
+			render_context.alignment = val;
+		} else
+			render_context.alignment = render_context.style-&gt;Alignment;
+	} else if (mystrcmp(&amp;p, &quot;a&quot;)) {
+		int val;
+		if (mystrtoi(&amp;p, 10, &amp;val) &amp;&amp; val)
+			render_context.alignment = val;
+		else
+			render_context.alignment = render_context.style-&gt;Alignment;
+	} else if (mystrcmp(&amp;p, &quot;pos&quot;)) {
+		int v1, v2;
+		skip('(');
+		v1 = strtol(p, &amp;p, 10);
+		skip(',');
+		v2 = strtol(p, &amp;p, 10);
+		skip(')');
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;pos(%d, %d)\n&quot;, v1, v2);
+		render_context.evt_type = EVENT_POSITIONED;
+		render_context.detect_collisions = 0;
+		render_context.pos_x = v1;
+		render_context.pos_y = v2;
+	} else if (mystrcmp(&amp;p, &quot;fad&quot;)) {
+		int a1, a2, a3;
+		long long t1, t2, t3, t4;
+		if (*p == 'e') ++p; // either \fad or \fade
+		skip('(');
+		a1 = strtol(p, &amp;p, 10);
+		skip(',');
+		a2 = strtol(p, &amp;p, 10);
+		if (*p == ')') {
+			// 2-argument version (\fad, according to specs)
+			// a1 and a2 are fade-in and fade-out durations
+			t1 = 0;
+			t4 = render_context.event-&gt;Duration;
+			t2 = a1;
+			t3 = t4 - a2;
+			a1 = 0xFF;
+			a2 = 0;
+			a3 = 0xFF;
+		} else {
+			// 6-argument version (\fade)
+			// a1 and a2 (and a3) are opacity values
+			skip(',');
+			a3 = strtol(p, &amp;p, 10);
+			skip(',');
+			t1 = strtoll(p, &amp;p, 10);
+			skip(',');
+			t2 = strtoll(p, &amp;p, 10);
+			skip(',');
+			t3 = strtoll(p, &amp;p, 10);
+			skip(',');
+			t4 = strtoll(p, &amp;p, 10);
+		}
+		skip(')');
+		render_context.fade = interpolate_alpha(frame_context.time - render_context.event-&gt;Start, t1, t2, t3, t4, a1, a2, a3);
+	} else if (mystrcmp(&amp;p, &quot;org&quot;)) {
+		int v1, v2;
+		skip('(');
+		v1 = strtol(p, &amp;p, 10);
+		skip(',');
+		v2 = strtol(p, &amp;p, 10);
+		skip(')');
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;org(%d, %d)\n&quot;, v1, v2);
+		//				render_context.evt_type = EVENT_POSITIONED;
+		render_context.org_x = v1;
+		render_context.org_y = v2;
+		render_context.have_origin = 1;
+	} else if (mystrcmp(&amp;p, &quot;t&quot;)) {
+		double v[3];
+		int v1, v2;
+		double v3;
+		int cnt;
+		long long t1, t2, t, delta_t;
+		double k;
+		skip('(');
+		for (cnt = 0; cnt &lt; 3; ++cnt) {
+			if (*p == '\\')
+				break;
+			v[cnt] = strtod(p, &amp;p);
+			skip(',');
+		}
+		if (cnt == 3) {
+			v1 = v[0]; v2 = v[1]; v3 = v[2];
+		} else if (cnt == 2) {
+			v1 = v[0]; v2 = v[1]; v3 = 1.;
+		} else if (cnt == 1) {
+			v1 = 0; v2 = render_context.event-&gt;Duration; v3 = v[0];
+		} else { // cnt == 0
+			v1 = 0; v2 = render_context.event-&gt;Duration; v3 = 1.;
+		}
+		render_context.detect_collisions = 0;
+		t1 = v1;
+		t2 = v2;
+		delta_t = v2 - v1;
+		if (v3 &lt; 0.)
+			v3 = 0.;
+		t = frame_context.time - render_context.event-&gt;Start; // FIXME: move to render_context
+		if (t &lt;= t1)
+			k = 0.;
+		else if (t &gt;= t2)
+			k = 1.;
+		else {
+			assert(delta_t != 0.);
+			k = pow(((double)(t - t1)) / delta_t, v3);
+		}
+		while (*p == '\\')
+			p = parse_tag(p, k); // maybe k*pwr ? no, specs forbid nested \t's 
+		skip_all(')'); // FIXME: better skip(')'), but much more tags support required
+	} else if (mystrcmp(&amp;p, &quot;clip&quot;)) {
+		int x0, y0, x1, y1;
+		int res = 1;
+		skip('(');
+		res &amp;= mystrtoi(&amp;p, 10, &amp;x0);
+		skip(',');
+		res &amp;= mystrtoi(&amp;p, 10, &amp;y0);
+		skip(',');
+		res &amp;= mystrtoi(&amp;p, 10, &amp;x1);
+		skip(',');
+		res &amp;= mystrtoi(&amp;p, 10, &amp;y1);
+		skip(')');
+		if (res) {
+			render_context.clip_x0 = render_context.clip_x0 * (1-pwr) + x0 * pwr;
+			render_context.clip_x1 = render_context.clip_x1 * (1-pwr) + x1 * pwr;
+			render_context.clip_y0 = render_context.clip_y0 * (1-pwr) + y0 * pwr;
+			render_context.clip_y1 = render_context.clip_y1 * (1-pwr) + y1 * pwr;
+		} else {
+			render_context.clip_x0 = 0;
+			render_context.clip_y0 = 0;
+			render_context.clip_x1 = frame_context.track-&gt;PlayResX;
+			render_context.clip_y1 = frame_context.track-&gt;PlayResY;
+		}
+	} else if (mystrcmp(&amp;p, &quot;c&quot;)) {
+		uint32_t val;
+		if (!strtocolor(&amp;p, &amp;val))
+			val = render_context.style-&gt;PrimaryColour;
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;color: %X\n&quot;, val);
+		change_color(&amp;render_context.c[0], val, pwr);
+	} else if ((*p &gt;= '1') &amp;&amp; (*p &lt;= '4') &amp;&amp; (++p) &amp;&amp; (mystrcmp(&amp;p, &quot;c&quot;) || mystrcmp(&amp;p, &quot;a&quot;))) {
+		char n = *(p-2);
+		int cidx = n - '1';
+		char cmd = *(p-1);
+		uint32_t val;
+		assert((n &gt;= '1') &amp;&amp; (n &lt;= '4'));
+		if (!strtocolor(&amp;p, &amp;val))
+			switch(n) {
+				case '1': val = render_context.style-&gt;PrimaryColour; break;
+				case '2': val = render_context.style-&gt;SecondaryColour; break;
+				case '3': val = render_context.style-&gt;OutlineColour; break;
+				case '4': val = render_context.style-&gt;BackColour; break;
+				default : val = 0; break; // impossible due to assert; avoid compilation warning
+			}
+		switch (cmd) {
+			case 'c': change_color(render_context.c + cidx, val, pwr); break;
+			case 'a': change_alpha(render_context.c + cidx, val &gt;&gt; 24, pwr); break;
+			default: mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_BadCommand, n, cmd); break;
+		}
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;single c/a at %f: %c%c = %X   \n&quot;, pwr, n, cmd, render_context.c[cidx]);
+	} else if (mystrcmp(&amp;p, &quot;r&quot;)) {
+		reset_render_context();
+	} else if (mystrcmp(&amp;p, &quot;be&quot;)) {
+		int val;
+		if (mystrtoi(&amp;p, 10, &amp;val))
+			render_context.be = val ? 1 : 0;
+		else
+			render_context.be = 0;
+	} else if (mystrcmp(&amp;p, &quot;b&quot;)) {
+		int b;
+		if (mystrtoi(&amp;p, 10, &amp;b)) {
+			if (pwr &gt;= .5)
+				render_context.bold = b;
+		} else
+			render_context.bold = render_context.style-&gt;Bold;
+		update_font();
+	} else if (mystrcmp(&amp;p, &quot;i&quot;)) {
+		int i;
+		if (mystrtoi(&amp;p, 10, &amp;i)) {
+			if (pwr &gt;= .5)
+				render_context.italic = i;
+		} else
+			render_context.italic = render_context.style-&gt;Italic;
+		update_font();
+	} else if (mystrcmp(&amp;p, &quot;kf&quot;) || mystrcmp(&amp;p, &quot;K&quot;)) {
+		int val = strtol(p, &amp;p, 10);
+		render_context.effect_type = EF_KARAOKE_KF;
+		if (render_context.effect_timing)
+			render_context.effect_skip_timing += render_context.effect_timing;
+		render_context.effect_timing = val * 10;
+	} else if (mystrcmp(&amp;p, &quot;ko&quot;)) {
+		int val = strtol(p, &amp;p, 10);
+		render_context.effect_type = EF_KARAOKE_KO;
+		if (render_context.effect_timing)
+			render_context.effect_skip_timing += render_context.effect_timing;
+		render_context.effect_timing = val * 10;
+	} else if (mystrcmp(&amp;p, &quot;k&quot;)) {
+		int val = strtol(p, &amp;p, 10);
+		render_context.effect_type = EF_KARAOKE;
+		if (render_context.effect_timing)
+			render_context.effect_skip_timing += render_context.effect_timing;
+		render_context.effect_timing = val * 10;
+	} else if (mystrcmp(&amp;p, &quot;shad&quot;)) {
+		int val;
+		if (mystrtoi(&amp;p, 10, &amp;val))
+			render_context.shadow = val;
+		else
+			render_context.shadow = render_context.style-&gt;Shadow;
+	}
+
+	return p;
+
+#undef skip
+#undef skip_all
+}
+
+/**
+ * \brief Get next ucs4 char from string, parsing and executing style overrides
+ * \param str string pointer
+ * \return ucs4 code of the next char
+ * On return str points to the unparsed part of the string
+ */
+static unsigned get_next_char(char** str)
+{
+	char* p = *str;
+	unsigned chr;
+	if (*p == '{') { // '\0' goes here
+		p++;
+		while (1) {
+			p = parse_tag(p, 1.);
+			if (*p == '}') { // end of tag
+				p++;
+				if (*p == '{') {
+					p++;
+					continue;
+				} else
+					break;
+			} else if (*p != '\\')
+				mp_msg(MSGT_ASS, MSGL_V, &quot;Unable to parse: \&quot;%s\&quot; \n&quot;, p);
+			if (*p == 0)
+				break;
+		}
+	}
+	if (*p == '\t') {
+		++p;
+		*str = p;
+		return ' ';
+	}
+	if (*p == '\\') {
+		if ((*(p+1) == 'N') || ((*(p+1) == 'n') &amp;&amp; (frame_context.track-&gt;WrapStyle == 2))) {
+			p += 2;
+			*str = p;
+			return '\n';
+		} else if (*(p+1) == 'n') {
+			p += 2;
+			*str = p;
+			return ' ';
+		}
+	}
+	chr = utf8_get_char(&amp;p);
+	*str = p;
+	return chr;
+}
+
+static void apply_transition_effects(ass_event_t* event)
+{
+	int v[4];
+	int cnt;
+	char* p = event-&gt;Effect;
+
+	if (!p || !*p) return;
+
+	cnt = 0;
+	while (cnt &lt; 4 &amp;&amp; (p = strchr(p, ';'))) {
+		v[cnt++] = atoi(++p);
+	}
+	
+	if (strncmp(event-&gt;Effect, &quot;Banner;&quot;, 7) == 0) {
+		int delay;
+		if (cnt &lt; 1) {
+			mp_msg(MSGT_ASS, MSGL_V, &quot;Error parsing effect: %s \n&quot;, event-&gt;Effect);
+			return;
+		}
+		if (cnt &gt;= 2 &amp;&amp; v[1] == 0) // right-to-left
+			render_context.scroll_direction = SCROLL_RL;
+		else // left-to-right
+			render_context.scroll_direction = SCROLL_LR;
+
+		delay = v[0];
+		if (delay == 0) delay = 1; // ?
+		render_context.scroll_shift = (frame_context.time - render_context.event-&gt;Start) / delay;
+		render_context.evt_type = EVENT_HSCROLL;
+		return;
+	}
+
+	if (strncmp(event-&gt;Effect, &quot;Scroll up;&quot;, 10) == 0) {
+		render_context.scroll_direction = SCROLL_BT;
+	} else if (strncmp(event-&gt;Effect, &quot;Scroll down;&quot;, 12) == 0) {
+		render_context.scroll_direction = SCROLL_TB;
+	} else {
+		mp_msg(MSGT_ASS, MSGL_V, &quot;Unknown transition effect: %s \n&quot;, event-&gt;Effect);
+		return;
+	}
+	// parse scroll up/down parameters
+	{
+		int delay;
+		int y0, y1;
+		if (cnt &lt; 3) {
+			mp_msg(MSGT_ASS, MSGL_V, &quot;Error parsing effect: %s \n&quot;, event-&gt;Effect);
+			return;
+		}
+		delay = v[2];
+		if (delay == 0) delay = 1; // ?
+		render_context.scroll_shift = (frame_context.time - render_context.event-&gt;Start) / delay;
+		if (v[0] &lt; v[1]) {
+			y0 = v[0]; y1 = v[1];
+		} else {
+			y0 = v[1]; y1 = v[0];
+		}
+		if (y1 == 0)
+			y1 = frame_context.track-&gt;PlayResY; // y0=y1=0 means fullscreen scrolling
+		render_context.clip_y0 = y0;
+		render_context.clip_y1 = y1;
+		render_context.evt_type = EVENT_VSCROLL;
+		render_context.detect_collisions = 0;
+	}
+
+}
+
+/**
+ * \brief partially reset render_context to style values
+ * Works like {\r}: resets some style overrides
+ */
+static void reset_render_context(void)
+{
+	render_context.c[0] = render_context.style-&gt;PrimaryColour;
+	render_context.c[1] = render_context.style-&gt;SecondaryColour;
+	render_context.c[2] = render_context.style-&gt;OutlineColour;
+	render_context.c[3] = render_context.style-&gt;BackColour;
+	render_context.font_size = render_context.style-&gt;FontSize;
+
+	if (render_context.family)
+		free(render_context.family);
+	render_context.family = strdup(render_context.style-&gt;FontName);
+	render_context.bold = render_context.style-&gt;Bold;
+	render_context.italic = render_context.style-&gt;Italic;
+	update_font();
+
+	change_border(-1.);
+	render_context.scale_x = render_context.style-&gt;ScaleX;
+	render_context.scale_y = render_context.style-&gt;ScaleY;
+	render_context.hspacing = render_context.style-&gt;Spacing;
+	render_context.be = 0;
+	render_context.shadow = render_context.style-&gt;Shadow;
+	render_context.frx = render_context.fry = 0.;
+	render_context.frz = M_PI * render_context.style-&gt;Angle / 180.;
+
+	// FIXME: does not reset unsupported attributes.
+}
+
+/**
+ * \brief Start new event. Reset render_context.
+ */
+static void init_render_context(ass_event_t* event)
+{
+	render_context.event = event;
+	render_context.style = frame_context.track-&gt;styles + event-&gt;Style;
+
+	reset_render_context();
+
+	render_context.evt_type = EVENT_NORMAL;
+	render_context.alignment = render_context.style-&gt;Alignment;
+	render_context.pos_x = 0;
+	render_context.pos_y = 0;
+	render_context.org_x = 0;
+	render_context.org_y = 0;
+	render_context.have_origin = 0;
+	render_context.clip_x0 = 0;
+	render_context.clip_y0 = 0;
+	render_context.clip_x1 = frame_context.track-&gt;PlayResX;
+	render_context.clip_y1 = frame_context.track-&gt;PlayResY;
+	render_context.detect_collisions = 1;
+	render_context.fade = 0;
+	render_context.effect_type = EF_NONE;
+	render_context.effect_timing = 0;
+	render_context.effect_skip_timing = 0;
+	
+	apply_transition_effects(event);
+}
+
+static void free_render_context(void)
+{
+}
+
+/**
+ * \brief Get normal and outline (border) glyphs
+ * \param symbol ucs4 char
+ * \param info out: struct filled with extracted data
+ * \param advance subpixel shift vector used for cache lookup
+ * Tries to get both glyphs from cache.
+ * If they can't be found, gets a glyph from font face, generates outline with FT_Stroker,
+ * and add them to cache.
+ * The glyphs are returned in info-&gt;glyph and info-&gt;outline_glyph
+ */
+static void get_outline_glyph(int symbol, glyph_info_t* info, FT_Vector* advance)
+{
+	int error;
+	glyph_hash_val_t* val;
+	glyph_hash_key_t key;
+	key.font = render_context.font;
+	key.size = render_context.font_size;
+	key.ch = symbol;
+	key.scale_x = (render_context.scale_x * 0xFFFF);
+	key.scale_y = (render_context.scale_y * 0xFFFF);
+	key.advance = *advance;
+	key.bold = render_context.bold;
+	key.italic = render_context.italic;
+	key.outline = render_context.border * 0xFFFF;
+
+	info-&gt;glyph = info-&gt;outline_glyph = 0;
+
+	val = cache_find_glyph(&amp;key);
+	if (val) {
+		FT_Glyph_Copy(val-&gt;glyph, &amp;info-&gt;glyph);
+		if (val-&gt;outline_glyph)
+			FT_Glyph_Copy(val-&gt;outline_glyph, &amp;info-&gt;outline_glyph);
+		info-&gt;bbox = val-&gt;bbox_scaled;
+		info-&gt;advance.x = val-&gt;advance.x;
+		info-&gt;advance.y = val-&gt;advance.y;
+	} else {
+		glyph_hash_val_t v;
+		info-&gt;glyph = ass_font_get_glyph(frame_context.ass_priv-&gt;fontconfig_priv, render_context.font, symbol, global_settings-&gt;hinting);
+		if (!info-&gt;glyph)
+			return;
+		info-&gt;advance.x = d16_to_d6(info-&gt;glyph-&gt;advance.x);
+		info-&gt;advance.y = d16_to_d6(info-&gt;glyph-&gt;advance.y);
+		FT_Glyph_Get_CBox( info-&gt;glyph, FT_GLYPH_BBOX_PIXELS, &amp;info-&gt;bbox);
+
+		if (render_context.stroker) {
+			info-&gt;outline_glyph = info-&gt;glyph;
+			error = FT_Glyph_StrokeBorder( &amp;(info-&gt;outline_glyph), render_context.stroker, 0 , 0 ); // don't destroy original
+			if (error) {
+				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FT_Glyph_Stroke_Error, error);
+			}
+		}
+
+		memset(&amp;v, 0, sizeof(v));
+		FT_Glyph_Copy(info-&gt;glyph, &amp;v.glyph);
+		if (info-&gt;outline_glyph)
+			FT_Glyph_Copy(info-&gt;outline_glyph, &amp;v.outline_glyph);
+		v.advance = info-&gt;advance;
+		v.bbox_scaled = info-&gt;bbox;
+		cache_add_glyph(&amp;key, &amp;v);
+	}
+}
+
+static void transform_3d(FT_Vector shift, FT_Glyph* glyph, FT_Glyph* glyph2, double frx, double fry, double frz);
+
+/**
+ * \brief Get bitmaps for a glyph
+ * \param info glyph info
+ * Tries to get glyph bitmaps from bitmap cache.
+ * If they can't be found, they are generated by rotating and rendering the glyph.
+ * After that, bitmaps are added to the cache.
+ * They are returned in info-&gt;bm (glyph), info-&gt;bm_o (outline) and info-&gt;bm_s (shadow).
+ */
+static void get_bitmap_glyph(glyph_info_t* info)
+{
+	bitmap_hash_val_t* val;
+	bitmap_hash_key_t* key = &amp;info-&gt;hash_key;
+	
+	val = cache_find_bitmap(key);
+/* 	val = 0; */
+	
+	if (val) {
+		info-&gt;bm = val-&gt;bm;
+		info-&gt;bm_o = val-&gt;bm_o;
+		info-&gt;bm_s = val-&gt;bm_s;
+	} else {
+		FT_Vector shift;
+		bitmap_hash_val_t hash_val;
+		int error;
+		info-&gt;bm = info-&gt;bm_o = info-&gt;bm_s = 0;
+		if (info-&gt;glyph &amp;&amp; info-&gt;symbol != '\n' &amp;&amp; info-&gt;symbol != 0) {
+			// calculating rotation shift vector (from rotation origin to the glyph basepoint)
+			shift.x = int_to_d6(info-&gt;hash_key.shift_x);
+			shift.y = int_to_d6(info-&gt;hash_key.shift_y);
+			// apply rotation
+			transform_3d(shift, &amp;info-&gt;glyph, &amp;info-&gt;outline_glyph, info-&gt;frx, info-&gt;fry, info-&gt;frz);
+
+			// render glyph
+			error = glyph_to_bitmap(ass_renderer-&gt;synth_priv,
+					info-&gt;glyph, info-&gt;outline_glyph,
+					&amp;info-&gt;bm, &amp;info-&gt;bm_o,
+					&amp;info-&gt;bm_s, info-&gt;be);
+			if (error)
+				info-&gt;symbol = 0;
+
+			// add bitmaps to cache
+			hash_val.bm_o = info-&gt;bm_o;
+			hash_val.bm = info-&gt;bm;
+			hash_val.bm_s = info-&gt;bm_s;
+			cache_add_bitmap(&amp;(info-&gt;hash_key), &amp;hash_val);
+		}
+	}
+	// deallocate glyphs
+	if (info-&gt;glyph)
+		FT_Done_Glyph(info-&gt;glyph);
+	if (info-&gt;outline_glyph)
+		FT_Done_Glyph(info-&gt;outline_glyph);
+}
+
+/**
+ * This function goes through text_info and calculates text parameters.
+ * The following text_info fields are filled:
+ *   height
+ *   lines[].height
+ *   lines[].asc
+ *   lines[].desc
+ */
+static void measure_text(void)
+{
+	int cur_line = 0, max_asc = 0, max_desc = 0;
+	int i;
+	text_info.height = 0;
+	for (i = 0; i &lt; text_info.length + 1; ++i) {
+		if ((i == text_info.length) || text_info.glyphs[i].linebreak) {
+			text_info.lines[cur_line].asc = max_asc;
+			text_info.lines[cur_line].desc = max_desc;
+			text_info.height += max_asc + max_desc;
+			cur_line ++;
+			max_asc = max_desc = 0;
+		}
+		if (i &lt; text_info.length) {
+			glyph_info_t* cur = text_info.glyphs + i;
+			if (cur-&gt;asc &gt; max_asc)
+				max_asc = cur-&gt;asc;
+			if (cur-&gt;desc &gt; max_desc)
+				max_desc = cur-&gt;desc;
+		}
+	}
+	text_info.height += (text_info.n_lines - 1) * double_to_d6(global_settings-&gt;line_spacing);
+}
+
+/**
+ * \brief rearrange text between lines
+ * \param max_text_width maximal text line width in pixels
+ * The algo is similar to the one in libvo/sub.c:
+ * 1. Place text, wrapping it when current line is full
+ * 2. Try moving words from the end of a line to the beginning of the next one while it reduces
+ * the difference in lengths between this two lines.
+ * The result may not be optimal, but usually is good enough.
+ */
+static void wrap_lines_smart(int max_text_width)
+{
+	int i, j;
+	glyph_info_t *cur, *s1, *e1, *s2, *s3, *w;
+	int last_space;
+	int break_type;
+	int exit;
+	int pen_shift_x;
+	int pen_shift_y;
+	int cur_line;
+
+	last_space = -1;
+	text_info.n_lines = 1;
+	break_type = 0;
+	s1 = text_info.glyphs; // current line start
+	for (i = 0; i &lt; text_info.length; ++i) {
+		int break_at, s_offset, len;
+		cur = text_info.glyphs + i;
+		break_at = -1;
+		s_offset = s1-&gt;bbox.xMin + s1-&gt;pos.x;
+		len = (cur-&gt;bbox.xMax + cur-&gt;pos.x) - s_offset;
+
+		if (cur-&gt;symbol == '\n') {
+			break_type = 2;
+			break_at = i;
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;forced line break at %d\n&quot;, break_at);
+		}
+		
+		if (len &gt;= max_text_width) {
+			break_type = 1;
+			break_at = last_space;
+			if (break_at == -1)
+				break_at = i - 1;
+			if (break_at == -1)
+				break_at = 0;
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;overfill at %d\n&quot;, i);
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;line break at %d\n&quot;, break_at);
+		}
+
+		if (break_at != -1) {
+			// need to use one more line
+			// marking break_at+1 as start of a new line
+			int lead = break_at + 1; // the first symbol of the new line
+			if (text_info.n_lines &gt;= MAX_LINES) {
+				// to many lines ! 
+				// no more linebreaks
+				for (j = lead; j &lt; text_info.length; ++j)
+					text_info.glyphs[j].linebreak = 0;
+				break;
+			}
+			if (lead &lt; text_info.length)
+				text_info.glyphs[lead].linebreak = break_type;
+			last_space = -1;
+			s1 = text_info.glyphs + lead;
+			s_offset = s1-&gt;bbox.xMin + s1-&gt;pos.x;
+			text_info.n_lines ++;
+		}
+		
+		if (cur-&gt;symbol == ' ')
+			last_space = i;
+
+		// make sure the hard linebreak is not forgotten when
+		// there was a new soft linebreak just inserted
+		if (cur-&gt;symbol == '\n' &amp;&amp; break_type == 1)
+			i--;
+	}
+#define DIFF(x,y) (((x) &lt; (y)) ? (y - x) : (x - y))
+	exit = 0;
+	while (!exit) {
+		exit = 1;
+		w = s3 = text_info.glyphs;
+		s1 = s2 = 0;
+		for (i = 0; i &lt;= text_info.length; ++i) {
+			cur = text_info.glyphs + i;
+			if ((i == text_info.length) || cur-&gt;linebreak) {
+				s1 = s2;
+				s2 = s3;
+				s3 = cur;
+				if (s1 &amp;&amp; (s2-&gt;linebreak == 1)) { // have at least 2 lines, and linebreak is 'soft'
+					int l1, l2, l1_new, l2_new;
+
+					w = s2;
+					do { --w; } while ((w &gt; s1) &amp;&amp; (w-&gt;symbol == ' '));
+					while ((w &gt; s1) &amp;&amp; (w-&gt;symbol != ' ')) { --w; }
+					e1 = w;
+					while ((e1 &gt; s1) &amp;&amp; (e1-&gt;symbol == ' ')) { --e1; }
+					if (w-&gt;symbol == ' ') ++w;
+
+					l1 = ((s2-1)-&gt;bbox.xMax + (s2-1)-&gt;pos.x) - (s1-&gt;bbox.xMin + s1-&gt;pos.x);
+					l2 = ((s3-1)-&gt;bbox.xMax + (s3-1)-&gt;pos.x) - (s2-&gt;bbox.xMin + s2-&gt;pos.x);
+					l1_new = (e1-&gt;bbox.xMax + e1-&gt;pos.x) - (s1-&gt;bbox.xMin + s1-&gt;pos.x);
+					l2_new = ((s3-1)-&gt;bbox.xMax + (s3-1)-&gt;pos.x) - (w-&gt;bbox.xMin + w-&gt;pos.x);
+
+					if (DIFF(l1_new, l2_new) &lt; DIFF(l1, l2)) {
+						w-&gt;linebreak = 1;
+						s2-&gt;linebreak = 0;
+						exit = 0;
+					}
+				}
+			}
+			if (i == text_info.length)
+				break;
+		}
+		
+	}
+	assert(text_info.n_lines &gt;= 1);
+#undef DIFF
+	
+	measure_text();
+
+	pen_shift_x = 0;
+	pen_shift_y = 0;
+	cur_line = 1;
+	for (i = 0; i &lt; text_info.length; ++i) {
+		cur = text_info.glyphs + i;
+		if (cur-&gt;linebreak) {
+			int height = text_info.lines[cur_line - 1].desc + text_info.lines[cur_line].asc;
+			cur_line ++;
+			pen_shift_x = - cur-&gt;pos.x;
+			pen_shift_y += d6_to_int(height + double_to_d6(global_settings-&gt;line_spacing));
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;shifting from %d to %d by (%d, %d)\n&quot;, i, text_info.length - 1, pen_shift_x, pen_shift_y);
+		}
+		cur-&gt;pos.x += pen_shift_x;
+		cur-&gt;pos.y += pen_shift_y;
+	}
+}
+
+/**
+ * \brief determine karaoke effects
+ * Karaoke effects cannot be calculated during parse stage (get_next_char()),
+ * so they are done in a separate step.
+ * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's 
+ * (the first glyph of the karaoke word)'s effect_type and effect_timing.
+ * This function:
+ * 1. sets effect_type for all glyphs in the word (_karaoke_ word)
+ * 2. sets effect_timing for all glyphs to x coordinate of the border line between the left and right karaoke parts
+ * (left part is filled with PrimaryColour, right one - with SecondaryColour).
+ */
+static void process_karaoke_effects(void)
+{
+	glyph_info_t *cur, *cur2;
+	glyph_info_t *s1, *e1; // start and end of the current word
+	glyph_info_t *s2; // start of the next word
+	int i;
+	int timing; // current timing
+	int tm_start, tm_end; // timings at start and end of the current word
+	int tm_current;
+	double dt;
+	int x;
+	int x_start, x_end;
+
+	tm_current = frame_context.time - render_context.event-&gt;Start;
+	timing = 0;
+	s1 = s2 = 0;
+	for (i = 0; i &lt;= text_info.length; ++i) {
+		cur = text_info.glyphs + i;
+		if ((i == text_info.length) || (cur-&gt;effect_type != EF_NONE)) {
+			s1 = s2;
+			s2 = cur;
+			if (s1) {
+				e1 = s2 - 1;
+				tm_start = timing + s1-&gt;effect_skip_timing;
+				tm_end = tm_start + s1-&gt;effect_timing;
+				timing = tm_end;
+				x_start = 1000000;
+				x_end = -1000000;
+				for (cur2 = s1; cur2 &lt;= e1; ++cur2) {
+					x_start = FFMIN(x_start, cur2-&gt;bbox.xMin + cur2-&gt;pos.x);
+					x_end = FFMAX(x_end, cur2-&gt;bbox.xMax + cur2-&gt;pos.x);
+				}
+
+				dt = (tm_current - tm_start);
+				if ((s1-&gt;effect_type == EF_KARAOKE) || (s1-&gt;effect_type == EF_KARAOKE_KO)) {
+					if (dt &gt; 0)
+						x = x_end + 1;
+					else
+						x = x_start;
+				} else if (s1-&gt;effect_type == EF_KARAOKE_KF) {
+					dt /= (tm_end - tm_start);
+					x = x_start + (x_end - x_start) * dt;
+				} else {
+					mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_UnknownEffectType_InternalError);
+					continue;
+				}
+
+				for (cur2 = s1; cur2 &lt;= e1; ++cur2) {
+					cur2-&gt;effect_type = s1-&gt;effect_type;
+					cur2-&gt;effect_timing = x - cur2-&gt;pos.x;
+				}
+			}
+		}
+	}
+}
+
+/**
+ * \brief Calculate base point for positioning and rotation
+ * \param bbox text bbox
+ * \param alignment alignment
+ * \param bx, by out: base point coordinates
+ */
+static void get_base_point(FT_BBox bbox, int alignment, int* bx, int* by)
+{
+	const int halign = alignment &amp; 3;
+	const int valign = alignment &amp; 12;
+	if (bx)
+		switch(halign) {
+		case HALIGN_LEFT:
+			*bx = bbox.xMin;
+			break;
+		case HALIGN_CENTER:
+			*bx = (bbox.xMax + bbox.xMin) / 2;
+			break;
+		case HALIGN_RIGHT:
+			*bx = bbox.xMax;
+			break;
+		}
+	if (by)
+		switch(valign) {
+		case VALIGN_TOP:
+			*by = bbox.yMin;
+			break;
+		case VALIGN_CENTER:
+			*by = (bbox.yMax + bbox.yMin) / 2;
+			break;
+		case VALIGN_SUB:
+			*by = bbox.yMax;
+			break;
+		}
+}
+
+/**
+ * \brief Multiply 4-vector by 4-matrix
+ * \param a 4-vector
+ * \param m 4-matrix]
+ * \param b out: 4-vector
+ * Calculates a * m and stores result in b
+ */
+static inline void transform_point_3d(double *a, double *m, double *b)
+{
+	b[0] = a[0] * m[0] + a[1] * m[4] + a[2] * m[8] +  a[3] * m[12];
+	b[1] = a[0] * m[1] + a[1] * m[5] + a[2] * m[9] +  a[3] * m[13];
+	b[2] = a[0] * m[2] + a[1] * m[6] + a[2] * m[10] + a[3] * m[14];
+	b[3] = a[0] * m[3] + a[1] * m[7] + a[2] * m[11] + a[3] * m[15];
+}
+
+/**
+ * \brief Apply 3d transformation to a vector
+ * \param v FreeType vector (2d)
+ * \param m 4-matrix
+ * Transforms v by m, projects the result back to the screen plane
+ * Result is returned in v.
+ */
+static inline void transform_vector_3d(FT_Vector* v, double *m) {
+	const double camera = 2500 * frame_context.border_scale; // camera distance
+	double a[4], b[4];
+	a[0] = d6_to_double(v-&gt;x);
+	a[1] = d6_to_double(v-&gt;y);
+	a[2] = 0.;
+	a[3] = 1.;
+	transform_point_3d(a, m, b);
+	/* Apply perspective projection with the following matrix:
+	   2500     0     0     0
+	      0  2500     0     0
+	      0     0     0     0
+	      0     0     8     2500
+	   where 2500 is camera distance, 8 - z-axis scale.
+	   Camera is always located in (org_x, org_y, -2500). This means
+	   that different subtitle events can be displayed at the same time
+	   using different cameras. */
+	b[0] *= camera;
+	b[1] *= camera;
+	b[3] = 8 * b[2] + camera;
+	if (b[3] &lt; 0.001 &amp;&amp; b[3] &gt; -0.001)
+		b[3] = b[3] &lt; 0. ? -0.001 : 0.001;
+	v-&gt;x = double_to_d6(b[0] / b[3]);
+	v-&gt;y = double_to_d6(b[1] / b[3]);
+}
+
+/**
+ * \brief Apply 3d transformation to a glyph
+ * \param glyph FreeType glyph
+ * \param m 4-matrix
+ * Transforms glyph by m, projects the result back to the screen plane
+ * Result is returned in glyph.
+ */
+static inline void transform_glyph_3d(FT_Glyph glyph, double *m, FT_Vector shift) {
+	int i;
+	FT_Outline* outline = &amp;((FT_OutlineGlyph)glyph)-&gt;outline;
+	FT_Vector* p = outline-&gt;points;
+
+	for (i=0; i&lt;outline-&gt;n_points; i++) {
+		p[i].x += shift.x;
+		p[i].y += shift.y;
+		transform_vector_3d(p + i, m);
+		p[i].x -= shift.x;
+		p[i].y -= shift.y;
+	}
+
+	//transform_vector_3d(&amp;glyph-&gt;advance, m);
+}
+
+/**
+ * \brief Apply 3d transformation to several objects
+ * \param shift FreeType vector
+ * \param glyph FreeType glyph
+ * \param glyph2 FreeType glyph
+ * \param frx x-axis rotation angle
+ * \param fry y-axis rotation angle
+ * \param frz z-axis rotation angle
+ * Rotates both glyphs by frx, fry and frz. Shift vector is added before rotation and subtracted after it.
+ */
+static void transform_3d(FT_Vector shift, FT_Glyph* glyph, FT_Glyph* glyph2, double frx, double fry, double frz)
+{
+	fry = - fry; // FreeType's y axis goes in the opposite direction
+	if (frx != 0. || fry != 0. || frz != 0.) {
+		double m[16];
+		double sx = sin(frx);
+		double sy = sin(fry);
+ 		double sz = sin(frz);
+		double cx = cos(frx);
+		double cy = cos(fry);
+		double cz = cos(frz);
+		m[0] = cy * cz;            m[1] = cy*sz;              m[2]  = -sy;    m[3] = 0.0;
+		m[4] = -cx*sz + sx*sy*cz;  m[5] = cx*cz + sx*sy*sz;   m[6]  = sx*cy;  m[7] = 0.0;
+		m[8] = sx*sz + cx*sy*cz;   m[9] = -sx*cz + cx*sy*sz;  m[10] = cx*cy;  m[11] = 0.0;
+		m[12] = 0.0;               m[13] = 0.0;               m[14] = 0.0;    m[15] = 1.0;
+
+		if (glyph &amp;&amp; *glyph)
+			transform_glyph_3d(*glyph, m, shift);
+
+		if (glyph2 &amp;&amp; *glyph2)
+			transform_glyph_3d(*glyph2, m, shift);
+	}
+}
+
+/**
+ * \brief Main ass rendering function, glues everything together
+ * \param event event to render
+ * Process event, appending resulting ass_image_t's to images_root.
+ */
+static int ass_render_event(ass_event_t* event, event_images_t* event_images)
+{
+	char* p;
+	FT_UInt previous; 
+	FT_UInt num_glyphs;
+	FT_Vector pen;
+	unsigned code;
+	FT_BBox bbox;
+	int i, j;
+	FT_Vector shift;
+	int MarginL, MarginR, MarginV;
+	int last_break;
+	int alignment, halign, valign;
+	int device_x = 0, device_y = 0;
+
+	if (event-&gt;Style &gt;= frame_context.track-&gt;n_styles) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoStyleFound);
+		return 1;
+	}
+	if (!event-&gt;Text) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EmptyEvent);
+		return 1;
+	}
+
+	init_render_context(event);
+
+	text_info.length = 0;
+	pen.x = 0;
+	pen.y = 0;
+	previous = 0;
+	num_glyphs = 0;
+	p = event-&gt;Text;
+	// Event parsing.
+	while (1) {
+		// get next char, executing style override
+		// this affects render_context
+		code = get_next_char(&amp;p);
+		
+		// face could have been changed in get_next_char
+		if (!render_context.font) {
+			free_render_context();
+			return 1;
+		}
+
+		if (code == 0)
+			break;
+
+		if (text_info.length &gt;= MAX_GLYPHS) {
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_MAX_GLYPHS_Reached, 
+					(int)(event - frame_context.track-&gt;events), event-&gt;Start, event-&gt;Duration, event-&gt;Text);
+			break;
+		}
+
+		if ( previous &amp;&amp; code ) {
+			FT_Vector delta;
+			delta = ass_font_get_kerning(render_context.font, previous, code);
+			pen.x += delta.x * render_context.scale_x;
+			pen.y += delta.y * render_context.scale_y;
+		}
+
+		shift.x = pen.x &amp; 63;
+		shift.y = pen.y &amp; 63;
+
+		ass_font_set_transform(render_context.font,
+				       render_context.scale_x * frame_context.font_scale_x,
+				       render_context.scale_y,
+				       &amp;shift );
+
+		get_outline_glyph(code, text_info.glyphs + text_info.length, &amp;shift);
+		
+		text_info.glyphs[text_info.length].pos.x = pen.x &gt;&gt; 6;
+		text_info.glyphs[text_info.length].pos.y = pen.y &gt;&gt; 6;
+		
+		pen.x += text_info.glyphs[text_info.length].advance.x;
+		pen.x += double_to_d6(render_context.hspacing);
+		pen.y += text_info.glyphs[text_info.length].advance.y;
+		
+		previous = code;
+
+		text_info.glyphs[text_info.length].symbol = code;
+		text_info.glyphs[text_info.length].linebreak = 0;
+		for (i = 0; i &lt; 4; ++i) {
+			uint32_t clr = render_context.c[i];
+			change_alpha(&amp;clr, mult_alpha(_a(clr), render_context.fade), 1.);
+			text_info.glyphs[text_info.length].c[i] = clr;
+		}
+		text_info.glyphs[text_info.length].effect_type = render_context.effect_type;
+		text_info.glyphs[text_info.length].effect_timing = render_context.effect_timing;
+		text_info.glyphs[text_info.length].effect_skip_timing = render_context.effect_skip_timing;
+		text_info.glyphs[text_info.length].be = render_context.be;
+		text_info.glyphs[text_info.length].shadow = render_context.shadow;
+		text_info.glyphs[text_info.length].frx = render_context.frx;
+		text_info.glyphs[text_info.length].fry = render_context.fry;
+		text_info.glyphs[text_info.length].frz = render_context.frz;
+		ass_font_get_asc_desc(render_context.font, code,
+				      &amp;text_info.glyphs[text_info.length].asc,
+				      &amp;text_info.glyphs[text_info.length].desc);
+		text_info.glyphs[text_info.length].asc *= render_context.scale_y;
+		text_info.glyphs[text_info.length].desc *= render_context.scale_y;
+
+		// fill bitmap_hash_key
+		text_info.glyphs[text_info.length].hash_key.font = render_context.font;
+		text_info.glyphs[text_info.length].hash_key.size = render_context.font_size;
+		text_info.glyphs[text_info.length].hash_key.outline = render_context.border * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.scale_x = render_context.scale_x * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.scale_y = render_context.scale_y * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.frx = render_context.frx * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.fry = render_context.fry * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.frz = render_context.frz * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.bold = render_context.bold;
+		text_info.glyphs[text_info.length].hash_key.italic = render_context.italic;
+		text_info.glyphs[text_info.length].hash_key.ch = code;
+		text_info.glyphs[text_info.length].hash_key.advance = shift;
+		text_info.glyphs[text_info.length].hash_key.be = render_context.be;
+
+		text_info.length++;
+
+		render_context.effect_type = EF_NONE;
+		render_context.effect_timing = 0;
+		render_context.effect_skip_timing = 0;
+	}
+	
+	if (text_info.length == 0) {
+		// no valid symbols in the event; this can be smth like {comment}
+		free_render_context();
+		return 1;
+	}
+	
+	// depends on glyph x coordinates being monotonous, so it should be done before line wrap
+	process_karaoke_effects();
+	
+	// alignments
+	alignment = render_context.alignment;
+	halign = alignment &amp; 3;
+	valign = alignment &amp; 12;
+
+	MarginL = (event-&gt;MarginL) ? event-&gt;MarginL : render_context.style-&gt;MarginL; 
+	MarginR = (event-&gt;MarginR) ? event-&gt;MarginR : render_context.style-&gt;MarginR; 
+	MarginV = (event-&gt;MarginV) ? event-&gt;MarginV : render_context.style-&gt;MarginV;
+
+	if (render_context.evt_type != EVENT_HSCROLL) {
+		int max_text_width;
+
+		// calculate max length of a line
+		max_text_width = x2scr(frame_context.track-&gt;PlayResX - MarginR) - x2scr(MarginL);
+
+		// rearrange text in several lines
+		wrap_lines_smart(max_text_width);
+
+		// align text
+		last_break = -1;
+		for (i = 1; i &lt; text_info.length + 1; ++i) { // (text_info.length + 1) is the end of the last line
+			if ((i == text_info.length) || text_info.glyphs[i].linebreak) {
+				int width, shift = 0;
+				glyph_info_t* first_glyph = text_info.glyphs + last_break + 1;
+				glyph_info_t* last_glyph = text_info.glyphs + i - 1;
+
+				while ((last_glyph &gt; first_glyph) &amp;&amp; ((last_glyph-&gt;symbol == '\n') || (last_glyph-&gt;symbol == 0)))
+					last_glyph --;
+
+				width = last_glyph-&gt;pos.x + d6_to_int(last_glyph-&gt;advance.x) - first_glyph-&gt;pos.x;
+				if (halign == HALIGN_LEFT) { // left aligned, no action
+					shift = 0;
+				} else if (halign == HALIGN_RIGHT) { // right aligned
+					shift = max_text_width - width;
+				} else if (halign == HALIGN_CENTER) { // centered
+					shift = (max_text_width - width) / 2;
+				}
+				for (j = last_break + 1; j &lt; i; ++j) {
+					text_info.glyphs[j].pos.x += shift;
+				}
+				last_break = i - 1;
+			}
+		}
+	} else { // render_context.evt_type == EVENT_HSCROLL
+		measure_text();
+	}
+	
+	// determing text bounding box
+	compute_string_bbox(&amp;text_info, &amp;bbox);
+	
+	// determine device coordinates for text
+	
+	// x coordinate for everything except positioned events
+	if (render_context.evt_type == EVENT_NORMAL ||
+	    render_context.evt_type == EVENT_VSCROLL) {
+		device_x = x2scr(MarginL);
+	} else if (render_context.evt_type == EVENT_HSCROLL) {
+		if (render_context.scroll_direction == SCROLL_RL)
+			device_x = x2scr(frame_context.track-&gt;PlayResX - render_context.scroll_shift);
+		else if (render_context.scroll_direction == SCROLL_LR)
+			device_x = x2scr(render_context.scroll_shift) - (bbox.xMax - bbox.xMin);
+	}
+
+	// y coordinate for everything except positioned events
+	if (render_context.evt_type == EVENT_NORMAL ||
+	    render_context.evt_type == EVENT_HSCROLL) {
+		if (valign == VALIGN_TOP) { // toptitle
+			device_y = y2scr_top(MarginV) + d6_to_int(text_info.lines[0].asc);
+		} else if (valign == VALIGN_CENTER) { // midtitle
+			int scr_y = y2scr(frame_context.track-&gt;PlayResY / 2);
+			device_y = scr_y - (bbox.yMax - bbox.yMin) / 2;
+		} else { // subtitle
+			int scr_y;
+			if (valign != VALIGN_SUB)
+				mp_msg(MSGT_ASS, MSGL_V, &quot;Invalid valign, supposing 0 (subtitle)\n&quot;);
+			scr_y = y2scr_sub(frame_context.track-&gt;PlayResY - MarginV);
+			device_y = scr_y;
+			device_y -= d6_to_int(text_info.height);
+			device_y += d6_to_int(text_info.lines[0].asc);
+		}
+	} else if (render_context.evt_type == EVENT_VSCROLL) {
+		if (render_context.scroll_direction == SCROLL_TB)
+			device_y = y2scr(render_context.clip_y0 + render_context.scroll_shift) - (bbox.yMax - bbox.yMin);
+		else if (render_context.scroll_direction == SCROLL_BT)
+			device_y = y2scr(render_context.clip_y1 - render_context.scroll_shift);
+	}
+
+	// positioned events are totally different
+	if (render_context.evt_type == EVENT_POSITIONED) {
+		int base_x = 0;
+		int base_y = 0;
+		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;positioned event at %d, %d\n&quot;, render_context.pos_x, render_context.pos_y);
+		get_base_point(bbox, alignment, &amp;base_x, &amp;base_y);
+		device_x = x2scr(render_context.pos_x) - base_x;
+		device_y = y2scr(render_context.pos_y) - base_y;
+	}
+	
+	// fix clip coordinates (they depend on alignment)
+	render_context.clip_x0 = x2scr(render_context.clip_x0);
+	render_context.clip_x1 = x2scr(render_context.clip_x1);
+	if (render_context.evt_type == EVENT_NORMAL ||
+	    render_context.evt_type == EVENT_HSCROLL ||
+	    render_context.evt_type == EVENT_VSCROLL) {
+		if (valign == VALIGN_TOP) {
+			render_context.clip_y0 = y2scr_top(render_context.clip_y0);
+			render_context.clip_y1 = y2scr_top(render_context.clip_y1);
+		} else if (valign == VALIGN_CENTER) {
+			render_context.clip_y0 = y2scr(render_context.clip_y0);
+			render_context.clip_y1 = y2scr(render_context.clip_y1);
+		} else if (valign == VALIGN_SUB) {
+			render_context.clip_y0 = y2scr_sub(render_context.clip_y0);
+			render_context.clip_y1 = y2scr_sub(render_context.clip_y1);
+		}
+	} else if (render_context.evt_type == EVENT_POSITIONED) {
+		render_context.clip_y0 = y2scr(render_context.clip_y0);
+		render_context.clip_y1 = y2scr(render_context.clip_y1);
+	}
+
+	// calculate rotation parameters
+	{
+		FT_Vector center;
+		
+		if (render_context.have_origin) {
+			center.x = x2scr(render_context.org_x);
+			center.y = y2scr(render_context.org_y);
+		} else {
+			int bx, by;
+			get_base_point(bbox, alignment, &amp;bx, &amp;by);
+			center.x = device_x + bx;
+			center.y = device_y + by;
+		}
+
+		for (i = 0; i &lt; text_info.length; ++i) {
+			glyph_info_t* info = text_info.glyphs + i;
+
+			if (info-&gt;hash_key.frx || info-&gt;hash_key.fry || info-&gt;hash_key.frz) {
+				info-&gt;hash_key.shift_x = info-&gt;pos.x + device_x - center.x;
+				info-&gt;hash_key.shift_y = - (info-&gt;pos.y + device_y - center.y);
+			} else {
+				info-&gt;hash_key.shift_x = 0;
+				info-&gt;hash_key.shift_y = 0;
+			}
+		}
+	}
+
+	// convert glyphs to bitmaps
+	for (i = 0; i &lt; text_info.length; ++i)
+		get_bitmap_glyph(text_info.glyphs + i);
+
+	event_images-&gt;top = device_y - d6_to_int(text_info.lines[0].asc);
+	event_images-&gt;height = d6_to_int(text_info.height);
+	event_images-&gt;detect_collisions = render_context.detect_collisions;
+	event_images-&gt;shift_direction = (valign == VALIGN_TOP) ? 1 : -1;
+	event_images-&gt;event = event;
+	event_images-&gt;imgs = render_text(&amp;text_info, device_x, device_y);
+
+	free_render_context();
+	
+	return 0;
+}
+
+/**
+ * \brief deallocate image list
+ * \param img list pointer
+ */
+void ass_free_images(ass_image_t* img)
+{
+	while (img) {
+		ass_image_t* next = img-&gt;next;
+		free(img);
+		img = next;
+	}
+}
+
+static void ass_reconfigure(ass_renderer_t* priv)
+{
+	priv-&gt;render_id = ++last_render_id;
+	ass_glyph_cache_reset();
+	ass_bitmap_cache_reset();
+	ass_free_images(priv-&gt;prev_images_root);
+	priv-&gt;prev_images_root = 0;
+}
+
+void ass_set_frame_size(ass_renderer_t* priv, int w, int h)
+{
+	if (priv-&gt;settings.frame_width != w || priv-&gt;settings.frame_height != h) {
+		priv-&gt;settings.frame_width = w;
+		priv-&gt;settings.frame_height = h;
+		if (priv-&gt;settings.aspect == 0.)
+			priv-&gt;settings.aspect = ((double)w) / h;
+		ass_reconfigure(priv);
+	}
+}
+
+void ass_set_margins(ass_renderer_t* priv, int t, int b, int l, int r)
+{
+	if (priv-&gt;settings.left_margin != l ||
+	    priv-&gt;settings.right_margin != r ||
+	    priv-&gt;settings.top_margin != t ||
+	    priv-&gt;settings.bottom_margin != b) {
+		priv-&gt;settings.left_margin = l;
+		priv-&gt;settings.right_margin = r;
+		priv-&gt;settings.top_margin = t;
+		priv-&gt;settings.bottom_margin = b;
+		ass_reconfigure(priv);
+	}
+}
+
+void ass_set_use_margins(ass_renderer_t* priv, int use)
+{
+	priv-&gt;settings.use_margins = use;
+}
+
+void ass_set_aspect_ratio(ass_renderer_t* priv, double ar)
+{
+	if (priv-&gt;settings.aspect != ar) {
+		priv-&gt;settings.aspect = ar;
+		ass_reconfigure(priv);
+	}
+}
+
+void ass_set_font_scale(ass_renderer_t* priv, double font_scale)
+{
+	if (priv-&gt;settings.font_size_coeff != font_scale) {
+		priv-&gt;settings.font_size_coeff = font_scale;
+		ass_reconfigure(priv);
+	}
+}
+
+void ass_set_hinting(ass_renderer_t* priv, ass_hinting_t ht)
+{
+	if (priv-&gt;settings.hinting != ht) {
+		priv-&gt;settings.hinting = ht;
+		ass_reconfigure(priv);
+	}
+}
+
+void ass_set_line_spacing(ass_renderer_t* priv, double line_spacing)
+{
+	priv-&gt;settings.line_spacing = line_spacing;
+}
+
+int ass_set_fonts(ass_renderer_t* priv, const char* default_font, const char* default_family)
+{
+	if (priv-&gt;settings.default_font)
+		free(priv-&gt;settings.default_font);
+	if (priv-&gt;settings.default_family)
+		free(priv-&gt;settings.default_family);
+
+	priv-&gt;settings.default_font = default_font ? strdup(default_font) : 0;
+	priv-&gt;settings.default_family = default_family ? strdup(default_family) : 0;
+
+	if (priv-&gt;fontconfig_priv)
+		fontconfig_done(priv-&gt;fontconfig_priv);
+	priv-&gt;fontconfig_priv = fontconfig_init(priv-&gt;library, priv-&gt;ftlibrary, default_family, default_font);
+
+	return !!priv-&gt;fontconfig_priv;
+}
+
+/**
+ * \brief Start a new frame
+ */
+static int ass_start_frame(ass_renderer_t *priv, ass_track_t* track, long long now)
+{
+	ass_renderer = priv;
+	global_settings = &amp;priv-&gt;settings;
+
+	if (!priv-&gt;settings.frame_width &amp;&amp; !priv-&gt;settings.frame_height)
+		return 1; // library not initialized
+	
+	frame_context.ass_priv = priv;
+	frame_context.width = global_settings-&gt;frame_width;
+	frame_context.height = global_settings-&gt;frame_height;
+	frame_context.orig_width = global_settings-&gt;frame_width - global_settings-&gt;left_margin - global_settings-&gt;right_margin;
+	frame_context.orig_height = global_settings-&gt;frame_height - global_settings-&gt;top_margin - global_settings-&gt;bottom_margin;
+	frame_context.track = track;
+	frame_context.time = now;
+
+	ass_lazy_track_init();
+	
+	frame_context.font_scale = global_settings-&gt;font_size_coeff *
+	                           frame_context.orig_height / frame_context.track-&gt;PlayResY;
+	frame_context.border_scale = ((double)frame_context.orig_height) / frame_context.track-&gt;PlayResY;
+
+	if (frame_context.orig_width * track-&gt;PlayResY == frame_context.orig_height * track-&gt;PlayResX)
+		frame_context.font_scale_x = 1.;
+	else
+		frame_context.font_scale_x = ((double)(frame_context.orig_width * track-&gt;PlayResY)) / (frame_context.orig_height * track-&gt;PlayResX);
+
+	priv-&gt;prev_images_root = priv-&gt;images_root;
+	priv-&gt;images_root = 0;
+
+	return 0;
+}
+
+static int cmp_event_layer(const void* p1, const void* p2)
+{
+	ass_event_t* e1 = ((event_images_t*)p1)-&gt;event;
+	ass_event_t* e2 = ((event_images_t*)p2)-&gt;event;
+	if (e1-&gt;Layer &lt; e2-&gt;Layer)
+		return -1;
+	if (e1-&gt;Layer &gt; e2-&gt;Layer)
+		return 1;
+	if (e1-&gt;ReadOrder &lt; e2-&gt;ReadOrder)
+		return -1;
+	if (e1-&gt;ReadOrder &gt; e2-&gt;ReadOrder)
+		return 1;
+	return 0;
+}
+
+#define MAX_EVENTS 100
+
+static render_priv_t* get_render_priv(ass_event_t* event)
+{
+	if (!event-&gt;render_priv)
+		event-&gt;render_priv = calloc(1, sizeof(render_priv_t));
+	// FIXME: check render_id
+	if (ass_renderer-&gt;render_id != event-&gt;render_priv-&gt;render_id) {
+		memset(event-&gt;render_priv, 0, sizeof(render_priv_t));
+		event-&gt;render_priv-&gt;render_id = ass_renderer-&gt;render_id;
+	}
+	return event-&gt;render_priv;
+}
+
+typedef struct segment_s {
+	int a, b; // top and height
+} segment_t;
+
+static int overlap(segment_t* s1, segment_t* s2)
+{
+	if (s1-&gt;a &gt;= s2-&gt;b || s2-&gt;a &gt;= s1-&gt;b)
+		return 0;
+	return 1;
+}
+
+static int cmp_segment(const void* p1, const void* p2)
+{
+	return ((segment_t*)p1)-&gt;a - ((segment_t*)p2)-&gt;a;
+}
+
+static void shift_event(event_images_t* ei, int shift)
+{
+	ass_image_t* cur = ei-&gt;imgs;
+	while (cur) {
+		cur-&gt;dst_y += shift;
+		// clip top and bottom
+		if (cur-&gt;dst_y &lt; 0) {
+			int clip = - cur-&gt;dst_y;
+			cur-&gt;h -= clip;
+			cur-&gt;bitmap += clip * cur-&gt;stride;
+			cur-&gt;dst_y = 0;
+		}
+		if (cur-&gt;dst_y + cur-&gt;h &gt;= frame_context.height) {
+			int clip = cur-&gt;dst_y + cur-&gt;h - frame_context.height;
+			cur-&gt;h -= clip;
+		}
+		if (cur-&gt;h &lt;= 0) {
+			cur-&gt;h = 0;
+			cur-&gt;dst_y = 0;
+		}
+		cur = cur-&gt;next;
+	}
+	ei-&gt;top += shift;
+}
+
+// dir: 1 - move down
+//      -1 - move up
+static int fit_segment(segment_t* s, segment_t* fixed, int* cnt, int dir)
+{
+	int i;
+	int shift = 0;
+
+	if (dir == 1) // move down
+		for (i = 0; i &lt; *cnt; ++i) {
+			if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
+				continue;
+			shift = fixed[i].b - s-&gt;a;
+		}
+	else // dir == -1, move up
+		for (i = *cnt-1; i &gt;= 0; --i) {
+			if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
+				continue;
+			shift = fixed[i].a - s-&gt;b;
+		}
+
+	fixed[*cnt].a = s-&gt;a + shift;
+	fixed[*cnt].b = s-&gt;b + shift;
+	(*cnt)++;
+	qsort(fixed, *cnt, sizeof(segment_t), cmp_segment);
+	
+	return shift;
+}
+
+static void fix_collisions(event_images_t* imgs, int cnt)
+{
+	segment_t used[MAX_EVENTS];
+	int cnt_used = 0;
+	int i, j;
+
+	// fill used[] with fixed events
+	for (i = 0; i &lt; cnt; ++i) {
+		render_priv_t* priv;
+		if (!imgs[i].detect_collisions) continue;
+		priv = get_render_priv(imgs[i].event);
+		if (priv-&gt;height &gt; 0) { // it's a fixed event
+			segment_t s;
+			s.a = priv-&gt;top;
+			s.b = priv-&gt;top + priv-&gt;height;
+			if (priv-&gt;height != imgs[i].height) { // no, it's not
+				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EventHeightHasChanged);
+				priv-&gt;top = 0;
+				priv-&gt;height = 0;
+			}
+			for (j = 0; j &lt; cnt_used; ++j)
+				if (overlap(&amp;s, used + j)) { // no, it's not
+					priv-&gt;top = 0;
+					priv-&gt;height = 0;
+				}
+			if (priv-&gt;height &gt; 0) { // still a fixed event
+				used[cnt_used].a = priv-&gt;top;
+				used[cnt_used].b = priv-&gt;top + priv-&gt;height;
+				cnt_used ++;
+				shift_event(imgs + i, priv-&gt;top - imgs[i].top);
+			}
+		}
+	}
+	qsort(used, cnt_used, sizeof(segment_t), cmp_segment);
+
+	// try to fit other events in free spaces
+	for (i = 0; i &lt; cnt; ++i) {
+		render_priv_t* priv;
+		if (!imgs[i].detect_collisions) continue;
+		priv = get_render_priv(imgs[i].event);
+		if (priv-&gt;height == 0) { // not a fixed event
+			int shift;
+			segment_t s;
+			s.a = imgs[i].top;
+			s.b = imgs[i].top + imgs[i].height;
+			shift = fit_segment(&amp;s, used, &amp;cnt_used, imgs[i].shift_direction);
+			if (shift) shift_event(imgs + i, shift);
+			// make it fixed
+			priv-&gt;top = imgs[i].top;
+			priv-&gt;height = imgs[i].height;
+		}
+		
+	}
+}
+
+/**
+ * \brief compare two images
+ * \param i1 first image
+ * \param i2 second image
+ * \return 0 if identical, 1 if different positions, 2 if different content
+ */
+int ass_image_compare(ass_image_t *i1, ass_image_t *i2)
+{
+	if (i1-&gt;w != i2-&gt;w) return 2;
+	if (i1-&gt;h != i2-&gt;h) return 2;
+	if (i1-&gt;stride != i2-&gt;stride) return 2;
+	if (i1-&gt;color != i2-&gt;color) return 2;
+	if (i1-&gt;bitmap != i2-&gt;bitmap)
+		return 2;
+	if (i1-&gt;dst_x != i2-&gt;dst_x) return 1;
+	if (i1-&gt;dst_y != i2-&gt;dst_y) return 1;
+	return 0;
+}
+
+/**
+ * \brief compare current and previous image list
+ * \param priv library handle
+ * \return 0 if identical, 1 if different positions, 2 if different content
+ */
+int ass_detect_change(ass_renderer_t *priv)
+{
+	ass_image_t* img, *img2;
+	int diff;
+
+	img = priv-&gt;prev_images_root;
+	img2 = priv-&gt;images_root;
+	diff = 0;
+	while (img &amp;&amp; diff &lt; 2) {
+		ass_image_t* next, *next2;
+		next = img-&gt;next;
+		if (img2) {
+			int d = ass_image_compare(img, img2);
+			if (d &gt; diff) diff = d;
+			next2 = img2-&gt;next;
+		} else {
+			// previous list is shorter
+			diff = 2;
+			break;
+		}
+		img = next;
+		img2 = next2;
+	}
+
+	// is the previous list longer?
+	if (img2)
+		diff = 2;
+
+	return diff;
+}
+
+/**
+ * \brief render a frame
+ * \param priv library handle
+ * \param track track
+ * \param now current video timestamp (ms)
+ * \param detect_change a value describing how the new images differ from the previous ones will be written here:
+ *        0 if identical, 1 if different positions, 2 if different content.
+ *        Can be NULL, in that case no detection is performed.
+ */
+ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now, int* detect_change)
+{
+	int i, cnt, rc;
+	event_images_t* last;
+	ass_image_t** tail;
+	
+	// init frame
+	rc = ass_start_frame(priv, track, now);
+	if (rc != 0)
+		return 0;
+
+	// render events separately
+	cnt = 0;
+	for (i = 0; i &lt; track-&gt;n_events; ++i) {
+		ass_event_t* event = track-&gt;events + i;
+		if ( (event-&gt;Start &lt;= now) &amp;&amp; (now &lt; (event-&gt;Start + event-&gt;Duration)) ) {
+			if (cnt &gt;= priv-&gt;eimg_size) {
+				priv-&gt;eimg_size += 100;
+				priv-&gt;eimg = realloc(priv-&gt;eimg, priv-&gt;eimg_size * sizeof(event_images_t));
+			}
+			rc = ass_render_event(event, priv-&gt;eimg + cnt);
+			if (!rc) ++cnt;
+		}
+	}
+
+	// sort by layer
+	qsort(priv-&gt;eimg, cnt, sizeof(event_images_t), cmp_event_layer);
+
+	// call fix_collisions for each group of events with the same layer
+	last = priv-&gt;eimg;
+	for (i = 1; i &lt; cnt; ++i)
+		if (last-&gt;event-&gt;Layer != priv-&gt;eimg[i].event-&gt;Layer) {
+			fix_collisions(last, priv-&gt;eimg + i - last);
+			last = priv-&gt;eimg + i;
+		}
+	if (cnt &gt; 0)
+		fix_collisions(last, priv-&gt;eimg + cnt - last);
+
+	// concat lists
+	tail = &amp;ass_renderer-&gt;images_root;
+	for (i = 0; i &lt; cnt; ++i) {
+		ass_image_t* cur = priv-&gt;eimg[i].imgs;
+		while (cur) {
+			*tail = cur;
+			tail = &amp;cur-&gt;next;
+			cur = cur-&gt;next;
+		}
+	}
+
+	if (detect_change)
+		*detect_change = ass_detect_change(priv);
+	
+	// free the previous image list
+	ass_free_images(priv-&gt;prev_images_root);
+	priv-&gt;prev_images_root = 0;
+
+	return ass_renderer-&gt;images_root;
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_types.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_types.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_types.h	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,114 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#ifndef ASS_TYPES_H
+#define ASS_TYPES_H
+
+#define VALIGN_SUB 0
+#define VALIGN_CENTER 8
+#define VALIGN_TOP 4
+#define HALIGN_LEFT 1
+#define HALIGN_CENTER 2
+#define HALIGN_RIGHT 3
+
+/// ass Style: line
+typedef struct ass_style_s {
+	char* Name;
+	char* FontName;
+	double FontSize;
+	uint32_t PrimaryColour;
+	uint32_t SecondaryColour;
+	uint32_t OutlineColour;
+	uint32_t BackColour;
+	int Bold;
+	int Italic;
+	int Underline;
+	int StrikeOut;
+	double ScaleX;
+	double ScaleY;
+	double Spacing;
+	int Angle;
+	int BorderStyle;
+	double Outline;
+	double Shadow;
+	int Alignment;
+	int MarginL;
+	int MarginR;
+	int MarginV;
+//        int AlphaLevel;
+	int Encoding;
+} ass_style_t;
+
+typedef struct render_priv_s render_priv_t;
+
+/// ass_event_t corresponds to a single Dialogue line
+/// Text is stored as-is, style overrides will be parsed later
+typedef struct ass_event_s {
+	long long Start; // ms
+	long long Duration; // ms
+
+	int ReadOrder;
+	int Layer;
+	int Style;
+	char* Name;
+	int MarginL;
+	int MarginR;
+	int MarginV;
+	char* Effect;
+	char* Text;
+
+	render_priv_t* render_priv;
+} ass_event_t;
+
+typedef struct parser_priv_s parser_priv_t;
+
+typedef struct ass_library_s ass_library_t;
+
+/// ass track represent either an external script or a matroska subtitle stream (no real difference between them)
+/// it can be used in rendering after the headers are parsed (i.e. events format line read)
+typedef struct ass_track_s {
+	int n_styles; // amount used
+	int max_styles; // amount allocated
+	int n_events;
+	int max_events;
+	ass_style_t* styles; // array of styles, max_styles length, n_styles used
+	ass_event_t* events; // the same as styles
+
+	char* style_format; // style format line (everything after &quot;Format: &quot;)
+	char* event_format; // event format line
+
+	enum {TRACK_TYPE_UNKNOWN = 0, TRACK_TYPE_ASS, TRACK_TYPE_SSA} track_type;
+	
+	// script header fields
+	int PlayResX;
+	int PlayResY;
+	double Timer;
+	int WrapStyle;
+
+	
+	int default_style; // index of default style
+	char* name; // file name in case of external subs, 0 for streams
+
+	ass_library_t* library;
+	parser_priv_t* parser_priv;
+} ass_track_t;
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.c	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,81 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+//#include &quot;config.h&quot;
+
+#include &lt;stdlib.h&gt;
+#include &lt;inttypes.h&gt;
+
+#include &quot;mputils.h&quot;
+#include &quot;ass_utils.h&quot;
+
+int mystrtoi(char** p, int base, int* res)
+{
+	char* start = *p;
+	*res = strtol(*p, p, base);
+	if (*p != start) return 1;
+	else return 0;
+}
+
+int mystrtou32(char** p, int base, uint32_t* res)
+{
+	char* start = *p;
+	*res = strtoll(*p, p, base);
+	if (*p != start) return 1;
+	else return 0;
+}
+
+int mystrtod(char** p, double* res)
+{
+	char* start = *p;
+	*res = strtod(*p, p);
+	if (*p != start) return 1;
+	else return 0;
+}
+
+int strtocolor(char** q, uint32_t* res)
+{
+	uint32_t color = 0;
+	int result;
+	char* p = *q;
+	
+	if (*p == '&amp;') ++p; 
+	else mp_msg(MSGT_ASS, MSGL_DBG2, &quot;suspicious color format: \&quot;%s\&quot;\n&quot;, p);
+	
+	if (*p == 'H' || *p == 'h') { 
+		++p;
+		result = mystrtou32(&amp;p, 16, &amp;color);
+	} else {
+		result = mystrtou32(&amp;p, 0, &amp;color);
+	}
+	
+	{
+		unsigned char* tmp = (unsigned char*)(&amp;color);
+		unsigned char b;
+		b = tmp[0]; tmp[0] = tmp[3]; tmp[3] = b;
+		b = tmp[1]; tmp[1] = tmp[2]; tmp[2] = b;
+	}
+	if (*p == '&amp;') ++p;
+	*q = p;
+
+	*res = color;
+	return result;
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/ass_utils.h	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,61 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#ifndef ASS_UTILS_H
+#define ASS_UTILS_H
+
+int mystrtoi(char** p, int base, int* res);
+int mystrtou32(char** p, int base, uint32_t* res);
+int mystrtod(char** p, double* res);
+int strtocolor(char** q, uint32_t* res);
+
+static inline int d6_to_int(int x) {
+	return (x + 32) &gt;&gt; 6;
+}
+static inline int d16_to_int(int x) {
+	return (x + 32768) &gt;&gt; 16;
+}
+static inline int int_to_d6(int x) {
+	return x &lt;&lt; 6;
+}
+static inline int int_to_d16(int x) {
+	return x &lt;&lt; 16;
+}
+static inline int d16_to_d6(int x) {
+	return (x + 512) &gt;&gt; 10;
+}
+static inline int d6_to_d16(int x) {
+	return x &lt;&lt; 10;
+}
+static inline double d6_to_double(int x) {
+	return x / 64.;
+}
+static inline int double_to_d6(double x) {
+	return (int)(x * 64);
+}
+static inline double d16_to_double(int x) {
+	return ((double)x) / 0x10000;
+}
+static inline int double_to_d16(double x) {
+	return (int)(x * 0x10000);
+}
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/help_mp.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/help_mp.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/help_mp.h	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,55 @@
+#ifndef __LIBASS_HELP_MP_H__
+#define __LIBASS_HELP_MP_H__
+#define MSGTR_LIBASS_FT_Glyph_To_BitmapError &quot;[ass] FT_Glyph_To_Bitmap error %d \n&quot;
+#define MSGTR_LIBASS_UnsupportedPixelMode &quot;[ass] Unsupported pixel mode: %d\n&quot;
+#define MSGTR_LIBASS_NoStyleNamedXFoundUsingY &quot;[ass] [%p] Warning: no style named '%s' found, using '%s'\n&quot;
+#define MSGTR_LIBASS_BadTimestamp &quot;[ass] bad timestamp\n&quot;
+#define MSGTR_LIBASS_BadEncodedDataSize &quot;[ass] bad encoded data size\n&quot;
+#define MSGTR_LIBASS_FontLineTooLong &quot;[ass] Font line too long: %d, %s\n&quot;
+#define MSGTR_LIBASS_EventFormatHeaderMissing &quot;[ass] Event format header missing\n&quot;
+#define MSGTR_LIBASS_ErrorOpeningIconvDescriptor &quot;[ass] error opening iconv descriptor.\n&quot;
+#define MSGTR_LIBASS_ErrorRecodingFile &quot;[ass] error recoding file.\n&quot;
+#define MSGTR_LIBASS_FopenFailed &quot;[ass] ass_read_file(%s): fopen failed\n&quot;
+#define MSGTR_LIBASS_FseekFailed &quot;[ass] ass_read_file(%s): fseek failed\n&quot;
+#define MSGTR_LIBASS_RefusingToLoadSubtitlesLargerThan10M &quot;[ass] ass_read_file(%s): Refusing to load subtitles larger than 10M\n&quot;
+#define MSGTR_LIBASS_ReadFailed &quot;Read failed, %d: %s\n&quot;
+#define MSGTR_LIBASS_AddedSubtitleFileMemory &quot;[ass] Added subtitle file: &lt;memory&gt; (%d styles, %d events)\n&quot;
+#define MSGTR_LIBASS_AddedSubtitleFileFname &quot;[ass] Added subtitle file: %s (%d styles, %d events)\n&quot;
+#define MSGTR_LIBASS_FailedToCreateDirectory &quot;[ass] Failed to create directory %s\n&quot;
+#define MSGTR_LIBASS_NotADirectory &quot;[ass] Not a directory: %s\n&quot;
+#define MSGTR_LIBASS_TooManyFonts &quot;[ass] Too many fonts\n&quot;
+#define MSGTR_LIBASS_ErrorOpeningFont &quot;[ass] Error opening font: %s, %d\n&quot;
+#define MSGTR_LIBASS_SelectedFontFamilyIsNotTheRequestedOne &quot;[ass] fontconfig: Selected font family is not the requested one: '%s' != '%s'\n&quot;
+#define MSGTR_LIBASS_UsingDefaultFontFamily &quot;[ass] fontconfig_select: Using default font family: (%s, %d, %d) -&gt; %s, %d\n&quot;
+#define MSGTR_LIBASS_UsingDefaultFont &quot;[ass] fontconfig_select: Using default font: (%s, %d, %d) -&gt; %s, %d\n&quot;
+#define MSGTR_LIBASS_UsingArialFontFamily &quot;[ass] fontconfig_select: Using 'Arial' font family: (%s, %d, %d) -&gt; %s, %d\n&quot;
+#define MSGTR_LIBASS_FcInitLoadConfigAndFontsFailed &quot;[ass] FcInitLoadConfigAndFonts failed.\n&quot;
+#define MSGTR_LIBASS_UpdatingFontCache &quot;[ass] Updating font cache.\n&quot;
+#define MSGTR_LIBASS_BetaVersionsOfFontconfigAreNotSupported &quot;[ass] Beta versions of fontconfig are not supported.\n[ass] Update before reporting any bugs.\n&quot;
+#define MSGTR_LIBASS_FcStrSetAddFailed &quot;[ass] FcStrSetAdd failed.\n&quot;
+#define MSGTR_LIBASS_FcDirScanFailed &quot;[ass] FcDirScan failed.\n&quot;
+#define MSGTR_LIBASS_FcDirSave &quot;[ass] FcDirSave failed.\n&quot;
+#define MSGTR_LIBASS_FcConfigAppFontAddDirFailed &quot;[ass] FcConfigAppFontAddDir failed\n&quot;
+#define MSGTR_LIBASS_FontconfigDisabledDefaultFontWillBeUsed &quot;[ass] Fontconfig disabled, only default font will be used.\n&quot;
+#define MSGTR_LIBASS_FunctionCallFailed &quot;[ass] %s failed\n&quot;
+#define MSGTR_LIBASS_NeitherPlayResXNorPlayResYDefined &quot;[ass] Neither PlayResX nor PlayResY defined. Assuming 384x288.\n&quot;
+#define MSGTR_LIBASS_PlayResYUndefinedSettingY &quot;[ass] PlayResY undefined, setting %d.\n&quot;
+#define MSGTR_LIBASS_PlayResXUndefinedSettingX &quot;[ass] PlayResX undefined, setting %d.\n&quot;
+#define MSGTR_LIBASS_FT_Init_FreeTypeFailed &quot;[ass] FT_Init_FreeType failed.\n&quot;
+#define MSGTR_LIBASS_Init &quot;[ass] Init\n&quot;
+#define MSGTR_LIBASS_InitFailed &quot;[ass] Init failed.\n&quot;
+#define MSGTR_LIBASS_BadCommand &quot;[ass] Bad command: %c%c\n&quot;
+#define MSGTR_LIBASS_ErrorLoadingGlyph  &quot;[ass] Error loading glyph.\n&quot;
+#define MSGTR_LIBASS_FT_Glyph_Stroke_Error &quot;[ass] FT_Glyph_Stroke error %d \n&quot;
+#define MSGTR_LIBASS_UnknownEffectType_InternalError &quot;[ass] Unknown effect type (internal error)\n&quot;
+#define MSGTR_LIBASS_NoStyleFound &quot;[ass] No style found!\n&quot;
+#define MSGTR_LIBASS_EmptyEvent &quot;[ass] Empty event!\n&quot;
+#define MSGTR_LIBASS_MAX_GLYPHS_Reached &quot;[ass] MAX_GLYPHS reached: event %d, start = %llu, duration = %llu\n Text = %s\n&quot;
+#define MSGTR_LIBASS_EventHeightHasChanged &quot;[ass] Warning! Event height has changed!  \n&quot;
+#define MSGTR_LIBASS_GlyphNotFoundReselectingFont &quot;[ass] Glyph 0x%X not found, reselecting font for (%s, %d, %d)\n&quot;
+#define MSGTR_LIBASS_GlyphNotFound &quot;[ass] Glyph 0x%X not found in font for (%s, %d, %d)\n&quot;
+#define MSGTR_LIBASS_ErrorOpeningMemoryFont &quot;[ass] Error opening memory font: %s\n&quot;
+#define MSGTR_LIBASS_NoCharmaps &quot;[ass] font face with no charmaps\n&quot;
+#define MSGTR_LIBASS_NoCharmapAutodetected &quot;[ass] no charmap autodetected, trying the first one\n&quot;
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.c	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,218 @@
+//#include &quot;config.h&quot;
+
+#include &quot;mputils.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdint.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
+
+#ifdef HAVE_ENCA
+#include &lt;enca.h&gt;
+#endif
+
+void my_mp_msg(int lvl, char *lvl_str, char *fmt, ...) {
+	va_list va;
+	if(lvl &gt; MSGL_V) return;
+	printf(&quot;[ass] **%s**: &quot;, lvl_str);
+	va_start(va, fmt);
+	vprintf(fmt, va);
+	va_end(va);
+}
+
+unsigned utf8_get_char(char **str) {
+  uint8_t *strp = (uint8_t *)*str;
+  unsigned c = *strp++;
+  unsigned mask = 0x80;
+  int len = -1;
+  while (c &amp; mask) {
+    mask &gt;&gt;= 1;
+    len++;
+  }
+  if (len &lt;= 0 || len &gt; 4)
+    goto no_utf8;
+  c &amp;= mask - 1;
+  while ((*strp &amp; 0xc0) == 0x80) {
+    if (len-- &lt;= 0)
+      goto no_utf8;
+    c = (c &lt;&lt; 6) | (*strp++ &amp; 0x3f);
+  }
+  if (len)
+    goto no_utf8;
+  *str = (char *)strp;
+  return c;
+
+no_utf8:
+  strp = (uint8_t *)*str;
+  c = *strp++;
+  *str = (char *)strp;
+  return c;
+}
+
+// gaussian blur
+void blur(
+	unsigned char *buffer,
+	unsigned short *tmp2,
+	int width,
+	int height,
+	int stride,
+	int *m2,
+	int r,
+	int mwidth) {
+
+    int x, y;
+
+    unsigned char  *s = buffer;
+    unsigned short *t = tmp2+1;
+    for(y=0; y&lt;height; y++){
+	memset(t-1, 0, (width+1)*sizeof(short));
+
+	for(x=0; x&lt;r; x++){
+	    const int src= s[x];
+	    if(src){
+		register unsigned short *dstp= t + x-r;
+		int mx;
+		unsigned *m3= m2 + src*mwidth;
+		for(mx=r-x; mx&lt;mwidth; mx++){
+		    dstp[mx]+= m3[mx];
+		}
+	    }
+	}
+
+	for(; x&lt;width-r; x++){
+	    const int src= s[x];
+	    if(src){
+		register unsigned short *dstp= t + x-r;
+		int mx;
+		unsigned *m3= m2 + src*mwidth;
+		for(mx=0; mx&lt;mwidth; mx++){
+		    dstp[mx]+= m3[mx];
+		}
+	    }
+	}
+
+	for(; x&lt;width; x++){
+	    const int src= s[x];
+	    if(src){
+		register unsigned short *dstp= t + x-r;
+		int mx;
+		const int x2= r+width -x;
+		unsigned *m3= m2 + src*mwidth;
+		for(mx=0; mx&lt;x2; mx++){
+		    dstp[mx]+= m3[mx];
+		}
+	    }
+	}
+
+	s+= stride;
+	t+= width + 1;
+    }
+
+    t = tmp2;
+    for(x=0; x&lt;width; x++){
+	for(y=0; y&lt;r; y++){
+	    unsigned short *srcp= t + y*(width+1) + 1;
+	    int src= *srcp;
+	    if(src){
+		register unsigned short *dstp= srcp - 1 + width+1;
+		const int src2= (src + 128)&gt;&gt;8;
+		unsigned *m3= m2 + src2*mwidth;
+
+		int mx;
+		*srcp= 128;
+		for(mx=r-1; mx&lt;mwidth; mx++){
+		    *dstp += m3[mx];
+		    dstp+= width+1;
+		}
+	    }
+	}
+	for(; y&lt;height-r; y++){
+	    unsigned short *srcp= t + y*(width+1) + 1;
+	    int src= *srcp;
+	    if(src){
+		register unsigned short *dstp= srcp - 1 - r*(width+1);
+		const int src2= (src + 128)&gt;&gt;8;
+		unsigned *m3= m2 + src2*mwidth;
+
+		int mx;
+		*srcp= 128;
+		for(mx=0; mx&lt;mwidth; mx++){
+		    *dstp += m3[mx];
+		    dstp+= width+1;
+		}
+	    }
+	}
+	for(; y&lt;height; y++){
+	    unsigned short *srcp= t + y*(width+1) + 1;
+	    int src= *srcp;
+	    if(src){
+		const int y2=r+height-y;
+		register unsigned short *dstp= srcp - 1 - r*(width+1);
+		const int src2= (src + 128)&gt;&gt;8;
+		unsigned *m3= m2 + src2*mwidth;
+
+		int mx;
+		*srcp= 128;
+		for(mx=0; mx&lt;y2; mx++){
+		    *dstp += m3[mx];
+		    dstp+= width+1;
+		}
+	    }
+	}
+	t++;
+    }
+
+    t = tmp2;
+    s = buffer;
+    for(y=0; y&lt;height; y++){
+	for(x=0; x&lt;width; x++){
+	    s[x]= t[x]&gt;&gt;8;
+	}
+	s+= stride;
+	t+= width + 1;
+    }
+}
+
+#ifdef HAVE_ENCA
+void* guess_buffer_cp(unsigned char* buffer, int buflen, char *preferred_language, char *fallback)
+{
+    const char **languages;
+    size_t langcnt;
+    EncaAnalyser analyser;
+    EncaEncoding encoding;
+    char *detected_sub_cp = NULL;
+    int i;
+
+    languages = enca_get_languages(&amp;langcnt);
+    mp_msg(MSGT_ASS, MSGL_V, &quot;ENCA supported languages: &quot;);
+    for (i = 0; i &lt; langcnt; i++) {
+	mp_msg(MSGT_ASS, MSGL_V, &quot;%s &quot;, languages[i]);
+    }
+    mp_msg(MSGT_ASS, MSGL_V, &quot;\n&quot;);
+    
+    for (i = 0; i &lt; langcnt; i++) {
+	const char *tmp;
+	
+	if (strcasecmp(languages[i], preferred_language) != 0) continue;
+	analyser = enca_analyser_alloc(languages[i]);
+	encoding = enca_analyse_const(analyser, buffer, buflen);
+	tmp = enca_charset_name(encoding.charset, ENCA_NAME_STYLE_ICONV);
+	if (tmp &amp;&amp; encoding.charset != ENCA_CS_UNKNOWN) {
+	    detected_sub_cp = strdup(tmp);
+	    mp_msg(MSGT_ASS, MSGL_INFO, &quot;ENCA detected charset: %s\n&quot;, tmp);
+	}
+	enca_analyser_free(analyser);
+    }
+    
+    free(languages);
+
+    if (!detected_sub_cp) {
+	detected_sub_cp = strdup(fallback);
+	mp_msg(MSGT_ASS, MSGL_INFO, &quot;ENCA detection failed: fallback to %s\n&quot;, fallback);
+    }
+
+    return detected_sub_cp;
+}
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_libass/mputils.h	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,35 @@
+#ifndef __MPUTILS_H__
+#define __MPUTILS_H__
+
+#include &quot;help_mp.h&quot;
+
+unsigned utf8_get_char(char **str);
+
+void my_mp_msg(int lvl, char *lvl_str, char *fmt, ...);
+
+#ifdef __VISUALC__
+static void mp_msg(int mod, int level, const char *fmt, ...) {
+	// MSVC doesn't like the # used all around for mp_msg, so it breaks va_arg
+}
+#else
+#define mp_msg(mod, level, args...) my_mp_msg(level, #level, args)
+#endif
+
+#define MSGT_ASS 43
+
+#define MSGL_FATAL 0
+#define MSGL_ERR 1
+#define MSGL_WARN 2
+#define MSGL_INFO 4
+#define MSGL_V 6
+#define MSGL_DBG2 7
+
+void blur(unsigned char *buffer, unsigned short *tmp2, int width, int height,
+          int stride, int *m2, int r, int mwidth);
+
+void* guess_buffer_cp(unsigned char* buffer, int buflen, char *preferred_language, char *fallback);
+
+#define FFMAX(a,b) ((a) &gt; (b) ? (a) : (b))
+#define FFMIN(a,b) ((a) &gt; (b) ? (b) : (a))
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_vidASS.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_vidASS.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ADM_vidASS.cpp	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,397 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+/*
+  Initial port from MPlayer by Moonz
+  Mplayer version is Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+*/
+
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_coreVideoFilterInternal.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;DIA_factory.h&quot;
+
+#include &quot;ass_ssa.h&quot;
+#include &quot;ass_ssa_desc.cpp&quot;
+
+extern &quot;C&quot;
+{
+#include &quot;ADM_libass/ass.h&quot;
+}
+
+/**
+    \class subAss
+*/
+class subAss : public  ADM_coreVideoFilter
+{
+protected:
+        ass_ssa         param;
+        ass_library_t   *_ass_lib;
+        ass_renderer_t  *_ass_rend;
+        ass_track_t     *_ass_track;
+        bool            init(void);
+        ADMImage        *src;
+public:
+                    subAss(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                    ~subAss();
+
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   subAss,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_SUBTITLE,            // Category
+                        &quot;ssa&quot;,            // internal name (must be uniq!)
+                        &quot;SSA.&quot;,            // Display name
+                        &quot;Hardcode ass/ssa subtitles using libass.&quot; // Description
+                    );
+
+
+
+#ifndef DIR_SEP
+# ifdef WIN32
+#   define DIR_SEP '\\'
+#   define DEFAULT_FONT_DIR &quot;c:&quot;
+# else
+#   define DIR_SEP '/'
+#   define DEFAULT_FONT_DIR &quot;/tmp/&quot;
+# endif
+#endif
+//*****************
+
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *subAss::getConfiguration(void)
+{
+    static char buf[500];
+    buf[0]=0;
+ 
+      sprintf((char *)buf,&quot; ASS/SSA Subtitles: &quot;);
+      
+      char *filename = (char*)param.subtitleFile;
+      if(filename)
+      {
+          if(strrchr(filename, DIR_SEP) != NULL &amp;&amp; *(strrchr(filename, DIR_SEP) + 1) != 0)
+              filename = strrchr(filename, DIR_SEP) + 1;
+          strncat(buf, filename, 49-strlen(buf));
+          buf[49] = 0;
+      }else
+      {
+        strcat(buf,&quot; (no sub)&quot;);       
+      }
+      return buf;
+}
+/**
+    \fn ctor
+*/
+subAss::subAss( ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilter(in,setup)
+{	
+	 if(!setup || !ADM_paramLoad(setup,ass_ssa_param,&amp;param))
+    {
+            param.font_scale = 1.;
+            param.line_spacing = param.topMargin = param.bottomMargin = 0;
+            param.subtitleFile = NULL;
+            param.fontDirectory = ADM_strdup(DEFAULT_FONT_DIR);
+            param.extractEmbeddedFonts = 1;
+    }  	  	
+        src=new ADMImageDefault(in-&gt;getInfo()-&gt;width,in-&gt;getInfo()-&gt;height);
+
+        /* ASS initialization */
+        _ass_lib = ass_library_init();
+        _ass_track = NULL;
+        _ass_rend = NULL;
+        ADM_assert(_ass_lib);
+        if(param.subtitleFile)
+        {
+              if(!init())
+              {
+                GUI_Error_HIG(&quot;Format ?&quot;,&quot;Are you sure this is an ass file ?&quot;); 
+              }
+        }
+}
+/**
+    \fn dtor
+*/
+#define DELETE(x) if(x) {ADM_dealloc(x);x=NULL;}
+subAss::~subAss()
+{
+      if(src) delete src;
+      src=NULL;
+      
+        
+        DELETE(param.subtitleFile);
+        DELETE(param.fontDirectory);
+
+#if ASS_HAS_GLOBAL
+        if(_ass_rend) 
+        {
+              ass_renderer_done(_ass_rend);
+              _ass_rend = NULL;
+         }
+
+        if(_ass_track) 
+        {
+              ass_free_track(_ass_track);
+              _ass_track = NULL;
+        }
+        if(_ass_lib) 
+        {
+              ass_library_done(_ass_lib);
+              _ass_lib = NULL;
+        }
+#endif
+}
+
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         subAss::getCoupledConf(CONFcouple **couples)
+{
+    return ADM_paramSave(couples, ass_ssa_param,&amp;param);
+}
+
+/**
+    \fn configure
+*/
+bool subAss::configure(void)
+{
+ 
+#define PX(x) &amp;(param.x)
+#define MKME(x,y) x=(ELEM_TYPE_FLOAT)param.y
+  ELEM_TYPE_FLOAT scale,spacing;
+  
+    MKME(scale,font_scale);
+    MKME(spacing,line_spacing);
+    
+    diaElemFile       file(0,(char **)PX(subtitleFile),QT_TR_NOOP(&quot;_Subtitle file (ASS/SSA):&quot;), NULL, QT_TR_NOOP(&quot;Select Subtitle file&quot;));
+    diaElemFloat      dSpacing(&amp;spacing,QT_TR_NOOP(&quot;_Line spacing:&quot;),0.10,10.0);
+    diaElemFloat      dScale(&amp;scale,QT_TR_NOOP(&quot;_Font scale:&quot;),0.10,10.0);
+    diaElemUInteger   dTop(PX(topMargin),QT_TR_NOOP(&quot;_Top margin:&quot;),0,200);
+    diaElemUInteger   dBottom(PX(bottomMargin),QT_TR_NOOP(&quot;Botto_m margin&quot;),0,200);
+    
+       diaElem *elems[5]={&amp;file,&amp;dSpacing,&amp;dScale,&amp;dTop,&amp;dBottom};
+  
+   if( diaFactoryRun(QT_TR_NOOP(&quot;ASS&quot;),5,elems))
+   {
+#undef MKME
+#define MKME(x,y) param.y=(float)x
+    MKME(scale,font_scale);
+    MKME(spacing,line_spacing);
+
+     return true;
+   }
+   return false;
+}
+
+/**
+    \fn init
+*/
+bool subAss::init(void)
+{
+bool use_margins = ( param.topMargin | param.bottomMargin ) != 0;
+
+        memcpy(&amp;info,previousFilter-&gt;getInfo(),sizeof(info));
+        info.height += param.topMargin + param.bottomMargin;
+
+        ass_set_fonts_dir(_ass_lib, (const char*)param.fontDirectory);
+        ass_set_extract_fonts(_ass_lib, param.extractEmbeddedFonts);
+        ass_set_style_overrides(_ass_lib, NULL);
+#if ASS_HAS_GLOBAL
+         if(_ass_rend) 
+        {
+              ass_renderer_done(_ass_rend);
+              _ass_rend = NULL;
+         }
+#endif
+        _ass_rend = ass_renderer_init(_ass_lib);
+
+        ADM_assert(_ass_rend);
+ 
+        ass_set_frame_size(_ass_rend, info.width, info.height);
+        ass_set_margins(_ass_rend, param.topMargin, param.bottomMargin, 0, 0);
+        ass_set_use_margins(_ass_rend, use_margins);
+        ass_set_font_scale(_ass_rend, param.font_scale);
+        ass_set_fonts(_ass_rend, NULL, &quot;Sans&quot;);
+        //~ ass_set_aspect_ratio(_ass_rend, ((double)_info.width) / ((double)_info.height));
+#if ASS_HAS_GLOBAL
+        if(_ass_track) 
+        {
+              ass_free_track(_ass_track);
+              _ass_track = NULL;
+        }
+#endif
+       _ass_track = ass_read_file(_ass_lib, (char*)param.subtitleFile, NULL);
+
+//        ADM_assert(_ass_track);
+        if(!_ass_track)
+          GUI_Error_HIG(&quot;SSA Error&quot;,&quot;Cannot read_file for *%s*&quot;,(char*)param.subtitleFile);
+        return 1;
+} 
+
+//*******************************************
+#define _r(c)  ((c)&gt;&gt;24)
+#define _g(c)  (((c)&gt;&gt;16)&amp;0xFF)
+#define _b(c)  (((c)&gt;&gt;8)&amp;0xFF)
+#define _a(c)  ((c)&amp;0xFF)
+#define rgba2y(c)  ( (( 263*_r(c)  + 516*_g(c) + 100*_b(c)) &gt;&gt; 10) + 16  )
+#define rgba2u(c)  ( (( 450*_r(c) - 376*_g(c) -  73*_b(c)) &gt;&gt; 10) + 128 )
+#define rgba2v(c)  ( ((-152*_r(c) - 298*_g(c) + 450*_b(c)) &gt;&gt; 10) + 128 )
+/**
+    \fn nextFrame
+*/
+static bool blacken(ADMImage *src, uint32_t lineStart, uint32_t howto)
+{
+        for(int i=0;i&lt;3;i++)
+            {
+                uint32_t w=src-&gt;_width;
+                uint32_t h=src-&gt;_height;
+                uint8_t filler=16;
+                uint32_t count=howto;
+                uint32_t lineOffset=lineStart;
+                if(i) {w&gt;&gt;=1;h&gt;&gt;=1;filler=128;count&gt;&gt;=1;lineOffset&gt;&gt;=1;}
+                ADM_PLANE plane=(ADM_PLANE)i;
+
+                uint8_t *dy=src-&gt;GetWritePtr(plane);
+                uint32_t dpitch=src-&gt;GetPitch(plane);
+                
+                dy+=dpitch*lineOffset;
+
+                for(int y=0;y&lt;count;y++)
+                {
+                    memset(dy,filler,w);
+                    dy+=dpitch;
+                 }
+            }
+            return true;
+}
+/**
+    \fn getNextFrame
+*/
+bool subAss::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    if(!previousFilter-&gt;getNextFrame(fn,src))
+    {
+        ADM_info(&quot;[blackenBorder] Cannot get previous image\n&quot;);
+        return false;
+    }
+ 
+        uint32_t  i, j, k, l, val;
+        uint8_t y, u, v, opacity;
+        int32_t orig_u, orig_v,klong,newu,newv;
+        uint8_t orig_y;
+        uint8_t *bitmap, *ydata, *udata, *vdata;
+
+       
+       /* copy source to image */
+
+        src-&gt;copyTo(image,0,param.topMargin);
+
+        /* Add black border if needed */
+        if(param.topMargin)
+            blacken(image, 0, param.topMargin);
+        if(param.bottomMargin)
+            blacken(image, src-&gt;_height+param.topMargin, param.bottomMargin);
+
+        image-&gt;copyInfo(src); // pts etc..
+        // Do we have something to render ?
+        if(!_ass_rend || !_ass_track)
+        {
+          printf(&quot;[Ass] No sub to render\n&quot;);
+          return true; 
+        }
+        
+        int changed=0;
+        int64_t now=previousFilter-&gt;getAbsoluteStartTime()+src-&gt;Pts;
+        now/=1000; // Ass works in ms
+        ass_image_t *img = ass_render_frame(_ass_rend, _ass_track, now,&amp;changed);
+        
+
+        while(img) {
+                  y = rgba2y(img-&gt;color);
+                  u = rgba2u(img-&gt;color);
+                  v = rgba2v(img-&gt;color);
+
+                  opacity = 255 - _a(img-&gt;color);
+
+                  
+
+                  uint8_t *planes[3];
+                  uint32_t pitches[3];
+            
+                  image-&gt;GetPitches(pitches);
+                  image-&gt;GetWritePlanes(planes);
+
+                  ydata = planes[0]+pitches[0]*img-&gt;dst_y;
+                  udata = planes[1]+pitches[1]*(img-&gt;dst_y/2);
+                  vdata = planes[2]+pitches[2]*(img-&gt;dst_y/2);
+
+                  // do y
+                  bitmap = img-&gt;bitmap;
+                  for(i = 0; i &lt; img-&gt;h; ++i) 
+                  {
+                          for(j = 0; j &lt; img-&gt;w; ++j) 
+                          {
+                                  k = *(bitmap+j) * opacity / 255;
+                                  orig_y = *(ydata+j);
+                                  *(ydata+j) = (k*y + (255-k)*orig_y) / 255;
+                          }
+
+                          bitmap += img-&gt;stride;
+                          ydata += pitches[0];
+                  }
+                  // Now do u &amp; v
+                  bitmap = img-&gt;bitmap;
+                  
+                  newu=u-128;
+                  newv=v-128;
+
+                  for(i = 0; i &lt; img-&gt;h; i += 2) 
+                  {
+                          for(j = 0, l = 0; j &lt; img-&gt;w; j += 2, ++l) 
+                          {
+                                  val = 0;
+                                  val += *(bitmap + j);
+                                  val += *(bitmap + j + 1);
+                                  val += *(bitmap + img-&gt;stride + j);
+                                  val += *(bitmap + img-&gt;stride + j + 1);
+                                  val &gt;&gt;= 2;
+
+                                  k = val * opacity / 255;
+                                  orig_u = *(udata+l);
+                                  orig_v = *(vdata+l);
+
+                                  orig_u=( k*u+(255-k)*orig_u)/255;
+                                  orig_v=( k*v+(255-k)*orig_v)/255;
+                                  *(udata+l) = orig_u;
+                                  *(vdata+l) = orig_v;
+                          }
+
+                          bitmap += img-&gt;stride &lt;&lt; 1;
+                          udata += pitches[1];
+                          vdata += pitches[2];
+                  }
+
+                  img = img-&gt;next;
+        }
+        return true;
+}
+
+/************************************************/
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/CMakeLists.txt	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,20 @@
+INCLUDE(admCheckFreeType)
+checkFreeType()
+
+IF (USE_FREETYPE)
+	ADD_SUBDIRECTORY(ADM_libass)
+
+	INCLUDE(vf_plugin)
+	SET(ADM_vf_ssa_SRCS ADM_vidASS.cpp)
+
+        ADD_VIDEO_FILTER(ADM_vf_ssa ${ADM_vf_ssa_SRCS})
+        IF(DO_COMMON)
+         TARGET_LINK_LIBRARIES(ADM_vf_ssa ADM_libass )
+	 ADD_TARGET_LDFLAGS(ADM_vf_ssa &quot;${FREETYPE2_LDFLAGS}&quot;)
+	 IF (FONTCONFIG_FOUND)
+		ADD_TARGET_LDFLAGS(ADM_vf_ssa &quot;${FONTCONFIG_LDFLAGS}&quot;)
+	 ENDIF (FONTCONFIG_FOUND)
+        ENDIF(DO_COMMON)
+        INIT_VIDEO_FILTER(ADM_vf_ssa)
+        INSTALL_VIDEO_FILTER(ADM_vf_ssa)
+ENDIF (USE_FREETYPE)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa.conf	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,7 @@
+float:font_scale
+float:line_spacing
+string:subtitleFile
+string:fontDirectory
+uint32_t:extractEmbeddedFonts
+uint32_t:topMargin
+uint32_t:bottomMargin

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa.h	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,14 @@
+// Automatically generated, do not edit!
+#ifndef ADM_ass_ssa_CONF_H
+#define ADM_ass_ssa_CONF_H
+typedef struct {
+   float font_scale;
+   float line_spacing;
+   char * subtitleFile;
+   char * fontDirectory;
+   uint32_t extractEmbeddedFonts;
+   uint32_t topMargin;
+   uint32_t bottomMargin;
+}ass_ssa;
+#endif //ass_ssa
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass/ass_ssa_desc.cpp	2010-09-04 16:33:33 UTC (rev 6583)
@@ -0,0 +1,11 @@
+// Automatically generated, do not edit!
+const ADM_paramList ass_ssa_param[]={
+ {&quot;font_scale&quot;,offsetof( ass_ssa,font_scale),&quot;float&quot;,ADM_param_float},
+ {&quot;line_spacing&quot;,offsetof( ass_ssa,line_spacing),&quot;float&quot;,ADM_param_float},
+ {&quot;subtitleFile&quot;,offsetof( ass_ssa,subtitleFile),&quot;char *&quot;,ADM_param_string},
+ {&quot;fontDirectory&quot;,offsetof( ass_ssa,fontDirectory),&quot;char *&quot;,ADM_param_string},
+ {&quot;extractEmbeddedFonts&quot;,offsetof( ass_ssa,extractEmbeddedFonts),&quot;uint32_t&quot;,ADM_param_uint32_t},
+ {&quot;topMargin&quot;,offsetof( ass_ssa,topMargin),&quot;uint32_t&quot;,ADM_param_uint32_t},
+ {&quot;bottomMargin&quot;,offsetof( ass_ssa,bottomMargin),&quot;uint32_t&quot;,ADM_param_uint32_t},
+{NULL,0,NULL}
+};


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003768.html">[Avidemux-svn-commit] r6582 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml
</A></li>
	<LI>Next message: <A HREF="003770.html">[Avidemux-svn-commit] r6584 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/ass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3769">[ date ]</a>
              <a href="thread.html#3769">[ thread ]</a>
              <a href="subject.html#3769">[ subject ]</a>
              <a href="author.html#3769">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
