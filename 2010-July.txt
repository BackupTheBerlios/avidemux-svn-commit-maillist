From mean at mail.berlios.de  Sat Jul  3 13:20:26 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat,  3 Jul 2010 13:20:26 +0200
Subject: [Avidemux-svn-commit] r6434 -
	branches/avidemux_2.5_branch_gruntster/scripts/auto
Message-ID: <20100703112026.B26C3480BF3@sheep.berlios.de>

Author: mean
Date: 2010-07-03 13:20:26 +0200 (Sat, 03 Jul 2010)
New Revision: 6434

Added:
   branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple iPod.js
   branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js
Log:
[auto] Put back PSP & ipod

Added: branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple iPod.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple iPod.js	                        (rev 0)
+++ branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple iPod.js	2010-07-03 11:20:26 UTC (rev 6434)
@@ -0,0 +1,41 @@
+//AD
+include("video/autoWizard.js");
+include("video/filter.js");
+
+var app = new Avidemux();
+
+if (app.video == null)
+    displayError(QT_TR_NOOP("A video file must be open to use this Auto Wizard."));
+else
+{
+    var result = videoAutoWizard(QT_TR_NOOP("Apple iPod Auto Wizard"), [[320, 240]]);
+
+    if (result)
+    {
+        var targetX = result[0][0];
+        var targetY = result[0][1];
+        var sourceRatio = result[1][0] + ":" + result[1][1];
+        var destinationRatio = result[2][0] + ":" + result[2][1];
+
+        resizeAndFillVideo(targetX, targetY, sourceRatio, destinationRatio);
+
+        app.video.codecPlugin("32BCB447-21C9-4210-AE9A-4FCE6C8588AE", "x264", "2PASSBITRATE=600", "<?xml version='1.0'?><x264Config><presetConfiguration><name>Apple iPod</name><type>system</type></presetConfiguration><x264Options></x264Options></x264Config>");
+
+        if (app.audio.targetTrackInfo.length > 0)
+        {
+            if (app.audio.targetTrackInfo[0].codec == "AAC" && app.audio.targetTrackInfo[0].channelCount == 2)
+                app.audio.codec("copy",0,0,"");
+            else
+            {
+                app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
+
+                if (app.audio.targetTrackInfo[0].channelCount == 2)
+                    app.audio.mixer = "NONE";
+                else
+                    app.audio.mixer = "STEREO";
+            }
+        }
+
+        app.setContainer("MP4");
+    }
+}

Added: branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js	                        (rev 0)
+++ branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js	2010-07-03 11:20:26 UTC (rev 6434)
@@ -0,0 +1,41 @@
+//AD
+include("video/autoWizard.js");
+include("video/filter.js");
+
+var app = new Avidemux();
+
+if (app.video == null)
+    displayError(QT_TR_NOOP("A video file must be open to use this Auto Wizard."));
+else
+{
+    var result = videoAutoWizard(QT_TR_NOOP("Sony PSP Auto Wizard"), [[480, 272], [720, 480]]);
+
+    if (result)
+    {
+        var targetX = result[0][0];
+        var targetY = result[0][1];
+        var sourceRatio = result[1][0] + ":" + result[1][1];
+        var destinationRatio = result[2][0] + ":" + result[2][1];
+
+        resizeAndFillVideo(targetX, targetY, sourceRatio, destinationRatio);
+
+        app.video.codecPlugin("32BCB447-21C9-4210-AE9A-4FCE6C8588AE", "x264", "2PASSBITRATE=1000", "<?xml version='1.0'?><x264Config><presetConfiguration><name>Sony PlayStation Portable</name><type>system</type></presetConfiguration><x264Options></x264Options></x264Config>");
+
+        if (app.audio.targetTrackInfo.length > 0)
+        {
+            if (app.audio.targetTrackInfo[0].codec == "AAC" && app.audio.targetTrackInfo[0].channelCount == 2)
+                app.video.codec("Copy", "CQ=4", "0 ");
+            else
+            {
+                app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
+
+                if (app.audio.targetTrackInfo[0].channelCount == 2)
+                    app.audio.mixer = "NONE";
+                else
+                    app.audio.mixer = "STEREO";
+            }
+        }
+
+        app.setContainer("PSP");
+    }
+}
\ No newline at end of file



From mean at mail.berlios.de  Sun Jul  4 19:18:08 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun,  4 Jul 2010 19:18:08 +0200
Subject: [Avidemux-svn-commit] r6435 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <20100704171808.21C29480D6D@sheep.berlios.de>

Author: mean
Date: 2010-07-04 19:18:07 +0200 (Sun, 04 Jul 2010)
New Revision: 6435

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
Log:
[UI] dont use null as pointer for project name

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2010-07-03 11:20:26 UTC (rev 6434)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2010-07-04 17:18:07 UTC (rev 6435)
@@ -593,7 +593,7 @@
 //  DIA_StopBusy ();
 
   // forget last project file
-    video_body->setProjectName(NULL);
+    video_body->setProjectName("");
 
   if (res!=ADM_OK)			// an error occured
     {



From mean at mail.berlios.de  Sun Jul  4 19:18:09 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun,  4 Jul 2010 19:18:09 +0200
Subject: [Avidemux-svn-commit] r6436 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src
Message-ID: <20100704171809.5784F480D6D@sheep.berlios.de>

Author: mean
Date: 2010-07-04 19:18:09 +0200 (Sun, 04 Jul 2010)
New Revision: 6436

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
Log:
[VDPAU] Add the get_format override to properly initialize vdpau for h264

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-07-04 17:18:07 UTC (rev 6435)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-07-04 17:18:09 UTC (rev 6436)
@@ -207,6 +207,35 @@
     dec->releaseBuffer(avctx,pic);
 }
 /**
+    \fn vdpauGetFormat
+    \brief Borrowed from mplayer
+
+*/
+extern "C"
+{
+static enum PixelFormat vdpauGetFormat(struct AVCodecContext *avctx,  const enum PixelFormat *fmt)
+{
+    int i;
+
+    for(i=0;fmt[i]!=PIX_FMT_NONE;i++)
+    {
+        PixelFormat c=fmt[i];
+        switch(c)
+        {
+            case PIX_FMT_VDPAU_H264:
+            case PIX_FMT_VDPAU_MPEG1:
+            case PIX_FMT_VDPAU_MPEG2:
+            case PIX_FMT_VDPAU_WMV3:
+            case PIX_FMT_VDPAU_VC1:
+                        return c;
+            default:break;
+
+        }
+    }
+    return PIX_FMT_NONE;
+}
+}
+/**
     \fn decoderFFVDPAU
 */
 decoderFFVDPAU::decoderFFVDPAU(uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, 
@@ -222,8 +251,8 @@
         _context->draw_horiz_band = draw;
         _context->slice_flags     = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
         _context->extradata = (uint8_t *) extraData;
-        _context->extradata_size = (int) extraDataLen;
-
+        _context->extradata_size  = (int) extraDataLen;
+        _context->get_format      = vdpauGetFormat;
         vdpau=(void *)new vdpauContext;
         VDPAU->vdpDecoder=VDP_INVALID_HANDLE;
         ADM_VDPAU_TYPE vdpauType=ADM_VDPAU_INVALID;



From mean at mail.berlios.de  Sun Jul  4 19:18:10 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun,  4 Jul 2010 19:18:10 +0200
Subject: [Avidemux-svn-commit] r6437 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src
Message-ID: <20100704171810.72EB3480D6D@sheep.berlios.de>

Author: mean
Date: 2010-07-04 19:18:10 +0200 (Sun, 04 Jul 2010)
New Revision: 6437

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp
Log:
[VDPAU] Re-enable VC1 decoding through vdpau

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp	2010-07-04 17:18:09 UTC (rev 6436)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp	2010-07-04 17:18:10 UTC (rev 6437)
@@ -48,7 +48,7 @@
   if(fromPlugin) return fromPlugin;
 #if defined(USE_VDPAU) 
   ADM_info("Searching decoder in vdpau (%d x %d, extradataSize:%d)...\n",w,h,extraLen);
-  if (isH264Compatible (fcc) || isMpeg12Compatible(fcc) || 0*isVC1Compatible(fcc))
+  if (isH264Compatible (fcc) || isMpeg12Compatible(fcc) || 1*isVC1Compatible(fcc))
     {
         ADM_info("This is vdpau compatible\n");
         if(true==vdpauUsable())



From mean at mail.berlios.de  Mon Jul  5 07:13:55 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon,  5 Jul 2010 07:13:55 +0200
Subject: [Avidemux-svn-commit] r6438 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config
Message-ID: <20100705051355.983AE480DEF@sheep.berlios.de>

Author: mean
Date: 2010-07-05 07:13:55 +0200 (Mon, 05 Jul 2010)
New Revision: 6438

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c
Log:
[FFmpeg] Enable MDCT, needed by (E) EAC3/AAC/...

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h	2010-07-04 17:18:10 UTC (rev 6437)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h	2010-07-05 05:13:55 UTC (rev 6438)
@@ -557,6 +557,7 @@
 #define ENABLE_YASM      0
 #define HAVE_YASM        0
 #endif // USE_YASM
+#define CONFIG_MDCT     1
 #define CONFIG_H264DSP  1
 #define ENABLE_ARM      0
 #define ENABLE_PPC      0

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c	2010-07-04 17:18:10 UTC (rev 6437)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c	2010-07-05 05:13:55 UTC (rev 6438)
@@ -635,6 +635,7 @@
         printf("#define HAVE_YASM        0\n");
         printf("#endif // USE_YASM\n");
 
+	printf("#define CONFIG_MDCT     1\n");
 	printf("#define CONFIG_H264DSP  1\n");
         printf("#define ENABLE_ARM      0\n");
         printf("#define ENABLE_PPC      0\n");



From gruntster at mail.berlios.de  Tue Jul  6 20:24:49 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue,  6 Jul 2010 20:24:49 +0200
Subject: [Avidemux-svn-commit] r6439 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog
Message-ID: <20100706182449.7F25C480C24@sheep.berlios.de>

Author: gruntster
Date: 2010-07-06 20:24:49 +0200 (Tue, 06 Jul 2010)
New Revision: 6439

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_pluginManager.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_pluginManager.h
Log:
[plugmgr] clear default when plugin is disabled

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_pluginManager.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_pluginManager.cpp	2010-07-05 05:13:55 UTC (rev 6438)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_pluginManager.cpp	2010-07-06 18:24:49 UTC (rev 6439)
@@ -65,6 +65,11 @@
 
 	fillVideoEncoderList(manager);
 	ui.pluginTableView->resizeColumnsToContents();
+
+	connect(
+		ui.pluginTableView->model(),
+		SIGNAL(itemChanged(QStandardItem*)), this,
+		SLOT(pluginTableView_itemChanged(QStandardItem*)));
 }
 
 void Ui_pluginManagerWindow::fillVideoEncoderList(UiPluginManager manager)
@@ -113,7 +118,7 @@
 			QString(id.c_str()), QString(itPlugin->second.name.c_str()), QString(itPlugin->second.version.c_str()),
 			QString(itPlugin->second.description.c_str()), itRankedPlugin->enabled, itRankedPlugin->isDefault);
 
-		if (itRankedPlugin->isDefault)
+		if (!defaultSet && itRankedPlugin->isDefault)
 			defaultSet = true;
 	}
 
@@ -122,7 +127,7 @@
 		ui.pluginTableView->selectRow(0);
 
 		if (!defaultSet)
-			setDefault(0);
+			setDefaultRow(0);
 	}
 
 }
@@ -133,11 +138,17 @@
 	ui.moveDownButton->setEnabled((current.row() + 1) != ui.pluginTableView->model()->rowCount());
 }
 
+void Ui_pluginManagerWindow::pluginTableView_itemChanged(QStandardItem* item)
+{
+	if (item->column() == 0 && item->checkState() == Qt::Unchecked)
+		clearDefaultRow(item->row());
+}
+
 void Ui_pluginManagerWindow::setDefaultButton_clicked(bool)
 {
 	QStandardItemModel *model = (QStandardItemModel*)ui.pluginTableView->model();
 	
-	setDefault(ui.pluginTableView->selectionModel()->currentIndex().row());
+	setDefaultRow(ui.pluginTableView->selectionModel()->currentIndex().row());
 }
 
 void Ui_pluginManagerWindow::enableAllButton_clicked(bool)
@@ -180,10 +191,10 @@
 	model->setItem(row, 2, descItem);
 
 	if (isDefault)
-		setDefault(row);
+		setDefaultRow(row);
 }
 
-void Ui_pluginManagerWindow::setDefault(int defaultRow)
+void Ui_pluginManagerWindow::setDefaultRow(int defaultRow)
 {
 	QStandardItemModel *model = (QStandardItemModel*)ui.pluginTableView->model();
 
@@ -204,6 +215,23 @@
 	}
 }
 
+void Ui_pluginManagerWindow::clearDefaultRow(int defaultRow)
+{
+	QStandardItemModel *model = (QStandardItemModel*)ui.pluginTableView->model();
+	QStandardItem *item = model->item(defaultRow, 0);
+
+	item->setData(false, PLUGIN_IS_DEFAULT);
+
+	for (int column = 0; column < model->columnCount(); column++)
+	{
+		QStandardItem *item = model->item(defaultRow, column);
+		QFont font = item->font();
+
+		font.setBold(false);
+		item->setFont(font);
+	}
+}
+
 void Ui_pluginManagerWindow::checkAllItems(bool checked)
 {
 	for (int i = 0; i < ui.pluginTableView->model()->rowCount(); i++)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_pluginManager.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_pluginManager.h	2010-07-05 05:13:55 UTC (rev 6438)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_pluginManager.h	2010-07-06 18:24:49 UTC (rev 6439)
@@ -24,7 +24,8 @@
 	void fillVideoEncoderList(UiPluginManager manager);
 	void addRow(QString id, QString name, QString version, QString desc, bool enabled, bool isDefault);
 	void checkAllItems(bool check);
-	void setDefault(int defaultRow);
+	void setDefaultRow(int defaultRow);
+	void clearDefaultRow(int defaultRow);
 	void moveSelectedItem(bool up);
 
 public:
@@ -33,6 +34,7 @@
 
 private slots:
 	void pluginTableView_rowChanged(const QModelIndex current, const QModelIndex previous);
+	void pluginTableView_itemChanged(QStandardItem *item);
 	void setDefaultButton_clicked(bool);
 	void enableAllButton_clicked(bool);
 	void disableAllButton_clicked(bool);



From gruntster at mail.berlios.de  Tue Jul  6 20:39:33 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue,  6 Jul 2010 20:39:33 +0200
Subject: [Avidemux-svn-commit] r6440 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_encoder
	ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <20100706183933.A935C480C24@sheep.berlios.de>

Author: gruntster
Date: 2010-07-06 20:39:33 +0200 (Tue, 06 Jul 2010)
New Revision: 6440

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_pluginLoad.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
Log:
[qt] honour default video encoder on startup

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_pluginLoad.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_pluginLoad.cpp	2010-07-06 18:24:49 UTC (rev 6439)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_pluginLoad.cpp	2010-07-06 18:39:33 UTC (rev 6440)
@@ -28,7 +28,7 @@
 using namespace std;
 
 vector<COMPRES_PARAMS> AllVideoCodec;
-int defaultVideoEncoder = 0;
+int defaultVideoEncoder = -1;
 
 extern COMPRES_PARAMS *internalVideoCodec[];
 extern int getInternalVideoCodecCount();
@@ -268,9 +268,6 @@
 		if (!itRankedPlugin->enabled)
 			continue;
 
-		if (itRankedPlugin->isDefault)
-			defaultVideoEncoder = AllVideoCodec.size();
-
 		// internal
 		for (int i = 0; i < internalCodecCount; i++)
 		{			
@@ -288,6 +285,9 @@
 				AllVideoCodec.push_back(param);
 				found = true;
 
+				if (itRankedPlugin->isDefault)
+					defaultVideoEncoder = AllVideoCodec.size() - 1;
+
 				break;
 			}
 		}
@@ -350,6 +350,11 @@
 				pluginOptions[length] = 0;
 
 				updateCompressionParameters(&param, encodeOptions.encodeMode, encodeOptions.encodeModeParameter, pluginOptions, length);
+
+				if (itRankedPlugin->isDefault)
+					defaultVideoEncoder = AllVideoCodec.size() - 1;
+
+				break;
 			}
 
 			counter++;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp	2010-07-06 18:24:49 UTC (rev 6439)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp	2010-07-06 18:39:33 UTC (rev 6440)
@@ -36,6 +36,7 @@
 #define MODULE_NAME MODULE_ENCODER
 #include "ADM_osSupport/ADM_debug.h"
 
+extern int defaultVideoEncoder;
 extern std::vector<COMPRES_PARAMS> AllVideoCodec;
 extern uint8_t DIA_videoCodec(int *codecIndex);
 extern void UI_setVideoCodec(int i);
@@ -44,7 +45,6 @@
 
 // Some static stuff
 void setVideoEncoderSettings(COMPRESSION_MODE mode, uint32_t param, uint32_t extraConf, uint8_t *extraData);
-static void encoderPrint(void);
 
 #include "adm_encConfig.h"
 #include "adm_encoder.h"
@@ -257,6 +257,11 @@
 	return AllVideoCodec.size();
 }
 
+int encoderGetDefaultIndex(void)
+{
+	return defaultVideoEncoder;
+}
+
 // Return the name of the encoder #i, as displayer by a menu/combo box
 const char *encoderGetIndexedName(uint32_t i)
 {
@@ -275,11 +280,6 @@
 	currentCodecIndex = newCodecIndex;
 }
 
-void encoderPrint(void)
-{
-	UI_setVideoCodec(currentCodecIndex);
-}
-
 SelectCodecType videoCodecGetType(void)
 {
 	return currentCodecType;
@@ -399,7 +399,7 @@
 void videoCodecSelect(void)
 {
   DIA_videoCodec(&currentCodecIndex);
-  encoderPrint ();
+  UI_setVideoCodec(currentCodecIndex);
   // HERE UI_PrintCurrentVCodec( (currentCodecType))
 
 }
@@ -408,7 +408,7 @@
 {
 	currentCodecIndex = codecIndex;
 	currentCodecType = AllVideoCodec[codecIndex].codec;
-	encoderPrint();
+	UI_setVideoCodec(currentCodecIndex);
 }
 
 void videoCodecConfigureUI(int codecIndex)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2010-07-06 18:24:49 UTC (rev 6439)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2010-07-06 18:39:33 UTC (rev 6440)
@@ -41,6 +41,7 @@
 extern int automation(void );
 extern void HandleAction(Action a);
 extern bool isVideoCodecConfigurable(void);
+extern int encoderGetDefaultIndex(void);
 extern int encoderGetEncoderCount (void);
 extern const char *encoderGetIndexedName (uint32_t i);
 uint32_t audioEncoderGetNumberOfEncoders(void);
@@ -878,6 +879,9 @@
 		WIDGET(comboBoxVideo)->addItem(name);
 	}
 
+	if (encoderGetDefaultIndex() > -1)
+		UI_setVideoCodec(encoderGetDefaultIndex());
+
 	// And A codec
 
 	uint32_t nbAud;



From gruntster at mail.berlios.de  Tue Jul  6 22:53:55 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue,  6 Jul 2010 22:53:55 +0200
Subject: [Avidemux-svn-commit] r6441 - in
	branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts:
	. avidemux
Message-ID: <20100706205355.F0785480C24@sheep.berlios.de>

Author: gruntster
Date: 2010-07-06 22:53:55 +0200 (Tue, 06 Jul 2010)
New Revision: 6441

Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Perform Build.bat
Log:
[win32] tweak build scripts for CMake 2.8

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat	2010-07-06 18:39:33 UTC (rev 6440)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat	2010-07-06 20:53:55 UTC (rev 6441)
@@ -44,13 +44,13 @@
 
 set qtDir=%qtDir%\%qtVer%
 
-if exist "%devDir%\CMake 2.6\bin" (
-	set cmakeDir=%devDir%\CMake 2.6\bin
+if exist "%devDir%\CMake 2.8\bin" (
+	set cmakeDir=%devDir%\CMake 2.8\bin
 	goto foundCMake
 )
 
-if exist "%ProgramFiles32%\CMake 2.6\bin" (
-	set cmakeDir=%ProgramFiles32%\CMake 2.6\bin
+if exist "%ProgramFiles32%\CMake 2.8\bin" (
+	set cmakeDir=%ProgramFiles32%\CMake 2.8\bin
 ) else (
 	echo CMake could not be found.  Please download from http://www.cmake.org
 	goto error

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Perform Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Perform Build.bat	2010-07-06 18:39:33 UTC (rev 6440)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Perform Build.bat	2010-07-06 20:53:55 UTC (rev 6441)
@@ -1,12 +1,12 @@
 cd "%sourceDir%\%buildFolder%"
-cmake -G"MSYS Makefiles" -DCMAKE_INSTALL_PREFIX="%buildDir%" -DCMAKE_EXE_LINKER_FLAGS="-shared-libgcc" -DCMAKE_SHARED_LINKER_FLAGS="-shared-libgcc" -DUSE_SYSTEM_SPIDERMONKEY=ON -DCMAKE_INCLUDE_PATH="%SpiderMonkeySourceDir%" -DCMAKE_LIBRARY_PATH="%SpiderMonkeyLibDir%" %DebugFlags% ..
+cmake -G"MSYS Makefiles" -DCMAKE_INSTALL_PREFIX="%buildDir%" -DCMAKE_EXE_LINKER_FLAGS="-shared-libgcc" -DCMAKE_SHARED_LINKER_FLAGS="-shared-libgcc %LDFLAGS%" -DUSE_SYSTEM_SPIDERMONKEY=ON -DCMAKE_INCLUDE_PATH="%SpiderMonkeySourceDir%" -DCMAKE_LIBRARY_PATH="%SpiderMonkeyLibDir%" %DebugFlags% ..
 
 if errorlevel 1 goto error
 pause
 
 set msysSourceDir=%sourceDir:\=/%
 cd "%sourceDir%\%buildPluginFolder%"
-cmake -G"MSYS Makefiles" -DCMAKE_INSTALL_PREFIX="%buildDir%" -DAVIDEMUX_CORECONFIG_DIR="%msysSourceDir%/%buildFolder%/config" -DAVIDEMUX_INSTALL_PREFIX="%buildDir%" -DAVIDEMUX_SOURCE_DIR="%msysSourceDir%" -DCMAKE_EXE_LINKER_FLAGS="-shared-libgcc" -DCMAKE_SHARED_LINKER_FLAGS="-shared-libgcc" %DebugFlags% ../plugins
+cmake -G"MSYS Makefiles" -DCMAKE_INSTALL_PREFIX="%buildDir%" -DAVIDEMUX_CORECONFIG_DIR="%msysSourceDir%/%buildFolder%/config" -DAVIDEMUX_INSTALL_PREFIX="%buildDir%" -DAVIDEMUX_SOURCE_DIR="%msysSourceDir%" -DCMAKE_EXE_LINKER_FLAGS="-shared-libgcc" -DCMAKE_SHARED_LINKER_FLAGS="-shared-libgcc %LDFLAGS%" %DebugFlags% ../plugins
 
 if errorlevel 1 goto error
 pause



From gruntster at mail.berlios.de  Tue Jul  6 22:55:50 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue,  6 Jul 2010 22:55:50 +0200
Subject: [Avidemux-svn-commit] r6442 - in
	branches/avidemux_2.5_branch_gruntster:
	avidemux/ADM_coreImage/src cmake cmake/patches
Message-ID: <20100706205550.B6227480C24@sheep.berlios.de>

Author: gruntster
Date: 2010-07-06 22:55:50 +0200 (Tue, 06 Jul 2010)
New Revision: 6442

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/yuv.cpp
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_file.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
Log:
[ffmpeg] update FFmpeg to r24078 & libswscale to r31642

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/yuv.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/yuv.cpp	2010-07-06 20:53:55 UTC (rev 6441)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/yuv.cpp	2010-07-06 20:55:50 UTC (rev 6442)
@@ -26,7 +26,7 @@
 #include <string.h>
 
 #include "ADM_default.h"
-#include "libavcodec/colorspace.h"
+#include "libavutil/colorspace.h"
 
 uint8_t COL_422_YV12( uint8_t *in[3], uint32_t stride[3],  uint8_t *out,uint32_t w, uint32_t h)
 {

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-07-06 20:53:55 UTC (rev 6441)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-07-06 20:55:50 UTC (rev 6442)
@@ -1,7 +1,7 @@
 include(admFFmpegUtil)
 
-set(FFMPEG_VERSION 23514)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=e98e85c1eb2e0b00e95714d98c61ffa55be349d4;sf=tgz
-set(SWSCALE_VERSION 31344)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=0eac904069b4398edd7d57784eb56883b26ee380;sf=tgz
+set(FFMPEG_VERSION 24078)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=831c3578f4948450c5b186dad4608638f13dce44;sf=tgz
+set(SWSCALE_VERSION 31642)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=fbeec9e0c5f6be5bb5ac082c2dc5c435628005c4;sf=tgz
 
 set(LIBRARY_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries")
 set(FFMPEG_SOURCE_DIR "${LIBRARY_SOURCE_DIR}/ffmpeg")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2010-07-06 20:53:55 UTC (rev 6441)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2010-07-06 20:55:50 UTC (rev 6442)
@@ -1,8 +1,8 @@
-*** libavcodec/avcodec.h.old	Mon Jun  7 19:34:55 2010
---- libavcodec/avcodec.h	Mon Jun  7 19:34:55 2010
+*** libavcodec/avcodec.h.old	Tue Jul  6 19:51:18 2010
+--- libavcodec/avcodec.h	Tue Jul  6 19:51:18 2010
 ***************
-*** 599,604 ****
---- 599,606 ----
+*** 600,605 ****
+--- 600,607 ----
   #define CODEC_FLAG2_PSY           0x00080000 ///< Use psycho visual optimizations.
   #define CODEC_FLAG2_SSIM          0x00100000 ///< Compute SSIM during encoding, error[] values are undefined.
   #define CODEC_FLAG2_INTRA_REFRESH 0x00200000 ///< Use periodic insertion of intra blocks instead of keyframes.
@@ -12,8 +12,8 @@
   /* Unsupported options :
    *              Syntax Arithmetic coding (SAC)
 ***************
-*** 1474,1479 ****
---- 1476,1482 ----
+*** 1482,1487 ****
+--- 1484,1490 ----
        * - decoding: unused
        */
       int rc_max_rate;
@@ -22,8 +22,8 @@
       /**
        * minimum bitrate
 ***************
-*** 1488,1493 ****
---- 1491,1498 ----
+*** 1496,1501 ****
+--- 1499,1506 ----
        * - decoding: unused
        */
       int rc_buffer_size;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch	2010-07-06 20:53:55 UTC (rev 6441)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch	2010-07-06 20:55:50 UTC (rev 6442)
@@ -1,8 +1,8 @@
-*** libavcodec/ffv1.c.old	Sun Apr 11 11:34:07 2010
---- libavcodec/ffv1.c	Sun Apr 11 11:34:07 2010
+*** libavcodec/ffv1.c.old	Tue Jul  6 19:51:19 2010
+--- libavcodec/ffv1.c	Tue Jul  6 19:51:19 2010
 ***************
-*** 1107,1112 ****
---- 1107,1114 ----
+*** 1112,1117 ****
+--- 1112,1119 ----
           clear_state(f);
       }else{
           p->key_frame= 0;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2010-07-06 20:53:55 UTC (rev 6441)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2010-07-06 20:55:50 UTC (rev 6442)
@@ -1,8 +1,8 @@
-*** libavcodec/h264.c.old	Mon Jun  7 19:34:59 2010
---- libavcodec/h264.c	Mon Jun  7 19:34:59 2010
+*** libavcodec/h264.c.old	Tue Jul  6 19:51:21 2010
+--- libavcodec/h264.c	Tue Jul  6 19:51:21 2010
 ***************
-*** 3381,3386 ****
---- 3381,3399 ----
+*** 3382,3387 ****
+--- 3382,3400 ----
       return 0;
   }
   

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2010-07-06 20:53:55 UTC (rev 6441)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2010-07-06 20:55:50 UTC (rev 6442)
@@ -1,7 +1,7 @@
-*** libavcodec/mpegvideo.c.old	Mon Jun  7 19:35:02 2010
---- libavcodec/mpegvideo.c	Mon Jun  7 19:35:02 2010
+*** libavcodec/mpegvideo.c.old	Tue Jul  6 19:51:24 2010
+--- libavcodec/mpegvideo.c	Tue Jul  6 19:51:24 2010
 ***************
-*** 641,647 ****
+*** 652,658 ****
       FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
   
       s->parse_context.state= -1;
@@ -9,7 +9,7 @@
          s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
          s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
          s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
---- 641,651 ----
+--- 652,662 ----
       FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
   
       s->parse_context.state= -1;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2010-07-06 20:53:55 UTC (rev 6441)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2010-07-06 20:55:50 UTC (rev 6442)
@@ -1,8 +1,8 @@
-*** libavcodec/utils.c.old	Mon Jun  7 19:35:04 2010
---- libavcodec/utils.c	Mon Jun  7 19:35:04 2010
+*** libavcodec/utils.c.old	Tue Jul  6 19:51:25 2010
+--- libavcodec/utils.c	Tue Jul  6 19:51:25 2010
 ***************
-*** 643,652 ****
---- 643,654 ----
+*** 636,645 ****
+--- 636,647 ----
   
       if((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size){
           //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
@@ -15,20 +15,3 @@
           if(*frame_size_ptr < FF_MIN_BUFFER_SIZE ||
           *frame_size_ptr < avctx->channels * avctx->frame_size * sizeof(int16_t)){
               av_log(avctx, AV_LOG_ERROR, "buffer %d too small\n", *frame_size_ptr);
-***************
-*** 1091,1097 ****
-          return -1;
-      }
-  #if !HAVE_MKSTEMP
-!     fd = open(*filename, O_RDWR | O_BINARY | O_CREAT, 0444);
-  #else
-      snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
-      fd = mkstemp(*filename);
---- 1093,1099 ----
-          return -1;
-      }
-  #if !HAVE_MKSTEMP
-!     fd = open(*filename, O_RDWR /* MEANX | O_BINARY*/ | O_CREAT, 0444);
-  #else
-      snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
-      fd = mkstemp(*filename);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_file.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_file.c.patch	2010-07-06 20:53:55 UTC (rev 6441)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_file.c.patch	2010-07-06 20:55:50 UTC (rev 6442)
@@ -1,8 +1,8 @@
-*** libavformat/file.c.old	Sun Apr 11 11:34:11 2010
---- libavformat/file.c	Sun Apr 11 11:34:11 2010
+*** libavformat/file.c.old	Tue Jul  6 19:51:26 2010
+--- libavformat/file.c	Tue Jul  6 19:51:26 2010
 ***************
-*** 31,36 ****
---- 31,105 ----
+*** 30,35 ****
+--- 30,104 ----
   #include <stdlib.h>
   #include "os_support.h"
   

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch	2010-07-06 20:53:55 UTC (rev 6441)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch	2010-07-06 20:55:50 UTC (rev 6442)
@@ -1,7 +1,7 @@
-*** libavformat/isom.c.old	Mon Jun  7 19:35:06 2010
---- libavformat/isom.c	Mon Jun  7 19:35:06 2010
+*** libavformat/isom.c.old	Tue Jul  6 19:51:27 2010
+--- libavformat/isom.c	Tue Jul  6 19:51:27 2010
 ***************
-*** 213,219 ****
+*** 215,221 ****
       { CODEC_ID_MP1, MKTAG('.', 'm', 'p', '1') }, /* MPEG layer 1 */
       { CODEC_ID_MP2, MKTAG('.', 'm', 'p', '2') }, /* MPEG layer 2 */
   
@@ -9,7 +9,7 @@
       { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
   
   /*  { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at http://heroinewarrior.com/xmovie.php3 use this tag */
---- 213,222 ----
+--- 215,224 ----
       { CODEC_ID_MP1, MKTAG('.', 'm', 'p', '1') }, /* MPEG layer 1 */
       { CODEC_ID_MP2, MKTAG('.', 'm', 'p', '2') }, /* MPEG layer 2 */
   

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2010-07-06 20:53:55 UTC (rev 6441)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2010-07-06 20:55:50 UTC (rev 6442)
@@ -1,8 +1,8 @@
-*** libavformat/matroskaenc.c.old	Mon Jun  7 19:35:07 2010
---- libavformat/matroskaenc.c	Mon Jun  7 19:35:07 2010
+*** libavformat/matroskaenc.c.old	Tue Jul  6 19:51:28 2010
+--- libavformat/matroskaenc.c	Tue Jul  6 19:51:28 2010
 ***************
-*** 408,413 ****
---- 408,414 ----
+*** 407,412 ****
+--- 407,413 ----
   
   static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec)
   {
@@ -11,8 +11,8 @@
       int header_len[3];
       int first_header_size;
 ***************
-*** 432,437 ****
---- 433,460 ----
+*** 431,436 ****
+--- 432,459 ----
           put_buffer(pb, header_start[j], header_len[j]);
   
       return 0;
@@ -42,8 +42,8 @@
   
   static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
 ***************
-*** 550,555 ****
---- 573,596 ----
+*** 549,554 ****
+--- 572,595 ----
           put_ebml_uint (pb, MATROSKA_ID_TRACKUID        , i + 1);
           put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
   



From mean at mail.berlios.de  Fri Jul  9 07:26:47 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri,  9 Jul 2010 07:26:47 +0200
Subject: [Avidemux-svn-commit] r6443 - in branches/avidemux_2.6_branch_mean:
	avidemux/common avidemux/common/ADM_editor
	avidemux/common/ADM_script2/binding
	avidemux/common/ADM_script2/include
	avidemux/common/ADM_script2/js avidemux/common/ADM_script2/py
	avidemux/common/ADM_script2/src
	avidemux/qt4/ADM_userInterfaces/ADM_shell
	avidemux_core/ADM_coreTinyPy/include
	avidemux_core/ADM_coreTinyPy/src cmake
Message-ID: <20100709052647.C23A1480B01@sheep.berlios.de>

Author: mean
Date: 2010-07-09 07:26:47 +0200 (Fri, 09 Jul 2010)
New Revision: 6443

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/adm_print.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/print_stat.patch
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/editor.admPyClass
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptCommon.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptEditor.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/ADM_pyAdm.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/editor_gen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAvidemux.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/include/ADM_tinypy.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/ADM_tinypy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/tinypy.cpp
   branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl
Log:
[py] Merge print patch + editor func + switch float to double, incomplete as tinypy still uses float internally

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2010-07-09 05:26:47 UTC (rev 6443)
@@ -602,6 +602,11 @@
     _segments.dump();
     return true;
 }
+bool                ADM_Composer::dumpSegment(int i)
+{
+    _segments.dumpSegment(i);
+    return true;
+}
 /**
 
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-07-09 05:26:47 UTC (rev 6443)
@@ -228,6 +228,7 @@
 // For js
                     bool                dumpRefVideos(void);
                     bool                dumpSegments(void);
+                    bool                dumpSegment(int i);
                     bool                dumpTiming(void);
                     bool                getVideoPtsDts(uint32_t frame, uint32_t *flags,uint64_t *pts, uint64_t *dts);
 /******************************* /Editing **********************************/										

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-07-09 05:26:47 UTC (rev 6443)
@@ -376,7 +376,8 @@
 */
 static bool TimeToFrame(_VIDEOS *v,uint64_t time,uint32_t *frame,uint32_t *oflags)
 {
-    vidHeader 							*demuxer=v->_aviheader;  
+    vidHeader *demuxer=v->_aviheader;  
+    bool warn=false;
     int nb=demuxer->getMainHeader()->dwTotalFrames;
     for(int i=0;i<nb;i++)
     {
@@ -390,6 +391,15 @@
                 *oflags=flags;
                 return true;
             }
+            if(dts!=ADM_NO_PTS && warn==false)
+            {
+                if(dts>time)
+                {
+                    ADM_error("We reached frame %d with a PTS of %"LLU" when looking for PTS %"LLU"\n",
+                                            i,dts,time);
+                    warn=true;
+                }
+            }
     }
     return false;
 }
@@ -490,6 +500,17 @@
     printf("We have %d segments\n",n);
     for(int i=0;i<n;i++)
     {
+      dumpSegment(i);
+    }
+}
+void       ADM_EditorSegment::dumpSegment(int i)
+{
+    int n=segments.size();
+    if(i>=n)
+    {
+        ADM_error("Segment %d too big (%d)\n",i,(int)n);
+        return ;
+    }
         _SEGMENT *s=getSegment(i);
         
         jsLog("Segment :%d/%d",i,n);
@@ -498,7 +519,6 @@
         jsLog( "\tduration     :%08"LLU" %s",s->_durationUs,ADM_us2plain(s->_durationUs));
         jsLog( "\trefStartPts  :%08"LLU" %s",s->_refStartTimeUs,ADM_us2plain(s->_refStartTimeUs));
         jsLog( "\trefStartDts  :%08"LLU" %s",s->_refStartDts,ADM_us2plain(s->_refStartDts));
-    }
 }
 /**
     \fn dumpRefVideos

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2010-07-09 05:26:47 UTC (rev 6443)
@@ -105,6 +105,8 @@
 
 public:
             void        dump(void);
+            void        dumpSegment(int i);
+
             void        dumpRefVideos(void);
                         ADM_EditorSegment(void);
                         ~ADM_EditorSegment();

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass	2010-07-09 05:26:47 UTC (rev 6443)
@@ -5,7 +5,7 @@
 /* METHOD */ int scriptLoadVideo:loadVideo          (str ) 
 /* METHOD */ int scriptClearSegments:clearSegments  (void) 
 /* METHOD */ int scriptAppendVideo:appendVideo      (str ) 
-/* METHOD */ int scriptAddSegment:addSegment        (int ,float , float ) 
+/* METHOD */ int scriptAddSegment:addSegment        (int ,double , double ) 
 /* METHOD */ int scriptSetPostProc:setPostProc      (int ,int , int ) 
 /* METHOD */ int scriptGetWidth:getWidth            (void) 
 /* METHOD */ int scriptGetHeight:getHeight          (void) 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/editor.admPyClass
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/editor.admPyClass	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/editor.admPyClass	2010-07-09 05:26:47 UTC (rev 6443)
@@ -1,7 +1,10 @@
 #              cname:pyname
 /* CLASS */ pyEditor : void : ADM_PYID_EDITOR
 /* METHOD */ int jsPrintTiming:printTiming      (int ) 
-/* METHOD */ int jsDumpSegments:dumpSegment     (void) 
+/* METHOD */ int scriptGetNbSegment:nbSegments  (void)
+/* METHOD */ int jsDumpSegments:dumpAllSegments    (void) 
+/* METHOD */ void scriptDumpSegment:dumpSegment     (int) 
+/* METHOD */ double scriptGetVideoDuration:getVideoDuration  (void) 
 /* METHOD */ int jsDumpRefVideos:dumpRefVideo   (void) 
 /* METHOD */ int jsHexDumpFrame:hexDumpFrame    (int) 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptCommon.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptCommon.h	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptCommon.h	2010-07-09 05:26:47 UTC (rev 6443)
@@ -43,6 +43,8 @@
 int scriptSetPostProc (int a,int b, int c);
 char *scriptGetVideoCodec ( void);
 
+int  scriptGetNbSegment(void);
+void scriptDumpSegment(int i);
 #ifdef __cplusplus
 };
 #endif 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptEditor.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptEditor.h	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptEditor.h	2010-07-09 05:26:47 UTC (rev 6443)
@@ -23,6 +23,7 @@
 int jsHexDumpFrame(int framenumber );
 int jsDumpSegments (void);
 int jsDumpRefVideos (void);
+float scriptGetVideoDuration(void);
 #ifdef __cplusplus
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor.cpp	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor.cpp	2010-07-09 05:26:47 UTC (rev 6443)
@@ -92,4 +92,12 @@
         
         return 0;
 }// end PostProcess
+/**
+    \fn scriptGetVideoDuration
+*/
+float scriptGetVideoDuration(void)
+{
+    uint64_t d=video_body->getVideoDuration();
+    return (float)d;
+}
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/ADM_pyAdm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/ADM_pyAdm.cpp	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/ADM_pyAdm.cpp	2010-07-09 05:26:47 UTC (rev 6443)
@@ -53,8 +53,7 @@
 #include "pyDFMenu_gen.cpp"
 #include "pyDialogFactory_gen.cpp"
 
-extern pyRegisterClass initClasspyAdm;
-extern pyRegisterClass initClasspyEditor;
+
 /**
 
 */
@@ -69,13 +68,13 @@
 static bool initPy(tinyPy *py)
 {
     py->init();
-    py->registerClass("Avidemux",initClasspyAdm);
-    py->registerClass("Editor",initClasspyEditor);
-    py->registerClass("Gui",initClasspyGui);
-    py->registerClass("DFToggle",initClasspyDFToggle);
-    py->registerClass("DFInteger",initClasspyDFInteger);
-    py->registerClass("DFMenu",initClasspyDFMenu);
-    py->registerClass("DialogFactory",initClasspyDialogFactory);
+    py->registerClass("Avidemux",initClasspyAdm,"avidemux class");
+    py->registerClass("Editor",initClasspyEditor,"add, remove videos");
+    py->registerClass("Gui",initClasspyGui,"widget, alert boxes,..");
+    py->registerClass("DFToggle",initClasspyDFToggle,"UI element : toggle");
+    py->registerClass("DFInteger",initClasspyDFInteger,"UI element : integer");
+    py->registerClass("DFMenu",initClasspyDFMenu,"UI element : drop down menu");
+    py->registerClass("DialogFactory",initClasspyDialogFactory, "UI manager, handle all UI elements");
 
     py->registerFuncs("test",pyHelpers_functions);
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2010-07-09 05:26:47 UTC (rev 6443)
@@ -144,15 +144,15 @@
   int r=  scriptGetWidth(); 
   return tp_number(r);
 }
-// addSegment -> int scriptAddSegment (int  float   float  ) 
+// addSegment -> int scriptAddSegment (int  double   double  ) 
 static tp_obj zzpy_addSegment(TP)
  {
   tp_obj self=tp_getraw( tp);
   tinyParams pm(tp);
   void *me=(void *)pm.asThis(&self,ADM_PYID_AVIDEMUX);
   int p0= pm.asInt();
-  float p1= pm.asFloat();
-  float p2= pm.asFloat();
+  double p1= pm.asDouble();
+  double p2= pm.asDouble();
   int r=  scriptAddSegment(p0,p1,p2); 
   return tp_number(r);
 }
@@ -366,7 +366,7 @@
   jsLog("saveAudio(str)");
   jsLog("videoCodec(str,couples)");
   jsLog("getWidth(void)");
-  jsLog("addSegment(int ,float , float )");
+  jsLog("addSegment(int ,double , double )");
   jsLog("clearVideoFilters(void)");
   jsLog("saveJpeg(str)");
   jsLog("setContainer(str,couples)");

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/editor_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/editor_gen.cpp	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/editor_gen.cpp	2010-07-09 05:26:47 UTC (rev 6443)
@@ -1,4 +1,22 @@
 // Generated by admPyClass.pl do not edit !
+// nbSegments -> int scriptGetNbSegment (void ) 
+static tp_obj zzpy_nbSegments(TP)
+ {
+  tp_obj self=tp_getraw( tp);
+  tinyParams pm(tp);
+  void *me=(void *)pm.asThis(&self,ADM_PYID_EDITOR);
+  int r=  scriptGetNbSegment(); 
+  return tp_number(r);
+}
+// dumpAllSegments -> int jsDumpSegments (void ) 
+static tp_obj zzpy_dumpAllSegments(TP)
+ {
+  tp_obj self=tp_getraw( tp);
+  tinyParams pm(tp);
+  void *me=(void *)pm.asThis(&self,ADM_PYID_EDITOR);
+  int r=  jsDumpSegments(); 
+  return tp_number(r);
+}
 // printTiming -> int jsPrintTiming (int  ) 
 static tp_obj zzpy_printTiming(TP)
  {
@@ -19,15 +37,25 @@
   int r=  jsHexDumpFrame(p0); 
   return tp_number(r);
 }
-// dumpSegment -> int jsDumpSegments (void ) 
-static tp_obj zzpy_dumpSegment(TP)
+// getVideoDuration -> double scriptGetVideoDuration (void ) 
+static tp_obj zzpy_getVideoDuration(TP)
  {
   tp_obj self=tp_getraw( tp);
   tinyParams pm(tp);
   void *me=(void *)pm.asThis(&self,ADM_PYID_EDITOR);
-  int r=  jsDumpSegments(); 
+  double r=  scriptGetVideoDuration(); 
   return tp_number(r);
 }
+// dumpSegment -> void scriptDumpSegment (int ) 
+static tp_obj zzpy_dumpSegment(TP)
+ {
+  tp_obj self=tp_getraw( tp);
+  tinyParams pm(tp);
+  void *me=(void *)pm.asThis(&self,ADM_PYID_EDITOR);
+  int p0= pm.asInt();
+  scriptDumpSegment(p0); 
+
+}
 // dumpRefVideo -> int jsDumpRefVideos (void ) 
 static tp_obj zzpy_dumpRefVideo(TP)
  {
@@ -43,6 +71,14 @@
   tinyParams pm(vm);
   void *me=(void *)pm.asThis(&self,ADM_PYID_EDITOR);
   char const *key = pm.asString();
+  if (!strcmp(key, "nbSegments"))
+  {
+     return tp_method(vm,self,zzpy_nbSegments);
+  }
+  if (!strcmp(key, "dumpAllSegments"))
+  {
+     return tp_method(vm,self,zzpy_dumpAllSegments);
+  }
   if (!strcmp(key, "printTiming"))
   {
      return tp_method(vm,self,zzpy_printTiming);
@@ -51,6 +87,10 @@
   {
      return tp_method(vm,self,zzpy_hexDumpFrame);
   }
+  if (!strcmp(key, "getVideoDuration"))
+  {
+     return tp_method(vm,self,zzpy_getVideoDuration);
+  }
   if (!strcmp(key, "dumpSegment"))
   {
      return tp_method(vm,self,zzpy_dumpSegment);
@@ -86,9 +126,12 @@
 }
 static tp_obj zzpy__pyEditor_help(TP)
  {
+  jsLog("nbSegments(void)");
+  jsLog("dumpAllSegments(void)");
   jsLog("printTiming(int )");
   jsLog("hexDumpFrame(int)");
-  jsLog("dumpSegment(void)");
+  jsLog("getVideoDuration(void)");
+  jsLog("dumpSegment(int)");
   jsLog("dumpRefVideo(void)");
 };
 tp_obj initClasspyEditor(tp_vm *vm)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAvidemux.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAvidemux.cpp	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAvidemux.cpp	2010-07-09 05:26:47 UTC (rev 6443)
@@ -93,6 +93,17 @@
     }
     return 0;
 }
+/**
+    \fn scriptGetNbSegment()
 
-
+*/
+int  scriptGetNbSegment(void)
+{
+   return video_body->getNbSegment() ;
+}
+void scriptDumpSegment(int i)
+{
+        video_body->dumpSegment(i);
+        return ;
+}
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2010-07-09 05:26:47 UTC (rev 6443)
@@ -876,10 +876,12 @@
   bool ret;
   ADM_info("Executing tinyPy script :%s\n",name);
   char *longname = ADM_PathCanonize(name);
-   if (playing){
-      GUI_PlayAvi();
+   if (playing)
+   {
+        return false;
    }
    ret = parseTinyPyScript(longname);
+   A_Resync(); // total duration & stuff
    if( ret == true )
    {
       video_body->setProjectName(longname);
@@ -893,10 +895,12 @@
 bool A_parseECMAScript(const char *name){
   bool ret;
   char *longname = ADM_PathCanonize(name);
-   if (playing){
-      GUI_PlayAvi();
+   if (playing)
+    {
+      return false;
    }
    ret = parseECMAScript(longname);
+   A_Resync(); // total duration & stuff
    if( ret == true )
    {
       video_body->setProjectName(longname);

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp	2010-07-09 05:26:47 UTC (rev 6443)
@@ -94,7 +94,7 @@
         case SCRIPT_LOG_NORMAL: ui.textBrowser->setTextColor(QColor(0,0,0));break;
         case SCRIPT_LOG_ERROR : ui.textBrowser->setTextColor(QColor(255,0,0));break;
     }
-    ui.textBrowser->append(string.toAscii());
+    ui.textBrowser->append(string);
     ui.textBrowser->setTextColor(QColor(0,0,0));
     return true;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/include/ADM_tinypy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/include/ADM_tinypy.h	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/include/ADM_tinypy.h	2010-07-09 05:26:47 UTC (rev 6443)
@@ -15,8 +15,19 @@
  ***************************************************************************/
 #ifndef ADM_TINYPY_H
 #define ADM_TINYPY_H
+#include "ADM_cpp.h"
 #include "tinypy.h"
 #include "ADM_confCouple.h"
+
+
+typedef struct
+{
+    string className;
+    string desc;
+}admPyClassDescriptor;
+
+
+
 /**
     \struct tyFunc
 */
@@ -40,7 +51,7 @@
                 tinyPy(void);
         bool    init(void);
         bool    registerFuncs(const char *group,pyFuncs *funcs);
-        bool    registerClass(const char *className,pyRegisterClass *pyclass);
+        bool    registerClass(const char *className,pyRegisterClass *pyclass,const char *desc);
                 ~tinyPy(void);
         bool    execString(const char *s);
         bool    execFile(const char *f);
@@ -63,7 +74,7 @@
 public:
         tinyParams(tp_vm *i) {tp=i;}
         int    asInt(void);
-        float  asFloat(void);
+       // float  asFloat(void);
         double asDouble(void);
 const   char  *asString(void);
         void  *asThis(tp_obj *self,int id);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/ADM_tinypy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/ADM_tinypy.cpp	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/ADM_tinypy.cpp	2010-07-09 05:26:47 UTC (rev 6443)
@@ -21,12 +21,14 @@
 #include "tinypy.h"
 #include "init_math.cpp"
 //}
+#include "ADM_cpp.h"
 #define INSTANCE ((tp_vm *)instance)
 #define SCRIPT   ((tp_obj *)script)
 
 pyLoggerFunc *pyLog=NULL;
 static tp_obj    tinyPy_dumpBuiltin(tp_vm *vm);
 static pyFuncs addons[]={{"help",tinyPy_dumpBuiltin},{NULL,NULL}};
+static vector <admPyClassDescriptor> listOfPyClass;;
 /**
 
 */
@@ -66,6 +68,7 @@
 tinyPy::tinyPy(void)
 {
     instance=NULL;
+    listOfPyClass.clear();
 }
 /**
     \fn tinypy
@@ -79,6 +82,7 @@
         tp_deinit(INSTANCE);
         instance=NULL;
     }
+    listOfPyClass.clear();
 }
 /**
     \fn tinypy
@@ -170,9 +174,14 @@
 /**
     \fn registerClass
 */
-bool    tinyPy::registerClass(const char *className,pyRegisterClass classPy)
+bool    tinyPy::registerClass(const char *className,pyRegisterClass classPy, const char *desc)
 {
     ADM_info("Registering class:%s\n",className);
+    admPyClassDescriptor  classDesc;
+    classDesc.className=string(className);
+    classDesc.desc=string(desc);
+    listOfPyClass.push_back(classDesc);
+    
     tp_set(INSTANCE, INSTANCE->builtins, tp_string(className), classPy(INSTANCE));
     return true;
 
@@ -182,6 +191,7 @@
 */
 tp_obj    tinyPy_dumpBuiltin(tp_vm *vm)
 {
+#if 0
     ADM_info("Dumping builtins\n");
     tp_obj builtins=vm->builtins;
     // It is a dict..
@@ -195,6 +205,14 @@
             pyPrintf("%s\n",str);
     }
     return tp_None;
+#endif
+    int n=listOfPyClass.size();
+    pyPrintf("You can get more help using CLASSNAME.help()\n");
+    for(int i=0;i<n;i++)
+    {
+        pyPrintf("%s \t%s\n",listOfPyClass[i].className.c_str(),listOfPyClass[i].desc.c_str());
+    }
+    return tp_None;
 }
 //*********************************************
 #define preamble(xtype) tp_obj obj=TP_OBJ();\
@@ -213,11 +231,13 @@
 /**
    \fn  asFloat
 */
+#if 0
 float    tinyParams::asFloat(void)
 {
     preamble(TP_NUMBER);
     return (float)obj.number.val;
 }
+#endif
 /**
    \fn  asDouble
 */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/adm_print.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/adm_print.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/adm_print.patch	2010-07-09 05:26:47 UTC (rev 6443)
@@ -0,0 +1,95 @@
+--- tinypy.c.org	2010-05-20 17:21:34.195371840 +0200
++++ tinypy.cpp	2010-07-06 20:49:12.780690579 +0200
+@@ -119,6 +119,10 @@
+ #ifndef tp_inline
+ #error "Unsuported compiler"
+ #endif
++// MEANX : Redirect printf
++bool pyPrintf(const char *fmt,...);
++#define printf pyPrintf
++// ************************
+ 
+ /*  #define tp_malloc(x) calloc((x),1)
+     #define tp_realloc(x,y) realloc(x,y)
+@@ -462,7 +466,8 @@
+ 
+ tp_inline static void tp_echo(TP,tp_obj e) {
+     e = tp_str(tp,e);
+-    fwrite(e.string.val,1,e.string.len,stdout);
++    //fwrite(e.string.val,1,e.string.len,stdout); // MEANX
++    printf("%s",e.string.val);
+ }
+ 
+ /* Function: tp_string_n
+@@ -980,12 +985,14 @@
+  * This is how you can create a tinypy function object which, when called in
+  * the script, calls the provided C function.
+  */
++
++//tp_obj tp_fnc_new(TP,int t, void *v, tp_obj c,tp_obj s, tp_obj g) ;
+ tp_obj tp_fnc(TP,tp_obj v(TP)) {
+-    return tp_fnc_new(tp,0,v,tp_None,tp_None,tp_None);
++    return tp_fnc_new(tp,0,(void *)v,tp_None,tp_None, tp_None);
+ }
+ 
+ tp_obj tp_method(TP,tp_obj self,tp_obj v(TP)) {
+-    return tp_fnc_new(tp,2,v,tp_None,self,tp_None);
++    return tp_fnc_new(tp,2,(void*)v,tp_None,self,tp_None);
+ }
+ 
+ /* Function: tp_data
+@@ -2198,6 +2205,7 @@
+         exit(-1);
+ #else
+         tp->ex = e;
++        printf("\nException:\n"); tp_echo(tp,e); printf("\n");
+         longjmp(tp->nextexpr,1);
+ #endif
+     }
+@@ -2234,6 +2242,7 @@
+     tp_print_stack(tp);
+     exit(-1);
+ #else
++    tp_print_stack(tp);
+     longjmp(tp->nextexpr,1);
+ #endif
+ }
+@@ -2425,6 +2434,7 @@
+             #ifdef TP_SANDBOX
+             tp_bounds(tp,cur,SVBC);
+             #endif
++            {
+             int a = (*(cur+1)).string.val-f->code.string.val;
+             RA = tp_def(tp,
+                 /*tp_string_n((*(cur+1)).string.val,(SVBC-1)*4),*/
+@@ -2432,6 +2442,7 @@
+                 f->globals);
+             cur += SVBC; continue;
+             }
++            }
+             break;
+ 
+         case TP_IRETURN: tp_return(tp,RA); SR(0); break;
+@@ -2445,11 +2456,13 @@
+             tp_bounds(tp,cur,VA);
+             #endif
+             ;
++            {
+             int a = (*(cur+1)).string.val-f->code.string.val;
+ /*            f->line = tp_string_n((*(cur+1)).string.val,VA*4-1);*/
+             f->line = tp_string_sub(tp,f->code,a,a+VA*4-1);
+ /*             fprintf(stderr,"%7d: %s\n",UVBC,f->line.string.val);*/
+             cur += VA; f->lineno = UVBC;
++            }
+             break;
+         case TP_IFILE: f->fname = RA; break;
+         case TP_INAME: f->name = RA; break;
+@@ -2558,7 +2571,7 @@
+ 
+ void tp_builtins(TP) {
+     tp_obj o;
+-    struct {const char *s;void *f;} b[] = {
++    struct {const char *s;tp_obj (*f)(TP);} b[] = {
+     {"print",tp_print}, {"range",tp_range}, {"min",tp_min},
+     {"max",tp_max}, {"bind",tp_bind}, {"copy",tp_copy},
+     {"import",tp_import_}, {"len",tp_len_}, {"assert",tp_assert},

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/print_stat.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/print_stat.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/print_stat.patch	2010-07-09 05:26:47 UTC (rev 6443)
@@ -0,0 +1,49 @@
+Index: encode.py
+===================================================================
+--- encode.py	(revision 148)
++++ encode.py	(working copy)
+@@ -348,6 +348,10 @@
+             mod]))
+         mod.type = 'name'
+         do_set_ctx(mod,Token(t.pos,'reg',v))
++def do_print(t):
++    r = do_call(Token(t.pos,'call',None,[
++        Token(t.pos,'name','print')] + t.items))
++    free_tmp(r)
+ def do_from(t):
+     mod = t.items[0]
+     mod.type = 'string'
+@@ -628,7 +632,7 @@
+     'module':do_module,'statements':do_statements,'def':do_def,
+     'return':do_return,'while':do_while,'if':do_if,
+     'break':do_break,'pass':do_pass,'continue':do_continue,'for':do_for,
+-    'class':do_class,'raise':do_raise,'try':do_try,'import':do_import,
++    'class':do_class,'raise':do_raise,'try':do_try,'import':do_import,'print':do_print,
+     'globals':do_globals,'del':do_del,'from':do_from,
+ }
+ rmap = {
+Index: parse.py
+===================================================================
+--- parse.py	(revision 148)
++++ parse.py	(working copy)
+@@ -374,6 +374,7 @@
+     'raise':{'lbp':0,'nud':prefix_nud0,'type':'raise','bp':20,},
+     'return':{'lbp':0,'nud':prefix_nud0,'type':'return','bp':10,},
+     'import':{'lbp':0,'nud':prefix_nuds,'type':'import','bp':20,},
++    'print':{'lbp':0,'nud':prefix_nuds,'type':'print','bp':20,},
+     'from':{'lbp':0,'nud':from_nud,'type':'from','bp':20,},
+     'del':{'lbp':0,'nud':prefix_nuds,'type':'del','bp':10,},
+     'global':{'lbp':0,'nud':prefix_nuds,'type':'globals','bp':20,},
+Index: tokenize.py
+===================================================================
+--- tokenize.py	(revision 148)
++++ tokenize.py	(working copy)
+@@ -14,7 +14,7 @@
+ 
+ ISYMBOLS = '`-=[];,./~!@$%^&*()+{}:<>?|'
+ SYMBOLS = [
+-    'def','class','yield','return','pass','and','or','not','in','import',
++    'def','class','yield','return','pass','and','or','not','in','import','print',
+     'is','while','break','for','continue','if','else','elif','try',
+     'except','raise','True','False','None','global','del','from',
+     '-','+','*','**','/','%','<<','>>',

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/tinypy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/tinypy.cpp	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/tinypy.cpp	2010-07-09 05:26:47 UTC (rev 6443)
@@ -122,7 +122,6 @@
 // MEANX : Redirect printf
 bool pyPrintf(const char *fmt,...);
 #define printf pyPrintf
-// ************************
 
 /*  #define tp_malloc(x) calloc((x),1)
     #define tp_realloc(x,y) realloc(x,y)
@@ -466,8 +465,8 @@
 
 tp_inline static void tp_echo(TP,tp_obj e) {
     e = tp_str(tp,e);
-    //fwrite(e.string.val,1,e.string.len,stdout); // MEANX
-    printf("%s",e.string.val);
+    //fwrite(e.string.val,1,e.string.len,stdout);
+    printf("%s",e.string.val); // MEANX
 }
 
 /* Function: tp_string_n
@@ -985,14 +984,14 @@
  * This is how you can create a tinypy function object which, when called in
  * the script, calls the provided C function.
  */
-
-//tp_obj tp_fnc_new(TP,int t, void *v, tp_obj c,tp_obj s, tp_obj g) ;
 tp_obj tp_fnc(TP,tp_obj v(TP)) {
-    return tp_fnc_new(tp,0,(void *)v,tp_None,tp_None, tp_None);
+    // MEANX return tp_fnc_new(tp,0,v,tp_None,tp_None,tp_None);
+    return tp_fnc_new(tp,0,(void *)v,tp_None,tp_None,tp_None);
 }
 
 tp_obj tp_method(TP,tp_obj self,tp_obj v(TP)) {
-    return tp_fnc_new(tp,2,(void*)v,tp_None,self,tp_None);
+    // MEANX return tp_fnc_new(tp,2,v,tp_None,self,tp_None);
+    return tp_fnc_new(tp,2,(void *)v,tp_None,self,tp_None);
 }
 
 /* Function: tp_data
@@ -2205,7 +2204,9 @@
         exit(-1);
 #else
         tp->ex = e;
-        printf("\nException:\n"); tp_echo(tp,e); printf("\n");
+        // MEANX
+         printf("\nException:\n"); tp_echo(tp,e); printf("\n");
+        // /MEANX
         longjmp(tp->nextexpr,1);
 #endif
     }
@@ -2242,7 +2243,9 @@
     tp_print_stack(tp);
     exit(-1);
 #else
+        // MEANX
     tp_print_stack(tp);
+        // /MEANX
     longjmp(tp->nextexpr,1);
 #endif
 }
@@ -2456,13 +2459,13 @@
             tp_bounds(tp,cur,VA);
             #endif
             ;
-            {
+             {
             int a = (*(cur+1)).string.val-f->code.string.val;
 /*            f->line = tp_string_n((*(cur+1)).string.val,VA*4-1);*/
             f->line = tp_string_sub(tp,f->code,a,a+VA*4-1);
 /*             fprintf(stderr,"%7d: %s\n",UVBC,f->line.string.val);*/
             cur += VA; f->lineno = UVBC;
-            }
+                }
             break;
         case TP_IFILE: f->fname = RA; break;
         case TP_INAME: f->name = RA; break;
@@ -2571,6 +2574,7 @@
 
 void tp_builtins(TP) {
     tp_obj o;
+    //MEANX struct {const char *s;void *f;} b[] = {
     struct {const char *s;tp_obj (*f)(TP);} b[] = {
     {"print",tp_print}, {"range",tp_range}, {"min",tp_min},
     {"max",tp_max}, {"bind",tp_bind}, {"copy",tp_copy},

Modified: branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl	2010-07-06 20:55:50 UTC (rev 6442)
+++ branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl	2010-07-09 05:26:47 UTC (rev 6443)
@@ -187,6 +187,10 @@
         {
                 return "  return tp_number(r);";
         }
+        if($retType=~m/double/)
+        {
+                return "  return tp_number(r);";
+        }
         if($retType=~m/float/)
         {
                 return "  return tp_number(r);";



From mean at mail.berlios.de  Fri Jul  9 07:26:49 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri,  9 Jul 2010 07:26:49 +0200
Subject: [Avidemux-svn-commit] r6444 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <20100709052649.73579480B01@sheep.berlios.de>

Author: mean
Date: 2010-07-09 07:26:49 +0200 (Fri, 09 Jul 2010)
New Revision: 6444

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
Log:
[editor] Dont switch seg if it is the same

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-07-09 05:26:47 UTC (rev 6443)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-07-09 05:26:49 UTC (rev 6444)
@@ -99,11 +99,14 @@
 
     uint64_t refTime=seg->_refStartTimeUs+segTime;
 
-    uint32_t frame=_segments.intraTimeToFrame(seg->_reference,refTime);       
-    if(false==switchToSegment(s))
+    uint32_t frame=_segments.intraTimeToFrame(seg->_reference,refTime);    
+    if(s!=_currentSegment)
     {
-        ADM_warning("Cannot go to segment %"LU"\n",s);
-        return false;
+        if(false==switchToSegment(s))
+        {
+            ADM_warning("Cannot go to segment %"LU"\n",s);
+            return false;
+        }
     }
     if(toframe) *toframe=frame;
     ref->lastSentFrame=frame; // For copy



From mean at mail.berlios.de  Fri Jul  9 07:26:50 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri,  9 Jul 2010 07:26:50 +0200
Subject: [Avidemux-svn-commit] r6445 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_editor avidemux/common/ADM_script2/py
	avidemux/qt4/ADM_userInterfaces/ADM_shell cmake
Message-ID: <20100709052650.CD897480B01@sheep.berlios.de>

Author: mean
Date: 2010-07-09 07:26:50 +0200 (Fri, 09 Jul 2010)
New Revision: 6445

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/GUI_gen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/editor_gen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/pyDFMenu_gen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/pyDialogFactory_gen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp
   branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl
Log:
[Py/Shell] dont add a CR/LD each time jsLog is called

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-07-09 05:26:49 UTC (rev 6444)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-07-09 05:26:50 UTC (rev 6445)
@@ -513,12 +513,12 @@
     }
         _SEGMENT *s=getSegment(i);
         
-        jsLog("Segment :%d/%d",i,n);
-        jsLog( "\tReference    :%"LU,s->_reference,ADM_us2plain(s->_reference));
-        jsLog( "\tstartLinear  :%08"LLU" %s",s->_startTimeUs,ADM_us2plain(s->_startTimeUs));
-        jsLog( "\tduration     :%08"LLU" %s",s->_durationUs,ADM_us2plain(s->_durationUs));
-        jsLog( "\trefStartPts  :%08"LLU" %s",s->_refStartTimeUs,ADM_us2plain(s->_refStartTimeUs));
-        jsLog( "\trefStartDts  :%08"LLU" %s",s->_refStartDts,ADM_us2plain(s->_refStartDts));
+        jsLog("Segment :%d/%d\n",i,n);
+        jsLog( "\tReference    :%"LU"\n",s->_reference,ADM_us2plain(s->_reference));
+        jsLog( "\tstartLinear  :%08"LLU" %s\n",s->_startTimeUs,ADM_us2plain(s->_startTimeUs));
+        jsLog( "\tduration     :%08"LLU" %s\n",s->_durationUs,ADM_us2plain(s->_durationUs));
+        jsLog( "\trefStartPts  :%08"LLU" %s\n",s->_refStartTimeUs,ADM_us2plain(s->_refStartTimeUs));
+        jsLog( "\trefStartDts  :%08"LLU" %s\n",s->_refStartDts,ADM_us2plain(s->_refStartDts));
 }
 /**
     \fn dumpRefVideos
@@ -533,10 +533,10 @@
     {
         _VIDEOS *s=getRefVideo(i);
 
-        jsLog("Videos :%d/%d",i,n);
-        jsLog("\tfirstFramePts      :%08"LLU" %s",s->firstFramePts,ADM_us2plain(s->firstFramePts));
-        jsLog("\ttimeIncrementInUs  :%08"LLU" %s",s->timeIncrementInUs,ADM_us2plain(s->timeIncrementInUs));
-        jsLog("\tnb frames    :%08"LLU,s->_nb_video_frames);
+        jsLog("Videos :%d/%d\n",i,n);
+        jsLog("\tfirstFramePts      :%08"LLU" %s\n",s->firstFramePts,ADM_us2plain(s->firstFramePts));
+        jsLog("\ttimeIncrementInUs  :%08"LLU" %s\n",s->timeIncrementInUs,ADM_us2plain(s->timeIncrementInUs));
+        jsLog("\tnb frames    :%08"LLU"\n",s->_nb_video_frames);
     }
 
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/GUI_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/GUI_gen.cpp	2010-07-09 05:26:49 UTC (rev 6444)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/GUI_gen.cpp	2010-07-09 05:26:50 UTC (rev 6445)
@@ -116,11 +116,11 @@
 }
 static tp_obj zzpy__pyGui_help(TP)
  {
-  jsLog("fileWriteSelect(str)");
-  jsLog("displayError(str,str)");
-  jsLog("dirSelect(str)");
-  jsLog("displayInfo(str,str)");
-  jsLog("fileReadSelect(str)");
+	jsLog("fileWriteSelect(str)\n");
+	jsLog("displayError(str,str)\n");
+	jsLog("dirSelect(str)\n");
+	jsLog("displayInfo(str,str)\n");
+	jsLog("fileReadSelect(str)\n");
 };
 tp_obj initClasspyGui(tp_vm *vm)
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2010-07-09 05:26:49 UTC (rev 6444)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2010-07-09 05:26:50 UTC (rev 6445)
@@ -352,26 +352,26 @@
 }
 static tp_obj zzpy__pyAdm_help(TP)
  {
-  jsLog("audioCodec(str,int,couples)");
-  jsLog("saveBmp(str)");
-  jsLog("addVideoFilter(str,couples)");
-  jsLog("loadVideo(str )");
-  jsLog("clearSegments(void)");
-  jsLog("getHeight(void)");
-  jsLog("setPostProc(int ,int , int )");
-  jsLog("save(str)");
-  jsLog("appendVideo(str )");
-  jsLog("audioMixer(str )");
-  jsLog("getFps1000(void)");
-  jsLog("saveAudio(str)");
-  jsLog("videoCodec(str,couples)");
-  jsLog("getWidth(void)");
-  jsLog("addSegment(int ,double , double )");
-  jsLog("clearVideoFilters(void)");
-  jsLog("saveJpeg(str)");
-  jsLog("setContainer(str,couples)");
-  jsLog("audioReset(void)");
-  jsLog("getVideoCodec(void)");
+	jsLog("audioCodec(str,int,couples)\n");
+	jsLog("saveBmp(str)\n");
+	jsLog("addVideoFilter(str,couples)\n");
+	jsLog("loadVideo(str )\n");
+	jsLog("clearSegments(void)\n");
+	jsLog("getHeight(void)\n");
+	jsLog("setPostProc(int ,int , int )\n");
+	jsLog("save(str)\n");
+	jsLog("appendVideo(str )\n");
+	jsLog("audioMixer(str )\n");
+	jsLog("getFps1000(void)\n");
+	jsLog("saveAudio(str)\n");
+	jsLog("videoCodec(str,couples)\n");
+	jsLog("getWidth(void)\n");
+	jsLog("addSegment(int ,double , double )\n");
+	jsLog("clearVideoFilters(void)\n");
+	jsLog("saveJpeg(str)\n");
+	jsLog("setContainer(str,couples)\n");
+	jsLog("audioReset(void)\n");
+	jsLog("getVideoCodec(void)\n");
 };
 tp_obj initClasspyAdm(tp_vm *vm)
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/editor_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/editor_gen.cpp	2010-07-09 05:26:49 UTC (rev 6444)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/editor_gen.cpp	2010-07-09 05:26:50 UTC (rev 6445)
@@ -126,13 +126,13 @@
 }
 static tp_obj zzpy__pyEditor_help(TP)
  {
-  jsLog("nbSegments(void)");
-  jsLog("dumpAllSegments(void)");
-  jsLog("printTiming(int )");
-  jsLog("hexDumpFrame(int)");
-  jsLog("getVideoDuration(void)");
-  jsLog("dumpSegment(int)");
-  jsLog("dumpRefVideo(void)");
+	jsLog("nbSegments(void)\n");
+	jsLog("dumpAllSegments(void)\n");
+	jsLog("printTiming(int )\n");
+	jsLog("hexDumpFrame(int)\n");
+	jsLog("getVideoDuration(void)\n");
+	jsLog("dumpSegment(int)\n");
+	jsLog("dumpRefVideo(void)\n");
 };
 tp_obj initClasspyEditor(tp_vm *vm)
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/pyDFMenu_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/pyDFMenu_gen.cpp	2010-07-09 05:26:49 UTC (rev 6444)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/pyDFMenu_gen.cpp	2010-07-09 05:26:50 UTC (rev 6445)
@@ -62,7 +62,7 @@
 }
 static tp_obj zzpy__pyDFMenu_help(TP)
  {
-  jsLog("addItem(str)");
+	jsLog("addItem(str)\n");
 };
 tp_obj initClasspyDFMenu(tp_vm *vm)
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/pyDialogFactory_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/pyDialogFactory_gen.cpp	2010-07-09 05:26:49 UTC (rev 6444)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/pyDialogFactory_gen.cpp	2010-07-09 05:26:50 UTC (rev 6445)
@@ -63,8 +63,8 @@
 }
 static tp_obj zzpy__pyDialogFactory_help(TP)
  {
-  jsLog("show(void)");
-  jsLog("addControl(ptr at ADM_scriptDFBaseHelper)");
+	jsLog("show(void)\n");
+	jsLog("addControl(ptr at ADM_scriptDFBaseHelper)\n");
 };
 tp_obj initClasspyDialogFactory(tp_vm *vm)
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp	2010-07-09 05:26:49 UTC (rev 6444)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp	2010-07-09 05:26:50 UTC (rev 6445)
@@ -94,7 +94,7 @@
         case SCRIPT_LOG_NORMAL: ui.textBrowser->setTextColor(QColor(0,0,0));break;
         case SCRIPT_LOG_ERROR : ui.textBrowser->setTextColor(QColor(255,0,0));break;
     }
-    ui.textBrowser->append(string);
+    ui.textBrowser->insertPlainText(string);
     ui.textBrowser->setTextColor(QColor(0,0,0));
     return true;
 }

Modified: branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl	2010-07-09 05:26:49 UTC (rev 6444)
+++ branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl	2010-07-09 05:26:50 UTC (rev 6445)
@@ -526,7 +526,7 @@
                 foreach $f(  keys %cFuncs)
                 {
                         my @params=@{$funcParams{$f}};
-                        print OUTPUT "  jsLog(\"$f(".join(",", at params) .")\");\n";
+                        print OUTPUT "\tjsLog(\"$f(".join(",", at params) .")\\n\");\n";
                 }
                 print OUTPUT "};\n";
 #



From mean at mail.berlios.de  Fri Jul  9 20:23:52 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri,  9 Jul 2010 20:23:52 +0200
Subject: [Avidemux-svn-commit] r6446 -
	branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_gui2
Message-ID: <20100709182352.5897F4805B1@sheep.berlios.de>

Author: mean
Date: 2010-07-09 20:23:52 +0200 (Fri, 09 Jul 2010)
New Revision: 6446

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_gui2/gui_none.cpp
   branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_gui2/preview_none.cpp
Log:
[Cli] Fix building

Modified: branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_gui2/gui_none.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_gui2/gui_none.cpp	2010-07-09 05:26:50 UTC (rev 6445)
+++ branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_gui2/gui_none.cpp	2010-07-09 18:23:52 UTC (rev 6446)
@@ -9,6 +9,7 @@
 //
 
 #include "config.h"
+#include "ADM_cpp.h"
 #include "ADM_default.h"
 #include "ADM_misc.h"
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_gui2/preview_none.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_gui2/preview_none.cpp	2010-07-09 05:26:50 UTC (rev 6445)
+++ branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_gui2/preview_none.cpp	2010-07-09 18:23:52 UTC (rev 6446)
@@ -6,7 +6,7 @@
 
 #include <time.h>
 #include <sys/time.h>
-
+#include "ADM_cpp.h"
 #include "ADM_assert.h"
 #include "fourcc.h"
 #include "ADM_editor/ADM_edit.hxx"



From mean at mail.berlios.de  Sat Jul 10 09:38:16 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 10 Jul 2010 09:38:16 +0200
Subject: [Avidemux-svn-commit] r6447 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy:
	include src
Message-ID: <20100710073816.A5309480A0C@sheep.berlios.de>

Author: mean
Date: 2010-07-10 09:38:16 +0200 (Sat, 10 Jul 2010)
New Revision: 6447

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/include/ADM_tinypy.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/ADM_tinypy.cpp
Log:
[W32] Tinypy build fix

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/include/ADM_tinypy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/include/ADM_tinypy.h	2010-07-09 18:23:52 UTC (rev 6446)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/include/ADM_tinypy.h	2010-07-10 07:38:16 UTC (rev 6447)
@@ -15,7 +15,6 @@
  ***************************************************************************/
 #ifndef ADM_TINYPY_H
 #define ADM_TINYPY_H
-#include "ADM_cpp.h"
 #include "tinypy.h"
 #include "ADM_confCouple.h"
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/ADM_tinypy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/ADM_tinypy.cpp	2010-07-09 18:23:52 UTC (rev 6446)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/src/ADM_tinypy.cpp	2010-07-10 07:38:16 UTC (rev 6447)
@@ -13,7 +13,9 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
+#include "ADM_cpp.h"
 #include "ADM_default.h"
+
 #include <stdarg.h>
 #include "ADM_tinypy.h"
 //extern "C"



From mean at mail.berlios.de  Sat Jul 10 10:07:18 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 10 Jul 2010 10:07:18 +0200
Subject: [Avidemux-svn-commit] r6448 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include
Message-ID: <20100710080718.82CF9480A0C@sheep.berlios.de>

Author: mean
Date: 2010-07-10 10:07:18 +0200 (Sat, 10 Jul 2010)
New Revision: 6448

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_mangle.h
Log:
[Mangle] MacOsX fix

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_mangle.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_mangle.h	2010-07-10 07:38:16 UTC (rev 6447)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_mangle.h	2010-07-10 08:07:18 UTC (rev 6448)
@@ -37,10 +37,10 @@
 #        define FUNNY_MANGLE_ARRAY(x, y)  x[y] asm(#x)
 #    elif defined(__APPLE__) /////////////// MACOSX
 #        define MANGLE(a) "_" #a
-#        define LOCAL_MANGLE(a) #a"(%%rip)"
+#        define LOCAL_MANGLE(a) #a
 #        define FUNNY_MANGLE(x) x asm(MANGLE(x))
 #        define FUNNY_MANGLE_ARRAY(x, y) x[y] asm(MANGLE(x))
-#                else /////////////// LINUX //////////////
+#     else /////////////// LINUX //////////////
 #                   define MANGLE(a) #a
 #                   define LOCAL_MANGLE(a) #a
 #                   define FUNNY_MANGLE(x) x asm(MANGLE(x))



From mean at mail.berlios.de  Mon Jul 12 19:30:37 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 12 Jul 2010 19:30:37 +0200
Subject: [Avidemux-svn-commit] r6449 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs
Message-ID: <20100712173037.A6A56480AB7@sheep.berlios.de>

Author: mean
Date: 2010-07-12 19:30:37 +0200 (Mon, 12 Jul 2010)
New Revision: 6449

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
Log:
[DV] Add  DV compatible fourcc, ref #99

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2010-07-10 08:07:18 UTC (rev 6448)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2010-07-12 17:30:37 UTC (rev 6449)
@@ -163,8 +163,10 @@
   uint8_t dv = 0;
 
   CHECK ("dvsd");
-  CHECK ("DVDS");
+  CHECK ("DVSD");
   CHECK ("dvpp");
+  CHECK ("CDVC");
+  CHECK ("cdvc");
 
   return dv;
 



From mean at mail.berlios.de  Wed Jul 14 14:17:20 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 14:17:20 +0200
Subject: [Avidemux-svn-commit] r6450 - in branches/avidemux_2.6_branch_mean:
	avidemux avidemux/common/ADM_render
	avidemux/common/ADM_videoCodec/include
	avidemux/common/ADM_videoCodec/src avidemux_core
	avidemux_core/ADM_coreUI/include avidemux_core/ADM_coreVdpau
	avidemux_core/ADM_coreVdpau/include avidemux_core/ADM_coreVdpau/src
Message-ID: <20100714121720.D6129480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 14:17:20 +0200 (Wed, 14 Jul 2010)
New Revision: 6450

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/ADM_windowInfo.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_ffmpeg_vdpau_internal.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
Log:
[vdpau] Add abstraction layer

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h	2010-07-12 17:30:37 UTC (rev 6449)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h	2010-07-14 12:17:20 UTC (rev 6450)
@@ -21,18 +21,8 @@
 
 #include "ADM_image.h"
 typedef bool (*refreshSB)(void);
+#include "ADM_windowInfo.h"
 
-typedef struct
-{
-    void *display;
-    int  window;
-	int x;
-	int y;
-	int width;
-	int height;
-} GUI_WindowInfo;
-
-
 typedef enum 
 {
         ZOOM_1_4,

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_ffmpeg_vdpau_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-07-12 17:30:37 UTC (rev 6449)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-07-14 12:17:20 UTC (rev 6450)
@@ -39,24 +39,7 @@
 
 #define VDPAU ((vdpauContext *)vdpau)
 
-// VDPAU internal linker
 
-typedef struct 
-{
-    VdpGetErrorString       *getErrorString;
-    VdpGetApiVersion        *getApiVersion;
-    VdpGetInformationString *getInformationString;
-
-    VdpVideoSurfaceCreate   *createSurface;
-    VdpVideoSurfaceDestroy  *destroySurface;
-    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
-
-    VdpDecoderCreate        *decoderCreate;
-    VdpDecoderDestroy       *decoderDestroy;
-    VdpDecoderRender        *decoderRender;
-
-}VdpFunctions;
-
 #define WRAP_Open_Template(funcz,argz,display,codecid) \
 {\
 AVCodec *codec=funcz(argz);\

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-07-12 17:30:37 UTC (rev 6449)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-07-14 12:17:20 UTC (rev 6450)
@@ -30,8 +30,6 @@
  #include "ADM_ffmpeg/libavcodec/vdpau.h"
 }
 
-#include "vdpau/vdpau_x11.h"
-#include "vdpau/vdpau.h"
 #include "ADM_codec.h"
 #include "ADM_ffmp43.h"
 #include "DIA_coreToolkit.h"
@@ -39,16 +37,13 @@
 #include "ADM_render/GUI_render.h"
 #include "ADM_ffmpeg_vdpau_internal.h"
 #include "prefs.h"
+#include "ADM_coreVdpau/include/ADM_coreVdpau.h"
 #include "ADM_codecVdpau.h"
 
-static VdpFunctions funcs;
 
+
 static bool vdpauWorking=false;
 
-static ADM_LibWrapper        vdpauDynaLoader;
-static VdpDeviceCreateX11    *ADM_createVdpX11;
-static VdpDevice             vdpDevice;
-static VdpGetProcAddress     *vdpProcAddress;
 
 #define aprintf(...) {}
 
@@ -72,63 +67,16 @@
     return v;
 }
 /**
-    \fn getFunc
-    \brief vdpau function pointers from ID
-*/
-static void *getFunc(uint32_t id)
-{
-    void *f;
-    if(VDP_STATUS_OK!=vdpProcAddress(vdpDevice,id,&f)) return NULL;
-    return (void *)f;
-}
-/**
     \fn vdpauProbe
     \brief Try loading vdpau...
 */
 bool vdpauProbe(void)
 {
-    memset(&funcs,0,sizeof(funcs));
-    if(false==vdpauDynaLoader.loadLibrary("/usr/lib/libvdpau.so"))
-    {
-        return false;
-    }
-    ADM_createVdpX11=(VdpDeviceCreateX11*)vdpauDynaLoader.getSymbol("vdp_device_create_x11");
-    if(!ADM_createVdpX11) return false;
-
-    //
     GUI_WindowInfo xinfo;
     void *draw;
     draw=UI_getDrawWidget();
     UI_getWindowInfo(draw,&xinfo );
-    
-    // try to create....
-    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)xinfo.display,0,&vdpDevice,&vdpProcAddress))
-    {
-        return false;
-    }
-    // Now that we have the vdpProcAddress, time to get the functions....
-#define GetMe(fun,id)         funcs.fun= (typeof(funcs.fun))getFunc(id);ADM_assert(funcs.fun); 
-        
-    GetMe(getErrorString,VDP_FUNC_ID_GET_ERROR_STRING);
-    GetMe(getApiVersion,VDP_FUNC_ID_GET_API_VERSION);
-    GetMe(getInformationString,VDP_FUNC_ID_GET_INFORMATION_STRING);
-
-    GetMe(createSurface,VDP_FUNC_ID_VIDEO_SURFACE_CREATE);
-    GetMe(destroySurface,VDP_FUNC_ID_VIDEO_SURFACE_DESTROY);
-    GetMe(getDataSurface,VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR);
-
-    GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
-    GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
-    GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
-
-
-
-    const char *versionString=NULL;
-    uint32_t version=0xff;
-        funcs.getInformationString(&versionString);
-        funcs.getApiVersion(&version);
-        ADM_info("[VDPAU] API : 0x%x, info : %s\n",version,versionString);
-
+    if(false==admVdpau::init(&xinfo)) return false;
     vdpauWorking=true;
     return true;
 }
@@ -287,8 +235,7 @@
         for(int i=0;i<NB_SURFACE;i++)
             VDPAU->renders[i]=NULL;
         
-        if(VDP_STATUS_OK!=funcs.decoderCreate(vdpDevice,vdpDecoder,
-                                w,h,15,&(VDPAU->vdpDecoder)))
+        if(VDP_STATUS_OK!=admVdpau::decoderCreate(vdpDecoder, w,h,15,&(VDPAU->vdpDecoder)))
         {
             ADM_error("Cannot create VDPAU decoder\n");
             alive=false;
@@ -299,7 +246,7 @@
         {
             VDPAU->renders[i]=new vdpau_render_state;
             memset(VDPAU->renders[i],0,sizeof( vdpau_render_state));
-            if(VDP_STATUS_OK!=funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,w,h,&(VDPAU->renders[i]->surface)))
+            if(VDP_STATUS_OK!=admVdpau::surfaceCreate(w,h,&(VDPAU->renders[i]->surface)))
             {
                 ADM_error("Cannot create surface %d/%d\n",i,NB_SURFACE);
                 alive=false;
@@ -325,14 +272,14 @@
                 if(VDPAU->renders[i]->surface)
                 {
                     if(VDPAU->renders[i]->surface)
-                        if(VDP_STATUS_OK!=funcs.destroySurface((VDPAU->renders[i]->surface)))
+                        if(VDP_STATUS_OK!=admVdpau::surfaceDestroy((VDPAU->renders[i]->surface)))
                                 ADM_error("Error destroying surface %d\n",i);
                 }
                 delete VDPAU->renders[i];
             }
         }
          ADM_info("[VDPAU] Destroying decoder\n");
-         if(VDP_STATUS_OK!=funcs.decoderDestroy(VDPAU->vdpDecoder))
+         if(VDP_STATUS_OK!=admVdpau::decoderDestroy(VDPAU->vdpDecoder))
                 ADM_error("Error destroying VDPAU decoder\n");
          delete VDPAU;
          vdpau=NULL;
@@ -370,16 +317,11 @@
     
    // Copy back the decoded image to our output ADM_image
    aprintf("[VDPAU] Getting datas from surface %d\n",surface);
-    status=funcs.getDataSurface(
-                surface,
-                VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
-                ( void * const *)planes, //void * const *   destination_data,
-                stride //destination_pitches
-                );
+    status=admVdpau::getDataSurface(surface,planes, stride );
     if(VDP_STATUS_OK!=status)
     {
         
-        printf("[VDPAU] Cannot get data from surface <%s>\n",funcs.getErrorString(status));
+        printf("[VDPAU] Cannot get data from surface <%s>\n",admVdpau::getErrorString(status));
         decode_status=false;
         return 0 ;
     }
@@ -401,11 +343,11 @@
     vdpau_pts=d->reordered_opaque; // Retrieve our PTS
 
      aprintf("[VDPAU] Decoding Using surface %d\n", surface);
-    status=funcs.decoderRender(VDPAU->vdpDecoder, surface,
-                            (void * const *)&rndr->info, rndr->bitstream_buffers_used, rndr->bitstream_buffers);
+    status=admVdpau::decoderRender(VDPAU->vdpDecoder, surface,
+                            &rndr->info, rndr->bitstream_buffers_used, rndr->bitstream_buffers);
     if(VDP_STATUS_OK!=status)
     {
-        printf("[VDPAU] No data after decoderRender <%s>\n",funcs.getErrorString(status));
+        printf("[VDPAU] No data after decoderRender <%s>\n",admVdpau::getErrorString(status));
         decode_status=false;
         return ;
     }

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-07-12 17:30:37 UTC (rev 6449)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-07-14 12:17:20 UTC (rev 6450)
@@ -90,6 +90,7 @@
 ADM_editor6
 ADM_audiocodec6 
 ADM_videocodec6 
+ADM_coreVDPAU6 
 ADM_coreVideoCodec6 
 ADM_commonUI6
 )

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/ADM_windowInfo.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/ADM_windowInfo.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/ADM_windowInfo.h	2010-07-14 12:17:20 UTC (rev 6450)
@@ -0,0 +1,12 @@
+#ifndef ADM_WINDOW_INFO_H
+#define ADM_WINDOW_INFO_H
+typedef struct
+{
+    void *display;
+    int  window;
+        int x;
+        int y;
+        int width;
+        int height;
+} GUI_WindowInfo;
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/CMakeLists.txt	2010-07-14 12:17:20 UTC (rev 6450)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(src)

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-14 12:17:20 UTC (rev 6450)
@@ -0,0 +1,43 @@
+/***************************************************************************
+    \file             : ADM_coreVdpau.cpp
+    \brief            : Wrapper around vdpau functions
+    \author           : (C) 2010 by mean fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef ADM_CORE_VDPAU_H
+#define ADM_CORE_VDPAU_H
+#include "vdpau/vdpau_x11.h"
+#include "vdpau/vdpau.h"
+#include "ADM_windowInfo.h"
+/**
+    \class admVdpau
+*/
+class admVdpau
+{
+public:
+    static bool         init(GUI_WindowInfo *x);
+    static const char  *getErrorString(VdpStatus er);
+    static bool         isOperationnal(void);
+    static  VdpStatus   decoderCreate( VdpDecoderProfile profile,    uint32_t          width,    uint32_t          height,    uint32_t          max_references,       VdpDecoder *      decoder);
+    static  VdpStatus   decoderDestroy(VdpDecoder decoder);
+    static  VdpStatus   surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface);
+    static  VdpStatus   surfaceDestroy(VdpVideoSurface surface);
+    static  VdpStatus   getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3]);
+    static  VdpStatus   decoderRender(
+            VdpDecoder                 decoder,
+            VdpVideoSurface            target,
+            const void                 *info,
+            uint32_t                   bitstream_buffer_count,
+            VdpBitstreamBuffer const * bitstream_buffers);
+
+};
+#endif
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 12:17:20 UTC (rev 6450)
@@ -0,0 +1,203 @@
+/***************************************************************************
+    \file             : ADM_coreVdpau.cpp
+    \brief            : Wrapper around vdpau functions
+    \author           : (C) 2010 by mean fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "../include/ADM_coreVdpau.h"
+#include "ADM_dynamicLoading.h"
+
+#ifdef USE_VDPAU
+/**
+    \fn VdpFunctions
+    
+*/
+typedef struct 
+{
+    VdpGetErrorString       *getErrorString;
+    VdpGetApiVersion        *getApiVersion;
+    VdpGetInformationString *getInformationString;
+
+    VdpVideoSurfaceCreate   *createSurface;
+    VdpVideoSurfaceDestroy  *destroySurface;
+    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
+
+    VdpDecoderCreate        *decoderCreate;
+    VdpDecoderDestroy       *decoderDestroy;
+    VdpDecoderRender        *decoderRender;
+}VdpFunctions;
+
+static VdpFunctions          funcs;
+static ADM_LibWrapper        vdpauDynaLoader;
+static VdpDeviceCreateX11    *ADM_createVdpX11;
+static VdpDevice             vdpDevice;
+static VdpGetProcAddress     *vdpProcAddress;
+static bool                  coreVdpWorking=false;
+/**
+    \fn getFunc
+    \brief vdpau function pointers from ID
+*/
+static void *getFunc(uint32_t id)
+{
+    void *f;
+    if(VDP_STATUS_OK!=vdpProcAddress(vdpDevice,id,&f)) return NULL;
+    return (void *)f;
+}
+
+/**
+    \fn     init
+    \brief
+*/
+bool admVdpau::init(GUI_WindowInfo *x)
+{
+    memset(&funcs,0,sizeof(funcs));
+    if(false==vdpauDynaLoader.loadLibrary("/usr/lib/libvdpau.so"))
+    {
+        ADM_info("Cannot load libvdpau.so\n");
+        return false;
+    }
+    ADM_createVdpX11=(VdpDeviceCreateX11*)vdpauDynaLoader.getSymbol("vdp_device_create_x11");
+    if(!ADM_createVdpX11) return false;
+
+    //    
+    // try to create....
+    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)x->display,0,&vdpDevice,&vdpProcAddress))
+    {
+        return false;
+    }
+    // Now that we have the vdpProcAddress, time to get the functions....
+#define GetMe(fun,id)         funcs.fun= (typeof(funcs.fun))getFunc(id);ADM_assert(funcs.fun); 
+        
+    GetMe(getErrorString,VDP_FUNC_ID_GET_ERROR_STRING);
+    GetMe(getApiVersion,VDP_FUNC_ID_GET_API_VERSION);
+    GetMe(getInformationString,VDP_FUNC_ID_GET_INFORMATION_STRING);
+
+    GetMe(createSurface,VDP_FUNC_ID_VIDEO_SURFACE_CREATE);
+    GetMe(destroySurface,VDP_FUNC_ID_VIDEO_SURFACE_DESTROY);
+    GetMe(getDataSurface,VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR);
+
+    GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
+    GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
+    GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
+
+
+
+    const char *versionString=NULL;
+    uint32_t version=0xff;
+        funcs.getInformationString(&versionString);
+        funcs.getApiVersion(&version);
+        ADM_info("[VDPAU] API : 0x%x, info : %s\n",version,versionString);
+
+    coreVdpWorking=true;
+    return true;
+}
+/**
+    \fn isOperationnal
+*/
+bool admVdpau::isOperationnal(void)
+{
+    return coreVdpWorking;
+}
+
+VdpStatus admVdpau::decoderCreate( VdpDecoderProfile profile,    uint32_t  width,uint32_t  height,
+            uint32_t  max_references,VdpDecoder *      decoder)
+{
+    return funcs.decoderCreate(vdpDevice,profile,width,height,max_references,decoder);
+}
+VdpStatus  admVdpau::decoderDestroy(VdpDecoder decoder)
+{
+    return funcs.decoderDestroy(decoder);
+}
+VdpStatus  admVdpau::surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface)
+{
+return funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,width,height,surface);
+}
+VdpStatus  admVdpau::surfaceDestroy(VdpVideoSurface surface)
+{
+    return funcs.destroySurface(surface);
+}
+VdpStatus  admVdpau::getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3])
+{
+  return funcs.getDataSurface(
+                surface,
+                VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
+                ( void * const *)planes, //void * const *   destination_data,
+                stride //destination_pitches
+                );
+}
+const char *admVdpau::getErrorString(VdpStatus er)
+{
+    return funcs.getErrorString(er);
+}
+VdpStatus admVdpau::decoderRender(
+    VdpDecoder                 decoder,
+    VdpVideoSurface            target,
+    const void                 *info,
+    uint32_t                   bitstream_buffer_count,
+    VdpBitstreamBuffer const * bitstream_buffers)
+{
+    return funcs.decoderRender(decoder, target, (void * const *)info,bitstream_buffer_count, bitstream_buffers);
+}
+#else // Dummy when vdpau is not there...
+
+static bool                  coreVdpWorking=false;
+bool admVdpau::init(GUI_WindowInfo *x)
+{
+          return false;
+}
+  
+/**
+    \fn isOperationnal
+*/
+bool admVdpau::isOperationnal(void)
+{
+    ADM_warning("This binary has no VPDAU support\n");
+    return coreVdpWorking;
+}
+
+VdpStatus admVdpau::decoderCreate( VdpDecoderProfile profile,    uint32_t  width,uint32_t  height,
+            uint32_t  max_references,VdpDecoder *      decoder)
+{
+    ADM_assert(0);
+}
+VdpStatus  admVdpau::decoderDestroy(VdpDecoder decoder)
+{
+    ADM_assert(0);
+}
+VdpStatus  admVdpau::surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface)
+{
+ADM_assert(0);
+}
+VdpStatus  admVdpau::surfaceDestroy(VdpVideoSurface surface)
+{
+    ADM_assert(0);
+}
+VdpStatus  admVdpau::getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3])
+{
+  ADM_assert(0);
+}
+const char *admVdpau::getErrorString(VdpStatus er)
+{
+ADM_assert(0);
+}
+VdpStatus admVdpau::decoderRender(
+    VdpDecoder                 decoder,
+    VdpVideoSurface            target,
+    const void                 *info,
+    uint32_t                   bitstream_buffer_count,
+    VdpBitstreamBuffer const * bitstream_buffers)
+{
+    ADM_assert(0);
+}
+
+#endif
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt	2010-07-14 12:17:20 UTC (rev 6450)
@@ -0,0 +1,11 @@
+
+SET(ADM_vdpau_SRCS
+ADM_coreVdpau.cpp
+)	
+#*************************************************
+#*************************************************
+ADD_LIBRARY(ADM_coreVDPAU6 SHARED ${ADM_vdpau_SRCS})
+INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreVdpau/include)
+TARGET_LINK_LIBRARIES(ADM_coreVDPAU6 ADM_core6 ADM_coreUI6 )
+
+ADM_INSTALL_LIB(ADM_coreVDPAU6)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2010-07-12 17:30:37 UTC (rev 6449)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2010-07-14 12:17:20 UTC (rev 6450)
@@ -70,6 +70,9 @@
 ADD_SUBDIRECTORY(ADM_ffmpeg)
 ADD_SUBDIRECTORY(ADM_smjs)
 ADD_SUBDIRECTORY(ADM_coreImageLoader)
+
+ADD_SUBDIRECTORY(ADM_coreVdpau)
+
 ########################################
 # Config Summary
 ########################################



From mean at mail.berlios.de  Wed Jul 14 14:17:22 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 14:17:22 +0200
Subject: [Avidemux-svn-commit] r6451 - in
	branches/avidemux_2.6_branch_mean/avidemux/common:
	ADM_audioFilter/src/ADM_libsamplerate ADM_commonUI ADM_ocr
Message-ID: <20100714121723.2041B480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 14:17:22 +0200 (Wed, 14 Jul 2010)
New Revision: 6451

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_requant.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_bitmapSource.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_leftturn.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrEngine.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrInternal.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_vob2vobsub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_leftturn.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/float_cast.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/samplerate.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_linear.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_sinc.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_zoh.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_plugins.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_postproc.cpp
Log:
[all] try to remove as much include config.h as possible

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/float_cast.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/float_cast.h	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/float_cast.h	2010-07-14 12:17:22 UTC (rev 6451)
@@ -45,12 +45,12 @@
 **		long int lrint  (double x) ;
 */
 
-// MEANX #include "config.h"
+// MEANX #include "xonfig.h"
 
 /*
 **	The presence of the required functions are detected during the configure
 **	process and the values HAVE_LRINT and HAVE_LRINTF are set accordingly in
-**	the config.h file.
+**	the xonfig.h file.
 */
 
 #define		HAVE_LRINT_REPLACEMENT	0

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/samplerate.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/samplerate.c	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/samplerate.c	2010-07-14 12:17:22 UTC (rev 6451)
@@ -26,7 +26,7 @@
 #include	<stdlib.h>
 #include	<string.h>
 
-#include	"config.h"
+#include	"xonfig.h"
 #else
 #include "ADM_default.h"
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_linear.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_linear.c	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_linear.c	2010-07-14 12:17:22 UTC (rev 6451)
@@ -26,7 +26,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "config.h"
+#include "xonfig.h"
 #else
 #include "ADM_default.h"
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_sinc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_sinc.c	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_sinc.c	2010-07-14 12:17:22 UTC (rev 6451)
@@ -26,7 +26,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "config.h"
+#include "xonfig.h"
 #else
 #include "ADM_default.h"
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_zoh.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_zoh.c	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_zoh.c	2010-07-14 12:17:22 UTC (rev 6451)
@@ -26,7 +26,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "config.h"
+#include "xonfig.h"
 #else
 #include "ADM_default.h"
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt	2010-07-14 12:17:22 UTC (rev 6451)
@@ -7,7 +7,6 @@
 DIA_bitrateHisto.cpp  
 DIA_prefs.cpp     
 DIA_builtin.cpp       
-DIA_requant.cpp   
 DIA_jobs_save.cpp
 DIA_plugins.cpp
 )

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_plugins.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_plugins.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_plugins.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -13,7 +13,7 @@
  *                                                                         *
  ***************************************************************************/
 
-//#include "config.h"
+//#include "xonfig.h"
 #include "ADM_default.h"
 #include "DIA_factory.h"
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_postproc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_postproc.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_postproc.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -12,7 +12,7 @@
 //
 //
 
-#include "config.h"
+//#include "xonfig.h"
 #include "ADM_default.h"
 
 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_requant.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_requant.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_requant.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,52 +0,0 @@
-/*
-    Dialog for lavcodec based Mpeg1/mpeg2 codec
-
-
-*/
-#include "config.h"
-
-#if 0
-#include "ADM_lavcodec.h"
-
-#include "ADM_default.h"
-
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_encoder/ADM_vidEncode.hxx"
-#include "ADM_codecs/ADM_ffmpegConfig.h"
-
-  
-#include "DIA_factory.h"
-#include "../../ADM_encoder/adm_encmjpeg_param.h"
-
-/**
-      \fn DIA_mjpegCodecSetting
-      \brief Dialog to set encoding options for Mjpeg lavcodec based
-*/
-//____________________________________________
-uint8_t DIA_requant(COMPRES_PARAMS *param)
-{
-  uint32_t *pp;
-  ELEM_TYPE_FLOAT fp;
-        ADM_assert(param->extraSettingsLen==sizeof(uint32_t));
-        pp=(uint32_t *)param->extraSettings;
-        
-       
-        fp=(ELEM_TYPE_FLOAT)(*pp);
-        fp/=1000;
-        
-       
-        uint8_t ret=0;
-        diaElemFloat  shrink(&fp,QT_TR_NOOP("_Shrink Factor:"),1,4.0);
-        
-        diaElem *elems[1]={&shrink};
-        if( diaFactoryRun(QT_TR_NOOP("Requant Configuration"),1,elems))
-        {
-            ret=1;
-            *pp=(uint32_t)(fp*1000);
-        }
-        return ret;
-        
-}   
-#endif
-// EOF
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_bitmapSource.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_bitmapSource.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_bitmapSource.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,223 +0,0 @@
-/***************************************************************************
-      Front end for bitmap sources (vobsub, ts, sup,...)
-      (C) 2007 Mean
- ***************************************************************************/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #include "config.h"
- #include "ADM_default.h"
-
- #include "ADM_editor/ADM_edit.hxx"
- #include "ADM_videoFilter.h"
- #include "ADM_ocr.h"
- #include "ADM_ocrInternal.h"
-  #include "DIA_enter.h"
-#include "ADM_videoFilter/ADM_vidDvbSub.h"
-
-/*  *****************************
- * 	**** Case 1 : Vobsub ********
- *  *****************************
- */
-
-class ADM_BitmapSource_VobSub : public ADM_BitmapSource
-{
-protected:
-			ADMVideoVobSub *_vobsub;
-			uint32_t		_nbPics;
-public: 
-								ADM_BitmapSource_VobSub(void);
-			virtual uint8_t     init(ADM_OCR_SOURCE *source);
-			virtual 			~ADM_BitmapSource_VobSub();
-			virtual uint32_t 	getNbImages(void);
-			virtual vobSubBitmap *getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last,uint32_t *eos);
-};
-
-ADM_BitmapSource_VobSub::ADM_BitmapSource_VobSub(void)
-{
-	_vobsub=NULL;
-	_nbPics=0;
-}
-ADM_BitmapSource_VobSub::~ADM_BitmapSource_VobSub()
-{
-	if(_vobsub) delete _vobsub;
-	_vobsub=NULL;
-}
-uint8_t     ADM_BitmapSource_VobSub::init(ADM_OCR_SOURCE *source)
-{
-	_vobsub=new ADMVideoVobSub(source->subparam->subname,source->subparam->index);
-	if(!_vobsub)
-	{
-		printf("[BitmapSource_VS] Cannot open source\n");
-		return 0;
-	}
-	_nbPics=_vobsub->getNbImage();
-	return 1;
-}
-uint32_t 	ADM_BitmapSource_VobSub::getNbImages(void)
-{
-	return _nbPics;
-}
-/**
- * 		\fn getBitmap
- * 		\brief returns a bitmap in black & white (luma+alpha)
- * */
-vobSubBitmap *ADM_BitmapSource_VobSub::getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last,uint32_t *endofstream)
-{
-	*endofstream=0;
-	return _vobsub->getBitmap(nb,start, end,first,last);
-}
-/*  *****************************
- * 	**** Case 2 : TsSub  ********
- *  *****************************
- */
-#define TS_WIDTH  720
-#define TS_HEIGHT 576
-#define NO_STARTING_TIMECODE 0xFFFFFFF
-class ADM_BitmapSource_TsSub : public ADM_BitmapSource
-{
-protected:
-			uint32_t		_nbPics;
-			ADMVideoSubDVB  *_dvb;
-			vobSubBitmap    *_bitmap;
-			uint32_t		_firstTimeCode;
-public: 
-								ADM_BitmapSource_TsSub(void);
-			virtual uint8_t     init(ADM_OCR_SOURCE *source);
-			virtual 			~ADM_BitmapSource_TsSub();
-			virtual uint32_t 	getNbImages(void);
-			virtual vobSubBitmap *getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last,
-									uint32_t *eos);
-};
-
-ADM_BitmapSource_TsSub::ADM_BitmapSource_TsSub(void)
-{
-	_nbPics=0x7FFFF;
-	_dvb=NULL;
-	_bitmap=new vobSubBitmap(TS_WIDTH,TS_HEIGHT);
-	_firstTimeCode=NO_STARTING_TIMECODE;
-}
-ADM_BitmapSource_TsSub::~ADM_BitmapSource_TsSub()
-{
-	if(_dvb) delete _dvb;
-	_dvb=NULL;
-	if(_bitmap) delete _bitmap;
-	_bitmap=NULL;
-}
-uint8_t     ADM_BitmapSource_TsSub::init(ADM_OCR_SOURCE *source)
-{
-	_dvb=new ADMVideoSubDVB(source->TsFile,source->TsPid,TS_WIDTH,TS_HEIGHT);
-	
-	ADM_assert(_dvb);
-	return _dvb->init(source->TsFile);
-}
-uint32_t 	ADM_BitmapSource_TsSub::getNbImages(void)
-{
-	return _nbPics;
-}
-/**
- * 		\fn getBitmap
- * 		\brief returns a bitmap in black & white (luma+alpha)
- *      @param nb : unused
- *      @start : Timecode of start (ms)
- * 		@end   : Timecode of end (ms)
- * 		@first : First non empty line
- * 		@last  : Last non empty line
- * */
-vobSubBitmap *ADM_BitmapSource_TsSub::getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last,uint32_t *endOfStream)
-{
-	uint32_t pts;
-	//
-	*endOfStream=0;
-	// First get our bitmap
-	  if(! _dvb->getNextBitmap(_bitmap,&pts))
-	  {
-		  printf("[BitmapSource] cannot get next bitmap\n");
-		  *endOfStream=1;
-		  return NULL;
-	  }
-	  // First ?
-	  if(_firstTimeCode==NO_STARTING_TIMECODE)
-	  {
-		  _firstTimeCode=pts;
-	  }
-	  // Now build it
-	  // First & last are the 1st and last non empty lines
-	  *first=0;
-	  *last=TS_HEIGHT-1;
-	  
-	  // Lookup the actual beginning /end
-	  uint32_t top=0;
-	   while(top<TS_HEIGHT && !_bitmap->isDirty(top) ) top++;
-	        
-	        if(top==TS_HEIGHT)
-	        {
-	                printf("[BitmapSource]Empty bitmap\n");
-	                return NULL; 
-	        }
-	  // 
-	        *first=top;
-	        
-	  // Now bottom
-	        uint32_t bottom=TS_HEIGHT-1;
-	        while(bottom>top && !_bitmap->isDirty(bottom) ) bottom--;
-	        if(bottom==top)
-	        {
-	        	   printf("[BitmapSource]Empty bitmap\n");
-	        	   return NULL; 
-	        }
-	        *last=bottom;
-	        
-	  // start & end are timecodes
-#define WRAP_TIMECODE 0x3FFFFFFF
-	  if(pts>_firstTimeCode)
-	  {
-		  *start=(pts-_firstTimeCode)/90;
-	  }else
-	  {
-		  *start=((WRAP_TIMECODE-pts)+_firstTimeCode)/90;
-	  }
-	  *end=*start+1000;
-			  
-	  // Set alpha as luma
-	  uint8_t *in,*out;
-	  in=_bitmap->_bitmap;
-	  out=_bitmap->_alphaMask;
-	  for(uint32_t yy=0;yy<TS_HEIGHT;yy++)
-		  for(uint32_t xx=0;xx<TS_WIDTH;xx++)
-		  {
-			  if(*in) *out=255;
-			  else *out=0;
-			  
-			  in++;
-			  out++;
-			  
-		  }
-		  
-	return _bitmap;
-}
-//**********************************************************
-//**********************************************************
-//**********************************************************
-/**
- * 	\fn ADM_buildBitmapSource
- * \brief Instantiate the correct bitmap source
-*/
-ADM_BitmapSource *ADM_buildBitmapSource(ADM_OCR_SOURCE *source)
-{
-	switch(source->type)
-	{
-			case ADM_OCR_TYPE_VOBSUB: 	return new ADM_BitmapSource_VobSub();
-			case ADM_OCR_TYPE_TS: 		return new ADM_BitmapSource_TsSub();
-			default:
-						printf("[BitmapSource] Unknown source type %d\n",source->type);
-						ADM_assert(0);
-	}
-	return NULL;
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_leftturn.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_leftturn.h	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_leftturn.h	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,17 +0,0 @@
-//
-// C++ Interface: %{MODULE}
-//
-// Description: 
-//
-//
-// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#ifndef ADM_LEFTY
-#define ADM_LEFTY
-#include "adm_glyph.h"
-
-uint8_t adm_estimate_glyphSize(admGlyph *gl,uint32_t *minx, uint32_t *maxx,uint32_t *miny,uint32_t *maxy,int *raw);
-#endif 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,278 +0,0 @@
-/***************************************************************************
-      UI independant part of the OCR engine
-      (C) 2007 Mean
- ***************************************************************************/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #include "config.h"
-#include "ADM_default.h"
-
- #include "ADM_editor/ADM_edit.hxx"
- #include "ADM_videoFilter.h"
- #include "ADM_ocr.h"
-#include "ADM_ocrInternal.h"
-  #include "DIA_enter.h"
-static uint32_t minThreshold=0x80;
-
-/* In the UI related code */
-extern void UI_purge(void);
-
-extern uint8_t adm_estimate_glyphSize(admGlyph *glyph,uint32_t *minx, uint32_t *maxx,uint32_t *miny,uint32_t *maxy,int *raw);
-
-static uint32_t minAlpha=7; /* Below minAlpha is is considered black */
-
-/**
-      \fn mergeBitmap
-      \brief Merge bitmap with alpha mask so that we go a black & white output
-      @param bitin bitmap (input)
-      @param bitout B&W bitmap (output)
-      @param maskin alpha mask (input)
-      @param w width of bitmap
-      @param h height of bitmap
-
-*/
-uint8_t mergeBitmap(uint8_t *bitin, uint8_t *bitout, uint8_t *maskin,uint32_t w, uint32_t h)
-{
-// Merge with alpha channel
-           uint8_t *in,*mask,*out;
-           uint32_t alp,nw;
-           in=bitin;
-           out=bitout;
-           mask=maskin;
-           for(uint32_t y=0;y<h;y++)
-           {
-            for(uint32_t x=0;x<w;x++)
-            {
-                   
-                    nw=in[x];
-                    alp=mask[x];
-
-                    if(alp>minAlpha&& nw >minThreshold)  nw=0xff;
-                         else       nw=0;
-                        
-                    out[x]=nw;
-            }
-            out+=w;
-            in+=w;
-            mask+=w;
-           }    
-    return 1;
-}
-/**
-      \fn ocrBitmap
-      \brief Split the bitmap into glyphes, ocr glyphes and output text
-      @param workArea, Bitmap to work with
-      @param w width of bitmap
-      @param h height of bitmap
-      @param decodedString Will contain ocr'ed text
-*/
-ReplyType ocrBitmap(uint8_t *workArea,uint32_t w,uint32_t h,char *decodedString,admGlyph *head)
-{
-uint8_t found;
-uint32_t colstart=0,colend=0,oldcol;
-uint32_t line=0,nbLine=1;
-uint32_t base=0,bottom,top;    
-ReplyType reply;
-    // Search First non nul colum
-    decodedString[0]=0;
-    // Search how much lines there is in the file
-    //
-    top=bottom=0;
-    while(top<h)
-    {
-        // Search non empty line as top
-        while(top<h && lineEmpty(workArea,w,w,top)) top++;
-        // Nothing found
-        if(top>=h-1) break;
-
-        // 
-       
-
-        bottom=top+1;
-        // Search empty line if any, bottom is the 1st line full of zero
-        while(bottom<h && (!lineEmpty(workArea,w,w,bottom) || bottom-top<7))
-        {
-            bottom++;
-        }
-        if(line) strcat(decodedString,"\n"); 
-        //printf("\n Top:%lu bottom:%lu\n",top,bottom);
-       
-        // Scan a full line
-        colstart=0;
-        oldcol=0;
-       
-        // Split a line into glyphs
-        while(colstart<w)
-        {
-            UI_purge();
-            oldcol=colstart;
-            while( columnEmpty(workArea+colstart+top*w, w, bottom-top) && colstart<w) colstart++;
-            if(colstart>=w) break;
-            // if too far apart, it means probably a blank space
-            if(colstart-oldcol>6)
-            {
-                strcat(decodedString," ");
-            }
-       
-            // We have found a non null column
-            // Seek the end now
-            colend=colstart+1;
-            while( !columnEmpty(workArea+colend+top*w, w, bottom-top) && colend<w) colend++;
-         
-         
-            // printf("Found glyph: %lu %lu\n",colstart,colend);  
-            reply=handleGlyph(workArea,colstart,colend,w,bottom,top,head,decodedString);
-            switch(reply)
-                {
-                        case ReplySkip:break;
-                        case ReplyOk:break;
-                        case ReplyClose:
-                        case ReplyCalibrate: return reply;break;
-            
-                        case ReplySkipAll: return ReplyOk;break;
-                        default: ADM_assert(0);
-                }
-            
-            
-            colstart=colend;
-      }
-      line++;      
-      top=bottom;
-      
-    }
-   
-    return ReplyOk;
-}
-
-/**
-      \fn handleGlyph
-      \brief Handle ONE glyph
-      @param workArea full bitmap to OCR 
-      @param start Start column of glyph
-      @param end end column of glyph
-      @param w Width of bitmap
-      @param h Height of bitmap
-      @param base Baseline of glyph
-    We now have a good candidate for the glyph.
-    We will do the following processing :
-        - Clip the glyph to have it in its bounding box
-        - extract its container. If the container is smaller than the glyph, it means
-                that we have in fact several glyphs that overlaps slightly. In
-                that case we use another method to extract the glyph.
-                We split it using leftturn method and do it again.
-*/
-ReplyType handleGlyph(uint8_t *workArea,uint32_t start, uint32_t end,uint32_t w,uint32_t h,uint32_t base,
-							admGlyph *head,char *decodedString)
-{
-uint8_t found=0;
-static int inc=1;
-ReplyType reply;
-          
-    
-    // Ok now we have the cropped glyp
-    
-    admGlyph *glyph,*cand;
-    uint32_t minx,maxx,miny,maxy;
-    int     *raw=NULL;
-            glyph=new admGlyph(end-start,h-base);
-            glyph->create(workArea+start+base*w,w);
-            glyph=clippedGlyph(glyph);
-            if(!glyph->width) // Empty glyph
-            {
-                delete glyph;
-                return ReplyOk;
-            }
-            // now we have our full glyph, try harder to split it
-_nextglyph:
-            raw=new int[glyph->height];            
-            if(adm_estimate_glyphSize(glyph,&minx, &maxx,&miny,&maxy,raw))
-            {
-            //printf("Glyph width :%lu min:%lu max:%lu estimate width:%lu\n",glyph->width,minx,maxx,maxx-minx+1);
-            if((maxx-minx+2)<glyph->width && (maxx-minx>2) && (maxy-miny>2))
-            {
-                // Suspicously too small
-                // We have to split the glyph
-                // recursively to extract each glyph
-                uint32_t width=maxx-minx+1;
-                uint32_t defStride=width+1;
-                
-                if(defStride>glyph->width) defStride=glyph->width;
-                
-                admGlyph *lefty=new admGlyph(defStride,glyph->height);
-                for(int32_t i=miny;i<=maxy;i++)
-                {
-                    if(raw[i]!=-1) memcpy(&(lefty->data[0+i*defStride]),&(glyph->data[minx+i*glyph->width]),raw[i]+1-minx);
-                    else
-                            memcpy(&(lefty->data[0+i*defStride]),&(glyph->data[minx+i*glyph->width]),defStride);
-                }
-                lefty=clippedGlyph(lefty);
-              
-                {
-                    // Remove that from the original
-                    for(uint32_t i=0;i<glyph->height;i++)
-                    {
-                        //printf("%d:%d(%d)\n",i,raw[i],glyph->width);
-                        if(raw[i]!=-1) memset(&(glyph->data[i*glyph->width]),0,raw[i]+1);
-                        else           memset(&(glyph->data[i*glyph->width]),0,defStride); 
-                    }
-                    // Clip
-                    glyph=clippedGlyph(glyph);
-                
-                    if(lefty->width)
-                    {
-                        reply=glyphToText(lefty,head,decodedString);
-                        if(reply!=ReplyOk)
-                        {
-                            printf("Glyph2text failed(1)\n");
-                            return reply;
-                        }
-                    }
-                    else
-                        delete lefty;
-                    if(glyph->width)
-                    {
-                        if(raw) delete [] raw;
-                        goto _nextglyph;                    
-                    } 
-                 }           
-            }
-            }//If
-            if(raw) delete [] raw;
-            if(glyph->width)
-            {
-                reply=glyphToText(glyph,head,decodedString);
-                if(reply!=ReplyOk)                 
-                {
-                    printf("Glyph2text failed(2)\n");
-                    return reply;
-                }
-            }
-            else 
-            {
-                delete glyph;
-            }
-            
-    return ReplyOk;
-
-}
-/**
-      \fn ocrUpdateMinThreshold
-      \brief update the threshold to say black or white when we merge bitmap and alpha mask
-*/
-void ocrUpdateMinThreshold(void)
-{
-        int val;
-        val=minThreshold;
-        if(DIA_GetIntegerValue(&val, 0x30, 0x80, "Minimum pixel value", "Enter new minimum pixel"))
-        {
-                minThreshold=val;
-
-        }
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.h	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.h	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,41 +0,0 @@
-/***************************************************************************
-                         
-     External Interface for OCR engine
-     
-    copyright            : (C) 2007 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_OCR_H
-#define ADM_OCR_H
-#include "ADM_videoFilter/ADM_vobsubinfo.h"
-#include "ADM_videoFilter/ADM_vidVobSub.h"
-#include "ADM_ocr/adm_glyph.h"
-typedef enum
-{
-	ADM_OCR_TYPE_VOBSUB=1,
-	ADM_OCR_TYPE_TS=2,
-}ADM_OCR_SOURCE_TYPE;
-
-
-typedef struct
-{
-	ADM_OCR_SOURCE_TYPE type;
-	vobSubParam *subparam;
-	char		*TsFile;
-	uint32_t    TsPid;
-}ADM_OCR_SOURCE;
-
-
-uint8_t ADM_ocr_engine(   ADM_OCR_SOURCE & source,const char *labelSrt,admGlyph *head);
-
-
-#endif 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrEngine.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrEngine.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrEngine.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,191 +0,0 @@
-/***************************************************************************
-      UI independant part of the OCR engine
-      (C) 2007 Mean
- ***************************************************************************/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #include "config.h"
-#include "ADM_default.h"
-
- #include "ADM_editor/ADM_edit.hxx"
- #include "ADM_videoFilter.h"
- #include "ADM_ocr.h"
- #include "ADM_ocrInternal.h"
- #include "DIA_coreToolkit.h"
-
-#include "ADM_video/ADM_vidMisc.h"
-
-/**************************
- *  UI Dependant part
- *************************/
-uint8_t ADM_ocrUpdateNbLines(void *ui,uint32_t cur,uint32_t total);
-uint8_t ADM_ocrUpdateNbGlyphs(void *ui,uint32_t nbGlyphs);
-uint8_t ADM_ocrUpdateTextAndTime(void *ui,char *decodedString,char *timeCode);
-uint8_t ADM_ocrDrawFull(void *d,uint8_t *data);
-uint8_t ADM_ocrUiEnd(void *d);
-void 	*ADM_ocrUiSetup(void);
-uint8_t ADM_ocrSetRedrawSize(void *ui,uint32_t w,uint32_t h);
-
-extern void UI_purge(void);
-/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        Main
-   +++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
-
-/**
- * 		\fn 		ADM_ocr_engine
- * 		\brief 		Common part of the OCR engine
- */
-uint8_t ADM_ocr_engine(ADM_OCR_SOURCE & source,const char *labelSrt,admGlyph *head)
-{
-    uint32_t nbSub=0;
-    FILE *out=NULL;
-    vobSubBitmap *bitmap=NULL;
-    ADM_BitmapSource *bitmapSource=NULL;
-    uint32_t startTime,endTime;
-    uint32_t w,h,oldw=0,oldh=0;
-    uint32_t oldbitmapw=0;
-    uint32_t oldbitmaph=0;
-    uint32_t first,last;
-    uint32_t seqNum;
-    char     text[1024];
-    ReplyType reply;
-    void *ui=NULL;
-    char decodedString[1024];
-    uint8_t *workArea=NULL;
-    uint32_t nbGlyphs=0;
-    
-    ui=ADM_ocrUiSetup();
-    
-    int success = 1;
-
-_again:    
-    
-    UI_purge();
- 
-    out=fopen(labelSrt,"wb");
-    if(!out)
-    {
-        success = 0;
-       GUI_Error_HIG(QT_TR_NOOP("Output file error"), QT_TR_NOOP("Could not open \"%s\" for writing."), labelSrt);
-       goto endIt;
-    }
-
-    bitmapSource=ADM_buildBitmapSource(&source);
-    if(!bitmapSource)
-    {
-        success = 0;
-        GUI_Error_HIG(QT_TR_NOOP("Input file error"), QT_TR_NOOP("Unknown source type"));
-        goto endIt;
-    }
-    if(!bitmapSource->init(&source))
-    {
-        success = 0;
-        GUI_Error_HIG(QT_TR_NOOP("Input file error"), QT_TR_NOOP("Bitmap source failed"));
-        goto endIt;
-    }
-    
-    nbSub=bitmapSource->getNbImages();
-    if(!nbSub)
-    {
-        success = 0;
-        GUI_Error_HIG(QT_TR_NOOP("Problem loading sub"),QT_TR_NOOP("No subs"));
-        goto endIt;
-     }
-
-    seqNum=1;   // Sub number in srt file
-    oldw=oldh=0;
-    uint32_t eos;
-    //******************    
-    // Load all bitmaps
-    //******************
-    for(uint32_t i=0;i<nbSub;i++)
-    {
-            first=last=0;
-            bitmap=bitmapSource->getBitmap(i,&startTime, &endTime,&first,&last,&eos);
-            if(eos) break;
-            ADM_assert(last>=first);
-            
-            if(!bitmap) continue;
-            if(first==last) continue;
-
-            // If the bitmap size changed or does not exist yet...
-            if(!workArea || oldbitmapw!=bitmap->_width || oldbitmaph!=bitmap->_height)
-            {
-              if(workArea) 
-              {
-                delete [] workArea;
-                workArea=NULL; 
-              }
-              // Workarea is actually bigger than what we use
-              workArea=new uint8_t[bitmap->_width*(bitmap->_height)];
-              memset(workArea,0,bitmap->_width*(bitmap->_height));
-            }
-            oldbitmaph=bitmap->_height;
-            oldbitmapw=bitmap->_width;
-
-           w=bitmap->_width;
-           h=last-first+1;
-           
-           ADM_ocrSetRedrawSize(ui,w,h);
-           
-           // Build
-againPlease:
-           mergeBitmap(bitmap->_bitmap+first*w, workArea, bitmap->_alphaMask+first*w,  w,   h);
-           if(oldw!=w || oldh !=h)
-           {                
-                UI_purge();  // Force redaw
-           }
-           // Merge & draw
-             ADM_ocrDrawFull(ui,workArea);
-             // OCR
-              reply=ocrBitmap(workArea,w,h,decodedString,head);
-              if(reply==ReplyClose) goto endIt;
-              if(reply==ReplyCalibrate)
-                {
-                        ocrUpdateMinThreshold();
-                        goto againPlease;
-                }
-             
-             fprintf(out,"%d\n",seqNum++);
-             uint16_t hh,mm,ss,ms;
-             ms2time(startTime, &hh, &mm, &ss, &ms);
-             fprintf(out,"%02d:%02d:%02d,%03d --> ",hh,mm,ss,ms);
-             
-             // Update Timecode
-             char timeCode[100];
-             snprintf(timeCode,100,"%02d:%02d:%02d,%03d",hh,mm,ss,ms);
-             ADM_ocrUpdateTextAndTime(ui,decodedString,timeCode);
-             
-             ms2time(endTime, &hh, &mm, &ss, &ms);
-             fprintf(out,"%02d:%02d:%02d,%03d\n",hh,mm,ss,ms);
-             fprintf(out,"%s\n\n",decodedString);
-
-             oldw=w;
-             oldh=h;
-             // Update infos
-             ADM_ocrUpdateNbLines(ui,i+1,nbSub);
-             ADM_ocrUpdateNbGlyphs(ui,nbGlyphs);
-    }
-
-endIt:
-	ADM_ocrUiEnd(ui);
-	ui=NULL;
-    
-    if(out) 
-          fclose(out);
-      out=NULL;
-      
-      if(bitmapSource)
-    	        delete bitmapSource;
-    	    bitmapSource=NULL;
-      
-    return success;
-}
-
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrInternal.h	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrInternal.h	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,51 +0,0 @@
-/***************************************************************************
-                         
-     Internal Interface for OCR engine
-     
-    copyright            : (C) 2007 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-#ifndef ADM_OCR_INTERNAL_H
-#define ADM_OCR_INTERNAL_H
- 
-#include "adm_glyph.h"
-
-
-typedef enum 
-{
-        ReplyOk=1,
-        ReplyClose=0,
-        ReplyCalibrate=2,
-        ReplySkip=3,
-        ReplySkipAll=4
-}ReplyType;
-
-// GUI independant part
-ReplyType handleGlyph(uint8_t *workArea,uint32_t start, uint32_t end,uint32_t w,uint32_t h,uint32_t base,
-							admGlyph *head,char *decodedstring);
-ReplyType ocrBitmap(uint8_t *workArea,uint32_t w,uint32_t h,char *decodedString,admGlyph *head);
-uint8_t   mergeBitmap(uint8_t *bitin, uint8_t *bitout, uint8_t *maskin,uint32_t w, uint32_t h);
-void 	  ocrUpdateMinThreshold(void);
-
-// In GUI dependant part
-ReplyType glyphToText(admGlyph *glyph,admGlyph *head,char *decodedString);
-
-/**
- * \class ADM_BitmapSource
- * \brief Front end base class for all OCR'able bitmap source
- */
-class ADM_BitmapSource
-{
-				
-public: 
-								ADM_BitmapSource(void) {};
-			virtual uint8_t     init(ADM_OCR_SOURCE *source)=0;
-			virtual 			~ADM_BitmapSource() {};
-			virtual uint32_t 	getNbImages(void)=0;
-			virtual vobSubBitmap *getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last,
-											uint32_t *eos)=0;
-};
-ADM_BitmapSource *ADM_buildBitmapSource(ADM_OCR_SOURCE *source);
-
-#endif 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_vob2vobsub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_vob2vobsub.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_vob2vobsub.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,551 +0,0 @@
-/***************************************************************************
-                         Vob2vobsub
-                      -------------------
-          Convert a set of vobs to a vobsub file
-          * missing : 
-                size 720*576 
-                palette
-                languages
-                Multiple sub           
-                      
-     IFO reading from mplayer, everything else from me
-                      
-    copyright            : (C) 2005 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#include "ADM_default.h"
-#include <math.h>
-
-#include <time.h>
-#include <sys/time.h>
-
-#include "DIA_coreToolkit.h"
-
-
-#include "ADM_audio/aviaudio.hxx"
-#include "ADM_audiofilter/audioprocess.hxx"
-
-#include "DIA_fileSel.h"
-#include "ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h"
-#include "ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h"
-#include "ADM_userInterfaces/ADM_commonUI/DIA_working.h"
-
-#include "ADM_video/ADM_vidMisc.h"
-
-#define ADM_VOBSUB_NO_PADDING
-static int vobsub_parse_ifo(const char *const name, 
-                     uint32_t *palette, 
-                     uint32_t *width, uint32_t *height, 
-		             char *language);
-static uint8_t dumpHeader(FILE *fd,int index,uint32_t w,uint32_t h,uint32_t *palette);
-static void padd(int nb,FILE *fd);
-
-static uint8_t  *padder;
-
-#define PADDER_SIZE 0x800
-
-#define MAX_LINE        5000
-#define MAX_BUFFER      (1*1024)
-#define MAX_LANGUAGE    10
-
-#define MIN_WRAP_VALUE (90*1000*60*1) // 1 mn
-
-typedef struct oneLine
-{
-    uint64_t pts;
-    uint32_t start;
-}oneLine;
-
-class OneTrack
-{
-protected:         
-            char        language[2];   
-            uint8_t     *base;
-            uint32_t    limit;
-            uint32_t    index;
-            oneLine     *lines;
-            uint32_t    nbLines;
-            int         runCode;
-            uint64_t    currentPTS;
-            int         firstOne;
-            
-            uint8_t     addData(uint8_t *data,uint32_t len);
-            uint8_t     addLine(uint64_t pts,uint32_t start);
-            uint8_t     grow(void);
-public:    
-            uint8_t     run(uint16_t twofirst,uint8_t *data,uint32_t size,uint32_t usableSize,uint64_t pts);
-            uint8_t     setLang(char *lang);
-            uint8_t     dump(uint32_t index,FILE *fdIdx, FILE *fdSub,uint32_t *out);
-                        OneTrack(void);
-                        ~OneTrack();
-};
-
-OneTrack::OneTrack(void)
-{
-    
-    base=new uint8_t[  MAX_BUFFER];
-    limit= MAX_BUFFER;
-    index=0;
-    lines=new oneLine[MAX_LINE];
-    nbLines=0;  
-    runCode=0;
-    
-}
-uint8_t OneTrack::setLang(char *lang)
-{
-    language[0]=lang[0];
-    language[1]=lang[1];
-    return 1;
-}
-OneTrack::~OneTrack()
-{
-    delete [] base;
-    delete [] lines;
-}
- uint8_t     OneTrack::addData(uint8_t *data,uint32_t len)
-{
-    while(len+index>limit) grow();
-    
-    memcpy(base+index,data,len);
-    index+=len;
-    return 1;   
-}
-uint8_t     OneTrack::grow(void)
-{
-    uint8_t *nw;
-    nw=new uint8_t[2*limit];
-    memcpy(nw,base,limit);
-    delete [] base;
-    base=nw;
-    limit*=2;
-    return 1;   
-    
-}
- uint8_t     OneTrack::addLine(uint64_t pts,uint32_t start)
-{
-    if(nbLines>=MAX_LINE) return 0;
-    lines[nbLines].pts=pts;
-    lines[nbLines].start=start;
-        
-    nbLines++;
-    return 1;   
-}
-uint8_t     OneTrack::dump(uint32_t number,FILE *fdIdx, FILE *fdSub,uint32_t *out)
-{
-    uint16_t hh,mm,ss,ms;
-    uint32_t timestamp;
-    uint32_t original,position;
-    original=ftello(fdSub); // Current position, we start from here
-      
-    if(!index) return 1;
-  
-    fwrite(base,index,1,fdSub); // Append our datas
-    
-    
-    fprintf(fdIdx,"# English\n");
-    fprintf(fdIdx,"id: %c%c, index: %d\n",language[0],language[1],number);
-    fprintf(fdIdx,"# Decomment next line to activate alternative name in DirectVobSub / Windows Media Player 6.x\n");
-    fprintf(fdIdx,"# alt: English\n");
-    fprintf(fdIdx,"# Vob/Cell ID: 1, 1 (PTS: 0)\n");
-    (*out)++;
-    for(int i=0;i<nbLines;i++) // We shift PTS & position by 1 to workaround the display bug
-    {   
-        if(lines[i].pts!=ADM_NO_PTS)
-        {     
-            timestamp=(uint32_t)floor(lines[i].pts/90.);
-            ms2time(timestamp,&hh,&mm,&ss,&ms);
-            position=lines[i].start;
-            //printf("Stream :%d position :%x offset:%x total:%x\n",i,position,original,original+position);
-            position+=original;          
-            fprintf(fdIdx,"timestamp: %02d:%02d:%02d:%03d, filepos: %08x\n",hh,mm,ss,ms,position); 
-        }
-        else
-        {
-                printf("Sub %d, skipped line at %d\n",number,i);
-        }
-    }
-    return 1;
-}
-uint8_t     OneTrack::run(uint16_t twofirst,uint8_t *data,uint32_t size,uint32_t usableSize,uint64_t pts)
-{
-uint32_t padding;
-    
-    if(!runCode) // new line
-    {
-        currentPTS=pts;
-        runCode=twofirst-usableSize;
-        addLine(pts,index);
-#if 0
-        {
-        uint16_t hh,mm,ss,ms;
-        uint32_t timestamp;
-
-              timestamp=pts/90;
-              ms2time(timestamp,&hh,&mm,&ss,&ms);
-              printf("Line : %03u  at %02d:%02d:%02d \n",nbLines,hh,mm,ss);
-        }
-#endif
-        addData(data,size);
-        if(runCode<0) runCode=0;
-        return 1; 
-    }
-    if(currentPTS==ADM_NO_PTS && pts!=ADM_NO_PTS)
-        currentPTS=lines[nbLines-1].pts=pts;
-    runCode-=usableSize;
-    if(runCode<0)
-    {
-         printf("Overrun %d\n",runCode);
-         runCode=0;
-    }
-    addData(data,size);
-    return 1;
-    
-} 
-/*
-    nameVob     : path + name of the 1st .vob file
-    nameVobSub  : path+name of the .idx file to write
-    nameIfo     : path+name of the ifo file
-
-
-*/
-//**********************************************
-uint8_t ADM_vob2vobsub(char *nameVob, char *nameVobSub, char *nameIfo)
-{
-   dmx_demuxerPS *demuxer=NULL;
-   DIA_working *working=NULL;
-   MPEG_TRACK track;
-   FILE *indexFile=NULL;
-   FILE *indexSub=NULL;
-   uint32_t palette[16],width,height;
-   uint64_t abs,rel,size,pts;
-   int blockSize;
-   uint8_t *data,stream;
-   char *subname;
-   double percent;
-   uint32_t packetLen,usedLen,read;
-   OneTrack allIndex[MAX_LANGUAGE];
-   char language[MAX_LANGUAGE*4];
-#ifdef  TEST_V2V  
-   nameIfo="d:/Crime/VTS_01_0.IFO";
-   nameVobSub="toto.idx";
-#endif
-   
-        printf("v2v: Ifo:%s Vob:%s Vsub:%s\n",nameIfo,nameVob,nameVobSub);
-
-   memset(language,0,sizeof(language));
-   memset(palette,0,sizeof(uint32_t)*16);
-   if(!vobsub_parse_ifo(nameIfo,palette,&width,&height,language))
-   {
-     GUI_Error_HIG(QT_TR_NOOP("Ifo error"),QT_TR_NOOP("Error reading ifo file, aborting."));   
-        return 0;
-   } 
-   printf("Ifo: %d x %d\n",width,height);                 
-   
-   indexFile=fopen(nameVobSub,"wt");
-   if(!indexFile)
-   {
-     GUI_Error_HIG(QT_TR_NOOP("Cannot write .idx"),NULL);              
-        return 0;
-    }
-   subname=ADM_strdup(nameVobSub);
-   size=strlen(subname);
-   subname[size-3]='s';
-   subname[size-2]='u';
-   subname[size-1]='b';
-   indexSub=fopen(subname,"wb");
-   ADM_dealloc(subname);
-    if(!indexSub)
-    {
-        fclose(indexFile);
-        GUI_Error_HIG(QT_TR_NOOP("Cannot write .sub"),NULL);
-        return 0;
-    }
-   for(int i=0;i<MAX_LANGUAGE;i++)
-   {
-         allIndex[i].setLang(language+i*3);  
-   }
-   track.pes=0x20;
-   track.pid=track.pes;
-   demuxer=new  dmx_demuxerPS(1,&track,1);
-   if(!demuxer->open(nameVob))
-   {
-     GUI_Error_HIG(QT_TR_NOOP("Problem opening the mpeg files"),NULL);
-        delete demuxer;
-        fclose(indexFile);
-        fclose(indexSub);
-        return 0;   
-   }
-   
-   
-   size=demuxer->getSize();
-   
-    int display=0;
-    
-   dumpHeader(indexFile,0,width,height,palette);
-   working=new DIA_working(QT_TR_NOOP("Generating VobSub file"));
-   
-   //*** Main Loop ***
-   uint32_t startPts=0,lastPts=0;
-   uint16_t hh,mm,ss,ms;
-   uint32_t timestamp;
-   while(1)
-   {
-       if(!demuxer->forceRefill(&stream)) goto _abt;
-       demuxer->getPos(&abs,&rel);
-       display++;
-       if(display>20)
-       {
-        working->update(abs>>10,size>>10);
-        display=0;
-       }
-#ifdef TEST_V2V       
-       //if(abs>200*1024*1024) break;
-#endif       
-       if(stream>=0x20 && stream<0x20+MAX_LANGUAGE)
-       {
-            demuxer->getPacketInfo(&data,&packetLen,&usedLen,&pts);
-            if(pts!=ADM_NO_PTS)
-            {
-                        // Wrap around ?
-                        if(lastPts)
-                        {
-                                if(pts<lastPts)
-                                {
-                                        if(lastPts-pts>MIN_WRAP_VALUE)
-                                        {
-                                                
-                                                printf("Wrapping at %u ",lastPts);
-                                                startPts+=lastPts;
-                                                timestamp=startPts/90;
-                                                ms2time(timestamp,&hh,&mm,&ss,&ms);
-                                                printf("%02d:%02d:%02d \n",hh,mm,ss);
-                                        }
-                                }
-                        }
-
-                        lastPts=pts;
-                        pts+=startPts;
-            }
-#if 0
-            if(pts!=ADM_NO_PTS)
-            {
-              timestamp=pts/90;
-              ms2time(timestamp,&hh,&mm,&ss,&ms);
-              printf("%02d:%02d:%02d \n",hh,mm,ss);
-            }
-#endif
-            blockSize=demuxer->read16i();
-            allIndex[stream-0x20].run(blockSize,data,packetLen,usedLen, pts)  ;
-       }
-    }
-  //*** /Main Loop ***     
-  _abt:
-  uint32_t out=0,padding;
-  for(int i=0;i<MAX_LANGUAGE;i++)
-  {
-      allIndex[i].dump(i,indexFile, indexSub,&out);  
-      padding=ftello(indexSub);
-      printf("Padding : was %x ",padding);
-      padding=padding+PADDER_SIZE-1;
-      padding&=0xffffffff^(PADDER_SIZE-1);  
-      fseeko(indexSub,padding,SEEK_SET);  
-      printf(" -> %x\n",padding);
-  }
-  
-  
-  printf("scan done %"LLU"/%"LLU"\n",abs,size); 
-  delete working;
-  delete demuxer;     
-  fclose(indexFile);
-  fclose(indexSub);
-  return 1;
-    
-}
-/*
-Borrowed from Mplayer
-*/
-
-extern void mixDump(uint8_t *p,uint32_t l);
-int vobsub_parse_ifo(const char *const name, 
-                     uint32_t *palette, 
-                     uint32_t *width, uint32_t *height, 
-		             char *language)
-{
-    int ret = 0;
-    FILE *fd = fopen(name, "rb");
-    if(!fd) return 0;
-    
-	// parse IFO header
-	unsigned char block[0x800];
-	const char *const ifo_magic = "DVDVIDEO-VTS";
-	if (fread(block, sizeof(block), 1, fd) != 1) 
-	{
-    	fclose(fd);
-    	return 0;
-    }
-    if(memcmp(block,ifo_magic,strlen(ifo_magic+1)))
-    {
-        printf("Bad ifo magic\n");
-        fclose(fd);
-    	return 0;
-    }
-	    unsigned long pgci_sector = block[0xcc] << 24 | block[0xcd] << 16
-		| block[0xce] << 8 | block[0xcf];
-	    int standard = (block[0x200] & 0x30) >> 4;
-	    int resolution = (block[0x201] & 0x0c) >> 2;
-	    *height = standard ? 576 : 480;
-	    *width = 0;
-	    switch (resolution) {
-	    case 0x0:
-		*width = 720;
-		break;
-	    case 0x1:
-		*width = 704;
-		break;
-	    case 0x2:
-		*width = 352;
-		break;
-	    case 0x3:
-		*width = 352;
-		*height /= 2;
-		break;
-	    default:
-		printf("Vobsub: Unknown resolution %d \n", resolution);
-	    }
-	    unsigned  int tmp=0;
-	    for(int lg=0;lg<MAX_LANGUAGE;lg++)
-	    {
-		    tmp= 0x256 + lg * 6 + 2;
-		    //printf("Lang :%d %c%c\n",lg,block[tmp],block[tmp+1]);//tmp[0],tmp[1]);
-		    language[lg*3+0]=block[tmp];
-		    language[lg*3+1]=block[tmp+1];
-            language[lg*3+2]=0;
-		}
-	    if (fseeko(fd, pgci_sector * sizeof(block), SEEK_SET)
-		|| fread(block, sizeof(block), 1, fd) != 1)
-		 {}
-		 else
-		 {
-	    
-		        unsigned long idx,r,g,b,y,u,v;
-		        unsigned long pgc_offset = block[0xc] << 24 | block[0xd] << 16
-		                 | block[0xe] << 8 | block[0xf];
-		        // 8+32*4+8*2+4+dvd_time_t+user_ops_t
-		        // 9c+dvd_time+user_ops_t=9c+4+8=0xA8  
-		        //mixDump(block,0x800);      
-		        for (idx = 0; idx < 16; ++idx) 
-		        {
-  		        
-		            unsigned char *p = block + pgc_offset + 0xa4 + 4 * idx; 
-#if 1
-                        r=p[1];g=p[2];b=p[3];
-                       // palette[idx] = r << 16 | g << 8 | b;
-                        palette[idx] = r << 16 | r << 8 | r;
-#else		            
-		                y=p[1];u=p[2];v=p[3];
-		                float rr,bb,gg;
-	                    float yy=y,uu=u-128,vv=v-128;
-
-	                    rr=	yy+			 	1.402*vv;
-	                    gg= yy+ 	-0.344*uu+  	-0.714*vv;
-	                    bb=	yy+ 	1.772*uu 	 		;
-
-	#define CLIP(x) if(x>255) x=255; else if (x<0) x=0;x=x+0.49;
-		                CLIP(rr);CLIP(gg);CLIP(bb);
-		                r=(unsigned long int)rr;
-		                g=(unsigned long int)gg;
-		                b=(unsigned long int)bb;
-		                //palette[idx] = p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3];
-		                palette[idx] = r << 16 | g << 8 | b;
-#endif		                
-		        }
-		        ret= 1;
-	     }
-_ifo_abt:		
-	    fclose(fd);
-    
-    return ret;
-}
-
-/**********************************************************************
-
-
-***********************************************************************/
-static uint8_t dumpHeader(FILE *fd,int index,uint32_t w,uint32_t h,uint32_t *palette)
-{
-    fprintf(fd,"# VobSub index file, v7 (do not modify this line!)\n");
-    fprintf(fd,"# \n");
-    fprintf(fd,"# To repair desyncronization, you can insert gaps this way:\n");
-    fprintf(fd,"# (it usually happens after vob id changes)\n");
-    fprintf(fd,"# \n");
-    fprintf(fd,"#	 delay: [sign]hh:mm:ss:ms\n");
-    fprintf(fd,"# \n");
-    fprintf(fd,"# Where:\n");
-    fprintf(fd,"#	 [sign]: +, - (optional)\n");
-    fprintf(fd,"#	 hh: hours (0 <= hh)\n");
-    fprintf(fd,"#	 mm/ss: minutes/seconds (0 <= mm/ss <= 59)\n");
-    fprintf(fd,"#	 ms: milliseconds (0 <= ms <= 999)\n");
-    fprintf(fd,"# \n");
-    fprintf(fd,"#	 Note: You can't position a sub before the previous with a negative value.\n");
-    fprintf(fd,"# \n");
-    fprintf(fd,"# You can also modify timestamps or delete a few subs you don't like.\n");
-    fprintf(fd,"# Just make sure they stay in increasing order.\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"# Settings\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"# Original frame size\n");
-    fprintf(fd,"size: %dx%d\n",w,h);
-    fprintf(fd,"\n");
-    fprintf(fd,"# Origin, relative to the upper-left corner, can be overloaded by aligment\n");
-    fprintf(fd,"org: 0, 0\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"# Image scaling (hor,ver), origin is at the upper-left corner or at the alignment coord (x, y)\n");
-    fprintf(fd,"scale: 100%%, 100%%\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"# Alpha blending\n");
-    fprintf(fd,"alpha: 100%%\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"# Smoothing for very blocky images (use OLD for no filtering)\n");
-    fprintf(fd,"smooth: OFF\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"# In millisecs\n");
-    fprintf(fd,"fadein/out: 50, 50\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"# Force subtitle placement relative to (org.x, org.y)\n");
-    fprintf(fd,"align: OFF at LEFT TOP\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"# For correcting non-progressive desync. (in millisecs or hh:mm:ss:ms)\n");
-    fprintf(fd,"# Note: Not effective in DirectVobSub, use \"delay: ... \" instead.\n");
-    fprintf(fd,"time offset: 0\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"# ON: displays only forced subtitles, OFF: shows everything\n");
-    fprintf(fd,"forced subs: OFF\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"# The original palette of the DVD\n");
-    fprintf(fd,"palette:");
-    for(int k=0;k<16;k++) // 131313, efefef, efefef, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff\n");
-    {
-        if(k) fprintf(fd,", ");
-        fprintf(fd,"%06x",palette[k]);
-    }
-    fprintf(fd,"\n");
-    fprintf(fd,"# Custom colors (transp idxs and the four colors)\n");
-    fprintf(fd,"custom colors: OFF, tridx: 0000, colors: 000008, 300030, 000030, 9332c8\n");
-    fprintf(fd,"\n");
-    fprintf(fd,"# Language index in use\n");
-    fprintf(fd,"langidx: %d\n",0);
-    fprintf(fd,"\n");
-    return 1;  
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/CMakeLists.txt	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/CMakeLists.txt	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,7 +0,0 @@
-SET(ADM_ocr_SRCS 
-	adm_glyph.cpp  adm_leftturn.cpp  ADM_vob2vobsub.cpp
-	ADM_ocr.cpp
-	ADM_bitmapSource.cpp
-	ADM_ocrEngine.cpp)
-
-ADD_ADM_LIB_ALL_TARGETS(ADM_ocr ${ADM_ocr_SRCS})
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,249 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #include "config.h"
-#include "ADM_default.h"
- #include "adm_glyph.h"
-#include "DIA_coreToolkit.h"
- //*************************************************
-admGlyph::admGlyph(uint32_t w,uint32_t h)
-{
-    ADM_assert(w*h);
-    width=w;
-    height=h;
-    data=new uint8_t[w*h];
-    memset(data,0,w*h);
-    code=NULL;
-    next=NULL;
-}
-//*************************************************
-admGlyph::~admGlyph()
-{
-    delete [] data;
-    data=NULL;
-    if(code)
-    {
-        ADM_dealloc(code);
-        code=NULL;
-    }
-}
-//*************************************************
-uint8_t admGlyph::create(uint8_t *incoming, uint32_t stride)
-{
-uint8_t *in=incoming;
-uint8_t *out=data;
-    for(uint32_t y=0;y<height;y++)
-    {
-        memcpy(out,in,width);
-        out+=width;
-        in+=stride;
-    }
-    return 1;
-}
-//*************************************************
-uint8_t  insertInGlyphTree(admGlyph *startGlyph, admGlyph *candidate)
-{
-admGlyph *old;
-            old=startGlyph->next;
-            candidate->next=old;
-            startGlyph->next=candidate;
-            return 1;
-}
-//*************************************************
-uint8_t  destroyGlyphTree(admGlyph *startGlyph)
-{
-admGlyph *head,*tmp;
-        if(!startGlyph) return 0;
-        head=startGlyph->next;
-        while(head)
-        {
-            tmp=head;
-            head=head->next;
-            delete tmp;
-        }
-    return 1;
-}
-//*************************************************
-admGlyph *searchGlyph(admGlyph *startGlyph, admGlyph *candidate)
-{
-admGlyph *head=startGlyph->next;
-            while(head)
-            {   
-                if(head->width==candidate->width && head->height==candidate->height)
-                {
-                    //Raw compare
-                    if(!memcmp(head->data,candidate->data,head->width*head->height))
-                        return head;
-                
-                }
-                head=head->next;
-            }
-            return NULL;
-}
-/*************************************************/
-admGlyph *clippedGlyph(admGlyph *in)
-{
-uint32_t w,h,lonecount,lone;
-int32_t top,bottom,left,right;
-admGlyph *nw=NULL;
-            w=in->width;
-            h=in->height;
-            // Look if we got a lonely point at the first line
-            lonecount=0;
-            if(w>3)
-              for(uint32_t i=0;i<w;i++) 
-                if(in->data[i]) 
-                {
-                    lonecount++;
-                    lone=i;
-                }
-            if(lonecount==1)
-            {
-                if(!lone) lone++;
-                if(lone==w-1) lone--;
-                if(!in->data[w+lone-1] && !in->data[w+lone] && !in->data[w+lone+1])
-                    in->data[lone]=0;
-            }
-            // Go!
-            left=0;
-            while(columnEmpty(in->data+left,w,h) && left<w) left++;
-            if(left==w) 
-            {
-                in->width=in->height=0;
-                return in;
-            }
-            right=w-1;
-            while(columnEmpty(in->data+right,w,h) && right>=left) right--;
-            
-            top=0;
-            while(lineEmpty(in->data,w,w,top) && top<h) top++;
-            
-            bottom=h-1;
-            while(lineEmpty(in->data,w,w,bottom) && bottom>=top) bottom--;
-            
-            nw=new admGlyph(right-left+1,bottom-top+1);
-            nw->create(in->data+left+top*w,w);
-            delete in;
-            return nw;
-
-}
-/**
-    \fn glyphSearchFather
-    \brief Returns the father of the "in" glyph.
-    @param in : Glyph to search the father of
-    @param head : head of glyph list
-    @returns father or NULL if not found
-*/
-admGlyph *glyphSearchFather(admGlyph *in,admGlyph *head )
-{
-  admGlyph *cur=head;
-  while(cur)
-  {
-    if(!cur->next) return NULL;
-    if(cur->next==in) return cur; 
-    cur=cur->next;
-  }
-  return NULL;
-}
-/*************************************************/
-/**
-    \fn       glyphSave
-    \brief    Save the glypset
-*/
-uint8_t saveGlyph(char *name,admGlyph *head,uint32_t nb)
-{
-  FILE *out;
-  uint32_t slen;
-  nb=0;
-  admGlyph *glyph=head->next;
-    
-    
-  out=fopen(name,"wb");
-  if(!out)
-  {
-    GUI_Error_HIG(QT_TR_NOOP("Could not write the file"), NULL);
-    return 0;
-  }
-    
-    /* First count how many glyphs */
-     while(glyph)
-    {
-      glyph=glyph->next;
-      nb++;
-    }
-    
-#define WRITE(x) fwrite(&(x),sizeof(x),1,out);
-    WRITE(nb);
-    
-    glyph=head->next;
-    while(glyph)
-    {
-      WRITE(glyph->width);
-      WRITE(glyph->height);
-      fwrite(glyph->data,glyph->width*glyph->height,1,out);
-      if(glyph->code) slen=strlen(glyph->code);
-      else slen=0;
-      WRITE(slen);
-      fwrite(glyph->code,slen,1,out);
-      glyph=glyph->next;
-    }
-    printf("[Glyph] Saved %u glyphs\n",nb);
-    fclose(out);
-    return 1;
-  
-}
-/**
-    \fn loadGlyph
-    \brief Load a glyph set
-*/
-uint8_t loadGlyph(char *name,admGlyph *head,uint32_t *outNb)
-{
-  FILE *out;
-  admGlyph *glyph,*nw;
-  uint32_t N,w,h,slen;
-  uint32_t nbGlyphs;
- 
-  *outNb=0;
-  
-  glyph=head;
-  out=fopen(name,"rb");
-  if(!out)
-  {
-    GUI_Error_HIG(QT_TR_NOOP("File error"), QT_TR_NOOP("Could not read \"%s\"."), name);
-    return 0;
-  }
-#define READ(x) fread(&(x),sizeof(x),1,out);
-    nbGlyphs=0;
-    READ(N);
-    while(N--)
-    {
-        
-      READ(w);
-      READ(h);
-      nw=new admGlyph(w,h);
-      fread(nw->data,w*h,1,out);
-      READ(slen);
-      if(slen)
-      {
-        nw->code=new char[slen+1];
-        fread(nw->code,slen,1,out);
-        nw->code[slen]=0;
-      }
-      glyph->next=nw;
-      glyph=nw;
-      nbGlyphs++;
-    }
-    
-    fclose(out);
-    *outNb=nbGlyphs;
-    printf("[Glyph] Loaded %u glyphs\n",nbGlyphs);
-    return 1;
-
-}
-/*************************************************/
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.h	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.h	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,68 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef ADM_GLYPH_
-#define ADM_GLYPH_
-
-#include "ADM_default.h"
-/*
-    returns 1 if the line is empty
-    0 if not
-*/
-static inline uint8_t lineEmpty(uint8_t *base, uint32_t stride, uint32_t width, uint32_t line)
-{
-    base+=line*stride;
-    for(uint32_t x=0;x<width;x++)
-    {
-        if(base[x]) return 0;
-    }
-    return 1;
-}
-/*
-    returns 1 if the line is empty
-    0 if not
-*/
-static inline uint8_t columnEmpty(uint8_t *base, uint32_t stride, uint32_t height)
-{
-   
-    for(uint32_t y=0;y<height;y++)
-    {
-        if(base[y*stride]) return 0;
-    }
-    return 1;
-}
-
-class admGlyph
-{
-private:
-public:
-    uint32_t width;
-    uint32_t height;
-    uint8_t  *data;
-    
-    
-
-        admGlyph *next;  
-        char * code;    
-                admGlyph(uint32_t w,uint32_t h);
-                ~admGlyph();
-        uint8_t create(uint8_t *data, uint32_t stride);
-};
-
-admGlyph *searchGlyph(admGlyph *startGlyph, admGlyph *candidate);
-uint8_t  destroyGlyphTree(admGlyph *startGlyph);
-uint8_t  insertInGlyphTree(admGlyph *startGlyph, admGlyph *candidate);
-admGlyph *clippedGlyph(admGlyph *in);
-admGlyph *glyphSearchFather(admGlyph *in,admGlyph *head );
-
-uint8_t loadGlyph(char *name,admGlyph *head,uint32_t *outNb);
-uint8_t saveGlyph(char *name,admGlyph *head,uint32_t nb);
-
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_leftturn.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_leftturn.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_leftturn.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,122 +0,0 @@
-//
-// C++ Implementation: %{MODULE}
-//
-// Description:
-//
-//
-// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "ADM_assert.h"
-
-
-#include "fourcc.h"
-
-#include "config.h"
-#include "avi_vars.h"
-
-
-#include "ADM_leftturn.h"
-
-static int incx[4]={1,0,-1,0};
-static int incy[4]={0,1,0,-1};
-
-static int nextdir[4]={1,0,3,2};
-
-
-uint8_t adm_estimate_glyphSize(admGlyph *glyph,uint32_t *minx, uint32_t *maxx,uint32_t *miny,uint32_t *maxy,int *raw)
-{
-    uint32_t nbPoints=0;
-    
-    int      startx,starty;
-    int      curx,cury;
-    int      tgtx,tgty;
-    int      dir;
-    int      found;
-    uint32_t xmin=glyph->width-1;
-    uint32_t xmax=0;
-    
-    uint32_t ymin=glyph->height-1,ymax=0;
-    
-    for(uint32_t i=0;i<glyph->height;i++) raw[i]=-1;
-    
-    
-    *minx=0;
-    *maxx=0;
-    // Small glyph ?
-    if(glyph->width<3)
-    {
-        *minx=0;
-        *maxx=glyph->width-1;
-        return 1;
-    }
-    // Search for a non empty line from the bottom of the glyph bottom to top, left to right
-    startx=0;
-    for(starty=glyph->height-1;starty>=0;starty--)
-    {
-       
-            if(glyph->data[starty*glyph->width]) goto _fnd;   
-        
-    }
-    // Glyph empty ?
-    printf("Empty glyph\n");
-    return 0;
-_fnd:
-    dir=0;
-    curx=startx;
-    cury=starty;
-    //printf("Starting :%d %d (%d x %d )\n",startx,starty,glyph->width,glyph->height);
-    
-    while(1)
-    {   
-        found=0;
-        for(uint32_t i=0;i<4;i++)
-        {   
-            tgtx=curx+incx[(dir+nextdir[i])%4];
-            tgty=cury+incy[(dir+nextdir[i])%4];
-            //printf("\t candidate :%d %d dir %d\n",tgtx,tgty,(dir+i)%4);
-            if(tgtx>=0 && tgty>=0 && tgtx<glyph->width && tgty<glyph->height)   // Still into the glyph bounding box ?
-                if(glyph->data[tgtx+glyph->width*tgty])                                // Still inside glyph ?
-                {
-                    dir=(dir+nextdir[i])%4;
-                    found=1;
-                    curx=tgtx;
-                    cury=tgty;
-                    break;
-                    
-                }
-        }     
-        if(!found)
-        {          
-            printf("!Stuck\n");
-            return 0;
-        }
-        if(curx>xmax) xmax=curx;
-        if(curx<xmin) xmin=curx;
-        if(cury>ymax) ymax=cury;
-        if(cury<ymin) ymin=cury;
-        if((int)curx>raw[cury])
-        {
-            raw[cury]=curx;
-        }
-        
-       // printf("New coord:%d %d, dir=%d\n",curx,cury,dir);
-        
-        if(curx==startx && cury==starty) 
-        {
-            *minx=xmin;
-            *maxx=xmax;
-    
-            *miny=ymin;
-            *maxy=ymax;
-            return 1;        
-        }        
-    }   
-    return 0;
-}



From mean at mail.berlios.de  Wed Jul 14 14:17:24 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 14:17:24 +0200
Subject: [Avidemux-svn-commit] r6452 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src
Message-ID: <20100714121724.D53EE480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 14:17:24 +0200 (Wed, 14 Jul 2010)
New Revision: 6452

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_codecType.cpp
Log:
[DV] Add more fourcc

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_codecType.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_codecType.cpp	2010-07-14 12:17:22 UTC (rev 6451)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_codecType.cpp	2010-07-14 12:17:24 UTC (rev 6452)
@@ -162,8 +162,10 @@
   uint8_t dv = 0;
 
   CHECK ("dvsd");
-  CHECK ("DVDS");
+  CHECK ("DVSD");
   CHECK ("dvpp");
+  CHECK ("CDVC");
+  CHECK ("cdvc");
 
   return dv;
 



From mean at mail.berlios.de  Wed Jul 14 14:17:26 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 14:17:26 +0200
Subject: [Avidemux-svn-commit] r6453 - in
	branches/avidemux_2.6_branch_mean/avidemux_core:
	ADM_coreUI/include ADM_coreVdpau/include ADM_coreVdpau/src
Message-ID: <20100714121726.3E3CB480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 14:17:26 +0200 (Wed, 14 Jul 2010)
New Revision: 6453

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/ADM_windowInfo.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
Log:
[vdpau] More complete wrapper around vdpau

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/ADM_windowInfo.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/ADM_windowInfo.h	2010-07-14 12:17:24 UTC (rev 6452)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/ADM_windowInfo.h	2010-07-14 12:17:26 UTC (rev 6453)
@@ -4,9 +4,9 @@
 {
     void *display;
     int  window;
-        int x;
-        int y;
-        int width;
-        int height;
+    int x;
+    int y;
+    int width;
+    int height;
 } GUI_WindowInfo;
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-14 12:17:24 UTC (rev 6452)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-14 12:17:26 UTC (rev 6453)
@@ -23,15 +23,20 @@
 */
 class admVdpau
 {
+protected:
+    static GUI_WindowInfo      myWindowInfo;
 public:
     static bool         init(GUI_WindowInfo *x);
     static const char  *getErrorString(VdpStatus er);
     static bool         isOperationnal(void);
-    static  VdpStatus   decoderCreate( VdpDecoderProfile profile,    uint32_t          width,    uint32_t          height,    uint32_t          max_references,       VdpDecoder *      decoder);
-    static  VdpStatus   decoderDestroy(VdpDecoder decoder);
+    /* Surface */
     static  VdpStatus   surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface);
     static  VdpStatus   surfaceDestroy(VdpVideoSurface surface);
     static  VdpStatus   getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3]);
+    /* Decoder */
+    static  VdpStatus   decoderCreate( VdpDecoderProfile profile,    uint32_t          width,    uint32_t          height,    uint32_t          max_references,       VdpDecoder *      decoder);
+    static  VdpStatus   decoderDestroy(VdpDecoder decoder);
+
     static  VdpStatus   decoderRender(
             VdpDecoder                 decoder,
             VdpVideoSurface            target,
@@ -39,5 +44,21 @@
             uint32_t                   bitstream_buffer_count,
             VdpBitstreamBuffer const * bitstream_buffers);
 
+    /* Output surface */
+    static VdpStatus outputSurfaceCreate(
+            VdpRGBAFormat      rgba_format,
+            uint32_t           width,
+            uint32_t           height,
+            VdpOutputSurface * surface);
+
+    static VdpStatus outputSurfaceDestroy(VdpOutputSurface surface);
+    static VdpStatus outPutSurfacePutBitsYV12( 
+            VdpOutputSurface     surface,
+            uint8_t *planes[3],
+            uint32_t pitches[3]);
+    /* Presentation queue */
+    static VdpStatus presentationQueueCreate(VdpPresentationQueue *queue);
+    static VdpStatus presentationQueueDestroy(VdpPresentationQueue queue);
+    static VdpStatus presentationQueueDisplay(VdpPresentationQueue queue,VdpOutputSurface outputSurface);
 };
 #endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 12:17:24 UTC (rev 6452)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 12:17:26 UTC (rev 6453)
@@ -17,6 +17,7 @@
 #include "ADM_dynamicLoading.h"
 
 #ifdef USE_VDPAU
+GUI_WindowInfo      admVdpau::myWindowInfo;
 /**
     \fn VdpFunctions
     
@@ -31,9 +32,21 @@
     VdpVideoSurfaceDestroy  *destroySurface;
     VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
 
+    VdpOutputSurfaceCreate  *createOutputSurface;
+    VdpOutputSurfaceDestroy *destroyOutputSurface;
+    VdpOutputSurfacePutBitsYCbCr *putBitsYV12OutputSurface;
+
     VdpDecoderCreate        *decoderCreate;
     VdpDecoderDestroy       *decoderDestroy;
     VdpDecoderRender        *decoderRender;
+
+
+    VdpPresentationQueueTargetDestroy *presentationQueueDestroy;
+    VdpPresentationQueueCreate        *presentationQueueCreate;
+    VdpPresentationQueueGetTime       *presentationQueueGetTime;
+    VdpPresentationQueueDisplay       *presentationQueueDisplay;
+
+    VdpPresentationQueueTargetCreateX11 *presentationQueueDisplayX11Create;
 }VdpFunctions;
 
 static VdpFunctions          funcs;
@@ -42,6 +55,7 @@
 static VdpDevice             vdpDevice;
 static VdpGetProcAddress     *vdpProcAddress;
 static bool                  coreVdpWorking=false;
+static VdpPresentationQueueTarget  queueX11;
 /**
     \fn getFunc
     \brief vdpau function pointers from ID
@@ -88,8 +102,22 @@
     GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
     GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
     GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
+    GetMe(createOutputSurface,VDP_FUNC_ID_OUTPUT_SURFACE_CREATE);
+    GetMe(destroyOutputSurface,VDP_FUNC_ID_OUTPUT_SURFACE_DESTROY);
+    GetMe(putBitsYV12OutputSurface,VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_Y_CB_CR);
 
+    GetMe(presentationQueueDestroy,VDP_FUNC_ID_PRESENTATION_QUEUE_DESTROY);
+    GetMe(presentationQueueCreate,VDP_FUNC_ID_PRESENTATION_QUEUE_CREATE);
+    GetMe(presentationQueueGetTime,VDP_FUNC_ID_PRESENTATION_QUEUE_GET_TIME);
+    GetMe(presentationQueueDisplay,VDP_FUNC_ID_PRESENTATION_QUEUE_DISPLAY);
 
+    GetMe(presentationQueueDisplayX11Create,VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_CREATE_X11);
+  
+    if(VDP_STATUS_OK!=funcs.presentationQueueDisplayX11Create(vdpDevice,x->window,&queueX11))
+    {
+        ADM_warning("Cannot create X11 Presentation Queue\n");
+        return false;
+    }
 
     const char *versionString=NULL;
     uint32_t version=0xff;
@@ -98,6 +126,7 @@
         ADM_info("[VDPAU] API : 0x%x, info : %s\n",version,versionString);
 
     coreVdpWorking=true;
+    myWindowInfo=*x;
     return true;
 }
 /**
@@ -107,24 +136,46 @@
 {
     return coreVdpWorking;
 }
-
+/**
+    \fn
+    \brief
+*/
 VdpStatus admVdpau::decoderCreate( VdpDecoderProfile profile,    uint32_t  width,uint32_t  height,
             uint32_t  max_references,VdpDecoder *      decoder)
 {
     return funcs.decoderCreate(vdpDevice,profile,width,height,max_references,decoder);
 }
+/**
+    \fn
+    \brief
+*/
 VdpStatus  admVdpau::decoderDestroy(VdpDecoder decoder)
 {
     return funcs.decoderDestroy(decoder);
 }
+/**
+    \fn
+    \brief
+*/
+
 VdpStatus  admVdpau::surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface)
 {
 return funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,width,height,surface);
 }
+/**
+    \fn
+    \brief
+*/
+
 VdpStatus  admVdpau::surfaceDestroy(VdpVideoSurface surface)
 {
     return funcs.destroySurface(surface);
 }
+/**
+    \fn
+    \brief
+*/
+
 VdpStatus  admVdpau::getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3])
 {
   return funcs.getDataSurface(
@@ -134,6 +185,11 @@
                 stride //destination_pitches
                 );
 }
+/**
+    \fn
+    \brief
+*/
+
 const char *admVdpau::getErrorString(VdpStatus er)
 {
     return funcs.getErrorString(er);
@@ -147,8 +203,85 @@
 {
     return funcs.decoderRender(decoder, target, (void * const *)info,bitstream_buffer_count, bitstream_buffers);
 }
-#else // Dummy when vdpau is not there...
+/**
+    \fn
+    \brief
+*/
 
+VdpStatus admVdpau::outputSurfaceCreate(
+    VdpRGBAFormat      rgba_format,
+    uint32_t           width,
+    uint32_t           height,
+    VdpOutputSurface * surface)
+{
+    return funcs.createOutputSurface(vdpDevice,rgba_format, width,height,surface);
+}
+/**
+    \fn
+    \brief
+*/
+
+VdpStatus admVdpau::outputSurfaceDestroy(    VdpOutputSurface surface)
+{
+    return funcs.destroyOutputSurface(surface);
+}
+/**
+    \fn
+    \brief
+*/
+
+VdpStatus admVdpau::outPutSurfacePutBitsYV12( VdpOutputSurface     surface,
+                        uint8_t *planes[3],
+                        uint32_t pitches[3])
+{
+    return funcs.putBitsYV12OutputSurface(surface,VDP_YCBCR_FORMAT_YV12,
+                                                       (void const * const *) planes,
+                                                        pitches,
+                                                        NULL,//VdpRect const *      destination_rect,
+                                                        NULL); //VdpCSCMatrix const * csc_matrix  );
+}
+/**
+    \fn
+    \brief
+*/
+
+VdpStatus admVdpau::presentationQueueCreate(VdpPresentationQueue *queue)
+{
+    return funcs.presentationQueueCreate(vdpDevice,queueX11,queue);
+
+}
+/**
+    \fn
+    \brief
+*/
+
+VdpStatus admVdpau::presentationQueueDestroy(VdpPresentationQueue queue)
+{
+    return funcs.presentationQueueDestroy(queue);
+}
+/**
+    \fn
+    \brief
+*/
+
+VdpStatus admVdpau::presentationQueueDisplay(VdpPresentationQueue queue,VdpOutputSurface outputSurface)
+{
+    VdpTime t;
+    VdpStatus r=funcs.presentationQueueGetTime(queue,&t);
+    if(VDP_STATUS_OK!=r)
+    {
+        ADM_warning("GetTime failed\n");
+        return r;
+    }
+    return funcs.presentationQueueDisplay(queue,outputSurface,0,0,t);
+}
+#else 
+//******************************************
+//******************************************
+// Dummy when vdpau is not there...
+// Dummy when vdpau is not there...
+//******************************************
+//******************************************
 static bool                  coreVdpWorking=false;
 bool admVdpau::init(GUI_WindowInfo *x)
 {
@@ -163,32 +296,66 @@
     ADM_warning("This binary has no VPDAU support\n");
     return coreVdpWorking;
 }
+/**
+    \fn
+    \brief
+*/
 
 VdpStatus admVdpau::decoderCreate( VdpDecoderProfile profile,    uint32_t  width,uint32_t  height,
             uint32_t  max_references,VdpDecoder *      decoder)
 {
     ADM_assert(0);
 }
+/**
+    \fn
+    \brief
+*/
+
 VdpStatus  admVdpau::decoderDestroy(VdpDecoder decoder)
 {
     ADM_assert(0);
 }
+/**
+    \fn
+    \brief
+*/
+
 VdpStatus  admVdpau::surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface)
 {
 ADM_assert(0);
 }
+/**
+    \fn
+    \brief
+*/
+
 VdpStatus  admVdpau::surfaceDestroy(VdpVideoSurface surface)
 {
     ADM_assert(0);
 }
+/**
+    \fn
+    \brief
+*/
+
 VdpStatus  admVdpau::getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3])
 {
   ADM_assert(0);
 }
+/**
+    \fn
+    \brief
+*/
+
 const char *admVdpau::getErrorString(VdpStatus er)
 {
 ADM_assert(0);
 }
+/**
+    \fn
+    \brief
+*/
+
 VdpStatus admVdpau::decoderRender(
     VdpDecoder                 decoder,
     VdpVideoSurface            target,
@@ -199,5 +366,56 @@
     ADM_assert(0);
 }
 
+/**
+    \fn
+    \brief
+*/
+
+VdpStatus admVdpau::outputSurfaceCreate(
+    VdpRGBAFormat      rgba_format,
+    uint32_t           width,
+    uint32_t           height,
+    VdpOutputSurface * surface)
+{
+    ADM_assert(0);
+}
+/**
+    \fn
+    \brief
+*/
+
+VdpStatus admVdpau::outputSurfaceDestroy(    VdpOutputSurface surface)
+{
+    ADM_assert(0);
+}
+VdpStatus admVdpau::outPutSurfacePutBitsYV12( VdpOutputSurface     surface,
+                        uint8_t *planes[3],
+                        uint32_t pitches[3])
+{
+   ADM_assert(0);
+}
+VdpStatus admVdpau::presentationQueueCreate(VdpPresentationQueue *queue)
+{
+    ADM_assert(0);
+}
+/**
+    \fn
+    \brief
+*/
+
+VdpStatus admVdpau::presentationQueueDestroy(VdpPresentationQueue queue)
+{
+    ADM_assert(0);
+}
+/**
+    \fn
+    \brief
+*/
+
+VdpStatus admVdpau::presentationQueueDisplay(VdpOutputSurface outputSurface)
+{
+    ADM_assert(0);
+}
+
 #endif
 // EOF



From mean at mail.berlios.de  Wed Jul 14 14:17:27 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 14:17:27 +0200
Subject: [Avidemux-svn-commit] r6454 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_commonUI avidemux/common/ADM_render
	avidemux_core/ADM_coreVdpau/include avidemux_core/ADM_coreVdpau/src
Message-ID: <20100714121728.1CD36480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 14:17:27 +0200 (Wed, 14 Jul 2010)
New Revision: 6454

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_prefs.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
Log:
[Vdpau] Vdpau render using only outputvideosurface

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_prefs.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_prefs.cpp	2010-07-14 12:17:26 UTC (rev 6453)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_prefs.cpp	2010-07-14 12:17:27 UTC (rev 6454)
@@ -231,6 +231,10 @@
 #ifdef USE_XV
                              ,{RENDER_XV,   QT_TR_NOOP("XVideo (best)"),NULL}
 #endif
+#ifdef USE_VDPAU
+                             ,{RENDER_VDPAU,   QT_TR_NOOP("VDPAU (best)"),NULL}
+#endif
+
 #ifdef USE_SDL
 #ifdef __WIN32
                              ,{RENDER_SDL,      QT_TR_NOOP("SDL (GDI)"),NULL}

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/CMakeLists.txt	2010-07-14 12:17:26 UTC (rev 6453)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/CMakeLists.txt	2010-07-14 12:17:27 UTC (rev 6454)
@@ -5,6 +5,7 @@
 GUI_simpleRender.cpp
 GUI_sdlRender.cpp
 GUI_xvRender.cpp
+GUI_vdpauRender.cpp
 )
 
 IF (APPLE)
@@ -22,4 +23,8 @@
        TARGET_LINK_LIBRARIES(${ADM_LIB}  ${SDL_LIBRARY})
 ENDIF (USE_SDL)
 
+IF (USE_VDPAU)
+       TARGET_LINK_LIBRARIES(${ADM_LIB}  ADM_coreVDPAU6)
+ENDIF (USE_VDPAU)
+
 ADM_INSTALL_LIB(${ADM_LIB})

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp	2010-07-14 12:17:26 UTC (rev 6453)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp	2010-07-14 12:17:27 UTC (rev 6454)
@@ -34,6 +34,10 @@
 #include "GUI_sdlRender.h"
 #endif
 
+#ifdef USE_VDPAU
+#include "GUI_vdpauRender.h"
+#endif
+
 #include "ADM_colorspace.h"
 #include "DIA_uiTypes.h"
 
@@ -239,6 +243,23 @@
         MUI_getWindowInfo(draw, &xinfo);
         switch(prefRenderer)
         {
+#if defined(USE_VDPAU)
+       case RENDER_VDPAU:
+                renderer=new vdpauRender();
+                r=renderer->init(&xinfo,phyW,phyH,lastZoom);
+                if(!r)
+                {
+                    delete renderer;
+                    renderer=NULL;
+                    ADM_warning("vdpau init failed\n");
+                }
+                else
+                {
+                    ADM_info("vdpau init ok\n");
+                }
+                break;
+#endif
+
 #if defined(USE_XV)
        case RENDER_XV:
                 renderer=new XvRender();

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h	2010-07-14 12:17:26 UTC (rev 6453)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h	2010-07-14 12:17:27 UTC (rev 6454)
@@ -63,6 +63,7 @@
 #ifdef USE_XV
         RENDER_XV=1,
 #endif
+
 #ifdef USE_SDL
         RENDER_SDL=2,
 
@@ -70,6 +71,11 @@
 		RENDER_DIRECTX=3,
 #endif
 #endif
+#ifdef USE_VDPAU
+        RENDER_VDPAU=4,
+
+#endif
+
         RENDER_LAST       
 
 

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp	2010-07-14 12:17:27 UTC (rev 6454)
@@ -0,0 +1,147 @@
+/***************************************************************************
+    \file GUI_vdpauRender.cpp
+    \author mean fixounet at free.fr (C) 2010
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#ifdef USE_VDPAU
+
+
+#include "GUI_render.h"
+
+#include "GUI_accelRender.h"
+#include "GUI_vdpauRender.h"
+#include "ADM_coreVdpau/include/ADM_coreVdpau.h"
+static VdpOutputSurface surface[2]={VDP_INVALID_HANDLE,VDP_INVALID_HANDLE};
+static int currentSurface=0;
+static VdpPresentationQueue queue=VDP_INVALID_HANDLE;
+//________________Wrapper around Xv_______________
+/**
+    \fn vdpauRender
+*/
+vdpauRender::vdpauRender( void )
+{
+
+}
+/**
+    \fn init
+*/
+bool vdpauRender::init( GUI_WindowInfo * window, uint32_t w, uint32_t h,renderZoom zoom)
+{
+	ADM_info("[Vdpau]Xv start\n");
+    info=*window;
+    if(admVdpau::isOperationnal()==false)
+    {
+        ADM_warning("[Vdpau] Not operationnal\n");
+    }
+    baseInit(w,h,zoom);
+    // Create couple of outputSurface
+    surface[0]=surface[1]=VDP_INVALID_HANDLE;
+    currentSurface=0;
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,w,h,&surface[0])) 
+    {
+        ADM_error("Cannot create outputSurface0\n");
+        goto badInit;
+    }
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,w,h,&surface[1])) 
+    {
+        ADM_error("Cannot create outputSurface1\n");
+        goto badInit;
+    }
+    if(VDP_STATUS_OK!=admVdpau::presentationQueueCreate(&queue)) 
+    {
+        ADM_error("Cannot create queue\n");
+        goto badInit;
+    } 
+
+    return true;
+badInit:
+    
+    return false;
+}
+/**
+    \fn cleanup
+*/
+bool vdpauRender::cleanup(void)
+{
+    if(surface[0]!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface[0]);
+    if(surface[1]!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface[1]);
+    if(queue!=VDP_INVALID_HANDLE)  admVdpau::presentationQueueDestroy(queue);
+    surface[0]=surface[1]=VDP_INVALID_HANDLE;
+    queue=VDP_INVALID_HANDLE;
+}
+/**
+    \fn stop
+*/
+bool vdpauRender::stop(void)
+{
+	 
+	 printf("[Vdpau]Xv end\n");
+     cleanup();
+	 return 1;
+}
+/**
+    \fn displayImage
+*/
+bool vdpauRender::displayImage(ADMImage *pic)
+{
+    // Blit pic into our next image
+    int next=currentSurface^1;
+    uint32_t pitches[3];
+    uint8_t *planes[3];
+    pic->GetPitches(pitches);
+    pic->GetReadPlanes(planes);
+    if(VDP_STATUS_OK!=admVdpau::outPutSurfacePutBitsYV12( 
+            surface[next],
+            planes,pitches))
+    {
+        ADM_warning("Cannot putbits\n");
+        return false;
+    }
+    // Display!
+    if(VDP_STATUS_OK!=admVdpau::presentationQueueDisplay(queue,surface[next]))
+    {
+        ADM_warning("Cannot display on presenation queue\n");
+        return false;
+    }
+    currentSurface=next;
+    return true;
+}
+
+/**
+    \fn changeZoom
+*/
+bool vdpauRender::changeZoom(renderZoom newZoom)
+{
+        ADM_info("[Vdpau]changing zoom, xv render.\n");
+        calcDisplayFromZoom(newZoom);
+        currentZoom=newZoom;
+        return true;
+}
+/**
+    \fn refresh
+*/
+bool vdpauRender::refresh(void)
+{
+    // since we dont know how to redraw without help, ask above
+    ADM_info("[Vdpau]refresh\n");
+    if(VDP_STATUS_OK!=admVdpau::presentationQueueDisplay(queue,surface[currentSurface]))
+    {
+        ADM_warning("[refresh]Cannot display on presenation queue\n");
+        return false;
+    }
+    renderCompleteRedrawRequest();
+    return true;
+}
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h	2010-07-14 12:17:27 UTC (rev 6454)
@@ -0,0 +1,42 @@
+
+/***************************************************************************
+    Class to handle Xv accelerated renderer
+    
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef T_VDPAURENDER_H
+#define T_VDPAURENDER_H
+/**
+    \fn class XvRender
+*/
+class vdpauRender: public VideoRenderBase
+{
+      protected:
+                            GUI_WindowInfo info;
+                        bool cleanup(void);
+      public:
+                             vdpauRender( void ) ;
+                             ~vdpauRender();
+              virtual	bool init( GUI_WindowInfo *  window, uint32_t w, uint32_t h,renderZoom zoom);
+              virtual	bool stop(void);				
+              virtual   bool displayImage(ADMImage *pic);
+              virtual   bool changeZoom(renderZoom newzoom);
+              virtual   bool refresh(void);
+              virtual   bool usingUIRedraw(void) {return false;};
+};
+#endif
+
+
+
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-14 12:17:26 UTC (rev 6453)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-14 12:17:27 UTC (rev 6454)
@@ -25,6 +25,7 @@
 {
 protected:
     static GUI_WindowInfo      myWindowInfo;
+    static bool queryYUVPutBitSupport(VdpRGBAFormat rgb,VdpYCbCrFormat yuv);
 public:
     static bool         init(GUI_WindowInfo *x);
     static const char  *getErrorString(VdpStatus er);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 12:17:26 UTC (rev 6453)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 12:17:27 UTC (rev 6454)
@@ -18,6 +18,11 @@
 
 #ifdef USE_VDPAU
 GUI_WindowInfo      admVdpau::myWindowInfo;
+
+#define CHECK(x) if(!isOperationnal()) {ADM_error("vdpau is not operationnal\n");return VDP_STATUS_ERROR;}\
+                 VdpStatus r=x;\
+                 if(VDP_STATUS_OK!=r) {ADM_warning(#x" call failed with error=%s\n",getErrorString(r));}return r;
+
 /**
     \fn VdpFunctions
     
@@ -32,10 +37,15 @@
     VdpVideoSurfaceDestroy  *destroySurface;
     VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
 
+
+ 
+
     VdpOutputSurfaceCreate  *createOutputSurface;
     VdpOutputSurfaceDestroy *destroyOutputSurface;
     VdpOutputSurfacePutBitsYCbCr *putBitsYV12OutputSurface;
+    VdpOutputSurfaceQueryPutBitsYCbCrCapabilities *putBitsCapsOutputSurface;
 
+
     VdpDecoderCreate        *decoderCreate;
     VdpDecoderDestroy       *decoderDestroy;
     VdpDecoderRender        *decoderRender;
@@ -105,6 +115,7 @@
     GetMe(createOutputSurface,VDP_FUNC_ID_OUTPUT_SURFACE_CREATE);
     GetMe(destroyOutputSurface,VDP_FUNC_ID_OUTPUT_SURFACE_DESTROY);
     GetMe(putBitsYV12OutputSurface,VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_Y_CB_CR);
+    GetMe(putBitsCapsOutputSurface,VDP_FUNC_ID_OUTPUT_SURFACE_QUERY_PUT_BITS_Y_CB_CR_CAPABILITIES);
 
     GetMe(presentationQueueDestroy,VDP_FUNC_ID_PRESENTATION_QUEUE_DESTROY);
     GetMe(presentationQueueCreate,VDP_FUNC_ID_PRESENTATION_QUEUE_CREATE);
@@ -127,9 +138,38 @@
 
     coreVdpWorking=true;
     myWindowInfo=*x;
+#if 0
+    ADM_info("Checking supported format\n");
+// See http://us.download.nvidia.com/XFree86/Linux-x86/195.36.24/README/vdpausupport.html#vdpau-implementation-limits-output-surface
+    ADM_info("FORMAT_B8G8R8A8->VDP_YCBCR_FORMAT_NV12 : %d\n",(int)queryYUVPutBitSupport(VDP_RGBA_FORMAT_B8G8R8A8,VDP_YCBCR_FORMAT_NV12));
+    ADM_info("FORMAT_B8G8R8A8->VDP_YCBCR_FORMAT_YV12 : %d\n",(int)queryYUVPutBitSupport(VDP_RGBA_FORMAT_B8G8R8A8,VDP_YCBCR_FORMAT_YV12));
+    ADM_info("FORMAT_B8G8R8A8->VDP_YCBCR_FORMAT_UYVY : %d\n",(int)queryYUVPutBitSupport(VDP_RGBA_FORMAT_B8G8R8A8,VDP_YCBCR_FORMAT_UYVY));
+    ADM_info("FORMAT_B8G8R8A8->VDP_YCBCR_FORMAT_Y8U8V8A8 : %d\n",(int)queryYUVPutBitSupport(VDP_RGBA_FORMAT_B8G8R8A8,VDP_YCBCR_FORMAT_Y8U8V8A8));
+
+    ADM_info("FORMAT_R8G8B8A8->VDP_YCBCR_FORMAT_NV12 : %d\n",(int)queryYUVPutBitSupport(VDP_RGBA_FORMAT_R8G8B8A8,VDP_YCBCR_FORMAT_NV12));
+    ADM_info("FORMAT_R8G8B8A8->VDP_YCBCR_FORMAT_YV12 : %d\n",(int)queryYUVPutBitSupport(VDP_RGBA_FORMAT_R8G8B8A8,VDP_YCBCR_FORMAT_YV12));
+    ADM_info("FORMAT_R8G8B8A8->VDP_YCBCR_FORMAT_UYVY : %d\n",(int)queryYUVPutBitSupport(VDP_RGBA_FORMAT_R8G8B8A8,VDP_YCBCR_FORMAT_UYVY));
+#endif
+
+    ADM_info("VDPAU renderer init ok.\n");
     return true;
 }
 /**
+    \fn queryYUVPutBitSupport
+*/
+bool admVdpau::queryYUVPutBitSupport(VdpRGBAFormat rgb,VdpYCbCrFormat yuv)
+{
+    VdpBool c;
+    if(VDP_STATUS_OK!=funcs.putBitsCapsOutputSurface(vdpDevice,rgb,yuv,&c))
+    {
+        ADM_warning("Query YCBCR put bits failed\n");
+        return false;
+    }
+    if(c) return true;
+    return false;
+}
+
+/**
     \fn isOperationnal
 */
 bool admVdpau::isOperationnal(void)
@@ -143,7 +183,7 @@
 VdpStatus admVdpau::decoderCreate( VdpDecoderProfile profile,    uint32_t  width,uint32_t  height,
             uint32_t  max_references,VdpDecoder *      decoder)
 {
-    return funcs.decoderCreate(vdpDevice,profile,width,height,max_references,decoder);
+    CHECK(funcs.decoderCreate(vdpDevice,profile,width,height,max_references,decoder));
 }
 /**
     \fn
@@ -151,7 +191,7 @@
 */
 VdpStatus  admVdpau::decoderDestroy(VdpDecoder decoder)
 {
-    return funcs.decoderDestroy(decoder);
+    CHECK(funcs.decoderDestroy(decoder));
 }
 /**
     \fn
@@ -160,7 +200,7 @@
 
 VdpStatus  admVdpau::surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface)
 {
-return funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,width,height,surface);
+    CHECK(funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,width,height,surface));
 }
 /**
     \fn
@@ -169,7 +209,7 @@
 
 VdpStatus  admVdpau::surfaceDestroy(VdpVideoSurface surface)
 {
-    return funcs.destroySurface(surface);
+    CHECK(funcs.destroySurface(surface));
 }
 /**
     \fn
@@ -178,12 +218,12 @@
 
 VdpStatus  admVdpau::getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3])
 {
-  return funcs.getDataSurface(
+  CHECK(funcs.getDataSurface(
                 surface,
                 VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
                 ( void * const *)planes, //void * const *   destination_data,
                 stride //destination_pitches
-                );
+                ));
 }
 /**
     \fn
@@ -201,7 +241,7 @@
     uint32_t                   bitstream_buffer_count,
     VdpBitstreamBuffer const * bitstream_buffers)
 {
-    return funcs.decoderRender(decoder, target, (void * const *)info,bitstream_buffer_count, bitstream_buffers);
+    CHECK(funcs.decoderRender(decoder, target, (void * const *)info,bitstream_buffer_count, bitstream_buffers));
 }
 /**
     \fn
@@ -214,7 +254,7 @@
     uint32_t           height,
     VdpOutputSurface * surface)
 {
-    return funcs.createOutputSurface(vdpDevice,rgba_format, width,height,surface);
+    CHECK(funcs.createOutputSurface(vdpDevice,rgba_format, width,height,surface));
 }
 /**
     \fn
@@ -223,7 +263,7 @@
 
 VdpStatus admVdpau::outputSurfaceDestroy(    VdpOutputSurface surface)
 {
-    return funcs.destroyOutputSurface(surface);
+    CHECK(funcs.destroyOutputSurface(surface));
 }
 /**
     \fn
@@ -234,11 +274,11 @@
                         uint8_t *planes[3],
                         uint32_t pitches[3])
 {
-    return funcs.putBitsYV12OutputSurface(surface,VDP_YCBCR_FORMAT_YV12,
+    CHECK(funcs.putBitsYV12OutputSurface(surface,VDP_YCBCR_FORMAT_YV12,
                                                        (void const * const *) planes,
                                                         pitches,
                                                         NULL,//VdpRect const *      destination_rect,
-                                                        NULL); //VdpCSCMatrix const * csc_matrix  );
+                                                        NULL)); //VdpCSCMatrix const * csc_matrix  );
 }
 /**
     \fn
@@ -247,7 +287,7 @@
 
 VdpStatus admVdpau::presentationQueueCreate(VdpPresentationQueue *queue)
 {
-    return funcs.presentationQueueCreate(vdpDevice,queueX11,queue);
+    CHECK(funcs.presentationQueueCreate(vdpDevice,queueX11,queue));
 
 }
 /**
@@ -257,7 +297,7 @@
 
 VdpStatus admVdpau::presentationQueueDestroy(VdpPresentationQueue queue)
 {
-    return funcs.presentationQueueDestroy(queue);
+    CHECK(funcs.presentationQueueDestroy(queue));
 }
 /**
     \fn
@@ -267,13 +307,13 @@
 VdpStatus admVdpau::presentationQueueDisplay(VdpPresentationQueue queue,VdpOutputSurface outputSurface)
 {
     VdpTime t;
-    VdpStatus r=funcs.presentationQueueGetTime(queue,&t);
-    if(VDP_STATUS_OK!=r)
+    VdpStatus z=funcs.presentationQueueGetTime(queue,&t);
+    if(VDP_STATUS_OK!=z)
     {
         ADM_warning("GetTime failed\n");
-        return r;
+        return z;
     }
-    return funcs.presentationQueueDisplay(queue,outputSurface,0,0,t);
+    CHECK(funcs.presentationQueueDisplay(queue,outputSurface,0,0,t));
 }
 #else 
 //******************************************



From mean at mail.berlios.de  Wed Jul 14 14:17:29 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 14:17:29 +0200
Subject: [Avidemux-svn-commit] r6455 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_render avidemux_core/ADM_coreVdpau/include
	avidemux_core/ADM_coreVdpau/src
Message-ID: <20100714121729.C74FF480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 14:17:29 +0200 (Wed, 14 Jul 2010)
New Revision: 6455

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
Log:
[Vdpau] First (simple) version of vdpau render

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp	2010-07-14 12:17:27 UTC (rev 6454)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp	2010-07-14 12:17:29 UTC (rev 6455)
@@ -22,8 +22,11 @@
 #include "GUI_accelRender.h"
 #include "GUI_vdpauRender.h"
 #include "ADM_coreVdpau/include/ADM_coreVdpau.h"
+
 static VdpOutputSurface surface[2]={VDP_INVALID_HANDLE,VDP_INVALID_HANDLE};
-static int currentSurface=0;
+static VdpVideoSurface  input=VDP_INVALID_HANDLE;
+static VdpVideoMixer    mixer=VDP_INVALID_HANDLE;
+static int              currentSurface=0;
 static VdpPresentationQueue queue=VDP_INVALID_HANDLE;
 //________________Wrapper around Xv_______________
 /**
@@ -48,6 +51,11 @@
     // Create couple of outputSurface
     surface[0]=surface[1]=VDP_INVALID_HANDLE;
     currentSurface=0;
+    if(VDP_STATUS_OK!=admVdpau::surfaceCreate(w,h,&input)) 
+    {
+        ADM_error("Cannot create input Surface\n");
+        goto badInit;
+    }
     if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,w,h,&surface[0])) 
     {
         ADM_error("Cannot create outputSurface0\n");
@@ -63,6 +71,11 @@
         ADM_error("Cannot create queue\n");
         goto badInit;
     } 
+    if(VDP_STATUS_OK!=admVdpau::mixerCreate(w,h,&mixer)) 
+    {
+        ADM_error("Cannot create mixer\n");
+        goto badInit;
+    } 
 
     return true;
 badInit:
@@ -74,11 +87,16 @@
 */
 bool vdpauRender::cleanup(void)
 {
+    if(input!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(input);
     if(surface[0]!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface[0]);
     if(surface[1]!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface[1]);
     if(queue!=VDP_INVALID_HANDLE)  admVdpau::presentationQueueDestroy(queue);
+    if(mixer!=VDP_INVALID_HANDLE) admVdpau::mixerDestroy(mixer);
     surface[0]=surface[1]=VDP_INVALID_HANDLE;
     queue=VDP_INVALID_HANDLE;
+    input=VDP_INVALID_HANDLE;
+    mixer=VDP_INVALID_HANDLE;
+    return true;
 }
 /**
     \fn stop
@@ -95,19 +113,30 @@
 */
 bool vdpauRender::displayImage(ADMImage *pic)
 {
-    // Blit pic into our next image
+    // Blit pic into our video Surface
     int next=currentSurface^1;
     uint32_t pitches[3];
     uint8_t *planes[3];
     pic->GetPitches(pitches);
     pic->GetReadPlanes(planes);
-    if(VDP_STATUS_OK!=admVdpau::outPutSurfacePutBitsYV12( 
-            surface[next],
+
+    // Put out stuff in input...
+
+    if(VDP_STATUS_OK!=admVdpau::surfacePutBits( 
+            input,
             planes,pitches))
     {
-        ADM_warning("Cannot putbits\n");
+        ADM_warning("video surface : Cannot putbits\n");
         return false;
     }
+
+    // Call mixer...
+    if(VDP_STATUS_OK!=admVdpau::mixerRender( mixer,input,surface[next], pic->_width,pic->_height))
+
+    {
+        ADM_warning("Cannot mixerRender\n");
+        return false;
+    }
     // Display!
     if(VDP_STATUS_OK!=admVdpau::presentationQueueDisplay(queue,surface[next]))
     {

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-14 12:17:27 UTC (rev 6454)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-14 12:17:29 UTC (rev 6455)
@@ -34,6 +34,7 @@
     static  VdpStatus   surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface);
     static  VdpStatus   surfaceDestroy(VdpVideoSurface surface);
     static  VdpStatus   getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3]);
+    static  VdpStatus   surfacePutBits(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3]);
     /* Decoder */
     static  VdpStatus   decoderCreate( VdpDecoderProfile profile,    uint32_t          width,    uint32_t          height,    uint32_t          max_references,       VdpDecoder *      decoder);
     static  VdpStatus   decoderDestroy(VdpDecoder decoder);
@@ -61,5 +62,9 @@
     static VdpStatus presentationQueueCreate(VdpPresentationQueue *queue);
     static VdpStatus presentationQueueDestroy(VdpPresentationQueue queue);
     static VdpStatus presentationQueueDisplay(VdpPresentationQueue queue,VdpOutputSurface outputSurface);
+    /* Mixer */
+    static VdpStatus mixerCreate(uint32_t width,uint32_t height, VdpVideoMixer *mixer);
+    static VdpStatus mixerDestroy(VdpVideoMixer mixer);
+    static VdpStatus mixerRender(VdpVideoMixer mixer,VdpVideoSurface sourceSurface,VdpOutputSurface targetOutputSurface, uint32_t targetWidth, uint32_t targetHeight );
 };
 #endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 12:17:27 UTC (rev 6454)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 12:17:29 UTC (rev 6455)
@@ -36,8 +36,8 @@
     VdpVideoSurfaceCreate   *createSurface;
     VdpVideoSurfaceDestroy  *destroySurface;
     VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
+    VdpVideoSurfacePutBitsYCbCr *surfacePutBitsYCbCr;
 
-
  
 
     VdpOutputSurfaceCreate  *createOutputSurface;
@@ -56,6 +56,10 @@
     VdpPresentationQueueGetTime       *presentationQueueGetTime;
     VdpPresentationQueueDisplay       *presentationQueueDisplay;
 
+    VdpVideoMixerCreate               *mixerCreate;
+    VdpVideoMixerDestroy              *mixerDestroy;
+    VdpVideoMixerRender               *mixerRender;
+
     VdpPresentationQueueTargetCreateX11 *presentationQueueDisplayX11Create;
 }VdpFunctions;
 
@@ -108,7 +112,9 @@
     GetMe(createSurface,VDP_FUNC_ID_VIDEO_SURFACE_CREATE);
     GetMe(destroySurface,VDP_FUNC_ID_VIDEO_SURFACE_DESTROY);
     GetMe(getDataSurface,VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR);
+    GetMe(surfacePutBitsYCbCr,VDP_FUNC_ID_VIDEO_SURFACE_PUT_BITS_Y_CB_CR);
 
+
     GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
     GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
     GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
@@ -123,7 +129,13 @@
     GetMe(presentationQueueDisplay,VDP_FUNC_ID_PRESENTATION_QUEUE_DISPLAY);
 
     GetMe(presentationQueueDisplayX11Create,VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_CREATE_X11);
+
+    GetMe(mixerCreate,VDP_FUNC_ID_VIDEO_MIXER_CREATE);
+    GetMe(mixerDestroy,VDP_FUNC_ID_VIDEO_MIXER_DESTROY);
+    GetMe(mixerRender,VDP_FUNC_ID_VIDEO_MIXER_RENDER);
   
+
+
     if(VDP_STATUS_OK!=funcs.presentationQueueDisplayX11Create(vdpDevice,x->window,&queueX11))
     {
         ADM_warning("Cannot create X11 Presentation Queue\n");
@@ -226,6 +238,18 @@
                 ));
 }
 /**
+    \fn 
+    \brief
+*/
+VdpStatus   admVdpau::surfacePutBits(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3])
+{
+    CHECK(funcs.surfacePutBitsYCbCr(surface,  
+                VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
+                ( void * const *)planes, //void * const *   destination_data,
+                stride //destination_pitches
+                ));
+}
+/**
     \fn
     \brief
 */
@@ -315,6 +339,76 @@
     }
     CHECK(funcs.presentationQueueDisplay(queue,outputSurface,0,0,t));
 }
+/**
+    \fn mixerCreate
+*/
+VdpStatus admVdpau::mixerCreate(uint32_t width,uint32_t height, VdpVideoMixer *mixer)
+{
+#define MIXER_NB_PARAM 3
+
+VdpVideoMixerParameter parameters[MIXER_NB_PARAM]=
+                                              {VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH,
+                                               VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT,
+                                               VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE};
+uint32_t color=VDP_CHROMA_TYPE_420;
+void    *values[MIXER_NB_PARAM]={&width,&height,&color};
+    
+    
+    VdpStatus e=funcs.mixerCreate(vdpDevice,
+                        0,NULL,
+                        MIXER_NB_PARAM,parameters,values,
+                        mixer);
+    if(VDP_STATUS_OK!=e)
+    {
+        
+        ADM_warning("MixerCreate  failed :%s\n",getErrorString(e));
+        
+    }
+    return e;
+}
+/**
+    \fn mixerDestroy
+*/
+
+VdpStatus admVdpau::mixerDestroy(VdpVideoMixer mixer)
+{
+    CHECK(funcs.mixerDestroy(mixer));
+}
+/**
+    \fn mixerRender
+*/
+
+VdpStatus admVdpau::mixerRender(VdpVideoMixer mixer,
+                                VdpVideoSurface sourceSurface,
+                                VdpOutputSurface targetOutputSurface, 
+                                uint32_t targetWidth, 
+                                uint32_t targetHeight )
+{
+const VdpVideoSurface listOfSurface[1]={sourceSurface};
+const VdpVideoSurface listOfInvalidSurface[1]={VDP_INVALID_HANDLE};
+      VdpStatus e=funcs.mixerRender(mixer,
+                VDP_INVALID_HANDLE,NULL,    // Background
+                VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
+                
+                0,            listOfInvalidSurface, // Past...
+                sourceSurface,                      // current
+                0,            listOfInvalidSurface, // Future
+                NULL,                               // source RECT
+                targetOutputSurface,
+                NULL,                               // dest Rec
+                NULL,                               // dest video Rec
+                0,NULL);                            // Layers
+                
+            
+  if(VDP_STATUS_OK!=e)
+    {
+        
+        ADM_warning("MixerCreate  failed :%s\n",getErrorString(e));
+        
+    }
+    return e;
+}
+
 #else 
 //******************************************
 //******************************************



From mean at mail.berlios.de  Wed Jul 14 14:17:31 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 14:17:31 +0200
Subject: [Avidemux-svn-commit] r6456 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render
Message-ID: <20100714121731.1BE02480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 14:17:30 +0200 (Wed, 14 Jul 2010)
New Revision: 6456

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h
Log:
[Render/Vdpau] Do hw resize by vdpau if needed

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp	2010-07-14 12:17:29 UTC (rev 6455)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp	2010-07-14 12:17:30 UTC (rev 6456)
@@ -1,6 +1,7 @@
 /***************************************************************************
     \file GUI_vdpauRender.cpp
     \author mean fixounet at free.fr (C) 2010
+    \brief  Use vdpau as renderer with hw rescaling.
 
  ***************************************************************************/
 
@@ -15,18 +16,16 @@
 
 #include "ADM_default.h"
 #ifdef USE_VDPAU
-
-
 #include "GUI_render.h"
 
 #include "GUI_accelRender.h"
 #include "GUI_vdpauRender.h"
 #include "ADM_coreVdpau/include/ADM_coreVdpau.h"
 
-static VdpOutputSurface surface[2]={VDP_INVALID_HANDLE,VDP_INVALID_HANDLE};
-static VdpVideoSurface  input=VDP_INVALID_HANDLE;
-static VdpVideoMixer    mixer=VDP_INVALID_HANDLE;
-static int              currentSurface=0;
+static VdpOutputSurface     surface[2]={VDP_INVALID_HANDLE,VDP_INVALID_HANDLE};
+static VdpVideoSurface      input=VDP_INVALID_HANDLE;
+static VdpVideoMixer        mixer=VDP_INVALID_HANDLE;
+static int                  currentSurface=0;
 static VdpPresentationQueue queue=VDP_INVALID_HANDLE;
 //________________Wrapper around Xv_______________
 /**
@@ -51,21 +50,15 @@
     // Create couple of outputSurface
     surface[0]=surface[1]=VDP_INVALID_HANDLE;
     currentSurface=0;
-    if(VDP_STATUS_OK!=admVdpau::surfaceCreate(w,h,&input)) 
+    if(!reallocOutputSurface(displayWidth,displayHeight))
     {
-        ADM_error("Cannot create input Surface\n");
         goto badInit;
     }
-    if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,w,h,&surface[0])) 
+    if(VDP_STATUS_OK!=admVdpau::surfaceCreate(w,h,&input)) 
     {
-        ADM_error("Cannot create outputSurface0\n");
+        ADM_error("Cannot create input Surface\n");
         goto badInit;
     }
-    if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,w,h,&surface[1])) 
-    {
-        ADM_error("Cannot create outputSurface1\n");
-        goto badInit;
-    }
     if(VDP_STATUS_OK!=admVdpau::presentationQueueCreate(&queue)) 
     {
         ADM_error("Cannot create queue\n");
@@ -83,6 +76,26 @@
     return false;
 }
 /**
+    \fn reallocOutputSurface
+*/
+bool vdpauRender::reallocOutputSurface(uint32_t tgtWidth, uint32_t tgtHeight)
+{
+    if(surface[0]!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface[0]);
+    if(surface[1]!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface[1]);
+    surface[0]=surface[1]=VDP_INVALID_HANDLE;
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,tgtWidth,tgtHeight,&surface[0])) 
+    {
+        ADM_error("Cannot create outputSurface0\n");
+        return false;
+    }
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,tgtWidth,tgtHeight,&surface[1])) 
+    {
+        ADM_error("Cannot create outputSurface1\n");
+        return false;
+    }
+    return true;
+}
+/**
     \fn cleanup
 */
 bool vdpauRender::cleanup(void)
@@ -104,7 +117,7 @@
 bool vdpauRender::stop(void)
 {
 	 
-	 printf("[Vdpau]Xv end\n");
+	 printf("[Vdpau]Vdpau render end\n");
      cleanup();
 	 return 1;
 }
@@ -126,7 +139,7 @@
             input,
             planes,pitches))
     {
-        ADM_warning("video surface : Cannot putbits\n");
+        ADM_warning("[Vdpau] video surface : Cannot putbits\n");
         return false;
     }
 
@@ -134,13 +147,13 @@
     if(VDP_STATUS_OK!=admVdpau::mixerRender( mixer,input,surface[next], pic->_width,pic->_height))
 
     {
-        ADM_warning("Cannot mixerRender\n");
+        ADM_warning("[Vdpau] Cannot mixerRender\n");
         return false;
     }
     // Display!
     if(VDP_STATUS_OK!=admVdpau::presentationQueueDisplay(queue,surface[next]))
     {
-        ADM_warning("Cannot display on presenation queue\n");
+        ADM_warning("[Vdpau] Cannot display on presenation queue\n");
         return false;
     }
     currentSurface=next;
@@ -152,9 +165,13 @@
 */
 bool vdpauRender::changeZoom(renderZoom newZoom)
 {
-        ADM_info("[Vdpau]changing zoom, xv render.\n");
+        ADM_info("[Vdpau]changing zoom.\n");
         calcDisplayFromZoom(newZoom);
         currentZoom=newZoom;
+        if(!reallocOutputSurface(displayWidth,displayHeight))
+        {
+            ADM_error("[VdpauRender] Change zoome failed\n");
+        }
         return true;
 }
 /**
@@ -163,10 +180,10 @@
 bool vdpauRender::refresh(void)
 {
     // since we dont know how to redraw without help, ask above
-    ADM_info("[Vdpau]refresh\n");
+    ADM_info("[Vdpau]Rrefresh\n");
     if(VDP_STATUS_OK!=admVdpau::presentationQueueDisplay(queue,surface[currentSurface]))
     {
-        ADM_warning("[refresh]Cannot display on presenation queue\n");
+        ADM_warning("[Vdpau] Refresh : Cannot display on presenation queue\n");
         return false;
     }
     renderCompleteRedrawRequest();

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h	2010-07-14 12:17:29 UTC (rev 6455)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h	2010-07-14 12:17:30 UTC (rev 6456)
@@ -25,6 +25,7 @@
       protected:
                             GUI_WindowInfo info;
                         bool cleanup(void);
+                        bool reallocOutputSurface(uint32_t tgtWidth, uint32_t tgtHeight);
       public:
                              vdpauRender( void ) ;
                              ~vdpauRender();



From mean at mail.berlios.de  Wed Jul 14 15:37:38 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 15:37:38 +0200
Subject: [Avidemux-svn-commit] r6457 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src
Message-ID: <20100714133738.C9BE2480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 15:37:38 +0200 (Wed, 14 Jul 2010)
New Revision: 6457

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt
Log:
[vdpau] Dont try to build coreVdpau if vdpau is not there

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt	2010-07-14 12:17:30 UTC (rev 6456)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt	2010-07-14 13:37:38 UTC (rev 6457)
@@ -4,8 +4,10 @@
 )	
 #*************************************************
 #*************************************************
+IF(USE_VDPAU)
 ADD_LIBRARY(ADM_coreVDPAU6 SHARED ${ADM_vdpau_SRCS})
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreVdpau/include)
 TARGET_LINK_LIBRARIES(ADM_coreVDPAU6 ADM_core6 ADM_coreUI6 )
+ENDIF(USE_VDPAU)
 
 ADM_INSTALL_LIB(ADM_coreVDPAU6)



From mean at mail.berlios.de  Wed Jul 14 15:42:55 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 15:42:55 +0200
Subject: [Avidemux-svn-commit] r6458 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src
Message-ID: <20100714134255.B888B480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 15:42:55 +0200 (Wed, 14 Jul 2010)
New Revision: 6458

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt
Log:
[vdpau] Finally, build an dummy vdpau to ease linking later

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 13:37:38 UTC (rev 6457)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 13:42:55 UTC (rev 6458)
@@ -430,126 +430,5 @@
     ADM_warning("This binary has no VPDAU support\n");
     return coreVdpWorking;
 }
-/**
-    \fn
-    \brief
-*/
-
-VdpStatus admVdpau::decoderCreate( VdpDecoderProfile profile,    uint32_t  width,uint32_t  height,
-            uint32_t  max_references,VdpDecoder *      decoder)
-{
-    ADM_assert(0);
-}
-/**
-    \fn
-    \brief
-*/
-
-VdpStatus  admVdpau::decoderDestroy(VdpDecoder decoder)
-{
-    ADM_assert(0);
-}
-/**
-    \fn
-    \brief
-*/
-
-VdpStatus  admVdpau::surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface)
-{
-ADM_assert(0);
-}
-/**
-    \fn
-    \brief
-*/
-
-VdpStatus  admVdpau::surfaceDestroy(VdpVideoSurface surface)
-{
-    ADM_assert(0);
-}
-/**
-    \fn
-    \brief
-*/
-
-VdpStatus  admVdpau::getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3])
-{
-  ADM_assert(0);
-}
-/**
-    \fn
-    \brief
-*/
-
-const char *admVdpau::getErrorString(VdpStatus er)
-{
-ADM_assert(0);
-}
-/**
-    \fn
-    \brief
-*/
-
-VdpStatus admVdpau::decoderRender(
-    VdpDecoder                 decoder,
-    VdpVideoSurface            target,
-    const void                 *info,
-    uint32_t                   bitstream_buffer_count,
-    VdpBitstreamBuffer const * bitstream_buffers)
-{
-    ADM_assert(0);
-}
-
-/**
-    \fn
-    \brief
-*/
-
-VdpStatus admVdpau::outputSurfaceCreate(
-    VdpRGBAFormat      rgba_format,
-    uint32_t           width,
-    uint32_t           height,
-    VdpOutputSurface * surface)
-{
-    ADM_assert(0);
-}
-/**
-    \fn
-    \brief
-*/
-
-VdpStatus admVdpau::outputSurfaceDestroy(    VdpOutputSurface surface)
-{
-    ADM_assert(0);
-}
-VdpStatus admVdpau::outPutSurfacePutBitsYV12( VdpOutputSurface     surface,
-                        uint8_t *planes[3],
-                        uint32_t pitches[3])
-{
-   ADM_assert(0);
-}
-VdpStatus admVdpau::presentationQueueCreate(VdpPresentationQueue *queue)
-{
-    ADM_assert(0);
-}
-/**
-    \fn
-    \brief
-*/
-
-VdpStatus admVdpau::presentationQueueDestroy(VdpPresentationQueue queue)
-{
-    ADM_assert(0);
-}
-/**
-    \fn
-    \brief
-*/
-
-VdpStatus admVdpau::presentationQueueDisplay(VdpOutputSurface outputSurface)
-{
-    ADM_assert(0);
-}
-
 #endif
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt	2010-07-14 13:37:38 UTC (rev 6457)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt	2010-07-14 13:42:55 UTC (rev 6458)
@@ -4,10 +4,7 @@
 )	
 #*************************************************
 #*************************************************
-IF(USE_VDPAU)
 ADD_LIBRARY(ADM_coreVDPAU6 SHARED ${ADM_vdpau_SRCS})
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreVdpau/include)
 TARGET_LINK_LIBRARIES(ADM_coreVDPAU6 ADM_core6 ADM_coreUI6 )
-ENDIF(USE_VDPAU)
-
 ADM_INSTALL_LIB(ADM_coreVDPAU6)



From mean at mail.berlios.de  Wed Jul 14 15:57:02 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 15:57:02 +0200
Subject: [Avidemux-svn-commit] r6459 -
	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces
Message-ID: <20100714135703.01403480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 15:57:02 +0200 (Wed, 14 Jul 2010)
New Revision: 6459

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/CMakeLists.txt
Log:
[Gtk] Remove ocr stuff

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/CMakeLists.txt	2010-07-14 13:42:55 UTC (rev 6458)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/CMakeLists.txt	2010-07-14 13:57:02 UTC (rev 6459)
@@ -9,7 +9,7 @@
 ADD_SUBDIRECTORY(ADM_dialog)
 ADD_SUBDIRECTORY(ADM_filters)
 ADD_SUBDIRECTORY(ADM_gui2)
-ADD_SUBDIRECTORY(ADM_ocr)
+#ADD_SUBDIRECTORY(ADM_ocr)
 ADD_SUBDIRECTORY(ADM_toolkit_gtk)
 ADD_SUBDIRECTORY(ADM_shell)
 ADD_SUBDIRECTORY(glade)



From mean at mail.berlios.de  Wed Jul 14 16:09:03 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 16:09:03 +0200
Subject: [Avidemux-svn-commit] r6460 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src
Message-ID: <20100714140903.4F9D7480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 16:09:03 +0200 (Wed, 14 Jul 2010)
New Revision: 6460

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
Log:
[vdpau] fix include when vdpau is not here

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 13:57:02 UTC (rev 6459)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 14:09:03 UTC (rev 6460)
@@ -13,10 +13,11 @@
  *                                                                         *
  ***************************************************************************/
 #include "ADM_default.h"
+#ifdef USE_VDPAU
 #include "../include/ADM_coreVdpau.h"
 #include "ADM_dynamicLoading.h"
 
-#ifdef USE_VDPAU
+
 GUI_WindowInfo      admVdpau::myWindowInfo;
 
 #define CHECK(x) if(!isOperationnal()) {ADM_error("vdpau is not operationnal\n");return VDP_STATUS_ERROR;}\



From mean at mail.berlios.de  Wed Jul 14 16:42:25 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 14 Jul 2010 16:42:25 +0200
Subject: [Avidemux-svn-commit] r6461 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau:
	include src
Message-ID: <20100714144225.2FACF480BDF@sheep.berlios.de>

Author: mean
Date: 2010-07-14 16:42:24 +0200 (Wed, 14 Jul 2010)
New Revision: 6461

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
Log:
[vdpau/render] Handle both vdpau present and not

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-14 14:09:03 UTC (rev 6460)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-14 14:42:24 UTC (rev 6461)
@@ -15,8 +15,12 @@
 
 #ifndef ADM_CORE_VDPAU_H
 #define ADM_CORE_VDPAU_H
+
+#ifdef USE_VDPAU
 #include "vdpau/vdpau_x11.h"
 #include "vdpau/vdpau.h"
+#endif 
+
 #include "ADM_windowInfo.h"
 /**
     \class admVdpau
@@ -25,12 +29,15 @@
 {
 protected:
     static GUI_WindowInfo      myWindowInfo;
+#ifdef USE_VDPAU
     static bool queryYUVPutBitSupport(VdpRGBAFormat rgb,VdpYCbCrFormat yuv);
+#endif
 public:
     static bool         init(GUI_WindowInfo *x);
-    static const char  *getErrorString(VdpStatus er);
     static bool         isOperationnal(void);
     /* Surface */
+#ifdef USE_VDPAU
+    static const char  *getErrorString(VdpStatus er);
     static  VdpStatus   surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface);
     static  VdpStatus   surfaceDestroy(VdpVideoSurface surface);
     static  VdpStatus   getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3]);
@@ -66,5 +73,6 @@
     static VdpStatus mixerCreate(uint32_t width,uint32_t height, VdpVideoMixer *mixer);
     static VdpStatus mixerDestroy(VdpVideoMixer mixer);
     static VdpStatus mixerRender(VdpVideoMixer mixer,VdpVideoSurface sourceSurface,VdpOutputSurface targetOutputSurface, uint32_t targetWidth, uint32_t targetHeight );
+#endif
 };
 #endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 14:09:03 UTC (rev 6460)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-14 14:42:24 UTC (rev 6461)
@@ -13,8 +13,8 @@
  *                                                                         *
  ***************************************************************************/
 #include "ADM_default.h"
+#include "../include/ADM_coreVdpau.h"
 #ifdef USE_VDPAU
-#include "../include/ADM_coreVdpau.h"
 #include "ADM_dynamicLoading.h"
 
 



From mean at mail.berlios.de  Thu Jul 15 20:10:21 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 15 Jul 2010 20:10:21 +0200
Subject: [Avidemux-svn-commit] r6462 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include
Message-ID: <20100715181021.60B15480C98@sheep.berlios.de>

Author: mean
Date: 2010-07-15 20:10:21 +0200 (Thu, 15 Jul 2010)
New Revision: 6462

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
Log:
[Image] Add writtable ref image

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2010-07-14 14:42:24 UTC (rev 6461)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2010-07-15 18:10:21 UTC (rev 6462)
@@ -147,6 +147,7 @@
 };
 /**
     \class ADMImageRef
+    \brief That image is a shell for another image. You cannot write to it!
 */
 class ADMImageRef: public ADMImage
 {
@@ -163,6 +164,17 @@
         virtual      bool           isWrittable(void);
         virtual      ADMImageRef    *castToRef(void) {return this;};
 };
+/**
+    \class ADMImageRefWrittable
+    \brief That image is a shell for another image. You can write to it!
+*/
+class ADMImageRefWrittable: public ADMImageRef
+{
+public:
+                 ADMImageRefWrittable(uint32_t w, uint32_t h) : ADMImageRef(w,h) {};
+    virtual      bool           isWrittable(void) {return true;}
+    virtual      uint8_t        *GetWritePtr(ADM_PLANE plane) {return GetReadPtr(plane);}
+};
 
 void drawString(ADMImage *dst, int x, int y, const char *s) ;
 



From mean at mail.berlios.de  Thu Jul 15 20:10:22 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 15 Jul 2010 20:10:22 +0200
Subject: [Avidemux-svn-commit] r6463 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	. addBorder
Message-ID: <20100715181022.88D4C480C98@sheep.berlios.de>

Author: mean
Date: 2010-07-15 20:10:22 +0200 (Thu, 15 Jul 2010)
New Revision: 6463

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder_desc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
Log:
[addBorder] Port filter

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-07-15 18:10:21 UTC (rev 6462)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-07-15 18:10:22 UTC (rev 6463)
@@ -6,3 +6,4 @@
 ADD_SUBDIRECTORY(mplayerDenoise3D)
 ADD_SUBDIRECTORY(printInfo)
 ADD_SUBDIRECTORY(vdpauFilters)
+ADD_SUBDIRECTORY(addBorder)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.cpp	2010-07-15 18:10:22 UTC (rev 6463)
@@ -0,0 +1,218 @@
+/***************************************************************************
+                          ADM_vidAddBorder.cpp  -  description
+                             -------------------
+    begin                : Sun Aug 11 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_vidAddBorder.h"
+#include "DIA_factory.h"
+#include "addBorder_desc.cpp"
+
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *addBorders::getConfiguration(void)
+{
+    static char conf[80];
+    conf[0]=0;
+    snprintf(conf,80,"Add Border : Left:%"LU" Right:%"LU" Top:%"LU" Bottom:%"LU" => %"LU"x%"LU"\n",
+                param.left,param.right,param.top,param.bottom,
+                info.width,info.height);
+    return conf;
+}
+/**
+    \fn ctor
+*/
+addBorders::addBorders( ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilter(in,setup)
+{	
+	 if(!setup || !ADM_paramLoad(setup,addBorder_param,&param))
+    {
+        // Default value
+        param.left=0;
+        param.right=0;
+        param.top=0;
+        param.bottom=0;
+        
+    }
+	info.width=in->getInfo()->width+param.left+param.right;
+    info.height=in->getInfo()->height+param.top+param.bottom;
+  	  	
+}
+/**
+    \fn dtor
+*/
+addBorders::~addBorders()
+{
+
+}
+
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         addBorders::getCoupledConf(CONFcouple **couples)
+{
+    return ADM_paramSave(couples, addBorder_param,&param);
+}
+/**
+
+*/
+bool addBorders::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    ADMImageRefWrittable ref(previousFilter->getInfo()->width,previousFilter->getInfo()->height);
+ 
+    uint32_t offset=param.top*image->GetPitch(PLANAR_Y);
+    ref._planes[0]=image->GetWritePtr(PLANAR_Y)+param.left+offset;
+
+
+    offset=(param.top>>1)*image->GetPitch(PLANAR_U);
+    ref._planes[1]=image->GetWritePtr(PLANAR_U)+(param.left>>1)+offset;
+
+    offset=(param.top>>1)*image->GetPitch(PLANAR_V);
+    ref._planes[2]=image->GetWritePtr(PLANAR_V)+(param.left>>1)+offset;
+
+    ref._planeStride[0]=info.width;
+    ref._planeStride[1]=info.width>>1;
+    ref._planeStride[2]=info.width>>1;
+    if(false==previousFilter->getNextFrame(fn,&ref))
+    {
+        ADM_warning("FlipFilter : Cannot get frame\n");
+        return false;
+    }
+    // Now do fill
+    return true;
+}
+
+#if 0
+		if(frame>=_info.nb_frames) 
+		{
+			printf("Filter : out of bound!\n");
+			return 0;
+		}
+	
+		ADM_assert(_param);									
+								
+			// read uncompressed frame
+       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+       		
+				// blacken screen
+				memset(YPLANE(data),16,_info.width*_info.height);
+				memset(UPLANE(data),128,(_info.width*_info.height)>>2);
+				memset(VPLANE(data),128,(_info.width*_info.height)>>2);
+
+				// do luma
+				uint8_t *src,*dest;
+       		uint32_t y,x,line,lineout;
+       		
+       		y=_in->getInfo()->height;
+       		x=_in->getInfo()->width;
+       		line=x;
+		lineout=_info.width;
+		
+		// copy Luma
+       		src=YPLANE(_uncompressed);
+       		dest=YPLANE(data)+_param->left+_info.width*_param->top;
+       		
+       		for(uint32_t k=y;k>0;k--)
+       		{
+       		 	    memcpy(dest,src,line);
+       		 	    src+=line;
+       		 	    dest+=lineout;
+       		}
+       		 
+		// U and V now
+		uint8_t *src_u,*src_v;
+		uint8_t *dst_u,*dst_v;
+
+       		src_u=UPLANE(_uncompressed);
+       		src_v=VPLANE(_uncompressed);
+       		line>>=1;
+       		lineout>>=1;       		       		 	
+		dst_u=UPLANE( data)+(_info.width*_param->top>>2)+
+						(_param->left>>1);;
+		dst_v= VPLANE( data)+(_info.width*_param->top>>2)+
+						(_param->left>>1);;
+
+       		 for(uint32_t k=y>>1;k>0;k--)
+       		 {
+       		 	memcpy(dst_u,src_u,line);
+       		 	memcpy(dst_v,src_v,line);
+
+       			src_u+=line;
+       			src_v+=line;
+
+       			dst_u+=lineout;
+       		    	dst_v+=lineout;
+
+       		 }
+       		  *len= _info.width*_info.height+(_info.width*_info.height>>1);
+		  data->copyInfo(_uncompressed);
+
+      return 1;
+}
+#endif
+/**
+    \fn configure
+*/
+bool addBorders::configure(void)
+{
+        uint32_t width,height;
+#define MAKEME(x) uint32_t x=param.x;
+        while(1)
+        {
+          MAKEME(left);
+          MAKEME(right);
+          MAKEME(top);
+          MAKEME(bottom);
+          
+          width=previousFilter->getInfo()->width;
+          height=previousFilter->getInfo()->height;
+          
+          diaElemUInteger dleft(&left,QT_TR_NOOP("_Left border:"),       0,width);
+          diaElemUInteger dright(&right,QT_TR_NOOP("_Right border:"),    0,width);
+          diaElemUInteger dtop(&(top),QT_TR_NOOP("_Top border:"),          0,height);
+          diaElemUInteger dbottom(&(bottom),QT_TR_NOOP("_Bottom border:"), 0,height);
+            
+          diaElem *elems[4]={&dleft,&dright,&dtop,&dbottom};
+          if(diaFactoryRun(QT_TR_NOOP("Add Borders"),4,elems))
+          {
+            if((left&1) || (right&1)|| (top&1) || (bottom&1))
+            {
+              GUI_Error_HIG(QT_TR_NOOP("Incorrect parameters"),QT_TR_NOOP("All parameters must be even and within range.")); 
+              continue;
+            }
+            else
+            {
+  #undef MAKEME
+  #define MAKEME(x) param.x=x;
+                MAKEME(left);
+                MAKEME(right);
+                MAKEME(top);
+                MAKEME(bottom);
+                info.width=width+left+right;
+                info.height=height+top+bottom;
+                return 1;
+            }
+          }
+          return 0;
+      }
+}
+
+
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.h	2010-07-15 18:10:22 UTC (rev 6463)
@@ -0,0 +1,47 @@
+/***************************************************************************
+                          ADM_vidAddBorder.h  -  description
+                             -------------------
+    begin                : Sun Aug 11 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef __ADDBORDER__
+#define     __ADDBORDER__
+
+#include "addBorder.h"
+class addBorders : public  ADM_coreVideoFilter
+{
+protected:
+        addBorder   param;
+public:
+                    addBorders(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                    ~addBorders();
+
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   addBorders,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_TRANSFORM,            // Category
+                        "addBorder",            // internal name (must be uniq!)
+                        "Add Borders",            // Display name
+                        "Add black boarders around the image." // Description
+                    );
+
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/CMakeLists.txt	2010-07-15 18:10:22 UTC (rev 6463)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_addBorders_SRCS ADM_vidAddBorder.cpp)
+
+ADD_VIDEO_FILTER(ADM_vf_addBorders ${ADM_vf_addBorders_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_addBorders)
+INSTALL_VIDEO_FILTER(ADM_vf_addBorders)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder.conf	2010-07-15 18:10:22 UTC (rev 6463)
@@ -0,0 +1,4 @@
+uint32_t:left; 
+uint32_t:right; 
+uint32_t:top; 
+uint32_t:bottom; 

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder.h	2010-07-15 18:10:22 UTC (rev 6463)
@@ -0,0 +1,11 @@
+// Automatically generated, do not edit!
+#ifndef ADM_addBorder_CONF_H
+#define ADM_addBorder_CONF_H
+typedef struct {
+   uint32_t left;
+   uint32_t right;
+   uint32_t top;
+   uint32_t bottom;
+}addBorder;
+#endif //addBorder
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/addBorder_desc.cpp	2010-07-15 18:10:22 UTC (rev 6463)
@@ -0,0 +1,8 @@
+// Automatically generated, do not edit!
+const ADM_paramList addBorder_param[]={
+ {"left",offsetof( addBorder,left),"uint32_t",ADM_param_uint32_t},
+ {"right",offsetof( addBorder,right),"uint32_t",ADM_param_uint32_t},
+ {"top",offsetof( addBorder,top),"uint32_t",ADM_param_uint32_t},
+ {"bottom",offsetof( addBorder,bottom),"uint32_t",ADM_param_uint32_t},
+{NULL,0,NULL}
+};



From mean at mail.berlios.de  Thu Jul 15 20:10:23 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 15 Jul 2010 20:10:23 +0200
Subject: [Avidemux-svn-commit] r6464 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder
Message-ID: <20100715181023.CD0A7480C98@sheep.berlios.de>

Author: mean
Date: 2010-07-15 20:10:23 +0200 (Thu, 15 Jul 2010)
New Revision: 6464

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.cpp
Log:
[AddBorder] Complete filter

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.cpp	2010-07-15 18:10:22 UTC (rev 6463)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/addBorder/ADM_vidAddBorder.cpp	2010-07-15 18:10:23 UTC (rev 6464)
@@ -69,8 +69,39 @@
 {
     return ADM_paramSave(couples, addBorder_param,&param);
 }
-/**
+#define Y_BLACK 16
+#define UV_BLACK 128
+static bool blackenHz(uint32_t w,uint32_t nbLine,uint8_t *ptr[3],uint32_t strides[3])
+{
+    // y
+    uint8_t *p=ptr[0];
+    uint32_t s=strides[0];
+    for(int y=0;y<nbLine;y++)
+    {
+        memset(p,Y_BLACK,w);
+        p+=s;
+    }
+    p=ptr[1];
+    s=strides[1];
+    nbLine/=2;
+    w/=2;
+    for(int y=0;y<nbLine;y++)
+    {
+        memset(p,UV_BLACK,w);
+        p+=s;
+    }
+    p=ptr[2];
+    s=strides[2];
+    for(int y=0;y<nbLine;y++)
+    {
+        memset(p,UV_BLACK,w);
+        p+=s;
+    }
+    return true;
+}
 
+/**
+    \fn getNextFrame
 */
 bool addBorders::getNextFrame(uint32_t *fn,ADMImage *image)
 {
@@ -95,77 +126,32 @@
         return false;
     }
     // Now do fill
+
+    // Top...
+    uint8_t *ptr[3];
+    uint32_t stride[3];
+    image->GetPitches(stride);
+    image->GetWritePlanes(ptr);
+    blackenHz(image->_width,param.top,ptr,stride);
+    // Left
+    blackenHz(param.left,image->_height,ptr,stride);
+    // Right
+    uint32_t pWidth=previousFilter->getInfo()->width;
+    ptr[0]+=param.left+pWidth;
+    ptr[1]+=(param.left+pWidth)/2;
+    ptr[2]+=(param.left+pWidth)/2;
+    blackenHz(param.right,image->_height,ptr,stride);
+    // Bottom
+    image->GetPitches(stride);
+    image->GetWritePlanes(ptr);
+    uint32_t offsetLine=previousFilter->getInfo()->height+param.top;
+    ptr[0]+=offsetLine*stride[0];
+    ptr[1]+=(offsetLine/2)*stride[1];
+    ptr[2]+=(offsetLine/2)*stride[2];
+    blackenHz(image->_width,param.bottom,ptr,stride);
     return true;
 }
 
-#if 0
-		if(frame>=_info.nb_frames) 
-		{
-			printf("Filter : out of bound!\n");
-			return 0;
-		}
-	
-		ADM_assert(_param);									
-								
-			// read uncompressed frame
-       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-       		
-				// blacken screen
-				memset(YPLANE(data),16,_info.width*_info.height);
-				memset(UPLANE(data),128,(_info.width*_info.height)>>2);
-				memset(VPLANE(data),128,(_info.width*_info.height)>>2);
-
-				// do luma
-				uint8_t *src,*dest;
-       		uint32_t y,x,line,lineout;
-       		
-       		y=_in->getInfo()->height;
-       		x=_in->getInfo()->width;
-       		line=x;
-		lineout=_info.width;
-		
-		// copy Luma
-       		src=YPLANE(_uncompressed);
-       		dest=YPLANE(data)+_param->left+_info.width*_param->top;
-       		
-       		for(uint32_t k=y;k>0;k--)
-       		{
-       		 	    memcpy(dest,src,line);
-       		 	    src+=line;
-       		 	    dest+=lineout;
-       		}
-       		 
-		// U and V now
-		uint8_t *src_u,*src_v;
-		uint8_t *dst_u,*dst_v;
-
-       		src_u=UPLANE(_uncompressed);
-       		src_v=VPLANE(_uncompressed);
-       		line>>=1;
-       		lineout>>=1;       		       		 	
-		dst_u=UPLANE( data)+(_info.width*_param->top>>2)+
-						(_param->left>>1);;
-		dst_v= VPLANE( data)+(_info.width*_param->top>>2)+
-						(_param->left>>1);;
-
-       		 for(uint32_t k=y>>1;k>0;k--)
-       		 {
-       		 	memcpy(dst_u,src_u,line);
-       		 	memcpy(dst_v,src_v,line);
-
-       			src_u+=line;
-       			src_v+=line;
-
-       			dst_u+=lineout;
-       		    	dst_v+=lineout;
-
-       		 }
-       		  *len= _info.width*_info.height+(_info.width*_info.height>>1);
-		  data->copyInfo(_uncompressed);
-
-      return 1;
-}
-#endif
 /**
     \fn configure
 */



From mean at mail.berlios.de  Sat Jul 17 08:58:09 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 17 Jul 2010 08:58:09 +0200
Subject: [Avidemux-svn-commit] r6465 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreVdpau/include avidemux_core/ADM_coreVdpau/src
	avidemux_plugins/ADM_videoFilters6
	avidemux_plugins/ADM_videoFilters6/swapUV
	avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20100717065810.0CAEF480AFB@sheep.berlios.de>

Author: mean
Date: 2010-07-17 08:58:09 +0200 (Sat, 17 Jul 2010)
New Revision: 6465

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/swapUV.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp
Log:
[VideoFilters] swapUV + simple vdpau (resize only)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-15 18:10:23 UTC (rev 6464)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-17 06:58:09 UTC (rev 6465)
@@ -65,6 +65,9 @@
             VdpOutputSurface     surface,
             uint8_t *planes[3],
             uint32_t pitches[3]);
+    // Warning only RGBA32 supported!
+    static VdpStatus outputSurfaceGetBitsNative(VdpOutputSurface     surface,  
+                        uint8_t *buffer, uint32_t w,uint32_t h);
     /* Presentation queue */
     static VdpStatus presentationQueueCreate(VdpPresentationQueue *queue);
     static VdpStatus presentationQueueDestroy(VdpPresentationQueue queue);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-15 18:10:23 UTC (rev 6464)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-17 06:58:09 UTC (rev 6465)
@@ -45,8 +45,8 @@
     VdpOutputSurfaceDestroy *destroyOutputSurface;
     VdpOutputSurfacePutBitsYCbCr *putBitsYV12OutputSurface;
     VdpOutputSurfaceQueryPutBitsYCbCrCapabilities *putBitsCapsOutputSurface;
+    VdpOutputSurfaceGetBitsNative                 *getBitsNativeOutputSurface;
 
-
     VdpDecoderCreate        *decoderCreate;
     VdpDecoderDestroy       *decoderDestroy;
     VdpDecoderRender        *decoderRender;
@@ -123,6 +123,7 @@
     GetMe(destroyOutputSurface,VDP_FUNC_ID_OUTPUT_SURFACE_DESTROY);
     GetMe(putBitsYV12OutputSurface,VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_Y_CB_CR);
     GetMe(putBitsCapsOutputSurface,VDP_FUNC_ID_OUTPUT_SURFACE_QUERY_PUT_BITS_Y_CB_CR_CAPABILITIES);
+    GetMe(getBitsNativeOutputSurface,VDP_FUNC_ID_OUTPUT_SURFACE_GET_BITS_NATIVE);
 
     GetMe(presentationQueueDestroy,VDP_FUNC_ID_PRESENTATION_QUEUE_DESTROY);
     GetMe(presentationQueueCreate,VDP_FUNC_ID_PRESENTATION_QUEUE_CREATE);
@@ -135,8 +136,8 @@
     GetMe(mixerDestroy,VDP_FUNC_ID_VIDEO_MIXER_DESTROY);
     GetMe(mixerRender,VDP_FUNC_ID_VIDEO_MIXER_RENDER);
   
+    
 
-
     if(VDP_STATUS_OK!=funcs.presentationQueueDisplayX11Create(vdpDevice,x->window,&queueX11))
     {
         ADM_warning("Cannot create X11 Presentation Queue\n");
@@ -306,6 +307,20 @@
                                                         NULL)); //VdpCSCMatrix const * csc_matrix  );
 }
 /**
+    \fn outputSurfaceGetBitsNative
+*/
+VdpStatus admVdpau::outputSurfaceGetBitsNative(VdpOutputSurface     surface, uint8_t *buffer, uint32_t w,uint32_t h)
+{
+    // Only support RGBA 32
+    uint32_t pitches[3]={w*4,0,0};
+    uint8_t *ptr[4]={buffer,NULL,NULL};
+    CHECK(funcs.getBitsNativeOutputSurface( surface,
+    NULL, // Rect
+     ( void * const *)ptr,
+    pitches));
+}
+
+/**
     \fn
     \brief
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-07-15 18:10:23 UTC (rev 6464)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-07-17 06:58:09 UTC (rev 6465)
@@ -7,3 +7,4 @@
 ADD_SUBDIRECTORY(printInfo)
 ADD_SUBDIRECTORY(vdpauFilters)
 ADD_SUBDIRECTORY(addBorder)
+ADD_SUBDIRECTORY(swapUV)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/CMakeLists.txt	2010-07-17 06:58:09 UTC (rev 6465)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_swapUV_SRCS swapUV.cpp)
+
+ADD_VIDEO_FILTER(ADM_vf_swapUV ${ADM_vf_swapUV_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_swapUV)
+INSTALL_VIDEO_FILTER(ADM_vf_swapUV)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/swapUV.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/swapUV.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/swapUV.cpp	2010-07-17 06:58:09 UTC (rev 6465)
@@ -0,0 +1,116 @@
+/***************************************************************************
+   \file swapUV.cpp
+    \author mean fixounet at free.fr (C) 2010
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "DIA_coreToolkit.h"
+class swapUv : public  ADM_coreVideoFilter
+{
+protected:
+        
+public:
+                    swapUv(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                    ~swapUv();
+
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   swapUv,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_COLORS,            // Category
+                        "swapUV",            // internal name (must be uniq!)
+                        "Swap UV",            // Display name
+                        "Swap the U and V planes." // Description
+                    );
+
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *swapUv::getConfiguration(void)
+{
+    static char conf[80];
+    conf[0]=0;
+    snprintf(conf,80,"swap UV");
+    return conf;
+}
+/**
+    \fn ctor
+*/
+swapUv::swapUv( ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilter(in,setup)
+{	
+	
+	
+}
+/**
+    \fn dtor
+*/
+swapUv::~swapUv()
+{
+
+}
+
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         swapUv::getCoupledConf(CONFcouple **couples)
+{
+    return true;
+}
+/**
+    \fn getNextFrame
+*/
+bool swapUv::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    ADMImageRefWrittable ref(info.width,info.height);
+ 
+    uint32_t strides[3];
+    uint8_t  *ptr[3];
+    image->GetWritePlanes(ptr);
+    image->GetPitches(strides);
+
+    ref._planes[0]=ptr[0];
+    ref._planeStride[0]=strides[0];
+
+    ref._planes[1]=ptr[2];
+    ref._planeStride[1]=strides[2];
+
+    ref._planes[2]=ptr[1];
+    ref._planeStride[2]=strides[2];
+
+
+    if(false==previousFilter->getNextFrame(fn,&ref))
+    {
+        ADM_warning("swapUV : Cannot get frame\n");
+        return false;
+    }
+   
+    return true;
+}
+
+/**
+    \fn configure
+*/
+bool swapUv::configure(void)
+{      
+          return true;     
+}
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2010-07-15 18:10:23 UTC (rev 6464)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2010-07-17 06:58:09 UTC (rev 6465)
@@ -2,7 +2,7 @@
     \brief VDPAU filters
     \author mean (C) 2010
     This is slow as we copy back and forth data to/from the video cards
-    Inspired a lot from mplayer vo_vdpau
+    Only 1 filter exposed at the moment : resize...
 
 */
 
@@ -12,6 +12,8 @@
 #include "DIA_factory.h"
 #include "vdpauFilter.h"
 #include "vdpauFilter_desc.cpp"
+#ifdef USE_VDPAU
+#include "ADM_coreVdpau/include/ADM_coreVdpau.h"
 //
 /**
     \class vdpauVideoFilter
@@ -19,8 +21,19 @@
 class vdpauVideoFilter : public  ADM_coreVideoFilter
 {
 protected:
-                    ADMImage    *original;
+                    ADMColorScalerSimple *scaler;
+                    bool passThrough;
+                    bool setupVdpau(void);
+                    bool cleanupVdpau(void);
+
+                    uint8_t   *tempBuffer;
+                    ADMImage *original;
                     vdpauFilter configuration;
+                    VdpOutputSurface     surface;
+                    VdpVideoSurface      input;
+                    VdpVideoMixer        mixer;
+
+
 public:
                     vdpauVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
                     ~vdpauVideoFilter();
@@ -34,42 +47,101 @@
 // Add the hook to make it valid plugin
 DECLARE_VIDEO_FILTER(   vdpauVideoFilter,   // Class
                         1,0,0,              // Version
-                        ADM_UI_GTK+ADM_UI_QT4,         // We need a display for VDPAU; so no cli...
+                        ADM_UI_GTK+ADM_UI_QT4,     // We need a display for VDPAU; so no cli...
                         VF_INTERLACING,            // Category
                         "vdpau",            // internal name (must be uniq!)
                         "vdpau",            // Display name
-                        "vdpau, vdpau filters, SLOW." // Description
+                        "vdpau, vdpau filters." // Description
                     );
 
 //
-static void filter_plane(int mode, uint8_t *dst, int dst_stride, const uint8_t *prev0, const uint8_t *cur0, const uint8_t *next0, int refs, int w, int h, int parity, int tff, int mmx);
+/**
+    \fn resetVdpau
+*/
+bool vdpauVideoFilter::setupVdpau(void)
+{
+    scaler=NULL;
+    if(!admVdpau::isOperationnal())
+    {
+        ADM_warning("Vdpau not operationnal\n");
+        return false;
+    }
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,
+                        info.width,info.height,&surface)) 
+    {
+        ADM_error("Cannot create outputSurface0\n");
+        return false;
+    }
+   if(VDP_STATUS_OK!=admVdpau::surfaceCreate(   previousFilter->getInfo()->width,
+                                                previousFilter->getInfo()->height,&input)) 
+    {
+        ADM_error("Cannot create input Surface\n");
+        goto badInit;
+    }
+    if(VDP_STATUS_OK!=admVdpau::mixerCreate(previousFilter->getInfo()->width,
+                                            previousFilter->getInfo()->height,&mixer)) 
+    {
+        ADM_error("Cannot create mixer\n");
+        goto badInit;
+    } 
+    tempBuffer=new uint8_t[info.width*info.height*4];
+    scaler=new ADMColorScalerSimple( info.width,info.height, ADM_COLOR_BGR32A,ADM_COLOR_YV12);
+    return true;
+badInit:
+    cleanupVdpau();
+    passThrough=true;
+    return false;
+}
+/**
+    \fn cleanupVdpau
+*/
+bool vdpauVideoFilter::cleanupVdpau(void)
+{
+    if(input!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(input);
+    if(surface!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface);
+    if(mixer!=VDP_INVALID_HANDLE) admVdpau::mixerDestroy(mixer);
+    surface=VDP_INVALID_HANDLE;
+    input=VDP_INVALID_HANDLE;
+    mixer=VDP_INVALID_HANDLE;
+    if(tempBuffer) delete [] tempBuffer;
+    tempBuffer=NULL;
+    if(scaler) delete scaler;
+    scaler=NULL;
+}
 
-
 /**
     \fn constructor
 */
 vdpauVideoFilter::vdpauVideoFilter(ADM_coreVideoFilter *in, CONFcouple *setup): ADM_coreVideoFilter(in,setup)
 {
-    original=new ADMImageDefault(in->getInfo()->width,in->getInfo()->height);
+    input=VDP_INVALID_HANDLE;
+    mixer=VDP_INVALID_HANDLE;
+    surface=VDP_INVALID_HANDLE;
     if(!setup || !ADM_paramLoad(setup,vdpauFilter_param,&configuration))
     {
         // Default value
-        configuration.mode=0;
-        configuration.order=1;
+        configuration.resizeToggle=false;
+        configuration.deinterlace=false;
+        configuration.targetWidth=info.width;
+        configuration.targetHeight=info.height;
     }
-    vidCache = new VideoCache (10, in);
+    vidCache = new VideoCache (5, in);
+    original=new ADMImageDefault(previousFilter->getInfo()->width,previousFilter->getInfo()->height);
     myName="vdpau";
+    tempBuffer=NULL;
+    passThrough=!setupVdpau();
+    
+    
 }
 /**
     \fn destructor
 */
 vdpauVideoFilter::~vdpauVideoFilter()
 {
-        delete  original;
-        original=NULL;
-       
+        delete original;
         delete vidCache;
         vidCache = NULL;
+        cleanupVdpau();
 }
 /**
     \fn updateInfo
@@ -77,24 +149,28 @@
 bool vdpauVideoFilter::configure( void) 
 {
     
-     diaMenuEntry tMode[]={
-                             {0,      QT_TR_NOOP("Temporal & spatial check"),NULL},
-                             {1,   QT_TR_NOOP("Bob, temporal & spatial check"),NULL},
-                             {2,      QT_TR_NOOP("Skip spatial temporal check"),NULL},
-                             {3,  QT_TR_NOOP("Bob, skip spatial temporal check"),NULL}
-          };
-     diaMenuEntry tOrder[]={
-                             {0,      QT_TR_NOOP("Bottom field first"),NULL},
-                             {1,   QT_TR_NOOP("Top field first"),NULL}
-          };
+     uint32_t resize=configuration.resizeToggle;
+     uint32_t deinterlace=configuration.deinterlace;
   
-     diaElemMenu mMode(&(configuration.mode),   QT_TR_NOOP("_Mode:"), 4,tMode);
-     diaElemMenu morder(&(configuration.order),   QT_TR_NOOP("_Order:"), 2,tOrder);
+     diaElemToggle resizeT(&(resize),   QT_TR_NOOP("Resize:"));
+     diaElemToggle deinterlaceT(&(deinterlace),   QT_TR_NOOP("Deinterlace:"));
      
-     diaElem *elems[]={&mMode,&morder};
+     diaElemUInteger  tWidth(&(configuration.targetWidth),QT_TR_NOOP("Width :"),16,2048);
+     diaElemUInteger  tHeight(&(configuration.targetHeight),QT_TR_NOOP("Height :"),16,2048);
      
+     diaElem *elems[]={&resizeT,&deinterlaceT,&tWidth,&tHeight};
+     
      if(diaFactoryRun(QT_TR_NOOP("vdpau"),sizeof(elems)/sizeof(diaElem *),elems))
      {
+         configuration.resizeToggle=resize;
+         configuration.deinterlace=deinterlace;
+         if(resize)
+         {
+                info.width=configuration.targetWidth;
+                info.height=configuration.targetHeight;
+         }
+        cleanupVdpau();
+        passThrough=!setupVdpau();
         return 1;
      }
      return 0;
@@ -114,9 +190,24 @@
 const char *vdpauVideoFilter::getConfiguration(void)
 {
     static char conf[80];
-    conf[0]=0;
-    snprintf(conf,80,"vdpau : mode=%d, order=%d\n",
-                (int)configuration.mode, (int)configuration.order);
+    char conf2[80];
+    conf2[0]=0;
+    sprintf(conf,"vdpau:");
+    if(configuration.resizeToggle)
+    {
+        sprintf(conf2,"%d x %d -> %d x %d",
+                        previousFilter->getInfo()->width, 
+                        previousFilter->getInfo()->height,
+                        info.width,info.height);
+        strcat(conf,conf2);
+    }
+    if(configuration.deinterlace)
+    {
+        sprintf(conf2," deinterlace");
+        strcat(conf,conf2);
+
+    }
+    conf[79]=0;
     return conf;
 }
 
@@ -126,9 +217,59 @@
 */
 bool vdpauVideoFilter::getNextFrame(uint32_t *fn,ADMImage *image)
 {
+    // 1- Get image...
+      if(passThrough) return previousFilter->getNextFrame(fn,image);
+    // 
+     if(false==previousFilter->getNextFrame(fn,original)) return false;
+     // Blit our image to surface
+    uint32_t pitches[3];
+    uint8_t *planes[3];
+    original->GetPitches(pitches);
+    original->GetReadPlanes(planes);
 
-        
-      return false;
+    // Put out stuff in input...
+
+    if(VDP_STATUS_OK!=admVdpau::surfacePutBits( 
+            input,
+            planes,pitches))
+    {
+        ADM_warning("[Vdpau] video surface : Cannot putbits\n");
+        return false;
+    }
+
+    // Call mixer...
+    if(VDP_STATUS_OK!=admVdpau::mixerRender( mixer,input,surface, info.width,info.height))
+
+    {
+        ADM_warning("[Vdpau] Cannot mixerRender\n");
+        return false;
+    }
+    // Now get our image back from surface...
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(surface,tempBuffer, info.width,info.height))
+    {
+        ADM_warning("[Vdpau] Cannot copy back data from output surface\n");
+        return false;
+    }
+    // Convert from VDP_RGBA_FORMAT_B8G8R8A8 to YV12
+    uint32_t sourceStride[3]={info.width*4,0,0};
+    uint8_t  *sourceData[3]={tempBuffer,NULL,NULL};
+    uint32_t destStride[3];
+    uint8_t  *destData[3];
+
+    image->GetPitches(destStride);
+    image->GetWritePlanes(destData);
+
+    // Invert U&V
+    uint32_t ts;
+    uint8_t  *td;
+
+    ts=destStride[2];destStride[2]=destStride[1];destStride[1]=ts;
+    td=destData[2];destData[2]=destData[1];destData[1]=td;
+
+    scaler->convertPlanes(  sourceStride,destStride,     
+                            sourceData,destData);
+      return true;
 }
+#endif
 //****************
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf	2010-07-15 18:10:23 UTC (rev 6464)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf	2010-07-17 06:58:09 UTC (rev 6465)
@@ -1,2 +1,4 @@
-uint32_t:mode
-uint32_t:order
+bool:resizeToggle;
+uint32_t:targetWidth;
+uint32_t:targetHeight;
+bool:deinterlace;
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h	2010-07-15 18:10:23 UTC (rev 6464)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h	2010-07-17 06:58:09 UTC (rev 6465)
@@ -2,8 +2,10 @@
 #ifndef ADM_vdpauFilter_CONF_H
 #define ADM_vdpauFilter_CONF_H
 typedef struct {
-   uint32_t mode;
-   uint32_t order;
+   bool resizeToggle;
+   uint32_t targetWidth;
+   uint32_t targetHeight;
+   bool deinterlace;
 }vdpauFilter;
 #endif //vdpauFilter
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp	2010-07-15 18:10:23 UTC (rev 6464)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp	2010-07-17 06:58:09 UTC (rev 6465)
@@ -1,6 +1,8 @@
 // Automatically generated, do not edit!
 const ADM_paramList vdpauFilter_param[]={
- {"mode",offsetof( vdpauFilter,mode),"uint32_t",ADM_param_uint32_t},
- {"order",offsetof( vdpauFilter,order),"uint32_t",ADM_param_uint32_t},
+ {"resizeToggle",offsetof( vdpauFilter,resizeToggle),"bool",ADM_param_bool},
+ {"targetWidth",offsetof( vdpauFilter,targetWidth),"uint32_t",ADM_param_uint32_t},
+ {"targetHeight",offsetof( vdpauFilter,targetHeight),"uint32_t",ADM_param_uint32_t},
+ {"deinterlace",offsetof( vdpauFilter,deinterlace),"bool",ADM_param_bool},
 {NULL,0,NULL}
 };



From mean at mail.berlios.de  Sat Jul 17 19:05:31 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 17 Jul 2010 19:05:31 +0200
Subject: [Avidemux-svn-commit] r6466 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreVdpau/include avidemux_core/ADM_coreVdpau/src
	avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20100717170531.8458F480BC1@sheep.berlios.de>

Author: mean
Date: 2010-07-17 19:05:31 +0200 (Sat, 17 Jul 2010)
New Revision: 6466

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
Log:
[Vdpau] More functions exposed through coreVdpau, non working resize+deinterlace filter

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-17 06:58:09 UTC (rev 6465)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-17 17:05:31 UTC (rev 6466)
@@ -30,7 +30,9 @@
 protected:
     static GUI_WindowInfo      myWindowInfo;
 #ifdef USE_VDPAU
-    static bool queryYUVPutBitSupport(VdpRGBAFormat rgb,VdpYCbCrFormat yuv);
+    static bool         queryYUVPutBitSupport(VdpRGBAFormat rgb,VdpYCbCrFormat yuv);
+    static VdpStatus    mixerEnableFeature( VdpVideoMixer mixer,uint32_t nbFeature,VdpVideoMixerFeature *feature,VdpBool *enabledFeature);
+    static bool         mixerFeatureSupported(VdpVideoMixerFeature attribute);
 #endif
 public:
     static bool         init(GUI_WindowInfo *x);
@@ -73,9 +75,13 @@
     static VdpStatus presentationQueueDestroy(VdpPresentationQueue queue);
     static VdpStatus presentationQueueDisplay(VdpPresentationQueue queue,VdpOutputSurface outputSurface);
     /* Mixer */
-    static VdpStatus mixerCreate(uint32_t width,uint32_t height, VdpVideoMixer *mixer);
+    static VdpStatus mixerCreate(uint32_t width,uint32_t height, VdpVideoMixer *mixer,bool deinterlace=false);
     static VdpStatus mixerDestroy(VdpVideoMixer mixer);
     static VdpStatus mixerRender(VdpVideoMixer mixer,VdpVideoSurface sourceSurface,VdpOutputSurface targetOutputSurface, uint32_t targetWidth, uint32_t targetHeight );
+    static VdpStatus mixerRenderWithPastAndFuture(VdpVideoMixer mixer,
+                                VdpVideoSurface sourceSurface[3], // Past present future
+                                VdpOutputSurface targetOutputSurface,uint32_t targetWidth, uint32_t targetHeight );
+
 #endif
 };
 #endif
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h	2010-07-17 17:05:31 UTC (rev 6466)
@@ -0,0 +1,76 @@
+/**
+
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_CORE_VDPAU_INTERNAL_H
+#define ADM_CORE_VDPAU_INTERNAL_H
+
+/**
+    \fn VdpFunctions
+    
+*/
+typedef struct 
+{
+    VdpGetErrorString       *getErrorString;
+    VdpGetApiVersion        *getApiVersion;
+    VdpGetInformationString *getInformationString;
+
+    VdpVideoSurfaceCreate   *createSurface;
+    VdpVideoSurfaceDestroy  *destroySurface;
+    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
+    VdpVideoSurfacePutBitsYCbCr *surfacePutBitsYCbCr;
+
+ 
+
+    VdpOutputSurfaceCreate  *createOutputSurface;
+    VdpOutputSurfaceDestroy *destroyOutputSurface;
+    VdpOutputSurfacePutBitsYCbCr *putBitsYV12OutputSurface;
+    VdpOutputSurfaceQueryPutBitsYCbCrCapabilities *putBitsCapsOutputSurface;
+    VdpOutputSurfaceGetBitsNative                 *getBitsNativeOutputSurface;
+
+    VdpDecoderCreate        *decoderCreate;
+    VdpDecoderDestroy       *decoderDestroy;
+    VdpDecoderRender        *decoderRender;
+
+
+    VdpPresentationQueueTargetDestroy *presentationQueueDestroy;
+    VdpPresentationQueueCreate        *presentationQueueCreate;
+    VdpPresentationQueueGetTime       *presentationQueueGetTime;
+    VdpPresentationQueueDisplay       *presentationQueueDisplay;
+
+    VdpVideoMixerCreate               *mixerCreate;
+    VdpVideoMixerDestroy              *mixerDestroy;
+    VdpVideoMixerRender               *mixerRender;
+    VdpVideoMixerSetFeatureEnables    *mixerEnableFeatures;
+    VdpVideoMixerQueryFeatureSupport  *mixerQueryFeatureSupported;
+
+    VdpPresentationQueueTargetCreateX11 *presentationQueueDisplayX11Create;
+}VdpFunctions;
+
+namespace ADM_coreVdpau
+{
+ extern VdpFunctions          funcs;
+ extern VdpDevice             vdpDevice;
+}
+
+#define CHECK(x) if(!isOperationnal()) {ADM_error("vdpau is not operationnal\n");return VDP_STATUS_ERROR;}\
+                 VdpStatus r=x;\
+                 if(VDP_STATUS_OK!=r) {ADM_warning(#x" call failed with error=%s\n",getErrorString(r));}return r;
+
+#define CHECKBOOL(x) if(!isOperationnal())\
+                    {ADM_error("vdpau is not operationnal\n");return false;}\
+                 VdpStatus r=x;\
+                 if(VDP_STATUS_OK!=r)  \
+                    {\
+                    ADM_warning(#x" call failed with error=%s\n",getErrorString(r));\
+                    return false;};
+
+#endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-17 06:58:09 UTC (rev 6465)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-17 17:05:31 UTC (rev 6466)
@@ -15,59 +15,20 @@
 #include "ADM_default.h"
 #include "../include/ADM_coreVdpau.h"
 #ifdef USE_VDPAU
+#include "../include/ADM_coreVdpauInternal.h"
 #include "ADM_dynamicLoading.h"
 
 
 GUI_WindowInfo      admVdpau::myWindowInfo;
 
-#define CHECK(x) if(!isOperationnal()) {ADM_error("vdpau is not operationnal\n");return VDP_STATUS_ERROR;}\
-                 VdpStatus r=x;\
-                 if(VDP_STATUS_OK!=r) {ADM_warning(#x" call failed with error=%s\n",getErrorString(r));}return r;
-
-/**
-    \fn VdpFunctions
-    
-*/
-typedef struct 
+namespace ADM_coreVdpau
 {
-    VdpGetErrorString       *getErrorString;
-    VdpGetApiVersion        *getApiVersion;
-    VdpGetInformationString *getInformationString;
+ VdpFunctions          funcs;
+ VdpDevice             vdpDevice;
+}
 
-    VdpVideoSurfaceCreate   *createSurface;
-    VdpVideoSurfaceDestroy  *destroySurface;
-    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
-    VdpVideoSurfacePutBitsYCbCr *surfacePutBitsYCbCr;
-
- 
-
-    VdpOutputSurfaceCreate  *createOutputSurface;
-    VdpOutputSurfaceDestroy *destroyOutputSurface;
-    VdpOutputSurfacePutBitsYCbCr *putBitsYV12OutputSurface;
-    VdpOutputSurfaceQueryPutBitsYCbCrCapabilities *putBitsCapsOutputSurface;
-    VdpOutputSurfaceGetBitsNative                 *getBitsNativeOutputSurface;
-
-    VdpDecoderCreate        *decoderCreate;
-    VdpDecoderDestroy       *decoderDestroy;
-    VdpDecoderRender        *decoderRender;
-
-
-    VdpPresentationQueueTargetDestroy *presentationQueueDestroy;
-    VdpPresentationQueueCreate        *presentationQueueCreate;
-    VdpPresentationQueueGetTime       *presentationQueueGetTime;
-    VdpPresentationQueueDisplay       *presentationQueueDisplay;
-
-    VdpVideoMixerCreate               *mixerCreate;
-    VdpVideoMixerDestroy              *mixerDestroy;
-    VdpVideoMixerRender               *mixerRender;
-
-    VdpPresentationQueueTargetCreateX11 *presentationQueueDisplayX11Create;
-}VdpFunctions;
-
-static VdpFunctions          funcs;
 static ADM_LibWrapper        vdpauDynaLoader;
 static VdpDeviceCreateX11    *ADM_createVdpX11;
-static VdpDevice             vdpDevice;
 static VdpGetProcAddress     *vdpProcAddress;
 static bool                  coreVdpWorking=false;
 static VdpPresentationQueueTarget  queueX11;
@@ -78,7 +39,7 @@
 static void *getFunc(uint32_t id)
 {
     void *f;
-    if(VDP_STATUS_OK!=vdpProcAddress(vdpDevice,id,&f)) return NULL;
+    if(VDP_STATUS_OK!=vdpProcAddress(ADM_coreVdpau::vdpDevice,id,&f)) return NULL;
     return (void *)f;
 }
 
@@ -88,7 +49,7 @@
 */
 bool admVdpau::init(GUI_WindowInfo *x)
 {
-    memset(&funcs,0,sizeof(funcs));
+    memset(&ADM_coreVdpau::funcs,0,sizeof(ADM_coreVdpau::funcs));
     if(false==vdpauDynaLoader.loadLibrary("/usr/lib/libvdpau.so"))
     {
         ADM_info("Cannot load libvdpau.so\n");
@@ -99,12 +60,12 @@
 
     //    
     // try to create....
-    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)x->display,0,&vdpDevice,&vdpProcAddress))
+    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)x->display,0,&ADM_coreVdpau::vdpDevice,&vdpProcAddress))
     {
         return false;
     }
     // Now that we have the vdpProcAddress, time to get the functions....
-#define GetMe(fun,id)         funcs.fun= (typeof(funcs.fun))getFunc(id);ADM_assert(funcs.fun); 
+#define GetMe(fun,id)         ADM_coreVdpau::funcs.fun= (typeof(ADM_coreVdpau::funcs.fun))getFunc(id);ADM_assert(ADM_coreVdpau::funcs.fun); 
         
     GetMe(getErrorString,VDP_FUNC_ID_GET_ERROR_STRING);
     GetMe(getApiVersion,VDP_FUNC_ID_GET_API_VERSION);
@@ -135,10 +96,10 @@
     GetMe(mixerCreate,VDP_FUNC_ID_VIDEO_MIXER_CREATE);
     GetMe(mixerDestroy,VDP_FUNC_ID_VIDEO_MIXER_DESTROY);
     GetMe(mixerRender,VDP_FUNC_ID_VIDEO_MIXER_RENDER);
-  
-    
+    GetMe(mixerEnableFeatures,VDP_FUNC_ID_VIDEO_MIXER_SET_FEATURE_ENABLES);
+    GetMe(mixerQueryFeatureSupported,VDP_FUNC_ID_VIDEO_MIXER_QUERY_FEATURE_SUPPORT);
 
-    if(VDP_STATUS_OK!=funcs.presentationQueueDisplayX11Create(vdpDevice,x->window,&queueX11))
+    if(VDP_STATUS_OK!=ADM_coreVdpau::funcs.presentationQueueDisplayX11Create(ADM_coreVdpau::vdpDevice,x->window,&queueX11))
     {
         ADM_warning("Cannot create X11 Presentation Queue\n");
         return false;
@@ -146,8 +107,8 @@
 
     const char *versionString=NULL;
     uint32_t version=0xff;
-        funcs.getInformationString(&versionString);
-        funcs.getApiVersion(&version);
+        ADM_coreVdpau::funcs.getInformationString(&versionString);
+        ADM_coreVdpau::funcs.getApiVersion(&version);
         ADM_info("[VDPAU] API : 0x%x, info : %s\n",version,versionString);
 
     coreVdpWorking=true;
@@ -164,6 +125,13 @@
     ADM_info("FORMAT_R8G8B8A8->VDP_YCBCR_FORMAT_YV12 : %d\n",(int)queryYUVPutBitSupport(VDP_RGBA_FORMAT_R8G8B8A8,VDP_YCBCR_FORMAT_YV12));
     ADM_info("FORMAT_R8G8B8A8->VDP_YCBCR_FORMAT_UYVY : %d\n",(int)queryYUVPutBitSupport(VDP_RGBA_FORMAT_R8G8B8A8,VDP_YCBCR_FORMAT_UYVY));
 #endif
+    ADM_info("Vdpau supports VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL : %d\n",(int)mixerFeatureSupported(VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL));
+    ADM_info("Vdpau supports VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL         : %d\n",(int)mixerFeatureSupported(VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL));
+    ADM_info("Vdpau supports VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L5      : %d\n",(int)mixerFeatureSupported(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L5));
+    ADM_info("Vdpau supports VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L3      : %d\n",(int)mixerFeatureSupported(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L3));
+    ADM_info("Vdpau supports VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L1      : %d\n",(int)mixerFeatureSupported(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L1));
+    ADM_info("Vdpau supports VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION              : %d\n",(int)mixerFeatureSupported(VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION));
+    ADM_info("Vdpau supports VDP_VIDEO_MIXER_FEATURE_INVERSE_TELECINE             : %d\n",(int)mixerFeatureSupported(VDP_VIDEO_MIXER_FEATURE_INVERSE_TELECINE));
 
     ADM_info("VDPAU renderer init ok.\n");
     return true;
@@ -174,7 +142,7 @@
 bool admVdpau::queryYUVPutBitSupport(VdpRGBAFormat rgb,VdpYCbCrFormat yuv)
 {
     VdpBool c;
-    if(VDP_STATUS_OK!=funcs.putBitsCapsOutputSurface(vdpDevice,rgb,yuv,&c))
+    if(VDP_STATUS_OK!=ADM_coreVdpau::funcs.putBitsCapsOutputSurface(ADM_coreVdpau::vdpDevice,rgb,yuv,&c))
     {
         ADM_warning("Query YCBCR put bits failed\n");
         return false;
@@ -197,7 +165,7 @@
 VdpStatus admVdpau::decoderCreate( VdpDecoderProfile profile,    uint32_t  width,uint32_t  height,
             uint32_t  max_references,VdpDecoder *      decoder)
 {
-    CHECK(funcs.decoderCreate(vdpDevice,profile,width,height,max_references,decoder));
+    CHECK(ADM_coreVdpau::funcs.decoderCreate(ADM_coreVdpau::vdpDevice,profile,width,height,max_references,decoder));
 }
 /**
     \fn
@@ -205,7 +173,7 @@
 */
 VdpStatus  admVdpau::decoderDestroy(VdpDecoder decoder)
 {
-    CHECK(funcs.decoderDestroy(decoder));
+    CHECK(ADM_coreVdpau::funcs.decoderDestroy(decoder));
 }
 /**
     \fn
@@ -214,7 +182,7 @@
 
 VdpStatus  admVdpau::surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface)
 {
-    CHECK(funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,width,height,surface));
+    CHECK(ADM_coreVdpau::funcs.createSurface(ADM_coreVdpau::vdpDevice,VDP_CHROMA_TYPE_420,width,height,surface));
 }
 /**
     \fn
@@ -223,7 +191,7 @@
 
 VdpStatus  admVdpau::surfaceDestroy(VdpVideoSurface surface)
 {
-    CHECK(funcs.destroySurface(surface));
+    CHECK(ADM_coreVdpau::funcs.destroySurface(surface));
 }
 /**
     \fn
@@ -232,7 +200,7 @@
 
 VdpStatus  admVdpau::getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3])
 {
-  CHECK(funcs.getDataSurface(
+  CHECK(ADM_coreVdpau::funcs.getDataSurface(
                 surface,
                 VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
                 ( void * const *)planes, //void * const *   destination_data,
@@ -245,7 +213,7 @@
 */
 VdpStatus   admVdpau::surfacePutBits(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3])
 {
-    CHECK(funcs.surfacePutBitsYCbCr(surface,  
+    CHECK(ADM_coreVdpau::funcs.surfacePutBitsYCbCr(surface,  
                 VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
                 ( void * const *)planes, //void * const *   destination_data,
                 stride //destination_pitches
@@ -258,7 +226,7 @@
 
 const char *admVdpau::getErrorString(VdpStatus er)
 {
-    return funcs.getErrorString(er);
+    return ADM_coreVdpau::funcs.getErrorString(er);
 }
 VdpStatus admVdpau::decoderRender(
     VdpDecoder                 decoder,
@@ -267,7 +235,7 @@
     uint32_t                   bitstream_buffer_count,
     VdpBitstreamBuffer const * bitstream_buffers)
 {
-    CHECK(funcs.decoderRender(decoder, target, (void * const *)info,bitstream_buffer_count, bitstream_buffers));
+    CHECK(ADM_coreVdpau::funcs.decoderRender(decoder, target, (void * const *)info,bitstream_buffer_count, bitstream_buffers));
 }
 /**
     \fn
@@ -280,7 +248,7 @@
     uint32_t           height,
     VdpOutputSurface * surface)
 {
-    CHECK(funcs.createOutputSurface(vdpDevice,rgba_format, width,height,surface));
+    CHECK(ADM_coreVdpau::funcs.createOutputSurface(ADM_coreVdpau::vdpDevice,rgba_format, width,height,surface));
 }
 /**
     \fn
@@ -289,7 +257,7 @@
 
 VdpStatus admVdpau::outputSurfaceDestroy(    VdpOutputSurface surface)
 {
-    CHECK(funcs.destroyOutputSurface(surface));
+    CHECK(ADM_coreVdpau::funcs.destroyOutputSurface(surface));
 }
 /**
     \fn
@@ -300,7 +268,7 @@
                         uint8_t *planes[3],
                         uint32_t pitches[3])
 {
-    CHECK(funcs.putBitsYV12OutputSurface(surface,VDP_YCBCR_FORMAT_YV12,
+    CHECK(ADM_coreVdpau::funcs.putBitsYV12OutputSurface(surface,VDP_YCBCR_FORMAT_YV12,
                                                        (void const * const *) planes,
                                                         pitches,
                                                         NULL,//VdpRect const *      destination_rect,
@@ -314,7 +282,7 @@
     // Only support RGBA 32
     uint32_t pitches[3]={w*4,0,0};
     uint8_t *ptr[4]={buffer,NULL,NULL};
-    CHECK(funcs.getBitsNativeOutputSurface( surface,
+    CHECK(ADM_coreVdpau::funcs.getBitsNativeOutputSurface( surface,
     NULL, // Rect
      ( void * const *)ptr,
     pitches));
@@ -327,7 +295,7 @@
 
 VdpStatus admVdpau::presentationQueueCreate(VdpPresentationQueue *queue)
 {
-    CHECK(funcs.presentationQueueCreate(vdpDevice,queueX11,queue));
+    CHECK(ADM_coreVdpau::funcs.presentationQueueCreate(ADM_coreVdpau::vdpDevice,queueX11,queue));
 
 }
 /**
@@ -337,94 +305,25 @@
 
 VdpStatus admVdpau::presentationQueueDestroy(VdpPresentationQueue queue)
 {
-    CHECK(funcs.presentationQueueDestroy(queue));
+    CHECK(ADM_coreVdpau::funcs.presentationQueueDestroy(queue));
 }
 /**
-    \fn
-    \brief
+    \fn    presentationQueueDisplay
+    \brief display immediately the outputsurface
 */
 
 VdpStatus admVdpau::presentationQueueDisplay(VdpPresentationQueue queue,VdpOutputSurface outputSurface)
 {
     VdpTime t;
-    VdpStatus z=funcs.presentationQueueGetTime(queue,&t);
+    VdpStatus z=ADM_coreVdpau::funcs.presentationQueueGetTime(queue,&t);
     if(VDP_STATUS_OK!=z)
     {
         ADM_warning("GetTime failed\n");
         return z;
     }
-    CHECK(funcs.presentationQueueDisplay(queue,outputSurface,0,0,t));
+    CHECK(ADM_coreVdpau::funcs.presentationQueueDisplay(queue,outputSurface,0,0,t));
 }
-/**
-    \fn mixerCreate
-*/
-VdpStatus admVdpau::mixerCreate(uint32_t width,uint32_t height, VdpVideoMixer *mixer)
-{
-#define MIXER_NB_PARAM 3
 
-VdpVideoMixerParameter parameters[MIXER_NB_PARAM]=
-                                              {VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH,
-                                               VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT,
-                                               VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE};
-uint32_t color=VDP_CHROMA_TYPE_420;
-void    *values[MIXER_NB_PARAM]={&width,&height,&color};
-    
-    
-    VdpStatus e=funcs.mixerCreate(vdpDevice,
-                        0,NULL,
-                        MIXER_NB_PARAM,parameters,values,
-                        mixer);
-    if(VDP_STATUS_OK!=e)
-    {
-        
-        ADM_warning("MixerCreate  failed :%s\n",getErrorString(e));
-        
-    }
-    return e;
-}
-/**
-    \fn mixerDestroy
-*/
-
-VdpStatus admVdpau::mixerDestroy(VdpVideoMixer mixer)
-{
-    CHECK(funcs.mixerDestroy(mixer));
-}
-/**
-    \fn mixerRender
-*/
-
-VdpStatus admVdpau::mixerRender(VdpVideoMixer mixer,
-                                VdpVideoSurface sourceSurface,
-                                VdpOutputSurface targetOutputSurface, 
-                                uint32_t targetWidth, 
-                                uint32_t targetHeight )
-{
-const VdpVideoSurface listOfSurface[1]={sourceSurface};
-const VdpVideoSurface listOfInvalidSurface[1]={VDP_INVALID_HANDLE};
-      VdpStatus e=funcs.mixerRender(mixer,
-                VDP_INVALID_HANDLE,NULL,    // Background
-                VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
-                
-                0,            listOfInvalidSurface, // Past...
-                sourceSurface,                      // current
-                0,            listOfInvalidSurface, // Future
-                NULL,                               // source RECT
-                targetOutputSurface,
-                NULL,                               // dest Rec
-                NULL,                               // dest video Rec
-                0,NULL);                            // Layers
-                
-            
-  if(VDP_STATUS_OK!=e)
-    {
-        
-        ADM_warning("MixerCreate  failed :%s\n",getErrorString(e));
-        
-    }
-    return e;
-}
-
 #else 
 //******************************************
 //******************************************

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp	2010-07-17 17:05:31 UTC (rev 6466)
@@ -0,0 +1,161 @@
+/***************************************************************************
+    \file             : ADM_coreVdpau.cpp
+    \brief            : Wrapper around vdpau functions
+    \author           : (C) 2010 by mean fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "../include/ADM_coreVdpau.h"
+
+#ifdef USE_VDPAU
+#include "../include/ADM_coreVdpauInternal.h"
+#include "ADM_dynamicLoading.h"
+
+
+//GUI_WindowInfo      admVdpau::myWindowInfo;
+
+/**
+    \fn    mixerEnableFeature
+    \brief enable mixer feature
+*/
+
+VdpStatus admVdpau::mixerEnableFeature( VdpVideoMixer mixer,uint32_t nbFeature,VdpVideoMixerFeature *feature,VdpBool *enabledFeature)
+{
+    CHECK(ADM_coreVdpau::funcs.mixerEnableFeatures(mixer,nbFeature,feature,enabledFeature));
+}
+/**
+    \fn mixerFeatureSupported
+    \brief Check a feature is supported by VDPAU
+*/
+bool admVdpau::mixerFeatureSupported(VdpVideoMixerFeature attribute)
+{
+VdpBool supported=VDP_TRUE;
+    CHECKBOOL(ADM_coreVdpau::funcs.mixerQueryFeatureSupported(ADM_coreVdpau::vdpDevice,attribute,&supported));
+    if(VDP_TRUE==supported) return true;
+    return false;
+}
+/**
+    \fn mixerCreate
+*/
+VdpStatus admVdpau::mixerCreate(uint32_t width,uint32_t height, VdpVideoMixer *mixer,bool deinterlace)
+{
+#define MIXER_NB_PARAM 3
+#define MIXER_NB_FEATURE_MAX 7
+
+VdpVideoMixerParameter parameters[MIXER_NB_PARAM]=
+                                              {VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH,
+                                               VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT,
+                                               VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE
+                                               };
+ VdpVideoMixerFeature features[MIXER_NB_FEATURE_MAX];
+ VdpBool              enabledFeatures[MIXER_NB_FEATURE_MAX]={VDP_TRUE,VDP_TRUE,VDP_TRUE,VDP_TRUE,VDP_TRUE,VDP_TRUE,VDP_TRUE};
+
+uint32_t color=VDP_CHROMA_TYPE_420;
+void    *values[MIXER_NB_PARAM]={&width,&height,&color};
+    int nbFeature=0;
+    //features[nbFeature++]=VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L5;
+    if(deinterlace)
+    {
+        features[nbFeature++]=VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL;
+    }
+    
+    int nbParam=MIXER_NB_PARAM;
+    
+    VdpStatus e=ADM_coreVdpau::funcs.mixerCreate(ADM_coreVdpau::vdpDevice,
+                        nbFeature,features,
+                        nbParam,parameters,values,
+                        mixer);
+    if(VDP_STATUS_OK!=e)
+    {
+        ADM_warning("MixerCreate  failed :%s\n",getErrorString(e));
+        
+    }else   
+    {
+        mixerEnableFeature(*mixer, nbFeature, features, enabledFeatures);
+    }
+    return e;
+}
+/**
+    \fn mixerDestroy
+*/
+
+VdpStatus admVdpau::mixerDestroy(VdpVideoMixer mixer)
+{
+    CHECK(ADM_coreVdpau::funcs.mixerDestroy(mixer));
+}
+/**
+    \fn mixerRender
+*/
+
+VdpStatus admVdpau::mixerRender(VdpVideoMixer mixer,
+                                VdpVideoSurface sourceSurface,
+                                VdpOutputSurface targetOutputSurface, 
+                                uint32_t targetWidth, 
+                                uint32_t targetHeight )
+{
+const VdpVideoSurface listOfSurface[1]={sourceSurface};
+const VdpVideoSurface listOfInvalidSurface[1]={VDP_INVALID_HANDLE};
+      VdpStatus e=ADM_coreVdpau::funcs.mixerRender(mixer,
+                VDP_INVALID_HANDLE,NULL,    // Background
+                VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
+                
+                0,            listOfInvalidSurface, // Past...
+                sourceSurface,                      // current
+                0,            listOfInvalidSurface, // Future
+                NULL,                               // source RECT
+                targetOutputSurface,
+                NULL,                               // dest Rec
+                NULL,                               // dest video Rec
+                0,NULL);                            // Layers
+                
+            
+  if(VDP_STATUS_OK!=e)
+    {
+        
+        ADM_warning("MixerCreate  failed :%s\n",getErrorString(e));
+        
+    }
+    return e;
+}
+
+/**
+    \fn mixerRenderWithPastAndFuture
+*/
+
+VdpStatus admVdpau::mixerRenderWithPastAndFuture(VdpVideoMixer mixer,
+                                VdpVideoSurface sourceSurface[3], // Past present future
+                                VdpOutputSurface targetOutputSurface, 
+                                uint32_t targetWidth, 
+                                uint32_t targetHeight )
+{
+      VdpStatus e=ADM_coreVdpau::funcs.mixerRender(mixer,
+                VDP_INVALID_HANDLE,NULL,    // Background
+                VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
+                1,            sourceSurface+0, // Past...
+                              sourceSurface[1], // current
+                1,            sourceSurface+2, // Future
+                NULL,                               // source RECT
+                targetOutputSurface,
+                NULL,                               // dest Rec
+                NULL,                               // dest video Rec
+                0,NULL);                            // Layers
+                
+            
+  if(VDP_STATUS_OK!=e)
+    {
+        
+        ADM_warning("MixerCreate  failed :%s\n",getErrorString(e));
+        
+    }
+    return e;
+}
+#endif
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt	2010-07-17 06:58:09 UTC (rev 6465)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/CMakeLists.txt	2010-07-17 17:05:31 UTC (rev 6466)
@@ -1,6 +1,7 @@
 
 SET(ADM_vdpau_SRCS
 ADM_coreVdpau.cpp
+ADM_coreVdpauMixer.cpp
 )	
 #*************************************************
 #*************************************************

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2010-07-17 06:58:09 UTC (rev 6465)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2010-07-17 17:05:31 UTC (rev 6466)
@@ -66,6 +66,9 @@
         ADM_warning("Vdpau not operationnal\n");
         return false;
     }
+    // check if we have something to do
+    if(!configuration.deinterlace && !configuration.resizeToggle)
+        return false;
     if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,
                         info.width,info.height,&surface)) 
     {
@@ -79,7 +82,7 @@
         goto badInit;
     }
     if(VDP_STATUS_OK!=admVdpau::mixerCreate(previousFilter->getInfo()->width,
-                                            previousFilter->getInfo()->height,&mixer)) 
+                                            previousFilter->getInfo()->height,&mixer,configuration.deinterlace)) 
     {
         ADM_error("Cannot create mixer\n");
         goto badInit;
@@ -238,7 +241,8 @@
     }
 
     // Call mixer...
-    if(VDP_STATUS_OK!=admVdpau::mixerRender( mixer,input,surface, info.width,info.height))
+    VdpOutputSurface surfaces[3]={surface,surface,surface};
+    if(VDP_STATUS_OK!=admVdpau::mixerRenderWithPastAndFuture( mixer,input,surfaces, info.width,info.height))
 
     {
         ADM_warning("[Vdpau] Cannot mixerRender\n");



From mean at mail.berlios.de  Sun Jul 18 18:41:59 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 18 Jul 2010 18:41:59 +0200
Subject: [Avidemux-svn-commit] r6467 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_asf
Message-ID: <20100718164159.26E18480BC1@sheep.berlios.de>

Author: mean
Date: 2010-07-18 18:41:58 +0200 (Sun, 18 Jul 2010)
New Revision: 6467

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_asf/ADM_asf.cpp
Log:
[Asf] Read extradata refs #100

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_asf/ADM_asf.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_asf/ADM_asf.cpp	2010-07-17 17:05:31 UTC (rev 6466)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_asf/ADM_asf.cpp	2010-07-18 16:41:58 UTC (rev 6467)
@@ -569,8 +569,14 @@
               return 0; 
             }
             printBih(&_video_bih);
+#if 1
+            if(_video_bih.biSize>sizeof(ADM_BITMAPINFOHEADER))
+                {
+                        x=_video_bih.biSize;            
+#else
             if(x>sizeof(ADM_BITMAPINFOHEADER))
             {
+#endif
               _extraDataLen=x-sizeof(ADM_BITMAPINFOHEADER);
               _extraData=new uint8_t[_extraDataLen];
               s->read(_extraData,_extraDataLen);



From mean at mail.berlios.de  Tue Jul 20 20:56:48 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 20 Jul 2010 20:56:48 +0200
Subject: [Avidemux-svn-commit] r6468 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf
Message-ID: <20100720185648.60AC548018E@sheep.berlios.de>

Author: mean
Date: 2010-07-20 20:56:48 +0200 (Tue, 20 Jul 2010)
New Revision: 6468

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfHeaders.cpp
Log:
[ASF demux] Fix extradata reading

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfHeaders.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfHeaders.cpp	2010-07-18 16:41:58 UTC (rev 6467)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfHeaders.cpp	2010-07-20 18:56:48 UTC (rev 6468)
@@ -67,9 +67,14 @@
     s->dump();
     switch(id->id)
     {
-#if 0      
+   
       case ADM_CHUNK_HEADER_EXTENSION_CHUNK:
       {
+        printf("Got header extension chunk\n");
+        s->skipChunk();
+        break;
+        }
+#if 0   
         s->skip(16); // Clock type extension ????
         printf("?? %d\n",s->read16());
         printf("?? %d\n",s->read32());
@@ -288,11 +293,21 @@
               return 0; 
             }
             printBih(&_video_bih);
+#if 1
+            if(_video_bih.biSize>sizeof(ADM_BITMAPINFOHEADER))
+            {
+                    x=_video_bih.biSize;
+#else
             if(x>sizeof(ADM_BITMAPINFOHEADER))
             {
+#endif
               _videoExtraLen=x-sizeof(ADM_BITMAPINFOHEADER);
               _videoExtraData=new uint8_t[_videoExtraLen];
               s->read(_videoExtraData,_videoExtraLen);
+              ADM_info("We have %d bytes of extra data for video.\n",(int)_videoExtraLen);
+            }else
+            {
+                ADM_info("No extra data for video\n");
             }
             return 1;
 }



From mean at mail.berlios.de  Tue Jul 20 20:56:49 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 20 Jul 2010 20:56:49 +0200
Subject: [Avidemux-svn-commit] r6469 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreVdpau/include avidemux_core/ADM_coreVdpau/src
	avidemux_core/ADM_coreVideoFilter/include
	avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20100720185649.E875348018E@sheep.berlios.de>

Author: mean
Date: 2010-07-20 20:56:49 +0200 (Tue, 20 Jul 2010)
New Revision: 6469

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp
Log:
[vdpau] Sort of working VDPAU deinterlacer (incomplete)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-20 18:56:49 UTC (rev 6469)
@@ -39,7 +39,8 @@
     static bool         isOperationnal(void);
     /* Surface */
 #ifdef USE_VDPAU
-    static const char  *getErrorString(VdpStatus er);
+    static  const char  *getErrorString(VdpStatus er);
+    static  bool        mixerIsFeatureEnabled( VdpVideoMixer mixer,VdpVideoMixerFeature feature);
     static  VdpStatus   surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface);
     static  VdpStatus   surfaceDestroy(VdpVideoSurface surface);
     static  VdpStatus   getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3]);
@@ -70,6 +71,10 @@
     // Warning only RGBA32 supported!
     static VdpStatus outputSurfaceGetBitsNative(VdpOutputSurface     surface,  
                         uint8_t *buffer, uint32_t w,uint32_t h);
+    static VdpStatus outputSurfaceGetBitsNative_FieldWeave(VdpOutputSurface     surface,  
+                        uint8_t *buffer, uint32_t w,uint32_t h);
+
+
     /* Presentation queue */
     static VdpStatus presentationQueueCreate(VdpPresentationQueue *queue);
     static VdpStatus presentationQueueDestroy(VdpPresentationQueue queue);
@@ -78,9 +83,10 @@
     static VdpStatus mixerCreate(uint32_t width,uint32_t height, VdpVideoMixer *mixer,bool deinterlace=false);
     static VdpStatus mixerDestroy(VdpVideoMixer mixer);
     static VdpStatus mixerRender(VdpVideoMixer mixer,VdpVideoSurface sourceSurface,VdpOutputSurface targetOutputSurface, uint32_t targetWidth, uint32_t targetHeight );
-    static VdpStatus mixerRenderWithPastAndFuture(VdpVideoMixer mixer,
+    static VdpStatus mixerRenderWithPastAndFuture(bool topField,VdpVideoMixer mixer,
                                 VdpVideoSurface sourceSurface[3], // Past present future
-                                VdpOutputSurface targetOutputSurface,uint32_t targetWidth, uint32_t targetHeight );
+                                VdpOutputSurface targetOutputSurface,
+                                uint32_t targetWidth, uint32_t targetHeight );
 
 #endif
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h	2010-07-20 18:56:49 UTC (rev 6469)
@@ -50,6 +50,7 @@
     VdpVideoMixerDestroy              *mixerDestroy;
     VdpVideoMixerRender               *mixerRender;
     VdpVideoMixerSetFeatureEnables    *mixerEnableFeatures;
+    VdpVideoMixerGetFeatureEnables    *mixerGetFeaturesEnabled;
     VdpVideoMixerQueryFeatureSupport  *mixerQueryFeatureSupported;
 
     VdpPresentationQueueTargetCreateX11 *presentationQueueDisplayX11Create;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-20 18:56:49 UTC (rev 6469)
@@ -98,7 +98,7 @@
     GetMe(mixerRender,VDP_FUNC_ID_VIDEO_MIXER_RENDER);
     GetMe(mixerEnableFeatures,VDP_FUNC_ID_VIDEO_MIXER_SET_FEATURE_ENABLES);
     GetMe(mixerQueryFeatureSupported,VDP_FUNC_ID_VIDEO_MIXER_QUERY_FEATURE_SUPPORT);
-
+    GetMe(mixerGetFeaturesEnabled,VDP_FUNC_ID_VIDEO_MIXER_GET_FEATURE_ENABLES)
     if(VDP_STATUS_OK!=ADM_coreVdpau::funcs.presentationQueueDisplayX11Create(ADM_coreVdpau::vdpDevice,x->window,&queueX11))
     {
         ADM_warning("Cannot create X11 Presentation Queue\n");
@@ -287,8 +287,20 @@
      ( void * const *)ptr,
     pitches));
 }
-
 /**
+    \fn outputSurfaceGetBitsNative_FieldWeave
+*/
+VdpStatus admVdpau::outputSurfaceGetBitsNative_FieldWeave(VdpOutputSurface     surface, uint8_t *buffer, uint32_t w,uint32_t h)
+{
+    // Only support RGBA 32
+    uint32_t pitches[3]={w*8,0,0};
+    uint8_t *ptr[4]={buffer,NULL,NULL,NULL};
+    CHECK(ADM_coreVdpau::funcs.getBitsNativeOutputSurface( surface,
+    NULL, // Rect
+     ( void * const *)ptr,
+    pitches));
+}
+/**
     \fn
     \brief
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp	2010-07-20 18:56:49 UTC (rev 6469)
@@ -19,16 +19,32 @@
 #include "../include/ADM_coreVdpauInternal.h"
 #include "ADM_dynamicLoading.h"
 
-
+#if 1
+    #define aprintf ADM_info
+#else
+    #define aprintf(...) {}
+#endif
 //GUI_WindowInfo      admVdpau::myWindowInfo;
 
 /**
+    \fn    mixerIsFeatureEnabled
+    \brief 
+*/
+bool admVdpau::mixerIsFeatureEnabled( VdpVideoMixer mixer,VdpVideoMixerFeature feature)
+{
+    VdpBool enabledFeature=true;
+    CHECKBOOL(ADM_coreVdpau::funcs.mixerGetFeaturesEnabled(mixer,1,&feature,&enabledFeature));
+    if(enabledFeature) return true;
+    return false;
+}
+/**
     \fn    mixerEnableFeature
     \brief enable mixer feature
 */
 
 VdpStatus admVdpau::mixerEnableFeature( VdpVideoMixer mixer,uint32_t nbFeature,VdpVideoMixerFeature *feature,VdpBool *enabledFeature)
 {
+    aprintf("Enabling %d features\n",nbFeature);
     CHECK(ADM_coreVdpau::funcs.mixerEnableFeatures(mixer,nbFeature,feature,enabledFeature));
 }
 /**
@@ -130,18 +146,61 @@
     \fn mixerRenderWithPastAndFuture
 */
 
-VdpStatus admVdpau::mixerRenderWithPastAndFuture(VdpVideoMixer mixer,
+VdpStatus admVdpau::mixerRenderWithPastAndFuture(
+                                bool topField,
+                                VdpVideoMixer mixer,
                                 VdpVideoSurface sourceSurface[3], // Past present future
                                 VdpOutputSurface targetOutputSurface, 
                                 uint32_t targetWidth, 
                                 uint32_t targetHeight )
 {
+    int nbPrev=2,nbNext=2;
+    VdpVideoMixerPictureStructure fieldType=VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD;
+    if(!topField) fieldType=VDP_VIDEO_MIXER_PICTURE_STRUCTURE_BOTTOM_FIELD;
+
+
+    VdpVideoSurface past[2]={VDP_INVALID_HANDLE,VDP_INVALID_HANDLE};
+    VdpVideoSurface future[2]={VDP_INVALID_HANDLE,VDP_INVALID_HANDLE};
+    VdpVideoSurface present;
+
+    present=sourceSurface[1];
+    
+
+    if(VDP_INVALID_HANDLE==sourceSurface[0] ) nbPrev=0;
+    else
+    {
+            if(topField) 
+            {
+                past[0]=sourceSurface[0];
+                past[1]=sourceSurface[0];
+            }else
+            {
+                past[0]=sourceSurface[1];
+                past[1]=sourceSurface[0];
+            }
+    }
+    if(VDP_INVALID_HANDLE==sourceSurface[2] ) nbNext=0;
+    else
+    {
+            if(topField) 
+            {
+                future[0]=sourceSurface[1];
+                future[1]=sourceSurface[2];
+            }else
+            {
+                future[0]=sourceSurface[2];
+                future[1]=sourceSurface[2];
+            }
+    }
+    // 0 & 1 p
+    //ADM_info("Deint : %d\n",(int)mixerIsFeatureEnabled(mixer,VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL));
+
       VdpStatus e=ADM_coreVdpau::funcs.mixerRender(mixer,
                 VDP_INVALID_HANDLE,NULL,    // Background
-                VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
-                1,            sourceSurface+0, // Past...
-                              sourceSurface[1], // current
-                1,            sourceSurface+2, // Future
+                fieldType,
+                nbPrev,       past, // Past...
+                              present, // current
+                nbNext,       future, // Future
                 NULL,                               // source RECT
                 targetOutputSurface,
                 NULL,                               // dest Rec
@@ -152,7 +211,7 @@
   if(VDP_STATUS_OK!=e)
     {
         
-        ADM_warning("MixerCreate  failed :%s\n",getErrorString(e));
+        ADM_warning("mixerRenderWithPastAndFuture  failed :%s\n",getErrorString(e));
         
     }
     return e;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-07-20 18:56:49 UTC (rev 6469)
@@ -47,7 +47,7 @@
        virtual             ~ADM_coreVideoFilter();
 
        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
-       virtual bool         goToTime(uint64_t usSeek);              
+       virtual bool         goToTime(uint64_t usSeek);                 /// Overide this if you have cleanup to do after a jump      
        virtual bool         getNextFrame(uint32_t *frameNumber,ADMImage *image)=0;              /// Dont mix getFrame & getNextFrame !
        virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
        virtual bool         getCoupledConf(CONFcouple **couples)=0 ;   /// Return the current filter configuration

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2010-07-20 18:56:49 UTC (rev 6469)
@@ -15,6 +15,9 @@
 #ifdef USE_VDPAU
 #include "ADM_coreVdpau/include/ADM_coreVdpau.h"
 //
+#define ADM_INVALID_FRAME_NUM 0x80000000
+#define ADM_NB_SURFACES 3
+
 /**
     \class vdpauVideoFilter
 */
@@ -22,21 +25,23 @@
 {
 protected:
                     ADMColorScalerSimple *scaler;
-                    bool passThrough;
-                    bool setupVdpau(void);
-                    bool cleanupVdpau(void);
+                    bool                 passThrough;
+                    bool                 setupVdpau(void);
+                    bool                 cleanupVdpau(void);
 
-                    uint8_t   *tempBuffer;
-                    ADMImage *original;
-                    vdpauFilter configuration;
+                    uint8_t             *tempBuffer;
+                    vdpauFilter          configuration;
                     VdpOutputSurface     surface;
-                    VdpVideoSurface      input;
+                    VdpVideoSurface      input[ADM_NB_SURFACES];
+                    uint32_t             frameDesc[ADM_NB_SURFACES];
+                    uint32_t             currentIndex;
                     VdpVideoMixer        mixer;
+                    bool                 uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) ;
 
-
 public:
-                    vdpauVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
-                    ~vdpauVideoFilter();
+        virtual bool         goToTime(uint64_t usSeek); 
+                             vdpauVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                             ~vdpauVideoFilter();
 
         virtual const char   *getConfiguration(void);                 /// Return  current configuration as a human readable string
         virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);           /// Return the next image
@@ -48,7 +53,7 @@
 DECLARE_VIDEO_FILTER(   vdpauVideoFilter,   // Class
                         1,0,0,              // Version
                         ADM_UI_GTK+ADM_UI_QT4,     // We need a display for VDPAU; so no cli...
-                        VF_INTERLACING,            // Category
+                        VF_TRANSFORM,            // Category
                         "vdpau",            // internal name (must be uniq!)
                         "vdpau",            // Display name
                         "vdpau, vdpau filters." // Description
@@ -56,18 +61,32 @@
 
 //
 /**
+    \fn goToTime
+    \brief called when seeking. Need to cleanup our stuff.
+*/
+bool         vdpauVideoFilter::goToTime(uint64_t usSeek)
+{
+    return ADM_coreVideoFilter::goToTime(usSeek);
+}
+
+/**
     \fn resetVdpau
 */
 bool vdpauVideoFilter::setupVdpau(void)
 {
     scaler=NULL;
+
+    info.width=configuration.targetWidth;
+    info.height=configuration.targetHeight;
+    for(int i=0;i<ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
+    currentIndex=0;
     if(!admVdpau::isOperationnal())
     {
         ADM_warning("Vdpau not operationnal\n");
         return false;
     }
     // check if we have something to do
-    if(!configuration.deinterlace && !configuration.resizeToggle)
+    if(info.width==previousFilter->getInfo()->width &&  info.height==previousFilter->getInfo()->height)
         return false;
     if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,
                         info.width,info.height,&surface)) 
@@ -75,20 +94,24 @@
         ADM_error("Cannot create outputSurface0\n");
         return false;
     }
-   if(VDP_STATUS_OK!=admVdpau::surfaceCreate(   previousFilter->getInfo()->width,
-                                                previousFilter->getInfo()->height,&input)) 
+    for(int i=0;i<ADM_NB_SURFACES;i++)
     {
-        ADM_error("Cannot create input Surface\n");
-        goto badInit;
+        if(VDP_STATUS_OK!=admVdpau::surfaceCreate(   previousFilter->getInfo()->width,
+                                                    previousFilter->getInfo()->height,input+i)) 
+        {
+            ADM_error("Cannot create input Surface %d\n",i);
+            goto badInit;
+        }
     }
     if(VDP_STATUS_OK!=admVdpau::mixerCreate(previousFilter->getInfo()->width,
-                                            previousFilter->getInfo()->height,&mixer,configuration.deinterlace)) 
+                                            previousFilter->getInfo()->height,&mixer)) 
     {
         ADM_error("Cannot create mixer\n");
         goto badInit;
     } 
     tempBuffer=new uint8_t[info.width*info.height*4];
     scaler=new ADMColorScalerSimple( info.width,info.height, ADM_COLOR_BGR32A,ADM_COLOR_YV12);
+    ADM_info("VDPAU setup ok\n");
     return true;
 badInit:
     cleanupVdpau();
@@ -100,11 +123,13 @@
 */
 bool vdpauVideoFilter::cleanupVdpau(void)
 {
-    if(input!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(input);
+    for(int i=0;i<ADM_NB_SURFACES;i++)
+        if(input[i]!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(input[i]);
     if(surface!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface);
     if(mixer!=VDP_INVALID_HANDLE) admVdpau::mixerDestroy(mixer);
     surface=VDP_INVALID_HANDLE;
-    input=VDP_INVALID_HANDLE;
+    for(int i=0;i<ADM_NB_SURFACES;i++)
+        input[i]=VDP_INVALID_HANDLE;
     mixer=VDP_INVALID_HANDLE;
     if(tempBuffer) delete [] tempBuffer;
     tempBuffer=NULL;
@@ -117,19 +142,17 @@
 */
 vdpauVideoFilter::vdpauVideoFilter(ADM_coreVideoFilter *in, CONFcouple *setup): ADM_coreVideoFilter(in,setup)
 {
-    input=VDP_INVALID_HANDLE;
+    for(int i=0;i<ADM_NB_SURFACES;i++)
+        input[i]=VDP_INVALID_HANDLE;
     mixer=VDP_INVALID_HANDLE;
     surface=VDP_INVALID_HANDLE;
     if(!setup || !ADM_paramLoad(setup,vdpauFilter_param,&configuration))
     {
         // Default value
-        configuration.resizeToggle=false;
-        configuration.deinterlace=false;
         configuration.targetWidth=info.width;
         configuration.targetHeight=info.height;
     }
     vidCache = new VideoCache (5, in);
-    original=new ADMImageDefault(previousFilter->getInfo()->width,previousFilter->getInfo()->height);
     myName="vdpau";
     tempBuffer=NULL;
     passThrough=!setupVdpau();
@@ -141,7 +164,7 @@
 */
 vdpauVideoFilter::~vdpauVideoFilter()
 {
-        delete original;
+//        delete original;
         delete vidCache;
         vidCache = NULL;
         cleanupVdpau();
@@ -152,29 +175,20 @@
 bool vdpauVideoFilter::configure( void) 
 {
     
-     uint32_t resize=configuration.resizeToggle;
-     uint32_t deinterlace=configuration.deinterlace;
-  
-     diaElemToggle resizeT(&(resize),   QT_TR_NOOP("Resize:"));
-     diaElemToggle deinterlaceT(&(deinterlace),   QT_TR_NOOP("Deinterlace:"));
      
      diaElemUInteger  tWidth(&(configuration.targetWidth),QT_TR_NOOP("Width :"),16,2048);
      diaElemUInteger  tHeight(&(configuration.targetHeight),QT_TR_NOOP("Height :"),16,2048);
      
-     diaElem *elems[]={&resizeT,&deinterlaceT,&tWidth,&tHeight};
+     diaElem *elems[]={&tWidth,&tHeight};
      
      if(diaFactoryRun(QT_TR_NOOP("vdpau"),sizeof(elems)/sizeof(diaElem *),elems))
      {
-         configuration.resizeToggle=resize;
-         configuration.deinterlace=deinterlace;
-         if(resize)
-         {
                 info.width=configuration.targetWidth;
                 info.height=configuration.targetHeight;
-         }
-        cleanupVdpau();
-        passThrough=!setupVdpau();
-        return 1;
+                ADM_info("New dimension : %d x %d\n",info.width,info.height);
+                cleanupVdpau();
+                passThrough=!setupVdpau();
+                return 1;
      }
      return 0;
 }
@@ -196,7 +210,7 @@
     char conf2[80];
     conf2[0]=0;
     sprintf(conf,"vdpau:");
-    if(configuration.resizeToggle)
+    if(1) //configuration.resizeToggle)
     {
         sprintf(conf2,"%d x %d -> %d x %d",
                         previousFilter->getInfo()->width, 
@@ -204,54 +218,74 @@
                         info.width,info.height);
         strcat(conf,conf2);
     }
-    if(configuration.deinterlace)
-    {
-        sprintf(conf2," deinterlace");
-        strcat(conf,conf2);
-
-    }
     conf[79]=0;
     return conf;
 }
-
 /**
-    \fn getConfiguration
-    \brief Return current setting as a string
+    \fn uploadImage
+    \brief upload an image to a vdpau surface
 */
-bool vdpauVideoFilter::getNextFrame(uint32_t *fn,ADMImage *image)
+bool vdpauVideoFilter::uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) 
 {
-    // 1- Get image...
-      if(passThrough) return previousFilter->getNextFrame(fn,image);
-    // 
-     if(false==previousFilter->getNextFrame(fn,original)) return false;
-     // Blit our image to surface
+    if(!next) // empty image
+    {
+        frameDesc[surfaceIndex%ADM_NB_SURFACES]=ADM_INVALID_FRAME_NUM;
+        ADM_warning("No image to upload\n");
+        return false;
+    }
+  // Blit our image to surface
     uint32_t pitches[3];
     uint8_t *planes[3];
-    original->GetPitches(pitches);
-    original->GetReadPlanes(planes);
+    next->GetPitches(pitches);
+    next->GetReadPlanes(planes);
 
     // Put out stuff in input...
+    printf("Uploading image to surface %d\n",surfaceIndex%ADM_NB_SURFACES);
 
     if(VDP_STATUS_OK!=admVdpau::surfacePutBits( 
-            input,
+            input[surfaceIndex%ADM_NB_SURFACES],
             planes,pitches))
     {
         ADM_warning("[Vdpau] video surface : Cannot putbits\n");
         return false;
     }
-
+    frameDesc[surfaceIndex%ADM_NB_SURFACES]=frameNumber;
+    return true;
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+bool vdpauVideoFilter::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    
+     if(passThrough) return previousFilter->getNextFrame(fn,image);
+    // regular image, in fact we get the next image here
+    ADMImage *next= vidCache->getImage(nextFrame);
+    if(false==uploadImage(next,0,nextFrame)) 
+            {
+                vidCache->unlockAll();
+                return false;
+            }
+    
+   
     // Call mixer...
-    VdpOutputSurface surfaces[3]={surface,surface,surface};
-    if(VDP_STATUS_OK!=admVdpau::mixerRenderWithPastAndFuture( mixer,input,surfaces, info.width,info.height))
+    if(VDP_STATUS_OK!=admVdpau::mixerRender( 
+                mixer,
+                input[0],
+                surface, 
+                info.width,info.height))
 
     {
         ADM_warning("[Vdpau] Cannot mixerRender\n");
+        vidCache->unlockAll();
         return false;
     }
     // Now get our image back from surface...
     if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(surface,tempBuffer, info.width,info.height))
     {
         ADM_warning("[Vdpau] Cannot copy back data from output surface\n");
+        vidCache->unlockAll();
         return false;
     }
     // Convert from VDP_RGBA_FORMAT_B8G8R8A8 to YV12
@@ -272,7 +306,10 @@
 
     scaler->convertPlanes(  sourceStride,destStride,     
                             sourceData,destData);
-      return true;
+    nextFrame++;
+    currentIndex++;
+    vidCache->unlockAll();
+    return true;
 }
 #endif
 //****************

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2010-07-20 18:56:49 UTC (rev 6469)
@@ -0,0 +1,346 @@
+/**
+    \brief VDPAU filters Deinterlacer
+    \author mean (C) 2010
+    This is slow as we copy back and forth data to/from the video cards
+    
+
+*/
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "ADM_videoFilterCache.h"
+#include "DIA_factory.h"
+#include "vdpauFilter.h"
+#include "vdpauFilter_desc.cpp"
+#ifdef USE_VDPAU
+#include "ADM_coreVdpau/include/ADM_coreVdpau.h"
+//
+#define ADM_INVALID_FRAME_NUM 0x80000000
+#define ADM_NB_SURFACES 3
+
+/**
+    \class vdpauVideoFilterDeint
+*/
+class vdpauVideoFilterDeint : public  ADM_coreVideoFilter
+{
+protected:
+                    ADMColorScalerSimple *scaler;
+                    bool                 passThrough;
+                    bool                 setupVdpau(void);
+                    bool                 cleanupVdpau(void);
+
+                    uint8_t             *tempBuffer;
+                    vdpauFilter          configuration;
+                    VdpOutputSurface     surface;
+                    VdpVideoSurface      input[ADM_NB_SURFACES];
+                    uint32_t             frameDesc[ADM_NB_SURFACES];
+                    uint32_t             currentIndex;
+                    VdpVideoMixer        mixer;
+                    bool                 uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) ;
+
+public:
+        virtual bool         goToTime(uint64_t usSeek); 
+                             vdpauVideoFilterDeint(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                             ~vdpauVideoFilterDeint();
+
+        virtual const char   *getConfiguration(void);                 /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);           /// Return the next image
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;                        /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   vdpauVideoFilterDeint,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_GTK+ADM_UI_QT4,     // We need a display for VDPAU; so no cli...
+                        VF_INTERLACING,            // Category
+                        "vdpauDeint",            // internal name (must be uniq!)
+                        "vdpauDeint",            // Display name
+                        "VDPAU deinterlacer." // Description
+                    );
+
+//
+/**
+    \fn goToTime
+    \brief called when seeking. Need to cleanup our stuff.
+*/
+bool         vdpauVideoFilterDeint::goToTime(uint64_t usSeek)
+{
+    for(int i=0;i<ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
+    currentIndex=0;
+    return ADM_coreVideoFilter::goToTime(usSeek);
+}
+
+/**
+    \fn resetVdpau
+*/
+bool vdpauVideoFilterDeint::setupVdpau(void)
+{
+    scaler=NULL;
+    for(int i=0;i<ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
+    currentIndex=0;
+    if(!admVdpau::isOperationnal())
+    {
+        ADM_warning("Vdpau not operationnal\n");
+        return false;
+    }   
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,
+                        info.width,info.height,&surface)) 
+    {
+        ADM_error("Cannot create outputSurface0\n");
+        return false;
+    }
+    for(int i=0;i<ADM_NB_SURFACES;i++)
+    {
+        if(VDP_STATUS_OK!=admVdpau::surfaceCreate(   previousFilter->getInfo()->width,
+                                                    previousFilter->getInfo()->height,input+i)) 
+        {
+            ADM_error("Cannot create input Surface %d\n",i);
+            goto badInit;
+        }
+    }
+    if(VDP_STATUS_OK!=admVdpau::mixerCreate(previousFilter->getInfo()->width,
+                                            previousFilter->getInfo()->height,&mixer,true)) 
+    {
+        ADM_error("Cannot create mixer\n");
+        goto badInit;
+    } 
+    tempBuffer=new uint8_t[info.width*info.height*4];
+    scaler=new ADMColorScalerSimple( info.width,info.height, ADM_COLOR_BGR32A,ADM_COLOR_YV12);
+    ADM_info("VDPAU setup ok\n");
+    return true;
+badInit:
+    cleanupVdpau();
+    passThrough=true;
+    return false;
+}
+/**
+    \fn cleanupVdpau
+*/
+bool vdpauVideoFilterDeint::cleanupVdpau(void)
+{
+    for(int i=0;i<ADM_NB_SURFACES;i++)
+        if(input[i]!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(input[i]);
+    if(surface!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface);
+    if(mixer!=VDP_INVALID_HANDLE) admVdpau::mixerDestroy(mixer);
+    surface=VDP_INVALID_HANDLE;
+    for(int i=0;i<ADM_NB_SURFACES;i++)
+        input[i]=VDP_INVALID_HANDLE;
+    mixer=VDP_INVALID_HANDLE;
+    if(tempBuffer) delete [] tempBuffer;
+    tempBuffer=NULL;
+    if(scaler) delete scaler;
+    scaler=NULL;
+    return true;
+}
+
+/**
+    \fn constructor
+*/
+vdpauVideoFilterDeint::vdpauVideoFilterDeint(ADM_coreVideoFilter *in, CONFcouple *setup): ADM_coreVideoFilter(in,setup)
+{
+    for(int i=0;i<ADM_NB_SURFACES;i++)
+        input[i]=VDP_INVALID_HANDLE;
+    mixer=VDP_INVALID_HANDLE;
+    surface=VDP_INVALID_HANDLE;
+    if(!setup || !ADM_paramLoad(setup,vdpauFilter_param,&configuration))
+    {
+        // Default value
+        configuration.targetWidth=info.width;
+        configuration.targetHeight=info.height;
+    }
+    vidCache = new VideoCache (5, in);
+    myName="vdpauDeint";
+    tempBuffer=NULL;
+    passThrough=!setupVdpau();
+    
+    
+}
+/**
+    \fn destructor
+*/
+vdpauVideoFilterDeint::~vdpauVideoFilterDeint()
+{
+//        delete original;
+        delete vidCache;
+        vidCache = NULL;
+        cleanupVdpau();
+}
+/**
+    \fn updateInfo
+*/
+bool vdpauVideoFilterDeint::configure( void) 
+{
+    
+     
+        cleanupVdpau();
+        passThrough=!setupVdpau();
+        return 1;
+     
+}
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         vdpauVideoFilterDeint::getCoupledConf(CONFcouple **couples)
+{
+    *couples=NULL;
+    return true;
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *vdpauVideoFilterDeint::getConfiguration(void)
+{
+    static char conf[80];
+    sprintf(conf,"Vdpau Deinterlace.");
+    conf[79]=0;
+    return conf;
+}
+/**
+    \fn uploadImage
+    \brief upload an image to a vdpau surface
+*/
+bool vdpauVideoFilterDeint::uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) 
+{
+    if(!next) // empty image
+    {
+        frameDesc[surfaceIndex%ADM_NB_SURFACES]=ADM_INVALID_FRAME_NUM;
+        ADM_warning("No image to upload\n");
+        return false;
+    }
+  // Blit our image to surface
+    uint32_t pitches[3];
+    uint8_t *planes[3];
+    next->GetPitches(pitches);
+    next->GetReadPlanes(planes);
+
+  
+    // Put out stuff in input...
+#if VDP_DEBUG
+    printf("Uploading image to surface %d\n",surfaceIndex%ADM_NB_SURFACES);
+#endif
+    if(VDP_STATUS_OK!=admVdpau::surfacePutBits( 
+            input[surfaceIndex%ADM_NB_SURFACES],
+            planes,pitches))
+    {
+        ADM_warning("[Vdpau] video surface : Cannot putbits\n");
+        return false;
+    }
+    frameDesc[surfaceIndex%ADM_NB_SURFACES]=frameNumber;
+    return true;
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+    The "input" arrays contains
+
+        T0 B0 T1 B1 T2 B2
+              ^ CurrentIndex
+    So in most case we have at least 2 fiels in the past and 2 in the future
+
+
+*/
+bool vdpauVideoFilterDeint::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    
+     if(passThrough) return previousFilter->getNextFrame(fn,image);
+    ADMImage *prev=NULL;
+    // our first frame, we need to send it + the next one
+    if(!nextFrame)
+    {
+            ADMImage *prev= vidCache->getImage( 0);
+            // Upload top field
+            if(false==uploadImage(prev,currentIndex,0)) 
+            {
+                vidCache->unlockAll();
+                return false;
+            }
+
+    }
+    // regular image, in fact we get the next image here
+    ADMImage *next= vidCache->getImage(nextFrame+1);
+    if(false==uploadImage(next,currentIndex+1,nextFrame+1)) 
+            {
+                vidCache->unlockAll();
+                return false;
+            }
+   
+    // Call mixer...
+    VdpVideoSurface in[3];
+        // PREVIOUS
+    if(!nextFrame) // First image, we dont have previous
+    {
+             in[0]=VDP_INVALID_HANDLE;
+    }else
+    {
+             in[0]=input[(currentIndex+ADM_NB_SURFACES-1)%ADM_NB_SURFACES];
+    }
+        // CURRENT
+     in[1]=input[currentIndex%ADM_NB_SURFACES];
+        // NEXT
+    if(next)
+    {
+     in[2]=input[(currentIndex+1)%ADM_NB_SURFACES];
+    }
+    else
+    {
+      in[2]=VDP_INVALID_HANDLE;
+    }
+
+    //
+#if VDP_DEBUG
+    printf("Current index=%d\n",(int)currentIndex);
+    for(int i=0;i<3;i++) printf("Calling with in[%d]=%d\n",i,in[i]);
+    for(int i=0;i<3;i++) printf("Desc[%d]=%d\n",i, frameDesc[i]);
+#endif
+    // ---------- Top field ------------
+    if(VDP_STATUS_OK!=admVdpau::mixerRenderWithPastAndFuture(true, 
+                mixer,
+                in,
+                surface, 
+                info.width,info.height))
+
+    {
+        ADM_warning("[Vdpau] Cannot mixerRender\n");
+        vidCache->unlockAll();
+        return false;
+    }
+    // Now get our image back from surface...
+    // Top Field..
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(surface,
+                                                            tempBuffer, 
+                                                            info.width,info.height))
+    {
+        ADM_warning("[Vdpau] Cannot copy back data from output surface\n");
+        vidCache->unlockAll();
+        return false;
+    }
+
+    // Convert from VDP_RGBA_FORMAT_B8G8R8A8 to YV12
+    uint32_t sourceStride[3]={info.width*4,0,0};
+    uint8_t  *sourceData[3]={tempBuffer,NULL,NULL};
+    uint32_t destStride[3];
+    uint8_t  *destData[3];
+
+    image->GetPitches(destStride);
+    image->GetWritePlanes(destData);
+
+    // Invert U&V
+    uint32_t ts;
+    uint8_t  *td;
+
+    ts=destStride[2];destStride[2]=destStride[1];destStride[1]=ts;
+    td=destData[2];destData[2]=destData[1];destData[1]=td;
+
+    scaler->convertPlanes(  sourceStride,destStride,     
+                            sourceData,destData);
+    nextFrame++;
+    currentIndex+=2; // Two fields at a time...
+    vidCache->unlockAll();
+    return true;
+}
+#endif
+
+//****************
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/CMakeLists.txt	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/CMakeLists.txt	2010-07-20 18:56:49 UTC (rev 6469)
@@ -1,9 +1,13 @@
 INCLUDE(vf_plugin)
 IF(NOT WIN32 AND NOT APPLE)
         SET(ADM_vf_vdpauFilter_SRCS ADM_vidVdpauFilter.cpp )
+        SET(ADM_vf_vdpauFilterDeint_SRCS ADM_vidVdpauFilterDeint.cpp )
 
         ADD_VIDEO_FILTER(ADM_vf_vdpauFilter ${ADM_vf_vdpauFilter_SRCS})
+        ADD_VIDEO_FILTER(ADM_vf_vdpauFilterDeint ${ADM_vf_vdpauFilterDeint_SRCS})
 
         INIT_VIDEO_FILTER(ADM_vf_vdpauFilter)
+        INIT_VIDEO_FILTER(ADM_vf_vdpauFilterDeint)
         INSTALL_VIDEO_FILTER(ADM_vf_vdpauFilter)
+        INSTALL_VIDEO_FILTER(ADM_vf_vdpauFilterDeint)
 ENDIF(NOT WIN32 AND NOT APPLE)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf	2010-07-20 18:56:49 UTC (rev 6469)
@@ -1,4 +1,2 @@
-bool:resizeToggle;
 uint32_t:targetWidth;
-uint32_t:targetHeight;
-bool:deinterlace;
\ No newline at end of file
+uint32_t:targetHeight;
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h	2010-07-20 18:56:49 UTC (rev 6469)
@@ -2,10 +2,8 @@
 #ifndef ADM_vdpauFilter_CONF_H
 #define ADM_vdpauFilter_CONF_H
 typedef struct {
-   bool resizeToggle;
    uint32_t targetWidth;
    uint32_t targetHeight;
-   bool deinterlace;
 }vdpauFilter;
 #endif //vdpauFilter
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp	2010-07-20 18:56:49 UTC (rev 6469)
@@ -1,8 +1,6 @@
 // Automatically generated, do not edit!
 const ADM_paramList vdpauFilter_param[]={
- {"resizeToggle",offsetof( vdpauFilter,resizeToggle),"bool",ADM_param_bool},
  {"targetWidth",offsetof( vdpauFilter,targetWidth),"uint32_t",ADM_param_uint32_t},
  {"targetHeight",offsetof( vdpauFilter,targetHeight),"uint32_t",ADM_param_uint32_t},
- {"deinterlace",offsetof( vdpauFilter,deinterlace),"bool",ADM_param_bool},
 {NULL,0,NULL}
 };



From mean at mail.berlios.de  Wed Jul 21 20:20:14 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 21 Jul 2010 20:20:14 +0200
Subject: [Avidemux-svn-commit] r6470 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreVdpau/src avidemux_plugins/ADM_muxers/muxerAvi
	avidemux_plugins/ADM_muxers/muxerRaw
	avidemux_plugins/ADM_videoFilters6/printInfo
	avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20100721182014.7BA3948002A@sheep.berlios.de>

Author: mean
Date: 2010-07-21 20:20:14 +0200 (Wed, 21 Jul 2010)
New Revision: 6470

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/printInfo/printInfo.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
Log:
[vdpauDeint] Handle resize + pts (incomplete)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp	2010-07-20 18:56:49 UTC (rev 6469)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp	2010-07-21 18:20:14 UTC (rev 6470)
@@ -164,33 +164,21 @@
     VdpVideoSurface present;
 
     present=sourceSurface[1];
-    
+    int index=0;
+    if(!topField) index=1;
 
     if(VDP_INVALID_HANDLE==sourceSurface[0] ) nbPrev=0;
     else
     {
-            if(topField) 
-            {
-                past[0]=sourceSurface[0];
-                past[1]=sourceSurface[0];
-            }else
-            {
-                past[0]=sourceSurface[1];
-                past[1]=sourceSurface[0];
-            }
+         
+            past[0]=sourceSurface[index];
+            past[1]=sourceSurface[0];
     }
     if(VDP_INVALID_HANDLE==sourceSurface[2] ) nbNext=0;
     else
     {
-            if(topField) 
-            {
-                future[0]=sourceSurface[1];
-                future[1]=sourceSurface[2];
-            }else
-            {
-                future[0]=sourceSurface[2];
-                future[1]=sourceSurface[2];
-            }
+            future[0]=sourceSurface[1+index];
+            future[1]=sourceSurface[2];
     }
     // 0 & 1 p
     //ADM_info("Deint : %d\n",(int)mixerIsFeatureEnabled(mixer,VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL));

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp	2010-07-20 18:56:49 UTC (rev 6469)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp	2010-07-21 18:20:14 UTC (rev 6470)
@@ -22,7 +22,6 @@
 #include "muxerAvi.h"
 
 
-#define ADM_NO_PTS 0xFFFFFFFFFFFFFFFFLL // FIXME
 #define AUDIO_BUFFER_SIZE 48000*6*sizeof(float)
 
 #if 1

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp	2010-07-20 18:56:49 UTC (rev 6469)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp	2010-07-21 18:20:14 UTC (rev 6470)
@@ -20,7 +20,6 @@
 #include "fourcc.h"
 #include "muxerRaw.h"
 #include "DIA_coreToolkit.h"
-#define ADM_NO_PTS 0xFFFFFFFFFFFFFFFFLL // FIXME
 
 
 #if 1

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/printInfo/printInfo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/printInfo/printInfo.cpp	2010-07-20 18:56:49 UTC (rev 6469)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/printInfo/printInfo.cpp	2010-07-21 18:20:14 UTC (rev 6470)
@@ -18,7 +18,6 @@
 #include "ADM_default.h"
 #include "ADM_coreVideoFilterInternal.h"
 #include "ADM_vidMisc.h"
-#define ADM_NO_PTS 0xFFFFFFFFFFFFFFFFLL // FIXME
 /**
     \class printInfoFilter
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2010-07-20 18:56:49 UTC (rev 6469)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2010-07-21 18:20:14 UTC (rev 6470)
@@ -9,33 +9,44 @@
 #include "ADM_coreVideoFilterInternal.h"
 #include "ADM_videoFilterCache.h"
 #include "DIA_factory.h"
-#include "vdpauFilter.h"
-#include "vdpauFilter_desc.cpp"
+#include "vdpauFilterDeint.h"
+#include "vdpauFilterDeint_desc.cpp"
 #ifdef USE_VDPAU
 #include "ADM_coreVdpau/include/ADM_coreVdpau.h"
 //
 #define ADM_INVALID_FRAME_NUM 0x80000000
 #define ADM_NB_SURFACES 3
 
+enum
+{
+    ADM_KEEP_TOP=0,
+    ADM_KEEP_BOTTOM=1,
+    ADM_KEEP_BOTH=2
+};
+
 /**
     \class vdpauVideoFilterDeint
 */
 class vdpauVideoFilterDeint : public  ADM_coreVideoFilter
 {
 protected:
+                    uint64_t             refPts;
+                    uint32_t             outputFrameNumber;
                     ADMColorScalerSimple *scaler;
                     bool                 passThrough;
                     bool                 setupVdpau(void);
                     bool                 cleanupVdpau(void);
-
+                    bool                 updateConf(void);
                     uint8_t             *tempBuffer;
-                    vdpauFilter          configuration;
+                    vdpauFilterDeint     configuration;
                     VdpOutputSurface     surface;
                     VdpVideoSurface      input[ADM_NB_SURFACES];
                     uint32_t             frameDesc[ADM_NB_SURFACES];
                     uint32_t             currentIndex;
                     VdpVideoMixer        mixer;
                     bool                 uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) ;
+                    bool                 getResult(ADMImage *image);
+                    bool                 sendField(bool topField,ADMImage *next);
 
 public:
         virtual bool         goToTime(uint64_t usSeek); 
@@ -55,11 +66,38 @@
                         VF_INTERLACING,            // Category
                         "vdpauDeint",            // internal name (must be uniq!)
                         "vdpauDeint",            // Display name
-                        "VDPAU deinterlacer." // Description
+                        "VDPAU deinterlacer (+resize)." // Description
                     );
 
 //
+
 /**
+    \fn updateConf
+*/
+bool vdpauVideoFilterDeint::updateConf(void)
+{
+    if(passThrough)
+    {
+        ADM_warning("PassThrough mode\n");
+        info=*(previousFilter->getInfo());
+        return true;
+    }
+    if(configuration.resizeToggle)
+    {
+        info.width=configuration.targetWidth;
+        info.height=configuration.targetHeight;
+    }else
+    {
+            info=*(previousFilter->getInfo());
+    }
+    uint64_t prev=previousFilter->getInfo()->frameIncrement;
+    if(configuration.deintMode==ADM_KEEP_BOTH)
+        info.frameIncrement=prev/2;
+    else
+        info.frameIncrement=prev;
+    return true;
+}
+/**
     \fn goToTime
     \brief called when seeking. Need to cleanup our stuff.
 */
@@ -67,6 +105,7 @@
 {
     for(int i=0;i<ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
     currentIndex=0;
+    outputFrameNumber=0;
     return ADM_coreVideoFilter::goToTime(usSeek);
 }
 
@@ -78,6 +117,7 @@
     scaler=NULL;
     for(int i=0;i<ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
     currentIndex=0;
+    outputFrameNumber=0;
     if(!admVdpau::isOperationnal())
     {
         ADM_warning("Vdpau not operationnal\n");
@@ -142,18 +182,21 @@
         input[i]=VDP_INVALID_HANDLE;
     mixer=VDP_INVALID_HANDLE;
     surface=VDP_INVALID_HANDLE;
-    if(!setup || !ADM_paramLoad(setup,vdpauFilter_param,&configuration))
+    if(!setup || !ADM_paramLoad(setup,vdpauFilterDeint_param,&configuration))
     {
         // Default value
+        configuration.resizeToggle=false;
+        configuration.deintMode=ADM_KEEP_TOP;
         configuration.targetWidth=info.width;
         configuration.targetHeight=info.height;
     }
     vidCache = new VideoCache (5, in);
     myName="vdpauDeint";
     tempBuffer=NULL;
+    passThrough=false;
+    updateConf();    
     passThrough=!setupVdpau();
     
-    
 }
 /**
     \fn destructor
@@ -170,8 +213,35 @@
 */
 bool vdpauVideoFilterDeint::configure( void) 
 {
-    
      
+     diaMenuEntry tMode[]={
+                             {ADM_KEEP_TOP,      QT_TR_NOOP("Keep Top Field"),NULL},
+                             {ADM_KEEP_BOTTOM,   QT_TR_NOOP("Keep Bottom Field"),NULL},
+                             {ADM_KEEP_BOTH,      QT_TR_NOOP("Double framerate"),NULL}
+                             
+          };
+     uint32_t doResize=(uint32_t)configuration.resizeToggle;
+     diaElemToggle    tResize(&(doResize),   QT_TR_NOOP("_Resize:"));
+     diaElemMenu      mMode(&(configuration.deintMode),   QT_TR_NOOP("_Deint Mode:"), 3,tMode);
+     diaElemUInteger  tWidth(&(configuration.targetWidth),QT_TR_NOOP("Width :"),16,2048);
+     diaElemUInteger  tHeight(&(configuration.targetHeight),QT_TR_NOOP("Height :"),16,2048);
+     
+     diaElem *elems[]={&mMode,&tResize,&tWidth,&tHeight};
+     
+     if(diaFactoryRun(QT_TR_NOOP("vdpau"),sizeof(elems)/sizeof(diaElem *),elems))
+     {
+                configuration.resizeToggle=(bool)doResize;
+                info.width=configuration.targetWidth;
+                info.height=configuration.targetHeight;
+                ADM_info("New dimension : %d x %d\n",info.width,info.height);
+                updateConf();
+                cleanupVdpau();
+                passThrough=!setupVdpau();
+                
+                return 1;
+     }
+     return 0;
+     
         cleanupVdpau();
         passThrough=!setupVdpau();
         return 1;
@@ -183,8 +253,7 @@
 */
 bool         vdpauVideoFilterDeint::getCoupledConf(CONFcouple **couples)
 {
-    *couples=NULL;
-    return true;
+   return ADM_paramSave(couples, vdpauFilterDeint_param,&configuration);
 }
 /**
     \fn getConfiguration
@@ -193,7 +262,7 @@
 const char *vdpauVideoFilterDeint::getConfiguration(void)
 {
     static char conf[80];
-    sprintf(conf,"Vdpau Deinterlace.");
+    sprintf(conf,"Vdpau Deinterlace mode=%d, %d x %d",configuration.deintMode,info.width,info.height);
     conf[79]=0;
     return conf;
 }
@@ -207,7 +276,7 @@
     {
         frameDesc[surfaceIndex%ADM_NB_SURFACES]=ADM_INVALID_FRAME_NUM;
         ADM_warning("No image to upload\n");
-        return false;
+        return true;
     }
   // Blit our image to surface
     uint32_t pitches[3];
@@ -231,43 +300,14 @@
     return true;
 }
 /**
-    \fn getConfiguration
-    \brief Return current setting as a string
-    The "input" arrays contains
-
-        T0 B0 T1 B1 T2 B2
-              ^ CurrentIndex
-    So in most case we have at least 2 fiels in the past and 2 in the future
-
-
+    \fn sendField
+    \brief Process a field (top or bottom). If null the next param means there is no successor (next image)
 */
-bool vdpauVideoFilterDeint::getNextFrame(uint32_t *fn,ADMImage *image)
+bool vdpauVideoFilterDeint::sendField(bool topField,ADMImage *next)
 {
-    
-     if(passThrough) return previousFilter->getNextFrame(fn,image);
-    ADMImage *prev=NULL;
-    // our first frame, we need to send it + the next one
-    if(!nextFrame)
-    {
-            ADMImage *prev= vidCache->getImage( 0);
-            // Upload top field
-            if(false==uploadImage(prev,currentIndex,0)) 
-            {
-                vidCache->unlockAll();
-                return false;
-            }
-
-    }
-    // regular image, in fact we get the next image here
-    ADMImage *next= vidCache->getImage(nextFrame+1);
-    if(false==uploadImage(next,currentIndex+1,nextFrame+1)) 
-            {
-                vidCache->unlockAll();
-                return false;
-            }
-   
-    // Call mixer...
+ // Call mixer...
     VdpVideoSurface in[3];
+    bool r=true;
         // PREVIOUS
     if(!nextFrame) // First image, we dont have previous
     {
@@ -295,25 +335,30 @@
     for(int i=0;i<3;i++) printf("Desc[%d]=%d\n",i, frameDesc[i]);
 #endif
     // ---------- Top field ------------
-    if(VDP_STATUS_OK!=admVdpau::mixerRenderWithPastAndFuture(true, 
+    if(VDP_STATUS_OK!=admVdpau::mixerRenderWithPastAndFuture(topField, 
                 mixer,
                 in,
                 surface, 
-                info.width,info.height))
+                previousFilter->getInfo()->width,previousFilter->getInfo()->height))
 
     {
         ADM_warning("[Vdpau] Cannot mixerRender\n");
-        vidCache->unlockAll();
-        return false;
+        r= false;
     }
-    // Now get our image back from surface...
-    // Top Field..
-    if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(surface,
+    vidCache->unlockAll();
+    return r;
+}
+/**
+    \fn     getResult
+    \brief  Convert the output surface into an ADMImage
+*/
+bool vdpauVideoFilterDeint::getResult(ADMImage *image)
+{
+ if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(surface,
                                                             tempBuffer, 
                                                             info.width,info.height))
     {
         ADM_warning("[Vdpau] Cannot copy back data from output surface\n");
-        vidCache->unlockAll();
         return false;
     }
 
@@ -335,9 +380,61 @@
 
     scaler->convertPlanes(  sourceStride,destStride,     
                             sourceData,destData);
+    return true;
+}
+/**
+    \fn getNextFrame
+    \brief 
+
+*/
+bool vdpauVideoFilterDeint::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+     if(passThrough) return previousFilter->getNextFrame(fn,image);
+    // top field has already been sent, grab bottom field
+    if((outputFrameNumber&1)&&(configuration.deintMode==ADM_KEEP_BOTH))
+        {
+            *fn=outputFrameNumber++;
+            if(false==getResult(image)) return false;
+            if(ADM_NO_PTS==refPts) image->Pts=refPts;
+                else image->Pts=refPts+info.frameIncrement;
+            return true;
+        }
+    
+    // our first frame, we need to send it + the next one
+    if(!nextFrame)
+    {
+            ADMImage *prev= vidCache->getImage( 0);
+            // Upload top field
+            if(false==uploadImage(prev,currentIndex,0)) 
+            {
+                vidCache->unlockAll();
+                return false;
+            }
+    }
+    // regular image, in fact we get the next image here
+    ADMImage *next= vidCache->getImage(nextFrame+1);
+    if(false==uploadImage(next,currentIndex+1,nextFrame+1)) 
+            {
+                vidCache->unlockAll();
+                return false;
+            }
+   
+   
+    // Now get our image back from surface...
+    sendField(true,next); // always send top field
+    if(configuration.deintMode==ADM_KEEP_TOP || configuration.deintMode==ADM_KEEP_BOTH)
+    {
+          if(false==getResult(image)) 
+                return false;
+    }
+    // Send 2nd field
+    sendField(false,next); 
+    // Top Field..
+   
     nextFrame++;
-    currentIndex+=2; // Two fields at a time...
-    vidCache->unlockAll();
+    currentIndex+=1; // Two fields at a time...
+    outputFrameNumber++;
+    refPts=image->Pts;
     return true;
 }
 #endif



From mean at mail.berlios.de  Wed Jul 21 20:20:17 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 21 Jul 2010 20:20:17 +0200
Subject: [Avidemux-svn-commit] r6471 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_editor avidemux_core/ADM_core/include
	avidemux_core/ADM_core/src avidemux_core/ADM_coreDemuxer/include
	avidemux_core/ADM_coreDemuxerMpeg/include
	avidemux_core/ADM_coreMuxer/include
	avidemux_core/ADM_coreUtils/include
	avidemux_core/ADM_coreVideoEncoder/src
	avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20100721182017.A0AC448002A@sheep.berlios.de>

Author: mean
Date: 2010-07-21 20:20:16 +0200 (Wed, 21 Jul 2010)
New Revision: 6471

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint_desc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_misc.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxer/include/ADM_Video.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxerMpeg/include/dmx_demuxer.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerUtils.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_compressedImage.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
Log:
[All] Put ADM_NO_PTS at only one place

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-07-21 18:20:14 UTC (rev 6470)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-07-21 18:20:16 UTC (rev 6471)
@@ -16,7 +16,6 @@
 #include "ADM_default.h"
 #include "ADM_image.h"
 #include "ADM_editor/ADM_edCache.h"
-#define ADM_NO_PTS 0xffffffffffffffffLL
 
 #if 1
 #define aprintf(...) {}

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h	2010-07-21 18:20:14 UTC (rev 6470)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h	2010-07-21 18:20:16 UTC (rev 6471)
@@ -26,7 +26,7 @@
 #include "ADM_coreConfig.h"
 #include "ADM_inttype.h"
 #include "ADM_assert.h"
-
+#define ADM_NO_PTS 0xffffffffffffffffLL
 #ifdef __cplusplus
 #include "ADM_cpuCap.h"
 #include "ADM_clock.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_misc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_misc.cpp	2010-07-21 18:20:14 UTC (rev 6470)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_misc.cpp	2010-07-21 18:20:16 UTC (rev 6471)
@@ -36,8 +36,6 @@
 #include "ADM_vidMisc.h"
 #undef fopen
 #undef fclose
-#warning FIXME
-#define ADM_NO_PTS 0xFFFFFFFFFFFFFFFFLL // FIXME
 //
 //    Sleep for n ms
 //

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxer/include/ADM_Video.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxer/include/ADM_Video.h	2010-07-21 18:20:14 UTC (rev 6470)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxer/include/ADM_Video.h	2010-07-21 18:20:16 UTC (rev 6471)
@@ -28,9 +28,6 @@
 
 #include "ADM_colorspace.h"
 
-#ifndef ADM_NO_PTS
-#define ADM_NO_PTS 0xFFFFFFFFFFFFFFFFLL // FIXME
-#endif
 
 typedef struct 
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxerMpeg/include/dmx_demuxer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxerMpeg/include/dmx_demuxer.h	2010-07-21 18:20:14 UTC (rev 6470)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxerMpeg/include/dmx_demuxer.h	2010-07-21 18:20:16 UTC (rev 6471)
@@ -20,9 +20,6 @@
  
 #include "dmx_io.h"
 
-#ifndef ADM_NO_PTS
-    #define ADM_NO_PTS 0xFFFFFFFFFFFFFFFFLL
-#endif
 #include "dmx_indexer.h"
 
 typedef enum 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerUtils.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerUtils.h	2010-07-21 18:20:14 UTC (rev 6470)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerUtils.h	2010-07-21 18:20:16 UTC (rev 6471)
@@ -20,7 +20,6 @@
 #include "libavformat/avformat.h"
 };
 
-#define ADM_NO_PTS 0xFFFFFFFFFFFFFFFFLL // FIXME
 #include "ADM_codecType.h"
 
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_compressedImage.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_compressedImage.h	2010-07-21 18:20:14 UTC (rev 6470)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_compressedImage.h	2010-07-21 18:20:16 UTC (rev 6471)
@@ -8,8 +8,7 @@
 //
 #ifndef ADM_COMPRESSED_IMAGE_H
 #define ADM_COMPRESSED_IMAGE_H
-
-#define ADM_COMPRESSED_NO_PTS (0xFFFFFFFFFFFFFFFFLL) // Same as ADM_NO_PTS
+#define ADM_COMPRESSED_NO_PTS ADM_NO_PTS
 class ADMCompressedImage
 {
   

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-07-21 18:20:14 UTC (rev 6470)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-07-21 18:20:16 UTC (rev 6471)
@@ -19,7 +19,6 @@
 #include "ADM_default.h"
 #include "ADM_coreVideoEncoderFFmpeg.h"
 #include "prefs.h"
-#define ADM_NO_PTS 0xFFFFFFFFFFFFFFFFLL // FIXME
 //#define TIME_TENTH_MILLISEC
 #if 1
     #define aprintf(...) {}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint.conf	2010-07-21 18:20:16 UTC (rev 6471)
@@ -0,0 +1,4 @@
+bool:resizeToggle;
+uint32_t:deintMode;
+uint32_t:targetWidth;
+uint32_t:targetHeight;

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint.h	2010-07-21 18:20:16 UTC (rev 6471)
@@ -0,0 +1,11 @@
+// Automatically generated, do not edit!
+#ifndef ADM_vdpauFilterDeint_CONF_H
+#define ADM_vdpauFilterDeint_CONF_H
+typedef struct {
+   bool resizeToggle;
+   uint32_t deintMode;
+   uint32_t targetWidth;
+   uint32_t targetHeight;
+}vdpauFilterDeint;
+#endif //vdpauFilterDeint
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilterDeint_desc.cpp	2010-07-21 18:20:16 UTC (rev 6471)
@@ -0,0 +1,8 @@
+// Automatically generated, do not edit!
+const ADM_paramList vdpauFilterDeint_param[]={
+ {"resizeToggle",offsetof( vdpauFilterDeint,resizeToggle),"bool",ADM_param_bool},
+ {"deintMode",offsetof( vdpauFilterDeint,deintMode),"uint32_t",ADM_param_uint32_t},
+ {"targetWidth",offsetof( vdpauFilterDeint,targetWidth),"uint32_t",ADM_param_uint32_t},
+ {"targetHeight",offsetof( vdpauFilterDeint,targetHeight),"uint32_t",ADM_param_uint32_t},
+{NULL,0,NULL}
+};



From mean at mail.berlios.de  Wed Jul 21 21:03:39 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 21 Jul 2010 21:03:39 +0200
Subject: [Avidemux-svn-commit] r6472 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20100721190339.7971C480B05@sheep.berlios.de>

Author: mean
Date: 2010-07-21 21:03:39 +0200 (Wed, 21 Jul 2010)
New Revision: 6472

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
Log:
[VdpauDeint] Fix PTS/DTS. workish, needs to be simplified

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2010-07-21 18:20:16 UTC (rev 6471)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2010-07-21 19:03:39 UTC (rev 6472)
@@ -9,6 +9,7 @@
 #include "ADM_coreVideoFilterInternal.h"
 #include "ADM_videoFilterCache.h"
 #include "DIA_factory.h"
+#include "ADM_vidMisc.h"
 #include "vdpauFilterDeint.h"
 #include "vdpauFilterDeint_desc.cpp"
 #ifdef USE_VDPAU
@@ -17,6 +18,8 @@
 #define ADM_INVALID_FRAME_NUM 0x80000000
 #define ADM_NB_SURFACES 3
 
+#define aprintf printf
+
 enum
 {
     ADM_KEEP_TOP=0,
@@ -30,7 +33,7 @@
 class vdpauVideoFilterDeint : public  ADM_coreVideoFilter
 {
 protected:
-                    uint64_t             refPts;
+                    uint64_t             nextPts;
                     uint32_t             outputFrameNumber;
                     ADMColorScalerSimple *scaler;
                     bool                 passThrough;
@@ -389,14 +392,18 @@
 */
 bool vdpauVideoFilterDeint::getNextFrame(uint32_t *fn,ADMImage *image)
 {
+bool r=true;
+uint64_t currentPts=ADM_NO_PTS;
+#define FAIL {r=false;goto endit;}
      if(passThrough) return previousFilter->getNextFrame(fn,image);
     // top field has already been sent, grab bottom field
     if((outputFrameNumber&1)&&(configuration.deintMode==ADM_KEEP_BOTH))
         {
             *fn=outputFrameNumber++;
             if(false==getResult(image)) return false;
-            if(ADM_NO_PTS==refPts) image->Pts=refPts;
-                else image->Pts=refPts+info.frameIncrement;
+            if(ADM_NO_PTS==nextPts) image->Pts=nextPts;
+                else image->Pts=nextPts-info.frameIncrement;
+            aprintf("2ndField : Pts=%s\n",ADM_us2plain(image->Pts));
             return true;
         }
     
@@ -410,13 +417,15 @@
                 vidCache->unlockAll();
                 return false;
             }
+            nextPts=prev->Pts;
     }
     // regular image, in fact we get the next image here
+    
     ADMImage *next= vidCache->getImage(nextFrame+1);
     if(false==uploadImage(next,currentIndex+1,nextFrame+1)) 
             {
                 vidCache->unlockAll();
-                return false;
+                FAIL
             }
    
    
@@ -425,17 +434,29 @@
     if(configuration.deintMode==ADM_KEEP_TOP || configuration.deintMode==ADM_KEEP_BOTH)
     {
           if(false==getResult(image)) 
-                return false;
+          {
+               FAIL
+          }
+          aprintf("TOP/BOTH : Pts=%s\n",ADM_us2plain(image->Pts));
     }
     // Send 2nd field
     sendField(false,next); 
+    if(configuration.deintMode==ADM_KEEP_BOTTOM)
+    {
+          if(false==getResult(image)) 
+          {
+               FAIL
+          }
+          aprintf("BOTTOM : Pts=%s\n",ADM_us2plain(image->Pts));
+    }
     // Top Field..
-   
+endit:   
     nextFrame++;
     currentIndex+=1; // Two fields at a time...
     outputFrameNumber++;
-    refPts=image->Pts;
-    return true;
+    image->Pts=nextPts;
+    if(next) nextPts=next->Pts;
+    return r;
 }
 #endif
 



From mean at mail.berlios.de  Thu Jul 22 07:34:28 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 22 Jul 2010 07:34:28 +0200
Subject: [Avidemux-svn-commit] r6473 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20100722053428.E1B7E480BE7@sheep.berlios.de>

Author: mean
Date: 2010-07-22 07:34:28 +0200 (Thu, 22 Jul 2010)
New Revision: 6473

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
Log:
[VdpauDeint] Simplify

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2010-07-21 19:03:39 UTC (rev 6472)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2010-07-22 05:34:28 UTC (rev 6473)
@@ -18,7 +18,11 @@
 #define ADM_INVALID_FRAME_NUM 0x80000000
 #define ADM_NB_SURFACES 3
 
+#if 0
 #define aprintf printf
+#else
+#define aprintf(...) {}
+#endif
 
 enum
 {
@@ -33,8 +37,8 @@
 class vdpauVideoFilterDeint : public  ADM_coreVideoFilter
 {
 protected:
+                    bool                 secondField;
                     uint64_t             nextPts;
-                    uint32_t             outputFrameNumber;
                     ADMColorScalerSimple *scaler;
                     bool                 passThrough;
                     bool                 setupVdpau(void);
@@ -45,7 +49,6 @@
                     VdpOutputSurface     surface;
                     VdpVideoSurface      input[ADM_NB_SURFACES];
                     uint32_t             frameDesc[ADM_NB_SURFACES];
-                    uint32_t             currentIndex;
                     VdpVideoMixer        mixer;
                     bool                 uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) ;
                     bool                 getResult(ADMImage *image);
@@ -106,9 +109,8 @@
 */
 bool         vdpauVideoFilterDeint::goToTime(uint64_t usSeek)
 {
+    secondField=false;
     for(int i=0;i<ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
-    currentIndex=0;
-    outputFrameNumber=0;
     return ADM_coreVideoFilter::goToTime(usSeek);
 }
 
@@ -118,9 +120,9 @@
 bool vdpauVideoFilterDeint::setupVdpau(void)
 {
     scaler=NULL;
+    secondField=false;
     for(int i=0;i<ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
-    currentIndex=0;
-    outputFrameNumber=0;
+    nextFrame=0;
     if(!admVdpau::isOperationnal())
     {
         ADM_warning("Vdpau not operationnal\n");
@@ -317,14 +319,14 @@
              in[0]=VDP_INVALID_HANDLE;
     }else
     {
-             in[0]=input[(currentIndex+ADM_NB_SURFACES-1)%ADM_NB_SURFACES];
+             in[0]=input[(nextFrame+ADM_NB_SURFACES-1)%ADM_NB_SURFACES];
     }
         // CURRENT
-     in[1]=input[currentIndex%ADM_NB_SURFACES];
+     in[1]=input[nextFrame%ADM_NB_SURFACES];
         // NEXT
     if(next)
     {
-     in[2]=input[(currentIndex+1)%ADM_NB_SURFACES];
+     in[2]=input[(nextFrame+1)%ADM_NB_SURFACES];
     }
     else
     {
@@ -333,7 +335,7 @@
 
     //
 #if VDP_DEBUG
-    printf("Current index=%d\n",(int)currentIndex);
+    printf("Current index=%d\n",(int)nextFrame);
     for(int i=0;i<3;i++) printf("Calling with in[%d]=%d\n",i,in[i]);
     for(int i=0;i<3;i++) printf("Desc[%d]=%d\n",i, frameDesc[i]);
 #endif
@@ -393,13 +395,13 @@
 bool vdpauVideoFilterDeint::getNextFrame(uint32_t *fn,ADMImage *image)
 {
 bool r=true;
-uint64_t currentPts=ADM_NO_PTS;
 #define FAIL {r=false;goto endit;}
      if(passThrough) return previousFilter->getNextFrame(fn,image);
     // top field has already been sent, grab bottom field
-    if((outputFrameNumber&1)&&(configuration.deintMode==ADM_KEEP_BOTH))
+    if((secondField)&&(configuration.deintMode==ADM_KEEP_BOTH))
         {
-            *fn=outputFrameNumber++;
+            secondField=false;
+            *fn=nextFrame*2+1;
             if(false==getResult(image)) return false;
             if(ADM_NO_PTS==nextPts) image->Pts=nextPts;
                 else image->Pts=nextPts-info.frameIncrement;
@@ -407,12 +409,12 @@
             return true;
         }
     
-    // our first frame, we need to send it + the next one
+    // our first frame, we need to preload one frame
     if(!nextFrame)
     {
             ADMImage *prev= vidCache->getImage( 0);
             // Upload top field
-            if(false==uploadImage(prev,currentIndex,0)) 
+            if(false==uploadImage(prev,nextFrame,0)) 
             {
                 vidCache->unlockAll();
                 return false;
@@ -422,7 +424,7 @@
     // regular image, in fact we get the next image here
     
     ADMImage *next= vidCache->getImage(nextFrame+1);
-    if(false==uploadImage(next,currentIndex+1,nextFrame+1)) 
+    if(false==uploadImage(next,nextFrame+1,nextFrame+1)) 
             {
                 vidCache->unlockAll();
                 FAIL
@@ -450,10 +452,14 @@
           aprintf("BOTTOM : Pts=%s\n",ADM_us2plain(image->Pts));
     }
     // Top Field..
-endit:   
+endit:  
+    if(configuration.deintMode==ADM_KEEP_BOTH) 
+    {
+        *fn=nextFrame*2;
+        secondField=true;
+    }
+        else    *fn=nextFrame;
     nextFrame++;
-    currentIndex+=1; // Two fields at a time...
-    outputFrameNumber++;
     image->Pts=nextPts;
     if(next) nextPts=next->Pts;
     return r;



From mean at mail.berlios.de  Fri Jul 23 08:00:38 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 23 Jul 2010 08:00:38 +0200
Subject: [Avidemux-svn-commit] r6474 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_videoFilter2/include
	avidemux_core/ADM_coreVideoFilter/include
Message-ID: <20100723060038.1442D480E63@sheep.berlios.de>

Author: mean
Date: 2010-07-23 08:00:37 +0200 (Fri, 23 Jul 2010)
New Revision: 6474

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
Log:
[filter] Add getAbsoluteStartTime (subtitle,...)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h	2010-07-22 05:34:28 UTC (rev 6473)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h	2010-07-23 06:00:37 UTC (rev 6474)
@@ -38,9 +38,12 @@
        virtual bool         getNextFrame(uint32_t *frameNumber,ADMImage *image);      
        virtual FilterInfo  *getInfo(void);                                      /// Return picture parameters after this filter
        virtual bool         getCoupledConf(CONFcouple **couples) {*couples=NULL;return true;} ; /// Return the current filter configuration
+       virtual uint64_t     getAbsoluteStartTime(void)  
+                            {
+                                    return startTime;
+                            }
+       bool                 rewind(void);
 
-        bool                rewind(void);
-
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-07-22 05:34:28 UTC (rev 6473)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-07-23 06:00:37 UTC (rev 6474)
@@ -52,6 +52,9 @@
        virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
        virtual bool         getCoupledConf(CONFcouple **couples)=0 ;   /// Return the current filter configuration
        virtual bool         configure(void) {return true;}             /// Start graphical user interface
+       virtual uint64_t     getAbsoluteStartTime(void)                 /// Return the absolute offset of the current frame. Used to display time of for filter
+                {return previousFilter->getAbsoluteStartTime();}       /// Like subtitlers who need that 
+                                                                                        
 protected:
             ADM_coreVideoFilter *previousFilter;
 };



From mean at mail.berlios.de  Fri Jul 23 08:00:41 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 23 Jul 2010 08:00:41 +0200
Subject: [Avidemux-svn-commit] r6475 - in branches/avidemux_2.6_branch_mean:
	avidemux/gtk/ADM_UIs/include
	avidemux/gtk/ADM_userInterfaces/ADM_dialog
	avidemux/qt4/ADM_UIs/include
	avidemux/qt4/ADM_userInterfaces/ADM_dialog
	avidemux/qt4/ADM_userInterfaces/ADM_filters
	avidemux_core/ADM_coreVideoFilter/include
	avidemux_core/ADM_coreVideoFilter/src
Message-ID: <20100723060041.16F02480E63@sheep.berlios.de>

Author: mean
Date: 2010-07-23 08:00:40 +0200 (Fri, 23 Jul 2010)
New Revision: 6475

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/include/DIA_flyDialogGtk.h
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/DIA_flyDialogQt4.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/seekablePreview.ui
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp
Log:
[flyDialog] Add a setCurrentPts function, unused most of the time by handy for preview

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/include/DIA_flyDialogGtk.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/include/DIA_flyDialogGtk.h	2010-07-23 06:00:37 UTC (rev 6474)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/include/DIA_flyDialogGtk.h	2010-07-23 06:00:40 UTC (rev 6475)
@@ -37,6 +37,7 @@
   virtual uint32_t sliderGet(void);
   virtual uint8_t  sliderSet(uint32_t value);
   virtual void    postInit(uint8_t reInit);
+  virtual bool    setCurrentPts(uint64_t  pts){return true;};
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h	2010-07-23 06:00:37 UTC (rev 6474)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h	2010-07-23 06:00:40 UTC (rev 6475)
@@ -12,6 +12,7 @@
 	flyPreview(uint32_t width, uint32_t height, void *canvas) : 
 	  ADM_flyDialogGtk(width, height, NULL, canvas, NULL, 0, RESIZE_NONE) {delete[] _rgbBuffer; _rgbBuffer = NULL;};
 	virtual ~flyPreview(void) {_rgbBuffer = NULL;};
+    bool setCurrentPts(uint64_t pts) {return 1;}
 };
 
 class flySeekablePreview : public ADM_flyDialogGtk
@@ -21,7 +22,7 @@
 	uint8_t download(void) {return 1;}
 	uint8_t upload(void) {return 1;}
 	uint8_t cleanup(void) {return 1;}
-
+    bool setCurrentPts(uint64_t pts) {return 1;}
 	flySeekablePreview(uint32_t width, uint32_t height, ADM_coreVideoFilter *videoStream, void *canvas, void *slider) : 
 	  ADM_flyDialogGtk(width, height, videoStream, canvas, slider, 0, RESIZE_AUTO) {delete[] _rgbBufferOut; _rgbBufferOut = NULL;};
 	virtual ~flySeekablePreview(void) {_rgbBufferOut = NULL;};

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/DIA_flyDialogQt4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/DIA_flyDialogQt4.h	2010-07-23 06:00:37 UTC (rev 6474)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/DIA_flyDialogQt4.h	2010-07-23 06:00:40 UTC (rev 6475)
@@ -44,6 +44,7 @@
   virtual uint32_t sliderGet(void);
   virtual uint8_t  sliderSet(uint32_t value);
   virtual void    postInit(uint8_t reInit);
+    bool          setCurrentPts(uint64_t pts) {return 1;}
 };
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h	2010-07-23 06:00:37 UTC (rev 6474)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h	2010-07-23 06:00:40 UTC (rev 6475)
@@ -14,16 +14,31 @@
 	virtual ~flyPreview(void) {_rgbBuffer = NULL;};
 };
 
+typedef bool (*CookieFunc)(void *c,uint64_t pts);
 class flySeekablePreview : public ADM_flyDialogQt4
 {
+protected:
+    void *cookie;
+    CookieFunc cookieFunc;
 public:
 	uint8_t process(void) {_rgbBufferOut = _rgbBuffer; return 1;}
 	uint8_t download(void) {return 1;}
 	uint8_t upload(void) {return 1;}
 	uint8_t cleanup(void) {return 1;}
-
+    bool    setCurrentPts(uint64_t pts)
+            {
+                if(cookieFunc)
+                    cookieFunc(cookie,pts);
+                return true;
+            }
 	flySeekablePreview(uint32_t width, uint32_t height, ADM_coreVideoFilter *videoStream, void *canvas, void *slider) : 
-	  ADM_flyDialogQt4(width, height, videoStream, canvas, slider, 0, RESIZE_AUTO) {delete[] _rgbBufferOut; _rgbBufferOut = NULL;};
+	  ADM_flyDialogQt4(width, height, videoStream, canvas, slider, 0, RESIZE_AUTO) {delete[] _rgbBufferOut; _rgbBufferOut = NULL;cookie=NULL;cookieFunc=NULL;};
 	virtual ~flySeekablePreview(void) {_rgbBufferOut = NULL;};
+    bool setCookieFunc(CookieFunc cookieFunc, void *cookie)
+        {
+                this->cookieFunc=cookieFunc;
+                this->cookie=cookie;
+                return true;
+        }
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp	2010-07-23 06:00:37 UTC (rev 6474)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp	2010-07-23 06:00:40 UTC (rev 6475)
@@ -16,7 +16,7 @@
  ***************************************************************************/
 
 #include "Q_seekablePreview.h"
-
+#include "ADM_vidMisc.h"
 Ui_seekablePreviewWindow::Ui_seekablePreviewWindow(QWidget *parent, ADM_coreVideoFilter *videoStream, uint32_t defaultFrame) : QDialog(parent)
 {
 	ui.setupUi(this);
@@ -55,7 +55,7 @@
 	canvas = new ADM_QCanvas(ui.frame, canvasWidth, canvasHeight);
 	canvas->show();
 	seekablePreview = new flySeekablePreview(canvasWidth, canvasHeight, videoStream, canvas, ui.horizontalSlider);	
-
+    seekablePreview->setCookieFunc(setCurrentPtsCallback,this);
 	seekablePreview->process();
 	seekablePreview->sliderChanged();
 }
@@ -68,4 +68,28 @@
 uint32_t Ui_seekablePreviewWindow::frameIndex()
 {
 	return seekablePreview->sliderGet();
-}
\ No newline at end of file
+}
+/**
+    \fn setCurrentPtsCallback
+    \brief callback so that the flyDialog can update its father widget
+*/
+bool Ui_seekablePreviewWindow::setCurrentPtsCallback(void *cookie,uint64_t pts)
+{
+    if(cookie)
+    {
+        return ((Ui_seekablePreviewWindow *)cookie)->setTime(pts);
+    }
+    printf("No cookie, New PTS :%"LLD" us\n",pts);
+    return true;
+}
+/**
+    \fn setTime
+    \brief Set timecode
+*/
+bool      Ui_seekablePreviewWindow::setTime(uint64_t timestamp)
+{
+    const char *s=ADM_us2plain(timestamp);
+    ui.label->setText(s);
+    return true;
+}
+// EOF
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h	2010-07-23 06:00:37 UTC (rev 6474)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h	2010-07-23 06:00:40 UTC (rev 6475)
@@ -25,7 +25,8 @@
 class Ui_seekablePreviewWindow : public QDialog
 {
 	Q_OBJECT
-
+protected:
+    static bool setCurrentPtsCallback(void *cookie,uint64_t pts);
 public:
 	ADM_QCanvas *canvas;
 	flySeekablePreview *seekablePreview;
@@ -33,7 +34,8 @@
 	Ui_seekablePreviewWindow(QWidget *parent, ADM_coreVideoFilter *videoStream, uint32_t defaultFrame = 0);
 	~Ui_seekablePreviewWindow();
 	void resetVideoStream(ADM_coreVideoFilter *videoStream);
-	uint32_t frameIndex();
+	uint32_t frameIndex();
+    bool      setTime(uint64_t timestamp);
 
 public slots:
 	void sliderChanged(int value);

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/seekablePreview.ui
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/seekablePreview.ui	2010-07-23 06:00:37 UTC (rev 6474)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/seekablePreview.ui	2010-07-23 06:00:40 UTC (rev 6475)
@@ -6,8 +6,8 @@
    <rect>
     <x>0</x>
     <y>0</y>
-    <width>400</width>
-    <height>300</height>
+    <width>441</width>
+    <height>378</height>
    </rect>
   </property>
   <property name="sizePolicy">
@@ -19,44 +19,109 @@
   <property name="windowTitle">
    <string>Preview</string>
   </property>
-  <layout class="QVBoxLayout">
-   <property name="spacing">
-    <number>6</number>
-   </property>
-   <property name="margin">
-    <number>9</number>
-   </property>
-   <item>
-    <widget class="QFrame" name="frame">
-     <property name="frameShape">
-      <enum>QFrame::StyledPanel</enum>
-     </property>
-     <property name="frameShadow">
-      <enum>QFrame::Raised</enum>
-     </property>
-    </widget>
+  <layout class="QFormLayout" name="formLayout">
+   <item row="0" column="0">
+    <layout class="QVBoxLayout" name="verticalLayout">
+     <item>
+      <layout class="QHBoxLayout" name="horizontalLayout_3">
+       <item>
+        <widget class="QFrame" name="frame">
+         <property name="minimumSize">
+          <size>
+           <width>320</width>
+           <height>240</height>
+          </size>
+         </property>
+         <property name="frameShape">
+          <enum>QFrame::StyledPanel</enum>
+         </property>
+         <property name="frameShadow">
+          <enum>QFrame::Raised</enum>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <spacer name="horizontalSpacer_3">
+         <property name="orientation">
+          <enum>Qt::Horizontal</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>40</width>
+           <height>20</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+      </layout>
+     </item>
+     <item>
+      <layout class="QHBoxLayout" name="horizontalLayout_2">
+       <item>
+        <widget class="QSlider" name="horizontalSlider">
+         <property name="orientation">
+          <enum>Qt::Horizontal</enum>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <spacer name="horizontalSpacer_2">
+         <property name="orientation">
+          <enum>Qt::Horizontal</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>40</width>
+           <height>20</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+      </layout>
+     </item>
+     <item>
+      <layout class="QHBoxLayout" name="horizontalLayout">
+       <property name="sizeConstraint">
+        <enum>QLayout::SetFixedSize</enum>
+       </property>
+       <item>
+        <widget class="QPushButton" name="next">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>next</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QLabel" name="label">
+         <property name="text">
+          <string>00:00:00.000</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <spacer name="horizontalSpacer">
+         <property name="orientation">
+          <enum>Qt::Horizontal</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>40</width>
+           <height>20</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+      </layout>
+     </item>
+    </layout>
    </item>
-   <item>
-    <widget class="QSlider" name="horizontalSlider">
-     <property name="orientation">
-      <enum>Qt::Horizontal</enum>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QPushButton" name="next">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
-       <horstretch>0</horstretch>
-       <verstretch>0</verstretch>
-      </sizepolicy>
-     </property>
-     <property name="text">
-      <string>next</string>
-     </property>
-    </widget>
-   </item>
-   <item>
+   <item row="1" column="0">
     <widget class="QDialogButtonBox" name="buttonBox">
      <property name="orientation">
       <enum>Qt::Horizontal</enum>

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h	2010-07-23 06:00:37 UTC (rev 6474)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h	2010-07-23 06:00:40 UTC (rev 6475)
@@ -68,6 +68,7 @@
 class ADM_flyDialog
 {
   protected:
+          uint64_t      _currentPts;
           uint32_t      _w, _h, _zoomW, _zoomH;
           float         _zoom;
           uint32_t      _zoomChangeCount;
@@ -102,6 +103,7 @@
   virtual uint8_t    process(void)=0;
   virtual uint8_t    download(void)=0;
   virtual uint8_t    upload(void)=0;
+  virtual bool       setCurrentPts(uint64_t pts)=0;
           /* /filter dependant */
   
         /* This is GTK/QT/whatever dependant */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp	2010-07-23 06:00:37 UTC (rev 6474)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp	2010-07-23 06:00:40 UTC (rev 6475)
@@ -64,7 +64,7 @@
 
 	_rgbBufferOut =new uint8_t [_w*_h*4];
 
-	
+	_currentPts=0;
 
 	
 }
@@ -248,7 +248,7 @@
       ADM_warning("[FlyDialog] Cannot get frame %u\n",frameNumber); 
       return 0;
     }
-
+    setCurrentPts(_yuvBuffer->Pts);
     // Process...    
     if(_isYuvProcessing)
     {



From mean at mail.berlios.de  Sun Jul 25 12:06:18 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 25 Jul 2010 12:06:18 +0200
Subject: [Avidemux-svn-commit] r6476 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	. resampleFps
Message-ID: <20100725100618.D9A2E480E6C@sheep.berlios.de>

Author: mean
Date: 2010-07-25 12:06:18 +0200 (Sun, 25 Jul 2010)
New Revision: 6476

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/ADM_vidResampleFPS.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps_desc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
Log:
[videoFilter] Dummy resample Fps

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-07-23 06:00:40 UTC (rev 6475)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-07-25 10:06:18 UTC (rev 6476)
@@ -8,3 +8,4 @@
 ADD_SUBDIRECTORY(vdpauFilters)
 ADD_SUBDIRECTORY(addBorder)
 ADD_SUBDIRECTORY(swapUV)
+ADD_SUBDIRECTORY(resampleFps)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/ADM_vidResampleFPS.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/ADM_vidResampleFPS.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/ADM_vidResampleFPS.cpp	2010-07-25 10:06:18 UTC (rev 6476)
@@ -0,0 +1,241 @@
+/***************************************************************************
+                          Resample fps
+                             -------------------
+    begin                : Wed Nov 6 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <math.h>
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "DIA_coreToolkit.h"
+#include "DIA_factory.h"
+
+#include "confResampleFps.h"
+#include "confResampleFps_desc.cpp"
+/**
+    \class resampleFps
+
+*/
+class  resampleFps:public ADM_coreVideoFilter
+{
+protected:
+        confResampleFps     configuration;
+        bool                updateIncrement(void);
+public:
+                            resampleFps(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                            ~resampleFps();
+
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+};
+//***********************************
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   resampleFps,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_TRANSFORM,            // Category
+                        "resampleFps",            // internal name (must be uniq!)
+                        "Resample FPS",            // Display name
+                        "Change and enforce FPS. Keep duration and sync." // Description
+                    );
+/**
+    \fn configure
+*/
+bool resampleFps::configure(void)
+{
+  float f=configuration.newFps; 
+  f/=1000;
+  
+  
+    diaElemFloat fps(&f,QT_TR_NOOP("_New frame rate:"),1,200.);
+    
+    diaElem *elems[1]={&fps};
+  
+    if( diaFactoryRun(QT_TR_NOOP("Resample fps"),1,elems))
+    {
+        f*=1000;
+      configuration.newFps=(uint32_t)floor(f+0.4);
+      updateIncrement();
+      return 1;
+    }
+    return 0;
+}
+/**
+    \fn updateIncrement
+    \brief FPS->TimeIncrement
+*/
+bool resampleFps::updateIncrement(void)
+{
+
+}
+/**
+    \fn getConfiguration
+*/
+const char *resampleFps::getConfiguration( void )
+{
+static char buf[100];
+ snprintf(buf,99," Resample to %2.2f fps",(double)configuration.newFps/1000.);
+ return buf;  
+}
+/**
+    \fn ctor
+*/
+resampleFps::resampleFps(  ADM_coreVideoFilter *previous,CONFcouple *setup) : ADM_coreVideoFilter(previous,setup)
+{
+    if(!setup || !ADM_paramLoad(setup,confResampleFps_param,&configuration))
+    {
+        // Default value
+#warning todo get fps from increment
+        configuration.newFps=25000;
+    }
+    updateIncrement();
+}
+/**
+    \fn dtor
+
+*/
+resampleFps::~resampleFps()
+{
+  
+}
+/**
+    \fn getCoupledConf
+*/ 
+bool         resampleFps::getCoupledConf(CONFcouple **couples)
+{
+    return ADM_paramSave(couples, confResampleFps_param,&configuration);
+}
+/**
+    \fn getNextFrame
+*/
+ bool         resampleFps::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    return false;
+#if 0
+  ADMImage *mysrc1=NULL;
+  ADMImage *mysrc2=NULL;
+
+  if(frame>=_info.nb_frames) return 0;
+  // read uncompressed frame
+  
+  // What frame are we seeking ?
+  double f;
+  uint32_t page=_info.width*_info.height;
+  
+  f=frame;
+  f*=_in->getInfo()->fps1000;
+  f/=_param->newfps;
+  
+  if(!_param->use_linear)
+  {
+      uint32_t nw;
+      
+      nw=(uint32_t)floor(f+0.4);
+      if(nw>_in->getInfo()->nb_frames-1)
+        nw=_in->getInfo()->nb_frames-1;
+    
+      mysrc1=vidCache->getImage(nw);
+      if(!mysrc1) return 0;
+      
+      memcpy(YPLANE(data),YPLANE(mysrc1),page);
+      memcpy(UPLANE(data),UPLANE(mysrc1),page>>2);
+      memcpy(VPLANE(data),VPLANE(mysrc1),page>>2);
+    
+      vidCache->unlockAll();
+      
+      return 1;
+  }
+  /* With linear blending */
+  uint32_t nw;
+  uint8_t lowweight;
+  uint8_t highweight;
+  
+  double diff;
+  
+  nw=(uint32_t)floor(f);
+  diff=f-floor(f);
+  highweight = (uint8_t)floor(diff*256);
+  lowweight = 256 - highweight;
+
+  if(nw>=_in->getInfo()->nb_frames-1)
+    {
+      printf("[ResampleFps] In %u Out %u\n",frame,nw);
+      nw=_in->getInfo()->nb_frames-1;
+      highweight=0;
+    }
+  //printf("New:%lu old:%lu\n",frame,nw);
+
+  if(highweight == 0)
+    {
+      mysrc1=vidCache->getImage(nw);  
+      if(!mysrc1) return 0;
+      
+      memcpy(YPLANE(data),YPLANE(mysrc1),page);
+      memcpy(UPLANE(data),UPLANE(mysrc1),page>>2);
+      memcpy(VPLANE(data),VPLANE(mysrc1),page>>2);
+      
+      vidCache->unlockAll();
+    }
+  else
+    {
+      mysrc1=vidCache->getImage(nw);
+      mysrc2=vidCache->getImage(nw+1);
+      if(!mysrc1 || !mysrc2) return 0;
+      
+      uint8_t *out, *in1, *in2;
+      uint32_t count;
+      uint32_t idx;
+      
+      out = YPLANE(data);
+      in1 = YPLANE(mysrc1);
+      in2 = YPLANE(mysrc2);
+        
+      count = page;
+
+#ifdef ADM_CPU_X86
+        if(CpuCaps::hasMMX())
+                blendMMX(in1,in2,out,lowweight,highweight,(count*3)>>1);
+        else
+#endif
+      {
+      for(idx = 0; idx < count; ++idx)
+	out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))>>8;
+
+      out = UPLANE(data);
+      in1 = UPLANE(mysrc1);
+      in2 = UPLANE(mysrc2);
+      count = page>>2;
+
+      for(idx = 0; idx < count; ++idx)
+        out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))>>8;      
+
+
+      out = VPLANE(data);
+      in1 = VPLANE(mysrc1);
+      in2 = VPLANE(mysrc2);
+      count = page>>2;
+
+      for(idx = 0; idx < count; ++idx)
+	out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))>>8;
+      }
+
+      vidCache->unlockAll();
+    }
+  return 1;
+#endif 
+}
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/CMakeLists.txt	2010-07-25 10:06:18 UTC (rev 6476)
@@ -0,0 +1,8 @@
+INCLUDE(vf_plugin)
+
+SET(ADM_vf_resampleFps_SRCS ADM_vidResampleFPS.cpp)
+
+ADD_VIDEO_FILTER(ADM_vf_resampleFps ${ADM_vf_resampleFps_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_resampleFps)
+INSTALL_VIDEO_FILTER(ADM_vf_resampleFps)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps.conf	2010-07-25 10:06:18 UTC (rev 6476)
@@ -0,0 +1 @@
+uint32_t:newFps

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps.h	2010-07-25 10:06:18 UTC (rev 6476)
@@ -0,0 +1,8 @@
+// Automatically generated, do not edit!
+#ifndef ADM_confResampleFps_CONF_H
+#define ADM_confResampleFps_CONF_H
+typedef struct {
+   uint32_t newFps;
+}confResampleFps;
+#endif //confResampleFps
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps/confResampleFps_desc.cpp	2010-07-25 10:06:18 UTC (rev 6476)
@@ -0,0 +1,5 @@
+// Automatically generated, do not edit!
+const ADM_paramList confResampleFps_param[]={
+ {"newFps",offsetof( confResampleFps,newFps),"uint32_t",ADM_param_uint32_t},
+{NULL,0,NULL}
+};



From mean at mail.berlios.de  Sun Jul 25 12:07:39 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 25 Jul 2010 12:07:39 +0200
Subject: [Avidemux-svn-commit] r6478 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:
	libavcodec libavcodec/x86 libavutil
Message-ID: <20100725100739.8F4B4480E6C@sheep.berlios.de>

Author: mean
Date: 2010-07-25 12:07:39 +0200 (Sun, 25 Jul 2010)
New Revision: 6478

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen_decl.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dct32.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dxva2_mpeg2.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8_parser.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8data.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/dct32_sse.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/h264_intrapred.asm
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mpegaudiodec_mmx.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vc1dsp_yasm.asm
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp56_arith.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp-init.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp.asm
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/colorspace.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.h
Log:
[ff] Import 25 July 2010

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,37 @@
+/*
+ * Generate a header file for hardcoded AAC tables
+ *
+ * Copyright (c) 2010 Alex Converse <alex.converse at gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdlib.h>
+#define CONFIG_HARDCODED_TABLES 0
+#include "aac_tablegen.h"
+#include "tableprint.h"
+
+int main(void)
+{
+    ff_aac_tableinit();
+
+    write_fileheader();
+
+    WRITE_ARRAY("const", float, ff_aac_pow2sf_tab);
+
+    return 0;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,42 @@
+/*
+ * Header file for hardcoded AAC tables
+ *
+ * Copyright (c) 2010 Alex Converse <alex.converse at gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AAC_TABLEGEN_H
+#define AAC_TABLEGEN_H
+
+#include "aac_tablegen_decl.h"
+
+#if CONFIG_HARDCODED_TABLES
+#include "libavcodec/aac_tables.h"
+#else
+#include "libavutil/mathematics.h"
+float ff_aac_pow2sf_tab[428];
+
+void ff_aac_tableinit(void)
+{
+    int i;
+    for (i = 0; i < 428; i++)
+        ff_aac_pow2sf_tab[i] = pow(2, (i - 200) / 4.);
+}
+#endif /* CONFIG_HARDCODED_TABLES */
+
+#endif /* AAC_TABLEGEN_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen_decl.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen_decl.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen_decl.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,34 @@
+/*
+ * Header file for hardcoded AAC tables
+ *
+ * Copyright (c) 2010 Alex Converse <alex.converse at gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AAC_TABLEGEN_INIT_H
+#define AAC_TABLEGEN_INIT_H
+
+#if CONFIG_HARDCODED_TABLES
+#define ff_aac_tableinit()
+extern const float ff_aac_pow2sf_tab[428];
+#else
+void ff_aac_tableinit(void);
+extern       float ff_aac_pow2sf_tab[428];
+#endif /* CONFIG_HARDCODED_TABLES */
+
+#endif /* AAC_TABLEGEN_INIT_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,70 @@
+/*
+ * Audio and Video frame extraction
+ * Copyright (c) 2003 Fabrice Bellard
+ * Copyright (c) 2003 Michael Niedermayer
+ * Copyright (c) 2009 Alex Converse
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "aac_ac3_parser.h"
+#include "aacadtsdec.h"
+#include "get_bits.h"
+#include "mpeg4audio.h"
+
+int ff_aac_parse_header(GetBitContext *gbc, AACADTSHeaderInfo *hdr)
+{
+    int size, rdb, ch, sr;
+    int aot, crc_abs;
+
+    if(get_bits(gbc, 12) != 0xfff)
+        return AAC_AC3_PARSE_ERROR_SYNC;
+
+    skip_bits1(gbc);             /* id */
+    skip_bits(gbc, 2);           /* layer */
+    crc_abs = get_bits1(gbc);    /* protection_absent */
+    aot     = get_bits(gbc, 2);  /* profile_objecttype */
+    sr      = get_bits(gbc, 4);  /* sample_frequency_index */
+    if(!ff_mpeg4audio_sample_rates[sr])
+        return AAC_AC3_PARSE_ERROR_SAMPLE_RATE;
+    skip_bits1(gbc);             /* private_bit */
+    ch      = get_bits(gbc, 3);  /* channel_configuration */
+
+    skip_bits1(gbc);             /* original/copy */
+    skip_bits1(gbc);             /* home */
+
+    /* adts_variable_header */
+    skip_bits1(gbc);             /* copyright_identification_bit */
+    skip_bits1(gbc);             /* copyright_identification_start */
+    size    = get_bits(gbc, 13); /* aac_frame_length */
+    if(size < AAC_ADTS_HEADER_SIZE)
+        return AAC_AC3_PARSE_ERROR_FRAME_SIZE;
+
+    skip_bits(gbc, 11);          /* adts_buffer_fullness */
+    rdb = get_bits(gbc, 2);      /* number_of_raw_data_blocks_in_frame */
+
+    hdr->object_type    = aot + 1;
+    hdr->chan_config    = ch;
+    hdr->crc_absent     = crc_abs;
+    hdr->num_aac_frames = rdb + 1;
+    hdr->sampling_index = sr;
+    hdr->sample_rate    = ff_mpeg4audio_sample_rates[sr];
+    hdr->samples        = (rdb + 1) * 1024;
+    hdr->bit_rate       = size * 8 * hdr->sample_rate / hdr->samples;
+
+    return size;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,54 @@
+/*
+ * AAC ADTS header decoding prototypes and structures
+ * Copyright (c) 2003 Fabrice Bellard
+ * Copyright (c) 2003 Michael Niedermayer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_AACADTSDEC_H
+#define AVCODEC_AACADTSDEC_H
+
+#include <stdint.h>
+#include "get_bits.h"
+
+#define AAC_ADTS_HEADER_SIZE 7
+
+typedef struct {
+    uint32_t sample_rate;
+    uint32_t samples;
+    uint32_t bit_rate;
+    uint8_t  crc_absent;
+    uint8_t  object_type;
+    uint8_t  sampling_index;
+    uint8_t  chan_config;
+    uint8_t  num_aac_frames;
+} AACADTSHeaderInfo;
+
+/**
+ * Parse AAC frame header.
+ * Parse the ADTS frame header to the end of the variable header, which is
+ * the first 54 bits.
+ * @param[in]  gbc BitContext containing the first 54 bits of the frame.
+ * @param[out] hdr Pointer to struct where header info is written.
+ * @return Returns 0 on success, -1 if there is a sync word mismatch,
+ * -2 if the version element is invalid, -3 if the sample rate
+ * element is invalid, or -4 if the bit rate element is invalid.
+ */
+int ff_aac_parse_header(GetBitContext *gbc, AACADTSHeaderInfo *hdr);
+
+#endif /* AVCODEC_AACADTSDEC_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacdec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacdec.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,2109 @@
+/*
+ * AAC decoder
+ * Copyright (c) 2005-2006 Oded Shimon ( ods15 ods15 dyndns org )
+ * Copyright (c) 2006-2007 Maxim Gavrilov ( maxim.gavrilov gmail com )
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * AAC decoder
+ * @author Oded Shimon  ( ods15 ods15 dyndns org )
+ * @author Maxim Gavrilov ( maxim.gavrilov gmail com )
+ */
+
+/*
+ * supported tools
+ *
+ * Support?             Name
+ * N (code in SoC repo) gain control
+ * Y                    block switching
+ * Y                    window shapes - standard
+ * N                    window shapes - Low Delay
+ * Y                    filterbank - standard
+ * N (code in SoC repo) filterbank - Scalable Sample Rate
+ * Y                    Temporal Noise Shaping
+ * N (code in SoC repo) Long Term Prediction
+ * Y                    intensity stereo
+ * Y                    channel coupling
+ * Y                    frequency domain prediction
+ * Y                    Perceptual Noise Substitution
+ * Y                    Mid/Side stereo
+ * N                    Scalable Inverse AAC Quantization
+ * N                    Frequency Selective Switch
+ * N                    upsampling filter
+ * Y                    quantization & coding - AAC
+ * N                    quantization & coding - TwinVQ
+ * N                    quantization & coding - BSAC
+ * N                    AAC Error Resilience tools
+ * N                    Error Resilience payload syntax
+ * N                    Error Protection tool
+ * N                    CELP
+ * N                    Silence Compression
+ * N                    HVXC
+ * N                    HVXC 4kbits/s VR
+ * N                    Structured Audio tools
+ * N                    Structured Audio Sample Bank Format
+ * N                    MIDI
+ * N                    Harmonic and Individual Lines plus Noise
+ * N                    Text-To-Speech Interface
+ * Y                    Spectral Band Replication
+ * Y (not in this code) Layer-1
+ * Y (not in this code) Layer-2
+ * Y (not in this code) Layer-3
+ * N                    SinuSoidal Coding (Transient, Sinusoid, Noise)
+ * Y                    Parametric Stereo
+ * N                    Direct Stream Transfer
+ *
+ * Note: - HE AAC v1 comprises LC AAC with Spectral Band Replication.
+ *       - HE AAC v2 comprises LC AAC with Spectral Band Replication and
+           Parametric Stereo.
+ */
+
+
+#include "avcodec.h"
+#include "internal.h"
+#include "get_bits.h"
+#include "dsputil.h"
+#include "fft.h"
+#include "lpc.h"
+
+#include "aac.h"
+#include "aactab.h"
+#include "aacdectab.h"
+#include "cbrt_tablegen.h"
+#include "sbr.h"
+#include "aacsbr.h"
+#include "mpeg4audio.h"
+#include "aacadtsdec.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <math.h>
+#include <string.h>
+
+#if ARCH_ARM
+#   include "arm/aac.h"
+#endif
+
+union float754 {
+    float f;
+    uint32_t i;
+};
+
+static VLC vlc_scalefactors;
+static VLC vlc_spectral[11];
+
+static const char overread_err[] = "Input buffer exhausted before END element found\n";
+
+static ChannelElement *get_che(AACContext *ac, int type, int elem_id)
+{
+    /* Some buggy encoders appear to set all elem_ids to zero and rely on
+    channels always occurring in the same order. This is expressly forbidden
+    by the spec but we will try to work around it.
+    */
+    int err_printed = 0;
+    while (ac->tags_seen_this_frame[type][elem_id] && elem_id < MAX_ELEM_ID) {
+        if (ac->output_configured < OC_LOCKED && !err_printed) {
+            av_log(ac->avctx, AV_LOG_WARNING, "Duplicate channel tag found, attempting to remap.\n");
+            err_printed = 1;
+        }
+        elem_id++;
+    }
+    if (elem_id == MAX_ELEM_ID)
+        return NULL;
+    ac->tags_seen_this_frame[type][elem_id] = 1;
+
+    if (ac->tag_che_map[type][elem_id]) {
+        return ac->tag_che_map[type][elem_id];
+    }
+    if (ac->tags_mapped >= tags_per_config[ac->m4ac.chan_config]) {
+        return NULL;
+    }
+    switch (ac->m4ac.chan_config) {
+    case 7:
+        if (ac->tags_mapped == 3 && type == TYPE_CPE) {
+            ac->tags_mapped++;
+            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][2];
+        }
+    case 6:
+        /* Some streams incorrectly code 5.1 audio as SCE[0] CPE[0] CPE[1] SCE[1]
+           instead of SCE[0] CPE[0] CPE[1] LFE[0]. If we seem to have
+           encountered such a stream, transfer the LFE[0] element to the SCE[1]'s mapping */
+        if (ac->tags_mapped == tags_per_config[ac->m4ac.chan_config] - 1 && (type == TYPE_LFE || type == TYPE_SCE)) {
+            ac->tags_mapped++;
+            return ac->tag_che_map[type][elem_id] = ac->che[TYPE_LFE][0];
+        }
+    case 5:
+        if (ac->tags_mapped == 2 && type == TYPE_CPE) {
+            ac->tags_mapped++;
+            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][1];
+        }
+    case 4:
+        if (ac->tags_mapped == 2 && ac->m4ac.chan_config == 4 && type == TYPE_SCE) {
+            ac->tags_mapped++;
+            return ac->tag_che_map[TYPE_SCE][elem_id] = ac->che[TYPE_SCE][1];
+        }
+    case 3:
+    case 2:
+        if (ac->tags_mapped == (ac->m4ac.chan_config != 2) && type == TYPE_CPE) {
+            ac->tags_mapped++;
+            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][0];
+        } else if (ac->m4ac.chan_config == 2) {
+            return NULL;
+        }
+    case 1:
+        if (!ac->tags_mapped && type == TYPE_SCE) {
+            ac->tags_mapped++;
+            return ac->tag_che_map[TYPE_SCE][elem_id] = ac->che[TYPE_SCE][0];
+        }
+    default:
+        return NULL;
+    }
+}
+
+/**
+ * Check for the channel element in the current channel position configuration.
+ * If it exists, make sure the appropriate element is allocated and map the
+ * channel order to match the internal FFmpeg channel layout.
+ *
+ * @param   che_pos current channel position configuration
+ * @param   type channel element type
+ * @param   id channel element id
+ * @param   channels count of the number of channels in the configuration
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static av_cold int che_configure(AACContext *ac,
+                         enum ChannelPosition che_pos[4][MAX_ELEM_ID],
+                         int type, int id,
+                         int *channels)
+{
+    if (che_pos[type][id]) {
+        if (!ac->che[type][id] && !(ac->che[type][id] = av_mallocz(sizeof(ChannelElement))))
+            return AVERROR(ENOMEM);
+        ff_aac_sbr_ctx_init(&ac->che[type][id]->sbr);
+        if (type != TYPE_CCE) {
+            ac->output_data[(*channels)++] = ac->che[type][id]->ch[0].ret;
+            if (type == TYPE_CPE ||
+                (type == TYPE_SCE && ac->m4ac.ps == 1)) {
+                ac->output_data[(*channels)++] = ac->che[type][id]->ch[1].ret;
+            }
+        }
+    } else {
+        if (ac->che[type][id])
+            ff_aac_sbr_ctx_close(&ac->che[type][id]->sbr);
+        av_freep(&ac->che[type][id]);
+    }
+    return 0;
+}
+
+/**
+ * Configure output channel order based on the current program configuration element.
+ *
+ * @param   che_pos current channel position configuration
+ * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static av_cold int output_configure(AACContext *ac,
+                            enum ChannelPosition che_pos[4][MAX_ELEM_ID],
+                            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
+                            int channel_config, enum OCStatus oc_type)
+{
+    AVCodecContext *avctx = ac->avctx;
+    int i, type, channels = 0, ret;
+
+    if (new_che_pos != che_pos)
+    memcpy(che_pos, new_che_pos, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
+
+    if (channel_config) {
+        for (i = 0; i < tags_per_config[channel_config]; i++) {
+            if ((ret = che_configure(ac, che_pos,
+                                     aac_channel_layout_map[channel_config - 1][i][0],
+                                     aac_channel_layout_map[channel_config - 1][i][1],
+                                     &channels)))
+                return ret;
+        }
+
+        memset(ac->tag_che_map, 0,       4 * MAX_ELEM_ID * sizeof(ac->che[0][0]));
+        ac->tags_mapped = 0;
+
+        avctx->channel_layout = aac_channel_layout[channel_config - 1];
+    } else {
+        /* Allocate or free elements depending on if they are in the
+         * current program configuration.
+         *
+         * Set up default 1:1 output mapping.
+         *
+         * For a 5.1 stream the output order will be:
+         *    [ Center ] [ Front Left ] [ Front Right ] [ LFE ] [ Surround Left ] [ Surround Right ]
+         */
+
+        for (i = 0; i < MAX_ELEM_ID; i++) {
+            for (type = 0; type < 4; type++) {
+                if ((ret = che_configure(ac, che_pos, type, i, &channels)))
+                    return ret;
+            }
+        }
+
+        memcpy(ac->tag_che_map, ac->che, 4 * MAX_ELEM_ID * sizeof(ac->che[0][0]));
+        ac->tags_mapped = 4 * MAX_ELEM_ID;
+
+        avctx->channel_layout = 0;
+    }
+
+    avctx->channels = channels;
+
+    ac->output_configured = oc_type;
+
+    return 0;
+}
+
+/**
+ * Decode an array of 4 bit element IDs, optionally interleaved with a stereo/mono switching bit.
+ *
+ * @param cpe_map Stereo (Channel Pair Element) map, NULL if stereo bit is not present.
+ * @param sce_map mono (Single Channel Element) map
+ * @param type speaker type/position for these channels
+ */
+static void decode_channel_map(enum ChannelPosition *cpe_map,
+                               enum ChannelPosition *sce_map,
+                               enum ChannelPosition type,
+                               GetBitContext *gb, int n)
+{
+    while (n--) {
+        enum ChannelPosition *map = cpe_map && get_bits1(gb) ? cpe_map : sce_map; // stereo or mono map
+        map[get_bits(gb, 4)] = type;
+    }
+}
+
+/**
+ * Decode program configuration element; reference: table 4.2.
+ *
+ * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_pce(AACContext *ac, enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
+                      GetBitContext *gb)
+{
+    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;
+    int comment_len;
+
+    skip_bits(gb, 2);  // object_type
+
+    sampling_index = get_bits(gb, 4);
+    if (ac->m4ac.sampling_index != sampling_index)
+        av_log(ac->avctx, AV_LOG_WARNING, "Sample rate index in program config element does not match the sample rate index configured by the container.\n");
+
+    num_front       = get_bits(gb, 4);
+    num_side        = get_bits(gb, 4);
+    num_back        = get_bits(gb, 4);
+    num_lfe         = get_bits(gb, 2);
+    num_assoc_data  = get_bits(gb, 3);
+    num_cc          = get_bits(gb, 4);
+
+    if (get_bits1(gb))
+        skip_bits(gb, 4); // mono_mixdown_tag
+    if (get_bits1(gb))
+        skip_bits(gb, 4); // stereo_mixdown_tag
+
+    if (get_bits1(gb))
+        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround
+
+    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);
+    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );
+    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );
+    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );
+
+    skip_bits_long(gb, 4 * num_assoc_data);
+
+    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );
+
+    align_get_bits(gb);
+
+    /* comment field, first byte is length */
+    comment_len = get_bits(gb, 8) * 8;
+    if (get_bits_left(gb) < comment_len) {
+        av_log(ac->avctx, AV_LOG_ERROR, overread_err);
+        return -1;
+    }
+    skip_bits_long(gb, comment_len);
+    return 0;
+}
+
+/**
+ * Set up channel positions based on a default channel configuration
+ * as specified in table 1.17.
+ *
+ * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static av_cold int set_default_channel_config(AACContext *ac,
+                                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
+                                      int channel_config)
+{
+    if (channel_config < 1 || channel_config > 7) {
+        av_log(ac->avctx, AV_LOG_ERROR, "invalid default channel configuration (%d)\n",
+               channel_config);
+        return -1;
+    }
+
+    /* default channel configurations:
+     *
+     * 1ch : front center (mono)
+     * 2ch : L + R (stereo)
+     * 3ch : front center + L + R
+     * 4ch : front center + L + R + back center
+     * 5ch : front center + L + R + back stereo
+     * 6ch : front center + L + R + back stereo + LFE
+     * 7ch : front center + L + R + outer front left + outer front right + back stereo + LFE
+     */
+
+    if (channel_config != 2)
+        new_che_pos[TYPE_SCE][0] = AAC_CHANNEL_FRONT; // front center (or mono)
+    if (channel_config > 1)
+        new_che_pos[TYPE_CPE][0] = AAC_CHANNEL_FRONT; // L + R (or stereo)
+    if (channel_config == 4)
+        new_che_pos[TYPE_SCE][1] = AAC_CHANNEL_BACK;  // back center
+    if (channel_config > 4)
+        new_che_pos[TYPE_CPE][(channel_config == 7) + 1]
+        = AAC_CHANNEL_BACK;  // back stereo
+    if (channel_config > 5)
+        new_che_pos[TYPE_LFE][0] = AAC_CHANNEL_LFE;   // LFE
+    if (channel_config == 7)
+        new_che_pos[TYPE_CPE][1] = AAC_CHANNEL_FRONT; // outer front left + outer front right
+
+    return 0;
+}
+
+/**
+ * Decode GA "General Audio" specific configuration; reference: table 4.1.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_ga_specific_config(AACContext *ac, GetBitContext *gb,
+                                     int channel_config)
+{
+    enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
+    int extension_flag, ret;
+
+    if (get_bits1(gb)) { // frameLengthFlag
+        av_log_missing_feature(ac->avctx, "960/120 MDCT window is", 1);
+        return -1;
+    }
+
+    if (get_bits1(gb))       // dependsOnCoreCoder
+        skip_bits(gb, 14);   // coreCoderDelay
+    extension_flag = get_bits1(gb);
+
+    if (ac->m4ac.object_type == AOT_AAC_SCALABLE ||
+        ac->m4ac.object_type == AOT_ER_AAC_SCALABLE)
+        skip_bits(gb, 3);     // layerNr
+
+    memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
+    if (channel_config == 0) {
+        skip_bits(gb, 4);  // element_instance_tag
+        if ((ret = decode_pce(ac, new_che_pos, gb)))
+            return ret;
+    } else {
+        if ((ret = set_default_channel_config(ac, new_che_pos, channel_config)))
+            return ret;
+    }
+    if ((ret = output_configure(ac, ac->che_pos, new_che_pos, channel_config, OC_GLOBAL_HDR)))
+        return ret;
+
+    if (extension_flag) {
+        switch (ac->m4ac.object_type) {
+        case AOT_ER_BSAC:
+            skip_bits(gb, 5);    // numOfSubFrame
+            skip_bits(gb, 11);   // layer_length
+            break;
+        case AOT_ER_AAC_LC:
+        case AOT_ER_AAC_LTP:
+        case AOT_ER_AAC_SCALABLE:
+        case AOT_ER_AAC_LD:
+            skip_bits(gb, 3);  /* aacSectionDataResilienceFlag
+                                    * aacScalefactorDataResilienceFlag
+                                    * aacSpectralDataResilienceFlag
+                                    */
+            break;
+        }
+        skip_bits1(gb);    // extensionFlag3 (TBD in version 3)
+    }
+    return 0;
+}
+
+/**
+ * Decode audio specific configuration; reference: table 1.13.
+ *
+ * @param   data        pointer to AVCodecContext extradata
+ * @param   data_size   size of AVCCodecContext extradata
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_audio_specific_config(AACContext *ac, void *data,
+                                        int data_size)
+{
+    GetBitContext gb;
+    int i;
+
+    init_get_bits(&gb, data, data_size * 8);
+
+    if ((i = ff_mpeg4audio_get_config(&ac->m4ac, data, data_size)) < 0)
+        return -1;
+    if (ac->m4ac.sampling_index > 12) {
+        av_log(ac->avctx, AV_LOG_ERROR, "invalid sampling rate index %d\n", ac->m4ac.sampling_index);
+        return -1;
+    }
+    if (ac->m4ac.sbr == 1 && ac->m4ac.ps == -1)
+        ac->m4ac.ps = 1;
+
+    skip_bits_long(&gb, i);
+
+    switch (ac->m4ac.object_type) {
+    case AOT_AAC_MAIN:
+    case AOT_AAC_LC:
+        if (decode_ga_specific_config(ac, &gb, ac->m4ac.chan_config))
+            return -1;
+        break;
+    default:
+        av_log(ac->avctx, AV_LOG_ERROR, "Audio object type %s%d is not supported.\n",
+               ac->m4ac.sbr == 1? "SBR+" : "", ac->m4ac.object_type);
+        return -1;
+    }
+    return 0;
+}
+
+/**
+ * linear congruential pseudorandom number generator
+ *
+ * @param   previous_val    pointer to the current state of the generator
+ *
+ * @return  Returns a 32-bit pseudorandom integer
+ */
+static av_always_inline int lcg_random(int previous_val)
+{
+    return previous_val * 1664525 + 1013904223;
+}
+
+static av_always_inline void reset_predict_state(PredictorState *ps)
+{
+    ps->r0   = 0.0f;
+    ps->r1   = 0.0f;
+    ps->cor0 = 0.0f;
+    ps->cor1 = 0.0f;
+    ps->var0 = 1.0f;
+    ps->var1 = 1.0f;
+}
+
+static void reset_all_predictors(PredictorState *ps)
+{
+    int i;
+    for (i = 0; i < MAX_PREDICTORS; i++)
+        reset_predict_state(&ps[i]);
+}
+
+static void reset_predictor_group(PredictorState *ps, int group_num)
+{
+    int i;
+    for (i = group_num - 1; i < MAX_PREDICTORS; i += 30)
+        reset_predict_state(&ps[i]);
+}
+
+#define AAC_INIT_VLC_STATIC(num, size) \
+    INIT_VLC_STATIC(&vlc_spectral[num], 8, ff_aac_spectral_sizes[num], \
+         ff_aac_spectral_bits[num], sizeof( ff_aac_spectral_bits[num][0]), sizeof( ff_aac_spectral_bits[num][0]), \
+        ff_aac_spectral_codes[num], sizeof(ff_aac_spectral_codes[num][0]), sizeof(ff_aac_spectral_codes[num][0]), \
+        size);
+
+static av_cold int aac_decode_init(AVCodecContext *avctx)
+{
+    AACContext *ac = avctx->priv_data;
+
+    ac->avctx = avctx;
+    ac->m4ac.sample_rate = avctx->sample_rate;
+
+    if (avctx->extradata_size > 0) {
+        if (decode_audio_specific_config(ac, avctx->extradata, avctx->extradata_size))
+            return -1;
+    }
+
+    avctx->sample_fmt = SAMPLE_FMT_S16;
+
+    AAC_INIT_VLC_STATIC( 0, 304);
+    AAC_INIT_VLC_STATIC( 1, 270);
+    AAC_INIT_VLC_STATIC( 2, 550);
+    AAC_INIT_VLC_STATIC( 3, 300);
+    AAC_INIT_VLC_STATIC( 4, 328);
+    AAC_INIT_VLC_STATIC( 5, 294);
+    AAC_INIT_VLC_STATIC( 6, 306);
+    AAC_INIT_VLC_STATIC( 7, 268);
+    AAC_INIT_VLC_STATIC( 8, 510);
+    AAC_INIT_VLC_STATIC( 9, 366);
+    AAC_INIT_VLC_STATIC(10, 462);
+
+    ff_aac_sbr_init();
+
+    dsputil_init(&ac->dsp, avctx);
+
+    ac->random_state = 0x1f2e3d4c;
+
+    // -1024 - Compensate wrong IMDCT method.
+    // 32768 - Required to scale values to the correct range for the bias method
+    //         for float to int16 conversion.
+
+    if (ac->dsp.float_to_int16_interleave == ff_float_to_int16_interleave_c) {
+        ac->add_bias  = 385.0f;
+        ac->sf_scale  = 1. / (-1024. * 32768.);
+        ac->sf_offset = 0;
+    } else {
+        ac->add_bias  = 0.0f;
+        ac->sf_scale  = 1. / -1024.;
+        ac->sf_offset = 60;
+    }
+
+    ff_aac_tableinit();
+
+    INIT_VLC_STATIC(&vlc_scalefactors,7,FF_ARRAY_ELEMS(ff_aac_scalefactor_code),
+                    ff_aac_scalefactor_bits, sizeof(ff_aac_scalefactor_bits[0]), sizeof(ff_aac_scalefactor_bits[0]),
+                    ff_aac_scalefactor_code, sizeof(ff_aac_scalefactor_code[0]), sizeof(ff_aac_scalefactor_code[0]),
+                    352);
+
+    ff_mdct_init(&ac->mdct, 11, 1, 1.0);
+    ff_mdct_init(&ac->mdct_small, 8, 1, 1.0);
+    // window initialization
+    ff_kbd_window_init(ff_aac_kbd_long_1024, 4.0, 1024);
+    ff_kbd_window_init(ff_aac_kbd_short_128, 6.0, 128);
+    ff_init_ff_sine_windows(10);
+    ff_init_ff_sine_windows( 7);
+
+    cbrt_tableinit();
+
+    return 0;
+}
+
+/**
+ * Skip data_stream_element; reference: table 4.10.
+ */
+static int skip_data_stream_element(AACContext *ac, GetBitContext *gb)
+{
+    int byte_align = get_bits1(gb);
+    int count = get_bits(gb, 8);
+    if (count == 255)
+        count += get_bits(gb, 8);
+    if (byte_align)
+        align_get_bits(gb);
+
+    if (get_bits_left(gb) < 8 * count) {
+        av_log(ac->avctx, AV_LOG_ERROR, overread_err);
+        return -1;
+    }
+    skip_bits_long(gb, 8 * count);
+    return 0;
+}
+
+static int decode_prediction(AACContext *ac, IndividualChannelStream *ics,
+                             GetBitContext *gb)
+{
+    int sfb;
+    if (get_bits1(gb)) {
+        ics->predictor_reset_group = get_bits(gb, 5);
+        if (ics->predictor_reset_group == 0 || ics->predictor_reset_group > 30) {
+            av_log(ac->avctx, AV_LOG_ERROR, "Invalid Predictor Reset Group.\n");
+            return -1;
+        }
+    }
+    for (sfb = 0; sfb < FFMIN(ics->max_sfb, ff_aac_pred_sfb_max[ac->m4ac.sampling_index]); sfb++) {
+        ics->prediction_used[sfb] = get_bits1(gb);
+    }
+    return 0;
+}
+
+/**
+ * Decode Individual Channel Stream info; reference: table 4.6.
+ *
+ * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
+ */
+static int decode_ics_info(AACContext *ac, IndividualChannelStream *ics,
+                           GetBitContext *gb, int common_window)
+{
+    if (get_bits1(gb)) {
+        av_log(ac->avctx, AV_LOG_ERROR, "Reserved bit set.\n");
+        memset(ics, 0, sizeof(IndividualChannelStream));
+        return -1;
+    }
+    ics->window_sequence[1] = ics->window_sequence[0];
+    ics->window_sequence[0] = get_bits(gb, 2);
+    ics->use_kb_window[1]   = ics->use_kb_window[0];
+    ics->use_kb_window[0]   = get_bits1(gb);
+    ics->num_window_groups  = 1;
+    ics->group_len[0]       = 1;
+    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+        int i;
+        ics->max_sfb = get_bits(gb, 4);
+        for (i = 0; i < 7; i++) {
+            if (get_bits1(gb)) {
+                ics->group_len[ics->num_window_groups - 1]++;
+            } else {
+                ics->num_window_groups++;
+                ics->group_len[ics->num_window_groups - 1] = 1;
+            }
+        }
+        ics->num_windows       = 8;
+        ics->swb_offset        =    ff_swb_offset_128[ac->m4ac.sampling_index];
+        ics->num_swb           =   ff_aac_num_swb_128[ac->m4ac.sampling_index];
+        ics->tns_max_bands     = ff_tns_max_bands_128[ac->m4ac.sampling_index];
+        ics->predictor_present = 0;
+    } else {
+        ics->max_sfb               = get_bits(gb, 6);
+        ics->num_windows           = 1;
+        ics->swb_offset            =    ff_swb_offset_1024[ac->m4ac.sampling_index];
+        ics->num_swb               =   ff_aac_num_swb_1024[ac->m4ac.sampling_index];
+        ics->tns_max_bands         = ff_tns_max_bands_1024[ac->m4ac.sampling_index];
+        ics->predictor_present     = get_bits1(gb);
+        ics->predictor_reset_group = 0;
+        if (ics->predictor_present) {
+            if (ac->m4ac.object_type == AOT_AAC_MAIN) {
+                if (decode_prediction(ac, ics, gb)) {
+                    memset(ics, 0, sizeof(IndividualChannelStream));
+                    return -1;
+                }
+            } else if (ac->m4ac.object_type == AOT_AAC_LC) {
+                av_log(ac->avctx, AV_LOG_ERROR, "Prediction is not allowed in AAC-LC.\n");
+                memset(ics, 0, sizeof(IndividualChannelStream));
+                return -1;
+            } else {
+                av_log_missing_feature(ac->avctx, "Predictor bit set but LTP is", 1);
+                memset(ics, 0, sizeof(IndividualChannelStream));
+                return -1;
+            }
+        }
+    }
+
+    if (ics->max_sfb > ics->num_swb) {
+        av_log(ac->avctx, AV_LOG_ERROR,
+               "Number of scalefactor bands in group (%d) exceeds limit (%d).\n",
+               ics->max_sfb, ics->num_swb);
+        memset(ics, 0, sizeof(IndividualChannelStream));
+        return -1;
+    }
+
+    return 0;
+}
+
+/**
+ * Decode band types (section_data payload); reference: table 4.46.
+ *
+ * @param   band_type           array of the used band type
+ * @param   band_type_run_end   array of the last scalefactor band of a band type run
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_band_types(AACContext *ac, enum BandType band_type[120],
+                             int band_type_run_end[120], GetBitContext *gb,
+                             IndividualChannelStream *ics)
+{
+    int g, idx = 0;
+    const int bits = (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;
+    for (g = 0; g < ics->num_window_groups; g++) {
+        int k = 0;
+        while (k < ics->max_sfb) {
+            uint8_t sect_end = k;
+            int sect_len_incr;
+            int sect_band_type = get_bits(gb, 4);
+            if (sect_band_type == 12) {
+                av_log(ac->avctx, AV_LOG_ERROR, "invalid band type\n");
+                return -1;
+            }
+            while ((sect_len_incr = get_bits(gb, bits)) == (1 << bits) - 1)
+                sect_end += sect_len_incr;
+            sect_end += sect_len_incr;
+            if (get_bits_left(gb) < 0) {
+                av_log(ac->avctx, AV_LOG_ERROR, overread_err);
+                return -1;
+            }
+            if (sect_end > ics->max_sfb) {
+                av_log(ac->avctx, AV_LOG_ERROR,
+                       "Number of bands (%d) exceeds limit (%d).\n",
+                       sect_end, ics->max_sfb);
+                return -1;
+            }
+            for (; k < sect_end; k++) {
+                band_type        [idx]   = sect_band_type;
+                band_type_run_end[idx++] = sect_end;
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Decode scalefactors; reference: table 4.47.
+ *
+ * @param   global_gain         first scalefactor value as scalefactors are differentially coded
+ * @param   band_type           array of the used band type
+ * @param   band_type_run_end   array of the last scalefactor band of a band type run
+ * @param   sf                  array of scalefactors or intensity stereo positions
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_scalefactors(AACContext *ac, float sf[120], GetBitContext *gb,
+                               unsigned int global_gain,
+                               IndividualChannelStream *ics,
+                               enum BandType band_type[120],
+                               int band_type_run_end[120])
+{
+    const int sf_offset = ac->sf_offset + (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE ? 12 : 0);
+    int g, i, idx = 0;
+    int offset[3] = { global_gain, global_gain - 90, 100 };
+    int noise_flag = 1;
+    static const char *sf_str[3] = { "Global gain", "Noise gain", "Intensity stereo position" };
+    for (g = 0; g < ics->num_window_groups; g++) {
+        for (i = 0; i < ics->max_sfb;) {
+            int run_end = band_type_run_end[idx];
+            if (band_type[idx] == ZERO_BT) {
+                for (; i < run_end; i++, idx++)
+                    sf[idx] = 0.;
+            } else if ((band_type[idx] == INTENSITY_BT) || (band_type[idx] == INTENSITY_BT2)) {
+                for (; i < run_end; i++, idx++) {
+                    offset[2] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                    if (offset[2] > 255U) {
+                        av_log(ac->avctx, AV_LOG_ERROR,
+                               "%s (%d) out of range.\n", sf_str[2], offset[2]);
+                        return -1;
+                    }
+                    sf[idx] = ff_aac_pow2sf_tab[-offset[2] + 300];
+                }
+            } else if (band_type[idx] == NOISE_BT) {
+                for (; i < run_end; i++, idx++) {
+                    if (noise_flag-- > 0)
+                        offset[1] += get_bits(gb, 9) - 256;
+                    else
+                        offset[1] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                    if (offset[1] > 255U) {
+                        av_log(ac->avctx, AV_LOG_ERROR,
+                               "%s (%d) out of range.\n", sf_str[1], offset[1]);
+                        return -1;
+                    }
+                    sf[idx] = -ff_aac_pow2sf_tab[offset[1] + sf_offset + 100];
+                }
+            } else {
+                for (; i < run_end; i++, idx++) {
+                    offset[0] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                    if (offset[0] > 255U) {
+                        av_log(ac->avctx, AV_LOG_ERROR,
+                               "%s (%d) out of range.\n", sf_str[0], offset[0]);
+                        return -1;
+                    }
+                    sf[idx] = -ff_aac_pow2sf_tab[ offset[0] + sf_offset];
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Decode pulse data; reference: table 4.7.
+ */
+static int decode_pulses(Pulse *pulse, GetBitContext *gb,
+                         const uint16_t *swb_offset, int num_swb)
+{
+    int i, pulse_swb;
+    pulse->num_pulse = get_bits(gb, 2) + 1;
+    pulse_swb        = get_bits(gb, 6);
+    if (pulse_swb >= num_swb)
+        return -1;
+    pulse->pos[0]    = swb_offset[pulse_swb];
+    pulse->pos[0]   += get_bits(gb, 5);
+    if (pulse->pos[0] > 1023)
+        return -1;
+    pulse->amp[0]    = get_bits(gb, 4);
+    for (i = 1; i < pulse->num_pulse; i++) {
+        pulse->pos[i] = get_bits(gb, 5) + pulse->pos[i - 1];
+        if (pulse->pos[i] > 1023)
+            return -1;
+        pulse->amp[i] = get_bits(gb, 4);
+    }
+    return 0;
+}
+
+/**
+ * Decode Temporal Noise Shaping data; reference: table 4.48.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_tns(AACContext *ac, TemporalNoiseShaping *tns,
+                      GetBitContext *gb, const IndividualChannelStream *ics)
+{
+    int w, filt, i, coef_len, coef_res, coef_compress;
+    const int is8 = ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE;
+    const int tns_max_order = is8 ? 7 : ac->m4ac.object_type == AOT_AAC_MAIN ? 20 : 12;
+    for (w = 0; w < ics->num_windows; w++) {
+        if ((tns->n_filt[w] = get_bits(gb, 2 - is8))) {
+            coef_res = get_bits1(gb);
+
+            for (filt = 0; filt < tns->n_filt[w]; filt++) {
+                int tmp2_idx;
+                tns->length[w][filt] = get_bits(gb, 6 - 2 * is8);
+
+                if ((tns->order[w][filt] = get_bits(gb, 5 - 2 * is8)) > tns_max_order) {
+                    av_log(ac->avctx, AV_LOG_ERROR, "TNS filter order %d is greater than maximum %d.\n",
+                           tns->order[w][filt], tns_max_order);
+                    tns->order[w][filt] = 0;
+                    return -1;
+                }
+                if (tns->order[w][filt]) {
+                    tns->direction[w][filt] = get_bits1(gb);
+                    coef_compress = get_bits1(gb);
+                    coef_len = coef_res + 3 - coef_compress;
+                    tmp2_idx = 2 * coef_compress + coef_res;
+
+                    for (i = 0; i < tns->order[w][filt]; i++)
+                        tns->coef[w][filt][i] = tns_tmp2_map[tmp2_idx][get_bits(gb, coef_len)];
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Decode Mid/Side data; reference: table 4.54.
+ *
+ * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
+ *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
+ *                      [3] reserved for scalable AAC
+ */
+static void decode_mid_side_stereo(ChannelElement *cpe, GetBitContext *gb,
+                                   int ms_present)
+{
+    int idx;
+    if (ms_present == 1) {
+        for (idx = 0; idx < cpe->ch[0].ics.num_window_groups * cpe->ch[0].ics.max_sfb; idx++)
+            cpe->ms_mask[idx] = get_bits1(gb);
+    } else if (ms_present == 2) {
+        memset(cpe->ms_mask, 1, cpe->ch[0].ics.num_window_groups * cpe->ch[0].ics.max_sfb * sizeof(cpe->ms_mask[0]));
+    }
+}
+
+#ifndef VMUL2
+static inline float *VMUL2(float *dst, const float *v, unsigned idx,
+                           const float *scale)
+{
+    float s = *scale;
+    *dst++ = v[idx    & 15] * s;
+    *dst++ = v[idx>>4 & 15] * s;
+    return dst;
+}
+#endif
+
+#ifndef VMUL4
+static inline float *VMUL4(float *dst, const float *v, unsigned idx,
+                           const float *scale)
+{
+    float s = *scale;
+    *dst++ = v[idx    & 3] * s;
+    *dst++ = v[idx>>2 & 3] * s;
+    *dst++ = v[idx>>4 & 3] * s;
+    *dst++ = v[idx>>6 & 3] * s;
+    return dst;
+}
+#endif
+
+#ifndef VMUL2S
+static inline float *VMUL2S(float *dst, const float *v, unsigned idx,
+                            unsigned sign, const float *scale)
+{
+    union float754 s0, s1;
+
+    s0.f = s1.f = *scale;
+    s0.i ^= sign >> 1 << 31;
+    s1.i ^= sign      << 31;
+
+    *dst++ = v[idx    & 15] * s0.f;
+    *dst++ = v[idx>>4 & 15] * s1.f;
+
+    return dst;
+}
+#endif
+
+#ifndef VMUL4S
+static inline float *VMUL4S(float *dst, const float *v, unsigned idx,
+                            unsigned sign, const float *scale)
+{
+    unsigned nz = idx >> 12;
+    union float754 s = { .f = *scale };
+    union float754 t;
+
+    t.i = s.i ^ (sign & 1<<31);
+    *dst++ = v[idx    & 3] * t.f;
+
+    sign <<= nz & 1; nz >>= 1;
+    t.i = s.i ^ (sign & 1<<31);
+    *dst++ = v[idx>>2 & 3] * t.f;
+
+    sign <<= nz & 1; nz >>= 1;
+    t.i = s.i ^ (sign & 1<<31);
+    *dst++ = v[idx>>4 & 3] * t.f;
+
+    sign <<= nz & 1; nz >>= 1;
+    t.i = s.i ^ (sign & 1<<31);
+    *dst++ = v[idx>>6 & 3] * t.f;
+
+    return dst;
+}
+#endif
+
+/**
+ * Decode spectral data; reference: table 4.50.
+ * Dequantize and scale spectral data; reference: 4.6.3.3.
+ *
+ * @param   coef            array of dequantized, scaled spectral data
+ * @param   sf              array of scalefactors or intensity stereo positions
+ * @param   pulse_present   set if pulses are present
+ * @param   pulse           pointer to pulse data struct
+ * @param   band_type       array of the used band type
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_spectrum_and_dequant(AACContext *ac, float coef[1024],
+                                       GetBitContext *gb, const float sf[120],
+                                       int pulse_present, const Pulse *pulse,
+                                       const IndividualChannelStream *ics,
+                                       enum BandType band_type[120])
+{
+    int i, k, g, idx = 0;
+    const int c = 1024 / ics->num_windows;
+    const uint16_t *offsets = ics->swb_offset;
+    float *coef_base = coef;
+
+    for (g = 0; g < ics->num_windows; g++)
+        memset(coef + g * 128 + offsets[ics->max_sfb], 0, sizeof(float) * (c - offsets[ics->max_sfb]));
+
+    for (g = 0; g < ics->num_window_groups; g++) {
+        unsigned g_len = ics->group_len[g];
+
+        for (i = 0; i < ics->max_sfb; i++, idx++) {
+            const unsigned cbt_m1 = band_type[idx] - 1;
+            float *cfo = coef + offsets[i];
+            int off_len = offsets[i + 1] - offsets[i];
+            int group;
+
+            if (cbt_m1 >= INTENSITY_BT2 - 1) {
+                for (group = 0; group < g_len; group++, cfo+=128) {
+                    memset(cfo, 0, off_len * sizeof(float));
+                }
+            } else if (cbt_m1 == NOISE_BT - 1) {
+                for (group = 0; group < g_len; group++, cfo+=128) {
+                    float scale;
+                    float band_energy;
+
+                    for (k = 0; k < off_len; k++) {
+                        ac->random_state  = lcg_random(ac->random_state);
+                        cfo[k] = ac->random_state;
+                    }
+
+                    band_energy = ac->dsp.scalarproduct_float(cfo, cfo, off_len);
+                    scale = sf[idx] / sqrtf(band_energy);
+                    ac->dsp.vector_fmul_scalar(cfo, cfo, scale, off_len);
+                }
+            } else {
+                const float *vq = ff_aac_codebook_vector_vals[cbt_m1];
+                const uint16_t *cb_vector_idx = ff_aac_codebook_vector_idx[cbt_m1];
+                VLC_TYPE (*vlc_tab)[2] = vlc_spectral[cbt_m1].table;
+                OPEN_READER(re, gb);
+
+                switch (cbt_m1 >> 1) {
+                case 0:
+                    for (group = 0; group < g_len; group++, cfo+=128) {
+                        float *cf = cfo;
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned cb_idx;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+                            cb_idx = cb_vector_idx[code];
+                            cf = VMUL4(cf, vq, cb_idx, sf + idx);
+                        } while (len -= 4);
+                    }
+                    break;
+
+                case 1:
+                    for (group = 0; group < g_len; group++, cfo+=128) {
+                        float *cf = cfo;
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned nnz;
+                            unsigned cb_idx;
+                            uint32_t bits;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+#if MIN_CACHE_BITS < 20
+                            UPDATE_CACHE(re, gb);
+#endif
+                            cb_idx = cb_vector_idx[code];
+                            nnz = cb_idx >> 8 & 15;
+                            bits = SHOW_UBITS(re, gb, nnz) << (32-nnz);
+                            LAST_SKIP_BITS(re, gb, nnz);
+                            cf = VMUL4S(cf, vq, cb_idx, bits, sf + idx);
+                        } while (len -= 4);
+                    }
+                    break;
+
+                case 2:
+                    for (group = 0; group < g_len; group++, cfo+=128) {
+                        float *cf = cfo;
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned cb_idx;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+                            cb_idx = cb_vector_idx[code];
+                            cf = VMUL2(cf, vq, cb_idx, sf + idx);
+                        } while (len -= 2);
+                    }
+                    break;
+
+                case 3:
+                case 4:
+                    for (group = 0; group < g_len; group++, cfo+=128) {
+                        float *cf = cfo;
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned nnz;
+                            unsigned cb_idx;
+                            unsigned sign;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+                            cb_idx = cb_vector_idx[code];
+                            nnz = cb_idx >> 8 & 15;
+                            sign = SHOW_UBITS(re, gb, nnz) << (cb_idx >> 12);
+                            LAST_SKIP_BITS(re, gb, nnz);
+                            cf = VMUL2S(cf, vq, cb_idx, sign, sf + idx);
+                        } while (len -= 2);
+                    }
+                    break;
+
+                default:
+                    for (group = 0; group < g_len; group++, cfo+=128) {
+                        float *cf = cfo;
+                        uint32_t *icf = (uint32_t *) cf;
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned nzt, nnz;
+                            unsigned cb_idx;
+                            uint32_t bits;
+                            int j;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+
+                            if (!code) {
+                                *icf++ = 0;
+                                *icf++ = 0;
+                                continue;
+                            }
+
+                            cb_idx = cb_vector_idx[code];
+                            nnz = cb_idx >> 12;
+                            nzt = cb_idx >> 8;
+                            bits = SHOW_UBITS(re, gb, nnz) << (32-nnz);
+                            LAST_SKIP_BITS(re, gb, nnz);
+
+                            for (j = 0; j < 2; j++) {
+                                if (nzt & 1<<j) {
+                                    uint32_t b;
+                                    int n;
+                                    /* The total length of escape_sequence must be < 22 bits according
+                                       to the specification (i.e. max is 111111110xxxxxxxxxxxx). */
+                                    UPDATE_CACHE(re, gb);
+                                    b = GET_CACHE(re, gb);
+                                    b = 31 - av_log2(~b);
+
+                                    if (b > 8) {
+                                        av_log(ac->avctx, AV_LOG_ERROR, "error in spectral data, ESC overflow\n");
+                                        return -1;
+                                    }
+
+#if MIN_CACHE_BITS < 21
+                                    LAST_SKIP_BITS(re, gb, b + 1);
+                                    UPDATE_CACHE(re, gb);
+#else
+                                    SKIP_BITS(re, gb, b + 1);
+#endif
+                                    b += 4;
+                                    n = (1 << b) + SHOW_UBITS(re, gb, b);
+                                    LAST_SKIP_BITS(re, gb, b);
+                                    *icf++ = cbrt_tab[n] | (bits & 1<<31);
+                                    bits <<= 1;
+                                } else {
+                                    unsigned v = ((const uint32_t*)vq)[cb_idx & 15];
+                                    *icf++ = (bits & 1<<31) | v;
+                                    bits <<= !!v;
+                                }
+                                cb_idx >>= 4;
+                            }
+                        } while (len -= 2);
+
+                        ac->dsp.vector_fmul_scalar(cfo, cfo, sf[idx], off_len);
+                    }
+                }
+
+                CLOSE_READER(re, gb);
+            }
+        }
+        coef += g_len << 7;
+    }
+
+    if (pulse_present) {
+        idx = 0;
+        for (i = 0; i < pulse->num_pulse; i++) {
+            float co = coef_base[ pulse->pos[i] ];
+            while (offsets[idx + 1] <= pulse->pos[i])
+                idx++;
+            if (band_type[idx] != NOISE_BT && sf[idx]) {
+                float ico = -pulse->amp[i];
+                if (co) {
+                    co /= sf[idx];
+                    ico = co / sqrtf(sqrtf(fabsf(co))) + (co > 0 ? -ico : ico);
+                }
+                coef_base[ pulse->pos[i] ] = cbrtf(fabsf(ico)) * ico * sf[idx];
+            }
+        }
+    }
+    return 0;
+}
+
+static av_always_inline float flt16_round(float pf)
+{
+    union float754 tmp;
+    tmp.f = pf;
+    tmp.i = (tmp.i + 0x00008000U) & 0xFFFF0000U;
+    return tmp.f;
+}
+
+static av_always_inline float flt16_even(float pf)
+{
+    union float754 tmp;
+    tmp.f = pf;
+    tmp.i = (tmp.i + 0x00007FFFU + (tmp.i & 0x00010000U >> 16)) & 0xFFFF0000U;
+    return tmp.f;
+}
+
+static av_always_inline float flt16_trunc(float pf)
+{
+    union float754 pun;
+    pun.f = pf;
+    pun.i &= 0xFFFF0000U;
+    return pun.f;
+}
+
+static av_always_inline void predict(PredictorState *ps, float *coef,
+                                     float sf_scale, float inv_sf_scale,
+                    int output_enable)
+{
+    const float a     = 0.953125; // 61.0 / 64
+    const float alpha = 0.90625;  // 29.0 / 32
+    float e0, e1;
+    float pv;
+    float k1, k2;
+    float   r0 = ps->r0,     r1 = ps->r1;
+    float cor0 = ps->cor0, cor1 = ps->cor1;
+    float var0 = ps->var0, var1 = ps->var1;
+
+    k1 = var0 > 1 ? cor0 * flt16_even(a / var0) : 0;
+    k2 = var1 > 1 ? cor1 * flt16_even(a / var1) : 0;
+
+    pv = flt16_round(k1 * r0 + k2 * r1);
+    if (output_enable)
+        *coef += pv * sf_scale;
+
+    e0 = *coef * inv_sf_scale;
+    e1 = e0 - k1 * r0;
+
+    ps->cor1 = flt16_trunc(alpha * cor1 + r1 * e1);
+    ps->var1 = flt16_trunc(alpha * var1 + 0.5f * (r1 * r1 + e1 * e1));
+    ps->cor0 = flt16_trunc(alpha * cor0 + r0 * e0);
+    ps->var0 = flt16_trunc(alpha * var0 + 0.5f * (r0 * r0 + e0 * e0));
+
+    ps->r1 = flt16_trunc(a * (r0 - k1 * e0));
+    ps->r0 = flt16_trunc(a * e0);
+}
+
+/**
+ * Apply AAC-Main style frequency domain prediction.
+ */
+static void apply_prediction(AACContext *ac, SingleChannelElement *sce)
+{
+    int sfb, k;
+    float sf_scale = ac->sf_scale, inv_sf_scale = 1 / ac->sf_scale;
+
+    if (!sce->ics.predictor_initialized) {
+        reset_all_predictors(sce->predictor_state);
+        sce->ics.predictor_initialized = 1;
+    }
+
+    if (sce->ics.window_sequence[0] != EIGHT_SHORT_SEQUENCE) {
+        for (sfb = 0; sfb < ff_aac_pred_sfb_max[ac->m4ac.sampling_index]; sfb++) {
+            for (k = sce->ics.swb_offset[sfb]; k < sce->ics.swb_offset[sfb + 1]; k++) {
+                predict(&sce->predictor_state[k], &sce->coeffs[k],
+                        sf_scale, inv_sf_scale,
+                        sce->ics.predictor_present && sce->ics.prediction_used[sfb]);
+            }
+        }
+        if (sce->ics.predictor_reset_group)
+            reset_predictor_group(sce->predictor_state, sce->ics.predictor_reset_group);
+    } else
+        reset_all_predictors(sce->predictor_state);
+}
+
+/**
+ * Decode an individual_channel_stream payload; reference: table 4.44.
+ *
+ * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
+ * @param   scale_flag      scalable [1] or non-scalable [0] AAC (Unused until scalable AAC is implemented.)
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_ics(AACContext *ac, SingleChannelElement *sce,
+                      GetBitContext *gb, int common_window, int scale_flag)
+{
+    Pulse pulse;
+    TemporalNoiseShaping    *tns = &sce->tns;
+    IndividualChannelStream *ics = &sce->ics;
+    float *out = sce->coeffs;
+    int global_gain, pulse_present = 0;
+
+    /* This assignment is to silence a GCC warning about the variable being used
+     * uninitialized when in fact it always is.
+     */
+    pulse.num_pulse = 0;
+
+    global_gain = get_bits(gb, 8);
+
+    if (!common_window && !scale_flag) {
+        if (decode_ics_info(ac, ics, gb, 0) < 0)
+            return -1;
+    }
+
+    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)
+        return -1;
+    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)
+        return -1;
+
+    pulse_present = 0;
+    if (!scale_flag) {
+        if ((pulse_present = get_bits1(gb))) {
+            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+                av_log(ac->avctx, AV_LOG_ERROR, "Pulse tool not allowed in eight short sequence.\n");
+                return -1;
+            }
+            if (decode_pulses(&pulse, gb, ics->swb_offset, ics->num_swb)) {
+                av_log(ac->avctx, AV_LOG_ERROR, "Pulse data corrupt or invalid.\n");
+                return -1;
+            }
+        }
+        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))
+            return -1;
+        if (get_bits1(gb)) {
+            av_log_missing_feature(ac->avctx, "SSR", 1);
+            return -1;
+        }
+    }
+
+    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)
+        return -1;
+
+    if (ac->m4ac.object_type == AOT_AAC_MAIN && !common_window)
+        apply_prediction(ac, sce);
+
+    return 0;
+}
+
+/**
+ * Mid/Side stereo decoding; reference: 4.6.8.1.3.
+ */
+static void apply_mid_side_stereo(AACContext *ac, ChannelElement *cpe)
+{
+    const IndividualChannelStream *ics = &cpe->ch[0].ics;
+    float *ch0 = cpe->ch[0].coeffs;
+    float *ch1 = cpe->ch[1].coeffs;
+    int g, i, group, idx = 0;
+    const uint16_t *offsets = ics->swb_offset;
+    for (g = 0; g < ics->num_window_groups; g++) {
+        for (i = 0; i < ics->max_sfb; i++, idx++) {
+            if (cpe->ms_mask[idx] &&
+                    cpe->ch[0].band_type[idx] < NOISE_BT && cpe->ch[1].band_type[idx] < NOISE_BT) {
+                for (group = 0; group < ics->group_len[g]; group++) {
+                    ac->dsp.butterflies_float(ch0 + group * 128 + offsets[i],
+                                              ch1 + group * 128 + offsets[i],
+                                              offsets[i+1] - offsets[i]);
+                }
+            }
+        }
+        ch0 += ics->group_len[g] * 128;
+        ch1 += ics->group_len[g] * 128;
+    }
+}
+
+/**
+ * intensity stereo decoding; reference: 4.6.8.2.3
+ *
+ * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
+ *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
+ *                      [3] reserved for scalable AAC
+ */
+static void apply_intensity_stereo(ChannelElement *cpe, int ms_present)
+{
+    const IndividualChannelStream *ics = &cpe->ch[1].ics;
+    SingleChannelElement         *sce1 = &cpe->ch[1];
+    float *coef0 = cpe->ch[0].coeffs, *coef1 = cpe->ch[1].coeffs;
+    const uint16_t *offsets = ics->swb_offset;
+    int g, group, i, k, idx = 0;
+    int c;
+    float scale;
+    for (g = 0; g < ics->num_window_groups; g++) {
+        for (i = 0; i < ics->max_sfb;) {
+            if (sce1->band_type[idx] == INTENSITY_BT || sce1->band_type[idx] == INTENSITY_BT2) {
+                const int bt_run_end = sce1->band_type_run_end[idx];
+                for (; i < bt_run_end; i++, idx++) {
+                    c = -1 + 2 * (sce1->band_type[idx] - 14);
+                    if (ms_present)
+                        c *= 1 - 2 * cpe->ms_mask[idx];
+                    scale = c * sce1->sf[idx];
+                    for (group = 0; group < ics->group_len[g]; group++)
+                        for (k = offsets[i]; k < offsets[i + 1]; k++)
+                            coef1[group * 128 + k] = scale * coef0[group * 128 + k];
+                }
+            } else {
+                int bt_run_end = sce1->band_type_run_end[idx];
+                idx += bt_run_end - i;
+                i    = bt_run_end;
+            }
+        }
+        coef0 += ics->group_len[g] * 128;
+        coef1 += ics->group_len[g] * 128;
+    }
+}
+
+/**
+ * Decode a channel_pair_element; reference: table 4.4.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_cpe(AACContext *ac, GetBitContext *gb, ChannelElement *cpe)
+{
+    int i, ret, common_window, ms_present = 0;
+
+    common_window = get_bits1(gb);
+    if (common_window) {
+        if (decode_ics_info(ac, &cpe->ch[0].ics, gb, 1))
+            return -1;
+        i = cpe->ch[1].ics.use_kb_window[0];
+        cpe->ch[1].ics = cpe->ch[0].ics;
+        cpe->ch[1].ics.use_kb_window[1] = i;
+        ms_present = get_bits(gb, 2);
+        if (ms_present == 3) {
+            av_log(ac->avctx, AV_LOG_ERROR, "ms_present = 3 is reserved.\n");
+            return -1;
+        } else if (ms_present)
+            decode_mid_side_stereo(cpe, gb, ms_present);
+    }
+    if ((ret = decode_ics(ac, &cpe->ch[0], gb, common_window, 0)))
+        return ret;
+    if ((ret = decode_ics(ac, &cpe->ch[1], gb, common_window, 0)))
+        return ret;
+
+    if (common_window) {
+        if (ms_present)
+            apply_mid_side_stereo(ac, cpe);
+        if (ac->m4ac.object_type == AOT_AAC_MAIN) {
+            apply_prediction(ac, &cpe->ch[0]);
+            apply_prediction(ac, &cpe->ch[1]);
+        }
+    }
+
+    apply_intensity_stereo(cpe, ms_present);
+    return 0;
+}
+
+static const float cce_scale[] = {
+    1.09050773266525765921, //2^(1/8)
+    1.18920711500272106672, //2^(1/4)
+    M_SQRT2,
+    2,
+};
+
+/**
+ * Decode coupling_channel_element; reference: table 4.8.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_cce(AACContext *ac, GetBitContext *gb, ChannelElement *che)
+{
+    int num_gain = 0;
+    int c, g, sfb, ret;
+    int sign;
+    float scale;
+    SingleChannelElement *sce = &che->ch[0];
+    ChannelCoupling     *coup = &che->coup;
+
+    coup->coupling_point = 2 * get_bits1(gb);
+    coup->num_coupled = get_bits(gb, 3);
+    for (c = 0; c <= coup->num_coupled; c++) {
+        num_gain++;
+        coup->type[c] = get_bits1(gb) ? TYPE_CPE : TYPE_SCE;
+        coup->id_select[c] = get_bits(gb, 4);
+        if (coup->type[c] == TYPE_CPE) {
+            coup->ch_select[c] = get_bits(gb, 2);
+            if (coup->ch_select[c] == 3)
+                num_gain++;
+        } else
+            coup->ch_select[c] = 2;
+    }
+    coup->coupling_point += get_bits1(gb) || (coup->coupling_point >> 1);
+
+    sign  = get_bits(gb, 1);
+    scale = cce_scale[get_bits(gb, 2)];
+
+    if ((ret = decode_ics(ac, sce, gb, 0, 0)))
+        return ret;
+
+    for (c = 0; c < num_gain; c++) {
+        int idx  = 0;
+        int cge  = 1;
+        int gain = 0;
+        float gain_cache = 1.;
+        if (c) {
+            cge = coup->coupling_point == AFTER_IMDCT ? 1 : get_bits1(gb);
+            gain = cge ? get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60: 0;
+            gain_cache = powf(scale, -gain);
+        }
+        if (coup->coupling_point == AFTER_IMDCT) {
+            coup->gain[c][0] = gain_cache;
+        } else {
+            for (g = 0; g < sce->ics.num_window_groups; g++) {
+                for (sfb = 0; sfb < sce->ics.max_sfb; sfb++, idx++) {
+                    if (sce->band_type[idx] != ZERO_BT) {
+                        if (!cge) {
+                            int t = get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                            if (t) {
+                                int s = 1;
+                                t = gain += t;
+                                if (sign) {
+                                    s  -= 2 * (t & 0x1);
+                                    t >>= 1;
+                                }
+                                gain_cache = powf(scale, -t) * s;
+                            }
+                        }
+                        coup->gain[c][idx] = gain_cache;
+                    }
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Parse whether channels are to be excluded from Dynamic Range Compression; reference: table 4.53.
+ *
+ * @return  Returns number of bytes consumed.
+ */
+static int decode_drc_channel_exclusions(DynamicRangeControl *che_drc,
+                                         GetBitContext *gb)
+{
+    int i;
+    int num_excl_chan = 0;
+
+    do {
+        for (i = 0; i < 7; i++)
+            che_drc->exclude_mask[num_excl_chan++] = get_bits1(gb);
+    } while (num_excl_chan < MAX_CHANNELS - 7 && get_bits1(gb));
+
+    return num_excl_chan / 7;
+}
+
+/**
+ * Decode dynamic range information; reference: table 4.52.
+ *
+ * @param   cnt length of TYPE_FIL syntactic element in bytes
+ *
+ * @return  Returns number of bytes consumed.
+ */
+static int decode_dynamic_range(DynamicRangeControl *che_drc,
+                                GetBitContext *gb, int cnt)
+{
+    int n             = 1;
+    int drc_num_bands = 1;
+    int i;
+
+    /* pce_tag_present? */
+    if (get_bits1(gb)) {
+        che_drc->pce_instance_tag  = get_bits(gb, 4);
+        skip_bits(gb, 4); // tag_reserved_bits
+        n++;
+    }
+
+    /* excluded_chns_present? */
+    if (get_bits1(gb)) {
+        n += decode_drc_channel_exclusions(che_drc, gb);
+    }
+
+    /* drc_bands_present? */
+    if (get_bits1(gb)) {
+        che_drc->band_incr            = get_bits(gb, 4);
+        che_drc->interpolation_scheme = get_bits(gb, 4);
+        n++;
+        drc_num_bands += che_drc->band_incr;
+        for (i = 0; i < drc_num_bands; i++) {
+            che_drc->band_top[i] = get_bits(gb, 8);
+            n++;
+        }
+    }
+
+    /* prog_ref_level_present? */
+    if (get_bits1(gb)) {
+        che_drc->prog_ref_level = get_bits(gb, 7);
+        skip_bits1(gb); // prog_ref_level_reserved_bits
+        n++;
+    }
+
+    for (i = 0; i < drc_num_bands; i++) {
+        che_drc->dyn_rng_sgn[i] = get_bits1(gb);
+        che_drc->dyn_rng_ctl[i] = get_bits(gb, 7);
+        n++;
+    }
+
+    return n;
+}
+
+/**
+ * Decode extension data (incomplete); reference: table 4.51.
+ *
+ * @param   cnt length of TYPE_FIL syntactic element in bytes
+ *
+ * @return Returns number of bytes consumed
+ */
+static int decode_extension_payload(AACContext *ac, GetBitContext *gb, int cnt,
+                                    ChannelElement *che, enum RawDataBlockType elem_type)
+{
+    int crc_flag = 0;
+    int res = cnt;
+    switch (get_bits(gb, 4)) { // extension type
+    case EXT_SBR_DATA_CRC:
+        crc_flag++;
+    case EXT_SBR_DATA:
+        if (!che) {
+            av_log(ac->avctx, AV_LOG_ERROR, "SBR was found before the first channel element.\n");
+            return res;
+        } else if (!ac->m4ac.sbr) {
+            av_log(ac->avctx, AV_LOG_ERROR, "SBR signaled to be not-present but was found in the bitstream.\n");
+            skip_bits_long(gb, 8 * cnt - 4);
+            return res;
+        } else if (ac->m4ac.sbr == -1 && ac->output_configured == OC_LOCKED) {
+            av_log(ac->avctx, AV_LOG_ERROR, "Implicit SBR was found with a first occurrence after the first frame.\n");
+            skip_bits_long(gb, 8 * cnt - 4);
+            return res;
+        } else if (ac->m4ac.ps == -1 && ac->output_configured < OC_LOCKED && ac->avctx->channels == 1) {
+            ac->m4ac.sbr = 1;
+            ac->m4ac.ps = 1;
+            output_configure(ac, ac->che_pos, ac->che_pos, ac->m4ac.chan_config, ac->output_configured);
+        } else {
+            ac->m4ac.sbr = 1;
+        }
+        res = ff_decode_sbr_extension(ac, &che->sbr, gb, crc_flag, cnt, elem_type);
+        break;
+    case EXT_DYNAMIC_RANGE:
+        res = decode_dynamic_range(&ac->che_drc, gb, cnt);
+        break;
+    case EXT_FILL:
+    case EXT_FILL_DATA:
+    case EXT_DATA_ELEMENT:
+    default:
+        skip_bits_long(gb, 8 * cnt - 4);
+        break;
+    };
+    return res;
+}
+
+/**
+ * Decode Temporal Noise Shaping filter coefficients and apply all-pole filters; reference: 4.6.9.3.
+ *
+ * @param   decode  1 if tool is used normally, 0 if tool is used in LTP.
+ * @param   coef    spectral coefficients
+ */
+static void apply_tns(float coef[1024], TemporalNoiseShaping *tns,
+                      IndividualChannelStream *ics, int decode)
+{
+    const int mmm = FFMIN(ics->tns_max_bands, ics->max_sfb);
+    int w, filt, m, i;
+    int bottom, top, order, start, end, size, inc;
+    float lpc[TNS_MAX_ORDER];
+
+    for (w = 0; w < ics->num_windows; w++) {
+        bottom = ics->num_swb;
+        for (filt = 0; filt < tns->n_filt[w]; filt++) {
+            top    = bottom;
+            bottom = FFMAX(0, top - tns->length[w][filt]);
+            order  = tns->order[w][filt];
+            if (order == 0)
+                continue;
+
+            // tns_decode_coef
+            compute_lpc_coefs(tns->coef[w][filt], order, lpc, 0, 0, 0);
+
+            start = ics->swb_offset[FFMIN(bottom, mmm)];
+            end   = ics->swb_offset[FFMIN(   top, mmm)];
+            if ((size = end - start) <= 0)
+                continue;
+            if (tns->direction[w][filt]) {
+                inc = -1;
+                start = end - 1;
+            } else {
+                inc = 1;
+            }
+            start += w * 128;
+
+            // ar filter
+            for (m = 0; m < size; m++, start += inc)
+                for (i = 1; i <= FFMIN(m, order); i++)
+                    coef[start] -= coef[start - i * inc] * lpc[i - 1];
+        }
+    }
+}
+
+/**
+ * Conduct IMDCT and windowing.
+ */
+static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)
+{
+    IndividualChannelStream *ics = &sce->ics;
+    float *in    = sce->coeffs;
+    float *out   = sce->ret;
+    float *saved = sce->saved;
+    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;
+    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;
+    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;
+    float *buf  = ac->buf_mdct;
+    float *temp = ac->temp;
+    int i;
+
+    // imdct
+    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+        for (i = 0; i < 1024; i += 128)
+            ff_imdct_half(&ac->mdct_small, buf + i, in + i);
+    } else
+        ff_imdct_half(&ac->mdct, buf, in);
+
+    /* window overlapping
+     * NOTE: To simplify the overlapping code, all 'meaningless' short to long
+     * and long to short transitions are considered to be short to short
+     * transitions. This leaves just two cases (long to long and short to short)
+     * with a little special sauce for EIGHT_SHORT_SEQUENCE.
+     */
+    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&
+            (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) {
+        ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);
+    } else {
+        for (i = 0; i < 448; i++)
+            out[i] = saved[i] + bias;
+
+        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+            ac->dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);
+            ac->dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);
+            ac->dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);
+            ac->dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);
+            ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);
+            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));
+        } else {
+            ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);
+            for (i = 576; i < 1024; i++)
+                out[i] = buf[i-512] + bias;
+        }
+    }
+
+    // buffer update
+    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+        for (i = 0; i < 64; i++)
+            saved[i] = temp[64 + i] - bias;
+        ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);
+        ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);
+        ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);
+        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));
+    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {
+        memcpy(                    saved,       buf + 512,        448 * sizeof(float));
+        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));
+    } else { // LONG_STOP or ONLY_LONG
+        memcpy(                    saved,       buf + 512,        512 * sizeof(float));
+    }
+}
+
+/**
+ * Apply dependent channel coupling (applied before IMDCT).
+ *
+ * @param   index   index into coupling gain array
+ */
+static void apply_dependent_coupling(AACContext *ac,
+                                     SingleChannelElement *target,
+                                     ChannelElement *cce, int index)
+{
+    IndividualChannelStream *ics = &cce->ch[0].ics;
+    const uint16_t *offsets = ics->swb_offset;
+    float *dest = target->coeffs;
+    const float *src = cce->ch[0].coeffs;
+    int g, i, group, k, idx = 0;
+    if (ac->m4ac.object_type == AOT_AAC_LTP) {
+        av_log(ac->avctx, AV_LOG_ERROR,
+               "Dependent coupling is not supported together with LTP\n");
+        return;
+    }
+    for (g = 0; g < ics->num_window_groups; g++) {
+        for (i = 0; i < ics->max_sfb; i++, idx++) {
+            if (cce->ch[0].band_type[idx] != ZERO_BT) {
+                const float gain = cce->coup.gain[index][idx];
+                for (group = 0; group < ics->group_len[g]; group++) {
+                    for (k = offsets[i]; k < offsets[i + 1]; k++) {
+                        // XXX dsputil-ize
+                        dest[group * 128 + k] += gain * src[group * 128 + k];
+                    }
+                }
+            }
+        }
+        dest += ics->group_len[g] * 128;
+        src  += ics->group_len[g] * 128;
+    }
+}
+
+/**
+ * Apply independent channel coupling (applied after IMDCT).
+ *
+ * @param   index   index into coupling gain array
+ */
+static void apply_independent_coupling(AACContext *ac,
+                                       SingleChannelElement *target,
+                                       ChannelElement *cce, int index)
+{
+    int i;
+    const float gain = cce->coup.gain[index][0];
+    const float bias = ac->add_bias;
+    const float *src = cce->ch[0].ret;
+    float *dest = target->ret;
+    const int len = 1024 << (ac->m4ac.sbr == 1);
+
+    for (i = 0; i < len; i++)
+        dest[i] += gain * (src[i] - bias);
+}
+
+/**
+ * channel coupling transformation interface
+ *
+ * @param   apply_coupling_method   pointer to (in)dependent coupling function
+ */
+static void apply_channel_coupling(AACContext *ac, ChannelElement *cc,
+                                   enum RawDataBlockType type, int elem_id,
+                                   enum CouplingPoint coupling_point,
+                                   void (*apply_coupling_method)(AACContext *ac, SingleChannelElement *target, ChannelElement *cce, int index))
+{
+    int i, c;
+
+    for (i = 0; i < MAX_ELEM_ID; i++) {
+        ChannelElement *cce = ac->che[TYPE_CCE][i];
+        int index = 0;
+
+        if (cce && cce->coup.coupling_point == coupling_point) {
+            ChannelCoupling *coup = &cce->coup;
+
+            for (c = 0; c <= coup->num_coupled; c++) {
+                if (coup->type[c] == type && coup->id_select[c] == elem_id) {
+                    if (coup->ch_select[c] != 1) {
+                        apply_coupling_method(ac, &cc->ch[0], cce, index);
+                        if (coup->ch_select[c] != 0)
+                            index++;
+                    }
+                    if (coup->ch_select[c] != 2)
+                        apply_coupling_method(ac, &cc->ch[1], cce, index++);
+                } else
+                    index += 1 + (coup->ch_select[c] == 3);
+            }
+        }
+    }
+}
+
+/**
+ * Convert spectral data to float samples, applying all supported tools as appropriate.
+ */
+static void spectral_to_sample(AACContext *ac)
+{
+    int i, type;
+    float imdct_bias = (ac->m4ac.sbr <= 0) ? ac->add_bias : 0.0f;
+    for (type = 3; type >= 0; type--) {
+        for (i = 0; i < MAX_ELEM_ID; i++) {
+            ChannelElement *che = ac->che[type][i];
+            if (che) {
+                if (type <= TYPE_CPE)
+                    apply_channel_coupling(ac, che, type, i, BEFORE_TNS, apply_dependent_coupling);
+                if (che->ch[0].tns.present)
+                    apply_tns(che->ch[0].coeffs, &che->ch[0].tns, &che->ch[0].ics, 1);
+                if (che->ch[1].tns.present)
+                    apply_tns(che->ch[1].coeffs, &che->ch[1].tns, &che->ch[1].ics, 1);
+                if (type <= TYPE_CPE)
+                    apply_channel_coupling(ac, che, type, i, BETWEEN_TNS_AND_IMDCT, apply_dependent_coupling);
+                if (type != TYPE_CCE || che->coup.coupling_point == AFTER_IMDCT) {
+                    imdct_and_windowing(ac, &che->ch[0], imdct_bias);
+                    if (type == TYPE_CPE) {
+                        imdct_and_windowing(ac, &che->ch[1], imdct_bias);
+                    }
+                    if (ac->m4ac.sbr > 0) {
+                        ff_sbr_apply(ac, &che->sbr, type, che->ch[0].ret, che->ch[1].ret);
+                    }
+                }
+                if (type <= TYPE_CCE)
+                    apply_channel_coupling(ac, che, type, i, AFTER_IMDCT, apply_independent_coupling);
+            }
+        }
+    }
+}
+
+static int parse_adts_frame_header(AACContext *ac, GetBitContext *gb)
+{
+    int size;
+    AACADTSHeaderInfo hdr_info;
+
+    size = ff_aac_parse_header(gb, &hdr_info);
+    if (size > 0) {
+        if (ac->output_configured != OC_LOCKED && hdr_info.chan_config) {
+            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
+            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
+            ac->m4ac.chan_config = hdr_info.chan_config;
+            if (set_default_channel_config(ac, new_che_pos, hdr_info.chan_config))
+                return -7;
+            if (output_configure(ac, ac->che_pos, new_che_pos, hdr_info.chan_config, OC_TRIAL_FRAME))
+                return -7;
+        } else if (ac->output_configured != OC_LOCKED) {
+            ac->output_configured = OC_NONE;
+        }
+        if (ac->output_configured != OC_LOCKED) {
+            ac->m4ac.sbr = -1;
+            ac->m4ac.ps  = -1;
+        }
+        ac->m4ac.sample_rate     = hdr_info.sample_rate;
+        ac->m4ac.sampling_index  = hdr_info.sampling_index;
+        ac->m4ac.object_type     = hdr_info.object_type;
+        if (!ac->avctx->sample_rate)
+            ac->avctx->sample_rate = hdr_info.sample_rate;
+        if (hdr_info.num_aac_frames == 1) {
+            if (!hdr_info.crc_absent)
+                skip_bits(gb, 16);
+        } else {
+            av_log_missing_feature(ac->avctx, "More than one AAC RDB per ADTS frame is", 0);
+            return -1;
+        }
+    }
+    return size;
+}
+
+static int aac_decode_frame(AVCodecContext *avctx, void *data,
+                            int *data_size, AVPacket *avpkt)
+{
+    const uint8_t *buf = avpkt->data;
+    int buf_size = avpkt->size;
+    AACContext *ac = avctx->priv_data;
+    ChannelElement *che = NULL, *che_prev = NULL;
+    GetBitContext gb;
+    enum RawDataBlockType elem_type, elem_type_prev = TYPE_END;
+    int err, elem_id, data_size_tmp;
+    int buf_consumed;
+    int samples = 0, multiplier;
+    int buf_offset;
+
+    init_get_bits(&gb, buf, buf_size * 8);
+
+    if (show_bits(&gb, 12) == 0xfff) {
+        if (parse_adts_frame_header(ac, &gb) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Error decoding AAC frame header.\n");
+            return -1;
+        }
+        if (ac->m4ac.sampling_index > 12) {
+            av_log(ac->avctx, AV_LOG_ERROR, "invalid sampling rate index %d\n", ac->m4ac.sampling_index);
+            return -1;
+        }
+    }
+
+    memset(ac->tags_seen_this_frame, 0, sizeof(ac->tags_seen_this_frame));
+    // parse
+    while ((elem_type = get_bits(&gb, 3)) != TYPE_END) {
+        elem_id = get_bits(&gb, 4);
+
+        if (elem_type < TYPE_DSE) {
+            if (!(che=get_che(ac, elem_type, elem_id))) {
+                av_log(ac->avctx, AV_LOG_ERROR, "channel element %d.%d is not allocated\n",
+                       elem_type, elem_id);
+                return -1;
+            }
+            samples = 1024;
+        }
+
+        switch (elem_type) {
+
+        case TYPE_SCE:
+            err = decode_ics(ac, &che->ch[0], &gb, 0, 0);
+            break;
+
+        case TYPE_CPE:
+            err = decode_cpe(ac, &gb, che);
+            break;
+
+        case TYPE_CCE:
+            err = decode_cce(ac, &gb, che);
+            break;
+
+        case TYPE_LFE:
+            err = decode_ics(ac, &che->ch[0], &gb, 0, 0);
+            break;
+
+        case TYPE_DSE:
+            err = skip_data_stream_element(ac, &gb);
+            break;
+
+        case TYPE_PCE: {
+            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
+            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
+            if ((err = decode_pce(ac, new_che_pos, &gb)))
+                break;
+            if (ac->output_configured > OC_TRIAL_PCE)
+                av_log(avctx, AV_LOG_ERROR,
+                       "Not evaluating a further program_config_element as this construct is dubious at best.\n");
+            else
+                err = output_configure(ac, ac->che_pos, new_che_pos, 0, OC_TRIAL_PCE);
+            break;
+        }
+
+        case TYPE_FIL:
+            if (elem_id == 15)
+                elem_id += get_bits(&gb, 8) - 1;
+            if (get_bits_left(&gb) < 8 * elem_id) {
+                    av_log(avctx, AV_LOG_ERROR, overread_err);
+                    return -1;
+            }
+            while (elem_id > 0)
+                elem_id -= decode_extension_payload(ac, &gb, elem_id, che_prev, elem_type_prev);
+            err = 0; /* FIXME */
+            break;
+
+        default:
+            err = -1; /* should not happen, but keeps compiler happy */
+            break;
+        }
+
+        che_prev       = che;
+        elem_type_prev = elem_type;
+
+        if (err)
+            return err;
+
+        if (get_bits_left(&gb) < 3) {
+            av_log(avctx, AV_LOG_ERROR, overread_err);
+            return -1;
+        }
+    }
+
+    spectral_to_sample(ac);
+
+    multiplier = (ac->m4ac.sbr == 1) ? ac->m4ac.ext_sample_rate > ac->m4ac.sample_rate : 0;
+    samples <<= multiplier;
+    if (ac->output_configured < OC_LOCKED) {
+        avctx->sample_rate = ac->m4ac.sample_rate << multiplier;
+        avctx->frame_size = samples;
+    }
+
+    data_size_tmp = samples * avctx->channels * sizeof(int16_t);
+    if (*data_size < data_size_tmp) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Output buffer too small (%d) or trying to output too many samples (%d) for this frame.\n",
+               *data_size, data_size_tmp);
+        return -1;
+    }
+    *data_size = data_size_tmp;
+
+    if (samples)
+        ac->dsp.float_to_int16_interleave(data, (const float **)ac->output_data, samples, avctx->channels);
+
+    if (ac->output_configured)
+        ac->output_configured = OC_LOCKED;
+
+    buf_consumed = (get_bits_count(&gb) + 7) >> 3;
+    for (buf_offset = buf_consumed; buf_offset < buf_size; buf_offset++)
+        if (buf[buf_offset])
+            break;
+
+    return buf_size > buf_offset ? buf_consumed : buf_size;
+}
+
+static av_cold int aac_decode_close(AVCodecContext *avctx)
+{
+    AACContext *ac = avctx->priv_data;
+    int i, type;
+
+    for (i = 0; i < MAX_ELEM_ID; i++) {
+        for (type = 0; type < 4; type++) {
+            if (ac->che[type][i])
+                ff_aac_sbr_ctx_close(&ac->che[type][i]->sbr);
+            av_freep(&ac->che[type][i]);
+        }
+    }
+
+    ff_mdct_end(&ac->mdct);
+    ff_mdct_end(&ac->mdct_small);
+    return 0;
+}
+
+AVCodec aac_decoder = {
+    "aac",
+    AVMEDIA_TYPE_AUDIO,
+    CODEC_ID_AAC,
+    sizeof(AACContext),
+    aac_decode_init,
+    NULL,
+    aac_decode_close,
+    aac_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL("Advanced Audio Coding"),
+    .sample_fmts = (const enum SampleFormat[]) {
+        SAMPLE_FMT_S16,SAMPLE_FMT_NONE
+    },
+    .channel_layouts = aac_channel_layout,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dct32.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dct32.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dct32.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,267 @@
+/*
+ * Template for the Discrete Cosine Transform for 32 samples
+ * Copyright (c) 2001, 2002 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifdef DCT32_FLOAT
+#   define FIXHR(x)       ((float)(x))
+#   define MULH3(x, y, s) ((s)*(y)*(x))
+#   define INTFLOAT float
+#endif
+
+
+/* tab[i][j] = 1.0 / (2.0 * cos(pi*(2*k+1) / 2^(6 - j))) */
+
+/* cos(i*pi/64) */
+
+#define COS0_0  FIXHR(0.50060299823519630134/2)
+#define COS0_1  FIXHR(0.50547095989754365998/2)
+#define COS0_2  FIXHR(0.51544730992262454697/2)
+#define COS0_3  FIXHR(0.53104259108978417447/2)
+#define COS0_4  FIXHR(0.55310389603444452782/2)
+#define COS0_5  FIXHR(0.58293496820613387367/2)
+#define COS0_6  FIXHR(0.62250412303566481615/2)
+#define COS0_7  FIXHR(0.67480834145500574602/2)
+#define COS0_8  FIXHR(0.74453627100229844977/2)
+#define COS0_9  FIXHR(0.83934964541552703873/2)
+#define COS0_10 FIXHR(0.97256823786196069369/2)
+#define COS0_11 FIXHR(1.16943993343288495515/4)
+#define COS0_12 FIXHR(1.48416461631416627724/4)
+#define COS0_13 FIXHR(2.05778100995341155085/8)
+#define COS0_14 FIXHR(3.40760841846871878570/8)
+#define COS0_15 FIXHR(10.19000812354805681150/32)
+
+#define COS1_0 FIXHR(0.50241928618815570551/2)
+#define COS1_1 FIXHR(0.52249861493968888062/2)
+#define COS1_2 FIXHR(0.56694403481635770368/2)
+#define COS1_3 FIXHR(0.64682178335999012954/2)
+#define COS1_4 FIXHR(0.78815462345125022473/2)
+#define COS1_5 FIXHR(1.06067768599034747134/4)
+#define COS1_6 FIXHR(1.72244709823833392782/4)
+#define COS1_7 FIXHR(5.10114861868916385802/16)
+
+#define COS2_0 FIXHR(0.50979557910415916894/2)
+#define COS2_1 FIXHR(0.60134488693504528054/2)
+#define COS2_2 FIXHR(0.89997622313641570463/2)
+#define COS2_3 FIXHR(2.56291544774150617881/8)
+
+#define COS3_0 FIXHR(0.54119610014619698439/2)
+#define COS3_1 FIXHR(1.30656296487637652785/4)
+
+#define COS4_0 FIXHR(0.70710678118654752439/2)
+
+/* butterfly operator */
+#define BF(a, b, c, s)\
+{\
+    tmp0 = val##a + val##b;\
+    tmp1 = val##a - val##b;\
+    val##a = tmp0;\
+    val##b = MULH3(tmp1, c, 1<<(s));\
+}
+
+#define BF0(a, b, c, s)\
+{\
+    tmp0 = tab[a] + tab[b];\
+    tmp1 = tab[a] - tab[b];\
+    val##a = tmp0;\
+    val##b = MULH3(tmp1, c, 1<<(s));\
+}
+
+#define BF1(a, b, c, d)\
+{\
+    BF(a, b, COS4_0, 1);\
+    BF(c, d,-COS4_0, 1);\
+    val##c += val##d;\
+}
+
+#define BF2(a, b, c, d)\
+{\
+    BF(a, b, COS4_0, 1);\
+    BF(c, d,-COS4_0, 1);\
+    val##c += val##d;\
+    val##a += val##c;\
+    val##c += val##b;\
+    val##b += val##d;\
+}
+
+#define ADD(a, b) val##a += val##b
+
+/* DCT32 without 1/sqrt(2) coef zero scaling. */
+static void dct32(INTFLOAT *out, const INTFLOAT *tab)
+{
+    INTFLOAT tmp0, tmp1;
+
+    INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,
+             val8 , val9 , val10, val11, val12, val13, val14, val15,
+             val16, val17, val18, val19, val20, val21, val22, val23,
+             val24, val25, val26, val27, val28, val29, val30, val31;
+
+    /* pass 1 */
+    BF0( 0, 31, COS0_0 , 1);
+    BF0(15, 16, COS0_15, 5);
+    /* pass 2 */
+    BF( 0, 15, COS1_0 , 1);
+    BF(16, 31,-COS1_0 , 1);
+    /* pass 1 */
+    BF0( 7, 24, COS0_7 , 1);
+    BF0( 8, 23, COS0_8 , 1);
+    /* pass 2 */
+    BF( 7,  8, COS1_7 , 4);
+    BF(23, 24,-COS1_7 , 4);
+    /* pass 3 */
+    BF( 0,  7, COS2_0 , 1);
+    BF( 8, 15,-COS2_0 , 1);
+    BF(16, 23, COS2_0 , 1);
+    BF(24, 31,-COS2_0 , 1);
+    /* pass 1 */
+    BF0( 3, 28, COS0_3 , 1);
+    BF0(12, 19, COS0_12, 2);
+    /* pass 2 */
+    BF( 3, 12, COS1_3 , 1);
+    BF(19, 28,-COS1_3 , 1);
+    /* pass 1 */
+    BF0( 4, 27, COS0_4 , 1);
+    BF0(11, 20, COS0_11, 2);
+    /* pass 2 */
+    BF( 4, 11, COS1_4 , 1);
+    BF(20, 27,-COS1_4 , 1);
+    /* pass 3 */
+    BF( 3,  4, COS2_3 , 3);
+    BF(11, 12,-COS2_3 , 3);
+    BF(19, 20, COS2_3 , 3);
+    BF(27, 28,-COS2_3 , 3);
+    /* pass 4 */
+    BF( 0,  3, COS3_0 , 1);
+    BF( 4,  7,-COS3_0 , 1);
+    BF( 8, 11, COS3_0 , 1);
+    BF(12, 15,-COS3_0 , 1);
+    BF(16, 19, COS3_0 , 1);
+    BF(20, 23,-COS3_0 , 1);
+    BF(24, 27, COS3_0 , 1);
+    BF(28, 31,-COS3_0 , 1);
+
+
+
+    /* pass 1 */
+    BF0( 1, 30, COS0_1 , 1);
+    BF0(14, 17, COS0_14, 3);
+    /* pass 2 */
+    BF( 1, 14, COS1_1 , 1);
+    BF(17, 30,-COS1_1 , 1);
+    /* pass 1 */
+    BF0( 6, 25, COS0_6 , 1);
+    BF0( 9, 22, COS0_9 , 1);
+    /* pass 2 */
+    BF( 6,  9, COS1_6 , 2);
+    BF(22, 25,-COS1_6 , 2);
+    /* pass 3 */
+    BF( 1,  6, COS2_1 , 1);
+    BF( 9, 14,-COS2_1 , 1);
+    BF(17, 22, COS2_1 , 1);
+    BF(25, 30,-COS2_1 , 1);
+
+    /* pass 1 */
+    BF0( 2, 29, COS0_2 , 1);
+    BF0(13, 18, COS0_13, 3);
+    /* pass 2 */
+    BF( 2, 13, COS1_2 , 1);
+    BF(18, 29,-COS1_2 , 1);
+    /* pass 1 */
+    BF0( 5, 26, COS0_5 , 1);
+    BF0(10, 21, COS0_10, 1);
+    /* pass 2 */
+    BF( 5, 10, COS1_5 , 2);
+    BF(21, 26,-COS1_5 , 2);
+    /* pass 3 */
+    BF( 2,  5, COS2_2 , 1);
+    BF(10, 13,-COS2_2 , 1);
+    BF(18, 21, COS2_2 , 1);
+    BF(26, 29,-COS2_2 , 1);
+    /* pass 4 */
+    BF( 1,  2, COS3_1 , 2);
+    BF( 5,  6,-COS3_1 , 2);
+    BF( 9, 10, COS3_1 , 2);
+    BF(13, 14,-COS3_1 , 2);
+    BF(17, 18, COS3_1 , 2);
+    BF(21, 22,-COS3_1 , 2);
+    BF(25, 26, COS3_1 , 2);
+    BF(29, 30,-COS3_1 , 2);
+
+    /* pass 5 */
+    BF1( 0,  1,  2,  3);
+    BF2( 4,  5,  6,  7);
+    BF1( 8,  9, 10, 11);
+    BF2(12, 13, 14, 15);
+    BF1(16, 17, 18, 19);
+    BF2(20, 21, 22, 23);
+    BF1(24, 25, 26, 27);
+    BF2(28, 29, 30, 31);
+
+    /* pass 6 */
+
+    ADD( 8, 12);
+    ADD(12, 10);
+    ADD(10, 14);
+    ADD(14,  9);
+    ADD( 9, 13);
+    ADD(13, 11);
+    ADD(11, 15);
+
+    out[ 0] = val0;
+    out[16] = val1;
+    out[ 8] = val2;
+    out[24] = val3;
+    out[ 4] = val4;
+    out[20] = val5;
+    out[12] = val6;
+    out[28] = val7;
+    out[ 2] = val8;
+    out[18] = val9;
+    out[10] = val10;
+    out[26] = val11;
+    out[ 6] = val12;
+    out[22] = val13;
+    out[14] = val14;
+    out[30] = val15;
+
+    ADD(24, 28);
+    ADD(28, 26);
+    ADD(26, 30);
+    ADD(30, 25);
+    ADD(25, 29);
+    ADD(29, 27);
+    ADD(27, 31);
+
+    out[ 1] = val16 + val24;
+    out[17] = val17 + val25;
+    out[ 9] = val18 + val26;
+    out[25] = val19 + val27;
+    out[ 5] = val20 + val28;
+    out[21] = val21 + val29;
+    out[13] = val22 + val30;
+    out[29] = val23 + val31;
+    out[ 3] = val24 + val20;
+    out[19] = val25 + val21;
+    out[11] = val26 + val22;
+    out[27] = val27 + val23;
+    out[ 7] = val28 + val18;
+    out[23] = val29 + val19;
+    out[15] = val30 + val17;
+    out[31] = val31;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dxva2_mpeg2.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dxva2_mpeg2.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dxva2_mpeg2.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,274 @@
+/*
+ * MPEG-2 HW acceleration.
+ *
+ * copyright (c) 2010 Laurent Aimar
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "dxva2_internal.h"
+
+#define MAX_SLICES (SLICE_MAX_START_CODE - SLICE_MIN_START_CODE + 1)
+struct dxva2_picture_context {
+    DXVA_PictureParameters pp;
+    DXVA_QmatrixData       qm;
+    unsigned               slice_count;
+    DXVA_SliceInfo         slice[MAX_SLICES];
+
+    const uint8_t          *bitstream;
+    unsigned               bitstream_size;
+};
+
+static void fill_picture_parameters(AVCodecContext *avctx,
+                                    struct dxva_context *ctx,
+                                    const struct MpegEncContext *s,
+                                    DXVA_PictureParameters *pp)
+{
+    const Picture *current_picture = s->current_picture_ptr;
+    int is_field = s->picture_structure != PICT_FRAME;
+
+    memset(pp, 0, sizeof(*pp));
+    pp->wDecodedPictureIndex         = ff_dxva2_get_surface_index(ctx, current_picture);
+    pp->wDeblockedPictureIndex       = 0;
+    if (s->pict_type != FF_I_TYPE)
+        pp->wForwardRefPictureIndex  = ff_dxva2_get_surface_index(ctx, &s->last_picture);
+    else
+        pp->wForwardRefPictureIndex  = 0xffff;
+    if (s->pict_type == FF_B_TYPE)
+        pp->wBackwardRefPictureIndex = ff_dxva2_get_surface_index(ctx, &s->next_picture);
+    else
+        pp->wBackwardRefPictureIndex = 0xffff;
+    pp->wPicWidthInMBminus1          = s->mb_width  - 1;
+    pp->wPicHeightInMBminus1         = (s->mb_height >> is_field) - 1;
+    pp->bMacroblockWidthMinus1       = 15;
+    pp->bMacroblockHeightMinus1      = 15;
+    pp->bBlockWidthMinus1            = 7;
+    pp->bBlockHeightMinus1           = 7;
+    pp->bBPPminus1                   = 7;
+    pp->bPicStructure                = s->picture_structure;
+    pp->bSecondField                 = is_field && !s->first_field;
+    pp->bPicIntra                    = s->pict_type == FF_I_TYPE;
+    pp->bPicBackwardPrediction       = s->pict_type == FF_B_TYPE;
+    pp->bBidirectionalAveragingMode  = 0;
+    pp->bMVprecisionAndChromaRelation= 0; /* FIXME */
+    pp->bChromaFormat                = s->chroma_format;
+    pp->bPicScanFixed                = 1;
+    pp->bPicScanMethod               = s->alternate_scan ? 1 : 0;
+    pp->bPicReadbackRequests         = 0;
+    pp->bRcontrol                    = 0;
+    pp->bPicSpatialResid8            = 0;
+    pp->bPicOverflowBlocks           = 0;
+    pp->bPicExtrapolation            = 0;
+    pp->bPicDeblocked                = 0;
+    pp->bPicDeblockConfined          = 0;
+    pp->bPic4MVallowed               = 0;
+    pp->bPicOBMC                     = 0;
+    pp->bPicBinPB                    = 0;
+    pp->bMV_RPS                      = 0;
+    pp->bReservedBits                = 0;
+    pp->wBitstreamFcodes             = (s->mpeg_f_code[0][0] << 12) |
+                                       (s->mpeg_f_code[0][1] <<  8) |
+                                       (s->mpeg_f_code[1][0] <<  4) |
+                                       (s->mpeg_f_code[1][1]      );
+    pp->wBitstreamPCEelements        = (s->intra_dc_precision         << 14) |
+                                       (s->picture_structure          << 12) |
+                                       (s->top_field_first            << 11) |
+                                       (s->frame_pred_frame_dct       << 10) |
+                                       (s->concealment_motion_vectors <<  9) |
+                                       (s->q_scale_type               <<  8) |
+                                       (s->intra_vlc_format           <<  7) |
+                                       (s->alternate_scan             <<  6) |
+                                       (s->repeat_first_field         <<  5) |
+                                       (s->chroma_420_type            <<  4) |
+                                       (s->progressive_frame          <<  3);
+    pp->bBitstreamConcealmentNeed    = 0;
+    pp->bBitstreamConcealmentMethod  = 0;
+}
+
+static void fill_quantization_matrices(AVCodecContext *avctx,
+                                       struct dxva_context *ctx,
+                                       const struct MpegEncContext *s,
+                                       DXVA_QmatrixData *qm)
+{
+    int i;
+    for (i = 0; i < 4; i++)
+        qm->bNewQmatrix[i] = 1;
+    for (i = 0; i < 64; i++) {
+        int n = s->dsp.idct_permutation[ff_zigzag_direct[i]];
+        qm->Qmatrix[0][i] = s->intra_matrix[n];;
+        qm->Qmatrix[1][i] = s->inter_matrix[n];;
+        qm->Qmatrix[2][i] = s->chroma_intra_matrix[n];;
+        qm->Qmatrix[3][i] = s->chroma_inter_matrix[n];;
+    }
+}
+
+static void fill_slice(AVCodecContext *avctx,
+                       const struct MpegEncContext *s,
+                       DXVA_SliceInfo *slice,
+                       unsigned position,
+                       const uint8_t *buffer, unsigned size)
+{
+    int is_field = s->picture_structure != PICT_FRAME;
+    GetBitContext gb;
+
+    memset(slice, 0, sizeof(*slice));
+    slice->wHorizontalPosition = s->mb_x;
+    slice->wVerticalPosition   = s->mb_y >> is_field;
+    slice->dwSliceBitsInBuffer = 8 * size;
+    slice->dwSliceDataLocation = position;
+    slice->bStartCodeBitOffset = 0;
+    slice->bReservedBits       = 0;
+    /* XXX We store the index of the first MB and it will be fixed later */
+    slice->wNumberMBsInSlice   = (s->mb_y >> is_field) * s->mb_width + s->mb_x;
+    slice->wBadSliceChopping   = 0;
+
+    init_get_bits(&gb, &buffer[4], 8 * (size - 4));
+
+    slice->wQuantizerScaleCode = get_bits(&gb, 5);
+    while (get_bits1(&gb))
+        skip_bits(&gb, 8);
+
+    slice->wMBbitOffset        = 4 * 8 + get_bits_count(&gb);
+}
+static int commit_bitstream_and_slice_buffer(AVCodecContext *avctx,
+                                             DXVA2_DecodeBufferDesc *bs,
+                                             DXVA2_DecodeBufferDesc *sc)
+{
+    const struct MpegEncContext *s = avctx->priv_data;
+    struct dxva_context *ctx = avctx->hwaccel_context;
+    struct dxva2_picture_context *ctx_pic =
+        s->current_picture_ptr->hwaccel_picture_private;
+    const int is_field = s->picture_structure != PICT_FRAME;
+    const unsigned mb_count = s->mb_width * (s->mb_height >> is_field);
+    uint8_t  *dxva_data, *current, *end;
+    unsigned dxva_size;
+    unsigned i;
+
+    if (FAILED(IDirectXVideoDecoder_GetBuffer(ctx->decoder,
+                                              DXVA2_BitStreamDateBufferType,
+                                              &dxva_data, &dxva_size)))
+        return -1;
+    current = dxva_data;
+    end = dxva_data + dxva_size;
+
+    for (i = 0; i < ctx_pic->slice_count; i++) {
+        DXVA_SliceInfo *slice = &ctx_pic->slice[i];
+        unsigned position = slice->dwSliceDataLocation;
+        unsigned size     = slice->dwSliceBitsInBuffer / 8;
+        if (size > end - current) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to build bitstream");
+            break;
+        }
+        slice->dwSliceDataLocation = current - dxva_data;
+
+        if (i < ctx_pic->slice_count - 1)
+            slice->wNumberMBsInSlice =
+                slice[1].wNumberMBsInSlice - slice[0].wNumberMBsInSlice;
+        else
+            slice->wNumberMBsInSlice =
+                mb_count - slice[0].wNumberMBsInSlice;
+
+        memcpy(current, &ctx_pic->bitstream[position], size);
+        current += size;
+    }
+    if (FAILED(IDirectXVideoDecoder_ReleaseBuffer(ctx->decoder,
+                                                  DXVA2_BitStreamDateBufferType)))
+        return -1;
+    if (i < ctx_pic->slice_count)
+        return -1;
+
+    memset(bs, 0, sizeof(*bs));
+    bs->CompressedBufferType = DXVA2_BitStreamDateBufferType;
+    bs->DataSize             = current - dxva_data;
+    bs->NumMBsInBuffer       = mb_count;
+
+    return ff_dxva2_commit_buffer(avctx, ctx, sc,
+                                  DXVA2_SliceControlBufferType,
+                                  ctx_pic->slice,
+                                  ctx_pic->slice_count * sizeof(*ctx_pic->slice),
+                                  mb_count);
+}
+
+static int start_frame(AVCodecContext *avctx,
+                       av_unused const uint8_t *buffer,
+                       av_unused uint32_t size)
+{
+    const struct MpegEncContext *s = avctx->priv_data;
+    struct dxva_context *ctx = avctx->hwaccel_context;
+    struct dxva2_picture_context *ctx_pic =
+        s->current_picture_ptr->hwaccel_picture_private;
+
+    if (!ctx->decoder || !ctx->cfg || ctx->surface_count <= 0)
+        return -1;
+    assert(ctx_pic);
+
+    fill_picture_parameters(avctx, ctx, s, &ctx_pic->pp);
+    fill_quantization_matrices(avctx, ctx, s, &ctx_pic->qm);
+
+    ctx_pic->slice_count    = 0;
+    ctx_pic->bitstream_size = 0;
+    ctx_pic->bitstream      = NULL;
+    return 0;
+}
+
+static int decode_slice(AVCodecContext *avctx,
+                        const uint8_t *buffer, uint32_t size)
+{
+    const struct MpegEncContext *s = avctx->priv_data;
+    struct dxva2_picture_context *ctx_pic =
+        s->current_picture_ptr->hwaccel_picture_private;
+    unsigned position;
+
+    if (ctx_pic->slice_count >= MAX_SLICES)
+        return -1;
+
+    if (!ctx_pic->bitstream)
+        ctx_pic->bitstream = buffer;
+    ctx_pic->bitstream_size += size;
+
+    position = buffer - ctx_pic->bitstream;
+    fill_slice(avctx, s, &ctx_pic->slice[ctx_pic->slice_count++], position,
+               buffer, size);
+    return 0;
+}
+
+static int end_frame(AVCodecContext *avctx)
+{
+    struct MpegEncContext *s = avctx->priv_data;
+    struct dxva2_picture_context *ctx_pic =
+        s->current_picture_ptr->hwaccel_picture_private;
+
+    if (ctx_pic->slice_count <= 0 || ctx_pic->bitstream_size <= 0)
+        return -1;
+    return ff_dxva2_common_end_frame(avctx, s,
+                                     &ctx_pic->pp, sizeof(ctx_pic->pp),
+                                     &ctx_pic->qm, sizeof(ctx_pic->qm),
+                                     commit_bitstream_and_slice_buffer);
+}
+
+AVHWAccel mpeg2_dxva2_hwaccel = {
+    .name           = "mpeg2_dxva2",
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = CODEC_ID_MPEG2VIDEO,
+    .pix_fmt        = PIX_FMT_DXVA2_VLD,
+    .capabilities   = 0,
+    .start_frame    = start_frame,
+    .decode_slice   = decode_slice,
+    .end_frame      = end_frame,
+    .priv_data_size = sizeof(struct dxva2_picture_context),
+};
+

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,1673 @@
+/**
+ * VP8 compatible video decoder
+ *
+ * Copyright (C) 2010 David Conrad
+ * Copyright (C) 2010 Ronald S. Bultje
+ * Copyright (C) 2010 Jason Garrett-Glaser
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avcodec.h"
+#include "vp56.h"
+#include "vp8data.h"
+#include "vp8dsp.h"
+#include "h264pred.h"
+#include "rectangle.h"
+
+typedef struct {
+    uint8_t filter_level;
+    uint8_t inner_limit;
+    uint8_t inner_filter;
+} VP8FilterStrength;
+
+typedef struct {
+    uint8_t skip;
+    // todo: make it possible to check for at least (i4x4 or split_mv)
+    // in one op. are others needed?
+    uint8_t mode;
+    uint8_t ref_frame;
+    uint8_t partitioning;
+    VP56mv mv;
+    VP56mv bmv[16];
+} VP8Macroblock;
+
+typedef struct {
+    AVCodecContext *avctx;
+    DSPContext dsp;
+    VP8DSPContext vp8dsp;
+    H264PredContext hpc;
+    vp8_mc_func put_pixels_tab[3][3][3];
+    AVFrame frames[4];
+    AVFrame *framep[4];
+    uint8_t *edge_emu_buffer;
+    VP56RangeCoder c;   ///< header context, includes mb modes and motion vectors
+    int profile;
+
+    int mb_width;   /* number of horizontal MB */
+    int mb_height;  /* number of vertical MB */
+    int linesize;
+    int uvlinesize;
+
+    int keyframe;
+    int invisible;
+    int update_last;    ///< update VP56_FRAME_PREVIOUS with the current one
+    int update_golden;  ///< VP56_FRAME_NONE if not updated, or which frame to copy if so
+    int update_altref;
+    int deblock_filter;
+
+    /**
+     * If this flag is not set, all the probability updates
+     * are discarded after this frame is decoded.
+     */
+    int update_probabilities;
+
+    /**
+     * All coefficients are contained in separate arith coding contexts.
+     * There can be 1, 2, 4, or 8 of these after the header context.
+     */
+    int num_coeff_partitions;
+    VP56RangeCoder coeff_partition[8];
+
+    VP8Macroblock *macroblocks;
+    VP8Macroblock *macroblocks_base;
+    VP8FilterStrength *filter_strength;
+    int mb_stride;
+
+    uint8_t *intra4x4_pred_mode;
+    uint8_t *intra4x4_pred_mode_base;
+    uint8_t *segmentation_map;
+    int b4_stride;
+
+    /**
+     * Cache of the top row needed for intra prediction
+     * 16 for luma, 8 for each chroma plane
+     */
+    uint8_t (*top_border)[16+8+8];
+
+    /**
+     * For coeff decode, we need to know whether the above block had non-zero
+     * coefficients. This means for each macroblock, we need data for 4 luma
+     * blocks, 2 u blocks, 2 v blocks, and the luma dc block, for a total of 9
+     * per macroblock. We keep the last row in top_nnz.
+     */
+    uint8_t (*top_nnz)[9];
+    DECLARE_ALIGNED(8, uint8_t, left_nnz)[9];
+
+    /**
+     * This is the index plus one of the last non-zero coeff
+     * for each of the blocks in the current macroblock.
+     * So, 0 -> no coeffs
+     *     1 -> dc-only (special transform)
+     *     2+-> full transform
+     */
+    DECLARE_ALIGNED(16, uint8_t, non_zero_count_cache)[6][4];
+    DECLARE_ALIGNED(16, DCTELEM, block)[6][4][16];
+    uint8_t intra4x4_pred_mode_mb[16];
+
+    int chroma_pred_mode;    ///< 8x8c pred mode of the current macroblock
+    int segment;             ///< segment of the current macroblock
+
+    int mbskip_enabled;
+    int sign_bias[4]; ///< one state [0, 1] per ref frame type
+    int ref_count[3];
+
+    /**
+     * Base parameters for segmentation, i.e. per-macroblock parameters.
+     * These must be kept unchanged even if segmentation is not used for
+     * a frame, since the values persist between interframes.
+     */
+    struct {
+        int enabled;
+        int absolute_vals;
+        int update_map;
+        int8_t base_quant[4];
+        int8_t filter_level[4];     ///< base loop filter level
+    } segmentation;
+
+    /**
+     * Macroblocks can have one of 4 different quants in a frame when
+     * segmentation is enabled.
+     * If segmentation is disabled, only the first segment's values are used.
+     */
+    struct {
+        // [0] - DC qmul  [1] - AC qmul
+        int16_t luma_qmul[2];
+        int16_t luma_dc_qmul[2];    ///< luma dc-only block quant
+        int16_t chroma_qmul[2];
+    } qmat[4];
+
+    struct {
+        int simple;
+        int level;
+        int sharpness;
+    } filter;
+
+    struct {
+        int enabled;    ///< whether each mb can have a different strength based on mode/ref
+
+        /**
+         * filter strength adjustment for the following macroblock modes:
+         * [0] - i4x4
+         * [1] - zero mv
+         * [2] - inter modes except for zero or split mv
+         * [3] - split mv
+         *  i16x16 modes never have any adjustment
+         */
+        int8_t mode[4];
+
+        /**
+         * filter strength adjustment for macroblocks that reference:
+         * [0] - intra / VP56_FRAME_CURRENT
+         * [1] - VP56_FRAME_PREVIOUS
+         * [2] - VP56_FRAME_GOLDEN
+         * [3] - altref / VP56_FRAME_GOLDEN2
+         */
+        int8_t ref[4];
+    } lf_delta;
+
+    /**
+     * These are all of the updatable probabilities for binary decisions.
+     * They are only implictly reset on keyframes, making it quite likely
+     * for an interframe to desync if a prior frame's header was corrupt
+     * or missing outright!
+     */
+    struct {
+        uint8_t segmentid[3];
+        uint8_t mbskip;
+        uint8_t intra;
+        uint8_t last;
+        uint8_t golden;
+        uint8_t pred16x16[4];
+        uint8_t pred8x8c[3];
+        uint8_t token[4][8][3][NUM_DCT_TOKENS-1];
+        uint8_t mvc[2][19];
+    } prob[2];
+} VP8Context;
+
+static void vp8_decode_flush(AVCodecContext *avctx)
+{
+    VP8Context *s = avctx->priv_data;
+    int i;
+
+    for (i = 0; i < 4; i++)
+        if (s->frames[i].data[0])
+            avctx->release_buffer(avctx, &s->frames[i]);
+    memset(s->framep, 0, sizeof(s->framep));
+
+    av_freep(&s->macroblocks_base);
+    av_freep(&s->intra4x4_pred_mode_base);
+    av_freep(&s->top_nnz);
+    av_freep(&s->edge_emu_buffer);
+    av_freep(&s->top_border);
+    av_freep(&s->segmentation_map);
+
+    s->macroblocks        = NULL;
+    s->intra4x4_pred_mode = NULL;
+}
+
+static int update_dimensions(VP8Context *s, int width, int height)
+{
+    int i;
+
+    if (avcodec_check_dimensions(s->avctx, width, height))
+        return AVERROR_INVALIDDATA;
+
+    vp8_decode_flush(s->avctx);
+
+    avcodec_set_dimensions(s->avctx, width, height);
+
+    s->mb_width  = (s->avctx->coded_width +15) / 16;
+    s->mb_height = (s->avctx->coded_height+15) / 16;
+
+    // we allocate a border around the top/left of intra4x4 modes
+    // this is 4 blocks for intra4x4 to keep 4-byte alignment for fill_rectangle
+    s->mb_stride = s->mb_width+1;
+    s->b4_stride = 4*s->mb_stride;
+
+    s->macroblocks_base        = av_mallocz((s->mb_stride+s->mb_height*2+2)*sizeof(*s->macroblocks));
+    s->filter_strength         = av_mallocz(s->mb_stride*sizeof(*s->filter_strength));
+    s->intra4x4_pred_mode_base = av_mallocz(s->b4_stride*(4*s->mb_height+1));
+    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));
+    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));
+    s->segmentation_map        = av_mallocz(s->mb_stride*s->mb_height);
+
+    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_base ||
+        !s->top_nnz || !s->top_border || !s->segmentation_map)
+        return AVERROR(ENOMEM);
+
+    s->macroblocks        = s->macroblocks_base + 1;
+    s->intra4x4_pred_mode = s->intra4x4_pred_mode_base + 4 + s->b4_stride;
+
+    memset(s->intra4x4_pred_mode_base, DC_PRED, s->b4_stride);
+    for (i = 0; i < 4*s->mb_height; i++)
+        s->intra4x4_pred_mode[i*s->b4_stride-1] = DC_PRED;
+
+    return 0;
+}
+
+static void parse_segment_info(VP8Context *s)
+{
+    VP56RangeCoder *c = &s->c;
+    int i;
+
+    s->segmentation.update_map = vp8_rac_get(c);
+
+    if (vp8_rac_get(c)) { // update segment feature data
+        s->segmentation.absolute_vals = vp8_rac_get(c);
+
+        for (i = 0; i < 4; i++)
+            s->segmentation.base_quant[i]   = vp8_rac_get_sint(c, 7);
+
+        for (i = 0; i < 4; i++)
+            s->segmentation.filter_level[i] = vp8_rac_get_sint(c, 6);
+    }
+    if (s->segmentation.update_map)
+        for (i = 0; i < 3; i++)
+            s->prob->segmentid[i] = vp8_rac_get(c) ? vp8_rac_get_uint(c, 8) : 255;
+}
+
+static void update_lf_deltas(VP8Context *s)
+{
+    VP56RangeCoder *c = &s->c;
+    int i;
+
+    for (i = 0; i < 4; i++)
+        s->lf_delta.ref[i]  = vp8_rac_get_sint(c, 6);
+
+    for (i = 0; i < 4; i++)
+        s->lf_delta.mode[i] = vp8_rac_get_sint(c, 6);
+}
+
+static int setup_partitions(VP8Context *s, const uint8_t *buf, int buf_size)
+{
+    const uint8_t *sizes = buf;
+    int i;
+
+    s->num_coeff_partitions = 1 << vp8_rac_get_uint(&s->c, 2);
+
+    buf      += 3*(s->num_coeff_partitions-1);
+    buf_size -= 3*(s->num_coeff_partitions-1);
+    if (buf_size < 0)
+        return -1;
+
+    for (i = 0; i < s->num_coeff_partitions-1; i++) {
+        int size = AV_RL24(sizes + 3*i);
+        if (buf_size - size < 0)
+            return -1;
+
+        vp56_init_range_decoder(&s->coeff_partition[i], buf, size);
+        buf      += size;
+        buf_size -= size;
+    }
+    vp56_init_range_decoder(&s->coeff_partition[i], buf, buf_size);
+
+    return 0;
+}
+
+static void get_quants(VP8Context *s)
+{
+    VP56RangeCoder *c = &s->c;
+    int i, base_qi;
+
+    int yac_qi     = vp8_rac_get_uint(c, 7);
+    int ydc_delta  = vp8_rac_get_sint(c, 4);
+    int y2dc_delta = vp8_rac_get_sint(c, 4);
+    int y2ac_delta = vp8_rac_get_sint(c, 4);
+    int uvdc_delta = vp8_rac_get_sint(c, 4);
+    int uvac_delta = vp8_rac_get_sint(c, 4);
+
+    for (i = 0; i < 4; i++) {
+        if (s->segmentation.enabled) {
+            base_qi = s->segmentation.base_quant[i];
+            if (!s->segmentation.absolute_vals)
+                base_qi += yac_qi;
+        } else
+            base_qi = yac_qi;
+
+        s->qmat[i].luma_qmul[0]    =       vp8_dc_qlookup[av_clip(base_qi + ydc_delta , 0, 127)];
+        s->qmat[i].luma_qmul[1]    =       vp8_ac_qlookup[av_clip(base_qi             , 0, 127)];
+        s->qmat[i].luma_dc_qmul[0] =   2 * vp8_dc_qlookup[av_clip(base_qi + y2dc_delta, 0, 127)];
+        s->qmat[i].luma_dc_qmul[1] = 155 * vp8_ac_qlookup[av_clip(base_qi + y2ac_delta, 0, 127)] / 100;
+        s->qmat[i].chroma_qmul[0]  =       vp8_dc_qlookup[av_clip(base_qi + uvdc_delta, 0, 127)];
+        s->qmat[i].chroma_qmul[1]  =       vp8_ac_qlookup[av_clip(base_qi + uvac_delta, 0, 127)];
+
+        s->qmat[i].luma_dc_qmul[1] = FFMAX(s->qmat[i].luma_dc_qmul[1], 8);
+        s->qmat[i].chroma_qmul[0]  = FFMIN(s->qmat[i].chroma_qmul[0], 132);
+    }
+}
+
+/**
+ * Determine which buffers golden and altref should be updated with after this frame.
+ * The spec isn't clear here, so I'm going by my understanding of what libvpx does
+ *
+ * Intra frames update all 3 references
+ * Inter frames update VP56_FRAME_PREVIOUS if the update_last flag is set
+ * If the update (golden|altref) flag is set, it's updated with the current frame
+ *      if update_last is set, and VP56_FRAME_PREVIOUS otherwise.
+ * If the flag is not set, the number read means:
+ *      0: no update
+ *      1: VP56_FRAME_PREVIOUS
+ *      2: update golden with altref, or update altref with golden
+ */
+static VP56Frame ref_to_update(VP8Context *s, int update, VP56Frame ref)
+{
+    VP56RangeCoder *c = &s->c;
+
+    if (update)
+        return VP56_FRAME_CURRENT;
+
+    switch (vp8_rac_get_uint(c, 2)) {
+    case 1:
+        return VP56_FRAME_PREVIOUS;
+    case 2:
+        return (ref == VP56_FRAME_GOLDEN) ? VP56_FRAME_GOLDEN2 : VP56_FRAME_GOLDEN;
+    }
+    return VP56_FRAME_NONE;
+}
+
+static void update_refs(VP8Context *s)
+{
+    VP56RangeCoder *c = &s->c;
+
+    int update_golden = vp8_rac_get(c);
+    int update_altref = vp8_rac_get(c);
+
+    s->update_golden = ref_to_update(s, update_golden, VP56_FRAME_GOLDEN);
+    s->update_altref = ref_to_update(s, update_altref, VP56_FRAME_GOLDEN2);
+}
+
+static int decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_size)
+{
+    VP56RangeCoder *c = &s->c;
+    int header_size, hscale, vscale, i, j, k, l, ret;
+    int width  = s->avctx->width;
+    int height = s->avctx->height;
+
+    s->keyframe  = !(buf[0] & 1);
+    s->profile   =  (buf[0]>>1) & 7;
+    s->invisible = !(buf[0] & 0x10);
+    header_size  = AV_RL24(buf) >> 5;
+    buf      += 3;
+    buf_size -= 3;
+
+    if (s->profile > 3)
+        av_log(s->avctx, AV_LOG_WARNING, "Unknown profile %d\n", s->profile);
+
+    if (!s->profile)
+        memcpy(s->put_pixels_tab, s->vp8dsp.put_vp8_epel_pixels_tab, sizeof(s->put_pixels_tab));
+    else    // profile 1-3 use bilinear, 4+ aren't defined so whatever
+        memcpy(s->put_pixels_tab, s->vp8dsp.put_vp8_bilinear_pixels_tab, sizeof(s->put_pixels_tab));
+
+    if (header_size > buf_size - 7*s->keyframe) {
+        av_log(s->avctx, AV_LOG_ERROR, "Header size larger than data provided\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (s->keyframe) {
+        if (AV_RL24(buf) != 0x2a019d) {
+            av_log(s->avctx, AV_LOG_ERROR, "Invalid start code 0x%x\n", AV_RL24(buf));
+            return AVERROR_INVALIDDATA;
+        }
+        width  = AV_RL16(buf+3) & 0x3fff;
+        height = AV_RL16(buf+5) & 0x3fff;
+        hscale = buf[4] >> 6;
+        vscale = buf[6] >> 6;
+        buf      += 7;
+        buf_size -= 7;
+
+        if (hscale || vscale)
+            av_log_missing_feature(s->avctx, "Upscaling", 1);
+
+        s->update_golden = s->update_altref = VP56_FRAME_CURRENT;
+        memcpy(s->prob->token    , vp8_token_default_probs , sizeof(s->prob->token));
+        memcpy(s->prob->pred16x16, vp8_pred16x16_prob_inter, sizeof(s->prob->pred16x16));
+        memcpy(s->prob->pred8x8c , vp8_pred8x8c_prob_inter , sizeof(s->prob->pred8x8c));
+        memcpy(s->prob->mvc      , vp8_mv_default_prob     , sizeof(s->prob->mvc));
+        memset(&s->segmentation, 0, sizeof(s->segmentation));
+    }
+
+    if (!s->macroblocks_base || /* first frame */
+        width != s->avctx->width || height != s->avctx->height) {
+        if ((ret = update_dimensions(s, width, height) < 0))
+            return ret;
+    }
+
+    vp56_init_range_decoder(c, buf, header_size);
+    buf      += header_size;
+    buf_size -= header_size;
+
+    if (s->keyframe) {
+        if (vp8_rac_get(c))
+            av_log(s->avctx, AV_LOG_WARNING, "Unspecified colorspace\n");
+        vp8_rac_get(c); // whether we can skip clamping in dsp functions
+    }
+
+    if ((s->segmentation.enabled = vp8_rac_get(c)))
+        parse_segment_info(s);
+    else
+        s->segmentation.update_map = 0; // FIXME: move this to some init function?
+
+    s->filter.simple    = vp8_rac_get(c);
+    s->filter.level     = vp8_rac_get_uint(c, 6);
+    s->filter.sharpness = vp8_rac_get_uint(c, 3);
+
+    if ((s->lf_delta.enabled = vp8_rac_get(c)))
+        if (vp8_rac_get(c))
+            update_lf_deltas(s);
+
+    if (setup_partitions(s, buf, buf_size)) {
+        av_log(s->avctx, AV_LOG_ERROR, "Invalid partitions\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    get_quants(s);
+
+    if (!s->keyframe) {
+        update_refs(s);
+        s->sign_bias[VP56_FRAME_GOLDEN]               = vp8_rac_get(c);
+        s->sign_bias[VP56_FRAME_GOLDEN2 /* altref */] = vp8_rac_get(c);
+    }
+
+    // if we aren't saving this frame's probabilities for future frames,
+    // make a copy of the current probabilities
+    if (!(s->update_probabilities = vp8_rac_get(c)))
+        s->prob[1] = s->prob[0];
+
+    s->update_last = s->keyframe || vp8_rac_get(c);
+
+    for (i = 0; i < 4; i++)
+        for (j = 0; j < 8; j++)
+            for (k = 0; k < 3; k++)
+                for (l = 0; l < NUM_DCT_TOKENS-1; l++)
+                    if (vp56_rac_get_prob_branchy(c, vp8_token_update_probs[i][j][k][l]))
+                        s->prob->token[i][j][k][l] = vp8_rac_get_uint(c, 8);
+
+    if ((s->mbskip_enabled = vp8_rac_get(c)))
+        s->prob->mbskip = vp8_rac_get_uint(c, 8);
+
+    if (!s->keyframe) {
+        s->prob->intra  = vp8_rac_get_uint(c, 8);
+        s->prob->last   = vp8_rac_get_uint(c, 8);
+        s->prob->golden = vp8_rac_get_uint(c, 8);
+
+        if (vp8_rac_get(c))
+            for (i = 0; i < 4; i++)
+                s->prob->pred16x16[i] = vp8_rac_get_uint(c, 8);
+        if (vp8_rac_get(c))
+            for (i = 0; i < 3; i++)
+                s->prob->pred8x8c[i]  = vp8_rac_get_uint(c, 8);
+
+        // 17.2 MV probability update
+        for (i = 0; i < 2; i++)
+            for (j = 0; j < 19; j++)
+                if (vp56_rac_get_prob_branchy(c, vp8_mv_update_prob[i][j]))
+                    s->prob->mvc[i][j] = vp8_rac_get_nn(c);
+    }
+
+    return 0;
+}
+
+static av_always_inline
+void clamp_mv(VP8Context *s, VP56mv *dst, const VP56mv *src, int mb_x, int mb_y)
+{
+#define MARGIN (16 << 2)
+    dst->x = av_clip(src->x, -((mb_x << 6) + MARGIN),
+                     ((s->mb_width  - 1 - mb_x) << 6) + MARGIN);
+    dst->y = av_clip(src->y, -((mb_y << 6) + MARGIN),
+                     ((s->mb_height - 1 - mb_y) << 6) + MARGIN);
+}
+
+static av_always_inline
+void find_near_mvs(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,
+                   VP56mv near[2], VP56mv *best, uint8_t cnt[4])
+{
+    VP8Macroblock *mb_edge[3] = { mb + 2 /* top */,
+                                  mb - 1 /* left */,
+                                  mb + 1 /* top-left */ };
+    enum { EDGE_TOP, EDGE_LEFT, EDGE_TOPLEFT };
+    VP56mv near_mv[4]  = {{ 0 }};
+    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };
+    int idx = CNT_ZERO;
+    int best_idx = CNT_ZERO;
+    int cur_sign_bias = s->sign_bias[mb->ref_frame];
+    int *sign_bias = s->sign_bias;
+
+    /* Process MB on top, left and top-left */
+    #define MV_EDGE_CHECK(n)\
+    {\
+        VP8Macroblock *edge = mb_edge[n];\
+        int edge_ref = edge->ref_frame;\
+        if (edge_ref != VP56_FRAME_CURRENT) {\
+            uint32_t mv = AV_RN32A(&edge->mv);\
+            if (mv) {\
+                if (cur_sign_bias != sign_bias[edge_ref]) {\
+                    /* SWAR negate of the values in mv. */\
+                    mv = ~mv;\
+                    mv = ((mv&0x7fff7fff) + 0x00010001) ^ (mv&0x80008000);\
+                }\
+                if (!n || mv != AV_RN32A(&near_mv[idx]))\
+                    AV_WN32A(&near_mv[++idx], mv);\
+                cnt[idx]      += 1 + (n != 2);\
+            } else\
+                cnt[CNT_ZERO] += 1 + (n != 2);\
+        }\
+    }
+    MV_EDGE_CHECK(0)
+    MV_EDGE_CHECK(1)
+    MV_EDGE_CHECK(2)
+
+    /* If we have three distinct MVs, merge first and last if they're the same */
+    if (cnt[CNT_SPLITMV] && AV_RN32A(&near_mv[1+EDGE_TOP]) == AV_RN32A(&near_mv[1+EDGE_TOPLEFT]))
+        cnt[CNT_NEAREST] += 1;
+
+    cnt[CNT_SPLITMV] = ((mb_edge[EDGE_LEFT]->mode   == VP8_MVMODE_SPLIT) +
+                        (mb_edge[EDGE_TOP]->mode    == VP8_MVMODE_SPLIT)) * 2 +
+                       (mb_edge[EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);
+
+    /* Swap near and nearest if necessary */
+    if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {
+        FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);
+        FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);
+    }
+
+    /* Choose the best mv out of 0,0 and the nearest mv */
+    if (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])
+        best_idx = CNT_NEAREST;
+
+    mb->mv  = near_mv[best_idx];
+    near[0] = near_mv[CNT_NEAREST];
+    near[1] = near_mv[CNT_NEAR];
+}
+
+/**
+ * Motion vector coding, 17.1.
+ */
+static int read_mv_component(VP56RangeCoder *c, const uint8_t *p)
+{
+    int bit, x = 0;
+
+    if (vp56_rac_get_prob_branchy(c, p[0])) {
+        int i;
+
+        for (i = 0; i < 3; i++)
+            x += vp56_rac_get_prob(c, p[9 + i]) << i;
+        for (i = 9; i > 3; i--)
+            x += vp56_rac_get_prob(c, p[9 + i]) << i;
+        if (!(x & 0xFFF0) || vp56_rac_get_prob(c, p[12]))
+            x += 8;
+    } else {
+        // small_mvtree
+        const uint8_t *ps = p+2;
+        bit = vp56_rac_get_prob(c, *ps);
+        ps += 1 + 3*bit;
+        x  += 4*bit;
+        bit = vp56_rac_get_prob(c, *ps);
+        ps += 1 + bit;
+        x  += 2*bit;
+        x  += vp56_rac_get_prob(c, *ps);
+    }
+
+    return (x && vp56_rac_get_prob(c, p[1])) ? -x : x;
+}
+
+static av_always_inline
+const uint8_t *get_submv_prob(uint32_t left, uint32_t top)
+{
+    if (left == top)
+        return vp8_submv_prob[4-!!left];
+    if (!top)
+        return vp8_submv_prob[2];
+    return vp8_submv_prob[1-!!left];
+}
+
+/**
+ * Split motion vector prediction, 16.4.
+ * @returns the number of motion vectors parsed (2, 4 or 16)
+ */
+static av_always_inline
+int decode_splitmvs(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb)
+{
+    int part_idx = mb->partitioning =
+        vp8_rac_get_tree(c, vp8_mbsplit_tree, vp8_mbsplit_prob);
+    int n, num = vp8_mbsplit_count[part_idx];
+    VP8Macroblock *top_mb  = &mb[2];
+    VP8Macroblock *left_mb = &mb[-1];
+    const uint8_t *mbsplits_left = vp8_mbsplits[left_mb->partitioning],
+                  *mbsplits_top = vp8_mbsplits[top_mb->partitioning],
+                  *mbsplits_cur = vp8_mbsplits[part_idx],
+                  *firstidx = vp8_mbfirstidx[part_idx];
+    VP56mv *top_mv  = top_mb->bmv;
+    VP56mv *left_mv = left_mb->bmv;
+    VP56mv *cur_mv  = mb->bmv;
+
+    for (n = 0; n < num; n++) {
+        int k = firstidx[n];
+        uint32_t left, above;
+        const uint8_t *submv_prob;
+
+        if (!(k & 3))
+            left = AV_RN32A(&left_mv[mbsplits_left[k + 3]]);
+        else
+            left  = AV_RN32A(&cur_mv[mbsplits_cur[k - 1]]);
+        if (k <= 3)
+            above = AV_RN32A(&top_mv[mbsplits_top[k + 12]]);
+        else
+            above = AV_RN32A(&cur_mv[mbsplits_cur[k - 4]]);
+
+        submv_prob = get_submv_prob(left, above);
+
+        switch (vp8_rac_get_tree(c, vp8_submv_ref_tree, submv_prob)) {
+        case VP8_SUBMVMODE_NEW4X4:
+            mb->bmv[n].y = mb->mv.y + read_mv_component(c, s->prob->mvc[0]);
+            mb->bmv[n].x = mb->mv.x + read_mv_component(c, s->prob->mvc[1]);
+            break;
+        case VP8_SUBMVMODE_ZERO4X4:
+            AV_ZERO32(&mb->bmv[n]);
+            break;
+        case VP8_SUBMVMODE_LEFT4X4:
+            AV_WN32A(&mb->bmv[n], left);
+            break;
+        case VP8_SUBMVMODE_TOP4X4:
+            AV_WN32A(&mb->bmv[n], above);
+            break;
+        }
+    }
+
+    return num;
+}
+
+static av_always_inline
+void decode_intra4x4_modes(VP56RangeCoder *c, uint8_t *intra4x4,
+                           int stride, int keyframe)
+{
+    int x, y, t, l, i;
+
+    if (keyframe) {
+        const uint8_t *ctx;
+        for (y = 0; y < 4; y++) {
+            for (x = 0; x < 4; x++) {
+                t = intra4x4[x - stride];
+                l = intra4x4[x - 1];
+                ctx = vp8_pred4x4_prob_intra[t][l];
+                intra4x4[x] = vp8_rac_get_tree(c, vp8_pred4x4_tree, ctx);
+            }
+            intra4x4 += stride;
+        }
+    } else {
+        for (i = 0; i < 16; i++)
+            intra4x4[i] = vp8_rac_get_tree(c, vp8_pred4x4_tree, vp8_pred4x4_prob_inter);
+    }
+}
+
+static av_always_inline
+void decode_mb_mode(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,
+                    uint8_t *intra4x4, uint8_t *segment)
+{
+    VP56RangeCoder *c = &s->c;
+
+    if (s->segmentation.update_map)
+        *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid);
+    s->segment = *segment;
+
+    mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0;
+
+    if (s->keyframe) {
+        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra, vp8_pred16x16_prob_intra);
+
+        if (mb->mode == MODE_I4x4) {
+            decode_intra4x4_modes(c, intra4x4, s->b4_stride, 1);
+        } else
+            fill_rectangle(intra4x4, 4, 4, s->b4_stride, vp8_pred4x4_mode[mb->mode], 1);
+
+        s->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, vp8_pred8x8c_prob_intra);
+        mb->ref_frame = VP56_FRAME_CURRENT;
+    } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) {
+        VP56mv near[2], best;
+        uint8_t cnt[4] = { 0 };
+        uint8_t p[4];
+
+        // inter MB, 16.2
+        if (vp56_rac_get_prob_branchy(c, s->prob->last))
+            mb->ref_frame = vp56_rac_get_prob(c, s->prob->golden) ?
+                VP56_FRAME_GOLDEN2 /* altref */ : VP56_FRAME_GOLDEN;
+        else
+            mb->ref_frame = VP56_FRAME_PREVIOUS;
+        s->ref_count[mb->ref_frame-1]++;
+
+        // motion vectors, 16.3
+        find_near_mvs(s, mb, mb_x, mb_y, near, &best, cnt);
+        p[0] = vp8_mode_contexts[cnt[0]][0];
+        p[1] = vp8_mode_contexts[cnt[1]][1];
+        p[2] = vp8_mode_contexts[cnt[2]][2];
+        p[3] = vp8_mode_contexts[cnt[3]][3];
+        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_mvinter, p);
+        switch (mb->mode) {
+        case VP8_MVMODE_SPLIT:
+            clamp_mv(s, &mb->mv, &mb->mv, mb_x, mb_y);
+            mb->mv = mb->bmv[decode_splitmvs(s, c, mb) - 1];
+            break;
+        case VP8_MVMODE_ZERO:
+            AV_ZERO32(&mb->mv);
+            break;
+        case VP8_MVMODE_NEAREST:
+            clamp_mv(s, &mb->mv, &near[0], mb_x, mb_y);
+            break;
+        case VP8_MVMODE_NEAR:
+            clamp_mv(s, &mb->mv, &near[1], mb_x, mb_y);
+            break;
+        case VP8_MVMODE_NEW:
+            clamp_mv(s, &mb->mv, &mb->mv, mb_x, mb_y);
+            mb->mv.y += + read_mv_component(c, s->prob->mvc[0]);
+            mb->mv.x += + read_mv_component(c, s->prob->mvc[1]);
+            break;
+        }
+        if (mb->mode != VP8_MVMODE_SPLIT) {
+            mb->partitioning = VP8_SPLITMVMODE_NONE;
+            mb->bmv[0] = mb->mv;
+        }
+    } else {
+        // intra MB, 16.1
+        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16);
+
+        if (mb->mode == MODE_I4x4)
+            decode_intra4x4_modes(c, intra4x4, 4, 0);
+
+        s->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, s->prob->pred8x8c);
+        mb->ref_frame = VP56_FRAME_CURRENT;
+        mb->partitioning = VP8_SPLITMVMODE_NONE;
+        AV_ZERO32(&mb->bmv[0]);
+    }
+}
+
+/**
+ * @param c arithmetic bitstream reader context
+ * @param block destination for block coefficients
+ * @param probs probabilities to use when reading trees from the bitstream
+ * @param i initial coeff index, 0 unless a separate DC block is coded
+ * @param zero_nhood the initial prediction context for number of surrounding
+ *                   all-zero blocks (only left/top, so 0-2)
+ * @param qmul array holding the dc/ac dequant factor at position 0/1
+ * @return 0 if no coeffs were decoded
+ *         otherwise, the index of the last coeff decoded plus one
+ */
+static int decode_block_coeffs(VP56RangeCoder *c, DCTELEM block[16],
+                               uint8_t probs[8][3][NUM_DCT_TOKENS-1],
+                               int i, int zero_nhood, int16_t qmul[2])
+{
+    uint8_t *token_prob;
+    int nonzero = 0;
+    int coeff;
+
+    do {
+        token_prob = probs[vp8_coeff_band[i]][zero_nhood];
+
+        if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB
+            return nonzero;
+
+skip_eob:
+        if (!vp56_rac_get_prob_branchy(c, token_prob[1])) { // DCT_0
+            zero_nhood = 0;
+            token_prob = probs[vp8_coeff_band[++i]][0];
+            if (i < 16)
+                goto skip_eob;
+            return nonzero; // invalid input; blocks should end with EOB
+        }
+
+        if (!vp56_rac_get_prob_branchy(c, token_prob[2])) { // DCT_1
+            coeff = 1;
+            zero_nhood = 1;
+        } else {
+            zero_nhood = 2;
+
+            if (!vp56_rac_get_prob_branchy(c, token_prob[3])) { // DCT 2,3,4
+                coeff = vp56_rac_get_prob(c, token_prob[4]);
+                if (coeff)
+                    coeff += vp56_rac_get_prob(c, token_prob[5]);
+                coeff += 2;
+            } else {
+                // DCT_CAT*
+                if (!vp56_rac_get_prob_branchy(c, token_prob[6])) {
+                    if (!vp56_rac_get_prob_branchy(c, token_prob[7])) { // DCT_CAT1
+                        coeff  = 5 + vp56_rac_get_prob(c, vp8_dct_cat1_prob[0]);
+                    } else {                                    // DCT_CAT2
+                        coeff  = 7;
+                        coeff += vp56_rac_get_prob(c, vp8_dct_cat2_prob[0]) << 1;
+                        coeff += vp56_rac_get_prob(c, vp8_dct_cat2_prob[1]);
+                    }
+                } else {    // DCT_CAT3 and up
+                    int a = vp56_rac_get_prob(c, token_prob[8]);
+                    int b = vp56_rac_get_prob(c, token_prob[9+a]);
+                    int cat = (a<<1) + b;
+                    coeff  = 3 + (8<<cat);
+                    coeff += vp8_rac_get_coeff(c, vp8_dct_cat_prob[cat]);
+                }
+            }
+        }
+
+        // todo: full [16] qmat? load into register?
+        block[zigzag_scan[i]] = (vp8_rac_get(c) ? -coeff : coeff) * qmul[!!i];
+        nonzero = ++i;
+    } while (i < 16);
+
+    return nonzero;
+}
+
+static av_always_inline
+void decode_mb_coeffs(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb,
+                      uint8_t t_nnz[9], uint8_t l_nnz[9])
+{
+    LOCAL_ALIGNED_16(DCTELEM, dc,[16]);
+    int i, x, y, luma_start = 0, luma_ctx = 3;
+    int nnz_pred, nnz, nnz_total = 0;
+    int segment = s->segment;
+
+    if (mb->mode != MODE_I4x4 && mb->mode != VP8_MVMODE_SPLIT) {
+        AV_ZERO128(dc);
+        AV_ZERO128(dc+8);
+        nnz_pred = t_nnz[8] + l_nnz[8];
+
+        // decode DC values and do hadamard
+        nnz = decode_block_coeffs(c, dc, s->prob->token[1], 0, nnz_pred,
+                                  s->qmat[segment].luma_dc_qmul);
+        l_nnz[8] = t_nnz[8] = !!nnz;
+        nnz_total += nnz;
+        s->vp8dsp.vp8_luma_dc_wht(s->block, dc);
+        luma_start = 1;
+        luma_ctx = 0;
+    }
+
+    // luma blocks
+    for (y = 0; y < 4; y++)
+        for (x = 0; x < 4; x++) {
+            nnz_pred = l_nnz[y] + t_nnz[x];
+            nnz = decode_block_coeffs(c, s->block[y][x], s->prob->token[luma_ctx], luma_start,
+                                      nnz_pred, s->qmat[segment].luma_qmul);
+            // nnz+luma_start may be one more than the actual last index, but we don't care
+            s->non_zero_count_cache[y][x] = nnz + luma_start;
+            t_nnz[x] = l_nnz[y] = !!nnz;
+            nnz_total += nnz;
+        }
+
+    // chroma blocks
+    // TODO: what to do about dimensions? 2nd dim for luma is x,
+    // but for chroma it's (y<<1)|x
+    for (i = 4; i < 6; i++)
+        for (y = 0; y < 2; y++)
+            for (x = 0; x < 2; x++) {
+                nnz_pred = l_nnz[i+2*y] + t_nnz[i+2*x];
+                nnz = decode_block_coeffs(c, s->block[i][(y<<1)+x], s->prob->token[2], 0,
+                                          nnz_pred, s->qmat[segment].chroma_qmul);
+                s->non_zero_count_cache[i][(y<<1)+x] = nnz;
+                t_nnz[i+2*x] = l_nnz[i+2*y] = !!nnz;
+                nnz_total += nnz;
+            }
+
+    // if there were no coded coeffs despite the macroblock not being marked skip,
+    // we MUST not do the inner loop filter and should not do IDCT
+    // Since skip isn't used for bitstream prediction, just manually set it.
+    if (!nnz_total)
+        mb->skip = 1;
+}
+
+static av_always_inline
+void backup_mb_border(uint8_t *top_border, uint8_t *src_y, uint8_t *src_cb, uint8_t *src_cr,
+                      int linesize, int uvlinesize, int simple)
+{
+    AV_COPY128(top_border, src_y + 15*linesize);
+    if (!simple) {
+        AV_COPY64(top_border+16, src_cb + 7*uvlinesize);
+        AV_COPY64(top_border+24, src_cr + 7*uvlinesize);
+    }
+}
+
+static av_always_inline
+void xchg_mb_border(uint8_t *top_border, uint8_t *src_y, uint8_t *src_cb, uint8_t *src_cr,
+                    int linesize, int uvlinesize, int mb_x, int mb_y, int mb_width,
+                    int simple, int xchg)
+{
+    uint8_t *top_border_m1 = top_border-32;     // for TL prediction
+    src_y  -=   linesize;
+    src_cb -= uvlinesize;
+    src_cr -= uvlinesize;
+
+#define XCHG(a,b,xchg) do {                     \
+        if (xchg) AV_SWAP64(b,a);               \
+        else      AV_COPY64(b,a);               \
+    } while (0)
+
+    XCHG(top_border_m1+8, src_y-8, xchg);
+    XCHG(top_border,      src_y,   xchg);
+    XCHG(top_border+8,    src_y+8, 1);
+    if (mb_x < mb_width-1)
+        XCHG(top_border+32, src_y+16, 1);
+
+    // only copy chroma for normal loop filter
+    // or to initialize the top row to 127
+    if (!simple || !mb_y) {
+        XCHG(top_border_m1+16, src_cb-8, xchg);
+        XCHG(top_border_m1+24, src_cr-8, xchg);
+        XCHG(top_border+16,    src_cb, 1);
+        XCHG(top_border+24,    src_cr, 1);
+    }
+}
+
+static av_always_inline
+int check_intra_pred_mode(int mode, int mb_x, int mb_y)
+{
+    if (mode == DC_PRED8x8) {
+        if (!mb_x) {
+            mode = mb_y ? TOP_DC_PRED8x8 : DC_128_PRED8x8;
+        } else if (!mb_y) {
+            mode = LEFT_DC_PRED8x8;
+        }
+    }
+    return mode;
+}
+
+static av_always_inline
+void intra_predict(VP8Context *s, uint8_t *dst[3], VP8Macroblock *mb,
+                   uint8_t *intra4x4, int mb_x, int mb_y)
+{
+    int x, y, mode, nnz, tr;
+
+    // for the first row, we need to run xchg_mb_border to init the top edge to 127
+    // otherwise, skip it if we aren't going to deblock
+    if (s->deblock_filter || !mb_y)
+        xchg_mb_border(s->top_border[mb_x+1], dst[0], dst[1], dst[2],
+                       s->linesize, s->uvlinesize, mb_x, mb_y, s->mb_width,
+                       s->filter.simple, 1);
+
+    if (mb->mode < MODE_I4x4) {
+        mode = check_intra_pred_mode(mb->mode, mb_x, mb_y);
+        s->hpc.pred16x16[mode](dst[0], s->linesize);
+    } else {
+        uint8_t *ptr = dst[0];
+        int stride = s->keyframe ? s->b4_stride : 4;
+
+        // all blocks on the right edge of the macroblock use bottom edge
+        // the top macroblock for their topright edge
+        uint8_t *tr_right = ptr - s->linesize + 16;
+
+        // if we're on the right edge of the frame, said edge is extended
+        // from the top macroblock
+        if (mb_x == s->mb_width-1) {
+            tr = tr_right[-1]*0x01010101;
+            tr_right = (uint8_t *)&tr;
+        }
+
+        if (mb->skip)
+            AV_ZERO128(s->non_zero_count_cache);
+
+        for (y = 0; y < 4; y++) {
+            uint8_t *topright = ptr + 4 - s->linesize;
+            for (x = 0; x < 4; x++) {
+                if (x == 3)
+                    topright = tr_right;
+
+                s->hpc.pred4x4[intra4x4[x]](ptr+4*x, topright, s->linesize);
+
+                nnz = s->non_zero_count_cache[y][x];
+                if (nnz) {
+                    if (nnz == 1)
+                        s->vp8dsp.vp8_idct_dc_add(ptr+4*x, s->block[y][x], s->linesize);
+                    else
+                        s->vp8dsp.vp8_idct_add(ptr+4*x, s->block[y][x], s->linesize);
+                }
+                topright += 4;
+            }
+
+            ptr   += 4*s->linesize;
+            intra4x4 += stride;
+        }
+    }
+
+    mode = check_intra_pred_mode(s->chroma_pred_mode, mb_x, mb_y);
+    s->hpc.pred8x8[mode](dst[1], s->uvlinesize);
+    s->hpc.pred8x8[mode](dst[2], s->uvlinesize);
+
+    if (s->deblock_filter || !mb_y)
+        xchg_mb_border(s->top_border[mb_x+1], dst[0], dst[1], dst[2],
+                       s->linesize, s->uvlinesize, mb_x, mb_y, s->mb_width,
+                       s->filter.simple, 0);
+}
+
+/**
+ * Generic MC function.
+ *
+ * @param s VP8 decoding context
+ * @param luma 1 for luma (Y) planes, 0 for chroma (Cb/Cr) planes
+ * @param dst target buffer for block data at block position
+ * @param src reference picture buffer at origin (0, 0)
+ * @param mv motion vector (relative to block position) to get pixel data from
+ * @param x_off horizontal position of block from origin (0, 0)
+ * @param y_off vertical position of block from origin (0, 0)
+ * @param block_w width of block (16, 8 or 4)
+ * @param block_h height of block (always same as block_w)
+ * @param width width of src/dst plane data
+ * @param height height of src/dst plane data
+ * @param linesize size of a single line of plane data, including padding
+ * @param mc_func motion compensation function pointers (bilinear or sixtap MC)
+ */
+static av_always_inline
+void vp8_mc(VP8Context *s, int luma,
+            uint8_t *dst, uint8_t *src, const VP56mv *mv,
+            int x_off, int y_off, int block_w, int block_h,
+            int width, int height, int linesize,
+            vp8_mc_func mc_func[3][3])
+{
+    if (AV_RN32A(mv)) {
+        static const uint8_t idx[8] = { 0, 1, 2, 1, 2, 1, 2, 1 };
+        int mx = (mv->x << luma)&7, mx_idx = idx[mx];
+        int my = (mv->y << luma)&7, my_idx = idx[my];
+
+        x_off += mv->x >> (3 - luma);
+        y_off += mv->y >> (3 - luma);
+
+        // edge emulation
+        src += y_off * linesize + x_off;
+        if (x_off < 2 || x_off >= width  - block_w - 3 ||
+            y_off < 2 || y_off >= height - block_h - 3) {
+            ff_emulated_edge_mc(s->edge_emu_buffer, src - 2 * linesize - 2, linesize,
+                                block_w + 5, block_h + 5,
+                                x_off - 2, y_off - 2, width, height);
+            src = s->edge_emu_buffer + 2 + linesize * 2;
+        }
+        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);
+    } else
+        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);
+}
+
+static av_always_inline
+void vp8_mc_part(VP8Context *s, uint8_t *dst[3],
+                 AVFrame *ref_frame, int x_off, int y_off,
+                 int bx_off, int by_off,
+                 int block_w, int block_h,
+                 int width, int height, VP56mv *mv)
+{
+    VP56mv uvmv = *mv;
+
+    /* Y */
+    vp8_mc(s, 1, dst[0] + by_off * s->linesize + bx_off,
+           ref_frame->data[0], mv, x_off + bx_off, y_off + by_off,
+           block_w, block_h, width, height, s->linesize,
+           s->put_pixels_tab[block_w == 8]);
+
+    /* U/V */
+    if (s->profile == 3) {
+        uvmv.x &= ~7;
+        uvmv.y &= ~7;
+    }
+    x_off   >>= 1; y_off   >>= 1;
+    bx_off  >>= 1; by_off  >>= 1;
+    width   >>= 1; height  >>= 1;
+    block_w >>= 1; block_h >>= 1;
+    vp8_mc(s, 0, dst[1] + by_off * s->uvlinesize + bx_off,
+           ref_frame->data[1], &uvmv, x_off + bx_off, y_off + by_off,
+           block_w, block_h, width, height, s->uvlinesize,
+           s->put_pixels_tab[1 + (block_w == 4)]);
+    vp8_mc(s, 0, dst[2] + by_off * s->uvlinesize + bx_off,
+           ref_frame->data[2], &uvmv, x_off + bx_off, y_off + by_off,
+           block_w, block_h, width, height, s->uvlinesize,
+           s->put_pixels_tab[1 + (block_w == 4)]);
+}
+
+/* Fetch pixels for estimated mv 4 macroblocks ahead.
+ * Optimized for 64-byte cache lines.  Inspired by ffh264 prefetch_motion. */
+static av_always_inline void prefetch_motion(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y, int mb_xy, int ref)
+{
+    /* Don't prefetch refs that haven't been used very often this frame. */
+    if (s->ref_count[ref-1] > (mb_xy >> 5)) {
+        int x_off = mb_x << 4, y_off = mb_y << 4;
+        int mx = mb->mv.x + x_off + 8;
+        int my = mb->mv.y + y_off;
+        uint8_t **src= s->framep[ref]->data;
+        int off= mx + (my + (mb_x&3)*4)*s->linesize + 64;
+        s->dsp.prefetch(src[0]+off, s->linesize, 4);
+        off= (mx>>1) + ((my>>1) + (mb_x&7))*s->uvlinesize + 64;
+        s->dsp.prefetch(src[1]+off, src[2]-src[1], 2);
+    }
+}
+
+/**
+ * Apply motion vectors to prediction buffer, chapter 18.
+ */
+static av_always_inline
+void inter_predict(VP8Context *s, uint8_t *dst[3], VP8Macroblock *mb,
+                   int mb_x, int mb_y)
+{
+    int x_off = mb_x << 4, y_off = mb_y << 4;
+    int width = 16*s->mb_width, height = 16*s->mb_height;
+    AVFrame *ref = s->framep[mb->ref_frame];
+    VP56mv *bmv = mb->bmv;
+
+    if (mb->mode < VP8_MVMODE_SPLIT) {
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 0, 16, 16, width, height, &mb->mv);
+    } else switch (mb->partitioning) {
+    case VP8_SPLITMVMODE_4x4: {
+        int x, y;
+        VP56mv uvmv;
+
+        /* Y */
+        for (y = 0; y < 4; y++) {
+            for (x = 0; x < 4; x++) {
+                vp8_mc(s, 1, dst[0] + 4*y*s->linesize + x*4,
+                       ref->data[0], &bmv[4*y + x],
+                       4*x + x_off, 4*y + y_off, 4, 4,
+                       width, height, s->linesize,
+                       s->put_pixels_tab[2]);
+            }
+        }
+
+        /* U/V */
+        x_off >>= 1; y_off >>= 1; width >>= 1; height >>= 1;
+        for (y = 0; y < 2; y++) {
+            for (x = 0; x < 2; x++) {
+                uvmv.x = mb->bmv[ 2*y    * 4 + 2*x  ].x +
+                         mb->bmv[ 2*y    * 4 + 2*x+1].x +
+                         mb->bmv[(2*y+1) * 4 + 2*x  ].x +
+                         mb->bmv[(2*y+1) * 4 + 2*x+1].x;
+                uvmv.y = mb->bmv[ 2*y    * 4 + 2*x  ].y +
+                         mb->bmv[ 2*y    * 4 + 2*x+1].y +
+                         mb->bmv[(2*y+1) * 4 + 2*x  ].y +
+                         mb->bmv[(2*y+1) * 4 + 2*x+1].y;
+                uvmv.x = (uvmv.x + 2 + (uvmv.x >> (INT_BIT-1))) >> 2;
+                uvmv.y = (uvmv.y + 2 + (uvmv.y >> (INT_BIT-1))) >> 2;
+                if (s->profile == 3) {
+                    uvmv.x &= ~7;
+                    uvmv.y &= ~7;
+                }
+                vp8_mc(s, 0, dst[1] + 4*y*s->uvlinesize + x*4,
+                       ref->data[1], &uvmv,
+                       4*x + x_off, 4*y + y_off, 4, 4,
+                       width, height, s->uvlinesize,
+                       s->put_pixels_tab[2]);
+                vp8_mc(s, 0, dst[2] + 4*y*s->uvlinesize + x*4,
+                       ref->data[2], &uvmv,
+                       4*x + x_off, 4*y + y_off, 4, 4,
+                       width, height, s->uvlinesize,
+                       s->put_pixels_tab[2]);
+            }
+        }
+        break;
+    }
+    case VP8_SPLITMVMODE_16x8:
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 0, 16, 8, width, height, &bmv[0]);
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 8, 16, 8, width, height, &bmv[1]);
+        break;
+    case VP8_SPLITMVMODE_8x16:
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 0, 8, 16, width, height, &bmv[0]);
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    8, 0, 8, 16, width, height, &bmv[1]);
+        break;
+    case VP8_SPLITMVMODE_8x8:
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 0, 8, 8, width, height, &bmv[0]);
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    8, 0, 8, 8, width, height, &bmv[1]);
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 8, 8, 8, width, height, &bmv[2]);
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    8, 8, 8, 8, width, height, &bmv[3]);
+        break;
+    }
+}
+
+static av_always_inline void idct_mb(VP8Context *s, uint8_t *dst[3], VP8Macroblock *mb)
+{
+    int x, y, ch;
+
+    if (mb->mode != MODE_I4x4) {
+        uint8_t *y_dst = dst[0];
+        for (y = 0; y < 4; y++) {
+            uint32_t nnz4 = AV_RN32A(s->non_zero_count_cache[y]);
+            if (nnz4) {
+                if (nnz4&~0x01010101) {
+                    for (x = 0; x < 4; x++) {
+                        int nnz = s->non_zero_count_cache[y][x];
+                        if (nnz) {
+                            if (nnz == 1)
+                                s->vp8dsp.vp8_idct_dc_add(y_dst+4*x, s->block[y][x], s->linesize);
+                            else
+                                s->vp8dsp.vp8_idct_add(y_dst+4*x, s->block[y][x], s->linesize);
+                        }
+                    }
+                } else {
+                    s->vp8dsp.vp8_idct_dc_add4y(y_dst, s->block[y], s->linesize);
+                }
+            }
+            y_dst += 4*s->linesize;
+        }
+    }
+
+    for (ch = 0; ch < 2; ch++) {
+        uint32_t nnz4 = AV_RN32A(s->non_zero_count_cache[4+ch]);
+        if (nnz4) {
+            uint8_t *ch_dst = dst[1+ch];
+            if (nnz4&~0x01010101) {
+                for (y = 0; y < 2; y++) {
+                    for (x = 0; x < 2; x++) {
+                        int nnz = s->non_zero_count_cache[4+ch][(y<<1)+x];
+                        if (nnz) {
+                            if (nnz == 1)
+                                s->vp8dsp.vp8_idct_dc_add(ch_dst+4*x, s->block[4+ch][(y<<1)+x], s->uvlinesize);
+                            else
+                                s->vp8dsp.vp8_idct_add(ch_dst+4*x, s->block[4+ch][(y<<1)+x], s->uvlinesize);
+                        }
+                    }
+                    ch_dst += 4*s->uvlinesize;
+                }
+            } else {
+                s->vp8dsp.vp8_idct_dc_add4uv(ch_dst, s->block[4+ch], s->uvlinesize);
+            }
+        }
+    }
+}
+
+static av_always_inline void filter_level_for_mb(VP8Context *s, VP8Macroblock *mb, VP8FilterStrength *f )
+{
+    int interior_limit, filter_level;
+
+    if (s->segmentation.enabled) {
+        filter_level = s->segmentation.filter_level[s->segment];
+        if (!s->segmentation.absolute_vals)
+            filter_level += s->filter.level;
+    } else
+        filter_level = s->filter.level;
+
+    if (s->lf_delta.enabled) {
+        filter_level += s->lf_delta.ref[mb->ref_frame];
+
+        if (mb->ref_frame == VP56_FRAME_CURRENT) {
+            if (mb->mode == MODE_I4x4)
+                filter_level += s->lf_delta.mode[0];
+        } else {
+            if (mb->mode == VP8_MVMODE_ZERO)
+                filter_level += s->lf_delta.mode[1];
+            else if (mb->mode == VP8_MVMODE_SPLIT)
+                filter_level += s->lf_delta.mode[3];
+            else
+                filter_level += s->lf_delta.mode[2];
+        }
+    }
+    filter_level = av_clip(filter_level, 0, 63);
+
+    interior_limit = filter_level;
+    if (s->filter.sharpness) {
+        interior_limit >>= s->filter.sharpness > 4 ? 2 : 1;
+        interior_limit = FFMIN(interior_limit, 9 - s->filter.sharpness);
+    }
+    interior_limit = FFMAX(interior_limit, 1);
+
+    f->filter_level = filter_level;
+    f->inner_limit = interior_limit;
+    f->inner_filter = !mb->skip || mb->mode == MODE_I4x4 || mb->mode == VP8_MVMODE_SPLIT;
+}
+
+static av_always_inline void filter_mb(VP8Context *s, uint8_t *dst[3], VP8FilterStrength *f, int mb_x, int mb_y)
+{
+    int mbedge_lim, bedge_lim, hev_thresh;
+    int filter_level = f->filter_level;
+    int inner_limit = f->inner_limit;
+    int inner_filter = f->inner_filter;
+    int linesize = s->linesize;
+    int uvlinesize = s->uvlinesize;
+
+    if (!filter_level)
+        return;
+
+    mbedge_lim = 2*(filter_level+2) + inner_limit;
+     bedge_lim = 2* filter_level    + inner_limit;
+    hev_thresh = filter_level >= 15;
+
+    if (s->keyframe) {
+        if (filter_level >= 40)
+            hev_thresh = 2;
+    } else {
+        if (filter_level >= 40)
+            hev_thresh = 3;
+        else if (filter_level >= 20)
+            hev_thresh = 2;
+    }
+
+    if (mb_x) {
+        s->vp8dsp.vp8_h_loop_filter16y(dst[0],     linesize,
+                                       mbedge_lim, inner_limit, hev_thresh);
+        s->vp8dsp.vp8_h_loop_filter8uv(dst[1],     dst[2],      uvlinesize,
+                                       mbedge_lim, inner_limit, hev_thresh);
+    }
+
+    if (inner_filter) {
+        s->vp8dsp.vp8_h_loop_filter16y_inner(dst[0]+ 4, linesize, bedge_lim,
+                                             inner_limit, hev_thresh);
+        s->vp8dsp.vp8_h_loop_filter16y_inner(dst[0]+ 8, linesize, bedge_lim,
+                                             inner_limit, hev_thresh);
+        s->vp8dsp.vp8_h_loop_filter16y_inner(dst[0]+12, linesize, bedge_lim,
+                                             inner_limit, hev_thresh);
+        s->vp8dsp.vp8_h_loop_filter8uv_inner(dst[1] + 4, dst[2] + 4,
+                                             uvlinesize,  bedge_lim,
+                                             inner_limit, hev_thresh);
+    }
+
+    if (mb_y) {
+        s->vp8dsp.vp8_v_loop_filter16y(dst[0],     linesize,
+                                       mbedge_lim, inner_limit, hev_thresh);
+        s->vp8dsp.vp8_v_loop_filter8uv(dst[1],     dst[2],      uvlinesize,
+                                       mbedge_lim, inner_limit, hev_thresh);
+    }
+
+    if (inner_filter) {
+        s->vp8dsp.vp8_v_loop_filter16y_inner(dst[0]+ 4*linesize,
+                                             linesize,    bedge_lim,
+                                             inner_limit, hev_thresh);
+        s->vp8dsp.vp8_v_loop_filter16y_inner(dst[0]+ 8*linesize,
+                                             linesize,    bedge_lim,
+                                             inner_limit, hev_thresh);
+        s->vp8dsp.vp8_v_loop_filter16y_inner(dst[0]+12*linesize,
+                                             linesize,    bedge_lim,
+                                             inner_limit, hev_thresh);
+        s->vp8dsp.vp8_v_loop_filter8uv_inner(dst[1] + 4 * uvlinesize,
+                                             dst[2] + 4 * uvlinesize,
+                                             uvlinesize,  bedge_lim,
+                                             inner_limit, hev_thresh);
+    }
+}
+
+static av_always_inline void filter_mb_simple(VP8Context *s, uint8_t *dst, VP8FilterStrength *f, int mb_x, int mb_y)
+{
+    int mbedge_lim, bedge_lim;
+    int filter_level = f->filter_level;
+    int inner_limit = f->inner_limit;
+    int inner_filter = f->inner_filter;
+    int linesize = s->linesize;
+
+    if (!filter_level)
+        return;
+
+    mbedge_lim = 2*(filter_level+2) + inner_limit;
+     bedge_lim = 2* filter_level    + inner_limit;
+
+    if (mb_x)
+        s->vp8dsp.vp8_h_loop_filter_simple(dst, linesize, mbedge_lim);
+    if (inner_filter) {
+        s->vp8dsp.vp8_h_loop_filter_simple(dst+ 4, linesize, bedge_lim);
+        s->vp8dsp.vp8_h_loop_filter_simple(dst+ 8, linesize, bedge_lim);
+        s->vp8dsp.vp8_h_loop_filter_simple(dst+12, linesize, bedge_lim);
+    }
+
+    if (mb_y)
+        s->vp8dsp.vp8_v_loop_filter_simple(dst, linesize, mbedge_lim);
+    if (inner_filter) {
+        s->vp8dsp.vp8_v_loop_filter_simple(dst+ 4*linesize, linesize, bedge_lim);
+        s->vp8dsp.vp8_v_loop_filter_simple(dst+ 8*linesize, linesize, bedge_lim);
+        s->vp8dsp.vp8_v_loop_filter_simple(dst+12*linesize, linesize, bedge_lim);
+    }
+}
+
+static void filter_mb_row(VP8Context *s, int mb_y)
+{
+    VP8FilterStrength *f = s->filter_strength;
+    uint8_t *dst[3] = {
+        s->framep[VP56_FRAME_CURRENT]->data[0] + 16*mb_y*s->linesize,
+        s->framep[VP56_FRAME_CURRENT]->data[1] +  8*mb_y*s->uvlinesize,
+        s->framep[VP56_FRAME_CURRENT]->data[2] +  8*mb_y*s->uvlinesize
+    };
+    int mb_x;
+
+    for (mb_x = 0; mb_x < s->mb_width; mb_x++) {
+        backup_mb_border(s->top_border[mb_x+1], dst[0], dst[1], dst[2], s->linesize, s->uvlinesize, 0);
+        filter_mb(s, dst, f++, mb_x, mb_y);
+        dst[0] += 16;
+        dst[1] += 8;
+        dst[2] += 8;
+    }
+}
+
+static void filter_mb_row_simple(VP8Context *s, int mb_y)
+{
+    VP8FilterStrength *f = s->filter_strength;
+    uint8_t *dst = s->framep[VP56_FRAME_CURRENT]->data[0] + 16*mb_y*s->linesize;
+    int mb_x;
+
+    for (mb_x = 0; mb_x < s->mb_width; mb_x++) {
+        backup_mb_border(s->top_border[mb_x+1], dst, NULL, NULL, s->linesize, 0, 1);
+        filter_mb_simple(s, dst, f++, mb_x, mb_y);
+        dst += 16;
+    }
+}
+
+static int vp8_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
+                            AVPacket *avpkt)
+{
+    VP8Context *s = avctx->priv_data;
+    int ret, mb_x, mb_y, i, y, referenced;
+    enum AVDiscard skip_thresh;
+    AVFrame *curframe = NULL;
+
+    if ((ret = decode_frame_header(s, avpkt->data, avpkt->size)) < 0)
+        return ret;
+
+    referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT
+                                || s->update_altref == VP56_FRAME_CURRENT;
+
+    skip_thresh = !referenced ? AVDISCARD_NONREF :
+                    !s->keyframe ? AVDISCARD_NONKEY : AVDISCARD_ALL;
+
+    if (avctx->skip_frame >= skip_thresh) {
+        s->invisible = 1;
+        goto skip_decode;
+    }
+    s->deblock_filter = s->filter.level && avctx->skip_loop_filter < skip_thresh;
+
+    for (i = 0; i < 4; i++)
+        if (&s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&
+            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] &&
+            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2]) {
+            curframe = s->framep[VP56_FRAME_CURRENT] = &s->frames[i];
+            break;
+        }
+    if (curframe->data[0])
+        avctx->release_buffer(avctx, curframe);
+
+    curframe->key_frame = s->keyframe;
+    curframe->pict_type = s->keyframe ? FF_I_TYPE : FF_P_TYPE;
+    curframe->reference = referenced ? 3 : 0;
+    if ((ret = avctx->get_buffer(avctx, curframe))) {
+        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed!\n");
+        return ret;
+    }
+
+    // Given that arithmetic probabilities are updated every frame, it's quite likely
+    // that the values we have on a random interframe are complete junk if we didn't
+    // start decode on a keyframe. So just don't display anything rather than junk.
+    if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||
+                         !s->framep[VP56_FRAME_GOLDEN] ||
+                         !s->framep[VP56_FRAME_GOLDEN2])) {
+        av_log(avctx, AV_LOG_WARNING, "Discarding interframe without a prior keyframe!\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    s->linesize   = curframe->linesize[0];
+    s->uvlinesize = curframe->linesize[1];
+
+    if (!s->edge_emu_buffer)
+        s->edge_emu_buffer = av_malloc(21*s->linesize);
+
+    memset(s->top_nnz, 0, s->mb_width*sizeof(*s->top_nnz));
+
+    /* Zero macroblock structures for top/left prediction from outside the frame. */
+    memset(s->macroblocks, 0, (s->mb_width + s->mb_height*2)*sizeof(*s->macroblocks));
+
+    // top edge of 127 for intra prediction
+    memset(s->top_border, 127, (s->mb_width+1)*sizeof(*s->top_border));
+    memset(s->ref_count, 0, sizeof(s->ref_count));
+
+    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {
+        VP56RangeCoder *c = &s->coeff_partition[mb_y & (s->num_coeff_partitions-1)];
+        VP8Macroblock *mb = s->macroblocks + (s->mb_height - mb_y - 1)*2;
+        uint8_t *intra4x4 = s->intra4x4_pred_mode + 4*mb_y*s->b4_stride;
+        uint8_t *segment_map = s->segmentation_map + mb_y*s->mb_stride;
+        int mb_xy = mb_y * s->mb_stride;
+        uint8_t *dst[3] = {
+            curframe->data[0] + 16*mb_y*s->linesize,
+            curframe->data[1] +  8*mb_y*s->uvlinesize,
+            curframe->data[2] +  8*mb_y*s->uvlinesize
+        };
+
+        memset(s->left_nnz, 0, sizeof(s->left_nnz));
+
+        // left edge of 129 for intra prediction
+        if (!(avctx->flags & CODEC_FLAG_EMU_EDGE))
+            for (i = 0; i < 3; i++)
+                for (y = 0; y < 16>>!!i; y++)
+                    dst[i][y*curframe->linesize[i]-1] = 129;
+        if (mb_y)
+            memset(s->top_border, 129, sizeof(*s->top_border));
+
+        for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) {
+            uint8_t *intra4x4_mb = s->keyframe ? intra4x4 + 4*mb_x : s->intra4x4_pred_mode_mb;
+            uint8_t *segment_mb = segment_map+mb_x;
+
+            /* Prefetch the current frame, 4 MBs ahead */
+            s->dsp.prefetch(dst[0] + (mb_x&3)*4*s->linesize + 64, s->linesize, 4);
+            s->dsp.prefetch(dst[1] + (mb_x&7)*s->uvlinesize + 64, dst[2] - dst[1], 2);
+
+            decode_mb_mode(s, mb, mb_x, mb_y, intra4x4_mb, segment_mb);
+
+            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS);
+
+            if (!mb->skip)
+                decode_mb_coeffs(s, c, mb, s->top_nnz[mb_x], s->left_nnz);
+
+            if (mb->mode <= MODE_I4x4)
+                intra_predict(s, dst, mb, intra4x4_mb, mb_x, mb_y);
+            else
+                inter_predict(s, dst, mb, mb_x, mb_y);
+
+            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN);
+
+            if (!mb->skip) {
+                idct_mb(s, dst, mb);
+            } else {
+                AV_ZERO64(s->left_nnz);
+                AV_WN64(s->top_nnz[mb_x], 0);   // array of 9, so unaligned
+
+                // Reset DC block predictors if they would exist if the mb had coefficients
+                if (mb->mode != MODE_I4x4 && mb->mode != VP8_MVMODE_SPLIT) {
+                    s->left_nnz[8]      = 0;
+                    s->top_nnz[mb_x][8] = 0;
+                }
+            }
+
+            if (s->deblock_filter)
+                filter_level_for_mb(s, mb, &s->filter_strength[mb_x]);
+
+            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2);
+
+            dst[0] += 16;
+            dst[1] += 8;
+            dst[2] += 8;
+        }
+        if (s->deblock_filter) {
+            if (s->filter.simple)
+                filter_mb_row_simple(s, mb_y);
+            else
+                filter_mb_row(s, mb_y);
+        }
+    }
+
+skip_decode:
+    // if future frames don't use the updated probabilities,
+    // reset them to the values we saved
+    if (!s->update_probabilities)
+        s->prob[0] = s->prob[1];
+
+    // check if golden and altref are swapped
+    if (s->update_altref == VP56_FRAME_GOLDEN &&
+        s->update_golden == VP56_FRAME_GOLDEN2)
+        FFSWAP(AVFrame *, s->framep[VP56_FRAME_GOLDEN], s->framep[VP56_FRAME_GOLDEN2]);
+    else {
+        if (s->update_altref != VP56_FRAME_NONE)
+            s->framep[VP56_FRAME_GOLDEN2] = s->framep[s->update_altref];
+
+        if (s->update_golden != VP56_FRAME_NONE)
+            s->framep[VP56_FRAME_GOLDEN] = s->framep[s->update_golden];
+    }
+
+    if (s->update_last) // move cur->prev
+        s->framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_CURRENT];
+
+    // release no longer referenced frames
+    for (i = 0; i < 4; i++)
+        if (s->frames[i].data[0] &&
+            &s->frames[i] != s->framep[VP56_FRAME_CURRENT] &&
+            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&
+            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] &&
+            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2])
+            avctx->release_buffer(avctx, &s->frames[i]);
+
+    if (!s->invisible) {
+        *(AVFrame*)data = *s->framep[VP56_FRAME_CURRENT];
+        *data_size = sizeof(AVFrame);
+    }
+
+    return avpkt->size;
+}
+
+static av_cold int vp8_decode_init(AVCodecContext *avctx)
+{
+    VP8Context *s = avctx->priv_data;
+
+    s->avctx = avctx;
+    avctx->pix_fmt = PIX_FMT_YUV420P;
+
+    dsputil_init(&s->dsp, avctx);
+    ff_h264_pred_init(&s->hpc, CODEC_ID_VP8);
+    ff_vp8dsp_init(&s->vp8dsp);
+
+    // intra pred needs edge emulation among other things
+    if (avctx->flags&CODEC_FLAG_EMU_EDGE) {
+        av_log(avctx, AV_LOG_ERROR, "Edge emulation not supported\n");
+        return AVERROR_PATCHWELCOME;
+    }
+
+    return 0;
+}
+
+static av_cold int vp8_decode_free(AVCodecContext *avctx)
+{
+    vp8_decode_flush(avctx);
+    return 0;
+}
+
+AVCodec vp8_decoder = {
+    "vp8",
+    AVMEDIA_TYPE_VIDEO,
+    CODEC_ID_VP8,
+    sizeof(VP8Context),
+    vp8_decode_init,
+    NULL,
+    vp8_decode_free,
+    vp8_decode_frame,
+    CODEC_CAP_DR1,
+    .flush = vp8_decode_flush,
+    .long_name = NULL_IF_CONFIG_SMALL("On2 VP8"),
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8_parser.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8_parser.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8_parser.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2008 Michael Niedermayer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "parser.h"
+
+static int parse(AVCodecParserContext *s,
+                           AVCodecContext *avctx,
+                           const uint8_t **poutbuf, int *poutbuf_size,
+                           const uint8_t *buf, int buf_size)
+{
+    s->pict_type= (buf[0]&0x01) ? FF_P_TYPE : FF_I_TYPE;
+
+    *poutbuf = buf;
+    *poutbuf_size = buf_size;
+    return buf_size;
+}
+
+AVCodecParser vp8_parser = {
+    { CODEC_ID_VP8 },
+    0,
+    NULL,
+    parse,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8data.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8data.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8data.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,734 @@
+/**
+ * VP8 compatible video decoder
+ *
+ * Copyright (C) 2010 David Conrad
+ * Copyright (C) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+// TODO: move these #define and enum to a better header...
+
+#define VP8_MAX_QUANT 127
+
+enum dct_token {
+    DCT_0,
+    DCT_1,
+    DCT_2,
+    DCT_3,
+    DCT_4,
+    DCT_CAT1,
+    DCT_CAT2,
+    DCT_CAT3,
+    DCT_CAT4,
+    DCT_CAT5,
+    DCT_CAT6,
+    DCT_EOB,
+
+    NUM_DCT_TOKENS
+};
+
+#include "h264pred.h"
+
+// used to signal 4x4 intra pred in luma MBs
+#define MODE_I4x4 4
+
+enum inter_mvmode {
+    VP8_MVMODE_NEAREST = MODE_I4x4 + 1,
+    VP8_MVMODE_NEAR,
+    VP8_MVMODE_ZERO,
+    VP8_MVMODE_NEW,
+    VP8_MVMODE_SPLIT
+};
+
+enum inter_submvmode {
+    VP8_SUBMVMODE_LEFT4X4,
+    VP8_SUBMVMODE_TOP4X4,
+    VP8_SUBMVMODE_ZERO4X4,
+    VP8_SUBMVMODE_NEW4X4
+};
+
+enum inter_splitmvmode {
+    VP8_SPLITMVMODE_16x8 = 0,    ///< 2 16x8 blocks (vertical)
+    VP8_SPLITMVMODE_8x16,        ///< 2 8x16 blocks (horizontal)
+    VP8_SPLITMVMODE_8x8,         ///< 2x2 blocks of 8x8px each
+    VP8_SPLITMVMODE_4x4,         ///< 4x4 blocks of 4x4px each
+    VP8_SPLITMVMODE_NONE,        ///< (only used in prediction) no split MVs
+};
+
+static const uint8_t vp8_pred4x4_mode[] =
+{
+    [DC_PRED8x8]    = DC_PRED,
+    [VERT_PRED8x8]  = VERT_PRED,
+    [HOR_PRED8x8]   = HOR_PRED,
+    [PLANE_PRED8x8] = TM_VP8_PRED,
+};
+
+static const int8_t vp8_pred16x16_tree_intra[4][2] =
+{
+    { -MODE_I4x4, 1 },                      // '0'
+     { 2, 3 },
+      {  -DC_PRED8x8,  -VERT_PRED8x8 },     // '100', '101'
+      { -HOR_PRED8x8, -PLANE_PRED8x8 },     // '110', '111'
+};
+
+static const int8_t vp8_pred16x16_tree_inter[4][2] =
+{
+    { -DC_PRED8x8, 1 },                     // '0'
+     { 2, 3 },
+      {  -VERT_PRED8x8, -HOR_PRED8x8 },     // '100', '101'
+      { -PLANE_PRED8x8, -MODE_I4x4 },       // '110', '111'
+};
+
+static const int vp8_mode_contexts[6][4] = {
+    {   7,   1,   1, 143 },
+    {  14,  18,  14, 107 },
+    { 135,  64,  57,  68 },
+    {  60,  56, 128,  65 },
+    { 159, 134, 128,  34 },
+    { 234, 188, 128,  28 },
+};
+
+static const int8_t vp8_pred16x16_tree_mvinter[4][2] = {
+    { -VP8_MVMODE_ZERO,      1 },           // '0'
+     { -VP8_MVMODE_NEAREST,  2 },           // '10'
+      { -VP8_MVMODE_NEAR,    3 },           // '110'
+       { -VP8_MVMODE_NEW, -VP8_MVMODE_SPLIT } // '1110', '1111'
+};
+
+static const uint8_t vp8_mbsplits[5][16] = {
+    {  0,  0,  0,  0,  0,  0,  0,  0,
+       1,  1,  1,  1,  1,  1,  1,  1  },
+    {  0,  0,  1,  1,  0,  0,  1,  1,
+       0,  0,  1,  1,  0,  0,  1,  1  },
+    {  0,  0,  1,  1,  0,  0,  1,  1,
+       2,  2,  3,  3,  2,  2,  3,  3  },
+    {  0,  1,  2,  3,  4,  5,  6,  7,
+       8,  9, 10, 11, 12, 13, 14, 15  },
+    {  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0  }
+};
+
+static const uint8_t vp8_mbfirstidx[4][16] = {
+    {  0,  8 }, {  0,  2 }, {  0,  2,  8,  10 },
+    {  0,  1,  2,  3,  4,  5,  6,  7,
+       8,  9, 10, 11, 12, 13, 14, 15 }
+};
+
+static const int8_t vp8_mbsplit_tree[3][2] = {
+    { -VP8_SPLITMVMODE_4x4,  1 },           // '0' - 16 individual MVs
+     { -VP8_SPLITMVMODE_8x8,  2 },          // '10' - quarter-based MVs
+      { -VP8_SPLITMVMODE_16x8,              // '110' - top/bottom MVs
+        -VP8_SPLITMVMODE_8x16 }             // '111' - left/right MVs
+};
+static const uint8_t vp8_mbsplit_count[4] = {   2,   2,   4,  16 };
+static const uint8_t vp8_mbsplit_prob[3]  = { 110, 111, 150 };
+
+static const uint8_t vp8_submv_prob[5][3] = {
+    { 147, 136,  18 },
+    { 106, 145,   1 },
+    { 179, 121,   1 },
+    { 223,   1,  34 },
+    { 208,   1,   1 }
+};
+
+static const int8_t vp8_submv_ref_tree[3][2] = {
+    { -VP8_SUBMVMODE_LEFT4X4, 1 },          // '0'
+     { -VP8_SUBMVMODE_TOP4X4, 2 },          // '10'
+      { -VP8_SUBMVMODE_ZERO4X4, -VP8_SUBMVMODE_NEW4X4 } // '110', '111'
+};
+
+static const uint8_t vp8_pred16x16_prob_intra[4] = { 145, 156, 163, 128 };
+static const uint8_t vp8_pred16x16_prob_inter[4] = { 112,  86, 140,  37 };
+
+static const int8_t vp8_pred4x4_tree[9][2] =
+{
+    { -DC_PRED, 1 },                                    // '0'
+     { -TM_VP8_PRED, 2 },                               // '10'
+      { -VERT_PRED, 3 },                                // '110'
+       { 4, 6 },
+        { -HOR_PRED, 5 },                               // '11100'
+         { -DIAG_DOWN_RIGHT_PRED, -VERT_RIGHT_PRED },   // '111010', '111011'
+        { -DIAG_DOWN_LEFT_PRED, 7 },                    // '11110'
+         { -VERT_LEFT_PRED, 8 },                        // '111110'
+          { -HOR_DOWN_PRED, -HOR_UP_PRED },             // '1111110', '1111111'
+};
+
+static const int8_t vp8_pred8x8c_tree[3][2] =
+{
+    { -DC_PRED8x8, 1 },                 // '0'
+     { -VERT_PRED8x8, 2 },              // '10
+      { -HOR_PRED8x8, -PLANE_PRED8x8 }, // '110', '111'
+};
+
+static const uint8_t vp8_pred8x8c_prob_intra[3] = { 142, 114, 183 };
+static const uint8_t vp8_pred8x8c_prob_inter[3] = { 162, 101, 204 };
+
+static const uint8_t vp8_pred4x4_prob_inter[9] =
+{
+    120, 90, 79, 133, 87, 85, 80, 111, 151
+};
+
+static const uint8_t vp8_pred4x4_prob_intra[10][10][9] =
+{
+    {
+        {  39,  53, 200,  87,  26,  21,  43, 232, 171 },
+        {  56,  34,  51, 104, 114, 102,  29,  93,  77 },
+        {  88,  88, 147, 150,  42,  46,  45, 196, 205 },
+        { 107,  54,  32,  26,  51,   1,  81,  43,  31 },
+        {  39,  28,  85, 171,  58, 165,  90,  98,  64 },
+        {  34,  22, 116, 206,  23,  34,  43, 166,  73 },
+        {  34,  19,  21, 102, 132, 188,  16,  76, 124 },
+        {  68,  25, 106,  22,  64, 171,  36, 225, 114 },
+        {  62,  18,  78,  95,  85,  57,  50,  48,  51 },
+        {  43,  97, 183, 117,  85,  38,  35, 179,  61 },
+    },
+    {
+        { 112, 113,  77,  85, 179, 255,  38, 120, 114 },
+        {  40,  42,   1, 196, 245, 209,  10,  25, 109 },
+        { 193, 101,  35, 159, 215, 111,  89,  46, 111 },
+        { 100,  80,   8,  43, 154,   1,  51,  26,  71 },
+        {  88,  43,  29, 140, 166, 213,  37,  43, 154 },
+        {  61,  63,  30, 155,  67,  45,  68,   1, 209 },
+        {  41,  40,   5, 102, 211, 183,   4,   1, 221 },
+        { 142,  78,  78,  16, 255, 128,  34, 197, 171 },
+        {  51,  50,  17, 168, 209, 192,  23,  25,  82 },
+        {  60, 148,  31, 172, 219, 228,  21,  18, 111 },
+    },
+    {
+        { 175,  69, 143,  80,  85,  82,  72, 155, 103 },
+        {  56,  58,  10, 171, 218, 189,  17,  13, 152 },
+        { 231, 120,  48,  89, 115, 113, 120, 152, 112 },
+        { 144,  71,  10,  38, 171, 213, 144,  34,  26 },
+        { 114,  26,  17, 163,  44, 195,  21,  10, 173 },
+        { 121,  24,  80, 195,  26,  62,  44,  64,  85 },
+        {  63,  20,   8, 114, 114, 208,  12,   9, 226 },
+        { 170,  46,  55,  19, 136, 160,  33, 206,  71 },
+        {  81,  40,  11,  96, 182,  84,  29,  16,  36 },
+        { 152, 179,  64, 126, 170, 118,  46,  70,  95 },
+    },
+    {
+        {  75,  79, 123,  47,  51, 128,  81, 171,   1 },
+        {  57,  17,   5,  71, 102,  57,  53,  41,  49 },
+        { 125,  98,  42,  88, 104,  85, 117, 175,  82 },
+        { 115,  21,   2,  10, 102, 255, 166,  23,   6 },
+        {  38,  33,  13, 121,  57,  73,  26,   1,  85 },
+        {  41,  10,  67, 138,  77, 110,  90,  47, 114 },
+        {  57,  18,  10, 102, 102, 213,  34,  20,  43 },
+        { 101,  29,  16,  10,  85, 128, 101, 196,  26 },
+        { 117,  20,  15,  36, 163, 128,  68,   1,  26 },
+        {  95,  84,  53,  89, 128, 100, 113, 101,  45 },
+    },
+    {
+        {  63,  59,  90, 180,  59, 166,  93,  73, 154 },
+        {  40,  40,  21, 116, 143, 209,  34,  39, 175 },
+        { 138,  31,  36, 171,  27, 166,  38,  44, 229 },
+        {  57,  46,  22,  24, 128,   1,  54,  17,  37 },
+        {  47,  15,  16, 183,  34, 223,  49,  45, 183 },
+        {  46,  17,  33, 183,   6,  98,  15,  32, 183 },
+        {  40,   3,   9, 115,  51, 192,  18,   6, 223 },
+        {  65,  32,  73, 115,  28, 128,  23, 128, 205 },
+        {  87,  37,   9, 115,  59,  77,  64,  21,  47 },
+        {  67,  87,  58, 169,  82, 115,  26,  59, 179 },
+    },
+    {
+        {  54,  57, 112, 184,   5,  41,  38, 166, 213 },
+        {  30,  34,  26, 133, 152, 116,  10,  32, 134 },
+        { 104,  55,  44, 218,   9,  54,  53, 130, 226 },
+        {  75,  32,  12,  51, 192, 255, 160,  43,  51 },
+        {  39,  19,  53, 221,  26, 114,  32,  73, 255 },
+        {  31,   9,  65, 234,   2,  15,   1, 118,  73 },
+        {  56,  21,  23, 111,  59, 205,  45,  37, 192 },
+        {  88,  31,  35,  67, 102,  85,  55, 186,  85 },
+        {  55,  38,  70, 124,  73, 102,   1,  34,  98 },
+        {  64,  90,  70, 205,  40,  41,  23,  26,  57 },
+    },
+    {
+        {  86,  40,  64, 135, 148, 224,  45, 183, 128 },
+        {  22,  26,  17, 131, 240, 154,  14,   1, 209 },
+        { 164,  50,  31, 137, 154, 133,  25,  35, 218 },
+        {  83,  12,  13,  54, 192, 255,  68,  47,  28 },
+        {  45,  16,  21,  91,  64, 222,   7,   1, 197 },
+        {  56,  21,  39, 155,  60, 138,  23, 102, 213 },
+        {  18,  11,   7,  63, 144, 171,   4,   4, 246 },
+        {  85,  26,  85,  85, 128, 128,  32, 146, 171 },
+        {  35,  27,  10, 146, 174, 171,  12,  26, 128 },
+        {  51, 103,  44, 131, 131, 123,  31,   6, 158 },
+    },
+    {
+        {  68,  45, 128,  34,   1,  47,  11, 245, 171 },
+        {  62,  17,  19,  70, 146,  85,  55,  62,  70 },
+        { 102,  61,  71,  37,  34,  53,  31, 243, 192 },
+        {  75,  15,   9,   9,  64, 255, 184, 119,  16 },
+        {  37,  43,  37, 154, 100, 163,  85, 160,   1 },
+        {  63,   9,  92, 136,  28,  64,  32, 201,  85 },
+        {  56,   8,  17, 132, 137, 255,  55, 116, 128 },
+        {  86,   6,  28,   5,  64, 255,  25, 248,   1 },
+        {  58,  15,  20,  82, 135,  57,  26, 121,  40 },
+        {  69,  60,  71,  38,  73, 119,  28, 222,  37 },
+    },
+    {
+        { 101,  75, 128, 139, 118, 146, 116, 128,  85 },
+        {  56,  41,  15, 176, 236,  85,  37,   9,  62 },
+        { 190,  80,  35,  99, 180,  80, 126,  54,  45 },
+        { 146,  36,  19,  30, 171, 255,  97,  27,  20 },
+        {  71,  30,  17, 119, 118, 255,  17,  18, 138 },
+        { 101,  38,  60, 138,  55,  70,  43,  26, 142 },
+        {  32,  41,  20, 117, 151, 142,  20,  21, 163 },
+        { 138,  45,  61,  62, 219,   1,  81, 188,  64 },
+        { 112,  19,  12,  61, 195, 128,  48,   4,  24 },
+        {  85, 126,  47,  87, 176,  51,  41,  20,  32 },
+    },
+    {
+        {  66, 102, 167,  99,  74,  62,  40, 234, 128 },
+        {  41,  53,   9, 178, 241, 141,  26,   8, 107 },
+        { 134, 183,  89, 137,  98, 101, 106, 165, 148 },
+        { 104,  79,  12,  27, 217, 255,  87,  17,   7 },
+        {  74,  43,  26, 146,  73, 166,  49,  23, 157 },
+        {  65,  38, 105, 160,  51,  52,  31, 115, 128 },
+        {  47,  41,  14, 110, 182, 183,  21,  17, 194 },
+        {  87,  68,  71,  44, 114,  51,  15, 186,  23 },
+        {  66,  45,  25, 102, 197, 189,  23,  18,  22 },
+        {  72, 187, 100, 130, 157, 111,  32,  75,  80 },
+    },
+};
+
+static const int8_t vp8_segmentid_tree[][2] =
+{
+    { 1, 2 },
+     { -0, -1 },    // '00', '01'
+     { -2, -3 },    // '10', '11'
+};
+
+static const uint8_t vp8_coeff_band[16] =
+{
+    0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7
+};
+
+static const uint8_t vp8_dct_cat1_prob[] = { 159, 0 };
+static const uint8_t vp8_dct_cat2_prob[] = { 165, 145, 0 };
+static const uint8_t vp8_dct_cat3_prob[] = { 173, 148, 140, 0 };
+static const uint8_t vp8_dct_cat4_prob[] = { 176, 155, 140, 135, 0 };
+static const uint8_t vp8_dct_cat5_prob[] = { 180, 157, 141, 134, 130, 0 };
+static const uint8_t vp8_dct_cat6_prob[] = { 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0 };
+
+// only used for cat3 and above; cat 1 and 2 are referenced directly
+static const uint8_t * const vp8_dct_cat_prob[] =
+{
+    vp8_dct_cat3_prob,
+    vp8_dct_cat4_prob,
+    vp8_dct_cat5_prob,
+    vp8_dct_cat6_prob,
+};
+
+static const uint8_t vp8_token_default_probs[4][8][3][NUM_DCT_TOKENS-1] =
+{
+    {
+        {
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+        {
+            { 253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128 },
+            { 189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128 },
+            { 106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128 },
+        },
+        {
+            {   1,  98, 248, 255, 236, 226, 255, 255, 128, 128, 128 },
+            { 181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128 },
+            {  78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128 },
+        },
+        {
+            {   1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128 },
+            { 184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128 },
+            {  77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128 },
+            { 170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128 },
+            {  37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128 },
+        },
+        {
+            {   1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128 },
+            { 207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128 },
+            { 102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128 },
+            { 177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128 },
+            {  80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 246,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+    },
+    {
+        {
+            { 198,  35, 237, 223, 193, 187, 162, 160, 145, 155,  62 },
+            { 131,  45, 198, 221, 172, 176, 220, 157, 252, 221,   1 },
+            {  68,  47, 146, 208, 149, 167, 221, 162, 255, 223, 128 },
+        },
+        {
+            {   1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128 },
+            { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128 },
+            {  81,  99, 181, 242, 176, 190, 249, 202, 255, 255, 128 },
+        },
+        {
+            {   1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128 },
+            {  99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128 },
+            {  23,  91, 163, 242, 170, 187, 247, 210, 255, 255, 128 },
+        },
+        {
+            {   1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128 },
+            { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128 },
+            {  44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128 },
+        },
+        {
+            {   1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128 },
+            {  94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128 },
+            {  22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128 },
+        },
+        {
+            {   1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128 },
+            { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128 },
+            {  35,  77, 181, 251, 193, 211, 255, 205, 128, 128, 128 },
+        },
+        {
+            {   1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128 },
+            { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128 },
+            {  45,  99, 188, 251, 195, 217, 255, 224, 128, 128, 128 },
+        },
+        {
+            {   1,   1, 251, 255, 213, 255, 128, 128, 128, 128, 128 },
+            { 203,   1, 248, 255, 255, 128, 128, 128, 128, 128, 128 },
+            { 137,   1, 177, 255, 224, 255, 128, 128, 128, 128, 128 },
+        },
+    },
+    {
+        {
+            { 253,   9, 248, 251, 207, 208, 255, 192, 128, 128, 128 },
+            { 175,  13, 224, 243, 193, 185, 249, 198, 255, 255, 128 },
+            {  73,  17, 171, 221, 161, 179, 236, 167, 255, 234, 128 },
+        },
+        {
+            {   1,  95, 247, 253, 212, 183, 255, 255, 128, 128, 128 },
+            { 239,  90, 244, 250, 211, 209, 255, 255, 128, 128, 128 },
+            { 155,  77, 195, 248, 188, 195, 255, 255, 128, 128, 128 },
+        },
+        {
+            {   1,  24, 239, 251, 218, 219, 255, 205, 128, 128, 128 },
+            { 201,  51, 219, 255, 196, 186, 128, 128, 128, 128, 128 },
+            {  69,  46, 190, 239, 201, 218, 255, 228, 128, 128, 128 },
+        },
+        {
+            {   1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128 },
+            { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128 },
+            { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1,  16, 248, 255, 255, 128, 128, 128, 128, 128, 128 },
+            { 190,  36, 230, 255, 236, 255, 128, 128, 128, 128, 128 },
+            { 149,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128 },
+            { 213,  62, 250, 255, 255, 128, 128, 128, 128, 128, 128 },
+            {  55,  93, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+        {
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+    },
+    {
+        {
+            { 202,  24, 213, 235, 186, 191, 220, 160, 240, 175, 255 },
+            { 126,  38, 182, 232, 169, 184, 228, 174, 255, 187, 128 },
+            {  61,  46, 138, 219, 151, 178, 240, 170, 255, 216, 128 },
+        },
+        {
+            {   1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128 },
+            { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128 },
+            {  39,  77, 162, 232, 172, 180, 245, 178, 255, 255, 128 },
+        },
+        {
+            {   1,  52, 220, 246, 198, 199, 249, 220, 255, 255, 128 },
+            { 124,  74, 191, 243, 183, 193, 250, 221, 255, 255, 128 },
+            {  24,  71, 130, 219, 154, 170, 243, 182, 255, 255, 128 },
+        },
+        {
+            {   1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128 },
+            { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128 },
+            {  28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128 },
+        },
+        {
+            {   1,  81, 230, 252, 204, 203, 255, 192, 128, 128, 128 },
+            { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128 },
+            {  20,  95, 153, 243, 164, 173, 255, 203, 128, 128, 128 },
+        },
+        {
+            {   1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128 },
+            { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128 },
+            {  47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128 },
+        },
+        {
+            {   1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128 },
+            { 141,  84, 213, 252, 201, 202, 255, 219, 128, 128, 128 },
+            {  42,  80, 160, 240, 162, 185, 255, 205, 128, 128, 128 },
+        },
+        {
+            {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 244,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 238,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+    },
+};
+
+static const uint8_t vp8_token_update_probs[4][8][3][NUM_DCT_TOKENS-1] =
+{
+    {
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255 },
+            { 250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+    },
+    {
+        {
+            { 217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255 },
+            { 234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+    },
+    {
+        {
+            { 186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255 },
+            { 251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+    },
+    {
+        {
+            { 248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255 },
+            { 248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+    },
+};
+
+// fixme: copied from h264data.h
+static const uint8_t zigzag_scan[16]={
+    0+0*4, 1+0*4, 0+1*4, 0+2*4,
+    1+1*4, 2+0*4, 3+0*4, 2+1*4,
+    1+2*4, 0+3*4, 1+3*4, 2+2*4,
+    3+1*4, 3+2*4, 2+3*4, 3+3*4,
+};
+
+static const uint8_t vp8_dc_qlookup[VP8_MAX_QUANT+1] =
+{
+      4,   5,   6,   7,   8,   9,  10,  10,  11,  12,  13,  14,  15,  16,  17,  17,
+     18,  19,  20,  20,  21,  21,  22,  22,  23,  23,  24,  25,  25,  26,  27,  28,
+     29,  30,  31,  32,  33,  34,  35,  36,  37,  37,  38,  39,  40,  41,  42,  43,
+     44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,
+     59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,
+     75,  76,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
+     91,  93,  95,  96,  98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118,
+    122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157,
+};
+
+static const uint16_t vp8_ac_qlookup[VP8_MAX_QUANT+1] =
+{
+      4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
+     20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,
+     36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,
+     52,  53,  54,  55,  56,  57,  58,  60,  62,  64,  66,  68,  70,  72,  74,  76,
+     78,  80,  82,  84,  86,  88,  90,  92,  94,  96,  98, 100, 102, 104, 106, 108,
+    110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152,
+    155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209,
+    213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284,
+};
+
+static const uint8_t vp8_mv_update_prob[2][19] = {
+    { 237,
+      246,
+      253, 253, 254, 254, 254, 254, 254,
+      254, 254, 254, 254, 254, 250, 250, 252, 254, 254 },
+    { 231,
+      243,
+      245, 253, 254, 254, 254, 254, 254,
+      254, 254, 254, 254, 254, 251, 251, 254, 254, 254 }
+};
+
+static const uint8_t vp8_mv_default_prob[2][19] = {
+    { 162,
+      128,
+      225, 146, 172, 147, 214, 39, 156,
+      128, 129, 132,  75, 145, 178, 206, 239, 254, 254 },
+    { 164,
+      128,
+      204, 170, 119, 235, 140, 230, 228,
+      128, 130, 130,  74, 148, 180, 203, 236, 254, 254 }
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,509 @@
+/**
+ * VP8 compatible video decoder
+ *
+ * Copyright (C) 2010 David Conrad
+ * Copyright (C) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "dsputil.h"
+#include "vp8dsp.h"
+
+// TODO: Maybe add dequant
+static void vp8_luma_dc_wht_c(DCTELEM block[4][4][16], DCTELEM dc[16])
+{
+    int i, t0, t1, t2, t3;
+
+    for (i = 0; i < 4; i++) {
+        t0 = dc[0*4+i] + dc[3*4+i];
+        t1 = dc[1*4+i] + dc[2*4+i];
+        t2 = dc[1*4+i] - dc[2*4+i];
+        t3 = dc[0*4+i] - dc[3*4+i];
+
+        dc[0*4+i] = t0 + t1;
+        dc[1*4+i] = t3 + t2;
+        dc[2*4+i] = t0 - t1;
+        dc[3*4+i] = t3 - t2;
+    }
+
+    for (i = 0; i < 4; i++) {
+        t0 = dc[i*4+0] + dc[i*4+3] + 3; // rounding
+        t1 = dc[i*4+1] + dc[i*4+2];
+        t2 = dc[i*4+1] - dc[i*4+2];
+        t3 = dc[i*4+0] - dc[i*4+3] + 3; // rounding
+
+        *block[i][0] = (t0 + t1) >> 3;
+        *block[i][1] = (t3 + t2) >> 3;
+        *block[i][2] = (t0 - t1) >> 3;
+        *block[i][3] = (t3 - t2) >> 3;
+    }
+}
+
+
+#define MUL_20091(a) ((((a)*20091) >> 16) + (a))
+#define MUL_35468(a)  (((a)*35468) >> 16)
+
+static void vp8_idct_add_c(uint8_t *dst, DCTELEM block[16], int stride)
+{
+    int i, t0, t1, t2, t3;
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
+    DCTELEM tmp[16];
+
+    for (i = 0; i < 4; i++) {
+        t0 = block[0*4+i] + block[2*4+i];
+        t1 = block[0*4+i] - block[2*4+i];
+        t2 = MUL_35468(block[1*4+i]) - MUL_20091(block[3*4+i]);
+        t3 = MUL_20091(block[1*4+i]) + MUL_35468(block[3*4+i]);
+        block[0*4+i] = 0;
+        block[1*4+i] = 0;
+        block[2*4+i] = 0;
+        block[3*4+i] = 0;
+
+        tmp[i*4+0] = t0 + t3;
+        tmp[i*4+1] = t1 + t2;
+        tmp[i*4+2] = t1 - t2;
+        tmp[i*4+3] = t0 - t3;
+    }
+
+    for (i = 0; i < 4; i++) {
+        t0 = tmp[0*4+i] + tmp[2*4+i];
+        t1 = tmp[0*4+i] - tmp[2*4+i];
+        t2 = MUL_35468(tmp[1*4+i]) - MUL_20091(tmp[3*4+i]);
+        t3 = MUL_20091(tmp[1*4+i]) + MUL_35468(tmp[3*4+i]);
+
+        dst[0] = cm[dst[0] + ((t0 + t3 + 4) >> 3)];
+        dst[1] = cm[dst[1] + ((t1 + t2 + 4) >> 3)];
+        dst[2] = cm[dst[2] + ((t1 - t2 + 4) >> 3)];
+        dst[3] = cm[dst[3] + ((t0 - t3 + 4) >> 3)];
+        dst += stride;
+    }
+}
+
+static void vp8_idct_dc_add_c(uint8_t *dst, DCTELEM block[16], int stride)
+{
+    int i, dc = (block[0] + 4) >> 3;
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;
+    block[0] = 0;
+
+    for (i = 0; i < 4; i++) {
+        dst[0] = cm[dst[0]];
+        dst[1] = cm[dst[1]];
+        dst[2] = cm[dst[2]];
+        dst[3] = cm[dst[3]];
+        dst += stride;
+    }
+}
+
+static void vp8_idct_dc_add4uv_c(uint8_t *dst, DCTELEM block[4][16], int stride)
+{
+    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);
+    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);
+    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);
+    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);
+}
+
+static void vp8_idct_dc_add4y_c(uint8_t *dst, DCTELEM block[4][16], int stride)
+{
+    vp8_idct_dc_add_c(dst+ 0, block[0], stride);
+    vp8_idct_dc_add_c(dst+ 4, block[1], stride);
+    vp8_idct_dc_add_c(dst+ 8, block[2], stride);
+    vp8_idct_dc_add_c(dst+12, block[3], stride);
+}
+
+// because I like only having two parameters to pass functions...
+#define LOAD_PIXELS\
+    int av_unused p3 = p[-4*stride];\
+    int av_unused p2 = p[-3*stride];\
+    int av_unused p1 = p[-2*stride];\
+    int av_unused p0 = p[-1*stride];\
+    int av_unused q0 = p[ 0*stride];\
+    int av_unused q1 = p[ 1*stride];\
+    int av_unused q2 = p[ 2*stride];\
+    int av_unused q3 = p[ 3*stride];
+
+#define clip_int8(n) (cm[n+0x80]-0x80)
+
+static av_always_inline void filter_common(uint8_t *p, int stride, int is4tap)
+{
+    LOAD_PIXELS
+    int a, f1, f2;
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
+
+    a = 3*(q0 - p0);
+
+    if (is4tap)
+        a += clip_int8(p1 - q1);
+
+    a = clip_int8(a);
+
+    // We deviate from the spec here with c(a+3) >> 3
+    // since that's what libvpx does.
+    f1 = FFMIN(a+4, 127) >> 3;
+    f2 = FFMIN(a+3, 127) >> 3;
+
+    // Despite what the spec says, we do need to clamp here to
+    // be bitexact with libvpx.
+    p[-1*stride] = cm[p0 + f2];
+    p[ 0*stride] = cm[q0 - f1];
+
+    // only used for _inner on blocks without high edge variance
+    if (!is4tap) {
+        a = (f1+1)>>1;
+        p[-2*stride] = cm[p1 + a];
+        p[ 1*stride] = cm[q1 - a];
+    }
+}
+
+static av_always_inline int simple_limit(uint8_t *p, int stride, int flim)
+{
+    LOAD_PIXELS
+    return 2*FFABS(p0-q0) + (FFABS(p1-q1) >> 1) <= flim;
+}
+
+/**
+ * E - limit at the macroblock edge
+ * I - limit for interior difference
+ */
+static av_always_inline int normal_limit(uint8_t *p, int stride, int E, int I)
+{
+    LOAD_PIXELS
+    return simple_limit(p, stride, E)
+        && FFABS(p3-p2) <= I && FFABS(p2-p1) <= I && FFABS(p1-p0) <= I
+        && FFABS(q3-q2) <= I && FFABS(q2-q1) <= I && FFABS(q1-q0) <= I;
+}
+
+// high edge variance
+static av_always_inline int hev(uint8_t *p, int stride, int thresh)
+{
+    LOAD_PIXELS
+    return FFABS(p1-p0) > thresh || FFABS(q1-q0) > thresh;
+}
+
+static av_always_inline void filter_mbedge(uint8_t *p, int stride)
+{
+    int a0, a1, a2, w;
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
+
+    LOAD_PIXELS
+
+    w = clip_int8(p1-q1);
+    w = clip_int8(w + 3*(q0-p0));
+
+    a0 = (27*w + 63) >> 7;
+    a1 = (18*w + 63) >> 7;
+    a2 = ( 9*w + 63) >> 7;
+
+    p[-3*stride] = cm[p2 + a2];
+    p[-2*stride] = cm[p1 + a1];
+    p[-1*stride] = cm[p0 + a0];
+    p[ 0*stride] = cm[q0 - a0];
+    p[ 1*stride] = cm[q1 - a1];
+    p[ 2*stride] = cm[q2 - a2];
+}
+
+#define LOOP_FILTER(dir, size, stridea, strideb, maybe_inline) \
+static maybe_inline void vp8_ ## dir ## _loop_filter ## size ## _c(uint8_t *dst, int stride,\
+                                     int flim_E, int flim_I, int hev_thresh)\
+{\
+    int i;\
+\
+    for (i = 0; i < size; i++)\
+        if (normal_limit(dst+i*stridea, strideb, flim_E, flim_I)) {\
+            if (hev(dst+i*stridea, strideb, hev_thresh))\
+                filter_common(dst+i*stridea, strideb, 1);\
+            else\
+                filter_mbedge(dst+i*stridea, strideb);\
+        }\
+}\
+\
+static maybe_inline void vp8_ ## dir ## _loop_filter ## size ## _inner_c(uint8_t *dst, int stride,\
+                                      int flim_E, int flim_I, int hev_thresh)\
+{\
+    int i;\
+\
+    for (i = 0; i < size; i++)\
+        if (normal_limit(dst+i*stridea, strideb, flim_E, flim_I)) {\
+            int hv = hev(dst+i*stridea, strideb, hev_thresh);\
+            if (hv) \
+                filter_common(dst+i*stridea, strideb, 1);\
+            else \
+                filter_common(dst+i*stridea, strideb, 0);\
+        }\
+}
+
+LOOP_FILTER(v, 16, 1, stride,)
+LOOP_FILTER(h, 16, stride, 1,)
+
+#define UV_LOOP_FILTER(dir, stridea, strideb) \
+LOOP_FILTER(dir, 8, stridea, strideb, av_always_inline) \
+static void vp8_ ## dir ## _loop_filter8uv_c(uint8_t *dstU, uint8_t *dstV, int stride,\
+                                      int fE, int fI, int hev_thresh)\
+{\
+  vp8_ ## dir ## _loop_filter8_c(dstU, stride, fE, fI, hev_thresh);\
+  vp8_ ## dir ## _loop_filter8_c(dstV, stride, fE, fI, hev_thresh);\
+}\
+static void vp8_ ## dir ## _loop_filter8uv_inner_c(uint8_t *dstU, uint8_t *dstV, int stride,\
+                                      int fE, int fI, int hev_thresh)\
+{\
+  vp8_ ## dir ## _loop_filter8_inner_c(dstU, stride, fE, fI, hev_thresh);\
+  vp8_ ## dir ## _loop_filter8_inner_c(dstV, stride, fE, fI, hev_thresh);\
+}
+
+UV_LOOP_FILTER(v, 1, stride)
+UV_LOOP_FILTER(h, stride, 1)
+
+static void vp8_v_loop_filter_simple_c(uint8_t *dst, int stride, int flim)
+{
+    int i;
+
+    for (i = 0; i < 16; i++)
+        if (simple_limit(dst+i, stride, flim))
+            filter_common(dst+i, stride, 1);
+}
+
+static void vp8_h_loop_filter_simple_c(uint8_t *dst, int stride, int flim)
+{
+    int i;
+
+    for (i = 0; i < 16; i++)
+        if (simple_limit(dst+i*stride, 1, flim))
+            filter_common(dst+i*stride, 1, 1);
+}
+
+static const uint8_t subpel_filters[7][6] = {
+    { 0,   6, 123,  12,   1,   0 },
+    { 2,  11, 108,  36,   8,   1 },
+    { 0,   9,  93,  50,   6,   0 },
+    { 3,  16,  77,  77,  16,   3 },
+    { 0,   6,  50,  93,   9,   0 },
+    { 1,   8,  36, 108,  11,   2 },
+    { 0,   1,  12, 123,   6,   0 },
+};
+
+#define PUT_PIXELS(WIDTH) \
+static void put_vp8_pixels ## WIDTH ##_c(uint8_t *dst, int dststride, uint8_t *src, int srcstride, int h, int x, int y) { \
+    int i; \
+    for (i = 0; i < h; i++, dst+= dststride, src+= srcstride) { \
+        memcpy(dst, src, WIDTH); \
+    } \
+}
+
+PUT_PIXELS(16)
+PUT_PIXELS(8)
+PUT_PIXELS(4)
+
+#define FILTER_6TAP(src, F, stride) \
+    cm[(F[2]*src[x+0*stride] - F[1]*src[x-1*stride] + F[0]*src[x-2*stride] + \
+        F[3]*src[x+1*stride] - F[4]*src[x+2*stride] + F[5]*src[x+3*stride] + 64) >> 7]
+
+#define FILTER_4TAP(src, F, stride) \
+    cm[(F[2]*src[x+0*stride] - F[1]*src[x-1*stride] + \
+        F[3]*src[x+1*stride] - F[4]*src[x+2*stride] + 64) >> 7]
+
+#define VP8_EPEL_H(SIZE, FILTER, FILTERNAME) \
+static void put_vp8_epel ## SIZE ## _ ## FILTERNAME ## _c(uint8_t *dst, int dststride, uint8_t *src, int srcstride, int h, int mx, int my) \
+{ \
+    const uint8_t *filter = subpel_filters[mx-1]; \
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP; \
+    int x, y; \
+\
+    for (y = 0; y < h; y++) { \
+        for (x = 0; x < SIZE; x++) \
+            dst[x] = FILTER(src, filter, 1); \
+        dst += dststride; \
+        src += srcstride; \
+    } \
+}
+#define VP8_EPEL_V(SIZE, FILTER, FILTERNAME) \
+static void put_vp8_epel ## SIZE ## _ ## FILTERNAME ## _c(uint8_t *dst, int dststride, uint8_t *src, int srcstride, int h, int mx, int my) \
+{ \
+    const uint8_t *filter = subpel_filters[my-1]; \
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP; \
+    int x, y; \
+\
+    for (y = 0; y < h; y++) { \
+        for (x = 0; x < SIZE; x++) \
+            dst[x] = FILTER(src, filter, srcstride); \
+        dst += dststride; \
+        src += srcstride; \
+    } \
+}
+#define VP8_EPEL_HV(SIZE, FILTERX, FILTERY, FILTERNAME) \
+static void put_vp8_epel ## SIZE ## _ ## FILTERNAME ## _c(uint8_t *dst, int dststride, uint8_t *src, int srcstride, int h, int mx, int my) \
+{ \
+    const uint8_t *filter = subpel_filters[mx-1]; \
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP; \
+    int x, y; \
+    uint8_t tmp_array[(2*SIZE+5)*SIZE]; \
+    uint8_t *tmp = tmp_array; \
+    src -= 2*srcstride; \
+\
+    for (y = 0; y < h+5; y++) { \
+        for (x = 0; x < SIZE; x++) \
+            tmp[x] = FILTERX(src, filter, 1); \
+        tmp += SIZE; \
+        src += srcstride; \
+    } \
+\
+    tmp = tmp_array + 2*SIZE; \
+    filter = subpel_filters[my-1]; \
+\
+    for (y = 0; y < h; y++) { \
+        for (x = 0; x < SIZE; x++) \
+            dst[x] = FILTERY(tmp, filter, SIZE); \
+        dst += dststride; \
+        tmp += SIZE; \
+    } \
+}
+
+VP8_EPEL_H(16, FILTER_4TAP, h4)
+VP8_EPEL_H(8,  FILTER_4TAP, h4)
+VP8_EPEL_H(4,  FILTER_4TAP, h4)
+VP8_EPEL_H(16, FILTER_6TAP, h6)
+VP8_EPEL_H(8,  FILTER_6TAP, h6)
+VP8_EPEL_H(4,  FILTER_6TAP, h6)
+VP8_EPEL_V(16, FILTER_4TAP, v4)
+VP8_EPEL_V(8,  FILTER_4TAP, v4)
+VP8_EPEL_V(4,  FILTER_4TAP, v4)
+VP8_EPEL_V(16, FILTER_6TAP, v6)
+VP8_EPEL_V(8,  FILTER_6TAP, v6)
+VP8_EPEL_V(4,  FILTER_6TAP, v6)
+VP8_EPEL_HV(16, FILTER_4TAP, FILTER_4TAP, h4v4)
+VP8_EPEL_HV(8,  FILTER_4TAP, FILTER_4TAP, h4v4)
+VP8_EPEL_HV(4,  FILTER_4TAP, FILTER_4TAP, h4v4)
+VP8_EPEL_HV(16, FILTER_4TAP, FILTER_6TAP, h4v6)
+VP8_EPEL_HV(8,  FILTER_4TAP, FILTER_6TAP, h4v6)
+VP8_EPEL_HV(4,  FILTER_4TAP, FILTER_6TAP, h4v6)
+VP8_EPEL_HV(16, FILTER_6TAP, FILTER_4TAP, h6v4)
+VP8_EPEL_HV(8,  FILTER_6TAP, FILTER_4TAP, h6v4)
+VP8_EPEL_HV(4,  FILTER_6TAP, FILTER_4TAP, h6v4)
+VP8_EPEL_HV(16, FILTER_6TAP, FILTER_6TAP, h6v6)
+VP8_EPEL_HV(8,  FILTER_6TAP, FILTER_6TAP, h6v6)
+VP8_EPEL_HV(4,  FILTER_6TAP, FILTER_6TAP, h6v6)
+
+#define VP8_BILINEAR(SIZE) \
+static void put_vp8_bilinear ## SIZE ## _h_c(uint8_t *dst, int stride, uint8_t *src, int s2, int h, int mx, int my) \
+{ \
+    int a = 8-mx, b = mx; \
+    int x, y; \
+\
+    for (y = 0; y < h; y++) { \
+        for (x = 0; x < SIZE; x++) \
+            dst[x] = (a*src[x] + b*src[x+1] + 4) >> 3; \
+        dst += stride; \
+        src += stride; \
+    } \
+} \
+static void put_vp8_bilinear ## SIZE ## _v_c(uint8_t *dst, int stride, uint8_t *src, int s2, int h, int mx, int my) \
+{ \
+    int c = 8-my, d = my; \
+    int x, y; \
+\
+    for (y = 0; y < h; y++) { \
+        for (x = 0; x < SIZE; x++) \
+            dst[x] = (c*src[x] + d*src[x+stride] + 4) >> 3; \
+        dst += stride; \
+        src += stride; \
+    } \
+} \
+\
+static void put_vp8_bilinear ## SIZE ## _hv_c(uint8_t *dst, int stride, uint8_t *src, int s2, int h, int mx, int my) \
+{ \
+    int a = 8-mx, b = mx; \
+    int c = 8-my, d = my; \
+    int x, y; \
+    uint8_t tmp_array[(2*SIZE+1)*SIZE]; \
+    uint8_t *tmp = tmp_array; \
+\
+    for (y = 0; y < h+1; y++) { \
+        for (x = 0; x < SIZE; x++) \
+            tmp[x] = (a*src[x] + b*src[x+1] + 4) >> 3; \
+        tmp += SIZE; \
+        src += stride; \
+    } \
+\
+    tmp = tmp_array; \
+\
+    for (y = 0; y < h; y++) { \
+        for (x = 0; x < SIZE; x++) \
+            dst[x] = (c*tmp[x] + d*tmp[x+SIZE] + 4) >> 3; \
+        dst += stride; \
+        tmp += SIZE; \
+    } \
+}
+
+VP8_BILINEAR(16)
+VP8_BILINEAR(8)
+VP8_BILINEAR(4)
+
+#define VP8_MC_FUNC(IDX, SIZE) \
+    dsp->put_vp8_epel_pixels_tab[IDX][0][0] = put_vp8_pixels ## SIZE ## _c; \
+    dsp->put_vp8_epel_pixels_tab[IDX][0][1] = put_vp8_epel ## SIZE ## _h4_c; \
+    dsp->put_vp8_epel_pixels_tab[IDX][0][2] = put_vp8_epel ## SIZE ## _h6_c; \
+    dsp->put_vp8_epel_pixels_tab[IDX][1][0] = put_vp8_epel ## SIZE ## _v4_c; \
+    dsp->put_vp8_epel_pixels_tab[IDX][1][1] = put_vp8_epel ## SIZE ## _h4v4_c; \
+    dsp->put_vp8_epel_pixels_tab[IDX][1][2] = put_vp8_epel ## SIZE ## _h6v4_c; \
+    dsp->put_vp8_epel_pixels_tab[IDX][2][0] = put_vp8_epel ## SIZE ## _v6_c; \
+    dsp->put_vp8_epel_pixels_tab[IDX][2][1] = put_vp8_epel ## SIZE ## _h4v6_c; \
+    dsp->put_vp8_epel_pixels_tab[IDX][2][2] = put_vp8_epel ## SIZE ## _h6v6_c
+
+#define VP8_BILINEAR_MC_FUNC(IDX, SIZE) \
+    dsp->put_vp8_bilinear_pixels_tab[IDX][0][0] = put_vp8_pixels ## SIZE ## _c; \
+    dsp->put_vp8_bilinear_pixels_tab[IDX][0][1] = put_vp8_bilinear ## SIZE ## _h_c; \
+    dsp->put_vp8_bilinear_pixels_tab[IDX][0][2] = put_vp8_bilinear ## SIZE ## _h_c; \
+    dsp->put_vp8_bilinear_pixels_tab[IDX][1][0] = put_vp8_bilinear ## SIZE ## _v_c; \
+    dsp->put_vp8_bilinear_pixels_tab[IDX][1][1] = put_vp8_bilinear ## SIZE ## _hv_c; \
+    dsp->put_vp8_bilinear_pixels_tab[IDX][1][2] = put_vp8_bilinear ## SIZE ## _hv_c; \
+    dsp->put_vp8_bilinear_pixels_tab[IDX][2][0] = put_vp8_bilinear ## SIZE ## _v_c; \
+    dsp->put_vp8_bilinear_pixels_tab[IDX][2][1] = put_vp8_bilinear ## SIZE ## _hv_c; \
+    dsp->put_vp8_bilinear_pixels_tab[IDX][2][2] = put_vp8_bilinear ## SIZE ## _hv_c
+
+av_cold void ff_vp8dsp_init(VP8DSPContext *dsp)
+{
+    dsp->vp8_luma_dc_wht    = vp8_luma_dc_wht_c;
+    dsp->vp8_idct_add       = vp8_idct_add_c;
+    dsp->vp8_idct_dc_add    = vp8_idct_dc_add_c;
+    dsp->vp8_idct_dc_add4y  = vp8_idct_dc_add4y_c;
+    dsp->vp8_idct_dc_add4uv = vp8_idct_dc_add4uv_c;
+
+    dsp->vp8_v_loop_filter16y = vp8_v_loop_filter16_c;
+    dsp->vp8_h_loop_filter16y = vp8_h_loop_filter16_c;
+    dsp->vp8_v_loop_filter8uv = vp8_v_loop_filter8uv_c;
+    dsp->vp8_h_loop_filter8uv = vp8_h_loop_filter8uv_c;
+
+    dsp->vp8_v_loop_filter16y_inner = vp8_v_loop_filter16_inner_c;
+    dsp->vp8_h_loop_filter16y_inner = vp8_h_loop_filter16_inner_c;
+    dsp->vp8_v_loop_filter8uv_inner = vp8_v_loop_filter8uv_inner_c;
+    dsp->vp8_h_loop_filter8uv_inner = vp8_h_loop_filter8uv_inner_c;
+
+    dsp->vp8_v_loop_filter_simple = vp8_v_loop_filter_simple_c;
+    dsp->vp8_h_loop_filter_simple = vp8_h_loop_filter_simple_c;
+
+    VP8_MC_FUNC(0, 16);
+    VP8_MC_FUNC(1, 8);
+    VP8_MC_FUNC(2, 4);
+
+    VP8_BILINEAR_MC_FUNC(0, 16);
+    VP8_BILINEAR_MC_FUNC(1, 8);
+    VP8_BILINEAR_MC_FUNC(2, 4);
+
+    if (HAVE_MMX)
+        ff_vp8dsp_init_x86(dsp);
+    if (HAVE_ALTIVEC)
+        ff_vp8dsp_init_altivec(dsp);
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,82 @@
+/**
+ * VP8 compatible video decoder
+ *
+ * Copyright (C) 2010 David Conrad
+ * Copyright (C) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+#ifndef AVCODEC_VP8DSP_H
+#define AVCODEC_VP8DSP_H
+
+#include "dsputil.h"
+
+typedef void (*vp8_mc_func)(uint8_t *dst/*align 8*/, int dstStride, uint8_t *src/*align 1*/, int srcStride, int h, int x, int y);
+
+typedef struct VP8DSPContext {
+    void (*vp8_luma_dc_wht)(DCTELEM block[4][4][16], DCTELEM dc[16]);
+    void (*vp8_idct_add)(uint8_t *dst, DCTELEM block[16], int stride);
+    void (*vp8_idct_dc_add)(uint8_t *dst, DCTELEM block[16], int stride);
+    void (*vp8_idct_dc_add4y)(uint8_t *dst, DCTELEM block[4][16], int stride);
+    void (*vp8_idct_dc_add4uv)(uint8_t *dst, DCTELEM block[4][16], int stride);
+
+    // loop filter applied to edges between macroblocks
+    void (*vp8_v_loop_filter16y)(uint8_t *dst, int stride,
+                                 int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_h_loop_filter16y)(uint8_t *dst, int stride,
+                                 int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_v_loop_filter8uv)(uint8_t *dstU, uint8_t *dstV, int stride,
+                                 int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_h_loop_filter8uv)(uint8_t *dstU, uint8_t *dstV, int stride,
+                                 int flim_E, int flim_I, int hev_thresh);
+
+    // loop filter applied to inner macroblock edges
+    void (*vp8_v_loop_filter16y_inner)(uint8_t *dst, int stride,
+                                       int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_h_loop_filter16y_inner)(uint8_t *dst, int stride,
+                                       int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_v_loop_filter8uv_inner)(uint8_t *dstU, uint8_t *dstV, int stride,
+                                       int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_h_loop_filter8uv_inner)(uint8_t *dstU, uint8_t *dstV, int stride,
+                                       int flim_E, int flim_I, int hev_thresh);
+
+    void (*vp8_v_loop_filter_simple)(uint8_t *dst, int stride, int flim);
+    void (*vp8_h_loop_filter_simple)(uint8_t *dst, int stride, int flim);
+
+    /**
+     * first dimension: width>>3, height is assumed equal to width
+     * second dimension: 0 if no vertical interpolation is needed;
+     *                   1 4-tap vertical interpolation filter (my & 1)
+     *                   2 6-tap vertical interpolation filter (!(my & 1))
+     * third dimension: same as second dimention, for horizontal interpolation
+     * so something like put_vp8_epel_pixels_tab[width>>3][2*!!my-(my&1)][2*!!mx-(mx&1)](..., mx, my)
+     */
+    vp8_mc_func put_vp8_epel_pixels_tab[3][3][3];
+    vp8_mc_func put_vp8_bilinear_pixels_tab[3][3][3];
+} VP8DSPContext;
+
+void ff_put_vp8_pixels16_c(uint8_t *dst, uint8_t *src, int stride, int h, int x, int y);
+void ff_put_vp8_pixels8_c(uint8_t *dst, uint8_t *src, int stride, int h, int x, int y);
+void ff_put_vp8_pixels4_c(uint8_t *dst, uint8_t *src, int stride, int h, int x, int y);
+
+void ff_vp8dsp_init(VP8DSPContext *c);
+void ff_vp8dsp_init_x86(VP8DSPContext *c);
+void ff_vp8dsp_init_altivec(VP8DSPContext *c);
+
+#endif /* AVCODEC_VP8DSP_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/dct32_sse.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/dct32_sse.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/dct32_sse.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,294 @@
+/*
+ * 32 point SSE-optimized DCT transform
+ * Copyright (c) 2010 Vitor Sessak
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "libavutil/x86_cpu.h"
+#include "libavutil/mem.h"
+#include "libavcodec/dsputil.h"
+#include "fft.h"
+
+DECLARE_ALIGNED(16, static const float, b1)[] = {
+     0.500603,  0.505471,  0.515447,  0.531043,
+     0.553104,  0.582935,  0.622504,  0.674808,
+    -1.169440, -0.972568, -0.839350, -0.744536,
+   -10.190008, -3.407609, -2.057781, -1.484165,
+     0.502419,  0.522499,  0.566944,  0.646822,
+     0.788155,  1.060678,  1.722447,  5.101149,
+     0.509796,  0.601345,  0.899976,  2.562916,
+     1.000000,  1.000000,  1.306563,  0.541196,
+     1.000000,  0.707107,  1.000000, -0.707107
+};
+
+DECLARE_ALIGNED(16, static const int32_t, smask)[4] = {
+    0, 0, 0x80000000, 0x80000000
+};
+
+/* butterfly operator */
+#define BUTTERFLY(a,b,c,tmp)                            \
+    "movaps  %%" #a    ", %%" #tmp  "             \n\t" \
+    "subps   %%" #b    ", %%" #a    "             \n\t" \
+    "addps   %%" #tmp  ", %%" #b    "             \n\t" \
+    "mulps     " #c    ", %%" #a    "             \n\t"
+
+///* Same as BUTTERFLY when vectors a and b overlap */
+#define BUTTERFLY0(val, mask, cos, tmp, shuf)                            \
+    "movaps  %%" #val  ", %%" #tmp  "             \n\t"                  \
+    "shufps    " #shuf ", %%" #val  ",%%" #val "  \n\t"                  \
+    "xorps   %%" #mask ", %%" #tmp  "             \n\t" /* flip signs */ \
+    "addps   %%" #tmp  ", %%" #val  "             \n\t"                  \
+    "mulps   %%" #cos  ", %%" #val  "             \n\t"
+
+#define BUTTERFLY2(val, mask, cos, tmp) BUTTERFLY0(val, mask, cos, tmp, $0x1b)
+#define BUTTERFLY3(val, mask, cos, tmp) BUTTERFLY0(val, mask, cos, tmp, $0xb1)
+
+void ff_dct32_float_sse(FFTSample *out, const FFTSample *in)
+{
+    int32_t tmp1 = 0;
+    __asm__ volatile(
+        /* pass 1 */
+
+        "movaps    (%4), %%xmm0           \n\t"
+        "movaps 112(%4), %%xmm1           \n\t"
+        "shufps   $0x1b, %%xmm1, %%xmm1   \n\t"
+        BUTTERFLY(xmm0, xmm1, (%2), xmm3)
+
+        "movaps  64(%4), %%xmm7           \n\t"
+        "movaps  48(%4), %%xmm4           \n\t"
+        "shufps   $0x1b, %%xmm4, %%xmm4   \n\t"
+        BUTTERFLY(xmm7, xmm4, 48(%2), xmm3)
+
+
+        /* pass 2 */
+        "movaps  64(%2), %%xmm2           \n\t"
+        BUTTERFLY(xmm1, xmm4, %%xmm2, xmm3)
+        "movaps  %%xmm1, 48(%1)           \n\t"
+        "movaps  %%xmm4, (%1)             \n\t"
+
+        /* pass 1 */
+        "movaps  16(%4), %%xmm1           \n\t"
+        "movaps  96(%4), %%xmm6           \n\t"
+        "shufps   $0x1b, %%xmm6, %%xmm6   \n\t"
+        BUTTERFLY(xmm1, xmm6, 16(%2), xmm3)
+
+        "movaps  80(%4), %%xmm4           \n\t"
+        "movaps  32(%4), %%xmm5           \n\t"
+        "shufps   $0x1b, %%xmm5, %%xmm5   \n\t"
+        BUTTERFLY(xmm4, xmm5, 32(%2), xmm3)
+
+        /* pass 2 */
+        BUTTERFLY(xmm0, xmm7, %%xmm2, xmm3)
+
+        "movaps  80(%2), %%xmm2           \n\t"
+        BUTTERFLY(xmm6, xmm5, %%xmm2, xmm3)
+
+        BUTTERFLY(xmm1, xmm4, %%xmm2, xmm3)
+
+        /* pass 3 */
+        "movaps  96(%2), %%xmm2           \n\t"
+        "shufps   $0x1b, %%xmm1, %%xmm1   \n\t"
+        BUTTERFLY(xmm0, xmm1, %%xmm2, xmm3)
+        "movaps  %%xmm0, 112(%1)          \n\t"
+        "movaps  %%xmm1,  96(%1)          \n\t"
+
+        "movaps   0(%1), %%xmm0           \n\t"
+        "shufps   $0x1b, %%xmm5, %%xmm5   \n\t"
+        BUTTERFLY(xmm0, xmm5, %%xmm2, xmm3)
+
+        "movaps  48(%1), %%xmm1           \n\t"
+        "shufps   $0x1b, %%xmm6, %%xmm6   \n\t"
+        BUTTERFLY(xmm1, xmm6, %%xmm2, xmm3)
+        "movaps  %%xmm1,  48(%1)          \n\t"
+
+        "shufps   $0x1b, %%xmm4, %%xmm4   \n\t"
+        BUTTERFLY(xmm7, xmm4, %%xmm2, xmm3)
+
+        /* pass 4 */
+        "movaps    (%3), %%xmm3           \n\t"
+        "movaps 112(%2), %%xmm2           \n\t"
+
+        BUTTERFLY2(xmm5, xmm3, xmm2, xmm1)
+
+        BUTTERFLY2(xmm0, xmm3, xmm2, xmm1)
+        "movaps  %%xmm0, 16(%1)           \n\t"
+
+        BUTTERFLY2(xmm6, xmm3, xmm2, xmm1)
+        "movaps  %%xmm6, 32(%1)           \n\t"
+
+        "movaps  48(%1), %%xmm0           \n\t"
+        BUTTERFLY2(xmm0, xmm3, xmm2, xmm1)
+        "movaps  %%xmm0, 48(%1)           \n\t"
+
+        BUTTERFLY2(xmm4, xmm3, xmm2, xmm1)
+
+        BUTTERFLY2(xmm7, xmm3, xmm2, xmm1)
+
+        "movaps  96(%1), %%xmm6           \n\t"
+        BUTTERFLY2(xmm6, xmm3, xmm2, xmm1)
+
+        "movaps 112(%1), %%xmm0           \n\t"
+        BUTTERFLY2(xmm0, xmm3, xmm2, xmm1)
+
+        /* pass 5 */
+        "movaps 128(%2), %%xmm2           \n\t"
+        "shufps   $0xCC, %%xmm3,%%xmm3    \n\t"
+
+        BUTTERFLY3(xmm5, xmm3, xmm2, xmm1)
+        "movaps  %%xmm5, (%1)             \n\t"
+
+        "movaps  16(%1), %%xmm1           \n\t"
+        BUTTERFLY3(xmm1, xmm3, xmm2, xmm5)
+        "movaps  %%xmm1, 16(%1)           \n\t"
+
+        BUTTERFLY3(xmm4, xmm3, xmm2, xmm5)
+        "movaps  %%xmm4, 64(%1)           \n\t"
+
+        BUTTERFLY3(xmm7, xmm3, xmm2, xmm5)
+        "movaps  %%xmm7, 80(%1)           \n\t"
+
+        "movaps  32(%1), %%xmm5           \n\t"
+        BUTTERFLY3(xmm5, xmm3, xmm2, xmm7)
+        "movaps  %%xmm5, 32(%1)           \n\t"
+
+        "movaps  48(%1), %%xmm4           \n\t"
+        BUTTERFLY3(xmm4, xmm3, xmm2, xmm7)
+        "movaps  %%xmm4, 48(%1)           \n\t"
+
+        BUTTERFLY3(xmm6, xmm3, xmm2, xmm7)
+        "movaps  %%xmm6, 96(%1)           \n\t"
+
+        BUTTERFLY3(xmm0, xmm3, xmm2, xmm7)
+        "movaps  %%xmm0, 112(%1)          \n\t"
+
+
+        /* pass 6, no SIMD... */
+        "movss    56(%1),  %%xmm3           \n\t"
+        "movl      4(%1),      %0           \n\t"
+        "addss    60(%1),  %%xmm3           \n\t"
+        "movss    72(%1),  %%xmm7           \n\t"
+        "addss    %%xmm3,  %%xmm4           \n\t"
+        "movss    52(%1),  %%xmm2           \n\t"
+        "addss    %%xmm3,  %%xmm2           \n\t"
+        "movss    24(%1),  %%xmm3           \n\t"
+        "addss    28(%1),  %%xmm3           \n\t"
+        "addss    76(%1),  %%xmm7           \n\t"
+        "addss    %%xmm3,  %%xmm1           \n\t"
+        "addss    %%xmm4,  %%xmm5           \n\t"
+        "movss    %%xmm1,  16(%1)           \n\t"
+        "movss    20(%1),  %%xmm1           \n\t"
+        "addss    %%xmm3,  %%xmm1           \n\t"
+        "movss    40(%1),  %%xmm3           \n\t"
+        "movss    %%xmm1,  48(%1)           \n\t"
+        "addss    44(%1),  %%xmm3           \n\t"
+        "movss    20(%1),  %%xmm1           \n\t"
+        "addss    %%xmm3,  %%xmm4           \n\t"
+        "addss    %%xmm2,  %%xmm3           \n\t"
+        "addss    28(%1),  %%xmm1           \n\t"
+        "movss    %%xmm3,  40(%1)           \n\t"
+        "addss    36(%1),  %%xmm2           \n\t"
+        "movss     8(%1),  %%xmm3           \n\t"
+        "movss    %%xmm2,  56(%1)           \n\t"
+        "addss    12(%1),  %%xmm3           \n\t"
+        "movss    %%xmm5,   8(%1)           \n\t"
+        "movss    %%xmm3,  32(%1)           \n\t"
+        "movss    52(%1),  %%xmm2           \n\t"
+        "movss    80(%1),  %%xmm3           \n\t"
+        "movss   120(%1),  %%xmm5           \n\t"
+        "movss    %%xmm1,  80(%1)           \n\t"
+        "movss    %%xmm4,  24(%1)           \n\t"
+        "addss   124(%1),  %%xmm5           \n\t"
+        "movss    64(%1),  %%xmm1           \n\t"
+        "addss    60(%1),  %%xmm2           \n\t"
+        "addss    %%xmm5,  %%xmm0           \n\t"
+        "addss   116(%1),  %%xmm5           \n\t"
+        "movl         %0,  64(%1)           \n\t"
+        "addss    %%xmm0,  %%xmm6           \n\t"
+        "addss    %%xmm6,  %%xmm1           \n\t"
+        "movl     12(%1),      %0           \n\t"
+        "movss    %%xmm1,   4(%1)           \n\t"
+        "movss    88(%1),  %%xmm1           \n\t"
+        "movl         %0,  96(%1)           \n\t"
+        "addss    92(%1),  %%xmm1           \n\t"
+        "movss   104(%1),  %%xmm4           \n\t"
+        "movl     28(%1),      %0           \n\t"
+        "addss   108(%1),  %%xmm4           \n\t"
+        "addss    %%xmm4,  %%xmm0           \n\t"
+        "addss    %%xmm1,  %%xmm3           \n\t"
+        "addss    84(%1),  %%xmm1           \n\t"
+        "addss    %%xmm5,  %%xmm4           \n\t"
+        "addss    %%xmm3,  %%xmm6           \n\t"
+        "addss    %%xmm0,  %%xmm3           \n\t"
+        "addss    %%xmm7,  %%xmm0           \n\t"
+        "addss   100(%1),  %%xmm5           \n\t"
+        "addss    %%xmm4,  %%xmm7           \n\t"
+        "movl         %0, 112(%1)           \n\t"
+        "movss    %%xmm0,  28(%1)           \n\t"
+        "movss    36(%1),  %%xmm0           \n\t"
+        "movss    %%xmm7,  36(%1)           \n\t"
+        "addss    %%xmm1,  %%xmm4           \n\t"
+        "movss   116(%1),  %%xmm7           \n\t"
+        "addss    %%xmm2,  %%xmm0           \n\t"
+        "addss   124(%1),  %%xmm7           \n\t"
+        "movss    %%xmm0,  72(%1)           \n\t"
+        "movss    44(%1),  %%xmm0           \n\t"
+        "movss    %%xmm6,  12(%1)           \n\t"
+        "movss    %%xmm3,  20(%1)           \n\t"
+        "addss    %%xmm0,  %%xmm2           \n\t"
+        "movss    %%xmm4,  44(%1)           \n\t"
+        "movss    %%xmm2,  88(%1)           \n\t"
+        "addss    60(%1),  %%xmm0           \n\t"
+        "movl     60(%1),      %0           \n\t"
+        "movl         %0, 120(%1)           \n\t"
+        "movss    %%xmm0, 104(%1)           \n\t"
+        "addss    %%xmm5,  %%xmm1           \n\t"
+        "addss    68(%1),  %%xmm5           \n\t"
+        "movss    %%xmm1,  52(%1)           \n\t"
+        "movss    %%xmm5,  60(%1)           \n\t"
+        "movss    68(%1),  %%xmm1           \n\t"
+        "movss   100(%1),  %%xmm5           \n\t"
+        "addss    %%xmm7,  %%xmm5           \n\t"
+        "addss   108(%1),  %%xmm7           \n\t"
+        "addss    %%xmm5,  %%xmm1           \n\t"
+        "movss    84(%1),  %%xmm2           \n\t"
+        "addss    92(%1),  %%xmm2           \n\t"
+        "addss    %%xmm2,  %%xmm5           \n\t"
+        "movss    %%xmm1,  68(%1)           \n\t"
+        "addss    %%xmm7,  %%xmm2           \n\t"
+        "movss    76(%1),  %%xmm1           \n\t"
+        "movss    %%xmm2,  84(%1)           \n\t"
+        "movss    %%xmm5,  76(%1)           \n\t"
+        "movss   108(%1),  %%xmm2           \n\t"
+        "addss    %%xmm1,  %%xmm7           \n\t"
+        "addss   124(%1),  %%xmm2           \n\t"
+        "addss    %%xmm2,  %%xmm1           \n\t"
+        "addss    92(%1),  %%xmm2           \n\t"
+        "movss    %%xmm1, 100(%1)           \n\t"
+        "movss    %%xmm2, 108(%1)           \n\t"
+        "movss    92(%1),  %%xmm2           \n\t"
+        "movss    %%xmm7,  92(%1)           \n\t"
+        "addss   124(%1),  %%xmm2           \n\t"
+        "movss    %%xmm2, 116(%1)           \n\t"
+        :"+&r"(tmp1)
+        :"r"(out), "r"(b1), "r"(smask), "r"(in)
+        :"memory"
+        );
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/h264_intrapred.asm
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/h264_intrapred.asm	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/h264_intrapred.asm	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,602 @@
+;******************************************************************************
+;* H.264 intra prediction asm optimizations
+;* Copyright (c) 2010 Jason Garrett-Glaser
+;*
+;* This file is part of FFmpeg.
+;*
+;* FFmpeg is free software; you can redistribute it and/or
+;* modify it under the terms of the GNU Lesser General Public
+;* License as published by the Free Software Foundation; either
+;* version 2.1 of the License, or (at your option) any later version.
+;*
+;* FFmpeg is distributed in the hope that it will be useful,
+;* but WITHOUT ANY WARRANTY; without even the implied warranty of
+;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;* Lesser General Public License for more details.
+;*
+;* You should have received a copy of the GNU Lesser General Public
+;* License along with FFmpeg; if not, write to the Free Software
+;* 51, Inc., Foundation Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+;******************************************************************************
+
+%include "x86inc.asm"
+
+SECTION_RODATA
+
+tm_shuf: times 8 db 0x03, 0x80
+
+SECTION .text
+
+cextern pb_1
+cextern pb_3
+
+;-----------------------------------------------------------------------------
+; void pred16x16_vertical(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+cglobal pred16x16_vertical_mmx, 2,3
+    sub   r0, r1
+    mov   r2, 8
+    movq mm0, [r0+0]
+    movq mm1, [r0+8]
+.loop:
+    movq [r0+r1*1+0], mm0
+    movq [r0+r1*1+8], mm1
+    movq [r0+r1*2+0], mm0
+    movq [r0+r1*2+8], mm1
+    lea   r0, [r0+r1*2]
+    dec   r2
+    jg .loop
+    REP_RET
+
+cglobal pred16x16_vertical_sse, 2,3
+    sub   r0, r1
+    mov   r2, 4
+    movaps xmm0, [r0]
+.loop:
+    movaps [r0+r1*1], xmm0
+    movaps [r0+r1*2], xmm0
+    lea   r0, [r0+r1*2]
+    movaps [r0+r1*1], xmm0
+    movaps [r0+r1*2], xmm0
+    lea   r0, [r0+r1*2]
+    dec   r2
+    jg .loop
+    REP_RET
+
+;-----------------------------------------------------------------------------
+; void pred16x16_horizontal(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED16x16_H 1
+cglobal pred16x16_horizontal_%1, 2,3
+    mov       r2, 8
+%ifidn %1, ssse3
+    mova      m2, [pb_3]
+%endif
+.loop:
+    movd      m0, [r0+r1*0-4]
+    movd      m1, [r0+r1*1-4]
+
+%ifidn %1, ssse3
+    pshufb    m0, m2
+    pshufb    m1, m2
+%else
+    punpcklbw m0, m0
+    punpcklbw m1, m1
+%ifidn %1, mmxext
+    pshufw    m0, m0, 0xff
+    pshufw    m1, m1, 0xff
+%else
+    punpckhwd m0, m0
+    punpckhwd m1, m1
+    punpckhdq m0, m0
+    punpckhdq m1, m1
+%endif
+    mova [r0+r1*0+8], m0
+    mova [r0+r1*1+8], m1
+%endif
+
+    mova [r0+r1*0], m0
+    mova [r0+r1*1], m1
+    lea       r0, [r0+r1*2]
+    dec       r2
+    jg .loop
+    REP_RET
+%endmacro
+
+INIT_MMX
+PRED16x16_H mmx
+PRED16x16_H mmxext
+INIT_XMM
+PRED16x16_H ssse3
+
+;-----------------------------------------------------------------------------
+; void pred16x16_dc(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED16x16_DC 1
+cglobal pred16x16_dc_%1, 2,7
+    mov       r4, r0
+    sub       r0, r1
+    pxor      mm0, mm0
+    pxor      mm1, mm1
+    psadbw    mm0, [r0+0]
+    psadbw    mm1, [r0+8]
+    dec        r0
+    movzx     r5d, byte [r0+r1*1]
+    paddw     mm0, mm1
+    movd      r6d, mm0
+    lea        r0, [r0+r1*2]
+%rep 7
+    movzx     r2d, byte [r0+r1*0]
+    movzx     r3d, byte [r0+r1*1]
+    add       r5d, r2d
+    add       r6d, r3d
+    lea        r0, [r0+r1*2]
+%endrep
+    movzx     r2d, byte [r0+r1*0]
+    add       r5d, r6d
+    lea       r2d, [r2+r5+16]
+    shr       r2d, 5
+%ifidn %1, mmxext
+    movd       m0, r2d
+    punpcklbw  m0, m0
+    pshufw     m0, m0, 0
+%elifidn %1, sse2
+    movd       m0, r2d
+    punpcklbw  m0, m0
+    pshuflw    m0, m0, 0
+    punpcklqdq m0, m0
+%elifidn %1, ssse3
+    pxor       m1, m1
+    movd       m0, r2d
+    pshufb     m0, m1
+%endif
+
+%if mmsize==8
+    mov       r3d, 8
+.loop:
+    mova [r4+r1*0+0], m0
+    mova [r4+r1*0+8], m0
+    mova [r4+r1*1+0], m0
+    mova [r4+r1*1+8], m0
+%else
+    mov       r3d, 4
+.loop:
+    mova [r4+r1*0], m0
+    mova [r4+r1*1], m0
+    lea   r4, [r4+r1*2]
+    mova [r4+r1*0], m0
+    mova [r4+r1*1], m0
+%endif
+    lea   r4, [r4+r1*2]
+    dec   r3d
+    jg .loop
+    REP_RET
+%endmacro
+
+INIT_MMX
+PRED16x16_DC mmxext
+INIT_XMM
+PRED16x16_DC   sse2
+PRED16x16_DC  ssse3
+
+;-----------------------------------------------------------------------------
+; void pred16x16_tm_vp8(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED16x16_TM_MMX 1
+cglobal pred16x16_tm_vp8_%1, 2,5
+    sub        r0, r1
+    pxor      mm7, mm7
+    movq      mm0, [r0+0]
+    movq      mm2, [r0+8]
+    movq      mm1, mm0
+    movq      mm3, mm2
+    punpcklbw mm0, mm7
+    punpckhbw mm1, mm7
+    punpcklbw mm2, mm7
+    punpckhbw mm3, mm7
+    movzx     r3d, byte [r0-1]
+    mov       r4d, 16
+.loop:
+    movzx     r2d, byte [r0+r1-1]
+    sub       r2d, r3d
+    movd      mm4, r2d
+%ifidn %1, mmx
+    punpcklwd mm4, mm4
+    punpckldq mm4, mm4
+%else
+    pshufw    mm4, mm4, 0
+%endif
+    movq      mm5, mm4
+    movq      mm6, mm4
+    movq      mm7, mm4
+    paddw     mm4, mm0
+    paddw     mm5, mm1
+    paddw     mm6, mm2
+    paddw     mm7, mm3
+    packuswb  mm4, mm5
+    packuswb  mm6, mm7
+    movq [r0+r1+0], mm4
+    movq [r0+r1+8], mm6
+    add        r0, r1
+    dec       r4d
+    jg .loop
+    REP_RET
+%endmacro
+
+PRED16x16_TM_MMX mmx
+PRED16x16_TM_MMX mmxext
+
+cglobal pred16x16_tm_vp8_sse2, 2,6,6
+    sub          r0, r1
+    pxor       xmm2, xmm2
+    movdqa     xmm0, [r0]
+    movdqa     xmm1, xmm0
+    punpcklbw  xmm0, xmm2
+    punpckhbw  xmm1, xmm2
+    movzx       r4d, byte [r0-1]
+    mov         r5d, 8
+.loop:
+    movzx       r2d, byte [r0+r1*1-1]
+    movzx       r3d, byte [r0+r1*2-1]
+    sub         r2d, r4d
+    sub         r3d, r4d
+    movd       xmm2, r2d
+    movd       xmm4, r3d
+    pshuflw    xmm2, xmm2, 0
+    pshuflw    xmm4, xmm4, 0
+    punpcklqdq xmm2, xmm2
+    punpcklqdq xmm4, xmm4
+    movdqa     xmm3, xmm2
+    movdqa     xmm5, xmm4
+    paddw      xmm2, xmm0
+    paddw      xmm3, xmm1
+    paddw      xmm4, xmm0
+    paddw      xmm5, xmm1
+    packuswb   xmm2, xmm3
+    packuswb   xmm4, xmm5
+    movdqa [r0+r1*1], xmm2
+    movdqa [r0+r1*2], xmm4
+    lea          r0, [r0+r1*2]
+    dec         r5d
+    jg .loop
+    REP_RET
+
+;-----------------------------------------------------------------------------
+; void pred8x8_vertical(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+cglobal pred8x8_vertical_mmx, 2,2
+    sub    r0, r1
+    movq  mm0, [r0]
+%rep 3
+    movq [r0+r1*1], mm0
+    movq [r0+r1*2], mm0
+    lea    r0, [r0+r1*2]
+%endrep
+    movq [r0+r1*1], mm0
+    movq [r0+r1*2], mm0
+    RET
+
+;-----------------------------------------------------------------------------
+; void pred8x8_horizontal(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED8x8_H 1
+cglobal pred8x8_horizontal_%1, 2,3
+    mov       r2, 4
+%ifidn %1, ssse3
+    mova      m2, [pb_3]
+%endif
+.loop:
+    movd      m0, [r0+r1*0-4]
+    movd      m1, [r0+r1*1-4]
+%ifidn %1, ssse3
+    pshufb    m0, m2
+    pshufb    m1, m2
+%else
+    punpcklbw m0, m0
+    punpcklbw m1, m1
+%ifidn %1, mmxext
+    pshufw    m0, m0, 0xff
+    pshufw    m1, m1, 0xff
+%else
+    punpckhwd m0, m0
+    punpckhwd m1, m1
+    punpckhdq m0, m0
+    punpckhdq m1, m1
+%endif
+%endif
+    mova [r0+r1*0], m0
+    mova [r0+r1*1], m1
+    lea       r0, [r0+r1*2]
+    dec       r2
+    jg .loop
+    REP_RET
+%endmacro
+
+INIT_MMX
+PRED8x8_H mmx
+PRED8x8_H mmxext
+PRED8x8_H ssse3
+
+;-----------------------------------------------------------------------------
+; void pred8x8_dc_rv40(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+cglobal pred8x8_dc_rv40_mmxext, 2,7
+    mov       r4, r0
+    sub       r0, r1
+    pxor      mm0, mm0
+    psadbw    mm0, [r0]
+    dec        r0
+    movzx     r5d, byte [r0+r1*1]
+    movd      r6d, mm0
+    lea        r0, [r0+r1*2]
+%rep 3
+    movzx     r2d, byte [r0+r1*0]
+    movzx     r3d, byte [r0+r1*1]
+    add       r5d, r2d
+    add       r6d, r3d
+    lea        r0, [r0+r1*2]
+%endrep
+    movzx     r2d, byte [r0+r1*0]
+    add       r5d, r6d
+    lea       r2d, [r2+r5+8]
+    shr       r2d, 4
+    movd      mm0, r2d
+    punpcklbw mm0, mm0
+    pshufw    mm0, mm0, 0
+    mov       r3d, 4
+.loop:
+    movq [r4+r1*0], mm0
+    movq [r4+r1*1], mm0
+    lea   r4, [r4+r1*2]
+    dec   r3d
+    jg .loop
+    REP_RET
+
+;-----------------------------------------------------------------------------
+; void pred8x8_tm_vp8(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED8x8_TM_MMX 1
+cglobal pred8x8_tm_vp8_%1, 2,6
+    sub        r0, r1
+    pxor      mm7, mm7
+    movq      mm0, [r0]
+    movq      mm1, mm0
+    punpcklbw mm0, mm7
+    punpckhbw mm1, mm7
+    movzx     r4d, byte [r0-1]
+    mov       r5d, 4
+.loop:
+    movzx     r2d, byte [r0+r1*1-1]
+    movzx     r3d, byte [r0+r1*2-1]
+    sub       r2d, r4d
+    sub       r3d, r4d
+    movd      mm2, r2d
+    movd      mm4, r3d
+%ifidn %1, mmx
+    punpcklwd mm2, mm2
+    punpcklwd mm4, mm4
+    punpckldq mm2, mm2
+    punpckldq mm4, mm4
+%else
+    pshufw    mm2, mm2, 0
+    pshufw    mm4, mm4, 0
+%endif
+    movq      mm3, mm2
+    movq      mm5, mm4
+    paddw     mm2, mm0
+    paddw     mm3, mm1
+    paddw     mm4, mm0
+    paddw     mm5, mm1
+    packuswb  mm2, mm3
+    packuswb  mm4, mm5
+    movq [r0+r1*1], mm2
+    movq [r0+r1*2], mm4
+    lea        r0, [r0+r1*2]
+    dec       r5d
+    jg .loop
+    REP_RET
+%endmacro
+
+PRED8x8_TM_MMX mmx
+PRED8x8_TM_MMX mmxext
+
+cglobal pred8x8_tm_vp8_sse2, 2,6,4
+    sub          r0, r1
+    pxor       xmm1, xmm1
+    movq       xmm0, [r0]
+    punpcklbw  xmm0, xmm1
+    movzx       r4d, byte [r0-1]
+    mov         r5d, 4
+.loop:
+    movzx       r2d, byte [r0+r1*1-1]
+    movzx       r3d, byte [r0+r1*2-1]
+    sub         r2d, r4d
+    sub         r3d, r4d
+    movd       xmm2, r2d
+    movd       xmm3, r3d
+    pshuflw    xmm2, xmm2, 0
+    pshuflw    xmm3, xmm3, 0
+    punpcklqdq xmm2, xmm2
+    punpcklqdq xmm3, xmm3
+    paddw      xmm2, xmm0
+    paddw      xmm3, xmm0
+    packuswb   xmm2, xmm3
+    movq   [r0+r1*1], xmm2
+    movhps [r0+r1*2], xmm2
+    lea          r0, [r0+r1*2]
+    dec         r5d
+    jg .loop
+    REP_RET
+
+cglobal pred8x8_tm_vp8_ssse3, 2,3,6
+    sub          r0, r1
+    movdqa     xmm4, [tm_shuf]
+    pxor       xmm1, xmm1
+    movq       xmm0, [r0]
+    punpcklbw  xmm0, xmm1
+    movd       xmm5, [r0-4]
+    pshufb     xmm5, xmm4
+    mov         r2d, 4
+.loop:
+    movd       xmm2, [r0+r1*1-4]
+    movd       xmm3, [r0+r1*2-4]
+    pshufb     xmm2, xmm4
+    pshufb     xmm3, xmm4
+    psubw      xmm2, xmm5
+    psubw      xmm3, xmm5
+    paddw      xmm2, xmm0
+    paddw      xmm3, xmm0
+    packuswb   xmm2, xmm3
+    movq   [r0+r1*1], xmm2
+    movhps [r0+r1*2], xmm2
+    lea          r0, [r0+r1*2]
+    dec         r2d
+    jg .loop
+    REP_RET
+
+;-----------------------------------------------------------------------------
+; void pred4x4_dc_mmxext(uint8_t *src, const uint8_t *topright, int stride)
+;-----------------------------------------------------------------------------
+
+cglobal pred4x4_dc_mmxext, 3,5
+    pxor   mm7, mm7
+    mov     r4, r0
+    sub     r0, r2
+    movd   mm0, [r0]
+    psadbw mm0, mm7
+    movzx  r1d, byte [r0+r2*1-1]
+    movd   r3d, mm0
+    add    r3d, r1d
+    movzx  r1d, byte [r0+r2*2-1]
+    lea     r0, [r0+r2*2]
+    add    r3d, r1d
+    movzx  r1d, byte [r0+r2*1-1]
+    add    r3d, r1d
+    movzx  r1d, byte [r0+r2*2-1]
+    add    r3d, r1d
+    add    r3d, 4
+    shr    r3d, 3
+    imul   r3d, 0x01010101
+    mov   [r4+r2*0], r3d
+    mov   [r0+r2*0], r3d
+    mov   [r0+r2*1], r3d
+    mov   [r0+r2*2], r3d
+    RET
+
+;-----------------------------------------------------------------------------
+; void pred4x4_tm_vp8_mmxext(uint8_t *src, const uint8_t *topright, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED4x4_TM_MMX 1
+cglobal pred4x4_tm_vp8_%1, 3,6
+    sub        r0, r2
+    pxor      mm7, mm7
+    movd      mm0, [r0]
+    punpcklbw mm0, mm7
+    movzx     r4d, byte [r0-1]
+    mov       r5d, 2
+.loop:
+    movzx     r1d, byte [r0+r2*1-1]
+    movzx     r3d, byte [r0+r2*2-1]
+    sub       r1d, r4d
+    sub       r3d, r4d
+    movd      mm2, r1d
+    movd      mm4, r3d
+%ifidn %1, mmx
+    punpcklwd mm2, mm2
+    punpcklwd mm4, mm4
+    punpckldq mm2, mm2
+    punpckldq mm4, mm4
+%else
+    pshufw    mm2, mm2, 0
+    pshufw    mm4, mm4, 0
+%endif
+    paddw     mm2, mm0
+    paddw     mm4, mm0
+    packuswb  mm2, mm2
+    packuswb  mm4, mm4
+    movd [r0+r2*1], mm2
+    movd [r0+r2*2], mm4
+    lea        r0, [r0+r2*2]
+    dec       r5d
+    jg .loop
+    REP_RET
+%endmacro
+
+PRED4x4_TM_MMX mmx
+PRED4x4_TM_MMX mmxext
+
+cglobal pred4x4_tm_vp8_ssse3, 3,3
+    sub         r0, r2
+    movq       mm6, [tm_shuf]
+    pxor       mm1, mm1
+    movd       mm0, [r0]
+    punpcklbw  mm0, mm1
+    movd       mm7, [r0-4]
+    pshufb     mm7, mm6
+    lea         r1, [r0+r2*2]
+    movd       mm2, [r0+r2*1-4]
+    movd       mm3, [r0+r2*2-4]
+    movd       mm4, [r1+r2*1-4]
+    movd       mm5, [r1+r2*2-4]
+    pshufb     mm2, mm6
+    pshufb     mm3, mm6
+    pshufb     mm4, mm6
+    pshufb     mm5, mm6
+    psubw      mm2, mm7
+    psubw      mm3, mm7
+    psubw      mm4, mm7
+    psubw      mm5, mm7
+    paddw      mm2, mm0
+    paddw      mm3, mm0
+    paddw      mm4, mm0
+    paddw      mm5, mm0
+    packuswb   mm2, mm2
+    packuswb   mm3, mm3
+    packuswb   mm4, mm4
+    packuswb   mm5, mm5
+    movd [r0+r2*1], mm2
+    movd [r0+r2*2], mm3
+    movd [r1+r2*1], mm4
+    movd [r1+r2*2], mm5
+    RET
+
+; dest, left, right, src, tmp
+; output: %1 = (t[n-1] + t[n]*2 + t[n+1] + 2) >> 2
+%macro PRED4x4_LOWPASS 5
+    mova    %5, %2
+    pavgb   %2, %3
+    pxor    %3, %5
+    mova    %1, %4
+    pand    %3, [pb_1]
+    psubusb %2, %3
+    pavgb   %1, %2
+%endmacro
+
+;-----------------------------------------------------------------------------
+; void pred4x4_vertical_vp8_mmxext(uint8_t *src, const uint8_t *topright, int stride)
+;-----------------------------------------------------------------------------
+
+INIT_MMX
+cglobal pred4x4_vertical_vp8_mmxext, 3,3
+    sub       r0, r2
+    movd      m1, [r0-1]
+    movd      m0, [r0]
+    mova      m2, m0   ;t0 t1 t2 t3
+    punpckldq m0, [r1] ;t0 t1 t2 t3 t4 t5 t6 t7
+    lea       r1, [r0+r2*2]
+    psrlq     m0, 8    ;t1 t2 t3 t4
+    PRED4x4_LOWPASS m3, m1, m0, m2, m4
+    movd [r0+r2*1], m3
+    movd [r0+r2*2], m3
+    movd [r1+r2*1], m3
+    movd [r1+r2*2], m3
+    RET

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mpegaudiodec_mmx.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mpegaudiodec_mmx.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mpegaudiodec_mmx.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,157 @@
+/*
+ * MMX optimized MP3 decoding functions
+ * Copyright (c) 2010 Vitor Sessak
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/x86_cpu.h"
+
+#define CONFIG_FLOAT 1
+#include "libavcodec/mpegaudio.h"
+
+#define MACS(rt, ra, rb) rt+=(ra)*(rb)
+#define MLSS(rt, ra, rb) rt-=(ra)*(rb)
+
+#define SUM8(op, sum, w, p)               \
+{                                         \
+    op(sum, (w)[0 * 64], (p)[0 * 64]);    \
+    op(sum, (w)[1 * 64], (p)[1 * 64]);    \
+    op(sum, (w)[2 * 64], (p)[2 * 64]);    \
+    op(sum, (w)[3 * 64], (p)[3 * 64]);    \
+    op(sum, (w)[4 * 64], (p)[4 * 64]);    \
+    op(sum, (w)[5 * 64], (p)[5 * 64]);    \
+    op(sum, (w)[6 * 64], (p)[6 * 64]);    \
+    op(sum, (w)[7 * 64], (p)[7 * 64]);    \
+}
+
+static void apply_window(const float *buf, const float *win1,
+                         const float *win2, float *sum1, float *sum2, int len)
+{
+    x86_reg count = - 4*len;
+    const float *win1a = win1+len;
+    const float *win2a = win2+len;
+    const float *bufa  = buf+len;
+    float *sum1a = sum1+len;
+    float *sum2a = sum2+len;
+
+
+#define MULT(a, b)                                 \
+    "movaps " #a "(%1,%0), %%xmm1           \n\t"  \
+    "movaps " #a "(%3,%0), %%xmm2           \n\t"  \
+    "mulps         %%xmm2, %%xmm1           \n\t"  \
+    "subps         %%xmm1, %%xmm0           \n\t"  \
+    "mulps  " #b "(%2,%0), %%xmm2           \n\t"  \
+    "subps         %%xmm2, %%xmm4           \n\t"  \
+
+    __asm__ volatile(
+            "1:                                   \n\t"
+            "xorps       %%xmm0, %%xmm0           \n\t"
+            "xorps       %%xmm4, %%xmm4           \n\t"
+
+            MULT(   0,   0)
+            MULT( 256,  64)
+            MULT( 512, 128)
+            MULT( 768, 192)
+            MULT(1024, 256)
+            MULT(1280, 320)
+            MULT(1536, 384)
+            MULT(1792, 448)
+
+            "movaps      %%xmm0, (%4,%0)          \n\t"
+            "movaps      %%xmm4, (%5,%0)          \n\t"
+            "add            $16,  %0              \n\t"
+            "jl              1b                   \n\t"
+            :"+&r"(count)
+            :"r"(win1a), "r"(win2a), "r"(bufa), "r"(sum1a), "r"(sum2a)
+            );
+
+#undef MULT
+}
+
+static void apply_window_mp3(float *in, float *win, int *unused, float *out,
+                             int incr)
+{
+    LOCAL_ALIGNED_16(float, suma, [17]);
+    LOCAL_ALIGNED_16(float, sumb, [17]);
+    LOCAL_ALIGNED_16(float, sumc, [17]);
+    LOCAL_ALIGNED_16(float, sumd, [17]);
+
+    float sum;
+
+    /* copy to avoid wrap */
+    memcpy(in + 512, in, 32 * sizeof(*in));
+
+    apply_window(in + 16, win     , win + 512, suma, sumc, 16);
+    apply_window(in + 32, win + 48, win + 640, sumb, sumd, 16);
+
+    SUM8(MACS, suma[0], win + 32, in + 48);
+
+    sumc[ 0] = 0;
+    sumb[16] = 0;
+    sumd[16] = 0;
+
+#define SUMS(suma, sumb, sumc, sumd, out1, out2)               \
+            "movups " #sumd "(%4),       %%xmm0          \n\t" \
+            "shufps         $0x1b,       %%xmm0, %%xmm0  \n\t" \
+            "subps  " #suma "(%1),       %%xmm0          \n\t" \
+            "movaps        %%xmm0," #out1 "(%0)          \n\t" \
+\
+            "movups " #sumc "(%3),       %%xmm0          \n\t" \
+            "shufps         $0x1b,       %%xmm0, %%xmm0  \n\t" \
+            "addps  " #sumb "(%2),       %%xmm0          \n\t" \
+            "movaps        %%xmm0," #out2 "(%0)          \n\t"
+
+    if (incr == 1) {
+        __asm__ volatile(
+            SUMS( 0, 48,  4, 52,  0, 112)
+            SUMS(16, 32, 20, 36, 16,  96)
+            SUMS(32, 16, 36, 20, 32,  80)
+            SUMS(48,  0, 52,  4, 48,  64)
+
+            :"+&r"(out)
+            :"r"(&suma[0]), "r"(&sumb[0]), "r"(&sumc[0]), "r"(&sumd[0])
+            :"memory"
+            );
+        out += 16*incr;
+    } else {
+        int j;
+        float *out2 = out + 32 * incr;
+        out[0  ]  = -suma[   0];
+        out += incr;
+        out2 -= incr;
+        for(j=1;j<16;j++) {
+            *out  = -suma[   j] + sumd[16-j];
+            *out2 =  sumb[16-j] + sumc[   j];
+            out  += incr;
+            out2 -= incr;
+        }
+    }
+
+    sum = 0;
+    SUM8(MLSS, sum, win + 16 + 32, in + 32);
+    *out = sum;
+}
+
+void ff_mpegaudiodec_init_mmx(MPADecodeContext *s)
+{
+    mm_flags = mm_support();
+
+    if (mm_flags & FF_MM_SSE2) {
+        s->apply_window_mp3 = apply_window_mp3;
+    }
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vc1dsp_yasm.asm
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vc1dsp_yasm.asm	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vc1dsp_yasm.asm	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,330 @@
+;******************************************************************************
+;* VC1 deblocking optimizations
+;* Copyright (c) 2009 David Conrad
+;*
+;* This file is part of FFmpeg.
+;*
+;* FFmpeg is free software; you can redistribute it and/or
+;* modify it under the terms of the GNU Lesser General Public
+;* License as published by the Free Software Foundation; either
+;* version 2.1 of the License, or (at your option) any later version.
+;*
+;* FFmpeg is distributed in the hope that it will be useful,
+;* but WITHOUT ANY WARRANTY; without even the implied warranty of
+;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;* Lesser General Public License for more details.
+;*
+;* You should have received a copy of the GNU Lesser General Public
+;* License along with FFmpeg; if not, write to the Free Software
+;* 51, Inc., Foundation Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+;******************************************************************************
+
+%include "x86inc.asm"
+%include "x86util.asm"
+
+cextern pw_4
+cextern pw_5
+
+section .text
+
+; dst_low, dst_high (src), zero
+; zero-extends one vector from 8 to 16 bits
+%macro UNPACK_8TO16 4
+    mova      m%2, m%3
+    punpckh%1 m%3, m%4
+    punpckl%1 m%2, m%4
+%endmacro
+
+%macro STORE_4_WORDS_MMX 6
+    movd   %6, %5
+%if mmsize==16
+    psrldq %5, 4
+%else
+    psrlq  %5, 32
+%endif
+    mov    %1, %6w
+    shr    %6, 16
+    mov    %2, %6w
+    movd   %6, %5
+    mov    %3, %6w
+    shr    %6, 16
+    mov    %4, %6w
+%endmacro
+
+%macro STORE_4_WORDS_SSE4 6
+    pextrw %1, %5, %6+0
+    pextrw %2, %5, %6+1
+    pextrw %3, %5, %6+2
+    pextrw %4, %5, %6+3
+%endmacro
+
+; in:  p1 p0 q0 q1, clobbers p0
+; out: p1 = (2*(p1 - q1) - 5*(p0 - q0) + 4) >> 3
+%macro VC1_LOOP_FILTER_A0 4
+    psubw  %1, %4
+    psubw  %2, %3
+    paddw  %1, %1
+    pmullw %2, [pw_5]
+    psubw  %1, %2
+    paddw  %1, [pw_4]
+    psraw  %1, 3
+%endmacro
+
+; in: p0 q0 a0 a1 a2
+;     m0 m1 m7 m6 m5
+; %1: size
+; out: m0=p0' m1=q0'
+%macro VC1_FILTER 1
+    PABSW   m4, m7
+    PABSW   m3, m6
+    PABSW   m2, m5
+    mova    m6, m4
+    pminsw  m3, m2
+    pcmpgtw m6, m3  ; if (a2 < a0 || a1 < a0)
+    psubw   m3, m4
+    pmullw  m3, [pw_5]   ; 5*(a3 - a0)
+    PABSW   m2, m3
+    psraw   m2, 3   ; abs(d/8)
+    pxor    m7, m3  ; d_sign ^= a0_sign
+
+    pxor    m5, m5
+    movd    m3, r2
+%if %1 > 4
+    punpcklbw m3, m3
+%endif
+    punpcklbw m3, m5
+    pcmpgtw m3, m4  ; if (a0 < pq)
+    pand    m6, m3
+
+    mova    m3, m0
+    psubw   m3, m1
+    PABSW   m4, m3
+    psraw   m4, 1
+    pxor    m3, m7  ; d_sign ^ clip_sign
+    psraw   m3, 15
+    pminsw  m2, m4  ; min(d, clip)
+    pcmpgtw m4, m5
+    pand    m6, m4  ; filt3 (C return value)
+
+; each set of 4 pixels is not filtered if the 3rd is not
+%if mmsize==16
+    pshuflw m4, m6, 0xaa
+%if %1 > 4
+    pshufhw m4, m4, 0xaa
+%endif
+%else
+    pshufw  m4, m6, 0xaa
+%endif
+    pandn   m3, m4
+    pand    m2, m6
+    pand    m3, m2  ; d final
+
+    PSIGNW  m3, m7
+    psubw   m0, m3
+    paddw   m1, m3
+    packuswb m0, m0
+    packuswb m1, m1
+%endmacro
+
+; 1st param: size of filter
+; 2nd param: mov suffix equivalent to the filter size
+%macro VC1_V_LOOP_FILTER 2
+    pxor      m5, m5
+    mov%2     m6, [r4]
+    mov%2     m4, [r4+r1]
+    mov%2     m7, [r4+2*r1]
+    mov%2     m0, [r4+r3]
+    punpcklbw m6, m5
+    punpcklbw m4, m5
+    punpcklbw m7, m5
+    punpcklbw m0, m5
+
+    VC1_LOOP_FILTER_A0 m6, m4, m7, m0
+    mov%2     m1, [r0]
+    mov%2     m2, [r0+r1]
+    punpcklbw m1, m5
+    punpcklbw m2, m5
+    mova      m4, m0
+    VC1_LOOP_FILTER_A0 m7, m4, m1, m2
+    mov%2     m3, [r0+2*r1]
+    mov%2     m4, [r0+r3]
+    punpcklbw m3, m5
+    punpcklbw m4, m5
+    mova      m5, m1
+    VC1_LOOP_FILTER_A0 m5, m2, m3, m4
+
+    VC1_FILTER %1
+    mov%2 [r4+r3], m0
+    mov%2 [r0],    m1
+%endmacro
+
+; 1st param: size of filter
+;     NOTE: UNPACK_8TO16 this number of 8 bit numbers are in half a register
+; 2nd (optional) param: temp register to use for storing words
+%macro VC1_H_LOOP_FILTER 1-2
+%if %1 == 4
+    movq      m0, [r0     -4]
+    movq      m1, [r0+  r1-4]
+    movq      m2, [r0+2*r1-4]
+    movq      m3, [r0+  r3-4]
+    TRANSPOSE4x4B 0, 1, 2, 3, 4
+%else
+    movq      m0, [r0     -4]
+    movq      m4, [r0+  r1-4]
+    movq      m1, [r0+2*r1-4]
+    movq      m5, [r0+  r3-4]
+    movq      m2, [r4     -4]
+    movq      m6, [r4+  r1-4]
+    movq      m3, [r4+2*r1-4]
+    movq      m7, [r4+  r3-4]
+    punpcklbw m0, m4
+    punpcklbw m1, m5
+    punpcklbw m2, m6
+    punpcklbw m3, m7
+    TRANSPOSE4x4W 0, 1, 2, 3, 4
+%endif
+    pxor      m5, m5
+
+    UNPACK_8TO16 bw, 6, 0, 5
+    UNPACK_8TO16 bw, 7, 1, 5
+    VC1_LOOP_FILTER_A0 m6, m0, m7, m1
+    UNPACK_8TO16 bw, 4, 2, 5
+    mova    m0, m1                      ; m0 = p0
+    VC1_LOOP_FILTER_A0 m7, m1, m4, m2
+    UNPACK_8TO16 bw, 1, 3, 5
+    mova    m5, m4
+    VC1_LOOP_FILTER_A0 m5, m2, m1, m3
+    SWAP 1, 4                           ; m1 = q0
+
+    VC1_FILTER %1
+    punpcklbw m0, m1
+%if %0 > 1
+    STORE_4_WORDS_MMX [r0-1], [r0+r1-1], [r0+2*r1-1], [r0+r3-1], m0, %2
+%if %1 > 4
+    psrldq m0, 4
+    STORE_4_WORDS_MMX [r4-1], [r4+r1-1], [r4+2*r1-1], [r4+r3-1], m0, %2
+%endif
+%else
+    STORE_4_WORDS_SSE4 [r0-1], [r0+r1-1], [r0+2*r1-1], [r0+r3-1], m0, 0
+    STORE_4_WORDS_SSE4 [r4-1], [r4+r1-1], [r4+2*r1-1], [r4+r3-1], m0, 4
+%endif
+%endmacro
+
+
+%macro START_V_FILTER 0
+    mov  r4, r0
+    lea  r3, [4*r1]
+    sub  r4, r3
+    lea  r3, [r1+2*r1]
+    imul r2, 0x01010101
+%endmacro
+
+%macro START_H_FILTER 1
+    lea  r3, [r1+2*r1]
+%if %1 > 4
+    lea  r4, [r0+4*r1]
+%endif
+    imul r2, 0x01010101
+%endmacro
+
+; I dont know why the sign extension is needed...
+%macro PSIGNW_SRA_MMX 2
+    psraw %2, 15
+    PSIGNW_MMX %1, %2
+%endmacro
+
+
+%macro VC1_LF_MMX 1
+INIT_MMX
+cglobal vc1_v_loop_filter_internal_%1
+    VC1_V_LOOP_FILTER 4, d
+    ret
+
+cglobal vc1_h_loop_filter_internal_%1
+    VC1_H_LOOP_FILTER 4, r4
+    ret
+
+; void ff_vc1_v_loop_filter4_mmx2(uint8_t *src, int stride, int pq)
+cglobal vc1_v_loop_filter4_%1, 3,5,0
+    START_V_FILTER
+    call vc1_v_loop_filter_internal_%1
+    RET
+
+; void ff_vc1_h_loop_filter4_mmx2(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter4_%1, 3,5,0
+    START_H_FILTER 4
+    call vc1_h_loop_filter_internal_%1
+    RET
+
+; void ff_vc1_v_loop_filter8_mmx2(uint8_t *src, int stride, int pq)
+cglobal vc1_v_loop_filter8_%1, 3,5,0
+    START_V_FILTER
+    call vc1_v_loop_filter_internal_%1
+    add  r4, 4
+    add  r0, 4
+    call vc1_v_loop_filter_internal_%1
+    RET
+
+; void ff_vc1_h_loop_filter8_mmx2(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter8_%1, 3,5,0
+    START_H_FILTER 4
+    call vc1_h_loop_filter_internal_%1
+    lea  r0, [r0+4*r1]
+    call vc1_h_loop_filter_internal_%1
+    RET
+%endmacro
+
+%define PABSW PABSW_MMX
+%define PSIGNW PSIGNW_SRA_MMX
+VC1_LF_MMX mmx
+
+%define PABSW PABSW_MMX2
+VC1_LF_MMX mmx2
+
+INIT_XMM
+; void ff_vc1_v_loop_filter8_sse2(uint8_t *src, int stride, int pq)
+cglobal vc1_v_loop_filter8_sse2, 3,5,8
+    START_V_FILTER
+    VC1_V_LOOP_FILTER 8, q
+    RET
+
+; void ff_vc1_h_loop_filter8_sse2(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter8_sse2, 3,6,8
+    START_H_FILTER 8
+    VC1_H_LOOP_FILTER 8, r5
+    RET
+
+%define PABSW PABSW_SSSE3
+%define PSIGNW PSIGNW_SSSE3
+
+INIT_MMX
+; void ff_vc1_v_loop_filter4_ssse3(uint8_t *src, int stride, int pq)
+cglobal vc1_v_loop_filter4_ssse3, 3,5,0
+    START_V_FILTER
+    VC1_V_LOOP_FILTER 4, d
+    RET
+
+; void ff_vc1_h_loop_filter4_ssse3(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter4_ssse3, 3,5,0
+    START_H_FILTER 4
+    VC1_H_LOOP_FILTER 4, r4
+    RET
+
+INIT_XMM
+; void ff_vc1_v_loop_filter8_ssse3(uint8_t *src, int stride, int pq)
+cglobal vc1_v_loop_filter8_ssse3, 3,5,8
+    START_V_FILTER
+    VC1_V_LOOP_FILTER 8, q
+    RET
+
+; void ff_vc1_h_loop_filter8_ssse3(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter8_ssse3, 3,6,8
+    START_H_FILTER 8
+    VC1_H_LOOP_FILTER 8, r5
+    RET
+
+; void ff_vc1_h_loop_filter8_sse4(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter8_sse4, 3,5,8
+    START_H_FILTER 8
+    VC1_H_LOOP_FILTER 8
+    RET

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp56_arith.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp56_arith.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp56_arith.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,54 @@
+/**
+ * VP5 and VP6 compatible video decoder (arith decoder)
+ *
+ * Copyright (C) 2006  Aurelien Jacobs <aurel at gnuage.org>
+ * Copyright (C) 2010  Eli Friedman
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_X86_VP56_ARITH_H
+#define AVCODEC_X86_VP56_ARITH_H
+
+#if HAVE_FAST_CMOV
+#define vp56_rac_get_prob vp56_rac_get_prob
+static inline int vp56_rac_get_prob(VP56RangeCoder *c, uint8_t prob)
+{
+    unsigned int code_word = vp56_rac_renorm(c);
+    unsigned int high = c->high;
+    unsigned int low = 1 + (((high - 1) * prob) >> 8);
+    unsigned int low_shift = low << 8;
+    int bit = 0;
+
+    __asm__(
+        "subl  %4, %1      \n\t"
+        "subl  %3, %2      \n\t"
+        "leal (%2, %3), %3 \n\t"
+        "setae %b0         \n\t"
+        "cmovb %4, %1      \n\t"
+        "cmovb %3, %2      \n\t"
+        : "+q"(bit), "+r"(high), "+r"(code_word), "+r"(low_shift)
+        : "r"(low)
+    );
+
+    c->high      = high;
+    c->code_word = code_word;
+    return bit;
+}
+#endif
+
+#endif /* AVCODEC_X86_VP56_ARITH_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp-init.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp-init.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp-init.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,397 @@
+/*
+ * VP8 DSP functions x86-optimized
+ * Copyright (c) 2010 Ronald S. Bultje <rsbultje at gmail.com>
+ * Copyright (c) 2010 Jason Garrett-Glaser <darkshikari at gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/x86_cpu.h"
+#include "libavcodec/vp8dsp.h"
+
+#if HAVE_YASM
+
+/*
+ * MC functions
+ */
+extern void ff_put_vp8_epel4_h4_mmxext(uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_h6_mmxext(uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_v4_mmxext(uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_v6_mmxext(uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+
+extern void ff_put_vp8_epel8_h4_sse2  (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_h6_sse2  (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_v4_sse2  (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_v6_sse2  (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+
+extern void ff_put_vp8_epel4_h4_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_h6_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_v4_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_v6_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_h4_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_h6_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_v4_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_v6_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+
+extern void ff_put_vp8_bilinear4_h_mmxext(uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear8_h_sse2  (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear4_h_ssse3 (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear8_h_ssse3 (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+
+extern void ff_put_vp8_bilinear4_v_mmxext(uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear8_v_sse2  (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear4_v_ssse3 (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear8_v_ssse3 (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+
+
+extern void ff_put_vp8_pixels8_mmx (uint8_t *dst, int dststride,
+                                    uint8_t *src, int srcstride,
+                                    int height, int mx, int my);
+extern void ff_put_vp8_pixels16_mmx(uint8_t *dst, int dststride,
+                                    uint8_t *src, int srcstride,
+                                    int height, int mx, int my);
+extern void ff_put_vp8_pixels16_sse(uint8_t *dst, int dststride,
+                                    uint8_t *src, int srcstride,
+                                    int height, int mx, int my);
+
+#define TAP_W16(OPT, FILTERTYPE, TAPTYPE) \
+static void ff_put_vp8_ ## FILTERTYPE ## 16_ ## TAPTYPE ## _ ## OPT( \
+    uint8_t *dst,  int dststride, uint8_t *src, \
+    int srcstride, int height, int mx, int my) \
+{ \
+    ff_put_vp8_ ## FILTERTYPE ## 8_ ## TAPTYPE ## _ ## OPT( \
+        dst,     dststride, src,     srcstride, height, mx, my); \
+    ff_put_vp8_ ## FILTERTYPE ## 8_ ## TAPTYPE ## _ ## OPT( \
+        dst + 8, dststride, src + 8, srcstride, height, mx, my); \
+}
+#define TAP_W8(OPT, FILTERTYPE, TAPTYPE) \
+static void ff_put_vp8_ ## FILTERTYPE ## 8_ ## TAPTYPE ## _ ## OPT( \
+    uint8_t *dst,  int dststride, uint8_t *src, \
+    int srcstride, int height, int mx, int my) \
+{ \
+    ff_put_vp8_ ## FILTERTYPE ## 4_ ## TAPTYPE ## _ ## OPT( \
+        dst,     dststride, src,     srcstride, height, mx, my); \
+    ff_put_vp8_ ## FILTERTYPE ## 4_ ## TAPTYPE ## _ ## OPT( \
+        dst + 4, dststride, src + 4, srcstride, height, mx, my); \
+}
+
+TAP_W8 (mmxext, epel, h4)
+TAP_W8 (mmxext, epel, h6)
+TAP_W16(mmxext, epel, h6)
+TAP_W8 (mmxext, epel, v4)
+TAP_W8 (mmxext, epel, v6)
+TAP_W16(mmxext, epel, v6)
+TAP_W8 (mmxext, bilinear, h)
+TAP_W16(mmxext, bilinear, h)
+TAP_W8 (mmxext, bilinear, v)
+TAP_W16(mmxext, bilinear, v)
+
+TAP_W16(sse2,   epel, h6)
+TAP_W16(sse2,   epel, v6)
+TAP_W16(sse2,   bilinear, h)
+TAP_W16(sse2,   bilinear, v)
+
+TAP_W16(ssse3,  epel, h6)
+TAP_W16(ssse3,  epel, v6)
+TAP_W16(ssse3,  bilinear, h)
+TAP_W16(ssse3,  bilinear, v)
+
+#define HVTAP(OPT, ALIGN, TAPNUMX, TAPNUMY, SIZE, MAXHEIGHT) \
+static void ff_put_vp8_epel ## SIZE ## _h ## TAPNUMX ## v ## TAPNUMY ## _ ## OPT( \
+    uint8_t *dst, int dststride, uint8_t *src, \
+    int srcstride, int height, int mx, int my) \
+{ \
+    DECLARE_ALIGNED(ALIGN, uint8_t, tmp)[SIZE * (MAXHEIGHT + TAPNUMY - 1)]; \
+    uint8_t *tmpptr = tmp + SIZE * (TAPNUMY / 2 - 1); \
+    src -= srcstride * (TAPNUMY / 2 - 1); \
+    ff_put_vp8_epel ## SIZE ## _h ## TAPNUMX ## _ ## OPT( \
+        tmp, SIZE,      src,    srcstride, height + TAPNUMY - 1, mx, my); \
+    ff_put_vp8_epel ## SIZE ## _v ## TAPNUMY ## _ ## OPT( \
+        dst, dststride, tmpptr, SIZE,      height,               mx, my); \
+}
+
+#define HVTAPMMX(x, y) \
+HVTAP(mmxext, 8, x, y,  4,  8) \
+HVTAP(mmxext, 8, x, y,  8, 16)
+
+HVTAPMMX(4, 4)
+HVTAPMMX(4, 6)
+HVTAPMMX(6, 4)
+HVTAPMMX(6, 6)
+HVTAP(mmxext, 8, 6, 6, 16, 16)
+
+#define HVTAPSSE2(x, y, w) \
+HVTAP(sse2,  16, x, y, w, 16) \
+HVTAP(ssse3, 16, x, y, w, 16)
+
+HVTAPSSE2(4, 4, 8)
+HVTAPSSE2(4, 6, 8)
+HVTAPSSE2(6, 4, 8)
+HVTAPSSE2(6, 6, 8)
+HVTAPSSE2(6, 6, 16)
+
+HVTAP(ssse3, 16, 4, 4, 4, 8)
+HVTAP(ssse3, 16, 4, 6, 4, 8)
+HVTAP(ssse3, 16, 6, 4, 4, 8)
+HVTAP(ssse3, 16, 6, 6, 4, 8)
+
+#define HVBILIN(OPT, ALIGN, SIZE, MAXHEIGHT) \
+static void ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT( \
+    uint8_t *dst, int dststride, uint8_t *src, \
+    int srcstride, int height, int mx, int my) \
+{ \
+    DECLARE_ALIGNED(ALIGN, uint8_t, tmp)[SIZE * (MAXHEIGHT + 2)]; \
+    ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT( \
+        tmp, SIZE,      src, srcstride, height + 1, mx, my); \
+    ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT( \
+        dst, dststride, tmp, SIZE,      height,     mx, my); \
+}
+
+HVBILIN(mmxext, 8,  4,  8)
+HVBILIN(mmxext, 8,  8, 16)
+HVBILIN(mmxext, 8, 16, 16)
+HVBILIN(sse2,   8,  8, 16)
+HVBILIN(sse2,   8, 16, 16)
+HVBILIN(ssse3,  8,  4,  8)
+HVBILIN(ssse3,  8,  8, 16)
+HVBILIN(ssse3,  8, 16, 16)
+
+extern void ff_vp8_idct_dc_add_mmx(uint8_t *dst, DCTELEM block[16], int stride);
+extern void ff_vp8_idct_dc_add_sse4(uint8_t *dst, DCTELEM block[16], int stride);
+extern void ff_vp8_idct_dc_add4y_mmx(uint8_t *dst, DCTELEM block[4][16], int stride);
+extern void ff_vp8_idct_dc_add4y_sse2(uint8_t *dst, DCTELEM block[4][16], int stride);
+extern void ff_vp8_idct_dc_add4uv_mmx(uint8_t *dst, DCTELEM block[2][16], int stride);
+extern void ff_vp8_luma_dc_wht_mmx(DCTELEM block[4][4][16], DCTELEM dc[16]);
+extern void ff_vp8_idct_add_mmx(uint8_t *dst, DCTELEM block[16], int stride);
+extern void ff_vp8_idct_add_sse(uint8_t *dst, DCTELEM block[16], int stride);
+
+#define DECLARE_LOOP_FILTER(NAME)\
+extern void ff_vp8_v_loop_filter_simple_ ## NAME(uint8_t *dst, int stride, int flim);\
+extern void ff_vp8_h_loop_filter_simple_ ## NAME(uint8_t *dst, int stride, int flim);\
+extern void ff_vp8_v_loop_filter16y_inner_ ## NAME (uint8_t *dst, int stride,\
+                                                    int e, int i, int hvt);\
+extern void ff_vp8_h_loop_filter16y_inner_ ## NAME (uint8_t *dst, int stride,\
+                                                    int e, int i, int hvt);\
+extern void ff_vp8_v_loop_filter8uv_inner_ ## NAME (uint8_t *dstU, uint8_t *dstV,\
+                                                    int s, int e, int i, int hvt);\
+extern void ff_vp8_h_loop_filter8uv_inner_ ## NAME (uint8_t *dstU, uint8_t *dstV,\
+                                                    int s, int e, int i, int hvt);\
+extern void ff_vp8_v_loop_filter16y_mbedge_ ## NAME(uint8_t *dst, int stride,\
+                                                    int e, int i, int hvt);\
+extern void ff_vp8_h_loop_filter16y_mbedge_ ## NAME(uint8_t *dst, int stride,\
+                                                    int e, int i, int hvt);\
+extern void ff_vp8_v_loop_filter8uv_mbedge_ ## NAME(uint8_t *dstU, uint8_t *dstV,\
+                                                    int s, int e, int i, int hvt);\
+extern void ff_vp8_h_loop_filter8uv_mbedge_ ## NAME(uint8_t *dstU, uint8_t *dstV,\
+                                                    int s, int e, int i, int hvt);
+
+DECLARE_LOOP_FILTER(mmx)
+DECLARE_LOOP_FILTER(mmxext)
+DECLARE_LOOP_FILTER(sse2)
+DECLARE_LOOP_FILTER(ssse3)
+DECLARE_LOOP_FILTER(sse4)
+
+#endif
+
+#define VP8_LUMA_MC_FUNC(IDX, SIZE, OPT) \
+    c->put_vp8_epel_pixels_tab[IDX][0][2] = ff_put_vp8_epel ## SIZE ## _h6_ ## OPT; \
+    c->put_vp8_epel_pixels_tab[IDX][2][0] = ff_put_vp8_epel ## SIZE ## _v6_ ## OPT; \
+    c->put_vp8_epel_pixels_tab[IDX][2][2] = ff_put_vp8_epel ## SIZE ## _h6v6_ ## OPT
+
+#define VP8_MC_FUNC(IDX, SIZE, OPT) \
+    c->put_vp8_epel_pixels_tab[IDX][0][1] = ff_put_vp8_epel ## SIZE ## _h4_ ## OPT; \
+    c->put_vp8_epel_pixels_tab[IDX][1][0] = ff_put_vp8_epel ## SIZE ## _v4_ ## OPT; \
+    c->put_vp8_epel_pixels_tab[IDX][1][1] = ff_put_vp8_epel ## SIZE ## _h4v4_ ## OPT; \
+    c->put_vp8_epel_pixels_tab[IDX][1][2] = ff_put_vp8_epel ## SIZE ## _h6v4_ ## OPT; \
+    c->put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \
+    VP8_LUMA_MC_FUNC(IDX, SIZE, OPT)
+
+#define VP8_BILINEAR_MC_FUNC(IDX, SIZE, OPT) \
+    c->put_vp8_bilinear_pixels_tab[IDX][0][1] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \
+    c->put_vp8_bilinear_pixels_tab[IDX][0][2] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \
+    c->put_vp8_bilinear_pixels_tab[IDX][1][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \
+    c->put_vp8_bilinear_pixels_tab[IDX][1][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \
+    c->put_vp8_bilinear_pixels_tab[IDX][1][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \
+    c->put_vp8_bilinear_pixels_tab[IDX][2][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \
+    c->put_vp8_bilinear_pixels_tab[IDX][2][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \
+    c->put_vp8_bilinear_pixels_tab[IDX][2][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT
+
+
+av_cold void ff_vp8dsp_init_x86(VP8DSPContext* c)
+{
+    mm_flags = mm_support();
+
+#if HAVE_YASM
+    if (mm_flags & FF_MM_MMX) {
+        c->vp8_idct_dc_add    = ff_vp8_idct_dc_add_mmx;
+        c->vp8_idct_dc_add4y  = ff_vp8_idct_dc_add4y_mmx;
+        c->vp8_idct_dc_add4uv = ff_vp8_idct_dc_add4uv_mmx;
+        c->vp8_idct_add       = ff_vp8_idct_add_mmx;
+        c->vp8_luma_dc_wht    = ff_vp8_luma_dc_wht_mmx;
+        c->put_vp8_epel_pixels_tab[0][0][0]     =
+        c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_mmx;
+        c->put_vp8_epel_pixels_tab[1][0][0]     =
+        c->put_vp8_bilinear_pixels_tab[1][0][0] = ff_put_vp8_pixels8_mmx;
+
+        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_mmx;
+        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_mmx;
+
+        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmx;
+        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmx;
+        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmx;
+        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmx;
+
+        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmx;
+        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmx;
+        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmx;
+        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmx;
+    }
+
+    /* note that 4-tap width=16 functions are missing because w=16
+     * is only used for luma, and luma is always a copy or sixtap. */
+    if (mm_flags & FF_MM_MMX2) {
+        VP8_LUMA_MC_FUNC(0, 16, mmxext);
+        VP8_MC_FUNC(1, 8, mmxext);
+        VP8_MC_FUNC(2, 4, mmxext);
+        VP8_BILINEAR_MC_FUNC(0, 16, mmxext);
+        VP8_BILINEAR_MC_FUNC(1, 8, mmxext);
+        VP8_BILINEAR_MC_FUNC(2, 4, mmxext);
+
+        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_mmxext;
+        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_mmxext;
+
+        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmxext;
+        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmxext;
+        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmxext;
+        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmxext;
+
+        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmxext;
+        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmxext;
+        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmxext;
+        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmxext;
+    }
+
+    if (mm_flags & FF_MM_SSE) {
+        c->vp8_idct_add                         = ff_vp8_idct_add_sse;
+        c->put_vp8_epel_pixels_tab[0][0][0]     =
+        c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_sse;
+    }
+
+    if (mm_flags & (FF_MM_SSE2|FF_MM_SSE2SLOW)) {
+        VP8_LUMA_MC_FUNC(0, 16, sse2);
+        VP8_MC_FUNC(1, 8, sse2);
+        VP8_BILINEAR_MC_FUNC(0, 16, sse2);
+        VP8_BILINEAR_MC_FUNC(1, 8, sse2);
+
+        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_sse2;
+        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_sse2;
+
+        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_sse2;
+        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_sse2;
+
+        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_sse2;
+        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_sse2;
+    }
+
+    if (mm_flags & FF_MM_SSE2) {
+        c->vp8_idct_dc_add4y          = ff_vp8_idct_dc_add4y_sse2;
+
+        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_sse2;
+        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_sse2;
+
+        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse2;
+        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse2;
+    }
+
+    if (mm_flags & FF_MM_SSSE3) {
+        VP8_LUMA_MC_FUNC(0, 16, ssse3);
+        VP8_MC_FUNC(1, 8, ssse3);
+        VP8_MC_FUNC(2, 4, ssse3);
+        VP8_BILINEAR_MC_FUNC(0, 16, ssse3);
+        VP8_BILINEAR_MC_FUNC(1, 8, ssse3);
+        VP8_BILINEAR_MC_FUNC(2, 4, ssse3);
+
+        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_ssse3;
+        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_ssse3;
+
+        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_ssse3;
+        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_ssse3;
+        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_ssse3;
+        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_ssse3;
+
+        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_ssse3;
+        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_ssse3;
+        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_ssse3;
+        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_ssse3;
+    }
+
+    if (mm_flags & FF_MM_SSE4) {
+        c->vp8_idct_dc_add                  = ff_vp8_idct_dc_add_sse4;
+
+        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse4;
+        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse4;
+    }
+#endif
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp.asm
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp.asm	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp.asm	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,2752 @@
+;******************************************************************************
+;* VP8 MMXEXT optimizations
+;* Copyright (c) 2010 Ronald S. Bultje <rsbultje at gmail.com>
+;* Copyright (c) 2010 Jason Garrett-Glaser <darkshikari at gmail.com>
+;*
+;* This file is part of FFmpeg.
+;*
+;* FFmpeg is free software; you can redistribute it and/or
+;* modify it under the terms of the GNU Lesser General Public
+;* License as published by the Free Software Foundation; either
+;* version 2.1 of the License, or (at your option) any later version.
+;*
+;* FFmpeg is distributed in the hope that it will be useful,
+;* but WITHOUT ANY WARRANTY; without even the implied warranty of
+;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;* Lesser General Public License for more details.
+;*
+;* You should have received a copy of the GNU Lesser General Public
+;* License along with FFmpeg; if not, write to the Free Software
+;* 51, Inc., Foundation Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+;******************************************************************************
+
+%include "x86inc.asm"
+%include "x86util.asm"
+
+SECTION_RODATA
+
+fourtap_filter_hw_m: times 4 dw  -6, 123
+                     times 4 dw  12,  -1
+                     times 4 dw  -9,  93
+                     times 4 dw  50,  -6
+                     times 4 dw  -6,  50
+                     times 4 dw  93,  -9
+                     times 4 dw  -1,  12
+                     times 4 dw 123,  -6
+
+sixtap_filter_hw_m:  times 4 dw   2, -11
+                     times 4 dw 108,  36
+                     times 4 dw  -8,   1
+                     times 4 dw   3, -16
+                     times 4 dw  77,  77
+                     times 4 dw -16,   3
+                     times 4 dw   1,  -8
+                     times 4 dw  36, 108
+                     times 4 dw -11,   2
+
+fourtap_filter_hb_m: times 8 db  -6, 123
+                     times 8 db  12,  -1
+                     times 8 db  -9,  93
+                     times 8 db  50,  -6
+                     times 8 db  -6,  50
+                     times 8 db  93,  -9
+                     times 8 db  -1,  12
+                     times 8 db 123,  -6
+
+sixtap_filter_hb_m:  times 8 db   2,   1
+                     times 8 db -11, 108
+                     times 8 db  36,  -8
+                     times 8 db   3,   3
+                     times 8 db -16,  77
+                     times 8 db  77, -16
+                     times 8 db   1,   2
+                     times 8 db  -8,  36
+                     times 8 db 108, -11
+
+fourtap_filter_v_m:  times 8 dw  -6
+                     times 8 dw 123
+                     times 8 dw  12
+                     times 8 dw  -1
+                     times 8 dw  -9
+                     times 8 dw  93
+                     times 8 dw  50
+                     times 8 dw  -6
+                     times 8 dw  -6
+                     times 8 dw  50
+                     times 8 dw  93
+                     times 8 dw  -9
+                     times 8 dw  -1
+                     times 8 dw  12
+                     times 8 dw 123
+                     times 8 dw  -6
+
+sixtap_filter_v_m:   times 8 dw   2
+                     times 8 dw -11
+                     times 8 dw 108
+                     times 8 dw  36
+                     times 8 dw  -8
+                     times 8 dw   1
+                     times 8 dw   3
+                     times 8 dw -16
+                     times 8 dw  77
+                     times 8 dw  77
+                     times 8 dw -16
+                     times 8 dw   3
+                     times 8 dw   1
+                     times 8 dw  -8
+                     times 8 dw  36
+                     times 8 dw 108
+                     times 8 dw -11
+                     times 8 dw   2
+
+bilinear_filter_vw_m: times 8 dw 1
+                      times 8 dw 2
+                      times 8 dw 3
+                      times 8 dw 4
+                      times 8 dw 5
+                      times 8 dw 6
+                      times 8 dw 7
+
+bilinear_filter_vb_m: times 8 db 7, 1
+                      times 8 db 6, 2
+                      times 8 db 5, 3
+                      times 8 db 4, 4
+                      times 8 db 3, 5
+                      times 8 db 2, 6
+                      times 8 db 1, 7
+
+%ifdef PIC
+%define fourtap_filter_hw    r11
+%define sixtap_filter_hw     r11
+%define fourtap_filter_hb    r11
+%define sixtap_filter_hb     r11
+%define fourtap_filter_v     r11
+%define sixtap_filter_v      r11
+%define bilinear_filter_vw   r11
+%define bilinear_filter_vb   r11
+%else
+%define fourtap_filter_hw fourtap_filter_hw_m
+%define sixtap_filter_hw  sixtap_filter_hw_m
+%define fourtap_filter_hb fourtap_filter_hb_m
+%define sixtap_filter_hb  sixtap_filter_hb_m
+%define fourtap_filter_v  fourtap_filter_v_m
+%define sixtap_filter_v   sixtap_filter_v_m
+%define bilinear_filter_vw bilinear_filter_vw_m
+%define bilinear_filter_vb bilinear_filter_vb_m
+%endif
+
+filter_h2_shuf:  db 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5,  6, 6,  7,  7,  8
+filter_h4_shuf:  db 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,  8, 8,  9,  9, 10
+
+filter_h6_shuf1: db 0, 5, 1, 6, 2, 7, 3, 8, 4, 9, 5, 10, 6, 11,  7, 12
+filter_h6_shuf2: db 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,  7, 7,  8,  8,  9
+filter_h6_shuf3: db 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8,  9, 9, 10, 10, 11
+
+pw_20091: times 4 dw 20091
+pw_17734: times 4 dw 17734
+
+cextern pb_1
+cextern pw_3
+cextern pb_3
+cextern pw_4
+cextern pb_4
+cextern pw_9
+cextern pw_18
+cextern pw_27
+cextern pw_63
+cextern pw_64
+cextern pb_80
+cextern pb_F8
+cextern pb_FE
+
+SECTION .text
+
+;-----------------------------------------------------------------------------
+; subpel MC functions:
+;
+; void put_vp8_epel<size>_h<htap>v<vtap>_<opt>(uint8_t *dst, int deststride,
+;                                              uint8_t *src, int srcstride,
+;                                              int height,   int mx, int my);
+;-----------------------------------------------------------------------------
+
+%macro FILTER_SSSE3 3
+cglobal put_vp8_epel%1_h6_ssse3, 6, 6, %2
+    lea      r5d, [r5*3]
+    mova      m3, [filter_h6_shuf2]
+    mova      m4, [filter_h6_shuf3]
+%ifdef PIC
+    lea      r11, [sixtap_filter_hb_m]
+%endif
+    mova      m5, [sixtap_filter_hb+r5*8-48] ; set up 6tap filter in bytes
+    mova      m6, [sixtap_filter_hb+r5*8-32]
+    mova      m7, [sixtap_filter_hb+r5*8-16]
+
+.nextrow
+    movu      m0, [r2-2]
+    mova      m1, m0
+    mova      m2, m0
+%ifidn %1, 4
+; For epel4, we need 9 bytes, but only 8 get loaded; to compensate, do the
+; shuffle with a memory operand
+    punpcklbw m0, [r2+3]
+%else
+    pshufb    m0, [filter_h6_shuf1]
+%endif
+    pshufb    m1, m3
+    pshufb    m2, m4
+    pmaddubsw m0, m5
+    pmaddubsw m1, m6
+    pmaddubsw m2, m7
+    paddsw    m0, m1
+    paddsw    m0, m2
+    paddsw    m0, [pw_64]
+    psraw     m0, 7
+    packuswb  m0, m0
+    movh    [r0], m0        ; store
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4            ; next row
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_epel%1_h4_ssse3, 6, 6, %3
+    shl      r5d, 4
+    mova      m2, [pw_64]
+    mova      m3, [filter_h2_shuf]
+    mova      m4, [filter_h4_shuf]
+%ifdef PIC
+    lea      r11, [fourtap_filter_hb_m]
+%endif
+    mova      m5, [fourtap_filter_hb+r5-16] ; set up 4tap filter in bytes
+    mova      m6, [fourtap_filter_hb+r5]
+
+.nextrow
+    movu      m0, [r2-1]
+    mova      m1, m0
+    pshufb    m0, m3
+    pshufb    m1, m4
+    pmaddubsw m0, m5
+    pmaddubsw m1, m6
+    paddsw    m0, m2
+    paddsw    m0, m1
+    psraw     m0, 7
+    packuswb  m0, m0
+    movh    [r0], m0        ; store
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4            ; next row
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_epel%1_v4_ssse3, 7, 7, %2
+    shl      r6d, 4
+%ifdef PIC
+    lea      r11, [fourtap_filter_hb_m]
+%endif
+    mova      m5, [fourtap_filter_hb+r6-16]
+    mova      m6, [fourtap_filter_hb+r6]
+    mova      m7, [pw_64]
+
+    ; read 3 lines
+    sub       r2, r3
+    movh      m0, [r2]
+    movh      m1, [r2+  r3]
+    movh      m2, [r2+2*r3]
+    add       r2, r3
+
+.nextrow
+    movh      m3, [r2+2*r3]                ; read new row
+    mova      m4, m0
+    mova      m0, m1
+    punpcklbw m4, m1
+    mova      m1, m2
+    punpcklbw m2, m3
+    pmaddubsw m4, m5
+    pmaddubsw m2, m6
+    paddsw    m4, m2
+    mova      m2, m3
+    paddsw    m4, m7
+    psraw     m4, 7
+    packuswb  m4, m4
+    movh    [r0], m4
+
+    ; go to next line
+    add        r0, r1
+    add        r2, r3
+    dec        r4                          ; next row
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_epel%1_v6_ssse3, 7, 7, %2
+    lea      r6d, [r6*3]
+%ifdef PIC
+    lea      r11, [sixtap_filter_hb_m]
+%endif
+    lea       r6, [sixtap_filter_hb+r6*8]
+
+    ; read 5 lines
+    sub       r2, r3
+    sub       r2, r3
+    movh      m0, [r2]
+    movh      m1, [r2+r3]
+    movh      m2, [r2+r3*2]
+    lea       r2, [r2+r3*2]
+    add       r2, r3
+    movh      m3, [r2]
+    movh      m4, [r2+r3]
+
+.nextrow
+    movh      m5, [r2+2*r3]                ; read new row
+    mova      m6, m0
+    punpcklbw m6, m5
+    mova      m0, m1
+    punpcklbw m1, m2
+    mova      m7, m3
+    punpcklbw m7, m4
+    pmaddubsw m6, [r6-48]
+    pmaddubsw m1, [r6-32]
+    pmaddubsw m7, [r6-16]
+    paddsw    m6, m1
+    paddsw    m6, m7
+    mova      m1, m2
+    paddsw    m6, [pw_64]
+    mova      m2, m3
+    psraw     m6, 7
+    mova      m3, m4
+    packuswb  m6, m6
+    mova      m4, m5
+    movh    [r0], m6
+
+    ; go to next line
+    add        r0, r1
+    add        r2, r3
+    dec        r4                          ; next row
+    jg .nextrow
+    REP_RET
+%endmacro
+
+INIT_MMX
+FILTER_SSSE3 4, 0, 0
+INIT_XMM
+FILTER_SSSE3 8, 8, 7
+
+; 4x4 block, H-only 4-tap filter
+cglobal put_vp8_epel4_h4_mmxext, 6, 6
+    shl       r5d, 4
+%ifdef PIC
+    lea       r11, [fourtap_filter_hw_m]
+%endif
+    movq      mm4, [fourtap_filter_hw+r5-16] ; set up 4tap filter in words
+    movq      mm5, [fourtap_filter_hw+r5]
+    movq      mm7, [pw_64]
+    pxor      mm6, mm6
+
+.nextrow
+    movq      mm1, [r2-1]                  ; (ABCDEFGH) load 8 horizontal pixels
+
+    ; first set of 2 pixels
+    movq      mm2, mm1                     ; byte ABCD..
+    punpcklbw mm1, mm6                     ; byte->word ABCD
+    pshufw    mm0, mm2, 9                  ; byte CDEF..
+    punpcklbw mm0, mm6                     ; byte->word CDEF
+    pshufw    mm3, mm1, 0x94               ; word ABBC
+    pshufw    mm1, mm0, 0x94               ; word CDDE
+    pmaddwd   mm3, mm4                     ; multiply 2px with F0/F1
+    movq      mm0, mm1                     ; backup for second set of pixels
+    pmaddwd   mm1, mm5                     ; multiply 2px with F2/F3
+    paddd     mm3, mm1                     ; finish 1st 2px
+
+    ; second set of 2 pixels, use backup of above
+    punpckhbw mm2, mm6                     ; byte->word EFGH
+    pmaddwd   mm0, mm4                     ; multiply backed up 2px with F0/F1
+    pshufw    mm1, mm2, 0x94               ; word EFFG
+    pmaddwd   mm1, mm5                     ; multiply 2px with F2/F3
+    paddd     mm0, mm1                     ; finish 2nd 2px
+
+    ; merge two sets of 2 pixels into one set of 4, round/clip/store
+    packssdw  mm3, mm0                     ; merge dword->word (4px)
+    paddsw    mm3, mm7                     ; rounding
+    psraw     mm3, 7
+    packuswb  mm3, mm6                     ; clip and word->bytes
+    movd     [r0], mm3                     ; store
+
+    ; go to next line
+    add        r0, r1
+    add        r2, r3
+    dec        r4                          ; next row
+    jg .nextrow
+    REP_RET
+
+; 4x4 block, H-only 6-tap filter
+cglobal put_vp8_epel4_h6_mmxext, 6, 6
+    lea       r5d, [r5*3]
+%ifdef PIC
+    lea       r11, [sixtap_filter_hw_m]
+%endif
+    movq      mm4, [sixtap_filter_hw+r5*8-48] ; set up 4tap filter in words
+    movq      mm5, [sixtap_filter_hw+r5*8-32]
+    movq      mm6, [sixtap_filter_hw+r5*8-16]
+    movq      mm7, [pw_64]
+    pxor      mm3, mm3
+
+.nextrow
+    movq      mm1, [r2-2]                  ; (ABCDEFGH) load 8 horizontal pixels
+
+    ; first set of 2 pixels
+    movq      mm2, mm1                     ; byte ABCD..
+    punpcklbw mm1, mm3                     ; byte->word ABCD
+    pshufw    mm0, mm2, 0x9                ; byte CDEF..
+    punpckhbw mm2, mm3                     ; byte->word EFGH
+    punpcklbw mm0, mm3                     ; byte->word CDEF
+    pshufw    mm1, mm1, 0x94               ; word ABBC
+    pshufw    mm2, mm2, 0x94               ; word EFFG
+    pmaddwd   mm1, mm4                     ; multiply 2px with F0/F1
+    pshufw    mm3, mm0, 0x94               ; word CDDE
+    movq      mm0, mm3                     ; backup for second set of pixels
+    pmaddwd   mm3, mm5                     ; multiply 2px with F2/F3
+    paddd     mm1, mm3                     ; add to 1st 2px cache
+    movq      mm3, mm2                     ; backup for second set of pixels
+    pmaddwd   mm2, mm6                     ; multiply 2px with F4/F5
+    paddd     mm1, mm2                     ; finish 1st 2px
+
+    ; second set of 2 pixels, use backup of above
+    movd      mm2, [r2+3]                  ; byte FGHI (prevent overreads)
+    pmaddwd   mm0, mm4                     ; multiply 1st backed up 2px with F0/F1
+    pmaddwd   mm3, mm5                     ; multiply 2nd backed up 2px with F2/F3
+    paddd     mm0, mm3                     ; add to 2nd 2px cache
+    pxor      mm3, mm3
+    punpcklbw mm2, mm3                     ; byte->word FGHI
+    pshufw    mm2, mm2, 0xE9               ; word GHHI
+    pmaddwd   mm2, mm6                     ; multiply 2px with F4/F5
+    paddd     mm0, mm2                     ; finish 2nd 2px
+
+    ; merge two sets of 2 pixels into one set of 4, round/clip/store
+    packssdw  mm1, mm0                     ; merge dword->word (4px)
+    paddsw    mm1, mm7                     ; rounding
+    psraw     mm1, 7
+    packuswb  mm1, mm3                     ; clip and word->bytes
+    movd     [r0], mm1                     ; store
+
+    ; go to next line
+    add        r0, r1
+    add        r2, r3
+    dec        r4                          ; next row
+    jg .nextrow
+    REP_RET
+
+; 4x4 block, H-only 4-tap filter
+INIT_XMM
+cglobal put_vp8_epel8_h4_sse2, 6, 6, 8
+    shl      r5d, 4
+%ifdef PIC
+    lea      r11, [fourtap_filter_hw_m]
+%endif
+    mova      m5, [fourtap_filter_hw+r5-16] ; set up 4tap filter in words
+    mova      m6, [fourtap_filter_hw+r5]
+    pxor      m7, m7
+
+.nextrow
+    movh      m0, [r2-1]
+    punpcklbw m0, m7        ; ABCDEFGH
+    mova      m1, m0
+    mova      m2, m0
+    mova      m3, m0
+    psrldq    m1, 2         ; BCDEFGH
+    psrldq    m2, 4         ; CDEFGH
+    psrldq    m3, 6         ; DEFGH
+    punpcklwd m0, m1        ; ABBCCDDE
+    punpcklwd m2, m3        ; CDDEEFFG
+    pmaddwd   m0, m5
+    pmaddwd   m2, m6
+    paddd     m0, m2
+
+    movh      m1, [r2+3]
+    punpcklbw m1, m7        ; ABCDEFGH
+    mova      m2, m1
+    mova      m3, m1
+    mova      m4, m1
+    psrldq    m2, 2         ; BCDEFGH
+    psrldq    m3, 4         ; CDEFGH
+    psrldq    m4, 6         ; DEFGH
+    punpcklwd m1, m2        ; ABBCCDDE
+    punpcklwd m3, m4        ; CDDEEFFG
+    pmaddwd   m1, m5
+    pmaddwd   m3, m6
+    paddd     m1, m3
+
+    packssdw  m0, m1
+    paddsw    m0, [pw_64]
+    psraw     m0, 7
+    packuswb  m0, m7
+    movh    [r0], m0        ; store
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4            ; next row
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_epel8_h6_sse2, 6, 6, 8
+    lea      r5d, [r5*3]
+%ifdef PIC
+    lea      r11, [sixtap_filter_hw_m]
+%endif
+    lea       r5, [sixtap_filter_hw+r5*8]
+    pxor      m7, m7
+
+.nextrow
+    movu      m0, [r2-2]
+    mova      m6, m0
+    mova      m4, m0
+    punpcklbw m0, m7        ; ABCDEFGHI
+    mova      m1, m0
+    mova      m2, m0
+    mova      m3, m0
+    psrldq    m1, 2         ; BCDEFGH
+    psrldq    m2, 4         ; CDEFGH
+    psrldq    m3, 6         ; DEFGH
+    psrldq    m4, 4
+    punpcklbw m4, m7        ; EFGH
+    mova      m5, m4
+    psrldq    m5, 2         ; FGH
+    punpcklwd m0, m1        ; ABBCCDDE
+    punpcklwd m2, m3        ; CDDEEFFG
+    punpcklwd m4, m5        ; EFFGGHHI
+    pmaddwd   m0, [r5-48]
+    pmaddwd   m2, [r5-32]
+    pmaddwd   m4, [r5-16]
+    paddd     m0, m2
+    paddd     m0, m4
+
+    psrldq    m6, 4
+    mova      m4, m6
+    punpcklbw m6, m7        ; ABCDEFGHI
+    mova      m1, m6
+    mova      m2, m6
+    mova      m3, m6
+    psrldq    m1, 2         ; BCDEFGH
+    psrldq    m2, 4         ; CDEFGH
+    psrldq    m3, 6         ; DEFGH
+    psrldq    m4, 4
+    punpcklbw m4, m7        ; EFGH
+    mova      m5, m4
+    psrldq    m5, 2         ; FGH
+    punpcklwd m6, m1        ; ABBCCDDE
+    punpcklwd m2, m3        ; CDDEEFFG
+    punpcklwd m4, m5        ; EFFGGHHI
+    pmaddwd   m6, [r5-48]
+    pmaddwd   m2, [r5-32]
+    pmaddwd   m4, [r5-16]
+    paddd     m6, m2
+    paddd     m6, m4
+
+    packssdw  m0, m6
+    paddsw    m0, [pw_64]
+    psraw     m0, 7
+    packuswb  m0, m7
+    movh    [r0], m0        ; store
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4            ; next row
+    jg .nextrow
+    REP_RET
+
+%macro FILTER_V 3
+; 4x4 block, V-only 4-tap filter
+cglobal put_vp8_epel%2_v4_%1, 7, 7, %3
+    shl      r6d, 5
+%ifdef PIC
+    lea      r11, [fourtap_filter_v_m]
+%endif
+    lea       r6, [fourtap_filter_v+r6-32]
+    mova      m6, [pw_64]
+    pxor      m7, m7
+    mova      m5, [r6+48]
+
+    ; read 3 lines
+    sub       r2, r3
+    movh      m0, [r2]
+    movh      m1, [r2+  r3]
+    movh      m2, [r2+2*r3]
+    add       r2, r3
+    punpcklbw m0, m7
+    punpcklbw m1, m7
+    punpcklbw m2, m7
+
+.nextrow
+    ; first calculate negative taps (to prevent losing positive overflows)
+    movh      m4, [r2+2*r3]                ; read new row
+    punpcklbw m4, m7
+    mova      m3, m4
+    pmullw    m0, [r6+0]
+    pmullw    m4, m5
+    paddsw    m4, m0
+
+    ; then calculate positive taps
+    mova      m0, m1
+    pmullw    m1, [r6+16]
+    paddsw    m4, m1
+    mova      m1, m2
+    pmullw    m2, [r6+32]
+    paddsw    m4, m2
+    mova      m2, m3
+
+    ; round/clip/store
+    paddsw    m4, m6
+    psraw     m4, 7
+    packuswb  m4, m7
+    movh    [r0], m4
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4                           ; next row
+    jg .nextrow
+    REP_RET
+
+
+; 4x4 block, V-only 6-tap filter
+cglobal put_vp8_epel%2_v6_%1, 7, 7, %3
+    shl      r6d, 4
+    lea       r6, [r6*3]
+%ifdef PIC
+    lea      r11, [sixtap_filter_v_m]
+%endif
+    lea       r6, [sixtap_filter_v+r6-96]
+    pxor      m7, m7
+
+    ; read 5 lines
+    sub       r2, r3
+    sub       r2, r3
+    movh      m0, [r2]
+    movh      m1, [r2+r3]
+    movh      m2, [r2+r3*2]
+    lea       r2, [r2+r3*2]
+    add       r2, r3
+    movh      m3, [r2]
+    movh      m4, [r2+r3]
+    punpcklbw m0, m7
+    punpcklbw m1, m7
+    punpcklbw m2, m7
+    punpcklbw m3, m7
+    punpcklbw m4, m7
+
+.nextrow
+    ; first calculate negative taps (to prevent losing positive overflows)
+    mova      m5, m1
+    pmullw    m5, [r6+16]
+    mova      m6, m4
+    pmullw    m6, [r6+64]
+    paddsw    m6, m5
+
+    ; then calculate positive taps
+    movh      m5, [r2+2*r3]                ; read new row
+    punpcklbw m5, m7
+    pmullw    m0, [r6+0]
+    paddsw    m6, m0
+    mova      m0, m1
+    mova      m1, m2
+    pmullw    m2, [r6+32]
+    paddsw    m6, m2
+    mova      m2, m3
+    pmullw    m3, [r6+48]
+    paddsw    m6, m3
+    mova      m3, m4
+    mova      m4, m5
+    pmullw    m5, [r6+80]
+    paddsw    m6, m5
+
+    ; round/clip/store
+    paddsw    m6, [pw_64]
+    psraw     m6, 7
+    packuswb  m6, m7
+    movh    [r0], m6
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4                           ; next row
+    jg .nextrow
+    REP_RET
+%endmacro
+
+INIT_MMX
+FILTER_V mmxext, 4, 0
+INIT_XMM
+FILTER_V sse2,   8, 8
+
+%macro FILTER_BILINEAR 3
+cglobal put_vp8_bilinear%2_v_%1, 7,7,%3
+    mov      r5d, 8*16
+    shl      r6d, 4
+    sub      r5d, r6d
+%ifdef PIC
+    lea      r11, [bilinear_filter_vw_m]
+%endif
+    pxor      m6, m6
+    mova      m4, [bilinear_filter_vw+r5-16]
+    mova      m5, [bilinear_filter_vw+r6-16]
+.nextrow
+    movh      m0, [r2+r3*0]
+    movh      m1, [r2+r3*1]
+    movh      m3, [r2+r3*2]
+    punpcklbw m0, m6
+    punpcklbw m1, m6
+    punpcklbw m3, m6
+    mova      m2, m1
+    pmullw    m0, m4
+    pmullw    m1, m5
+    pmullw    m2, m4
+    pmullw    m3, m5
+    paddsw    m0, m1
+    paddsw    m2, m3
+    psraw     m0, 2
+    psraw     m2, 2
+    pavgw     m0, m6
+    pavgw     m2, m6
+%ifidn %1, mmxext
+    packuswb  m0, m0
+    packuswb  m2, m2
+    movh [r0+r1*0], m0
+    movh [r0+r1*1], m2
+%else
+    packuswb  m0, m2
+    movh   [r0+r1*0], m0
+    movhps [r0+r1*1], m0
+%endif
+
+    lea       r0, [r0+r1*2]
+    lea       r2, [r2+r3*2]
+    sub       r4, 2
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_bilinear%2_h_%1, 7,7,%3
+    mov      r6d, 8*16
+    shl      r5d, 4
+    sub      r6d, r5d
+%ifdef PIC
+    lea      r11, [bilinear_filter_vw_m]
+%endif
+    pxor      m6, m6
+    mova      m4, [bilinear_filter_vw+r6-16]
+    mova      m5, [bilinear_filter_vw+r5-16]
+.nextrow
+    movh      m0, [r2+r3*0+0]
+    movh      m1, [r2+r3*0+1]
+    movh      m2, [r2+r3*1+0]
+    movh      m3, [r2+r3*1+1]
+    punpcklbw m0, m6
+    punpcklbw m1, m6
+    punpcklbw m2, m6
+    punpcklbw m3, m6
+    pmullw    m0, m4
+    pmullw    m1, m5
+    pmullw    m2, m4
+    pmullw    m3, m5
+    paddsw    m0, m1
+    paddsw    m2, m3
+    psraw     m0, 2
+    psraw     m2, 2
+    pavgw     m0, m6
+    pavgw     m2, m6
+%ifidn %1, mmxext
+    packuswb  m0, m0
+    packuswb  m2, m2
+    movh [r0+r1*0], m0
+    movh [r0+r1*1], m2
+%else
+    packuswb  m0, m2
+    movh   [r0+r1*0], m0
+    movhps [r0+r1*1], m0
+%endif
+
+    lea       r0, [r0+r1*2]
+    lea       r2, [r2+r3*2]
+    sub       r4, 2
+    jg .nextrow
+    REP_RET
+%endmacro
+
+INIT_MMX
+FILTER_BILINEAR mmxext, 4, 0
+INIT_XMM
+FILTER_BILINEAR   sse2, 8, 7
+
+%macro FILTER_BILINEAR_SSSE3 1
+cglobal put_vp8_bilinear%1_v_ssse3, 7,7
+    shl      r6d, 4
+%ifdef PIC
+    lea      r11, [bilinear_filter_vb_m]
+%endif
+    pxor      m4, m4
+    mova      m3, [bilinear_filter_vb+r6-16]
+.nextrow
+    movh      m0, [r2+r3*0]
+    movh      m1, [r2+r3*1]
+    movh      m2, [r2+r3*2]
+    punpcklbw m0, m1
+    punpcklbw m1, m2
+    pmaddubsw m0, m3
+    pmaddubsw m1, m3
+    psraw     m0, 2
+    psraw     m1, 2
+    pavgw     m0, m4
+    pavgw     m1, m4
+%if mmsize==8
+    packuswb  m0, m0
+    packuswb  m1, m1
+    movh [r0+r1*0], m0
+    movh [r0+r1*1], m1
+%else
+    packuswb  m0, m1
+    movh   [r0+r1*0], m0
+    movhps [r0+r1*1], m0
+%endif
+
+    lea       r0, [r0+r1*2]
+    lea       r2, [r2+r3*2]
+    sub       r4, 2
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_bilinear%1_h_ssse3, 7,7
+    shl      r5d, 4
+%ifdef PIC
+    lea      r11, [bilinear_filter_vb_m]
+%endif
+    pxor      m4, m4
+    mova      m2, [filter_h2_shuf]
+    mova      m3, [bilinear_filter_vb+r5-16]
+.nextrow
+    movu      m0, [r2+r3*0]
+    movu      m1, [r2+r3*1]
+    pshufb    m0, m2
+    pshufb    m1, m2
+    pmaddubsw m0, m3
+    pmaddubsw m1, m3
+    psraw     m0, 2
+    psraw     m1, 2
+    pavgw     m0, m4
+    pavgw     m1, m4
+%if mmsize==8
+    packuswb  m0, m0
+    packuswb  m1, m1
+    movh [r0+r1*0], m0
+    movh [r0+r1*1], m1
+%else
+    packuswb  m0, m1
+    movh   [r0+r1*0], m0
+    movhps [r0+r1*1], m0
+%endif
+
+    lea       r0, [r0+r1*2]
+    lea       r2, [r2+r3*2]
+    sub       r4, 2
+    jg .nextrow
+    REP_RET
+%endmacro
+
+INIT_MMX
+FILTER_BILINEAR_SSSE3 4
+INIT_XMM
+FILTER_BILINEAR_SSSE3 8
+
+cglobal put_vp8_pixels8_mmx, 5,5
+.nextrow:
+    movq  mm0, [r2+r3*0]
+    movq  mm1, [r2+r3*1]
+    lea    r2, [r2+r3*2]
+    movq [r0+r1*0], mm0
+    movq [r0+r1*1], mm1
+    lea    r0, [r0+r1*2]
+    sub   r4d, 2
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_pixels16_mmx, 5,5
+.nextrow:
+    movq  mm0, [r2+r3*0+0]
+    movq  mm1, [r2+r3*0+8]
+    movq  mm2, [r2+r3*1+0]
+    movq  mm3, [r2+r3*1+8]
+    lea    r2, [r2+r3*2]
+    movq [r0+r1*0+0], mm0
+    movq [r0+r1*0+8], mm1
+    movq [r0+r1*1+0], mm2
+    movq [r0+r1*1+8], mm3
+    lea    r0, [r0+r1*2]
+    sub   r4d, 2
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_pixels16_sse, 5,5,2
+.nextrow:
+    movups xmm0, [r2+r3*0]
+    movups xmm1, [r2+r3*1]
+    lea     r2, [r2+r3*2]
+    movaps [r0+r1*0], xmm0
+    movaps [r0+r1*1], xmm1
+    lea     r0, [r0+r1*2]
+    sub    r4d, 2
+    jg .nextrow
+    REP_RET
+
+;-----------------------------------------------------------------------------
+; void vp8_idct_dc_add_<opt>(uint8_t *dst, DCTELEM block[16], int stride);
+;-----------------------------------------------------------------------------
+
+%macro ADD_DC 4
+    %4        m2, [r0+%3]
+    %4        m3, [r0+r2+%3]
+    %4        m4, [r1+%3]
+    %4        m5, [r1+r2+%3]
+    paddusb   m2, %1
+    paddusb   m3, %1
+    paddusb   m4, %1
+    paddusb   m5, %1
+    psubusb   m2, %2
+    psubusb   m3, %2
+    psubusb   m4, %2
+    psubusb   m5, %2
+    %4    [r0+%3], m2
+    %4 [r0+r2+%3], m3
+    %4    [r1+%3], m4
+    %4 [r1+r2+%3], m5
+%endmacro
+
+INIT_MMX
+cglobal vp8_idct_dc_add_mmx, 3, 3
+    ; load data
+    movd       m0, [r1]
+
+    ; calculate DC
+    paddw      m0, [pw_4]
+    pxor       m1, m1
+    psraw      m0, 3
+    movd      [r1], m1
+    psubw      m1, m0
+    packuswb   m0, m0
+    packuswb   m1, m1
+    punpcklbw  m0, m0
+    punpcklbw  m1, m1
+    punpcklwd  m0, m0
+    punpcklwd  m1, m1
+
+    ; add DC
+    lea        r1, [r0+r2*2]
+    ADD_DC     m0, m1, 0, movh
+    RET
+
+INIT_XMM
+cglobal vp8_idct_dc_add_sse4, 3, 3, 6
+    ; load data
+    movd       m0, [r1]
+    pxor       m1, m1
+
+    ; calculate DC
+    paddw      m0, [pw_4]
+    movd     [r1], m1
+    lea        r1, [r0+r2*2]
+    movd       m2, [r0]
+    movd       m3, [r0+r2]
+    movd       m4, [r1]
+    movd       m5, [r1+r2]
+    psraw      m0, 3
+    pshuflw    m0, m0, 0
+    punpcklqdq m0, m0
+    punpckldq  m2, m3
+    punpckldq  m4, m5
+    punpcklbw  m2, m1
+    punpcklbw  m4, m1
+    paddw      m2, m0
+    paddw      m4, m0
+    packuswb   m2, m4
+    movd      [r0], m2
+    pextrd [r0+r2], m2, 1
+    pextrd    [r1], m2, 2
+    pextrd [r1+r2], m2, 3
+    RET
+
+;-----------------------------------------------------------------------------
+; void vp8_idct_dc_add4y_<opt>(uint8_t *dst, DCTELEM block[4][16], int stride);
+;-----------------------------------------------------------------------------
+
+INIT_MMX
+cglobal vp8_idct_dc_add4y_mmx, 3, 3
+    ; load data
+    movd      m0, [r1+32*0] ; A
+    movd      m1, [r1+32*2] ; C
+    punpcklwd m0, [r1+32*1] ; A B
+    punpcklwd m1, [r1+32*3] ; C D
+    punpckldq m0, m1        ; A B C D
+    pxor      m6, m6
+
+    ; calculate DC
+    paddw     m0, [pw_4]
+    movd [r1+32*0], m6
+    movd [r1+32*1], m6
+    movd [r1+32*2], m6
+    movd [r1+32*3], m6
+    psraw     m0, 3
+    psubw     m6, m0
+    packuswb  m0, m0
+    packuswb  m6, m6
+    punpcklbw m0, m0 ; AABBCCDD
+    punpcklbw m6, m6 ; AABBCCDD
+    movq      m1, m0
+    movq      m7, m6
+    punpcklbw m0, m0 ; AAAABBBB
+    punpckhbw m1, m1 ; CCCCDDDD
+    punpcklbw m6, m6 ; AAAABBBB
+    punpckhbw m7, m7 ; CCCCDDDD
+
+    ; add DC
+    lea       r1, [r0+r2*2]
+    ADD_DC    m0, m6, 0, mova
+    ADD_DC    m1, m7, 8, mova
+    RET
+
+INIT_XMM
+cglobal vp8_idct_dc_add4y_sse2, 3, 3, 6
+    ; load data
+    movd      m0, [r1+32*0] ; A
+    movd      m1, [r1+32*2] ; C
+    punpcklwd m0, [r1+32*1] ; A B
+    punpcklwd m1, [r1+32*3] ; C D
+    punpckldq m0, m1        ; A B C D
+    pxor      m1, m1
+
+    ; calculate DC
+    paddw     m0, [pw_4]
+    movd [r1+32*0], m1
+    movd [r1+32*1], m1
+    movd [r1+32*2], m1
+    movd [r1+32*3], m1
+    psraw     m0, 3
+    psubw     m1, m0
+    packuswb  m0, m0
+    packuswb  m1, m1
+    punpcklbw m0, m0
+    punpcklbw m1, m1
+    punpcklbw m0, m0
+    punpcklbw m1, m1
+
+    ; add DC
+    lea       r1, [r0+r2*2]
+    ADD_DC    m0, m1, 0, mova
+    RET
+
+;-----------------------------------------------------------------------------
+; void vp8_idct_dc_add4uv_<opt>(uint8_t *dst, DCTELEM block[4][16], int stride);
+;-----------------------------------------------------------------------------
+
+INIT_MMX
+cglobal vp8_idct_dc_add4uv_mmx, 3, 3
+    ; load data
+    movd      m0, [r1+32*0] ; A
+    movd      m1, [r1+32*2] ; C
+    punpcklwd m0, [r1+32*1] ; A B
+    punpcklwd m1, [r1+32*3] ; C D
+    punpckldq m0, m1        ; A B C D
+    pxor      m6, m6
+
+    ; calculate DC
+    paddw     m0, [pw_4]
+    movd [r1+32*0], m6
+    movd [r1+32*1], m6
+    movd [r1+32*2], m6
+    movd [r1+32*3], m6
+    psraw     m0, 3
+    psubw     m6, m0
+    packuswb  m0, m0
+    packuswb  m6, m6
+    punpcklbw m0, m0 ; AABBCCDD
+    punpcklbw m6, m6 ; AABBCCDD
+    movq      m1, m0
+    movq      m7, m6
+    punpcklbw m0, m0 ; AAAABBBB
+    punpckhbw m1, m1 ; CCCCDDDD
+    punpcklbw m6, m6 ; AAAABBBB
+    punpckhbw m7, m7 ; CCCCDDDD
+
+    ; add DC
+    lea       r1, [r0+r2*2]
+    ADD_DC    m0, m6, 0, mova
+    lea       r0, [r0+r2*4]
+    lea       r1, [r1+r2*4]
+    ADD_DC    m1, m7, 0, mova
+    RET
+
+;-----------------------------------------------------------------------------
+; void vp8_idct_add_<opt>(uint8_t *dst, DCTELEM block[16], int stride);
+;-----------------------------------------------------------------------------
+
+; calculate %1=mul_35468(%1)-mul_20091(%2); %2=mul_20091(%1)+mul_35468(%2)
+;           this macro assumes that m6/m7 have words for 20091/17734 loaded
+%macro VP8_MULTIPLY_SUMSUB 4
+    mova      %3, %1
+    mova      %4, %2
+    pmulhw    %3, m6 ;20091(1)
+    pmulhw    %4, m6 ;20091(2)
+    paddw     %3, %1
+    paddw     %4, %2
+    paddw     %1, %1
+    paddw     %2, %2
+    pmulhw    %1, m7 ;35468(1)
+    pmulhw    %2, m7 ;35468(2)
+    psubw     %1, %4
+    paddw     %2, %3
+%endmacro
+
+; calculate x0=%1+%3; x1=%1-%3
+;           x2=mul_35468(%2)-mul_20091(%4); x3=mul_20091(%2)+mul_35468(%4)
+;           %1=x0+x3 (tmp0); %2=x1+x2 (tmp1); %3=x1-x2 (tmp2); %4=x0-x3 (tmp3)
+;           %5/%6 are temporary registers
+;           we assume m6/m7 have constant words 20091/17734 loaded in them
+%macro VP8_IDCT_TRANSFORM4x4_1D 6
+    SUMSUB_BA           m%3, m%1, m%5     ;t0, t1
+    VP8_MULTIPLY_SUMSUB m%2, m%4, m%5,m%6 ;t2, t3
+    SUMSUB_BA           m%4, m%3, m%5     ;tmp0, tmp3
+    SUMSUB_BA           m%2, m%1, m%5     ;tmp1, tmp2
+    SWAP                 %4,  %1
+    SWAP                 %4,  %3
+%endmacro
+
+INIT_MMX
+%macro VP8_IDCT_ADD 1
+cglobal vp8_idct_add_%1, 3, 3
+    ; load block data
+    movq         m0, [r1+ 0]
+    movq         m1, [r1+ 8]
+    movq         m2, [r1+16]
+    movq         m3, [r1+24]
+    movq         m6, [pw_20091]
+    movq         m7, [pw_17734]
+%ifidn %1, sse
+    xorps      xmm0, xmm0
+    movaps  [r1+ 0], xmm0
+    movaps  [r1+16], xmm0
+%else
+    pxor         m4, m4
+    movq    [r1+ 0], m4
+    movq    [r1+ 8], m4
+    movq    [r1+16], m4
+    movq    [r1+24], m4
+%endif
+
+    ; actual IDCT
+    VP8_IDCT_TRANSFORM4x4_1D 0, 1, 2, 3, 4, 5
+    TRANSPOSE4x4W            0, 1, 2, 3, 4
+    paddw        m0, [pw_4]
+    VP8_IDCT_TRANSFORM4x4_1D 0, 1, 2, 3, 4, 5
+    TRANSPOSE4x4W            0, 1, 2, 3, 4
+
+    ; store
+    pxor         m4, m4
+    lea          r1, [r0+2*r2]
+    STORE_DIFFx2 m0, m1, m6, m7, m4, 3, r0, r2
+    STORE_DIFFx2 m2, m3, m6, m7, m4, 3, r1, r2
+
+    RET
+%endmacro
+
+VP8_IDCT_ADD mmx
+VP8_IDCT_ADD sse
+
+;-----------------------------------------------------------------------------
+; void vp8_luma_dc_wht_mmxext(DCTELEM block[4][4][16], DCTELEM dc[16])
+;-----------------------------------------------------------------------------
+
+%macro SCATTER_WHT 3
+    movd  r1d, m%1
+    movd  r2d, m%2
+    mov [r0+2*16*(0+%3)], r1w
+    mov [r0+2*16*(1+%3)], r2w
+    shr   r1d, 16
+    shr   r2d, 16
+    psrlq m%1, 32
+    psrlq m%2, 32
+    mov [r0+2*16*(4+%3)], r1w
+    mov [r0+2*16*(5+%3)], r2w
+    movd  r1d, m%1
+    movd  r2d, m%2
+    mov [r0+2*16*(8+%3)], r1w
+    mov [r0+2*16*(9+%3)], r2w
+    shr   r1d, 16
+    shr   r2d, 16
+    mov [r0+2*16*(12+%3)], r1w
+    mov [r0+2*16*(13+%3)], r2w
+%endmacro
+
+%macro HADAMARD4_1D 4
+    SUMSUB_BADC m%2, m%1, m%4, m%3
+    SUMSUB_BADC m%4, m%2, m%3, m%1
+    SWAP %1, %4, %3
+%endmacro
+
+INIT_MMX
+cglobal vp8_luma_dc_wht_mmx, 2,3
+    movq          m0, [r1]
+    movq          m1, [r1+8]
+    movq          m2, [r1+16]
+    movq          m3, [r1+24]
+    HADAMARD4_1D  0, 1, 2, 3
+    TRANSPOSE4x4W 0, 1, 2, 3, 4
+    paddw         m0, [pw_3]
+    HADAMARD4_1D  0, 1, 2, 3
+    psraw         m0, 3
+    psraw         m1, 3
+    psraw         m2, 3
+    psraw         m3, 3
+    SCATTER_WHT   0, 1, 0
+    SCATTER_WHT   2, 3, 2
+    RET
+
+;-----------------------------------------------------------------------------
+; void vp8_h/v_loop_filter_simple_<opt>(uint8_t *dst, int stride, int flim);
+;-----------------------------------------------------------------------------
+
+; macro called with 7 mm register indexes as argument, and 4 regular registers
+;
+; first 4 mm registers will carry the transposed pixel data
+; the other three are scratchspace (one would be sufficient, but this allows
+; for more spreading/pipelining and thus faster execution on OOE CPUs)
+;
+; first two regular registers are buf+4*stride and buf+5*stride
+; third is -stride, fourth is +stride
+%macro READ_8x4_INTERLEAVED 11
+    ; interleave 8 (A-H) rows of 4 pixels each
+    movd          m%1, [%8+%10*4]   ; A0-3
+    movd          m%5, [%9+%10*4]   ; B0-3
+    movd          m%2, [%8+%10*2]   ; C0-3
+    movd          m%6, [%8+%10]     ; D0-3
+    movd          m%3, [%8]         ; E0-3
+    movd          m%7, [%9]         ; F0-3
+    movd          m%4, [%9+%11]     ; G0-3
+    punpcklbw     m%1, m%5          ; A/B interleaved
+    movd          m%5, [%9+%11*2]   ; H0-3
+    punpcklbw     m%2, m%6          ; C/D interleaved
+    punpcklbw     m%3, m%7          ; E/F interleaved
+    punpcklbw     m%4, m%5          ; G/H interleaved
+%endmacro
+
+; macro called with 7 mm register indexes as argument, and 5 regular registers
+; first 11 mean the same as READ_8x4_TRANSPOSED above
+; fifth regular register is scratchspace to reach the bottom 8 rows, it
+; will be set to second regular register + 8*stride at the end
+%macro READ_16x4_INTERLEAVED 12
+    ; transpose 16 (A-P) rows of 4 pixels each
+    lea           %12, [r0+8*r2]
+
+    ; read (and interleave) those addressable by %8 (=r0), A/C/D/E/I/K/L/M
+    movd          m%1, [%8+%10*4]   ; A0-3
+    movd          m%3, [%12+%10*4]  ; I0-3
+    movd          m%2, [%8+%10*2]   ; C0-3
+    movd          m%4, [%12+%10*2]  ; K0-3
+    movd          m%6, [%8+%10]     ; D0-3
+    movd          m%5, [%12+%10]    ; L0-3
+    movd          m%7, [%12]        ; M0-3
+    add           %12, %11
+    punpcklbw     m%1, m%3          ; A/I
+    movd          m%3, [%8]         ; E0-3
+    punpcklbw     m%2, m%4          ; C/K
+    punpcklbw     m%6, m%5          ; D/L
+    punpcklbw     m%3, m%7          ; E/M
+    punpcklbw     m%2, m%6          ; C/D/K/L interleaved
+
+    ; read (and interleave) those addressable by %9 (=r4), B/F/G/H/J/N/O/P
+    movd         m%5, [%9+%10*4]   ; B0-3
+    movd         m%4, [%12+%10*4]  ; J0-3
+    movd         m%7, [%9]         ; F0-3
+    movd         m%6, [%12]        ; N0-3
+    punpcklbw    m%5, m%4          ; B/J
+    punpcklbw    m%7, m%6          ; F/N
+    punpcklbw    m%1, m%5          ; A/B/I/J interleaved
+    punpcklbw    m%3, m%7          ; E/F/M/N interleaved
+    movd         m%4, [%9+%11]     ; G0-3
+    movd         m%6, [%12+%11]    ; O0-3
+    movd         m%5, [%9+%11*2]   ; H0-3
+    movd         m%7, [%12+%11*2]  ; P0-3
+    punpcklbw    m%4, m%6          ; G/O
+    punpcklbw    m%5, m%7          ; H/P
+    punpcklbw    m%4, m%5          ; G/H/O/P interleaved
+%endmacro
+
+; write 4 mm registers of 2 dwords each
+; first four arguments are mm register indexes containing source data
+; last four are registers containing buf+4*stride, buf+5*stride,
+; -stride and +stride
+%macro WRITE_4x2D 8
+    ; write out (2 dwords per register)
+    movd    [%5+%7*4], m%1
+    movd    [%5+%7*2], m%2
+    movd         [%5], m%3
+    movd      [%6+%8], m%4
+    punpckhdq     m%1, m%1
+    punpckhdq     m%2, m%2
+    punpckhdq     m%3, m%3
+    punpckhdq     m%4, m%4
+    movd    [%6+%7*4], m%1
+    movd      [%5+%7], m%2
+    movd         [%6], m%3
+    movd    [%6+%8*2], m%4
+%endmacro
+
+; write 4 xmm registers of 4 dwords each
+; arguments same as WRITE_2x4D, but with an extra register, so that the 5 regular
+; registers contain buf+4*stride, buf+5*stride, buf+12*stride, -stride and +stride
+; we add 1*stride to the third regular registry in the process
+; the 10th argument is 16 if it's a Y filter (i.e. all regular registers cover the
+; same memory region), or 8 if they cover two separate buffers (third one points to
+; a different memory region than the first two), allowing for more optimal code for
+; the 16-width case
+%macro WRITE_4x4D 10
+    ; write out (4 dwords per register), start with dwords zero
+    movd    [%5+%8*4], m%1
+    movd         [%5], m%2
+    movd    [%7+%8*4], m%3
+    movd         [%7], m%4
+
+    ; store dwords 1
+    psrldq        m%1, 4
+    psrldq        m%2, 4
+    psrldq        m%3, 4
+    psrldq        m%4, 4
+    movd    [%6+%8*4], m%1
+    movd         [%6], m%2
+%if %10 == 16
+    movd    [%6+%9*4], m%3
+%endif
+    movd      [%7+%9], m%4
+
+    ; write dwords 2
+    psrldq        m%1, 4
+    psrldq        m%2, 4
+%if %10 == 8
+    movd    [%5+%8*2], m%1
+    movd           %5, m%3
+%endif
+    psrldq        m%3, 4
+    psrldq        m%4, 4
+%if %10 == 16
+    movd    [%5+%8*2], m%1
+%endif
+    movd      [%6+%9], m%2
+    movd    [%7+%8*2], m%3
+    movd    [%7+%9*2], m%4
+    add            %7, %9
+
+    ; store dwords 3
+    psrldq        m%1, 4
+    psrldq        m%2, 4
+    psrldq        m%3, 4
+    psrldq        m%4, 4
+%if %10 == 8
+    mov     [%7+%8*4], %5d
+    movd    [%6+%8*2], m%1
+%else
+    movd      [%5+%8], m%1
+%endif
+    movd    [%6+%9*2], m%2
+    movd    [%7+%8*2], m%3
+    movd    [%7+%9*2], m%4
+%endmacro
+
+%macro SPLATB_REG_MMX 2-3
+    movd           %1, %2
+    punpcklbw      %1, %1
+    punpcklwd      %1, %1
+    punpckldq      %1, %1
+%endmacro
+
+%macro SPLATB_REG_MMXEXT 2-3
+    movd           %1, %2
+    punpcklbw      %1, %1
+    pshufw         %1, %1, 0x0
+%endmacro
+
+%macro SPLATB_REG_SSE2 2-3
+    movd           %1, %2
+    punpcklbw      %1, %1
+    pshuflw        %1, %1, 0x0
+    punpcklqdq     %1, %1
+%endmacro
+
+%macro SPLATB_REG_SSSE3 3
+    movd           %1, %2
+    pshufb         %1, %3
+%endmacro
+
+%macro SIMPLE_LOOPFILTER 3
+cglobal vp8_%2_loop_filter_simple_%1, 3, %3
+%ifidn %2, h
+    mov            r5, rsp          ; backup stack pointer
+    and           rsp, ~(mmsize-1)  ; align stack
+%endif
+%if mmsize == 8 ; mmx/mmxext
+    mov            r3, 2
+%endif
+%ifnidn %1, sse2 && mmsize == 16
+    pxor           m0, m0
+%endif
+    SPLATB_REG     m7, r2, m0       ; splat "flim" into register
+
+    ; set up indexes to address 4 rows
+    mov            r2, r1
+    neg            r1
+%ifidn %2, h
+    lea            r0, [r0+4*r2-2]
+    sub           rsp, mmsize*2     ; (aligned) storage space for saving p1/q1
+%endif
+
+%if mmsize == 8 ; mmx / mmxext
+.next8px
+%endif
+%ifidn %2, v
+    ; read 4 half/full rows of pixels
+    mova           m0, [r0+r1*2]    ; p1
+    mova           m1, [r0+r1]      ; p0
+    mova           m2, [r0]         ; q0
+    mova           m3, [r0+r2]      ; q1
+%else ; h
+    lea            r4, [r0+r2]
+
+%if mmsize == 8 ; mmx/mmxext
+    READ_8x4_INTERLEAVED  0, 1, 2, 3, 4, 5, 6, r0, r4, r1, r2
+%else ; sse2
+    READ_16x4_INTERLEAVED 0, 1, 2, 3, 4, 5, 6, r0, r4, r1, r2, r3
+%endif
+    TRANSPOSE4x4W         0, 1, 2, 3, 4
+
+    mova        [rsp], m0           ; store p1
+    mova [rsp+mmsize], m3           ; store q1
+%endif
+
+    ; simple_limit
+    mova           m5, m2           ; m5=backup of q0
+    mova           m6, m1           ; m6=backup of p0
+    psubusb        m1, m2           ; p0-q0
+    psubusb        m2, m6           ; q0-p0
+    por            m1, m2           ; FFABS(p0-q0)
+    paddusb        m1, m1           ; m1=FFABS(p0-q0)*2
+
+    mova           m4, m3
+    mova           m2, m0
+    psubusb        m3, m0           ; q1-p1
+    psubusb        m0, m4           ; p1-q1
+    por            m3, m0           ; FFABS(p1-q1)
+    mova           m0, [pb_80]
+    pxor           m2, m0
+    pxor           m4, m0
+    psubsb         m2, m4           ; m2=p1-q1 (signed) backup for below
+    pand           m3, [pb_FE]
+    psrlq          m3, 1            ; m3=FFABS(p1-q1)/2, this can be used signed
+    paddusb        m3, m1
+    psubusb        m3, m7
+    pxor           m1, m1
+    pcmpeqb        m3, m1           ; abs(p0-q0)*2+abs(p1-q1)/2<=flim mask(0xff/0x0)
+
+    ; filter_common (use m2/p1-q1, m4=q0, m6=p0, m5/q0-p0 and m3/mask)
+    mova           m4, m5
+    pxor           m5, m0
+    pxor           m0, m6
+    psubsb         m5, m0           ; q0-p0 (signed)
+    paddsb         m2, m5
+    paddsb         m2, m5
+    paddsb         m2, m5           ; a=(p1-q1) + 3*(q0-p0)
+    pand           m2, m3           ; apply filter mask (m3)
+
+    mova           m3, [pb_F8]
+    mova           m1, m2
+    paddsb         m2, [pb_4]       ; f1<<3=a+4
+    paddsb         m1, [pb_3]       ; f2<<3=a+3
+    pand           m2, m3
+    pand           m1, m3           ; cache f2<<3
+
+    pxor           m0, m0
+    pxor           m3, m3
+    pcmpgtb        m0, m2           ; which values are <0?
+    psubb          m3, m2           ; -f1<<3
+    psrlq          m2, 3            ; +f1
+    psrlq          m3, 3            ; -f1
+    pand           m3, m0
+    pandn          m0, m2
+    psubusb        m4, m0
+    paddusb        m4, m3           ; q0-f1
+
+    pxor           m0, m0
+    pxor           m3, m3
+    pcmpgtb        m0, m1           ; which values are <0?
+    psubb          m3, m1           ; -f2<<3
+    psrlq          m1, 3            ; +f2
+    psrlq          m3, 3            ; -f2
+    pand           m3, m0
+    pandn          m0, m1
+    paddusb        m6, m0
+    psubusb        m6, m3           ; p0+f2
+
+    ; store
+%ifidn %2, v
+    mova         [r0], m4
+    mova      [r0+r1], m6
+%else ; h
+    mova           m0, [rsp]        ; p1
+    SWAP            2, 4            ; p0
+    SWAP            1, 6            ; q0
+    mova           m3, [rsp+mmsize] ; q1
+
+    TRANSPOSE4x4B  0, 1, 2, 3, 4
+%if mmsize == 16 ; sse2
+    add            r3, r1           ; change from r4*8*stride to r0+8*stride
+    WRITE_4x4D 0, 1, 2, 3, r0, r4, r3, r1, r2, 16
+%else ; mmx/mmxext
+    WRITE_4x2D 0, 1, 2, 3, r0, r4, r1, r2
+%endif
+%endif
+
+%if mmsize == 8 ; mmx/mmxext
+    ; next 8 pixels
+%ifidn %2, v
+    add            r0, 8            ; advance 8 cols = pixels
+%else ; h
+    lea            r0, [r0+r2*8]    ; advance 8 rows = lines
+%endif
+    dec            r3
+    jg .next8px
+%ifidn %2, v
+    REP_RET
+%else ; h
+    mov           rsp, r5           ; restore stack pointer
+    RET
+%endif
+%else ; sse2
+%ifidn %2, h
+    mov           rsp, r5           ; restore stack pointer
+%endif
+    RET
+%endif
+%endmacro
+
+INIT_MMX
+%define SPLATB_REG SPLATB_REG_MMX
+SIMPLE_LOOPFILTER mmx,    v, 4
+SIMPLE_LOOPFILTER mmx,    h, 6
+%define SPLATB_REG SPLATB_REG_MMXEXT
+SIMPLE_LOOPFILTER mmxext, v, 4
+SIMPLE_LOOPFILTER mmxext, h, 6
+INIT_XMM
+%define SPLATB_REG SPLATB_REG_SSE2
+SIMPLE_LOOPFILTER sse2,   v, 3
+SIMPLE_LOOPFILTER sse2,   h, 6
+%define SPLATB_REG SPLATB_REG_SSSE3
+SIMPLE_LOOPFILTER ssse3,  v, 3
+SIMPLE_LOOPFILTER ssse3,  h, 6
+
+;-----------------------------------------------------------------------------
+; void vp8_h/v_loop_filter<size>_inner_<opt>(uint8_t *dst, [uint8_t *v,] int stride,
+;                                            int flimE, int flimI, int hev_thr);
+;-----------------------------------------------------------------------------
+
+%macro INNER_LOOPFILTER 5
+%if %4 == 8 ; chroma
+cglobal vp8_%2_loop_filter8uv_inner_%1, 6, %3, %5
+%define dst8_reg    r1
+%define mstride_reg r2
+%define E_reg       r3
+%define I_reg       r4
+%define hev_thr_reg r5
+%else ; luma
+cglobal vp8_%2_loop_filter16y_inner_%1, 5, %3, %5
+%define mstride_reg r1
+%define E_reg       r2
+%define I_reg       r3
+%define hev_thr_reg r4
+%ifdef m8 ; x86-64, sse2
+%define dst8_reg    r4
+%elif mmsize == 16 ; x86-32, sse2
+%define dst8_reg    r5
+%else ; x86-32, mmx/mmxext
+%define cnt_reg     r5
+%endif
+%endif
+%define dst_reg     r0
+%define stride_reg  E_reg
+%define dst2_reg    I_reg
+%ifndef m8
+%define stack_reg   hev_thr_reg
+%endif
+
+%ifnidn %1, sse2 && mmsize == 16
+    pxor             m7, m7
+%endif
+
+%ifndef m8 ; mmx/mmxext or sse2 on x86-32
+    ; splat function arguments
+    SPLATB_REG       m0, E_reg, m7   ; E
+    SPLATB_REG       m1, I_reg, m7   ; I
+    SPLATB_REG       m2, hev_thr_reg, m7 ; hev_thresh
+
+    ; align stack
+    mov       stack_reg, rsp         ; backup stack pointer
+    and             rsp, ~(mmsize-1) ; align stack
+%ifidn %2, v
+    sub             rsp, mmsize * 4  ; stack layout: [0]=E, [1]=I, [2]=hev_thr
+                                     ;               [3]=hev() result
+%else ; h
+    sub             rsp, mmsize * 5  ; extra storage space for transposes
+%endif
+
+%define flim_E   [rsp]
+%define flim_I   [rsp+mmsize]
+%define hev_thr  [rsp+mmsize*2]
+%define mask_res [rsp+mmsize*3]
+%define p0backup [rsp+mmsize*3]
+%define q0backup [rsp+mmsize*4]
+
+    mova         flim_E, m0
+    mova         flim_I, m1
+    mova        hev_thr, m2
+
+%else ; sse2 on x86-64
+
+%define flim_E   m9
+%define flim_I   m10
+%define hev_thr  m11
+%define mask_res m12
+%define p0backup m12
+%define q0backup m8
+
+    ; splat function arguments
+    SPLATB_REG   flim_E, E_reg, m7   ; E
+    SPLATB_REG   flim_I, I_reg, m7   ; I
+    SPLATB_REG  hev_thr, hev_thr_reg, m7 ; hev_thresh
+%endif
+
+%if mmsize == 8 && %4 == 16 ; mmx/mmxext
+    mov         cnt_reg, 2
+%endif
+    mov      stride_reg, mstride_reg
+    neg     mstride_reg
+%ifidn %2, h
+    lea         dst_reg, [dst_reg + stride_reg*4-4]
+%if %4 == 8
+    lea        dst8_reg, [dst8_reg+ stride_reg*4-4]
+%endif
+%endif
+
+%if mmsize == 8
+.next8px
+%endif
+    ; read
+    lea        dst2_reg, [dst_reg + stride_reg]
+%ifidn %2, v
+%if %4 == 8 && mmsize == 16
+%define movrow movh
+%else
+%define movrow mova
+%endif
+    movrow           m0, [dst_reg +mstride_reg*4] ; p3
+    movrow           m1, [dst2_reg+mstride_reg*4] ; p2
+    movrow           m2, [dst_reg +mstride_reg*2] ; p1
+    movrow           m5, [dst2_reg]               ; q1
+    movrow           m6, [dst2_reg+ stride_reg]   ; q2
+    movrow           m7, [dst2_reg+ stride_reg*2] ; q3
+%if mmsize == 16 && %4 == 8
+    movhps           m0, [dst8_reg+mstride_reg*4]
+    movhps           m2, [dst8_reg+mstride_reg*2]
+    add        dst8_reg, stride_reg
+    movhps           m1, [dst8_reg+mstride_reg*4]
+    movhps           m5, [dst8_reg]
+    movhps           m6, [dst8_reg+ stride_reg]
+    movhps           m7, [dst8_reg+ stride_reg*2]
+    add        dst8_reg, mstride_reg
+%endif
+%elif mmsize == 8 ; mmx/mmxext (h)
+    ; read 8 rows of 8px each
+    movu             m0, [dst_reg +mstride_reg*4]
+    movu             m1, [dst2_reg+mstride_reg*4]
+    movu             m2, [dst_reg +mstride_reg*2]
+    movu             m3, [dst_reg +mstride_reg]
+    movu             m4, [dst_reg]
+    movu             m5, [dst2_reg]
+    movu             m6, [dst2_reg+ stride_reg]
+
+    ; 8x8 transpose
+    TRANSPOSE4x4B     0, 1, 2, 3, 7
+    mova       q0backup, m1
+    movu             m7, [dst2_reg+ stride_reg*2]
+    TRANSPOSE4x4B     4, 5, 6, 7, 1
+    SBUTTERFLY       dq, 0, 4, 1     ; p3/p2
+    SBUTTERFLY       dq, 2, 6, 1     ; q0/q1
+    SBUTTERFLY       dq, 3, 7, 1     ; q2/q3
+    mova             m1, q0backup
+    mova       q0backup, m2          ; store q0
+    SBUTTERFLY       dq, 1, 5, 2     ; p1/p0
+    mova       p0backup, m5          ; store p0
+    SWAP              1, 4
+    SWAP              2, 4
+    SWAP              6, 3
+    SWAP              5, 3
+%else ; sse2 (h)
+%if %4 == 16
+    lea        dst8_reg, [dst_reg + stride_reg*8]
+%endif
+
+    ; read 16 rows of 8px each, interleave
+    movh             m0, [dst_reg +mstride_reg*4]
+    movh             m1, [dst8_reg+mstride_reg*4]
+    movh             m2, [dst_reg +mstride_reg*2]
+    movh             m5, [dst8_reg+mstride_reg*2]
+    movh             m3, [dst_reg +mstride_reg]
+    movh             m6, [dst8_reg+mstride_reg]
+    movh             m4, [dst_reg]
+    movh             m7, [dst8_reg]
+    punpcklbw        m0, m1          ; A/I
+    punpcklbw        m2, m5          ; C/K
+    punpcklbw        m3, m6          ; D/L
+    punpcklbw        m4, m7          ; E/M
+
+    add        dst8_reg, stride_reg
+    movh             m1, [dst2_reg+mstride_reg*4]
+    movh             m6, [dst8_reg+mstride_reg*4]
+    movh             m5, [dst2_reg]
+    movh             m7, [dst8_reg]
+    punpcklbw        m1, m6          ; B/J
+    punpcklbw        m5, m7          ; F/N
+    movh             m6, [dst2_reg+ stride_reg]
+    movh             m7, [dst8_reg+ stride_reg]
+    punpcklbw        m6, m7          ; G/O
+
+    ; 8x16 transpose
+    TRANSPOSE4x4B     0, 1, 2, 3, 7
+%ifdef m8
+    SWAP              1, 8
+%else
+    mova       q0backup, m1
+%endif
+    movh             m7, [dst2_reg+ stride_reg*2]
+    movh             m1, [dst8_reg+ stride_reg*2]
+    punpcklbw        m7, m1          ; H/P
+    TRANSPOSE4x4B     4, 5, 6, 7, 1
+    SBUTTERFLY       dq, 0, 4, 1     ; p3/p2
+    SBUTTERFLY       dq, 2, 6, 1     ; q0/q1
+    SBUTTERFLY       dq, 3, 7, 1     ; q2/q3
+%ifdef m8
+    SWAP              1, 8
+    SWAP              2, 8
+%else
+    mova             m1, q0backup
+    mova       q0backup, m2          ; store q0
+%endif
+    SBUTTERFLY       dq, 1, 5, 2     ; p1/p0
+%ifdef m12
+    SWAP              5, 12
+%else
+    mova       p0backup, m5          ; store p0
+%endif
+    SWAP              1, 4
+    SWAP              2, 4
+    SWAP              6, 3
+    SWAP              5, 3
+%endif
+
+    ; normal_limit for p3-p2, p2-p1, q3-q2 and q2-q1
+    mova             m4, m1
+    SWAP              4, 1
+    psubusb          m4, m0          ; p2-p3
+    psubusb          m0, m1          ; p3-p2
+    por              m0, m4          ; abs(p3-p2)
+
+    mova             m4, m2
+    SWAP              4, 2
+    psubusb          m4, m1          ; p1-p2
+    psubusb          m1, m2          ; p2-p1
+    por              m1, m4          ; abs(p2-p1)
+
+    mova             m4, m6
+    SWAP              4, 6
+    psubusb          m4, m7          ; q2-q3
+    psubusb          m7, m6          ; q3-q2
+    por              m7, m4          ; abs(q3-q2)
+
+    mova             m4, m5
+    SWAP              4, 5
+    psubusb          m4, m6          ; q1-q2
+    psubusb          m6, m5          ; q2-q1
+    por              m6, m4          ; abs(q2-q1)
+
+%ifidn %1, mmx
+    mova             m4, flim_I
+    pxor             m3, m3
+    psubusb          m0, m4
+    psubusb          m1, m4
+    psubusb          m7, m4
+    psubusb          m6, m4
+    pcmpeqb          m0, m3          ; abs(p3-p2) <= I
+    pcmpeqb          m1, m3          ; abs(p2-p1) <= I
+    pcmpeqb          m7, m3          ; abs(q3-q2) <= I
+    pcmpeqb          m6, m3          ; abs(q2-q1) <= I
+    pand             m0, m1
+    pand             m7, m6
+    pand             m0, m7
+%else ; mmxext/sse2
+    pmaxub           m0, m1
+    pmaxub           m6, m7
+    pmaxub           m0, m6
+%endif
+
+    ; normal_limit and high_edge_variance for p1-p0, q1-q0
+    SWAP              7, 3           ; now m7 is zero
+%ifidn %2, v
+    movrow           m3, [dst_reg +mstride_reg] ; p0
+%if mmsize == 16 && %4 == 8
+    movhps           m3, [dst8_reg+mstride_reg]
+%endif
+%elifdef m12
+    SWAP              3, 12
+%else
+    mova             m3, p0backup
+%endif
+
+    mova             m1, m2
+    SWAP              1, 2
+    mova             m6, m3
+    SWAP              3, 6
+    psubusb          m1, m3          ; p1-p0
+    psubusb          m6, m2          ; p0-p1
+    por              m1, m6          ; abs(p1-p0)
+%ifidn %1, mmx
+    mova             m6, m1
+    psubusb          m1, m4
+    psubusb          m6, hev_thr
+    pcmpeqb          m1, m7          ; abs(p1-p0) <= I
+    pcmpeqb          m6, m7          ; abs(p1-p0) <= hev_thresh
+    pand             m0, m1
+    mova       mask_res, m6
+%else ; mmxext/sse2
+    pmaxub           m0, m1          ; max_I
+    SWAP              1, 4           ; max_hev_thresh
+%endif
+
+    SWAP              6, 4           ; now m6 is I
+%ifidn %2, v
+    movrow           m4, [dst_reg]   ; q0
+%if mmsize == 16 && %4 == 8
+    movhps           m4, [dst8_reg]
+%endif
+%elifdef m8
+    SWAP              4, 8
+%else
+    mova             m4, q0backup
+%endif
+    mova             m1, m4
+    SWAP              1, 4
+    mova             m7, m5
+    SWAP              7, 5
+    psubusb          m1, m5          ; q0-q1
+    psubusb          m7, m4          ; q1-q0
+    por              m1, m7          ; abs(q1-q0)
+%ifidn %1, mmx
+    mova             m7, m1
+    psubusb          m1, m6
+    psubusb          m7, hev_thr
+    pxor             m6, m6
+    pcmpeqb          m1, m6          ; abs(q1-q0) <= I
+    pcmpeqb          m7, m6          ; abs(q1-q0) <= hev_thresh
+    mova             m6, mask_res
+    pand             m0, m1          ; abs([pq][321]-[pq][210]) <= I
+    pand             m6, m7
+%else ; mmxext/sse2
+    pxor             m7, m7
+    pmaxub           m0, m1
+    pmaxub           m6, m1
+    psubusb          m0, flim_I
+    psubusb          m6, hev_thr
+    pcmpeqb          m0, m7          ; max(abs(..)) <= I
+    pcmpeqb          m6, m7          ; !(max(abs..) > thresh)
+%endif
+%ifdef m12
+    SWAP              6, 12
+%else
+    mova       mask_res, m6          ; !(abs(p1-p0) > hev_t || abs(q1-q0) > hev_t)
+%endif
+
+    ; simple_limit
+    mova             m1, m3
+    SWAP              1, 3
+    mova             m6, m4          ; keep copies of p0/q0 around for later use
+    SWAP              6, 4
+    psubusb          m1, m4          ; p0-q0
+    psubusb          m6, m3          ; q0-p0
+    por              m1, m6          ; abs(q0-p0)
+    paddusb          m1, m1          ; m1=2*abs(q0-p0)
+
+    mova             m7, m2
+    SWAP              7, 2
+    mova             m6, m5
+    SWAP              6, 5
+    psubusb          m7, m5          ; p1-q1
+    psubusb          m6, m2          ; q1-p1
+    por              m7, m6          ; abs(q1-p1)
+    pxor             m6, m6
+    pand             m7, [pb_FE]
+    psrlq            m7, 1           ; abs(q1-p1)/2
+    paddusb          m7, m1          ; abs(q0-p0)*2+abs(q1-p1)/2
+    psubusb          m7, flim_E
+    pcmpeqb          m7, m6          ; abs(q0-p0)*2+abs(q1-p1)/2 <= E
+    pand             m0, m7          ; normal_limit result
+
+    ; filter_common; at this point, m2-m5=p1-q1 and m0 is filter_mask
+%ifdef m8 ; x86-64 && sse2
+    mova             m8, [pb_80]
+%define pb_80_var m8
+%else ; x86-32 or mmx/mmxext
+%define pb_80_var [pb_80]
+%endif
+    mova             m1, m4
+    mova             m7, m3
+    pxor             m1, pb_80_var
+    pxor             m7, pb_80_var
+    psubsb           m1, m7          ; (signed) q0-p0
+    mova             m6, m2
+    mova             m7, m5
+    pxor             m6, pb_80_var
+    pxor             m7, pb_80_var
+    psubsb           m6, m7          ; (signed) p1-q1
+    mova             m7, mask_res
+    pandn            m7, m6
+    paddsb           m7, m1
+    paddsb           m7, m1
+    paddsb           m7, m1          ; 3*(q0-p0)+is4tap?(p1-q1)
+
+    pand             m7, m0
+    mova             m1, [pb_F8]
+    mova             m6, m7
+    paddsb           m7, [pb_3]
+    paddsb           m6, [pb_4]
+    pand             m7, m1
+    pand             m6, m1
+
+    pxor             m1, m1
+    pxor             m0, m0
+    pcmpgtb          m1, m7
+    psubb            m0, m7
+    psrlq            m7, 3           ; +f2
+    psrlq            m0, 3           ; -f2
+    pand             m0, m1
+    pandn            m1, m7
+    psubusb          m3, m0
+    paddusb          m3, m1          ; p0+f2
+
+    pxor             m1, m1
+    pxor             m0, m0
+    pcmpgtb          m0, m6
+    psubb            m1, m6
+    psrlq            m6, 3           ; +f1
+    psrlq            m1, 3           ; -f1
+    pand             m1, m0
+    pandn            m0, m6
+    psubusb          m4, m0
+    paddusb          m4, m1          ; q0-f1
+
+%ifdef m12
+    SWAP              6, 12
+%else
+    mova             m6, mask_res
+%endif
+%ifidn %1, mmx
+    mova             m7, [pb_1]
+%else ; mmxext/sse2
+    pxor             m7, m7
+%endif
+    pand             m0, m6
+    pand             m1, m6
+%ifidn %1, mmx
+    paddusb          m0, m7
+    pand             m1, [pb_FE]
+    pandn            m7, m0
+    psrlq            m1, 1
+    psrlq            m7, 1
+    SWAP              0, 7
+%else ; mmxext/sse2
+    psubusb          m1, [pb_1]
+    pavgb            m0, m7          ; a
+    pavgb            m1, m7          ; -a
+%endif
+    psubusb          m5, m0
+    psubusb          m2, m1
+    paddusb          m5, m1          ; q1-a
+    paddusb          m2, m0          ; p1+a
+
+    ; store
+%ifidn %2, v
+    movrow [dst_reg +mstride_reg*2], m2
+    movrow [dst_reg +mstride_reg  ], m3
+    movrow    [dst_reg], m4
+    movrow [dst_reg + stride_reg  ], m5
+%if mmsize == 16 && %4 == 8
+    movhps [dst8_reg+mstride_reg*2], m2
+    movhps [dst8_reg+mstride_reg  ], m3
+    movhps   [dst8_reg], m4
+    movhps [dst8_reg+ stride_reg  ], m5
+%endif
+%else ; h
+    add         dst_reg, 2
+    add        dst2_reg, 2
+
+    ; 4x8/16 transpose
+    TRANSPOSE4x4B     2, 3, 4, 5, 6
+
+%if mmsize == 8 ; mmx/mmxext (h)
+    WRITE_4x2D        2, 3, 4, 5, dst_reg, dst2_reg, mstride_reg, stride_reg
+%else ; sse2 (h)
+    lea        dst8_reg, [dst8_reg+mstride_reg+2]
+    WRITE_4x4D        2, 3, 4, 5, dst_reg, dst2_reg, dst8_reg, mstride_reg, stride_reg, %4
+%endif
+%endif
+
+%if mmsize == 8
+%if %4 == 8 ; chroma
+%ifidn %2, h
+    sub         dst_reg, 2
+%endif
+    cmp         dst_reg, dst8_reg
+    mov         dst_reg, dst8_reg
+    jnz .next8px
+%else
+%ifidn %2, h
+    lea         dst_reg, [dst_reg + stride_reg*8-2]
+%else ; v
+    add         dst_reg, 8
+%endif
+    dec         cnt_reg
+    jg .next8px
+%endif
+%endif
+
+%ifndef m8 ; sse2 on x86-32 or mmx/mmxext
+    mov             rsp, stack_reg   ; restore stack pointer
+%endif
+    RET
+%endmacro
+
+INIT_MMX
+%define SPLATB_REG SPLATB_REG_MMX
+INNER_LOOPFILTER mmx,    v, 6, 16, 0
+INNER_LOOPFILTER mmx,    h, 6, 16, 0
+INNER_LOOPFILTER mmx,    v, 6,  8, 0
+INNER_LOOPFILTER mmx,    h, 6,  8, 0
+
+%define SPLATB_REG SPLATB_REG_MMXEXT
+INNER_LOOPFILTER mmxext, v, 6, 16, 0
+INNER_LOOPFILTER mmxext, h, 6, 16, 0
+INNER_LOOPFILTER mmxext, v, 6,  8, 0
+INNER_LOOPFILTER mmxext, h, 6,  8, 0
+
+INIT_XMM
+%define SPLATB_REG SPLATB_REG_SSE2
+INNER_LOOPFILTER sse2,   v, 5, 16, 13
+%ifdef m8
+INNER_LOOPFILTER sse2,   h, 5, 16, 13
+%else
+INNER_LOOPFILTER sse2,   h, 6, 16, 13
+%endif
+INNER_LOOPFILTER sse2,   v, 6,  8, 13
+INNER_LOOPFILTER sse2,   h, 6,  8, 13
+
+%define SPLATB_REG SPLATB_REG_SSSE3
+INNER_LOOPFILTER ssse3,  v, 5, 16, 13
+%ifdef m8
+INNER_LOOPFILTER ssse3,  h, 5, 16, 13
+%else
+INNER_LOOPFILTER ssse3,  h, 6, 16, 13
+%endif
+INNER_LOOPFILTER ssse3,  v, 6,  8, 13
+INNER_LOOPFILTER ssse3,  h, 6,  8, 13
+
+;-----------------------------------------------------------------------------
+; void vp8_h/v_loop_filter<size>_mbedge_<opt>(uint8_t *dst, [uint8_t *v,] int stride,
+;                                            int flimE, int flimI, int hev_thr);
+;-----------------------------------------------------------------------------
+
+; write 4 or 8 words in the mmx/xmm registers as 8 lines
+; 1 and 2 are the registers to write, this can be the same (for SSE2)
+; for pre-SSE4:
+; 3 is a general-purpose register that we will clobber
+; for SSE4:
+; 3 is a pointer to the destination's 5th line
+; 4 is a pointer to the destination's 4th line
+; 5/6 is -stride and +stride
+; 7 is optimization string
+%macro WRITE_8W 7
+%ifidn %7, sse4
+    pextrw    [%4+%5*4], %1, 0
+    pextrw    [%3+%5*4], %1, 1
+    pextrw    [%4+%5*2], %1, 2
+    pextrw    [%4+%5  ], %1, 3
+    pextrw    [%4     ], %1, 4
+    pextrw    [%3     ], %1, 5
+    pextrw    [%3+%6  ], %1, 6
+    pextrw    [%3+%6*2], %1, 7
+%else
+    movd             %3, %1
+%if mmsize == 8
+    punpckhdq        %1, %1
+%else
+    psrldq           %1, 4
+%endif
+    mov       [%4+%5*4], %3w
+    shr              %3, 16
+    add              %4, %6
+    mov       [%4+%5*4], %3w
+
+    movd             %3, %1
+%if mmsize == 16
+    psrldq           %1, 4
+%endif
+    add              %4, %5
+    mov       [%4+%5*2], %3w
+    shr              %3, 16
+    mov       [%4+%5  ], %3w
+
+    movd             %3, %2
+%if mmsize == 8
+    punpckhdq        %2, %2
+%else
+    psrldq           %2, 4
+%endif
+    mov       [%4     ], %3w
+    shr              %3, 16
+    mov       [%4+%6  ], %3w
+
+    movd             %3, %2
+    add              %4, %6
+    mov       [%4+%6  ], %3w
+    shr              %3, 16
+    mov       [%4+%6*2], %3w
+%if mmsize == 8
+    add              %4, %5
+%endif
+%endif
+%endmacro
+
+%macro MBEDGE_LOOPFILTER 5
+%if %4 == 8 ; chroma
+cglobal vp8_%2_loop_filter8uv_mbedge_%1, 6, %3, %5
+%define dst8_reg    r1
+%define mstride_reg r2
+%define E_reg       r3
+%define I_reg       r4
+%define hev_thr_reg r5
+%else ; luma
+cglobal vp8_%2_loop_filter16y_mbedge_%1, 5, %3, %5
+%define mstride_reg r1
+%define E_reg       r2
+%define I_reg       r3
+%define hev_thr_reg r4
+%ifdef m8 ; x86-64, sse2
+%define dst8_reg    r4
+%elif mmsize == 16 ; x86-32, sse2
+%define dst8_reg    r5
+%else ; x86-32, mmx/mmxext
+%define cnt_reg     r5
+%endif
+%endif
+%define dst_reg     r0
+%define stride_reg  E_reg
+%define dst2_reg    I_reg
+%ifndef m8
+%define stack_reg   hev_thr_reg
+%endif
+
+%ifnidn %1, sse2 && mmsize == 16
+    pxor             m7, m7
+%endif
+
+%ifndef m8 ; mmx/mmxext or sse2 on x86-32
+    ; splat function arguments
+    SPLATB_REG       m0, E_reg, m7   ; E
+    SPLATB_REG       m1, I_reg, m7   ; I
+    SPLATB_REG       m2, hev_thr_reg, m7 ; hev_thresh
+
+    ; align stack
+    mov       stack_reg, rsp         ; backup stack pointer
+    and             rsp, ~(mmsize-1) ; align stack
+    sub             rsp, mmsize * 8  ; stack layout: [0]=E, [1]=I, [2]=hev_thr
+                                     ;               [3]=hev() result
+                                     ;               [4]=filter tmp result
+                                     ;               [5]/[6] = p2/q2 backup
+                                     ;               [7]=lim_res sign result
+
+%define flim_E   [rsp]
+%define flim_I   [rsp+mmsize]
+%define hev_thr  [rsp+mmsize*2]
+%define mask_res [rsp+mmsize*3]
+%define lim_res  [rsp+mmsize*4]
+%define p0backup [rsp+mmsize*3]
+%define q0backup [rsp+mmsize*4]
+%define p2backup [rsp+mmsize*5]
+%define q2backup [rsp+mmsize*6]
+%define lim_sign [rsp+mmsize*7]
+
+    mova         flim_E, m0
+    mova         flim_I, m1
+    mova        hev_thr, m2
+
+%else ; sse2 on x86-64
+
+%define flim_E   m9
+%define flim_I   m10
+%define hev_thr  m11
+%define mask_res m12
+%define lim_res  m8
+%define p0backup m12
+%define q0backup m8
+%define p2backup m13
+%define q2backup m14
+%define lim_sign m15
+
+    ; splat function arguments
+    SPLATB_REG   flim_E, E_reg, m7   ; E
+    SPLATB_REG   flim_I, I_reg, m7   ; I
+    SPLATB_REG  hev_thr, hev_thr_reg, m7 ; hev_thresh
+%endif
+
+%if mmsize == 8 && %4 == 16 ; mmx/mmxext
+    mov         cnt_reg, 2
+%endif
+    mov      stride_reg, mstride_reg
+    neg     mstride_reg
+%ifidn %2, h
+    lea         dst_reg, [dst_reg + stride_reg*4-4]
+%if %4 == 8
+    lea        dst8_reg, [dst8_reg+ stride_reg*4-4]
+%endif
+%endif
+
+%if mmsize == 8
+.next8px
+%endif
+    ; read
+    lea        dst2_reg, [dst_reg + stride_reg]
+%ifidn %2, v
+%if %4 == 8 && mmsize == 16
+%define movrow movh
+%else
+%define movrow mova
+%endif
+    movrow           m0, [dst_reg +mstride_reg*4] ; p3
+    movrow           m1, [dst2_reg+mstride_reg*4] ; p2
+    movrow           m2, [dst_reg +mstride_reg*2] ; p1
+    movrow           m5, [dst2_reg]               ; q1
+    movrow           m6, [dst2_reg+ stride_reg]   ; q2
+    movrow           m7, [dst2_reg+ stride_reg*2] ; q3
+%if mmsize == 16 && %4 == 8
+    movhps           m0, [dst8_reg+mstride_reg*4]
+    movhps           m2, [dst8_reg+mstride_reg*2]
+    add        dst8_reg, stride_reg
+    movhps           m1, [dst8_reg+mstride_reg*4]
+    movhps           m5, [dst8_reg]
+    movhps           m6, [dst8_reg+ stride_reg]
+    movhps           m7, [dst8_reg+ stride_reg*2]
+    add        dst8_reg, mstride_reg
+%endif
+%elif mmsize == 8 ; mmx/mmxext (h)
+    ; read 8 rows of 8px each
+    movu             m0, [dst_reg +mstride_reg*4]
+    movu             m1, [dst2_reg+mstride_reg*4]
+    movu             m2, [dst_reg +mstride_reg*2]
+    movu             m3, [dst_reg +mstride_reg]
+    movu             m4, [dst_reg]
+    movu             m5, [dst2_reg]
+    movu             m6, [dst2_reg+ stride_reg]
+
+    ; 8x8 transpose
+    TRANSPOSE4x4B     0, 1, 2, 3, 7
+    mova       q0backup, m1
+    movu             m7, [dst2_reg+ stride_reg*2]
+    TRANSPOSE4x4B     4, 5, 6, 7, 1
+    SBUTTERFLY       dq, 0, 4, 1     ; p3/p2
+    SBUTTERFLY       dq, 2, 6, 1     ; q0/q1
+    SBUTTERFLY       dq, 3, 7, 1     ; q2/q3
+    mova             m1, q0backup
+    mova       q0backup, m2          ; store q0
+    SBUTTERFLY       dq, 1, 5, 2     ; p1/p0
+    mova       p0backup, m5          ; store p0
+    SWAP              1, 4
+    SWAP              2, 4
+    SWAP              6, 3
+    SWAP              5, 3
+%else ; sse2 (h)
+%if %4 == 16
+    lea        dst8_reg, [dst_reg + stride_reg*8]
+%endif
+
+    ; read 16 rows of 8px each, interleave
+    movh             m0, [dst_reg +mstride_reg*4]
+    movh             m1, [dst8_reg+mstride_reg*4]
+    movh             m2, [dst_reg +mstride_reg*2]
+    movh             m5, [dst8_reg+mstride_reg*2]
+    movh             m3, [dst_reg +mstride_reg]
+    movh             m6, [dst8_reg+mstride_reg]
+    movh             m4, [dst_reg]
+    movh             m7, [dst8_reg]
+    punpcklbw        m0, m1          ; A/I
+    punpcklbw        m2, m5          ; C/K
+    punpcklbw        m3, m6          ; D/L
+    punpcklbw        m4, m7          ; E/M
+
+    add        dst8_reg, stride_reg
+    movh             m1, [dst2_reg+mstride_reg*4]
+    movh             m6, [dst8_reg+mstride_reg*4]
+    movh             m5, [dst2_reg]
+    movh             m7, [dst8_reg]
+    punpcklbw        m1, m6          ; B/J
+    punpcklbw        m5, m7          ; F/N
+    movh             m6, [dst2_reg+ stride_reg]
+    movh             m7, [dst8_reg+ stride_reg]
+    punpcklbw        m6, m7          ; G/O
+
+    ; 8x16 transpose
+    TRANSPOSE4x4B     0, 1, 2, 3, 7
+%ifdef m8
+    SWAP              1, 8
+%else
+    mova       q0backup, m1
+%endif
+    movh             m7, [dst2_reg+ stride_reg*2]
+    movh             m1, [dst8_reg+ stride_reg*2]
+    punpcklbw        m7, m1          ; H/P
+    TRANSPOSE4x4B     4, 5, 6, 7, 1
+    SBUTTERFLY       dq, 0, 4, 1     ; p3/p2
+    SBUTTERFLY       dq, 2, 6, 1     ; q0/q1
+    SBUTTERFLY       dq, 3, 7, 1     ; q2/q3
+%ifdef m8
+    SWAP              1, 8
+    SWAP              2, 8
+%else
+    mova             m1, q0backup
+    mova       q0backup, m2          ; store q0
+%endif
+    SBUTTERFLY       dq, 1, 5, 2     ; p1/p0
+%ifdef m12
+    SWAP              5, 12
+%else
+    mova       p0backup, m5          ; store p0
+%endif
+    SWAP              1, 4
+    SWAP              2, 4
+    SWAP              6, 3
+    SWAP              5, 3
+%endif
+
+    ; normal_limit for p3-p2, p2-p1, q3-q2 and q2-q1
+    mova             m4, m1
+    SWAP              4, 1
+    psubusb          m4, m0          ; p2-p3
+    psubusb          m0, m1          ; p3-p2
+    por              m0, m4          ; abs(p3-p2)
+
+    mova             m4, m2
+    SWAP              4, 2
+    psubusb          m4, m1          ; p1-p2
+    mova       p2backup, m1
+    psubusb          m1, m2          ; p2-p1
+    por              m1, m4          ; abs(p2-p1)
+
+    mova             m4, m6
+    SWAP              4, 6
+    psubusb          m4, m7          ; q2-q3
+    psubusb          m7, m6          ; q3-q2
+    por              m7, m4          ; abs(q3-q2)
+
+    mova             m4, m5
+    SWAP              4, 5
+    psubusb          m4, m6          ; q1-q2
+    mova       q2backup, m6
+    psubusb          m6, m5          ; q2-q1
+    por              m6, m4          ; abs(q2-q1)
+
+%ifidn %1, mmx
+    mova             m4, flim_I
+    pxor             m3, m3
+    psubusb          m0, m4
+    psubusb          m1, m4
+    psubusb          m7, m4
+    psubusb          m6, m4
+    pcmpeqb          m0, m3          ; abs(p3-p2) <= I
+    pcmpeqb          m1, m3          ; abs(p2-p1) <= I
+    pcmpeqb          m7, m3          ; abs(q3-q2) <= I
+    pcmpeqb          m6, m3          ; abs(q2-q1) <= I
+    pand             m0, m1
+    pand             m7, m6
+    pand             m0, m7
+%else ; mmxext/sse2
+    pmaxub           m0, m1
+    pmaxub           m6, m7
+    pmaxub           m0, m6
+%endif
+
+    ; normal_limit and high_edge_variance for p1-p0, q1-q0
+    SWAP              7, 3           ; now m7 is zero
+%ifidn %2, v
+    movrow           m3, [dst_reg +mstride_reg] ; p0
+%if mmsize == 16 && %4 == 8
+    movhps           m3, [dst8_reg+mstride_reg]
+%endif
+%elifdef m12
+    SWAP              3, 12
+%else
+    mova             m3, p0backup
+%endif
+
+    mova             m1, m2
+    SWAP              1, 2
+    mova             m6, m3
+    SWAP              3, 6
+    psubusb          m1, m3          ; p1-p0
+    psubusb          m6, m2          ; p0-p1
+    por              m1, m6          ; abs(p1-p0)
+%ifidn %1, mmx
+    mova             m6, m1
+    psubusb          m1, m4
+    psubusb          m6, hev_thr
+    pcmpeqb          m1, m7          ; abs(p1-p0) <= I
+    pcmpeqb          m6, m7          ; abs(p1-p0) <= hev_thresh
+    pand             m0, m1
+    mova       mask_res, m6
+%else ; mmxext/sse2
+    pmaxub           m0, m1          ; max_I
+    SWAP              1, 4           ; max_hev_thresh
+%endif
+
+    SWAP              6, 4           ; now m6 is I
+%ifidn %2, v
+    movrow           m4, [dst_reg]   ; q0
+%if mmsize == 16 && %4 == 8
+    movhps           m4, [dst8_reg]
+%endif
+%elifdef m8
+    SWAP              4, 8
+%else
+    mova             m4, q0backup
+%endif
+    mova             m1, m4
+    SWAP              1, 4
+    mova             m7, m5
+    SWAP              7, 5
+    psubusb          m1, m5          ; q0-q1
+    psubusb          m7, m4          ; q1-q0
+    por              m1, m7          ; abs(q1-q0)
+%ifidn %1, mmx
+    mova             m7, m1
+    psubusb          m1, m6
+    psubusb          m7, hev_thr
+    pxor             m6, m6
+    pcmpeqb          m1, m6          ; abs(q1-q0) <= I
+    pcmpeqb          m7, m6          ; abs(q1-q0) <= hev_thresh
+    mova             m6, mask_res
+    pand             m0, m1          ; abs([pq][321]-[pq][210]) <= I
+    pand             m6, m7
+%else ; mmxext/sse2
+    pxor             m7, m7
+    pmaxub           m0, m1
+    pmaxub           m6, m1
+    psubusb          m0, flim_I
+    psubusb          m6, hev_thr
+    pcmpeqb          m0, m7          ; max(abs(..)) <= I
+    pcmpeqb          m6, m7          ; !(max(abs..) > thresh)
+%endif
+%ifdef m12
+    SWAP              6, 12
+%else
+    mova       mask_res, m6          ; !(abs(p1-p0) > hev_t || abs(q1-q0) > hev_t)
+%endif
+
+    ; simple_limit
+    mova             m1, m3
+    SWAP              1, 3
+    mova             m6, m4          ; keep copies of p0/q0 around for later use
+    SWAP              6, 4
+    psubusb          m1, m4          ; p0-q0
+    psubusb          m6, m3          ; q0-p0
+    por              m1, m6          ; abs(q0-p0)
+    paddusb          m1, m1          ; m1=2*abs(q0-p0)
+
+    mova             m7, m2
+    SWAP              7, 2
+    mova             m6, m5
+    SWAP              6, 5
+    psubusb          m7, m5          ; p1-q1
+    psubusb          m6, m2          ; q1-p1
+    por              m7, m6          ; abs(q1-p1)
+    pxor             m6, m6
+    pand             m7, [pb_FE]
+    psrlq            m7, 1           ; abs(q1-p1)/2
+    paddusb          m7, m1          ; abs(q0-p0)*2+abs(q1-p1)/2
+    psubusb          m7, flim_E
+    pcmpeqb          m7, m6          ; abs(q0-p0)*2+abs(q1-p1)/2 <= E
+    pand             m0, m7          ; normal_limit result
+
+    ; filter_common; at this point, m2-m5=p1-q1 and m0 is filter_mask
+%ifdef m8 ; x86-64 && sse2
+    mova             m8, [pb_80]
+%define pb_80_var m8
+%else ; x86-32 or mmx/mmxext
+%define pb_80_var [pb_80]
+%endif
+    mova             m1, m4
+    mova             m7, m3
+    pxor             m1, pb_80_var
+    pxor             m7, pb_80_var
+    psubsb           m1, m7          ; (signed) q0-p0
+    mova             m6, m2
+    mova             m7, m5
+    pxor             m6, pb_80_var
+    pxor             m7, pb_80_var
+    psubsb           m6, m7          ; (signed) p1-q1
+    mova             m7, mask_res
+    paddsb           m6, m1
+    paddsb           m6, m1
+    paddsb           m6, m1
+    pand             m6, m0
+%ifdef m8
+    mova        lim_res, m6          ; 3*(qp-p0)+(p1-q1) masked for filter_mbedge
+    pand        lim_res, m7
+%else
+    mova             m0, m6
+    pand             m0, m7
+    mova        lim_res, m0
+%endif
+    pandn            m7, m6          ; 3*(q0-p0)+(p1-q1) masked for filter_common
+
+    mova             m1, [pb_F8]
+    mova             m6, m7
+    paddsb           m7, [pb_3]
+    paddsb           m6, [pb_4]
+    pand             m7, m1
+    pand             m6, m1
+
+    pxor             m1, m1
+    pxor             m0, m0
+    pcmpgtb          m1, m7
+    psubb            m0, m7
+    psrlq            m7, 3           ; +f2
+    psrlq            m0, 3           ; -f2
+    pand             m0, m1
+    pandn            m1, m7
+    psubusb          m3, m0
+    paddusb          m3, m1          ; p0+f2
+
+    pxor             m1, m1
+    pxor             m0, m0
+    pcmpgtb          m0, m6
+    psubb            m1, m6
+    psrlq            m6, 3           ; +f1
+    psrlq            m1, 3           ; -f1
+    pand             m1, m0
+    pandn            m0, m6
+    psubusb          m4, m0
+    paddusb          m4, m1          ; q0-f1
+
+    ; filter_mbedge (m2-m5 = p1-q1; lim_res carries w)
+    mova             m7, [pw_63]
+%ifdef m8
+    SWAP              1, 8
+%else
+    mova             m1, lim_res
+%endif
+    pxor             m0, m0
+    mova             m6, m1
+    pcmpgtb          m0, m1         ; which are negative
+    punpcklbw        m6, m0         ; signed byte->word
+    punpckhbw        m1, m0
+    mova       lim_sign, m0
+    mova       mask_res, m6         ; backup for later in filter
+    mova        lim_res, m1
+    pmullw          m6, [pw_27]
+    pmullw          m1, [pw_27]
+    paddw           m6, m7
+    paddw           m1, m7
+    psraw           m6, 7
+    psraw           m1, 7
+    packsswb        m6, m1          ; a0
+    pxor            m1, m1
+    psubb           m1, m6
+    pand            m1, m0          ; -a0
+    pandn           m0, m6          ; +a0
+    psubusb         m3, m1
+    paddusb         m4, m1
+    paddusb         m3, m0          ; p0+a0
+    psubusb         m4, m0          ; q0-a0
+
+    mova            m6, mask_res
+    mova            m1, lim_res
+    mova            m0, lim_sign
+    pmullw          m6, [pw_18]
+    pmullw          m1, [pw_18]
+    paddw           m6, m7
+    paddw           m1, m7
+    psraw           m6, 7
+    psraw           m1, 7
+    packsswb        m6, m1          ; a1
+    pxor            m1, m1
+    psubb           m1, m6
+    pand            m1, m0          ; -a1
+    pandn           m0, m6          ; +a1
+    psubusb         m2, m1
+    paddusb         m5, m1
+    paddusb         m2, m0          ; p1+a1
+    psubusb         m5, m0          ; q1-a1
+
+%ifdef m8
+    SWAP             6, 12
+    SWAP             1, 8
+%else
+    mova            m6, mask_res
+    mova            m1, lim_res
+%endif
+    pmullw          m6, [pw_9]
+    pmullw          m1, [pw_9]
+    paddw           m6, m7
+    paddw           m1, m7
+%ifdef m15
+    SWAP             7, 15
+%else
+    mova            m7, lim_sign
+%endif
+    psraw           m6, 7
+    psraw           m1, 7
+    packsswb        m6, m1          ; a1
+    pxor            m0, m0
+    psubb           m0, m6
+    pand            m0, m7          ; -a1
+    pandn           m7, m6          ; +a1
+%ifdef m8
+    SWAP             1, 13
+    SWAP             6, 14
+%else
+    mova            m1, p2backup
+    mova            m6, q2backup
+%endif
+    psubusb         m1, m0
+    paddusb         m6, m0
+    paddusb         m1, m7          ; p1+a1
+    psubusb         m6, m7          ; q1-a1
+
+    ; store
+%ifidn %2, v
+    movrow [dst2_reg+mstride_reg*4], m1
+    movrow [dst_reg +mstride_reg*2], m2
+    movrow [dst_reg +mstride_reg  ], m3
+    movrow    [dst_reg], m4
+    movrow   [dst2_reg], m5
+    movrow [dst2_reg+ stride_reg  ], m6
+%if mmsize == 16 && %4 == 8
+    add        dst8_reg, mstride_reg
+    movhps [dst8_reg+mstride_reg*2], m1
+    movhps [dst8_reg+mstride_reg  ], m2
+    movhps   [dst8_reg], m3
+    add        dst8_reg, stride_reg
+    movhps   [dst8_reg], m4
+    movhps [dst8_reg+ stride_reg  ], m5
+    movhps [dst8_reg+ stride_reg*2], m6
+%endif
+%else ; h
+    inc         dst_reg
+    inc        dst2_reg
+
+    ; 4x8/16 transpose
+    TRANSPOSE4x4B     1, 2, 3, 4, 0
+    SBUTTERFLY       bw, 5, 6, 0
+
+%if mmsize == 8 ; mmx/mmxext (h)
+    WRITE_4x2D        1, 2, 3, 4, dst_reg, dst2_reg, mstride_reg, stride_reg
+    add         dst_reg, 4
+    WRITE_8W         m5, m6, dst2_reg, dst_reg, mstride_reg, stride_reg, %4
+%else ; sse2 (h)
+    lea        dst8_reg, [dst8_reg+mstride_reg+1]
+    WRITE_4x4D        1, 2, 3, 4, dst_reg, dst2_reg, dst8_reg, mstride_reg, stride_reg, %4
+    lea         dst_reg, [dst2_reg+mstride_reg+4]
+    lea        dst8_reg, [dst8_reg+mstride_reg+4]
+    WRITE_8W         m5, m5, dst2_reg, dst_reg,  mstride_reg, stride_reg, %2
+%ifidn %2, sse4
+    lea        dst2_reg, [dst8_reg+ stride_reg]
+%endif
+    WRITE_8W         m6, m6, dst2_reg, dst8_reg, mstride_reg, stride_reg, %2
+%endif
+%endif
+
+%if mmsize == 8
+%if %4 == 8 ; chroma
+%ifidn %2, h
+    sub         dst_reg, 5
+%endif
+    cmp         dst_reg, dst8_reg
+    mov         dst_reg, dst8_reg
+    jnz .next8px
+%else
+%ifidn %2, h
+    lea         dst_reg, [dst_reg + stride_reg*8-5]
+%else ; v
+    add         dst_reg, 8
+%endif
+    dec         cnt_reg
+    jg .next8px
+%endif
+%endif
+
+%ifndef m8 ; sse2 on x86-32 or mmx/mmxext
+    mov             rsp, stack_reg   ; restore stack pointer
+%endif
+    RET
+%endmacro
+
+INIT_MMX
+%define SPLATB_REG SPLATB_REG_MMX
+MBEDGE_LOOPFILTER mmx,    v, 6, 16, 0
+MBEDGE_LOOPFILTER mmx,    h, 6, 16, 0
+MBEDGE_LOOPFILTER mmx,    v, 6,  8, 0
+MBEDGE_LOOPFILTER mmx,    h, 6,  8, 0
+
+%define SPLATB_REG SPLATB_REG_MMXEXT
+MBEDGE_LOOPFILTER mmxext, v, 6, 16, 0
+MBEDGE_LOOPFILTER mmxext, h, 6, 16, 0
+MBEDGE_LOOPFILTER mmxext, v, 6,  8, 0
+MBEDGE_LOOPFILTER mmxext, h, 6,  8, 0
+
+INIT_XMM
+%define SPLATB_REG SPLATB_REG_SSE2
+MBEDGE_LOOPFILTER sse2,   v, 5, 16, 16
+%ifdef m8
+MBEDGE_LOOPFILTER sse2,   h, 5, 16, 16
+%else
+MBEDGE_LOOPFILTER sse2,   h, 6, 16, 16
+%endif
+MBEDGE_LOOPFILTER sse2,   v, 6,  8, 16
+MBEDGE_LOOPFILTER sse2,   h, 6,  8, 16
+
+%define SPLATB_REG SPLATB_REG_SSSE3
+MBEDGE_LOOPFILTER ssse3,  v, 5, 16, 16
+%ifdef m8
+MBEDGE_LOOPFILTER ssse3,  h, 5, 16, 16
+%else
+MBEDGE_LOOPFILTER ssse3,  h, 6, 16, 16
+%endif
+MBEDGE_LOOPFILTER ssse3,  v, 6,  8, 16
+MBEDGE_LOOPFILTER ssse3,  h, 6,  8, 16
+
+%ifdef m8
+MBEDGE_LOOPFILTER sse4,   h, 5, 16, 16
+%else
+MBEDGE_LOOPFILTER sse4,   h, 6, 16, 16
+%endif
+MBEDGE_LOOPFILTER sse4,   h, 6,  8, 16

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/colorspace.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/colorspace.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/colorspace.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,111 @@
+/*
+ * Colorspace conversion defines
+ * Copyright (c) 2001, 2002, 2003 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Various defines for YUV<->RGB conversion
+ */
+
+#ifndef AVUTIL_COLORSPACE_H
+#define AVUTIL_COLORSPACE_H
+
+#define SCALEBITS 10
+#define ONE_HALF  (1 << (SCALEBITS - 1))
+#define FIX(x)    ((int) ((x) * (1<<SCALEBITS) + 0.5))
+
+#define YUV_TO_RGB1_CCIR(cb1, cr1)\
+{\
+    cb = (cb1) - 128;\
+    cr = (cr1) - 128;\
+    r_add = FIX(1.40200*255.0/224.0) * cr + ONE_HALF;\
+    g_add = - FIX(0.34414*255.0/224.0) * cb - FIX(0.71414*255.0/224.0) * cr + \
+            ONE_HALF;\
+    b_add = FIX(1.77200*255.0/224.0) * cb + ONE_HALF;\
+}
+
+#define YUV_TO_RGB2_CCIR(r, g, b, y1)\
+{\
+    y = ((y1) - 16) * FIX(255.0/219.0);\
+    r = cm[(y + r_add) >> SCALEBITS];\
+    g = cm[(y + g_add) >> SCALEBITS];\
+    b = cm[(y + b_add) >> SCALEBITS];\
+}
+
+#define YUV_TO_RGB1(cb1, cr1)\
+{\
+    cb = (cb1) - 128;\
+    cr = (cr1) - 128;\
+    r_add = FIX(1.40200) * cr + ONE_HALF;\
+    g_add = - FIX(0.34414) * cb - FIX(0.71414) * cr + ONE_HALF;\
+    b_add = FIX(1.77200) * cb + ONE_HALF;\
+}
+
+#define YUV_TO_RGB2(r, g, b, y1)\
+{\
+    y = (y1) << SCALEBITS;\
+    r = cm[(y + r_add) >> SCALEBITS];\
+    g = cm[(y + g_add) >> SCALEBITS];\
+    b = cm[(y + b_add) >> SCALEBITS];\
+}
+
+#define Y_CCIR_TO_JPEG(y)\
+ cm[((y) * FIX(255.0/219.0) + (ONE_HALF - 16 * FIX(255.0/219.0))) >> SCALEBITS]
+
+#define Y_JPEG_TO_CCIR(y)\
+ (((y) * FIX(219.0/255.0) + (ONE_HALF + (16 << SCALEBITS))) >> SCALEBITS)
+
+#define C_CCIR_TO_JPEG(y)\
+ cm[(((y) - 128) * FIX(127.0/112.0) + (ONE_HALF + (128 << SCALEBITS))) >> SCALEBITS]
+
+/* NOTE: the clamp is really necessary! */
+static inline int C_JPEG_TO_CCIR(int y) {
+    y = (((y - 128) * FIX(112.0/127.0) + (ONE_HALF + (128 << SCALEBITS))) >> SCALEBITS);
+    if (y < 16)
+        y = 16;
+    return y;
+}
+
+
+#define RGB_TO_Y(r, g, b) \
+((FIX(0.29900) * (r) + FIX(0.58700) * (g) + \
+  FIX(0.11400) * (b) + ONE_HALF) >> SCALEBITS)
+
+#define RGB_TO_U(r1, g1, b1, shift)\
+(((- FIX(0.16874) * r1 - FIX(0.33126) * g1 +         \
+     FIX(0.50000) * b1 + (ONE_HALF << shift) - 1) >> (SCALEBITS + shift)) + 128)
+
+#define RGB_TO_V(r1, g1, b1, shift)\
+(((FIX(0.50000) * r1 - FIX(0.41869) * g1 -           \
+   FIX(0.08131) * b1 + (ONE_HALF << shift) - 1) >> (SCALEBITS + shift)) + 128)
+
+#define RGB_TO_Y_CCIR(r, g, b) \
+((FIX(0.29900*219.0/255.0) * (r) + FIX(0.58700*219.0/255.0) * (g) + \
+  FIX(0.11400*219.0/255.0) * (b) + (ONE_HALF + (16 << SCALEBITS))) >> SCALEBITS)
+
+#define RGB_TO_U_CCIR(r1, g1, b1, shift)\
+(((- FIX(0.16874*224.0/255.0) * r1 - FIX(0.33126*224.0/255.0) * g1 +         \
+     FIX(0.50000*224.0/255.0) * b1 + (ONE_HALF << shift) - 1) >> (SCALEBITS + shift)) + 128)
+
+#define RGB_TO_V_CCIR(r1, g1, b1, shift)\
+(((FIX(0.50000*224.0/255.0) * r1 - FIX(0.41869*224.0/255.0) * g1 -           \
+   FIX(0.08131*224.0/255.0) * b1 + (ONE_HALF << shift) - 1) >> (SCALEBITS + shift)) + 128)
+
+#endif /* AVUTIL_COLORSPACE_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,591 @@
+/*
+ * Copyright (c) 2002-2006 Michael Niedermayer <michaelni at gmx.at>
+ * Copyright (c) 2006 Oded Shimon <ods15 at ods15.dyndns.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * simple arithmetic expression evaluator.
+ *
+ * see http://joe.hotchkiss.com/programming/eval/eval.html
+ */
+
+#include "libavutil/avutil.h"
+#include "eval.h"
+
+typedef struct Parser {
+    const AVClass *class;
+    int stack_index;
+    char *s;
+    const double *const_values;
+    const char * const *const_names;          // NULL terminated
+    double (* const *funcs1)(void *, double a);           // NULL terminated
+    const char * const *func1_names;          // NULL terminated
+    double (* const *funcs2)(void *, double a, double b); // NULL terminated
+    const char * const *func2_names;          // NULL terminated
+    void *opaque;
+    int log_offset;
+    void *log_ctx;
+#define VARS 10
+    double var[VARS];
+} Parser;
+
+static const AVClass class = { "Eval", av_default_item_name, NULL, LIBAVUTIL_VERSION_INT, offsetof(Parser,log_offset), offsetof(Parser,log_ctx) };
+
+static const int8_t si_prefixes['z' - 'E' + 1] = {
+    ['y'-'E']= -24,
+    ['z'-'E']= -21,
+    ['a'-'E']= -18,
+    ['f'-'E']= -15,
+    ['p'-'E']= -12,
+    ['n'-'E']= - 9,
+    ['u'-'E']= - 6,
+    ['m'-'E']= - 3,
+    ['c'-'E']= - 2,
+    ['d'-'E']= - 1,
+    ['h'-'E']=   2,
+    ['k'-'E']=   3,
+    ['K'-'E']=   3,
+    ['M'-'E']=   6,
+    ['G'-'E']=   9,
+    ['T'-'E']=  12,
+    ['P'-'E']=  15,
+    ['E'-'E']=  18,
+    ['Z'-'E']=  21,
+    ['Y'-'E']=  24,
+};
+
+double av_strtod(const char *numstr, char **tail)
+{
+    double d;
+    char *next;
+    d = strtod(numstr, &next);
+    /* if parsing succeeded, check for and interpret postfixes */
+    if (next!=numstr) {
+        if (*next >= 'E' && *next <= 'z') {
+            int e= si_prefixes[*next - 'E'];
+            if (e) {
+                if (next[1] == 'i') {
+                    d*= pow( 2, e/0.3);
+                    next+=2;
+                } else {
+                    d*= pow(10, e);
+                    next++;
+                }
+            }
+        }
+
+        if (*next=='B') {
+            d*=8;
+            next++;
+        }
+    }
+    /* if requested, fill in tail with the position after the last parsed
+       character */
+    if (tail)
+        *tail = next;
+    return d;
+}
+
+static int strmatch(const char *s, const char *prefix)
+{
+    int i;
+    for (i=0; prefix[i]; i++) {
+        if (prefix[i] != s[i]) return 0;
+    }
+    return 1;
+}
+
+struct AVExpr {
+    enum {
+        e_value, e_const, e_func0, e_func1, e_func2,
+        e_squish, e_gauss, e_ld,
+        e_mod, e_max, e_min, e_eq, e_gt, e_gte,
+        e_pow, e_mul, e_div, e_add,
+        e_last, e_st, e_while,
+    } type;
+    double value; // is sign in other types
+    union {
+        int const_index;
+        double (*func0)(double);
+        double (*func1)(void *, double);
+        double (*func2)(void *, double, double);
+    } a;
+    struct AVExpr *param[2];
+};
+
+static double eval_expr(Parser *p, AVExpr *e)
+{
+    switch (e->type) {
+        case e_value:  return e->value;
+        case e_const:  return e->value * p->const_values[e->a.const_index];
+        case e_func0:  return e->value * e->a.func0(eval_expr(p, e->param[0]));
+        case e_func1:  return e->value * e->a.func1(p->opaque, eval_expr(p, e->param[0]));
+        case e_func2:  return e->value * e->a.func2(p->opaque, eval_expr(p, e->param[0]), eval_expr(p, e->param[1]));
+        case e_squish: return 1/(1+exp(4*eval_expr(p, e->param[0])));
+        case e_gauss: { double d = eval_expr(p, e->param[0]); return exp(-d*d/2)/sqrt(2*M_PI); }
+        case e_ld:     return e->value * p->var[av_clip(eval_expr(p, e->param[0]), 0, VARS-1)];
+        case e_while: {
+            double d = NAN;
+            while (eval_expr(p, e->param[0]))
+                d=eval_expr(p, e->param[1]);
+            return d;
+        }
+        default: {
+            double d = eval_expr(p, e->param[0]);
+            double d2 = eval_expr(p, e->param[1]);
+            switch (e->type) {
+                case e_mod: return e->value * (d - floor(d/d2)*d2);
+                case e_max: return e->value * (d >  d2 ?   d : d2);
+                case e_min: return e->value * (d <  d2 ?   d : d2);
+                case e_eq:  return e->value * (d == d2 ? 1.0 : 0.0);
+                case e_gt:  return e->value * (d >  d2 ? 1.0 : 0.0);
+                case e_gte: return e->value * (d >= d2 ? 1.0 : 0.0);
+                case e_pow: return e->value * pow(d, d2);
+                case e_mul: return e->value * (d * d2);
+                case e_div: return e->value * (d / d2);
+                case e_add: return e->value * (d + d2);
+                case e_last:return e->value * d2;
+                case e_st : return e->value * (p->var[av_clip(d, 0, VARS-1)]= d2);
+            }
+        }
+    }
+    return NAN;
+}
+
+static int parse_expr(AVExpr **e, Parser *p);
+
+void av_free_expr(AVExpr *e)
+{
+    if (!e) return;
+    av_free_expr(e->param[0]);
+    av_free_expr(e->param[1]);
+    av_freep(&e);
+}
+
+static int parse_primary(AVExpr **e, Parser *p)
+{
+    AVExpr *d = av_mallocz(sizeof(AVExpr));
+    char *next = p->s, *s0 = p->s;
+    int ret, i;
+
+    if (!d)
+        return AVERROR(ENOMEM);
+
+    /* number */
+    d->value = av_strtod(p->s, &next);
+    if (next != p->s) {
+        d->type = e_value;
+        p->s= next;
+        *e = d;
+        return 0;
+    }
+    d->value = 1;
+
+    /* named constants */
+    for (i=0; p->const_names && p->const_names[i]; i++) {
+        if (strmatch(p->s, p->const_names[i])) {
+            p->s+= strlen(p->const_names[i]);
+            d->type = e_const;
+            d->a.const_index = i;
+            *e = d;
+            return 0;
+        }
+    }
+
+    p->s= strchr(p->s, '(');
+    if (p->s==NULL) {
+        av_log(p, AV_LOG_ERROR, "Undefined constant or missing '(' in '%s'\n", s0);
+        p->s= next;
+        av_free_expr(d);
+        return AVERROR(EINVAL);
+    }
+    p->s++; // "("
+    if (*next == '(') { // special case do-nothing
+        av_freep(&d);
+        if ((ret = parse_expr(&d, p)) < 0)
+            return ret;
+        if (p->s[0] != ')') {
+            av_log(p, AV_LOG_ERROR, "Missing ')' in '%s'\n", s0);
+            av_free_expr(d);
+            return AVERROR(EINVAL);
+        }
+        p->s++; // ")"
+        *e = d;
+        return 0;
+    }
+    if ((ret = parse_expr(&(d->param[0]), p)) < 0) {
+        av_free_expr(d);
+        return ret;
+    }
+    if (p->s[0]== ',') {
+        p->s++; // ","
+        parse_expr(&d->param[1], p);
+    }
+    if (p->s[0] != ')') {
+        av_log(p, AV_LOG_ERROR, "Missing ')' or too many args in '%s'\n", s0);
+        av_free_expr(d);
+        return AVERROR(EINVAL);
+    }
+    p->s++; // ")"
+
+    d->type = e_func0;
+         if (strmatch(next, "sinh"  )) d->a.func0 = sinh;
+    else if (strmatch(next, "cosh"  )) d->a.func0 = cosh;
+    else if (strmatch(next, "tanh"  )) d->a.func0 = tanh;
+    else if (strmatch(next, "sin"   )) d->a.func0 = sin;
+    else if (strmatch(next, "cos"   )) d->a.func0 = cos;
+    else if (strmatch(next, "tan"   )) d->a.func0 = tan;
+    else if (strmatch(next, "atan"  )) d->a.func0 = atan;
+    else if (strmatch(next, "asin"  )) d->a.func0 = asin;
+    else if (strmatch(next, "acos"  )) d->a.func0 = acos;
+    else if (strmatch(next, "exp"   )) d->a.func0 = exp;
+    else if (strmatch(next, "log"   )) d->a.func0 = log;
+    else if (strmatch(next, "abs"   )) d->a.func0 = fabs;
+    else if (strmatch(next, "squish")) d->type = e_squish;
+    else if (strmatch(next, "gauss" )) d->type = e_gauss;
+    else if (strmatch(next, "mod"   )) d->type = e_mod;
+    else if (strmatch(next, "max"   )) d->type = e_max;
+    else if (strmatch(next, "min"   )) d->type = e_min;
+    else if (strmatch(next, "eq"    )) d->type = e_eq;
+    else if (strmatch(next, "gte"   )) d->type = e_gte;
+    else if (strmatch(next, "gt"    )) d->type = e_gt;
+    else if (strmatch(next, "lte"   )) { AVExpr *tmp = d->param[1]; d->param[1] = d->param[0]; d->param[0] = tmp; d->type = e_gt; }
+    else if (strmatch(next, "lt"    )) { AVExpr *tmp = d->param[1]; d->param[1] = d->param[0]; d->param[0] = tmp; d->type = e_gte; }
+    else if (strmatch(next, "ld"    )) d->type = e_ld;
+    else if (strmatch(next, "st"    )) d->type = e_st;
+    else if (strmatch(next, "while" )) d->type = e_while;
+    else {
+        for (i=0; p->func1_names && p->func1_names[i]; i++) {
+            if (strmatch(next, p->func1_names[i])) {
+                d->a.func1 = p->funcs1[i];
+                d->type = e_func1;
+                *e = d;
+                return 0;
+            }
+        }
+
+        for (i=0; p->func2_names && p->func2_names[i]; i++) {
+            if (strmatch(next, p->func2_names[i])) {
+                d->a.func2 = p->funcs2[i];
+                d->type = e_func2;
+                *e = d;
+                return 0;
+            }
+        }
+
+        av_log(p, AV_LOG_ERROR, "Unknown function in '%s'\n", s0);
+        av_free_expr(d);
+        return AVERROR(EINVAL);
+    }
+
+    *e = d;
+    return 0;
+}
+
+static AVExpr *new_eval_expr(int type, int value, AVExpr *p0, AVExpr *p1)
+{
+    AVExpr *e = av_mallocz(sizeof(AVExpr));
+    if (!e)
+        return NULL;
+    e->type     =type   ;
+    e->value    =value  ;
+    e->param[0] =p0     ;
+    e->param[1] =p1     ;
+    return e;
+}
+
+static int parse_pow(AVExpr **e, Parser *p, int *sign)
+{
+    *sign= (*p->s == '+') - (*p->s == '-');
+    p->s += *sign&1;
+    return parse_primary(e, p);
+}
+
+static int parse_factor(AVExpr **e, Parser *p)
+{
+    int sign, sign2, ret;
+    AVExpr *e0, *e1, *e2;
+    if ((ret = parse_pow(&e0, p, &sign)) < 0)
+        return ret;
+    while(p->s[0]=='^'){
+        e1 = e0;
+        p->s++;
+        if ((ret = parse_pow(&e2, p, &sign2)) < 0) {
+            av_free_expr(e1);
+            return ret;
+        }
+        e0 = new_eval_expr(e_pow, 1, e1, e2);
+        if (!e0) {
+            av_free_expr(e1);
+            av_free_expr(e2);
+            return AVERROR(ENOMEM);
+        }
+        if (e0->param[1]) e0->param[1]->value *= (sign2|1);
+    }
+    if (e0) e0->value *= (sign|1);
+
+    *e = e0;
+    return 0;
+}
+
+static int parse_term(AVExpr **e, Parser *p)
+{
+    int ret;
+    AVExpr *e0, *e1, *e2;
+    if ((ret = parse_factor(&e0, p)) < 0)
+        return ret;
+    while (p->s[0]=='*' || p->s[0]=='/') {
+        int c= *p->s++;
+        e1 = e0;
+        if ((ret = parse_factor(&e2, p)) < 0) {
+            av_free_expr(e1);
+            return ret;
+        }
+        e0 = new_eval_expr(c == '*' ? e_mul : e_div, 1, e1, e2);
+        if (!e0) {
+            av_free_expr(e1);
+            av_free_expr(e2);
+            return AVERROR(ENOMEM);
+        }
+    }
+    *e = e0;
+    return 0;
+}
+
+static int parse_subexpr(AVExpr **e, Parser *p)
+{
+    int ret;
+    AVExpr *e0, *e1, *e2;
+    if ((ret = parse_term(&e0, p)) < 0)
+        return ret;
+    while (*p->s == '+' || *p->s == '-') {
+        e1 = e0;
+        if ((ret = parse_term(&e2, p)) < 0) {
+            av_free_expr(e1);
+            return ret;
+        }
+        e0 = new_eval_expr(e_add, 1, e1, e2);
+        if (!e0) {
+            av_free_expr(e1);
+            av_free_expr(e2);
+            return AVERROR(ENOMEM);
+        }
+    };
+
+    *e = e0;
+    return 0;
+}
+
+static int parse_expr(AVExpr **e, Parser *p)
+{
+    int ret;
+    AVExpr *e0, *e1, *e2;
+    if (p->stack_index <= 0) //protect against stack overflows
+        return AVERROR(EINVAL);
+    p->stack_index--;
+
+    if ((ret = parse_subexpr(&e0, p)) < 0)
+        return ret;
+    while (*p->s == ';') {
+        e1 = e0;
+        if ((ret = parse_subexpr(&e2, p)) < 0) {
+            av_free_expr(e1);
+            return ret;
+        }
+        p->s++;
+        e0 = new_eval_expr(e_last, 1, e1, e2);
+        if (!e0) {
+            av_free_expr(e1);
+            av_free_expr(e2);
+            return AVERROR(ENOMEM);
+        }
+    };
+
+    p->stack_index++;
+    *e = e0;
+    return 0;
+}
+
+static int verify_expr(AVExpr *e)
+{
+    if (!e) return 0;
+    switch (e->type) {
+        case e_value:
+        case e_const: return 1;
+        case e_func0:
+        case e_func1:
+        case e_squish:
+        case e_ld:
+        case e_gauss: return verify_expr(e->param[0]);
+        default: return verify_expr(e->param[0]) && verify_expr(e->param[1]);
+    }
+}
+
+int av_parse_expr(AVExpr **expr, const char *s,
+                  const char * const *const_names,
+                  const char * const *func1_names, double (* const *funcs1)(void *, double),
+                  const char * const *func2_names, double (* const *funcs2)(void *, double, double),
+                  int log_offset, void *log_ctx)
+{
+    Parser p;
+    AVExpr *e = NULL;
+    char *w = av_malloc(strlen(s) + 1);
+    char *wp = w;
+    const char *s0 = s;
+    int ret = 0;
+
+    if (!w)
+        return AVERROR(ENOMEM);
+
+    while (*s)
+        if (!isspace(*s++)) *wp++ = s[-1];
+    *wp++ = 0;
+
+    p.class      = &class;
+    p.stack_index=100;
+    p.s= w;
+    p.const_names = const_names;
+    p.funcs1      = funcs1;
+    p.func1_names = func1_names;
+    p.funcs2      = funcs2;
+    p.func2_names = func2_names;
+    p.log_offset = log_offset;
+    p.log_ctx    = log_ctx;
+
+    if ((ret = parse_expr(&e, &p)) < 0)
+        goto end;
+    if (*p.s) {
+        av_log(&p, AV_LOG_ERROR, "Invalid chars '%s' at the end of expression '%s'\n", p.s, s0);
+        ret = AVERROR(EINVAL);
+        goto end;
+    }
+    if (!verify_expr(e)) {
+        av_free_expr(e);
+        ret = AVERROR(EINVAL);
+        goto end;
+    }
+    *expr = e;
+end:
+    av_free(w);
+    return ret;
+}
+
+double av_eval_expr(AVExpr *e, const double *const_values, void *opaque)
+{
+    Parser p;
+
+    p.const_values = const_values;
+    p.opaque     = opaque;
+    return eval_expr(&p, e);
+}
+
+int av_parse_and_eval_expr(double *d, const char *s,
+                           const char * const *const_names, const double *const_values,
+                           const char * const *func1_names, double (* const *funcs1)(void *, double),
+                           const char * const *func2_names, double (* const *funcs2)(void *, double, double),
+                           void *opaque, int log_offset, void *log_ctx)
+{
+    AVExpr *e = NULL;
+    int ret = av_parse_expr(&e, s, const_names, func1_names, funcs1, func2_names, funcs2, log_offset, log_ctx);
+
+    if (ret < 0) {
+        *d = NAN;
+        return ret;
+    }
+    *d = av_eval_expr(e, const_values, opaque);
+    av_free_expr(e);
+    return isnan(*d) ? AVERROR(EINVAL) : 0;
+}
+
+#ifdef TEST
+#undef printf
+static double const_values[] = {
+    M_PI,
+    M_E,
+    0
+};
+
+static const char *const_names[] = {
+    "PI",
+    "E",
+    0
+};
+
+int main(void)
+{
+    int i;
+    double d;
+    const char **expr, *exprs[] = {
+        "",
+        "1+(5-2)^(3-1)+1/2+sin(PI)-max(-2.2,-3.1)",
+        "80G/80Gi"
+        "1k",
+        "1Gi",
+        "1gi",
+        "1GiFoo",
+        "1k+1k",
+        "1Gi*3foo",
+        "foo",
+        "foo(",
+        "foo()",
+        "foo)",
+        "sin",
+        "sin(",
+        "sin()",
+        "sin)",
+        "sin 10",
+        "sin(1,2,3)",
+        "sin(1 )",
+        "1",
+        "1foo",
+        "bar + PI + E + 100f*2 + foo",
+        "13k + 12f - foo(1, 2)",
+        "1gi",
+        "1Gi",
+        NULL
+    };
+
+    for (expr = exprs; *expr; expr++) {
+        printf("Evaluating '%s'\n", *expr);
+        av_parse_and_eval_expr(&d, *expr,
+                               const_names, const_values,
+                               NULL, NULL, NULL, NULL, NULL, 0, NULL);
+        printf("'%s' -> %f\n\n", *expr, d);
+    }
+
+    av_parse_and_eval_expr(&d, "1+(5-2)^(3-1)+1/2+sin(PI)-max(-2.2,-3.1)",
+                           const_names, const_values,
+                           NULL, NULL, NULL, NULL, NULL, 0, NULL);
+    printf("%f == 12.7\n", d);
+    av_parse_and_eval_expr(&d, "80G/80Gi",
+                           const_names, const_values,
+                           NULL, NULL, NULL, NULL, NULL, 0, NULL);
+    printf("%f == 0.931322575\n", d);
+
+    for (i=0; i<1050; i++) {
+        START_TIMER
+            av_parse_and_eval_expr(&d, "1+(5-2)^(3-1)+1/2+sin(PI)-max(-2.2,-3.1)",
+                                   const_names, const_values,
+                                   NULL, NULL, NULL, NULL, NULL, 0, NULL);
+        STOP_TIMER("av_parse_and_eval_expr")
+    }
+    return 0;
+}
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2002 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * simple arithmetic expression evaluator
+ */
+
+#ifndef AVUTIL_EVAL_H
+#define AVUTIL_EVAL_H
+
+typedef struct AVExpr AVExpr;
+
+/**
+ * Parse and evaluate an expression.
+ * Note, this is significantly slower than av_eval_expr().
+ *
+ * @param res a pointer to a double where is put the result value of
+ * the expression, or NAN in case of error
+ * @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
+ * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
+ * @param const_values a zero terminated array of values for the identifiers from const_names
+ * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
+ * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
+ * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
+ * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
+ * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
+ * @param log_ctx parent logging context
+ * @return 0 in case of success, a negative value corresponding to an
+ * AVERROR code otherwise
+ */
+int av_parse_and_eval_expr(double *res, const char *s,
+                           const char * const *const_names, const double *const_values,
+                           const char * const *func1_names, double (* const *funcs1)(void *, double),
+                           const char * const *func2_names, double (* const *funcs2)(void *, double, double),
+                           void *opaque, int log_offset, void *log_ctx);
+
+/**
+ * Parse an expression.
+ *
+ * @param expr a pointer where is put an AVExpr containing the parsed
+ * value in case of successfull parsing, or NULL otherwise.
+ * The pointed to AVExpr must be freed with av_free_expr() by the user
+ * when it is not needed anymore.
+ * @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
+ * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
+ * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
+ * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
+ * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
+ * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
+ * @param log_ctx parent logging context
+ * @return 0 in case of success, a negative value corresponding to an
+ * AVERROR code otherwise
+ */
+int av_parse_expr(AVExpr **expr, const char *s,
+                  const char * const *const_names,
+                  const char * const *func1_names, double (* const *funcs1)(void *, double),
+                  const char * const *func2_names, double (* const *funcs2)(void *, double, double),
+                  int log_offset, void *log_ctx);
+
+/**
+ * Evaluate a previously parsed expression.
+ *
+ * @param const_values a zero terminated array of values for the identifiers from av_parse_expr() const_names
+ * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
+ * @return the value of the expression
+ */
+double av_eval_expr(AVExpr *e, const double *const_values, void *opaque);
+
+/**
+ * Free a parsed expression previously created with av_parse_expr().
+ */
+void av_free_expr(AVExpr *e);
+
+/**
+ * Parse the string in numstr and return its value as a double. If
+ * the string is empty, contains only whitespaces, or does not contain
+ * an initial substring that has the expected syntax for a
+ * floating-point number, no conversion is performed. In this case,
+ * returns a value of zero and the value returned in tail is the value
+ * of numstr.
+ *
+ * @param numstr a string representing a number, may contain one of
+ * the International System number postfixes, for example 'K', 'M',
+ * 'G'. If 'i' is appended after the postfix, powers of 2 are used
+ * instead of powers of 10. The 'B' postfix multiplies the value for
+ * 8, and can be appended after another postfix or used alone. This
+ * allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.
+ * @param tail if non-NULL puts here the pointer to the char next
+ * after the last parsed character
+ */
+double av_strtod(const char *numstr, char **tail);
+
+#endif /* AVUTIL_EVAL_H */



From mean at mail.berlios.de  Sun Jul 25 12:07:41 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 25 Jul 2010 12:07:41 +0200
Subject: [Avidemux-svn-commit] r6479 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config
Message-ID: <20100725100741.B6E49480E6C@sheep.berlios.de>

Author: mean
Date: 2010-07-25 12:07:41 +0200 (Sun, 25 Jul 2010)
New Revision: 6479

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c
Log:
[ffmpeg] Update 25 july

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h	2010-07-25 10:07:39 UTC (rev 6478)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h	2010-07-25 10:07:41 UTC (rev 6479)
@@ -9,6 +9,7 @@
 #define CONFIG_VC1_DXVA2_HWACCEL 0
 #define CONFIG_VC1_DXVA2_HWACCEL 0
 #define CONFIG_WMV3_DXVA2_HWACCEL 0
+#define CONFIG_MPEG2_DXVA2_HWACCEL 0
 #ifdef USE_VDPAU
 #define CONFIG_H264_VDPAU_DECODER 1
 #define CONFIG_MPEG_VDPAU_DECODER 1
@@ -88,6 +89,12 @@
 #define CONFIG_MP3FLOAT_DECODER 1
 #define CONFIG_INDEO5_DECODER 1
 #define CONFIG_INDEO5_DECODER 1
+#define CONFIG_VP8_DECODER 1
+#define CONFIG_LIBVPX_DECODER 0
+#define CONFIG_GSM_MS_DECODER 0
+#define CONFIG_GSM_DECODER 0
+#define CONFIG_ANSI_DECODER 0
+#define CONFIG_PICTOR_DECODER 0
 #define CONFIG_MP3ADUFLOAT_DECODER 0
 #define CONFIG_MP3ON4FLOAT_DECODER 0
 #define CONFIG_CDGRAPHICS_DECODER 0
@@ -298,6 +305,7 @@
 #define CONFIG_ADPCM_YAMAHA_DECODER 0
 #define CONFIG_DVDSUB_DECODER 0
 #define CONFIG_LIBVORBIS_DECODER 0
+#define CONFIG_VP8_PARSER 1
 #define CONFIG_AAC_PARSER 1
 #define CONFIG_H263_PARSER 1
 #define CONFIG_H264_PARSER 1
@@ -334,6 +342,8 @@
 #define CONFIG_HUFFYUV_ENCODER 1
 #define CONFIG_DVBSUB_ENCODER 1
 #define CONFIG_SNOW_ENCODER 1
+#define CONFIG_LIBVPX_ENCODER 0
+#define CONFIG_RA_144_ENCODER 0
 #define CONFIG_XSUB_ENCODER 0
 #define CONFIG_V210_ENCODER 0
 #define CONFIG_LIBOPENCORE_AMRNB_ENCODER 0
@@ -444,6 +454,8 @@
 #define CONFIG_MOV2TEXTSUB_BSF 0
 #define CONFIG_TEXT2MOVSUB_BSF 0
 #define CONFIG_MUXERS 1
+#define CONFIG_MATROSKA_MUXER 1
+#define CONFIG_WEBM_MUXER 1
 #define CONFIG_MOV_MUXER 1
 #define CONFIG_IPOD_MUXER 1
 #define CONFIG_MP4_MUXER 1
@@ -557,7 +569,10 @@
 #define ENABLE_YASM      0
 #define HAVE_YASM        0
 #endif // USE_YASM
+#define CONFIG_FILE_PROTOCOL  1
 #define CONFIG_MDCT     1
+#define CONFIG_DCT      1
+#define CONFIG_LPC      1
 #define CONFIG_H264DSP  1
 #define ENABLE_ARM      0
 #define ENABLE_PPC      0

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c	2010-07-25 10:07:39 UTC (rev 6478)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c	2010-07-25 10:07:41 UTC (rev 6479)
@@ -22,6 +22,7 @@
     DECLARE_HW(VC1_DXVA2,nellymoser);
     DECLARE_HW(VC1_DXVA2,nellymoser);
     DECLARE_HW(WMV3_DXVA2,nellymoser);
+    DECLARE_HW(MPEG2_DXVA2,nellymoser);
 
 #define DECLARE_VDPAU(a,b); printf("#define CONFIG_"#a"_VDPAU_DECODER 1\n");
         printf("#ifdef USE_VDPAU\n");
@@ -111,9 +112,15 @@
     DECLARE_DECODER (MP3FLOAT, indeo5);
     DECLARE_DECODER (INDEO5, indeo5);
     DECLARE_DECODER (INDEO5, indeo5);
+    DECLARE_DECODER (VP8, indeo5);
 #undef DECLARE_DECODER
 #define DECLARE_DECODER(a,b); printf("#define CONFIG_"#a"_DECODER 0\n"); 
 
+    DECLARE_DECODER (LIBVPX, indeo5);
+    DECLARE_DECODER (GSM_MS, indeo5);
+    DECLARE_DECODER (GSM, indeo5);
+    DECLARE_DECODER (ANSI, indeo5);
+    DECLARE_DECODER (PICTOR, indeo5);
     DECLARE_DECODER (MP3ADUFLOAT, indeo5);
     DECLARE_DECODER (MP3ON4FLOAT, indeo5);
     DECLARE_DECODER(CDGRAPHICS, eatgq);
@@ -336,6 +343,7 @@
 	DECLARE_DECODER (LIBVORBIS, libvorbis);
 
 #define DECLARE_PARSER(a,b); printf("#define CONFIG_"#a"_PARSER 1\n"); 
+    DECLARE_PARSER (VP8, aac);
     DECLARE_PARSER (AAC, aac);
     DECLARE_PARSER (H263, h263);
     DECLARE_PARSER (H264, h264);
@@ -381,6 +389,8 @@
 
 #undef DECLARE_ENCODER
 #define DECLARE_ENCODER(a,b); printf("#define CONFIG_"#a"_ENCODER 0\n"); 
+    DECLARE_ENCODER(LIBVPX, amv);
+    DECLARE_ENCODER(RA_144, amv);
     DECLARE_ENCODER(XSUB, amv);
     DECLARE_ENCODER(V210, amv);
     DECLARE_ENCODER(LIBOPENCORE_AMRNB, amv);
@@ -500,6 +510,8 @@
 #define DECLARE_MUXER(a,b); printf("#define CONFIG_"#a"_MUXER 1\n");
 
 	printf("#define CONFIG_MUXERS 1\n");
+	DECLARE_MUXER(MATROSKA, mov)
+	DECLARE_MUXER(WEBM, mov)
 	DECLARE_MUXER(MOV, mov)
 	DECLARE_MUXER(IPOD, mov)
 	DECLARE_MUXER(MP4, mp4)
@@ -635,7 +647,10 @@
         printf("#define HAVE_YASM        0\n");
         printf("#endif // USE_YASM\n");
 
+	printf("#define CONFIG_FILE_PROTOCOL  1\n");
 	printf("#define CONFIG_MDCT     1\n");
+	printf("#define CONFIG_DCT      1\n");
+	printf("#define CONFIG_LPC      1\n");
 	printf("#define CONFIG_H264DSP  1\n");
         printf("#define ENABLE_ARM      0\n");
         printf("#define ENABLE_PPC      0\n");



From mean at mail.berlios.de  Sun Jul 25 12:07:43 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 25 Jul 2010 12:07:43 +0200
Subject: [Avidemux-svn-commit] r6480 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:
	libavutil patches patches/avutils
Message-ID: <20100725100743.8D774480E6C@sheep.berlios.de>

Author: mean
Date: 2010-07-25 12:07:43 +0200 (Sun, 25 Jul 2010)
New Revision: 6480

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/inverse.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/avutil.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/internal.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/lfg.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/lfg.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/libm.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/mem.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/timer.h.patch
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sha1.c
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avutil.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/internal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/libm.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/timer.h
Log:
[ffmpeg] update 25 July , avutil

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/CMakeLists.txt	2010-07-25 10:07:41 UTC (rev 6479)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/CMakeLists.txt	2010-07-25 10:07:43 UTC (rev 6480)
@@ -1,6 +1,7 @@
 SET(ADM_LIB ADM_libavutil6)
 
 SET(${ADM_LIB}_SRCS 
+eval.c
 adler32.c
 aes.c
 base64.c
@@ -18,13 +19,13 @@
 random_seed.c
 rational.c
 rc4.c
-sha1.c
 #string.c
 avstring.c
 tree.c
 lfg.c
 mem.c
 pixdesc.c
+sha.c
 )
 
 ADD_LIBRARY(${ADM_LIB} SHARED ${${ADM_LIB}_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avutil.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avutil.h	2010-07-25 10:07:41 UTC (rev 6479)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avutil.h	2010-07-25 10:07:43 UTC (rev 6480)
@@ -26,7 +26,14 @@
  * external API header
  */
 
+/* MEANX
+ * - */
+#define ASMALIGN(ZEROBITS) ".p2align " #ZEROBITS "\n\t"
+/* /MEANX
+ */
 
+
+
 #define AV_STRINGIFY(s)         AV_TOSTRING(s)
 #define AV_TOSTRING(s) #s
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/internal.h	2010-07-25 10:07:41 UTC (rev 6479)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/internal.h	2010-07-25 10:07:43 UTC (rev 6480)
@@ -34,7 +34,11 @@
 #include <stdint.h>
 #include <stddef.h>
 #include <assert.h>
+//MEANX
+#ifndef ADM_NO_CONFIG_H
 #include "config.h"
+#endif
+// /MEANX
 #include "attributes.h"
 #include "timer.h"
 
@@ -101,6 +105,8 @@
 #endif
 
 /* Use to export labels from asm. */
+#include "ADM_mangle.h"
+#if 0 // MEANX
 #define LABEL_MANGLE(a) EXTERN_PREFIX #a
 
 // Use rip-relative addressing if compiling PIC code on x86-64.
@@ -111,7 +117,7 @@
 #endif
 
 #define MANGLE(a) EXTERN_PREFIX LOCAL_MANGLE(a)
-
+#endif // MEANX
 /* debug stuff */
 
 /* dprintf macros */
@@ -140,12 +146,14 @@
 #endif
 
 /* avoid usage of dangerous/inappropriate system functions */
+#if 0 //MEANX
 #undef  malloc
 #define malloc please_use_av_malloc
 #undef  free
 #define free please_use_av_free
 #undef  realloc
 #define realloc please_use_av_realloc
+#endif
 #undef  time
 #define time time_is_forbidden_due_to_security_issues
 #undef  rand

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/inverse.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/inverse.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/inverse.c	2010-07-25 10:07:43 UTC (rev 6480)
@@ -0,0 +1,60 @@
+/*
+ * Inverse table
+ * Copyright (c) 2002-2004 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/intmath.h"
+
+/* a*inverse[b]>>32 == a/b for all 0<=a<=16909558 && 2<=b<=256
+ * for a>16909558, is an overestimate by less than 1 part in 1<<24 */
+const uint32_t ff_inverse[257]={
+         0, 4294967295U,2147483648U,1431655766, 1073741824,  858993460,  715827883,  613566757,
+ 536870912,  477218589,  429496730,  390451573,  357913942,  330382100,  306783379,  286331154,
+ 268435456,  252645136,  238609295,  226050911,  214748365,  204522253,  195225787,  186737709,
+ 178956971,  171798692,  165191050,  159072863,  153391690,  148102321,  143165577,  138547333,
+ 134217728,  130150525,  126322568,  122713352,  119304648,  116080198,  113025456,  110127367,
+ 107374183,  104755300,  102261127,   99882961,   97612894,   95443718,   93368855,   91382283,
+  89478486,   87652394,   85899346,   84215046,   82595525,   81037119,   79536432,   78090315,
+  76695845,   75350304,   74051161,   72796056,   71582789,   70409300,   69273667,   68174085,
+  67108864,   66076420,   65075263,   64103990,   63161284,   62245903,   61356676,   60492498,
+  59652324,   58835169,   58040099,   57266231,   56512728,   55778797,   55063684,   54366675,
+  53687092,   53024288,   52377650,   51746594,   51130564,   50529028,   49941481,   49367441,
+  48806447,   48258060,   47721859,   47197443,   46684428,   46182445,   45691142,   45210183,
+  44739243,   44278014,   43826197,   43383509,   42949673,   42524429,   42107523,   41698712,
+  41297763,   40904451,   40518560,   40139882,   39768216,   39403370,   39045158,   38693400,
+  38347923,   38008561,   37675152,   37347542,   37025581,   36709123,   36398028,   36092163,
+  35791395,   35495598,   35204650,   34918434,   34636834,   34359739,   34087043,   33818641,
+  33554432,   33294321,   33038210,   32786010,   32537632,   32292988,   32051995,   31814573,
+  31580642,   31350127,   31122952,   30899046,   30678338,   30460761,   30246249,   30034737,
+  29826162,   29620465,   29417585,   29217465,   29020050,   28825284,   28633116,   28443493,
+  28256364,   28071682,   27889399,   27709467,   27531842,   27356480,   27183338,   27012373,
+  26843546,   26676816,   26512144,   26349493,   26188825,   26030105,   25873297,   25718368,
+  25565282,   25414008,   25264514,   25116768,   24970741,   24826401,   24683721,   24542671,
+  24403224,   24265352,   24129030,   23994231,   23860930,   23729102,   23598722,   23469767,
+  23342214,   23216040,   23091223,   22967740,   22845571,   22724695,   22605092,   22486740,
+  22369622,   22253717,   22139007,   22025474,   21913099,   21801865,   21691755,   21582751,
+  21474837,   21367997,   21262215,   21157475,   21053762,   20951060,   20849356,   20748635,
+  20648882,   20550083,   20452226,   20355296,   20259280,   20164166,   20069941,   19976593,
+  19884108,   19792477,   19701685,   19611723,   19522579,   19434242,   19346700,   19259944,
+  19173962,   19088744,   19004281,   18920561,   18837576,   18755316,   18673771,   18592933,
+  18512791,   18433337,   18354562,   18276457,   18199014,   18122225,   18046082,   17970575,
+  17895698,   17821442,   17747799,   17674763,   17602325,   17530479,   17459217,   17388532,
+  17318417,   17248865,   17179870,   17111424,   17043522,   16976156,   16909321,   16843010,
+  16777216
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.c	2010-07-25 10:07:41 UTC (rev 6479)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.c	2010-07-25 10:07:43 UTC (rev 6480)
@@ -39,7 +39,7 @@
         c->state[i+2]= AV_RL32(tmp+8);
         c->state[i+3]= AV_RL32(tmp+12);
     }
-    c->index=0;
+    c->xindex=0;
 }
 
 void av_bmg_get(AVLFG *lfg, double out[2])

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.h	2010-07-25 10:07:41 UTC (rev 6479)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.h	2010-07-25 10:07:43 UTC (rev 6480)
@@ -24,7 +24,7 @@
 
 typedef struct {
     unsigned int state[64];
-    int index;
+    int xindex;
 } AVLFG;
 
 void av_lfg_init(AVLFG *c, unsigned int seed);
@@ -36,8 +36,8 @@
  * it may be good enough and faster for your specific use case.
  */
 static inline unsigned int av_lfg_get(AVLFG *c){
-    c->state[c->index & 63] = c->state[(c->index-24) & 63] + c->state[(c->index-55) & 63];
-    return c->state[c->index++ & 63];
+    c->state[c->xindex & 63] = c->state[(c->xindex-24) & 63] + c->state[(c->xindex-55) & 63];
+    return c->state[c->xindex++ & 63];
 }
 
 /**
@@ -46,9 +46,9 @@
  * Please also consider av_lfg_get() above, it is faster.
  */
 static inline unsigned int av_mlfg_get(AVLFG *c){
-    unsigned int a= c->state[(c->index-55) & 63];
-    unsigned int b= c->state[(c->index-24) & 63];
-    return c->state[c->index++ & 63] = 2*a*b+a+b;
+    unsigned int a= c->state[(c->xindex-55) & 63];
+    unsigned int b= c->state[(c->xindex-24) & 63];
+    return c->state[c->xindex++ & 63] = 2*a*b+a+b;
 }
 
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/libm.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/libm.h	2010-07-25 10:07:41 UTC (rev 6479)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/libm.h	2010-07-25 10:07:43 UTC (rev 6480)
@@ -25,7 +25,11 @@
 #define AVUTIL_LIBM_H
 
 #include <math.h>
+//MEANX
+#ifndef ADM_NO_CONFIG_H
 #include "config.h"
+#endif
+///MEANX
 #include "attributes.h"
 
 #if !HAVE_EXP2

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.c	2010-07-25 10:07:41 UTC (rev 6479)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.c	2010-07-25 10:07:43 UTC (rev 6480)
@@ -63,87 +63,110 @@
 
 void *av_malloc(unsigned int size)
 {
-    void *ptr = NULL;
-#if CONFIG_MEMALIGN_HACK
-    long diff;
-#endif
+#ifdef __APPLE__
+	return malloc(size);
+#else
+	char *c;
 
-    /* let's disallow possible ambiguous cases */
-    if(size > (INT_MAX-16) )
-        return NULL;
+	uint64_t l, lorg;
+	uint32_t *backdoor;
 
-#if CONFIG_MEMALIGN_HACK
-    ptr = malloc(size+16);
-    if(!ptr)
-        return ptr;
-    diff= ((-(long)ptr - 1)&15) + 1;
-    ptr = (char*)ptr + diff;
-    ((char*)ptr)[-1]= diff;
-#elif HAVE_POSIX_MEMALIGN
-    if (posix_memalign(&ptr,16,size))
-        ptr = NULL;
-#elif HAVE_MEMALIGN
-    ptr = memalign(16,size);
-    /* Why 64?
-       Indeed, we should align it:
-         on 4 for 386
-         on 16 for 486
-         on 32 for 586, PPro - K6-III
-         on 64 for K7 (maybe for P3 too).
-       Because L1 and L2 caches are aligned on those values.
-       But I don't want to code such logic here!
-     */
-     /* Why 16?
-        Because some CPUs need alignment, for example SSE2 on P4, & most RISC CPUs
-        it will just trigger an exception and the unaligned load will be done in the
-        exception handler or it will just segfault (SSE2 on P4).
-        Why not larger? Because I did not see a difference in benchmarks ...
-     */
-     /* benchmarks with P3
-        memalign(64)+1          3071,3051,3032
-        memalign(64)+2          3051,3032,3041
-        memalign(64)+4          2911,2896,2915
-        memalign(64)+8          2545,2554,2550
-        memalign(64)+16         2543,2572,2563
-        memalign(64)+32         2546,2545,2571
-        memalign(64)+64         2570,2533,2558
+	l = (uint64_t)malloc(size + 32);
 
-        BTW, malloc seems to do 8-byte alignment by default here.
-     */
-#else
-    ptr = malloc(size);
+	// Get next boundary
+	lorg = l;
+	l = (l + 15) & 0xfffffffffffffff0LL;
+	l += 16;
+	c = (char*)l;
+	backdoor = (uint32_t*)(c - 8);
+	*backdoor = (0xdead << 16) + l - lorg;
+	backdoor[1] = size;
+
+	return c;
 #endif
-    return ptr;
 }
 
-void *av_realloc(void *ptr, unsigned int size)
+void *av_realloc(void *ptr, unsigned int newsize)
 {
-#if CONFIG_MEMALIGN_HACK
-    int diff;
-#endif
+#ifdef __APPLE__
+	if (!ptr)
+		return av_malloc(newsize);
 
-    /* let's disallow possible ambiguous cases */
-    if(size > (INT_MAX-16) )
-        return NULL;
+	if (!newsize)
+	{
+		av_free(ptr);
+		return NULL;
+	}
 
-#if CONFIG_MEMALIGN_HACK
-    //FIXME this isn't aligned correctly, though it probably isn't needed
-    if(!ptr) return av_malloc(size);
-    diff= ((char*)ptr)[-1];
-    return (char*)realloc((char*)ptr - diff, size + diff) + diff;
+	return realloc(ptr, newsize);
 #else
-    return realloc(ptr, size);
+	void *nalloc;
+
+	if (!ptr)
+		return av_malloc(newsize);
+
+	if (!newsize) 
+	{
+		av_free(ptr);
+		return NULL;
+	}
+
+	// now we either shrink them or expand them
+	// in case of shrink, we do nothing
+	// in case of expand we have to copy
+	// Do copy everytime (slower)
+	uint32_t *backdoor;
+	uint32_t size, offset;
+	char *c = (char*)ptr;
+
+	backdoor = (uint32_t*)ptr;
+	backdoor -= 2;
+
+	assert(((*backdoor) >> 16) == 0xdead);
+
+	offset = backdoor[0] & 0xffff;
+	size = backdoor[1];
+
+	if(size >= newsize) // do nothing
+		return ptr;
+
+	// Allocate a new one
+	nalloc = av_malloc(newsize);
+	memcpy(nalloc, ptr, size);
+	av_free(ptr);
+
+	return nalloc;
 #endif
 }
 
 void av_free(void *ptr)
 {
-    /* XXX: this test should not be needed on most libcs */
-    if (ptr)
-#if CONFIG_MEMALIGN_HACK
-        free((char*)ptr - ((char*)ptr)[-1]);
+#ifdef __APPLE__
+	if (!ptr)
+		return;
+
+	free(ptr);
 #else
-        free(ptr);
+	uint32_t *backdoor;
+	uint32_t size, offset;
+	char *c = (char*)ptr;
+
+	if (!ptr)
+		return;
+
+	backdoor = (uint32_t*)ptr;
+	backdoor -= 2;
+
+	if (*backdoor == 0xbeefbeef)
+		assert(0);
+
+	assert(((*backdoor) >> 16) == 0xdead);
+
+	offset = backdoor[0] & 0xffff;
+	size = backdoor[1];
+	*backdoor = 0xbeefbeef; // Scratch sig
+
+	free(c - offset);
 #endif
 }
 

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sha1.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sha1.c	2010-07-25 10:07:41 UTC (rev 6479)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sha1.c	2010-07-25 10:07:43 UTC (rev 6480)
@@ -1,178 +0,0 @@
-/*
- * Copyright (C) 2007 Michael Niedermayer <michaelni at gmx.at>
- * based on public domain SHA-1 code by Steve Reid <steve at edmweb.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "common.h"
-#include "bswap.h"
-#include "sha1.h"
-
-typedef struct AVSHA1 {
-    uint64_t count;
-    uint8_t buffer[64];
-    uint32_t state[5];
-} AVSHA1;
-
-const int av_sha1_size = sizeof(AVSHA1);
-
-#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
-
-/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
-#define blk0(i) (block[i] = be2me_32(((const uint32_t*)buffer)[i]))
-#define blk(i) (block[i] = rol(block[i-3]^block[i-8]^block[i-14]^block[i-16],1))
-
-#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)    +blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
-#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)    +blk (i)+0x5A827999+rol(v,5);w=rol(w,30);
-#define R2(v,w,x,y,z,i) z+=( w^x     ^y)    +blk (i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
-#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk (i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
-#define R4(v,w,x,y,z,i) z+=( w^x     ^y)    +blk (i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
-
-/* Hash a single 512-bit block. This is the core of the algorithm. */
-
-static void transform(uint32_t state[5], const uint8_t buffer[64]){
-    uint32_t block[80];
-    unsigned int i, a, b, c, d, e;
-
-    a = state[0];
-    b = state[1];
-    c = state[2];
-    d = state[3];
-    e = state[4];
-#if CONFIG_SMALL
-    for(i=0; i<80; i++){
-        int t;
-        if(i<16) t= be2me_32(((uint32_t*)buffer)[i]);
-        else     t= rol(block[i-3]^block[i-8]^block[i-14]^block[i-16],1);
-        block[i]= t;
-        t+= e+rol(a,5);
-        if(i<40){
-            if(i<20)    t+= ((b&(c^d))^d)    +0x5A827999;
-            else        t+= ( b^c     ^d)    +0x6ED9EBA1;
-        }else{
-            if(i<60)    t+= (((b|c)&d)|(b&c))+0x8F1BBCDC;
-            else        t+= ( b^c     ^d)    +0xCA62C1D6;
-        }
-        e= d;
-        d= c;
-        c= rol(b,30);
-        b= a;
-        a= t;
-    }
-#else
-    for(i=0; i<15; i+=5){
-        R0(a,b,c,d,e,0+i); R0(e,a,b,c,d,1+i); R0(d,e,a,b,c,2+i); R0(c,d,e,a,b,3+i); R0(b,c,d,e,a,4+i);
-    }
-    R0(a,b,c,d,e,15); R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
-    for(i=20; i<40; i+=5){
-        R2(a,b,c,d,e,0+i); R2(e,a,b,c,d,1+i); R2(d,e,a,b,c,2+i); R2(c,d,e,a,b,3+i); R2(b,c,d,e,a,4+i);
-    }
-    for(; i<60; i+=5){
-        R3(a,b,c,d,e,0+i); R3(e,a,b,c,d,1+i); R3(d,e,a,b,c,2+i); R3(c,d,e,a,b,3+i); R3(b,c,d,e,a,4+i);
-    }
-    for(; i<80; i+=5){
-        R4(a,b,c,d,e,0+i); R4(e,a,b,c,d,1+i); R4(d,e,a,b,c,2+i); R4(c,d,e,a,b,3+i); R4(b,c,d,e,a,4+i);
-    }
-#endif
-    state[0] += a;
-    state[1] += b;
-    state[2] += c;
-    state[3] += d;
-    state[4] += e;
-}
-
-void av_sha1_init(AVSHA1* ctx){
-    ctx->state[0] = 0x67452301;
-    ctx->state[1] = 0xEFCDAB89;
-    ctx->state[2] = 0x98BADCFE;
-    ctx->state[3] = 0x10325476;
-    ctx->state[4] = 0xC3D2E1F0;
-    ctx->count    = 0;
-}
-
-void av_sha1_update(AVSHA1* ctx, const uint8_t* data, unsigned int len){
-    unsigned int i, j;
-
-    j = ctx->count & 63;
-    ctx->count += len;
-#if CONFIG_SMALL
-    for( i = 0; i < len; i++ ){
-        ctx->buffer[ j++ ] = data[i];
-        if( 64 == j ){
-            transform(ctx->state, ctx->buffer);
-            j = 0;
-        }
-    }
-#else
-    if ((j + len) > 63) {
-        memcpy(&ctx->buffer[j], data, (i = 64-j));
-        transform(ctx->state, ctx->buffer);
-        for ( ; i + 63 < len; i += 64) {
-            transform(ctx->state, &data[i]);
-        }
-        j=0;
-    }
-    else i = 0;
-    memcpy(&ctx->buffer[j], &data[i], len - i);
-#endif
-}
-
-void av_sha1_final(AVSHA1* ctx, uint8_t digest[20]){
-    int i;
-    uint64_t finalcount= be2me_64(ctx->count<<3);
-
-    av_sha1_update(ctx, "\200", 1);
-    while ((ctx->count & 63) != 56) {
-        av_sha1_update(ctx, "", 1);
-    }
-    av_sha1_update(ctx, (uint8_t *)&finalcount, 8); /* Should cause a transform() */
-    for(i=0; i<5; i++)
-        ((uint32_t*)digest)[i]= be2me_32(ctx->state[i]);
-}
-
-#ifdef TEST
-#include <stdio.h>
-#undef printf
-
-int main(void){
-    int i, k;
-    AVSHA1 ctx;
-    unsigned char digest[20];
-
-    for(k=0; k<3; k++){
-        av_sha1_init(&ctx);
-        if(k==0)
-            av_sha1_update(&ctx, "abc", 3);
-        else if(k==1)
-            av_sha1_update(&ctx, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56);
-        else
-            for(i=0; i<1000*1000; i++)
-                av_sha1_update(&ctx, "a", 1);
-        av_sha1_final(&ctx, digest);
-        for (i = 0; i < 20; i++)
-            printf("%02X", digest[i]);
-        putchar('\n');
-    }
-    //test vectors (from FIPS PUB 180-1)
-    printf("A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D\n"
-           "84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1\n"
-           "34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F\n");
-
-    return 0;
-}
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/timer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/timer.h	2010-07-25 10:07:41 UTC (rev 6479)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/timer.h	2010-07-25 10:07:43 UTC (rev 6480)
@@ -26,8 +26,13 @@
 
 #include <stdlib.h>
 #include <stdint.h>
+// MEANX
+#ifndef ADM_NO_CONFIG_H
 #include "config.h"
+#endif
+// MEANX
 
+
 #if   ARCH_ARM
 #   include "arm/timer.h"
 #elif ARCH_BFIN

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/avutil.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/avutil.h.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/avutil.h.patch	2010-07-25 10:07:43 UTC (rev 6480)
@@ -0,0 +1,18 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavutil/avutil.h b/avidemux_core/ADM_ffmpeg/libavutil/avutil.h
+index 50b29fc..691c5cb 100644
+--- a/avidemux_core/ADM_ffmpeg/libavutil/avutil.h
++++ b/avidemux_core/ADM_ffmpeg/libavutil/avutil.h
+@@ -26,6 +26,13 @@
+  * external API header
+  */
+ 
++/* MEANX
++ * - */
++#define ASMALIGN(ZEROBITS) ".p2align " #ZEROBITS "\n\t"
++/* /MEANX
++ */
++
++
+ 
+ #define AV_STRINGIFY(s)         AV_TOSTRING(s)
+ #define AV_TOSTRING(s) #s

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/internal.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/internal.h.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/internal.h.patch	2010-07-25 10:07:43 UTC (rev 6480)
@@ -0,0 +1,49 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavutil/internal.h b/avidemux_core/ADM_ffmpeg/libavutil/internal.h
+index 53d2b94..6cfbc6a 100644
+--- a/avidemux_core/ADM_ffmpeg/libavutil/internal.h
++++ b/avidemux_core/ADM_ffmpeg/libavutil/internal.h
+@@ -34,7 +34,11 @@
+ #include <stdint.h>
+ #include <stddef.h>
+ #include <assert.h>
++//MEANX
++#ifndef ADM_NO_CONFIG_H
+ #include "config.h"
++#endif
++// /MEANX
+ #include "attributes.h"
+ #include "timer.h"
+ 
+@@ -101,6 +105,8 @@
+ #endif
+ 
+ /* Use to export labels from asm. */
++#include "ADM_mangle.h"
++#if 0 // MEANX
+ #define LABEL_MANGLE(a) EXTERN_PREFIX #a
+ 
+ // Use rip-relative addressing if compiling PIC code on x86-64.
+@@ -111,7 +117,7 @@
+ #endif
+ 
+ #define MANGLE(a) EXTERN_PREFIX LOCAL_MANGLE(a)
+-
++#endif // MEANX
+ /* debug stuff */
+ 
+ /* dprintf macros */
+@@ -140,12 +146,14 @@
+ #endif
+ 
+ /* avoid usage of dangerous/inappropriate system functions */
++#if 0 //MEANX
+ #undef  malloc
+ #define malloc please_use_av_malloc
+ #undef  free
+ #define free please_use_av_free
+ #undef  realloc
+ #define realloc please_use_av_realloc
++#endif
+ #undef  time
+ #define time time_is_forbidden_due_to_security_issues
+ #undef  rand

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/lfg.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/lfg.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/lfg.c.patch	2010-07-25 10:07:43 UTC (rev 6480)
@@ -0,0 +1,13 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavutil/lfg.c b/avidemux_core/ADM_ffmpeg/libavutil/lfg.c
+index b5db5a4..8256adc 100644
+--- a/avidemux_core/ADM_ffmpeg/libavutil/lfg.c
++++ b/avidemux_core/ADM_ffmpeg/libavutil/lfg.c
+@@ -39,7 +39,7 @@ void av_cold av_lfg_init(AVLFG *c, unsigned int seed){
+         c->state[i+2]= AV_RL32(tmp+8);
+         c->state[i+3]= AV_RL32(tmp+12);
+     }
+-    c->index=0;
++    c->xindex=0;
+ }
+ 
+ void av_bmg_get(AVLFG *lfg, double out[2])

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/lfg.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/lfg.h.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/lfg.h.patch	2010-07-25 10:07:43 UTC (rev 6480)
@@ -0,0 +1,37 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavutil/lfg.h b/avidemux_core/ADM_ffmpeg/libavutil/lfg.h
+index 0e89ea3..e95b8c2 100644
+--- a/avidemux_core/ADM_ffmpeg/libavutil/lfg.h
++++ b/avidemux_core/ADM_ffmpeg/libavutil/lfg.h
+@@ -24,7 +24,7 @@
+ 
+ typedef struct {
+     unsigned int state[64];
+-    int index;
++    int xindex;
+ } AVLFG;
+ 
+ void av_lfg_init(AVLFG *c, unsigned int seed);
+@@ -36,8 +36,8 @@ void av_lfg_init(AVLFG *c, unsigned int seed);
+  * it may be good enough and faster for your specific use case.
+  */
+ static inline unsigned int av_lfg_get(AVLFG *c){
+-    c->state[c->index & 63] = c->state[(c->index-24) & 63] + c->state[(c->index-55) & 63];
+-    return c->state[c->index++ & 63];
++    c->state[c->xindex & 63] = c->state[(c->xindex-24) & 63] + c->state[(c->xindex-55) & 63];
++    return c->state[c->xindex++ & 63];
+ }
+ 
+ /**
+@@ -46,9 +46,9 @@ static inline unsigned int av_lfg_get(AVLFG *c){
+  * Please also consider av_lfg_get() above, it is faster.
+  */
+ static inline unsigned int av_mlfg_get(AVLFG *c){
+-    unsigned int a= c->state[(c->index-55) & 63];
+-    unsigned int b= c->state[(c->index-24) & 63];
+-    return c->state[c->index++ & 63] = 2*a*b+a+b;
++    unsigned int a= c->state[(c->xindex-55) & 63];
++    unsigned int b= c->state[(c->xindex-24) & 63];
++    return c->state[c->xindex++ & 63] = 2*a*b+a+b;
+ }
+ 
+ /**

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/libm.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/libm.h.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/libm.h.patch	2010-07-25 10:07:43 UTC (rev 6480)
@@ -0,0 +1,16 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavutil/libm.h b/avidemux_core/ADM_ffmpeg/libavutil/libm.h
+index c7c28ac..3f6ae07 100644
+--- a/avidemux_core/ADM_ffmpeg/libavutil/libm.h
++++ b/avidemux_core/ADM_ffmpeg/libavutil/libm.h
+@@ -25,7 +25,11 @@
+ #define AVUTIL_LIBM_H
+ 
+ #include <math.h>
++//MEANX
++#ifndef ADM_NO_CONFIG_H
+ #include "config.h"
++#endif
++///MEANX
+ #include "attributes.h"
+ 
+ #if !HAVE_EXP2

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/mem.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/mem.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/mem.c.patch	2010-07-25 10:07:43 UTC (rev 6480)
@@ -0,0 +1,182 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavutil/mem.c b/avidemux_core/ADM_ffmpeg/libavutil/mem.c
+index 8cad089..8e95a78 100644
+--- a/avidemux_core/ADM_ffmpeg/libavutil/mem.c
++++ b/avidemux_core/ADM_ffmpeg/libavutil/mem.c
+@@ -63,87 +63,110 @@ void  free(void *ptr);
+ 
+ void *av_malloc(unsigned int size)
+ {
+-    void *ptr = NULL;
+-#if CONFIG_MEMALIGN_HACK
+-    long diff;
+-#endif
+-
+-    /* let's disallow possible ambiguous cases */
+-    if(size > (INT_MAX-16) )
+-        return NULL;
+-
+-#if CONFIG_MEMALIGN_HACK
+-    ptr = malloc(size+16);
+-    if(!ptr)
+-        return ptr;
+-    diff= ((-(long)ptr - 1)&15) + 1;
+-    ptr = (char*)ptr + diff;
+-    ((char*)ptr)[-1]= diff;
+-#elif HAVE_POSIX_MEMALIGN
+-    if (posix_memalign(&ptr,16,size))
+-        ptr = NULL;
+-#elif HAVE_MEMALIGN
+-    ptr = memalign(16,size);
+-    /* Why 64?
+-       Indeed, we should align it:
+-         on 4 for 386
+-         on 16 for 486
+-         on 32 for 586, PPro - K6-III
+-         on 64 for K7 (maybe for P3 too).
+-       Because L1 and L2 caches are aligned on those values.
+-       But I don't want to code such logic here!
+-     */
+-     /* Why 16?
+-        Because some CPUs need alignment, for example SSE2 on P4, & most RISC CPUs
+-        it will just trigger an exception and the unaligned load will be done in the
+-        exception handler or it will just segfault (SSE2 on P4).
+-        Why not larger? Because I did not see a difference in benchmarks ...
+-     */
+-     /* benchmarks with P3
+-        memalign(64)+1          3071,3051,3032
+-        memalign(64)+2          3051,3032,3041
+-        memalign(64)+4          2911,2896,2915
+-        memalign(64)+8          2545,2554,2550
+-        memalign(64)+16         2543,2572,2563
+-        memalign(64)+32         2546,2545,2571
+-        memalign(64)+64         2570,2533,2558
+-
+-        BTW, malloc seems to do 8-byte alignment by default here.
+-     */
++#ifdef __APPLE__
++	return malloc(size);
+ #else
+-    ptr = malloc(size);
++	char *c;
++
++	uint64_t l, lorg;
++	uint32_t *backdoor;
++
++	l = (uint64_t)malloc(size + 32);
++
++	// Get next boundary
++	lorg = l;
++	l = (l + 15) & 0xfffffffffffffff0LL;
++	l += 16;
++	c = (char*)l;
++	backdoor = (uint32_t*)(c - 8);
++	*backdoor = (0xdead << 16) + l - lorg;
++	backdoor[1] = size;
++
++	return c;
+ #endif
+-    return ptr;
+ }
+ 
+-void *av_realloc(void *ptr, unsigned int size)
++void *av_realloc(void *ptr, unsigned int newsize)
+ {
+-#if CONFIG_MEMALIGN_HACK
+-    int diff;
+-#endif
++#ifdef __APPLE__
++	if (!ptr)
++		return av_malloc(newsize);
+ 
+-    /* let's disallow possible ambiguous cases */
+-    if(size > (INT_MAX-16) )
+-        return NULL;
++	if (!newsize)
++	{
++		av_free(ptr);
++		return NULL;
++	}
+ 
+-#if CONFIG_MEMALIGN_HACK
+-    //FIXME this isn't aligned correctly, though it probably isn't needed
+-    if(!ptr) return av_malloc(size);
+-    diff= ((char*)ptr)[-1];
+-    return (char*)realloc((char*)ptr - diff, size + diff) + diff;
++	return realloc(ptr, newsize);
+ #else
+-    return realloc(ptr, size);
++	void *nalloc;
++
++	if (!ptr)
++		return av_malloc(newsize);
++
++	if (!newsize) 
++	{
++		av_free(ptr);
++		return NULL;
++	}
++
++	// now we either shrink them or expand them
++	// in case of shrink, we do nothing
++	// in case of expand we have to copy
++	// Do copy everytime (slower)
++	uint32_t *backdoor;
++	uint32_t size, offset;
++	char *c = (char*)ptr;
++
++	backdoor = (uint32_t*)ptr;
++	backdoor -= 2;
++
++	assert(((*backdoor) >> 16) == 0xdead);
++
++	offset = backdoor[0] & 0xffff;
++	size = backdoor[1];
++
++	if(size >= newsize) // do nothing
++		return ptr;
++
++	// Allocate a new one
++	nalloc = av_malloc(newsize);
++	memcpy(nalloc, ptr, size);
++	av_free(ptr);
++
++	return nalloc;
+ #endif
+ }
+ 
+ void av_free(void *ptr)
+ {
+-    /* XXX: this test should not be needed on most libcs */
+-    if (ptr)
+-#if CONFIG_MEMALIGN_HACK
+-        free((char*)ptr - ((char*)ptr)[-1]);
++#ifdef __APPLE__
++	if (!ptr)
++		return;
++
++	free(ptr);
+ #else
+-        free(ptr);
++	uint32_t *backdoor;
++	uint32_t size, offset;
++	char *c = (char*)ptr;
++
++	if (!ptr)
++		return;
++
++	backdoor = (uint32_t*)ptr;
++	backdoor -= 2;
++
++	if (*backdoor == 0xbeefbeef)
++		assert(0);
++
++	assert(((*backdoor) >> 16) == 0xdead);
++
++	offset = backdoor[0] & 0xffff;
++	size = backdoor[1];
++	*backdoor = 0xbeefbeef; // Scratch sig
++
++	free(c - offset);
+ #endif
+ }
+ 

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/timer.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/timer.h.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avutils/timer.h.patch	2010-07-25 10:07:43 UTC (rev 6480)
@@ -0,0 +1,17 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavutil/timer.h b/avidemux_core/ADM_ffmpeg/libavutil/timer.h
+index cd8fba8..66be371 100644
+--- a/avidemux_core/ADM_ffmpeg/libavutil/timer.h
++++ b/avidemux_core/ADM_ffmpeg/libavutil/timer.h
+@@ -26,7 +26,12 @@
+ 
+ #include <stdlib.h>
+ #include <stdint.h>
++// MEANX
++#ifndef ADM_NO_CONFIG_H
+ #include "config.h"
++#endif
++// MEANX
++
+ 
+ #if   ARCH_ARM
+ #   include "arm/timer.h"



From mean at mail.berlios.de  Sun Jul 25 12:07:46 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 25 Jul 2010 12:07:46 +0200
Subject: [Avidemux-svn-commit] r6481 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:
	libavformat patches patches/avformat
Message-ID: <20100725100746.C3EBA480E6C@sheep.berlios.de>

Author: mean
Date: 2010-07-25 12:07:46 +0200 (Sun, 25 Jul 2010)
New Revision: 6481

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/http.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/ivfdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/md5proto.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mmst.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsodec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsoenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/srtdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/tty.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/file.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/flvenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/isom.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/matroskaenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/movenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegtsenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/utils.c.patch
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c
Log:
[ffmpeg] update 25 July , avformat

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -30,7 +30,73 @@
 #include <stdlib.h>
 #include "os_support.h"
 
+// GRUNTSTER start
+#ifdef __WIN32
+#include <windows.h>
 
+int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString)
+{
+	int wideCharStringLength = MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, NULL, 0);
+
+	if (wideCharString)
+		MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, wideCharString, wideCharStringLength);
+
+	return wideCharStringLength;
+}
+
+int ADM_open(const char *path, int oflag, ...)
+{
+	int fileNameLength = utf8StringToWideChar(path, -1, NULL);
+	wchar_t wcFile[fileNameLength];
+	int creation = 0, access = 0;
+	HANDLE hFile;
+
+	utf8StringToWideChar(path, -1, wcFile);
+
+	if (oflag & O_WRONLY || oflag & O_RDWR)
+	{
+		access = GENERIC_WRITE;
+
+		if (oflag & O_RDWR)
+			access |= GENERIC_READ;
+
+		if (oflag & O_CREAT)
+		{
+			if (oflag & O_EXCL)
+				creation = CREATE_NEW;
+			else if (oflag & O_TRUNC)
+				creation = CREATE_ALWAYS;
+			else
+				creation = OPEN_ALWAYS;
+		}
+		else if (oflag & O_TRUNC)
+			creation = TRUNCATE_EXISTING;
+	}
+	else if (oflag & O_RDONLY)
+		creation = OPEN_EXISTING;
+
+	if (creation & GENERIC_WRITE)
+	{
+		hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
+
+		if (hFile == INVALID_HANDLE_VALUE)
+			return -1;
+		else
+			CloseHandle(hFile);
+	}
+
+	hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
+
+	if (hFile == INVALID_HANDLE_VALUE)
+		return -1;
+	else
+		return _open_osfhandle((intptr_t)hFile, oflag);
+}
+
+#define open ADM_open
+#endif
+// GRUNTSTER end
+
 /* standard file protocol */
 
 static int file_read(URLContext *h, unsigned char *buf, int size)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -406,7 +406,8 @@
     "video/x-flv",
     "flv",
     sizeof(FLVContext),
-#if CONFIG_LIBMP3LAME
+//MEANX #if CONFIG_LIBMP3LAME
+#ifdef HAVE_LIBMP3LAME
     CODEC_ID_MP3,
 #else // CONFIG_LIBMP3LAME
     CODEC_ID_ADPCM_SWF,
@@ -418,3 +419,9 @@
     .codec_tag= (const AVCodecTag* const []){flv_video_codec_ids, flv_audio_codec_ids, 0},
     .flags= AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
 };
+// MEANX
+int flvenc_init(void)
+{
+    av_register_output_format(&flv_muxer);
+    return 0;
+}
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/http.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/http.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/http.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,64 @@
+/*
+ * HTTP definitions
+ * Copyright (c) 2010 Josh Allmann
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_HTTP_H
+#define AVFORMAT_HTTP_H
+
+#include "avio.h"
+
+/**
+ * Set custom HTTP headers.
+ * A trailing CRLF ("\r\n") is required for custom headers.
+ * Passing in an empty header string ("\0") will reset to defaults.
+ *
+ * The following headers can be overriden by custom values,
+ * otherwise they will be set to their defaults.
+ *  -User-Agent
+ *  -Accept
+ *  -Range
+ *  -Host
+ *  -Connection
+ *
+ * @param h URL context for this HTTP connection
+ * @param headers the custom headers to set
+ */
+void ff_http_set_headers(URLContext *h, const char *headers);
+
+/**
+ * Enable or disable chunked transfer encoding. (default is enabled)
+ *
+ * @param h URL context for this HTTP connection
+ * @param is_chunked 0 to disable chunking, nonzero otherwise.
+ */
+void ff_http_set_chunked_transfer_encoding(URLContext *h, int is_chunked);
+
+/**
+ * Initialize the authentication state based on another HTTP URLContext.
+ * This can be used to pre-initialize the authentication parameters if
+ * they are known beforehand, to avoid having to do an initial failing
+ * request just to get the parameters.
+ *
+ * @param dest URL context whose authentication state gets updated
+ * @param src URL context whose authentication state gets copied
+ */
+void ff_http_init_auth_state(URLContext *dest, const URLContext *src);
+
+#endif /* AVFORMAT_HTTP_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -215,7 +215,10 @@
     { CODEC_ID_MP1, MKTAG('.', 'm', 'p', '1') }, /* MPEG layer 1 */
     { CODEC_ID_MP2, MKTAG('.', 'm', 'p', '2') }, /* MPEG layer 2 */
 
-    { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at http://www.3ivx.com/showcase.html use this tag */
+    //MEANX { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at http://www.3ivx.com/showcase.html use this tag */
+     { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
+     { CODEC_ID_MP2, MKTAG( 'm', 'p', '4', 'a') },
+    // /MEANX
     { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
 
 /*  { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at http://heroinewarrior.com/xmovie.php3 use this tag */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/ivfdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/ivfdec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/ivfdec.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2010 David Conrad
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avformat.h"
+#include "riff.h"
+#include "libavutil/intreadwrite.h"
+
+static int probe(AVProbeData *p)
+{
+    if (AV_RL32(p->buf) == MKTAG('D','K','I','F')
+        && !AV_RL16(p->buf+4) && AV_RL16(p->buf+6) == 32)
+        return AVPROBE_SCORE_MAX-2;
+
+    return 0;
+}
+
+static int read_header(AVFormatContext *s, AVFormatParameters *ap)
+{
+    AVStream *st;
+    AVRational time_base;
+
+    get_le32(s->pb); // DKIF
+    get_le16(s->pb); // version
+    get_le16(s->pb); // header size
+
+    st = av_new_stream(s, 0);
+    if (!st)
+        return AVERROR(ENOMEM);
+
+
+    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
+    st->codec->codec_tag  = get_le32(s->pb);
+    st->codec->codec_id   = ff_codec_get_id(ff_codec_bmp_tags, st->codec->codec_tag);
+    st->codec->width      = get_le16(s->pb);
+    st->codec->height     = get_le16(s->pb);
+    time_base.den         = get_le32(s->pb);
+    time_base.num         = get_le32(s->pb);
+    st->duration          = get_le64(s->pb);
+
+    st->need_parsing      = AVSTREAM_PARSE_HEADERS;
+
+    if (!time_base.den || !time_base.num) {
+        av_log(s, AV_LOG_ERROR, "Invalid frame rate\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    av_set_pts_info(st, 64, time_base.num, time_base.den);
+
+    return 0;
+}
+
+static int read_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    int ret, size = get_le32(s->pb);
+    int64_t   pts = get_le64(s->pb);
+
+    ret = av_get_packet(s->pb, pkt, size);
+    pkt->stream_index = 0;
+    pkt->pts          = pts;
+    pkt->pos         -= 12;
+
+    return ret;
+}
+
+AVInputFormat ivf_demuxer = {
+    "ivf",
+    NULL_IF_CONFIG_SMALL("On2 IVF"),
+    0,
+    probe,
+    read_header,
+    read_packet,
+    .flags= AVFMT_GENERIC_INDEX,
+    .codec_tag = (const AVCodecTag*[]){ff_codec_bmp_tags, 0},
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -407,6 +407,7 @@
 
 static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec)
 {
+#if 0 // MEANX avidemux does thing differently
     uint8_t *header_start[3];
     int header_len[3];
     int first_header_size;
@@ -431,6 +432,28 @@
         put_buffer(pb, header_start[j], header_len[j]);
 
     return 0;
+#else
+   // Not endian safe....
+      uint32_t packetLen[3],*ptr=(uint32_t *)codec->extradata;
+      uint8_t *data[3],i,j;
+      if( 3*4+ptr[0]+ptr[1]+ptr[2]!=codec->extradata_size)
+      {
+        av_log(s, AV_LOG_ERROR, "Broken avidemux xiph header.\n");
+        return -1;
+      }
+      data[0]=codec->extradata+3*4;
+      data[1]=data[0]+ptr[0];
+      data[2]=data[1]+ptr[1];
+      put_byte(pb, 2);                    // number packets - 1
+      for (j = 0; j < 2; j++) 
+      {
+          put_xiph_size(pb, ptr[j]);
+      }
+      for (j = 0; j < 3; j++)
+        put_buffer(pb, data[j], ptr[j]);
+      
+      return 0; // /MEANX
+#endif
 }
 
 static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
@@ -548,6 +571,23 @@
         put_ebml_uint (pb, MATROSKA_ID_TRACKNUMBER     , i + 1);
         put_ebml_uint (pb, MATROSKA_ID_TRACKUID        , i + 1);
         put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
+/**  MEANX : Add a default duration for video **/
+        if(codec->codec_type==CODEC_TYPE_VIDEO)
+        {
+          if(codec->time_base.den && codec->time_base.num)
+          {
+            int num=codec->time_base.num;
+            int den=codec->time_base.den;
+            unsigned int default_duration;
+            float period=num;
+                  period/=den;
+                  period*=1000*1000*1000; // in ns
+                  default_duration=(unsigned int)floor(period);
+                  put_ebml_uint (pb, MATROSKA_ID_TRACKDEFAULTDURATION ,default_duration);
+          }
+        }
+        
+/**  MEANX : Add a default duration for video **/
 
         if ((tag = av_metadata_get(st->metadata, "title", NULL, 0)))
             put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value);
@@ -1087,3 +1127,17 @@
     .codec_tag = (const AVCodecTag* const []){ff_codec_wav_tags, 0},
 };
 #endif
+
+ // MEANX
+ //
+ int matroskaenc_init(void)
+ {
+     av_register_output_format(&matroska_muxer);
+#if CONFIG_WEBM_MUXER
+     av_register_output_format(&webm_muxer);
+#endif
+     return 0;
+ }
+ // /MEANX
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/md5proto.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/md5proto.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/md5proto.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2010 Mans Rullgard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdio.h>
+#include "libavutil/avstring.h"
+#include "libavutil/md5.h"
+#include "libavutil/mem.h"
+#include "libavutil/error.h"
+#include "avformat.h"
+#include "avio.h"
+
+#define PRIV_SIZE 128
+
+static int md5_open(URLContext *h, const char *filename, int flags)
+{
+    if (PRIV_SIZE < av_md5_size) {
+        av_log(NULL, AV_LOG_ERROR, "Insuffient size for MD5 context\n");
+        return -1;
+    }
+
+    if (flags != URL_WRONLY)
+        return AVERROR(EINVAL);
+
+    av_md5_init(h->priv_data);
+
+    return 0;
+}
+
+static int md5_write(URLContext *h, const unsigned char *buf, int size)
+{
+    av_md5_update(h->priv_data, buf, size);
+    return size;
+}
+
+static int md5_close(URLContext *h)
+{
+    const char *filename = h->filename;
+    uint8_t md5[16], buf[64];
+    URLContext *out;
+    int i, err = 0;
+
+    av_md5_final(h->priv_data, md5);
+    for (i = 0; i < sizeof(md5); i++)
+        snprintf(buf + i*2, 3, "%02x", md5[i]);
+    buf[i*2] = '\n';
+
+    av_strstart(filename, "md5:", &filename);
+
+    if (*filename) {
+        err = url_open(&out, filename, URL_WRONLY);
+        if (err)
+            return err;
+        err = url_write(out, buf, i*2+1);
+        url_close(out);
+    } else {
+        if (fwrite(buf, 1, i*2+1, stdout) < i*2+1)
+            err = AVERROR(errno);
+    }
+
+    return err;
+}
+
+static int md5_get_handle(URLContext *h)
+{
+    return (intptr_t)h->priv_data;
+}
+
+URLProtocol md5_protocol = {
+    .name                = "md5",
+    .url_open            = md5_open,
+    .url_write           = md5_write,
+    .url_close           = md5_close,
+    .url_get_file_handle = md5_get_handle,
+    .priv_data_size      = PRIV_SIZE,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mmst.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mmst.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mmst.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,716 @@
+/*
+ * MMS protocol over TCP
+ * Copyright (c) 2006,2007 Ryan Martell
+ * Copyright (c) 2007 Bj?rn Axelsson
+ * Copyright (c) 2010 Zhentan Feng <spyfeng at gmail dot com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/* References
+ * MMS protocol specification:
+ *  [1]http://msdn.microsoft.com/en-us/library/cc234711(PROT.10).aspx
+ * ASF specification. Revision 01.20.03.
+ *  [2]http://msdn.microsoft.com/en-us/library/bb643323.aspx
+ */
+
+#include "avformat.h"
+#include "internal.h"
+#include "libavutil/intreadwrite.h"
+#include "libavcodec/bytestream.h"
+#include "network.h"
+#include "asf.h"
+
+#define LOCAL_ADDRESS 0xc0a80081    // FIXME get and use correct local ip address.
+#define LOCAL_PORT    1037          // as above.
+/** Client to server packet types. */
+typedef enum {
+    CS_PKT_INITIAL                  = 0x01,
+    CS_PKT_PROTOCOL_SELECT          = 0x02,
+    CS_PKT_MEDIA_FILE_REQUEST       = 0x05,
+    CS_PKT_START_FROM_PKT_ID        = 0x07,
+    CS_PKT_STREAM_PAUSE             = 0x09,
+    CS_PKT_STREAM_CLOSE             = 0x0d,
+    CS_PKT_MEDIA_HEADER_REQUEST     = 0x15,
+    CS_PKT_TIMING_DATA_REQUEST      = 0x18,
+    CS_PKT_USER_PASSWORD            = 0x1a,
+    CS_PKT_KEEPALIVE                = 0x1b,
+    CS_PKT_STREAM_ID_REQUEST        = 0x33,
+} MMSCSPacketType;
+
+/** Server to client packet types. */
+typedef enum {
+    /** Control packets. */
+    /*@{*/
+    SC_PKT_CLIENT_ACCEPTED          = 0x01,
+    SC_PKT_PROTOCOL_ACCEPTED        = 0x02,
+    SC_PKT_PROTOCOL_FAILED          = 0x03,
+    SC_PKT_MEDIA_PKT_FOLLOWS        = 0x05,
+    SC_PKT_MEDIA_FILE_DETAILS       = 0x06,
+    SC_PKT_HEADER_REQUEST_ACCEPTED  = 0x11,
+    SC_PKT_TIMING_TEST_REPLY        = 0x15,
+    SC_PKT_PASSWORD_REQUIRED        = 0x1a,
+    SC_PKT_KEEPALIVE                = 0x1b,
+    SC_PKT_STREAM_STOPPED           = 0x1e,
+    SC_PKT_STREAM_CHANGING          = 0x20,
+    SC_PKT_STREAM_ID_ACCEPTED       = 0x21,
+    /*@}*/
+
+    /** Pseudo packets. */
+    /*@{*/
+    SC_PKT_CANCEL                   = -1,
+    SC_PKT_NO_DATA                  = -2,
+    /*@}*/
+
+    /** Data packets. */
+    /*@{*/
+    SC_PKT_ASF_HEADER               = 0x010000,// make it bigger than 0xFF in case of
+    SC_PKT_ASF_MEDIA                = 0x010001,// receiving false data packets.
+    /*@}*/
+} MMSSCPacketType;
+
+typedef struct {
+    int id;
+}MMSStream;
+
+typedef struct {
+    int outgoing_packet_seq;             ///< Outgoing packet sequence number.
+    char path[256];                      ///< Path of the resource being asked for.
+    char host[128];                      ///< Host of the resources.
+
+    URLContext *mms_hd;                  ///< TCP connection handle
+    MMSStream streams[MAX_STREAMS];
+
+    /** Buffer for outgoing packets. */
+    /*@{*/
+    uint8_t *write_out_ptr;              ///< Pointer for writting the buffer.
+    uint8_t out_buffer[512];             ///< Buffer for outgoing packet.
+    /*@}*/
+
+    /** Buffer for incoming packets. */
+    /*@{*/
+    uint8_t in_buffer[8192];             ///< Buffer for incoming packets.
+    uint8_t *read_in_ptr;                ///< Pointer for reading from incoming buffer.
+    int remaining_in_len;                ///< Reading length from incoming buffer.
+    /*@}*/
+
+    int incoming_packet_seq;             ///< Incoming packet sequence number.
+    int incoming_flags;                  ///< Incoming packet flags.
+
+    int packet_id;                       ///< Identifier for packets in the current stream.
+    unsigned int header_packet_id;       ///< default is 2.
+
+    /** Internal handling of the ASF header */
+    /*@{*/
+    uint8_t *asf_header;                 ///< Stored ASF header.
+    int asf_header_size;                 ///< Size of stored ASF header.
+    int header_parsed;                   ///< The header has been received and parsed.
+    int asf_packet_len;
+    int asf_header_read_size;
+    /*@}*/
+
+    int stream_num;                      ///< stream numbers.
+    int is_playing;
+} MMSContext;
+
+/** Create MMST command packet header */
+static void start_command_packet(MMSContext *mms, MMSCSPacketType packet_type)
+{
+    mms->write_out_ptr = mms->out_buffer;
+
+    bytestream_put_le32(&mms->write_out_ptr, 1); // start sequence
+    bytestream_put_le32(&mms->write_out_ptr, 0xb00bface);
+    bytestream_put_le32(&mms->write_out_ptr, 0); // Length starts from after the protocol type bytes
+    bytestream_put_le32(&mms->write_out_ptr, MKTAG('M','M','S',' '));
+    bytestream_put_le32(&mms->write_out_ptr, 0);
+    bytestream_put_le32(&mms->write_out_ptr, mms->outgoing_packet_seq++);
+    bytestream_put_le64(&mms->write_out_ptr, 0); // timestamp
+    bytestream_put_le32(&mms->write_out_ptr, 0);
+    bytestream_put_le16(&mms->write_out_ptr, packet_type);
+    bytestream_put_le16(&mms->write_out_ptr, 3); // direction to server
+}
+
+/** Add prefixes to MMST command packet. */
+static void insert_command_prefixes(MMSContext *mms,
+        uint32_t prefix1, uint32_t prefix2)
+{
+    bytestream_put_le32(&mms->write_out_ptr, prefix1); // first prefix
+    bytestream_put_le32(&mms->write_out_ptr, prefix2); // second prefix
+}
+
+/** Send a prepared MMST command packet. */
+static int send_command_packet(MMSContext *mms)
+{
+    int len= mms->write_out_ptr - mms->out_buffer;
+    int exact_length = (len + 7) & ~7;
+    int first_length= exact_length - 16;
+    int len8= first_length/8;
+    int write_result;
+
+    // update packet length fields.
+    AV_WL32(mms->out_buffer + 8, first_length);
+    AV_WL32(mms->out_buffer + 16, len8);
+    AV_WL32(mms->out_buffer + 32, len8-2);
+    memset(mms->write_out_ptr, 0, exact_length - len);
+
+    // write it out.
+    write_result= url_write(mms->mms_hd, mms->out_buffer, exact_length);
+    if(write_result != exact_length) {
+        dprintf(NULL, "url_write returned: %d != %d\n",
+                write_result, exact_length);
+        return AVERROR_IO;
+    }
+
+    return 0;
+}
+
+static void mms_put_utf16(MMSContext *mms, uint8_t *src)
+{
+    ByteIOContext bic;
+    int size = mms->write_out_ptr - mms->out_buffer;
+    int len;
+    init_put_byte(&bic, mms->write_out_ptr,
+            sizeof(mms->out_buffer) - size, 1, NULL, NULL, NULL, NULL);
+
+    len = ff_put_str16_nolen(&bic, src);
+    mms->write_out_ptr += len;
+}
+
+static int send_time_test_data(MMSContext *mms)
+{
+    start_command_packet(mms, CS_PKT_TIMING_DATA_REQUEST);
+    insert_command_prefixes(mms, 0xf0f0f0f1, 0x0004000b);
+    return send_command_packet(mms);
+}
+
+static int send_protocol_select(MMSContext *mms)
+{
+    char data_string[256];
+
+    start_command_packet(mms, CS_PKT_PROTOCOL_SELECT);
+    insert_command_prefixes(mms, 0, 0xffffffff);
+    bytestream_put_le32(&mms->write_out_ptr, 0);          // maxFunnelBytes
+    bytestream_put_le32(&mms->write_out_ptr, 0x00989680); // maxbitRate
+    bytestream_put_le32(&mms->write_out_ptr, 2);          // funnelMode
+    snprintf(data_string, sizeof(data_string), "\\\\%d.%d.%d.%d\\%s\\%d",
+            (LOCAL_ADDRESS>>24)&0xff,
+            (LOCAL_ADDRESS>>16)&0xff,
+            (LOCAL_ADDRESS>>8)&0xff,
+            LOCAL_ADDRESS&0xff,
+            "TCP",                                        // or UDP
+            LOCAL_PORT);
+
+    mms_put_utf16(mms, data_string);
+    return send_command_packet(mms);
+}
+
+static int send_media_file_request(MMSContext *mms)
+{
+    start_command_packet(mms, CS_PKT_MEDIA_FILE_REQUEST);
+    insert_command_prefixes(mms, 1, 0xffffffff);
+    bytestream_put_le32(&mms->write_out_ptr, 0);
+    bytestream_put_le32(&mms->write_out_ptr, 0);
+    mms_put_utf16(mms, mms->path + 1); // +1 for skip "/"
+
+    return send_command_packet(mms);
+}
+
+static void handle_packet_stream_changing_type(MMSContext *mms)
+{
+    dprintf(NULL, "Stream changing!\n");
+
+    // 40 is the packet header size, 7 is the prefix size.
+    mms->header_packet_id= AV_RL32(mms->in_buffer + 40 + 7);
+    dprintf(NULL, "Changed header prefix to 0x%x", mms->header_packet_id);
+}
+
+static int send_keepalive_packet(MMSContext *mms)
+{
+    // respond to a keepalive with a keepalive...
+    start_command_packet(mms, CS_PKT_KEEPALIVE);
+    insert_command_prefixes(mms, 1, 0x100FFFF);
+    return send_command_packet(mms);
+}
+
+/** Pad media packets smaller than max_packet_size and/or adjust read position
+  * after a seek. */
+static void pad_media_packet(MMSContext *mms)
+{
+    if(mms->remaining_in_len<mms->asf_packet_len) {
+        int padding_size = mms->asf_packet_len - mms->remaining_in_len;
+        memset(mms->in_buffer + mms->remaining_in_len, 0, padding_size);
+        mms->remaining_in_len += padding_size;
+    }
+}
+
+/** Read incoming MMST media, header or command packet. */
+static MMSSCPacketType get_tcp_server_response(MMSContext *mms)
+{
+    int read_result;
+    MMSSCPacketType packet_type= -1;
+
+    for(;;) {
+        if((read_result= url_read_complete(mms->mms_hd, mms->in_buffer, 8))==8) {
+            // handle command packet.
+            if(AV_RL32(mms->in_buffer + 4)==0xb00bface) {
+                mms->incoming_flags= mms->in_buffer[3];
+                read_result= url_read_complete(mms->mms_hd, mms->in_buffer+8, 4);
+                if(read_result == 4) {
+                    int length_remaining= AV_RL32(mms->in_buffer+8) + 4;
+                    int hr;
+
+                    dprintf(NULL, "Length remaining is %d\n", length_remaining);
+                    // read the rest of the packet.
+                    if (length_remaining < 0
+                        || length_remaining > sizeof(mms->in_buffer) - 12) {
+                        dprintf(NULL, "Incoming message len %d exceeds buffer len %d\n",
+                            length_remaining, sizeof(mms->in_buffer) - 12);
+                        return -1;
+                    }
+                    read_result = url_read_complete(mms->mms_hd, mms->in_buffer + 12,
+                                                  length_remaining) ;
+                    if (read_result == length_remaining) {
+                        packet_type= AV_RL16(mms->in_buffer+36);
+                    } else {
+                        dprintf(NULL, "read for packet type failed%d!\n", read_result);
+                        return -1;
+                    }
+                    hr = AV_RL32(mms->in_buffer + 40);
+                    if (hr) {
+                        dprintf(NULL, "The server side send back error code:0x%x\n", hr);
+                        return -1;
+                    }
+                } else {
+                    dprintf(NULL, "read for length remaining failed%d!\n", read_result);
+                    return -1;
+                }
+            } else {
+                int length_remaining;
+                int packet_id_type;
+                int tmp;
+
+                // note we cache the first 8 bytes,
+                // then fill up the buffer with the others
+                tmp                       = AV_RL16(mms->in_buffer + 6);
+                length_remaining          = (tmp - 8) & 0xffff;
+                mms->incoming_packet_seq  = AV_RL32(mms->in_buffer);
+                packet_id_type            = mms->in_buffer[4];
+                mms->incoming_flags       = mms->in_buffer[5];
+
+                if (length_remaining < 0
+                        || length_remaining > sizeof(mms->in_buffer) - 8) {
+                    dprintf(NULL, "Incoming data len %d exceeds buffer len %d\n",
+                            length_remaining, sizeof(mms->in_buffer));
+                    return -1;
+                }
+                mms->remaining_in_len    = length_remaining;
+                mms->read_in_ptr         = mms->in_buffer;
+                read_result= url_read_complete(mms->mms_hd, mms->in_buffer, length_remaining);
+                if(read_result != length_remaining) {
+                    dprintf(NULL, "read_bytes result: %d asking for %d\n",
+                            read_result, length_remaining);
+                    return -1;
+                } else {
+                    // if we successfully read everything.
+                    if(packet_id_type == mms->header_packet_id) {
+                        packet_type = SC_PKT_ASF_HEADER;
+                        // Store the asf header
+                        if(!mms->header_parsed) {
+                            void *p = av_realloc(mms->asf_header,
+                                              mms->asf_header_size
+                                              + mms->remaining_in_len);
+                            if (!p) {
+                                av_freep(&mms->asf_header);
+                                return AVERROR(ENOMEM);
+                            }
+                            mms->asf_header = p;
+                            memcpy(mms->asf_header + mms->asf_header_size,
+                                                 mms->read_in_ptr,
+                                                 mms->remaining_in_len);
+                            mms->asf_header_size += mms->remaining_in_len;
+                        }
+                        // 0x04 means asf header is sent in multiple packets.
+                        if (mms->incoming_flags == 0x04)
+                            continue;
+                    } else if(packet_id_type == mms->packet_id) {
+                        packet_type = SC_PKT_ASF_MEDIA;
+                    } else {
+                        dprintf(NULL, "packet id type %d is old.", packet_id_type);
+                        continue;
+                    }
+                }
+            }
+
+            // preprocess some packet type
+            if(packet_type == SC_PKT_KEEPALIVE) {
+                send_keepalive_packet(mms);
+                continue;
+            } else if(packet_type == SC_PKT_STREAM_CHANGING) {
+                handle_packet_stream_changing_type(mms);
+            } else if(packet_type == SC_PKT_ASF_MEDIA) {
+                pad_media_packet(mms);
+            }
+            return packet_type;
+        } else {
+            if(read_result<0) {
+                dprintf(NULL, "Read error (or cancelled) returned %d!\n", read_result);
+                packet_type = SC_PKT_CANCEL;
+            } else {
+                dprintf(NULL, "Read result of zero?!\n");
+                packet_type = SC_PKT_NO_DATA;
+            }
+            return packet_type;
+        }
+    }
+}
+
+static int mms_safe_send_recv(MMSContext *mms,
+                              int (*send_fun)(MMSContext *mms),
+                              const MMSSCPacketType expect_type)
+{
+    MMSSCPacketType type;
+    if(send_fun) {
+        int ret = send_fun(mms);
+        if (ret < 0) {
+            dprintf(NULL, "Send Packet error before expecting recv packet %d\n", expect_type);
+            return ret;
+        }
+    }
+
+    if ((type = get_tcp_server_response(mms)) != expect_type) {
+        dprintf(NULL,"Unexpected packet type %d with type %d\n", type, expect_type);
+        return -1;
+    } else {
+        return 0;
+    }
+}
+
+static int send_media_header_request(MMSContext *mms)
+{
+    start_command_packet(mms, CS_PKT_MEDIA_HEADER_REQUEST);
+    insert_command_prefixes(mms, 1, 0);
+    bytestream_put_le32(&mms->write_out_ptr, 0);
+    bytestream_put_le32(&mms->write_out_ptr, 0x00800000);
+    bytestream_put_le32(&mms->write_out_ptr, 0xffffffff);
+    bytestream_put_le32(&mms->write_out_ptr, 0);
+    bytestream_put_le32(&mms->write_out_ptr, 0);
+    bytestream_put_le32(&mms->write_out_ptr, 0);
+
+    // the media preroll value in milliseconds?
+    bytestream_put_le32(&mms->write_out_ptr, 0);
+    bytestream_put_le32(&mms->write_out_ptr, 0x40AC2000);
+    bytestream_put_le32(&mms->write_out_ptr, 2);
+    bytestream_put_le32(&mms->write_out_ptr, 0);
+
+    return send_command_packet(mms);
+}
+
+/** Send the initial handshake. */
+static int send_startup_packet(MMSContext *mms)
+{
+    char data_string[256];
+    // SubscriberName is defined in MS specification linked below.
+    // The guid value can be any valid value.
+    // http://download.microsoft.com/
+    // download/9/5/E/95EF66AF-9026-4BB0-A41D-A4F81802D92C/%5BMS-WMSP%5D.pdf
+    snprintf(data_string, sizeof(data_string),
+            "NSPlayer/7.0.0.1956; {%s}; Host: %s",
+            "7E667F5D-A661-495E-A512-F55686DDA178", mms->host);
+
+    start_command_packet(mms, CS_PKT_INITIAL);
+    insert_command_prefixes(mms, 0, 0x0004000b);
+    bytestream_put_le32(&mms->write_out_ptr, 0x0003001c);
+    mms_put_utf16(mms, data_string);
+    return send_command_packet(mms);
+}
+
+static int asf_header_parser(MMSContext *mms)
+{
+    uint8_t *p = mms->asf_header;
+    uint8_t *end;
+    int flags, stream_id;
+    mms->stream_num = 0;
+
+    if (mms->asf_header_size < sizeof(ff_asf_guid) * 2 + 22 ||
+        memcmp(p, ff_asf_header, sizeof(ff_asf_guid)))
+        return -1;
+
+    end = mms->asf_header + mms->asf_header_size;
+
+    p += sizeof(ff_asf_guid) + 14;
+    while(end - p >= sizeof(ff_asf_guid) + 8) {
+        uint64_t chunksize = AV_RL64(p + sizeof(ff_asf_guid));
+        if (!chunksize || chunksize > end - p) {
+            dprintf(NULL, "chunksize is exceptional value:%"PRId64"!\n", chunksize);
+            return -1;
+        }
+        if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {
+            /* read packet size */
+            if (end - p > sizeof(ff_asf_guid) * 2 + 68) {
+                mms->asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64);
+                if (mms->asf_packet_len <= 0 || mms->asf_packet_len > sizeof(mms->in_buffer)) {
+                    dprintf(NULL,"Too large packet len:%d"
+                        " may overwrite in_buffer when padding", mms->asf_packet_len);
+                    return -1;
+                }
+            }
+        } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {
+            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);
+            stream_id = flags & 0x7F;
+            //The second condition is for checking CS_PKT_STREAM_ID_REQUEST packet size,
+            //we can calcuate the packet size by stream_num.
+            //Please see function send_stream_selection_request().
+            if (mms->stream_num < MAX_STREAMS &&
+                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {
+                mms->streams[mms->stream_num].id = stream_id;
+                mms->stream_num++;
+            } else {
+                dprintf(NULL, "Too many streams.\n");
+                return -1;
+            }
+        } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {
+            chunksize = 46; // see references [2] section 3.4. This should be set 46.
+        }
+        p += chunksize;
+    }
+
+    return 0;
+}
+
+/** Send MMST stream selection command based on the AVStream->discard values. */
+static int send_stream_selection_request(MMSContext *mms)
+{
+    int i;
+
+    //  send the streams we want back...
+    start_command_packet(mms, CS_PKT_STREAM_ID_REQUEST);
+    bytestream_put_le32(&mms->write_out_ptr, mms->stream_num);         // stream nums
+    for(i= 0; i<mms->stream_num; i++) {
+        bytestream_put_le16(&mms->write_out_ptr, 0xffff);              // flags
+        bytestream_put_le16(&mms->write_out_ptr, mms->streams[i].id);  // stream id
+        bytestream_put_le16(&mms->write_out_ptr, 0);                   // selection
+    }
+    return send_command_packet(mms);
+}
+
+static int read_data(MMSContext *mms, uint8_t *buf, const int buf_size)
+{
+    int read_size;
+    read_size = FFMIN(buf_size, mms->remaining_in_len);
+    memcpy(buf, mms->read_in_ptr, read_size);
+    mms->remaining_in_len -= read_size;
+    mms->read_in_ptr      += read_size;
+    return read_size;
+}
+
+/** Read at most one media packet (or a whole header). */
+static int read_mms_packet(MMSContext *mms, uint8_t *buf, int buf_size)
+{
+    int result = 0;
+    int size_to_copy;
+
+    do {
+        if(mms->asf_header_read_size < mms->asf_header_size && !mms->is_playing) {
+            /* Read from ASF header buffer */
+            size_to_copy= FFMIN(buf_size,
+                                mms->asf_header_size - mms->asf_header_read_size);
+            memcpy(buf, mms->asf_header + mms->asf_header_read_size, size_to_copy);
+            mms->asf_header_read_size += size_to_copy;
+            result += size_to_copy;
+            dprintf(NULL, "Copied %d bytes from stored header. left: %d\n",
+                   size_to_copy, mms->asf_header_size - mms->asf_header_read_size);
+            if (mms->asf_header_size == mms->asf_header_read_size) {
+                av_freep(&mms->asf_header);
+                mms->is_playing = 1;
+            }
+        } else if(mms->remaining_in_len) {
+            /* Read remaining packet data to buffer.
+             * the result can not be zero because remaining_in_len is positive.*/
+            result = read_data(mms, buf, buf_size);
+        } else {
+            /* Read from network */
+            int err = mms_safe_send_recv(mms, NULL, SC_PKT_ASF_MEDIA);
+            if (err == 0) {
+                if(mms->remaining_in_len>mms->asf_packet_len) {
+                    dprintf(NULL, "Incoming packet"
+                            "larger than the asf packet size stated (%d>%d)\n",
+                            mms->remaining_in_len, mms->asf_packet_len);
+                    result= AVERROR_IO;
+                } else {
+                    // copy the data to the packet buffer.
+                    result = read_data(mms, buf, buf_size);
+                    if (result == 0) {
+                        dprintf(NULL, "read asf media paket size is zero!\n");
+                        break;
+                    }
+                }
+            } else {
+                dprintf(NULL, "read packet error!\n");
+                break;
+            }
+        }
+    } while(!result); // only return one packet.
+    return result;
+}
+
+static int send_close_packet(MMSContext *mms)
+{
+    start_command_packet(mms, CS_PKT_STREAM_CLOSE);
+    insert_command_prefixes(mms, 1, 1);
+
+    return send_command_packet(mms);
+}
+
+/** Close the MMSH/MMST connection */
+static int mms_close(URLContext *h)
+{
+    MMSContext *mms = (MMSContext *)h->priv_data;
+
+    if(mms->mms_hd) {
+        send_close_packet(mms);
+        url_close(mms->mms_hd);
+    }
+
+    /* free all separately allocated pointers in mms */
+    av_free(mms->asf_header);
+    av_freep(&h->priv_data);
+
+    return 0;
+}
+
+static int mms_open(URLContext *h, const char *uri, int flags)
+{
+    MMSContext *mms;
+    int port, err;
+    char tcpname[256];
+
+    h->is_streamed = 1;
+    mms = h->priv_data = av_mallocz(sizeof(MMSContext));
+    if (!h->priv_data)
+        return AVERROR(ENOMEM);
+
+    // only for MMS over TCP, so set proto = NULL
+    av_url_split(NULL, 0, NULL, 0,
+            mms->host, sizeof(mms->host), &port, mms->path,
+            sizeof(mms->path), uri);
+
+    if(port<0)
+        port = 1755; // defaut mms protocol port
+
+    // establish tcp connection.
+    ff_url_join(tcpname, sizeof(tcpname), "tcp", NULL, mms->host, port, NULL);
+    err = url_open(&mms->mms_hd, tcpname, URL_RDWR);
+    if (err)
+        goto fail;
+
+    mms->packet_id        = 3;          // default, initial value.
+    mms->header_packet_id = 2;          // default, initial value.
+    err = mms_safe_send_recv(mms, send_startup_packet, SC_PKT_CLIENT_ACCEPTED);
+    if (err)
+        goto fail;
+    err = mms_safe_send_recv(mms, send_time_test_data, SC_PKT_TIMING_TEST_REPLY);
+    if (err)
+        goto fail;
+    err = mms_safe_send_recv(mms, send_protocol_select, SC_PKT_PROTOCOL_ACCEPTED);
+    if (err)
+        goto fail;
+    err = mms_safe_send_recv(mms, send_media_file_request, SC_PKT_MEDIA_FILE_DETAILS);
+    if (err)
+        goto fail;
+    err = mms_safe_send_recv(mms, send_media_header_request, SC_PKT_HEADER_REQUEST_ACCEPTED);
+    if (err)
+        goto fail;
+    err = mms_safe_send_recv(mms, NULL, SC_PKT_ASF_HEADER);
+    if (err)
+        goto fail;
+    if((mms->incoming_flags != 0X08) && (mms->incoming_flags != 0X0C))
+        goto fail;
+    err = asf_header_parser(mms);
+    if (err) {
+        dprintf(NULL, "asf header parsed failed!\n");
+        goto fail;
+    }
+    mms->header_parsed = 1;
+
+    if (!mms->asf_packet_len || !mms->stream_num)
+        goto fail;
+
+    dprintf(NULL, "Leaving open (success)\n");
+    return 0;
+fail:
+    mms_close(h);
+    dprintf(NULL, "Leaving open (failure: %d)\n", err);
+    return err;
+}
+
+static int send_media_packet_request(MMSContext *mms)
+{
+    start_command_packet(mms, CS_PKT_START_FROM_PKT_ID);
+    insert_command_prefixes(mms, 1, 0x0001FFFF);
+    bytestream_put_le64(&mms->write_out_ptr, 0);          // seek timestamp
+    bytestream_put_le32(&mms->write_out_ptr, 0xffffffff); // unknown
+    bytestream_put_le32(&mms->write_out_ptr, 0xffffffff); // packet offset
+    bytestream_put_byte(&mms->write_out_ptr, 0xff);       // max stream time limit
+    bytestream_put_byte(&mms->write_out_ptr, 0xff);       // max stream time limit
+    bytestream_put_byte(&mms->write_out_ptr, 0xff);       // max stream time limit
+    bytestream_put_byte(&mms->write_out_ptr, 0x00);       // stream time limit flag
+
+    mms->packet_id++;                                     // new packet_id
+    bytestream_put_le32(&mms->write_out_ptr, mms->packet_id);
+    return send_command_packet(mms);
+}
+
+
+static void clear_stream_buffers(MMSContext *mms)
+{
+    mms->remaining_in_len = 0;
+    mms->read_in_ptr      = mms->in_buffer;
+}
+
+/** Read ASF data through the protocol. */
+static int mms_read(URLContext *h, uint8_t *buf, int size)
+{
+    /* TODO: see tcp.c:tcp_read() about a possible timeout scheme */
+    MMSContext *mms = h->priv_data;
+    int result = 0;
+
+    /* Since we read the header at open(), this shouldn't be possible */
+    assert(mms->header_parsed);
+
+    if (!mms->is_playing) {
+        dprintf(NULL, "mms_read() before play().\n");
+        clear_stream_buffers(mms);
+        result = mms_safe_send_recv(mms, send_stream_selection_request, SC_PKT_STREAM_ID_ACCEPTED);
+        if (result)
+            return result;
+        // send media packet request
+        result = mms_safe_send_recv(mms, send_media_packet_request, SC_PKT_MEDIA_PKT_FOLLOWS);
+        if (result) {
+            return result;
+        }
+    }
+    return read_mms_packet(mms, buf, size);
+}
+
+URLProtocol mmst_protocol = {
+    "mmst",
+    mms_open,
+    mms_read,
+    NULL, // write
+    NULL, // seek
+    mms_close,
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -2298,3 +2298,15 @@
     .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
 };
 #endif
+/* MEANX */
+int movenc_init(void)
+{
+    av_register_output_format(&mov_muxer);
+    av_register_output_format(&tgp_muxer);
+    av_register_output_format(&mp4_muxer);
+    av_register_output_format(&psp_muxer);
+    av_register_output_format(&tg2_muxer);
+    av_register_output_format(&ipod_muxer);
+    return 0;
+}
+/* MEANX */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig	2010-07-25 10:07:46 UTC (rev 6481)
@@ -622,15 +622,18 @@
 } mov_pix_fmt_tags[] = {
     { PIX_FMT_YUYV422, MKTAG('y','u','v','s'),  0 },
     { PIX_FMT_UYVY422, MKTAG('2','v','u','y'),  0 },
-    { PIX_FMT_BGR555,  MKTAG('r','a','w',' '), 16 },
+    { PIX_FMT_RGB555BE,MKTAG('r','a','w',' '), 16 },
     { PIX_FMT_RGB555LE,MKTAG('L','5','5','5'), 16 },
     { PIX_FMT_RGB565LE,MKTAG('L','5','6','5'), 16 },
     { PIX_FMT_RGB565BE,MKTAG('B','5','6','5'), 16 },
+    { PIX_FMT_GRAY16BE,MKTAG('b','1','6','g'), 16 },
     { PIX_FMT_RGB24,   MKTAG('r','a','w',' '), 24 },
     { PIX_FMT_BGR24,   MKTAG('2','4','B','G'), 24 },
     { PIX_FMT_ARGB,    MKTAG('r','a','w',' '), 32 },
     { PIX_FMT_BGRA,    MKTAG('B','G','R','A'), 32 },
     { PIX_FMT_RGBA,    MKTAG('R','G','B','A'), 32 },
+    { PIX_FMT_ABGR,    MKTAG('A','B','G','R'), 32 },
+    { PIX_FMT_RGB48BE, MKTAG('b','4','8','r'), 48 },
 };
 
 static int mov_get_rawvideo_codec_tag(AVFormatContext *s, MOVTrack *track)
@@ -744,6 +747,19 @@
     return updateSize(pb, pos);
 }
 
+static int mov_write_pasp_tag(ByteIOContext *pb, MOVTrack *track)
+{
+    AVRational sar;
+    av_reduce(&sar.num, &sar.den, track->enc->sample_aspect_ratio.num,
+              track->enc->sample_aspect_ratio.den, INT_MAX);
+
+    put_be32(pb, 16);
+    put_tag(pb, "pasp");
+    put_be32(pb, track->enc->sample_aspect_ratio.num);
+    put_be32(pb, track->enc->sample_aspect_ratio.den);
+    return 16;
+}
+
 static int mov_write_video_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int64_t pos = url_ftell(pb);
@@ -805,6 +821,12 @@
     } else if(track->vosLen > 0)
         mov_write_glbl_tag(pb, track);
 
+    if (track->mode == MODE_MOV &&
+        track->enc->sample_aspect_ratio.den && track->enc->sample_aspect_ratio.num &&
+        track->enc->sample_aspect_ratio.den != track->enc->sample_aspect_ratio.num) {
+        mov_write_pasp_tag(pb, track);
+    }
+
     return updateSize(pb, pos);
 }
 
@@ -1608,8 +1630,8 @@
         put_be32(pb, size+8);
         put_tag(pb, "udta");
         put_buffer(pb, buf, size);
-        av_free(buf);
     }
+    av_free(buf);
 
     return 0;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -1300,3 +1300,13 @@
     mpeg_mux_end,
 };
 #endif
+// MEANX
+//
+int mpegenc_init(void)
+{
+    av_register_output_format(&mpeg2dvd_muxer);
+    av_register_output_format(&mpeg2svcd_muxer);
+    av_register_output_format(&mpeg2vob_muxer);
+    av_register_output_format(&mpeg1vcd_muxer);
+    return 0;
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -947,3 +947,8 @@
     mpegts_write_packet,
     mpegts_write_end,
 };
+int mpegtsenc_init(void)
+{
+    av_register_output_format(&mpegts_muxer);
+    return 0;
+}
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,30 @@
+/*
+ * RSO format common data
+ * Copyright (c) 2010 Rafael Carre
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avformat.h"
+#include "internal.h"
+#include "rso.h"
+
+const AVCodecTag ff_codec_rso_tags[] = {
+    { CODEC_ID_PCM_U8,          0x0100 },
+    { CODEC_ID_ADPCM_IMA_WAV,   0x0101 },
+    { CODEC_ID_NONE, 0 },
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,32 @@
+/*
+ * RSO format common data
+ * Copyright (c) 2010 Rafael Carre
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_RSO_H
+#define AVFORMAT_RSO_H
+
+#include "internal.h"
+
+#define RSO_HEADER_SIZE 8
+
+/* The ffmpeg codecs we support, and the IDs they have in the file */
+extern const AVCodecTag ff_codec_rso_tags[];
+
+#endif /* AVFORMAT_RSO_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsodec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsodec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsodec.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,102 @@
+/*
+ * RSO demuxer
+ * Copyright (c) 2001 Fabrice Bellard (original AU code)
+ * Copyright (c) 2010 Rafael Carre
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/intreadwrite.h"
+#include "avformat.h"
+#include "internal.h"
+#include "raw.h"
+#include "riff.h"
+#include "rso.h"
+
+static int rso_read_header(AVFormatContext *s, AVFormatParameters *ap)
+{
+    ByteIOContext *pb = s->pb;
+    int id, rate, bps;
+    unsigned int size;
+    enum CodecID codec;
+    AVStream *st;
+
+    id   = get_be16(pb);
+    size = get_be16(pb);
+    rate = get_be16(pb);
+    get_be16(pb);   /* play mode ? (0x0000 = don't loop) */
+
+    codec = ff_codec_get_id(ff_codec_rso_tags, id);
+
+    if (codec == CODEC_ID_ADPCM_IMA_WAV) {
+        av_log(s, AV_LOG_ERROR, "ADPCM in RSO not implemented\n");
+        return AVERROR_PATCHWELCOME;
+    }
+
+    bps = av_get_bits_per_sample(codec);
+    if (!bps) {
+        av_log_ask_for_sample(s, "could not determine bits per sample\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    /* now we are ready: build format streams */
+    st = av_new_stream(s, 0);
+    if (!st)
+        return AVERROR(ENOMEM);
+
+    st->duration            = (size * 8) / bps;
+    st->codec->codec_type   = AVMEDIA_TYPE_AUDIO;
+    st->codec->codec_tag    = id;
+    st->codec->codec_id     = codec;
+    st->codec->channels     = 1;
+    st->codec->sample_rate  = rate;
+
+    av_set_pts_info(st, 64, 1, rate);
+
+    return 0;
+}
+
+#define BLOCK_SIZE 1024 /* in samples */
+
+static int rso_read_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    int bps = av_get_bits_per_sample(s->streams[0]->codec->codec_id);
+    int ret = av_get_packet(s->pb, pkt, BLOCK_SIZE * bps >> 3);
+
+    if (ret < 0)
+        return ret;
+
+    pkt->stream_index = 0;
+
+    /* note: we need to modify the packet size here to handle the last packet */
+    pkt->size = ret;
+
+    return 0;
+}
+
+AVInputFormat rso_demuxer = {
+    .name           =   "rso",
+    .long_name      =   NULL_IF_CONFIG_SMALL("Lego Mindstorms RSO format"),
+    .extensions     =   "rso",
+    .priv_data_size =   0,
+    .read_probe     =   NULL, /* no magic value in this format */
+    .read_header    =   rso_read_header,
+    .read_packet    =   rso_read_packet,
+    .read_close     =   NULL,
+    .read_seek      =   pcm_read_seek,
+    .codec_tag      =   (const AVCodecTag* const []){ff_codec_rso_tags, 0},
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsoenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsoenc.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsoenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,114 @@
+/*
+ * RSO muxer
+ * Copyright (c) 2001 Fabrice Bellard (original AU code)
+ * Copyright (c) 2010 Rafael Carre
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avformat.h"
+#include "internal.h"
+#include "riff.h"
+#include "rso.h"
+
+static int rso_write_header(AVFormatContext *s)
+{
+    ByteIOContext  *pb  = s->pb;
+    AVCodecContext *enc = s->streams[0]->codec;
+
+    if (!enc->codec_tag)
+        return AVERROR_INVALIDDATA;
+
+    if (enc->channels != 1) {
+        av_log(s, AV_LOG_ERROR, "RSO only supports mono\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (url_is_streamed(s->pb)) {
+        av_log(s, AV_LOG_ERROR, "muxer does not support non seekable output\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    /* XXX: find legal sample rates (if any) */
+    if (enc->sample_rate >= 1u<<16) {
+        av_log(s, AV_LOG_ERROR, "Sample rate must be < 65536\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (enc->codec_id == CODEC_ID_ADPCM_IMA_WAV) {
+        av_log(s, AV_LOG_ERROR, "ADPCM in RSO not implemented\n");
+        return AVERROR_PATCHWELCOME;
+    }
+
+    /* format header */
+    put_be16(pb, enc->codec_tag);   /* codec ID */
+    put_be16(pb, 0);                /* data size, will be written at EOF */
+    put_be16(pb, enc->sample_rate);
+    put_be16(pb, 0x0000);           /* play mode ? (0x0000 = don't loop) */
+
+    put_flush_packet(pb);
+
+    return 0;
+}
+
+static int rso_write_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    put_buffer(s->pb, pkt->data, pkt->size);
+    return 0;
+}
+
+static int rso_write_trailer(AVFormatContext *s)
+{
+    ByteIOContext *pb = s->pb;
+    int64_t file_size;
+    uint16_t coded_file_size;
+
+    file_size = url_ftell(pb);
+
+    if (file_size < 0)
+        return file_size;
+
+    if (file_size > 0xffff + RSO_HEADER_SIZE) {
+        av_log(s, AV_LOG_WARNING,
+               "Output file is too big (%"PRId64" bytes >= 64kB)\n", file_size);
+        coded_file_size = 0xffff;
+    } else {
+        coded_file_size = file_size - RSO_HEADER_SIZE;
+    }
+
+    /* update file size */
+    url_fseek(pb, 2, SEEK_SET);
+    put_be16(pb, coded_file_size);
+    url_fseek(pb, file_size, SEEK_SET);
+
+    put_flush_packet(pb);
+
+    return 0;
+}
+
+AVOutputFormat rso_muxer = {
+    .name           =   "rso",
+    .long_name      =   NULL_IF_CONFIG_SMALL("Lego Mindstorms RSO format"),
+    .extensions     =   "rso",
+    .priv_data_size =   0,
+    .audio_codec    =   CODEC_ID_PCM_U8,
+    .video_codec    =   CODEC_ID_NONE,
+    .write_header   =   rso_write_header,
+    .write_packet   =   rso_write_packet,
+    .write_trailer  =   rso_write_trailer,
+    .codec_tag      =   (const AVCodecTag* const []){ff_codec_rso_tags, 0},
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,281 @@
+/**
+ * Common code for the RTP depacketization of MPEG-4 formats.
+ * Copyright (c) 2010 Fabrice Bellard
+ *                    Romain Degez
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @brief MPEG4 / RTP Code
+ * @author Fabrice Bellard
+ * @author Romain Degez
+ */
+
+#include "rtpdec_mpeg4.h"
+#include "internal.h"
+#include "libavutil/avstring.h"
+#include "libavcodec/get_bits.h"
+#include <strings.h>
+
+/** Structure listing useful vars to parse RTP packet payload*/
+struct PayloadContext
+{
+    int sizelength;
+    int indexlength;
+    int indexdeltalength;
+    int profile_level_id;
+    int streamtype;
+    int objecttype;
+    char *mode;
+
+    /** mpeg 4 AU headers */
+    struct AUHeaders {
+        int size;
+        int index;
+        int cts_flag;
+        int cts;
+        int dts_flag;
+        int dts;
+        int rap_flag;
+        int streamstate;
+    } *au_headers;
+    int au_headers_allocated;
+    int nb_au_headers;
+    int au_headers_length_bytes;
+    int cur_au_index;
+};
+
+/* return the length and optionally the data */
+static int hex_to_data(uint8_t *data, const char *p)
+{
+    int c, len, v;
+
+    len = 0;
+    v = 1;
+    for (;;) {
+        p += strspn(p, SPACE_CHARS);
+        if (*p == '\0')
+            break;
+        c = toupper((unsigned char) *p++);
+        if (c >= '0' && c <= '9')
+            c = c - '0';
+        else if (c >= 'A' && c <= 'F')
+            c = c - 'A' + 10;
+        else
+            break;
+        v = (v << 4) | c;
+        if (v & 0x100) {
+            if (data)
+                data[len] = v;
+            len++;
+            v = 1;
+        }
+    }
+    return len;
+}
+
+typedef struct {
+    const char *str;
+    uint16_t    type;
+    uint32_t    offset;
+} AttrNameMap;
+
+/* All known fmtp parameters and the corresponding RTPAttrTypeEnum */
+#define ATTR_NAME_TYPE_INT 0
+#define ATTR_NAME_TYPE_STR 1
+static const AttrNameMap attr_names[]=
+{
+    { "SizeLength",       ATTR_NAME_TYPE_INT,
+      offsetof(PayloadContext, sizelength) },
+    { "IndexLength",      ATTR_NAME_TYPE_INT,
+      offsetof(PayloadContext, indexlength) },
+    { "IndexDeltaLength", ATTR_NAME_TYPE_INT,
+      offsetof(PayloadContext, indexdeltalength) },
+    { "profile-level-id", ATTR_NAME_TYPE_INT,
+      offsetof(PayloadContext, profile_level_id) },
+    { "StreamType",       ATTR_NAME_TYPE_INT,
+      offsetof(PayloadContext, streamtype) },
+    { "mode",             ATTR_NAME_TYPE_STR,
+      offsetof(PayloadContext, mode) },
+    { NULL, -1, -1 },
+};
+
+static PayloadContext *new_context(void)
+{
+    return av_mallocz(sizeof(PayloadContext));
+}
+
+static void free_context(PayloadContext * data)
+{
+    int i;
+    for (i = 0; i < data->nb_au_headers; i++) {
+         /* according to rtp_parse_mp4_au, we treat multiple
+          * au headers as one, so nb_au_headers is always 1.
+          * loop anyway in case this changes.
+          * (note: changes done carelessly might lead to a double free)
+          */
+       av_free(&data->au_headers[i]);
+    }
+    av_free(data->mode);
+    av_free(data);
+}
+
+static int parse_fmtp_config(AVCodecContext * codec, char *value)
+{
+    /* decode the hexa encoded parameter */
+    int len = hex_to_data(NULL, value);
+    if (codec->extradata)
+        av_free(codec->extradata);
+    codec->extradata = av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);
+    if (!codec->extradata)
+        return AVERROR(ENOMEM);
+    codec->extradata_size = len;
+    hex_to_data(codec->extradata, value);
+    return 0;
+}
+
+static int rtp_parse_mp4_au(PayloadContext *data, const uint8_t *buf)
+{
+    int au_headers_length, au_header_size, i;
+    GetBitContext getbitcontext;
+
+    /* decode the first 2 bytes where the AUHeader sections are stored
+       length in bits */
+    au_headers_length = AV_RB16(buf);
+
+    if (au_headers_length > RTP_MAX_PACKET_LENGTH)
+      return -1;
+
+    data->au_headers_length_bytes = (au_headers_length + 7) / 8;
+
+    /* skip AU headers length section (2 bytes) */
+    buf += 2;
+
+    init_get_bits(&getbitcontext, buf, data->au_headers_length_bytes * 8);
+
+    /* XXX: Wrong if optionnal additional sections are present (cts, dts etc...) */
+    au_header_size = data->sizelength + data->indexlength;
+    if (au_header_size <= 0 || (au_headers_length % au_header_size != 0))
+        return -1;
+
+    data->nb_au_headers = au_headers_length / au_header_size;
+    if (!data->au_headers || data->au_headers_allocated < data->nb_au_headers) {
+        av_free(data->au_headers);
+        data->au_headers = av_malloc(sizeof(struct AUHeaders) * data->nb_au_headers);
+        data->au_headers_allocated = data->nb_au_headers;
+    }
+
+    /* XXX: We handle multiple AU Section as only one (need to fix this for interleaving)
+       In my test, the FAAD decoder does not behave correctly when sending each AU one by one
+       but does when sending the whole as one big packet...  */
+    data->au_headers[0].size = 0;
+    data->au_headers[0].index = 0;
+    for (i = 0; i < data->nb_au_headers; ++i) {
+        data->au_headers[0].size += get_bits_long(&getbitcontext, data->sizelength);
+        data->au_headers[0].index = get_bits_long(&getbitcontext, data->indexlength);
+    }
+
+    data->nb_au_headers = 1;
+
+    return 0;
+}
+
+
+/* Follows RFC 3640 */
+static int aac_parse_packet(AVFormatContext *ctx,
+                            PayloadContext *data,
+                            AVStream *st,
+                            AVPacket *pkt,
+                            uint32_t *timestamp,
+                            const uint8_t *buf, int len, int flags)
+{
+    if (rtp_parse_mp4_au(data, buf))
+        return -1;
+
+    buf += data->au_headers_length_bytes + 2;
+    len -= data->au_headers_length_bytes + 2;
+
+    /* XXX: Fixme we only handle the case where rtp_parse_mp4_au define
+                    one au_header */
+    av_new_packet(pkt, data->au_headers[0].size);
+    memcpy(pkt->data, buf, data->au_headers[0].size);
+
+    pkt->stream_index = st->index;
+    return 0;
+}
+
+static int parse_fmtp(AVStream *stream, PayloadContext *data,
+                      char *attr, char *value)
+{
+    AVCodecContext *codec = stream->codec;
+    int res, i;
+
+    if (!strcmp(attr, "config")) {
+        res = parse_fmtp_config(codec, value);
+
+        if (res < 0)
+            return res;
+    }
+
+    if (codec->codec_id == CODEC_ID_AAC) {
+        /* Looking for a known attribute */
+        for (i = 0; attr_names[i].str; ++i) {
+            if (!strcasecmp(attr, attr_names[i].str)) {
+                if (attr_names[i].type == ATTR_NAME_TYPE_INT) {
+                    *(int *)((char *)data+
+                        attr_names[i].offset) = atoi(value);
+                } else if (attr_names[i].type == ATTR_NAME_TYPE_STR)
+                    *(char **)((char *)data+
+                        attr_names[i].offset) = av_strdup(value);
+            }
+        }
+    }
+    return 0;
+}
+
+static int parse_sdp_line(AVFormatContext *s, int st_index,
+                          PayloadContext *data, const char *line)
+{
+    const char *p;
+
+    if (av_strstart(line, "fmtp:", &p))
+        return ff_parse_fmtp(s->streams[st_index], data, p, parse_fmtp);
+
+    return 0;
+}
+
+RTPDynamicProtocolHandler ff_mp4v_es_dynamic_handler = {
+    .enc_name           = "MP4V-ES",
+    .codec_type         = AVMEDIA_TYPE_VIDEO,
+    .codec_id           = CODEC_ID_MPEG4,
+    .parse_sdp_a_line   = parse_sdp_line,
+    .open               = NULL,
+    .close              = NULL,
+    .parse_packet       = NULL
+};
+
+RTPDynamicProtocolHandler ff_mpeg4_generic_dynamic_handler = {
+    .enc_name           = "mpeg4-generic",
+    .codec_type         = AVMEDIA_TYPE_AUDIO,
+    .codec_id           = CODEC_ID_AAC,
+    .parse_sdp_a_line   = parse_sdp_line,
+    .open               = new_context,
+    .close              = free_context,
+    .parse_packet       = aac_parse_packet
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,39 @@
+/**
+ * Common code for the RTP depacketization of MPEG-4 formats.
+ * Copyright (c) 2010 Fabrice Bellard
+ *                    Romain Degez
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_RTPDEC_MPEG4_H
+#define AVFORMAT_RTPDEC_MPEG4_H
+
+#include "rtpdec.h"
+
+/**
+ * MPEG-4 Video RTP callbacks. (RFC 3016)
+ */
+extern RTPDynamicProtocolHandler ff_mp4v_es_dynamic_handler;
+
+/**
+ * AAC RTP callbacks. (RFC 3640)
+ */
+extern RTPDynamicProtocolHandler ff_mpeg4_generic_dynamic_handler;
+
+#endif /* AVFORMAT_RTPDEC_MPEG4_H */
+

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,316 @@
+/*
+ * QDesign Music 2 (QDM2) payload for RTP
+ * Copyright (c) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @brief RTP support for the QDM2 payload (todo: wiki)
+ * @author Ronald S. Bultje <rbultje at ronald.bitfreak.net>
+ */
+
+#include <string.h>
+#include "libavutil/intreadwrite.h"
+#include "libavcodec/avcodec.h"
+#include "rtp.h"
+#include "rtpdec.h"
+#include "rtpdec_qdm2.h"
+
+struct PayloadContext {
+    /** values read from the config header, used as packet headers */
+    //@{
+    int block_type;            ///< superblock type, value 2 .. 8
+    int block_size;            ///< from extradata, used as pkt length
+    int subpkts_per_block;     ///< max. nr. of subpackets to add per output buffer
+    //@}
+
+    /** Temporary storage for superblock restoring, per packet ID (0x80 total) */
+    //@{
+    uint16_t len[0x80];        ///< how much the temporary buffer is filled
+    uint8_t  buf[0x80][0x800]; ///< the temporary storage buffer
+
+    unsigned int cache;        ///< number of data packets that we have cached right now
+    unsigned int n_pkts;       ///< number of RTP packets received since last packet output / config
+    uint32_t timestamp;        ///< timestamp of next-to-be-returned packet
+    //@}
+};
+
+/**
+ * Parses configuration (basically the codec-specific extradata) from
+ * a RTP config subpacket (starts with 0xff).
+ *
+ * Layout of the config subpacket (in bytes):
+ * 1: 0xFF          <- config ID
+ * then an array {
+ *     1: size      <- of the current item
+ *     1: item type <- 0 .. 4
+ *     size-2: data <- data depends on the item type
+ * }
+ *
+ * Item 0 implies the end of the config subpacket, and has no data.
+ * Item 1 implies a stream configuration without extradata.
+ * Item 2 max. nr. of subpackets per superblock
+ * Item 3 superblock type for the stream
+ * Item 4 implies a stream configuration with extradata (size >= 0x1c).
+ *
+ * @return <0 on error, otherwise the number of bytes parsed from the
+ *         input buffer.
+ */
+static int qdm2_parse_config(PayloadContext *qdm, AVStream *st,
+                             const uint8_t *buf, const uint8_t *end)
+{
+    const uint8_t *p = buf;
+
+    while (end - p >= 2) {
+        unsigned int item_len = p[0], config_item = p[1];
+
+        if (item_len < 2 || end - p < item_len || config_item > 4)
+            return AVERROR_INVALIDDATA;
+
+        switch (config_item) {
+            case 0: /* end of config block */
+                return p - buf + item_len;
+            case 1: /* stream without extradata */
+                /* FIXME: set default qdm->block_size */
+                break;
+            case 2: /**< subpackets per block */
+                if (item_len < 3)
+                    return AVERROR_INVALIDDATA;
+                qdm->subpkts_per_block = p[2];
+                break;
+            case 3: /* superblock type */
+                if (item_len < 4)
+                    return AVERROR_INVALIDDATA;
+                qdm->block_type = AV_RB16(p + 2);
+                break;
+            case 4: /* stream with extradata */
+                if (item_len < 30)
+                    return AVERROR_INVALIDDATA;
+                av_freep(&st->codec->extradata);
+                st->codec->extradata_size = 26 + item_len;
+                if (!(st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE))) {
+                    st->codec->extradata_size = 0;
+                    return AVERROR(ENOMEM);
+                }
+                AV_WB32(st->codec->extradata, 12);
+                memcpy(st->codec->extradata + 4, "frma", 4);
+                memcpy(st->codec->extradata + 8, "QDM2", 4);
+                AV_WB32(st->codec->extradata + 12, 6 + item_len);
+                memcpy(st->codec->extradata + 16, "QDCA", 4);
+                memcpy(st->codec->extradata + 20, p + 2, item_len - 2);
+                AV_WB32(st->codec->extradata + 18 + item_len, 8);
+                AV_WB32(st->codec->extradata + 22 + item_len, 0);
+
+                qdm->block_size = AV_RB32(p + 26);
+                break;
+        }
+
+        p += item_len;
+    }
+
+    return AVERROR(EAGAIN); /* not enough data */
+}
+
+/**
+ * Parses a single subpacket. We store this subpacket in an intermediate
+ * buffer (position depends on the ID (byte[0]). When called, at least
+ * 4 bytes are available for reading (see qdm2_parse_packet()).
+ *
+ * Layout of a single subpacket (RTP packets commonly contain multiple
+ * such subpackets) - length in bytes:
+ * 1:    ordering ID        <- 0 .. 0x7F
+ * 1:    subpacket type     <- 0 .. 0x7F; value & 0x80 means subpacket length = 2 bytes, else 1 byte
+ * 1/2:  subpacket length   <- length of the data following the flags/length fields
+ * if (subpacket type & 0x7F) == 0x7F
+ *   1:  subpacket type, higher bits
+ * size: subpacket data
+ *
+ * The subpackets come in randomly, and should be encapsulated into 1
+ * or more superblocks (containing qdm->subpkts_per_block subpackets
+ * each) per RTP packet, in order of ascending "ordering ID", see
+ * qdm2_restore_block().
+ *
+ * @return <0 on error, otherwise the number of bytes parsed from the
+ *         input buffer.
+ */
+static int qdm2_parse_subpacket(PayloadContext *qdm, AVStream *st,
+                                const uint8_t *buf, const uint8_t *end)
+{
+    const uint8_t *p = buf;
+    unsigned int id, len, type, to_copy;
+
+    /* parse header so we know the size of the header/data */
+    id       = *p++;
+    type     = *p++;
+    if (type & 0x80) {
+        len   = AV_RB16(p);
+        p    += 2;
+        type &= 0x7F;
+    } else
+        len = *p++;
+
+    if (end - p < len + (type == 0x7F) || id >= 0x80)
+        return AVERROR_INVALIDDATA;
+    if (type == 0x7F)
+        type |= *p++ << 8;
+
+    /* copy data into a temporary buffer */
+    to_copy = FFMIN(len + (p - &buf[1]), 0x800 - qdm->len[id]);
+    memcpy(&qdm->buf[id][qdm->len[id]], buf + 1, to_copy);
+    qdm->len[id] += to_copy;
+
+    return p + len - buf;
+}
+
+/**
+ * Adds a superblock header around a set of subpackets.
+ *
+ * @return <0 on error, else 0.
+ */
+static int qdm2_restore_block(PayloadContext *qdm, AVStream *st, AVPacket *pkt)
+{
+    int to_copy, n, res, include_csum;
+    uint8_t *p, *csum_pos = NULL;
+
+    /* create packet to hold subpkts into a superblock */
+    assert(qdm->cache > 0);
+    for (n = 0; n < 0x80; n++)
+        if (qdm->len[n] > 0)
+            break;
+    assert(n < 0x80);
+
+    if ((res = av_new_packet(pkt, qdm->block_size)) < 0)
+        return res;
+    memset(pkt->data, 0, pkt->size);
+    pkt->stream_index  = st->index;
+    p                  = pkt->data;
+
+    /* superblock header */
+    if (qdm->len[n] > 0xff) {
+        *p++ = qdm->block_type | 0x80;
+        AV_WB16(p, qdm->len[n]);
+        p   += 2;
+    } else {
+        *p++ = qdm->block_type;
+        *p++ = qdm->len[n];
+    }
+    if ((include_csum = (qdm->block_type == 2 || qdm->block_type == 4))) {
+        csum_pos = p;
+        p       += 2;
+    }
+
+    /* subpacket data */
+    to_copy = FFMIN(qdm->len[n], pkt->size - (p - pkt->data));
+    memcpy(p, qdm->buf[n], to_copy);
+    qdm->len[n] = 0;
+
+    /* checksum header */
+    if (include_csum) {
+        unsigned int total = 0;
+        uint8_t *q;
+
+        for (q = pkt->data; q < &pkt->data[qdm->block_size]; q++)
+            total += *q;
+        AV_WB16(csum_pos, (uint16_t) total);
+    }
+
+    return 0;
+}
+
+/** return 0 on packet, no more left, 1 on packet, -1 on partial packet... */
+static int qdm2_parse_packet(AVFormatContext *s, PayloadContext *qdm,
+                             AVStream *st, AVPacket *pkt,
+                             uint32_t *timestamp,
+                             const uint8_t *buf, int len, int flags)
+{
+    int res = AVERROR_INVALIDDATA, n;
+    const uint8_t *end = buf + len, *p = buf;
+
+    if (len > 0) {
+        if (len < 2)
+            return AVERROR_INVALIDDATA;
+
+        /* configuration block */
+        if (*p == 0xff) {
+            if (qdm->n_pkts > 0) {
+                av_log(s, AV_LOG_WARNING,
+                       "Out of sequence config - dropping queue\n");
+                qdm->n_pkts = 0;
+                memset(qdm->len, 0, sizeof(qdm->len));
+            }
+
+            if ((res = qdm2_parse_config(qdm, st, ++p, end)) < 0)
+                return res;
+            p += res;
+
+            /* We set codec_id to CODEC_ID_NONE initially to
+             * delay decoder initialization since extradata is
+             * carried within the RTP stream, not SDP. Here,
+             * by setting codec_id to CODEC_ID_QDM2, we are signalling
+             * to the decoder that it is OK to initialize. */
+            st->codec->codec_id = CODEC_ID_QDM2;
+        }
+
+        /* subpackets */
+        while (end - p >= 4) {
+            if ((res = qdm2_parse_subpacket(qdm, st, p, end)) < 0)
+                return res;
+            p += res;
+        }
+
+        qdm->timestamp = *timestamp;
+        if (++qdm->n_pkts < qdm->subpkts_per_block)
+            return AVERROR(EAGAIN);
+        qdm->cache = 0;
+        for (n = 0; n < 0x80; n++)
+            if (qdm->len[n] > 0)
+                qdm->cache++;
+    }
+
+    /* output the subpackets into freshly created superblock structures */
+    if (!qdm->cache || (res = qdm2_restore_block(qdm, st, pkt)) < 0)
+        return res;
+    if (--qdm->cache == 0)
+        qdm->n_pkts = 0;
+
+    *timestamp = qdm->timestamp;
+    qdm->timestamp = RTP_NOTS_VALUE;
+
+    return (qdm->cache > 0) ? 1 : 0;
+}
+
+static PayloadContext *qdm2_extradata_new(void)
+{
+    return av_mallocz(sizeof(PayloadContext));
+}
+
+static void qdm2_extradata_free(PayloadContext *qdm)
+{
+    av_free(qdm);
+}
+
+RTPDynamicProtocolHandler ff_qdm2_dynamic_handler = {
+    "X-QDM",
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_NONE,
+    NULL,
+    qdm2_extradata_new,
+    qdm2_extradata_free,
+    qdm2_parse_packet,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,32 @@
+/*
+ * QDesign Music 2 (QDM2) payload for RTP
+ * Copyright (c) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_RTPDEC_QDM2_H
+#define AVFORMAT_RTPDEC_QDM2_H
+
+#include "rtpdec.h"
+
+/**
+ * QMD2 RTP callbacks.
+ */
+extern RTPDynamicProtocolHandler ff_qdm2_dynamic_handler;
+
+#endif /* AVFORMAT_RTPDEC_QDM2_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,138 @@
+/*
+ * Sorenson-3 (SVQ3/SV3V) payload for RTP
+ * Copyright (c) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @brief RTP support for the SV3V (SVQ3) payload
+ * (http://wiki.multimedia.cx/index.php?title=Sorenson_Video_3#Packetization)
+ * @author Ronald S. Bultje <rbultje at ronald.bitfreak.net>
+ */
+
+#include <string.h>
+#include <libavcodec/get_bits.h>
+#include "rtp.h"
+#include "rtpdec.h"
+#include "rtpdec_svq3.h"
+
+struct PayloadContext {
+    ByteIOContext *pktbuf;
+    int64_t        timestamp;
+    int            is_keyframe;
+};
+
+/** return 0 on packet, <0 on partial packet or error... */
+static int svq3_parse_packet (AVFormatContext *s, PayloadContext *sv,
+                              AVStream *st, AVPacket *pkt,
+                              uint32_t *timestamp,
+                              const uint8_t *buf, int len, int flags)
+{
+    int config_packet, start_packet, end_packet;
+
+    if (len < 2)
+        return AVERROR_INVALIDDATA;
+
+    config_packet = buf[0] & 0x40;
+    start_packet  = buf[0] & 0x20;
+    end_packet    = buf[0] & 0x10;
+    buf += 2;     // ignore buf[1]
+    len -= 2;
+
+    if (config_packet) {
+
+        av_freep(&st->codec->extradata);
+        st->codec->extradata_size = 0;
+
+        if (len < 2 || !(st->codec->extradata =
+                         av_malloc(len + 8 + FF_INPUT_BUFFER_PADDING_SIZE)))
+            return AVERROR_INVALIDDATA;
+
+        st->codec->extradata_size = len + 8;
+        memcpy(st->codec->extradata, "SEQH", 4);
+        AV_WB32(st->codec->extradata + 4, len);
+        memcpy(st->codec->extradata + 8, buf, len);
+
+        /* We set codec_id to CODEC_ID_NONE initially to
+         * delay decoder initialization since extradata is
+         * carried within the RTP stream, not SDP. Here,
+         * by setting codec_id to CODEC_ID_SVQ3, we are signalling
+         * to the decoder that it is OK to initialize. */
+        st->codec->codec_id = CODEC_ID_SVQ3;
+
+        return AVERROR(EAGAIN);
+    }
+
+    if (start_packet) {
+        int res;
+
+        if (sv->pktbuf) {
+            uint8_t *tmp;
+            url_close_dyn_buf(sv->pktbuf, &tmp);
+            av_free(tmp);
+        }
+        if ((res = url_open_dyn_buf(&sv->pktbuf)) < 0)
+            return res;
+        sv->timestamp   = *timestamp;
+        sv->is_keyframe = flags & RTP_FLAG_KEY;
+    }
+
+    if (!sv->pktbuf)
+        return AVERROR_INVALIDDATA;
+
+    put_buffer(sv->pktbuf, buf, len);
+
+    if (end_packet) {
+        av_init_packet(pkt);
+        pkt->stream_index = st->index;
+        *timestamp        = sv->timestamp;
+        pkt->flags        = sv->is_keyframe ? AV_PKT_FLAG_KEY : 0;
+        pkt->size         = url_close_dyn_buf(sv->pktbuf, &pkt->data);
+        pkt->destruct     = av_destruct_packet;
+        sv->pktbuf        = NULL;
+        return 0;
+    }
+
+    return AVERROR(EAGAIN);
+}
+
+static PayloadContext *svq3_extradata_new(void)
+{
+    return av_mallocz(sizeof(PayloadContext));
+}
+
+static void svq3_extradata_free(PayloadContext *sv)
+{
+    if (sv->pktbuf) {
+        uint8_t *buf;
+        url_close_dyn_buf(sv->pktbuf, &buf);
+        av_free(buf);
+    }
+    av_free(sv);
+}
+
+RTPDynamicProtocolHandler ff_svq3_dynamic_handler = {
+    "X-SV3V-ES",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_NONE,          // see if (config_packet) above
+    NULL,                   // parse sdp line
+    svq3_extradata_new,
+    svq3_extradata_free,
+    svq3_parse_packet,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,33 @@
+/*
+ * Sorenson-3 (SVQ3/SV3V) payload for RTP
+ * Copyright (c) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_RTPDEC_SVQ3_H
+#define AVFORMAT_RTPDEC_SVQ3_H
+
+#include "libavcodec/avcodec.h"
+#include "rtpdec.h"
+
+/**
+ * Sorenson-3 RTP callbacks.
+ */
+extern RTPDynamicProtocolHandler ff_svq3_dynamic_handler;
+
+#endif /* AVFORMAT_RTPDEC_SVQ3_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,103 @@
+/*
+ * SAUCE header parser
+ * Copyright (c) 2010 Peter Ross <pross at xvid.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * SAUCE header parser
+ */
+
+#include "libavutil/intreadwrite.h"
+#include "avformat.h"
+#include "sauce.h"
+
+int ff_sauce_read(AVFormatContext *avctx, uint64_t *fsize, int *got_width, int get_height)
+{
+    ByteIOContext *pb = avctx->pb;
+    char buf[36];
+    int datatype, filetype, t1, t2, nb_comments, flags;
+    uint64_t start_pos = url_fsize(pb) - 128;
+
+    url_fseek(pb, start_pos, SEEK_SET);
+    if (get_buffer(pb, buf, 7) != 7)
+        return -1;
+    if (memcmp(buf, "SAUCE00", 7))
+        return -1;
+
+#define GET_SAUCE_META(name,size) \
+    if (get_buffer(pb, buf, size) == size && buf[0]) { \
+        buf[size] = 0; \
+        av_metadata_set2(&avctx->metadata, name, buf, 0); \
+    }
+
+    GET_SAUCE_META("title",     35)
+    GET_SAUCE_META("artist",    20)
+    GET_SAUCE_META("publisher", 20)
+    GET_SAUCE_META("date",      8)
+    url_fskip(pb, 4);
+    datatype    = get_byte(pb);
+    filetype    = get_byte(pb);
+    t1          = get_le16(pb);
+    t2          = get_le16(pb);
+    nb_comments = get_byte(pb);
+    flags       = get_byte(pb);
+    url_fskip(pb, 4);
+    GET_SAUCE_META("encoder",   22);
+
+    if (got_width && datatype && filetype) {
+        if ((datatype == 1 && filetype <=2) || (datatype == 5 && filetype == 255) || datatype == 6) {
+            if (t1) {
+                avctx->streams[0]->codec->width = t1<<3;
+                *got_width = 1;
+            }
+            if (get_height && t2)
+                avctx->streams[0]->codec->height = t2<<4;
+        } else if (datatype == 5) {
+            if (filetype > 1) {
+                avctx->streams[0]->codec->width = (filetype == 1 ? t1 : filetype) << 4;
+                *got_width = 1;
+            }
+            if (get_height && t2)
+                avctx->streams[0]->codec->height = t2<<4;
+        }
+    }
+
+    *fsize -= 128;
+
+    if (nb_comments > 0) {
+        url_fseek(pb, start_pos - 64*nb_comments - 5, SEEK_SET);
+        if (get_buffer(pb, buf, 5) == 5 && !memcmp(buf, "COMNT", 5)) {
+            int i;
+            char *str = av_malloc(65*nb_comments + 1);
+            *fsize -= 64*nb_comments + 5;
+            if (!str)
+                return 0;
+            for (i = 0; i < nb_comments; i++) {
+                if (get_buffer(pb, str + 65*i, 64) != 64)
+                    break;
+                str[65*i + 64] = '\n';
+            }
+            str[65*i] = 0;
+            av_metadata_set2(&avctx->metadata, "comment", str, AV_METADATA_DONT_STRDUP_VAL);
+        }
+    }
+
+    return 0;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,40 @@
+/*
+ * SAUCE header parser
+ * Copyright (c) 2010 Peter Ross <pross at xvid.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * SAUCE header parser
+ */
+
+#ifndef AVFORMAT_SAUCE_H
+#define AVFORMAT_SAUCE_H
+
+#include "avformat.h"
+
+/**
+ * @param avctx AVFormatContext
+ * @param[out] fsize return length of file, less SAUCE header
+ * @param[out] got_width set to non-zero if SAUCE header reported height
+ * @param get_height Tell SAUCE header to parse height
+ */
+int ff_sauce_read(AVFormatContext *avctx, uint64_t *fsize, int *got_width, int get_height);
+
+#endif /* AVFORMAT_SAUCE_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/srtdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/srtdec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/srtdec.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,102 @@
+/*
+ * SubRip subtitle demuxer
+ * Copyright (c) 2010  Aurelien Jacobs <aurel at gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avformat.h"
+#include "internal.h"
+#include "libavutil/intreadwrite.h"
+
+static int srt_probe(AVProbeData *p)
+{
+    unsigned char *ptr = p->buf;
+    int i, v, num = 0;
+
+    if (AV_RB24(ptr) == 0xEFBBBF)
+        ptr += 3;  /* skip UTF-8 BOM */
+
+    for (i=0; i<2; i++) {
+        if (num == i && sscanf(ptr, "%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d", &v) == 1)
+            return AVPROBE_SCORE_MAX;
+        num = atoi(ptr);
+        ptr += strcspn(ptr, "\n") + 1;
+    }
+    return 0;
+}
+
+static int srt_read_header(AVFormatContext *s, AVFormatParameters *ap)
+{
+    AVStream *st = av_new_stream(s, 0);
+    if (!st)
+        return -1;
+    av_set_pts_info(st, 64, 1, 1000);
+    st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;
+    st->codec->codec_id   = CODEC_ID_SRT;
+    return 0;
+}
+
+static int64_t get_pts(const char *buf)
+{
+    int i, v, hour, min, sec, hsec;
+
+    for (i=0; i<2; i++) {
+        if (sscanf(buf, "%d:%2d:%2d%*1[,.]%3d --> %*d:%*2d:%*2d%*1[,.]%3d",
+                   &hour, &min, &sec, &hsec, &v) == 5) {
+            min += 60*hour;
+            sec += 60*min;
+            return sec*1000+hsec;
+        }
+        buf += strcspn(buf, "\n") + 1;
+    }
+    return AV_NOPTS_VALUE;
+}
+
+static inline int is_eol(char c)
+{
+    return c == '\r' || c == '\n';
+}
+
+static int srt_read_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    char buffer[2048], *ptr = buffer, *ptr2;
+    int64_t pos = url_ftell(s->pb);
+    int res = AVERROR_EOF;
+
+    do {
+        ptr2 = ptr;
+        ptr += ff_get_line(s->pb, ptr, sizeof(buffer)+buffer-ptr);
+    } while (!is_eol(*ptr2) && !url_feof(s->pb) && ptr-buffer<sizeof(buffer)-1);
+
+    if (buffer[0] && !(res = av_new_packet(pkt, ptr-buffer))) {
+        memcpy(pkt->data, buffer, pkt->size);
+        pkt->flags |= AV_PKT_FLAG_KEY;
+        pkt->pos = pos;
+        pkt->pts = pkt->dts = get_pts(pkt->data);
+    }
+    return res;
+}
+
+AVInputFormat srt_demuxer = {
+    .name        = "srt",
+    .long_name   = NULL_IF_CONFIG_SMALL("SubRip subtitle format"),
+    .read_probe  = srt_probe,
+    .read_header = srt_read_header,
+    .read_packet = srt_read_packet,
+    .flags       = AVFMT_GENERIC_INDEX,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/tty.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/tty.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/tty.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,135 @@
+/*
+ * Tele-typewriter demuxer
+ * Copyright (c) 2010 Peter Ross <pross at xvid.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Tele-typewriter demuxer
+ */
+
+#include "libavutil/intreadwrite.h"
+#include "libavutil/avstring.h"
+#include "avformat.h"
+#include "sauce.h"
+#include <strings.h>
+
+#define LINE_RATE 6000 /* characters per second */
+
+typedef struct {
+    int chars_per_frame;
+    uint64_t fsize;  /** file size less metadata buffer */
+} TtyDemuxContext;
+
+/**
+ * Parse EFI header
+ */
+static int efi_read(AVFormatContext *avctx, uint64_t start_pos)
+{
+    TtyDemuxContext *s = avctx->priv_data;
+    ByteIOContext *pb = avctx->pb;
+    char buf[37];
+    int len;
+
+    url_fseek(pb, start_pos, SEEK_SET);
+    if (get_byte(pb) != 0x1A)
+        return -1;
+
+#define GET_EFI_META(name,size) \
+    len = get_byte(pb); \
+    if (len < 1 || len > size) \
+        return -1; \
+    if (get_buffer(pb, buf, size) == size) { \
+        buf[len] = 0; \
+        av_metadata_set2(&avctx->metadata, name, buf, 0); \
+    }
+
+    GET_EFI_META("filename", 12)
+    GET_EFI_META("title",    36)
+
+    s->fsize = start_pos;
+    return 0;
+}
+
+static int read_header(AVFormatContext *avctx,
+                       AVFormatParameters *ap)
+{
+    TtyDemuxContext *s = avctx->priv_data;
+    AVStream *st = av_new_stream(avctx, 0);
+    if (!st)
+        return AVERROR(ENOMEM);
+    st->codec->codec_tag   = 0;
+    st->codec->codec_type  = CODEC_TYPE_VIDEO;
+    st->codec->codec_id    = CODEC_ID_ANSI;
+    if (ap->width)  st->codec->width  = ap->width;
+    if (ap->height) st->codec->height = ap->height;
+
+    if (!ap->time_base.num) {
+        av_set_pts_info(st, 60, 1, 25);
+    } else {
+        av_set_pts_info(st, 60, ap->time_base.num, ap->time_base.den);
+    }
+
+    /* simulate tty display speed */
+    s->chars_per_frame = FFMAX(av_q2d(st->time_base) * (ap->sample_rate ? ap->sample_rate : LINE_RATE), 1);
+
+    if (!url_is_streamed(avctx->pb)) {
+        s->fsize = url_fsize(avctx->pb);
+        st->duration = (s->fsize + s->chars_per_frame - 1) / s->chars_per_frame;
+
+        if (ff_sauce_read(avctx, &s->fsize, 0, 0) < 0)
+            efi_read(avctx, s->fsize - 51);
+
+        url_fseek(avctx->pb, 0, SEEK_SET);
+    }
+
+    return 0;
+}
+
+static int read_packet(AVFormatContext *avctx, AVPacket *pkt)
+{
+    TtyDemuxContext *s = avctx->priv_data;
+    int n;
+
+    if (url_feof(avctx->pb))
+        return AVERROR_EOF;
+
+    n = s->chars_per_frame;
+    if (s->fsize) {
+        // ignore metadata buffer
+        uint64_t p = url_ftell(avctx->pb);
+        if (p + s->chars_per_frame > s->fsize)
+            n = s->fsize - p;
+    }
+
+    pkt->size = av_get_packet(avctx->pb, pkt, n);
+    if (pkt->size <= 0)
+        return AVERROR(EIO);
+    pkt->flags |= PKT_FLAG_KEY;
+    return 0;
+}
+
+AVInputFormat tty_demuxer = {
+    .name           = "tty",
+    .long_name      = NULL_IF_CONFIG_SMALL("Tele-typewriter"),
+    .priv_data_size = sizeof(TtyDemuxContext),
+    .read_header    = read_header,
+    .read_packet    = read_packet,
+    .extensions     = "ans,art,asc,diz,ice,nfo,txt,vt",
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -49,13 +49,14 @@
 
 const char *avformat_configuration(void)
 {
-    return FFMPEG_CONFIGURATION;
+    return "avidemux"; // MEANX FFMPEG_CONFIGURATION;
 }
 
 const char *avformat_license(void)
 {
 #define LICENSE_PREFIX "libavformat license: "
-    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
+        return LICENSE_PREFIX "GPL";
+//MEANX    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
 }
 
 /* fraction handling */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/file.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/file.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/file.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,77 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/file.c b/avidemux_core/ADM_ffmpeg/libavformat/file.c
+index 3c3f42f..298c07a 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/file.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/file.c
+@@ -30,6 +30,72 @@
+ #include <stdlib.h>
+ #include "os_support.h"
+ 
++// GRUNTSTER start
++#ifdef __WIN32
++#include <windows.h>
++
++int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString)
++{
++	int wideCharStringLength = MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, NULL, 0);
++
++	if (wideCharString)
++		MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, wideCharString, wideCharStringLength);
++
++	return wideCharStringLength;
++}
++
++int ADM_open(const char *path, int oflag, ...)
++{
++	int fileNameLength = utf8StringToWideChar(path, -1, NULL);
++	wchar_t wcFile[fileNameLength];
++	int creation = 0, access = 0;
++	HANDLE hFile;
++
++	utf8StringToWideChar(path, -1, wcFile);
++
++	if (oflag & O_WRONLY || oflag & O_RDWR)
++	{
++		access = GENERIC_WRITE;
++
++		if (oflag & O_RDWR)
++			access |= GENERIC_READ;
++
++		if (oflag & O_CREAT)
++		{
++			if (oflag & O_EXCL)
++				creation = CREATE_NEW;
++			else if (oflag & O_TRUNC)
++				creation = CREATE_ALWAYS;
++			else
++				creation = OPEN_ALWAYS;
++		}
++		else if (oflag & O_TRUNC)
++			creation = TRUNCATE_EXISTING;
++	}
++	else if (oflag & O_RDONLY)
++		creation = OPEN_EXISTING;
++
++	if (creation & GENERIC_WRITE)
++	{
++		hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
++
++		if (hFile == INVALID_HANDLE_VALUE)
++			return -1;
++		else
++			CloseHandle(hFile);
++	}
++
++	hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
++
++	if (hFile == INVALID_HANDLE_VALUE)
++		return -1;
++	else
++		return _open_osfhandle((intptr_t)hFile, oflag);
++}
++
++#define open ADM_open
++#endif
++// GRUNTSTER end
+ 
+ /* standard file protocol */
+ 

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/flvenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/flvenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/flvenc.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,25 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c b/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
+index 709ef07..a573c63 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
+@@ -406,7 +406,8 @@ AVOutputFormat flv_muxer = {
+     "video/x-flv",
+     "flv",
+     sizeof(FLVContext),
+-#if CONFIG_LIBMP3LAME
++//MEANX #if CONFIG_LIBMP3LAME
++#ifdef HAVE_LIBMP3LAME
+     CODEC_ID_MP3,
+ #else // CONFIG_LIBMP3LAME
+     CODEC_ID_ADPCM_SWF,
+@@ -418,3 +419,9 @@ AVOutputFormat flv_muxer = {
+     .codec_tag= (const AVCodecTag* const []){flv_video_codec_ids, flv_audio_codec_ids, 0},
+     .flags= AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
+ };
++// MEANX
++int flvenc_init(void)
++{
++    av_register_output_format(&flv_muxer);
++    return 0;
++}
+\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/isom.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/isom.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/isom.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,16 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/isom.c b/avidemux_core/ADM_ffmpeg/libavformat/isom.c
+index bf2d3b1..99c8069 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/isom.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/isom.c
+@@ -215,7 +215,10 @@ const AVCodecTag codec_movaudio_tags[] = {
+     { CODEC_ID_MP1, MKTAG('.', 'm', 'p', '1') }, /* MPEG layer 1 */
+     { CODEC_ID_MP2, MKTAG('.', 'm', 'p', '2') }, /* MPEG layer 2 */
+ 
+-    { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at http://www.3ivx.com/showcase.html use this tag */
++    //MEANX { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at http://www.3ivx.com/showcase.html use this tag */
++     { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
++     { CODEC_ID_MP2, MKTAG( 'm', 'p', '4', 'a') },
++    // /MEANX
+     { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
+ 
+ /*  { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at http://heroinewarrior.com/xmovie.php3 use this tag */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/matroskaenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/matroskaenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/matroskaenc.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,83 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c b/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
+index f275d44..a7602a9 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
+@@ -407,6 +407,7 @@ static int64_t mkv_write_cues(ByteIOContext *pb, mkv_cues *cues, int num_tracks)
+ 
+ static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec)
+ {
++#if 0 // MEANX avidemux does thing differently
+     uint8_t *header_start[3];
+     int header_len[3];
+     int first_header_size;
+@@ -431,6 +432,28 @@ static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecCont
+         put_buffer(pb, header_start[j], header_len[j]);
+ 
+     return 0;
++#else
++   // Not endian safe....
++      uint32_t packetLen[3],*ptr=(uint32_t *)codec->extradata;
++      uint8_t *data[3],i,j;
++      if( 3*4+ptr[0]+ptr[1]+ptr[2]!=codec->extradata_size)
++      {
++        av_log(s, AV_LOG_ERROR, "Broken avidemux xiph header.\n");
++        return -1;
++      }
++      data[0]=codec->extradata+3*4;
++      data[1]=data[0]+ptr[0];
++      data[2]=data[1]+ptr[1];
++      put_byte(pb, 2);                    // number packets - 1
++      for (j = 0; j < 2; j++) 
++      {
++          put_xiph_size(pb, ptr[j]);
++      }
++      for (j = 0; j < 3; j++)
++        put_buffer(pb, data[j], ptr[j]);
++      
++      return 0; // /MEANX
++#endif
+ }
+ 
+ static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
+@@ -548,6 +571,23 @@ static int mkv_write_tracks(AVFormatContext *s)
+         put_ebml_uint (pb, MATROSKA_ID_TRACKNUMBER     , i + 1);
+         put_ebml_uint (pb, MATROSKA_ID_TRACKUID        , i + 1);
+         put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
++/**  MEANX : Add a default duration for video **/
++        if(codec->codec_type==CODEC_TYPE_VIDEO)
++        {
++          if(codec->time_base.den && codec->time_base.num)
++          {
++            int num=codec->time_base.num;
++            int den=codec->time_base.den;
++            unsigned int default_duration;
++            float period=num;
++                  period/=den;
++                  period*=1000*1000*1000; // in ns
++                  default_duration=(unsigned int)floor(period);
++                  put_ebml_uint (pb, MATROSKA_ID_TRACKDEFAULTDURATION ,default_duration);
++          }
++        }
++        
++/**  MEANX : Add a default duration for video **/
+ 
+         if ((tag = av_metadata_get(st->metadata, "title", NULL, 0)))
+             put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value);
+@@ -1087,3 +1127,17 @@ AVOutputFormat matroska_audio_muxer = {
+     .codec_tag = (const AVCodecTag* const []){ff_codec_wav_tags, 0},
+ };
+ #endif
++
++ // MEANX
++ //
++ int matroskaenc_init(void)
++ {
++     av_register_output_format(&matroska_muxer);
++#if CONFIG_WEBM_MUXER
++     av_register_output_format(&webm_muxer);
++#endif
++     return 0;
++ }
++ // /MEANX
++
++

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/movenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/movenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/movenc.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,20 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/movenc.c b/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
+index aed748b..ded5383 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
+@@ -2298,3 +2298,15 @@ AVOutputFormat ipod_muxer = {
+     .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
+ };
+ #endif
++/* MEANX */
++int movenc_init(void)
++{
++    av_register_output_format(&mov_muxer);
++    av_register_output_format(&tgp_muxer);
++    av_register_output_format(&mp4_muxer);
++    av_register_output_format(&psp_muxer);
++    av_register_output_format(&tg2_muxer);
++    av_register_output_format(&ipod_muxer);
++    return 0;
++}
++/* MEANX */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegenc.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,19 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c b/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
+index b37a774..32ce21b 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
+@@ -1300,3 +1300,13 @@ AVOutputFormat mpeg2dvd_muxer = {
+     mpeg_mux_end,
+ };
+ #endif
++// MEANX
++//
++int mpegenc_init(void)
++{
++    av_register_output_format(&mpeg2dvd_muxer);
++    av_register_output_format(&mpeg2svcd_muxer);
++    av_register_output_format(&mpeg2vob_muxer);
++    av_register_output_format(&mpeg1vcd_muxer);
++    return 0;
++}
+\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegtsenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegtsenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegtsenc.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,14 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c b/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
+index ac09ab9..fe32325 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
+@@ -947,3 +947,8 @@ AVOutputFormat mpegts_muxer = {
+     mpegts_write_packet,
+     mpegts_write_end,
+ };
++int mpegtsenc_init(void)
++{
++    av_register_output_format(&mpegts_muxer);
++    return 0;
++}
+\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/utils.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/utils.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/utils.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,21 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/utils.c b/avidemux_core/ADM_ffmpeg/libavformat/utils.c
+index 6fa4dff..8646c6c 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/utils.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/utils.c
+@@ -49,13 +49,14 @@ unsigned avformat_version(void)
+ 
+ const char *avformat_configuration(void)
+ {
+-    return FFMPEG_CONFIGURATION;
++    return "avidemux"; // MEANX FFMPEG_CONFIGURATION;
+ }
+ 
+ const char *avformat_license(void)
+ {
+ #define LICENSE_PREFIX "libavformat license: "
+-    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
++        return LICENSE_PREFIX "GPL";
++//MEANX    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
+ }
+ 
+ /* fraction handling */



From mean at mail.berlios.de  Sun Jul 25 12:07:49 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 25 Jul 2010 12:07:49 +0200
Subject: [Avidemux-svn-commit] r6482 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale:
	. x86
Message-ID: <20100725100749.8B3A2480E6C@sheep.berlios.de>

Author: mean
Date: 2010-07-25 12:07:49 +0200 (Sun, 25 Jul 2010)
New Revision: 6482

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb_template.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_internal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_template.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/utils.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_mmx.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_template.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/yuv2rgb.c
Log:
[swscale] update 25 july

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/CMakeLists.txt	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/CMakeLists.txt	2010-07-25 10:07:49 UTC (rev 6482)
@@ -2,7 +2,7 @@
 SET(${ADM_LIB}_SRCS 
         swscale.c yuv2rgb.c rgb2rgb.c ADM_mp.cpp swscale_avoption.c utils.c
 )
-
+ADD_DEFINITIONS("-Dbswap_16=av_bswap16")
 IF(ADM_CPU_X86)
 SET(${ADM_LIB}_SRCS ${${ADM_LIB}_SRCS} x86/yuv2rgb_mmx.c)
 ENDIF(ADM_CPU_X86)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -8,22 +8,19 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * The C code (not assembly, MMX, ...) of this file can be used
- * under the LGPL license.
  */
 #include <inttypes.h>
 #include "config.h"
@@ -101,7 +98,7 @@
                      long lumStride, long chromStride, long srcStride);
 
 
-#if ARCH_X86 && CONFIG_GPL
+#if ARCH_X86
 DECLARE_ASM_CONST(8, uint64_t, mmx_null)     = 0x0000000000000000ULL;
 DECLARE_ASM_CONST(8, uint64_t, mmx_one)      = 0xFFFFFFFFFFFFFFFFULL;
 DECLARE_ASM_CONST(8, uint64_t, mask32b)      = 0x000000FF000000FFULL;
@@ -162,7 +159,7 @@
 #define RENAME(a) a ## _C
 #include "rgb2rgb_template.c"
 
-#if ARCH_X86 && CONFIG_GPL
+#if ARCH_X86
 
 //MMX versions
 #undef RENAME
@@ -198,7 +195,7 @@
 
 void sws_rgb2rgb_init(int flags)
 {
-#if (HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX)  && CONFIG_GPL
+#if HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX
     if (flags & SWS_CPU_CAPS_MMX2)
         rgb2rgb_init_MMX2();
     else if (flags & SWS_CPU_CAPS_3DNOW)
@@ -210,31 +207,15 @@
         rgb2rgb_init_C();
 }
 
-/**
- * Convert the palette to the same packet 32-bit format as the palette
- */
+#if LIBSWSCALE_VERSION_MAJOR < 1
 void palette8topacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
 {
-    long i;
-
-    for (i=0; i<num_pixels; i++)
-        ((uint32_t *) dst)[i] = ((const uint32_t *) palette)[src[i]];
+    sws_convertPalette8ToPacked32(src, dst, num_pixels, palette);
 }
 
-/**
- * Palette format: ABCD -> dst format: ABC
- */
 void palette8topacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
 {
-    long i;
-
-    for (i=0; i<num_pixels; i++) {
-        //FIXME slow?
-        dst[0]= palette[src[i]*4+0];
-        dst[1]= palette[src[i]*4+1];
-        dst[2]= palette[src[i]*4+2];
-        dst+= 3;
-    }
+    sws_convertPalette8ToPacked24(src, dst, num_pixels, palette);
 }
 
 /**
@@ -252,23 +233,8 @@
     for (i=0; i<num_pixels; i++)
         ((uint16_t *)dst)[i] = bswap_16(((const uint16_t *)palette)[src[i]]);
 }
+#endif
 
-/**
- * Palette is assumed to contain BGR15, see rgb32to15 to convert the palette.
- */
-void palette8torgb15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
-{
-    long i;
-    for (i=0; i<num_pixels; i++)
-        ((uint16_t *)dst)[i] = ((const uint16_t *)palette)[src[i]];
-}
-void palette8tobgr15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
-{
-    long i;
-    for (i=0; i<num_pixels; i++)
-        ((uint16_t *)dst)[i] = bswap_16(((const uint16_t *)palette)[src[i]]);
-}
-
 void rgb32to24(const uint8_t *src, uint8_t *dst, long src_size)
 {
     long i;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.h	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.h	2010-07-25 10:07:49 UTC (rev 6482)
@@ -4,7 +4,7 @@
  *               Software YUV to YUV converter
  *               Software YUV to RGB converter
  *  Written by Nick Kurshev.
- *  palette & YUV & runtime CPU stuff by Michael (michaelni at gmx.at)
+ *  YUV & runtime CPU stuff by Michael (michaelni at gmx.at)
  *
  * This file is part of FFmpeg.
  *
@@ -28,6 +28,9 @@
 
 #include <inttypes.h>
 
+#include "libswscale/swscale.h"
+#include "libavutil/avutil.h"
+
 /* A full collection of RGB to RGB(BGR) converters */
 extern void (*rgb24tobgr32)(const uint8_t *src, uint8_t *dst, long src_size);
 extern void (*rgb24tobgr16)(const uint8_t *src, uint8_t *dst, long src_size);
@@ -66,13 +69,16 @@
 void shuffle_bytes_3012(const uint8_t *src, uint8_t *dst, long src_size);
 void shuffle_bytes_3210(const uint8_t *src, uint8_t *dst, long src_size);
 
-void palette8topacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-void palette8topacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-void palette8torgb16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-void palette8torgb15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-void palette8tobgr15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+#if LIBSWSCALE_VERSION_MAJOR < 1
+/* deprecated, use the public versions in swscale.h */
+attribute_deprecated void palette8topacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+attribute_deprecated void palette8topacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
 
+/* totally deprecated, please fix code that uses this */
+attribute_deprecated void palette8torgb16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+attribute_deprecated void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+#endif
+
 /**
  * Height should be a multiple of 2 and width should be a multiple of 16.
  * (If this is a problem for anyone then tell me, and I will fix it.)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb_template.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb_template.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb_template.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -9,22 +9,19 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * The C code (not assembly, MMX, ...) of this file can be used
- * under the LGPL license.
  */
 
 #include <stddef.h>
@@ -125,6 +122,43 @@
     }
 }
 
+#define STORE_BGR24_MMX \
+            "psrlq         $8, %%mm2    \n\t" \
+            "psrlq         $8, %%mm3    \n\t" \
+            "psrlq         $8, %%mm6    \n\t" \
+            "psrlq         $8, %%mm7    \n\t" \
+            "pand "MANGLE(mask24l)", %%mm0\n\t" \
+            "pand "MANGLE(mask24l)", %%mm1\n\t" \
+            "pand "MANGLE(mask24l)", %%mm4\n\t" \
+            "pand "MANGLE(mask24l)", %%mm5\n\t" \
+            "pand "MANGLE(mask24h)", %%mm2\n\t" \
+            "pand "MANGLE(mask24h)", %%mm3\n\t" \
+            "pand "MANGLE(mask24h)", %%mm6\n\t" \
+            "pand "MANGLE(mask24h)", %%mm7\n\t" \
+            "por        %%mm2, %%mm0    \n\t" \
+            "por        %%mm3, %%mm1    \n\t" \
+            "por        %%mm6, %%mm4    \n\t" \
+            "por        %%mm7, %%mm5    \n\t" \
+ \
+            "movq       %%mm1, %%mm2    \n\t" \
+            "movq       %%mm4, %%mm3    \n\t" \
+            "psllq        $48, %%mm2    \n\t" \
+            "psllq        $32, %%mm3    \n\t" \
+            "pand "MANGLE(mask24hh)", %%mm2\n\t" \
+            "pand "MANGLE(mask24hhh)", %%mm3\n\t" \
+            "por        %%mm2, %%mm0    \n\t" \
+            "psrlq        $16, %%mm1    \n\t" \
+            "psrlq        $32, %%mm4    \n\t" \
+            "psllq        $16, %%mm5    \n\t" \
+            "por        %%mm3, %%mm1    \n\t" \
+            "pand  "MANGLE(mask24hhhh)", %%mm5\n\t" \
+            "por        %%mm5, %%mm4    \n\t" \
+ \
+            MOVNTQ"     %%mm0,   %0     \n\t" \
+            MOVNTQ"     %%mm1,  8%0     \n\t" \
+            MOVNTQ"     %%mm4, 16%0"
+
+
 static inline void RENAME(rgb32tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)
 {
     uint8_t *dest = dst;
@@ -148,43 +182,9 @@
             "movq       %%mm1, %%mm3    \n\t"
             "movq       %%mm4, %%mm6    \n\t"
             "movq       %%mm5, %%mm7    \n\t"
-            "psrlq         $8, %%mm2    \n\t"
-            "psrlq         $8, %%mm3    \n\t"
-            "psrlq         $8, %%mm6    \n\t"
-            "psrlq         $8, %%mm7    \n\t"
-            "pand          %2, %%mm0    \n\t"
-            "pand          %2, %%mm1    \n\t"
-            "pand          %2, %%mm4    \n\t"
-            "pand          %2, %%mm5    \n\t"
-            "pand          %3, %%mm2    \n\t"
-            "pand          %3, %%mm3    \n\t"
-            "pand          %3, %%mm6    \n\t"
-            "pand          %3, %%mm7    \n\t"
-            "por        %%mm2, %%mm0    \n\t"
-            "por        %%mm3, %%mm1    \n\t"
-            "por        %%mm6, %%mm4    \n\t"
-            "por        %%mm7, %%mm5    \n\t"
-
-            "movq       %%mm1, %%mm2    \n\t"
-            "movq       %%mm4, %%mm3    \n\t"
-            "psllq        $48, %%mm2    \n\t"
-            "psllq        $32, %%mm3    \n\t"
-            "pand          %4, %%mm2    \n\t"
-            "pand          %5, %%mm3    \n\t"
-            "por        %%mm2, %%mm0    \n\t"
-            "psrlq        $16, %%mm1    \n\t"
-            "psrlq        $32, %%mm4    \n\t"
-            "psllq        $16, %%mm5    \n\t"
-            "por        %%mm3, %%mm1    \n\t"
-            "pand          %6, %%mm5    \n\t"
-            "por        %%mm5, %%mm4    \n\t"
-
-            MOVNTQ"     %%mm0,   %0     \n\t"
-            MOVNTQ"     %%mm1,  8%0     \n\t"
-            MOVNTQ"     %%mm4, 16%0"
+            STORE_BGR24_MMX
             :"=m"(*dest)
-            :"m"(*s),"m"(mask24l),
-            "m"(mask24h),"m"(mask24hh),"m"(mask24hhh),"m"(mask24hhhh)
+            :"m"(*s)
             :"memory");
         dest += 24;
         s += 32;
@@ -974,43 +974,10 @@
             "movq       %%mm0, %%mm2    \n\t"
             "movq       %%mm1, %%mm3    \n\t"
 
-            "psrlq         $8, %%mm2    \n\t"
-            "psrlq         $8, %%mm3    \n\t"
-            "psrlq         $8, %%mm6    \n\t"
-            "psrlq         $8, %%mm7    \n\t"
-            "pand          %2, %%mm0    \n\t"
-            "pand          %2, %%mm1    \n\t"
-            "pand          %2, %%mm4    \n\t"
-            "pand          %2, %%mm5    \n\t"
-            "pand          %3, %%mm2    \n\t"
-            "pand          %3, %%mm3    \n\t"
-            "pand          %3, %%mm6    \n\t"
-            "pand          %3, %%mm7    \n\t"
-            "por        %%mm2, %%mm0    \n\t"
-            "por        %%mm3, %%mm1    \n\t"
-            "por        %%mm6, %%mm4    \n\t"
-            "por        %%mm7, %%mm5    \n\t"
+            STORE_BGR24_MMX
 
-            "movq       %%mm1, %%mm2    \n\t"
-            "movq       %%mm4, %%mm3    \n\t"
-            "psllq        $48, %%mm2    \n\t"
-            "psllq        $32, %%mm3    \n\t"
-            "pand          %4, %%mm2    \n\t"
-            "pand          %5, %%mm3    \n\t"
-            "por        %%mm2, %%mm0    \n\t"
-            "psrlq        $16, %%mm1    \n\t"
-            "psrlq        $32, %%mm4    \n\t"
-            "psllq        $16, %%mm5    \n\t"
-            "por        %%mm3, %%mm1    \n\t"
-            "pand          %6, %%mm5    \n\t"
-            "por        %%mm5, %%mm4    \n\t"
-
-            MOVNTQ"     %%mm0,   %0     \n\t"
-            MOVNTQ"     %%mm1,  8%0     \n\t"
-            MOVNTQ"     %%mm4, 16%0"
-
             :"=m"(*d)
-            :"m"(*s),"m"(mask24l),"m"(mask24h),"m"(mask24hh),"m"(mask24hhh),"m"(mask24hhhh)
+            :"m"(*s)
             :"memory");
         d += 24;
         s += 8;
@@ -1113,43 +1080,10 @@
             "movq       %%mm0, %%mm2    \n\t"
             "movq       %%mm1, %%mm3    \n\t"
 
-            "psrlq         $8, %%mm2    \n\t"
-            "psrlq         $8, %%mm3    \n\t"
-            "psrlq         $8, %%mm6    \n\t"
-            "psrlq         $8, %%mm7    \n\t"
-            "pand          %2, %%mm0    \n\t"
-            "pand          %2, %%mm1    \n\t"
-            "pand          %2, %%mm4    \n\t"
-            "pand          %2, %%mm5    \n\t"
-            "pand          %3, %%mm2    \n\t"
-            "pand          %3, %%mm3    \n\t"
-            "pand          %3, %%mm6    \n\t"
-            "pand          %3, %%mm7    \n\t"
-            "por        %%mm2, %%mm0    \n\t"
-            "por        %%mm3, %%mm1    \n\t"
-            "por        %%mm6, %%mm4    \n\t"
-            "por        %%mm7, %%mm5    \n\t"
+            STORE_BGR24_MMX
 
-            "movq       %%mm1, %%mm2    \n\t"
-            "movq       %%mm4, %%mm3    \n\t"
-            "psllq        $48, %%mm2    \n\t"
-            "psllq        $32, %%mm3    \n\t"
-            "pand          %4, %%mm2    \n\t"
-            "pand          %5, %%mm3    \n\t"
-            "por        %%mm2, %%mm0    \n\t"
-            "psrlq        $16, %%mm1    \n\t"
-            "psrlq        $32, %%mm4    \n\t"
-            "psllq        $16, %%mm5    \n\t"
-            "por        %%mm3, %%mm1    \n\t"
-            "pand          %6, %%mm5    \n\t"
-            "por        %%mm5, %%mm4    \n\t"
-
-            MOVNTQ"     %%mm0,   %0     \n\t"
-            MOVNTQ"     %%mm1,  8%0     \n\t"
-            MOVNTQ"     %%mm4, 16%0"
-
             :"=m"(*d)
-            :"m"(*s),"m"(mask24l),"m"(mask24h),"m"(mask24hh),"m"(mask24hhh),"m"(mask24hhhh)
+            :"m"(*s)
             :"memory");
         d += 24;
         s += 8;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -3,22 +3,19 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * the C code (not assembly, mmx, ...) of this file can be used
- * under the LGPL license too
  */
 
 /*
@@ -27,7 +24,7 @@
   {BGR,RGB}{1,4,8,15,16} support dithering
 
   unscaled special converters (YV12=I420=IYUV, Y800=Y8)
-  YV12 -> {BGR,RGB}{1,4,8,15,16,24,32}
+  YV12 -> {BGR,RGB}{1,4,8,12,15,16,24,32}
   x -> x
   YUV9 -> YV12
   YUV9/YV12 -> Y800
@@ -39,7 +36,7 @@
 
 /*
 tested special converters (most are tested actually, but I did not write it down ...)
- YV12 -> BGR16
+ YV12 -> BGR12/BGR16
  YV12 -> YV12
  BGR15 -> BGR16
  BGR16 -> BGR16
@@ -66,6 +63,7 @@
 #include "libavutil/intreadwrite.h"
 #include "libavutil/x86_cpu.h"
 #include "libavutil/avutil.h"
+#include "libavutil/mathematics.h"
 #include "libavutil/bswap.h"
 #include "libavutil/pixdesc.h"
 
@@ -80,19 +78,12 @@
 
 #define FAST_BGR2YV12 // use 7 bit coefficients instead of 15 bit
 
-#ifdef M_PI
-#define PI M_PI
-#else
-#define PI 3.14159265358979323846
-#endif
-
 #define isPacked(x)         (       \
            (x)==PIX_FMT_PAL8        \
         || (x)==PIX_FMT_YUYV422     \
         || (x)==PIX_FMT_UYVY422     \
         || isAnyRGB(x)              \
     )
-#define usePal(x) (av_pix_fmt_descriptors[x].flags & PIX_FMT_PAL)
 
 #define RGB2YUV_SHIFT 15
 #define BY ( (int)(0.114*219/255*(1<<RGB2YUV_SHIFT)+0.5))
@@ -131,7 +122,7 @@
 write special BGR->BGR scaler
 */
 
-#if ARCH_X86 && CONFIG_GPL
+#if ARCH_X86
 DECLARE_ASM_CONST(8, uint64_t, bF8)=       0xF8F8F8F8F8F8F8F8LL;
 DECLARE_ASM_CONST(8, uint64_t, bFC)=       0xFCFCFCFCFCFCFCFCLL;
 DECLARE_ASM_CONST(8, uint64_t, w10)=       0x0010001000100010LL;
@@ -186,7 +177,7 @@
 
 DECLARE_ASM_CONST(8, uint64_t, ff_bgr24toUVOffset)= 0x0040400000404000ULL;
 
-#endif /* ARCH_X86 && CONFIG_GPL */
+#endif /* ARCH_X86 */
 
 DECLARE_ALIGNED(8, static const uint8_t, dither_2x2_4)[2][8]={
 {  1,   3,   1,   3,   1,   3,   1,   3, },
@@ -198,6 +189,13 @@
 {  0,   4,   0,   4,   0,   4,   0,   4, },
 };
 
+DECLARE_ALIGNED(8, const uint8_t, dither_4x4_16)[4][8]={
+{  8,   4,  11,   7,   8,   4,  11,   7, },
+{  2,  14,   1,  13,   2,  14,   1,  13, },
+{ 10,   6,   9,   5,  10,   6,   9,   5, },
+{  0,  12,   3,  15,   0,  12,   3,  15, },
+};
+
 DECLARE_ALIGNED(8, const uint8_t, dither_8x8_32)[8][8]={
 { 17,   9,  23,  15,  16,   8,  22,  14, },
 {  5,  29,   3,  27,   4,  28,   2,  26, },
@@ -765,8 +763,10 @@
             dest+=6;\
         }\
         break;\
-    case PIX_FMT_RGB565:\
-    case PIX_FMT_BGR565:\
+    case PIX_FMT_RGB565BE:\
+    case PIX_FMT_RGB565LE:\
+    case PIX_FMT_BGR565BE:\
+    case PIX_FMT_BGR565LE:\
         {\
             const int dr1= dither_2x2_8[y&1    ][0];\
             const int dg1= dither_2x2_4[y&1    ][0];\
@@ -780,8 +780,10 @@
             }\
         }\
         break;\
-    case PIX_FMT_RGB555:\
-    case PIX_FMT_BGR555:\
+    case PIX_FMT_RGB555BE:\
+    case PIX_FMT_RGB555LE:\
+    case PIX_FMT_BGR555BE:\
+    case PIX_FMT_BGR555LE:\
         {\
             const int dr1= dither_2x2_8[y&1    ][0];\
             const int dg1= dither_2x2_8[y&1    ][1];\
@@ -795,6 +797,23 @@
             }\
         }\
         break;\
+    case PIX_FMT_RGB444BE:\
+    case PIX_FMT_RGB444LE:\
+    case PIX_FMT_BGR444BE:\
+    case PIX_FMT_BGR444LE:\
+        {\
+            const int dr1= dither_4x4_16[y&3    ][0];\
+            const int dg1= dither_4x4_16[y&3    ][1];\
+            const int db1= dither_4x4_16[(y&3)^3][0];\
+            const int dr2= dither_4x4_16[y&3    ][1];\
+            const int dg2= dither_4x4_16[y&3    ][0];\
+            const int db2= dither_4x4_16[(y&3)^3][1];\
+            func(uint16_t,0)\
+                ((uint16_t*)dest)[i2+0]= r[Y1+dr1] + g[Y1+dg1] + b[Y1+db1];\
+                ((uint16_t*)dest)[i2+1]= r[Y2+dr2] + g[Y2+dg2] + b[Y2+db2];\
+            }\
+        }\
+        break;\
     case PIX_FMT_RGB8:\
     case PIX_FMT_BGR8:\
         {\
@@ -970,7 +989,7 @@
     }
 }
 
-static inline void rgb48ToY(uint8_t *dst, const uint8_t *src, int width,
+static inline void rgb48ToY(uint8_t *dst, const uint8_t *src, long width,
                             uint32_t *unused)
 {
     int i;
@@ -985,7 +1004,7 @@
 
 static inline void rgb48ToUV(uint8_t *dstU, uint8_t *dstV,
                              const uint8_t *src1, const uint8_t *src2,
-                             int width, uint32_t *unused)
+                             long width, uint32_t *unused)
 {
     int i;
     assert(src1==src2);
@@ -1001,7 +1020,7 @@
 
 static inline void rgb48ToUV_half(uint8_t *dstU, uint8_t *dstV,
                                   const uint8_t *src1, const uint8_t *src2,
-                                  int width, uint32_t *unused)
+                                  long width, uint32_t *unused)
 {
     int i;
     assert(src1==src2);
@@ -1127,27 +1146,27 @@
 
 //Note: we have C, MMX, MMX2, 3DNOW versions, there is no 3DNOW+MMX2 one
 //Plain C versions
-#if ((!HAVE_MMX || !CONFIG_GPL) && !HAVE_ALTIVEC) || CONFIG_RUNTIME_CPUDETECT
+#if (!HAVE_MMX && !HAVE_ALTIVEC) || CONFIG_RUNTIME_CPUDETECT
 #define COMPILE_C
 #endif
 
 #if ARCH_PPC
-#if HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT
+#if HAVE_ALTIVEC
 #define COMPILE_ALTIVEC
 #endif
 #endif //ARCH_PPC
 
 #if ARCH_X86
 
-#if ((HAVE_MMX && !HAVE_AMD3DNOW && !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL
+#if (HAVE_MMX && !HAVE_AMD3DNOW && !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT
 #define COMPILE_MMX
 #endif
 
-#if (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL
+#if HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT
 #define COMPILE_MMX2
 #endif
 
-#if ((HAVE_AMD3DNOW && !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL
+#if (HAVE_AMD3DNOW && !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT
 #define COMPILE_3DNOW
 #endif
 #endif //ARCH_X86
@@ -1218,7 +1237,7 @@
 #if CONFIG_RUNTIME_CPUDETECT
     int flags = c->flags;
 
-#if ARCH_X86 && CONFIG_GPL
+#if ARCH_X86
     // ordered per speed fastest first
     if (flags & SWS_CPU_CAPS_MMX2) {
         sws_init_swScale_MMX2(c);
@@ -1235,7 +1254,7 @@
     }
 
 #else
-#if ARCH_PPC
+#ifdef COMPILE_ALTIVEC
     if (flags & SWS_CPU_CAPS_ALTIVEC) {
         sws_init_swScale_altivec(c);
         return swScale_altivec;
@@ -1246,7 +1265,7 @@
 #endif
     sws_init_swScale_C(c);
     return swScale_C;
-#endif /* ARCH_X86 && CONFIG_GPL */
+#endif /* ARCH_X86 */
 #else //CONFIG_RUNTIME_CPUDETECT
 #if   COMPILE_TEMPLATE_MMX2
     sws_init_swScale_MMX2(c);
@@ -1400,12 +1419,12 @@
 
     if (usePal(srcFormat)) {
         switch (dstFormat) {
-        case PIX_FMT_RGB32  : conv = palette8topacked32; break;
-        case PIX_FMT_BGR32  : conv = palette8topacked32; break;
-        case PIX_FMT_BGR32_1: conv = palette8topacked32; break;
-        case PIX_FMT_RGB32_1: conv = palette8topacked32; break;
-        case PIX_FMT_RGB24  : conv = palette8topacked24; break;
-        case PIX_FMT_BGR24  : conv = palette8topacked24; break;
+        case PIX_FMT_RGB32  : conv = sws_convertPalette8ToPacked32; break;
+        case PIX_FMT_BGR32  : conv = sws_convertPalette8ToPacked32; break;
+        case PIX_FMT_BGR32_1: conv = sws_convertPalette8ToPacked32; break;
+        case PIX_FMT_RGB32_1: conv = sws_convertPalette8ToPacked32; break;
+        case PIX_FMT_RGB24  : conv = sws_convertPalette8ToPacked24; break;
+        case PIX_FMT_BGR24  : conv = sws_convertPalette8ToPacked24; break;
         }
     }
 
@@ -1849,6 +1868,8 @@
                 r= (i>>3    )*255;
                 g= ((i>>1)&3)*85;
                 b= (i&1     )*255;
+            } else if(c->srcFormat == PIX_FMT_GRAY8) {
+                r = g = b = i;
             } else {
                 assert(c->srcFormat == PIX_FMT_BGR4_BYTE);
                 b= (i>>3    )*255;
@@ -1936,3 +1957,26 @@
     return sws_scale(c, src, srcStride, srcSliceY, srcSliceH, dst, dstStride);
 }
 #endif
+
+/* Convert the palette to the same packed 32-bit format as the palette */
+void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
+{
+    long i;
+
+    for (i=0; i<num_pixels; i++)
+        ((uint32_t *) dst)[i] = ((const uint32_t *) palette)[src[i]];
+}
+
+/* Palette format: ABCD -> dst format: ABC */
+void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
+{
+    long i;
+
+    for (i=0; i<num_pixels; i++) {
+        //FIXME slow?
+        dst[0]= palette[src[i]*4+0];
+        dst[1]= palette[src[i]*4+1];
+        dst[2]= palette[src[i]*4+2];
+        dst+= 3;
+    }
+}

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.h	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.h	2010-07-25 10:07:49 UTC (rev 6482)
@@ -22,7 +22,7 @@
 #define SWSCALE_SWSCALE_H
 
 /**
- * @file libswscale/swscale.h
+ * @file
  * @brief
  *     external api for the swscale stuff
  */
@@ -30,7 +30,7 @@
 #include "libavutil/avutil.h"
 
 #define LIBSWSCALE_VERSION_MAJOR 0
-#define LIBSWSCALE_VERSION_MINOR 10
+#define LIBSWSCALE_VERSION_MINOR 11
 #define LIBSWSCALE_VERSION_MICRO 0
 
 #define LIBSWSCALE_VERSION_INT  AV_VERSION_INT(LIBSWSCALE_VERSION_MAJOR, \
@@ -194,6 +194,7 @@
  */
 int sws_scale(struct SwsContext *context, const uint8_t* const srcSlice[], const int srcStride[],
               int srcSliceY, int srcSliceH, uint8_t* const dst[], const int dstStride[]);
+
 #if LIBSWSCALE_VERSION_MAJOR < 1
 /**
  * @deprecated Use sws_scale() instead.
@@ -302,4 +303,29 @@
                                         int flags, SwsFilter *srcFilter,
                                         SwsFilter *dstFilter, const double *param);
 
+/**
+ * Converts an 8bit paletted frame into a frame with a color depth of 32-bits.
+ *
+ * The output frame will have the same packed format as the palette.
+ *
+ * @param src        source frame buffer
+ * @param dst        destination frame buffer
+ * @param num_pixels number of pixels to convert
+ * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
+ */
+void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+
+/**
+ * Converts an 8bit paletted frame into a frame with a color depth of 24 bits.
+ *
+ * With the palette format "ABCD", the destination frame ends up with the format "ABC".
+ *
+ * @param src        source frame buffer
+ * @param dst        destination frame buffer
+ * @param num_pixels number of pixels to convert
+ * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
+ */
+void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+
+
 #endif /* SWSCALE_SWSCALE_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_internal.h	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_internal.h	2010-07-25 10:07:49 UTC (rev 6482)
@@ -391,8 +391,12 @@
         || (x)==PIX_FMT_RGB32       \
         || (x)==PIX_FMT_RGB32_1     \
         || (x)==PIX_FMT_RGB24       \
-        || (x)==PIX_FMT_RGB565      \
-        || (x)==PIX_FMT_RGB555      \
+        || (x)==PIX_FMT_RGB565BE    \
+        || (x)==PIX_FMT_RGB565LE    \
+        || (x)==PIX_FMT_RGB555BE    \
+        || (x)==PIX_FMT_RGB555LE    \
+        || (x)==PIX_FMT_RGB444BE    \
+        || (x)==PIX_FMT_RGB444LE    \
         || (x)==PIX_FMT_RGB8        \
         || (x)==PIX_FMT_RGB4        \
         || (x)==PIX_FMT_RGB4_BYTE   \
@@ -403,8 +407,12 @@
            (x)==PIX_FMT_BGR32       \
         || (x)==PIX_FMT_BGR32_1     \
         || (x)==PIX_FMT_BGR24       \
-        || (x)==PIX_FMT_BGR565      \
-        || (x)==PIX_FMT_BGR555      \
+        || (x)==PIX_FMT_BGR565BE    \
+        || (x)==PIX_FMT_BGR565LE    \
+        || (x)==PIX_FMT_BGR555BE    \
+        || (x)==PIX_FMT_BGR555LE    \
+        || (x)==PIX_FMT_BGR444BE    \
+        || (x)==PIX_FMT_BGR444LE    \
         || (x)==PIX_FMT_BGR8        \
         || (x)==PIX_FMT_BGR4        \
         || (x)==PIX_FMT_BGR4_BYTE   \
@@ -434,6 +442,7 @@
         || (x)==PIX_FMT_RGB32_1     \
         || (x)==PIX_FMT_YUVA420P    \
     )
+#define usePal(x) (av_pix_fmt_descriptors[x].flags & PIX_FMT_PAL)
 
 extern const uint64_t ff_dither4[2];
 extern const uint64_t ff_dither8[2];

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_template.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_template.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_template.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -3,22 +3,19 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * The C code (not assembly, MMX, ...) of this file can be used
- * under the LGPL license.
  */
 
 #undef REAL_MOVNTQ
@@ -2211,7 +2208,7 @@
         dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...
         //dst[i] = val>>7;
     }
-#endif /* COMPILE_ALTIVEC */
+#endif /* COMPILE_TEMPLATE_ALTIVEC */
 #endif /* COMPILE_MMX */
 }
 
@@ -2258,7 +2255,7 @@
                                         long dstWidth, const uint8_t *src, int srcW,
                                         int xInc)
 {
-#if ARCH_X86 && CONFIG_GPL
+#if ARCH_X86
 #if COMPILE_TEMPLATE_MMX2
     int32_t *filterPos = c->hLumFilterPos;
     int16_t *filter    = c->hLumFilter;
@@ -2407,7 +2404,7 @@
                                         long dstWidth, const uint8_t *src1,
                                         const uint8_t *src2, int srcW, int xInc)
 {
-#if ARCH_X86 && CONFIG_GPL
+#if ARCH_X86
 #if COMPILE_TEMPLATE_MMX2
     int32_t *filterPos = c->hChrFilterPos;
     int16_t *filter    = c->hChrFilter;
@@ -2651,8 +2648,10 @@
         unsigned char *aDest=(CONFIG_SWSCALE_ALPHA && alpPixBuf) ? dst[3]+dstStride[3]*dstY : NULL;
 
         const int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input
+        const int firstLumSrcY2= vLumFilterPos[FFMIN(dstY | ((1<<c->chrDstVSubSample) - 1), dstH-1)];
         const int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input
         int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input
+        int lastLumSrcY2=firstLumSrcY2+ vLumFilterSize -1; // Last line needed as input
         int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input
         int enough_lines;
 
@@ -2669,7 +2668,8 @@
                          firstChrSrcY,    lastChrSrcY,    lastInChrBuf);
 
         // Do we have enough lines in this slice to output the dstY line
-        enough_lines = lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample);
+        enough_lines = lastLumSrcY2 < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample);
+
         if (!enough_lines) {
             lastLumSrcY = srcSliceY + srcSliceH - 1;
             lastChrSrcY = chrSrcSliceY + chrSrcSliceH - 1;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/utils.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/utils.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -3,22 +3,19 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * the C code (not assembly, mmx, ...) of this file can be used
- * under the LGPL license too
  */
 
 #define _SVID_SOURCE //needed for MAP_ANONYMOUS
@@ -54,13 +51,13 @@
 
 const char *swscale_configuration(void)
 {
-    return "avidemux";//FFMPEG_CONFIGURATION;
+    return "avidemux"; // MEANX FFMPEG_CONFIGURATION;
 }
 
 const char *swscale_license(void)
 {
 #define LICENSE_PREFIX "libswscale license: "
-    return LICENSE_PREFIX "GPL"; //FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
+    return LICENSE_PREFIX "GPL"; // MEANX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
 }
 
 #define RET 0xC3 //near return opcode for x86
@@ -150,8 +147,6 @@
     return isSupportedOut(pix_fmt);
 }
 
-#define usePal(x) (av_pix_fmt_descriptors[x].flags & PIX_FMT_PAL)
-
 extern const int32_t ff_yuv2rgb_coeffs[8][4];
 
 const char *sws_format_name(enum PixelFormat format)
@@ -292,7 +287,7 @@
                 }
 /*                else if (flags & SWS_X) {
                     double p= param ? param*0.01 : 0.3;
-                    coeff = d ? sin(d*PI)/(d*PI) : 1.0;
+                    coeff = d ? sin(d*M_PI)/(d*M_PI) : 1.0;
                     coeff*= pow(2.0, - p*d*d);
                 }*/
                 else if (flags & SWS_X) {
@@ -510,7 +505,7 @@
     return ret;
 }
 
-#if ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL
+#if ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT)
 static int initMMX2HScaler(int dstW, int xInc, uint8_t *filterCode, int16_t *filter, int32_t *filterPos, int numSplits)
 {
     uint8_t *fragmentA;
@@ -668,7 +663,7 @@
 
     return fragmentPos + 1;
 }
-#endif /* ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL */
+#endif /* ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) */
 
 static void getSubSampleFactors(int *h, int *v, enum PixelFormat format)
 {
@@ -676,23 +671,8 @@
     *v = av_pix_fmt_descriptors[format].log2_chroma_h;
 }
 
-static uint16_t roundToInt16(int64_t f)
-{
-    int r= (f + (1<<15))>>16;
-         if (r<-0x7FFF) return 0x8000;
-    else if (r> 0x7FFF) return 0x7FFF;
-    else                return r;
-}
-
 int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
 {
-    int64_t crv =  inv_table[0];
-    int64_t cbu =  inv_table[1];
-    int64_t cgu = -inv_table[2];
-    int64_t cgv = -inv_table[3];
-    int64_t cy  = 1<<16;
-    int64_t oy  = 0;
-
     memcpy(c->srcColorspaceTable, inv_table, sizeof(int)*4);
     memcpy(c->dstColorspaceTable,     table, sizeof(int)*4);
 
@@ -703,45 +683,10 @@
     c->dstRange  = dstRange;
     if (isYUV(c->dstFormat) || isGray(c->dstFormat)) return -1;
 
-    c->uOffset=   0x0400040004000400LL;
-    c->vOffset=   0x0400040004000400LL;
-
-    if (!srcRange) {
-        cy= (cy*255) / 219;
-        oy= 16<<16;
-    } else {
-        crv= (crv*224) / 255;
-        cbu= (cbu*224) / 255;
-        cgu= (cgu*224) / 255;
-        cgv= (cgv*224) / 255;
-    }
-
-    cy = (cy *contrast             )>>16;
-    crv= (crv*contrast * saturation)>>32;
-    cbu= (cbu*contrast * saturation)>>32;
-    cgu= (cgu*contrast * saturation)>>32;
-    cgv= (cgv*contrast * saturation)>>32;
-
-    oy -= 256*brightness;
-
-    c->yCoeff=    roundToInt16(cy *8192) * 0x0001000100010001ULL;
-    c->vrCoeff=   roundToInt16(crv*8192) * 0x0001000100010001ULL;
-    c->ubCoeff=   roundToInt16(cbu*8192) * 0x0001000100010001ULL;
-    c->vgCoeff=   roundToInt16(cgv*8192) * 0x0001000100010001ULL;
-    c->ugCoeff=   roundToInt16(cgu*8192) * 0x0001000100010001ULL;
-    c->yOffset=   roundToInt16(oy *   8) * 0x0001000100010001ULL;
-
-    c->yuv2rgb_y_coeff  = (int16_t)roundToInt16(cy <<13);
-    c->yuv2rgb_y_offset = (int16_t)roundToInt16(oy << 9);
-    c->yuv2rgb_v2r_coeff= (int16_t)roundToInt16(crv<<13);
-    c->yuv2rgb_v2g_coeff= (int16_t)roundToInt16(cgv<<13);
-    c->yuv2rgb_u2g_coeff= (int16_t)roundToInt16(cgu<<13);
-    c->yuv2rgb_u2b_coeff= (int16_t)roundToInt16(cbu<<13);
-
     ff_yuv2rgb_c_init_tables(c, inv_table, srcRange, brightness, contrast, saturation);
     //FIXME factorize
 
-#if ARCH_PPC && (HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT)
+#if HAVE_ALTIVEC
     if (c->flags & SWS_CPU_CAPS_ALTIVEC)
         ff_yuv2rgb_init_tables_altivec(c, inv_table, brightness, contrast, saturation);
 #endif
@@ -766,20 +711,11 @@
 static int handle_jpeg(enum PixelFormat *format)
 {
     switch (*format) {
-    case PIX_FMT_YUVJ420P:
-        *format = PIX_FMT_YUV420P;
-        return 1;
-    case PIX_FMT_YUVJ422P:
-        *format = PIX_FMT_YUV422P;
-        return 1;
-    case PIX_FMT_YUVJ444P:
-        *format = PIX_FMT_YUV444P;
-        return 1;
-    case PIX_FMT_YUVJ440P:
-        *format = PIX_FMT_YUV440P;
-        return 1;
-    default:
-        return 0;
+    case PIX_FMT_YUVJ420P: *format = PIX_FMT_YUV420P; return 1;
+    case PIX_FMT_YUVJ422P: *format = PIX_FMT_YUV422P; return 1;
+    case PIX_FMT_YUVJ444P: *format = PIX_FMT_YUV444P; return 1;
+    case PIX_FMT_YUVJ440P: *format = PIX_FMT_YUV440P; return 1;
+    default:                                          return 0;
     }
 }
 
@@ -787,7 +723,6 @@
                            int dstW, int dstH, enum PixelFormat dstFormat, int flags,
                            SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
 {
-
     SwsContext *c;
     int i;
     int usesVFilter, usesHFilter;
@@ -954,7 +889,7 @@
 
     /* precalculate horizontal scaler filter coefficients */
     {
-#if ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL
+#if ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT)
 // can't downscale !!!
         if (c->canMMX2BeUsed && (flags & SWS_FAST_BILINEAR)) {
             c->lumMmx2FilterCodeSize = initMMX2HScaler(      dstW, c->lumXInc, NULL, NULL, NULL, 8);
@@ -971,6 +906,8 @@
             c->chrMmx2FilterCode = av_malloc(c->chrMmx2FilterCodeSize);
 #endif
 
+            if (!c->lumMmx2FilterCode || !c->chrMmx2FilterCode)
+                goto fail;
             FF_ALLOCZ_OR_GOTO(c, c->hLumFilter   , (dstW        /8+8)*sizeof(int16_t), fail);
             FF_ALLOCZ_OR_GOTO(c, c->hChrFilter   , (c->chrDstW  /4+8)*sizeof(int16_t), fail);
             FF_ALLOCZ_OR_GOTO(c, c->hLumFilterPos, (dstW      /2/8+8)*sizeof(int32_t), fail);
@@ -984,7 +921,7 @@
             mprotect(c->chrMmx2FilterCode, c->chrMmx2FilterCodeSize, PROT_EXEC | PROT_READ);
 #endif
         } else
-#endif /* ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL */
+#endif /* ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) */
         {
             const int filterAlign=
                 (flags & SWS_CPU_CAPS_MMX) ? 4 :
@@ -1022,7 +959,7 @@
                        srcFilter->chrV, dstFilter->chrV, c->param) < 0)
             goto fail;
 
-#if ARCH_PPC && (HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT)
+#if HAVE_ALTIVEC
         FF_ALLOC_OR_GOTO(c, c->vYCoeffsBank, sizeof (vector signed short)*c->vLumFilterSize*c->dstH, fail);
         FF_ALLOC_OR_GOTO(c, c->vCCoeffsBank, sizeof (vector signed short)*c->vChrFilterSize*c->chrDstH, fail);
 
@@ -1116,7 +1053,9 @@
         av_log(c, AV_LOG_INFO, "from %s to %s%s ",
                sws_format_name(srcFormat),
 #ifdef DITHER1XBPP
-               dstFormat == PIX_FMT_BGR555 || dstFormat == PIX_FMT_BGR565 ? "dithered " : "",
+               dstFormat == PIX_FMT_BGR555 || dstFormat == PIX_FMT_BGR565 ||
+               dstFormat == PIX_FMT_RGB444BE || dstFormat == PIX_FMT_RGB444LE ||
+               dstFormat == PIX_FMT_BGR444BE || dstFormat == PIX_FMT_BGR444LE ? "dithered " : "",
 #else
                "",
 #endif
@@ -1185,6 +1124,9 @@
             av_log(c, AV_LOG_VERBOSE, "using %s YV12->BGR16 converter\n", (flags & SWS_CPU_CAPS_MMX) ? "MMX" : "C");
         else if (dstFormat==PIX_FMT_BGR555)
             av_log(c, AV_LOG_VERBOSE, "using %s YV12->BGR15 converter\n", (flags & SWS_CPU_CAPS_MMX) ? "MMX" : "C");
+        else if (dstFormat == PIX_FMT_RGB444BE || dstFormat == PIX_FMT_RGB444LE ||
+                 dstFormat == PIX_FMT_BGR444BE || dstFormat == PIX_FMT_BGR444LE)
+            av_log(c, AV_LOG_VERBOSE, "using %s YV12->BGR12 converter\n", (flags & SWS_CPU_CAPS_MMX) ? "MMX" : "C");
 
         av_log(c, AV_LOG_VERBOSE, "%dx%d -> %dx%d\n", srcW, srcH, dstW, dstH);
         av_log(c, AV_LOG_DEBUG, "lum srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n",
@@ -1312,7 +1254,7 @@
     return sws_getConstVec(1.0, 1);
 }
 
-double sws_dcVec(SwsVector *a)
+static double sws_dcVec(SwsVector *a)
 {
     int i;
     double sum=0;
@@ -1526,7 +1468,7 @@
     av_freep(&c->vChrFilter);
     av_freep(&c->hLumFilter);
     av_freep(&c->hChrFilter);
-#if ARCH_PPC && (HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT)
+#if HAVE_ALTIVEC
     av_freep(&c->vYCoeffsBank);
     av_freep(&c->vCCoeffsBank);
 #endif
@@ -1536,20 +1478,20 @@
     av_freep(&c->hLumFilterPos);
     av_freep(&c->hChrFilterPos);
 
-#if ARCH_X86 && CONFIG_GPL
+#if ARCH_X86
 #ifdef MAP_ANONYMOUS
     if (c->lumMmx2FilterCode) munmap(c->lumMmx2FilterCode, c->lumMmx2FilterCodeSize);
     if (c->chrMmx2FilterCode) munmap(c->chrMmx2FilterCode, c->chrMmx2FilterCodeSize);
 #elif HAVE_VIRTUALALLOC
-    if (c->lumMmx2FilterCode) VirtualFree(c->lumMmx2FilterCode, c->lumMmx2FilterCodeSize, MEM_RELEASE);
-    if (c->chrMmx2FilterCode) VirtualFree(c->chrMmx2FilterCode, c->chrMmx2FilterCodeSize, MEM_RELEASE);
+    if (c->lumMmx2FilterCode) VirtualFree(c->lumMmx2FilterCode, 0, MEM_RELEASE);
+    if (c->chrMmx2FilterCode) VirtualFree(c->chrMmx2FilterCode, 0, MEM_RELEASE);
 #else
     av_free(c->lumMmx2FilterCode);
     av_free(c->chrMmx2FilterCode);
 #endif
     c->lumMmx2FilterCode=NULL;
     c->chrMmx2FilterCode=NULL;
-#endif /* ARCH_X86 && CONFIG_GPL */
+#endif /* ARCH_X86 */
 
     av_freep(&c->yuvTable);
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_mmx.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_mmx.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_mmx.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -41,6 +41,9 @@
 DECLARE_ASM_CONST(8, uint64_t, mmx_00ffw)   = 0x00ff00ff00ff00ffULL;
 DECLARE_ASM_CONST(8, uint64_t, mmx_redmask) = 0xf8f8f8f8f8f8f8f8ULL;
 DECLARE_ASM_CONST(8, uint64_t, mmx_grnmask) = 0xfcfcfcfcfcfcfcfcULL;
+DECLARE_ASM_CONST(8, uint64_t, pb_e0) = 0xe0e0e0e0e0e0e0e0ULL;
+DECLARE_ASM_CONST(8, uint64_t, pb_03) = 0x0303030303030303ULL;
+DECLARE_ASM_CONST(8, uint64_t, pb_07) = 0x0707070707070707ULL;
 
 //MMX versions
 #undef RENAME

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_template.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_template.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_template.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -1,28 +1,23 @@
 /*
- * yuv2rgb_mmx.c, software YUV to RGB converter with Intel MMX "technology"
+ * software YUV to RGB converter
  *
- * Copyright (C) 2000, Silicon Integrated System Corp
+ * Copyright (C) 2001-2007 Michael Niedermayer
+ *           (c) 2010 Konstantin Shishkov
  *
- * Author: Olie Lho <ollie at sis.com.tw>
+ * This file is part of FFmpeg.
  *
- * 15,24 bpp and dithering from Michael Niedermayer (michaelni at gmx.at)
- * MMX/MMX2 Template stuff from Michael Niedermayer (needed for fast movntq support)
- * context / deglobalize stuff by Michael Niedermayer
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This file is part of mpeg2dec, a free MPEG-2 video decoder
- *
- * mpeg2dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * mpeg2dec is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with mpeg2dec; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -32,9 +27,9 @@
 
 #if HAVE_AMD3DNOW
 /* On K6 femms is faster than emms. On K7 femms is directly mapped to emms. */
-#define EMMS     "femms"
+#define EMMS   "femms"
 #else
-#define EMMS     "emms"
+#define EMMS   "emms"
 #endif
 
 #if HAVE_MMX2
@@ -45,520 +40,414 @@
 #define SFENCE " # nop"
 #endif
 
-#define YUV2RGB \
-    /* Do the multiply part of the conversion for even and odd pixels,
-       register usage:
-       mm0 -> Cblue, mm1 -> Cred, mm2 -> Cgreen even pixels,
-       mm3 -> Cblue, mm4 -> Cred, mm5 -> Cgreen odd pixels,
-       mm6 -> Y even, mm7 -> Y odd */\
-    /* convert the chroma part */\
-    "punpcklbw %%mm4, %%mm0;" /* scatter 4 Cb 00 u3 00 u2 00 u1 00 u0 */ \
-    "punpcklbw %%mm4, %%mm1;" /* scatter 4 Cr 00 v3 00 v2 00 v1 00 v0 */ \
+#define REG_BLUE  "0"
+#define REG_RED   "1"
+#define REG_GREEN "2"
+#define REG_ALPHA "3"
+
+#define YUV2RGB_LOOP(depth)                                          \
+    h_size = (c->dstW + 7) & ~7;                                     \
+    if (h_size * depth > FFABS(dstStride[0]))                        \
+        h_size -= 8;                                                 \
+                                                                     \
+    if (c->srcFormat == PIX_FMT_YUV422P) {                           \
+        srcStride[1] *= 2;                                           \
+        srcStride[2] *= 2;                                           \
+    }                                                                \
+                                                                     \
+    __asm__ volatile ("pxor %mm4, %mm4\n\t");                        \
+    for (y = 0; y < srcSliceH; y++) {                                \
+        uint8_t *image    = dst[0] + (y + srcSliceY) * dstStride[0]; \
+        const uint8_t *py = src[0] +               y * srcStride[0]; \
+        const uint8_t *pu = src[1] +        (y >> 1) * srcStride[1]; \
+        const uint8_t *pv = src[2] +        (y >> 1) * srcStride[2]; \
+        x86_reg index = -h_size / 2;                                 \
+
+#define YUV2RGB_INITIAL_LOAD          \
+    __asm__ volatile (                \
+        "movq (%5, %0, 2), %%mm6\n\t" \
+        "movd    (%2, %0), %%mm0\n\t" \
+        "movd    (%3, %0), %%mm1\n\t" \
+        "1: \n\t"                     \
+
+/* YUV2RGB core
+ * Conversion is performed in usual way:
+ * R = Y' * Ycoef + Vred * V'
+ * G = Y' * Ycoef + Vgreen * V' + Ugreen * U'
+ * B = Y' * Ycoef               + Ublue * U'
+ *
+ * where X' = X * 8 - Xoffset (multiplication is performed to increase
+ * precision a bit).
+ * Since it operates in YUV420 colorspace, Y component is additionally
+ * split into Y1 and Y2 for even and odd pixels.
+ *
+ * Input:
+ * mm0 - U (4 elems), mm1 - V (4 elems), mm6 - Y (8 elems), mm4 - zero register
+ * Output:
+ * mm1 - R, mm2 - G, mm0 - B
+ */
+#define YUV2RGB                                  \
+    /* convert Y, U, V into Y1', Y2', U', V' */  \
+    "movq      %%mm6, %%mm7\n\t"                 \
+    "punpcklbw %%mm4, %%mm0\n\t"                 \
+    "punpcklbw %%mm4, %%mm1\n\t"                 \
+    "pand     "MANGLE(mmx_00ffw)", %%mm6\n\t"    \
+    "psrlw     $8,    %%mm7\n\t"                 \
+    "psllw     $3,    %%mm0\n\t"                 \
+    "psllw     $3,    %%mm1\n\t"                 \
+    "psllw     $3,    %%mm6\n\t"                 \
+    "psllw     $3,    %%mm7\n\t"                 \
+    "psubsw   "U_OFFSET"(%4), %%mm0\n\t"         \
+    "psubsw   "V_OFFSET"(%4), %%mm1\n\t"         \
+    "psubw    "Y_OFFSET"(%4), %%mm6\n\t"         \
+    "psubw    "Y_OFFSET"(%4), %%mm7\n\t"         \
 \
-    "psllw $3, %%mm0;" /* Promote precision */ \
-    "psllw $3, %%mm1;" /* Promote precision */ \
+     /* multiply by coefficients */              \
+    "movq      %%mm0, %%mm2\n\t"                 \
+    "movq      %%mm1, %%mm3\n\t"                 \
+    "pmulhw   "UG_COEFF"(%4), %%mm2\n\t"         \
+    "pmulhw   "VG_COEFF"(%4), %%mm3\n\t"         \
+    "pmulhw   "Y_COEFF" (%4), %%mm6\n\t"         \
+    "pmulhw   "Y_COEFF" (%4), %%mm7\n\t"         \
+    "pmulhw   "UB_COEFF"(%4), %%mm0\n\t"         \
+    "pmulhw   "VR_COEFF"(%4), %%mm1\n\t"         \
+    "paddsw    %%mm3, %%mm2\n\t"                 \
+    /* now: mm0 = UB, mm1 = VR, mm2 = CG */      \
+    /*      mm6 = Y1, mm7 = Y2 */                \
 \
-    "psubsw "U_OFFSET"(%4), %%mm0;" /* Cb -= 128 */ \
-    "psubsw "V_OFFSET"(%4), %%mm1;" /* Cr -= 128 */ \
-\
-    "movq %%mm0, %%mm2;" /* Copy 4 Cb 00 u3 00 u2 00 u1 00 u0 */ \
-    "movq %%mm1, %%mm3;" /* Copy 4 Cr 00 v3 00 v2 00 v1 00 v0 */ \
-\
-    "pmulhw "UG_COEFF"(%4), %%mm2;" /* Mul Cb with green coeff -> Cb green */ \
-    "pmulhw "VG_COEFF"(%4), %%mm3;" /* Mul Cr with green coeff -> Cr green */ \
-\
-    "pmulhw "UB_COEFF"(%4), %%mm0;" /* Mul Cb -> Cblue 00 b3 00 b2 00 b1 00 b0 */\
-    "pmulhw "VR_COEFF"(%4), %%mm1;" /* Mul Cr -> Cred 00 r3 00 r2 00 r1 00 r0 */\
-\
-    "paddsw %%mm3, %%mm2;" /* Cb green + Cr green -> Cgreen */\
-\
-    /* convert the luma part */\
-    "movq %%mm6, %%mm7;" /* Copy 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\
-    "pand "MANGLE(mmx_00ffw)", %%mm6;" /* get Y even 00 Y6 00 Y4 00 Y2 00 Y0 */\
-\
-    "psrlw $8, %%mm7;" /* get Y odd 00 Y7 00 Y5 00 Y3 00 Y1 */\
-\
-    "psllw $3, %%mm6;" /* Promote precision */\
-    "psllw $3, %%mm7;" /* Promote precision */\
-\
-    "psubw "Y_OFFSET"(%4), %%mm6;" /* Y -= 16 */\
-    "psubw "Y_OFFSET"(%4), %%mm7;" /* Y -= 16 */\
-\
-    "pmulhw "Y_COEFF"(%4), %%mm6;" /* Mul 4 Y even 00 y6 00 y4 00 y2 00 y0 */\
-    "pmulhw "Y_COEFF"(%4), %%mm7;" /* Mul 4 Y odd 00 y7 00 y5 00 y3 00 y1 */\
-\
-    /* Do the addition part of the conversion for even and odd pixels,
-       register usage:
-       mm0 -> Cblue, mm1 -> Cred, mm2 -> Cgreen even pixels,
-       mm3 -> Cblue, mm4 -> Cred, mm5 -> Cgreen odd pixels,
-       mm6 -> Y even, mm7 -> Y odd */\
-    "movq %%mm0, %%mm3;" /* Copy Cblue */\
-    "movq %%mm1, %%mm4;" /* Copy Cred */\
-    "movq %%mm2, %%mm5;" /* Copy Cgreen */\
-\
-    "paddsw %%mm6, %%mm0;" /* Y even + Cblue 00 B6 00 B4 00 B2 00 B0 */\
-    "paddsw %%mm7, %%mm3;" /* Y odd + Cblue 00 B7 00 B5 00 B3 00 B1 */\
-\
-    "paddsw %%mm6, %%mm1;" /* Y even + Cred 00 R6 00 R4 00 R2 00 R0 */\
-    "paddsw %%mm7, %%mm4;" /* Y odd + Cred 00 R7 00 R5 00 R3 00 R1 */\
-\
-    "paddsw %%mm6, %%mm2;" /* Y even + Cgreen 00 G6 00 G4 00 G2 00 G0 */\
-    "paddsw %%mm7, %%mm5;" /* Y odd + Cgreen 00 G7 00 G5 00 G3 00 G1 */\
-\
-    /* Limit RGB even to 0..255 */\
-    "packuswb %%mm0, %%mm0;" /* B6 B4 B2 B0  B6 B4 B2 B0 */\
-    "packuswb %%mm1, %%mm1;" /* R6 R4 R2 R0  R6 R4 R2 R0 */\
-    "packuswb %%mm2, %%mm2;" /* G6 G4 G2 G0  G6 G4 G2 G0 */\
-\
-    /* Limit RGB odd to 0..255 */\
-    "packuswb %%mm3, %%mm3;" /* B7 B5 B3 B1  B7 B5 B3 B1 */\
-    "packuswb %%mm4, %%mm4;" /* R7 R5 R3 R1  R7 R5 R3 R1 */\
-    "packuswb %%mm5, %%mm5;" /* G7 G5 G3 G1  G7 G5 G3 G1 */\
-\
-    /* Interleave RGB even and odd */\
-    "punpcklbw %%mm3, %%mm0;" /* B7 B6 B5 B4 B3 B2 B1 B0 */\
-    "punpcklbw %%mm4, %%mm1;" /* R7 R6 R5 R4 R3 R2 R1 R0 */\
-    "punpcklbw %%mm5, %%mm2;" /* G7 G6 G5 G4 G3 G2 G1 G0 */\
+    /* produce RGB */                            \
+    "movq      %%mm7, %%mm3\n\t"                 \
+    "movq      %%mm7, %%mm5\n\t"                 \
+    "paddsw    %%mm0, %%mm3\n\t"                 \
+    "paddsw    %%mm1, %%mm5\n\t"                 \
+    "paddsw    %%mm2, %%mm7\n\t"                 \
+    "paddsw    %%mm6, %%mm0\n\t"                 \
+    "paddsw    %%mm6, %%mm1\n\t"                 \
+    "paddsw    %%mm6, %%mm2\n\t"                 \
 
+#define RGB_PACK_INTERLEAVE                  \
+    /* pack and interleave even/odd pixels */    \
+    "packuswb  %%mm1, %%mm0\n\t"                 \
+    "packuswb  %%mm5, %%mm3\n\t"                 \
+    "packuswb  %%mm2, %%mm2\n\t"                 \
+    "movq      %%mm0, %%mm1\n\n"                 \
+    "packuswb  %%mm7, %%mm7\n\t"                 \
+    "punpcklbw %%mm3, %%mm0\n\t"                 \
+    "punpckhbw %%mm3, %%mm1\n\t"                 \
+    "punpcklbw %%mm7, %%mm2\n\t"                 \
 
-#define YUV422_UNSHIFT                   \
-    if(c->srcFormat == PIX_FMT_YUV422P) {\
-        srcStride[1] *= 2;               \
-        srcStride[2] *= 2;               \
-    }                                    \
+#define YUV2RGB_ENDLOOP(depth)                   \
+    "movq 8 (%5, %0, 2), %%mm6\n\t"              \
+    "movd 4 (%3, %0),    %%mm1\n\t"              \
+    "movd 4 (%2, %0),    %%mm0\n\t"              \
+    "add $"AV_STRINGIFY(depth * 8)", %1\n\t"     \
+    "add  $4, %0\n\t"                            \
+    "js   1b\n\t"                                \
 
-#define YUV2RGB_LOOP(depth)                                   \
-    h_size= (c->dstW+7)&~7;                                   \
-    if(h_size*depth > FFABS(dstStride[0])) h_size-=8;         \
-\
-    __asm__ volatile ("pxor %mm4, %mm4;" /* zero mm4 */ );    \
-    for (y= 0; y<srcSliceH; y++ ) {                           \
-        uint8_t *image = dst[0] + (y+srcSliceY)*dstStride[0]; \
-        const uint8_t *py = src[0] + y*srcStride[0];          \
-        const uint8_t *pu = src[1] + (y>>1)*srcStride[1];     \
-        const uint8_t *pv = src[2] + (y>>1)*srcStride[2];     \
-        x86_reg index= -h_size/2;                                \
+#define YUV2RGB_OPERANDS                                          \
+        : "+r" (index), "+r" (image)                              \
+        : "r" (pu - index), "r" (pv - index), "r"(&c->redDither), \
+          "r" (py - 2*index)                                      \
+        );                                                        \
+    }                                                             \
 
-#define YUV2RGB_INIT                                                       \
-        /* This MMX assembly code deals with a SINGLE scan line at a time, \
-         * it converts 8 pixels in each iteration. */                      \
-        __asm__ volatile (                                                 \
-        /* load data for start of next scan line */                        \
-        "movd    (%2, %0), %%mm0;" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */ \
-        "movd    (%3, %0), %%mm1;" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */ \
-        "movq (%5, %0, 2), %%mm6;" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */ \
-        /*                                                                 \
-        ".balign 16     \n\t"                                              \
-        */                                                                 \
-        "1:             \n\t"                                              \
-        /* No speed difference on my p3 at 500 with prefetch,                 \
-         * if it is faster for anyone with -benchmark then tell me.        \
-        PREFETCH" 64(%0) \n\t"                                             \
-        PREFETCH" 64(%1) \n\t"                                             \
-        PREFETCH" 64(%2) \n\t"                                             \
-        */                                                                 \
+#define YUV2RGB_OPERANDS_ALPHA                                    \
+        : "+r" (index), "+r" (image)                              \
+        : "r" (pu - index), "r" (pv - index), "r"(&c->redDither), \
+          "r" (py - 2*index), "r" (pa - 2*index)                  \
+        );                                                        \
+    }                                                             \
 
-#define YUV2RGB_ENDLOOP(depth) \
-        "add $"AV_STRINGIFY(depth*8)", %1    \n\t" \
-        "add                       $4, %0    \n\t" \
-        " js                       1b        \n\t" \
+#define YUV2RGB_ENDFUNC                          \
+    __asm__ volatile (SFENCE"\n\t"EMMS);         \
+    return srcSliceH;                            \
 
-#define YUV2RGB_OPERANDS \
-        : "+r" (index), "+r" (image) \
-        : "r" (pu - index), "r" (pv - index), "r"(&c->redDither), "r" (py - 2*index) \
-        ); \
-    } \
-    __asm__ volatile (SFENCE"\n\t"EMMS); \
-    return srcSliceH; \
+#define IF0(x)
+#define IF1(x) x
 
-#define YUV2RGB_OPERANDS_ALPHA \
-        : "+r" (index), "+r" (image) \
-        : "r" (pu - index), "r" (pv - index), "r"(&c->redDither), "r" (py - 2*index), "r" (pa - 2*index) \
-        ); \
-    } \
-    __asm__ volatile (SFENCE"\n\t"EMMS); \
-    return srcSliceH; \
+#define RGB_PACK16(gmask, is15)                  \
+    "pand      "MANGLE(mmx_redmask)", %%mm0\n\t" \
+    "pand      "MANGLE(mmx_redmask)", %%mm1\n\t" \
+    "movq      %%mm2,     %%mm3\n\t"             \
+    "psllw   $"AV_STRINGIFY(3-is15)", %%mm2\n\t" \
+    "psrlw   $"AV_STRINGIFY(5+is15)", %%mm3\n\t" \
+    "psrlw     $3,        %%mm0\n\t"             \
+    IF##is15("psrlw  $1,  %%mm1\n\t")            \
+    "pand "MANGLE(pb_e0)", %%mm2\n\t"            \
+    "pand "MANGLE(gmask)", %%mm3\n\t"            \
+    "por       %%mm2,     %%mm0\n\t"             \
+    "por       %%mm3,     %%mm1\n\t"             \
+    "movq      %%mm0,     %%mm2\n\t"             \
+    "punpcklbw %%mm1,     %%mm0\n\t"             \
+    "punpckhbw %%mm1,     %%mm2\n\t"             \
+    MOVNTQ "   %%mm0,      (%1)\n\t"             \
+    MOVNTQ "   %%mm2,     8(%1)\n\t"             \
 
-static inline int RENAME(yuv420_rgb16)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+#define DITHER_RGB                               \
+    "paddusb "BLUE_DITHER"(%4),  %%mm0\n\t"      \
+    "paddusb "GREEN_DITHER"(%4), %%mm2\n\t"      \
+    "paddusb "RED_DITHER"(%4),   %%mm1\n\t"      \
+
+static inline int RENAME(yuv420_rgb15)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(2)
 
-        c->blueDither= ff_dither8[y&1];
-        c->greenDither= ff_dither4[y&1];
-        c->redDither= ff_dither8[(y+1)&1];
+#ifdef DITHER1XBPP
+        c->blueDither  = ff_dither8[y       & 1];
+        c->greenDither = ff_dither8[y       & 1];
+        c->redDither   = ff_dither8[(y + 1) & 1];
+#endif
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-
+        RGB_PACK_INTERLEAVE
 #ifdef DITHER1XBPP
-        "paddusb "BLUE_DITHER"(%4), %%mm0;"
-        "paddusb "GREEN_DITHER"(%4), %%mm2;"
-        "paddusb "RED_DITHER"(%4), %%mm1;"
+        DITHER_RGB
 #endif
-        /* mask unneeded bits off */
-        "pand "MANGLE(mmx_redmask)", %%mm0;" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */
-        "pand "MANGLE(mmx_grnmask)", %%mm2;" /* g7g6g5g4 g3g2_0_0 g7g6g5g4 g3g2_0_0 */
-        "pand "MANGLE(mmx_redmask)", %%mm1;" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */
+        RGB_PACK16(pb_03, 1)
 
-        "psrlw   $3, %%mm0;" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */
-        "pxor %%mm4, %%mm4;" /* zero mm4 */
-
-        "movq %%mm0, %%mm5;" /* Copy B7-B0 */
-        "movq %%mm2, %%mm7;" /* Copy G7-G0 */
-
-        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
-        "punpcklbw %%mm4, %%mm2;" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */
-        "punpcklbw %%mm1, %%mm0;" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
-
-        "psllw  $3, %%mm2;" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */
-        "por %%mm2, %%mm0;" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */
-
-        "movq 8 (%5, %0, 2), %%mm6;" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */
-        MOVNTQ "      %%mm0, (%1);" /* store pixel 0-3 */
-
-        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
-        "punpckhbw %%mm4, %%mm7;" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */
-        "punpckhbw %%mm1, %%mm5;" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
-
-        "psllw        $3, %%mm7;" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */
-        "movd 4 (%2, %0), %%mm0;" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */
-
-        "por       %%mm7, %%mm5;" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */
-        "movd 4 (%3, %0), %%mm1;" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */
-
-        MOVNTQ "   %%mm5, 8 (%1);" /* store pixel 4-7 */
-
     YUV2RGB_ENDLOOP(2)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuv420_rgb15)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuv420_rgb16)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(2)
 
-        c->blueDither= ff_dither8[y&1];
-        c->greenDither= ff_dither8[y&1];
-        c->redDither= ff_dither8[(y+1)&1];
+#ifdef DITHER1XBPP
+        c->blueDither  = ff_dither8[y       & 1];
+        c->greenDither = ff_dither4[y       & 1];
+        c->redDither   = ff_dither8[(y + 1) & 1];
+#endif
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-
+        RGB_PACK_INTERLEAVE
 #ifdef DITHER1XBPP
-        "paddusb "BLUE_DITHER"(%4), %%mm0  \n\t"
-        "paddusb "GREEN_DITHER"(%4), %%mm2  \n\t"
-        "paddusb "RED_DITHER"(%4), %%mm1  \n\t"
+        DITHER_RGB
 #endif
+        RGB_PACK16(pb_07, 0)
 
-        /* mask unneeded bits off */
-        "pand "MANGLE(mmx_redmask)", %%mm0;" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */
-        "pand "MANGLE(mmx_redmask)", %%mm2;" /* g7g6g5g4 g3_0_0_0 g7g6g5g4 g3_0_0_0 */
-        "pand "MANGLE(mmx_redmask)", %%mm1;" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */
-
-        "psrlw   $3, %%mm0;" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */
-        "psrlw   $1, %%mm1;" /* 0_r7r6r5  r4r3_0_0 0_r7r6r5 r4r3_0_0 */
-        "pxor %%mm4, %%mm4;" /* zero mm4 */
-
-        "movq %%mm0, %%mm5;" /* Copy B7-B0 */
-        "movq %%mm2, %%mm7;" /* Copy G7-G0 */
-
-        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
-        "punpcklbw %%mm4, %%mm2;" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3_0_0_0 */
-        "punpcklbw %%mm1, %%mm0;" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
-
-        "psllw  $2, %%mm2;" /* 0_0_0_0 0_0_g7g6 g5g4g3_0 0_0_0_0 */
-        "por %%mm2, %%mm0;" /* 0_r7r6r5 r4r3g7g6 g5g4g3b7 b6b5b4b3 */
-
-        "movq 8 (%5, %0, 2), %%mm6;" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */
-        MOVNTQ "      %%mm0, (%1);"  /* store pixel 0-3 */
-
-        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
-        "punpckhbw %%mm4, %%mm7;" /* 0_0_0_0 0_0_0_0 0_g7g6g5 g4g3_0_0 */
-        "punpckhbw %%mm1, %%mm5;" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
-
-        "psllw        $2, %%mm7;" /* 0_0_0_0 0_0_g7g6 g5g4g3_0 0_0_0_0 */
-        "movd 4 (%2, %0), %%mm0;" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */
-
-        "por       %%mm7, %%mm5;" /* 0_r7r6r5 r4r3g7g6 g5g4g3b7 b6b5b4b3 */
-        "movd 4 (%3, %0), %%mm1;" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */
-
-        MOVNTQ " %%mm5, 8 (%1);" /* store pixel 4-7 */
-
     YUV2RGB_ENDLOOP(2)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-#undef RGB_PLANAR2PACKED24
+#define RGB_PACK24(blue, red)\
+    "packuswb  %%mm3,      %%mm0 \n" /* R0 R2 R4 R6 R1 R3 R5 R7 */\
+    "packuswb  %%mm5,      %%mm1 \n" /* B0 B2 B4 B6 B1 B3 B5 B7 */\
+    "packuswb  %%mm7,      %%mm2 \n" /* G0 G2 G4 G6 G1 G3 G5 G7 */\
+    "movq      %%mm"red",  %%mm3 \n"\
+    "movq      %%mm"blue", %%mm6 \n"\
+    "psrlq     $32,        %%mm"red" \n" /* R1 R3 R5 R7 */\
+    "punpcklbw %%mm2,      %%mm3 \n" /* R0 G0 R2 G2 R4 G4 R6 G6 */\
+    "punpcklbw %%mm"red",  %%mm6 \n" /* B0 R1 B2 R3 B4 R5 B6 R7 */\
+    "movq      %%mm3,      %%mm5 \n"\
+    "punpckhbw %%mm"blue", %%mm2 \n" /* G1 B1 G3 B3 G5 B5 G7 B7?*/\
+    "punpcklwd %%mm6,      %%mm3 \n" /* R0 G0 B0 R1 R2 G2 B2 R3 */\
+    "punpckhwd %%mm6,      %%mm5 \n" /* R4 G4 B4 R5 R6 G6 B6 R7 */\
+    RGB_PACK24_B
+
 #if HAVE_MMX2
-#define RGB_PLANAR2PACKED24(red, blue)\
-        "movq "MANGLE(ff_M24A)", %%mm4     \n\t"\
-        "movq "MANGLE(ff_M24C)", %%mm7     \n\t"\
-        "pshufw $0x50, %%mm"blue", %%mm5   \n\t" /* B3 B2 B3 B2  B1 B0 B1 B0 */\
-        "pshufw $0x50, %%mm2, %%mm3     \n\t" /* G3 G2 G3 G2  G1 G0 G1 G0 */\
-        "pshufw $0x00, %%mm"red", %%mm6 \n\t" /* R1 R0 R1 R0  R1 R0 R1 R0 */\
-\
-        "pand   %%mm4, %%mm5            \n\t" /*    B2        B1       B0 */\
-        "pand   %%mm4, %%mm3            \n\t" /*    G2        G1       G0 */\
-        "pand   %%mm7, %%mm6            \n\t" /*       R1        R0       */\
-\
-        "psllq     $8, %%mm3            \n\t" /* G2        G1       G0    */\
-        "por    %%mm5, %%mm6            \n\t"\
-        "por    %%mm3, %%mm6            \n\t"\
-        MOVNTQ" %%mm6, (%1)             \n\t"\
-\
-        "psrlq     $8, %%mm2            \n\t" /* 00 G7 G6 G5  G4 G3 G2 G1 */\
-        "pshufw $0xA5, %%mm"blue", %%mm5\n\t" /* B5 B4 B5 B4  B3 B2 B3 B2 */\
-        "pshufw $0x55, %%mm2, %%mm3     \n\t" /* G4 G3 G4 G3  G4 G3 G4 G3 */\
-        "pshufw $0xA5, %%mm"red", %%mm6 \n\t" /* R5 R4 R5 R4  R3 R2 R3 R2 */\
-\
-        "pand "MANGLE(ff_M24B)", %%mm5  \n\t" /* B5       B4        B3    */\
-        "pand          %%mm7, %%mm3     \n\t" /*       G4        G3       */\
-        "pand          %%mm4, %%mm6     \n\t" /*    R4        R3       R2 */\
-\
-        "por    %%mm5, %%mm3            \n\t" /* B5    G4 B4     G3 B3    */\
-        "por    %%mm3, %%mm6            \n\t"\
-        MOVNTQ" %%mm6, 8(%1)            \n\t"\
-\
-        "pshufw $0xFF, %%mm"blue", %%mm5\n\t" /* B7 B6 B7 B6  B7 B6 B6 B7 */\
-        "pshufw $0xFA, %%mm2, %%mm3     \n\t" /* 00 G7 00 G7  G6 G5 G6 G5 */\
-        "pshufw $0xFA, %%mm"red", %%mm6 \n\t" /* R7 R6 R7 R6  R5 R4 R5 R4 */\
-        "movd 4 (%2, %0), %%mm0;" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\
-\
-        "pand          %%mm7, %%mm5     \n\t" /*       B7        B6       */\
-        "pand          %%mm4, %%mm3     \n\t" /*    G7        G6       G5 */\
-        "pand "MANGLE(ff_M24B)", %%mm6  \n\t" /* R7       R6        R5    */\
-        "movd 4 (%3, %0), %%mm1;" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\
-\
-        "por          %%mm5, %%mm3      \n\t"\
-        "por          %%mm3, %%mm6      \n\t"\
-        MOVNTQ"       %%mm6, 16(%1)     \n\t"\
-        "movq 8 (%5, %0, 2), %%mm6;" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\
-        "pxor         %%mm4, %%mm4      \n\t"
+DECLARE_ASM_CONST(8, int16_t, mask1101[4]) = {-1,-1, 0,-1};
+DECLARE_ASM_CONST(8, int16_t, mask0010[4]) = { 0, 0,-1, 0};
+DECLARE_ASM_CONST(8, int16_t, mask0110[4]) = { 0,-1,-1, 0};
+DECLARE_ASM_CONST(8, int16_t, mask1001[4]) = {-1, 0, 0,-1};
+DECLARE_ASM_CONST(8, int16_t, mask0100[4]) = { 0,-1, 0, 0};
+#undef RGB_PACK24_B
+#define RGB_PACK24_B\
+    "pshufw    $0xc6,  %%mm2, %%mm1 \n"\
+    "pshufw    $0x84,  %%mm3, %%mm6 \n"\
+    "pshufw    $0x38,  %%mm5, %%mm7 \n"\
+    "pand "MANGLE(mask1101)", %%mm6 \n" /* R0 G0 B0 R1 -- -- R2 G2 */\
+    "movq      %%mm1,         %%mm0 \n"\
+    "pand "MANGLE(mask0110)", %%mm7 \n" /* -- -- R6 G6 B6 R7 -- -- */\
+    "movq      %%mm1,         %%mm2 \n"\
+    "pand "MANGLE(mask0100)", %%mm1 \n" /* -- -- G3 B3 -- -- -- -- */\
+    "psrlq       $48,         %%mm3 \n" /* B2 R3 -- -- -- -- -- -- */\
+    "pand "MANGLE(mask0010)", %%mm0 \n" /* -- -- -- -- G1 B1 -- -- */\
+    "psllq       $32,         %%mm5 \n" /* -- -- -- -- R4 G4 B4 R5 */\
+    "pand "MANGLE(mask1001)", %%mm2 \n" /* G5 B5 -- -- -- -- G7 B7 */\
+    "por       %%mm3,         %%mm1 \n"\
+    "por       %%mm6,         %%mm0 \n"\
+    "por       %%mm5,         %%mm1 \n"\
+    "por       %%mm7,         %%mm2 \n"\
+    MOVNTQ"    %%mm0,          (%1) \n"\
+    MOVNTQ"    %%mm1,         8(%1) \n"\
+    MOVNTQ"    %%mm2,        16(%1) \n"\
+
 #else
-#define RGB_PLANAR2PACKED24(red, blue)\
-        "pxor      %%mm4, %%mm4     \n\t"\
-        "movq      %%mm"blue", %%mm5\n\t" /* B */\
-        "movq      %%mm"red", %%mm6 \n\t" /* R */\
-        "punpcklbw %%mm2, %%mm"blue"\n\t" /* GBGBGBGB 0 */\
-        "punpcklbw %%mm4, %%mm"red" \n\t" /* 0R0R0R0R 0 */\
-        "punpckhbw %%mm2, %%mm5     \n\t" /* GBGBGBGB 2 */\
-        "punpckhbw %%mm4, %%mm6     \n\t" /* 0R0R0R0R 2 */\
-        "movq      %%mm"blue", %%mm7\n\t" /* GBGBGBGB 0 */\
-        "movq      %%mm5, %%mm3     \n\t" /* GBGBGBGB 2 */\
-        "punpcklwd %%mm"red", %%mm7 \n\t" /* 0RGB0RGB 0 */\
-        "punpckhwd %%mm"red", %%mm"blue"\n\t" /* 0RGB0RGB 1 */\
-        "punpcklwd %%mm6, %%mm5     \n\t" /* 0RGB0RGB 2 */\
-        "punpckhwd %%mm6, %%mm3     \n\t" /* 0RGB0RGB 3 */\
-\
-        "movq      %%mm7, %%mm2     \n\t" /* 0RGB0RGB 0 */\
-        "movq      %%mm"blue", %%mm6\n\t" /* 0RGB0RGB 1 */\
-        "movq      %%mm5, %%mm"red" \n\t" /* 0RGB0RGB 2 */\
-        "movq      %%mm3, %%mm4     \n\t" /* 0RGB0RGB 3 */\
-\
-        "psllq       $40, %%mm7     \n\t" /* RGB00000 0 */\
-        "psllq       $40, %%mm"blue"\n\t" /* RGB00000 1 */\
-        "psllq       $40, %%mm5     \n\t" /* RGB00000 2 */\
-        "psllq       $40, %%mm3     \n\t" /* RGB00000 3 */\
-\
-        "punpckhdq %%mm2, %%mm7     \n\t" /* 0RGBRGB0 0 */\
-        "punpckhdq %%mm6, %%mm"blue"\n\t" /* 0RGBRGB0 1 */\
-        "punpckhdq %%mm"red", %%mm5 \n\t" /* 0RGBRGB0 2 */\
-        "punpckhdq %%mm4, %%mm3     \n\t" /* 0RGBRGB0 3 */\
-\
-        "psrlq        $8, %%mm7     \n\t" /* 00RGBRGB 0 */\
-        "movq      %%mm"blue", %%mm6\n\t" /* 0RGBRGB0 1 */\
-        "psllq       $40, %%mm"blue"\n\t" /* GB000000 1 */\
-        "por       %%mm"blue", %%mm7\n\t" /* GBRGBRGB 0 */\
-        MOVNTQ"    %%mm7, (%1)      \n\t"\
-\
-        "psrlq       $24, %%mm6     \n\t" /* 0000RGBR 1 */\
-        "movq      %%mm5, %%mm"red" \n\t" /* 0RGBRGB0 2 */\
-        "psllq       $24, %%mm5     \n\t" /* BRGB0000 2 */\
-        "por       %%mm5, %%mm6     \n\t" /* BRGBRGBR 1 */\
-        MOVNTQ"    %%mm6, 8(%1)     \n\t"\
-\
-        "movq 8 (%5, %0, 2), %%mm6;" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\
-\
-        "psrlq       $40, %%mm"red" \n\t" /* 000000RG 2 */\
-        "psllq        $8, %%mm3     \n\t" /* RGBRGB00 3 */\
-        "por       %%mm3, %%mm"red" \n\t" /* RGBRGBRG 2 */\
-        MOVNTQ"    %%mm"red", 16(%1)\n\t"\
-\
-        "movd 4 (%3, %0), %%mm1;" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\
-        "movd 4 (%2, %0), %%mm0;" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\
-        "pxor      %%mm4, %%mm4     \n\t"
+#undef RGB_PACK24_B
+#define RGB_PACK24_B\
+    "movd      %%mm3,       (%1) \n" /* R0 G0 B0 R1 */\
+    "movd      %%mm2,      4(%1) \n" /* G1 B1 */\
+    "psrlq     $32,        %%mm3 \n"\
+    "psrlq     $16,        %%mm2 \n"\
+    "movd      %%mm3,      6(%1) \n" /* R2 G2 B2 R3 */\
+    "movd      %%mm2,     10(%1) \n" /* G3 B3 */\
+    "psrlq     $16,        %%mm2 \n"\
+    "movd      %%mm5,     12(%1) \n" /* R4 G4 B4 R5 */\
+    "movd      %%mm2,     16(%1) \n" /* G5 B5 */\
+    "psrlq     $32,        %%mm5 \n"\
+    "movd      %%mm2,     20(%1) \n" /* -- -- G7 B7 */\
+    "movd      %%mm5,     18(%1) \n" /* R6 G6 B6 R7 */\
+
 #endif
 
-static inline int RENAME(yuv420_rgb24)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuv420_rgb24)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(3)
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        /* mm0=B, %%mm2=G, %%mm1=R */
-        RGB_PLANAR2PACKED24("0", "1")
+        RGB_PACK24(REG_BLUE, REG_RED)
 
     YUV2RGB_ENDLOOP(3)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuv420_bgr24)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuv420_bgr24)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(3)
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        /* mm0=B, %%mm2=G, %%mm1=R */
-        RGB_PLANAR2PACKED24("1", "0")
+        RGB_PACK24(REG_RED, REG_BLUE)
 
     YUV2RGB_ENDLOOP(3)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-/*
 
-RGB_PLANAR2PACKED32(red,green,blue,alpha)
+#define SET_EMPTY_ALPHA                                                      \
+    "pcmpeqd   %%mm"REG_ALPHA", %%mm"REG_ALPHA"\n\t" /* set alpha to 0xFF */ \
 
-convert RGB plane to RGB packed format
+#define LOAD_ALPHA                                   \
+    "movq      (%6, %0, 2),     %%mm"REG_ALPHA"\n\t" \
 
-macro parameters specify the output color channel order:
+#define RGB_PACK32(red, green, blue, alpha)  \
+    "movq      %%mm"blue",  %%mm5\n\t"       \
+    "movq      %%mm"red",   %%mm6\n\t"       \
+    "punpckhbw %%mm"green", %%mm5\n\t"       \
+    "punpcklbw %%mm"green", %%mm"blue"\n\t"  \
+    "punpckhbw %%mm"alpha", %%mm6\n\t"       \
+    "punpcklbw %%mm"alpha", %%mm"red"\n\t"   \
+    "movq      %%mm"blue",  %%mm"green"\n\t" \
+    "movq      %%mm5,       %%mm"alpha"\n\t" \
+    "punpcklwd %%mm"red",   %%mm"blue"\n\t"  \
+    "punpckhwd %%mm"red",   %%mm"green"\n\t" \
+    "punpcklwd %%mm6,       %%mm5\n\t"       \
+    "punpckhwd %%mm6,       %%mm"alpha"\n\t" \
+    MOVNTQ "   %%mm"blue",   0(%1)\n\t"      \
+    MOVNTQ "   %%mm"green",  8(%1)\n\t"      \
+    MOVNTQ "   %%mm5,       16(%1)\n\t"      \
+    MOVNTQ "   %%mm"alpha", 24(%1)\n\t"      \
 
-RGB_PLANAR2PACKED32(REG_RED,  REG_GREEN, REG_BLUE, REG_ALPHA) for RGBA output,
-RGB_PLANAR2PACKED32(REG_BLUE, REG_GREEN, REG_RED,  REG_ALPHA) for BGRA output,
-RGB_PLANAR2PACKED32(REG_ALPHA,REG_BLUE,  REG_GREEN,REG_RED)   for ABGR output,
-
-etc.
-*/
-
-#define REG_BLUE  "0"
-#define REG_RED   "1"
-#define REG_GREEN "2"
-#define REG_ALPHA "3"
-
-#define RGB_PLANAR2PACKED32(red,green,blue,alpha)                       \
-    /* convert RGB plane to RGB packed format,                          \
-       mm0 ->  B, mm1 -> R, mm2 -> G, mm3 -> A,                         \
-       mm4 -> GB, mm5 -> AR pixel 4-7,                                  \
-       mm6 -> GB, mm7 -> AR pixel 0-3 */                                \
-    "movq      %%mm" blue ", %%mm6;"   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
-    "movq      %%mm" red  ", %%mm7;"   /* R7 R6 R5 R4 R3 R2 R1 R0 */    \
-\
-    "movq      %%mm" blue ", %%mm4;"   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
-    "movq      %%mm" red  ", %%mm5;"   /* R7 R6 R5 R4 R3 R2 R1 R0 */    \
-\
-    "punpcklbw %%mm" green ", %%mm6;"  /* G3 B3 G2 B2 G1 B1 G0 B0 */    \
-    "punpcklbw %%mm" alpha ", %%mm7;"  /* A3 R3 A2 R2 A1 R1 A0 R0 */    \
-\
-    "punpcklwd %%mm7, %%mm6;"          /* A1 R1 B1 G1 A0 R0 B0 G0 */    \
-    MOVNTQ "   %%mm6, (%1);"           /* Store ARGB1 ARGB0 */          \
-\
-    "movq      %%mm" blue ", %%mm6;"   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
-    "punpcklbw %%mm" green ", %%mm6;"  /* G3 B3 G2 B2 G1 B1 G0 B0 */    \
-\
-    "punpckhwd %%mm7, %%mm6;"          /* A3 R3 G3 B3 A2 R2 B3 G2 */    \
-    MOVNTQ "   %%mm6, 8 (%1);"         /* Store ARGB3 ARGB2 */          \
-\
-    "punpckhbw %%mm" green ", %%mm4;"  /* G7 B7 G6 B6 G5 B5 G4 B4 */    \
-    "punpckhbw %%mm" alpha ", %%mm5;"  /* A7 R7 A6 R6 A5 R5 A4 R4 */    \
-\
-    "punpcklwd %%mm5, %%mm4;"          /* A5 R5 B5 G5 A4 R4 B4 G4 */    \
-    MOVNTQ "   %%mm4, 16 (%1);"        /* Store ARGB5 ARGB4 */          \
-\
-    "movq      %%mm" blue ", %%mm4;"   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
-    "punpckhbw %%mm" green ", %%mm4;"  /* G7 B7 G6 B6 G5 B5 G4 B4 */    \
-\
-    "punpckhwd %%mm5, %%mm4;"   /* A7 R7 G7 B7 A6 R6 B6 G6 */           \
-    MOVNTQ "   %%mm4, 24 (%1);" /* Store ARGB7 ARGB6 */                 \
-\
-    "movd 4 (%2, %0), %%mm0;"   /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */ \
-    "movd 4 (%3, %0), %%mm1;"   /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */ \
-\
-    "pxor         %%mm4, %%mm4;" /* zero mm4 */                         \
-    "movq 8 (%5, %0, 2), %%mm6;" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */ \
-
-static inline int RENAME(yuv420_rgb32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuv420_rgb32)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(4)
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        "pcmpeqd   %%mm3, %%mm3;"   /* fill mm3 */
-        RGB_PLANAR2PACKED32(REG_RED,REG_GREEN,REG_BLUE,REG_ALPHA)
+        RGB_PACK_INTERLEAVE
+        SET_EMPTY_ALPHA
+        RGB_PACK32(REG_RED, REG_GREEN, REG_BLUE, REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuva420_rgb32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                        int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuva420_rgb32)(SwsContext *c, const uint8_t *src[],
+                                        int srcStride[],
+                                        int srcSliceY, int srcSliceH,
+                                        uint8_t *dst[], int dstStride[])
 {
 #if HAVE_7REGS
     int y, h_size;
 
     YUV2RGB_LOOP(4)
 
-        const uint8_t *pa = src[3] + y*srcStride[3];
-        YUV2RGB_INIT
+        const uint8_t *pa = src[3] + y * srcStride[3];
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        "movq     (%6, %0, 2), %%mm3;"            /* Load 8 A A7 A6 A5 A4 A3 A2 A1 A0 */
-        RGB_PLANAR2PACKED32(REG_RED,REG_GREEN,REG_BLUE,REG_ALPHA)
+        RGB_PACK_INTERLEAVE
+        LOAD_ALPHA
+        RGB_PACK32(REG_RED, REG_GREEN, REG_BLUE, REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS_ALPHA
+    YUV2RGB_ENDFUNC
 #endif
 }
 
-static inline int RENAME(yuv420_bgr32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuv420_bgr32)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(4)
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        "pcmpeqd   %%mm3, %%mm3;"   /* fill mm3 */
-        RGB_PLANAR2PACKED32(REG_BLUE,REG_GREEN,REG_RED,REG_ALPHA)
+        RGB_PACK_INTERLEAVE
+        SET_EMPTY_ALPHA
+        RGB_PACK32(REG_BLUE, REG_GREEN, REG_RED, REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuva420_bgr32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                        int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuva420_bgr32)(SwsContext *c, const uint8_t *src[],
+                                        int srcStride[],
+                                        int srcSliceY, int srcSliceH,
+                                        uint8_t *dst[], int dstStride[])
 {
 #if HAVE_7REGS
     int y, h_size;
 
     YUV2RGB_LOOP(4)
 
-        const uint8_t *pa = src[3] + y*srcStride[3];
-        YUV2RGB_INIT
+        const uint8_t *pa = src[3] + y * srcStride[3];
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        "movq     (%6, %0, 2), %%mm3;"            /* Load 8 A A7 A6 A5 A4 A3 A2 A1 A0 */
-        RGB_PLANAR2PACKED32(REG_BLUE,REG_GREEN,REG_RED,REG_ALPHA)
+        RGB_PACK_INTERLEAVE
+        LOAD_ALPHA
+        RGB_PACK32(REG_BLUE, REG_GREEN, REG_RED, REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS_ALPHA
+    YUV2RGB_ENDFUNC
 #endif
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/yuv2rgb.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/yuv2rgb.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/yuv2rgb.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -33,7 +33,9 @@
 #include "swscale.h"
 #include "swscale_internal.h"
 #include "libavutil/x86_cpu.h"
+#include "libavutil/bswap.h"
 
+extern const uint8_t dither_4x4_16[4][8];
 extern const uint8_t dither_8x8_32[8][8];
 extern const uint8_t dither_8x8_73[8][8];
 extern const uint8_t dither_8x8_220[8][8];
@@ -49,7 +51,7 @@
     {117579, 136230, 16907, 35559}  /* SMPTE 240M (1987) */
 };
 
-const int * sws_getCoefficients(int colorspace)
+const int *sws_getCoefficients(int colorspace)
 {
     if (colorspace > 7 || colorspace < 0)
         colorspace = SWS_CS_DEFAULT;
@@ -351,6 +353,32 @@
 #endif
 
 // r, g, b, dst_1, dst_2
+YUV2RGBFUNC(yuv2rgb_c_12_ordered_dither, uint16_t, 0)
+    const uint8_t *d16 = dither_4x4_16[y&3];
+#define PUTRGB12(dst,src,i,o)                                   \
+    Y = src[2*i];                                               \
+    dst[2*i]   = r[Y+d16[0+o]] + g[Y+d16[0+o]] + b[Y+d16[0+o]]; \
+    Y = src[2*i+1];                                             \
+    dst[2*i+1] = r[Y+d16[1+o]] + g[Y+d16[1+o]] + b[Y+d16[1+o]];
+
+    LOADCHROMA(0);
+    PUTRGB12(dst_1,py_1,0,0);
+    PUTRGB12(dst_2,py_2,0,0+8);
+
+    LOADCHROMA(1);
+    PUTRGB12(dst_2,py_2,1,2+8);
+    PUTRGB12(dst_1,py_1,1,2);
+
+    LOADCHROMA(2);
+    PUTRGB12(dst_1,py_1,2,4);
+    PUTRGB12(dst_2,py_2,2,4+8);
+
+    LOADCHROMA(3);
+    PUTRGB12(dst_2,py_2,3,6+8);
+    PUTRGB12(dst_1,py_1,3,6);
+CLOSEYUV2RGBFUNC(8)
+
+// r, g, b, dst_1, dst_2
 YUV2RGBFUNC(yuv2rgb_c_8_ordered_dither, uint8_t, 0)
     const uint8_t *d32 = dither_8x8_32[y&7];
     const uint8_t *d64 = dither_8x8_73[y&7];
@@ -515,7 +543,7 @@
 SwsFunc ff_yuv2rgb_get_func_ptr(SwsContext *c)
 {
     SwsFunc t = NULL;
-#if (HAVE_MMX2 || HAVE_MMX) && CONFIG_GPL
+#if HAVE_MMX
      t = ff_yuv2rgb_init_mmx(c);
 #endif
 #if HAVE_VIS
@@ -552,6 +580,8 @@
     case PIX_FMT_BGR565:
     case PIX_FMT_RGB555:
     case PIX_FMT_BGR555:     return yuv2rgb_c_16;
+    case PIX_FMT_RGB444:
+    case PIX_FMT_BGR444:     return yuv2rgb_c_12_ordered_dither;
     case PIX_FMT_RGB8:
     case PIX_FMT_BGR8:       return yuv2rgb_c_8_ordered_dither;
     case PIX_FMT_RGB4:
@@ -590,18 +620,36 @@
     }
 }
 
+static uint16_t roundToInt16(int64_t f)
+{
+    int r= (f + (1<<15))>>16;
+         if (r<-0x7FFF) return 0x8000;
+    else if (r> 0x7FFF) return 0x7FFF;
+    else                return r;
+}
+
 av_cold int ff_yuv2rgb_c_init_tables(SwsContext *c, const int inv_table[4], int fullRange,
                                      int brightness, int contrast, int saturation)
 {
     const int isRgb =      c->dstFormat==PIX_FMT_RGB32
                         || c->dstFormat==PIX_FMT_RGB32_1
                         || c->dstFormat==PIX_FMT_BGR24
-                        || c->dstFormat==PIX_FMT_RGB565
-                        || c->dstFormat==PIX_FMT_RGB555
+                        || c->dstFormat==PIX_FMT_RGB565BE
+                        || c->dstFormat==PIX_FMT_RGB565LE
+                        || c->dstFormat==PIX_FMT_RGB555BE
+                        || c->dstFormat==PIX_FMT_RGB555LE
+                        || c->dstFormat==PIX_FMT_RGB444BE
+                        || c->dstFormat==PIX_FMT_RGB444LE
                         || c->dstFormat==PIX_FMT_RGB8
                         || c->dstFormat==PIX_FMT_RGB4
                         || c->dstFormat==PIX_FMT_RGB4_BYTE
                         || c->dstFormat==PIX_FMT_MONOBLACK;
+    const int isNotNe =    c->dstFormat==PIX_FMT_NE(RGB565LE,RGB565BE)
+                        || c->dstFormat==PIX_FMT_NE(RGB555LE,RGB555BE)
+                        || c->dstFormat==PIX_FMT_NE(RGB444LE,RGB444BE)
+                        || c->dstFormat==PIX_FMT_NE(BGR565LE,BGR565BE)
+                        || c->dstFormat==PIX_FMT_NE(BGR555LE,BGR555BE)
+                        || c->dstFormat==PIX_FMT_NE(BGR444LE,BGR444BE);
     const int bpp = c->dstFormatBpp;
     uint8_t *y_table;
     uint16_t *y_table16;
@@ -635,6 +683,22 @@
     cgv = (cgv*contrast * saturation) >> 32;
     oy -= 256*brightness;
 
+    c->uOffset=   0x0400040004000400LL;
+    c->vOffset=   0x0400040004000400LL;
+    c->yCoeff=    roundToInt16(cy *8192) * 0x0001000100010001ULL;
+    c->vrCoeff=   roundToInt16(crv*8192) * 0x0001000100010001ULL;
+    c->ubCoeff=   roundToInt16(cbu*8192) * 0x0001000100010001ULL;
+    c->vgCoeff=   roundToInt16(cgv*8192) * 0x0001000100010001ULL;
+    c->ugCoeff=   roundToInt16(cgu*8192) * 0x0001000100010001ULL;
+    c->yOffset=   roundToInt16(oy *   8) * 0x0001000100010001ULL;
+
+    c->yuv2rgb_y_coeff  = (int16_t)roundToInt16(cy <<13);
+    c->yuv2rgb_y_offset = (int16_t)roundToInt16(oy << 9);
+    c->yuv2rgb_v2r_coeff= (int16_t)roundToInt16(crv<<13);
+    c->yuv2rgb_v2g_coeff= (int16_t)roundToInt16(cgv<<13);
+    c->yuv2rgb_u2g_coeff= (int16_t)roundToInt16(cgu<<13);
+    c->yuv2rgb_u2b_coeff= (int16_t)roundToInt16(cbu<<13);
+
     //scale coefficients by cy
     crv = ((crv << 16) + 0x8000) / cy;
     cbu = ((cbu << 16) + 0x8000) / cy;
@@ -694,6 +758,28 @@
         fill_table(c->table_bU, 1, cbu, y_table + yoffs + 2048);
         fill_gv_table(c->table_gV, 1, cgv);
         break;
+    case 12:
+        rbase = isRgb ? 8 : 0;
+        gbase = 4;
+        bbase = isRgb ? 0 : 8;
+        c->yuvTable = av_malloc(1024*3*2);
+        y_table16 = c->yuvTable;
+        yb = -(384<<16) - oy;
+        for (i = 0; i < 1024; i++) {
+            uint8_t yval = av_clip_uint8((yb + 0x8000) >> 16);
+            y_table16[i     ] = (yval >> 4) << rbase;
+            y_table16[i+1024] = (yval >> 4) << gbase;
+            y_table16[i+2048] = (yval >> 4) << bbase;
+            yb += cy;
+        }
+        if (isNotNe)
+            for (i = 0; i < 1024*3; i++)
+                y_table16[i] = bswap_16(y_table16[i]);
+        fill_table(c->table_rV, 2, crv, y_table16 + yoffs);
+        fill_table(c->table_gU, 2, cgu, y_table16 + yoffs + 1024);
+        fill_table(c->table_bU, 2, cbu, y_table16 + yoffs + 2048);
+        fill_gv_table(c->table_gV, 2, cgv);
+        break;
     case 15:
     case 16:
         rbase = isRgb ? bpp - 5 : 0;
@@ -709,6 +795,9 @@
             y_table16[i+2048] = (yval >> 3)          << bbase;
             yb += cy;
         }
+        if(isNotNe)
+            for (i = 0; i < 1024*3; i++)
+                y_table16[i] = bswap_16(y_table16[i]);
         fill_table(c->table_rV, 2, crv, y_table16 + yoffs);
         fill_table(c->table_gU, 2, cgu, y_table16 + yoffs + 1024);
         fill_table(c->table_bU, 2, cbu, y_table16 + yoffs + 2048);



From mean at mail.berlios.de  Sun Jul 25 12:07:52 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 25 Jul 2010 12:07:52 +0200
Subject: [Avidemux-svn-commit] r6483 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:
	libavcodec libavcodec/x86 patches patches/avcodec
Message-ID: <20100725100753.10E51480E6C@sheep.berlios.de>

Author: mean
Date: 2010-07-25 12:07:52 +0200 (Sun, 25 Jul 2010)
New Revision: 6483

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacpsdata.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ansi.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/gsmdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/inverse.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pictordec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144dec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144enc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/fft.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h263dec.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h264dsp.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12enc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo_enc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/png.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngdec.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/utils.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/x86_mathops.h.patch
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac.c
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/png.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
Log:
[ffmpeg] update 25 july avcodec

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2010-07-25 10:07:52 UTC (rev 6483)
@@ -26,7 +26,7 @@
         dca.c
         ac3enc.c  ac3.c  ac3tab.c   ac3_parser.c
         eac3dec.c ac3dec.c ac3dec_data.c eac3dec_data.c
-        aacenc.c aaccoder.c aac.c aactab.c psymodel.c aacpsy.c iirfilter.c
+        aacenc.c aaccoder.c  aactab.c psymodel.c aacpsy.c iirfilter.c
 	dvbsub_parser.c  dvbsubdec.c  dvbsub.c  xiph.c  sp5xdec.c  
         nellymoserdec.c nellymoser.c
 	ADM_lavcodec.cpp  pthread.c  huffman.c  wmv2dec.c  wmv2.c  h264pred.c  intrax8.c
@@ -37,6 +37,7 @@
         ivi_common.c dcadsp.c h264_direct.c ivi_dsp.c ituh263dec.c dvdata.c ituh263enc.c aacsbr.c
         synth_filter.c    mpeg4videodec.c h264_cabac.c h264_cavlc.c vp56dsp.c h264_loopfilter.c
         h264_sei.c h264_ps.c svq3.c h264dsp.c flvdec.c
+        aacps.c  aacpsy.c aacadtsdec.c lpc.c vp8_parser.c vp8.c vp8dsp.c inverse.c dct.c aacdec.c
         )
 
 if(USE_VDPAU)
@@ -51,12 +52,20 @@
                 x86/idct_sse2_xvid.c 
                 x86/vp6dsp_mmx.c
                 x86/vp6dsp_sse2.c
+                x86/vp8dsp-init.c
+                x86/mpegaudiodec_mmx.c
+                x86/lpc_mmx.c
+                x86/fft.c
+                x86/dct32_sse.c
                 #x86/fft_sse.c
                 #x86/fft_3dn2.c
 		#x86/fft_3dn.c  
                 x86/dsputilenc_mmx.c  x86/vc1dsp_mmx.c  x86/idct_mmx.c)
         IF(USE_YASM)
-                SET(YASM_SOURCE
+                SET(YASM_SOURCE         
+                                x86/h264_intrapred.asm
+                                x86/vp8dsp.asm
+                                x86/vc1dsp_yasm.asm
                                 x86/dsputil_yasm.asm
                                 x86/fft_mmx.asm
                                 x86/h264_deblock_sse2.asm

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -1,2108 +0,0 @@
-/*
- * AAC decoder
- * Copyright (c) 2005-2006 Oded Shimon ( ods15 ods15 dyndns org )
- * Copyright (c) 2006-2007 Maxim Gavrilov ( maxim.gavrilov gmail com )
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * AAC decoder
- * @author Oded Shimon  ( ods15 ods15 dyndns org )
- * @author Maxim Gavrilov ( maxim.gavrilov gmail com )
- */
-
-/*
- * supported tools
- *
- * Support?             Name
- * N (code in SoC repo) gain control
- * Y                    block switching
- * Y                    window shapes - standard
- * N                    window shapes - Low Delay
- * Y                    filterbank - standard
- * N (code in SoC repo) filterbank - Scalable Sample Rate
- * Y                    Temporal Noise Shaping
- * N (code in SoC repo) Long Term Prediction
- * Y                    intensity stereo
- * Y                    channel coupling
- * Y                    frequency domain prediction
- * Y                    Perceptual Noise Substitution
- * Y                    Mid/Side stereo
- * N                    Scalable Inverse AAC Quantization
- * N                    Frequency Selective Switch
- * N                    upsampling filter
- * Y                    quantization & coding - AAC
- * N                    quantization & coding - TwinVQ
- * N                    quantization & coding - BSAC
- * N                    AAC Error Resilience tools
- * N                    Error Resilience payload syntax
- * N                    Error Protection tool
- * N                    CELP
- * N                    Silence Compression
- * N                    HVXC
- * N                    HVXC 4kbits/s VR
- * N                    Structured Audio tools
- * N                    Structured Audio Sample Bank Format
- * N                    MIDI
- * N                    Harmonic and Individual Lines plus Noise
- * N                    Text-To-Speech Interface
- * Y                    Spectral Band Replication
- * Y (not in this code) Layer-1
- * Y (not in this code) Layer-2
- * Y (not in this code) Layer-3
- * N                    SinuSoidal Coding (Transient, Sinusoid, Noise)
- * N (planned)          Parametric Stereo
- * N                    Direct Stream Transfer
- *
- * Note: - HE AAC v1 comprises LC AAC with Spectral Band Replication.
- *       - HE AAC v2 comprises LC AAC with Spectral Band Replication and
-           Parametric Stereo.
- */
-
-
-#include "avcodec.h"
-#include "internal.h"
-#include "get_bits.h"
-#include "dsputil.h"
-#include "fft.h"
-#include "lpc.h"
-
-#include "aac.h"
-#include "aactab.h"
-#include "aacdectab.h"
-#include "cbrt_tablegen.h"
-#include "sbr.h"
-#include "aacsbr.h"
-#include "mpeg4audio.h"
-#include "aac_parser.h"
-
-#include <assert.h>
-#include <errno.h>
-#include <math.h>
-#include <string.h>
-
-#if ARCH_ARM
-#   include "arm/aac.h"
-#endif
-
-union float754 {
-    float f;
-    uint32_t i;
-};
-
-static VLC vlc_scalefactors;
-static VLC vlc_spectral[11];
-
-static const char overread_err[] = "Input buffer exhausted before END element found\n";
-
-static ChannelElement *get_che(AACContext *ac, int type, int elem_id)
-{
-    if (ac->tag_che_map[type][elem_id]) {
-        return ac->tag_che_map[type][elem_id];
-    }
-    if (ac->tags_mapped >= tags_per_config[ac->m4ac.chan_config]) {
-        return NULL;
-    }
-    switch (ac->m4ac.chan_config) {
-    case 7:
-        if (ac->tags_mapped == 3 && type == TYPE_CPE) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][2];
-        }
-    case 6:
-        /* Some streams incorrectly code 5.1 audio as SCE[0] CPE[0] CPE[1] SCE[1]
-           instead of SCE[0] CPE[0] CPE[0] LFE[0]. If we seem to have
-           encountered such a stream, transfer the LFE[0] element to SCE[1] */
-        if (ac->tags_mapped == tags_per_config[ac->m4ac.chan_config] - 1 && (type == TYPE_LFE || type == TYPE_SCE)) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[type][elem_id] = ac->che[TYPE_LFE][0];
-        }
-    case 5:
-        if (ac->tags_mapped == 2 && type == TYPE_CPE) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][1];
-        }
-    case 4:
-        if (ac->tags_mapped == 2 && ac->m4ac.chan_config == 4 && type == TYPE_SCE) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[TYPE_SCE][elem_id] = ac->che[TYPE_SCE][1];
-        }
-    case 3:
-    case 2:
-        if (ac->tags_mapped == (ac->m4ac.chan_config != 2) && type == TYPE_CPE) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][0];
-        } else if (ac->m4ac.chan_config == 2) {
-            return NULL;
-        }
-    case 1:
-        if (!ac->tags_mapped && type == TYPE_SCE) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[TYPE_SCE][elem_id] = ac->che[TYPE_SCE][0];
-        }
-    default:
-        return NULL;
-    }
-}
-
-/**
- * Check for the channel element in the current channel position configuration.
- * If it exists, make sure the appropriate element is allocated and map the
- * channel order to match the internal FFmpeg channel layout.
- *
- * @param   che_pos current channel position configuration
- * @param   type channel element type
- * @param   id channel element id
- * @param   channels count of the number of channels in the configuration
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static av_cold int che_configure(AACContext *ac,
-                         enum ChannelPosition che_pos[4][MAX_ELEM_ID],
-                         int type, int id,
-                         int *channels)
-{
-    if (che_pos[type][id]) {
-        if (!ac->che[type][id] && !(ac->che[type][id] = av_mallocz(sizeof(ChannelElement))))
-            return AVERROR(ENOMEM);
-        ff_aac_sbr_ctx_init(&ac->che[type][id]->sbr);
-        if (type != TYPE_CCE) {
-            ac->output_data[(*channels)++] = ac->che[type][id]->ch[0].ret;
-            if (type == TYPE_CPE) {
-                ac->output_data[(*channels)++] = ac->che[type][id]->ch[1].ret;
-            }
-        }
-    } else {
-        if (ac->che[type][id])
-            ff_aac_sbr_ctx_close(&ac->che[type][id]->sbr);
-        av_freep(&ac->che[type][id]);
-    }
-    return 0;
-}
-
-/**
- * Configure output channel order based on the current program configuration element.
- *
- * @param   che_pos current channel position configuration
- * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static av_cold int output_configure(AACContext *ac,
-                            enum ChannelPosition che_pos[4][MAX_ELEM_ID],
-                            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
-                            int channel_config, enum OCStatus oc_type)
-{
-    AVCodecContext *avctx = ac->avccontext;
-    int i, type, channels = 0, ret;
-
-    memcpy(che_pos, new_che_pos, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-
-    if (channel_config) {
-        for (i = 0; i < tags_per_config[channel_config]; i++) {
-            if ((ret = che_configure(ac, che_pos,
-                                     aac_channel_layout_map[channel_config - 1][i][0],
-                                     aac_channel_layout_map[channel_config - 1][i][1],
-                                     &channels)))
-                return ret;
-        }
-
-        memset(ac->tag_che_map, 0,       4 * MAX_ELEM_ID * sizeof(ac->che[0][0]));
-        ac->tags_mapped = 0;
-
-        avctx->channel_layout = aac_channel_layout[channel_config - 1];
-    } else {
-        /* Allocate or free elements depending on if they are in the
-         * current program configuration.
-         *
-         * Set up default 1:1 output mapping.
-         *
-         * For a 5.1 stream the output order will be:
-         *    [ Center ] [ Front Left ] [ Front Right ] [ LFE ] [ Surround Left ] [ Surround Right ]
-         */
-
-        for (i = 0; i < MAX_ELEM_ID; i++) {
-            for (type = 0; type < 4; type++) {
-                if ((ret = che_configure(ac, che_pos, type, i, &channels)))
-                    return ret;
-            }
-        }
-
-        memcpy(ac->tag_che_map, ac->che, 4 * MAX_ELEM_ID * sizeof(ac->che[0][0]));
-        ac->tags_mapped = 4 * MAX_ELEM_ID;
-
-        avctx->channel_layout = 0;
-    }
-
-    avctx->channels = channels;
-
-    ac->output_configured = oc_type;
-
-    return 0;
-}
-
-/**
- * Decode an array of 4 bit element IDs, optionally interleaved with a stereo/mono switching bit.
- *
- * @param cpe_map Stereo (Channel Pair Element) map, NULL if stereo bit is not present.
- * @param sce_map mono (Single Channel Element) map
- * @param type speaker type/position for these channels
- */
-static void decode_channel_map(enum ChannelPosition *cpe_map,
-                               enum ChannelPosition *sce_map,
-                               enum ChannelPosition type,
-                               GetBitContext *gb, int n)
-{
-    while (n--) {
-        enum ChannelPosition *map = cpe_map && get_bits1(gb) ? cpe_map : sce_map; // stereo or mono map
-        map[get_bits(gb, 4)] = type;
-    }
-}
-
-/**
- * Decode program configuration element; reference: table 4.2.
- *
- * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_pce(AACContext *ac, enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
-                      GetBitContext *gb)
-{
-    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;
-    int comment_len;
-
-    skip_bits(gb, 2);  // object_type
-
-    sampling_index = get_bits(gb, 4);
-    if (ac->m4ac.sampling_index != sampling_index)
-        av_log(ac->avccontext, AV_LOG_WARNING, "Sample rate index in program config element does not match the sample rate index configured by the container.\n");
-
-    num_front       = get_bits(gb, 4);
-    num_side        = get_bits(gb, 4);
-    num_back        = get_bits(gb, 4);
-    num_lfe         = get_bits(gb, 2);
-    num_assoc_data  = get_bits(gb, 3);
-    num_cc          = get_bits(gb, 4);
-
-    if (get_bits1(gb))
-        skip_bits(gb, 4); // mono_mixdown_tag
-    if (get_bits1(gb))
-        skip_bits(gb, 4); // stereo_mixdown_tag
-
-    if (get_bits1(gb))
-        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround
-
-    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);
-    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );
-    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );
-    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );
-
-    skip_bits_long(gb, 4 * num_assoc_data);
-
-    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );
-
-    align_get_bits(gb);
-
-    /* comment field, first byte is length */
-    comment_len = get_bits(gb, 8) * 8;
-    if (get_bits_left(gb) < comment_len) {
-        av_log(ac->avccontext, AV_LOG_ERROR, overread_err);
-        return -1;
-    }
-    skip_bits_long(gb, comment_len);
-    return 0;
-}
-
-/**
- * Set up channel positions based on a default channel configuration
- * as specified in table 1.17.
- *
- * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static av_cold int set_default_channel_config(AACContext *ac,
-                                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
-                                      int channel_config)
-{
-    if (channel_config < 1 || channel_config > 7) {
-        av_log(ac->avccontext, AV_LOG_ERROR, "invalid default channel configuration (%d)\n",
-               channel_config);
-        return -1;
-    }
-
-    /* default channel configurations:
-     *
-     * 1ch : front center (mono)
-     * 2ch : L + R (stereo)
-     * 3ch : front center + L + R
-     * 4ch : front center + L + R + back center
-     * 5ch : front center + L + R + back stereo
-     * 6ch : front center + L + R + back stereo + LFE
-     * 7ch : front center + L + R + outer front left + outer front right + back stereo + LFE
-     */
-
-    if (channel_config != 2)
-        new_che_pos[TYPE_SCE][0] = AAC_CHANNEL_FRONT; // front center (or mono)
-    if (channel_config > 1)
-        new_che_pos[TYPE_CPE][0] = AAC_CHANNEL_FRONT; // L + R (or stereo)
-    if (channel_config == 4)
-        new_che_pos[TYPE_SCE][1] = AAC_CHANNEL_BACK;  // back center
-    if (channel_config > 4)
-        new_che_pos[TYPE_CPE][(channel_config == 7) + 1]
-        = AAC_CHANNEL_BACK;  // back stereo
-    if (channel_config > 5)
-        new_che_pos[TYPE_LFE][0] = AAC_CHANNEL_LFE;   // LFE
-    if (channel_config == 7)
-        new_che_pos[TYPE_CPE][1] = AAC_CHANNEL_FRONT; // outer front left + outer front right
-
-    return 0;
-}
-
-/**
- * Decode GA "General Audio" specific configuration; reference: table 4.1.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_ga_specific_config(AACContext *ac, GetBitContext *gb,
-                                     int channel_config)
-{
-    enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
-    int extension_flag, ret;
-
-    if (get_bits1(gb)) { // frameLengthFlag
-        av_log_missing_feature(ac->avccontext, "960/120 MDCT window is", 1);
-        return -1;
-    }
-
-    if (get_bits1(gb))       // dependsOnCoreCoder
-        skip_bits(gb, 14);   // coreCoderDelay
-    extension_flag = get_bits1(gb);
-
-    if (ac->m4ac.object_type == AOT_AAC_SCALABLE ||
-        ac->m4ac.object_type == AOT_ER_AAC_SCALABLE)
-        skip_bits(gb, 3);     // layerNr
-
-    memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-    if (channel_config == 0) {
-        skip_bits(gb, 4);  // element_instance_tag
-        if ((ret = decode_pce(ac, new_che_pos, gb)))
-            return ret;
-    } else {
-        if ((ret = set_default_channel_config(ac, new_che_pos, channel_config)))
-            return ret;
-    }
-    if ((ret = output_configure(ac, ac->che_pos, new_che_pos, channel_config, OC_GLOBAL_HDR)))
-        return ret;
-
-    if (extension_flag) {
-        switch (ac->m4ac.object_type) {
-        case AOT_ER_BSAC:
-            skip_bits(gb, 5);    // numOfSubFrame
-            skip_bits(gb, 11);   // layer_length
-            break;
-        case AOT_ER_AAC_LC:
-        case AOT_ER_AAC_LTP:
-        case AOT_ER_AAC_SCALABLE:
-        case AOT_ER_AAC_LD:
-            skip_bits(gb, 3);  /* aacSectionDataResilienceFlag
-                                    * aacScalefactorDataResilienceFlag
-                                    * aacSpectralDataResilienceFlag
-                                    */
-            break;
-        }
-        skip_bits1(gb);    // extensionFlag3 (TBD in version 3)
-    }
-    return 0;
-}
-
-/**
- * Decode audio specific configuration; reference: table 1.13.
- *
- * @param   data        pointer to AVCodecContext extradata
- * @param   data_size   size of AVCCodecContext extradata
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_audio_specific_config(AACContext *ac, void *data,
-                                        int data_size)
-{
-    GetBitContext gb;
-    int i;
-
-    init_get_bits(&gb, data, data_size * 8);
-
-    if ((i = ff_mpeg4audio_get_config(&ac->m4ac, data, data_size)) < 0)
-        return -1;
-    if (ac->m4ac.sampling_index > 12) {
-        av_log(ac->avccontext, AV_LOG_ERROR, "invalid sampling rate index %d\n", ac->m4ac.sampling_index);
-        return -1;
-    }
-
-    skip_bits_long(&gb, i);
-
-    switch (ac->m4ac.object_type) {
-    case AOT_AAC_MAIN:
-    case AOT_AAC_LC:
-        if (decode_ga_specific_config(ac, &gb, ac->m4ac.chan_config))
-            return -1;
-        break;
-    default:
-        av_log(ac->avccontext, AV_LOG_ERROR, "Audio object type %s%d is not supported.\n",
-               ac->m4ac.sbr == 1? "SBR+" : "", ac->m4ac.object_type);
-        return -1;
-    }
-    return 0;
-}
-
-/**
- * linear congruential pseudorandom number generator
- *
- * @param   previous_val    pointer to the current state of the generator
- *
- * @return  Returns a 32-bit pseudorandom integer
- */
-static av_always_inline int lcg_random(int previous_val)
-{
-    return previous_val * 1664525 + 1013904223;
-}
-
-static av_always_inline void reset_predict_state(PredictorState *ps)
-{
-    ps->r0   = 0.0f;
-    ps->r1   = 0.0f;
-    ps->cor0 = 0.0f;
-    ps->cor1 = 0.0f;
-    ps->var0 = 1.0f;
-    ps->var1 = 1.0f;
-}
-
-static void reset_all_predictors(PredictorState *ps)
-{
-    int i;
-    for (i = 0; i < MAX_PREDICTORS; i++)
-        reset_predict_state(&ps[i]);
-}
-
-static void reset_predictor_group(PredictorState *ps, int group_num)
-{
-    int i;
-    for (i = group_num - 1; i < MAX_PREDICTORS; i += 30)
-        reset_predict_state(&ps[i]);
-}
-
-static av_cold int aac_decode_init(AVCodecContext *avccontext)
-{
-    AACContext *ac = avccontext->priv_data;
-    int i;
-
-    ac->avccontext = avccontext;
-    ac->m4ac.sample_rate = avccontext->sample_rate;
-
-    if (avccontext->extradata_size > 0) {
-        if (decode_audio_specific_config(ac, avccontext->extradata, avccontext->extradata_size))
-            return -1;
-    }
-
-    avccontext->sample_fmt = SAMPLE_FMT_S16;
-
-    AAC_INIT_VLC_STATIC( 0, 304);
-    AAC_INIT_VLC_STATIC( 1, 270);
-    AAC_INIT_VLC_STATIC( 2, 550);
-    AAC_INIT_VLC_STATIC( 3, 300);
-    AAC_INIT_VLC_STATIC( 4, 328);
-    AAC_INIT_VLC_STATIC( 5, 294);
-    AAC_INIT_VLC_STATIC( 6, 306);
-    AAC_INIT_VLC_STATIC( 7, 268);
-    AAC_INIT_VLC_STATIC( 8, 510);
-    AAC_INIT_VLC_STATIC( 9, 366);
-    AAC_INIT_VLC_STATIC(10, 462);
-
-    ff_aac_sbr_init();
-
-    dsputil_init(&ac->dsp, avccontext);
-
-    ac->random_state = 0x1f2e3d4c;
-
-    // -1024 - Compensate wrong IMDCT method.
-    // 32768 - Required to scale values to the correct range for the bias method
-    //         for float to int16 conversion.
-
-    if (ac->dsp.float_to_int16_interleave == ff_float_to_int16_interleave_c) {
-        ac->add_bias  = 385.0f;
-        ac->sf_scale  = 1. / (-1024. * 32768.);
-        ac->sf_offset = 0;
-    } else {
-        ac->add_bias  = 0.0f;
-        ac->sf_scale  = 1. / -1024.;
-        ac->sf_offset = 60;
-    }
-
-#if !CONFIG_HARDCODED_TABLES
-    for (i = 0; i < 428; i++)
-        ff_aac_pow2sf_tab[i] = pow(2, (i - 200) / 4.);
-#endif /* CONFIG_HARDCODED_TABLES */
-
-    INIT_VLC_STATIC(&vlc_scalefactors,7,FF_ARRAY_ELEMS(ff_aac_scalefactor_code),
-                    ff_aac_scalefactor_bits, sizeof(ff_aac_scalefactor_bits[0]), sizeof(ff_aac_scalefactor_bits[0]),
-                    ff_aac_scalefactor_code, sizeof(ff_aac_scalefactor_code[0]), sizeof(ff_aac_scalefactor_code[0]),
-                    352);
-
-    ff_mdct_init(&ac->mdct, 11, 1, 1.0);
-    ff_mdct_init(&ac->mdct_small, 8, 1, 1.0);
-    // window initialization
-    ff_kbd_window_init(ff_aac_kbd_long_1024, 4.0, 1024);
-    ff_kbd_window_init(ff_aac_kbd_short_128, 6.0, 128);
-    ff_init_ff_sine_windows(10);
-    ff_init_ff_sine_windows( 7);
-
-    cbrt_tableinit();
-
-    return 0;
-}
-
-/**
- * Skip data_stream_element; reference: table 4.10.
- */
-static int skip_data_stream_element(AACContext *ac, GetBitContext *gb)
-{
-    int byte_align = get_bits1(gb);
-    int count = get_bits(gb, 8);
-    if (count == 255)
-        count += get_bits(gb, 8);
-    if (byte_align)
-        align_get_bits(gb);
-
-    if (get_bits_left(gb) < 8 * count) {
-        av_log(ac->avccontext, AV_LOG_ERROR, overread_err);
-        return -1;
-    }
-    skip_bits_long(gb, 8 * count);
-    return 0;
-}
-
-static int decode_prediction(AACContext *ac, IndividualChannelStream *ics,
-                             GetBitContext *gb)
-{
-    int sfb;
-    if (get_bits1(gb)) {
-        ics->predictor_reset_group = get_bits(gb, 5);
-        if (ics->predictor_reset_group == 0 || ics->predictor_reset_group > 30) {
-            av_log(ac->avccontext, AV_LOG_ERROR, "Invalid Predictor Reset Group.\n");
-            return -1;
-        }
-    }
-    for (sfb = 0; sfb < FFMIN(ics->max_sfb, ff_aac_pred_sfb_max[ac->m4ac.sampling_index]); sfb++) {
-        ics->prediction_used[sfb] = get_bits1(gb);
-    }
-    return 0;
-}
-
-/**
- * Decode Individual Channel Stream info; reference: table 4.6.
- *
- * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
- */
-static int decode_ics_info(AACContext *ac, IndividualChannelStream *ics,
-                           GetBitContext *gb, int common_window)
-{
-    if (get_bits1(gb)) {
-        av_log(ac->avccontext, AV_LOG_ERROR, "Reserved bit set.\n");
-        memset(ics, 0, sizeof(IndividualChannelStream));
-        return -1;
-    }
-    ics->window_sequence[1] = ics->window_sequence[0];
-    ics->window_sequence[0] = get_bits(gb, 2);
-    ics->use_kb_window[1]   = ics->use_kb_window[0];
-    ics->use_kb_window[0]   = get_bits1(gb);
-    ics->num_window_groups  = 1;
-    ics->group_len[0]       = 1;
-    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-        int i;
-        ics->max_sfb = get_bits(gb, 4);
-        for (i = 0; i < 7; i++) {
-            if (get_bits1(gb)) {
-                ics->group_len[ics->num_window_groups - 1]++;
-            } else {
-                ics->num_window_groups++;
-                ics->group_len[ics->num_window_groups - 1] = 1;
-            }
-        }
-        ics->num_windows       = 8;
-        ics->swb_offset        =    ff_swb_offset_128[ac->m4ac.sampling_index];
-        ics->num_swb           =   ff_aac_num_swb_128[ac->m4ac.sampling_index];
-        ics->tns_max_bands     = ff_tns_max_bands_128[ac->m4ac.sampling_index];
-        ics->predictor_present = 0;
-    } else {
-        ics->max_sfb               = get_bits(gb, 6);
-        ics->num_windows           = 1;
-        ics->swb_offset            =    ff_swb_offset_1024[ac->m4ac.sampling_index];
-        ics->num_swb               =   ff_aac_num_swb_1024[ac->m4ac.sampling_index];
-        ics->tns_max_bands         = ff_tns_max_bands_1024[ac->m4ac.sampling_index];
-        ics->predictor_present     = get_bits1(gb);
-        ics->predictor_reset_group = 0;
-        if (ics->predictor_present) {
-            if (ac->m4ac.object_type == AOT_AAC_MAIN) {
-                if (decode_prediction(ac, ics, gb)) {
-                    memset(ics, 0, sizeof(IndividualChannelStream));
-                    return -1;
-                }
-            } else if (ac->m4ac.object_type == AOT_AAC_LC) {
-                av_log(ac->avccontext, AV_LOG_ERROR, "Prediction is not allowed in AAC-LC.\n");
-                memset(ics, 0, sizeof(IndividualChannelStream));
-                return -1;
-            } else {
-                av_log_missing_feature(ac->avccontext, "Predictor bit set but LTP is", 1);
-                memset(ics, 0, sizeof(IndividualChannelStream));
-                return -1;
-            }
-        }
-    }
-
-    if (ics->max_sfb > ics->num_swb) {
-        av_log(ac->avccontext, AV_LOG_ERROR,
-               "Number of scalefactor bands in group (%d) exceeds limit (%d).\n",
-               ics->max_sfb, ics->num_swb);
-        memset(ics, 0, sizeof(IndividualChannelStream));
-        return -1;
-    }
-
-    return 0;
-}
-
-/**
- * Decode band types (section_data payload); reference: table 4.46.
- *
- * @param   band_type           array of the used band type
- * @param   band_type_run_end   array of the last scalefactor band of a band type run
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_band_types(AACContext *ac, enum BandType band_type[120],
-                             int band_type_run_end[120], GetBitContext *gb,
-                             IndividualChannelStream *ics)
-{
-    int g, idx = 0;
-    const int bits = (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;
-    for (g = 0; g < ics->num_window_groups; g++) {
-        int k = 0;
-        while (k < ics->max_sfb) {
-            uint8_t sect_end = k;
-            int sect_len_incr;
-            int sect_band_type = get_bits(gb, 4);
-            if (sect_band_type == 12) {
-                av_log(ac->avccontext, AV_LOG_ERROR, "invalid band type\n");
-                return -1;
-            }
-            while ((sect_len_incr = get_bits(gb, bits)) == (1 << bits) - 1)
-                sect_end += sect_len_incr;
-            sect_end += sect_len_incr;
-            if (get_bits_left(gb) < 0) {
-                av_log(ac->avccontext, AV_LOG_ERROR, overread_err);
-                return -1;
-            }
-            if (sect_end > ics->max_sfb) {
-                av_log(ac->avccontext, AV_LOG_ERROR,
-                       "Number of bands (%d) exceeds limit (%d).\n",
-                       sect_end, ics->max_sfb);
-                return -1;
-            }
-            for (; k < sect_end; k++) {
-                band_type        [idx]   = sect_band_type;
-                band_type_run_end[idx++] = sect_end;
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Decode scalefactors; reference: table 4.47.
- *
- * @param   global_gain         first scalefactor value as scalefactors are differentially coded
- * @param   band_type           array of the used band type
- * @param   band_type_run_end   array of the last scalefactor band of a band type run
- * @param   sf                  array of scalefactors or intensity stereo positions
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_scalefactors(AACContext *ac, float sf[120], GetBitContext *gb,
-                               unsigned int global_gain,
-                               IndividualChannelStream *ics,
-                               enum BandType band_type[120],
-                               int band_type_run_end[120])
-{
-    const int sf_offset = ac->sf_offset + (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE ? 12 : 0);
-    int g, i, idx = 0;
-    int offset[3] = { global_gain, global_gain - 90, 100 };
-    int noise_flag = 1;
-    static const char *sf_str[3] = { "Global gain", "Noise gain", "Intensity stereo position" };
-    for (g = 0; g < ics->num_window_groups; g++) {
-        for (i = 0; i < ics->max_sfb;) {
-            int run_end = band_type_run_end[idx];
-            if (band_type[idx] == ZERO_BT) {
-                for (; i < run_end; i++, idx++)
-                    sf[idx] = 0.;
-            } else if ((band_type[idx] == INTENSITY_BT) || (band_type[idx] == INTENSITY_BT2)) {
-                for (; i < run_end; i++, idx++) {
-                    offset[2] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                    if (offset[2] > 255U) {
-                        av_log(ac->avccontext, AV_LOG_ERROR,
-                               "%s (%d) out of range.\n", sf_str[2], offset[2]);
-                        return -1;
-                    }
-                    sf[idx] = ff_aac_pow2sf_tab[-offset[2] + 300];
-                }
-            } else if (band_type[idx] == NOISE_BT) {
-                for (; i < run_end; i++, idx++) {
-                    if (noise_flag-- > 0)
-                        offset[1] += get_bits(gb, 9) - 256;
-                    else
-                        offset[1] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                    if (offset[1] > 255U) {
-                        av_log(ac->avccontext, AV_LOG_ERROR,
-                               "%s (%d) out of range.\n", sf_str[1], offset[1]);
-                        return -1;
-                    }
-                    sf[idx] = -ff_aac_pow2sf_tab[offset[1] + sf_offset + 100];
-                }
-            } else {
-                for (; i < run_end; i++, idx++) {
-                    offset[0] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                    if (offset[0] > 255U) {
-                        av_log(ac->avccontext, AV_LOG_ERROR,
-                               "%s (%d) out of range.\n", sf_str[0], offset[0]);
-                        return -1;
-                    }
-                    sf[idx] = -ff_aac_pow2sf_tab[ offset[0] + sf_offset];
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Decode pulse data; reference: table 4.7.
- */
-static int decode_pulses(Pulse *pulse, GetBitContext *gb,
-                         const uint16_t *swb_offset, int num_swb)
-{
-    int i, pulse_swb;
-    pulse->num_pulse = get_bits(gb, 2) + 1;
-    pulse_swb        = get_bits(gb, 6);
-    if (pulse_swb >= num_swb)
-        return -1;
-    pulse->pos[0]    = swb_offset[pulse_swb];
-    pulse->pos[0]   += get_bits(gb, 5);
-    if (pulse->pos[0] > 1023)
-        return -1;
-    pulse->amp[0]    = get_bits(gb, 4);
-    for (i = 1; i < pulse->num_pulse; i++) {
-        pulse->pos[i] = get_bits(gb, 5) + pulse->pos[i - 1];
-        if (pulse->pos[i] > 1023)
-            return -1;
-        pulse->amp[i] = get_bits(gb, 4);
-    }
-    return 0;
-}
-
-/**
- * Decode Temporal Noise Shaping data; reference: table 4.48.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_tns(AACContext *ac, TemporalNoiseShaping *tns,
-                      GetBitContext *gb, const IndividualChannelStream *ics)
-{
-    int w, filt, i, coef_len, coef_res, coef_compress;
-    const int is8 = ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE;
-    const int tns_max_order = is8 ? 7 : ac->m4ac.object_type == AOT_AAC_MAIN ? 20 : 12;
-    for (w = 0; w < ics->num_windows; w++) {
-        if ((tns->n_filt[w] = get_bits(gb, 2 - is8))) {
-            coef_res = get_bits1(gb);
-
-            for (filt = 0; filt < tns->n_filt[w]; filt++) {
-                int tmp2_idx;
-                tns->length[w][filt] = get_bits(gb, 6 - 2 * is8);
-
-                if ((tns->order[w][filt] = get_bits(gb, 5 - 2 * is8)) > tns_max_order) {
-                    av_log(ac->avccontext, AV_LOG_ERROR, "TNS filter order %d is greater than maximum %d.\n",
-                           tns->order[w][filt], tns_max_order);
-                    tns->order[w][filt] = 0;
-                    return -1;
-                }
-                if (tns->order[w][filt]) {
-                    tns->direction[w][filt] = get_bits1(gb);
-                    coef_compress = get_bits1(gb);
-                    coef_len = coef_res + 3 - coef_compress;
-                    tmp2_idx = 2 * coef_compress + coef_res;
-
-                    for (i = 0; i < tns->order[w][filt]; i++)
-                        tns->coef[w][filt][i] = tns_tmp2_map[tmp2_idx][get_bits(gb, coef_len)];
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Decode Mid/Side data; reference: table 4.54.
- *
- * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
- *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
- *                      [3] reserved for scalable AAC
- */
-static void decode_mid_side_stereo(ChannelElement *cpe, GetBitContext *gb,
-                                   int ms_present)
-{
-    int idx;
-    if (ms_present == 1) {
-        for (idx = 0; idx < cpe->ch[0].ics.num_window_groups * cpe->ch[0].ics.max_sfb; idx++)
-            cpe->ms_mask[idx] = get_bits1(gb);
-    } else if (ms_present == 2) {
-        memset(cpe->ms_mask, 1, cpe->ch[0].ics.num_window_groups * cpe->ch[0].ics.max_sfb * sizeof(cpe->ms_mask[0]));
-    }
-}
-
-#ifndef VMUL2
-static inline float *VMUL2(float *dst, const float *v, unsigned idx,
-                           const float *scale)
-{
-    float s = *scale;
-    *dst++ = v[idx    & 15] * s;
-    *dst++ = v[idx>>4 & 15] * s;
-    return dst;
-}
-#endif
-
-#ifndef VMUL4
-static inline float *VMUL4(float *dst, const float *v, unsigned idx,
-                           const float *scale)
-{
-    float s = *scale;
-    *dst++ = v[idx    & 3] * s;
-    *dst++ = v[idx>>2 & 3] * s;
-    *dst++ = v[idx>>4 & 3] * s;
-    *dst++ = v[idx>>6 & 3] * s;
-    return dst;
-}
-#endif
-
-#ifndef VMUL2S
-static inline float *VMUL2S(float *dst, const float *v, unsigned idx,
-                            unsigned sign, const float *scale)
-{
-    union float754 s0, s1;
-
-    s0.f = s1.f = *scale;
-    s0.i ^= sign >> 1 << 31;
-    s1.i ^= sign      << 31;
-
-    *dst++ = v[idx    & 15] * s0.f;
-    *dst++ = v[idx>>4 & 15] * s1.f;
-
-    return dst;
-}
-#endif
-
-#ifndef VMUL4S
-static inline float *VMUL4S(float *dst, const float *v, unsigned idx,
-                            unsigned sign, const float *scale)
-{
-    unsigned nz = idx >> 12;
-    union float754 s = { .f = *scale };
-    union float754 t;
-
-    t.i = s.i ^ (sign & 1<<31);
-    *dst++ = v[idx    & 3] * t.f;
-
-    sign <<= nz & 1; nz >>= 1;
-    t.i = s.i ^ (sign & 1<<31);
-    *dst++ = v[idx>>2 & 3] * t.f;
-
-    sign <<= nz & 1; nz >>= 1;
-    t.i = s.i ^ (sign & 1<<31);
-    *dst++ = v[idx>>4 & 3] * t.f;
-
-    sign <<= nz & 1; nz >>= 1;
-    t.i = s.i ^ (sign & 1<<31);
-    *dst++ = v[idx>>6 & 3] * t.f;
-
-    return dst;
-}
-#endif
-
-/**
- * Decode spectral data; reference: table 4.50.
- * Dequantize and scale spectral data; reference: 4.6.3.3.
- *
- * @param   coef            array of dequantized, scaled spectral data
- * @param   sf              array of scalefactors or intensity stereo positions
- * @param   pulse_present   set if pulses are present
- * @param   pulse           pointer to pulse data struct
- * @param   band_type       array of the used band type
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_spectrum_and_dequant(AACContext *ac, float coef[1024],
-                                       GetBitContext *gb, const float sf[120],
-                                       int pulse_present, const Pulse *pulse,
-                                       const IndividualChannelStream *ics,
-                                       enum BandType band_type[120])
-{
-    int i, k, g, idx = 0;
-    const int c = 1024 / ics->num_windows;
-    const uint16_t *offsets = ics->swb_offset;
-    float *coef_base = coef;
-    int err_idx;
-
-    for (g = 0; g < ics->num_windows; g++)
-        memset(coef + g * 128 + offsets[ics->max_sfb], 0, sizeof(float) * (c - offsets[ics->max_sfb]));
-
-    for (g = 0; g < ics->num_window_groups; g++) {
-        unsigned g_len = ics->group_len[g];
-
-        for (i = 0; i < ics->max_sfb; i++, idx++) {
-            const unsigned cbt_m1 = band_type[idx] - 1;
-            float *cfo = coef + offsets[i];
-            int off_len = offsets[i + 1] - offsets[i];
-            int group;
-
-            if (cbt_m1 >= INTENSITY_BT2 - 1) {
-                for (group = 0; group < g_len; group++, cfo+=128) {
-                    memset(cfo, 0, off_len * sizeof(float));
-                }
-            } else if (cbt_m1 == NOISE_BT - 1) {
-                for (group = 0; group < g_len; group++, cfo+=128) {
-                    float scale;
-                    float band_energy;
-
-                    for (k = 0; k < off_len; k++) {
-                        ac->random_state  = lcg_random(ac->random_state);
-                        cfo[k] = ac->random_state;
-                    }
-
-                    band_energy = ac->dsp.scalarproduct_float(cfo, cfo, off_len);
-                    scale = sf[idx] / sqrtf(band_energy);
-                    ac->dsp.vector_fmul_scalar(cfo, cfo, scale, off_len);
-                }
-            } else {
-                const float *vq = ff_aac_codebook_vector_vals[cbt_m1];
-                const uint16_t *cb_vector_idx = ff_aac_codebook_vector_idx[cbt_m1];
-                VLC_TYPE (*vlc_tab)[2] = vlc_spectral[cbt_m1].table;
-                const int cb_size = ff_aac_spectral_sizes[cbt_m1];
-                OPEN_READER(re, gb);
-
-                switch (cbt_m1 >> 1) {
-                case 0:
-                    for (group = 0; group < g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned cb_idx;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-
-                            if (code >= cb_size) {
-                                err_idx = code;
-                                goto err_cb_overflow;
-                            }
-
-                            cb_idx = cb_vector_idx[code];
-                            cf = VMUL4(cf, vq, cb_idx, sf + idx);
-                        } while (len -= 4);
-                    }
-                    break;
-
-                case 1:
-                    for (group = 0; group < g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned nnz;
-                            unsigned cb_idx;
-                            uint32_t bits;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-
-                            if (code >= cb_size) {
-                                err_idx = code;
-                                goto err_cb_overflow;
-                            }
-
-#if MIN_CACHE_BITS < 20
-                            UPDATE_CACHE(re, gb);
-#endif
-                            cb_idx = cb_vector_idx[code];
-                            nnz = cb_idx >> 8 & 15;
-                            bits = SHOW_UBITS(re, gb, nnz) << (32-nnz);
-                            LAST_SKIP_BITS(re, gb, nnz);
-                            cf = VMUL4S(cf, vq, cb_idx, bits, sf + idx);
-                        } while (len -= 4);
-                    }
-                    break;
-
-                case 2:
-                    for (group = 0; group < g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned cb_idx;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-
-                            if (code >= cb_size) {
-                                err_idx = code;
-                                goto err_cb_overflow;
-                            }
-
-                            cb_idx = cb_vector_idx[code];
-                            cf = VMUL2(cf, vq, cb_idx, sf + idx);
-                        } while (len -= 2);
-                    }
-                    break;
-
-                case 3:
-                case 4:
-                    for (group = 0; group < g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned nnz;
-                            unsigned cb_idx;
-                            unsigned sign;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-
-                            if (code >= cb_size) {
-                                err_idx = code;
-                                goto err_cb_overflow;
-                            }
-
-                            cb_idx = cb_vector_idx[code];
-                            nnz = cb_idx >> 8 & 15;
-                            sign = SHOW_UBITS(re, gb, nnz) << (cb_idx >> 12);
-                            LAST_SKIP_BITS(re, gb, nnz);
-                            cf = VMUL2S(cf, vq, cb_idx, sign, sf + idx);
-                        } while (len -= 2);
-                    }
-                    break;
-
-                default:
-                    for (group = 0; group < g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        uint32_t *icf = (uint32_t *) cf;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned nzt, nnz;
-                            unsigned cb_idx;
-                            uint32_t bits;
-                            int j;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-
-                            if (!code) {
-                                *icf++ = 0;
-                                *icf++ = 0;
-                                continue;
-                            }
-
-                            if (code >= cb_size) {
-                                err_idx = code;
-                                goto err_cb_overflow;
-                            }
-
-                            cb_idx = cb_vector_idx[code];
-                            nnz = cb_idx >> 12;
-                            nzt = cb_idx >> 8;
-                            bits = SHOW_UBITS(re, gb, nnz) << (32-nnz);
-                            LAST_SKIP_BITS(re, gb, nnz);
-
-                            for (j = 0; j < 2; j++) {
-                                if (nzt & 1<<j) {
-                                    uint32_t b;
-                                    int n;
-                                    /* The total length of escape_sequence must be < 22 bits according
-                                       to the specification (i.e. max is 111111110xxxxxxxxxxxx). */
-                                    UPDATE_CACHE(re, gb);
-                                    b = GET_CACHE(re, gb);
-                                    b = 31 - av_log2(~b);
-
-                                    if (b > 8) {
-                                        av_log(ac->avccontext, AV_LOG_ERROR, "error in spectral data, ESC overflow\n");
-                                        return -1;
-                                    }
-
-#if MIN_CACHE_BITS < 21
-                                    LAST_SKIP_BITS(re, gb, b + 1);
-                                    UPDATE_CACHE(re, gb);
-#else
-                                    SKIP_BITS(re, gb, b + 1);
-#endif
-                                    b += 4;
-                                    n = (1 << b) + SHOW_UBITS(re, gb, b);
-                                    LAST_SKIP_BITS(re, gb, b);
-                                    *icf++ = cbrt_tab[n] | (bits & 1<<31);
-                                    bits <<= 1;
-                                } else {
-                                    unsigned v = ((const uint32_t*)vq)[cb_idx & 15];
-                                    *icf++ = (bits & 1<<31) | v;
-                                    bits <<= !!v;
-                                }
-                                cb_idx >>= 4;
-                            }
-                        } while (len -= 2);
-
-                        ac->dsp.vector_fmul_scalar(cfo, cfo, sf[idx], off_len);
-                    }
-                }
-
-                CLOSE_READER(re, gb);
-            }
-        }
-        coef += g_len << 7;
-    }
-
-    if (pulse_present) {
-        idx = 0;
-        for (i = 0; i < pulse->num_pulse; i++) {
-            float co = coef_base[ pulse->pos[i] ];
-            while (offsets[idx + 1] <= pulse->pos[i])
-                idx++;
-            if (band_type[idx] != NOISE_BT && sf[idx]) {
-                float ico = -pulse->amp[i];
-                if (co) {
-                    co /= sf[idx];
-                    ico = co / sqrtf(sqrtf(fabsf(co))) + (co > 0 ? -ico : ico);
-                }
-                coef_base[ pulse->pos[i] ] = cbrtf(fabsf(ico)) * ico * sf[idx];
-            }
-        }
-    }
-    return 0;
-
-err_cb_overflow:
-    av_log(ac->avccontext, AV_LOG_ERROR,
-           "Read beyond end of ff_aac_codebook_vectors[%d][]. index %d >= %d\n",
-           band_type[idx], err_idx, ff_aac_spectral_sizes[band_type[idx]]);
-    return -1;
-}
-
-static av_always_inline float flt16_round(float pf)
-{
-    union float754 tmp;
-    tmp.f = pf;
-    tmp.i = (tmp.i + 0x00008000U) & 0xFFFF0000U;
-    return tmp.f;
-}
-
-static av_always_inline float flt16_even(float pf)
-{
-    union float754 tmp;
-    tmp.f = pf;
-    tmp.i = (tmp.i + 0x00007FFFU + (tmp.i & 0x00010000U >> 16)) & 0xFFFF0000U;
-    return tmp.f;
-}
-
-static av_always_inline float flt16_trunc(float pf)
-{
-    union float754 pun;
-    pun.f = pf;
-    pun.i &= 0xFFFF0000U;
-    return pun.f;
-}
-
-static av_always_inline void predict(AACContext *ac, PredictorState *ps, float *coef,
-                    int output_enable)
-{
-    const float a     = 0.953125; // 61.0 / 64
-    const float alpha = 0.90625;  // 29.0 / 32
-    float e0, e1;
-    float pv;
-    float k1, k2;
-
-    k1 = ps->var0 > 1 ? ps->cor0 * flt16_even(a / ps->var0) : 0;
-    k2 = ps->var1 > 1 ? ps->cor1 * flt16_even(a / ps->var1) : 0;
-
-    pv = flt16_round(k1 * ps->r0 + k2 * ps->r1);
-    if (output_enable)
-        *coef += pv * ac->sf_scale;
-
-    e0 = *coef / ac->sf_scale;
-    e1 = e0 - k1 * ps->r0;
-
-    ps->cor1 = flt16_trunc(alpha * ps->cor1 + ps->r1 * e1);
-    ps->var1 = flt16_trunc(alpha * ps->var1 + 0.5 * (ps->r1 * ps->r1 + e1 * e1));
-    ps->cor0 = flt16_trunc(alpha * ps->cor0 + ps->r0 * e0);
-    ps->var0 = flt16_trunc(alpha * ps->var0 + 0.5 * (ps->r0 * ps->r0 + e0 * e0));
-
-    ps->r1 = flt16_trunc(a * (ps->r0 - k1 * e0));
-    ps->r0 = flt16_trunc(a * e0);
-}
-
-/**
- * Apply AAC-Main style frequency domain prediction.
- */
-static void apply_prediction(AACContext *ac, SingleChannelElement *sce)
-{
-    int sfb, k;
-
-    if (!sce->ics.predictor_initialized) {
-        reset_all_predictors(sce->predictor_state);
-        sce->ics.predictor_initialized = 1;
-    }
-
-    if (sce->ics.window_sequence[0] != EIGHT_SHORT_SEQUENCE) {
-        for (sfb = 0; sfb < ff_aac_pred_sfb_max[ac->m4ac.sampling_index]; sfb++) {
-            for (k = sce->ics.swb_offset[sfb]; k < sce->ics.swb_offset[sfb + 1]; k++) {
-                predict(ac, &sce->predictor_state[k], &sce->coeffs[k],
-                        sce->ics.predictor_present && sce->ics.prediction_used[sfb]);
-            }
-        }
-        if (sce->ics.predictor_reset_group)
-            reset_predictor_group(sce->predictor_state, sce->ics.predictor_reset_group);
-    } else
-        reset_all_predictors(sce->predictor_state);
-}
-
-/**
- * Decode an individual_channel_stream payload; reference: table 4.44.
- *
- * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
- * @param   scale_flag      scalable [1] or non-scalable [0] AAC (Unused until scalable AAC is implemented.)
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_ics(AACContext *ac, SingleChannelElement *sce,
-                      GetBitContext *gb, int common_window, int scale_flag)
-{
-    Pulse pulse;
-    TemporalNoiseShaping    *tns = &sce->tns;
-    IndividualChannelStream *ics = &sce->ics;
-    float *out = sce->coeffs;
-    int global_gain, pulse_present = 0;
-
-    /* This assignment is to silence a GCC warning about the variable being used
-     * uninitialized when in fact it always is.
-     */
-    pulse.num_pulse = 0;
-
-    global_gain = get_bits(gb, 8);
-
-    if (!common_window && !scale_flag) {
-        if (decode_ics_info(ac, ics, gb, 0) < 0)
-            return -1;
-    }
-
-    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)
-        return -1;
-    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)
-        return -1;
-
-    pulse_present = 0;
-    if (!scale_flag) {
-        if ((pulse_present = get_bits1(gb))) {
-            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-                av_log(ac->avccontext, AV_LOG_ERROR, "Pulse tool not allowed in eight short sequence.\n");
-                return -1;
-            }
-            if (decode_pulses(&pulse, gb, ics->swb_offset, ics->num_swb)) {
-                av_log(ac->avccontext, AV_LOG_ERROR, "Pulse data corrupt or invalid.\n");
-                return -1;
-            }
-        }
-        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))
-            return -1;
-        if (get_bits1(gb)) {
-            av_log_missing_feature(ac->avccontext, "SSR", 1);
-            return -1;
-        }
-    }
-
-    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)
-        return -1;
-
-    if (ac->m4ac.object_type == AOT_AAC_MAIN && !common_window)
-        apply_prediction(ac, sce);
-
-    return 0;
-}
-
-/**
- * Mid/Side stereo decoding; reference: 4.6.8.1.3.
- */
-static void apply_mid_side_stereo(AACContext *ac, ChannelElement *cpe)
-{
-    const IndividualChannelStream *ics = &cpe->ch[0].ics;
-    float *ch0 = cpe->ch[0].coeffs;
-    float *ch1 = cpe->ch[1].coeffs;
-    int g, i, group, idx = 0;
-    const uint16_t *offsets = ics->swb_offset;
-    for (g = 0; g < ics->num_window_groups; g++) {
-        for (i = 0; i < ics->max_sfb; i++, idx++) {
-            if (cpe->ms_mask[idx] &&
-                    cpe->ch[0].band_type[idx] < NOISE_BT && cpe->ch[1].band_type[idx] < NOISE_BT) {
-                for (group = 0; group < ics->group_len[g]; group++) {
-                    ac->dsp.butterflies_float(ch0 + group * 128 + offsets[i],
-                                              ch1 + group * 128 + offsets[i],
-                                              offsets[i+1] - offsets[i]);
-                }
-            }
-        }
-        ch0 += ics->group_len[g] * 128;
-        ch1 += ics->group_len[g] * 128;
-    }
-}
-
-/**
- * intensity stereo decoding; reference: 4.6.8.2.3
- *
- * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
- *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
- *                      [3] reserved for scalable AAC
- */
-static void apply_intensity_stereo(ChannelElement *cpe, int ms_present)
-{
-    const IndividualChannelStream *ics = &cpe->ch[1].ics;
-    SingleChannelElement         *sce1 = &cpe->ch[1];
-    float *coef0 = cpe->ch[0].coeffs, *coef1 = cpe->ch[1].coeffs;
-    const uint16_t *offsets = ics->swb_offset;
-    int g, group, i, k, idx = 0;
-    int c;
-    float scale;
-    for (g = 0; g < ics->num_window_groups; g++) {
-        for (i = 0; i < ics->max_sfb;) {
-            if (sce1->band_type[idx] == INTENSITY_BT || sce1->band_type[idx] == INTENSITY_BT2) {
-                const int bt_run_end = sce1->band_type_run_end[idx];
-                for (; i < bt_run_end; i++, idx++) {
-                    c = -1 + 2 * (sce1->band_type[idx] - 14);
-                    if (ms_present)
-                        c *= 1 - 2 * cpe->ms_mask[idx];
-                    scale = c * sce1->sf[idx];
-                    for (group = 0; group < ics->group_len[g]; group++)
-                        for (k = offsets[i]; k < offsets[i + 1]; k++)
-                            coef1[group * 128 + k] = scale * coef0[group * 128 + k];
-                }
-            } else {
-                int bt_run_end = sce1->band_type_run_end[idx];
-                idx += bt_run_end - i;
-                i    = bt_run_end;
-            }
-        }
-        coef0 += ics->group_len[g] * 128;
-        coef1 += ics->group_len[g] * 128;
-    }
-}
-
-/**
- * Decode a channel_pair_element; reference: table 4.4.
- *
- * @param   elem_id Identifies the instance of a syntax element.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_cpe(AACContext *ac, GetBitContext *gb, ChannelElement *cpe)
-{
-    int i, ret, common_window, ms_present = 0;
-
-    common_window = get_bits1(gb);
-    if (common_window) {
-        if (decode_ics_info(ac, &cpe->ch[0].ics, gb, 1))
-            return -1;
-        i = cpe->ch[1].ics.use_kb_window[0];
-        cpe->ch[1].ics = cpe->ch[0].ics;
-        cpe->ch[1].ics.use_kb_window[1] = i;
-        ms_present = get_bits(gb, 2);
-        if (ms_present == 3) {
-            av_log(ac->avccontext, AV_LOG_ERROR, "ms_present = 3 is reserved.\n");
-            return -1;
-        } else if (ms_present)
-            decode_mid_side_stereo(cpe, gb, ms_present);
-    }
-    if ((ret = decode_ics(ac, &cpe->ch[0], gb, common_window, 0)))
-        return ret;
-    if ((ret = decode_ics(ac, &cpe->ch[1], gb, common_window, 0)))
-        return ret;
-
-    if (common_window) {
-        if (ms_present)
-            apply_mid_side_stereo(ac, cpe);
-        if (ac->m4ac.object_type == AOT_AAC_MAIN) {
-            apply_prediction(ac, &cpe->ch[0]);
-            apply_prediction(ac, &cpe->ch[1]);
-        }
-    }
-
-    apply_intensity_stereo(cpe, ms_present);
-    return 0;
-}
-
-/**
- * Decode coupling_channel_element; reference: table 4.8.
- *
- * @param   elem_id Identifies the instance of a syntax element.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_cce(AACContext *ac, GetBitContext *gb, ChannelElement *che)
-{
-    int num_gain = 0;
-    int c, g, sfb, ret;
-    int sign;
-    float scale;
-    SingleChannelElement *sce = &che->ch[0];
-    ChannelCoupling     *coup = &che->coup;
-
-    coup->coupling_point = 2 * get_bits1(gb);
-    coup->num_coupled = get_bits(gb, 3);
-    for (c = 0; c <= coup->num_coupled; c++) {
-        num_gain++;
-        coup->type[c] = get_bits1(gb) ? TYPE_CPE : TYPE_SCE;
-        coup->id_select[c] = get_bits(gb, 4);
-        if (coup->type[c] == TYPE_CPE) {
-            coup->ch_select[c] = get_bits(gb, 2);
-            if (coup->ch_select[c] == 3)
-                num_gain++;
-        } else
-            coup->ch_select[c] = 2;
-    }
-    coup->coupling_point += get_bits1(gb) || (coup->coupling_point >> 1);
-
-    sign  = get_bits(gb, 1);
-    scale = pow(2., pow(2., (int)get_bits(gb, 2) - 3));
-
-    if ((ret = decode_ics(ac, sce, gb, 0, 0)))
-        return ret;
-
-    for (c = 0; c < num_gain; c++) {
-        int idx  = 0;
-        int cge  = 1;
-        int gain = 0;
-        float gain_cache = 1.;
-        if (c) {
-            cge = coup->coupling_point == AFTER_IMDCT ? 1 : get_bits1(gb);
-            gain = cge ? get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60: 0;
-            gain_cache = pow(scale, -gain);
-        }
-        if (coup->coupling_point == AFTER_IMDCT) {
-            coup->gain[c][0] = gain_cache;
-        } else {
-            for (g = 0; g < sce->ics.num_window_groups; g++) {
-                for (sfb = 0; sfb < sce->ics.max_sfb; sfb++, idx++) {
-                    if (sce->band_type[idx] != ZERO_BT) {
-                        if (!cge) {
-                            int t = get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                            if (t) {
-                                int s = 1;
-                                t = gain += t;
-                                if (sign) {
-                                    s  -= 2 * (t & 0x1);
-                                    t >>= 1;
-                                }
-                                gain_cache = pow(scale, -t) * s;
-                            }
-                        }
-                        coup->gain[c][idx] = gain_cache;
-                    }
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Parse whether channels are to be excluded from Dynamic Range Compression; reference: table 4.53.
- *
- * @return  Returns number of bytes consumed.
- */
-static int decode_drc_channel_exclusions(DynamicRangeControl *che_drc,
-                                         GetBitContext *gb)
-{
-    int i;
-    int num_excl_chan = 0;
-
-    do {
-        for (i = 0; i < 7; i++)
-            che_drc->exclude_mask[num_excl_chan++] = get_bits1(gb);
-    } while (num_excl_chan < MAX_CHANNELS - 7 && get_bits1(gb));
-
-    return num_excl_chan / 7;
-}
-
-/**
- * Decode dynamic range information; reference: table 4.52.
- *
- * @param   cnt length of TYPE_FIL syntactic element in bytes
- *
- * @return  Returns number of bytes consumed.
- */
-static int decode_dynamic_range(DynamicRangeControl *che_drc,
-                                GetBitContext *gb, int cnt)
-{
-    int n             = 1;
-    int drc_num_bands = 1;
-    int i;
-
-    /* pce_tag_present? */
-    if (get_bits1(gb)) {
-        che_drc->pce_instance_tag  = get_bits(gb, 4);
-        skip_bits(gb, 4); // tag_reserved_bits
-        n++;
-    }
-
-    /* excluded_chns_present? */
-    if (get_bits1(gb)) {
-        n += decode_drc_channel_exclusions(che_drc, gb);
-    }
-
-    /* drc_bands_present? */
-    if (get_bits1(gb)) {
-        che_drc->band_incr            = get_bits(gb, 4);
-        che_drc->interpolation_scheme = get_bits(gb, 4);
-        n++;
-        drc_num_bands += che_drc->band_incr;
-        for (i = 0; i < drc_num_bands; i++) {
-            che_drc->band_top[i] = get_bits(gb, 8);
-            n++;
-        }
-    }
-
-    /* prog_ref_level_present? */
-    if (get_bits1(gb)) {
-        che_drc->prog_ref_level = get_bits(gb, 7);
-        skip_bits1(gb); // prog_ref_level_reserved_bits
-        n++;
-    }
-
-    for (i = 0; i < drc_num_bands; i++) {
-        che_drc->dyn_rng_sgn[i] = get_bits1(gb);
-        che_drc->dyn_rng_ctl[i] = get_bits(gb, 7);
-        n++;
-    }
-
-    return n;
-}
-
-/**
- * Decode extension data (incomplete); reference: table 4.51.
- *
- * @param   cnt length of TYPE_FIL syntactic element in bytes
- *
- * @return Returns number of bytes consumed
- */
-static int decode_extension_payload(AACContext *ac, GetBitContext *gb, int cnt,
-                                    ChannelElement *che, enum RawDataBlockType elem_type)
-{
-    int crc_flag = 0;
-    int res = cnt;
-    switch (get_bits(gb, 4)) { // extension type
-    case EXT_SBR_DATA_CRC:
-        crc_flag++;
-    case EXT_SBR_DATA:
-        if (!che) {
-            av_log(ac->avccontext, AV_LOG_ERROR, "SBR was found before the first channel element.\n");
-            return res;
-        } else if (!ac->m4ac.sbr) {
-            av_log(ac->avccontext, AV_LOG_ERROR, "SBR signaled to be not-present but was found in the bitstream.\n");
-            skip_bits_long(gb, 8 * cnt - 4);
-            return res;
-        } else if (ac->m4ac.sbr == -1 && ac->output_configured == OC_LOCKED) {
-            av_log(ac->avccontext, AV_LOG_ERROR, "Implicit SBR was found with a first occurrence after the first frame.\n");
-            skip_bits_long(gb, 8 * cnt - 4);
-            return res;
-        } else {
-            ac->m4ac.sbr = 1;
-        }
-        res = ff_decode_sbr_extension(ac, &che->sbr, gb, crc_flag, cnt, elem_type);
-        break;
-    case EXT_DYNAMIC_RANGE:
-        res = decode_dynamic_range(&ac->che_drc, gb, cnt);
-        break;
-    case EXT_FILL:
-    case EXT_FILL_DATA:
-    case EXT_DATA_ELEMENT:
-    default:
-        skip_bits_long(gb, 8 * cnt - 4);
-        break;
-    };
-    return res;
-}
-
-/**
- * Decode Temporal Noise Shaping filter coefficients and apply all-pole filters; reference: 4.6.9.3.
- *
- * @param   decode  1 if tool is used normally, 0 if tool is used in LTP.
- * @param   coef    spectral coefficients
- */
-static void apply_tns(float coef[1024], TemporalNoiseShaping *tns,
-                      IndividualChannelStream *ics, int decode)
-{
-    const int mmm = FFMIN(ics->tns_max_bands, ics->max_sfb);
-    int w, filt, m, i;
-    int bottom, top, order, start, end, size, inc;
-    float lpc[TNS_MAX_ORDER];
-
-    for (w = 0; w < ics->num_windows; w++) {
-        bottom = ics->num_swb;
-        for (filt = 0; filt < tns->n_filt[w]; filt++) {
-            top    = bottom;
-            bottom = FFMAX(0, top - tns->length[w][filt]);
-            order  = tns->order[w][filt];
-            if (order == 0)
-                continue;
-
-            // tns_decode_coef
-            compute_lpc_coefs(tns->coef[w][filt], order, lpc, 0, 0, 0);
-
-            start = ics->swb_offset[FFMIN(bottom, mmm)];
-            end   = ics->swb_offset[FFMIN(   top, mmm)];
-            if ((size = end - start) <= 0)
-                continue;
-            if (tns->direction[w][filt]) {
-                inc = -1;
-                start = end - 1;
-            } else {
-                inc = 1;
-            }
-            start += w * 128;
-
-            // ar filter
-            for (m = 0; m < size; m++, start += inc)
-                for (i = 1; i <= FFMIN(m, order); i++)
-                    coef[start] -= coef[start - i * inc] * lpc[i - 1];
-        }
-    }
-}
-
-/**
- * Conduct IMDCT and windowing.
- */
-static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)
-{
-    IndividualChannelStream *ics = &sce->ics;
-    float *in    = sce->coeffs;
-    float *out   = sce->ret;
-    float *saved = sce->saved;
-    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;
-    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;
-    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;
-    float *buf  = ac->buf_mdct;
-    float *temp = ac->temp;
-    int i;
-
-    // imdct
-    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-        if (ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE)
-            av_log(ac->avccontext, AV_LOG_WARNING,
-                   "Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. "
-                   "If you heard an audible artifact, please submit the sample to the FFmpeg developers.\n");
-        for (i = 0; i < 1024; i += 128)
-            ff_imdct_half(&ac->mdct_small, buf + i, in + i);
-    } else
-        ff_imdct_half(&ac->mdct, buf, in);
-
-    /* window overlapping
-     * NOTE: To simplify the overlapping code, all 'meaningless' short to long
-     * and long to short transitions are considered to be short to short
-     * transitions. This leaves just two cases (long to long and short to short)
-     * with a little special sauce for EIGHT_SHORT_SEQUENCE.
-     */
-    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&
-            (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) {
-        ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);
-    } else {
-        for (i = 0; i < 448; i++)
-            out[i] = saved[i] + bias;
-
-        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-            ac->dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);
-            ac->dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);
-            ac->dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);
-            ac->dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);
-            ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);
-            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));
-        } else {
-            ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);
-            for (i = 576; i < 1024; i++)
-                out[i] = buf[i-512] + bias;
-        }
-    }
-
-    // buffer update
-    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-        for (i = 0; i < 64; i++)
-            saved[i] = temp[64 + i] - bias;
-        ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);
-        ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);
-        ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);
-        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));
-    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {
-        memcpy(                    saved,       buf + 512,        448 * sizeof(float));
-        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));
-    } else { // LONG_STOP or ONLY_LONG
-        memcpy(                    saved,       buf + 512,        512 * sizeof(float));
-    }
-}
-
-/**
- * Apply dependent channel coupling (applied before IMDCT).
- *
- * @param   index   index into coupling gain array
- */
-static void apply_dependent_coupling(AACContext *ac,
-                                     SingleChannelElement *target,
-                                     ChannelElement *cce, int index)
-{
-    IndividualChannelStream *ics = &cce->ch[0].ics;
-    const uint16_t *offsets = ics->swb_offset;
-    float *dest = target->coeffs;
-    const float *src = cce->ch[0].coeffs;
-    int g, i, group, k, idx = 0;
-    if (ac->m4ac.object_type == AOT_AAC_LTP) {
-        av_log(ac->avccontext, AV_LOG_ERROR,
-               "Dependent coupling is not supported together with LTP\n");
-        return;
-    }
-    for (g = 0; g < ics->num_window_groups; g++) {
-        for (i = 0; i < ics->max_sfb; i++, idx++) {
-            if (cce->ch[0].band_type[idx] != ZERO_BT) {
-                const float gain = cce->coup.gain[index][idx];
-                for (group = 0; group < ics->group_len[g]; group++) {
-                    for (k = offsets[i]; k < offsets[i + 1]; k++) {
-                        // XXX dsputil-ize
-                        dest[group * 128 + k] += gain * src[group * 128 + k];
-                    }
-                }
-            }
-        }
-        dest += ics->group_len[g] * 128;
-        src  += ics->group_len[g] * 128;
-    }
-}
-
-/**
- * Apply independent channel coupling (applied after IMDCT).
- *
- * @param   index   index into coupling gain array
- */
-static void apply_independent_coupling(AACContext *ac,
-                                       SingleChannelElement *target,
-                                       ChannelElement *cce, int index)
-{
-    int i;
-    const float gain = cce->coup.gain[index][0];
-    const float bias = ac->add_bias;
-    const float *src = cce->ch[0].ret;
-    float *dest = target->ret;
-    const int len = 1024 << (ac->m4ac.sbr == 1);
-
-    for (i = 0; i < len; i++)
-        dest[i] += gain * (src[i] - bias);
-}
-
-/**
- * channel coupling transformation interface
- *
- * @param   index   index into coupling gain array
- * @param   apply_coupling_method   pointer to (in)dependent coupling function
- */
-static void apply_channel_coupling(AACContext *ac, ChannelElement *cc,
-                                   enum RawDataBlockType type, int elem_id,
-                                   enum CouplingPoint coupling_point,
-                                   void (*apply_coupling_method)(AACContext *ac, SingleChannelElement *target, ChannelElement *cce, int index))
-{
-    int i, c;
-
-    for (i = 0; i < MAX_ELEM_ID; i++) {
-        ChannelElement *cce = ac->che[TYPE_CCE][i];
-        int index = 0;
-
-        if (cce && cce->coup.coupling_point == coupling_point) {
-            ChannelCoupling *coup = &cce->coup;
-
-            for (c = 0; c <= coup->num_coupled; c++) {
-                if (coup->type[c] == type && coup->id_select[c] == elem_id) {
-                    if (coup->ch_select[c] != 1) {
-                        apply_coupling_method(ac, &cc->ch[0], cce, index);
-                        if (coup->ch_select[c] != 0)
-                            index++;
-                    }
-                    if (coup->ch_select[c] != 2)
-                        apply_coupling_method(ac, &cc->ch[1], cce, index++);
-                } else
-                    index += 1 + (coup->ch_select[c] == 3);
-            }
-        }
-    }
-}
-
-/**
- * Convert spectral data to float samples, applying all supported tools as appropriate.
- */
-static void spectral_to_sample(AACContext *ac)
-{
-    int i, type;
-    float imdct_bias = (ac->m4ac.sbr <= 0) ? ac->add_bias : 0.0f;
-    for (type = 3; type >= 0; type--) {
-        for (i = 0; i < MAX_ELEM_ID; i++) {
-            ChannelElement *che = ac->che[type][i];
-            if (che) {
-                if (type <= TYPE_CPE)
-                    apply_channel_coupling(ac, che, type, i, BEFORE_TNS, apply_dependent_coupling);
-                if (che->ch[0].tns.present)
-                    apply_tns(che->ch[0].coeffs, &che->ch[0].tns, &che->ch[0].ics, 1);
-                if (che->ch[1].tns.present)
-                    apply_tns(che->ch[1].coeffs, &che->ch[1].tns, &che->ch[1].ics, 1);
-                if (type <= TYPE_CPE)
-                    apply_channel_coupling(ac, che, type, i, BETWEEN_TNS_AND_IMDCT, apply_dependent_coupling);
-                if (type != TYPE_CCE || che->coup.coupling_point == AFTER_IMDCT) {
-                    imdct_and_windowing(ac, &che->ch[0], imdct_bias);
-                    if (type == TYPE_CPE) {
-                        imdct_and_windowing(ac, &che->ch[1], imdct_bias);
-                    }
-                    if (ac->m4ac.sbr > 0) {
-                        ff_sbr_apply(ac, &che->sbr, type, che->ch[0].ret, che->ch[1].ret);
-                    }
-                }
-                if (type <= TYPE_CCE)
-                    apply_channel_coupling(ac, che, type, i, AFTER_IMDCT, apply_independent_coupling);
-            }
-        }
-    }
-}
-
-static int parse_adts_frame_header(AACContext *ac, GetBitContext *gb)
-{
-    int size;
-    AACADTSHeaderInfo hdr_info;
-
-    size = ff_aac_parse_header(gb, &hdr_info);
-    if (size > 0) {
-        if (ac->output_configured != OC_LOCKED && hdr_info.chan_config) {
-            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
-            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-            ac->m4ac.chan_config = hdr_info.chan_config;
-            if (set_default_channel_config(ac, new_che_pos, hdr_info.chan_config))
-                return -7;
-            if (output_configure(ac, ac->che_pos, new_che_pos, hdr_info.chan_config, OC_TRIAL_FRAME))
-                return -7;
-        } else if (ac->output_configured != OC_LOCKED) {
-            ac->output_configured = OC_NONE;
-        }
-        if (ac->output_configured != OC_LOCKED)
-            ac->m4ac.sbr = -1;
-        ac->m4ac.sample_rate     = hdr_info.sample_rate;
-        ac->m4ac.sampling_index  = hdr_info.sampling_index;
-        ac->m4ac.object_type     = hdr_info.object_type;
-        if (!ac->avccontext->sample_rate)
-            ac->avccontext->sample_rate = hdr_info.sample_rate;
-        if (hdr_info.num_aac_frames == 1) {
-            if (!hdr_info.crc_absent)
-                skip_bits(gb, 16);
-        } else {
-            av_log_missing_feature(ac->avccontext, "More than one AAC RDB per ADTS frame is", 0);
-            return -1;
-        }
-    }
-    return size;
-}
-
-static int aac_decode_frame(AVCodecContext *avccontext, void *data,
-                            int *data_size, AVPacket *avpkt)
-{
-    const uint8_t *buf = avpkt->data;
-    int buf_size = avpkt->size;
-    AACContext *ac = avccontext->priv_data;
-    ChannelElement *che = NULL, *che_prev = NULL;
-    GetBitContext gb;
-    enum RawDataBlockType elem_type, elem_type_prev = TYPE_END;
-    int err, elem_id, data_size_tmp;
-    int buf_consumed;
-    int samples = 1024, multiplier;
-    int buf_offset;
-
-    init_get_bits(&gb, buf, buf_size * 8);
-
-    if (show_bits(&gb, 12) == 0xfff) {
-        if (parse_adts_frame_header(ac, &gb) < 0) {
-            av_log(avccontext, AV_LOG_ERROR, "Error decoding AAC frame header.\n");
-            return -1;
-        }
-        if (ac->m4ac.sampling_index > 12) {
-            av_log(ac->avccontext, AV_LOG_ERROR, "invalid sampling rate index %d\n", ac->m4ac.sampling_index);
-            return -1;
-        }
-    }
-
-    // parse
-    while ((elem_type = get_bits(&gb, 3)) != TYPE_END) {
-        elem_id = get_bits(&gb, 4);
-
-        if (elem_type < TYPE_DSE && !(che=get_che(ac, elem_type, elem_id))) {
-            av_log(ac->avccontext, AV_LOG_ERROR, "channel element %d.%d is not allocated\n", elem_type, elem_id);
-            return -1;
-        }
-
-        switch (elem_type) {
-
-        case TYPE_SCE:
-            err = decode_ics(ac, &che->ch[0], &gb, 0, 0);
-            break;
-
-        case TYPE_CPE:
-            err = decode_cpe(ac, &gb, che);
-            break;
-
-        case TYPE_CCE:
-            err = decode_cce(ac, &gb, che);
-            break;
-
-        case TYPE_LFE:
-            err = decode_ics(ac, &che->ch[0], &gb, 0, 0);
-            break;
-
-        case TYPE_DSE:
-            err = skip_data_stream_element(ac, &gb);
-            break;
-
-        case TYPE_PCE: {
-            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
-            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-            if ((err = decode_pce(ac, new_che_pos, &gb)))
-                break;
-            if (ac->output_configured > OC_TRIAL_PCE)
-                av_log(avccontext, AV_LOG_ERROR,
-                       "Not evaluating a further program_config_element as this construct is dubious at best.\n");
-            else
-                err = output_configure(ac, ac->che_pos, new_che_pos, 0, OC_TRIAL_PCE);
-            break;
-        }
-
-        case TYPE_FIL:
-            if (elem_id == 15)
-                elem_id += get_bits(&gb, 8) - 1;
-            if (get_bits_left(&gb) < 8 * elem_id) {
-                    av_log(avccontext, AV_LOG_ERROR, overread_err);
-                    return -1;
-            }
-            while (elem_id > 0)
-                elem_id -= decode_extension_payload(ac, &gb, elem_id, che_prev, elem_type_prev);
-            err = 0; /* FIXME */
-            break;
-
-        default:
-            err = -1; /* should not happen, but keeps compiler happy */
-            break;
-        }
-
-        che_prev       = che;
-        elem_type_prev = elem_type;
-
-        if (err)
-            return err;
-
-        if (get_bits_left(&gb) < 3) {
-            av_log(avccontext, AV_LOG_ERROR, overread_err);
-            return -1;
-        }
-    }
-
-    spectral_to_sample(ac);
-
-    multiplier = (ac->m4ac.sbr == 1) ? ac->m4ac.ext_sample_rate > ac->m4ac.sample_rate : 0;
-    samples <<= multiplier;
-    if (ac->output_configured < OC_LOCKED) {
-        avccontext->sample_rate = ac->m4ac.sample_rate << multiplier;
-        avccontext->frame_size = samples;
-    }
-
-    data_size_tmp = samples * avccontext->channels * sizeof(int16_t);
-    if (*data_size < data_size_tmp) {
-        av_log(avccontext, AV_LOG_ERROR,
-               "Output buffer too small (%d) or trying to output too many samples (%d) for this frame.\n",
-               *data_size, data_size_tmp);
-        return -1;
-    }
-    *data_size = data_size_tmp;
-
-    ac->dsp.float_to_int16_interleave(data, (const float **)ac->output_data, samples, avccontext->channels);
-
-    if (ac->output_configured)
-        ac->output_configured = OC_LOCKED;
-
-    buf_consumed = (get_bits_count(&gb) + 7) >> 3;
-    for (buf_offset = buf_consumed; buf_offset < buf_size; buf_offset++)
-        if (buf[buf_offset])
-            break;
-
-    return buf_size > buf_offset ? buf_consumed : buf_size;
-}
-
-static av_cold int aac_decode_close(AVCodecContext *avccontext)
-{
-    AACContext *ac = avccontext->priv_data;
-    int i, type;
-
-    for (i = 0; i < MAX_ELEM_ID; i++) {
-        for (type = 0; type < 4; type++) {
-            if (ac->che[type][i])
-                ff_aac_sbr_ctx_close(&ac->che[type][i]->sbr);
-            av_freep(&ac->che[type][i]);
-        }
-    }
-
-    ff_mdct_end(&ac->mdct);
-    ff_mdct_end(&ac->mdct_small);
-    return 0;
-}
-
-AVCodec aac_decoder = {
-    "aac",
-    AVMEDIA_TYPE_AUDIO,
-    CODEC_ID_AAC,
-    sizeof(AACContext),
-    aac_decode_init,
-    NULL,
-    aac_decode_close,
-    aac_decode_frame,
-    .long_name = NULL_IF_CONFIG_SMALL("Advanced Audio Coding"),
-    .sample_fmts = (const enum SampleFormat[]) {
-        SAMPLE_FMT_S16,SAMPLE_FMT_NONE
-    },
-    .channel_layouts = aac_channel_layout,
-};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,1037 @@
+/*
+ * MPEG-4 Parametric Stereo decoding functions
+ * Copyright (c) 2010 Alex Converse <alex.converse at gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+#include "libavutil/common.h"
+#include "libavutil/mathematics.h"
+#include "avcodec.h"
+#include "get_bits.h"
+#include "aacps.h"
+#include "aacps_tablegen.h"
+#include "aacpsdata.c"
+
+#define PS_BASELINE 0  //< Operate in Baseline PS mode
+                       //< Baseline implies 10 or 20 stereo bands,
+                       //< mixing mode A, and no ipd/opd
+
+#define numQMFSlots 32 //numTimeSlots * RATE
+
+static const int8_t num_env_tab[2][4] = {
+    { 0, 1, 2, 4, },
+    { 1, 2, 3, 4, },
+};
+
+static const int8_t nr_iidicc_par_tab[] = {
+    10, 20, 34, 10, 20, 34,
+};
+
+static const int8_t nr_iidopd_par_tab[] = {
+     5, 11, 17,  5, 11, 17,
+};
+
+enum {
+    huff_iid_df1,
+    huff_iid_dt1,
+    huff_iid_df0,
+    huff_iid_dt0,
+    huff_icc_df,
+    huff_icc_dt,
+    huff_ipd_df,
+    huff_ipd_dt,
+    huff_opd_df,
+    huff_opd_dt,
+};
+
+static const int huff_iid[] = {
+    huff_iid_df0,
+    huff_iid_df1,
+    huff_iid_dt0,
+    huff_iid_dt1,
+};
+
+static VLC vlc_ps[10];
+
+/**
+ * Read Inter-channel Intensity Difference/Inter-Channel Coherence/
+ * Inter-channel Phase Difference/Overall Phase Difference parameters from the
+ * bitstream.
+ *
+ * @param avctx contains the current codec context
+ * @param gb    pointer to the input bitstream
+ * @param ps    pointer to the Parametric Stereo context
+ * @param par   pointer to the parameter to be read
+ * @param e     envelope to decode
+ * @param dt    1: time delta-coded, 0: frequency delta-coded
+ */
+#define READ_PAR_DATA(PAR, OFFSET, MASK, ERR_CONDITION) \
+static int read_ ## PAR ## _data(AVCodecContext *avctx, GetBitContext *gb, PSContext *ps, \
+                        int8_t (*PAR)[PS_MAX_NR_IIDICC], int table_idx, int e, int dt) \
+{ \
+    int b, num = ps->nr_ ## PAR ## _par; \
+    VLC_TYPE (*vlc_table)[2] = vlc_ps[table_idx].table; \
+    if (dt) { \
+        int e_prev = e ? e - 1 : ps->num_env_old - 1; \
+        e_prev = FFMAX(e_prev, 0); \
+        for (b = 0; b < num; b++) { \
+            int val = PAR[e_prev][b] + get_vlc2(gb, vlc_table, 9, 3) - OFFSET; \
+            if (MASK) val &= MASK; \
+            PAR[e][b] = val; \
+            if (ERR_CONDITION) \
+                goto err; \
+        } \
+    } else { \
+        int val = 0; \
+        for (b = 0; b < num; b++) { \
+            val += get_vlc2(gb, vlc_table, 9, 3) - OFFSET; \
+            if (MASK) val &= MASK; \
+            PAR[e][b] = val; \
+            if (ERR_CONDITION) \
+                goto err; \
+        } \
+    } \
+    return 0; \
+err: \
+    av_log(avctx, AV_LOG_ERROR, "illegal "#PAR"\n"); \
+    return -1; \
+}
+
+READ_PAR_DATA(iid,    huff_offset[table_idx],    0, FFABS(ps->iid_par[e][b]) > 7 + 8 * ps->iid_quant)
+READ_PAR_DATA(icc,    huff_offset[table_idx],    0, ps->icc_par[e][b] > 7U)
+READ_PAR_DATA(ipdopd,                      0, 0x07, 0)
+
+static int ps_read_extension_data(GetBitContext *gb, PSContext *ps, int ps_extension_id)
+{
+    int e;
+    int count = get_bits_count(gb);
+
+    if (ps_extension_id)
+        return 0;
+
+    ps->enable_ipdopd = get_bits1(gb);
+    if (ps->enable_ipdopd) {
+        for (e = 0; e < ps->num_env; e++) {
+            int dt = get_bits1(gb);
+            read_ipdopd_data(NULL, gb, ps, ps->ipd_par, dt ? huff_ipd_dt : huff_ipd_df, e, dt);
+            dt = get_bits1(gb);
+            read_ipdopd_data(NULL, gb, ps, ps->opd_par, dt ? huff_opd_dt : huff_opd_df, e, dt);
+        }
+    }
+    skip_bits1(gb);      //reserved_ps
+    return get_bits_count(gb) - count;
+}
+
+static void ipdopd_reset(int8_t *opd_hist, int8_t *ipd_hist)
+{
+    int i;
+    for (i = 0; i < PS_MAX_NR_IPDOPD; i++) {
+        opd_hist[i] = 0;
+        ipd_hist[i] = 0;
+    }
+}
+
+int ff_ps_read_data(AVCodecContext *avctx, GetBitContext *gb_host, PSContext *ps, int bits_left)
+{
+    int e;
+    int bit_count_start = get_bits_count(gb_host);
+    int header;
+    int bits_consumed;
+    GetBitContext gbc = *gb_host, *gb = &gbc;
+
+    header = get_bits1(gb);
+    if (header) {     //enable_ps_header
+        ps->enable_iid = get_bits1(gb);
+        if (ps->enable_iid) {
+            int iid_mode = get_bits(gb, 3);
+            if (iid_mode > 5) {
+                av_log(avctx, AV_LOG_ERROR, "iid_mode %d is reserved.\n",
+                       iid_mode);
+                goto err;
+            }
+            ps->nr_iid_par    = nr_iidicc_par_tab[iid_mode];
+            ps->iid_quant     = iid_mode > 2;
+            ps->nr_ipdopd_par = nr_iidopd_par_tab[iid_mode];
+        }
+        ps->enable_icc = get_bits1(gb);
+        if (ps->enable_icc) {
+            ps->icc_mode = get_bits(gb, 3);
+            if (ps->icc_mode > 5) {
+                av_log(avctx, AV_LOG_ERROR, "icc_mode %d is reserved.\n",
+                       ps->icc_mode);
+                goto err;
+            }
+            ps->nr_icc_par = nr_iidicc_par_tab[ps->icc_mode];
+        }
+        ps->enable_ext = get_bits1(gb);
+    }
+
+    ps->frame_class = get_bits1(gb);
+    ps->num_env_old = ps->num_env;
+    ps->num_env     = num_env_tab[ps->frame_class][get_bits(gb, 2)];
+
+    ps->border_position[0] = -1;
+    if (ps->frame_class) {
+        for (e = 1; e <= ps->num_env; e++)
+            ps->border_position[e] = get_bits(gb, 5);
+    } else
+        for (e = 1; e <= ps->num_env; e++)
+            ps->border_position[e] = (e * numQMFSlots >> ff_log2_tab[ps->num_env]) - 1;
+
+    if (ps->enable_iid) {
+        for (e = 0; e < ps->num_env; e++) {
+            int dt = get_bits1(gb);
+            if (read_iid_data(avctx, gb, ps, ps->iid_par, huff_iid[2*dt+ps->iid_quant], e, dt))
+                goto err;
+        }
+    } else
+        memset(ps->iid_par, 0, sizeof(ps->iid_par));
+
+    if (ps->enable_icc)
+        for (e = 0; e < ps->num_env; e++) {
+            int dt = get_bits1(gb);
+            if (read_icc_data(avctx, gb, ps, ps->icc_par, dt ? huff_icc_dt : huff_icc_df, e, dt))
+                goto err;
+        }
+    else
+        memset(ps->icc_par, 0, sizeof(ps->icc_par));
+
+    if (ps->enable_ext) {
+        int cnt = get_bits(gb, 4);
+        if (cnt == 15) {
+            cnt += get_bits(gb, 8);
+        }
+        cnt *= 8;
+        while (cnt > 7) {
+            int ps_extension_id = get_bits(gb, 2);
+            cnt -= 2 + ps_read_extension_data(gb, ps, ps_extension_id);
+        }
+        if (cnt < 0) {
+            av_log(avctx, AV_LOG_ERROR, "ps extension overflow %d", cnt);
+            goto err;
+        }
+        skip_bits(gb, cnt);
+    }
+
+    ps->enable_ipdopd &= !PS_BASELINE;
+
+    //Fix up envelopes
+    if (!ps->num_env || ps->border_position[ps->num_env] < numQMFSlots - 1) {
+        //Create a fake envelope
+        int source = ps->num_env ? ps->num_env - 1 : ps->num_env_old - 1;
+        if (source >= 0 && source != ps->num_env) {
+            if (ps->enable_iid) {
+                memcpy(ps->iid_par+ps->num_env, ps->iid_par+source, sizeof(ps->iid_par[0]));
+            }
+            if (ps->enable_icc) {
+                memcpy(ps->icc_par+ps->num_env, ps->icc_par+source, sizeof(ps->icc_par[0]));
+            }
+            if (ps->enable_ipdopd) {
+                memcpy(ps->ipd_par+ps->num_env, ps->ipd_par+source, sizeof(ps->ipd_par[0]));
+                memcpy(ps->opd_par+ps->num_env, ps->opd_par+source, sizeof(ps->opd_par[0]));
+            }
+        }
+        ps->num_env++;
+        ps->border_position[ps->num_env] = numQMFSlots - 1;
+    }
+
+
+    ps->is34bands_old = ps->is34bands;
+    if (!PS_BASELINE && (ps->enable_iid || ps->enable_icc))
+        ps->is34bands = (ps->enable_iid && ps->nr_iid_par == 34) ||
+                        (ps->enable_icc && ps->nr_icc_par == 34);
+
+    //Baseline
+    if (!ps->enable_ipdopd) {
+        memset(ps->ipd_par, 0, sizeof(ps->ipd_par));
+        memset(ps->opd_par, 0, sizeof(ps->opd_par));
+    }
+
+    if (header)
+        ps->start = 1;
+
+    bits_consumed = get_bits_count(gb) - bit_count_start;
+    if (bits_consumed <= bits_left) {
+        skip_bits_long(gb_host, bits_consumed);
+        return bits_consumed;
+    }
+    av_log(avctx, AV_LOG_ERROR, "Expected to read %d PS bits actually read %d.\n", bits_left, bits_consumed);
+err:
+    ps->start = 0;
+    skip_bits_long(gb_host, bits_left);
+    return bits_left;
+}
+
+/** Split one subband into 2 subsubbands with a symmetric real filter.
+ * The filter must have its non-center even coefficients equal to zero. */
+static void hybrid2_re(float (*in)[2], float (*out)[32][2], const float filter[7], int len, int reverse)
+{
+    int i, j;
+    for (i = 0; i < len; i++, in++) {
+        float re_in = filter[6] * in[6][0];          //real inphase
+        float re_op = 0.0f;                          //real out of phase
+        float im_in = filter[6] * in[6][1];          //imag inphase
+        float im_op = 0.0f;                          //imag out of phase
+        for (j = 0; j < 6; j += 2) {
+            re_op += filter[j+1] * (in[j+1][0] + in[12-j-1][0]);
+            im_op += filter[j+1] * (in[j+1][1] + in[12-j-1][1]);
+        }
+        out[ reverse][i][0] = re_in + re_op;
+        out[ reverse][i][1] = im_in + im_op;
+        out[!reverse][i][0] = re_in - re_op;
+        out[!reverse][i][1] = im_in - im_op;
+    }
+}
+
+/** Split one subband into 6 subsubbands with a complex filter */
+static void hybrid6_cx(float (*in)[2], float (*out)[32][2], const float (*filter)[7][2], int len)
+{
+    int i, j, ssb;
+    int N = 8;
+    float temp[8][2];
+
+    for (i = 0; i < len; i++, in++) {
+        for (ssb = 0; ssb < N; ssb++) {
+            float sum_re = filter[ssb][6][0] * in[6][0], sum_im = filter[ssb][6][0] * in[6][1];
+            for (j = 0; j < 6; j++) {
+                float in0_re = in[j][0];
+                float in0_im = in[j][1];
+                float in1_re = in[12-j][0];
+                float in1_im = in[12-j][1];
+                sum_re += filter[ssb][j][0] * (in0_re + in1_re) - filter[ssb][j][1] * (in0_im - in1_im);
+                sum_im += filter[ssb][j][0] * (in0_im + in1_im) + filter[ssb][j][1] * (in0_re - in1_re);
+            }
+            temp[ssb][0] = sum_re;
+            temp[ssb][1] = sum_im;
+        }
+        out[0][i][0] = temp[6][0];
+        out[0][i][1] = temp[6][1];
+        out[1][i][0] = temp[7][0];
+        out[1][i][1] = temp[7][1];
+        out[2][i][0] = temp[0][0];
+        out[2][i][1] = temp[0][1];
+        out[3][i][0] = temp[1][0];
+        out[3][i][1] = temp[1][1];
+        out[4][i][0] = temp[2][0] + temp[5][0];
+        out[4][i][1] = temp[2][1] + temp[5][1];
+        out[5][i][0] = temp[3][0] + temp[4][0];
+        out[5][i][1] = temp[3][1] + temp[4][1];
+    }
+}
+
+static void hybrid4_8_12_cx(float (*in)[2], float (*out)[32][2], const float (*filter)[7][2], int N, int len)
+{
+    int i, j, ssb;
+
+    for (i = 0; i < len; i++, in++) {
+        for (ssb = 0; ssb < N; ssb++) {
+            float sum_re = filter[ssb][6][0] * in[6][0], sum_im = filter[ssb][6][0] * in[6][1];
+            for (j = 0; j < 6; j++) {
+                float in0_re = in[j][0];
+                float in0_im = in[j][1];
+                float in1_re = in[12-j][0];
+                float in1_im = in[12-j][1];
+                sum_re += filter[ssb][j][0] * (in0_re + in1_re) - filter[ssb][j][1] * (in0_im - in1_im);
+                sum_im += filter[ssb][j][0] * (in0_im + in1_im) + filter[ssb][j][1] * (in0_re - in1_re);
+            }
+            out[ssb][i][0] = sum_re;
+            out[ssb][i][1] = sum_im;
+        }
+    }
+}
+
+static void hybrid_analysis(float out[91][32][2], float in[5][44][2], float L[2][38][64], int is34, int len)
+{
+    int i, j;
+    for (i = 0; i < 5; i++) {
+        for (j = 0; j < 38; j++) {
+            in[i][j+6][0] = L[0][j][i];
+            in[i][j+6][1] = L[1][j][i];
+        }
+    }
+    if (is34) {
+        hybrid4_8_12_cx(in[0], out,    f34_0_12, 12, len);
+        hybrid4_8_12_cx(in[1], out+12, f34_1_8,   8, len);
+        hybrid4_8_12_cx(in[2], out+20, f34_2_4,   4, len);
+        hybrid4_8_12_cx(in[3], out+24, f34_2_4,   4, len);
+        hybrid4_8_12_cx(in[4], out+28, f34_2_4,   4, len);
+        for (i = 0; i < 59; i++) {
+            for (j = 0; j < len; j++) {
+                out[i+32][j][0] = L[0][j][i+5];
+                out[i+32][j][1] = L[1][j][i+5];
+            }
+        }
+    } else {
+        hybrid6_cx(in[0], out, f20_0_8, len);
+        hybrid2_re(in[1], out+6, g1_Q2, len, 1);
+        hybrid2_re(in[2], out+8, g1_Q2, len, 0);
+        for (i = 0; i < 61; i++) {
+            for (j = 0; j < len; j++) {
+                out[i+10][j][0] = L[0][j][i+3];
+                out[i+10][j][1] = L[1][j][i+3];
+            }
+        }
+    }
+    //update in_buf
+    for (i = 0; i < 5; i++) {
+        memcpy(in[i], in[i]+32, 6 * sizeof(in[i][0]));
+    }
+}
+
+static void hybrid_synthesis(float out[2][38][64], float in[91][32][2], int is34, int len)
+{
+    int i, n;
+    if (is34) {
+        for (n = 0; n < len; n++) {
+            memset(out[0][n], 0, 5*sizeof(out[0][n][0]));
+            memset(out[1][n], 0, 5*sizeof(out[1][n][0]));
+            for (i = 0; i < 12; i++) {
+                out[0][n][0] += in[   i][n][0];
+                out[1][n][0] += in[   i][n][1];
+            }
+            for (i = 0; i < 8; i++) {
+                out[0][n][1] += in[12+i][n][0];
+                out[1][n][1] += in[12+i][n][1];
+            }
+            for (i = 0; i < 4; i++) {
+                out[0][n][2] += in[20+i][n][0];
+                out[1][n][2] += in[20+i][n][1];
+                out[0][n][3] += in[24+i][n][0];
+                out[1][n][3] += in[24+i][n][1];
+                out[0][n][4] += in[28+i][n][0];
+                out[1][n][4] += in[28+i][n][1];
+            }
+        }
+        for (i = 0; i < 59; i++) {
+            for (n = 0; n < len; n++) {
+                out[0][n][i+5] = in[i+32][n][0];
+                out[1][n][i+5] = in[i+32][n][1];
+            }
+        }
+    } else {
+        for (n = 0; n < len; n++) {
+            out[0][n][0] = in[0][n][0] + in[1][n][0] + in[2][n][0] +
+                           in[3][n][0] + in[4][n][0] + in[5][n][0];
+            out[1][n][0] = in[0][n][1] + in[1][n][1] + in[2][n][1] +
+                           in[3][n][1] + in[4][n][1] + in[5][n][1];
+            out[0][n][1] = in[6][n][0] + in[7][n][0];
+            out[1][n][1] = in[6][n][1] + in[7][n][1];
+            out[0][n][2] = in[8][n][0] + in[9][n][0];
+            out[1][n][2] = in[8][n][1] + in[9][n][1];
+        }
+        for (i = 0; i < 61; i++) {
+            for (n = 0; n < len; n++) {
+                out[0][n][i+3] = in[i+10][n][0];
+                out[1][n][i+3] = in[i+10][n][1];
+            }
+        }
+    }
+}
+
+/// All-pass filter decay slope
+#define DECAY_SLOPE      0.05f
+/// Number of frequency bands that can be addressed by the parameter index, b(k)
+static const int   NR_PAR_BANDS[]      = { 20, 34 };
+/// Number of frequency bands that can be addressed by the sub subband index, k
+static const int   NR_BANDS[]          = { 71, 91 };
+/// Start frequency band for the all-pass filter decay slope
+static const int   DECAY_CUTOFF[]      = { 10, 32 };
+/// Number of all-pass filer bands
+static const int   NR_ALLPASS_BANDS[]  = { 30, 50 };
+/// First stereo band using the short one sample delay
+static const int   SHORT_DELAY_BAND[]  = { 42, 62 };
+
+/** Table 8.46 */
+static void map_idx_10_to_20(int8_t *par_mapped, const int8_t *par, int full)
+{
+    int b;
+    if (full)
+        b = 9;
+    else {
+        b = 4;
+        par_mapped[10] = 0;
+    }
+    for (; b >= 0; b--) {
+        par_mapped[2*b+1] = par_mapped[2*b] = par[b];
+    }
+}
+
+static void map_idx_34_to_20(int8_t *par_mapped, const int8_t *par, int full)
+{
+    par_mapped[ 0] = (2*par[ 0] +   par[ 1]) / 3;
+    par_mapped[ 1] = (  par[ 1] + 2*par[ 2]) / 3;
+    par_mapped[ 2] = (2*par[ 3] +   par[ 4]) / 3;
+    par_mapped[ 3] = (  par[ 4] + 2*par[ 5]) / 3;
+    par_mapped[ 4] = (  par[ 6] +   par[ 7]) / 2;
+    par_mapped[ 5] = (  par[ 8] +   par[ 9]) / 2;
+    par_mapped[ 6] =    par[10];
+    par_mapped[ 7] =    par[11];
+    par_mapped[ 8] = (  par[12] +   par[13]) / 2;
+    par_mapped[ 9] = (  par[14] +   par[15]) / 2;
+    par_mapped[10] =    par[16];
+    if (full) {
+        par_mapped[11] =    par[17];
+        par_mapped[12] =    par[18];
+        par_mapped[13] =    par[19];
+        par_mapped[14] = (  par[20] +   par[21]) / 2;
+        par_mapped[15] = (  par[22] +   par[23]) / 2;
+        par_mapped[16] = (  par[24] +   par[25]) / 2;
+        par_mapped[17] = (  par[26] +   par[27]) / 2;
+        par_mapped[18] = (  par[28] +   par[29] +   par[30] +   par[31]) / 4;
+        par_mapped[19] = (  par[32] +   par[33]) / 2;
+    }
+}
+
+static void map_val_34_to_20(float par[PS_MAX_NR_IIDICC])
+{
+    par[ 0] = (2*par[ 0] +   par[ 1]) * 0.33333333f;
+    par[ 1] = (  par[ 1] + 2*par[ 2]) * 0.33333333f;
+    par[ 2] = (2*par[ 3] +   par[ 4]) * 0.33333333f;
+    par[ 3] = (  par[ 4] + 2*par[ 5]) * 0.33333333f;
+    par[ 4] = (  par[ 6] +   par[ 7]) * 0.5f;
+    par[ 5] = (  par[ 8] +   par[ 9]) * 0.5f;
+    par[ 6] =    par[10];
+    par[ 7] =    par[11];
+    par[ 8] = (  par[12] +   par[13]) * 0.5f;
+    par[ 9] = (  par[14] +   par[15]) * 0.5f;
+    par[10] =    par[16];
+    par[11] =    par[17];
+    par[12] =    par[18];
+    par[13] =    par[19];
+    par[14] = (  par[20] +   par[21]) * 0.5f;
+    par[15] = (  par[22] +   par[23]) * 0.5f;
+    par[16] = (  par[24] +   par[25]) * 0.5f;
+    par[17] = (  par[26] +   par[27]) * 0.5f;
+    par[18] = (  par[28] +   par[29] +   par[30] +   par[31]) * 0.25f;
+    par[19] = (  par[32] +   par[33]) * 0.5f;
+}
+
+static void map_idx_10_to_34(int8_t *par_mapped, const int8_t *par, int full)
+{
+    if (full) {
+        par_mapped[33] = par[9];
+        par_mapped[32] = par[9];
+        par_mapped[31] = par[9];
+        par_mapped[30] = par[9];
+        par_mapped[29] = par[9];
+        par_mapped[28] = par[9];
+        par_mapped[27] = par[8];
+        par_mapped[26] = par[8];
+        par_mapped[25] = par[8];
+        par_mapped[24] = par[8];
+        par_mapped[23] = par[7];
+        par_mapped[22] = par[7];
+        par_mapped[21] = par[7];
+        par_mapped[20] = par[7];
+        par_mapped[19] = par[6];
+        par_mapped[18] = par[6];
+        par_mapped[17] = par[5];
+        par_mapped[16] = par[5];
+    } else {
+        par_mapped[16] =      0;
+    }
+    par_mapped[15] = par[4];
+    par_mapped[14] = par[4];
+    par_mapped[13] = par[4];
+    par_mapped[12] = par[4];
+    par_mapped[11] = par[3];
+    par_mapped[10] = par[3];
+    par_mapped[ 9] = par[2];
+    par_mapped[ 8] = par[2];
+    par_mapped[ 7] = par[2];
+    par_mapped[ 6] = par[2];
+    par_mapped[ 5] = par[1];
+    par_mapped[ 4] = par[1];
+    par_mapped[ 3] = par[1];
+    par_mapped[ 2] = par[0];
+    par_mapped[ 1] = par[0];
+    par_mapped[ 0] = par[0];
+}
+
+static void map_idx_20_to_34(int8_t *par_mapped, const int8_t *par, int full)
+{
+    if (full) {
+        par_mapped[33] =  par[19];
+        par_mapped[32] =  par[19];
+        par_mapped[31] =  par[18];
+        par_mapped[30] =  par[18];
+        par_mapped[29] =  par[18];
+        par_mapped[28] =  par[18];
+        par_mapped[27] =  par[17];
+        par_mapped[26] =  par[17];
+        par_mapped[25] =  par[16];
+        par_mapped[24] =  par[16];
+        par_mapped[23] =  par[15];
+        par_mapped[22] =  par[15];
+        par_mapped[21] =  par[14];
+        par_mapped[20] =  par[14];
+        par_mapped[19] =  par[13];
+        par_mapped[18] =  par[12];
+        par_mapped[17] =  par[11];
+    }
+    par_mapped[16] =  par[10];
+    par_mapped[15] =  par[ 9];
+    par_mapped[14] =  par[ 9];
+    par_mapped[13] =  par[ 8];
+    par_mapped[12] =  par[ 8];
+    par_mapped[11] =  par[ 7];
+    par_mapped[10] =  par[ 6];
+    par_mapped[ 9] =  par[ 5];
+    par_mapped[ 8] =  par[ 5];
+    par_mapped[ 7] =  par[ 4];
+    par_mapped[ 6] =  par[ 4];
+    par_mapped[ 5] =  par[ 3];
+    par_mapped[ 4] = (par[ 2] + par[ 3]) / 2;
+    par_mapped[ 3] =  par[ 2];
+    par_mapped[ 2] =  par[ 1];
+    par_mapped[ 1] = (par[ 0] + par[ 1]) / 2;
+    par_mapped[ 0] =  par[ 0];
+}
+
+static void map_val_20_to_34(float par[PS_MAX_NR_IIDICC])
+{
+    par[33] =  par[19];
+    par[32] =  par[19];
+    par[31] =  par[18];
+    par[30] =  par[18];
+    par[29] =  par[18];
+    par[28] =  par[18];
+    par[27] =  par[17];
+    par[26] =  par[17];
+    par[25] =  par[16];
+    par[24] =  par[16];
+    par[23] =  par[15];
+    par[22] =  par[15];
+    par[21] =  par[14];
+    par[20] =  par[14];
+    par[19] =  par[13];
+    par[18] =  par[12];
+    par[17] =  par[11];
+    par[16] =  par[10];
+    par[15] =  par[ 9];
+    par[14] =  par[ 9];
+    par[13] =  par[ 8];
+    par[12] =  par[ 8];
+    par[11] =  par[ 7];
+    par[10] =  par[ 6];
+    par[ 9] =  par[ 5];
+    par[ 8] =  par[ 5];
+    par[ 7] =  par[ 4];
+    par[ 6] =  par[ 4];
+    par[ 5] =  par[ 3];
+    par[ 4] = (par[ 2] + par[ 3]) * 0.5f;
+    par[ 3] =  par[ 2];
+    par[ 2] =  par[ 1];
+    par[ 1] = (par[ 0] + par[ 1]) * 0.5f;
+    par[ 0] =  par[ 0];
+}
+
+static void decorrelation(PSContext *ps, float (*out)[32][2], const float (*s)[32][2], int is34)
+{
+    float power[34][PS_QMF_TIME_SLOTS] = {{0}};
+    float transient_gain[34][PS_QMF_TIME_SLOTS];
+    float *peak_decay_nrg = ps->peak_decay_nrg;
+    float *power_smooth = ps->power_smooth;
+    float *peak_decay_diff_smooth = ps->peak_decay_diff_smooth;
+    float (*delay)[PS_QMF_TIME_SLOTS + PS_MAX_DELAY][2] = ps->delay;
+    float (*ap_delay)[PS_AP_LINKS][PS_QMF_TIME_SLOTS + PS_MAX_AP_DELAY][2] = ps->ap_delay;
+    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;
+    const float peak_decay_factor = 0.76592833836465f;
+    const float transient_impact  = 1.5f;
+    const float a_smooth          = 0.25f; //< Smoothing coefficient
+    int i, k, m, n;
+    int n0 = 0, nL = 32;
+    static const int link_delay[] = { 3, 4, 5 };
+    static const float a[] = { 0.65143905753106f,
+                               0.56471812200776f,
+                               0.48954165955695f };
+
+    if (is34 != ps->is34bands_old) {
+        memset(ps->peak_decay_nrg,         0, sizeof(ps->peak_decay_nrg));
+        memset(ps->power_smooth,           0, sizeof(ps->power_smooth));
+        memset(ps->peak_decay_diff_smooth, 0, sizeof(ps->peak_decay_diff_smooth));
+        memset(ps->delay,                  0, sizeof(ps->delay));
+        memset(ps->ap_delay,               0, sizeof(ps->ap_delay));
+    }
+
+    for (n = n0; n < nL; n++) {
+        for (k = 0; k < NR_BANDS[is34]; k++) {
+            int i = k_to_i[k];
+            power[i][n] += s[k][n][0] * s[k][n][0] + s[k][n][1] * s[k][n][1];
+        }
+    }
+
+    //Transient detection
+    for (i = 0; i < NR_PAR_BANDS[is34]; i++) {
+        for (n = n0; n < nL; n++) {
+            float decayed_peak = peak_decay_factor * peak_decay_nrg[i];
+            float denom;
+            peak_decay_nrg[i] = FFMAX(decayed_peak, power[i][n]);
+            power_smooth[i] += a_smooth * (power[i][n] - power_smooth[i]);
+            peak_decay_diff_smooth[i] += a_smooth * (peak_decay_nrg[i] - power[i][n] - peak_decay_diff_smooth[i]);
+            denom = transient_impact * peak_decay_diff_smooth[i];
+            transient_gain[i][n]   = (denom > power_smooth[i]) ?
+                                         power_smooth[i] / denom : 1.0f;
+        }
+    }
+
+    //Decorrelation and transient reduction
+    //                         PS_AP_LINKS - 1
+    //                               -----
+    //                                | |  Q_fract_allpass[k][m]*z^-link_delay[m] - a[m]*g_decay_slope[k]
+    //H[k][z] = z^-2 * phi_fract[k] * | | ----------------------------------------------------------------
+    //                                | | 1 - a[m]*g_decay_slope[k]*Q_fract_allpass[k][m]*z^-link_delay[m]
+    //                               m = 0
+    //d[k][z] (out) = transient_gain_mapped[k][z] * H[k][z] * s[k][z]
+    for (k = 0; k < NR_ALLPASS_BANDS[is34]; k++) {
+        int b = k_to_i[k];
+        float g_decay_slope = 1.f - DECAY_SLOPE * (k - DECAY_CUTOFF[is34]);
+        float ag[PS_AP_LINKS];
+        g_decay_slope = av_clipf(g_decay_slope, 0.f, 1.f);
+        memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));
+        memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));
+        for (m = 0; m < PS_AP_LINKS; m++) {
+            memcpy(ap_delay[k][m],   ap_delay[k][m]+numQMFSlots,           5*sizeof(ap_delay[k][m][0]));
+            ag[m] = a[m] * g_decay_slope;
+        }
+        for (n = n0; n < nL; n++) {
+            float in_re = delay[k][n+PS_MAX_DELAY-2][0] * phi_fract[is34][k][0] -
+                          delay[k][n+PS_MAX_DELAY-2][1] * phi_fract[is34][k][1];
+            float in_im = delay[k][n+PS_MAX_DELAY-2][0] * phi_fract[is34][k][1] +
+                          delay[k][n+PS_MAX_DELAY-2][1] * phi_fract[is34][k][0];
+            for (m = 0; m < PS_AP_LINKS; m++) {
+                float a_re                = ag[m] * in_re;
+                float a_im                = ag[m] * in_im;
+                float link_delay_re       = ap_delay[k][m][n+5-link_delay[m]][0];
+                float link_delay_im       = ap_delay[k][m][n+5-link_delay[m]][1];
+                float fractional_delay_re = Q_fract_allpass[is34][k][m][0];
+                float fractional_delay_im = Q_fract_allpass[is34][k][m][1];
+                ap_delay[k][m][n+5][0] = in_re;
+                ap_delay[k][m][n+5][1] = in_im;
+                in_re = link_delay_re * fractional_delay_re - link_delay_im * fractional_delay_im - a_re;
+                in_im = link_delay_re * fractional_delay_im + link_delay_im * fractional_delay_re - a_im;
+                ap_delay[k][m][n+5][0] += ag[m] * in_re;
+                ap_delay[k][m][n+5][1] += ag[m] * in_im;
+            }
+            out[k][n][0] = transient_gain[b][n] * in_re;
+            out[k][n][1] = transient_gain[b][n] * in_im;
+        }
+    }
+    for (; k < SHORT_DELAY_BAND[is34]; k++) {
+        memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));
+        memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));
+        for (n = n0; n < nL; n++) {
+            //H = delay 14
+            out[k][n][0] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-14][0];
+            out[k][n][1] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-14][1];
+        }
+    }
+    for (; k < NR_BANDS[is34]; k++) {
+        memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));
+        memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));
+        for (n = n0; n < nL; n++) {
+            //H = delay 1
+            out[k][n][0] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-1][0];
+            out[k][n][1] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-1][1];
+        }
+    }
+}
+
+static void remap34(int8_t (**p_par_mapped)[PS_MAX_NR_IIDICC],
+                    int8_t           (*par)[PS_MAX_NR_IIDICC],
+                    int num_par, int num_env, int full)
+{
+    int8_t (*par_mapped)[PS_MAX_NR_IIDICC] = *p_par_mapped;
+    int e;
+    if (num_par == 20 || num_par == 11) {
+        for (e = 0; e < num_env; e++) {
+            map_idx_20_to_34(par_mapped[e], par[e], full);
+        }
+    } else if (num_par == 10 || num_par == 5) {
+        for (e = 0; e < num_env; e++) {
+            map_idx_10_to_34(par_mapped[e], par[e], full);
+        }
+    } else {
+        *p_par_mapped = par;
+    }
+}
+
+static void remap20(int8_t (**p_par_mapped)[PS_MAX_NR_IIDICC],
+                    int8_t           (*par)[PS_MAX_NR_IIDICC],
+                    int num_par, int num_env, int full)
+{
+    int8_t (*par_mapped)[PS_MAX_NR_IIDICC] = *p_par_mapped;
+    int e;
+    if (num_par == 34 || num_par == 17) {
+        for (e = 0; e < num_env; e++) {
+            map_idx_34_to_20(par_mapped[e], par[e], full);
+        }
+    } else if (num_par == 10 || num_par == 5) {
+        for (e = 0; e < num_env; e++) {
+            map_idx_10_to_20(par_mapped[e], par[e], full);
+        }
+    } else {
+        *p_par_mapped = par;
+    }
+}
+
+static void stereo_processing(PSContext *ps, float (*l)[32][2], float (*r)[32][2], int is34)
+{
+    int e, b, k, n;
+
+    float (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H11;
+    float (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H12;
+    float (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H21;
+    float (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H22;
+    int8_t *opd_hist = ps->opd_hist;
+    int8_t *ipd_hist = ps->ipd_hist;
+    int8_t iid_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];
+    int8_t icc_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];
+    int8_t ipd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];
+    int8_t opd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];
+    int8_t (*iid_mapped)[PS_MAX_NR_IIDICC] = iid_mapped_buf;
+    int8_t (*icc_mapped)[PS_MAX_NR_IIDICC] = icc_mapped_buf;
+    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;
+    int8_t (*opd_mapped)[PS_MAX_NR_IIDICC] = opd_mapped_buf;
+    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;
+    const float (*H_LUT)[8][4] = (PS_BASELINE || ps->icc_mode < 3) ? HA : HB;
+
+    //Remapping
+    memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));
+    memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));
+    memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));
+    memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));
+    memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));
+    memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));
+    memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));
+    memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));
+    if (is34) {
+        remap34(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);
+        remap34(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);
+        if (ps->enable_ipdopd) {
+            remap34(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);
+            remap34(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);
+        }
+        if (!ps->is34bands_old) {
+            map_val_20_to_34(H11[0][0]);
+            map_val_20_to_34(H11[1][0]);
+            map_val_20_to_34(H12[0][0]);
+            map_val_20_to_34(H12[1][0]);
+            map_val_20_to_34(H21[0][0]);
+            map_val_20_to_34(H21[1][0]);
+            map_val_20_to_34(H22[0][0]);
+            map_val_20_to_34(H22[1][0]);
+            ipdopd_reset(ipd_hist, opd_hist);
+        }
+    } else {
+        remap20(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);
+        remap20(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);
+        if (ps->enable_ipdopd) {
+            remap20(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);
+            remap20(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);
+        }
+        if (ps->is34bands_old) {
+            map_val_34_to_20(H11[0][0]);
+            map_val_34_to_20(H11[1][0]);
+            map_val_34_to_20(H12[0][0]);
+            map_val_34_to_20(H12[1][0]);
+            map_val_34_to_20(H21[0][0]);
+            map_val_34_to_20(H21[1][0]);
+            map_val_34_to_20(H22[0][0]);
+            map_val_34_to_20(H22[1][0]);
+            ipdopd_reset(ipd_hist, opd_hist);
+        }
+    }
+
+    //Mixing
+    for (e = 0; e < ps->num_env; e++) {
+        for (b = 0; b < NR_PAR_BANDS[is34]; b++) {
+            float h11, h12, h21, h22;
+            h11 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][0];
+            h12 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][1];
+            h21 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][2];
+            h22 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][3];
+            if (!PS_BASELINE && ps->enable_ipdopd && b < ps->nr_ipdopd_par) {
+                //The spec say says to only run this smoother when enable_ipdopd
+                //is set but the reference decoder appears to run it constantly
+                float h11i, h12i, h21i, h22i;
+                float ipd_adj_re, ipd_adj_im;
+                int opd_idx = opd_hist[b] * 8 + opd_mapped[e][b];
+                int ipd_idx = ipd_hist[b] * 8 + ipd_mapped[e][b];
+                float opd_re = pd_re_smooth[opd_idx];
+                float opd_im = pd_im_smooth[opd_idx];
+                float ipd_re = pd_re_smooth[ipd_idx];
+                float ipd_im = pd_im_smooth[ipd_idx];
+                opd_hist[b] = opd_idx & 0x3F;
+                ipd_hist[b] = ipd_idx & 0x3F;
+
+                ipd_adj_re = opd_re*ipd_re + opd_im*ipd_im;
+                ipd_adj_im = opd_im*ipd_re - opd_re*ipd_im;
+                h11i = h11 * opd_im;
+                h11  = h11 * opd_re;
+                h12i = h12 * ipd_adj_im;
+                h12  = h12 * ipd_adj_re;
+                h21i = h21 * opd_im;
+                h21  = h21 * opd_re;
+                h22i = h22 * ipd_adj_im;
+                h22  = h22 * ipd_adj_re;
+                H11[1][e+1][b] = h11i;
+                H12[1][e+1][b] = h12i;
+                H21[1][e+1][b] = h21i;
+                H22[1][e+1][b] = h22i;
+            }
+            H11[0][e+1][b] = h11;
+            H12[0][e+1][b] = h12;
+            H21[0][e+1][b] = h21;
+            H22[0][e+1][b] = h22;
+        }
+        for (k = 0; k < NR_BANDS[is34]; k++) {
+            float h11r, h12r, h21r, h22r;
+            float h11i, h12i, h21i, h22i;
+            float h11r_step, h12r_step, h21r_step, h22r_step;
+            float h11i_step, h12i_step, h21i_step, h22i_step;
+            int start = ps->border_position[e];
+            int stop  = ps->border_position[e+1];
+            float width = 1.f / (stop - start);
+            b = k_to_i[k];
+            h11r = H11[0][e][b];
+            h12r = H12[0][e][b];
+            h21r = H21[0][e][b];
+            h22r = H22[0][e][b];
+            if (!PS_BASELINE && ps->enable_ipdopd) {
+            //Is this necessary? ps_04_new seems unchanged
+            if ((is34 && k <= 13 && k >= 9) || (!is34 && k <= 1)) {
+                h11i = -H11[1][e][b];
+                h12i = -H12[1][e][b];
+                h21i = -H21[1][e][b];
+                h22i = -H22[1][e][b];
+            } else {
+                h11i = H11[1][e][b];
+                h12i = H12[1][e][b];
+                h21i = H21[1][e][b];
+                h22i = H22[1][e][b];
+            }
+            }
+            //Interpolation
+            h11r_step = (H11[0][e+1][b] - h11r) * width;
+            h12r_step = (H12[0][e+1][b] - h12r) * width;
+            h21r_step = (H21[0][e+1][b] - h21r) * width;
+            h22r_step = (H22[0][e+1][b] - h22r) * width;
+            if (!PS_BASELINE && ps->enable_ipdopd) {
+                h11i_step = (H11[1][e+1][b] - h11i) * width;
+                h12i_step = (H12[1][e+1][b] - h12i) * width;
+                h21i_step = (H21[1][e+1][b] - h21i) * width;
+                h22i_step = (H22[1][e+1][b] - h22i) * width;
+            }
+            for (n = start + 1; n <= stop; n++) {
+                //l is s, r is d
+                float l_re = l[k][n][0];
+                float l_im = l[k][n][1];
+                float r_re = r[k][n][0];
+                float r_im = r[k][n][1];
+                h11r += h11r_step;
+                h12r += h12r_step;
+                h21r += h21r_step;
+                h22r += h22r_step;
+                if (!PS_BASELINE && ps->enable_ipdopd) {
+                    h11i += h11i_step;
+                    h12i += h12i_step;
+                    h21i += h21i_step;
+                    h22i += h22i_step;
+
+                    l[k][n][0] = h11r*l_re + h21r*r_re - h11i*l_im - h21i*r_im;
+                    l[k][n][1] = h11r*l_im + h21r*r_im + h11i*l_re + h21i*r_re;
+                    r[k][n][0] = h12r*l_re + h22r*r_re - h12i*l_im - h22i*r_im;
+                    r[k][n][1] = h12r*l_im + h22r*r_im + h12i*l_re + h22i*r_re;
+                } else {
+                    l[k][n][0] = h11r*l_re + h21r*r_re;
+                    l[k][n][1] = h11r*l_im + h21r*r_im;
+                    r[k][n][0] = h12r*l_re + h22r*r_re;
+                    r[k][n][1] = h12r*l_im + h22r*r_im;
+                }
+            }
+        }
+    }
+}
+
+int ff_ps_apply(AVCodecContext *avctx, PSContext *ps, float L[2][38][64], float R[2][38][64], int top)
+{
+    float Lbuf[91][32][2];
+    float Rbuf[91][32][2];
+    const int len = 32;
+    int is34 = ps->is34bands;
+
+    top += NR_BANDS[is34] - 64;
+    memset(ps->delay+top, 0, (NR_BANDS[is34] - top)*sizeof(ps->delay[0]));
+    if (top < NR_ALLPASS_BANDS[is34])
+        memset(ps->ap_delay + top, 0, (NR_ALLPASS_BANDS[is34] - top)*sizeof(ps->ap_delay[0]));
+
+    hybrid_analysis(Lbuf, ps->in_buf, L, is34, len);
+    decorrelation(ps, Rbuf, Lbuf, is34);
+    stereo_processing(ps, Lbuf, Rbuf, is34);
+    hybrid_synthesis(L, Lbuf, is34, len);
+    hybrid_synthesis(R, Rbuf, is34, len);
+
+    return 0;
+}
+
+#define PS_INIT_VLC_STATIC(num, size) \
+    INIT_VLC_STATIC(&vlc_ps[num], 9, ps_tmp[num].table_size / ps_tmp[num].elem_size,    \
+                    ps_tmp[num].ps_bits, 1, 1,                                          \
+                    ps_tmp[num].ps_codes, ps_tmp[num].elem_size, ps_tmp[num].elem_size, \
+                    size);
+
+#define PS_VLC_ROW(name) \
+    { name ## _codes, name ## _bits, sizeof(name ## _codes), sizeof(name ## _codes[0]) }
+
+av_cold void ff_ps_init(void) {
+    // Syntax initialization
+    static const struct {
+        const void *ps_codes, *ps_bits;
+        const unsigned int table_size, elem_size;
+    } ps_tmp[] = {
+        PS_VLC_ROW(huff_iid_df1),
+        PS_VLC_ROW(huff_iid_dt1),
+        PS_VLC_ROW(huff_iid_df0),
+        PS_VLC_ROW(huff_iid_dt0),
+        PS_VLC_ROW(huff_icc_df),
+        PS_VLC_ROW(huff_icc_dt),
+        PS_VLC_ROW(huff_ipd_df),
+        PS_VLC_ROW(huff_ipd_dt),
+        PS_VLC_ROW(huff_opd_df),
+        PS_VLC_ROW(huff_opd_dt),
+    };
+
+    PS_INIT_VLC_STATIC(0, 1544);
+    PS_INIT_VLC_STATIC(1,  832);
+    PS_INIT_VLC_STATIC(2, 1024);
+    PS_INIT_VLC_STATIC(3, 1036);
+    PS_INIT_VLC_STATIC(4,  544);
+    PS_INIT_VLC_STATIC(5,  544);
+    PS_INIT_VLC_STATIC(6,  512);
+    PS_INIT_VLC_STATIC(7,  512);
+    PS_INIT_VLC_STATIC(8,  512);
+    PS_INIT_VLC_STATIC(9,  512);
+
+    ps_tableinit();
+}
+
+av_cold void ff_ps_ctx_init(PSContext *ps)
+{
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.h	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,82 @@
+/*
+ * MPEG-4 Parametric Stereo definitions and declarations
+ * Copyright (c) 2010 Alex Converse <alex.converse at gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_PS_H
+#define AVCODEC_PS_H
+
+#include <stdint.h>
+
+#include "avcodec.h"
+#include "get_bits.h"
+
+#define PS_MAX_NUM_ENV 5
+#define PS_MAX_NR_IIDICC 34
+#define PS_MAX_NR_IPDOPD 17
+#define PS_MAX_SSB 91
+#define PS_MAX_AP_BANDS 50
+#define PS_QMF_TIME_SLOTS 32
+#define PS_MAX_DELAY 14
+#define PS_AP_LINKS 3
+#define PS_MAX_AP_DELAY 5
+
+typedef struct {
+    int    start;
+    int    enable_iid;
+    int    iid_quant;
+    int    nr_iid_par;
+    int    nr_ipdopd_par;
+    int    enable_icc;
+    int    icc_mode;
+    int    nr_icc_par;
+    int    enable_ext;
+    int    frame_class;
+    int    num_env_old;
+    int    num_env;
+    int    enable_ipdopd;
+    int    border_position[PS_MAX_NUM_ENV+1];
+    int8_t iid_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //<Inter-channel Intensity Difference Parameters
+    int8_t icc_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //<Inter-Channel Coherence Parameters
+    /* ipd/opd is iid/icc sized so that the same functions can handle both */
+    int8_t ipd_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //<Inter-channel Phase Difference Parameters
+    int8_t opd_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //<Overall Phase Difference Parameters
+    int    is34bands;
+    int    is34bands_old;
+
+    float  in_buf[5][44][2];
+    float  delay[PS_MAX_SSB][PS_QMF_TIME_SLOTS + PS_MAX_DELAY][2];
+    float  ap_delay[PS_MAX_AP_BANDS][PS_AP_LINKS][PS_QMF_TIME_SLOTS + PS_MAX_AP_DELAY][2];
+    float  peak_decay_nrg[34];
+    float  power_smooth[34];
+    float  peak_decay_diff_smooth[34];
+    float  H11[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    float  H12[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    float  H21[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    float  H22[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    int8_t opd_hist[PS_MAX_NR_IIDICC];
+    int8_t ipd_hist[PS_MAX_NR_IIDICC];
+} PSContext;
+
+void ff_ps_init(void);
+void ff_ps_ctx_init(PSContext *ps);
+int ff_ps_read_data(AVCodecContext *avctx, GetBitContext *gb, PSContext *ps, int bits_left);
+int ff_ps_apply(AVCodecContext *avctx, PSContext *ps, float L[2][38][64], float R[2][38][64], int top);
+
+#endif /* AVCODEC_PS_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,93 @@
+/*
+ * Generate a header file for hardcoded Parametric Stereo tables
+ *
+ * Copyright (c) 2010 Alex Converse <alex.converse at gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdlib.h>
+#define CONFIG_HARDCODED_TABLES 0
+#include "aacps_tablegen.h"
+#include "tableprint.h"
+
+void write_float_3d_array (const void *p, int b, int c, int d)
+{
+    int i;
+    const float *f = p;
+    for (i = 0; i < b; i++) {
+        printf("{\n");
+        write_float_2d_array(f, c, d);
+        printf("},\n");
+        f += c * d;
+    }
+}
+
+void write_float_4d_array (const void *p, int a, int b, int c, int d)
+{
+    int i;
+    const float *f = p;
+    for (i = 0; i < a; i++) {
+        printf("{\n");
+        write_float_3d_array(f, b, c, d);
+        printf("},\n");
+        f += b * c * d;
+    }
+}
+
+int main(void)
+{
+    ps_tableinit();
+
+    write_fileheader();
+
+    printf("static const float pd_re_smooth[8*8*8] = {\n");
+    write_float_array(pd_re_smooth, 8*8*8);
+    printf("};\n");
+    printf("static const float pd_im_smooth[8*8*8] = {\n");
+    write_float_array(pd_im_smooth, 8*8*8);
+    printf("};\n");
+
+    printf("static const float HA[46][8][4] = {\n");
+    write_float_3d_array(HA, 46, 8, 4);
+    printf("};\n");
+    printf("static const float HB[46][8][4] = {\n");
+    write_float_3d_array(HB, 46, 8, 4);
+    printf("};\n");
+
+    printf("static const float f20_0_8[8][7][2] = {\n");
+    write_float_3d_array(f20_0_8, 8, 7, 2);
+    printf("};\n");
+    printf("static const float f34_0_12[12][7][2] = {\n");
+    write_float_3d_array(f34_0_12, 12, 7, 2);
+    printf("};\n");
+    printf("static const float f34_1_8[8][7][2] = {\n");
+    write_float_3d_array(f34_1_8, 8, 7, 2);
+    printf("};\n");
+    printf("static const float f34_2_4[4][7][2] = {\n");
+    write_float_3d_array(f34_2_4, 4, 7, 2);
+    printf("};\n");
+
+    printf("static const float Q_fract_allpass[2][50][3][2] = {\n");
+    write_float_4d_array(Q_fract_allpass, 2, 50, 3, 2);
+    printf("};\n");
+    printf("static const float phi_fract[2][50][2] = {\n");
+    write_float_3d_array(phi_fract, 2, 50, 2);
+    printf("};\n");
+
+    return 0;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.h	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,212 @@
+/*
+ * Header file for hardcoded Parametric Stereo tables
+ *
+ * Copyright (c) 2010 Alex Converse <alex.converse at gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AACPS_TABLEGEN_H
+#define AACPS_TABLEGEN_H
+
+#include <stdint.h>
+
+#if CONFIG_HARDCODED_TABLES
+#define ps_tableinit()
+#include "libavcodec/aacps_tables.h"
+#else
+#include "libavutil/common.h"
+#include "libavutil/mathematics.h"
+#define NR_ALLPASS_BANDS20 30
+#define NR_ALLPASS_BANDS34 50
+#define PS_AP_LINKS 3
+static float pd_re_smooth[8*8*8];
+static float pd_im_smooth[8*8*8];
+static float HA[46][8][4];
+static float HB[46][8][4];
+static float f20_0_8 [ 8][7][2];
+static float f34_0_12[12][7][2];
+static float f34_1_8 [ 8][7][2];
+static float f34_2_4 [ 4][7][2];
+static float Q_fract_allpass[2][50][3][2];
+static float phi_fract[2][50][2];
+
+static const float g0_Q8[] = {
+    0.00746082949812f, 0.02270420949825f, 0.04546865930473f, 0.07266113929591f,
+    0.09885108575264f, 0.11793710567217f, 0.125f
+};
+
+static const float g0_Q12[] = {
+    0.04081179924692f, 0.03812810994926f, 0.05144908135699f, 0.06399831151592f,
+    0.07428313801106f, 0.08100347892914f, 0.08333333333333f
+};
+
+static const float g1_Q8[] = {
+    0.01565675600122f, 0.03752716391991f, 0.05417891378782f, 0.08417044116767f,
+    0.10307344158036f, 0.12222452249753f, 0.125f
+};
+
+static const float g2_Q4[] = {
+    -0.05908211155639f, -0.04871498374946f, 0.0f,   0.07778723915851f,
+     0.16486303567403f,  0.23279856662996f, 0.25f
+};
+
+static void make_filters_from_proto(float (*filter)[7][2], const float *proto, int bands)
+{
+    int q, n;
+    for (q = 0; q < bands; q++) {
+        for (n = 0; n < 7; n++) {
+            double theta = 2 * M_PI * (q + 0.5) * (n - 6) / bands;
+            filter[q][n][0] = proto[n] *  cos(theta);
+            filter[q][n][1] = proto[n] * -sin(theta);
+        }
+    }
+}
+
+static void ps_tableinit(void)
+{
+    static const float ipdopd_sin[] = { 0, M_SQRT1_2, 1,  M_SQRT1_2,  0, -M_SQRT1_2, -1, -M_SQRT1_2 };
+    static const float ipdopd_cos[] = { 1, M_SQRT1_2, 0, -M_SQRT1_2, -1, -M_SQRT1_2,  0,  M_SQRT1_2 };
+    int pd0, pd1, pd2;
+
+    static const float iid_par_dequant[] = {
+        //iid_par_dequant_default
+        0.05623413251903, 0.12589254117942, 0.19952623149689, 0.31622776601684,
+        0.44668359215096, 0.63095734448019, 0.79432823472428, 1,
+        1.25892541179417, 1.58489319246111, 2.23872113856834, 3.16227766016838,
+        5.01187233627272, 7.94328234724282, 17.7827941003892,
+        //iid_par_dequant_fine
+        0.00316227766017, 0.00562341325190, 0.01,             0.01778279410039,
+        0.03162277660168, 0.05623413251903, 0.07943282347243, 0.11220184543020,
+        0.15848931924611, 0.22387211385683, 0.31622776601684, 0.39810717055350,
+        0.50118723362727, 0.63095734448019, 0.79432823472428, 1,
+        1.25892541179417, 1.58489319246111, 1.99526231496888, 2.51188643150958,
+        3.16227766016838, 4.46683592150963, 6.30957344480193, 8.91250938133745,
+        12.5892541179417, 17.7827941003892, 31.6227766016838, 56.2341325190349,
+        100,              177.827941003892, 316.227766016837,
+    };
+    static const float icc_invq[] = {
+        1, 0.937,      0.84118,    0.60092,    0.36764,   0,      -0.589,    -1
+    };
+    static const float acos_icc_invq[] = {
+        0, 0.35685527, 0.57133466, 0.92614472, 1.1943263, M_PI/2, 2.2006171, M_PI
+    };
+    int iid, icc;
+
+    int k, m;
+    static const int8_t f_center_20[] = {
+        -3, -1, 1, 3, 5, 7, 10, 14, 18, 22,
+    };
+    static const int8_t f_center_34[] = {
+         2,  6, 10, 14, 18, 22, 26, 30,
+        34,-10, -6, -2, 51, 57, 15, 21,
+        27, 33, 39, 45, 54, 66, 78, 42,
+       102, 66, 78, 90,102,114,126, 90,
+    };
+    static const float fractional_delay_links[] = { 0.43f, 0.75f, 0.347f };
+    const float fractional_delay_gain = 0.39f;
+
+    for (pd0 = 0; pd0 < 8; pd0++) {
+        float pd0_re = ipdopd_cos[pd0];
+        float pd0_im = ipdopd_sin[pd0];
+        for (pd1 = 0; pd1 < 8; pd1++) {
+            float pd1_re = ipdopd_cos[pd1];
+            float pd1_im = ipdopd_sin[pd1];
+            for (pd2 = 0; pd2 < 8; pd2++) {
+                float pd2_re = ipdopd_cos[pd2];
+                float pd2_im = ipdopd_sin[pd2];
+                float re_smooth = 0.25f * pd0_re + 0.5f * pd1_re + pd2_re;
+                float im_smooth = 0.25f * pd0_im + 0.5f * pd1_im + pd2_im;
+                float pd_mag = 1 / sqrt(im_smooth * im_smooth + re_smooth * re_smooth);
+                pd_re_smooth[pd0*64+pd1*8+pd2] = re_smooth * pd_mag;
+                pd_im_smooth[pd0*64+pd1*8+pd2] = im_smooth * pd_mag;
+            }
+        }
+    }
+
+    for (iid = 0; iid < 46; iid++) {
+        float c = iid_par_dequant[iid]; //<Linear Inter-channel Intensity Difference
+        float c1 = (float)M_SQRT2 / sqrtf(1.0f + c*c);
+        float c2 = c * c1;
+        for (icc = 0; icc < 8; icc++) {
+            /*if (PS_BASELINE || ps->icc_mode < 3)*/ {
+                float alpha = 0.5f * acos_icc_invq[icc];
+                float beta  = alpha * (c1 - c2) * (float)M_SQRT1_2;
+                HA[iid][icc][0] = c2 * cosf(beta + alpha);
+                HA[iid][icc][1] = c1 * cosf(beta - alpha);
+                HA[iid][icc][2] = c2 * sinf(beta + alpha);
+                HA[iid][icc][3] = c1 * sinf(beta - alpha);
+            } /* else */ {
+                float alpha, gamma, mu, rho;
+                float alpha_c, alpha_s, gamma_c, gamma_s;
+                rho = FFMAX(icc_invq[icc], 0.05f);
+                alpha = 0.5f * atan2f(2.0f * c * rho, c*c - 1.0f);
+                mu = c + 1.0f / c;
+                mu = sqrtf(1 + (4 * rho * rho - 4)/(mu * mu));
+                gamma = atanf(sqrtf((1.0f - mu)/(1.0f + mu)));
+                if (alpha < 0) alpha += M_PI/2;
+                alpha_c = cosf(alpha);
+                alpha_s = sinf(alpha);
+                gamma_c = cosf(gamma);
+                gamma_s = sinf(gamma);
+                HB[iid][icc][0] =  M_SQRT2 * alpha_c * gamma_c;
+                HB[iid][icc][1] =  M_SQRT2 * alpha_s * gamma_c;
+                HB[iid][icc][2] = -M_SQRT2 * alpha_s * gamma_s;
+                HB[iid][icc][3] =  M_SQRT2 * alpha_c * gamma_s;
+            }
+        }
+    }
+
+    for (k = 0; k < NR_ALLPASS_BANDS20; k++) {
+        double f_center, theta;
+        if (k < FF_ARRAY_ELEMS(f_center_20))
+            f_center = f_center_20[k] * 0.125;
+        else
+            f_center = k - 6.5f;
+        for (m = 0; m < PS_AP_LINKS; m++) {
+            theta = -M_PI * fractional_delay_links[m] * f_center;
+            Q_fract_allpass[0][k][m][0] = cos(theta);
+            Q_fract_allpass[0][k][m][1] = sin(theta);
+        }
+        theta = -M_PI*fractional_delay_gain*f_center;
+        phi_fract[0][k][0] = cos(theta);
+        phi_fract[0][k][1] = sin(theta);
+    }
+    for (k = 0; k < NR_ALLPASS_BANDS34; k++) {
+        double f_center, theta;
+        if (k < FF_ARRAY_ELEMS(f_center_34))
+            f_center = f_center_34[k] / 24.;
+        else
+            f_center = k - 26.5f;
+        for (m = 0; m < PS_AP_LINKS; m++) {
+            theta = -M_PI * fractional_delay_links[m] * f_center;
+            Q_fract_allpass[1][k][m][0] = cos(theta);
+            Q_fract_allpass[1][k][m][1] = sin(theta);
+        }
+        theta = -M_PI*fractional_delay_gain*f_center;
+        phi_fract[1][k][0] = cos(theta);
+        phi_fract[1][k][1] = sin(theta);
+    }
+
+    make_filters_from_proto(f20_0_8,  g0_Q8,   8);
+    make_filters_from_proto(f34_0_12, g0_Q12, 12);
+    make_filters_from_proto(f34_1_8,  g1_Q8,   8);
+    make_filters_from_proto(f34_2_4,  g2_Q4,   4);
+}
+#endif /* CONFIG_HARDCODED_TABLES */
+
+#endif /* AACPS_TABLEGEN_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacpsdata.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacpsdata.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacpsdata.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,163 @@
+/*
+ * MPEG-4 Parametric Stereo data tables
+ * Copyright (c) 2010 Alex Converse <alex.converse at gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+static const uint8_t huff_iid_df1_bits[] = {
+    18, 18, 18, 18, 18, 18, 18, 18, 18, 17, 18, 17, 17, 16, 16, 15, 14, 14,
+    13, 12, 12, 11, 10, 10,  8,  7,  6,  5,  4,  3,  1,  3,  4,  5,  6,  7,
+     8,  9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 16, 17, 17, 18, 17, 18, 18,
+    18, 18, 18, 18, 18, 18, 18,
+};
+
+static const uint32_t huff_iid_df1_codes[] = {
+    0x01FEB4, 0x01FEB5, 0x01FD76, 0x01FD77, 0x01FD74, 0x01FD75, 0x01FE8A,
+    0x01FE8B, 0x01FE88, 0x00FE80, 0x01FEB6, 0x00FE82, 0x00FEB8, 0x007F42,
+    0x007FAE, 0x003FAF, 0x001FD1, 0x001FE9, 0x000FE9, 0x0007EA, 0x0007FB,
+    0x0003FB, 0x0001FB, 0x0001FF, 0x00007C, 0x00003C, 0x00001C, 0x00000C,
+    0x000000, 0x000001, 0x000001, 0x000002, 0x000001, 0x00000D, 0x00001D,
+    0x00003D, 0x00007D, 0x0000FC, 0x0001FC, 0x0003FC, 0x0003F4, 0x0007EB,
+    0x000FEA, 0x001FEA, 0x001FD6, 0x003FD0, 0x007FAF, 0x007F43, 0x00FEB9,
+    0x00FE83, 0x01FEB7, 0x00FE81, 0x01FE89, 0x01FE8E, 0x01FE8F, 0x01FE8C,
+    0x01FE8D, 0x01FEB2, 0x01FEB3, 0x01FEB0, 0x01FEB1,
+};
+
+static const uint8_t huff_iid_dt1_bits[] = {
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 15, 15, 15, 15, 14, 14, 13,
+    13, 13, 12, 12, 11, 10,  9,  9,  7,  6,  5,  3,  1,  2,  5,  6,  7,  8,
+     9, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16,
+};
+
+static const uint16_t huff_iid_dt1_codes[] = {
+    0x004ED4, 0x004ED5, 0x004ECE, 0x004ECF, 0x004ECC, 0x004ED6, 0x004ED8,
+    0x004F46, 0x004F60, 0x002718, 0x002719, 0x002764, 0x002765, 0x00276D,
+    0x0027B1, 0x0013B7, 0x0013D6, 0x0009C7, 0x0009E9, 0x0009ED, 0x0004EE,
+    0x0004F7, 0x000278, 0x000139, 0x00009A, 0x00009F, 0x000020, 0x000011,
+    0x00000A, 0x000003, 0x000001, 0x000000, 0x00000B, 0x000012, 0x000021,
+    0x00004C, 0x00009B, 0x00013A, 0x000279, 0x000270, 0x0004EF, 0x0004E2,
+    0x0009EA, 0x0009D8, 0x0013D7, 0x0013D0, 0x0027B2, 0x0027A2, 0x00271A,
+    0x00271B, 0x004F66, 0x004F67, 0x004F61, 0x004F47, 0x004ED9, 0x004ED7,
+    0x004ECD, 0x004ED2, 0x004ED3, 0x004ED0, 0x004ED1,
+};
+
+static const uint8_t huff_iid_df0_bits[] = {
+    17, 17, 17, 17, 16, 15, 13, 10,  9,  7,  6,  5,  4,  3,  1,  3,  4,  5,
+     6,  6,  8, 11, 13, 14, 14, 15, 17, 18, 18,
+};
+
+static const uint32_t huff_iid_df0_codes[] = {
+    0x01FFFB, 0x01FFFC, 0x01FFFD, 0x01FFFA, 0x00FFFC, 0x007FFC, 0x001FFD,
+    0x0003FE, 0x0001FE, 0x00007E, 0x00003C, 0x00001D, 0x00000D, 0x000005,
+    0x000000, 0x000004, 0x00000C, 0x00001C, 0x00003D, 0x00003E, 0x0000FE,
+    0x0007FE, 0x001FFC, 0x003FFC, 0x003FFD, 0x007FFD, 0x01FFFE, 0x03FFFE,
+    0x03FFFF,
+};
+
+static const uint8_t huff_iid_dt0_bits[] = {
+    19, 19, 19, 20, 20, 20, 17, 15, 12, 10,  8,  6,  4,  2,  1,  3,  5,  7,
+     9, 11, 13, 14, 17, 19, 20, 20, 20, 20, 20,
+};
+
+static const uint32_t huff_iid_dt0_codes[] = {
+    0x07FFF9, 0x07FFFA, 0x07FFFB, 0x0FFFF8, 0x0FFFF9, 0x0FFFFA, 0x01FFFD,
+    0x007FFE, 0x000FFE, 0x0003FE, 0x0000FE, 0x00003E, 0x00000E, 0x000002,
+    0x000000, 0x000006, 0x00001E, 0x00007E, 0x0001FE, 0x0007FE, 0x001FFE,
+    0x003FFE, 0x01FFFC, 0x07FFF8, 0x0FFFFB, 0x0FFFFC, 0x0FFFFD, 0x0FFFFE,
+    0x0FFFFF,
+};
+
+static const uint8_t huff_icc_df_bits[] = {
+    14, 14, 12, 10, 7, 5, 3, 1, 2, 4, 6, 8, 9, 11, 13,
+};
+
+static const uint16_t huff_icc_df_codes[] = {
+    0x3FFF, 0x3FFE, 0x0FFE, 0x03FE, 0x007E, 0x001E, 0x0006, 0x0000,
+    0x0002, 0x000E, 0x003E, 0x00FE, 0x01FE, 0x07FE, 0x1FFE,
+};
+
+static const uint8_t huff_icc_dt_bits[] = {
+    14, 13, 11, 9, 7, 5, 3, 1, 2, 4, 6, 8, 10, 12, 14,
+};
+
+static const uint16_t huff_icc_dt_codes[] = {
+    0x3FFE, 0x1FFE, 0x07FE, 0x01FE, 0x007E, 0x001E, 0x0006, 0x0000,
+    0x0002, 0x000E, 0x003E, 0x00FE, 0x03FE, 0x0FFE, 0x3FFF,
+};
+
+static const uint8_t huff_ipd_df_bits[] = {
+    1, 3, 4, 4, 4, 4, 4, 4,
+};
+
+static const uint8_t huff_ipd_df_codes[] = {
+    0x01, 0x00, 0x06, 0x04, 0x02, 0x03, 0x05, 0x07,
+};
+
+static const uint8_t huff_ipd_dt_bits[] = {
+    1, 3, 4, 5, 5, 4, 4, 3,
+};
+
+static const uint8_t huff_ipd_dt_codes[] = {
+    0x01, 0x02, 0x02, 0x03, 0x02, 0x00, 0x03, 0x03,
+};
+
+static const uint8_t huff_opd_df_bits[] = {
+    1, 3, 4, 4, 5, 5, 4, 3,
+};
+
+static const uint8_t huff_opd_df_codes[] = {
+    0x01, 0x01, 0x06, 0x04, 0x0F, 0x0E, 0x05, 0x00,
+};
+
+static const uint8_t huff_opd_dt_bits[] = {
+    1, 3, 4, 5, 5, 4, 4, 3,
+};
+
+static const uint8_t huff_opd_dt_codes[] = {
+    0x01, 0x02, 0x01, 0x07, 0x06, 0x00, 0x02, 0x03,
+};
+
+static const int8_t huff_offset[] = {
+    30, 30,
+    14, 14,
+    7, 7,
+    0, 0,
+    0, 0,
+};
+
+///Table 8.48
+static const int8_t k_to_i_20[] = {
+     1,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 14, 15,
+    15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18,
+    18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19
+};
+///Table 8.49
+static const int8_t k_to_i_34[] = {
+     0,  1,  2,  3,  4,  5,  6,  6,  7,  2,  1,  0, 10, 10,  4,  5,  6,  7,  8,
+     9, 10, 11, 12,  9, 14, 11, 12, 13, 14, 15, 16, 13, 16, 17, 18, 19, 20, 21,
+    22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 28, 29, 29, 29,
+    30, 30, 30, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33,
+    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33
+};
+
+static const float g1_Q2[] = {
+    0.0f,  0.01899487526049f, 0.0f, -0.07293139167538f,
+    0.0f,  0.30596630545168f, 0.5f
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ansi.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ansi.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ansi.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,432 @@
+/*
+ * ASCII/ANSI art decoder
+ * Copyright (c) 2010 Peter Ross <pross at xvid.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * ASCII/ANSI art decoder
+ */
+
+#include "avcodec.h"
+#include "cga_data.h"
+#include <libavutil/lfg.h>
+
+#define ATTR_BOLD         0x01  /** Bold/Bright-foreground (mode 1) */
+#define ATTR_FAINT        0x02  /** Faint (mode 2) */
+#define ATTR_UNDERLINE    0x08  /** Underline (mode 4) */
+#define ATTR_BLINK        0x10  /** Blink/Bright-background (mode 5) */
+#define ATTR_REVERSE      0x40  /** Reverse (mode 7) */
+#define ATTR_CONCEALED    0x80  /** Concealed (mode 8) */
+
+#define DEFAULT_FG_COLOR     7  /** CGA color index */
+#define DEFAULT_BG_COLOR     0
+#define DEFAULT_SCREEN_MODE  3  /** 80x25 */
+
+#define FONT_WIDTH           8  /** Font width */
+
+/** map ansi color index to cga palette index */
+static const uint8_t ansi_to_cga[16] = {
+    0,  4,  2,  6,  1,  5,  3, 7, 8, 12, 10, 14,  9, 13, 11, 15
+};
+
+typedef struct {
+    AVFrame frame;
+    int x, y;             /** cursor position (pixels) */
+    int sx, sy;           /** saved cursor position (pixels) */
+    const uint8_t* font;  /** font */
+    int font_height;      /** font height */
+    int attributes;       /** attribute flags */
+    int fg, bg;           /** foreground and background color */
+
+    /* ansi parser state machine */
+    enum {
+        STATE_NORMAL = 0,
+        STATE_ESCAPE,
+        STATE_CODE,
+        STATE_MUSIC_PREAMBLE
+    } state;
+#define MAX_NB_ARGS 4
+    int args[MAX_NB_ARGS];
+    int nb_args;          /** number of arguments (may exceed MAX_NB_ARGS) */
+} AnsiContext;
+
+static av_cold int decode_init(AVCodecContext *avctx)
+{
+    AnsiContext *s = avctx->priv_data;
+    avctx->pix_fmt = PIX_FMT_PAL8;
+
+    /* defaults */
+    s->font        = ff_vga16_font;
+    s->font_height = 16;
+    s->fg          = DEFAULT_FG_COLOR;
+    s->bg          = DEFAULT_BG_COLOR;
+
+    if (!avctx->width || !avctx->height)
+        avcodec_set_dimensions(avctx, 80<<3, 25<<4);
+
+    return 0;
+}
+
+static void hscroll(AVCodecContext *avctx)
+{
+    AnsiContext *s = avctx->priv_data;
+    int i;
+
+    if (s->y < avctx->height - s->font_height) {
+        s->y += s->font_height;
+        return;
+    }
+
+    i = 0;
+    for (; i < avctx->height - s->font_height; i++)
+        memcpy(s->frame.data[0] + i * s->frame.linesize[0],
+               s->frame.data[0] + (i + s->font_height) * s->frame.linesize[0],
+               avctx->width);
+    for (; i < avctx->height; i++)
+        memset(s->frame.data[0] + i * s->frame.linesize[0],
+            DEFAULT_BG_COLOR, avctx->width);
+}
+
+static void erase_line(AVCodecContext * avctx, int xoffset, int xlength)
+{
+    AnsiContext *s = avctx->priv_data;
+    int i;
+    for (i = 0; i < s->font_height; i++)
+        memset(s->frame.data[0] + (s->y + i)*s->frame.linesize[0] + xoffset,
+            DEFAULT_BG_COLOR, xlength);
+}
+
+static void erase_screen(AVCodecContext *avctx)
+{
+    AnsiContext *s = avctx->priv_data;
+    int i;
+    for (i = 0; i < avctx->height; i++)
+        memset(s->frame.data[0] + i * s->frame.linesize[0], DEFAULT_BG_COLOR, avctx->width);
+    s->x = s->y = 0;
+}
+
+/**
+ * Draw character to screen
+ */
+static void draw_char(AVCodecContext *avctx, int c)
+{
+    AnsiContext *s = avctx->priv_data;
+    int fg = s->fg;
+    int bg = s->bg;
+
+    if ((s->attributes & ATTR_BOLD))
+        fg += 8;
+    if ((s->attributes & ATTR_BLINK))
+        bg += 8;
+    if ((s->attributes & ATTR_REVERSE))
+        FFSWAP(int, fg, bg);
+    if ((s->attributes & ATTR_CONCEALED))
+        fg = bg;
+    ff_draw_pc_font(s->frame.data[0] + s->y * s->frame.linesize[0] + s->x,
+                    s->frame.linesize[0], s->font, s->font_height, c, fg, bg);
+    s->x += FONT_WIDTH;
+    if (s->x >= avctx->width) {
+        s->x = 0;
+        hscroll(avctx);
+    }
+}
+
+/**
+ * Execute ANSI escape code
+ * @param <0 error
+ */
+static int execute_code(AVCodecContext * avctx, int c)
+{
+    AnsiContext *s = avctx->priv_data;
+    int ret, i, width, height;
+    switch(c) {
+    case 'A': //Cursor Up
+        s->y = FFMAX(s->y - (s->nb_args > 0 ? s->args[0]*s->font_height : s->font_height), 0);
+        break;
+    case 'B': //Cursor Down
+        s->y = FFMIN(s->y + (s->nb_args > 0 ? s->args[0]*s->font_height : s->font_height), avctx->height - s->font_height);
+        break;
+    case 'C': //Cursor Right
+        s->x = FFMIN(s->x + (s->nb_args > 0 ? s->args[0]*FONT_WIDTH : FONT_WIDTH), avctx->width  - FONT_WIDTH);
+        break;
+    case 'D': //Cursor Left
+        s->x = FFMAX(s->x - (s->nb_args > 0 ? s->args[0]*FONT_WIDTH : FONT_WIDTH), 0);
+        break;
+    case 'H': //Cursor Position
+    case 'f': //Horizontal and Vertical Position
+        s->y = s->nb_args > 0 ? av_clip((s->args[0] - 1)*s->font_height, 0, avctx->height - s->font_height) : 0;
+        s->x = s->nb_args > 1 ? av_clip((s->args[1] - 1)*FONT_WIDTH,     0, avctx->width  - FONT_WIDTH) : 0;
+        break;
+    case 'h': //set creen mode
+    case 'l': //reset screen mode
+        if (s->nb_args < 2)
+            s->args[0] = DEFAULT_SCREEN_MODE;
+        switch(s->args[0]) {
+        case 0: case 1: case 4: case 5: case 13: case 19: //320x200 (25 rows)
+            s->font = ff_cga_font;
+            s->font_height = 8;
+            width  = 40<<3;
+            height = 25<<3;
+            break;
+        case 2: case 3: //640x400 (25 rows)
+            s->font = ff_vga16_font;
+            s->font_height = 16;
+            width  = 80<<3;
+            height = 25<<4;
+            break;
+        case 6: case 14: //640x200 (25 rows)
+            s->font = ff_cga_font;
+            s->font_height = 8;
+            width  = 80<<3;
+            height = 25<<3;
+            break;
+        case 7: //set line wrapping
+            break;
+        case 15: case 16: //640x350 (43 rows)
+            s->font = ff_cga_font;
+            s->font_height = 8;
+            width  = 80<<3;
+            height = 43<<3;
+            break;
+        case 17: case 18: //640x480 (60 rows)
+            s->font = ff_cga_font;
+            s->font_height = 8;
+            width  = 80<<3;
+            height = 60<<4;
+            break;
+        default:
+            av_log_ask_for_sample(avctx, "unsupported screen mode\n");
+        }
+        if (width != avctx->width || height != avctx->height) {
+            if (s->frame.data[0])
+                avctx->release_buffer(avctx, &s->frame);
+            avcodec_set_dimensions(avctx, width, height);
+            ret = avctx->get_buffer(avctx, &s->frame);
+            if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
+                return ret;
+            }
+            s->frame.pict_type           = FF_I_TYPE;
+            s->frame.palette_has_changed = 1;
+            memcpy(s->frame.data[1], ff_cga_palette, 16 * 4);
+            erase_screen(avctx);
+        } else if (c == 'l') {
+            erase_screen(avctx);
+        }
+        break;
+    case 'J': //Erase in Page
+        switch (s->args[0]) {
+        case 0:
+            erase_line(avctx, s->x, avctx->width - s->x);
+            if (s->y < avctx->height - s->font_height)
+                memset(s->frame.data[0] + (s->y + s->font_height)*s->frame.linesize[0],
+                    DEFAULT_BG_COLOR, (avctx->height - s->y - s->font_height)*s->frame.linesize[0]);
+            break;
+        case 1:
+            erase_line(avctx, 0, s->x);
+            if (s->y > 0)
+                memset(s->frame.data[0], DEFAULT_BG_COLOR, s->y * s->frame.linesize[0]);
+            break;
+        case 2:
+            erase_screen(avctx);
+        }
+        break;
+    case 'K': //Erase in Line
+        switch(s->args[0]) {
+        case 0:
+            erase_line(avctx, s->x, avctx->width - s->x);
+            break;
+        case 1:
+            erase_line(avctx, 0, s->x);
+            break;
+        case 2:
+            erase_line(avctx, 0, avctx->width);
+        }
+        break;
+    case 'm': //Select Graphics Rendition
+        if (s->nb_args == 0) {
+            s->nb_args = 1;
+            s->args[0] = 0;
+        }
+        for (i = 0; i < FFMIN(s->nb_args, MAX_NB_ARGS); i++) {
+            int m = s->args[i];
+            if (m == 0) {
+                s->attributes = 0;
+                s->fg = DEFAULT_FG_COLOR;
+                s->bg = DEFAULT_BG_COLOR;
+            } else if (m == 1 || m == 2 || m == 4 || m == 5 || m == 7 || m == 8) {
+                s->attributes |= 1 << (m - 1);
+            } else if (m >= 30 && m <= 38) {
+                s->fg = ansi_to_cga[m - 30];
+            } else if (m == 39) {
+                s->fg = ansi_to_cga[DEFAULT_FG_COLOR];
+            } else if (m >= 40 && m <= 47) {
+                s->bg = ansi_to_cga[m - 40];
+            } else if (m == 49) {
+                s->fg = ansi_to_cga[DEFAULT_BG_COLOR];
+            } else {
+                av_log_ask_for_sample(avctx, "unsupported rendition parameter\n");
+            }
+        }
+        break;
+    case 'n': //Device Status Report
+    case 'R': //report current line and column
+        /* ignore */
+        break;
+    case 's': //Save Cursor Position
+        s->sx = s->x;
+        s->sy = s->y;
+        break;
+    case 'u': //Restore Cursor Position
+        s->x = av_clip(s->sx, 0, avctx->width  - FONT_WIDTH);
+        s->y = av_clip(s->sy, 0, avctx->height - s->font_height);
+        break;
+    default:
+        av_log_ask_for_sample(avctx, "unsupported escape code\n");
+        break;
+    }
+    return 0;
+}
+
+static int decode_frame(AVCodecContext *avctx,
+                            void *data, int *data_size,
+                            AVPacket *avpkt)
+{
+    AnsiContext *s = avctx->priv_data;
+    uint8_t *buf = avpkt->data;
+    int buf_size = avpkt->size;
+    const uint8_t *buf_end   = buf+buf_size;
+    int ret, i, count;
+
+    ret = avctx->reget_buffer(avctx, &s->frame);
+    if (ret < 0){
+        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
+        return ret;
+    }
+    s->frame.pict_type           = FF_I_TYPE;
+    s->frame.palette_has_changed = 1;
+    memcpy(s->frame.data[1], ff_cga_palette, 16 * 4);
+
+    while(buf < buf_end) {
+        switch(s->state) {
+        case STATE_NORMAL:
+            switch (buf[0]) {
+            case 0x00: //NUL
+            case 0x07: //BEL
+            case 0x1A: //SUB
+                /* ignore */
+                break;
+            case 0x08: //BS
+                s->x = FFMAX(s->x - 1, 0);
+                break;
+            case 0x09: //HT
+                i = s->x / FONT_WIDTH;
+                count = ((i + 8) & ~7) - i;
+                for (i = 0; i < count; i++)
+                    draw_char(avctx, ' ');
+                break;
+            case 0x0A: //LF
+                hscroll(avctx);
+            case 0x0D: //CR
+                s->x = 0;
+                break;
+            case 0x0C: //FF
+                erase_screen(avctx);
+                break;
+            case 0x1B: //ESC
+                s->state = STATE_ESCAPE;
+                break;
+            default:
+                draw_char(avctx, buf[0]);
+            }
+            break;
+        case STATE_ESCAPE:
+            if (buf[0] == '[') {
+                s->state   = STATE_CODE;
+                s->nb_args = 0;
+                s->args[0] = 0;
+            } else {
+                s->state = STATE_NORMAL;
+                draw_char(avctx, 0x1B);
+                    return -1;
+                continue;
+            }
+            break;
+        case STATE_CODE:
+            switch(buf[0]) {
+            case '0': case '1': case '2': case '3': case '4':
+            case '5': case '6': case '7': case '8': case '9':
+                if (s->nb_args < MAX_NB_ARGS)
+                    s->args[s->nb_args] = s->args[s->nb_args] * 10 + buf[0] - '0';
+                break;
+            case ';':
+                s->nb_args++;
+                if (s->nb_args < MAX_NB_ARGS)
+                    s->args[s->nb_args] = 0;
+                break;
+            case 'M':
+                s->state = STATE_MUSIC_PREAMBLE;
+                break;
+            case '=': case '?':
+                /* ignore */
+                break;
+            default:
+                if (s->nb_args > MAX_NB_ARGS)
+                    av_log(avctx, AV_LOG_WARNING, "args overflow (%i)\n", s->nb_args);
+                if (s->nb_args < MAX_NB_ARGS && s->args[s->nb_args])
+                    s->nb_args++;
+                if (execute_code(avctx, buf[0]) < 0)
+                    return -1;
+                s->state = STATE_NORMAL;
+            }
+            break;
+        case STATE_MUSIC_PREAMBLE:
+            if (buf[0] == 0x0E || buf[0] == 0x1B)
+                s->state = STATE_NORMAL;
+            /* ignore music data */
+            break;
+        }
+        buf++;
+    }
+
+    *data_size = sizeof(AVFrame);
+    *(AVFrame*)data = s->frame;
+    return buf_size;
+}
+
+static av_cold int decode_close(AVCodecContext *avctx)
+{
+    AnsiContext *s = avctx->priv_data;
+    if (s->frame.data[0])
+        avctx->release_buffer(avctx, &s->frame);
+    return 0;
+}
+
+AVCodec ansi_decoder = {
+    .name           = "ansi",
+    .type           = CODEC_TYPE_VIDEO,
+    .id             = CODEC_ID_ANSI,
+    .priv_data_size = sizeof(AnsiContext),
+    .init           = decode_init,
+    .close          = decode_close,
+    .decode         = decode_frame,
+    .capabilities   = CODEC_CAP_DR1,
+    .long_name      = NULL_IF_CONFIG_SMALL("ASCII/ANSI art"),
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h	2010-07-25 10:07:52 UTC (rev 6483)
@@ -614,6 +614,8 @@
 #define CODEC_FLAG2_PSY           0x00080000 ///< Use psycho visual optimizations.
 #define CODEC_FLAG2_SSIM          0x00100000 ///< Compute SSIM during encoding, error[] values are undefined.
 #define CODEC_FLAG2_INTRA_REFRESH 0x00200000 ///< Use periodic insertion of intra blocks instead of keyframes.
+//MEANX: NEVER EVER USE CLOSED GOP ?
+#define CODEC_FLAG2_32_PULLDOWN   0x80000000 
 
 /* Unsupported options :
  *              Syntax Arithmetic coding (SAC)
@@ -1496,6 +1498,7 @@
      * - decoding: unused
      */
     int rc_max_rate;
+    int rc_max_rate_header; /*< That one is set in the header MEANX */
 
     /**
      * minimum bitrate
@@ -1510,6 +1513,8 @@
      * - decoding: unused
      */
     int rc_buffer_size;
+    int rc_buffer_size_header;  /*< That one is set in the header MEANX*/
+
     float rc_buffer_aggressivity;
 
     /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/fft.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/fft.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -105,7 +105,7 @@
 
     if (ARCH_ARM)     ff_fft_init_arm(s);
     if (HAVE_ALTIVEC) ff_fft_init_altivec(s);
-    if (HAVE_MMX)     ff_fft_init_mmx(s);
+    // MEANX if (HAVE_MMX)     ff_fft_init_mmx(s);
 
     for(j=4; j<=nbits; j++) {
         ff_init_ff_cos_tabs(j);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -1112,6 +1112,8 @@
         clear_state(f);
     }else{
         p->key_frame= 0;
+         p->pict_type= FF_P_TYPE; // MEANX : looks more like a P to me as user
+
     }
     if(f->ac>1){
         int i;

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/gsmdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/gsmdec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/gsmdec.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,316 @@
+/*
+ * gsm 06.10 decoder
+ * Copyright (c) 2010 Reimar D?ffinger <Reimar.Doeffinger at gmx.de>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * GSM decoder
+ */
+
+#define ALT_BITSTREAM_READER_LE
+#include "avcodec.h"
+#include "get_bits.h"
+
+// input and output sizes in byte
+#define GSM_BLOCK_SIZE    33
+#define GSM_MS_BLOCK_SIZE 65
+#define GSM_FRAME_SIZE   160
+
+typedef struct {
+    int16_t ref_buf[280];
+    int v[9];
+    int lar[2][8];
+    int lar_idx;
+    int msr;
+} GSMContext;
+
+static av_cold int gsm_init(AVCodecContext *avctx)
+{
+    avctx->channels = 1;
+    if (!avctx->sample_rate)
+        avctx->sample_rate = 8000;
+    avctx->sample_fmt = SAMPLE_FMT_S16;
+
+    switch (avctx->codec_id) {
+    case CODEC_ID_GSM:
+        avctx->frame_size  = GSM_FRAME_SIZE;
+        avctx->block_align = GSM_BLOCK_SIZE;
+        break;
+    case CODEC_ID_GSM_MS:
+        avctx->frame_size  = 2 * GSM_FRAME_SIZE;
+        avctx->block_align = GSM_MS_BLOCK_SIZE;
+    }
+
+    return 0;
+}
+
+static const int16_t dequant_tab[64][8] = {
+    {   -28,    -20,    -12,     -4,      4,     12,     20,     28},
+    {   -56,    -40,    -24,     -8,      8,     24,     40,     56},
+    {   -84,    -60,    -36,    -12,     12,     36,     60,     84},
+    {  -112,    -80,    -48,    -16,     16,     48,     80,    112},
+    {  -140,   -100,    -60,    -20,     20,     60,    100,    140},
+    {  -168,   -120,    -72,    -24,     24,     72,    120,    168},
+    {  -196,   -140,    -84,    -28,     28,     84,    140,    196},
+    {  -224,   -160,    -96,    -32,     32,     96,    160,    224},
+    {  -252,   -180,   -108,    -36,     36,    108,    180,    252},
+    {  -280,   -200,   -120,    -40,     40,    120,    200,    280},
+    {  -308,   -220,   -132,    -44,     44,    132,    220,    308},
+    {  -336,   -240,   -144,    -48,     48,    144,    240,    336},
+    {  -364,   -260,   -156,    -52,     52,    156,    260,    364},
+    {  -392,   -280,   -168,    -56,     56,    168,    280,    392},
+    {  -420,   -300,   -180,    -60,     60,    180,    300,    420},
+    {  -448,   -320,   -192,    -64,     64,    192,    320,    448},
+    {  -504,   -360,   -216,    -72,     72,    216,    360,    504},
+    {  -560,   -400,   -240,    -80,     80,    240,    400,    560},
+    {  -616,   -440,   -264,    -88,     88,    264,    440,    616},
+    {  -672,   -480,   -288,    -96,     96,    288,    480,    672},
+    {  -728,   -520,   -312,   -104,    104,    312,    520,    728},
+    {  -784,   -560,   -336,   -112,    112,    336,    560,    784},
+    {  -840,   -600,   -360,   -120,    120,    360,    600,    840},
+    {  -896,   -640,   -384,   -128,    128,    384,    640,    896},
+    { -1008,   -720,   -432,   -144,    144,    432,    720,   1008},
+    { -1120,   -800,   -480,   -160,    160,    480,    800,   1120},
+    { -1232,   -880,   -528,   -176,    176,    528,    880,   1232},
+    { -1344,   -960,   -576,   -192,    192,    576,    960,   1344},
+    { -1456,  -1040,   -624,   -208,    208,    624,   1040,   1456},
+    { -1568,  -1120,   -672,   -224,    224,    672,   1120,   1568},
+    { -1680,  -1200,   -720,   -240,    240,    720,   1200,   1680},
+    { -1792,  -1280,   -768,   -256,    256,    768,   1280,   1792},
+    { -2016,  -1440,   -864,   -288,    288,    864,   1440,   2016},
+    { -2240,  -1600,   -960,   -320,    320,    960,   1600,   2240},
+    { -2464,  -1760,  -1056,   -352,    352,   1056,   1760,   2464},
+    { -2688,  -1920,  -1152,   -384,    384,   1152,   1920,   2688},
+    { -2912,  -2080,  -1248,   -416,    416,   1248,   2080,   2912},
+    { -3136,  -2240,  -1344,   -448,    448,   1344,   2240,   3136},
+    { -3360,  -2400,  -1440,   -480,    480,   1440,   2400,   3360},
+    { -3584,  -2560,  -1536,   -512,    512,   1536,   2560,   3584},
+    { -4032,  -2880,  -1728,   -576,    576,   1728,   2880,   4032},
+    { -4480,  -3200,  -1920,   -640,    640,   1920,   3200,   4480},
+    { -4928,  -3520,  -2112,   -704,    704,   2112,   3520,   4928},
+    { -5376,  -3840,  -2304,   -768,    768,   2304,   3840,   5376},
+    { -5824,  -4160,  -2496,   -832,    832,   2496,   4160,   5824},
+    { -6272,  -4480,  -2688,   -896,    896,   2688,   4480,   6272},
+    { -6720,  -4800,  -2880,   -960,    960,   2880,   4800,   6720},
+    { -7168,  -5120,  -3072,  -1024,   1024,   3072,   5120,   7168},
+    { -8063,  -5759,  -3456,  -1152,   1152,   3456,   5760,   8064},
+    { -8959,  -6399,  -3840,  -1280,   1280,   3840,   6400,   8960},
+    { -9855,  -7039,  -4224,  -1408,   1408,   4224,   7040,   9856},
+    {-10751,  -7679,  -4608,  -1536,   1536,   4608,   7680,  10752},
+    {-11647,  -8319,  -4992,  -1664,   1664,   4992,   8320,  11648},
+    {-12543,  -8959,  -5376,  -1792,   1792,   5376,   8960,  12544},
+    {-13439,  -9599,  -5760,  -1920,   1920,   5760,   9600,  13440},
+    {-14335, -10239,  -6144,  -2048,   2048,   6144,  10240,  14336},
+    {-16127, -11519,  -6912,  -2304,   2304,   6912,  11519,  16127},
+    {-17919, -12799,  -7680,  -2560,   2560,   7680,  12799,  17919},
+    {-19711, -14079,  -8448,  -2816,   2816,   8448,  14079,  19711},
+    {-21503, -15359,  -9216,  -3072,   3072,   9216,  15359,  21503},
+    {-23295, -16639,  -9984,  -3328,   3328,   9984,  16639,  23295},
+    {-25087, -17919, -10752,  -3584,   3584,  10752,  17919,  25087},
+    {-26879, -19199, -11520,  -3840,   3840,  11520,  19199,  26879},
+    {-28671, -20479, -12288,  -4096,   4096,  12288,  20479,  28671}
+};
+
+static void apcm_dequant_add(GetBitContext *gb, int16_t *dst)
+{
+    int i;
+    int maxidx = get_bits(gb, 6);
+    const int16_t *tab = dequant_tab[maxidx];
+    for (i = 0; i < 13; i++)
+        dst[3*i] += tab[get_bits(gb, 3)];
+}
+
+static inline int gsm_mult(int a, int b)
+{
+    return (a * b + (1 << 14)) >> 15;
+}
+
+static const uint16_t long_term_gain_tab[4] = {
+    3277, 11469, 21299, 32767
+};
+
+static void long_term_synth(int16_t *dst, int lag, int gain_idx)
+{
+    int i;
+    const int16_t *src = dst - lag;
+    uint16_t gain = long_term_gain_tab[gain_idx];
+    for (i = 0; i < 40; i++)
+        dst[i] = gsm_mult(gain, src[i]);
+}
+
+static inline int decode_log_area(int coded, int factor, int offset)
+{
+    coded <<= 10;
+    coded -= offset;
+    return gsm_mult(coded, factor) << 1;
+}
+
+static av_noinline int get_rrp(int filtered)
+{
+    int abs = FFABS(filtered);
+    if      (abs < 11059) abs <<= 1;
+    else if (abs < 20070) abs += 11059;
+    else                  abs = (abs >> 2) + 26112;
+    return filtered < 0 ? -abs : abs;
+}
+
+static int filter_value(int in, int rrp[8], int v[9])
+{
+    int i;
+    for (i = 7; i >= 0; i--) {
+        in -= gsm_mult(rrp[i], v[i]);
+        v[i + 1] = v[i] + gsm_mult(rrp[i], in);
+    }
+    v[0] = in;
+    return in;
+}
+
+static void short_term_synth(GSMContext *ctx, int16_t *dst, const int16_t *src)
+{
+    int i;
+    int rrp[8];
+    int *lar = ctx->lar[ctx->lar_idx];
+    int *lar_prev = ctx->lar[ctx->lar_idx ^ 1];
+    for (i = 0; i < 8; i++)
+        rrp[i] = get_rrp((lar_prev[i] >> 2) + (lar_prev[i] >> 1) + (lar[i] >> 2));
+    for (i = 0; i < 13; i++)
+        dst[i] = filter_value(src[i], rrp, ctx->v);
+
+    for (i = 0; i < 8; i++)
+        rrp[i] = get_rrp((lar_prev[i] >> 1) + (lar     [i] >> 1));
+    for (i = 13; i < 27; i++)
+        dst[i] = filter_value(src[i], rrp, ctx->v);
+
+    for (i = 0; i < 8; i++)
+        rrp[i] = get_rrp((lar_prev[i] >> 2) + (lar     [i] >> 1) + (lar[i] >> 2));
+    for (i = 27; i < 40; i++)
+        dst[i] = filter_value(src[i], rrp, ctx->v);
+
+    for (i = 0; i < 8; i++)
+        rrp[i] = get_rrp(lar[i]);
+    for (i = 40; i < 160; i++)
+        dst[i] = filter_value(src[i], rrp, ctx->v);
+
+    ctx->lar_idx ^= 1;
+}
+
+static int postprocess(int16_t *data, int msr)
+{
+    int i;
+    for (i = 0; i < 160; i++) {
+        msr = av_clip_int16(data[i] + gsm_mult(msr, 28180));
+        data[i] = av_clip_int16(msr << 1) & ~7;
+    }
+    return msr;
+}
+
+static int gsm_decode_block(AVCodecContext *avctx, int16_t *samples,
+                            GetBitContext *gb)
+{
+    GSMContext *ctx = avctx->priv_data;
+    int i;
+    int16_t *ref_dst = ctx->ref_buf + 120;
+    int *lar = ctx->lar[ctx->lar_idx];
+    lar[0] = decode_log_area(get_bits(gb, 6), 13107,  1 << 15);
+    lar[1] = decode_log_area(get_bits(gb, 6), 13107,  1 << 15);
+    lar[2] = decode_log_area(get_bits(gb, 5), 13107, (1 << 14) + 2048*2);
+    lar[3] = decode_log_area(get_bits(gb, 5), 13107, (1 << 14) - 2560*2);
+    lar[4] = decode_log_area(get_bits(gb, 4), 19223, (1 << 13) +   94*2);
+    lar[5] = decode_log_area(get_bits(gb, 4), 17476, (1 << 13) - 1792*2);
+    lar[6] = decode_log_area(get_bits(gb, 3), 31454, (1 << 12) -  341*2);
+    lar[7] = decode_log_area(get_bits(gb, 3), 29708, (1 << 12) - 1144*2);
+
+    for (i = 0; i < 4; i++) {
+        int lag      = get_bits(gb, 7);
+        int gain_idx = get_bits(gb, 2);
+        int offset   = get_bits(gb, 2);
+        lag = av_clip(lag, 40, 120);
+        long_term_synth(ref_dst, lag, gain_idx);
+        apcm_dequant_add(gb, ref_dst + offset);
+        ref_dst += 40;
+    }
+    memcpy(ctx->ref_buf, ctx->ref_buf + 160, 120 * sizeof(*ctx->ref_buf));
+    short_term_synth(ctx, samples, ctx->ref_buf + 120);
+    // for optimal speed this could be merged with short_term_synth,
+    // not done yet because it is a bit ugly
+    ctx->msr = postprocess(samples, ctx->msr);
+    return 0;
+}
+
+static int gsm_decode_frame(AVCodecContext *avctx, void *data,
+                            int *data_size, AVPacket *avpkt)
+{
+    int res;
+    GetBitContext gb;
+    const uint8_t *buf = avpkt->data;
+    int buf_size = avpkt->size;
+    int16_t *samples = data;
+    int frame_bytes = 2 * avctx->frame_size;
+
+    if (*data_size < frame_bytes)
+        return -1;
+    *data_size = 0;
+    if(buf_size < avctx->block_align)
+        return AVERROR_INVALIDDATA;
+    init_get_bits(&gb, buf, buf_size * 8);
+
+    switch (avctx->codec_id) {
+    case CODEC_ID_GSM:
+        if (get_bits(&gb, 4) != 0xd)
+            av_log(avctx, AV_LOG_WARNING, "Missing GSM magic!\n");
+        res = gsm_decode_block(avctx, samples, &gb);
+        if (res < 0)
+            return res;
+        break;
+    case CODEC_ID_GSM_MS:
+        res = gsm_decode_block(avctx, samples, &gb);
+        if (res < 0)
+            return res;
+        res = gsm_decode_block(avctx, samples + GSM_FRAME_SIZE, &gb);
+        if (res < 0)
+            return res;
+    }
+    *data_size = frame_bytes;
+    return avctx->block_align;
+}
+
+AVCodec gsm_decoder = {
+    "gsm",
+    AVMEDIA_TYPE_AUDIO,
+    CODEC_ID_GSM,
+    sizeof(GSMContext),
+    gsm_init,
+    NULL,
+    NULL,
+    gsm_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL("GSM"),
+};
+
+AVCodec gsm_ms_decoder = {
+    "gsm_ms",
+    AVMEDIA_TYPE_AUDIO,
+    CODEC_ID_GSM_MS,
+    sizeof(GSMContext),
+    gsm_init,
+    NULL,
+    NULL,
+    gsm_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL("GSM Microsoft variant"),
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -119,7 +119,24 @@
 
     return 0;
 }
+/* MeanX : Ugly patch to detect vo ppacked stuff ... */
+int av_is_voppacked(AVCodecContext *avctx, int *vop_packed, int *gmc, int *qpel)
+{
+    MpegEncContext *s = avctx->priv_data;
+    // set sane default
+    *vop_packed=0;
+    *gmc=0;
+    *qpel=0;
+    if(avctx->codec->id!=CODEC_ID_MPEG4) return 0;
+    	
+  	*vop_packed=(s->divx_packed);
+	*qpel=s->quarter_sample;
+	*gmc=0;	// FIXME
+	return 1;
 
+  }
+  /* MeanX */
+
 av_cold int ff_h263_decode_end(AVCodecContext *avctx)
 {
     MpegEncContext *s = avctx->priv_data;
@@ -414,6 +431,12 @@
     } else {
         ret = h263_decode_picture_header(s);
     }
+	//MEANX we need to do it here also for quicktime file / ctts atom 
+        // we need the correct frame type, and qt file may contain 
+        // vop not coded frame.
+        pict->pict_type=s->current_picture.pict_type= s->pict_type;
+        pict->key_frame=s->current_picture.key_frame= s->pict_type == FF_I_TYPE;
+        //MEANX
 
     if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_size);
 
@@ -709,6 +732,14 @@
 
 assert(s->current_picture.pict_type == s->current_picture_ptr->pict_type);
 assert(s->current_picture.pict_type == s->pict_type);
+/* MEANX */
+  if(s->current_picture_ptr)
+      s->current_picture_ptr->opaque=pict->opaque;
+/* MEANX */
+
+
+
+
     if (s->pict_type == FF_B_TYPE || s->low_delay) {
         *pict= *(AVFrame*)s->current_picture_ptr;
     } else if (s->last_picture_ptr != NULL) {

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -316,5 +316,7 @@
 
     if (ARCH_ARM) ff_h264dsp_init_arm(c);
     if (HAVE_ALTIVEC) ff_h264dsp_init_ppc(c);
+#if CONFIG_H264DSP //MEANX
     if (HAVE_MMX) ff_h264dsp_init_x86(c);
+#endif
 }

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/inverse.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/inverse.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/inverse.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1 @@
+#include "libavutil/inverse.c"

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -1948,7 +1948,12 @@
         ff_er_frame_end(s);
 
         MPV_frame_end(s);
+/* MEANX */
+  if(s->current_picture_ptr)
+      s->current_picture_ptr->opaque=pict->opaque;
+/* MEANX */
 
+
         if (s->pict_type == FF_B_TYPE || s->low_delay) {
             *pict= *(AVFrame*)s->current_picture_ptr;
             ff_print_debug_info(s, pict);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -127,10 +127,19 @@
             s->frame_rate_index= i;
         }
     }
+ /* MEANX 
+
     if(dmin)
         return -1;
     else
         return 0;
+  */
+        if(dmin>4)
+   {
+        av_log(0,AV_LOG_ERROR,"We did a roundup ! Expect async!\n");
+   }
+        return 0; //MEANX
+
 }
 
 static av_cold int encode_init(AVCodecContext *avctx)
@@ -209,6 +218,7 @@
             put_sbits(&s->pb, 12, s->width );
             put_sbits(&s->pb, 12, s->height);
 
+#if 0 //MEANX
             for(i=1; i<15; i++){
                 float error= aspect_ratio;
                 if(s->codec_id == CODEC_ID_MPEG1VIDEO || i <=1)
@@ -223,20 +233,44 @@
                     s->aspect_ratio_info= i;
                 }
             }
+#endif // MEANX
+            //MEANX put_bits(&s->pb, 4, s->aspect_ratio_info);
+            //MEANX put_bits(&s->pb, 4, s->frame_rate_index);
+ // MEANX 4:3
+  if(s->avctx->sample_aspect_ratio.num==16 && s->avctx->sample_aspect_ratio.den==9)
+            {
+                //printf("FFmpeg : Wide\n");
+                put_bits(&s->pb,4,3); //16:9
+            }
+            else        //4:3
+            {
+              if(s->codec_id == CODEC_ID_MPEG2VIDEO)
+                put_bits(&s->pb, 4, 2);
+              else
+                put_bits(&s->pb, 4, 12); // MPEG1
+            }
+// /MEANX
 
-            put_bits(&s->pb, 4, s->aspect_ratio_info);
-            put_bits(&s->pb, 4, s->frame_rate_index);
+// //MEANX PULLDOWN            put_bits(&s->pb, 4, s->frame_rate_index);
+if((s->flags2 & CODEC_FLAG2_32_PULLDOWN) && (s->codec_id == CODEC_ID_MPEG2VIDEO))
+            {           
+                put_bits(&s->pb, 4,4);
+            }
+            else
+            {                                  
+                put_bits(&s->pb, 4, s->frame_rate_index);
+            } //MEANX pulldown
 
-            if(s->avctx->rc_max_rate){
-                v = (s->avctx->rc_max_rate + 399) / 400;
+            if(s->avctx->rc_max_rate_header){ //MEANX we use header
+                v = (s->avctx->rc_max_rate_header + 399) / 400;
                 if (v > 0x3ffff && s->codec_id == CODEC_ID_MPEG1VIDEO)
                     v = 0x3ffff;
             }else{
                 v= 0x3FFFF;
             }
 
-            if(s->avctx->rc_buffer_size)
-                vbv_buffer_size = s->avctx->rc_buffer_size;
+            if(s->avctx->rc_buffer_size_header) // MEANX we use header
+                vbv_buffer_size = s->avctx->rc_buffer_size_header;
             else
                 /* VBV calculation: Scaled so that a VCD has the proper VBV size of 40 kilobytes */
                 vbv_buffer_size = (( 20 * s->bit_rate) / (1151929 / 2)) * 8 * 1024;
@@ -269,8 +303,17 @@
 
                 put_bits(&s->pb, 3, s->avctx->profile); //profile
                 put_bits(&s->pb, 4, s->avctx->level); //level
+   // MEANX pulldown put_bits(&s->pb, 1, s->progressive_sequence);
+  // MEANX Pulldown
+ if(s->flags2 & CODEC_FLAG2_32_PULLDOWN) //MEANX
+                        put_bits(&s->pb, 1, 0);
+                else
+                        put_bits(&s->pb, 1, s->progressive_sequence);
 
-                put_bits(&s->pb, 1, s->progressive_sequence);
+
+// /MEANX
+
+
                 put_bits(&s->pb, 2, s->chroma_format);
                 put_bits(&s->pb, 2, s->width >>12);
                 put_bits(&s->pb, 2, s->height>>12);
@@ -339,6 +382,8 @@
 
 void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
 {
+	int tff,rff; //MEANX
+
     mpeg1_encode_sequence_header(s);
 
     /* mpeg1 picture header */
@@ -375,6 +420,49 @@
 
     s->frame_pred_frame_dct = 1;
     if(s->codec_id == CODEC_ID_MPEG2VIDEO){
+ /* MEANX -- Pulldown */
+        if(s->flags2 & CODEC_FLAG2_32_PULLDOWN)
+        {
+        
+                switch((s->picture_number - 
+                          s->gop_picture_number)&3)
+                {
+                        case 0:
+                        default:
+                                rff=1;
+                                tff=1;
+                                break;
+                        case 1:
+                                rff=0;
+                                tff=0;
+                                break;
+                        case 2:
+                                rff=1;
+                                tff=0;
+                                break;
+                        case 3:
+                                rff=0;
+                                tff=1;
+                                break;
+                }               
+           }
+        else
+        {
+                if (s->progressive_sequence) 
+                {
+                        tff=0; /* no repeat */
+                } else 
+                {
+                        tff= s->current_picture_ptr->top_field_first;
+                }
+                rff=s->repeat_first_field;
+        
+        }
+
+//               /MEANX pulldown
+
+
+
         put_header(s, EXT_START_CODE);
         put_bits(&s->pb, 4, 8); //pic ext
         if (s->pict_type == FF_P_TYPE || s->pict_type == FF_B_TYPE) {
@@ -393,11 +481,16 @@
 
         assert(s->picture_structure == PICT_FRAME);
         put_bits(&s->pb, 2, s->picture_structure);
+#if 0 //MEANX
+
         if (s->progressive_sequence) {
             put_bits(&s->pb, 1, 0); /* no repeat */
         } else {
             put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first);
         }
+#endif
+         put_bits(&s->pb, 1, tff);  //MEANX PULLDOWN
+
         /* XXX: optimize the generation of this flag with entropy
            measures */
         s->frame_pred_frame_dct = s->progressive_sequence;
@@ -407,7 +500,10 @@
         put_bits(&s->pb, 1, s->q_scale_type);
         put_bits(&s->pb, 1, s->intra_vlc_format);
         put_bits(&s->pb, 1, s->alternate_scan);
-        put_bits(&s->pb, 1, s->repeat_first_field);
+ // MEANX put_bits(&s->pb, 1, s->repeat_first_field);
+	put_bits(&s->pb, 1, rff);
+      // /MEANX
+
         s->progressive_frame = s->progressive_sequence;
         put_bits(&s->pb, 1, s->chroma_format == CHROMA_420 ? s->progressive_frame : 0); /* chroma_420_type */
         put_bits(&s->pb, 1, s->progressive_frame);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -652,7 +652,11 @@
     FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
 
     s->parse_context.state= -1;
-    if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){
+ //MEANX: Allocate them always, as they may be free when we decode 1st image
+
+    // MEANXif((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){
+if(1){ // MEANX
+
        s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
        s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
        s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -367,12 +367,14 @@
 
         av_log(avctx, AV_LOG_INFO, "Warning vbv_delay will be set to 0xFFFF (=VBR) as the specified vbv buffer is too large for the given bitrate!\n");
     }
+#if 0 //MEANX
 
     if((s->flags & CODEC_FLAG_4MV) && s->codec_id != CODEC_ID_MPEG4
        && s->codec_id != CODEC_ID_H263 && s->codec_id != CODEC_ID_H263P && s->codec_id != CODEC_ID_FLV1){
         av_log(avctx, AV_LOG_ERROR, "4MV not supported by codec\n");
         return -1;
     }
+#endif
 
     if(s->obmc && s->avctx->mb_decision != FF_MB_DECISION_SIMPLE){
         av_log(avctx, AV_LOG_ERROR, "OBMC is only supported with simple mb decision\n");
@@ -413,10 +415,12 @@
         return -1;
     }
 
+#if 0 //MEANX
     if(s->mpeg_quant && s->codec_id != CODEC_ID_MPEG4){ //FIXME mpeg2 uses that too
         av_log(avctx, AV_LOG_ERROR, "mpeg2 style quantization not supported by codec\n");
         return -1;
     }
+#endif
 
     if((s->flags & CODEC_FLAG_CBP_RD) && !avctx->trellis){
         av_log(avctx, AV_LOG_ERROR, "CBP RD needs trellis quant\n");

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pictordec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pictordec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pictordec.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,250 @@
+/*
+ * Pictor/PC Paint decoder
+ * Copyright (c) 2010 Peter Ross <pross at xvid.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Pictor/PC Paint decoder
+ */
+
+#include "avcodec.h"
+#include "bytestream.h"
+#include "cga_data.h"
+
+typedef struct PicContext {
+    AVFrame frame;
+    int width, height;
+    int nb_planes;
+} PicContext;
+
+static void picmemset_8bpp(PicContext *s, int value, int run, int *x, int *y)
+{
+    while (run > 0) {
+        uint8_t *d = s->frame.data[0] + *y * s->frame.linesize[0];
+        if (*x + run >= s->width) {
+            int n = s->width - *x;
+            memset(d + *x, value, n);
+            run -= n;
+            *x = 0;
+            *y -= 1;
+            if (*y < 0)
+                break;
+        } else {
+            memset(d + *x, value, run);
+            *x += run;
+            break;
+        }
+    }
+}
+
+static void picmemset(PicContext *s, int value, int run, int *x, int *y, int *plane, int bits_per_plane)
+{
+    uint8_t *d;
+    int shift = *plane * bits_per_plane;
+    int mask  = ((1 << bits_per_plane) - 1) << shift;
+    value   <<= shift;
+
+    while (run > 0) {
+        int j;
+        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {
+            d = s->frame.data[0] + *y * s->frame.linesize[0];
+            d[*x] |= (value >> j) & mask;
+            *x += 1;
+            if (*x == s->width) {
+                *y -= 1;
+                *x = 0;
+                if (*y < 0) {
+                   *y = s->height - 1;
+                   *plane += 1;
+                   value <<= bits_per_plane;
+                   mask  <<= bits_per_plane;
+                   if (*plane >= s->nb_planes)
+                       break;
+                }
+            }
+        }
+        run--;
+    }
+}
+
+static const uint8_t cga_mode45_index[6][4] = {
+    [0] = { 0, 3,  5,   7 }, // mode4, palette#1, low intensity
+    [1] = { 0, 2,  4,   6 }, // mode4, palette#2, low intensity
+    [2] = { 0, 3,  4,   7 }, // mode5, low intensity
+    [3] = { 0, 11, 13, 15 }, // mode4, palette#1, high intensity
+    [4] = { 0, 10, 12, 14 }, // mode4, palette#2, high intensity
+    [5] = { 0, 11, 12, 15 }, // mode5, high intensity
+};
+
+static int decode_frame(AVCodecContext *avctx,
+                        void *data, int *data_size,
+                        AVPacket *avpkt)
+{
+    PicContext *s = avctx->priv_data;
+    int buf_size = avpkt->size;
+    const uint8_t *buf = avpkt->data;
+    const uint8_t *buf_end = avpkt->data + buf_size;
+    uint32_t *palette;
+    int bits_per_plane, bpp, etype, esize, npal;
+    int i, x, y, plane;
+
+    if (buf_size < 11)
+        return AVERROR_INVALIDDATA;
+
+    if (bytestream_get_le16(&buf) != 0x1234)
+        return AVERROR_INVALIDDATA;
+    s->width  = bytestream_get_le16(&buf);
+    s->height = bytestream_get_le16(&buf);
+    buf += 4;
+    bits_per_plane    = *buf & 0xF;
+    s->nb_planes      = (*buf++ >> 4) + 1;
+    bpp               = s->nb_planes ? bits_per_plane*s->nb_planes : bits_per_plane;
+    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {
+        av_log_ask_for_sample(s, "unsupported bit depth\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (*buf == 0xFF) {
+        buf += 2;
+        etype  = bytestream_get_le16(&buf);
+        esize  = bytestream_get_le16(&buf);
+        if (buf_end - buf < esize)
+            return AVERROR_INVALIDDATA;
+    } else {
+        etype = -1;
+        esize = 0;
+    }
+
+    avctx->pix_fmt = PIX_FMT_PAL8;
+
+    if (s->width != avctx->width && s->height != avctx->height) {
+        if (avcodec_check_dimensions(avctx, s->width, s->height) < 0)
+            return -1;
+        avcodec_set_dimensions(avctx, s->width, s->height);
+        if (s->frame.data[0])
+            avctx->release_buffer(avctx, &s->frame);
+    }
+
+    if (avctx->get_buffer(avctx, &s->frame) < 0){
+        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
+        return -1;
+    }
+    memset(s->frame.data[0], 0, s->height * s->frame.linesize[0]);
+    s->frame.pict_type           = FF_I_TYPE;
+    s->frame.palette_has_changed = 1;
+
+    palette = (uint32_t*)s->frame.data[1];
+    if (etype == 1 && esize > 1 && *buf < 6) {
+        int idx = *buf;
+        npal = 4;
+        for (i = 0; i < npal; i++)
+            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];
+    } else if (etype == 2) {
+        npal = FFMIN(esize, 16);
+        for (i = 0; i < npal; i++)
+            palette[i] = ff_cga_palette[ FFMIN(buf[i], 16)];
+    } else if (etype == 3) {
+        npal = FFMIN(esize, 16);
+        for (i = 0; i < npal; i++)
+            palette[i] = ff_ega_palette[ FFMIN(buf[i], 63)];
+    } else if (etype == 4 || etype == 5) {
+        npal = FFMIN(esize / 3, 256);
+        for (i = 0; i < npal; i++)
+            palette[i] = AV_RB24(buf + i*3) << 2;
+    } else {
+        if (bpp == 1) {
+            npal = 2;
+            palette[0] = 0x000000;
+            palette[1] = 0xFFFFFF;
+        } else if (bpp == 2) {
+            npal = 4;
+            for (i = 0; i < npal; i++)
+                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];
+        } else {
+            npal = 16;
+            memcpy(palette, ff_cga_palette, npal * 4);
+        }
+    }
+    // fill remaining palette entries
+    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);
+    buf += esize;
+
+
+    x = 0;
+    y = s->height - 1;
+    plane = 0;
+    if (bytestream_get_le16(&buf)) {
+        while (buf_end - buf >= 6) {
+            const uint8_t *buf_pend = buf + FFMIN(AV_RL16(buf), buf_end - buf);
+            //ignore uncompressed block size reported at buf[2]
+            int marker = buf[4];
+            buf += 5;
+
+            while (plane < s->nb_planes && buf_pend - buf >= 1) {
+                int run = 1;
+                int val = *buf++;
+                if (val == marker) {
+                    run = *buf++;
+                    if (run == 0)
+                        run = bytestream_get_le16(&buf);
+                    val = *buf++;
+                }
+                if (buf > buf_end)
+                    break;
+
+                if (bits_per_plane == 8) {
+                    picmemset_8bpp(s, val, run, &x, &y);
+                    if (y < 0)
+                        break;
+                } else {
+                    picmemset(s, val, run, &x, &y, &plane, bits_per_plane);
+                }
+            }
+        }
+    } else {
+        av_log_ask_for_sample(s, "uncompressed image\n");
+        return buf_size;
+    }
+
+    *data_size = sizeof(AVFrame);
+    *(AVFrame*)data = s->frame;
+    return buf_size;
+}
+
+static av_cold int decode_end(AVCodecContext *avctx)
+{
+    PicContext *s = avctx->priv_data;
+    if (s->frame.data[0])
+        avctx->release_buffer(avctx, &s->frame);
+    return 0;
+}
+
+AVCodec pictor_decoder = {
+    "pictor",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_PICTOR,
+    sizeof(PicContext),
+    NULL,
+    NULL,
+    decode_end,
+    decode_frame,
+    CODEC_CAP_DR1,
+    .long_name = NULL_IF_CONFIG_SMALL("Pictor/PC Paint"),
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/png.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/png.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/png.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -20,7 +20,7 @@
  */
 #include "avcodec.h"
 #include "bytestream.h"
-#include "png.h"
+#include "ffpng.h"
 
 const uint8_t ff_pngsig[8] = {137, 80, 78, 71, 13, 10, 26, 10};
 const uint8_t ff_mngsig[8] = {138, 77, 78, 71, 13, 10, 26, 10};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -20,7 +20,7 @@
  */
 #include "avcodec.h"
 #include "bytestream.h"
-#include "png.h"
+#include "ffpng.h"
 #include "dsputil.h"
 
 /* TODO:

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -21,7 +21,7 @@
 #include "avcodec.h"
 #include "bytestream.h"
 #include "dsputil.h"
-#include "png.h"
+#include "ffpng.h"
 
 /* TODO:
  * - add 2, 4 and 16 bit depth support

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144dec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144dec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144dec.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,128 @@
+/*
+ * Real Audio 1.0 (14.4K)
+ *
+ * Copyright (c) 2008 Vitor Sessak
+ * Copyright (c) 2003 Nick Kurshev
+ *     Based on public domain decoder at http://www.honeypot.net/audio
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/intmath.h"
+#include "avcodec.h"
+#include "get_bits.h"
+#include "ra144.h"
+
+
+static av_cold int ra144_decode_init(AVCodecContext * avctx)
+{
+    RA144Context *ractx = avctx->priv_data;
+
+    ractx->avctx = avctx;
+
+    ractx->lpc_coef[0] = ractx->lpc_tables[0];
+    ractx->lpc_coef[1] = ractx->lpc_tables[1];
+
+    avctx->sample_fmt = SAMPLE_FMT_S16;
+    return 0;
+}
+
+static void do_output_subblock(RA144Context *ractx, const uint16_t  *lpc_coefs,
+                               int gval, GetBitContext *gb)
+{
+    int cba_idx = get_bits(gb, 7); // index of the adaptive CB, 0 if none
+    int gain    = get_bits(gb, 8);
+    int cb1_idx = get_bits(gb, 7);
+    int cb2_idx = get_bits(gb, 7);
+
+    ff_subblock_synthesis(ractx, lpc_coefs, cba_idx, cb1_idx, cb2_idx, gval,
+                          gain);
+}
+
+/** Uncompress one block (20 bytes -> 160*2 bytes). */
+static int ra144_decode_frame(AVCodecContext * avctx, void *vdata,
+                              int *data_size, AVPacket *avpkt)
+{
+    const uint8_t *buf = avpkt->data;
+    int buf_size = avpkt->size;
+    static const uint8_t sizes[10] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2};
+    unsigned int refl_rms[4];    // RMS of the reflection coefficients
+    uint16_t block_coefs[4][10]; // LPC coefficients of each sub-block
+    unsigned int lpc_refl[10];   // LPC reflection coefficients of the frame
+    int i, j;
+    int16_t *data = vdata;
+    unsigned int energy;
+
+    RA144Context *ractx = avctx->priv_data;
+    GetBitContext gb;
+
+    if (*data_size < 2*160)
+        return -1;
+
+    if(buf_size < 20) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Frame too small (%d bytes). Truncated file?\n", buf_size);
+        *data_size = 0;
+        return buf_size;
+    }
+    init_get_bits(&gb, buf, 20 * 8);
+
+    for (i=0; i<10; i++)
+        lpc_refl[i] = ff_lpc_refl_cb[i][get_bits(&gb, sizes[i])];
+
+    ff_eval_coefs(ractx->lpc_coef[0], lpc_refl);
+    ractx->lpc_refl_rms[0] = ff_rms(lpc_refl);
+
+    energy = ff_energy_tab[get_bits(&gb, 5)];
+
+    refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx->old_energy);
+    refl_rms[1] = ff_interp(ractx, block_coefs[1], 2,
+                            energy <= ractx->old_energy,
+                            ff_t_sqrt(energy*ractx->old_energy) >> 12);
+    refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy);
+    refl_rms[3] = ff_rescale_rms(ractx->lpc_refl_rms[0], energy);
+
+    ff_int_to_int16(block_coefs[3], ractx->lpc_coef[0]);
+
+    for (i=0; i < 4; i++) {
+        do_output_subblock(ractx, block_coefs[i], refl_rms[i], &gb);
+
+        for (j=0; j < BLOCKSIZE; j++)
+            *data++ = av_clip_int16(ractx->curr_sblock[j + 10] << 2);
+    }
+
+    ractx->old_energy = energy;
+    ractx->lpc_refl_rms[1] = ractx->lpc_refl_rms[0];
+
+    FFSWAP(unsigned int *, ractx->lpc_coef[0], ractx->lpc_coef[1]);
+
+    *data_size = 2*160;
+    return 20;
+}
+
+AVCodec ra_144_decoder =
+{
+    "real_144",
+    AVMEDIA_TYPE_AUDIO,
+    CODEC_ID_RA_144,
+    sizeof(RA144Context),
+    ra144_decode_init,
+    NULL,
+    NULL,
+    ra144_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL("RealAudio 1.0 (14.4K)"),
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144enc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144enc.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144enc.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,511 @@
+/*
+ * Real Audio 1.0 (14.4K) encoder
+ * Copyright (c) 2010 Francesco Lavra <francescolavra at interfree.it>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Real Audio 1.0 (14.4K) encoder
+ * @author Francesco Lavra <francescolavra at interfree.it>
+ */
+
+#include <float.h>
+
+#include "avcodec.h"
+#include "put_bits.h"
+#include "lpc.h"
+#include "celp_filters.h"
+#include "ra144.h"
+
+
+static av_cold int ra144_encode_init(AVCodecContext * avctx)
+{
+    RA144Context *ractx;
+
+    if (avctx->sample_fmt != SAMPLE_FMT_S16) {
+        av_log(avctx, AV_LOG_ERROR, "invalid sample format\n");
+        return -1;
+    }
+    if (avctx->channels != 1) {
+        av_log(avctx, AV_LOG_ERROR, "invalid number of channels: %d\n",
+               avctx->channels);
+        return -1;
+    }
+    avctx->frame_size = NBLOCKS * BLOCKSIZE;
+    avctx->bit_rate = 8000;
+    ractx = avctx->priv_data;
+    ractx->lpc_coef[0] = ractx->lpc_tables[0];
+    ractx->lpc_coef[1] = ractx->lpc_tables[1];
+    ractx->avctx = avctx;
+    dsputil_init(&ractx->dsp, avctx);
+    return 0;
+}
+
+
+/**
+ * Quantize a value by searching a sorted table for the element with the
+ * nearest value
+ *
+ * @param value value to quantize
+ * @param table array containing the quantization table
+ * @param size size of the quantization table
+ * @return index of the quantization table corresponding to the element with the
+ *         nearest value
+ */
+static int quantize(int value, const int16_t *table, unsigned int size)
+{
+    unsigned int low = 0, high = size - 1;
+
+    while (1) {
+        int index = (low + high) >> 1;
+        int error = table[index] - value;
+
+        if (index == low)
+            return table[high] + error > value ? low : high;
+        if (error > 0) {
+            high = index;
+        } else {
+            low = index;
+        }
+    }
+}
+
+
+/**
+ * Orthogonalize a vector to another vector
+ *
+ * @param v vector to orthogonalize
+ * @param u vector against which orthogonalization is performed
+ */
+static void orthogonalize(float *v, const float *u)
+{
+    int i;
+    float num = 0, den = 0;
+
+    for (i = 0; i < BLOCKSIZE; i++) {
+        num += v[i] * u[i];
+        den += u[i] * u[i];
+    }
+    num /= den;
+    for (i = 0; i < BLOCKSIZE; i++)
+        v[i] -= num * u[i];
+}
+
+
+/**
+ * Calculate match score and gain of an LPC-filtered vector with respect to
+ * input data, possibly othogonalizing it to up to 2 other vectors
+ *
+ * @param work array used to calculate the filtered vector
+ * @param coefs coefficients of the LPC filter
+ * @param vect original vector
+ * @param ortho1 first vector against which orthogonalization is performed
+ * @param ortho2 second vector against which orthogonalization is performed
+ * @param data input data
+ * @param score pointer to variable where match score is returned
+ * @param gain pointer to variable where gain is returned
+ */
+static void get_match_score(float *work, const float *coefs, float *vect,
+                            const float *ortho1, const float *ortho2,
+                            const float *data, float *score, float *gain)
+{
+    float c, g;
+    int i;
+
+    ff_celp_lp_synthesis_filterf(work, coefs, vect, BLOCKSIZE, LPC_ORDER);
+    if (ortho1)
+        orthogonalize(work, ortho1);
+    if (ortho2)
+        orthogonalize(work, ortho2);
+    c = g = 0;
+    for (i = 0; i < BLOCKSIZE; i++) {
+        g += work[i] * work[i];
+        c += data[i] * work[i];
+    }
+    if (c <= 0) {
+        *score = 0;
+        return;
+    }
+    *gain = c / g;
+    *score = *gain * c;
+}
+
+
+/**
+ * Create a vector from the adaptive codebook at a given lag value
+ *
+ * @param vect array where vector is stored
+ * @param cb adaptive codebook
+ * @param lag lag value
+ */
+static void create_adapt_vect(float *vect, const int16_t *cb, int lag)
+{
+    int i;
+
+    cb += BUFFERSIZE - lag;
+    for (i = 0; i < FFMIN(BLOCKSIZE, lag); i++)
+        vect[i] = cb[i];
+    if (lag < BLOCKSIZE)
+        for (i = 0; i < BLOCKSIZE - lag; i++)
+            vect[lag + i] = cb[i];
+}
+
+
+/**
+ * Search the adaptive codebook for the best entry and gain and remove its
+ * contribution from input data
+ *
+ * @param adapt_cb array from which the adaptive codebook is extracted
+ * @param work array used to calculate LPC-filtered vectors
+ * @param coefs coefficients of the LPC filter
+ * @param data input data
+ * @return index of the best entry of the adaptive codebook
+ */
+static int adaptive_cb_search(const int16_t *adapt_cb, float *work,
+                              const float *coefs, float *data)
+{
+    int i, best_vect;
+    float score, gain, best_score, best_gain;
+    float exc[BLOCKSIZE];
+
+    gain = best_score = 0;
+    for (i = BLOCKSIZE / 2; i <= BUFFERSIZE; i++) {
+        create_adapt_vect(exc, adapt_cb, i);
+        get_match_score(work, coefs, exc, NULL, NULL, data, &score, &gain);
+        if (score > best_score) {
+            best_score = score;
+            best_vect = i;
+            best_gain = gain;
+        }
+    }
+    if (!best_score)
+        return 0;
+
+    /**
+     * Re-calculate the filtered vector from the vector with maximum match score
+     * and remove its contribution from input data.
+     */
+    create_adapt_vect(exc, adapt_cb, best_vect);
+    ff_celp_lp_synthesis_filterf(work, coefs, exc, BLOCKSIZE, LPC_ORDER);
+    for (i = 0; i < BLOCKSIZE; i++)
+        data[i] -= best_gain * work[i];
+    return (best_vect - BLOCKSIZE / 2 + 1);
+}
+
+
+/**
+ * Find the best vector of a fixed codebook by applying an LPC filter to
+ * codebook entries, possibly othogonalizing them to up to 2 other vectors and
+ * matching the results with input data
+ *
+ * @param work array used to calculate the filtered vectors
+ * @param coefs coefficients of the LPC filter
+ * @param cb fixed codebook
+ * @param ortho1 first vector against which orthogonalization is performed
+ * @param ortho2 second vector against which orthogonalization is performed
+ * @param data input data
+ * @param idx pointer to variable where the index of the best codebook entry is
+ *        returned
+ * @param gain pointer to variable where the gain of the best codebook entry is
+ *        returned
+ */
+static void find_best_vect(float *work, const float *coefs,
+                           const int8_t cb[][BLOCKSIZE], const float *ortho1,
+                           const float *ortho2, float *data, int *idx,
+                           float *gain)
+{
+    int i, j;
+    float g, score, best_score;
+    float vect[BLOCKSIZE];
+
+    *idx = *gain = best_score = 0;
+    for (i = 0; i < FIXED_CB_SIZE; i++) {
+        for (j = 0; j < BLOCKSIZE; j++)
+            vect[j] = cb[i][j];
+        get_match_score(work, coefs, vect, ortho1, ortho2, data, &score, &g);
+        if (score > best_score) {
+            best_score = score;
+            *idx = i;
+            *gain = g;
+        }
+    }
+}
+
+
+/**
+ * Search the two fixed codebooks for the best entry and gain
+ *
+ * @param work array used to calculate LPC-filtered vectors
+ * @param coefs coefficients of the LPC filter
+ * @param data input data
+ * @param cba_idx index of the best entry of the adaptive codebook
+ * @param cb1_idx pointer to variable where the index of the best entry of the
+ *        first fixed codebook is returned
+ * @param cb2_idx pointer to variable where the index of the best entry of the
+ *        second fixed codebook is returned
+ */
+static void fixed_cb_search(float *work, const float *coefs, float *data,
+                            int cba_idx, int *cb1_idx, int *cb2_idx)
+{
+    int i, ortho_cb1;
+    float gain;
+    float cba_vect[BLOCKSIZE], cb1_vect[BLOCKSIZE];
+    float vect[BLOCKSIZE];
+
+    /**
+     * The filtered vector from the adaptive codebook can be retrieved from
+     * work, because this function is called just after adaptive_cb_search().
+     */
+    if (cba_idx)
+        memcpy(cba_vect, work, sizeof(cba_vect));
+
+    find_best_vect(work, coefs, ff_cb1_vects, cba_idx ? cba_vect : NULL, NULL,
+                   data, cb1_idx, &gain);
+
+    /**
+     * Re-calculate the filtered vector from the vector with maximum match score
+     * and remove its contribution from input data.
+     */
+    if (gain) {
+        for (i = 0; i < BLOCKSIZE; i++)
+            vect[i] = ff_cb1_vects[*cb1_idx][i];
+        ff_celp_lp_synthesis_filterf(work, coefs, vect, BLOCKSIZE, LPC_ORDER);
+        if (cba_idx)
+            orthogonalize(work, cba_vect);
+        for (i = 0; i < BLOCKSIZE; i++)
+            data[i] -= gain * work[i];
+        memcpy(cb1_vect, work, sizeof(cb1_vect));
+        ortho_cb1 = 1;
+    } else
+        ortho_cb1 = 0;
+
+    find_best_vect(work, coefs, ff_cb2_vects, cba_idx ? cba_vect : NULL,
+                   ortho_cb1 ? cb1_vect : NULL, data, cb2_idx, &gain);
+}
+
+
+/**
+ * Encode a subblock of the current frame
+ *
+ * @param ractx encoder context
+ * @param sblock_data input data of the subblock
+ * @param lpc_coefs coefficients of the LPC filter
+ * @param rms RMS of the reflection coefficients
+ * @param pb pointer to PutBitContext of the current frame
+ */
+static void ra144_encode_subblock(RA144Context *ractx,
+                                  const int16_t *sblock_data,
+                                  const int16_t *lpc_coefs, unsigned int rms,
+                                  PutBitContext *pb)
+{
+    float data[BLOCKSIZE], work[LPC_ORDER + BLOCKSIZE];
+    float coefs[LPC_ORDER];
+    float zero[BLOCKSIZE], cba[BLOCKSIZE], cb1[BLOCKSIZE], cb2[BLOCKSIZE];
+    int16_t cba_vect[BLOCKSIZE];
+    int cba_idx, cb1_idx, cb2_idx, gain;
+    int i, n, m[3];
+    float g[3];
+    float error, best_error;
+
+    for (i = 0; i < LPC_ORDER; i++) {
+        work[i] = ractx->curr_sblock[BLOCKSIZE + i];
+        coefs[i] = lpc_coefs[i] * (1/4096.0);
+    }
+
+    /**
+     * Calculate the zero-input response of the LPC filter and subtract it from
+     * input data.
+     */
+    memset(data, 0, sizeof(data));
+    ff_celp_lp_synthesis_filterf(work + LPC_ORDER, coefs, data, BLOCKSIZE,
+                                 LPC_ORDER);
+    for (i = 0; i < BLOCKSIZE; i++) {
+        zero[i] = work[LPC_ORDER + i];
+        data[i] = sblock_data[i] - zero[i];
+    }
+
+    /**
+     * Codebook search is performed without taking into account the contribution
+     * of the previous subblock, since it has been just subtracted from input
+     * data.
+     */
+    memset(work, 0, LPC_ORDER * sizeof(*work));
+
+    cba_idx = adaptive_cb_search(ractx->adapt_cb, work + LPC_ORDER, coefs,
+                                 data);
+    if (cba_idx) {
+        /**
+         * The filtered vector from the adaptive codebook can be retrieved from
+         * work, see implementation of adaptive_cb_search().
+         */
+        memcpy(cba, work + LPC_ORDER, sizeof(cba));
+
+        ff_copy_and_dup(cba_vect, ractx->adapt_cb, cba_idx + BLOCKSIZE / 2 - 1);
+        m[0] = (ff_irms(cba_vect) * rms) >> 12;
+    }
+    fixed_cb_search(work + LPC_ORDER, coefs, data, cba_idx, &cb1_idx, &cb2_idx);
+    for (i = 0; i < BLOCKSIZE; i++) {
+        cb1[i] = ff_cb1_vects[cb1_idx][i];
+        cb2[i] = ff_cb2_vects[cb2_idx][i];
+    }
+    ff_celp_lp_synthesis_filterf(work + LPC_ORDER, coefs, cb1, BLOCKSIZE,
+                                 LPC_ORDER);
+    memcpy(cb1, work + LPC_ORDER, sizeof(cb1));
+    m[1] = (ff_cb1_base[cb1_idx] * rms) >> 8;
+    ff_celp_lp_synthesis_filterf(work + LPC_ORDER, coefs, cb2, BLOCKSIZE,
+                                 LPC_ORDER);
+    memcpy(cb2, work + LPC_ORDER, sizeof(cb2));
+    m[2] = (ff_cb2_base[cb2_idx] * rms) >> 8;
+    best_error = FLT_MAX;
+    gain = 0;
+    for (n = 0; n < 256; n++) {
+        g[1] = ((ff_gain_val_tab[n][1] * m[1]) >> ff_gain_exp_tab[n]) *
+               (1/4096.0);
+        g[2] = ((ff_gain_val_tab[n][2] * m[2]) >> ff_gain_exp_tab[n]) *
+               (1/4096.0);
+        error = 0;
+        if (cba_idx) {
+            g[0] = ((ff_gain_val_tab[n][0] * m[0]) >> ff_gain_exp_tab[n]) *
+                   (1/4096.0);
+            for (i = 0; i < BLOCKSIZE; i++) {
+                data[i] = zero[i] + g[0] * cba[i] + g[1] * cb1[i] +
+                          g[2] * cb2[i];
+                error += (data[i] - sblock_data[i]) *
+                         (data[i] - sblock_data[i]);
+            }
+        } else {
+            for (i = 0; i < BLOCKSIZE; i++) {
+                data[i] = zero[i] + g[1] * cb1[i] + g[2] * cb2[i];
+                error += (data[i] - sblock_data[i]) *
+                         (data[i] - sblock_data[i]);
+            }
+        }
+        if (error < best_error) {
+            best_error = error;
+            gain = n;
+        }
+    }
+    put_bits(pb, 7, cba_idx);
+    put_bits(pb, 8, gain);
+    put_bits(pb, 7, cb1_idx);
+    put_bits(pb, 7, cb2_idx);
+    ff_subblock_synthesis(ractx, lpc_coefs, cba_idx, cb1_idx, cb2_idx, rms,
+                          gain);
+}
+
+
+static int ra144_encode_frame(AVCodecContext *avctx, uint8_t *frame,
+                              int buf_size, void *data)
+{
+    static const uint8_t sizes[LPC_ORDER] = {64, 32, 32, 16, 16, 8, 8, 8, 8, 4};
+    static const uint8_t bit_sizes[LPC_ORDER] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2};
+    RA144Context *ractx;
+    PutBitContext pb;
+    int32_t lpc_data[NBLOCKS * BLOCKSIZE];
+    int32_t lpc_coefs[LPC_ORDER][MAX_LPC_ORDER];
+    int shift[LPC_ORDER];
+    int16_t block_coefs[NBLOCKS][LPC_ORDER];
+    int lpc_refl[LPC_ORDER];    /**< reflection coefficients of the frame */
+    unsigned int refl_rms[NBLOCKS]; /**< RMS of the reflection coefficients */
+    int energy = 0;
+    int i, idx;
+
+    if (buf_size < FRAMESIZE) {
+        av_log(avctx, AV_LOG_ERROR, "output buffer too small\n");
+        return 0;
+    }
+    ractx = avctx->priv_data;
+
+    /**
+     * Since the LPC coefficients are calculated on a frame centered over the
+     * fourth subframe, to encode a given frame, data from the next frame is
+     * needed. In each call to this function, the previous frame (whose data are
+     * saved in the encoder context) is encoded, and data from the current frame
+     * are saved in the encoder context to be used in the next function call.
+     */
+    for (i = 0; i < (2 * BLOCKSIZE + BLOCKSIZE / 2); i++) {
+        lpc_data[i] = ractx->curr_block[BLOCKSIZE + BLOCKSIZE / 2 + i];
+        energy += (lpc_data[i] * lpc_data[i]) >> 4;
+    }
+    for (i = 2 * BLOCKSIZE + BLOCKSIZE / 2; i < NBLOCKS * BLOCKSIZE; i++) {
+        lpc_data[i] = *((int16_t *)data + i - 2 * BLOCKSIZE - BLOCKSIZE / 2) >>
+                      2;
+        energy += (lpc_data[i] * lpc_data[i]) >> 4;
+    }
+    energy = ff_energy_tab[quantize(ff_t_sqrt(energy >> 5) >> 10, ff_energy_tab,
+                                    32)];
+
+    ff_lpc_calc_coefs(&ractx->dsp, lpc_data, NBLOCKS * BLOCKSIZE, LPC_ORDER,
+                      LPC_ORDER, 16, lpc_coefs, shift, AV_LPC_TYPE_LEVINSON,
+                      0, ORDER_METHOD_EST, 12, 0);
+    for (i = 0; i < LPC_ORDER; i++)
+        block_coefs[NBLOCKS - 1][i] = -(lpc_coefs[LPC_ORDER - 1][i] <<
+                                        (12 - shift[LPC_ORDER - 1]));
+
+    /**
+     * TODO: apply perceptual weighting of the input speech through bandwidth
+     * expansion of the LPC filter.
+     */
+
+    if (ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx)) {
+        /**
+         * The filter is unstable: use the coefficients of the previous frame.
+         */
+        ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[1]);
+        ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx);
+    }
+    init_put_bits(&pb, frame, buf_size);
+    for (i = 0; i < LPC_ORDER; i++) {
+        idx = quantize(lpc_refl[i], ff_lpc_refl_cb[i], sizes[i]);
+        put_bits(&pb, bit_sizes[i], idx);
+        lpc_refl[i] = ff_lpc_refl_cb[i][idx];
+    }
+    ractx->lpc_refl_rms[0] = ff_rms(lpc_refl);
+    ff_eval_coefs(ractx->lpc_coef[0], lpc_refl);
+    refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx->old_energy);
+    refl_rms[1] = ff_interp(ractx, block_coefs[1], 2,
+                            energy <= ractx->old_energy,
+                            ff_t_sqrt(energy * ractx->old_energy) >> 12);
+    refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy);
+    refl_rms[3] = ff_rescale_rms(ractx->lpc_refl_rms[0], energy);
+    ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[0]);
+    put_bits(&pb, 5, quantize(energy, ff_energy_tab, 32));
+    for (i = 0; i < NBLOCKS; i++)
+        ra144_encode_subblock(ractx, ractx->curr_block + i * BLOCKSIZE,
+                              block_coefs[i], refl_rms[i], &pb);
+    flush_put_bits(&pb);
+    ractx->old_energy = energy;
+    ractx->lpc_refl_rms[1] = ractx->lpc_refl_rms[0];
+    FFSWAP(unsigned int *, ractx->lpc_coef[0], ractx->lpc_coef[1]);
+    for (i = 0; i < NBLOCKS * BLOCKSIZE; i++)
+        ractx->curr_block[i] = *((int16_t *)data + i) >> 2;
+    return FRAMESIZE;
+}
+
+
+AVCodec ra_144_encoder =
+{
+    "real_144",
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_RA_144,
+    sizeof(RA144Context),
+    ra144_encode_init,
+    ra144_encode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL("RealAudio 1.0 (14.4K) encoder"),
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/utils.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/utils.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -643,10 +643,12 @@
 
     if((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size){
         //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
+#if 0 // MEANX : Silence
         if(*frame_size_ptr < AVCODEC_MAX_AUDIO_FRAME_SIZE){
             av_log(avctx, AV_LOG_ERROR, "buffer smaller than AVCODEC_MAX_AUDIO_FRAME_SIZE\n");
             return -1;
         }
+#endif
         if(*frame_size_ptr < FF_MIN_BUFFER_SIZE ||
         *frame_size_ptr < avctx->channels * avctx->frame_size * sizeof(int16_t)){
             av_log(avctx, AV_LOG_ERROR, "buffer %d too small\n", *frame_size_ptr);
@@ -952,13 +954,13 @@
 
 const char *avcodec_configuration(void)
 {
-    return FFMPEG_CONFIGURATION;
+    return "avidemux"; //FFMPEG_CONFIGURATION;
 }
 
 const char *avcodec_license(void)
 {
 #define LICENSE_PREFIX "libavcodec license: "
-    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
+    return LICENSE_PREFIX /*FFMPEG_LICENSE*/ "GPL" + sizeof(LICENSE_PREFIX) - 1;
 }
 
 void avcodec_init(void)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h	2010-07-25 10:07:52 UTC (rev 6483)
@@ -21,8 +21,12 @@
 
 #ifndef AVCODEC_X86_MATHOPS_H
 #define AVCODEC_X86_MATHOPS_H
+// MEANX
+#ifndef ADM_NO_CONFIG_H
+#include "config.h"
+#endif
+// /MEANX
 
-#include "config.h"
 #include "libavutil/common.h"
 
 #if ARCH_X86_32

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,30 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
+index 14e049d..78e39a5 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
+@@ -614,6 +614,8 @@ typedef struct RcOverride{
+ #define CODEC_FLAG2_PSY           0x00080000 ///< Use psycho visual optimizations.
+ #define CODEC_FLAG2_SSIM          0x00100000 ///< Compute SSIM during encoding, error[] values are undefined.
+ #define CODEC_FLAG2_INTRA_REFRESH 0x00200000 ///< Use periodic insertion of intra blocks instead of keyframes.
++//MEANX: NEVER EVER USE CLOSED GOP ?
++#define CODEC_FLAG2_32_PULLDOWN   0x80000000 
+ 
+ /* Unsupported options :
+  *              Syntax Arithmetic coding (SAC)
+@@ -1496,6 +1498,7 @@ typedef struct AVCodecContext {
+      * - decoding: unused
+      */
+     int rc_max_rate;
++    int rc_max_rate_header; /*< That one is set in the header MEANX */
+ 
+     /**
+      * minimum bitrate
+@@ -1510,6 +1513,8 @@ typedef struct AVCodecContext {
+      * - decoding: unused
+      */
+     int rc_buffer_size;
++    int rc_buffer_size_header;  /*< That one is set in the header MEANX*/
++
+     float rc_buffer_aggressivity;
+ 
+     /**

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,30 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
+index 14e049d..78e39a5 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
+@@ -614,6 +614,8 @@ typedef struct RcOverride{
+ #define CODEC_FLAG2_PSY           0x00080000 ///< Use psycho visual optimizations.
+ #define CODEC_FLAG2_SSIM          0x00100000 ///< Compute SSIM during encoding, error[] values are undefined.
+ #define CODEC_FLAG2_INTRA_REFRESH 0x00200000 ///< Use periodic insertion of intra blocks instead of keyframes.
++//MEANX: NEVER EVER USE CLOSED GOP ?
++#define CODEC_FLAG2_32_PULLDOWN   0x80000000 
+ 
+ /* Unsupported options :
+  *              Syntax Arithmetic coding (SAC)
+@@ -1496,6 +1498,7 @@ typedef struct AVCodecContext {
+      * - decoding: unused
+      */
+     int rc_max_rate;
++    int rc_max_rate_header; /*< That one is set in the header MEANX */
+ 
+     /**
+      * minimum bitrate
+@@ -1510,6 +1513,8 @@ typedef struct AVCodecContext {
+      * - decoding: unused
+      */
+     int rc_buffer_size;
++    int rc_buffer_size_header;  /*< That one is set in the header MEANX*/
++
+     float rc_buffer_aggressivity;
+ 
+     /**

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/fft.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/fft.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/fft.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,13 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/fft.c b/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
+index 8176551..c946d87 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
+@@ -105,7 +105,7 @@ av_cold int ff_fft_init(FFTContext *s, int nbits, int inverse)
+ 
+     if (ARCH_ARM)     ff_fft_init_arm(s);
+     if (HAVE_ALTIVEC) ff_fft_init_altivec(s);
+-    if (HAVE_MMX)     ff_fft_init_mmx(s);
++    // MEANX if (HAVE_MMX)     ff_fft_init_mmx(s);
+ 
+     for(j=4; j<=nbits; j++) {
+         ff_init_ff_cos_tabs(j);

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h263dec.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h263dec.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h263dec.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,56 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c b/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
+index d9d6f7e..218959d 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
+@@ -119,6 +119,23 @@ av_cold int ff_h263_decode_init(AVCodecContext *avctx)
+ 
+     return 0;
+ }
++/* MeanX : Ugly patch to detect vo ppacked stuff ... */
++int av_is_voppacked(AVCodecContext *avctx, int *vop_packed, int *gmc, int *qpel)
++{
++    MpegEncContext *s = avctx->priv_data;
++    // set sane default
++    *vop_packed=0;
++    *gmc=0;
++    *qpel=0;
++    if(avctx->codec->id!=CODEC_ID_MPEG4) return 0;
++    	
++  	*vop_packed=(s->divx_packed);
++	*qpel=s->quarter_sample;
++	*gmc=0;	// FIXME
++	return 1;
++
++  }
++  /* MeanX */
+ 
+ av_cold int ff_h263_decode_end(AVCodecContext *avctx)
+ {
+@@ -414,6 +431,12 @@ retry:
+     } else {
+         ret = h263_decode_picture_header(s);
+     }
++	//MEANX we need to do it here also for quicktime file / ctts atom 
++        // we need the correct frame type, and qt file may contain 
++        // vop not coded frame.
++        pict->pict_type=s->current_picture.pict_type= s->pict_type;
++        pict->key_frame=s->current_picture.key_frame= s->pict_type == FF_I_TYPE;
++        //MEANX
+ 
+     if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_size);
+ 
+@@ -709,6 +732,14 @@ intrax8_decoded:
+ 
+ assert(s->current_picture.pict_type == s->current_picture_ptr->pict_type);
+ assert(s->current_picture.pict_type == s->pict_type);
++/* MEANX */
++  if(s->current_picture_ptr)
++      s->current_picture_ptr->opaque=pict->opaque;
++/* MEANX */
++
++
++
++
+     if (s->pict_type == FF_B_TYPE || s->low_delay) {
+         *pict= *(AVFrame*)s->current_picture_ptr;
+     } else if (s->last_picture_ptr != NULL) {

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h264dsp.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h264dsp.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h264dsp.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,12 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c b/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
+index c01fc77..0fe9f40 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
+@@ -316,5 +316,7 @@ void ff_h264dsp_init(H264DSPContext *c)
+ 
+     if (ARCH_ARM) ff_h264dsp_init_arm(c);
+     if (HAVE_ALTIVEC) ff_h264dsp_init_ppc(c);
++#if CONFIG_H264DSP //MEANX
+     if (HAVE_MMX) ff_h264dsp_init_x86(c);
++#endif
+ }

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,16 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
+index 0af24ad..3ffea4c 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
+@@ -1948,6 +1948,11 @@ static int slice_end(AVCodecContext *avctx, AVFrame *pict)
+         ff_er_frame_end(s);
+ 
+         MPV_frame_end(s);
++/* MEANX */
++  if(s->current_picture_ptr)
++      s->current_picture_ptr->opaque=pict->opaque;
++/* MEANX */
++
+ 
+         if (s->pict_type == FF_B_TYPE || s->low_delay) {
+             *pict= *(AVFrame*)s->current_picture_ptr;

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12enc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12enc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12enc.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,190 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
+index 6868e2a..34b650f 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
+@@ -127,10 +127,19 @@ static int find_frame_rate_index(MpegEncContext *s){
+             s->frame_rate_index= i;
+         }
+     }
++ /* MEANX 
++
+     if(dmin)
+         return -1;
+     else
+         return 0;
++  */
++        if(dmin>4)
++   {
++        av_log(0,AV_LOG_ERROR,"We did a roundup ! Expect async!\n");
++   }
++        return 0; //MEANX
++
+ }
+ 
+ static av_cold int encode_init(AVCodecContext *avctx)
+@@ -209,6 +218,7 @@ static void mpeg1_encode_sequence_header(MpegEncContext *s)
+             put_sbits(&s->pb, 12, s->width );
+             put_sbits(&s->pb, 12, s->height);
+ 
++#if 0 //MEANX
+             for(i=1; i<15; i++){
+                 float error= aspect_ratio;
+                 if(s->codec_id == CODEC_ID_MPEG1VIDEO || i <=1)
+@@ -223,20 +233,44 @@ static void mpeg1_encode_sequence_header(MpegEncContext *s)
+                     s->aspect_ratio_info= i;
+                 }
+             }
++#endif // MEANX
++            //MEANX put_bits(&s->pb, 4, s->aspect_ratio_info);
++            //MEANX put_bits(&s->pb, 4, s->frame_rate_index);
++ // MEANX 4:3
++  if(s->avctx->sample_aspect_ratio.num==16 && s->avctx->sample_aspect_ratio.den==9)
++            {
++                //printf("FFmpeg : Wide\n");
++                put_bits(&s->pb,4,3); //16:9
++            }
++            else        //4:3
++            {
++              if(s->codec_id == CODEC_ID_MPEG2VIDEO)
++                put_bits(&s->pb, 4, 2);
++              else
++                put_bits(&s->pb, 4, 12); // MPEG1
++            }
++// /MEANX
+ 
+-            put_bits(&s->pb, 4, s->aspect_ratio_info);
+-            put_bits(&s->pb, 4, s->frame_rate_index);
++// //MEANX PULLDOWN            put_bits(&s->pb, 4, s->frame_rate_index);
++if((s->flags2 & CODEC_FLAG2_32_PULLDOWN) && (s->codec_id == CODEC_ID_MPEG2VIDEO))
++            {           
++                put_bits(&s->pb, 4,4);
++            }
++            else
++            {                                  
++                put_bits(&s->pb, 4, s->frame_rate_index);
++            } //MEANX pulldown
+ 
+-            if(s->avctx->rc_max_rate){
+-                v = (s->avctx->rc_max_rate + 399) / 400;
++            if(s->avctx->rc_max_rate_header){ //MEANX we use header
++                v = (s->avctx->rc_max_rate_header + 399) / 400;
+                 if (v > 0x3ffff && s->codec_id == CODEC_ID_MPEG1VIDEO)
+                     v = 0x3ffff;
+             }else{
+                 v= 0x3FFFF;
+             }
+ 
+-            if(s->avctx->rc_buffer_size)
+-                vbv_buffer_size = s->avctx->rc_buffer_size;
++            if(s->avctx->rc_buffer_size_header) // MEANX we use header
++                vbv_buffer_size = s->avctx->rc_buffer_size_header;
+             else
+                 /* VBV calculation: Scaled so that a VCD has the proper VBV size of 40 kilobytes */
+                 vbv_buffer_size = (( 20 * s->bit_rate) / (1151929 / 2)) * 8 * 1024;
+@@ -269,8 +303,17 @@ static void mpeg1_encode_sequence_header(MpegEncContext *s)
+ 
+                 put_bits(&s->pb, 3, s->avctx->profile); //profile
+                 put_bits(&s->pb, 4, s->avctx->level); //level
++   // MEANX pulldown put_bits(&s->pb, 1, s->progressive_sequence);
++  // MEANX Pulldown
++ if(s->flags2 & CODEC_FLAG2_32_PULLDOWN) //MEANX
++                        put_bits(&s->pb, 1, 0);
++                else
++                        put_bits(&s->pb, 1, s->progressive_sequence);
++
++
++// /MEANX
++
+ 
+-                put_bits(&s->pb, 1, s->progressive_sequence);
+                 put_bits(&s->pb, 2, s->chroma_format);
+                 put_bits(&s->pb, 2, s->width >>12);
+                 put_bits(&s->pb, 2, s->height>>12);
+@@ -339,6 +382,8 @@ void ff_mpeg1_encode_slice_header(MpegEncContext *s){
+ 
+ void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
+ {
++	int tff,rff; //MEANX
++
+     mpeg1_encode_sequence_header(s);
+ 
+     /* mpeg1 picture header */
+@@ -375,6 +420,49 @@ void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
+ 
+     s->frame_pred_frame_dct = 1;
+     if(s->codec_id == CODEC_ID_MPEG2VIDEO){
++ /* MEANX -- Pulldown */
++        if(s->flags2 & CODEC_FLAG2_32_PULLDOWN)
++        {
++        
++                switch((s->picture_number - 
++                          s->gop_picture_number)&3)
++                {
++                        case 0:
++                        default:
++                                rff=1;
++                                tff=1;
++                                break;
++                        case 1:
++                                rff=0;
++                                tff=0;
++                                break;
++                        case 2:
++                                rff=1;
++                                tff=0;
++                                break;
++                        case 3:
++                                rff=0;
++                                tff=1;
++                                break;
++                }               
++           }
++        else
++        {
++                if (s->progressive_sequence) 
++                {
++                        tff=0; /* no repeat */
++                } else 
++                {
++                        tff= s->current_picture_ptr->top_field_first;
++                }
++                rff=s->repeat_first_field;
++        
++        }
++
++//               /MEANX pulldown
++
++
++
+         put_header(s, EXT_START_CODE);
+         put_bits(&s->pb, 4, 8); //pic ext
+         if (s->pict_type == FF_P_TYPE || s->pict_type == FF_B_TYPE) {
+@@ -393,11 +481,16 @@ void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
+ 
+         assert(s->picture_structure == PICT_FRAME);
+         put_bits(&s->pb, 2, s->picture_structure);
++#if 0 //MEANX
++
+         if (s->progressive_sequence) {
+             put_bits(&s->pb, 1, 0); /* no repeat */
+         } else {
+             put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first);
+         }
++#endif
++         put_bits(&s->pb, 1, tff);  //MEANX PULLDOWN
++
+         /* XXX: optimize the generation of this flag with entropy
+            measures */
+         s->frame_pred_frame_dct = s->progressive_sequence;
+@@ -407,7 +500,10 @@ void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
+         put_bits(&s->pb, 1, s->q_scale_type);
+         put_bits(&s->pb, 1, s->intra_vlc_format);
+         put_bits(&s->pb, 1, s->alternate_scan);
+-        put_bits(&s->pb, 1, s->repeat_first_field);
++ // MEANX put_bits(&s->pb, 1, s->repeat_first_field);
++	put_bits(&s->pb, 1, rff);
++      // /MEANX
++
+         s->progressive_frame = s->progressive_sequence;
+         put_bits(&s->pb, 1, s->chroma_format == CHROMA_420 ? s->progressive_frame : 0); /* chroma_420_type */
+         put_bits(&s->pb, 1, s->progressive_frame);

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,17 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
+index 684bdfe..2135c3d 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
+@@ -652,7 +652,11 @@ av_cold int MPV_common_init(MpegEncContext *s)
+     FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
+ 
+     s->parse_context.state= -1;
+-    if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){
++ //MEANX: Allocate them always, as they may be free when we decode 1st image
++
++    // MEANXif((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){
++if(1){ // MEANX
++
+        s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
+        s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
+        s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo_enc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo_enc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo_enc.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,32 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
+index 9f8682c..1f296a5 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
+@@ -367,12 +367,14 @@ av_cold int MPV_encode_init(AVCodecContext *avctx)
+ 
+         av_log(avctx, AV_LOG_INFO, "Warning vbv_delay will be set to 0xFFFF (=VBR) as the specified vbv buffer is too large for the given bitrate!\n");
+     }
++#if 0 //MEANX
+ 
+     if((s->flags & CODEC_FLAG_4MV) && s->codec_id != CODEC_ID_MPEG4
+        && s->codec_id != CODEC_ID_H263 && s->codec_id != CODEC_ID_H263P && s->codec_id != CODEC_ID_FLV1){
+         av_log(avctx, AV_LOG_ERROR, "4MV not supported by codec\n");
+         return -1;
+     }
++#endif
+ 
+     if(s->obmc && s->avctx->mb_decision != FF_MB_DECISION_SIMPLE){
+         av_log(avctx, AV_LOG_ERROR, "OBMC is only supported with simple mb decision\n");
+@@ -413,10 +415,12 @@ av_cold int MPV_encode_init(AVCodecContext *avctx)
+         return -1;
+     }
+ 
++#if 0 //MEANX
+     if(s->mpeg_quant && s->codec_id != CODEC_ID_MPEG4){ //FIXME mpeg2 uses that too
+         av_log(avctx, AV_LOG_ERROR, "mpeg2 style quantization not supported by codec\n");
+         return -1;
+     }
++#endif
+ 
+     if((s->flags & CODEC_FLAG_CBP_RD) && !avctx->trellis){
+         av_log(avctx, AV_LOG_ERROR, "CBP RD needs trellis quant\n");

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/png.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/png.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/png.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,13 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/png.c b/avidemux_core/ADM_ffmpeg/libavcodec/png.c
+index 534dc68..1a6e137 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/png.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/png.c
+@@ -20,7 +20,7 @@
+  */
+ #include "avcodec.h"
+ #include "bytestream.h"
+-#include "png.h"
++#include "ffpng.h"
+ 
+ const uint8_t ff_pngsig[8] = {137, 80, 78, 71, 13, 10, 26, 10};
+ const uint8_t ff_mngsig[8] = {138, 77, 78, 71, 13, 10, 26, 10};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngdec.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngdec.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngdec.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,13 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c b/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
+index 037c5a0..6546567 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
+@@ -20,7 +20,7 @@
+  */
+ #include "avcodec.h"
+ #include "bytestream.h"
+-#include "png.h"
++#include "ffpng.h"
+ #include "dsputil.h"
+ 
+ /* TODO:

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngenc.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,13 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c b/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
+index d199b95..b63c84e 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
+@@ -21,7 +21,7 @@
+ #include "avcodec.h"
+ #include "bytestream.h"
+ #include "dsputil.h"
+-#include "png.h"
++#include "ffpng.h"
+ 
+ /* TODO:
+  * - add 2, 4 and 16 bit depth support

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/utils.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/utils.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/utils.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,33 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/utils.c b/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
+index f21e9ed..acd1078 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
+@@ -643,10 +643,12 @@ int attribute_align_arg avcodec_decode_audio3(AVCodecContext *avctx, int16_t *sa
+ 
+     if((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size){
+         //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
++#if 0 // MEANX : Silence
+         if(*frame_size_ptr < AVCODEC_MAX_AUDIO_FRAME_SIZE){
+             av_log(avctx, AV_LOG_ERROR, "buffer smaller than AVCODEC_MAX_AUDIO_FRAME_SIZE\n");
+             return -1;
+         }
++#endif
+         if(*frame_size_ptr < FF_MIN_BUFFER_SIZE ||
+         *frame_size_ptr < avctx->channels * avctx->frame_size * sizeof(int16_t)){
+             av_log(avctx, AV_LOG_ERROR, "buffer %d too small\n", *frame_size_ptr);
+@@ -952,13 +954,13 @@ unsigned avcodec_version( void )
+ 
+ const char *avcodec_configuration(void)
+ {
+-    return FFMPEG_CONFIGURATION;
++    return "avidemux"; //FFMPEG_CONFIGURATION;
+ }
+ 
+ const char *avcodec_license(void)
+ {
+ #define LICENSE_PREFIX "libavcodec license: "
+-    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
++    return LICENSE_PREFIX /*FFMPEG_LICENSE*/ "GPL" + sizeof(LICENSE_PREFIX) - 1;
+ }
+ 
+ void avcodec_init(void)

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/x86_mathops.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/x86_mathops.h.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/x86_mathops.h.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,18 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h b/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
+index 5949dfe..c30f9df 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
+@@ -21,8 +21,12 @@
+ 
+ #ifndef AVCODEC_X86_MATHOPS_H
+ #define AVCODEC_X86_MATHOPS_H
+-
++// MEANX
++#ifndef ADM_NO_CONFIG_H
+ #include "config.h"
++#endif
++// /MEANX
++
+ #include "libavutil/common.h"
+ 
+ #if ARCH_X86_32



From mean at mail.berlios.de  Sun Jul 25 12:07:55 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 25 Jul 2010 12:07:55 +0200
Subject: [Avidemux-svn-commit] r6484 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat
Message-ID: <20100725100755.7E8DE480E6C@sheep.berlios.de>

Author: mean
Date: 2010-07-25 12:07:55 +0200 (Sun, 25 Jul 2010)
New Revision: 6484

Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig
Log:
[cleanup] libavformat/movenc.c.orig

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig	2010-07-25 10:07:52 UTC (rev 6483)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig	2010-07-25 10:07:55 UTC (rev 6484)
@@ -1,2300 +0,0 @@
-/*
- * MOV, 3GP, MP4 muxer
- * Copyright (c) 2003 Thomas Raivio
- * Copyright (c) 2004 Gildas Bazin <gbazin at videolan dot org>
- * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "movenc.h"
-#include "avformat.h"
-#include "riff.h"
-#include "avio.h"
-#include "isom.h"
-#include "avc.h"
-#include "libavcodec/get_bits.h"
-#include "libavcodec/put_bits.h"
-#include "internal.h"
-#include "libavutil/avstring.h"
-
-#undef NDEBUG
-#include <assert.h>
-
-//FIXME support 64 bit variant with wide placeholders
-static int64_t updateSize(ByteIOContext *pb, int64_t pos)
-{
-    int64_t curpos = url_ftell(pb);
-    url_fseek(pb, pos, SEEK_SET);
-    put_be32(pb, curpos - pos); /* rewrite size */
-    url_fseek(pb, curpos, SEEK_SET);
-
-    return curpos - pos;
-}
-
-/* Chunk offset atom */
-static int mov_write_stco_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int i;
-    int mode64 = 0; //   use 32 bit size variant if possible
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    if (pos > UINT32_MAX) {
-        mode64 = 1;
-        put_tag(pb, "co64");
-    } else
-        put_tag(pb, "stco");
-    put_be32(pb, 0); /* version & flags */
-    put_be32(pb, track->entry); /* entry count */
-    for (i=0; i<track->entry; i++) {
-        if(mode64 == 1)
-            put_be64(pb, track->cluster[i].pos);
-        else
-            put_be32(pb, track->cluster[i].pos);
-    }
-    return updateSize(pb, pos);
-}
-
-/* Sample size atom */
-static int mov_write_stsz_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int equalChunks = 1;
-    int i, j, entries = 0, tst = -1, oldtst = -1;
-
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "stsz");
-    put_be32(pb, 0); /* version & flags */
-
-    for (i=0; i<track->entry; i++) {
-        tst = track->cluster[i].size/track->cluster[i].entries;
-        if(oldtst != -1 && tst != oldtst) {
-            equalChunks = 0;
-        }
-        oldtst = tst;
-        entries += track->cluster[i].entries;
-    }
-    if (equalChunks) {
-        int sSize = track->cluster[0].size/track->cluster[0].entries;
-        put_be32(pb, sSize); // sample size
-        put_be32(pb, entries); // sample count
-    }
-    else {
-        put_be32(pb, 0); // sample size
-        put_be32(pb, entries); // sample count
-        for (i=0; i<track->entry; i++) {
-            for (j=0; j<track->cluster[i].entries; j++) {
-                put_be32(pb, track->cluster[i].size /
-                         track->cluster[i].entries);
-            }
-        }
-    }
-    return updateSize(pb, pos);
-}
-
-/* Sample to chunk atom */
-static int mov_write_stsc_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int index = 0, oldval = -1, i;
-    int64_t entryPos, curpos;
-
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "stsc");
-    put_be32(pb, 0); // version & flags
-    entryPos = url_ftell(pb);
-    put_be32(pb, track->entry); // entry count
-    for (i=0; i<track->entry; i++) {
-        if(oldval != track->cluster[i].samplesInChunk)
-        {
-            put_be32(pb, i+1); // first chunk
-            put_be32(pb, track->cluster[i].samplesInChunk); // samples per chunk
-            put_be32(pb, 0x1); // sample description index
-            oldval = track->cluster[i].samplesInChunk;
-            index++;
-        }
-    }
-    curpos = url_ftell(pb);
-    url_fseek(pb, entryPos, SEEK_SET);
-    put_be32(pb, index); // rewrite size
-    url_fseek(pb, curpos, SEEK_SET);
-
-    return updateSize(pb, pos);
-}
-
-/* Sync sample atom */
-static int mov_write_stss_tag(ByteIOContext *pb, MOVTrack *track, uint32_t flag)
-{
-    int64_t curpos, entryPos;
-    int i, index = 0;
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); // size
-    put_tag(pb, flag == MOV_SYNC_SAMPLE ? "stss" : "stps");
-    put_be32(pb, 0); // version & flags
-    entryPos = url_ftell(pb);
-    put_be32(pb, track->entry); // entry count
-    for (i=0; i<track->entry; i++) {
-        if (track->cluster[i].flags & flag) {
-            put_be32(pb, i+1);
-            index++;
-        }
-    }
-    curpos = url_ftell(pb);
-    url_fseek(pb, entryPos, SEEK_SET);
-    put_be32(pb, index); // rewrite size
-    url_fseek(pb, curpos, SEEK_SET);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_amr_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    put_be32(pb, 0x11); /* size */
-    if (track->mode == MODE_MOV) put_tag(pb, "samr");
-    else                         put_tag(pb, "damr");
-    put_tag(pb, "FFMP");
-    put_byte(pb, 0); /* decoder version */
-
-    put_be16(pb, 0x81FF); /* Mode set (all modes for AMR_NB) */
-    put_byte(pb, 0x00); /* Mode change period (no restriction) */
-    put_byte(pb, 0x01); /* Frames per sample */
-    return 0x11;
-}
-
-static int mov_write_ac3_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    GetBitContext gbc;
-    PutBitContext pbc;
-    uint8_t buf[3];
-    int fscod, bsid, bsmod, acmod, lfeon, frmsizecod;
-
-    if (track->vosLen < 7)
-        return -1;
-
-    put_be32(pb, 11);
-    put_tag(pb, "dac3");
-
-    init_get_bits(&gbc, track->vosData+4, track->vosLen-4);
-    fscod      = get_bits(&gbc, 2);
-    frmsizecod = get_bits(&gbc, 6);
-    bsid       = get_bits(&gbc, 5);
-    bsmod      = get_bits(&gbc, 3);
-    acmod      = get_bits(&gbc, 3);
-    if (acmod == 2) {
-        skip_bits(&gbc, 2); // dsurmod
-    } else {
-        if ((acmod & 1) && acmod != 1)
-            skip_bits(&gbc, 2); // cmixlev
-        if (acmod & 4)
-            skip_bits(&gbc, 2); // surmixlev
-    }
-    lfeon = get_bits1(&gbc);
-
-    init_put_bits(&pbc, buf, sizeof(buf));
-    put_bits(&pbc, 2, fscod);
-    put_bits(&pbc, 5, bsid);
-    put_bits(&pbc, 3, bsmod);
-    put_bits(&pbc, 3, acmod);
-    put_bits(&pbc, 1, lfeon);
-    put_bits(&pbc, 5, frmsizecod>>1); // bit_rate_code
-    put_bits(&pbc, 5, 0); // reserved
-
-    flush_put_bits(&pbc);
-    put_buffer(pb, buf, sizeof(buf));
-
-    return 11;
-}
-
-/**
- * This function writes extradata "as is".
- * Extradata must be formated like a valid atom (with size and tag)
- */
-static int mov_write_extradata_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    put_buffer(pb, track->enc->extradata, track->enc->extradata_size);
-    return track->enc->extradata_size;
-}
-
-static int mov_write_enda_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 10);
-    put_tag(pb, "enda");
-    put_be16(pb, 1); /* little endian */
-    return 10;
-}
-
-static unsigned int descrLength(unsigned int len)
-{
-    int i;
-    for(i=1; len>>(7*i); i++);
-    return len + 1 + i;
-}
-
-static void putDescr(ByteIOContext *pb, int tag, unsigned int size)
-{
-    int i= descrLength(size) - size - 2;
-    put_byte(pb, tag);
-    for(; i>0; i--)
-        put_byte(pb, (size>>(7*i)) | 0x80);
-    put_byte(pb, size & 0x7F);
-}
-
-static int mov_write_esds_tag(ByteIOContext *pb, MOVTrack *track) // Basic
-{
-    int64_t pos = url_ftell(pb);
-    int decoderSpecificInfoLen = track->vosLen ? descrLength(track->vosLen):0;
-
-    put_be32(pb, 0); // size
-    put_tag(pb, "esds");
-    put_be32(pb, 0); // Version
-
-    // ES descriptor
-    putDescr(pb, 0x03, 3 + descrLength(13 + decoderSpecificInfoLen) +
-             descrLength(1));
-    put_be16(pb, track->trackID);
-    put_byte(pb, 0x00); // flags (= no flags)
-
-    // DecoderConfig descriptor
-    putDescr(pb, 0x04, 13 + decoderSpecificInfoLen);
-
-    // Object type indication
-    if ((track->enc->codec_id == CODEC_ID_MP2 ||
-         track->enc->codec_id == CODEC_ID_MP3) &&
-        track->enc->sample_rate > 24000)
-        put_byte(pb, 0x6B); // 11172-3
-    else
-        put_byte(pb, ff_codec_get_tag(ff_mp4_obj_type, track->enc->codec_id));
-
-    // the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)
-    // plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)
-    if(track->enc->codec_type == AVMEDIA_TYPE_AUDIO)
-        put_byte(pb, 0x15); // flags (= Audiostream)
-    else
-        put_byte(pb, 0x11); // flags (= Visualstream)
-
-    put_byte(pb,  track->enc->rc_buffer_size>>(3+16));    // Buffersize DB (24 bits)
-    put_be16(pb, (track->enc->rc_buffer_size>>3)&0xFFFF); // Buffersize DB
-
-    put_be32(pb, FFMAX(track->enc->bit_rate, track->enc->rc_max_rate)); // maxbitrate (FIXME should be max rate in any 1 sec window)
-    if(track->enc->rc_max_rate != track->enc->rc_min_rate || track->enc->rc_min_rate==0)
-        put_be32(pb, 0); // vbr
-    else
-        put_be32(pb, track->enc->rc_max_rate); // avg bitrate
-
-    if (track->vosLen) {
-        // DecoderSpecific info descriptor
-        putDescr(pb, 0x05, track->vosLen);
-        put_buffer(pb, track->vosData, track->vosLen);
-    }
-
-    // SL descriptor
-    putDescr(pb, 0x06, 1);
-    put_byte(pb, 0x02);
-    return updateSize(pb, pos);
-}
-
-static int mov_pcm_le_gt16(enum CodecID codec_id)
-{
-    return codec_id == CODEC_ID_PCM_S24LE ||
-           codec_id == CODEC_ID_PCM_S32LE ||
-           codec_id == CODEC_ID_PCM_F32LE ||
-           codec_id == CODEC_ID_PCM_F64LE;
-}
-
-static int mov_write_wave_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-
-    put_be32(pb, 0);     /* size */
-    put_tag(pb, "wave");
-
-    put_be32(pb, 12);    /* size */
-    put_tag(pb, "frma");
-    put_le32(pb, track->tag);
-
-    if (track->enc->codec_id == CODEC_ID_AAC) {
-        /* useless atom needed by mplayer, ipod, not needed by quicktime */
-        put_be32(pb, 12); /* size */
-        put_tag(pb, "mp4a");
-        put_be32(pb, 0);
-        mov_write_esds_tag(pb, track);
-    } else if (mov_pcm_le_gt16(track->enc->codec_id)) {
-        mov_write_enda_tag(pb);
-    } else if (track->enc->codec_id == CODEC_ID_AMR_NB) {
-        mov_write_amr_tag(pb, track);
-    } else if (track->enc->codec_id == CODEC_ID_AC3) {
-        mov_write_ac3_tag(pb, track);
-    } else if (track->enc->codec_id == CODEC_ID_ALAC) {
-        mov_write_extradata_tag(pb, track);
-    }
-
-    put_be32(pb, 8);     /* size */
-    put_be32(pb, 0);     /* null tag */
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_glbl_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    put_be32(pb, track->vosLen+8);
-    put_tag(pb, "glbl");
-    put_buffer(pb, track->vosData, track->vosLen);
-    return 8+track->vosLen;
-}
-
-/**
- * Compute flags for 'lpcm' tag.
- * See CoreAudioTypes and AudioStreamBasicDescription at Apple.
- */
-static int mov_get_lpcm_flags(enum CodecID codec_id)
-{
-    switch (codec_id) {
-    case CODEC_ID_PCM_F32BE:
-    case CODEC_ID_PCM_F64BE:
-        return 11;
-    case CODEC_ID_PCM_F32LE:
-    case CODEC_ID_PCM_F64LE:
-        return 9;
-    case CODEC_ID_PCM_U8:
-        return 10;
-    case CODEC_ID_PCM_S16BE:
-    case CODEC_ID_PCM_S24BE:
-    case CODEC_ID_PCM_S32BE:
-        return 14;
-    case CODEC_ID_PCM_S8:
-    case CODEC_ID_PCM_S16LE:
-    case CODEC_ID_PCM_S24LE:
-    case CODEC_ID_PCM_S32LE:
-        return 12;
-    default:
-        return 0;
-    }
-}
-
-static int mov_write_audio_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    int version = 0;
-    uint32_t tag = track->tag;
-
-    if (track->mode == MODE_MOV) {
-        if (track->timescale > UINT16_MAX) {
-            if (mov_get_lpcm_flags(track->enc->codec_id))
-                tag = AV_RL32("lpcm");
-            version = 2;
-        } else if (track->audio_vbr || mov_pcm_le_gt16(track->enc->codec_id)) {
-            version = 1;
-        }
-    }
-
-    put_be32(pb, 0); /* size */
-    put_le32(pb, tag); // store it byteswapped
-    put_be32(pb, 0); /* Reserved */
-    put_be16(pb, 0); /* Reserved */
-    put_be16(pb, 1); /* Data-reference index, XXX  == 1 */
-
-    /* SoundDescription */
-    put_be16(pb, version); /* Version */
-    put_be16(pb, 0); /* Revision level */
-    put_be32(pb, 0); /* Reserved */
-
-    if (version == 2) {
-        put_be16(pb, 3);
-        put_be16(pb, 16);
-        put_be16(pb, 0xfffe);
-        put_be16(pb, 0);
-        put_be32(pb, 0x00010000);
-        put_be32(pb, 72);
-        put_be64(pb, av_dbl2int(track->timescale));
-        put_be32(pb, track->enc->channels);
-        put_be32(pb, 0x7F000000);
-        put_be32(pb, av_get_bits_per_sample(track->enc->codec_id));
-        put_be32(pb, mov_get_lpcm_flags(track->enc->codec_id));
-        put_be32(pb, track->sampleSize);
-        put_be32(pb, track->enc->frame_size);
-    } else {
-        if (track->mode == MODE_MOV) {
-            put_be16(pb, track->enc->channels);
-            if (track->enc->codec_id == CODEC_ID_PCM_U8 ||
-                track->enc->codec_id == CODEC_ID_PCM_S8)
-                put_be16(pb, 8); /* bits per sample */
-            else
-                put_be16(pb, 16);
-            put_be16(pb, track->audio_vbr ? -2 : 0); /* compression ID */
-        } else { /* reserved for mp4/3gp */
-            put_be16(pb, 2);
-            put_be16(pb, 16);
-            put_be16(pb, 0);
-        }
-
-        put_be16(pb, 0); /* packet size (= 0) */
-        put_be16(pb, track->timescale); /* Time scale */
-        put_be16(pb, 0); /* Reserved */
-    }
-
-    if(version == 1) { /* SoundDescription V1 extended info */
-        put_be32(pb, track->enc->frame_size); /* Samples per packet */
-        put_be32(pb, track->sampleSize / track->enc->channels); /* Bytes per packet */
-        put_be32(pb, track->sampleSize); /* Bytes per frame */
-        put_be32(pb, 2); /* Bytes per sample */
-    }
-
-    if(track->mode == MODE_MOV &&
-       (track->enc->codec_id == CODEC_ID_AAC ||
-        track->enc->codec_id == CODEC_ID_AC3 ||
-        track->enc->codec_id == CODEC_ID_AMR_NB ||
-        track->enc->codec_id == CODEC_ID_ALAC ||
-        mov_pcm_le_gt16(track->enc->codec_id)))
-        mov_write_wave_tag(pb, track);
-    else if(track->tag == MKTAG('m','p','4','a'))
-        mov_write_esds_tag(pb, track);
-    else if(track->enc->codec_id == CODEC_ID_AMR_NB)
-        mov_write_amr_tag(pb, track);
-    else if(track->enc->codec_id == CODEC_ID_AC3)
-        mov_write_ac3_tag(pb, track);
-    else if(track->enc->codec_id == CODEC_ID_ALAC)
-        mov_write_extradata_tag(pb, track);
-    else if(track->vosLen > 0)
-        mov_write_glbl_tag(pb, track);
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_d263_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 0xf); /* size */
-    put_tag(pb, "d263");
-    put_tag(pb, "FFMP");
-    put_byte(pb, 0); /* decoder version */
-    /* FIXME use AVCodecContext level/profile, when encoder will set values */
-    put_byte(pb, 0xa); /* level */
-    put_byte(pb, 0); /* profile */
-    return 0xf;
-}
-
-/* TODO: No idea about these values */
-static int mov_write_svq3_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 0x15);
-    put_tag(pb, "SMI ");
-    put_tag(pb, "SEQH");
-    put_be32(pb, 0x5);
-    put_be32(pb, 0xe2c0211d);
-    put_be32(pb, 0xc0000000);
-    put_byte(pb, 0);
-    return 0x15;
-}
-
-static int mov_write_avcc_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-
-    put_be32(pb, 0);
-    put_tag(pb, "avcC");
-    ff_isom_write_avcc(pb, track->vosData, track->vosLen);
-    return updateSize(pb, pos);
-}
-
-/* also used by all avid codecs (dv, imx, meridien) and their variants */
-static int mov_write_avid_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int i;
-    put_be32(pb, 24); /* size */
-    put_tag(pb, "ACLR");
-    put_tag(pb, "ACLR");
-    put_tag(pb, "0001");
-    put_be32(pb, 1); /* yuv 1 / rgb 2 ? */
-    put_be32(pb, 0); /* unknown */
-
-    put_be32(pb, 24); /* size */
-    put_tag(pb, "APRG");
-    put_tag(pb, "APRG");
-    put_tag(pb, "0001");
-    put_be32(pb, 1); /* unknown */
-    put_be32(pb, 0); /* unknown */
-
-    put_be32(pb, 120); /* size */
-    put_tag(pb, "ARES");
-    put_tag(pb, "ARES");
-    put_tag(pb, "0001");
-    put_be32(pb, AV_RB32(track->vosData + 0x28)); /* dnxhd cid, some id ? */
-    put_be32(pb, track->enc->width);
-    /* values below are based on samples created with quicktime and avid codecs */
-    if (track->vosData[5] & 2) { // interlaced
-        put_be32(pb, track->enc->height/2);
-        put_be32(pb, 2); /* unknown */
-        put_be32(pb, 0); /* unknown */
-        put_be32(pb, 4); /* unknown */
-    } else {
-        put_be32(pb, track->enc->height);
-        put_be32(pb, 1); /* unknown */
-        put_be32(pb, 0); /* unknown */
-        if (track->enc->height == 1080)
-            put_be32(pb, 5); /* unknown */
-        else
-            put_be32(pb, 6); /* unknown */
-    }
-    /* padding */
-    for (i = 0; i < 10; i++)
-        put_be64(pb, 0);
-
-    /* extra padding for stsd needed */
-    put_be32(pb, 0);
-    return 0;
-}
-
-static int mp4_get_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag = track->enc->codec_tag;
-
-    if (!ff_codec_get_tag(ff_mp4_obj_type, track->enc->codec_id))
-        return 0;
-
-    if      (track->enc->codec_id == CODEC_ID_H264)      tag = MKTAG('a','v','c','1');
-    else if (track->enc->codec_id == CODEC_ID_AC3)       tag = MKTAG('a','c','-','3');
-    else if (track->enc->codec_id == CODEC_ID_DIRAC)     tag = MKTAG('d','r','a','c');
-    else if (track->enc->codec_id == CODEC_ID_MOV_TEXT)  tag = MKTAG('t','x','3','g');
-    else if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) tag = MKTAG('m','p','4','v');
-    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) tag = MKTAG('m','p','4','a');
-
-    return tag;
-}
-
-static const AVCodecTag codec_ipod_tags[] = {
-    { CODEC_ID_H264,   MKTAG('a','v','c','1') },
-    { CODEC_ID_MPEG4,  MKTAG('m','p','4','v') },
-    { CODEC_ID_AAC,    MKTAG('m','p','4','a') },
-    { CODEC_ID_ALAC,   MKTAG('a','l','a','c') },
-    { CODEC_ID_AC3,    MKTAG('a','c','-','3') },
-    { CODEC_ID_MOV_TEXT, MKTAG('t','x','3','g') },
-    { CODEC_ID_MOV_TEXT, MKTAG('t','e','x','t') },
-    { CODEC_ID_NONE, 0 },
-};
-
-static int ipod_get_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag = track->enc->codec_tag;
-
-    // keep original tag for subs, ipod supports both formats
-    if (!(track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE &&
-        (tag == MKTAG('t','x','3','g') ||
-         tag == MKTAG('t','e','x','t'))))
-        tag = ff_codec_get_tag(codec_ipod_tags, track->enc->codec_id);
-
-    if (!av_match_ext(s->filename, "m4a") && !av_match_ext(s->filename, "m4v"))
-        av_log(s, AV_LOG_WARNING, "Warning, extension is not .m4a nor .m4v "
-               "Quicktime/Ipod might not play the file\n");
-
-    return tag;
-}
-
-static int mov_get_dv_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag;
-
-    if (track->enc->height == 480) /* NTSC */
-        if  (track->enc->pix_fmt == PIX_FMT_YUV422P) tag = MKTAG('d','v','5','n');
-        else                                         tag = MKTAG('d','v','c',' ');
-    else if (track->enc->pix_fmt == PIX_FMT_YUV422P) tag = MKTAG('d','v','5','p');
-    else if (track->enc->pix_fmt == PIX_FMT_YUV420P) tag = MKTAG('d','v','c','p');
-    else                                             tag = MKTAG('d','v','p','p');
-
-    return tag;
-}
-
-static const struct {
-    enum PixelFormat pix_fmt;
-    uint32_t tag;
-    unsigned bps;
-} mov_pix_fmt_tags[] = {
-    { PIX_FMT_YUYV422, MKTAG('y','u','v','s'),  0 },
-    { PIX_FMT_UYVY422, MKTAG('2','v','u','y'),  0 },
-    { PIX_FMT_RGB555BE,MKTAG('r','a','w',' '), 16 },
-    { PIX_FMT_RGB555LE,MKTAG('L','5','5','5'), 16 },
-    { PIX_FMT_RGB565LE,MKTAG('L','5','6','5'), 16 },
-    { PIX_FMT_RGB565BE,MKTAG('B','5','6','5'), 16 },
-    { PIX_FMT_GRAY16BE,MKTAG('b','1','6','g'), 16 },
-    { PIX_FMT_RGB24,   MKTAG('r','a','w',' '), 24 },
-    { PIX_FMT_BGR24,   MKTAG('2','4','B','G'), 24 },
-    { PIX_FMT_ARGB,    MKTAG('r','a','w',' '), 32 },
-    { PIX_FMT_BGRA,    MKTAG('B','G','R','A'), 32 },
-    { PIX_FMT_RGBA,    MKTAG('R','G','B','A'), 32 },
-    { PIX_FMT_ABGR,    MKTAG('A','B','G','R'), 32 },
-    { PIX_FMT_RGB48BE, MKTAG('b','4','8','r'), 48 },
-};
-
-static int mov_get_rawvideo_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag = track->enc->codec_tag;
-    int i;
-
-    for (i = 0; i < FF_ARRAY_ELEMS(mov_pix_fmt_tags); i++) {
-        if (track->enc->pix_fmt == mov_pix_fmt_tags[i].pix_fmt) {
-            tag = mov_pix_fmt_tags[i].tag;
-            track->enc->bits_per_coded_sample = mov_pix_fmt_tags[i].bps;
-            break;
-        }
-    }
-
-    return tag;
-}
-
-static int mov_get_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag = track->enc->codec_tag;
-
-    if (!tag || (track->enc->strict_std_compliance >= FF_COMPLIANCE_NORMAL &&
-                 (tag == MKTAG('d','v','c','p') ||
-                  track->enc->codec_id == CODEC_ID_RAWVIDEO ||
-                  av_get_bits_per_sample(track->enc->codec_id)))) { // pcm audio
-        if (track->enc->codec_id == CODEC_ID_DVVIDEO)
-            tag = mov_get_dv_codec_tag(s, track);
-        else if (track->enc->codec_id == CODEC_ID_RAWVIDEO)
-            tag = mov_get_rawvideo_codec_tag(s, track);
-        else if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {
-            tag = ff_codec_get_tag(codec_movvideo_tags, track->enc->codec_id);
-            if (!tag) { // if no mac fcc found, try with Microsoft tags
-                tag = ff_codec_get_tag(ff_codec_bmp_tags, track->enc->codec_id);
-                if (tag)
-                    av_log(s, AV_LOG_INFO, "Warning, using MS style video codec tag, "
-                           "the file may be unplayable!\n");
-            }
-        } else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) {
-            tag = ff_codec_get_tag(codec_movaudio_tags, track->enc->codec_id);
-            if (!tag) { // if no mac fcc found, try with Microsoft tags
-                int ms_tag = ff_codec_get_tag(ff_codec_wav_tags, track->enc->codec_id);
-                if (ms_tag) {
-                    tag = MKTAG('m', 's', ((ms_tag >> 8) & 0xff), (ms_tag & 0xff));
-                    av_log(s, AV_LOG_INFO, "Warning, using MS style audio codec tag, "
-                           "the file may be unplayable!\n");
-                }
-            }
-        } else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE)
-            tag = ff_codec_get_tag(ff_codec_movsubtitle_tags, track->enc->codec_id);
-    }
-
-    return tag;
-}
-
-static const AVCodecTag codec_3gp_tags[] = {
-    { CODEC_ID_H263,   MKTAG('s','2','6','3') },
-    { CODEC_ID_H264,   MKTAG('a','v','c','1') },
-    { CODEC_ID_MPEG4,  MKTAG('m','p','4','v') },
-    { CODEC_ID_AAC,    MKTAG('m','p','4','a') },
-    { CODEC_ID_AMR_NB, MKTAG('s','a','m','r') },
-    { CODEC_ID_AMR_WB, MKTAG('s','a','w','b') },
-    { CODEC_ID_MOV_TEXT, MKTAG('t','x','3','g') },
-    { CODEC_ID_NONE, 0 },
-};
-
-static int mov_find_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag = track->enc->codec_tag;
-
-    if (track->mode == MODE_MP4 || track->mode == MODE_PSP)
-        tag = mp4_get_codec_tag(s, track);
-    else if (track->mode == MODE_IPOD)
-        tag = ipod_get_codec_tag(s, track);
-    else if (track->mode & MODE_3GP)
-        tag = ff_codec_get_tag(codec_3gp_tags, track->enc->codec_id);
-    else
-        tag = mov_get_codec_tag(s, track);
-
-    return tag;
-}
-
-/** Write uuid atom.
- * Needed to make file play in iPods running newest firmware
- * goes after avcC atom in moov.trak.mdia.minf.stbl.stsd.avc1
- */
-static int mov_write_uuid_tag_ipod(ByteIOContext *pb)
-{
-    put_be32(pb, 28);
-    put_tag(pb, "uuid");
-    put_be32(pb, 0x6b6840f2);
-    put_be32(pb, 0x5f244fc5);
-    put_be32(pb, 0xba39a51b);
-    put_be32(pb, 0xcf0323f3);
-    put_be32(pb, 0x0);
-    return 28;
-}
-
-static int mov_write_subtitle_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0);    /* size */
-    put_le32(pb, track->tag); // store it byteswapped
-    put_be32(pb, 0);    /* Reserved */
-    put_be16(pb, 0);    /* Reserved */
-    put_be16(pb, 1);    /* Data-reference index */
-
-    if (track->enc->extradata_size)
-        put_buffer(pb, track->enc->extradata, track->enc->extradata_size);
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_pasp_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    AVRational sar;
-    av_reduce(&sar.num, &sar.den, track->enc->sample_aspect_ratio.num,
-              track->enc->sample_aspect_ratio.den, INT_MAX);
-
-    put_be32(pb, 16);
-    put_tag(pb, "pasp");
-    put_be32(pb, track->enc->sample_aspect_ratio.num);
-    put_be32(pb, track->enc->sample_aspect_ratio.den);
-    return 16;
-}
-
-static int mov_write_video_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    char compressor_name[32];
-
-    put_be32(pb, 0); /* size */
-    put_le32(pb, track->tag); // store it byteswapped
-    put_be32(pb, 0); /* Reserved */
-    put_be16(pb, 0); /* Reserved */
-    put_be16(pb, 1); /* Data-reference index */
-
-    put_be16(pb, 0); /* Codec stream version */
-    put_be16(pb, 0); /* Codec stream revision (=0) */
-    if (track->mode == MODE_MOV) {
-        put_tag(pb, "FFMP"); /* Vendor */
-        if(track->enc->codec_id == CODEC_ID_RAWVIDEO) {
-            put_be32(pb, 0); /* Temporal Quality */
-            put_be32(pb, 0x400); /* Spatial Quality = lossless*/
-        } else {
-            put_be32(pb, 0x200); /* Temporal Quality = normal */
-            put_be32(pb, 0x200); /* Spatial Quality = normal */
-        }
-    } else {
-        put_be32(pb, 0); /* Reserved */
-        put_be32(pb, 0); /* Reserved */
-        put_be32(pb, 0); /* Reserved */
-    }
-    put_be16(pb, track->enc->width); /* Video width */
-    put_be16(pb, track->height); /* Video height */
-    put_be32(pb, 0x00480000); /* Horizontal resolution 72dpi */
-    put_be32(pb, 0x00480000); /* Vertical resolution 72dpi */
-    put_be32(pb, 0); /* Data size (= 0) */
-    put_be16(pb, 1); /* Frame count (= 1) */
-
-    memset(compressor_name,0,32);
-    /* FIXME not sure, ISO 14496-1 draft where it shall be set to 0 */
-    if (track->mode == MODE_MOV && track->enc->codec && track->enc->codec->name)
-        strncpy(compressor_name,track->enc->codec->name,31);
-    put_byte(pb, strlen(compressor_name));
-    put_buffer(pb, compressor_name, 31);
-
-    if (track->mode == MODE_MOV && track->enc->bits_per_coded_sample)
-        put_be16(pb, track->enc->bits_per_coded_sample);
-    else
-        put_be16(pb, 0x18); /* Reserved */
-    put_be16(pb, 0xffff); /* Reserved */
-    if(track->tag == MKTAG('m','p','4','v'))
-        mov_write_esds_tag(pb, track);
-    else if(track->enc->codec_id == CODEC_ID_H263)
-        mov_write_d263_tag(pb);
-    else if(track->enc->codec_id == CODEC_ID_SVQ3)
-        mov_write_svq3_tag(pb);
-    else if(track->enc->codec_id == CODEC_ID_DNXHD)
-        mov_write_avid_tag(pb, track);
-    else if(track->enc->codec_id == CODEC_ID_H264) {
-        mov_write_avcc_tag(pb, track);
-        if(track->mode == MODE_IPOD)
-            mov_write_uuid_tag_ipod(pb);
-    } else if(track->vosLen > 0)
-        mov_write_glbl_tag(pb, track);
-
-    if (track->mode == MODE_MOV &&
-        track->enc->sample_aspect_ratio.den && track->enc->sample_aspect_ratio.num &&
-        track->enc->sample_aspect_ratio.den != track->enc->sample_aspect_ratio.num) {
-        mov_write_pasp_tag(pb, track);
-    }
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_rtp_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "rtp ");
-    put_be32(pb, 0); /* Reserved */
-    put_be16(pb, 0); /* Reserved */
-    put_be16(pb, 1); /* Data-reference index */
-
-    put_be16(pb, 1); /* Hint track version */
-    put_be16(pb, 1); /* Highest compatible version */
-    put_be32(pb, track->max_packet_size); /* Max packet size */
-
-    put_be32(pb, 12); /* size */
-    put_tag(pb, "tims");
-    put_be32(pb, track->timescale);
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_stsd_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "stsd");
-    put_be32(pb, 0); /* version & flags */
-    put_be32(pb, 1); /* entry count */
-    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO)
-        mov_write_video_tag(pb, track);
-    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)
-        mov_write_audio_tag(pb, track);
-    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE)
-        mov_write_subtitle_tag(pb, track);
-    else if (track->enc->codec_tag == MKTAG('r','t','p',' '))
-        mov_write_rtp_tag(pb, track);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_ctts_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    MOVStts *ctts_entries;
-    uint32_t entries = 0;
-    uint32_t atom_size;
-    int i;
-
-    ctts_entries = av_malloc((track->entry + 1) * sizeof(*ctts_entries)); /* worst case */
-    ctts_entries[0].count = 1;
-    ctts_entries[0].duration = track->cluster[0].cts;
-    for (i=1; i<track->entry; i++) {
-        if (track->cluster[i].cts == ctts_entries[entries].duration) {
-            ctts_entries[entries].count++; /* compress */
-        } else {
-            entries++;
-            ctts_entries[entries].duration = track->cluster[i].cts;
-            ctts_entries[entries].count = 1;
-        }
-    }
-    entries++; /* last one */
-    atom_size = 16 + (entries * 8);
-    put_be32(pb, atom_size); /* size */
-    put_tag(pb, "ctts");
-    put_be32(pb, 0); /* version & flags */
-    put_be32(pb, entries); /* entry count */
-    for (i=0; i<entries; i++) {
-        put_be32(pb, ctts_entries[i].count);
-        put_be32(pb, ctts_entries[i].duration);
-    }
-    av_free(ctts_entries);
-    return atom_size;
-}
-
-/* Time to sample atom */
-static int mov_write_stts_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    MOVStts *stts_entries;
-    uint32_t entries = -1;
-    uint32_t atom_size;
-    int i;
-
-    if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO && !track->audio_vbr) {
-        stts_entries = av_malloc(sizeof(*stts_entries)); /* one entry */
-        stts_entries[0].count = track->sampleCount;
-        stts_entries[0].duration = 1;
-        entries = 1;
-    } else {
-        stts_entries = av_malloc(track->entry * sizeof(*stts_entries)); /* worst case */
-        for (i=0; i<track->entry; i++) {
-            int64_t duration = i + 1 == track->entry ?
-                track->trackDuration - track->cluster[i].dts + track->cluster[0].dts : /* readjusting */
-                track->cluster[i+1].dts - track->cluster[i].dts;
-            if (i && duration == stts_entries[entries].duration) {
-                stts_entries[entries].count++; /* compress */
-            } else {
-                entries++;
-                stts_entries[entries].duration = duration;
-                stts_entries[entries].count = 1;
-            }
-        }
-        entries++; /* last one */
-    }
-    atom_size = 16 + (entries * 8);
-    put_be32(pb, atom_size); /* size */
-    put_tag(pb, "stts");
-    put_be32(pb, 0); /* version & flags */
-    put_be32(pb, entries); /* entry count */
-    for (i=0; i<entries; i++) {
-        put_be32(pb, stts_entries[i].count);
-        put_be32(pb, stts_entries[i].duration);
-    }
-    av_free(stts_entries);
-    return atom_size;
-}
-
-static int mov_write_dref_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 28); /* size */
-    put_tag(pb, "dref");
-    put_be32(pb, 0); /* version & flags */
-    put_be32(pb, 1); /* entry count */
-
-    put_be32(pb, 0xc); /* size */
-    put_tag(pb, "url ");
-    put_be32(pb, 1); /* version & flags */
-
-    return 28;
-}
-
-static int mov_write_stbl_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "stbl");
-    mov_write_stsd_tag(pb, track);
-    mov_write_stts_tag(pb, track);
-    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||
-         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&
-        track->hasKeyframes && track->hasKeyframes < track->entry)
-        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);
-    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)
-        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);
-    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&
-        track->flags & MOV_TRACK_CTTS)
-        mov_write_ctts_tag(pb, track);
-    mov_write_stsc_tag(pb, track);
-    mov_write_stsz_tag(pb, track);
-    mov_write_stco_tag(pb, track);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_dinf_tag(ByteIOContext *pb)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "dinf");
-    mov_write_dref_tag(pb);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_nmhd_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 12);
-    put_tag(pb, "nmhd");
-    put_be32(pb, 0);
-    return 12;
-}
-
-static int mov_write_gmhd_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 0x20);   /* size */
-    put_tag(pb, "gmhd");
-    put_be32(pb, 0x18);   /* gmin size */
-    put_tag(pb, "gmin");  /* generic media info */
-    put_be32(pb, 0);      /* version & flags */
-    put_be16(pb, 0x40);   /* graphics mode = */
-    put_be16(pb, 0x8000); /* opColor (r?) */
-    put_be16(pb, 0x8000); /* opColor (g?) */
-    put_be16(pb, 0x8000); /* opColor (b?) */
-    put_be16(pb, 0);      /* balance */
-    put_be16(pb, 0);      /* reserved */
-    return 0x20;
-}
-
-static int mov_write_smhd_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 16); /* size */
-    put_tag(pb, "smhd");
-    put_be32(pb, 0); /* version & flags */
-    put_be16(pb, 0); /* reserved (balance, normally = 0) */
-    put_be16(pb, 0); /* reserved */
-    return 16;
-}
-
-static int mov_write_vmhd_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 0x14); /* size (always 0x14) */
-    put_tag(pb, "vmhd");
-    put_be32(pb, 0x01); /* version & flags */
-    put_be64(pb, 0); /* reserved (graphics mode = copy) */
-    return 0x14;
-}
-
-static int mov_write_hdlr_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    const char *hdlr, *descr = NULL, *hdlr_type = NULL;
-    int64_t pos = url_ftell(pb);
-
-    if (!track) { /* no media --> data handler */
-        hdlr = "dhlr";
-        hdlr_type = "url ";
-        descr = "DataHandler";
-    } else {
-        hdlr = (track->mode == MODE_MOV) ? "mhlr" : "\0\0\0\0";
-        if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {
-            hdlr_type = "vide";
-            descr = "VideoHandler";
-        } else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) {
-            hdlr_type = "soun";
-            descr = "SoundHandler";
-        } else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {
-            if (track->tag == MKTAG('t','x','3','g')) hdlr_type = "sbtl";
-            else                                      hdlr_type = "text";
-            descr = "SubtitleHandler";
-        } else if (track->enc->codec_tag == MKTAG('r','t','p',' ')) {
-            hdlr_type = "hint";
-            descr = "HintHandler";
-        }
-    }
-
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "hdlr");
-    put_be32(pb, 0); /* Version & flags */
-    put_buffer(pb, hdlr, 4); /* handler */
-    put_tag(pb, hdlr_type); /* handler type */
-    put_be32(pb ,0); /* reserved */
-    put_be32(pb ,0); /* reserved */
-    put_be32(pb ,0); /* reserved */
-    if (!track || track->mode == MODE_MOV)
-        put_byte(pb, strlen(descr)); /* pascal string */
-    put_buffer(pb, descr, strlen(descr)); /* handler description */
-    if (track && track->mode != MODE_MOV)
-        put_byte(pb, 0); /* c string */
-    return updateSize(pb, pos);
-}
-
-static int mov_write_hmhd_tag(ByteIOContext *pb)
-{
-    /* This atom must be present, but leaving the values at zero
-     * seems harmless. */
-    put_be32(pb, 28); /* size */
-    put_tag(pb, "hmhd");
-    put_be32(pb, 0); /* version, flags */
-    put_be16(pb, 0); /* maxPDUsize */
-    put_be16(pb, 0); /* avgPDUsize */
-    put_be32(pb, 0); /* maxbitrate */
-    put_be32(pb, 0); /* avgbitrate */
-    put_be32(pb, 0); /* reserved */
-    return 28;
-}
-
-static int mov_write_minf_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "minf");
-    if(track->enc->codec_type == AVMEDIA_TYPE_VIDEO)
-        mov_write_vmhd_tag(pb);
-    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)
-        mov_write_smhd_tag(pb);
-    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {
-        if (track->tag == MKTAG('t','e','x','t')) mov_write_gmhd_tag(pb);
-        else                                      mov_write_nmhd_tag(pb);
-    } else if (track->tag == MKTAG('r','t','p',' ')) {
-        mov_write_hmhd_tag(pb);
-    }
-    if (track->mode == MODE_MOV) /* FIXME: Why do it for MODE_MOV only ? */
-        mov_write_hdlr_tag(pb, NULL);
-    mov_write_dinf_tag(pb);
-    mov_write_stbl_tag(pb, track);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_mdhd_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int version = track->trackDuration < INT32_MAX ? 0 : 1;
-
-    (version == 1) ? put_be32(pb, 44) : put_be32(pb, 32); /* size */
-    put_tag(pb, "mdhd");
-    put_byte(pb, version);
-    put_be24(pb, 0); /* flags */
-    if (version == 1) {
-        put_be64(pb, track->time);
-        put_be64(pb, track->time);
-    } else {
-        put_be32(pb, track->time); /* creation time */
-        put_be32(pb, track->time); /* modification time */
-    }
-    put_be32(pb, track->timescale); /* time scale (sample rate for audio) */
-    (version == 1) ? put_be64(pb, track->trackDuration) : put_be32(pb, track->trackDuration); /* duration */
-    put_be16(pb, track->language); /* language */
-    put_be16(pb, 0); /* reserved (quality) */
-
-    if(version!=0 && track->mode == MODE_MOV){
-        av_log(NULL, AV_LOG_ERROR,
-            "FATAL error, file duration too long for timebase, this file will not be\n"
-            "playable with quicktime. Choose a different timebase or a different\n"
-            "container format\n");
-    }
-
-    return 32;
-}
-
-static int mov_write_mdia_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "mdia");
-    mov_write_mdhd_tag(pb, track);
-    mov_write_hdlr_tag(pb, track);
-    mov_write_minf_tag(pb, track);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_tkhd_tag(ByteIOContext *pb, MOVTrack *track, AVStream *st)
-{
-    int64_t duration = av_rescale_rnd(track->trackDuration, MOV_TIMESCALE,
-                                      track->timescale, AV_ROUND_UP);
-    int version = duration < INT32_MAX ? 0 : 1;
-
-    (version == 1) ? put_be32(pb, 104) : put_be32(pb, 92); /* size */
-    put_tag(pb, "tkhd");
-    put_byte(pb, version);
-    put_be24(pb, 0xf); /* flags (track enabled) */
-    if (version == 1) {
-        put_be64(pb, track->time);
-        put_be64(pb, track->time);
-    } else {
-        put_be32(pb, track->time); /* creation time */
-        put_be32(pb, track->time); /* modification time */
-    }
-    put_be32(pb, track->trackID); /* track-id */
-    put_be32(pb, 0); /* reserved */
-    (version == 1) ? put_be64(pb, duration) : put_be32(pb, duration);
-
-    put_be32(pb, 0); /* reserved */
-    put_be32(pb, 0); /* reserved */
-    put_be32(pb, 0x0); /* reserved (Layer & Alternate group) */
-    /* Volume, only for audio */
-    if(track->enc->codec_type == AVMEDIA_TYPE_AUDIO)
-        put_be16(pb, 0x0100);
-    else
-        put_be16(pb, 0);
-    put_be16(pb, 0); /* reserved */
-
-    /* Matrix structure */
-    put_be32(pb, 0x00010000); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x00010000); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x40000000); /* reserved */
-
-    /* Track width and height, for visual only */
-    if(st && (track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||
-              track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE)) {
-        double sample_aspect_ratio = av_q2d(st->sample_aspect_ratio);
-        if(!sample_aspect_ratio || track->height != track->enc->height)
-            sample_aspect_ratio = 1;
-        put_be32(pb, sample_aspect_ratio * track->enc->width*0x10000);
-        put_be32(pb, track->height*0x10000);
-    }
-    else {
-        put_be32(pb, 0);
-        put_be32(pb, 0);
-    }
-    return 0x5c;
-}
-
-// This box seems important for the psp playback ... without it the movie seems to hang
-static int mov_write_edts_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    put_be32(pb, 0x24); /* size  */
-    put_tag(pb, "edts");
-    put_be32(pb, 0x1c); /* size  */
-    put_tag(pb, "elst");
-    put_be32(pb, 0x0);
-    put_be32(pb, 0x1);
-
-    /* duration   ... doesn't seem to effect psp */
-    put_be32(pb, av_rescale_rnd(track->trackDuration, MOV_TIMESCALE,
-                                track->timescale, AV_ROUND_UP));
-
-    put_be32(pb, track->cluster[0].cts); /* first pts is cts since dts is 0 */
-    put_be32(pb, 0x00010000);
-    return 0x24;
-}
-
-static int mov_write_tref_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    put_be32(pb, 20);   // size
-    put_tag(pb, "tref");
-    put_be32(pb, 12);   // size (subatom)
-    put_le32(pb, track->tref_tag);
-    put_be32(pb, track->tref_id);
-    return 20;
-}
-
-// goes at the end of each track!  ... Critical for PSP playback ("Incompatible data" without it)
-static int mov_write_uuid_tag_psp(ByteIOContext *pb, MOVTrack *mov)
-{
-    put_be32(pb, 0x34); /* size ... reports as 28 in mp4box! */
-    put_tag(pb, "uuid");
-    put_tag(pb, "USMT");
-    put_be32(pb, 0x21d24fce);
-    put_be32(pb, 0xbb88695c);
-    put_be32(pb, 0xfac9c740);
-    put_be32(pb, 0x1c);     // another size here!
-    put_tag(pb, "MTDT");
-    put_be32(pb, 0x00010012);
-    put_be32(pb, 0x0a);
-    put_be32(pb, 0x55c40000);
-    put_be32(pb, 0x1);
-    put_be32(pb, 0x0);
-    return 0x34;
-}
-
-static int mov_write_udta_sdp(ByteIOContext *pb, AVCodecContext *ctx, int index)
-{
-    char buf[1000] = "";
-    int len;
-
-    ff_sdp_write_media(buf, sizeof(buf), ctx, NULL, 0, 0);
-    av_strlcatf(buf, sizeof(buf), "a=control:streamid=%d\r\n", index);
-    len = strlen(buf);
-
-    put_be32(pb, len + 24);
-    put_tag (pb, "udta");
-    put_be32(pb, len + 16);
-    put_tag (pb, "hnti");
-    put_be32(pb, len + 8);
-    put_tag (pb, "sdp ");
-    put_buffer(pb, buf, len);
-    return len + 24;
-}
-
-static int mov_write_trak_tag(ByteIOContext *pb, MOVTrack *track, AVStream *st)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "trak");
-    mov_write_tkhd_tag(pb, track, st);
-    if (track->mode == MODE_PSP || track->flags & MOV_TRACK_CTTS)
-        mov_write_edts_tag(pb, track);  // PSP Movies require edts box
-    if (track->tref_tag)
-        mov_write_tref_tag(pb, track);
-    mov_write_mdia_tag(pb, track);
-    if (track->mode == MODE_PSP)
-        mov_write_uuid_tag_psp(pb,track);  // PSP Movies require this uuid box
-    if (track->tag == MKTAG('r','t','p',' '))
-        mov_write_udta_sdp(pb, track->rtp_ctx->streams[0]->codec, track->trackID);
-    return updateSize(pb, pos);
-}
-
-#if 0
-/* TODO: Not sorted out, but not necessary either */
-static int mov_write_iods_tag(ByteIOContext *pb, MOVMuxContext *mov)
-{
-    put_be32(pb, 0x15); /* size */
-    put_tag(pb, "iods");
-    put_be32(pb, 0);    /* version & flags */
-    put_be16(pb, 0x1007);
-    put_byte(pb, 0);
-    put_be16(pb, 0x4fff);
-    put_be16(pb, 0xfffe);
-    put_be16(pb, 0x01ff);
-    return 0x15;
-}
-#endif
-
-static int mov_write_mvhd_tag(ByteIOContext *pb, MOVMuxContext *mov)
-{
-    int maxTrackID = 1, i;
-    int64_t maxTrackLenTemp, maxTrackLen = 0;
-    int version;
-
-    for (i=0; i<mov->nb_streams; i++) {
-        if(mov->tracks[i].entry > 0) {
-            maxTrackLenTemp = av_rescale_rnd(mov->tracks[i].trackDuration,
-                                             MOV_TIMESCALE,
-                                             mov->tracks[i].timescale,
-                                             AV_ROUND_UP);
-            if(maxTrackLen < maxTrackLenTemp)
-                maxTrackLen = maxTrackLenTemp;
-            if(maxTrackID < mov->tracks[i].trackID)
-                maxTrackID = mov->tracks[i].trackID;
-        }
-    }
-
-    version = maxTrackLen < UINT32_MAX ? 0 : 1;
-    (version == 1) ? put_be32(pb, 120) : put_be32(pb, 108); /* size */
-    put_tag(pb, "mvhd");
-    put_byte(pb, version);
-    put_be24(pb, 0); /* flags */
-    if (version == 1) {
-        put_be64(pb, mov->time);
-        put_be64(pb, mov->time);
-    } else {
-        put_be32(pb, mov->time); /* creation time */
-        put_be32(pb, mov->time); /* modification time */
-    }
-    put_be32(pb, MOV_TIMESCALE);
-    (version == 1) ? put_be64(pb, maxTrackLen) : put_be32(pb, maxTrackLen); /* duration of longest track */
-
-    put_be32(pb, 0x00010000); /* reserved (preferred rate) 1.0 = normal */
-    put_be16(pb, 0x0100); /* reserved (preferred volume) 1.0 = normal */
-    put_be16(pb, 0); /* reserved */
-    put_be32(pb, 0); /* reserved */
-    put_be32(pb, 0); /* reserved */
-
-    /* Matrix structure */
-    put_be32(pb, 0x00010000); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x00010000); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x40000000); /* reserved */
-
-    put_be32(pb, 0); /* reserved (preview time) */
-    put_be32(pb, 0); /* reserved (preview duration) */
-    put_be32(pb, 0); /* reserved (poster time) */
-    put_be32(pb, 0); /* reserved (selection time) */
-    put_be32(pb, 0); /* reserved (selection duration) */
-    put_be32(pb, 0); /* reserved (current time) */
-    put_be32(pb, maxTrackID+1); /* Next track id */
-    return 0x6c;
-}
-
-static int mov_write_itunes_hdlr_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                                     AVFormatContext *s)
-{
-    put_be32(pb, 33); /* size */
-    put_tag(pb, "hdlr");
-    put_be32(pb, 0);
-    put_be32(pb, 0);
-    put_tag(pb, "mdir");
-    put_tag(pb, "appl");
-    put_be32(pb, 0);
-    put_be32(pb, 0);
-    put_byte(pb, 0);
-    return 33;
-}
-
-/* helper function to write a data tag with the specified string as data */
-static int mov_write_string_data_tag(ByteIOContext *pb, const char *data, int lang, int long_style)
-{
-    if(long_style){
-        int size = 16 + strlen(data);
-        put_be32(pb, size); /* size */
-        put_tag(pb, "data");
-        put_be32(pb, 1);
-        put_be32(pb, 0);
-        put_buffer(pb, data, strlen(data));
-        return size;
-    }else{
-        if (!lang)
-            lang = ff_mov_iso639_to_lang("und", 1);
-        put_be16(pb, strlen(data)); /* string length */
-        put_be16(pb, lang);
-        put_buffer(pb, data, strlen(data));
-        return strlen(data) + 4;
-    }
-}
-
-static int mov_write_string_tag(ByteIOContext *pb, const char *name, const char *value, int lang, int long_style){
-    int size = 0;
-    if (value && value[0]) {
-        int64_t pos = url_ftell(pb);
-        put_be32(pb, 0); /* size */
-        put_tag(pb, name);
-        mov_write_string_data_tag(pb, value, lang, long_style);
-        size= updateSize(pb, pos);
-    }
-    return size;
-}
-
-static int mov_write_string_metadata(AVFormatContext *s, ByteIOContext *pb,
-                                     const char *name, const char *tag,
-                                     int long_style)
-{
-    int l, lang = 0, len, len2;
-    AVMetadataTag *t, *t2 = NULL;
-    char tag2[16];
-
-    if (!(t = av_metadata_get(s->metadata, tag, NULL, 0)))
-        return 0;
-
-    len = strlen(t->key);
-    snprintf(tag2, sizeof(tag2), "%s-", tag);
-    while ((t2 = av_metadata_get(s->metadata, tag2, t2, AV_METADATA_IGNORE_SUFFIX))) {
-        len2 = strlen(t2->key);
-        if (len2 == len+4 && !strcmp(t->value, t2->value)
-            && (l=ff_mov_iso639_to_lang(&t2->key[len2-3], 1)) >= 0) {
-            lang = l;
-            break;
-        }
-    }
-    return mov_write_string_tag(pb, name, t->value, lang, long_style);
-}
-
-/* iTunes track number */
-static int mov_write_trkn_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                              AVFormatContext *s)
-{
-    AVMetadataTag *t = av_metadata_get(s->metadata, "track", NULL, 0);
-    int size = 0, track = t ? atoi(t->value) : 0;
-    if (track) {
-        put_be32(pb, 32); /* size */
-        put_tag(pb, "trkn");
-            put_be32(pb, 24); /* size */
-            put_tag(pb, "data");
-            put_be32(pb, 0);        // 8 bytes empty
-            put_be32(pb, 0);
-            put_be16(pb, 0);        // empty
-            put_be16(pb, track);    // track number
-            put_be16(pb, 0);        // total track number
-            put_be16(pb, 0);        // empty
-        size = 32;
-    }
-    return size;
-}
-
-/* iTunes meta data list */
-static int mov_write_ilst_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                              AVFormatContext *s)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "ilst");
-    mov_write_string_metadata(s, pb, "\251nam", "title"    , 1);
-    mov_write_string_metadata(s, pb, "\251ART", "artist"   , 1);
-    mov_write_string_metadata(s, pb, "aART", "album_artist", 1);
-    mov_write_string_metadata(s, pb, "\251wrt", "composer" , 1);
-    mov_write_string_metadata(s, pb, "\251alb", "album"    , 1);
-    mov_write_string_metadata(s, pb, "\251day", "date"     , 1);
-    mov_write_string_tag(pb, "\251too", LIBAVFORMAT_IDENT, 0, 1);
-    mov_write_string_metadata(s, pb, "\251cmt", "comment"  , 1);
-    mov_write_string_metadata(s, pb, "\251gen", "genre"    , 1);
-    mov_write_string_metadata(s, pb, "\251cpy", "copyright", 1);
-    mov_write_string_metadata(s, pb, "\251grp", "grouping" , 1);
-    mov_write_string_metadata(s, pb, "\251lyr", "lyrics"   , 1);
-    mov_write_string_metadata(s, pb, "desc",    "description",1);
-    mov_write_string_metadata(s, pb, "ldes",    "synopsis" , 1);
-    mov_write_string_metadata(s, pb, "tvsh",    "show"     , 1);
-    mov_write_string_metadata(s, pb, "tven",    "episode_id",1);
-    mov_write_string_metadata(s, pb, "tvnn",    "network"  , 1);
-    mov_write_trkn_tag(pb, mov, s);
-    return updateSize(pb, pos);
-}
-
-/* iTunes meta data tag */
-static int mov_write_meta_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                              AVFormatContext *s)
-{
-    int size = 0;
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "meta");
-    put_be32(pb, 0);
-    mov_write_itunes_hdlr_tag(pb, mov, s);
-    mov_write_ilst_tag(pb, mov, s);
-    size = updateSize(pb, pos);
-    return size;
-}
-
-static int utf8len(const uint8_t *b)
-{
-    int len=0;
-    int val;
-    while(*b){
-        GET_UTF8(val, *b++, return -1;)
-        len++;
-    }
-    return len;
-}
-
-static int ascii_to_wc(ByteIOContext *pb, const uint8_t *b)
-{
-    int val;
-    while(*b){
-        GET_UTF8(val, *b++, return -1;)
-        put_be16(pb, val);
-    }
-    put_be16(pb, 0x00);
-    return 0;
-}
-
-static uint16_t language_code(const char *str)
-{
-    return (((str[0]-0x60) & 0x1F) << 10) + (((str[1]-0x60) & 0x1F) << 5) + ((str[2]-0x60) & 0x1F);
-}
-
-static int mov_write_3gp_udta_tag(ByteIOContext *pb, AVFormatContext *s,
-                                  const char *tag, const char *str)
-{
-    int64_t pos = url_ftell(pb);
-    AVMetadataTag *t = av_metadata_get(s->metadata, str, NULL, 0);
-    if (!t || !utf8len(t->value))
-        return 0;
-    put_be32(pb, 0);   /* size */
-    put_tag (pb, tag); /* type */
-    put_be32(pb, 0);   /* version + flags */
-    if (!strcmp(tag, "yrrc"))
-        put_be16(pb, atoi(t->value));
-    else {
-        put_be16(pb, language_code("eng")); /* language */
-        put_buffer(pb, t->value, strlen(t->value)+1); /* UTF8 string value */
-        if (!strcmp(tag, "albm") &&
-            (t = av_metadata_get(s->metadata, "track", NULL, 0)))
-            put_byte(pb, atoi(t->value));
-    }
-    return updateSize(pb, pos);
-}
-
-static int mov_write_chpl_tag(ByteIOContext *pb, AVFormatContext *s)
-{
-    int64_t pos = url_ftell(pb);
-    int i, nb_chapters = FFMIN(s->nb_chapters, 255);
-
-    put_be32(pb, 0);            // size
-    put_tag (pb, "chpl");
-    put_be32(pb, 0x01000000);   // version + flags
-    put_be32(pb, 0);            // unknown
-    put_byte(pb, nb_chapters);
-
-    for (i = 0; i < nb_chapters; i++) {
-        AVChapter *c = s->chapters[i];
-        AVMetadataTag *t;
-        put_be64(pb, av_rescale_q(c->start, c->time_base, (AVRational){1,10000000}));
-
-        if ((t = av_metadata_get(c->metadata, "title", NULL, 0))) {
-            int len = FFMIN(strlen(t->value), 255);
-            put_byte(pb, len);
-            put_buffer(pb, t->value, len);
-        } else
-            put_byte(pb, 0);
-    }
-    return updateSize(pb, pos);
-}
-
-static int mov_write_udta_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                              AVFormatContext *s)
-{
-    ByteIOContext *pb_buf;
-    int i, ret, size;
-    uint8_t *buf;
-
-    for (i = 0; i < s->nb_streams; i++)
-        if (mov->tracks[i].enc->flags & CODEC_FLAG_BITEXACT) {
-            return 0;
-        }
-
-    ret = url_open_dyn_buf(&pb_buf);
-    if(ret < 0)
-        return ret;
-
-        if (mov->mode & MODE_3GP) {
-            mov_write_3gp_udta_tag(pb_buf, s, "perf", "artist");
-            mov_write_3gp_udta_tag(pb_buf, s, "titl", "title");
-            mov_write_3gp_udta_tag(pb_buf, s, "auth", "author");
-            mov_write_3gp_udta_tag(pb_buf, s, "gnre", "genre");
-            mov_write_3gp_udta_tag(pb_buf, s, "dscp", "comment");
-            mov_write_3gp_udta_tag(pb_buf, s, "albm", "album");
-            mov_write_3gp_udta_tag(pb_buf, s, "cprt", "copyright");
-            mov_write_3gp_udta_tag(pb_buf, s, "yrrc", "date");
-        } else if (mov->mode == MODE_MOV) { // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4
-            mov_write_string_metadata(s, pb_buf, "\251nam", "title"      , 0);
-            mov_write_string_metadata(s, pb_buf, "\251aut", "author"     , 0);
-            mov_write_string_metadata(s, pb_buf, "\251alb", "album"      , 0);
-            mov_write_string_metadata(s, pb_buf, "\251day", "date"       , 0);
-            mov_write_string_tag(pb_buf, "\251enc", LIBAVFORMAT_IDENT, 0, 0);
-            mov_write_string_metadata(s, pb_buf, "\251des", "comment"    , 0);
-            mov_write_string_metadata(s, pb_buf, "\251gen", "genre"      , 0);
-            mov_write_string_metadata(s, pb_buf, "\251cpy", "copyright"  , 0);
-        } else {
-            /* iTunes meta data */
-            mov_write_meta_tag(pb_buf, mov, s);
-        }
-
-        if (s->nb_chapters)
-            mov_write_chpl_tag(pb_buf, s);
-
-    if ((size = url_close_dyn_buf(pb_buf, &buf)) > 0) {
-        put_be32(pb, size+8);
-        put_tag(pb, "udta");
-        put_buffer(pb, buf, size);
-    }
-    av_free(buf);
-
-    return 0;
-}
-
-static void mov_write_psp_udta_tag(ByteIOContext *pb,
-                                  const char *str, const char *lang, int type)
-{
-    int len = utf8len(str)+1;
-    if(len<=0)
-        return;
-    put_be16(pb, len*2+10);            /* size */
-    put_be32(pb, type);                /* type */
-    put_be16(pb, language_code(lang)); /* language */
-    put_be16(pb, 0x01);                /* ? */
-    ascii_to_wc(pb, str);
-}
-
-static int mov_write_uuidusmt_tag(ByteIOContext *pb, AVFormatContext *s)
-{
-    AVMetadataTag *title = av_metadata_get(s->metadata, "title", NULL, 0);
-    int64_t pos, pos2;
-
-    if (title) {
-        pos = url_ftell(pb);
-        put_be32(pb, 0); /* size placeholder*/
-        put_tag(pb, "uuid");
-        put_tag(pb, "USMT");
-        put_be32(pb, 0x21d24fce); /* 96 bit UUID */
-        put_be32(pb, 0xbb88695c);
-        put_be32(pb, 0xfac9c740);
-
-        pos2 = url_ftell(pb);
-        put_be32(pb, 0); /* size placeholder*/
-        put_tag(pb, "MTDT");
-        put_be16(pb, 4);
-
-        // ?
-        put_be16(pb, 0x0C);                 /* size */
-        put_be32(pb, 0x0B);                 /* type */
-        put_be16(pb, language_code("und")); /* language */
-        put_be16(pb, 0x0);                  /* ? */
-        put_be16(pb, 0x021C);               /* data */
-
-        mov_write_psp_udta_tag(pb, LIBAVCODEC_IDENT,      "eng", 0x04);
-        mov_write_psp_udta_tag(pb, title->value,          "eng", 0x01);
-//        snprintf(dt,32,"%04d/%02d/%02d %02d:%02d:%02d",t_st->tm_year+1900,t_st->tm_mon+1,t_st->tm_mday,t_st->tm_hour,t_st->tm_min,t_st->tm_sec);
-        mov_write_psp_udta_tag(pb, "2006/04/01 11:11:11", "und", 0x03);
-
-        updateSize(pb, pos2);
-        return updateSize(pb, pos);
-    }
-
-    return 0;
-}
-
-static int mov_write_moov_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                              AVFormatContext *s)
-{
-    int i;
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size placeholder*/
-    put_tag(pb, "moov");
-
-    for (i=0; i<mov->nb_streams; i++) {
-        if(mov->tracks[i].entry <= 0) continue;
-
-        mov->tracks[i].time = mov->time;
-        mov->tracks[i].trackID = i+1;
-    }
-
-    if (mov->chapter_track)
-        for (i=0; i<s->nb_streams; i++) {
-            mov->tracks[i].tref_tag = MKTAG('c','h','a','p');
-            mov->tracks[i].tref_id = mov->tracks[mov->chapter_track].trackID;
-        }
-    for (i = 0; i < mov->nb_streams; i++) {
-        if (mov->tracks[i].tag == MKTAG('r','t','p',' ')) {
-            mov->tracks[i].tref_tag = MKTAG('h','i','n','t');
-            mov->tracks[i].tref_id =
-                mov->tracks[mov->tracks[i].src_track].trackID;
-        }
-    }
-
-    mov_write_mvhd_tag(pb, mov);
-    //mov_write_iods_tag(pb, mov);
-    for (i=0; i<mov->nb_streams; i++) {
-        if(mov->tracks[i].entry > 0) {
-            mov_write_trak_tag(pb, &(mov->tracks[i]), i < s->nb_streams ? s->streams[i] : NULL);
-        }
-    }
-
-    if (mov->mode == MODE_PSP)
-        mov_write_uuidusmt_tag(pb, s);
-    else
-        mov_write_udta_tag(pb, mov, s);
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_mdat_tag(ByteIOContext *pb, MOVMuxContext *mov)
-{
-    put_be32(pb, 8);    // placeholder for extended size field (64 bit)
-    put_tag(pb, mov->mode == MODE_MOV ? "wide" : "free");
-
-    mov->mdat_pos = url_ftell(pb);
-    put_be32(pb, 0); /* size placeholder*/
-    put_tag(pb, "mdat");
-    return 0;
-}
-
-/* TODO: This needs to be more general */
-static int mov_write_ftyp_tag(ByteIOContext *pb, AVFormatContext *s)
-{
-    MOVMuxContext *mov = s->priv_data;
-    int64_t pos = url_ftell(pb);
-    int has_h264 = 0, has_video = 0;
-    int minor = 0x200;
-    int i;
-
-    for (i = 0; i < s->nb_streams; i++) {
-        AVStream *st = s->streams[i];
-        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
-            has_video = 1;
-        if (st->codec->codec_id == CODEC_ID_H264)
-            has_h264 = 1;
-    }
-
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "ftyp");
-
-    if (mov->mode == MODE_3GP) {
-        put_tag(pb, has_h264 ? "3gp6"  : "3gp4");
-        minor =     has_h264 ?   0x100 :   0x200;
-    } else if (mov->mode & MODE_3G2) {
-        put_tag(pb, has_h264 ? "3g2b"  : "3g2a");
-        minor =     has_h264 ? 0x20000 : 0x10000;
-    }else if (mov->mode == MODE_PSP)
-        put_tag(pb, "MSNV");
-    else if (mov->mode == MODE_MP4)
-        put_tag(pb, "isom");
-    else if (mov->mode == MODE_IPOD)
-        put_tag(pb, has_video ? "M4V ":"M4A ");
-    else
-        put_tag(pb, "qt  ");
-
-    put_be32(pb, minor);
-
-    if(mov->mode == MODE_MOV)
-        put_tag(pb, "qt  ");
-    else{
-        put_tag(pb, "isom");
-        put_tag(pb, "iso2");
-        if(has_h264)
-            put_tag(pb, "avc1");
-    }
-
-    if (mov->mode == MODE_3GP)
-        put_tag(pb, has_h264 ? "3gp6":"3gp4");
-    else if (mov->mode & MODE_3G2)
-        put_tag(pb, has_h264 ? "3g2b":"3g2a");
-    else if (mov->mode == MODE_PSP)
-        put_tag(pb, "MSNV");
-    else if (mov->mode == MODE_MP4)
-        put_tag(pb, "mp41");
-    return updateSize(pb, pos);
-}
-
-static void mov_write_uuidprof_tag(ByteIOContext *pb, AVFormatContext *s)
-{
-    AVCodecContext *VideoCodec = s->streams[0]->codec;
-    AVCodecContext *AudioCodec = s->streams[1]->codec;
-    int AudioRate = AudioCodec->sample_rate;
-    int FrameRate = ((VideoCodec->time_base.den) * (0x10000))/ (VideoCodec->time_base.num);
-    int audio_kbitrate= AudioCodec->bit_rate / 1000;
-    int video_kbitrate= FFMIN(VideoCodec->bit_rate / 1000, 800 - audio_kbitrate);
-
-    put_be32(pb, 0x94); /* size */
-    put_tag(pb, "uuid");
-    put_tag(pb, "PROF");
-
-    put_be32(pb, 0x21d24fce); /* 96 bit UUID */
-    put_be32(pb, 0xbb88695c);
-    put_be32(pb, 0xfac9c740);
-
-    put_be32(pb, 0x0);  /* ? */
-    put_be32(pb, 0x3);  /* 3 sections ? */
-
-    put_be32(pb, 0x14); /* size */
-    put_tag(pb, "FPRF");
-    put_be32(pb, 0x0);  /* ? */
-    put_be32(pb, 0x0);  /* ? */
-    put_be32(pb, 0x0);  /* ? */
-
-    put_be32(pb, 0x2c);  /* size */
-    put_tag(pb, "APRF");   /* audio */
-    put_be32(pb, 0x0);
-    put_be32(pb, 0x2);   /* TrackID */
-    put_tag(pb, "mp4a");
-    put_be32(pb, 0x20f);
-    put_be32(pb, 0x0);
-    put_be32(pb, audio_kbitrate);
-    put_be32(pb, audio_kbitrate);
-    put_be32(pb, AudioRate);
-    put_be32(pb, AudioCodec->channels);
-
-    put_be32(pb, 0x34);  /* size */
-    put_tag(pb, "VPRF");   /* video */
-    put_be32(pb, 0x0);
-    put_be32(pb, 0x1);    /* TrackID */
-    if (VideoCodec->codec_id == CODEC_ID_H264) {
-        put_tag(pb, "avc1");
-        put_be16(pb, 0x014D);
-        put_be16(pb, 0x0015);
-    } else {
-        put_tag(pb, "mp4v");
-        put_be16(pb, 0x0000);
-        put_be16(pb, 0x0103);
-    }
-    put_be32(pb, 0x0);
-    put_be32(pb, video_kbitrate);
-    put_be32(pb, video_kbitrate);
-    put_be32(pb, FrameRate);
-    put_be32(pb, FrameRate);
-    put_be16(pb, VideoCodec->width);
-    put_be16(pb, VideoCodec->height);
-    put_be32(pb, 0x010001); /* ? */
-}
-
-static int mov_parse_mpeg2_frame(AVPacket *pkt, uint32_t *flags)
-{
-    uint32_t c = -1;
-    int i, closed_gop = 0;
-
-    for (i = 0; i < pkt->size - 4; i++) {
-        c = (c<<8) + pkt->data[i];
-        if (c == 0x1b8) { // gop
-            closed_gop = pkt->data[i+4]>>6 & 0x01;
-        } else if (c == 0x100) { // pic
-            int temp_ref = (pkt->data[i+1]<<2) | (pkt->data[i+2]>>6);
-            if (!temp_ref || closed_gop) // I picture is not reordered
-                *flags = MOV_SYNC_SAMPLE;
-            else
-                *flags = MOV_PARTIAL_SYNC_SAMPLE;
-            break;
-        }
-    }
-    return 0;
-}
-
-int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)
-{
-    MOVMuxContext *mov = s->priv_data;
-    ByteIOContext *pb = s->pb;
-    MOVTrack *trk = &mov->tracks[pkt->stream_index];
-    AVCodecContext *enc = trk->enc;
-    unsigned int samplesInChunk = 0;
-    int size= pkt->size;
-
-    if (url_is_streamed(s->pb)) return 0; /* Can't handle that */
-    if (!size) return 0; /* Discard 0 sized packets */
-
-    if (enc->codec_id == CODEC_ID_AMR_NB) {
-        /* We must find out how many AMR blocks there are in one packet */
-        static uint16_t packed_size[16] =
-            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0};
-        int len = 0;
-
-        while (len < size && samplesInChunk < 100) {
-            len += packed_size[(pkt->data[len] >> 3) & 0x0F];
-            samplesInChunk++;
-        }
-        if(samplesInChunk > 1){
-            av_log(s, AV_LOG_ERROR, "fatal error, input is not a single packet, implement a AVParser for it\n");
-            return -1;
-        }
-    } else if (trk->sampleSize)
-        samplesInChunk = size/trk->sampleSize;
-    else
-        samplesInChunk = 1;
-
-    /* copy extradata if it exists */
-    if (trk->vosLen == 0 && enc->extradata_size > 0) {
-        trk->vosLen = enc->extradata_size;
-        trk->vosData = av_malloc(trk->vosLen);
-        memcpy(trk->vosData, enc->extradata, trk->vosLen);
-    }
-
-    if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) {
-        /* from x264 or from bytestream h264 */
-        /* nal reformating needed */
-        size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);
-    } else {
-        put_buffer(pb, pkt->data, size);
-    }
-
-    if ((enc->codec_id == CODEC_ID_DNXHD ||
-         enc->codec_id == CODEC_ID_AC3) && !trk->vosLen) {
-        /* copy frame to create needed atoms */
-        trk->vosLen = size;
-        trk->vosData = av_malloc(size);
-        if (!trk->vosData)
-            return AVERROR(ENOMEM);
-        memcpy(trk->vosData, pkt->data, size);
-    }
-
-    if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) {
-        trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster));
-        if (!trk->cluster)
-            return -1;
-    }
-
-    trk->cluster[trk->entry].pos = url_ftell(pb) - size;
-    trk->cluster[trk->entry].samplesInChunk = samplesInChunk;
-    trk->cluster[trk->entry].size = size;
-    trk->cluster[trk->entry].entries = samplesInChunk;
-    trk->cluster[trk->entry].dts = pkt->dts;
-    trk->trackDuration = pkt->dts - trk->cluster[0].dts + pkt->duration;
-
-    if (pkt->pts == AV_NOPTS_VALUE) {
-        av_log(s, AV_LOG_WARNING, "pts has no value\n");
-        pkt->pts = pkt->dts;
-    }
-    if (pkt->dts != pkt->pts)
-        trk->flags |= MOV_TRACK_CTTS;
-    trk->cluster[trk->entry].cts = pkt->pts - pkt->dts;
-    trk->cluster[trk->entry].flags = 0;
-    if (pkt->flags & AV_PKT_FLAG_KEY) {
-        if (mov->mode == MODE_MOV && enc->codec_id == CODEC_ID_MPEG2VIDEO) {
-            mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);
-            if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE)
-                trk->flags |= MOV_TRACK_STPS;
-        } else {
-            trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE;
-        }
-        if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE)
-            trk->hasKeyframes++;
-    }
-    trk->entry++;
-    trk->sampleCount += samplesInChunk;
-    mov->mdat_size += size;
-
-    put_flush_packet(pb);
-
-    if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams)
-        ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry);
-    return 0;
-}
-
-// QuickTime chapters involve an additional text track with the chapter names
-// as samples, and a tref pointing from the other tracks to the chapter one.
-static void mov_create_chapter_track(AVFormatContext *s, int tracknum)
-{
-    MOVMuxContext *mov = s->priv_data;
-    MOVTrack *track = &mov->tracks[tracknum];
-    AVPacket pkt = { .stream_index = tracknum, .flags = AV_PKT_FLAG_KEY };
-    int i, len;
-
-    track->mode = mov->mode;
-    track->tag = MKTAG('t','e','x','t');
-    track->timescale = MOV_TIMESCALE;
-    track->enc = avcodec_alloc_context();
-    track->enc->codec_type = AVMEDIA_TYPE_SUBTITLE;
-
-    for (i = 0; i < s->nb_chapters; i++) {
-        AVChapter *c = s->chapters[i];
-        AVMetadataTag *t;
-
-        int64_t end = av_rescale_q(c->end, c->time_base, (AVRational){1,MOV_TIMESCALE});
-        pkt.pts = pkt.dts = av_rescale_q(c->start, c->time_base, (AVRational){1,MOV_TIMESCALE});
-        pkt.duration = end - pkt.dts;
-
-        if ((t = av_metadata_get(c->metadata, "title", NULL, 0))) {
-            len = strlen(t->value);
-            pkt.size = len+2;
-            pkt.data = av_malloc(pkt.size);
-            AV_WB16(pkt.data, len);
-            memcpy(pkt.data+2, t->value, len);
-            ff_mov_write_packet(s, &pkt);
-            av_freep(&pkt.data);
-        }
-    }
-}
-
-static int mov_write_header(AVFormatContext *s)
-{
-    ByteIOContext *pb = s->pb;
-    MOVMuxContext *mov = s->priv_data;
-    int i, hint_track = 0;
-
-    if (url_is_streamed(s->pb)) {
-        av_log(s, AV_LOG_ERROR, "muxer does not support non seekable output\n");
-        return -1;
-    }
-
-    /* Default mode == MP4 */
-    mov->mode = MODE_MP4;
-
-    if (s->oformat != NULL) {
-        if (!strcmp("3gp", s->oformat->name)) mov->mode = MODE_3GP;
-        else if (!strcmp("3g2", s->oformat->name)) mov->mode = MODE_3GP|MODE_3G2;
-        else if (!strcmp("mov", s->oformat->name)) mov->mode = MODE_MOV;
-        else if (!strcmp("psp", s->oformat->name)) mov->mode = MODE_PSP;
-        else if (!strcmp("ipod",s->oformat->name)) mov->mode = MODE_IPOD;
-
-        mov_write_ftyp_tag(pb,s);
-        if (mov->mode == MODE_PSP) {
-            if (s->nb_streams != 2) {
-                av_log(s, AV_LOG_ERROR, "PSP mode need one video and one audio stream\n");
-                return -1;
-            }
-            mov_write_uuidprof_tag(pb,s);
-        }
-    }
-
-    mov->nb_streams = s->nb_streams;
-    if (mov->mode & (MODE_MOV|MODE_IPOD) && s->nb_chapters)
-        mov->chapter_track = mov->nb_streams++;
-
-    if (s->flags & AVFMT_FLAG_RTP_HINT) {
-        /* Add hint tracks for each audio and video stream */
-        hint_track = mov->nb_streams;
-        for (i = 0; i < s->nb_streams; i++) {
-            AVStream *st = s->streams[i];
-            if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
-                st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
-                mov->nb_streams++;
-            }
-        }
-    }
-
-    mov->tracks = av_mallocz(mov->nb_streams*sizeof(*mov->tracks));
-    if (!mov->tracks)
-        return AVERROR(ENOMEM);
-
-    for(i=0; i<s->nb_streams; i++){
-        AVStream *st= s->streams[i];
-        MOVTrack *track= &mov->tracks[i];
-        AVMetadataTag *lang = av_metadata_get(st->metadata, "language", NULL,0);
-
-        track->enc = st->codec;
-        track->language = ff_mov_iso639_to_lang(lang?lang->value:"und", mov->mode!=MODE_MOV);
-        if (track->language < 0)
-            track->language = 0;
-        track->mode = mov->mode;
-        track->tag = mov_find_codec_tag(s, track);
-        if (!track->tag) {
-            av_log(s, AV_LOG_ERROR, "track %d: could not find tag, "
-                   "codec not currently supported in container\n", i);
-            goto error;
-        }
-        /* If hinting of this track is enabled by a later hint track,
-         * this is updated. */
-        track->hint_track = -1;
-        if(st->codec->codec_type == AVMEDIA_TYPE_VIDEO){
-            if (track->tag == MKTAG('m','x','3','p') || track->tag == MKTAG('m','x','3','n') ||
-                track->tag == MKTAG('m','x','4','p') || track->tag == MKTAG('m','x','4','n') ||
-                track->tag == MKTAG('m','x','5','p') || track->tag == MKTAG('m','x','5','n')) {
-                if (st->codec->width != 720 || (st->codec->height != 608 && st->codec->height != 512)) {
-                    av_log(s, AV_LOG_ERROR, "D-10/IMX must use 720x608 or 720x512 video resolution\n");
-                    goto error;
-                }
-                track->height = track->tag>>24 == 'n' ? 486 : 576;
-            }
-            track->timescale = st->codec->time_base.den;
-            if (track->mode == MODE_MOV && track->timescale > 100000)
-                av_log(s, AV_LOG_WARNING,
-                       "WARNING codec timebase is very high. If duration is too long,\n"
-                       "file may not be playable by quicktime. Specify a shorter timebase\n"
-                       "or choose different container.\n");
-        }else if(st->codec->codec_type == AVMEDIA_TYPE_AUDIO){
-            track->timescale = st->codec->sample_rate;
-            if(!st->codec->frame_size && !av_get_bits_per_sample(st->codec->codec_id)) {
-                av_log(s, AV_LOG_ERROR, "track %d: codec frame size is not set\n", i);
-                goto error;
-            }else if(st->codec->frame_size > 1){ /* assume compressed audio */
-                track->audio_vbr = 1;
-            }else{
-                st->codec->frame_size = 1;
-                track->sampleSize = (av_get_bits_per_sample(st->codec->codec_id) >> 3) * st->codec->channels;
-            }
-            if (track->mode != MODE_MOV) {
-                if (track->timescale > UINT16_MAX) {
-                    av_log(s, AV_LOG_ERROR, "track %d: output format does not support "
-                           "sample rate %dhz\n", i, track->timescale);
-                    goto error;
-                }
-                if (track->enc->codec_id == CODEC_ID_MP3 && track->timescale < 16000) {
-                    av_log(s, AV_LOG_ERROR, "track %d: muxing mp3 at %dhz is not supported\n",
-                           i, track->enc->sample_rate);
-                    goto error;
-                }
-            }
-        }else if(st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE){
-            track->timescale = st->codec->time_base.den;
-        }
-        if (!track->height)
-            track->height = st->codec->height;
-
-        av_set_pts_info(st, 64, 1, track->timescale);
-    }
-
-    mov_write_mdat_tag(pb, mov);
-    mov->time = s->timestamp + 0x7C25B080; //1970 based -> 1904 based
-
-    if (mov->chapter_track)
-        mov_create_chapter_track(s, mov->chapter_track);
-
-    if (s->flags & AVFMT_FLAG_RTP_HINT) {
-        /* Initialize the hint tracks for each audio and video stream */
-        for (i = 0; i < s->nb_streams; i++) {
-            AVStream *st = s->streams[i];
-            if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
-                st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
-                ff_mov_init_hinting(s, hint_track, i);
-                hint_track++;
-            }
-        }
-    }
-
-    put_flush_packet(pb);
-
-    return 0;
- error:
-    av_freep(&mov->tracks);
-    return -1;
-}
-
-static int mov_write_trailer(AVFormatContext *s)
-{
-    MOVMuxContext *mov = s->priv_data;
-    ByteIOContext *pb = s->pb;
-    int res = 0;
-    int i;
-
-    int64_t moov_pos = url_ftell(pb);
-
-    /* Write size of mdat tag */
-    if (mov->mdat_size+8 <= UINT32_MAX) {
-        url_fseek(pb, mov->mdat_pos, SEEK_SET);
-        put_be32(pb, mov->mdat_size+8);
-    } else {
-        /* overwrite 'wide' placeholder atom */
-        url_fseek(pb, mov->mdat_pos - 8, SEEK_SET);
-        put_be32(pb, 1); /* special value: real atom size will be 64 bit value after tag field */
-        put_tag(pb, "mdat");
-        put_be64(pb, mov->mdat_size+16);
-    }
-    url_fseek(pb, moov_pos, SEEK_SET);
-
-    mov_write_moov_tag(pb, mov, s);
-
-    if (mov->chapter_track)
-        av_freep(&mov->tracks[mov->chapter_track].enc);
-
-    for (i=0; i<mov->nb_streams; i++) {
-        if (mov->tracks[i].tag == MKTAG('r','t','p',' '))
-            ff_mov_close_hinting(&mov->tracks[i]);
-        av_freep(&mov->tracks[i].cluster);
-
-        if(mov->tracks[i].vosLen) av_free(mov->tracks[i].vosData);
-
-    }
-
-    put_flush_packet(pb);
-
-    av_freep(&mov->tracks);
-
-    return res;
-}
-
-#if CONFIG_MOV_MUXER
-AVOutputFormat mov_muxer = {
-    "mov",
-    NULL_IF_CONFIG_SMALL("MOV format"),
-    NULL,
-    "mov",
-    sizeof(MOVMuxContext),
-    CODEC_ID_AAC,
-    CODEC_ID_MPEG4,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
-    .codec_tag = (const AVCodecTag* const []){codec_movvideo_tags, codec_movaudio_tags, 0},
-};
-#endif
-#if CONFIG_TGP_MUXER
-AVOutputFormat tgp_muxer = {
-    "3gp",
-    NULL_IF_CONFIG_SMALL("3GP format"),
-    NULL,
-    "3gp",
-    sizeof(MOVMuxContext),
-    CODEC_ID_AMR_NB,
-    CODEC_ID_H263,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER,
-    .codec_tag = (const AVCodecTag* const []){codec_3gp_tags, 0},
-};
-#endif
-#if CONFIG_MP4_MUXER
-AVOutputFormat mp4_muxer = {
-    "mp4",
-    NULL_IF_CONFIG_SMALL("MP4 format"),
-    "application/mp4",
-    "mp4",
-    sizeof(MOVMuxContext),
-    CODEC_ID_AAC,
-    CODEC_ID_MPEG4,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
-    .codec_tag = (const AVCodecTag* const []){ff_mp4_obj_type, 0},
-};
-#endif
-#if CONFIG_PSP_MUXER
-AVOutputFormat psp_muxer = {
-    "psp",
-    NULL_IF_CONFIG_SMALL("PSP MP4 format"),
-    NULL,
-    "mp4,psp",
-    sizeof(MOVMuxContext),
-    CODEC_ID_AAC,
-    CODEC_ID_MPEG4,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER,
-    .codec_tag = (const AVCodecTag* const []){ff_mp4_obj_type, 0},
-};
-#endif
-#if CONFIG_TG2_MUXER
-AVOutputFormat tg2_muxer = {
-    "3g2",
-    NULL_IF_CONFIG_SMALL("3GP2 format"),
-    NULL,
-    "3g2",
-    sizeof(MOVMuxContext),
-    CODEC_ID_AMR_NB,
-    CODEC_ID_H263,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER,
-    .codec_tag = (const AVCodecTag* const []){codec_3gp_tags, 0},
-};
-#endif
-#if CONFIG_IPOD_MUXER
-AVOutputFormat ipod_muxer = {
-    "ipod",
-    NULL_IF_CONFIG_SMALL("iPod H.264 MP4 format"),
-    "application/mp4",
-    "m4v,m4a",
-    sizeof(MOVMuxContext),
-    CODEC_ID_AAC,
-    CODEC_ID_H264,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER,
-    .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
-};
-#endif



From mean at mail.berlios.de  Sun Jul 25 12:07:57 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 25 Jul 2010 12:07:57 +0200
Subject: [Avidemux-svn-commit] r6485 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches:
	. avcodec
Message-ID: <20100725100757.26AF5480E6C@sheep.berlios.de>

Author: mean
Date: 2010-07-25 12:07:56 +0200 (Sun, 25 Jul 2010)
New Revision: 6485

Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_avcodec.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_eac3_patch.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_fft.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_ffv1.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h263dec.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h264.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h264dsp.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpeg12.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpeg12enc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpegvideo.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpegvideo_enc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_png.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_pngdec.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_pngenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_utils.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_x86_mathops.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_file.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_flvenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_isom.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_matroskaenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_movenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegtsenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_utils.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_avutil.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_bswap.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_internal.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_intreadwrite.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_lfg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_libm.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_mem.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_timer.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_x86_bswap.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_x86_intreadwrite.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/swscale_c.patch
Log:
[ffmpeg] cleanup

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,30 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
-index 14e049d..78e39a5 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
-@@ -614,6 +614,8 @@ typedef struct RcOverride{
- #define CODEC_FLAG2_PSY           0x00080000 ///< Use psycho visual optimizations.
- #define CODEC_FLAG2_SSIM          0x00100000 ///< Compute SSIM during encoding, error[] values are undefined.
- #define CODEC_FLAG2_INTRA_REFRESH 0x00200000 ///< Use periodic insertion of intra blocks instead of keyframes.
-+//MEANX: NEVER EVER USE CLOSED GOP ?
-+#define CODEC_FLAG2_32_PULLDOWN   0x80000000 
- 
- /* Unsupported options :
-  *              Syntax Arithmetic coding (SAC)
-@@ -1496,6 +1498,7 @@ typedef struct AVCodecContext {
-      * - decoding: unused
-      */
-     int rc_max_rate;
-+    int rc_max_rate_header; /*< That one is set in the header MEANX */
- 
-     /**
-      * minimum bitrate
-@@ -1510,6 +1513,8 @@ typedef struct AVCodecContext {
-      * - decoding: unused
-      */
-     int rc_buffer_size;
-+    int rc_buffer_size_header;  /*< That one is set in the header MEANX*/
-+
-     float rc_buffer_aggressivity;
- 
-     /**

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_avcodec.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_avcodec.h.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_avcodec.h.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,30 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
-index cd642ac..c90eac7 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
-@@ -599,6 +599,8 @@ typedef struct RcOverride{
- #define CODEC_FLAG2_PSY           0x00080000 ///< Use psycho visual optimizations.
- #define CODEC_FLAG2_SSIM          0x00100000 ///< Compute SSIM during encoding, error[] values are undefined.
- #define CODEC_FLAG2_INTRA_REFRESH 0x00200000 ///< Use periodic insertion of intra blocks instead of keyframes.
-+//MEANX: NEVER EVER USE CLOSED GOP ?
-+#define CODEC_FLAG2_32_PULLDOWN   0x80000000 
- 
- /* Unsupported options :
-  *              Syntax Arithmetic coding (SAC)
-@@ -1469,6 +1471,7 @@ typedef struct AVCodecContext {
-      * - decoding: unused
-      */
-     int rc_max_rate;
-+    int rc_max_rate_header; /*< That one is set in the header MEANX */
- 
-     /**
-      * minimum bitrate
-@@ -1483,6 +1486,8 @@ typedef struct AVCodecContext {
-      * - decoding: unused
-      */
-     int rc_buffer_size;
-+    int rc_buffer_size_header;  /*< That one is set in the header MEANX*/
-+
-     float rc_buffer_aggressivity;
- 
-     /**

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_eac3_patch.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_eac3_patch.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_eac3_patch.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,426 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.c b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.c
-index f2cadf0..61b857c 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.c
-@@ -812,14 +812,100 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
- 
-     /* spectral extension strategy */
-     if (s->eac3 && (!blk || get_bits1(gbc))) {
--        if (get_bits1(gbc)) {
--            av_log_missing_feature(s->avctx, "Spectral extension", 1);
--            return -1;
-+        s->spx_in_use = get_bits1(gbc);
-+        if (s->spx_in_use) {
-+            int begf, endf;
-+            int spx_end_subband;
-+
-+            /* determine which channels use spx */
-+            if (s->channel_mode == AC3_CHMODE_MONO) {
-+                s->channel_in_spx[1] = 1;
-+            } else {
-+                for (ch = 1; ch <= fbw_channels; ch++)
-+                    s->channel_in_spx[ch] = get_bits1(gbc);
-+            }
-+
-+            s->spx_copy_start_freq = get_bits(gbc, 2) * 12 + 25;
-+            begf = get_bits(gbc, 3);
-+            endf = get_bits(gbc, 3);
-+            s->spx_start_subband = begf < 6 ? begf+2 : 2*begf-3;
-+            spx_end_subband      = endf < 4 ? endf+5 : 2*endf+3;
-+            if (s->spx_start_subband >= spx_end_subband) {
-+                av_log(s->avctx, AV_LOG_ERROR, "invalid spectral extension range (%d >= %d)\n",
-+                       s->spx_start_subband, spx_end_subband);
-+                return -1;
-+            }
-+            s->spx_start_freq    = s->spx_start_subband * 12 + 25;
-+            s->spx_end_freq      = spx_end_subband      * 12 + 25;
-+            if (s->spx_copy_start_freq >= s->spx_start_freq) {
-+                av_log(s->avctx, AV_LOG_ERROR, "invalid spectral extension copy start bin (%d >= %d)\n",
-+                       s->spx_copy_start_freq, s->spx_start_freq);
-+                return -1;
-+            }
-+/*
-+  decode_band_structure(gbc, blk, s->eac3, 0, cpl_start_subband,
-+                                  cpl_end_subband,
-+                                  ff_eac3_default_cpl_band_struct,
-+                                  &s->num_cpl_bands, s->cpl_band_sizes);
-+*/
-+            decode_band_structure(gbc, blk, s->eac3, 0,
-+                                  s->spx_start_subband, spx_end_subband,
-+                                  ff_eac3_default_spx_band_struct,
-+                                  /*s->spx_band_struct,*/ &s->num_spx_bands,
-+                                  s->spx_band_sizes);
-+        } else {
-+            for (ch = 1; ch <= fbw_channels; ch++) {
-+                s->channel_in_spx[ch] = 0;
-+                s->first_spx_coords[ch] = 1;
-+            }
-         }
--        /* TODO: parse spectral extension strategy info */
-     }
- 
--    /* TODO: spectral extension coordinates */
-+    /* spectral extension coordinates */
-+    if (s->spx_in_use) {
-+        for (ch = 1; ch <= fbw_channels; ch++) {
-+            if (s->channel_in_spx[ch]) {
-+                if (s->first_spx_coords[ch] || get_bits1(gbc)) {
-+                    int bin;
-+                    float spx_blend;
-+                    int master_spx_coord;
-+                    s->first_spx_coords[ch] = 0;
-+                    spx_blend = get_bits(gbc, 5) / 32.0f;
-+                    master_spx_coord = get_bits(gbc, 2) * 3;
-+                    bin = s->spx_start_freq;
-+                    for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
-+                        int bandsize;
-+                        int spx_coord_exp, spx_coord_mant;
-+                        float nratio, sblend, nblend, spx_coord;
-+
-+                        /* calculate blending factors */
-+                        bandsize = s->spx_band_sizes[bnd];
-+                        nratio = ((float)((bin + (bandsize >> 1))) / s->spx_end_freq) - spx_blend;
-+                        nratio = av_clipf(nratio, 0.0f, 1.0f);
-+                        nblend = sqrt(       nratio);
-+                        sblend = sqrt(1.0f - nratio);
-+                        nblend *= 1.73205077648f; // scale noise to give unity variance
-+                        bin += bandsize;
-+
-+                        /* decode spx coordinates */
-+                        spx_coord_exp  = get_bits(gbc, 4);
-+                        spx_coord_mant = get_bits(gbc, 2);
-+                        if (spx_coord_exp == 15)
-+                            spx_coord = spx_coord_mant / 4.0f;
-+                        else
-+                            spx_coord = (spx_coord_mant + 4) / 8.0f;
-+                        spx_coord /= (float)(1 << (spx_coord_exp + master_spx_coord));
-+
-+                        /* multiply noise and signal blending factors by spx coordinate */
-+                        s->spx_noise_blend [ch][bnd] = nblend * spx_coord * 32.0f;
-+                        s->spx_signal_blend[ch][bnd] = sblend * spx_coord * 32.0f;
-+                    }
-+                }
-+            } else {
-+                s->first_spx_coords[ch] = 1;
-+            }
-+        }
-+    }
- 
-     /* coupling strategy */
-     if (s->eac3 ? s->cpl_strategy_exists[blk] : get_bits1(gbc)) {
-@@ -856,9 +942,9 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
-                 s->phase_flags_in_use = get_bits1(gbc);
- 
-             /* coupling frequency range */
--            /* TODO: modify coupling end freq if spectral extension is used */
-             cpl_start_subband = get_bits(gbc, 4);
--            cpl_end_subband   = get_bits(gbc, 4) + 3;
-+            cpl_end_subband = s->spx_in_use ? s->spx_start_subband - 1 :
-+                                              get_bits(gbc, 4) + 3;
-             if (cpl_start_subband >= cpl_end_subband) {
-                 av_log(s->avctx, AV_LOG_ERROR, "invalid coupling range (%d >= %d)\n",
-                        cpl_start_subband, cpl_end_subband);
-@@ -931,8 +1017,11 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
-     if (channel_mode == AC3_CHMODE_STEREO) {
-         if ((s->eac3 && !blk) || get_bits1(gbc)) {
-             s->num_rematrixing_bands = 4;
--            if(cpl_in_use && s->start_freq[CPL_CH] <= 61)
-+            if (cpl_in_use && s->start_freq[CPL_CH] <= 61) {
-                 s->num_rematrixing_bands -= 1 + (s->start_freq[CPL_CH] == 37);
-+            } else if (s->spx_in_use && s->spx_start_freq <= 61) {
-+                s->num_rematrixing_bands -= 1;
-+            }
-             for(bnd=0; bnd<s->num_rematrixing_bands; bnd++)
-                 s->rematrixing_flags[bnd] = get_bits1(gbc);
-         } else if (!blk) {
-@@ -957,6 +1046,8 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
-             int prev = s->end_freq[ch];
-             if (s->channel_in_cpl[ch])
-                 s->end_freq[ch] = s->start_freq[CPL_CH];
-+            else if (s->channel_in_spx[ch])
-+                s->end_freq[ch] = s->spx_start_freq;
-             else {
-                 int bandwidth_code = get_bits(gbc, 6);
-                 if (bandwidth_code > 60) {
-@@ -1153,8 +1244,6 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
- 
-     /* TODO: generate enhanced coupling coordinates and uncouple */
- 
--    /* TODO: apply spectral extension */
--
-     /* recover coefficients if rematrixing is in use */
-     if(s->channel_mode == AC3_CHMODE_STEREO)
-         do_rematrixing(s);
-@@ -1170,6 +1259,10 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
-         s->dsp.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256);
-     }
- 
-+    /* apply spectral extension to high frequency bins */
-+    if (s->spx_in_use)
-+        ff_eac3_apply_spectral_extension(s);
-+
-     /* downmix and MDCT. order depends on whether block switching is used for
-        any channel in this block. this is because coefficients for the long
-        and short transforms cannot be mixed. */
-@@ -1211,8 +1304,8 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
- static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size,
-                             AVPacket *avpkt)
- {
--    const uint8_t *buf = avpkt->data;
--    int buf_size = avpkt->size;
-+    const uint8_t *buf=avpkt->data;
-+    int buf_size=avpkt->size;
-     AC3DecodeContext *s = avctx->priv_data;
-     int16_t *out_samples = (int16_t *)data;
-     int blk, ch, err;
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.h b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.h
-index 52eb0ef..4cffbb5 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.h
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.h
-@@ -42,6 +42,7 @@
- #define AC3_MAX_COEFS   256
- #define AC3_BLOCK_SIZE  256
- #define MAX_BLOCKS        6
-+#define SPX_MAX_BANDS    17
- 
- typedef struct {
-     AVCodecContext *avctx;                  ///< parent context
-@@ -88,6 +89,23 @@ typedef struct {
-     int cpl_coords[AC3_MAX_CHANNELS][18];   ///< coupling coordinates                   (cplco)
- ///@}
- 
-+///@defgroup spx spectral extension
-+///@{
-+    int spx_in_use;                             ///< spectral extension in use              (spxinu)
-+    uint8_t channel_in_spx[AC3_MAX_CHANNELS];   ///< channel in spectral extension          (chinspx)
-+    int8_t spx_atten_code[AC3_MAX_CHANNELS];    ///< spx attenuation code                   (spxattencod)
-+    int spx_start_subband;                      ///< spx beginning frequency band           (spxbegf)
-+    int spx_start_freq;                         ///< spx start frequency bin
-+    int spx_end_freq;                           ///< spx end frequency bin
-+    int spx_copy_start_freq;                    ///< spx starting frequency for copying     (copystartmant)
-+    int num_spx_bands;                          ///< number of spx bands                    (nspxbnds)
-+    uint8_t spx_band_struct[SPX_MAX_BANDS];     ///< spectral extension band structure      (spxbndstrc)
-+    uint8_t spx_band_sizes[SPX_MAX_BANDS];      ///< number of bins in each band            (spxbndsztab)
-+    uint8_t first_spx_coords[AC3_MAX_CHANNELS]; ///< first spx coordinates states           (firstspxcos)
-+    float spx_noise_blend[AC3_MAX_CHANNELS][SPX_MAX_BANDS]; ///< spx noise blending factor  (nblendfact)
-+    float spx_signal_blend[AC3_MAX_CHANNELS][SPX_MAX_BANDS];///< spx signal blending factor (sblendfact)
-+///@}
-+
- ///@defgroup aht adaptive hybrid transform
-     int channel_uses_aht[AC3_MAX_CHANNELS];                         ///< channel AHT in use (chahtinu)
-     int pre_mantissa[AC3_MAX_CHANNELS][AC3_MAX_COEFS][MAX_BLOCKS];  ///< pre-IDCT mantissas
-@@ -178,4 +196,11 @@ int ff_eac3_parse_header(AC3DecodeContext *s);
-  */
- void ff_eac3_decode_transform_coeffs_aht_ch(AC3DecodeContext *s, int ch);
- 
-+/**
-+ * Apply spectral extension to each channel by copying lower frequency
-+ * coefficients to higher frequency bins and applying side information to
-+ * approximate the original high frequency signal.
-+ */
-+void ff_eac3_apply_spectral_extension(AC3DecodeContext *s);
-+
- #endif /* AVCODEC_AC3DEC_H */
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.c b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.c
-index 907a3ae..57bed8d 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.c
-@@ -64,3 +64,48 @@ const uint8_t ff_eac3_hebap_tab[64] = {
-  */
- const uint8_t ff_eac3_default_cpl_band_struct[18] =
- { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1 };
-+
-+/**
-+ * Table E2.15 Default Spectral Extension Banding Structure
-+ */
-+const uint8_t ff_eac3_default_spx_band_struct[17] =
-+{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 };
-+
-+/**
-+ * Table E.25: Spectral Extension Attenuation Table
-+ * ff_eac3_spx_atten_tab[code][bin]=pow(2.0,(bin+1)*(code+1)/-15.0);
-+ */
-+const float ff_eac3_spx_atten_tab[32][3] = {
-+    { 0.954841603910416503f, 0.911722488558216804f, 0.870550563296124125f },
-+    { 0.911722488558216804f, 0.831237896142787758f, 0.757858283255198995f },
-+    { 0.870550563296124125f, 0.757858283255198995f, 0.659753955386447100f },
-+    { 0.831237896142787758f, 0.690956439983888004f, 0.574349177498517438f },
-+    { 0.793700525984099792f, 0.629960524947436595f, 0.500000000000000000f },
-+    { 0.757858283255198995f, 0.574349177498517438f, 0.435275281648062062f },
-+    { 0.723634618720189082f, 0.523647061410313364f, 0.378929141627599553f },
-+    { 0.690956439983888004f, 0.477420801955208307f, 0.329876977693223550f },
-+    { 0.659753955386447100f, 0.435275281648062062f, 0.287174588749258719f },
-+    { 0.629960524947436595f, 0.396850262992049896f, 0.250000000000000000f },
-+    { 0.601512518041058319f, 0.361817309360094541f, 0.217637640824031003f },
-+    { 0.574349177498517438f, 0.329876977693223550f, 0.189464570813799776f },
-+    { 0.548412489847312945f, 0.300756259020529160f, 0.164938488846611775f },
-+    { 0.523647061410313364f, 0.274206244923656473f, 0.143587294374629387f },
-+    { 0.500000000000000000f, 0.250000000000000000f, 0.125000000000000000f },
-+    { 0.477420801955208307f, 0.227930622139554201f, 0.108818820412015502f },
-+    { 0.455861244279108402f, 0.207809474035696939f, 0.094732285406899888f },
-+    { 0.435275281648062062f, 0.189464570813799776f, 0.082469244423305887f },
-+    { 0.415618948071393879f, 0.172739109995972029f, 0.071793647187314694f },
-+    { 0.396850262992049896f, 0.157490131236859149f, 0.062500000000000000f },
-+    { 0.378929141627599553f, 0.143587294374629387f, 0.054409410206007751f },
-+    { 0.361817309360094541f, 0.130911765352578369f, 0.047366142703449930f },
-+    { 0.345478219991944002f, 0.119355200488802049f, 0.041234622211652958f },
-+    { 0.329876977693223550f, 0.108818820412015502f, 0.035896823593657347f },
-+    { 0.314980262473718298f, 0.099212565748012460f, 0.031250000000000000f },
-+    { 0.300756259020529160f, 0.090454327340023621f, 0.027204705103003875f },
-+    { 0.287174588749258719f, 0.082469244423305887f, 0.023683071351724965f },
-+    { 0.274206244923656473f, 0.075189064755132290f, 0.020617311105826479f },
-+    { 0.261823530705156682f, 0.068551561230914118f, 0.017948411796828673f },
-+    { 0.250000000000000000f, 0.062500000000000000f, 0.015625000000000000f },
-+    { 0.238710400977604098f, 0.056982655534888536f, 0.013602352551501938f },
-+    { 0.227930622139554201f, 0.051952368508924235f, 0.011841535675862483f }
-+};
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.h b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.h
-index 8d9db05..877ea0b 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.h
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.h
-@@ -29,5 +29,7 @@ extern const uint8_t ff_ac3_rematrix_band_tab[5];
- 
- extern const uint8_t ff_eac3_hebap_tab[64];
- extern const uint8_t ff_eac3_default_cpl_band_struct[18];
-+extern const uint8_t ff_eac3_default_spx_band_struct[17];
-+extern const float   ff_eac3_spx_atten_tab[32][3];
- 
- #endif /* AVCODEC_AC3DEC_DATA_H */
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/eac3dec.c b/avidemux_core/ADM_ffmpeg/libavcodec/eac3dec.c
-index 3784ccf..79f3c3b 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/eac3dec.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/eac3dec.c
-@@ -23,10 +23,6 @@
- /*
-  * There are several features of E-AC-3 that this decoder does not yet support.
-  *
-- * Spectral Extension
-- *     There is a patch to get this working for the two samples we have that
-- *     use it, but it needs some minor changes in order to be accepted.
-- *
-  * Enhanced Coupling
-  *     No known samples exist.  If any ever surface, this feature should not be
-  *     too difficult to implement.
-@@ -67,6 +63,95 @@ typedef enum {
- 
- #define EAC3_SR_CODE_REDUCED  3
- 
-+void ff_eac3_apply_spectral_extension(AC3DecodeContext *s)
-+{
-+    int bin, bnd, ch, i;
-+    uint8_t wrapflag[SPX_MAX_BANDS]={0,}, num_copy_sections, copy_sizes[SPX_MAX_BANDS];
-+    float rms_energy[SPX_MAX_BANDS];
-+
-+    /* Set copy index mapping table. Set wrap flags to apply a notch filter at
-+       wrap points later on. */
-+    wrapflag[0] = 1;
-+    bin = s->spx_copy_start_freq;
-+    num_copy_sections = 0;
-+    for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
-+        int copysize;
-+        int bandsize = s->spx_band_sizes[bnd];
-+        if ((bin + bandsize) > s->spx_start_freq) {
-+            copy_sizes[num_copy_sections++] = bin - s->spx_copy_start_freq;
-+            bin = s->spx_copy_start_freq;
-+            wrapflag[bnd] = 1;
-+        }
-+        for (i = 0; i < bandsize; i += copysize) {
-+            if (bin == s->spx_start_freq) {
-+                copy_sizes[num_copy_sections++] = bin - s->spx_copy_start_freq;
-+                bin = s->spx_copy_start_freq;
-+            }
-+            copysize = FFMIN(bandsize - i, s->spx_start_freq - bin);
-+            bin += copysize;
-+        }
-+    }
-+    copy_sizes[num_copy_sections++] = bin - s->spx_copy_start_freq;
-+
-+    for (ch = 1; ch <= s->fbw_channels; ch++) {
-+        if (!s->channel_in_spx[ch])
-+            continue;
-+
-+        /* Copy coeffs from normal bands to extension bands */
-+        bin = s->spx_start_freq;
-+        for (i = 0; i < num_copy_sections; i++) {
-+            memcpy(&s->transform_coeffs[ch][bin],
-+                   &s->transform_coeffs[ch][s->spx_copy_start_freq],
-+                   copy_sizes[i]*sizeof(float));
-+            bin += copy_sizes[i];
-+        }
-+
-+        /* Calculate RMS energy for each SPX band. */
-+        bin = s->spx_start_freq;
-+        for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
-+            int bandsize = s->spx_band_sizes[bnd];
-+            float accum = 0.0f;
-+            for (i = 0; i < bandsize; i++) {
-+                float coeff = s->transform_coeffs[ch][bin++];
-+                accum += coeff * coeff;
-+            }
-+            rms_energy[bnd] = sqrt(accum / (float)bandsize);
-+        }
-+
-+        /* Apply a notch filter at transitions between normal and extension
-+           bands and at all wrap points. */
-+        if (s->spx_atten_code[ch] >= 0) {
-+            const float *atten_tab = ff_eac3_spx_atten_tab[s->spx_atten_code[ch]];
-+            bin = s->spx_start_freq - 2;
-+            for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
-+                if (wrapflag[bnd]) {
-+                    float *coeffs = &s->transform_coeffs[ch][bin];
-+                    coeffs[0] *= atten_tab[0];
-+                    coeffs[1] *= atten_tab[1];
-+                    coeffs[2] *= atten_tab[2];
-+                    coeffs[3] *= atten_tab[1];
-+                    coeffs[4] *= atten_tab[0];
-+                }
-+                bin += s->spx_band_sizes[bnd];
-+            }
-+        }
-+
-+        /* Apply noise-blended coefficient scaling based on previously
-+           calculated RMS energy, blending factors, and SPX coordinates for
-+           each band. */
-+        bin = s->spx_start_freq;
-+        for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
-+            float nscale = s->spx_noise_blend[ch][bnd] * rms_energy[bnd];
-+            float sscale = s->spx_signal_blend[ch][bnd];
-+            for (i = 0; i < s->spx_band_sizes[bnd]; i++) {
-+                float noise  = nscale * (((int)av_lfg_get(&s->dith_state))/(float)(1<<31));
-+                s->transform_coeffs[ch][bin]   *= sscale;
-+                s->transform_coeffs[ch][bin++] += noise;
-+            }
-+        }
-+    }
-+}
-+
- /** lrint(M_SQRT2*cos(2*M_PI/12)*(1<<23)) */
- #define COEFF_0 10273905LL
- 
-@@ -492,13 +577,11 @@ int ff_eac3_parse_header(AC3DecodeContext *s)
-     }
- 
-     /* spectral extension attenuation data */
--    if (parse_spx_atten_data) {
--        av_log_missing_feature(s->avctx, "Spectral extension attenuation", 1);
--        for (ch = 1; ch <= s->fbw_channels; ch++) {
--            if (get_bits1(gbc)) { // channel has spx attenuation
--                skip_bits(gbc, 5); // skip spx attenuation code
--            }
--        }
-+    for (ch = 1; ch <= s->fbw_channels; ch++) {
-+        if (parse_spx_atten_data && get_bits1(gbc))
-+            s->spx_atten_code[ch] = get_bits(gbc, 5);
-+        else
-+            s->spx_atten_code[ch] = -1;
-     }
- 
-     /* block start information */
-@@ -514,6 +597,7 @@ int ff_eac3_parse_header(AC3DecodeContext *s)
- 
-     /* syntax state initialization */
-     for (ch = 1; ch <= s->fbw_channels; ch++) {
-+        s->first_spx_coords[ch] = 1;
-         s->first_cpl_coords[ch] = 1;
-     }
-     s->first_cpl_leak = 1;

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_fft.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_fft.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_fft.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,13 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/fft.c b/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
-index bf240bf..6199d91 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
-@@ -112,7 +112,7 @@ av_cold int ff_fft_init(FFTContext *s, int nbits, int inverse)
- 
-     if (ARCH_ARM)     ff_fft_init_arm(s);
-     if (HAVE_ALTIVEC) ff_fft_init_altivec(s);
--    if (HAVE_MMX)     ff_fft_init_mmx(s);
-+    // MEANX if (HAVE_MMX)     ff_fft_init_mmx(s);
- 
-     if (s->split_radix) {
-         for(j=4; j<=nbits; j++) {

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_ffv1.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_ffv1.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_ffv1.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,13 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c b/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c
-index 12056e1..b2f3efe 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c
-@@ -1107,6 +1107,8 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPac
-         clear_state(f);
-     }else{
-         p->key_frame= 0;
-+         p->pict_type= FF_P_TYPE; // MEANX : looks more like a P to me as user
-+
-     }
-     if(f->ac>1){
-         int i;

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h263dec.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h263dec.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h263dec.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,56 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c b/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
-index f5df556..3bc37c0 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
-@@ -119,6 +119,23 @@ av_cold int ff_h263_decode_init(AVCodecContext *avctx)
- 
-     return 0;
- }
-+/* MeanX : Ugly patch to detect vo ppacked stuff ... */
-+int av_is_voppacked(AVCodecContext *avctx, int *vop_packed, int *gmc, int *qpel)
-+{
-+    MpegEncContext *s = avctx->priv_data;
-+    // set sane default
-+    *vop_packed=0;
-+    *gmc=0;
-+    *qpel=0;
-+    if(avctx->codec->id!=CODEC_ID_MPEG4) return 0;
-+    	
-+  	*vop_packed=(s->divx_packed);
-+	*qpel=s->quarter_sample;
-+	*gmc=0;	// FIXME
-+	return 1;
-+
-+  }
-+  /* MeanX */
- 
- av_cold int ff_h263_decode_end(AVCodecContext *avctx)
- {
-@@ -414,6 +431,12 @@ retry:
-     } else {
-         ret = h263_decode_picture_header(s);
-     }
-+	//MEANX we need to do it here also for quicktime file / ctts atom 
-+        // we need the correct frame type, and qt file may contain 
-+        // vop not coded frame.
-+        pict->pict_type=s->current_picture.pict_type= s->pict_type;
-+        pict->key_frame=s->current_picture.key_frame= s->pict_type == FF_I_TYPE;
-+        //MEANX
- 
-     if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_size);
- 
-@@ -707,6 +730,14 @@ intrax8_decoded:
- 
- assert(s->current_picture.pict_type == s->current_picture_ptr->pict_type);
- assert(s->current_picture.pict_type == s->pict_type);
-+/* MEANX */
-+  if(s->current_picture_ptr)
-+      s->current_picture_ptr->opaque=pict->opaque;
-+/* MEANX */
-+
-+
-+
-+
-     if (s->pict_type == FF_B_TYPE || s->low_delay) {
-         *pict= *(AVFrame*)s->current_picture_ptr;
-     } else if (s->last_picture_ptr != NULL) {

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h264.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h264.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h264.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,22 +0,0 @@
-[1mdiff --git a/avidemux_core/ADM_ffmpeg/libavcodec/h264.c b/avidemux_core/ADM_ffmpeg/libavcodec/h264.c[m
-[1mindex e4654f0..cfab425 100644[m
-[1m--- a/avidemux_core/ADM_ffmpeg/libavcodec/h264.c[m
-[1m+++ b/avidemux_core/ADM_ffmpeg/libavcodec/h264.c[m
-[36m@@ -3358,6 +3358,17 @@[m [mav_cold int ff_h264_decode_end(AVCodecContext *avctx)[m
-     return 0;[m
- }[m
- [m
-[32m+[m[32m/* MEANX */[m
-[32m+[m[32mint av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc)[m
-[32m+[m[32m{[m
-[32m+[m[32m      H264Context *h = avctx->priv_data;[m
-[32m+[m[32m      assert(h);[m
-[32m+[m[32m      *nalSize=h->nal_length_size;[m
-[32m+[m[32m      *isAvc=h->is_avc;[m
-[32m+[m	[32mreturn 1;[m
-[32m+[m
-[32m+[m[32m  }[m
-[32m+[m[32m/* MeanX */[m
- [m
- AVCodec h264_decoder = {[m
-     "h264",[m

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h264dsp.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h264dsp.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_h264dsp.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,12 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c b/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
-index c01fc77..0fe9f40 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
-@@ -316,5 +316,7 @@ void ff_h264dsp_init(H264DSPContext *c)
- 
-     if (ARCH_ARM) ff_h264dsp_init_arm(c);
-     if (HAVE_ALTIVEC) ff_h264dsp_init_ppc(c);
-+#if CONFIG_H264DSP //MEANX
-     if (HAVE_MMX) ff_h264dsp_init_x86(c);
-+#endif
- }

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpeg12.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpeg12.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpeg12.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,16 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
-index bc9ddcc..036b9ba 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
-@@ -1948,6 +1948,11 @@ static int slice_end(AVCodecContext *avctx, AVFrame *pict)
-         ff_er_frame_end(s);
- 
-         MPV_frame_end(s);
-+/* MEANX */
-+  if(s->current_picture_ptr)
-+      s->current_picture_ptr->opaque=pict->opaque;
-+/* MEANX */
-+
- 
-         if (s->pict_type == FF_B_TYPE || s->low_delay) {
-             *pict= *(AVFrame*)s->current_picture_ptr;

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpeg12enc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpeg12enc.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpeg12enc.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,190 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
-index bf36129..b4d6a1d 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
-@@ -127,10 +127,19 @@ static int find_frame_rate_index(MpegEncContext *s){
-             s->frame_rate_index= i;
-         }
-     }
-+ /* MEANX 
-+
-     if(dmin)
-         return -1;
-     else
-         return 0;
-+  */
-+        if(dmin>4)
-+   {
-+        av_log(0,AV_LOG_ERROR,"We did a roundup ! Expect async!\n");
-+   }
-+        return 0; //MEANX
-+
- }
- 
- static av_cold int encode_init(AVCodecContext *avctx)
-@@ -209,6 +218,7 @@ static void mpeg1_encode_sequence_header(MpegEncContext *s)
-             put_sbits(&s->pb, 12, s->width );
-             put_sbits(&s->pb, 12, s->height);
- 
-+#if 0 //MEANX
-             for(i=1; i<15; i++){
-                 float error= aspect_ratio;
-                 if(s->codec_id == CODEC_ID_MPEG1VIDEO || i <=1)
-@@ -223,20 +233,44 @@ static void mpeg1_encode_sequence_header(MpegEncContext *s)
-                     s->aspect_ratio_info= i;
-                 }
-             }
-+#endif // MEANX
-+            //MEANX put_bits(&s->pb, 4, s->aspect_ratio_info);
-+            //MEANX put_bits(&s->pb, 4, s->frame_rate_index);
-+ // MEANX 4:3
-+  if(s->avctx->sample_aspect_ratio.num==16 && s->avctx->sample_aspect_ratio.den==9)
-+            {
-+                //printf("FFmpeg : Wide\n");
-+                put_bits(&s->pb,4,3); //16:9
-+            }
-+            else        //4:3
-+            {
-+              if(s->codec_id == CODEC_ID_MPEG2VIDEO)
-+                put_bits(&s->pb, 4, 2);
-+              else
-+                put_bits(&s->pb, 4, 12); // MPEG1
-+            }
-+// /MEANX
- 
--            put_bits(&s->pb, 4, s->aspect_ratio_info);
--            put_bits(&s->pb, 4, s->frame_rate_index);
-+// //MEANX PULLDOWN            put_bits(&s->pb, 4, s->frame_rate_index);
-+if((s->flags2 & CODEC_FLAG2_32_PULLDOWN) && (s->codec_id == CODEC_ID_MPEG2VIDEO))
-+            {           
-+                put_bits(&s->pb, 4,4);
-+            }
-+            else
-+            {                                  
-+                put_bits(&s->pb, 4, s->frame_rate_index);
-+            } //MEANX pulldown
- 
--            if(s->avctx->rc_max_rate){
--                v = (s->avctx->rc_max_rate + 399) / 400;
-+            if(s->avctx->rc_max_rate_header){ //MEANX we use header
-+                v = (s->avctx->rc_max_rate_header + 399) / 400;
-                 if (v > 0x3ffff && s->codec_id == CODEC_ID_MPEG1VIDEO)
-                     v = 0x3ffff;
-             }else{
-                 v= 0x3FFFF;
-             }
- 
--            if(s->avctx->rc_buffer_size)
--                vbv_buffer_size = s->avctx->rc_buffer_size;
-+            if(s->avctx->rc_buffer_size_header) // MEANX we use header
-+                vbv_buffer_size = s->avctx->rc_buffer_size_header;
-             else
-                 /* VBV calculation: Scaled so that a VCD has the proper VBV size of 40 kilobytes */
-                 vbv_buffer_size = (( 20 * s->bit_rate) / (1151929 / 2)) * 8 * 1024;
-@@ -269,8 +303,17 @@ static void mpeg1_encode_sequence_header(MpegEncContext *s)
- 
-                 put_bits(&s->pb, 3, s->avctx->profile); //profile
-                 put_bits(&s->pb, 4, s->avctx->level); //level
-+   // MEANX pulldown put_bits(&s->pb, 1, s->progressive_sequence);
-+  // MEANX Pulldown
-+ if(s->flags2 & CODEC_FLAG2_32_PULLDOWN) //MEANX
-+                        put_bits(&s->pb, 1, 0);
-+                else
-+                        put_bits(&s->pb, 1, s->progressive_sequence);
-+
-+
-+// /MEANX
-+
- 
--                put_bits(&s->pb, 1, s->progressive_sequence);
-                 put_bits(&s->pb, 2, s->chroma_format);
-                 put_bits(&s->pb, 2, s->width >>12);
-                 put_bits(&s->pb, 2, s->height>>12);
-@@ -339,6 +382,8 @@ void ff_mpeg1_encode_slice_header(MpegEncContext *s){
- 
- void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
- {
-+	int tff,rff; //MEANX
-+
-     mpeg1_encode_sequence_header(s);
- 
-     /* mpeg1 picture header */
-@@ -375,6 +420,49 @@ void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
- 
-     s->frame_pred_frame_dct = 1;
-     if(s->codec_id == CODEC_ID_MPEG2VIDEO){
-+ /* MEANX -- Pulldown */
-+        if(s->flags2 & CODEC_FLAG2_32_PULLDOWN)
-+        {
-+        
-+                switch((s->picture_number - 
-+                          s->gop_picture_number)&3)
-+                {
-+                        case 0:
-+                        default:
-+                                rff=1;
-+                                tff=1;
-+                                break;
-+                        case 1:
-+                                rff=0;
-+                                tff=0;
-+                                break;
-+                        case 2:
-+                                rff=1;
-+                                tff=0;
-+                                break;
-+                        case 3:
-+                                rff=0;
-+                                tff=1;
-+                                break;
-+                }               
-+           }
-+        else
-+        {
-+                if (s->progressive_sequence) 
-+                {
-+                        tff=0; /* no repeat */
-+                } else 
-+                {
-+                        tff= s->current_picture_ptr->top_field_first;
-+                }
-+                rff=s->repeat_first_field;
-+        
-+        }
-+
-+//               /MEANX pulldown
-+
-+
-+
-         put_header(s, EXT_START_CODE);
-         put_bits(&s->pb, 4, 8); //pic ext
-         if (s->pict_type == FF_P_TYPE || s->pict_type == FF_B_TYPE) {
-@@ -393,11 +481,16 @@ void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
- 
-         assert(s->picture_structure == PICT_FRAME);
-         put_bits(&s->pb, 2, s->picture_structure);
-+#if 0 //MEANX
-+
-         if (s->progressive_sequence) {
-             put_bits(&s->pb, 1, 0); /* no repeat */
-         } else {
-             put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first);
-         }
-+#endif
-+         put_bits(&s->pb, 1, tff);  //MEANX PULLDOWN
-+
-         /* XXX: optimize the generation of this flag with entropy
-            measures */
-         s->frame_pred_frame_dct = s->progressive_sequence;
-@@ -407,7 +500,10 @@ void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
-         put_bits(&s->pb, 1, s->q_scale_type);
-         put_bits(&s->pb, 1, s->intra_vlc_format);
-         put_bits(&s->pb, 1, s->alternate_scan);
--        put_bits(&s->pb, 1, s->repeat_first_field);
-+ // MEANX put_bits(&s->pb, 1, s->repeat_first_field);
-+	put_bits(&s->pb, 1, rff);
-+      // /MEANX
-+
-         s->progressive_frame = s->progressive_sequence;
-         put_bits(&s->pb, 1, s->chroma_format == CHROMA_420 ? s->progressive_frame : 0); /* chroma_420_type */
-         put_bits(&s->pb, 1, s->progressive_frame);

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpegvideo.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpegvideo.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpegvideo.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,17 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
-index b5631cf..770fed5 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
-@@ -641,7 +641,11 @@ av_cold int MPV_common_init(MpegEncContext *s)
-     FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
- 
-     s->parse_context.state= -1;
--    if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){
-+ //MEANX: Allocate them always, as they may be free when we decode 1st image
-+
-+    // MEANXif((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){
-+if(1){ // MEANX
-+
-        s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
-        s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
-        s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpegvideo_enc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpegvideo_enc.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_mpegvideo_enc.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,32 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
-index a8616d0..0b226d8 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
-@@ -367,12 +367,14 @@ av_cold int MPV_encode_init(AVCodecContext *avctx)
- 
-         av_log(avctx, AV_LOG_INFO, "Warning vbv_delay will be set to 0xFFFF (=VBR) as the specified vbv buffer is too large for the given bitrate!\n");
-     }
-+#if 0 //MEANX
- 
-     if((s->flags & CODEC_FLAG_4MV) && s->codec_id != CODEC_ID_MPEG4
-        && s->codec_id != CODEC_ID_H263 && s->codec_id != CODEC_ID_H263P && s->codec_id != CODEC_ID_FLV1){
-         av_log(avctx, AV_LOG_ERROR, "4MV not supported by codec\n");
-         return -1;
-     }
-+#endif
- 
-     if(s->obmc && s->avctx->mb_decision != FF_MB_DECISION_SIMPLE){
-         av_log(avctx, AV_LOG_ERROR, "OBMC is only supported with simple mb decision\n");
-@@ -413,10 +415,12 @@ av_cold int MPV_encode_init(AVCodecContext *avctx)
-         return -1;
-     }
- 
-+#if 0 //MEANX
-     if(s->mpeg_quant && s->codec_id != CODEC_ID_MPEG4){ //FIXME mpeg2 uses that too
-         av_log(avctx, AV_LOG_ERROR, "mpeg2 style quantization not supported by codec\n");
-         return -1;
-     }
-+#endif
- 
-     if((s->flags & CODEC_FLAG_CBP_RD) && !avctx->trellis){
-         av_log(avctx, AV_LOG_ERROR, "CBP RD needs trellis quant\n");

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_png.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_png.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_png.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,13 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/png.c b/avidemux_core/ADM_ffmpeg/libavcodec/png.c
-index 534dc68..1a6e137 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/png.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/png.c
-@@ -20,7 +20,7 @@
-  */
- #include "avcodec.h"
- #include "bytestream.h"
--#include "png.h"
-+#include "ffpng.h"
- 
- const uint8_t ff_pngsig[8] = {137, 80, 78, 71, 13, 10, 26, 10};
- const uint8_t ff_mngsig[8] = {138, 77, 78, 71, 13, 10, 26, 10};

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_pngdec.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_pngdec.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_pngdec.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,13 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c b/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
-index 03859a9..e1b6d6e 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
-@@ -20,7 +20,7 @@
-  */
- #include "avcodec.h"
- #include "bytestream.h"
--#include "png.h"
-+#include "ffpng.h"
- #include "dsputil.h"
- 
- /* TODO:

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_pngenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_pngenc.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_pngenc.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,13 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c b/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
-index 615bcc4..4149234 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
-@@ -21,7 +21,7 @@
- #include "avcodec.h"
- #include "bytestream.h"
- #include "dsputil.h"
--#include "png.h"
-+#include "ffpng.h"
- 
- /* TODO:
-  * - add 2, 4 and 16 bit depth support

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_utils.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_utils.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_utils.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,42 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/utils.c b/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
-index 56d4dbd..aad5a47 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
-@@ -643,10 +643,12 @@ int attribute_align_arg avcodec_decode_audio3(AVCodecContext *avctx, int16_t *sa
- 
-     if((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size){
-         //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
-+#if 0 // MEANX : Silence
-         if(*frame_size_ptr < AVCODEC_MAX_AUDIO_FRAME_SIZE){
-             av_log(avctx, AV_LOG_ERROR, "buffer smaller than AVCODEC_MAX_AUDIO_FRAME_SIZE\n");
-             return -1;
-         }
-+#endif
-         if(*frame_size_ptr < FF_MIN_BUFFER_SIZE ||
-         *frame_size_ptr < avctx->channels * avctx->frame_size * sizeof(int16_t)){
-             av_log(avctx, AV_LOG_ERROR, "buffer %d too small\n", *frame_size_ptr);
-@@ -921,13 +923,13 @@ unsigned avcodec_version( void )
- 
- const char *avcodec_configuration(void)
- {
--    return FFMPEG_CONFIGURATION;
-+    return "avidemux"; //FFMPEG_CONFIGURATION;
- }
- 
- const char *avcodec_license(void)
- {
- #define LICENSE_PREFIX "libavcodec license: "
--    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
-+    return LICENSE_PREFIX /*FFMPEG_LICENSE*/ "GPL" + sizeof(LICENSE_PREFIX) - 1;
- }
- 
- void avcodec_init(void)
-@@ -1080,7 +1082,7 @@ int av_tempfile(char *prefix, char **filename) {
-         return -1;
-     }
- #if !HAVE_MKSTEMP
--    fd = open(*filename, O_RDWR | O_BINARY | O_CREAT, 0444);
-+    fd = open(*filename, O_RDWR /* MEANX | O_BINARY*/ | O_CREAT, 0444);
- #else
-     snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
-     fd = mkstemp(*filename);

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_x86_mathops.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_x86_mathops.h	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_x86_mathops.h	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,17 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h b/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
-index 5949dfe..c7f54c5 100644
---- a/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
-+++ b/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
-@@ -22,7 +22,12 @@
- #ifndef AVCODEC_X86_MATHOPS_H
- #define AVCODEC_X86_MATHOPS_H
- 
-+// MEANX
-+#ifndef ADM_NO_CONFIG_H
- #include "config.h"
-+#endif
-+// MEANX
-+
- #include "libavutil/common.h"
- 
- #if ARCH_X86_32

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_file.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_file.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_file.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,77 +0,0 @@
-*** libavformat/file.c.old	Mon Feb  2 19:49:57 2009
---- libavformat/file.c	Mon Feb  2 19:49:56 2009
-***************
-*** 30,35 ****
---- 30,101 ----
-  #include <stdlib.h>
-  #include "os_support.h"
-  
-+ // GRUNTSTER start
-+ #ifdef __WIN32
-+ #include <windows.h>
-+ 
-+ int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString)
-+ {
-+ 	int wideCharStringLength = MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, NULL, 0);
-+ 
-+ 	if (wideCharString)
-+ 		MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, wideCharString, wideCharStringLength);
-+ 
-+ 	return wideCharStringLength;
-+ }
-+ 
-+ int ADM_open(const char *path, int oflag, ...)
-+ {
-+ 	int fileNameLength = utf8StringToWideChar(path, -1, NULL);
-+ 	wchar_t wcFile[fileNameLength];
-+ 	int creation = 0, access = 0;
-+ 	HANDLE hFile;
-+ 
-+ 	utf8StringToWideChar(path, -1, wcFile);
-+ 
-+ 	if (oflag & O_WRONLY || oflag & O_RDWR)
-+ 	{
-+ 		access = GENERIC_WRITE;
-+ 
-+ 		if (oflag & O_RDWR)
-+ 			access |= GENERIC_READ;
-+ 
-+ 		if (oflag & O_CREAT)
-+ 		{
-+ 			if (oflag & O_EXCL)
-+ 				creation = CREATE_NEW;
-+ 			else if (oflag & O_TRUNC)
-+ 				creation = CREATE_ALWAYS;
-+ 			else
-+ 				creation = OPEN_ALWAYS;
-+ 		}
-+ 		else if (oflag & O_TRUNC)
-+ 			creation = TRUNCATE_EXISTING;
-+ 	}
-+ 	else if (oflag & O_RDONLY)
-+ 		creation = OPEN_EXISTING;
-+ 
-+ 	if (creation & GENERIC_WRITE)
-+ 	{
-+ 		hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
-+ 
-+ 		if (hFile == INVALID_HANDLE_VALUE)
-+ 			return -1;
-+ 		else
-+ 			CloseHandle(hFile);
-+ 	}
-+ 
-+ 	hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
-+ 
-+ 	if (hFile == INVALID_HANDLE_VALUE)
-+ 		return -1;
-+ 	else
-+ 		return _open_osfhandle((intptr_t)hFile, oflag);
-+ }
-+ 
-+ #define open ADM_open
-+ #endif
-+ // GRUNTSTER end
-  
-  /* standard file protocol */
-  

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_flvenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_flvenc.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_flvenc.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,33 +0,0 @@
-*** libavformat/flvenc.c.old	Mon Feb  2 19:49:58 2009
---- libavformat/flvenc.c	Mon Feb  2 19:49:57 2009
-***************
-*** 389,395 ****
-      "video/x-flv",
-      "flv",
-      sizeof(FLVContext),
-! #if CONFIG_LIBMP3LAME
-      CODEC_ID_MP3,
-  #else // CONFIG_LIBMP3LAME
-      CODEC_ID_ADPCM_SWF,
---- 389,396 ----
-      "video/x-flv",
-      "flv",
-      sizeof(FLVContext),
-! //MEANX #if CONFIG_LIBMP3LAME
-! #ifdef HAVE_LIBMP3LAME
-      CODEC_ID_MP3,
-  #else // CONFIG_LIBMP3LAME
-      CODEC_ID_ADPCM_SWF,
-***************
-*** 401,403 ****
---- 402,410 ----
-      .codec_tag= (const AVCodecTag* const []){flv_video_codec_ids, flv_audio_codec_ids, 0},
-      .flags= AVFMT_GLOBALHEADER,
-  };
-+ // MEANX
-+ int flvenc_init(void)
-+ {
-+     av_register_output_format(&flv_muxer);
-+     return 0;
-+ }
-\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_isom.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_isom.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_isom.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,22 +0,0 @@
-*** libavformat/isom.c.old	Mon Feb  2 19:49:59 2009
---- libavformat/isom.c	Mon Feb  2 19:49:59 2009
-***************
-*** 187,193 ****
-      { CODEC_ID_MACE3, MKTAG('M', 'A', 'C', '3') }, /* Macintosh Audio Compression and Expansion 3:1 */
-      { CODEC_ID_MACE6, MKTAG('M', 'A', 'C', '6') }, /* Macintosh Audio Compression and Expansion 6:1 */
-  
-!     { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at http://www.3ivx.com/showcase.html use this tag */
-      { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
-  
-  /*  { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at http://heroinewarrior.com/xmovie.php3 use this tag */
---- 187,196 ----
-      { CODEC_ID_MACE3, MKTAG('M', 'A', 'C', '3') }, /* Macintosh Audio Compression and Expansion 3:1 */
-      { CODEC_ID_MACE6, MKTAG('M', 'A', 'C', '6') }, /* Macintosh Audio Compression and Expansion 6:1 */
-  
-!     //MEANX { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at http://www.3ivx.com/showcase.html use this tag */
-!      { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
-!      { CODEC_ID_MP2, MKTAG( 'm', 'p', '4', 'a') },
-!     // /MEANX
-      { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
-  
-  /*  { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at http://heroinewarrior.com/xmovie.php3 use this tag */

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_matroskaenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_matroskaenc.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_matroskaenc.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,85 +0,0 @@
-*** libavformat/matroskaenc.c.old	Wed Apr  1 18:35:42 2009
---- libavformat/matroskaenc.c	Wed Apr  1 18:35:42 2009
-***************
-*** 395,400 ****
---- 395,401 ----
-  
-  static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec)
-  {
-+ #if 0 // MEANX avidemux does thing differently
-      uint8_t *header_start[3];
-      int header_len[3];
-      int first_header_size;
-***************
-*** 419,424 ****
---- 420,447 ----
-          put_buffer(pb, header_start[j], header_len[j]);
-  
-      return 0;
-+ #else
-+    // Not endian safe....
-+       uint32_t packetLen[3],*ptr=(uint32_t *)codec->extradata;
-+       uint8_t *data[3],i,j;
-+       if( 3*4+ptr[0]+ptr[1]+ptr[2]!=codec->extradata_size)
-+       {
-+         av_log(s, AV_LOG_ERROR, "Broken avidemux xiph header.\n");
-+         return -1;
-+       }
-+       data[0]=codec->extradata+3*4;
-+       data[1]=data[0]+ptr[0];
-+       data[2]=data[1]+ptr[1];
-+       put_byte(pb, 2);                    // number packets - 1
-+       for (j = 0; j < 2; j++) 
-+       {
-+           put_xiph_size(pb, ptr[j]);
-+       }
-+       for (j = 0; j < 3; j++)
-+         put_buffer(pb, data[j], ptr[j]);
-+       
-+       return 0; // /MEANX
-+ #endif
-  }
-  
-  static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
-***************
-*** 534,539 ****
---- 557,579 ----
-          put_ebml_uint (pb, MATROSKA_ID_TRACKNUMBER     , i + 1);
-          put_ebml_uint (pb, MATROSKA_ID_TRACKUID        , i + 1);
-          put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
-+ /**  MEANX : Add a default duration for video **/
-+         if(codec->codec_type==CODEC_TYPE_VIDEO)
-+         {
-+           if(codec->time_base.den && codec->time_base.num)
-+           {
-+             int num=codec->time_base.num;
-+             int den=codec->time_base.den;
-+             unsigned int default_duration;
-+             float period=num;
-+                   period/=den;
-+                   period*=1000*1000*1000; // in ns
-+                   default_duration=(unsigned int)floor(period);
-+                   put_ebml_uint (pb, MATROSKA_ID_TRACKDEFAULTDURATION ,default_duration);
-+           }
-+         }
-+         
-+ /**  MEANX : Add a default duration for video **/
-  
-          if ((tag = av_metadata_get(st->metadata, "description", NULL, 0)))
-              put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value);
-***************
-*** 907,909 ****
---- 947,959 ----
-      .flags = AVFMT_GLOBALHEADER,
-      .codec_tag = (const AVCodecTag* const []){codec_wav_tags, 0},
-  };
-+ // MEANX
-+ //
-+ int matroskaenc_init(void)
-+ {
-+     av_register_output_format(&matroska_muxer);
-+     return 0;
-+ }
-+ // /MEANX
-+ 
-+ 

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_movenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_movenc.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_movenc.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,20 +0,0 @@
-*** libavformat/movenc.c.old	Wed Apr  1 18:35:42 2009
---- libavformat/movenc.c	Wed Apr  1 18:35:42 2009
-***************
-*** 1960,1962 ****
---- 1960,1974 ----
-      .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
-  };
-  #endif
-+ /* MEANX */
-+ int movenc_init(void)
-+ {
-+     av_register_output_format(&mov_muxer);
-+     av_register_output_format(&tgp_muxer);
-+     av_register_output_format(&mp4_muxer);
-+     av_register_output_format(&psp_muxer);
-+     av_register_output_format(&tg2_muxer);
-+     av_register_output_format(&ipod_muxer);
-+     return 0;
-+ }
-+ /* MEANX */

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegenc.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegenc.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,17 +0,0 @@
---- libavformat/mpegenc.c
-+++ libavformat/mpegenc.c
-@@ -1300,3 +1300,13 @@ AVOutputFormat mpeg2dvd_muxer = {
-     mpeg_mux_end,
- };
- #endif
-+// MEANX
-+//
-+int mpegenc_init(void)
-+{
-+    av_register_output_format(&mpeg2dvd_muxer);
-+    av_register_output_format(&mpeg2svcd_muxer);
-+    av_register_output_format(&mpeg2vob_muxer);
-+    av_register_output_format(&mpeg1vcd_muxer);
-+    return 0;
-+}
-\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegtsenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegtsenc.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegtsenc.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,12 +0,0 @@
---- libavformat/mpegtsenc.c
-+++ libavformat/mpegtsenc.c
-@@ -809,3 +809,8 @@ AVOutputFormat mpegts_muxer = {
-     mpegts_write_packet,
-     mpegts_write_end,
- };
-+int mpegtsenc_init(void)
-+{
-+    av_register_output_format(&mpegts_muxer);
-+    return 0;
-+}
-\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_utils.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_utils.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_utils.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,21 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavformat/utils.c b/avidemux_core/ADM_ffmpeg/libavformat/utils.c
-index 22c833d..e90b609 100644
---- a/avidemux_core/ADM_ffmpeg/libavformat/utils.c
-+++ b/avidemux_core/ADM_ffmpeg/libavformat/utils.c
-@@ -49,13 +49,14 @@ unsigned avformat_version(void)
- 
- const char *avformat_configuration(void)
- {
--    return FFMPEG_CONFIGURATION;
-+    return "avidemux"; //FFMPEG_CONFIGURATION;
- }
- 
- const char *avformat_license(void)
- {
- #define LICENSE_PREFIX "libavformat license: "
--    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
-+    //return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
-+        return LICENSE_PREFIX "GPL";
- }
- 
- /* fraction handling */

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_avutil.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_avutil.h.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_avutil.h.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,18 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavutil/avutil.h b/avidemux_core/ADM_ffmpeg/libavutil/avutil.h
-index 72bd2c5..a81225f 100644
---- a/avidemux_core/ADM_ffmpeg/libavutil/avutil.h
-+++ b/avidemux_core/ADM_ffmpeg/libavutil/avutil.h
-@@ -26,6 +26,13 @@
-  * external API header
-  */
- 
-+/* MEANX
-+ * - */
-+#define ASMALIGN(ZEROBITS) ".p2align " #ZEROBITS "\n\t"
-+/* /MEANX
-+ */
-+
-+
- 
- #define AV_STRINGIFY(s)         AV_TOSTRING(s)
- #define AV_TOSTRING(s) #s

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_bswap.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_bswap.h.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_bswap.h.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,16 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavutil/bswap.h b/avidemux_core/ADM_ffmpeg/libavutil/bswap.h
-index 6dd2a35..f7a422c 100644
---- a/avidemux_core/ADM_ffmpeg/libavutil/bswap.h
-+++ b/avidemux_core/ADM_ffmpeg/libavutil/bswap.h
-@@ -27,7 +27,11 @@
- #define AVUTIL_BSWAP_H
- 
- #include <stdint.h>
-+// MEANX
-+#ifndef ADM_NO_CONFIG_H
- #include "config.h"
-+#endif
-+// /MEANX
- #include "attributes.h"
- 
- #if   ARCH_ARM

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_internal.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_internal.h.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_internal.h.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,49 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavutil/internal.h b/avidemux_core/ADM_ffmpeg/libavutil/internal.h
-index 2faafc9..8516159 100644
---- a/avidemux_core/ADM_ffmpeg/libavutil/internal.h
-+++ b/avidemux_core/ADM_ffmpeg/libavutil/internal.h
-@@ -34,7 +34,11 @@
- #include <stdint.h>
- #include <stddef.h>
- #include <assert.h>
-+//MEANX
-+#ifndef ADM_NO_CONFIG_H
- #include "config.h"
-+#endif
-+// /MEANX
- #include "attributes.h"
- #include "timer.h"
- 
-@@ -95,6 +99,8 @@
- #endif
- 
- /* Use to export labels from asm. */
-+#include "ADM_mangle.h"
-+#if 0 // MEANX
- #define LABEL_MANGLE(a) EXTERN_PREFIX #a
- 
- // Use rip-relative addressing if compiling PIC code on x86-64.
-@@ -105,7 +111,7 @@
- #endif
- 
- #define MANGLE(a) EXTERN_PREFIX LOCAL_MANGLE(a)
--
-+#endif // MEANX
- /* debug stuff */
- 
- /* dprintf macros */
-@@ -134,12 +140,14 @@
- #endif
- 
- /* avoid usage of dangerous/inappropriate system functions */
-+#if 0 //MEANX
- #undef  malloc
- #define malloc please_use_av_malloc
- #undef  free
- #define free please_use_av_free
- #undef  realloc
- #define realloc please_use_av_realloc
-+#endif
- #undef  time
- #define time time_is_forbidden_due_to_security_issues
- #undef  rand

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_intreadwrite.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_intreadwrite.h.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_intreadwrite.h.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,17 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavutil/intreadwrite.h b/avidemux_core/ADM_ffmpeg/libavutil/intreadwrite.h
-index c8026f0..272a3b1 100644
---- a/avidemux_core/ADM_ffmpeg/libavutil/intreadwrite.h
-+++ b/avidemux_core/ADM_ffmpeg/libavutil/intreadwrite.h
-@@ -20,7 +20,12 @@
- #define AVUTIL_INTREADWRITE_H
- 
- #include <stdint.h>
-+// MEANX
-+#ifndef ADM_NO_CONFIG_H
- #include "config.h"
-+#endif
-+// MEANX
-+
- #include "bswap.h"
- #include "common.h"
- 

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_lfg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_lfg.h	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_lfg.h	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,50 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavutil/lfg.c b/avidemux_core/ADM_ffmpeg/libavutil/lfg.c
-index 1dad4e4..9b1db67 100644
---- a/avidemux_core/ADM_ffmpeg/libavutil/lfg.c
-+++ b/avidemux_core/ADM_ffmpeg/libavutil/lfg.c
-@@ -37,7 +37,7 @@ void av_cold av_lfg_init(AVLFG *c, unsigned int seed){
-         c->state[i+2]= AV_RL32(tmp+8);
-         c->state[i+3]= AV_RL32(tmp+12);
-     }
--    c->index=0;
-+    c->xindex=0;
- }
- 
- void av_bmg_get(AVLFG *lfg, double out[2])
-diff --git a/avidemux_core/ADM_ffmpeg/libavutil/lfg.h b/avidemux_core/ADM_ffmpeg/libavutil/lfg.h
-index c952fc8..9648fce 100644
---- a/avidemux_core/ADM_ffmpeg/libavutil/lfg.h
-+++ b/avidemux_core/ADM_ffmpeg/libavutil/lfg.h
-@@ -23,7 +23,7 @@
- #define AVUTIL_LFG_H
- typedef struct {
-     unsigned int state[64];
--    int index;
-+    int xindex;
- } AVLFG;
- 
- void av_lfg_init(AVLFG *c, unsigned int seed);
-@@ -35,8 +35,8 @@ void av_lfg_init(AVLFG *c, unsigned int seed);
-  * it may be good enough and faster for your specific use case.
-  */
- static inline unsigned int av_lfg_get(AVLFG *c){
--    c->state[c->index & 63] = c->state[(c->index-24) & 63] + c->state[(c->index-55) & 63];
--    return c->state[c->index++ & 63];
-+    c->state[c->xindex & 63] = c->state[(c->xindex-24) & 63] + c->state[(c->xindex-55) & 63];
-+    return c->state[c->xindex++ & 63];
- }
- 
- /**
-@@ -45,9 +45,9 @@ static inline unsigned int av_lfg_get(AVLFG *c){
-  * Please also consider av_lfg_get() above, it is faster.
-  */
- static inline unsigned int av_mlfg_get(AVLFG *c){
--    unsigned int a= c->state[(c->index-55) & 63];
--    unsigned int b= c->state[(c->index-24) & 63];
--    return c->state[c->index++ & 63] = 2*a*b+a+b;
-+    unsigned int a= c->state[(c->xindex-55) & 63];
-+    unsigned int b= c->state[(c->xindex-24) & 63];
-+    return c->state[c->xindex++ & 63] = 2*a*b+a+b;
- }
- 
- /**

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_libm.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_libm.h.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_libm.h.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,16 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavutil/libm.h b/avidemux_core/ADM_ffmpeg/libavutil/libm.h
-index c7c28ac..3f6ae07 100644
---- a/avidemux_core/ADM_ffmpeg/libavutil/libm.h
-+++ b/avidemux_core/ADM_ffmpeg/libavutil/libm.h
-@@ -25,7 +25,11 @@
- #define AVUTIL_LIBM_H
- 
- #include <math.h>
-+//MEANX
-+#ifndef ADM_NO_CONFIG_H
- #include "config.h"
-+#endif
-+///MEANX
- #include "attributes.h"
- 
- #if !HAVE_EXP2

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_mem.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_mem.c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_mem.c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,182 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavutil/mem.c b/avidemux_core/ADM_ffmpeg/libavutil/mem.c
-index 8cad089..8e95a78 100644
---- a/avidemux_core/ADM_ffmpeg/libavutil/mem.c
-+++ b/avidemux_core/ADM_ffmpeg/libavutil/mem.c
-@@ -63,87 +63,110 @@ void  free(void *ptr);
- 
- void *av_malloc(unsigned int size)
- {
--    void *ptr = NULL;
--#if CONFIG_MEMALIGN_HACK
--    long diff;
--#endif
--
--    /* let's disallow possible ambiguous cases */
--    if(size > (INT_MAX-16) )
--        return NULL;
--
--#if CONFIG_MEMALIGN_HACK
--    ptr = malloc(size+16);
--    if(!ptr)
--        return ptr;
--    diff= ((-(long)ptr - 1)&15) + 1;
--    ptr = (char*)ptr + diff;
--    ((char*)ptr)[-1]= diff;
--#elif HAVE_POSIX_MEMALIGN
--    if (posix_memalign(&ptr,16,size))
--        ptr = NULL;
--#elif HAVE_MEMALIGN
--    ptr = memalign(16,size);
--    /* Why 64?
--       Indeed, we should align it:
--         on 4 for 386
--         on 16 for 486
--         on 32 for 586, PPro - K6-III
--         on 64 for K7 (maybe for P3 too).
--       Because L1 and L2 caches are aligned on those values.
--       But I don't want to code such logic here!
--     */
--     /* Why 16?
--        Because some CPUs need alignment, for example SSE2 on P4, & most RISC CPUs
--        it will just trigger an exception and the unaligned load will be done in the
--        exception handler or it will just segfault (SSE2 on P4).
--        Why not larger? Because I did not see a difference in benchmarks ...
--     */
--     /* benchmarks with P3
--        memalign(64)+1          3071,3051,3032
--        memalign(64)+2          3051,3032,3041
--        memalign(64)+4          2911,2896,2915
--        memalign(64)+8          2545,2554,2550
--        memalign(64)+16         2543,2572,2563
--        memalign(64)+32         2546,2545,2571
--        memalign(64)+64         2570,2533,2558
--
--        BTW, malloc seems to do 8-byte alignment by default here.
--     */
-+#ifdef __APPLE__
-+	return malloc(size);
- #else
--    ptr = malloc(size);
-+	char *c;
-+
-+	uint64_t l, lorg;
-+	uint32_t *backdoor;
-+
-+	l = (uint64_t)malloc(size + 32);
-+
-+	// Get next boundary
-+	lorg = l;
-+	l = (l + 15) & 0xfffffffffffffff0LL;
-+	l += 16;
-+	c = (char*)l;
-+	backdoor = (uint32_t*)(c - 8);
-+	*backdoor = (0xdead << 16) + l - lorg;
-+	backdoor[1] = size;
-+
-+	return c;
- #endif
--    return ptr;
- }
- 
--void *av_realloc(void *ptr, unsigned int size)
-+void *av_realloc(void *ptr, unsigned int newsize)
- {
--#if CONFIG_MEMALIGN_HACK
--    int diff;
--#endif
-+#ifdef __APPLE__
-+	if (!ptr)
-+		return av_malloc(newsize);
- 
--    /* let's disallow possible ambiguous cases */
--    if(size > (INT_MAX-16) )
--        return NULL;
-+	if (!newsize)
-+	{
-+		av_free(ptr);
-+		return NULL;
-+	}
- 
--#if CONFIG_MEMALIGN_HACK
--    //FIXME this isn't aligned correctly, though it probably isn't needed
--    if(!ptr) return av_malloc(size);
--    diff= ((char*)ptr)[-1];
--    return (char*)realloc((char*)ptr - diff, size + diff) + diff;
-+	return realloc(ptr, newsize);
- #else
--    return realloc(ptr, size);
-+	void *nalloc;
-+
-+	if (!ptr)
-+		return av_malloc(newsize);
-+
-+	if (!newsize) 
-+	{
-+		av_free(ptr);
-+		return NULL;
-+	}
-+
-+	// now we either shrink them or expand them
-+	// in case of shrink, we do nothing
-+	// in case of expand we have to copy
-+	// Do copy everytime (slower)
-+	uint32_t *backdoor;
-+	uint32_t size, offset;
-+	char *c = (char*)ptr;
-+
-+	backdoor = (uint32_t*)ptr;
-+	backdoor -= 2;
-+
-+	assert(((*backdoor) >> 16) == 0xdead);
-+
-+	offset = backdoor[0] & 0xffff;
-+	size = backdoor[1];
-+
-+	if(size >= newsize) // do nothing
-+		return ptr;
-+
-+	// Allocate a new one
-+	nalloc = av_malloc(newsize);
-+	memcpy(nalloc, ptr, size);
-+	av_free(ptr);
-+
-+	return nalloc;
- #endif
- }
- 
- void av_free(void *ptr)
- {
--    /* XXX: this test should not be needed on most libcs */
--    if (ptr)
--#if CONFIG_MEMALIGN_HACK
--        free((char*)ptr - ((char*)ptr)[-1]);
-+#ifdef __APPLE__
-+	if (!ptr)
-+		return;
-+
-+	free(ptr);
- #else
--        free(ptr);
-+	uint32_t *backdoor;
-+	uint32_t size, offset;
-+	char *c = (char*)ptr;
-+
-+	if (!ptr)
-+		return;
-+
-+	backdoor = (uint32_t*)ptr;
-+	backdoor -= 2;
-+
-+	if (*backdoor == 0xbeefbeef)
-+		assert(0);
-+
-+	assert(((*backdoor) >> 16) == 0xdead);
-+
-+	offset = backdoor[0] & 0xffff;
-+	size = backdoor[1];
-+	*backdoor = 0xbeefbeef; // Scratch sig
-+
-+	free(c - offset);
- #endif
- }
- 

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_timer.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_timer.h.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_timer.h.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,17 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavutil/timer.h b/avidemux_core/ADM_ffmpeg/libavutil/timer.h
-index cd8fba8..66be371 100644
---- a/avidemux_core/ADM_ffmpeg/libavutil/timer.h
-+++ b/avidemux_core/ADM_ffmpeg/libavutil/timer.h
-@@ -26,7 +26,12 @@
- 
- #include <stdlib.h>
- #include <stdint.h>
-+// MEANX
-+#ifndef ADM_NO_CONFIG_H
- #include "config.h"
-+#endif
-+// MEANX
-+
- 
- #if   ARCH_ARM
- #   include "arm/timer.h"

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_x86_bswap.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_x86_bswap.h	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_x86_bswap.h	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,16 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavutil/x86/bswap.h b/avidemux_core/ADM_ffmpeg/libavutil/x86/bswap.h
-index 26dc4e2..c7a87dd 100644
---- a/avidemux_core/ADM_ffmpeg/libavutil/x86/bswap.h
-+++ b/avidemux_core/ADM_ffmpeg/libavutil/x86/bswap.h
-@@ -25,7 +25,11 @@
- #define AVUTIL_X86_BSWAP_H
- 
- #include <stdint.h>
-+// MEANX
-+#ifndef ADM_NO_CONFIG_H
- #include "config.h"
-+#endif
-+// /MEANX
- #include "libavutil/attributes.h"
- 
- #define bswap_16 bswap_16

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_x86_intreadwrite.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_x86_intreadwrite.h	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavutil_x86_intreadwrite.h	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,16 +0,0 @@
-diff --git a/avidemux_core/ADM_ffmpeg/libavutil/x86/intreadwrite.h b/avidemux_core/ADM_ffmpeg/libavutil/x86/intreadwrite.h
-index 4061d19..4740886 100644
---- a/avidemux_core/ADM_ffmpeg/libavutil/x86/intreadwrite.h
-+++ b/avidemux_core/ADM_ffmpeg/libavutil/x86/intreadwrite.h
-@@ -22,7 +22,11 @@
- #define AVUTIL_X86_INTREADWRITE_H
- 
- #include <stdint.h>
-+// MEANX
-+#ifndef ADM_NO_CONFIG_H
- #include "config.h"
-+#endif
-+/// MEANX
- #include "libavutil/attributes.h"
- 
- #if HAVE_MMX

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/swscale_c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/swscale_c.patch	2010-07-25 10:07:55 UTC (rev 6484)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/swscale_c.patch	2010-07-25 10:07:56 UTC (rev 6485)
@@ -1,19 +0,0 @@
-diff --git a/avidemux/ADM_libraries/ADM_ffmpeg/libswscale/swscale.c b/avidemux/ADM_libraries/ADM_ffmpeg/libswscale/swscale.c
-index 7a54fd7..4690d98 100644
---- libswscale/swscale.c
-+++ libswscale/swscale.c
-@@ -960,11 +960,14 @@ static inline void yuv2rgbXinC_full(SwsContext *c, int16_t *lumFilter, int16_t *
- #define COMPILE_C
- #endif
- 
-+#if 0 // MEANX
- #ifdef ARCH_PPC
- #if (defined (HAVE_ALTIVEC) || defined (RUNTIME_CPUDETECT)) && defined (CONFIG_GPL)
- #define COMPILE_ALTIVEC
- #endif //HAVE_ALTIVEC
- #endif //ARCH_PPC
-+#endif // MEANX
-+
- 
- #if defined(ARCH_X86)
- 



From mean at mail.berlios.de  Sun Jul 25 18:09:21 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 25 Jul 2010 18:09:21 +0200
Subject: [Avidemux-svn-commit] r6486 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm
Message-ID: <20100725160922.5DCFE480E6C@sheep.berlios.de>

Author: mean
Date: 2010-07-25 18:09:21 +0200 (Sun, 25 Jul 2010)
New Revision: 6486

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/ADM_ad_ima_adpcm.cpp
Log:
[adpcm] Fix bswap with newer ffmpeg

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/ADM_ad_ima_adpcm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/ADM_ad_ima_adpcm.cpp	2010-07-25 10:07:56 UTC (rev 6485)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/ADM_ad_ima_adpcm.cpp	2010-07-25 16:09:21 UTC (rev 6486)
@@ -80,10 +80,10 @@
 #define QT_IMA_ADPCM_BLOCK_SIZE 0x22
 #define QT_IMA_ADPCM_SAMPLES_PER_BLOCK 64
 
-#define BE_16(x) (be2me_16(*(unsigned short *)(x)))
-#define BE_32(x) (be2me_32(*(unsigned int *)(x)))
-#define LE_16(x) (le2me_16(*(unsigned short *)(x)))
-#define LE_32(x) (le2me_32(*(unsigned int *)(x)))
+#define BE_16(x) (be2me16(*(unsigned short *)(x)))
+#define BE_32(x) (be2me32(*(unsigned int *)(x)))
+#define LE_16(x) (av_le2ne16(*(unsigned short *)(x)))
+#define LE_32(x) (av_le2ne32(*(unsigned int *)(x)))
 
 int ms_ima_adpcm_decode_block(unsigned short *output,
   unsigned char *input, int channels, int block_size);



From mean at mail.berlios.de  Mon Jul 26 19:24:29 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 26 Jul 2010 19:24:29 +0200
Subject: [Avidemux-svn-commit] r6487 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
Message-ID: <20100726172429.ED6DF480EC8@sheep.berlios.de>

Author: mean
Date: 2010-07-26 19:24:29 +0200 (Mon, 26 Jul 2010)
New Revision: 6487

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/translation_table.h
Log:
[OCR] Remove OCR related menu entries

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui	2010-07-25 16:09:21 UTC (rev 6486)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui	2010-07-26 17:24:29 UTC (rev 6487)
@@ -1296,17 +1296,6 @@
     <addaction name="actionFilters"/>
     <addaction name="actionFrame_rate"/>
    </widget>
-   <widget class="QMenu" name="menuAudio">
-    <property name="title">
-     <string>&amp;Audio</string>
-    </property>
-    <addaction name="actionMain_Track"/>
-    <addaction name="actionSecondary_Track"/>
-    <addaction name="actionBuild_VBR_time_map"/>
-    <addaction name="separator"/>
-    <addaction name="actionSave_2"/>
-    <addaction name="actionFilters_2"/>
-   </widget>
    <widget class="QMenu" name="menuEdit">
     <property name="title">
      <string>&amp;Edit</string>
@@ -1390,10 +1379,6 @@
     <addaction name="actionBitrate_histogram"/>
     <addaction name="actionScan_for_black_frames"/>
     <addaction name="separator"/>
-    <addaction name="actionVob_to_vobsub"/>
-    <addaction name="actionOCR"/>
-    <addaction name="actionOCR_DVB_T_TS_files"/>
-    <addaction name="actionGlyphs_Edit"/>
     <addaction name="actionJavaScript_shell"/>
     <addaction name="actionPython_Shell"/>
    </widget>
@@ -1440,6 +1425,17 @@
     <addaction name="separator"/>
     <addaction name="actionQuit"/>
    </widget>
+   <widget class="QMenu" name="menuAudio">
+    <property name="title">
+     <string>&amp;Audio</string>
+    </property>
+    <addaction name="actionMain_Track"/>
+    <addaction name="actionSecondary_Track"/>
+    <addaction name="actionBuild_VBR_time_map"/>
+    <addaction name="separator"/>
+    <addaction name="actionSave_2"/>
+    <addaction name="actionFilters_2"/>
+   </widget>
    <addaction name="menuFile"/>
    <addaction name="menuEdit"/>
    <addaction name="menuView"/>
@@ -1880,28 +1876,6 @@
     <string>Scan for Black Frames</string>
    </property>
   </action>
-  <action name="actionVob_to_vobsub">
-   <property name="text">
-    <string>&amp;VOB -&gt; VobSub...</string>
-   </property>
-   <property name="iconText">
-    <string>VOB -&gt; VobSub</string>
-   </property>
-   <property name="toolTip">
-    <string>VOB -&gt; VobSub</string>
-   </property>
-  </action>
-  <action name="actionOCR">
-   <property name="text">
-    <string>&amp;OCR (VobSub -&gt; srt)...</string>
-   </property>
-   <property name="iconText">
-    <string>OCR (VobSub -&gt; srt)</string>
-   </property>
-   <property name="toolTip">
-    <string>OCR (VobSub -&gt; srt)</string>
-   </property>
-  </action>
   <action name="actionPlay_Stop">
    <property name="icon">
     <iconset resource="avidemux.qrc">
@@ -2223,28 +2197,6 @@
     <string>Save</string>
    </property>
   </action>
-  <action name="actionOCR_DVB_T_TS_files">
-   <property name="text">
-    <string>OCR (&amp;TS -&gt; srt)...</string>
-   </property>
-   <property name="iconText">
-    <string>OCR (TS -&gt; srt)</string>
-   </property>
-   <property name="toolTip">
-    <string>OCR (TS -&gt; srt)</string>
-   </property>
-  </action>
-  <action name="actionGlyphs_Edit">
-   <property name="text">
-    <string>Edit &amp;Glyphs...</string>
-   </property>
-   <property name="iconText">
-    <string>Edit Glyphs</string>
-   </property>
-   <property name="toolTip">
-    <string>Edit Glyphs</string>
-   </property>
-  </action>
   <action name="actionPreviewInput">
    <property name="checkable">
     <bool>true</bool>

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/translation_table.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/translation_table.h	2010-07-25 16:09:21 UTC (rev 6486)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/translation_table.h	2010-07-26 17:24:29 UTC (rev 6487)
@@ -19,8 +19,6 @@
 PROCESS(actionSave_project_as,ACT_SaveWork) \
 PROCESS(actionConnect_to_AvsProxy,ACT_AVS_PROXY) \
 PROCESS(actionReset_Edits,ACT_ResetSegments) \
-PROCESS(actionOCR_DVB_T_TS_files,ACT_DVB_Ocr) \
-PROCESS(actionGlyphs_Edit,ACT_GLYPHEDIT) \
 PROCESS(actionZoom_1_4,ACT_ZOOM_1_4) \
 PROCESS(actionZoom_1_2,ACT_ZOOM_1_2) \
 PROCESS(actionZoom_1_1,ACT_ZOOM_1_1) \
@@ -40,8 +38,6 @@
 PROCESS(actionRebuild_I_B_Frames,ACT_RebuildKF) \
 PROCESS(actionBitrate_histogram,ACT_BitRate) \
 PROCESS(actionScan_for_black_frames,ACT_AllBlackFrames) \
-PROCESS(actionVob_to_vobsub,ACT_V2V) \
-PROCESS(actionOCR,ACT_Ocr) \
 PROCESS(actionPlay_Stop,ACT_StopAvi) \
 PROCESS(actionPrevious_Frame,ACT_PreviousFrame) \
 PROCESS(actionNext_Frame,ACT_NextFrame) \
@@ -102,3 +98,13 @@
 PROCESS(toolButtonLastFrame, ACT_End) \
 PROCESS(pushButtonJumpToMarkerA, ACT_GotoMarkA) \
 PROCESS(pushButtonJumpToMarkerB, ACT_GotoMarkB)
+
+
+/*
+PROCESS(actionVob_to_vobsub,ACT_V2V) \
+PROCESS(actionOCR,ACT_Ocr) \
+PROCESS(actionOCR_DVB_T_TS_files,ACT_DVB_Ocr) \
+PROCESS(actionGlyphs_Edit,ACT_GLYPHEDIT) \
+
+
+*/



From mean at mail.berlios.de  Mon Jul 26 19:24:31 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 26 Jul 2010 19:24:31 +0200
Subject: [Avidemux-svn-commit] r6488 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src
Message-ID: <20100726172431.162BC480EC8@sheep.berlios.de>

Author: mean
Date: 2010-07-26 19:24:30 +0200 (Mon, 26 Jul 2010)
New Revision: 6488

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_coreCodecMapping.cpp
Log:
[Codec] Add VP8 support from ffmpeg

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_coreCodecMapping.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_coreCodecMapping.cpp	2010-07-26 17:24:29 UTC (rev 6487)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_coreCodecMapping.cpp	2010-07-26 17:24:30 UTC (rev 6488)
@@ -43,8 +43,9 @@
   {"WMV3", CODEC_ID_WMV3,       true, false,    true},
   {"WVC1", CODEC_ID_VC1,        true, false,    true},
   {"WMVA", CODEC_ID_VC1,        true, false,    true},
+  {"VP8 ", CODEC_ID_VP8,        true, false,    false},
 
-  {"WMVA", CODEC_ID_DVVIDEO,    true, false,    false},
+  
 // RefCopy
   {"FFV1", CODEC_ID_FFV1,       true, true,    false},
   {"H263", CODEC_ID_H263,       false, true,   false},



From mean at mail.berlios.de  Tue Jul 27 07:18:23 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 27 Jul 2010 07:18:23 +0200
Subject: [Avidemux-svn-commit] r6489 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <20100727051823.15654480E94@sheep.berlios.de>

Author: mean
Date: 2010-07-27 07:18:22 +0200 (Tue, 27 Jul 2010)
New Revision: 6489

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
Log:
[segement] Also delete segment when doing cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-07-26 17:24:30 UTC (rev 6488)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-07-27 05:18:22 UTC (rev 6489)
@@ -149,7 +149,7 @@
 */
 bool ADM_EditorSegment::deleteAll (void)
 {
-  ADM_info("[Editor] Deleting all video\n");
+  ADM_info("[Editor] Deleting all videos\n");
   int n=videos.size();
   for (uint32_t vid = 0; vid < n; vid++)
     {
@@ -188,6 +188,7 @@
     }
 
     videos.clear();
+    segments.clear();
     return true;
 }
 



From mean at mail.berlios.de  Tue Jul 27 07:18:24 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 27 Jul 2010 07:18:24 +0200
Subject: [Avidemux-svn-commit] r6490 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <20100727051824.237D8480E94@sheep.berlios.de>

Author: mean
Date: 2010-07-27 07:18:23 +0200 (Tue, 27 Jul 2010)
New Revision: 6490

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
Log:
[ui] Remove dead code, useless now

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2010-07-27 05:18:22 UTC (rev 6489)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2010-07-27 05:18:23 UTC (rev 6490)
@@ -154,7 +154,7 @@
                 name=prefs->get_lastfiles();
                 rank=(int)action-ACT_RECENT0;
                 ADM_assert(name[rank]);
-                A_openAvi2 (name[rank], 0);
+                A_openAvi (name[rank]);
                 return;
         case ACT_ViewMain: UI_toogleMain();return;
         case ACT_ViewSide: UI_toogleSide();return;
@@ -186,7 +186,7 @@
     	char *file;
 		if(		DIA_RecentFiles(&file))
 		{
-			A_openAvi2 (file, 0);
+			A_openAvi (file);
 		}
 		return;
     case ACT_About :
@@ -543,20 +543,12 @@
 //    mode 1: Suspicious
 //_____________________________________________________________
 
-void
-A_openBrokenAvi (const char *name)
-{
-  A_openAvi2 (name, 1);
-}
-
-int
-A_openAvi (const char *name)
-{
-  return A_openAvi2 (name, 0);
-}
 extern void GUI_PreviewEnd (void);
-
-int A_openAvi2 (const char *name, uint8_t mode)
+/**
+        \fn A_openAvi
+        \brief Open (replace mode) a video
+*/
+int A_openAvi (const char *name)
 {
   uint8_t res;
   char *longname;



From mean at mail.berlios.de  Tue Jul 27 07:18:25 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 27 Jul 2010 07:18:25 +0200
Subject: [Avidemux-svn-commit] r6491 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src
Message-ID: <20100727051825.41CBD480E94@sheep.berlios.de>

Author: mean
Date: 2010-07-27 07:18:25 +0200 (Tue, 27 Jul 2010)
New Revision: 6491

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAvidemux.cpp
Log:
[Script] Cosmetic

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAvidemux.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAvidemux.cpp	2010-07-27 05:18:23 UTC (rev 6490)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAvidemux.cpp	2010-07-27 05:18:25 UTC (rev 6491)
@@ -44,7 +44,7 @@
 int scriptLoadVideo(const char *s)
 {
 int ret=0;
-        jsLog("[Js] Loading video %s",s);
+        jsLog("[Js] Loading video %s\n",s);
         if(A_openAvi(s)) 
         {
           ret=1;



From mean at mail.berlios.de  Wed Jul 28 07:30:38 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 28 Jul 2010 07:30:38 +0200
Subject: [Avidemux-svn-commit] r6492 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
Message-ID: <20100728053038.7D76448054C@sheep.berlios.de>

Author: mean
Date: 2010-07-28 07:30:38 +0200 (Wed, 28 Jul 2010)
New Revision: 6492

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/file_qt4.cpp
Log:
[FileSel/Qt4] Close the race window where the string is automatically deallocated just before using it

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/file_qt4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/file_qt4.cpp	2010-07-27 05:18:25 UTC (rev 6491)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/file_qt4.cpp	2010-07-28 05:30:38 UTC (rev 6492)
@@ -67,8 +67,7 @@
 
 		if (!fileName.isNull() )
 		{
-			const char *s = fileName.toUtf8().constData();
-			*name = ADM_strdup(s);
+			*name = ADM_strdup(fileName.toUtf8().constData());
 			prefs->set(pref_entry, (ADM_filename*)*name);
 		}
 



From mean at mail.berlios.de  Wed Jul 28 07:30:40 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 28 Jul 2010 07:30:40 +0200
Subject: [Avidemux-svn-commit] r6493 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src
Message-ID: <20100728053040.142D748054C@sheep.berlios.de>

Author: mean
Date: 2010-07-28 07:30:39 +0200 (Wed, 28 Jul 2010)
New Revision: 6493

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
Log:
[CoreMuxer] Add conversion for EAC3 from ADM to FFMPEG type

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-07-28 05:30:38 UTC (rev 6492)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-07-28 05:30:39 UTC (rev 6493)
@@ -301,6 +301,7 @@
                                 c->extradata_size= audioextraSize;
                                 break;
                   case WAV_DTS: c->codec_id = CODEC_ID_DTS;c->frame_size=1024;break;
+                  case WAV_EAC3: c->codec_id = CODEC_ID_EAC3;c->frame_size=6*256;break;
                   case WAV_AC3: c->codec_id = CODEC_ID_AC3;c->frame_size=6*256;break;
                   case WAV_MP2: c->codec_id = CODEC_ID_MP2;c->frame_size=1152;break;
                   case WAV_MP3:



From mean at mail.berlios.de  Wed Jul 28 07:30:41 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 28 Jul 2010 07:30:41 +0200
Subject: [Avidemux-svn-commit] r6494 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat
Message-ID: <20100728053041.39A2448054C@sheep.berlios.de>

Author: mean
Date: 2010-07-28 07:30:41 +0200 (Wed, 28 Jul 2010)
New Revision: 6494

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
Log:
[libavformat] Refuse to copy an audio block larger than the buffer

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c	2010-07-28 05:30:39 UTC (rev 6493)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c	2010-07-28 05:30:41 UTC (rev 6494)
@@ -884,7 +884,13 @@
         av_free(data);
         return 0;
     }
-
+    // MEANX
+    if(size>DEFAULT_PES_PAYLOAD_SIZE)
+    {
+        av_log(s, AV_LOG_ERROR, "Audio size is greater than supported :%d,%d\n",(int)size,(int)DEFAULT_PES_PAYLOAD_SIZE);
+        return -1;
+    }
+    // MEANX
     if (ts_st->payload_index + size > DEFAULT_PES_PAYLOAD_SIZE) {
         mpegts_write_pes(s, st, ts_st->payload, ts_st->payload_index,
                          ts_st->payload_pts, ts_st->payload_dts);



From mean at mail.berlios.de  Wed Jul 28 07:30:42 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 28 Jul 2010 07:30:42 +0200
Subject: [Avidemux-svn-commit] r6495 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src
Message-ID: <20100728053042.5078C48054C@sheep.berlios.de>

Author: mean
Date: 2010-07-28 07:30:42 +0200 (Wed, 28 Jul 2010)
New Revision: 6495

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp
Log:
[audioStream] MP2 is same as MP3 as far as parsing is concerned

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp	2010-07-28 05:30:41 UTC (rev 6494)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp	2010-07-28 05:30:42 UTC (rev 6495)
@@ -141,6 +141,7 @@
             return new ADM_audioStreamEAC3(wavheader,access);    
         case WAV_AC3:
             return new ADM_audioStreamAC3(wavheader,access);
+        case WAV_MP2:
         case WAV_MP3:
             return new ADM_audioStreamMP3(wavheader,access);
         case WAV_DTS:



