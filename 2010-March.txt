From mean at mail.berlios.de  Mon Mar  1 07:22:04 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Mar 2010 07:22:04 +0100
Subject: [Avidemux-svn-commit] r5956 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_videoCodec/src
	avidemux/gtk/ADM_userInterfaces/ADM_dialog
	avidemux/qt4/ADM_userInterfaces/ADM_dialog
	avidemux/qt4/ADM_userInterfaces/ADM_gui
	avidemux_core/ADM_core/include
	avidemux_core/ADM_coreUI/include avidemux_core/ADM_coreUI/src
	avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <201003010622.o216M4la000024@sheep.berlios.de>

Author: mean
Date: 2010-03-01 07:22:02 +0100 (Mon, 01 Mar 2010)
New Revision: 5956

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_encoding.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_clock.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreUI_internal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_coreToolkit.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
Log:
[UI] Base groundwork for encoding dialog + qt4 version, some dos2unix to files while we are at it

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-03-01 06:22:02 UTC (rev 5956)
@@ -244,6 +244,7 @@
             ADM_assert(VDP_STATUS_OK==funcs.destroySurface((VDPAU->renders[i]->surface)));
             delete VDPAU->renders[i];
         }
+        printf("[VDPAU] Destroying decoder\n");
          ADM_assert(VDP_STATUS_OK==funcs.decoderDestroy(VDPAU->vdpDecoder));
          delete VDPAU;
          vdpau=NULL;

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_encoding.cpp	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_encoding.cpp	2010-03-01 06:22:02 UTC (rev 5956)
@@ -6,7 +6,7 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-
+#if 0
 #include <math.h>
 
 #include "ADM_toolkitGtk.h"
@@ -1001,3 +1001,4 @@
   gtk_widget_grab_default (closebutton1);
   return dialog1;
 }
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/CMakeLists.txt	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/CMakeLists.txt	2010-03-01 06:22:02 UTC (rev 5956)
@@ -1,42 +1,42 @@
-SET(ADM_LIB ADM_dialogQt4)
-
+SET(ADM_LIB ADM_dialogQt4)
+
 SET(    
-        uiFiles
-        about.ui  
-        calculator.ui  
-#encoding.ui  
-        license.ui
+        uiFiles
+        about.ui  
+        calculator.ui  
+        encoding.ui  
+        license.ui
         jobs.ui  
         props.ui  vobsub.ui  
-        working.ui)
-
-SET(headers
-	Q_about.h  Q_calculator.h  
-#Q_encoding.h
-	Q_license.h  Q_jobs.h  Q_props.h  Q_vobsub.h  Q_working.h  T_index_pg.h)
-
-QT4_WRAP_UI(${ADM_LIB}_headers ${uiFiles})
-QT4_WRAP_CPP(${ADM_LIB}_source ${headers})
-QT4_ADD_RESOURCES(${ADM_LIB}_resource  about.qrc)
-
-SET(${ADM_LIB}_SRCS ${${ADM_LIB}_SRCS}
+        working.ui)
+
+SET(headers
+	Q_about.h  Q_calculator.h  
+        Q_encoding.h
+	Q_license.h  Q_jobs.h  Q_props.h  Q_vobsub.h  Q_working.h  T_index_pg.h)
+
+QT4_WRAP_UI(${ADM_LIB}_headers ${uiFiles})
+QT4_WRAP_CPP(${ADM_LIB}_source ${headers})
+QT4_ADD_RESOURCES(${ADM_LIB}_resource  about.qrc)
+
+SET(${ADM_LIB}_SRCS ${${ADM_LIB}_SRCS}
 	${${ADM_LIB}_headers}  ${${ADM_LIB}_source}  ${${ADM_LIB}_resource}  
-        Q_about.cpp  
-        Q_license.cpp
-        Q_jobs.cpp  Q_props.cpp   
-        Q_working.cpp   
-        T_index_pg.cpp
+        Q_about.cpp  
+        Q_license.cpp
+        Q_jobs.cpp  Q_props.cpp   
+        Q_working.cpp   
+        T_index_pg.cpp
         alert_qt4.cpp  
         DIA_busy.cpp  
-        DIA_none.cpp  
+        DIA_none.cpp  
 #DIA_xvid4.cpp  OCR_none.cpp
 #Q_vobsub.cpp  
 #Q_calculator.cpp  
-#Q_encoding.cpp  
-
-)
-
-ADD_DEFINITIONS(-DADM_SUBVERSION=${ADM_SUBVERSION})
-INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})
-INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/avidemux/ADM_UIs/ADM_QT4/include")
-ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+        Q_encoding.cpp  
+
+)
+
+ADD_DEFINITIONS(-DADM_SUBVERSION=${ADM_SUBVERSION})
+INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})
+INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/avidemux/ADM_UIs/ADM_QT4/include")
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2010-03-01 06:22:02 UTC (rev 5956)
@@ -1,463 +1,302 @@
-/***************************************************************************
-    copyright            : (C) 2001 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <math.h>
-
-#include "Q_encoding.h"
-#include "prefs.h"
-#include "DIA_working.h"
-#include "DIA_encoding.h"
-#include "DIA_coreToolkit.h"
-#include "ADM_libraries/ADM_utilities/avidemutils.h"
-#include "ADM_video/ADM_vidMisc.h"
-
-extern void UI_purge(void);
-static int stopReq=0;
-
-encodingWindow::encodingWindow() : QDialog()
- {
-	ui.setupUi(this);
-
-#ifndef __WIN32
-	//check for root privileges
-	if (getuid() == 0)
-	{
-		// set priority to normal, regardless of preferences
-		ui.comboBoxPriority->setCurrentIndex(2);
-	}
-#endif
-
-	connect(ui.checkBoxShutdown, SIGNAL(stateChanged(int)), this, SLOT(shutdownChanged(int)));
-	connect(ui.pushButton, SIGNAL(pressed()), this, SLOT(buttonPressed()));
-	connect(ui.comboBoxPriority, SIGNAL(currentIndexChanged(int)), this, SLOT(priorityChanged(int)));
-
-	// set priority
-	uint32_t priority;
-
-	prefs->get(PRIORITY_ENCODING,&priority);	
-
-#ifndef __WIN32
-	// check for root privileges
-	if (getuid() == 0)
-	{
-		ui.comboBoxPriority->setCurrentIndex(priority);
-	}
-#else
-	ui.comboBoxPriority->setCurrentIndex(priority);
-#endif
- }
-
-void encodingWindow::buttonPressed(void)
-{
-	printf("StopReq\n");
-	stopReq=1;
-}
-
-void encodingWindow::priorityChanged(int priorityLevel)
-{
-#ifndef __WIN32
-	if (getuid() != 0)
-	{
-		ui.comboBoxPriority->disconnect(SIGNAL(currentIndexChanged(int)));
-		ui.comboBoxPriority->setCurrentIndex(2);
-		connect(ui.checkBoxShutdown, SIGNAL(currentIndexChanged(int)), this, SLOT(priorityChanged(int)));
-
-		GUI_Error_HIG(QT_TR_NOOP("Privileges Required"), QT_TR_NOOP( "Root privileges are required to perform this operation."));
-
-		return;
-	}
-#endif
-
-	setpriority(PRIO_PROCESS, 0, ADM_getNiceValue(priorityLevel));
-}
-
-void encodingWindow::shutdownChanged(int state)
-{
-#ifndef __WIN32
-	if (getuid() != 0)
-	{
-		ui.checkBoxShutdown->disconnect(SIGNAL(stateChanged(int)));
-		ui.checkBoxShutdown->setCheckState(Qt::Unchecked);
-		connect(ui.checkBoxShutdown, SIGNAL(stateChanged(int)), this, SLOT(shutdownChanged(int)));
-
-		GUI_Error_HIG(QT_TR_NOOP("Privileges Required"), QT_TR_NOOP( "Root privileges are required to perform this operation."));
-	}
-#endif
-}
-
-//*******************************************
-#define WIDGET(x) (window->ui.x)
-#define WRITEM(x,y) window->ui.x->setText(y)
-#define WRITE(x) WRITEM(x,string)
-/*************************************/
-static char string[80];
-static encodingWindow *window=NULL;
-DIA_encoding::DIA_encoding( uint32_t fps1000 )
-{
-uint32_t useTray=0;
-
-
-        ADM_assert(window==NULL);
-        stopReq=0;
-        _lastnb=0;
-        _totalSize=0;
-        _audioSize=0;
-        _videoSize=0;
-        _current=0;
-        window=new encodingWindow();
-        setFps(fps1000);
-		_originalPriority=getpriority(PRIO_PROCESS, 0);
-        _lastTime=0;
-        _lastFrame=0;
-        _fps_average=0;
-        _total=1000;
-
-         window->setModal(TRUE);
-         window->show();
-
-}
-/**
-    \fn setFps(uint32_t fps)
-    \brief Memorize fps, it will be used later for bitrate computation
-*/
-
-void DIA_encoding::setFps(uint32_t fps)
-{
-        _roundup=(uint32_t )floor( (fps+999)/1000);
-        _fps1000=fps;
-        ADM_assert(_roundup<MAX_BR_SLOT);
-        memset(_bitrate,0,sizeof(_bitrate));
-        _bitrate_sum=0;
-        _average_bitrate=0;
-        
-}
-
-void DIA_stop( void)
-{
-        printf("Stop request\n");
-        stopReq=1;
-}
-DIA_encoding::~DIA_encoding( )
-{
-	bool shutdownRequired = (window->ui.checkBoxShutdown->checkState() == Qt::Checked);
-
-	setpriority(PRIO_PROCESS, 0, _originalPriority);
-
-	if(window) delete window;
-	window=NULL;
-
-	if (shutdownRequired && !stopReq)
-	{
-		DIA_working *work=new DIA_working(QT_TR_NOOP("Shutting down"));
-		bool performShutdown=true;
-
-		for(int i = 0; i <= 30; i++)
-		{
-			if (work->isAlive())
-			{
-				GUI_Sleep(1000);
-				work->update(i, 30);
-			}
-			else
-			{
-				performShutdown=false;
-				break;
-			}
-		}
-
-		if (performShutdown && shutdown())
-		{
-			GUI_Sleep(5000);
-		}
-
-		delete work;
-	}
-}
-/**
-    \fn setPhasis(const char *n)
-    \brief Display parameters as phasis
-*/
-
-void DIA_encoding::setPhasis(const char *n)
-{
-          ADM_assert(window);
-          WRITEM(labelPhasis,n);
-
-}
-/**
-    \fn setAudioCodec(const char *n)
-    \brief Display parameters as audio codec
-*/
-
-void DIA_encoding::setAudioCodec(const char *n)
-{
-          ADM_assert(window);
-          WRITEM(labelAudCodec,n);
-}
-/**
-    \fn setCodec(const char *n)
-    \brief Display parameters as video codec
-*/
-
-void DIA_encoding::setCodec(const char *n)
-{
-          ADM_assert(window);
-          WRITEM(labelVidCodec,n);
-}
-/**
-    \fn setBitrate(uint32_t br,uint32_t globalbr)
-    \brief Display parameters as instantaneous bitrate and average bitrate
-*/
-
-void DIA_encoding::setBitrate(uint32_t br,uint32_t globalbr)
-{
-          ADM_assert(window);
-          snprintf(string,79,"%lu kB/s",br,globalbr);
-          WRITE(labelVidBitrate);
-
-}
-/**
-    \fn reset(void)
-    \brief Reset everything, used for 2pass
-*/
-
-void DIA_encoding::reset(void)
-{
-          ADM_assert(window);
-          _totalSize=0;
-          _videoSize=0;
-          _current=0;
-}
-/**
-    \fn setContainer(const char *container)
-    \brief Display parameter as container field
-*/
-
-void DIA_encoding::setContainer(const char *container)
-{
-        ADM_assert(window);
-        WRITEM(labelContainer,container);
-}
-#define  ETA_SAMPLE_PERIOD 60000 //Use last n millis to calculate ETA
-#define  GUI_UPDATE_RATE 500  
-/**
-    \fn setFrame(uint32_t nb,uint32_t size, uint32_t quant,uint32_t total)
-    \brief Recompute and update everything concering video
-*/
-
-void DIA_encoding::setFrame(uint32_t nb,uint32_t size, uint32_t quant,uint32_t total)
-{
-          _total=total;
-          _videoSize+=size;
-          if(nb < _lastnb || _lastnb == 0) // restart ?
-           {
-                _lastnb = nb;
-                clock.reset();
-                _lastTime=clock.getElapsedMS();
-                _lastFrame=0;
-                _fps_average=0;
-                _videoSize=size;
-    
-                _nextUpdate = _lastTime + GUI_UPDATE_RATE;
-                _nextSampleStartTime=_lastTime + ETA_SAMPLE_PERIOD;
-                _nextSampleStartFrame=0;
-          } 
-          _lastnb = nb;
-          _current=nb%_roundup;
-          _bitrate[_current].size=size;
-          _bitrate[_current].quant=quant;
-}
-/**
-    \fn updateUI(void)
-    \brief Recompute and update all fields, especially ETA
-*/
-
-void DIA_encoding::updateUI(void)
-{
-uint32_t tim;
-
-	   ADM_assert(window);
-     	   //
-           //	nb/total=timestart/totaltime -> total time =timestart*total/nb
-           //
-           //
-           
-           UI_purge();
-          if(!_lastnb) return;
-          
-          tim=clock.getElapsedMS();
-          if(_lastTime > tim) return;
-          if( tim < _nextUpdate) return ; 
-          _nextUpdate = tim+GUI_UPDATE_RATE;
-  
-          snprintf(string,79,"%lu",_lastnb);
-          WIDGET(labelFrame)->setText(string);
-
-          snprintf(string,79,"%lu",_total);
-          WIDGET(labelTotalFrame)->setText(string);
-
-		  snprintf(string,79,"%lu",_total);
-          WIDGET(labelTotalFrame)->setText(string);
-
-          // Average bitrate  on the last second
-          uint32_t sum=0,aquant=0,gsum;
-          for(int i=0;i<_roundup;i++)
-          {
-            sum+=_bitrate[i].size;
-            aquant+=_bitrate[i].quant;
-          }
-          
-          aquant/=_roundup;
-
-          sum=(sum*8)/1000;
-
-          // Now compute global average bitrate
-          float whole=_videoSize,second;
-            second=_lastnb;
-            second/=_fps1000;
-            second*=1000;
-           
-          whole/=second;
-          whole/=1000;
-          whole*=8;
-      
-          gsum=(uint32_t)whole;
-
-          setBitrate(sum,gsum);
-          setQuantIn(aquant);
-
-          // compute fps
-          uint32_t deltaFrame, deltaTime;
-          deltaTime=tim-_lastTime;
-          deltaFrame=_lastnb-_lastFrame;
-
-          _fps_average    =(float)( deltaFrame*1000.0F / deltaTime ); 
-
-          snprintf(string,79,"%.2f",_fps_average);
-          WIDGET(labelFps)->setText(string);
-  
-          uint32_t   hh,mm,ss;
-  
-            double framesLeft=(_total-_lastnb);
-
-			ms2time(tim,&hh,&mm,&ss);
-			snprintf(string,79,"%02d:%02d:%02d",hh,mm,ss);
-			WIDGET(labelElapsed)->setText(string);
-
-//            WIDGET(labelETA)->setText(ms2timedisplay((uint32_t) floor(0.5 + deltaTime * framesLeft / deltaFrame)));
-  
-           // Check if we should move on to the next sample period
-          if (tim >= _nextSampleStartTime + ETA_SAMPLE_PERIOD ) {
-            _lastTime=_nextSampleStartTime;
-            _lastFrame=_nextSampleStartFrame;
-            _nextSampleStartTime=tim;
-            _nextSampleStartFrame=0;
-          } else if (tim >= _nextSampleStartTime && _nextSampleStartFrame == 0 ) {
-            // Store current point for use later as the next sample period.
-            //
-            _nextSampleStartTime=tim;
-            _nextSampleStartFrame=_lastnb;
-          }
-          // update progress bar
-            float f=_lastnb*100;
-            f=f/_total;
-            WIDGET(progressBar)->setValue((int)f);
-          
-        _totalSize=_audioSize+_videoSize;
-        setSize(_totalSize>>20);
-        setAudioSizeIn((_audioSize>>20));
-        setVideoSizeIn((_videoSize>>20));
-        UI_purge();
-
-}
-/**
-    \fn setQuantIn(int size)
-    \brief display parameter as quantizer
-*/
-
-void DIA_encoding::setQuantIn(int size)
-{
-          ADM_assert(window);
-          sprintf(string,"%lu",size);
-          WRITE(labelQz);
-
-}
-/**
-    \fn setSize(int size)
-    \brief display parameter as total size
-*/
-
-void DIA_encoding::setSize(int size)
-{
-          ADM_assert(window);
-          sprintf(string,"%lu MB",size);
-          WRITE(labelTotalSize);
-
-}
-/**
-    \fn setAudioSizeIn(int size)
-    \brief display parameter as audio size
-*/
-
-void DIA_encoding::setAudioSizeIn(int size)
-{
-          ADM_assert(window);
-          sprintf(string,"%lu MB",size);
-          WRITE(labelAudioSize);
-
-}
-/**
-    \fn setVideoSizeIn(int size)
-    \brief display parameter as video size
-*/
-
-void DIA_encoding::setVideoSizeIn(int size)
-{
-          ADM_assert(window);
-          sprintf(string,"%lu MB",size);
-          WRITE(labelVideoSize);
-
-}
-/**
-    \fn setAudioSize( uint32_t size)
-    \brief set the total audio size as per parameter
-*/
-
-void DIA_encoding::setAudioSize(uint32_t size)
-{
-      _audioSize=size;
-}
-/**
-    \fn isAlive( void )
-    \brief return 0 if the window was killed or cancel button press, 1 otherwisearchForward
-*/
-uint8_t DIA_encoding::isAlive( void )
-{
-        updateUI();
-
-        if(stopReq)
-        {
-          if(GUI_Alternate((char*)QT_TR_NOOP("The encoding is paused. Do you want to resume or abort?"),
-                              (char*)QT_TR_NOOP("Resume"),(char*)QT_TR_NOOP("Abort")))
-                 {
-                         stopReq=0;
-                 }
-        }
-
-        if(!stopReq) return 1;		
-
-        return 0;
-}
-
-//********************************************
-//EOF
+/***************************************************************************
+    copyright            : (C) 2001 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <math.h>
+#include "ADM_inttype.h"
+#include "Q_encoding.h"
+
+#include "prefs.h"
+#include "DIA_working.h"
+#include "DIA_encoding.h"
+#include "DIA_coreToolkit.h"
+#include "avidemutils.h"
+#include "ADM_vidMisc.h"
+
+extern void UI_purge(void);
+static int stopReq=0;
+
+encodingWindow::encodingWindow() : QDialog()
+ {
+	ui.setupUi(this);
+
+#ifndef __WIN32
+	//check for root privileges
+	if (getuid() == 0)
+	{
+		// set priority to normal, regardless of preferences
+		ui.comboBoxPriority->setCurrentIndex(2);
+	}
+#endif
+
+	connect(ui.checkBoxShutdown, SIGNAL(stateChanged(int)), this, SLOT(shutdownChanged(int)));
+	connect(ui.pushButton, SIGNAL(pressed()), this, SLOT(buttonPressed()));
+	connect(ui.comboBoxPriority, SIGNAL(currentIndexChanged(int)), this, SLOT(priorityChanged(int)));
+
+	// set priority
+	uint32_t priority;
+
+	prefs->get(PRIORITY_ENCODING,&priority);	
+
+#ifndef __WIN32
+	// check for root privileges
+	if (getuid() == 0)
+	{
+		ui.comboBoxPriority->setCurrentIndex(priority);
+	}
+#else
+	ui.comboBoxPriority->setCurrentIndex(priority);
+#endif
+ }
+
+void encodingWindow::buttonPressed(void)
+{
+	printf("StopReq\n");
+	stopReq=1;
+}
+
+void encodingWindow::priorityChanged(int priorityLevel)
+{
+#ifndef __WIN32
+	if (getuid() != 0)
+	{
+		ui.comboBoxPriority->disconnect(SIGNAL(currentIndexChanged(int)));
+		ui.comboBoxPriority->setCurrentIndex(2);
+		connect(ui.checkBoxShutdown, SIGNAL(currentIndexChanged(int)), this, SLOT(priorityChanged(int)));
+
+		GUI_Error_HIG(QT_TR_NOOP("Privileges Required"), QT_TR_NOOP( "Root privileges are required to perform this operation."));
+
+		return;
+	}
+#endif
+
+	setpriority(PRIO_PROCESS, 0, ADM_getNiceValue(priorityLevel));
+}
+
+void encodingWindow::shutdownChanged(int state)
+{
+#ifndef __WIN32
+	if (getuid() != 0)
+	{
+		ui.checkBoxShutdown->disconnect(SIGNAL(stateChanged(int)));
+		ui.checkBoxShutdown->setCheckState(Qt::Unchecked);
+		connect(ui.checkBoxShutdown, SIGNAL(stateChanged(int)), this, SLOT(shutdownChanged(int)));
+
+		GUI_Error_HIG(QT_TR_NOOP("Privileges Required"), QT_TR_NOOP( "Root privileges are required to perform this operation."));
+	}
+#endif
+}
+
+//*******************************************
+#define WIDGET(x) (window->ui.x)
+#define WRITEM(x,y) window->ui.x->setText(y)
+#define WRITE(x) WRITEM(x,string)
+/*************************************/
+static char string[80];
+static encodingWindow *window=NULL;
+DIA_encodingQt4::DIA_encodingQt4( uint64_t duration) : DIA_encodingBase(duration)
+{
+        ADM_assert(window==NULL);
+        stopReq=0;
+        window=new encodingWindow();
+        window->setModal(TRUE);
+        window->show();
+
+}
+/**
+    \fn setFps(uint32_t fps)
+    \brief Memorize fps, it will be used later for bitrate computation
+*/
+
+void DIA_encodingQt4::setFps(uint32_t fps)
+{
+    
+        
+}
+
+void DIA_stop( void)
+{
+        printf("Stop request\n");
+        stopReq=1;
+}
+/**
+    \fn dtpor
+*/
+DIA_encodingQt4::~DIA_encodingQt4( )
+{
+	bool shutdownRequired = (window->ui.checkBoxShutdown->checkState() == Qt::Checked);
+
+	if(window) delete window;
+	window=NULL;
+#if 0
+	if (shutdownRequired && !stopReq)
+	{
+		DIA_working *work=new DIA_working(QT_TR_NOOP("Shutting down"));
+		bool performShutdown=true;
+
+		for(int i = 0; i <= 30; i++)
+		{
+			if (work->isAlive())
+			{
+				GUI_Sleep(1000);
+				work->update(i, 30);
+			}
+			else
+			{
+				performShutdown=false;
+				break;
+			}
+		}
+
+		if (performShutdown && shutdown())
+		{
+			GUI_Sleep(5000);
+		}
+
+		delete work;
+	}
+#endif
+}
+/**
+    \fn setPhasis(const char *n)
+    \brief Display parameters as phasis
+*/
+
+void DIA_encodingQt4::setPhasis(const char *n)
+{
+          ADM_assert(window);
+          WRITEM(labelPhasis,n);
+
+}
+/**
+    \fn    setPercent
+    \brief display percent of saved file
+*/
+
+void DIA_encodingQt4::setPercent(uint32_t p)
+{
+          ADM_assert(window);
+}
+/**
+    \fn setAudioCodec(const char *n)
+    \brief Display parameters as audio codec
+*/
+
+void DIA_encodingQt4::setAudioCodec(const char *n)
+{
+          ADM_assert(window);
+          WRITEM(labelAudCodec,n);
+}
+/**
+    \fn setCodec(const char *n)
+    \brief Display parameters as video codec
+*/
+
+void DIA_encodingQt4::setVideoCodec(const char *n)
+{
+          ADM_assert(window);
+          WRITEM(labelVidCodec,n);
+}
+/**
+    \fn setBitrate(uint32_t br,uint32_t globalbr)
+    \brief Display parameters as instantaneous bitrate and average bitrate
+*/
+
+void DIA_encodingQt4::setBitrate(uint32_t br,uint32_t globalbr)
+{
+          ADM_assert(window);
+          snprintf(string,79,"%lu kB/s",br,globalbr);
+          WRITE(labelVidBitrate);
+
+}
+/**
+    \fn setContainer(const char *container)
+    \brief Display parameter as container field
+*/
+
+void DIA_encodingQt4::setContainer(const char *container)
+{
+        ADM_assert(window);
+        WRITEM(labelContainer,container);
+}
+
+/**
+    \fn setQuantIn(int size)
+    \brief display parameter as quantizer
+*/
+
+void DIA_encodingQt4::setQuantIn(int size)
+{
+          ADM_assert(window);
+          sprintf(string,"%lu",size);
+          WRITE(labelQz);
+
+}
+/**
+    \fn setSize(int size)
+    \brief display parameter as total size
+*/
+
+void DIA_encodingQt4::setTotalSize(uint64_t size)
+{
+          ADM_assert(window);
+          uint64_t mb=size>>20;
+          sprintf(string,"%lu MB",(int)mb);
+          WRITE(labelTotalSize);
+
+}
+
+/**
+    \fn setAudioSizeIn(int size)
+    \brief display parameter as audio size
+*/
+
+void DIA_encodingQt4::setAudioSize(uint64_t size)
+{
+          ADM_assert(window);
+          uint64_t mb=size>>20;
+          sprintf(string,"%lu MB",(int)mb);
+          WRITE(labelAudioSize);
+
+}
+/**
+    \fn isAlive( void )
+    \brief return 0 if the window was killed or cancel button press, 1 otherwisearchForward
+*/
+bool DIA_encodingQt4::isAlive( void )
+{
+
+        if(stopReq)
+        {
+          if(GUI_Alternate((char*)QT_TR_NOOP("The encoding is paused. Do you want to resume or abort?"),
+                              (char*)QT_TR_NOOP("Resume"),(char*)QT_TR_NOOP("Abort")))
+                 {
+                         stopReq=0;
+                 }
+        }
+
+        if(!stopReq) return true;		
+
+        return false;
+}
+/**
+        \fn createEncoding
+*/
+namespace ADM_Qt4CoreUIToolkit
+{
+DIA_encodingBase *createEncoding(uint64_t duration)
+{
+        return new DIA_encodingQt4(duration);
+}
+}
+//********************************************
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h	2010-03-01 06:22:02 UTC (rev 5956)
@@ -1,19 +1,65 @@
-#ifndef Q_encoding_h
-#define Q_encoding_h
-
-#include "ui_encoding.h"
-
-class encodingWindow : public QDialog
-{
-     Q_OBJECT
-
- public:
-     encodingWindow();
-     Ui_encodingDialog ui;
-
- public slots:
-	void buttonPressed(void);
-	void priorityChanged(int priorityLevel);
-	void shutdownChanged(int state);
-};
-#endif	// Q_encoding_h
+/** *************************************************************************
+             
+    \fn Q_encoding.h
+    
+                      
+    copyright            : (C) 2008 by mean/gruntster/?
+    
+ ***************************************************************************/
+
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef Q_encoding_h
+#define Q_encoding_h
+
+#include "ui_encoding.h"
+#include "ADM_inttype.h"
+#include "DIA_encoding.h"
+/**
+    \class encodingWindow
+*/
+class encodingWindow : public QDialog
+{
+     Q_OBJECT
+
+ public:
+     encodingWindow();
+     Ui_encodingDialog ui;
+
+ public slots:
+	void buttonPressed(void);
+	void priorityChanged(int priorityLevel);
+	void shutdownChanged(int state);
+};
+/**
+    \class DIA_encodingQt4
+*/
+
+class DIA_encodingQt4 : public DIA_encodingBase
+{
+public:
+    DIA_encodingQt4( uint64_t duration);
+    ~DIA_encodingQt4( );
+    
+protected:
+    encodingWindow *window;
+    void setFps(uint32_t fps);
+    void setPhasis(const char *n);
+    void setAudioCodec(const char *n);
+    void setVideoCodec(const char *n);
+    void setBitrate(uint32_t br,uint32_t globalbr);
+    void setContainer(const char *container);
+    void setQuantIn(int size);
+    void setTotalSize(uint64_t size);
+    void setAudioSize(uint64_t size);
+    void setPercent(uint32_t percent);
+    bool isAlive( void );
+};
+#endif	// Q_encoding_h

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp	2010-03-01 06:22:02 UTC (rev 5956)
@@ -227,6 +227,7 @@
 }
 //****************************************************************************************************
 extern DIA_workingBase *createWorking(const char *title);
+extern DIA_encodingBase *createEncoding(uint64_t duration);
 }
 
 static CoreToolkitDescriptor Qt4CoreToolkitDescriptor=
@@ -240,8 +241,8 @@
 		&ADM_Qt4CoreUIToolkit::GUI_Verbose,
 		&ADM_Qt4CoreUIToolkit::GUI_Quiet,
 		&ADM_Qt4CoreUIToolkit::GUI_isQuiet,
-        &ADM_Qt4CoreUIToolkit::createWorking,
-        //&ADM_Qt4CoreUIToolkit::createEncodingQt4
+                &ADM_Qt4CoreUIToolkit::createWorking,
+                &ADM_Qt4CoreUIToolkit::createEncoding
 };
 
 void InitCoreToolkit(void )

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2010-03-01 06:22:02 UTC (rev 5956)
@@ -1,570 +1,570 @@
-/***************************************************************************
-    copyright            : (C) 2001 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#include "ADM_inttype.h"
-#include <QtCore/QFileInfo>
-#include <QtCore/QUrl>
-#include <QtGui/QKeyEvent>
-#include <QtGui/QGraphicsView>
-
-#include "Q_gui2.h"
-#include "ADM_default.h"
-
-//#include "ADM_codecs/ADM_codec.h"
-#include "gui_action.hxx"
-#include "ADM_editor/ADM_outputfmt.h"
-#include "DIA_fileSel.h"
-#include "ADM_vidMisc.h"
-#include "prefs.h"
-#include "avi_vars.h"
-
+/***************************************************************************
+    copyright            : (C) 2001 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#include "ADM_inttype.h"
+#include <QtCore/QFileInfo>
+#include <QtCore/QUrl>
+#include <QtGui/QKeyEvent>
+#include <QtGui/QGraphicsView>
+
+#include "Q_gui2.h"
+#include "ADM_default.h"
+
+//#include "ADM_codecs/ADM_codec.h"
+#include "gui_action.hxx"
+#include "ADM_editor/ADM_outputfmt.h"
+#include "DIA_fileSel.h"
+#include "ADM_vidMisc.h"
+#include "prefs.h"
+#include "avi_vars.h"
+
 #include "ADM_render/GUI_renderInternal.h"
 #include "ADM_coreVideoEncoderInternal.h"
 #include "ADM_muxerProto.h"
-#include "T_vumeter.h"
-extern int global_argc;
-extern char **global_argv;
-
-extern uint8_t UI_getPhysicalScreenSize(void* window, uint32_t *w,uint32_t *h);
-extern int automation(void );
-extern void HandleAction(Action a);
-extern int encoderGetEncoderCount (void);
-extern const char *encoderGetIndexedName (uint32_t i);
+#include "T_vumeter.h"
+extern int global_argc;
+extern char **global_argv;
+
+extern uint8_t UI_getPhysicalScreenSize(void* window, uint32_t *w,uint32_t *h);
+extern int automation(void );
+extern void HandleAction(Action a);
+extern int encoderGetEncoderCount (void);
+extern const char *encoderGetIndexedName (uint32_t i);
 uint32_t audioEncoderGetNumberOfEncoders(void);
 const char  *audioEncoderGetDisplayName(uint32_t i);
-extern void checkCrashFile(void);
-extern void UI_QT4VideoWidget(QFrame *frame);
-extern void loadTranslator(void);
-extern void initTranslator(void);
-extern void destroyTranslator(void);
-extern ADM_RENDER_TYPE UI_getPreferredRender(void);
-extern int A_openAvi(const char *name);
-extern int A_appendAvi(const char *name);
-extern char *actual_workbench_file;
-extern void FileSel_ReadWrite(SELFILE_CB *cb, int rw, const char *name, const char *actual_workbench_file);
+extern void checkCrashFile(void);
+extern void UI_QT4VideoWidget(QFrame *frame);
+extern void loadTranslator(void);
+extern void initTranslator(void);
+extern void destroyTranslator(void);
+extern ADM_RENDER_TYPE UI_getPreferredRender(void);
+extern int A_openAvi(const char *name);
+extern int A_appendAvi(const char *name);
+extern char *actual_workbench_file;
+extern void FileSel_ReadWrite(SELFILE_CB *cb, int rw, const char *name, const char *actual_workbench_file);
 
-
-int SliderIsShifted=0;
-static void setupMenus(void);
-static int shiftKeyHeld=0;
-static ADM_QSlider *slider=NULL;
-static int _upd_in_progres=0;
-static char     *customNames[ADM_MAC_CUSTOM_SCRIPT];
-static QAction  *customActions[ADM_MAC_CUSTOM_SCRIPT];
-static uint32_t ADM_nbCustom=0;
-static int currentFps = 0;
-static int frameCount = 0;
-static int currentFrame = 0;
+
+int SliderIsShifted=0;
+static void setupMenus(void);
+static int shiftKeyHeld=0;
+static ADM_QSlider *slider=NULL;
+static int _upd_in_progres=0;
+static char     *customNames[ADM_MAC_CUSTOM_SCRIPT];
+static QAction  *customActions[ADM_MAC_CUSTOM_SCRIPT];
+static uint32_t ADM_nbCustom=0;
+static int currentFps = 0;
+static int frameCount = 0;
+static int currentFrame = 0;
 bool     ADM_ve6_getEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
 uint32_t ADM_ve6_getNbEncoders(void);
 void UI_refreshCustomMenu(void);
 QWidget *QuiMainWindows=NULL;
 QGraphicsView *drawWindow=NULL;
 uint8_t UI_updateRecentMenu( void );
-
-#ifdef HAVE_AUDIO
-extern uint8_t AVDM_setVolume(int volume);
-#endif
-
-#define WIDGET(x)  (((MainWindow *)QuiMainWindows)->ui.x)
-
-#define CONNECT(object,zzz) connect( (ui.object),SIGNAL(triggered()),this,SLOT(buttonPressed()));
-#define CONNECT_TB(object,zzz) connect( (ui.object),SIGNAL(clicked(bool)),this,SLOT(toolButtonPressed(bool)));
-#define DECLARE_VAR(object,signal_name) {#object,signal_name},
-
-#include "translation_table.h"    
-/*
-    Declare the table converting widget name to our internal signal           
-*/
-typedef struct 
-{
-	const char *name;
-	Action     action; 
+
+#ifdef HAVE_AUDIO
+extern uint8_t AVDM_setVolume(int volume);
+#endif
+
+#define WIDGET(x)  (((MainWindow *)QuiMainWindows)->ui.x)
+
+#define CONNECT(object,zzz) connect( (ui.object),SIGNAL(triggered()),this,SLOT(buttonPressed()));
+#define CONNECT_TB(object,zzz) connect( (ui.object),SIGNAL(clicked(bool)),this,SLOT(toolButtonPressed(bool)));
+#define DECLARE_VAR(object,signal_name) {#object,signal_name},
+
+#include "translation_table.h"    
+/*
+    Declare the table converting widget name to our internal signal           
+*/
+typedef struct 
+{
+	const char *name;
+	Action     action; 
 }adm_qt4_translation;
-
-const adm_qt4_translation myTranslationTable[]=
-{
-#define PROCESS DECLARE_VAR
-	LIST_OF_OBJECTS
-	LIST_OF_BUTTONS
-#undef PROCESS
-};
-static Action searchTranslationTable(const char *name);
-#define SIZEOF_MY_TRANSLATION sizeof(myTranslationTable)/sizeof(adm_qt4_translation)
-
-int UI_readCurTime(uint16_t &hh, uint16_t &mm, uint16_t &ss, uint16_t &ms);
-void UI_updateFrameCount(uint32_t curFrame);
-void UI_updateTimeCount(uint32_t curFrame,uint32_t fps);
-extern void UI_purge(void);
-/*
-    Declare the class that will be our main window
-
-*/
-
-void MainWindow::comboChanged(int z)
-{
-	const char *source=qPrintable(sender()->objectName());
-
-	if(!strcmp(source,"comboBoxVideo"))  
-	{
-		bool b=FALSE;
-		if(ui.comboBoxVideo->currentIndex())
-		{
-			b=TRUE;
-		}
-		ui.pushButtonVideoConf->setEnabled(b);
-		ui.pushButtonVideoFilter->setEnabled(b);
-		HandleAction (ACT_VideoCodecChanged) ;
-	}
-	else if(!strcmp(source,"comboBoxAudio"))  
-	{
-		bool b=FALSE;
-		if(ui.comboBoxAudio->currentIndex())
-		{
-			b=TRUE;
-		}
-		ui.pushButtonAudioConf->setEnabled(b);
-		ui.pushButtonAudioFilter->setEnabled(b);
-		HandleAction (ACT_AudioCodecChanged) ;
-	}
-	else
-		printf("From +: %s\n",source);
-}
-
-void MainWindow::sliderValueChanged(int u) 
-{
-	if(!_upd_in_progres)
-		HandleAction(ACT_Scale);
-}
-
-void MainWindow::sliderMoved(int value)
-{
-	SliderIsShifted = shiftKeyHeld;
-}
-
-void MainWindow::sliderReleased(void)
-{
-	SliderIsShifted = 0;
-}
-
-void MainWindow::volumeChange( int u )
-{
-#ifdef HAVE_AUDIO
-	if (_upd_in_progres || !ui.toolButtonAudioToggle->isChecked())
-		return;
-
-	_upd_in_progres++;
-
-	int vol = ui.horizontalSlider_2->value();
-
-	AVDM_setVolume(vol);
-	_upd_in_progres--;
-#endif
-}
-
-void MainWindow::audioToggled(bool checked)
-{
-#ifdef HAVE_AUDIO
-	if (checked)
-		AVDM_setVolume(ui.horizontalSlider_2->value());
-	else
-		AVDM_setVolume(0);
-#endif
-}
-
-void MainWindow::previewModeChanged(QAction *action)
-{
-	HandleAction(ACT_PreviewChanged);
-}
-
-void MainWindow::timeChangeFinished(void)
-{
-	this->setFocus(Qt::OtherFocusReason);
-}
-
-void MainWindow::currentFrameChanged(void)
-{
-	HandleAction(ACT_JumpToFrame);
-
-	this->setFocus(Qt::OtherFocusReason);
-}
-
-void MainWindow::currentTimeChanged(void)
-{
-	HandleAction(ACT_JumpToTime);
-
-	this->setFocus(Qt::OtherFocusReason);
-}
-
-
-MainWindow::MainWindow() : QMainWindow()
-{
-	ui.setupUi(this);
-
-	this->setStatusBar(0);
-	this->adjustSize();
-
-#if defined(__APPLE__) && defined(USE_SDL)
-	ui.actionAbout_avidemux->setMenuRole(QAction::NoRole);
-	ui.actionPreferences->setMenuRole(QAction::NoRole);
-	ui.actionQuit->setMenuRole(QAction::NoRole);
-#endif
-
-	// Preview modes
-	QActionGroup *groupPreviewModes = new QActionGroup(this);
-
-	groupPreviewModes->addAction(ui.actionPreviewInput);
-	groupPreviewModes->addAction(ui.actionPreviewOutput);
-	groupPreviewModes->addAction(ui.actionPreviewSide);
-	groupPreviewModes->addAction(ui.actionPreviewTop);
-	groupPreviewModes->addAction(ui.actionPreviewSeparate);
-	connect(groupPreviewModes, SIGNAL(triggered(QAction*)), this, SLOT(previewModeChanged(QAction*)));
-
-	// Zoom modes
-	QActionGroup *groupZoomModes = new QActionGroup(this);
-
-	groupZoomModes->addAction(ui.actionZoom_1_4);
-	groupZoomModes->addAction(ui.actionZoom_1_2);
-	groupZoomModes->addAction(ui.actionZoom_1_1);
-	groupZoomModes->addAction(ui.actionZoom_2_1);
-
-	/*
-	Connect our button to buttonPressed
-	*/
-#define PROCESS CONNECT
-	LIST_OF_OBJECTS
-#undef PROCESS
-#define PROCESS CONNECT_TB
-	LIST_OF_BUTTONS
-#undef PROCESS
-
-	connect(ui.actionPrevious_intra_frame, SIGNAL(triggered()), this, SLOT(previousIntraFrame()));
-	connect(ui.actionNext_intra_frame, SIGNAL(triggered()), this, SLOT(nextIntraFrame()));
-
-	//ACT_VideoCodecChanged
-	connect( ui.comboBoxVideo,SIGNAL(activated(int)),this,SLOT(comboChanged(int)));
-	connect( ui.comboBoxAudio,SIGNAL(activated(int)),this,SLOT(comboChanged(int)));
-
-	// Slider
-	slider=ui.horizontalSlider;
-	slider->setMinimum(0);
-	slider->setMaximum(1000000000);
-	connect( slider,SIGNAL(valueChanged(int)),this,SLOT(sliderValueChanged(int)));
-	connect( slider,SIGNAL(sliderMoved(int)),this,SLOT(sliderMoved(int)));
-	connect( slider,SIGNAL(sliderReleased()),this,SLOT(sliderReleased()));
-
-	// Volume slider
-	QSlider *volSlider=ui.horizontalSlider_2;
-	volSlider->setMinimum(0);
-	volSlider->setMaximum(100);
-	connect(volSlider,SIGNAL(valueChanged(int)),this,SLOT(volumeChange(int)));
-	connect(ui.toolButtonAudioToggle,SIGNAL(clicked(bool)),this,SLOT(audioToggled(bool)));
-
-	// default state
-	bool b=0;
-	ui.pushButtonVideoConf->setEnabled(b);
-	ui.pushButtonVideoFilter->setEnabled(b);
-	ui.pushButtonAudioConf->setEnabled(b);
-	ui.pushButtonAudioFilter->setEnabled(b);
-
-	/* Time Shift */
-	connect(ui.checkBox_TimeShift,SIGNAL(stateChanged(int)),this,SLOT(timeChanged(int)));
-	connect(ui.spinBox_TimeValue,SIGNAL(valueChanged(int)),this,SLOT(timeChanged(int)));
-	connect(ui.spinBox_TimeValue, SIGNAL(editingFinished()), this, SLOT(timeChangeFinished()));
-
-
-
-
-	QRegExp timeRegExp("^[0-9]{2}:[0-5][0-9]:[0-5][0-9]\\.[0-9]{3}$");
-	QRegExpValidator *timeValidator = new QRegExpValidator(timeRegExp, this);
-	ui.currentTime->setValidator(timeValidator);
-	ui.currentTime->setInputMask("99:99:99.999");
-
-	connect(ui.currentTime, SIGNAL(editingFinished()), this, SLOT(currentTimeChanged()));
-
-	/* Build the custom menu */
-	buildCustomMenu();
-
-	this->installEventFilter(this);
-	slider->installEventFilter(this);
-	
-	ui.currentTime->installEventFilter(this);
-
-	this->setFocus(Qt::OtherFocusReason);
-
-	setAcceptDrops(true);
-}
-/**
-\fn     custom
-\brief  Invoked when one of the custom script has been called
-*/
-void MainWindow::custom(void)
-{
-	printf("[Custom] Invoked\n");
-	QObject *ptr=sender();
-	if(!ptr) return;
-	for(int i=0;i<ADM_nbCustom;i++)
-	{
-		if(customActions[i]==ptr)
-		{
-			printf("[Custom] %u/%u scripts\n",i,ADM_nbCustom);
-			HandleAction( (Action)(ACT_CUSTOM_BASE+i));
-			return; 
-		}
-	}
-	printf("[Custom] Not found\n");
-}
-/**
-    Get the custom entry 
-
-*/
-const char * GUI_getCustomScript(uint32_t nb)
-{
-	ADM_assert(nb<ADM_nbCustom);
-	return customNames[nb];
-
-}
-/**
-    \fn timeChanged
-    \brief Called whenever timeshift is on/off'ed or value changes
-*/
-void MainWindow::timeChanged(int)
-{
-	HandleAction (ACT_TimeShift) ;
-}
-/*
-      We receive a button press event
-*/
-void MainWindow::buttonPressed(void)
-{
-	// Receveid a key press Event, look into table..
-	const char *source=qPrintable(sender()->objectName());
-
-	Action action=searchTranslationTable(source);
-
-	if(action!=ACT_DUMMY)
-		HandleAction (action);
-
-}
-void MainWindow::toolButtonPressed(bool i)
-{
-	buttonPressed();
-}
-
-bool MainWindow::eventFilter(QObject* watched, QEvent* event)
-{
-	QKeyEvent *keyEvent;
-
-	switch (event->type())
-	{
-		case QEvent::KeyPress:
-			keyEvent = (QKeyEvent*)event;
-
-			if (watched == slider)
-			{
-				switch (keyEvent->key())
-				{
-					case Qt::Key_Left:
-						if (keyEvent->modifiers() == Qt::ShiftModifier)
-							HandleAction(ACT_Back25Frames);
-						else if (keyEvent->modifiers() == Qt::ControlModifier)
-							HandleAction(ACT_Back50Frames);
-						else
-							HandleAction(ACT_PreviousFrame);
-
-						return true;
-					case Qt::Key_Right:
-						if (keyEvent->modifiers() == Qt::ShiftModifier)
-							HandleAction(ACT_Forward25Frames);
-						else if (keyEvent->modifiers() == Qt::ControlModifier)
-							HandleAction(ACT_Forward50Frames);
-						else
-							HandleAction(ACT_NextFrame);
-
-						return true;
-					case Qt::Key_Up:
-						HandleAction(ACT_NextKFrame);
-						return true;
-					case Qt::Key_Down:
-						HandleAction(ACT_PreviousKFrame);
-						return true;
-					case Qt::Key_Shift:
-						shiftKeyHeld = 1;
-						break;
-				}
-			}
-			else if (keyEvent->key() == Qt::Key_Space)
-			{
-				HandleAction(ACT_PlayAvi);
-				return true;
-			}
-
-			break;
-		case QEvent::KeyRelease:
-			keyEvent = (QKeyEvent*)event;
-
-			if (keyEvent->key() == Qt::Key_Shift)
-				shiftKeyHeld = 0;
-
-			break;
-		case QEvent::FocusOut:
-			if (watched == ui.currentTime)
-			{
-				uint16_t hh, mm, ss, ms;
-
-				if (!UI_readCurTime(hh, mm, ss, ms))
-					UI_updateTimeCount(currentFrame, currentFps);
-			}
-	}
-
-	return QObject::eventFilter(watched, event);
-}
-
-void MainWindow::mousePressEvent(QMouseEvent* event)
-{
-	this->setFocus(Qt::OtherFocusReason);
-}
-
-void MainWindow::dragEnterEvent(QDragEnterEvent *event)
-{
-	if (event->mimeData()->hasFormat("text/uri-list"))
-		event->acceptProposedAction();
-}
-
-void MainWindow::dropEvent(QDropEvent *event)
-{
-	QList<QUrl> urlList;
-	QString fileName;
-	QFileInfo info;
-
-	if (event->mimeData()->hasUrls())
-	{
-		urlList = event->mimeData()->urls();
-
-		for (int fileIndex = 0; fileIndex < urlList.size(); fileIndex++)
-		{
-			fileName = urlList[fileIndex].toLocalFile();
-			info.setFile(fileName);
-
-			if (info.isFile())
-			{
-				if (avifileinfo)
-					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_appendAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
-				else
-					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_openAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
-			}
-		}
-	}
-
-	event->acceptProposedAction();
-}
-
-void MainWindow::previousIntraFrame(void)
-{
-	if (ui.spinBox_TimeValue->hasFocus())
-		ui.spinBox_TimeValue->stepDown();
-	else
-		HandleAction(ACT_PreviousKFrame);
-}
-
-void MainWindow::nextIntraFrame(void)
-{
-	if (ui.spinBox_TimeValue->hasFocus())
-		ui.spinBox_TimeValue->stepUp();
-	else
-		HandleAction(ACT_NextKFrame);
-}
-
-void MainWindow::clearCustomMenu(void)
-{
-	if (ADM_nbCustom)
-	{
-		for(int i = 0; i < ADM_nbCustom; i++)
-		{
-			disconnect(customActions[i], SIGNAL(triggered()), this, SLOT(custom()));
-			delete customActions[i];
-			delete customNames[i];
-		}
-
-		ui.menuCustom->clear();
-		ADM_nbCustom = 0;
-	}
-}
-
-void MainWindow::buildCustomMenu(void)
-{
-	clearCustomMenu();
-
-	char *customdir = ADM_getCustomDir();
-
-	if (!customdir)
-	{
-		printf("No custom dir...\n");
-		return;
-	}
-
-	/* Collect the name */
-	if (! buildDirectoryContent(&ADM_nbCustom, customdir, customNames, ADM_MAC_CUSTOM_SCRIPT,".js"))
-	{
-		printf("Failed to build custom dir content");
-		return;
-	}
-
-	if(ADM_nbCustom)
-	{
-		printf("Found %u custom script(s), adding them\n", ADM_nbCustom);
-
-		for(int i=0; i < ADM_nbCustom; i++)
-		{
-			customActions[i] = new QAction(QString::fromUtf8(ADM_GetFileName(customNames[i])), NULL);
-			ui.menuCustom->addAction(customActions[i]);
-			connect(customActions[i], SIGNAL(triggered()), this, SLOT(custom()));
-		}
-	}
-	else
-		printf("No custom scripts\n");
-
-	printf("Custom menu built\n");
-}
-
-MainWindow::~MainWindow()
-{
-	clearCustomMenu();
-}
-static const UI_FUNCTIONS_T UI_Hooks=
-    {
-        ADM_RENDER_API_VERSION_NUMBER,
-        UI_purge,
-        UI_getWindowInfo,
-        UI_updateDrawWindowSize,
-        UI_rgbDraw,
-        UI_getDrawWidget,
-        UI_getPreferredRender
-        
+
+const adm_qt4_translation myTranslationTable[]=
+{
+#define PROCESS DECLARE_VAR
+	LIST_OF_OBJECTS
+	LIST_OF_BUTTONS
+#undef PROCESS
+};
+static Action searchTranslationTable(const char *name);
+#define SIZEOF_MY_TRANSLATION sizeof(myTranslationTable)/sizeof(adm_qt4_translation)
+
+int UI_readCurTime(uint16_t &hh, uint16_t &mm, uint16_t &ss, uint16_t &ms);
+void UI_updateFrameCount(uint32_t curFrame);
+void UI_updateTimeCount(uint32_t curFrame,uint32_t fps);
+extern void UI_purge(void);
+/*
+    Declare the class that will be our main window
+
+*/
+
+void MainWindow::comboChanged(int z)
+{
+	const char *source=qPrintable(sender()->objectName());
+
+	if(!strcmp(source,"comboBoxVideo"))  
+	{
+		bool b=FALSE;
+		if(ui.comboBoxVideo->currentIndex())
+		{
+			b=TRUE;
+		}
+		ui.pushButtonVideoConf->setEnabled(b);
+		ui.pushButtonVideoFilter->setEnabled(b);
+		HandleAction (ACT_VideoCodecChanged) ;
+	}
+	else if(!strcmp(source,"comboBoxAudio"))  
+	{
+		bool b=FALSE;
+		if(ui.comboBoxAudio->currentIndex())
+		{
+			b=TRUE;
+		}
+		ui.pushButtonAudioConf->setEnabled(b);
+		ui.pushButtonAudioFilter->setEnabled(b);
+		HandleAction (ACT_AudioCodecChanged) ;
+	}
+	else
+		printf("From +: %s\n",source);
+}
+
+void MainWindow::sliderValueChanged(int u) 
+{
+	if(!_upd_in_progres)
+		HandleAction(ACT_Scale);
+}
+
+void MainWindow::sliderMoved(int value)
+{
+	SliderIsShifted = shiftKeyHeld;
+}
+
+void MainWindow::sliderReleased(void)
+{
+	SliderIsShifted = 0;
+}
+
+void MainWindow::volumeChange( int u )
+{
+#ifdef HAVE_AUDIO
+	if (_upd_in_progres || !ui.toolButtonAudioToggle->isChecked())
+		return;
+
+	_upd_in_progres++;
+
+	int vol = ui.horizontalSlider_2->value();
+
+	AVDM_setVolume(vol);
+	_upd_in_progres--;
+#endif
+}
+
+void MainWindow::audioToggled(bool checked)
+{
+#ifdef HAVE_AUDIO
+	if (checked)
+		AVDM_setVolume(ui.horizontalSlider_2->value());
+	else
+		AVDM_setVolume(0);
+#endif
+}
+
+void MainWindow::previewModeChanged(QAction *action)
+{
+	HandleAction(ACT_PreviewChanged);
+}
+
+void MainWindow::timeChangeFinished(void)
+{
+	this->setFocus(Qt::OtherFocusReason);
+}
+
+void MainWindow::currentFrameChanged(void)
+{
+	HandleAction(ACT_JumpToFrame);
+
+	this->setFocus(Qt::OtherFocusReason);
+}
+
+void MainWindow::currentTimeChanged(void)
+{
+	HandleAction(ACT_JumpToTime);
+
+	this->setFocus(Qt::OtherFocusReason);
+}
+
+
+MainWindow::MainWindow() : QMainWindow()
+{
+	ui.setupUi(this);
+
+	this->setStatusBar(0);
+	this->adjustSize();
+
+#if defined(__APPLE__) && defined(USE_SDL)
+	ui.actionAbout_avidemux->setMenuRole(QAction::NoRole);
+	ui.actionPreferences->setMenuRole(QAction::NoRole);
+	ui.actionQuit->setMenuRole(QAction::NoRole);
+#endif
+
+	// Preview modes
+	QActionGroup *groupPreviewModes = new QActionGroup(this);
+
+	groupPreviewModes->addAction(ui.actionPreviewInput);
+	groupPreviewModes->addAction(ui.actionPreviewOutput);
+	groupPreviewModes->addAction(ui.actionPreviewSide);
+	groupPreviewModes->addAction(ui.actionPreviewTop);
+	groupPreviewModes->addAction(ui.actionPreviewSeparate);
+	connect(groupPreviewModes, SIGNAL(triggered(QAction*)), this, SLOT(previewModeChanged(QAction*)));
+
+	// Zoom modes
+	QActionGroup *groupZoomModes = new QActionGroup(this);
+
+	groupZoomModes->addAction(ui.actionZoom_1_4);
+	groupZoomModes->addAction(ui.actionZoom_1_2);
+	groupZoomModes->addAction(ui.actionZoom_1_1);
+	groupZoomModes->addAction(ui.actionZoom_2_1);
+
+	/*
+	Connect our button to buttonPressed
+	*/
+#define PROCESS CONNECT
+	LIST_OF_OBJECTS
+#undef PROCESS
+#define PROCESS CONNECT_TB
+	LIST_OF_BUTTONS
+#undef PROCESS
+
+	connect(ui.actionPrevious_intra_frame, SIGNAL(triggered()), this, SLOT(previousIntraFrame()));
+	connect(ui.actionNext_intra_frame, SIGNAL(triggered()), this, SLOT(nextIntraFrame()));
+
+	//ACT_VideoCodecChanged
+	connect( ui.comboBoxVideo,SIGNAL(activated(int)),this,SLOT(comboChanged(int)));
+	connect( ui.comboBoxAudio,SIGNAL(activated(int)),this,SLOT(comboChanged(int)));
+
+	// Slider
+	slider=ui.horizontalSlider;
+	slider->setMinimum(0);
+	slider->setMaximum(1000000000);
+	connect( slider,SIGNAL(valueChanged(int)),this,SLOT(sliderValueChanged(int)));
+	connect( slider,SIGNAL(sliderMoved(int)),this,SLOT(sliderMoved(int)));
+	connect( slider,SIGNAL(sliderReleased()),this,SLOT(sliderReleased()));
+
+	// Volume slider
+	QSlider *volSlider=ui.horizontalSlider_2;
+	volSlider->setMinimum(0);
+	volSlider->setMaximum(100);
+	connect(volSlider,SIGNAL(valueChanged(int)),this,SLOT(volumeChange(int)));
+	connect(ui.toolButtonAudioToggle,SIGNAL(clicked(bool)),this,SLOT(audioToggled(bool)));
+
+	// default state
+	bool b=0;
+	ui.pushButtonVideoConf->setEnabled(b);
+	ui.pushButtonVideoFilter->setEnabled(b);
+	ui.pushButtonAudioConf->setEnabled(b);
+	ui.pushButtonAudioFilter->setEnabled(b);
+
+	/* Time Shift */
+	connect(ui.checkBox_TimeShift,SIGNAL(stateChanged(int)),this,SLOT(timeChanged(int)));
+	connect(ui.spinBox_TimeValue,SIGNAL(valueChanged(int)),this,SLOT(timeChanged(int)));
+	connect(ui.spinBox_TimeValue, SIGNAL(editingFinished()), this, SLOT(timeChangeFinished()));
+
+
+
+
+	QRegExp timeRegExp("^[0-9]{2}:[0-5][0-9]:[0-5][0-9]\\.[0-9]{3}$");
+	QRegExpValidator *timeValidator = new QRegExpValidator(timeRegExp, this);
+	ui.currentTime->setValidator(timeValidator);
+	ui.currentTime->setInputMask("99:99:99.999");
+
+	connect(ui.currentTime, SIGNAL(editingFinished()), this, SLOT(currentTimeChanged()));
+
+	/* Build the custom menu */
+	buildCustomMenu();
+
+	this->installEventFilter(this);
+	slider->installEventFilter(this);
+	
+	ui.currentTime->installEventFilter(this);
+
+	this->setFocus(Qt::OtherFocusReason);
+
+	setAcceptDrops(true);
+}
+/**
+\fn     custom
+\brief  Invoked when one of the custom script has been called
+*/
+void MainWindow::custom(void)
+{
+	printf("[Custom] Invoked\n");
+	QObject *ptr=sender();
+	if(!ptr) return;
+	for(int i=0;i<ADM_nbCustom;i++)
+	{
+		if(customActions[i]==ptr)
+		{
+			printf("[Custom] %u/%u scripts\n",i,ADM_nbCustom);
+			HandleAction( (Action)(ACT_CUSTOM_BASE+i));
+			return; 
+		}
+	}
+	printf("[Custom] Not found\n");
+}
+/**
+    Get the custom entry 
+
+*/
+const char * GUI_getCustomScript(uint32_t nb)
+{
+	ADM_assert(nb<ADM_nbCustom);
+	return customNames[nb];
+
+}
+/**
+    \fn timeChanged
+    \brief Called whenever timeshift is on/off'ed or value changes
+*/
+void MainWindow::timeChanged(int)
+{
+	HandleAction (ACT_TimeShift) ;
+}
+/*
+      We receive a button press event
+*/
+void MainWindow::buttonPressed(void)
+{
+	// Receveid a key press Event, look into table..
+	const char *source=qPrintable(sender()->objectName());
+
+	Action action=searchTranslationTable(source);
+
+	if(action!=ACT_DUMMY)
+		HandleAction (action);
+
+}
+void MainWindow::toolButtonPressed(bool i)
+{
+	buttonPressed();
+}
+
+bool MainWindow::eventFilter(QObject* watched, QEvent* event)
+{
+	QKeyEvent *keyEvent;
+
+	switch (event->type())
+	{
+		case QEvent::KeyPress:
+			keyEvent = (QKeyEvent*)event;
+
+			if (watched == slider)
+			{
+				switch (keyEvent->key())
+				{
+					case Qt::Key_Left:
+						if (keyEvent->modifiers() == Qt::ShiftModifier)
+							HandleAction(ACT_Back25Frames);
+						else if (keyEvent->modifiers() == Qt::ControlModifier)
+							HandleAction(ACT_Back50Frames);
+						else
+							HandleAction(ACT_PreviousFrame);
+
+						return true;
+					case Qt::Key_Right:
+						if (keyEvent->modifiers() == Qt::ShiftModifier)
+							HandleAction(ACT_Forward25Frames);
+						else if (keyEvent->modifiers() == Qt::ControlModifier)
+							HandleAction(ACT_Forward50Frames);
+						else
+							HandleAction(ACT_NextFrame);
+
+						return true;
+					case Qt::Key_Up:
+						HandleAction(ACT_NextKFrame);
+						return true;
+					case Qt::Key_Down:
+						HandleAction(ACT_PreviousKFrame);
+						return true;
+					case Qt::Key_Shift:
+						shiftKeyHeld = 1;
+						break;
+				}
+			}
+			else if (keyEvent->key() == Qt::Key_Space)
+			{
+				HandleAction(ACT_PlayAvi);
+				return true;
+			}
+
+			break;
+		case QEvent::KeyRelease:
+			keyEvent = (QKeyEvent*)event;
+
+			if (keyEvent->key() == Qt::Key_Shift)
+				shiftKeyHeld = 0;
+
+			break;
+		case QEvent::FocusOut:
+			if (watched == ui.currentTime)
+			{
+				uint16_t hh, mm, ss, ms;
+
+				if (!UI_readCurTime(hh, mm, ss, ms))
+					UI_updateTimeCount(currentFrame, currentFps);
+			}
+	}
+
+	return QObject::eventFilter(watched, event);
+}
+
+void MainWindow::mousePressEvent(QMouseEvent* event)
+{
+	this->setFocus(Qt::OtherFocusReason);
+}
+
+void MainWindow::dragEnterEvent(QDragEnterEvent *event)
+{
+	if (event->mimeData()->hasFormat("text/uri-list"))
+		event->acceptProposedAction();
+}
+
+void MainWindow::dropEvent(QDropEvent *event)
+{
+	QList<QUrl> urlList;
+	QString fileName;
+	QFileInfo info;
+
+	if (event->mimeData()->hasUrls())
+	{
+		urlList = event->mimeData()->urls();
+
+		for (int fileIndex = 0; fileIndex < urlList.size(); fileIndex++)
+		{
+			fileName = urlList[fileIndex].toLocalFile();
+			info.setFile(fileName);
+
+			if (info.isFile())
+			{
+				if (avifileinfo)
+					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_appendAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
+				else
+					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_openAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
+			}
+		}
+	}
+
+	event->acceptProposedAction();
+}
+
+void MainWindow::previousIntraFrame(void)
+{
+	if (ui.spinBox_TimeValue->hasFocus())
+		ui.spinBox_TimeValue->stepDown();
+	else
+		HandleAction(ACT_PreviousKFrame);
+}
+
+void MainWindow::nextIntraFrame(void)
+{
+	if (ui.spinBox_TimeValue->hasFocus())
+		ui.spinBox_TimeValue->stepUp();
+	else
+		HandleAction(ACT_NextKFrame);
+}
+
+void MainWindow::clearCustomMenu(void)
+{
+	if (ADM_nbCustom)
+	{
+		for(int i = 0; i < ADM_nbCustom; i++)
+		{
+			disconnect(customActions[i], SIGNAL(triggered()), this, SLOT(custom()));
+			delete customActions[i];
+			delete customNames[i];
+		}
+
+		ui.menuCustom->clear();
+		ADM_nbCustom = 0;
+	}
+}
+
+void MainWindow::buildCustomMenu(void)
+{
+	clearCustomMenu();
+
+	char *customdir = ADM_getCustomDir();
+
+	if (!customdir)
+	{
+		printf("No custom dir...\n");
+		return;
+	}
+
+	/* Collect the name */
+	if (! buildDirectoryContent(&ADM_nbCustom, customdir, customNames, ADM_MAC_CUSTOM_SCRIPT,".js"))
+	{
+		printf("Failed to build custom dir content");
+		return;
+	}
+
+	if(ADM_nbCustom)
+	{
+		printf("Found %u custom script(s), adding them\n", ADM_nbCustom);
+
+		for(int i=0; i < ADM_nbCustom; i++)
+		{
+			customActions[i] = new QAction(QString::fromUtf8(ADM_GetFileName(customNames[i])), NULL);
+			ui.menuCustom->addAction(customActions[i]);
+			connect(customActions[i], SIGNAL(triggered()), this, SLOT(custom()));
+		}
+	}
+	else
+		printf("No custom scripts\n");
+
+	printf("Custom menu built\n");
+}
+
+MainWindow::~MainWindow()
+{
+	clearCustomMenu();
+}
+static const UI_FUNCTIONS_T UI_Hooks=
+    {
+        ADM_RENDER_API_VERSION_NUMBER,
+        UI_purge,
+        UI_getWindowInfo,
+        UI_updateDrawWindowSize,
+        UI_rgbDraw,
+        UI_getDrawWidget,
+        UI_getPreferredRender
+        
     };
 QApplication *myApplication=NULL;
 /**
     \fn  UI_Init
     \brief First part of UI initialization
 
-*/
-int UI_Init(int nargc,char **nargv)
-{
-	initTranslator();
-
-	global_argc=nargc;
-	global_argv=nargv;
+*/
+int UI_Init(int nargc,char **nargv)
+{
+	initTranslator();
+
+	global_argc=nargc;
+	global_argv=nargv;
 	ADM_renderLibInit(&UI_Hooks);
     Q_INIT_RESOURCE(avidemux);
 	Q_INIT_RESOURCE(filter);
@@ -586,332 +586,332 @@
 
 	UI_QT4VideoWidget(mw->ui.frame_video);  // Add the widget that will handle video display
 	UI_updateRecentMenu();
-    // Init vumeter
-    UI_InitVUMeter(mw->ui.frameVU);
-	return 0;
-}
-
-void UI_refreshCustomMenu(void)
-{
-	((MainWindow*)QuiMainWindows)->buildCustomMenu();
-}
-
-/**
-    \fn UI_getCurrentPreview(void)
-    \brief Read previewmode from comboxbox 
-*/
-int UI_getCurrentPreview(void)
-{
-	int index;
-
-	if (WIDGET(actionPreviewOutput)->isChecked())
-		index = 1;
-	else if (WIDGET(actionPreviewSide)->isChecked())
-		index = 2;
-	else if (WIDGET(actionPreviewTop)->isChecked())
-		index = 3;
-	else if (WIDGET(actionPreviewSeparate)->isChecked())
-		index = 4;
-	else
-		index = 0;
-
-	return index;
-}
-
-/**
-    \fn UI_setCurrentPreview(int ne)
-    \brief Update comboxbox with previewmode
-*/
-void UI_setCurrentPreview(int ne)
-{
-	switch (ne)
-	{
-		case 1:
-			WIDGET(actionPreviewOutput)->setChecked(true);
-			break;
-		case 2:
-			WIDGET(actionPreviewSide)->setChecked(true);
-			break;
-		case 3:
-			WIDGET(actionPreviewTop)->setChecked(true);
-			break;
-		case 4:
-			WIDGET(actionPreviewSeparate)->setChecked(true);
-			break;
-		default:
-			WIDGET(actionPreviewInput)->setChecked(true);
-	}
-}
-
-/**
-    \fn UI_RunApp(void)
-    \brief Main entry point for the GUI application
-*/
-int UI_RunApp(void)
-{
-	
-	setupMenus();
-	checkCrashFile();
-
-	if (global_argc >= 2)
-		automation();
-
-	myApplication->exec();
-
+        // Init vumeter
+        UI_InitVUMeter(mw->ui.frameVU);
+	return 0;
+}
+
+void UI_refreshCustomMenu(void)
+{
+	((MainWindow*)QuiMainWindows)->buildCustomMenu();
+}
+
+/**
+    \fn UI_getCurrentPreview(void)
+    \brief Read previewmode from comboxbox 
+*/
+int UI_getCurrentPreview(void)
+{
+	int index;
+
+	if (WIDGET(actionPreviewOutput)->isChecked())
+		index = 1;
+	else if (WIDGET(actionPreviewSide)->isChecked())
+		index = 2;
+	else if (WIDGET(actionPreviewTop)->isChecked())
+		index = 3;
+	else if (WIDGET(actionPreviewSeparate)->isChecked())
+		index = 4;
+	else
+		index = 0;
+
+	return index;
+}
+
+/**
+    \fn UI_setCurrentPreview(int ne)
+    \brief Update comboxbox with previewmode
+*/
+void UI_setCurrentPreview(int ne)
+{
+	switch (ne)
+	{
+		case 1:
+			WIDGET(actionPreviewOutput)->setChecked(true);
+			break;
+		case 2:
+			WIDGET(actionPreviewSide)->setChecked(true);
+			break;
+		case 3:
+			WIDGET(actionPreviewTop)->setChecked(true);
+			break;
+		case 4:
+			WIDGET(actionPreviewSeparate)->setChecked(true);
+			break;
+		default:
+			WIDGET(actionPreviewInput)->setChecked(true);
+	}
+}
+
+/**
+    \fn UI_RunApp(void)
+    \brief Main entry point for the GUI application
+*/
+int UI_RunApp(void)
+{
+	
+	setupMenus();
+	checkCrashFile();
+
+	if (global_argc >= 2)
+		automation();
+
+	myApplication->exec();
+
 	destroyTranslator();
     delete myApplication;
     myApplication=NULL;
-    
-}
-/**
-    \fn searchTranslationTable(const char *name))
-    \brief return the action corresponding to a give button. The translation table is in translation_table.h
-*/
-Action searchTranslationTable(const char *name)
-{
-	for(int i=0;i< SIZEOF_MY_TRANSLATION;i++)
-	{
-		if(!strcmp(name, myTranslationTable[i].name))
-		{
-			return  myTranslationTable[i].action;
-		}
-	}
-	printf("WARNING: Signal not found in translation table %s\n",name);
-	return ACT_DUMMY;
-}
-/**
-    \fn     UI_updateRecentMenu( void )
-    \brief  Update the recent submenu with the latest files loaded
-*/
-uint8_t UI_updateRecentMenu( void )
-{
-	const char **names;
-	uint32_t nb_item=0;
-	QAction *actions[4]={WIDGET(actionRecent0),WIDGET(actionRecent1),WIDGET(actionRecent2),WIDGET(actionRecent3)};
-	names=prefs->get_lastfiles();
-
-	// hide them all
-	for(int i=0;i<4;i++) actions[i]->setVisible(0);
-	// Redraw..
-	for( nb_item=0;nb_item<4;nb_item++)
-	{
-		if(!names[nb_item]) 
-		{
-			return 1;
-		}
-		else
-		{
-			//actions[nb_item]->setVisible(1);
-			// Replace widget ?
-			actions[nb_item]->setText(QString::fromUtf8(names[nb_item]));
-			actions[nb_item]->setVisible(1);
-		}
-		// Update name
-	}
-	return 1;
-}
-/** 
-  \fn    setupMenus(void)
-  \brief Fill in video & audio co
-*/
-void setupMenus(void)
-{
+    
+}
+/**
+    \fn searchTranslationTable(const char *name))
+    \brief return the action corresponding to a give button. The translation table is in translation_table.h
+*/
+Action searchTranslationTable(const char *name)
+{
+	for(int i=0;i< SIZEOF_MY_TRANSLATION;i++)
+	{
+		if(!strcmp(name, myTranslationTable[i].name))
+		{
+			return  myTranslationTable[i].action;
+		}
+	}
+	printf("WARNING: Signal not found in translation table %s\n",name);
+	return ACT_DUMMY;
+}
+/**
+    \fn     UI_updateRecentMenu( void )
+    \brief  Update the recent submenu with the latest files loaded
+*/
+uint8_t UI_updateRecentMenu( void )
+{
+	const char **names;
+	uint32_t nb_item=0;
+	QAction *actions[4]={WIDGET(actionRecent0),WIDGET(actionRecent1),WIDGET(actionRecent2),WIDGET(actionRecent3)};
+	names=prefs->get_lastfiles();
+
+	// hide them all
+	for(int i=0;i<4;i++) actions[i]->setVisible(0);
+	// Redraw..
+	for( nb_item=0;nb_item<4;nb_item++)
+	{
+		if(!names[nb_item]) 
+		{
+			return 1;
+		}
+		else
+		{
+			//actions[nb_item]->setVisible(1);
+			// Replace widget ?
+			actions[nb_item]->setText(QString::fromUtf8(names[nb_item]));
+			actions[nb_item]->setVisible(1);
+		}
+		// Update name
+	}
+	return 1;
+}
+/** 
+  \fn    setupMenus(void)
+  \brief Fill in video & audio co
+*/
+void setupMenus(void)
+{
 	uint32_t nbVid;
-    uint32_t maj,mn,pa;
-	const char *name;
-
-	nbVid=ADM_ve6_getNbEncoders();
-	printf("Found %d video encoder(s)\n",nbVid);
-	for(uint32_t i=1;i<nbVid;i++)
-	{
-		ADM_ve6_getEncoderInfo(i,&name,&maj,&mn,&pa);
-		WIDGET(comboBoxVideo)->addItem(name);
-	}
-
-	// And A codec
-
-	uint32_t nbAud;
-
-    nbAud=audioEncoderGetNumberOfEncoders();
-	printf("Found %d audio encoder(s)\n",nbAud);		       
-	for(uint32_t i=1;i<nbAud;i++)
-	{
-		name=audioEncoderGetDisplayName(i);
-		WIDGET(comboBoxAudio)->addItem(name);
+    uint32_t maj,mn,pa;
+	const char *name;
+
+	nbVid=ADM_ve6_getNbEncoders();
+	printf("Found %d video encoder(s)\n",nbVid);
+	for(uint32_t i=1;i<nbVid;i++)
+	{
+		ADM_ve6_getEncoderInfo(i,&name,&maj,&mn,&pa);
+		WIDGET(comboBoxVideo)->addItem(name);
 	}
-
-	/*   Fill in output format window */
-	uint32_t nbFormat=ADM_mx_getNbMuxers();
-
-	printf("Found %d format(s)\n",nbFormat);
-	for(uint32_t i=0;i<nbFormat;i++)
+
+	// And A codec
+
+	uint32_t nbAud;
+
+    nbAud=audioEncoderGetNumberOfEncoders();
+	printf("Found %d audio encoder(s)\n",nbAud);		       
+	for(uint32_t i=1;i<nbAud;i++)
 	{
+		name=audioEncoderGetDisplayName(i);
+		WIDGET(comboBoxAudio)->addItem(name);
+	}
+
+	/*   Fill in output format window */
+	uint32_t nbFormat=ADM_mx_getNbMuxers();
+
+	printf("Found %d format(s)\n",nbFormat);
+	for(uint32_t i=0;i<nbFormat;i++)
+	{
         const char *name=ADM_mx_getName(i);
-		WIDGET(comboBoxFormat)->addItem(name);	
-	}
-
-}
-/*
-    Return % of scale (between 0 and 1)
-*/
-double 	UI_readScale( void )
-{
-	double v;
-	if(!slider) v=0;
-	v= (double)(slider->value());
-	v/=10000000;
-	return v;
-}
-void UI_setScale( double val )
-{
-	if(_upd_in_progres) return;
-	_upd_in_progres++;
-	slider->setValue( (int)(val * 10000000));
-	_upd_in_progres--;
-}
-
-int UI_readCurFrame(void)
-{
-	return 0;
-}
-
-int UI_readCurTime(uint16_t &hh, uint16_t &mm, uint16_t &ss, uint16_t &ms)
-{
-	int success = 0;
-
-	QString timeText = WIDGET(currentTime)->text();
-	int pos;
-
-	if (WIDGET(currentTime)->validator()->validate(timeText, pos) == QValidator::Acceptable)
-	{
-		uint32_t frame;
-
-		hh = (uint16_t)timeText.left(2).toUInt();
-		mm = (uint16_t)timeText.mid(3, 2).toUInt();
-		ss = (uint16_t)timeText.mid(6, 2).toUInt();
-		ms = (uint16_t)timeText.right(3).toUInt();
-
-		time2frame(&frame, currentFps, hh, mm, ss, ms);
-
-		if (frame <= frameCount)
-			success = 1;
-	}
-
-	return success;
-}
-
-void UI_purge( void )
-{
-	QCoreApplication::processEvents ();
-}
-
-
-//*******************************************
-
-/**
-    \fn UI_setTitle(char *name)
-    \brief Set the main window title, usually name if the file being edited
-*/
-void UI_setTitle(const char *name)
-{
-	char *title;
-	const char* defaultTitle = "Avidemux";
-
-	if (name && strlen(name) > 0)
-	{
-		title = new char[strlen(defaultTitle) + strlen(name) + 3 + 1];
-
-		strcpy(title, name);
-		strcat(title, " - ");
-		strcat(title, defaultTitle);
-	}
-	else
-	{
-		title = new char[strlen(defaultTitle) + 1];
-
-		strcpy(title, defaultTitle);
-	}
-
-	QuiMainWindows->setWindowTitle(QString::fromUtf8(title));
-	delete [] title;
-}
-
-/**
-    \fn     UI_setFrameType( uint32_t frametype,uint32_t qp)
-    \brief  Display frametype (I/P/B) and associated quantizer
-*/
-
-void UI_setFrameType( uint32_t frametype,uint32_t qp)
-{
-	char string[100];
-	char	c='?';
-	switch(frametype)
-	{
-	case AVI_KEY_FRAME: c='I';break;
-	case AVI_B_FRAME: c='B';break;
-	case 0: c='P';break;
-	default:c='?';break;
-
-	}
-	sprintf(string,QT_TR_NOOP("%c (%02d)"),c,qp);
-	WIDGET(label_8)->setText(string);	
-
-}
-
-/**
-    \fn     UI_updateFrameCount(uint32_t curFrame)
-    \brief  Display the current displayed frame #
-*/
-void UI_updateFrameCount(uint32_t curFrame)
-{
-	
-}
-
-/**
-    \fn      UI_setFrameCount(uint32_t curFrame,uint32_t total)
-    \brief  Display the current displayed frame # and total frame #
-*/
-void UI_setFrameCount(uint32_t curFrame,uint32_t total)
-{
-	
-}
-
-/**
-    \fn     UI_updateTimeCount(uint32_t curFrame,uint32_t fps)
-    \brief  Display the time corresponding to current frame according to fps (fps1000)
-*/
-void UI_updateTimeCount(uint32_t curFrame,uint32_t fps)
-{
-	char text[80];   
-	uint32_t mm,hh,ss,ms;
-
-	frame2time(curFrame,fps, &hh, &mm, &ss, &ms);
-	sprintf(text, "%02d:%02d:%02d.%03d", hh, mm, ss, ms);
-	WIDGET(currentTime)->setText(text);
-}
-
-/**
-    \fn     UI_updateTimeCount(uint32_t curFrame,uint32_t fps)
-    \brief  Display the time corresponding to current frame according to fps (fps1000) and total duration
-*/
-void UI_setTimeCount(uint32_t curFrame,uint32_t total, uint32_t fps)
-{
-	char text[80];   
-	uint32_t mm,hh,ss,ms;
-
-	if(total) total--; // We display from 0 to X
-
-	UI_updateTimeCount(curFrame,fps);
-	frame2time(total,fps, &hh, &mm, &ss, &ms);
-	sprintf(text, "/ %02d:%02d:%02d.%03d", hh, mm, ss, ms);
-	WIDGET(totalTime)->setText(text);
-
-	slider->setFrameCount(total);
-
-	currentFps = fps;	
-}
+		WIDGET(comboBoxFormat)->addItem(name);	
+	}
 
+}
+/*
+    Return % of scale (between 0 and 1)
+*/
+double 	UI_readScale( void )
+{
+	double v;
+	if(!slider) v=0;
+	v= (double)(slider->value());
+	v/=10000000;
+	return v;
+}
+void UI_setScale( double val )
+{
+	if(_upd_in_progres) return;
+	_upd_in_progres++;
+	slider->setValue( (int)(val * 10000000));
+	_upd_in_progres--;
+}
+
+int UI_readCurFrame(void)
+{
+	return 0;
+}
+
+int UI_readCurTime(uint16_t &hh, uint16_t &mm, uint16_t &ss, uint16_t &ms)
+{
+	int success = 0;
+
+	QString timeText = WIDGET(currentTime)->text();
+	int pos;
+
+	if (WIDGET(currentTime)->validator()->validate(timeText, pos) == QValidator::Acceptable)
+	{
+		uint32_t frame;
+
+		hh = (uint16_t)timeText.left(2).toUInt();
+		mm = (uint16_t)timeText.mid(3, 2).toUInt();
+		ss = (uint16_t)timeText.mid(6, 2).toUInt();
+		ms = (uint16_t)timeText.right(3).toUInt();
+
+		time2frame(&frame, currentFps, hh, mm, ss, ms);
+
+		if (frame <= frameCount)
+			success = 1;
+	}
+
+	return success;
+}
+
+void UI_purge( void )
+{
+	QCoreApplication::processEvents ();
+}
+
+
+//*******************************************
+
 /**
+    \fn UI_setTitle(char *name)
+    \brief Set the main window title, usually name if the file being edited
+*/
+void UI_setTitle(const char *name)
+{
+	char *title;
+	const char* defaultTitle = "Avidemux";
+
+	if (name && strlen(name) > 0)
+	{
+		title = new char[strlen(defaultTitle) + strlen(name) + 3 + 1];
+
+		strcpy(title, name);
+		strcat(title, " - ");
+		strcat(title, defaultTitle);
+	}
+	else
+	{
+		title = new char[strlen(defaultTitle) + 1];
+
+		strcpy(title, defaultTitle);
+	}
+
+	QuiMainWindows->setWindowTitle(QString::fromUtf8(title));
+	delete [] title;
+}
+
+/**
+    \fn     UI_setFrameType( uint32_t frametype,uint32_t qp)
+    \brief  Display frametype (I/P/B) and associated quantizer
+*/
+
+void UI_setFrameType( uint32_t frametype,uint32_t qp)
+{
+	char string[100];
+	char	c='?';
+	switch(frametype)
+	{
+	case AVI_KEY_FRAME: c='I';break;
+	case AVI_B_FRAME: c='B';break;
+	case 0: c='P';break;
+	default:c='?';break;
+
+	}
+	sprintf(string,QT_TR_NOOP("%c (%02d)"),c,qp);
+	WIDGET(label_8)->setText(string);	
+
+}
+
+/**
+    \fn     UI_updateFrameCount(uint32_t curFrame)
+    \brief  Display the current displayed frame #
+*/
+void UI_updateFrameCount(uint32_t curFrame)
+{
+	
+}
+
+/**
+    \fn      UI_setFrameCount(uint32_t curFrame,uint32_t total)
+    \brief  Display the current displayed frame # and total frame #
+*/
+void UI_setFrameCount(uint32_t curFrame,uint32_t total)
+{
+	
+}
+
+/**
+    \fn     UI_updateTimeCount(uint32_t curFrame,uint32_t fps)
+    \brief  Display the time corresponding to current frame according to fps (fps1000)
+*/
+void UI_updateTimeCount(uint32_t curFrame,uint32_t fps)
+{
+	char text[80];   
+	uint32_t mm,hh,ss,ms;
+
+	frame2time(curFrame,fps, &hh, &mm, &ss, &ms);
+	sprintf(text, "%02d:%02d:%02d.%03d", hh, mm, ss, ms);
+	WIDGET(currentTime)->setText(text);
+}
+
+/**
+    \fn     UI_updateTimeCount(uint32_t curFrame,uint32_t fps)
+    \brief  Display the time corresponding to current frame according to fps (fps1000) and total duration
+*/
+void UI_setTimeCount(uint32_t curFrame,uint32_t total, uint32_t fps)
+{
+	char text[80];   
+	uint32_t mm,hh,ss,ms;
+
+	if(total) total--; // We display from 0 to X
+
+	UI_updateTimeCount(curFrame,fps);
+	frame2time(total,fps, &hh, &mm, &ss, &ms);
+	sprintf(text, "/ %02d:%02d:%02d.%03d", hh, mm, ss, ms);
+	WIDGET(totalTime)->setText(text);
+
+	slider->setFrameCount(total);
+
+	currentFps = fps;	
+}
+
+/**
     \fn UI_setCurrentTime
     \brief Set current PTS of displayed video
 */
@@ -940,131 +940,131 @@
     ms2time(shorty,&hh,&mm,&ss,&ms);
   	sprintf(text, "/%02d:%02d:%02d.%03d", hh, mm, ss, ms);
     WIDGET(totalTime)->setText(text);
-}
-/**
-    \fn     UI_setMarkers(uint64_t Ptsa, uint32_t Ptsb )
-    \brief  Display frame # for marker A & B
-*/
-void UI_setMarkers(uint64_t a, uint64_t b)
-{
-	char text[80];
+}
+/**
+    \fn     UI_setMarkers(uint64_t Ptsa, uint32_t Ptsb )
+    \brief  Display frame # for marker A & B
+*/
+void UI_setMarkers(uint64_t a, uint64_t b)
+{
+	char text[80];
     uint32_t hh,mm,ss,ms;
     uint32_t timems;
     a/=1000;
     b/=1000;
 
     timems=(uint32_t)(a);
-    ms2time(timems,&hh,&mm,&ss,&ms);
-	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
-	WIDGET(pushButtonJumpToMarkerA)->setText(text);
-
+    ms2time(timems,&hh,&mm,&ss,&ms);
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
+	WIDGET(pushButtonJumpToMarkerA)->setText(text);
+
 	timems=(uint32_t)(b);
     ms2time(timems,&hh,&mm,&ss,&ms);
-	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
-	WIDGET(pushButtonJumpToMarkerB)->setText(text);
-
-	//slider->setMarkers(a, b);
-}
-
-/**
-    \fn     UI_getCurrentVCodec(void)
-    \brief  Returns the current selected video code in menu, i.e its number (0 being the first)
-*/
-int 	UI_getCurrentVCodec(void)
-{
-	int i=WIDGET(comboBoxVideo)->currentIndex();
-	if(i<0) i=0;
-	return i; 
-}
-/**
-    \fn     UI_setVideoCodec( int i)
-    \brief  Select the video codec which is # x in pulldown menu (starts at zero :copy)
-*/
-
-void UI_setVideoCodec( int i)
-{
-	int b=!!i;
-	WIDGET(comboBoxVideo)->setCurrentIndex(i);
-
-	WIDGET(pushButtonVideoConf)->setEnabled(b);
-	WIDGET(pushButtonVideoFilter)->setEnabled(b);
-}
-/**
-    \fn     UI_getCurrentACodec(void)
-    \brief  Returns the current selected audio code in menu, i.e its number (0 being the first)
-*/
-
-int 	UI_getCurrentACodec(void)
-{
-	int i=WIDGET(comboBoxAudio)->currentIndex();
-	if(i<0) i=0;
-	return i; 
-}
-/**
-    \fn     UI_setAudioCodec( int i)
-    \brief  Select the audio codec which is # x in pulldown menu (starts at zero :copy)
-*/
-
-void UI_setAudioCodec( int i)
-{ int b=!!i;
-WIDGET(comboBoxAudio)->setCurrentIndex(i);
-WIDGET(pushButtonAudioConf)->setEnabled(b);
-WIDGET(pushButtonAudioFilter)->setEnabled(b);
-}
-/**
-    \fn     UI_GetCurrentFormat(void)
-    \brief  Returns the current selected output format
-*/
-
-ADM_OUT_FORMAT 	UI_GetCurrentFormat( void )
-{
-	int i=WIDGET(comboBoxFormat)->currentIndex();
-	if(i<0) i=0;
-	return (ADM_OUT_FORMAT)i; 
-}
-/**
-    \fn     UI_SetCurrentFormat( ADM_OUT_FORMAT fmt )
-    \brief  Select  output format
-*/
-uint8_t 	UI_SetCurrentFormat( uint32_t fmt )
-{
-	WIDGET(comboBoxFormat)->setCurrentIndex((int)fmt);
-}
-
-/**
-      \fn UI_getTimeShift
-      \brief get state (on/off) and value for time Shift
-*/
-uint8_t UI_getTimeShift(int *onoff,int *value)
-{
-	if(WIDGET(checkBox_TimeShift)->checkState()==Qt::Checked)
-		*onoff=1;
-	else
-		*onoff=0;
-	*value=WIDGET(spinBox_TimeValue)->value();
-	return 1;
-}
-/**
-      \fn UI_setTimeShift
-      \brief get state (on/off) and value for time Shift
-*/
-
-uint8_t UI_setTimeShift(int onoff,int value)
-{
-	if (onoff && value)
-		WIDGET(checkBox_TimeShift)->setCheckState(Qt::Checked);
-	else
-		WIDGET(checkBox_TimeShift)->setCheckState(Qt::Unchecked);
-	WIDGET(spinBox_TimeValue)->setValue(value);
-	return 1;
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
+	WIDGET(pushButtonJumpToMarkerB)->setText(text);
+
+	//slider->setMarkers(a, b);
 }
+
 /**
+    \fn     UI_getCurrentVCodec(void)
+    \brief  Returns the current selected video code in menu, i.e its number (0 being the first)
+*/
+int 	UI_getCurrentVCodec(void)
+{
+	int i=WIDGET(comboBoxVideo)->currentIndex();
+	if(i<0) i=0;
+	return i; 
+}
+/**
+    \fn     UI_setVideoCodec( int i)
+    \brief  Select the video codec which is # x in pulldown menu (starts at zero :copy)
+*/
+
+void UI_setVideoCodec( int i)
+{
+	int b=!!i;
+	WIDGET(comboBoxVideo)->setCurrentIndex(i);
+
+	WIDGET(pushButtonVideoConf)->setEnabled(b);
+	WIDGET(pushButtonVideoFilter)->setEnabled(b);
+}
+/**
+    \fn     UI_getCurrentACodec(void)
+    \brief  Returns the current selected audio code in menu, i.e its number (0 being the first)
+*/
+
+int 	UI_getCurrentACodec(void)
+{
+	int i=WIDGET(comboBoxAudio)->currentIndex();
+	if(i<0) i=0;
+	return i; 
+}
+/**
+    \fn     UI_setAudioCodec( int i)
+    \brief  Select the audio codec which is # x in pulldown menu (starts at zero :copy)
+*/
+
+void UI_setAudioCodec( int i)
+{ int b=!!i;
+WIDGET(comboBoxAudio)->setCurrentIndex(i);
+WIDGET(pushButtonAudioConf)->setEnabled(b);
+WIDGET(pushButtonAudioFilter)->setEnabled(b);
+}
+/**
+    \fn     UI_GetCurrentFormat(void)
+    \brief  Returns the current selected output format
+*/
+
+ADM_OUT_FORMAT 	UI_GetCurrentFormat( void )
+{
+	int i=WIDGET(comboBoxFormat)->currentIndex();
+	if(i<0) i=0;
+	return (ADM_OUT_FORMAT)i; 
+}
+/**
+    \fn     UI_SetCurrentFormat( ADM_OUT_FORMAT fmt )
+    \brief  Select  output format
+*/
+uint8_t 	UI_SetCurrentFormat( uint32_t fmt )
+{
+	WIDGET(comboBoxFormat)->setCurrentIndex((int)fmt);
+}
+
+/**
+      \fn UI_getTimeShift
+      \brief get state (on/off) and value for time Shift
+*/
+uint8_t UI_getTimeShift(int *onoff,int *value)
+{
+	if(WIDGET(checkBox_TimeShift)->checkState()==Qt::Checked)
+		*onoff=1;
+	else
+		*onoff=0;
+	*value=WIDGET(spinBox_TimeValue)->value();
+	return 1;
+}
+/**
+      \fn UI_setTimeShift
+      \brief get state (on/off) and value for time Shift
+*/
+
+uint8_t UI_setTimeShift(int onoff,int value)
+{
+	if (onoff && value)
+		WIDGET(checkBox_TimeShift)->setCheckState(Qt::Checked);
+	else
+		WIDGET(checkBox_TimeShift)->setCheckState(Qt::Unchecked);
+	WIDGET(spinBox_TimeValue)->setValue(value);
+	return 1;
+}
+/**
     \fn UI_setVUMeter
-*/
+*/
 bool UI_setVUMeter( uint32_t volume[6])
 {
     UI_vuUpdate( volume);
     return true;
-}
-//********************************************
-//EOF
+}
+//********************************************
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_clock.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_clock.h	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_clock.h	2010-03-01 06:22:02 UTC (rev 5956)
@@ -18,7 +18,8 @@
 #define ADM_CLOCK_H
 class Clock
 {
-	private: uint32_t _startTime;
+	private: 
+            uint32_t _startTime;
 
 	public:
 			Clock(void );

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreUI_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreUI_internal.h	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreUI_internal.h	2010-03-01 06:22:02 UTC (rev 5956)
@@ -126,7 +126,7 @@
 typedef void            CREATE_GUI_QUIET(void);
 typedef uint8_t			CREATE_GUI_IS_GUIET(void);
 typedef DIA_workingBase  *CREATE_GUI_WORKING(const char *title);
-typedef DIA_encodingBase *CREATE_GUI_ENCODING(uint32_t fps1000);
+typedef DIA_encodingBase *CREATE_GUI_ENCODING(uint64_t duration);
 // GUI_Sleep is internal
 typedef struct
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h	2010-03-01 06:22:02 UTC (rev 5956)
@@ -16,52 +16,48 @@
 #ifndef ADM_ENCODING_H
 #define ADM_ENCODING_H
 
+#include "ADM_clock.h"
+/**
+    \class DIA_encodingBase
+    \brief Base class for encoding dialog
+*/
 
-#define MAX_BR_SLOT 200
-
-typedef struct 
-{
-  uint32_t size;
-  uint32_t quant;
-}encodingSlice;
-
 class DIA_encodingBase
 {
 protected:
-                Clock	clock;
-                uint32_t  _lastTime;            // Start time used to calc. ETA
-                uint32_t  _lastFrame;           // Start frame used to calc. ETA
-                uint32_t  _nextSampleStartTime; // Next start time to be used for ETA
-                uint32_t  _nextSampleStartFrame; // Next start frame for ETA
+                Clock	  clock;
+                
+                uint32_t  _lastFrameCount;       // Start frame used to calc. ETA
+                uint32_t  _currentFrameCount;    //
+                uint32_t  _lastClock;            // Start time used to calc. ETA
                 uint32_t  _nextUpdate;           // Next time to update the GUI
-                float _fps_average;
-                uint32_t _average_bitrate;
-                uint64_t _totalSize;
-                uint64_t _audioSize;
-                uint64_t _videoSize;
-                uint32_t _bitrate_sum;           // Sum of bitrate array
-                encodingSlice _bitrate[MAX_BR_SLOT];
-                uint32_t _roundup;
-                uint32_t _current;
-                uint32_t _total;
-                uint32_t _lastnb;
-                uint32_t _fps1000;
-                uint32_t _originalPriority;
+                float     _fps_average;
+                uint32_t  _average_bitrate;
+                uint64_t  _totalDurationUs;
+                uint64_t  _currentDurationUs;
+                uint64_t  _totalSize;
+                uint64_t  _audioSize;
+                uint64_t  _videoSize;
+                uint32_t  _originalPriority;
         
 public:
-                             DIA_encodingBase( uint32_t fps1000 );
+                             DIA_encodingBase( uint64_t duration );
                 virtual      ~DIA_encodingBase( );
                 
                 virtual void reset( void );
-                virtual void setPhasis(const char *n);
-                virtual void setCodec(const char *n);
-                virtual void setAudioCodec(const char *n);
-                virtual void setFps(uint32_t fps);
-                virtual void setFrame(uint32_t nb,uint32_t size, uint32_t quant,uint32_t total);
-                virtual void setPercent(uint32_t percent);
-                virtual void setContainer(const char *container);
-                virtual void setAudioSize(uint32_t size);
-                virtual uint8_t isAlive(void);
+                virtual void setPhasis(const char *n)=0;
+                virtual void setVideoCodec(const char *n)=0;
+                virtual void setAudioCodec(const char *n)=0;
+                virtual void setFps(uint32_t fps1000)=0;
+                virtual void setPercent(uint32_t percent)=0;
+                virtual void setContainer(const char *container)=0;
+                virtual void setAudioSize(uint64_t size)=0;
+                virtual void setTotalSize(uint64_t size)=0;
+                virtual bool isAlive(void)=0;
+
+                virtual void pushVideoFrame(uint32_t size, uint32_t quant,uint64_t timeUs);
+                virtual void pushAudioFrame(uint32_t size);
+                virtual void refresh(void);
 };
 //********************
 DIA_encodingBase *createEncoding(uint32_t fps1000);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_coreToolkit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_coreToolkit.cpp	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_coreToolkit.cpp	2010-03-01 06:22:02 UTC (rev 5956)
@@ -231,9 +231,10 @@
 /**
     \fn createEncoding
 */
-DIA_encodingBase *createEncoding(uint32_t fps1000)
+DIA_encodingBase *createEncoding(uint64_t duration)
 {
- if(Toolkit->createEncoding) return Toolkit->createEncoding(fps1000);
-    return new DIA_encodingBase(fps1000);
+    if(Toolkit->createEncoding) return Toolkit->createEncoding(duration);
+//    return new DIA_encodingDummy(duration);
+    return NULL;
 } 
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-01 06:22:02 UTC (rev 5956)
@@ -7,9 +7,9 @@
  *                                                                         *
  ***************************************************************************/
 
-#include <math.h>
 
-//#include "prefs.h"
+
+
 #include "ADM_default.h"
 #include "DIA_coreToolkit.h"
 #include "avidemutils.h"
@@ -17,33 +17,20 @@
 #include "DIA_encoding.h"
 #include "ADM_vidMisc.h"
 
+#include <math.h>
+#define  ETA_SAMPLE_PERIOD 60000 //Use last n millis to calculate ETA
+#define  GUI_UPDATE_RATE 500    // Ms
 
-DIA_encodingBase::DIA_encodingBase( uint32_t fps1000 )
+DIA_encodingBase::DIA_encodingBase( uint64_t duration )
 {
-
-        _lastnb=0;
-        _totalSize=0;
-        _audioSize=0;
-        _videoSize=0;
-        _current=0;
-        setFps(fps1000);
         _originalPriority=getpriority(PRIO_PROCESS, 0);
-        _lastTime=0;
-        _lastFrame=0;
-        _fps_average=0;
-        _total=1000;
+        _totalDurationUs=duration;
+#ifdef __WIN32
+        _originalPriority=getpriority(PRIO_PROCESS, 0);
+#endif
+        reset();
 }
 
-void DIA_encodingBase::setFps(uint32_t fps)
-{
-        _roundup=(uint32_t )floor( (fps+999)/1000);
-        _fps1000=fps;
-        ADM_assert(_roundup<MAX_BR_SLOT);
-        memset(_bitrate,0,sizeof(_bitrate));
-        _bitrate_sum=0;
-        _average_bitrate=0;
-        
-}
 void DIA_stop( void)
 {
 	printf("Stop request\n");
@@ -53,69 +40,57 @@
 
 DIA_encodingBase::~DIA_encodingBase( )
 {
-
+#ifdef __WIN32
 	setpriority(PRIO_PROCESS, 0, _originalPriority);
-
+#endif
 }
 
-void DIA_encodingBase::setPhasis(const char *n)
+void DIA_encodingBase::reset(void)
 {
+        _lastFrameCount=0;
+        _currentFrameCount=0;
+        _totalSize=0;
+        _audioSize=0;
+        _videoSize=0;
+        _nextUpdate=GUI_UPDATE_RATE;
+        _lastClock=0;
+        _fps_average=0;
+        clock.reset();
 
 }
-void DIA_encodingBase::setAudioCodec(const char *n)
-{
 
-}
-
-void DIA_encodingBase::setCodec(const char *n)
+void DIA_encodingBase::pushVideoFrame(uint32_t size, uint32_t quant,uint64_t timeUs)
 {
-
-}
-void DIA_encodingBase::reset(void)
-{
-          _totalSize=0;
-          _videoSize=0;
-          _current=0;
-}
-void DIA_encodingBase::setContainer(const char *container)
-{
-}
-#define  ETA_SAMPLE_PERIOD 60000 //Use last n millis to calculate ETA
-#define  GUI_UPDATE_RATE 500  
-
-void DIA_encodingBase::setFrame(uint32_t nb,uint32_t size, uint32_t quant,uint32_t total)
-{
-          _total=total;
           _videoSize+=size;
-          if(nb < _lastnb || _lastnb == 0) // restart ?
-           {
-                _lastnb = nb;
-                clock.reset();
-                _lastTime=clock.getElapsedMS();
-                _lastFrame=0;
-                _fps_average=0;
-                _videoSize=size;
-    
-                _nextUpdate = _lastTime + GUI_UPDATE_RATE;
-                _nextSampleStartTime=_lastTime + ETA_SAMPLE_PERIOD;
-                _nextSampleStartFrame=0;
-          } 
-          _lastnb = nb;
-          _current=nb%_roundup;
-          _bitrate[_current].size=size;
-          _bitrate[_current].quant=quant;
+          _currentFrameCount++;
+          _currentDurationUs=timeUs;
 }
-void DIA_encodingBase::setAudioSize(uint32_t size)
+void DIA_encodingBase::pushAudioFrame(uint32_t size)
 {
-      _audioSize=size;
+          _audioSize+=size;
 }
-uint8_t DIA_encodingBase::isAlive( void )
+void DIA_encodingBase::refresh(void)
 {
-	return 0;
+          uint32_t time=clock.getElapsedMS();
+          if(time>_nextUpdate)
+          {
+                uint32_t deltaTime=time-_lastClock;
+                uint32_t deltaFrame=_currentFrameCount-_lastFrameCount;
+                if(deltaFrame)
+                {
+                    deltaFrame*=1000;
+                    deltaFrame/=deltaTime;
+                    _fps_average=((float)deltaFrame)/1000.;
+                    setFps(deltaFrame);
+                    float percent=_currentDurationUs/_totalDurationUs;
+                    if(percent>1.0) percent=1.0;
+                    percent*=100;
+                    setPercent((uint32_t)percent);
+                }
+                _nextUpdate=time+GUI_UPDATE_RATE;
+                setAudioSize(_audioSize);
+                UI_purge();
+          }
 }
-void DIA_encodingBase::setPercent(uint32_t percent)
-{
-
-}
 //EOF
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-02-28 20:50:24 UTC (rev 5955)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-03-01 06:22:02 UTC (rev 5956)
@@ -208,7 +208,7 @@
             *bFramePresent=false;
         }else
         {
-            ADM_info("PTS is monotonous, probably no bframe\n");
+            ADM_info("PTS is not monotonous, there are bframe\n");
             *bFramePresent=true;
         }
     }



From mean at mail.berlios.de  Mon Mar  1 07:22:10 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Mar 2010 07:22:10 +0100
Subject: [Avidemux-svn-commit] r5957 - in branches/avidemux_2.6_branch_mean:
	autononreg/dialogFactory avidemux/common/ADM_script2/include
	avidemux/common/ADM_script2/src
	avidemux/qt4/ADM_userInterfaces/ADM_dialog
	avidemux_core/ADM_coreUI/include avidemux_core/ADM_coreUI/src
Message-ID: <201003010622.o216MAS2000037@sheep.berlios.de>

Author: mean
Date: 2010-03-01 07:22:09 +0100 (Mon, 01 Mar 2010)
New Revision: 5957

Added:
   branches/avidemux_2.6_branch_mean/autononreg/dialogFactory/encoding.js
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsTestFactory.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
Log:
[EncodingDialog] Unit test case (js)

Added: branches/avidemux_2.6_branch_mean/autononreg/dialogFactory/encoding.js
===================================================================
--- branches/avidemux_2.6_branch_mean/autononreg/dialogFactory/encoding.js	2010-03-01 06:22:02 UTC (rev 5956)
+++ branches/avidemux_2.6_branch_mean/autononreg/dialogFactory/encoding.js	2010-03-01 06:22:09 UTC (rev 5957)
@@ -0,0 +1,6 @@
+//AD  <- These first 4 characters need to be the first 4 characters to identify the ECMAScript file to Avidemux
+print("Testing factory FileSel");
+admTestEncoding();
+print("Testing factory FileSel");
+/* End of test
+*/

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsTestFactory.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsTestFactory.h	2010-03-01 06:22:02 UTC (rev 5956)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsTestFactory.h	2010-03-01 06:22:09 UTC (rev 5957)
@@ -39,6 +39,7 @@
 int jsTestFacToggle(void);
 int jsTestFacFloat(void);
 int jsTestFacInt(void);
+int jsTestFacEncoding(void);
 };
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp	2010-03-01 06:22:02 UTC (rev 5956)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp	2010-03-01 06:22:09 UTC (rev 5957)
@@ -18,8 +18,8 @@
 #include "DIA_fileSel.h"
 #include "DIA_factory.h"
 #include "ADM_jsTestFactory.h"
+#include "DIA_encoding.h"
 
-
 /**
     \fn crashTest
     \brief Force a crash
@@ -420,5 +420,25 @@
   return false;
       
 }
-
+/**
+    \fn jsTestFacEncoding
+*/
+int jsTestFacEncoding(void)
+{
+    DIA_encodingBase *base=createEncoding(1000*10000LL);
+    base->setContainer("the container");
+    base->setAudioCodec("the audio codec");
+    base->setVideoCodec("the video codec");
+    for(int i=0;i<20;i++)
+    {
+        base->refresh();
+        base->pushVideoFrame(10000,1,5*1000LL*i);
+        base->refresh();
+        
+        ADM_usleep(500*1000);
+    }
+    delete base;
+    base=NULL;
+    return true;
+}
 //EOF 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c	2010-03-01 06:22:02 UTC (rev 5956)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c	2010-03-01 06:22:09 UTC (rev 5957)
@@ -517,34 +517,61 @@
     return var120;
 }
 static JSBool
-jjadmTestCrash(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+jjadmTestEncoding(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSObject *var128;
+    int var129;
     int var132;
+    jsval var133;
     JSBool var127;
     var128 = NULL;
+    var129 = 0;
     var132 = 0;
+    var133 = JSVAL_NULL;
     var127 = JS_FALSE;
     var128 = obj;
     var132 = argc;
-    jsTestCrash();
+    var129 = jsTestFacEncoding();
+    if (JS_NewNumberValue(cx, var129, &var133) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var133;
+    if (rval) {
+        *rval = var133;
+    }
     var127 = JS_TRUE;
+    do_return:
     return var127;
 }
 static JSBool
+jjadmTestCrash(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var135;
+    int var139;
+    JSBool var134;
+    var135 = NULL;
+    var139 = 0;
+    var134 = JS_FALSE;
+    var135 = obj;
+    var139 = argc;
+    jsTestCrash();
+    var134 = JS_TRUE;
+    return var134;
+}
+static JSBool
 jjadmTestAssert(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var134;
-    int var138;
-    JSBool var133;
-    var134 = NULL;
-    var138 = 0;
-    var133 = JS_FALSE;
-    var134 = obj;
-    var138 = argc;
+    JSObject *var141;
+    int var145;
+    JSBool var140;
+    var141 = NULL;
+    var145 = 0;
+    var140 = JS_FALSE;
+    var141 = obj;
+    var145 = argc;
     jsTestAssert();
-    var133 = JS_TRUE;
-    return var133;
+    var140 = JS_TRUE;
+    return var140;
 }
 static JSPropertySpec jj_static_ps[] = {
     {NULL, 0, 0, NULL, NULL}
@@ -571,6 +598,7 @@
     JS_FS("admTestFacNotch", jjadmTestFacNotch, 0, 0, 1),
     JS_FS("admTestFacThreadCount", jjadmTestFacThreadCount, 0, 0, 1),
     JS_FS("admTestFacSlider", jjadmTestFacSlider, 0, 0, 1),
+    JS_FS("admTestEncoding", jjadmTestEncoding, 0, 0, 1),
     JS_FS("admTestCrash", jjadmTestCrash, 0, 0, 0),
     JS_FS("admTestAssert", jjadmTestAssert, 0, 0, 0),
     JS_FS_END
@@ -594,6 +622,7 @@
     JS_FS("admTestFacNotch", jjadmTestFacNotch, 0, 0, 1),
     JS_FS("admTestFacThreadCount", jjadmTestFacThreadCount, 0, 0, 1),
     JS_FS("admTestFacSlider", jjadmTestFacSlider, 0, 0, 1),
+    JS_FS("admTestEncoding", jjadmTestEncoding, 0, 0, 1),
     JS_FS("admTestCrash", jjadmTestCrash, 0, 0, 0),
     JS_FS("admTestAssert", jjadmTestAssert, 0, 0, 0),
     JS_FS_END

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl	2010-03-01 06:22:02 UTC (rev 5956)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl	2010-03-01 06:22:09 UTC (rev 5957)
@@ -21,6 +21,7 @@
 function int admTestFacNotch   :  jsTestFacNotch   (void  ) <static>;
 function int admTestFacThreadCount:  jsTestFacThreadCount   (void  ) <static>;
 function int admTestFacSlider  :  jsTestFacSlider  (void  ) <static>;
+function int admTestEncoding   :  jsTestFacEncoding  (void  ) <static>;
 function void admTestCrash     :  jsTestCrash      (void  ) <static>;
 function void admTestAssert    :  jsTestAssert     (void  ) <static>;
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2010-03-01 06:22:02 UTC (rev 5956)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2010-03-01 06:22:09 UTC (rev 5957)
@@ -214,7 +214,7 @@
 void DIA_encodingQt4::setBitrate(uint32_t br,uint32_t globalbr)
 {
           ADM_assert(window);
-          snprintf(string,79,"%lu kB/s",br,globalbr);
+          snprintf(string,79,"%"LU" kB/s",br,globalbr);
           WRITE(labelVidBitrate);
 
 }
@@ -237,7 +237,7 @@
 void DIA_encodingQt4::setQuantIn(int size)
 {
           ADM_assert(window);
-          sprintf(string,"%lu",size);
+          sprintf(string,"%"LU,size);
           WRITE(labelQz);
 
 }
@@ -250,7 +250,7 @@
 {
           ADM_assert(window);
           uint64_t mb=size>>20;
-          sprintf(string,"%lu MB",(int)mb);
+          sprintf(string,"%"LU" MB",(int)mb);
           WRITE(labelTotalSize);
 
 }
@@ -264,7 +264,7 @@
 {
           ADM_assert(window);
           uint64_t mb=size>>20;
-          sprintf(string,"%lu MB",(int)mb);
+          sprintf(string,"%"LU" MB",(int)mb);
           WRITE(labelAudioSize);
 
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h	2010-03-01 06:22:02 UTC (rev 5956)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h	2010-03-01 06:22:09 UTC (rev 5957)
@@ -60,5 +60,5 @@
                 virtual void refresh(void);
 };
 //********************
-DIA_encodingBase *createEncoding(uint32_t fps1000);
+DIA_encodingBase *createEncoding(uint64_t duration);
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-01 06:22:02 UTC (rev 5956)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-01 06:22:09 UTC (rev 5957)
@@ -20,7 +20,7 @@
 #include <math.h>
 #define  ETA_SAMPLE_PERIOD 60000 //Use last n millis to calculate ETA
 #define  GUI_UPDATE_RATE 500    // Ms
-
+extern void UI_purge(void);
 DIA_encodingBase::DIA_encodingBase( uint64_t duration )
 {
         _originalPriority=getpriority(PRIO_PROCESS, 0);



From mean at mail.berlios.de  Mon Mar  1 07:22:15 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Mar 2010 07:22:15 +0100
Subject: [Avidemux-svn-commit] r5958 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_script2/src
	avidemux/qt4/ADM_userInterfaces/ADM_dialog
	avidemux_core/ADM_coreMuxer/include avidemux_core/ADM_coreMuxer/src
	avidemux_core/ADM_coreUI/include avidemux_core/ADM_coreUI/src
	avidemux_plugins/ADM_muxers/muxerAvi
	avidemux_plugins/ADM_muxers/muxerFlv
	avidemux_plugins/ADM_muxers/muxerMkv
	avidemux_plugins/ADM_muxers/muxerMp4
	avidemux_plugins/ADM_muxers/muxerRaw
	avidemux_plugins/ADM_muxers/muxerffPS
	avidemux_plugins/ADM_muxers/muxerffTS
Message-ID: <201003010622.o216MFZ1000104@sheep.berlios.de>

Author: mean
Date: 2010-03-01 07:22:14 +0100 (Mon, 01 Mar 2010)
New Revision: 5958

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/encoding.ui
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.h
Log:
[ui] Improve and hook the encoding dialog

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp	2010-03-01 06:22:14 UTC (rev 5958)
@@ -425,16 +425,16 @@
 */
 int jsTestFacEncoding(void)
 {
-    DIA_encodingBase *base=createEncoding(1000*10000LL);
+    DIA_encodingBase *base=createEncoding(1000*1000LL);
     base->setContainer("the container");
     base->setAudioCodec("the audio codec");
     base->setVideoCodec("the video codec");
     for(int i=0;i<20;i++)
     {
         base->refresh();
-        base->pushVideoFrame(10000,1,5*1000LL*i);
+        base->pushVideoFrame(10000,1,50*1000LL*i);
         base->refresh();
-        
+        printf("%d / %d\n",i,20);
         ADM_usleep(500*1000);
     }
     delete base;

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2010-03-01 06:22:14 UTC (rev 5958)
@@ -102,12 +102,12 @@
 #define WRITE(x) WRITEM(x,string)
 /*************************************/
 static char string[80];
-static encodingWindow *window=NULL;
+#define window ((encodingWindow *)WINDOW)
 DIA_encodingQt4::DIA_encodingQt4( uint64_t duration) : DIA_encodingBase(duration)
 {
-        ADM_assert(window==NULL);
+        WINDOW=NULL;
         stopReq=0;
-        window=new encodingWindow();
+        WINDOW=(void *)new encodingWindow();
         window->setModal(TRUE);
         window->show();
 
@@ -119,24 +119,19 @@
 
 void DIA_encodingQt4::setFps(uint32_t fps)
 {
-    
-        
+      snprintf(string,79,"%"LU" fps",fps);
+      WRITE(labelFps);
 }
 
-void DIA_stop( void)
-{
-        printf("Stop request\n");
-        stopReq=1;
-}
 /**
     \fn dtpor
 */
 DIA_encodingQt4::~DIA_encodingQt4( )
 {
 	bool shutdownRequired = (window->ui.checkBoxShutdown->checkState() == Qt::Checked);
-
-	if(window) delete window;
-	window=NULL;
+    encodingWindow *w=window;
+	if(w) delete w;
+	WINDOW=NULL;
 #if 0
 	if (shutdownRequired && !stopReq)
 	{
@@ -178,6 +173,18 @@
 
 }
 /**
+    \fn    setFrameCount
+    \brief display the # of processed frames
+*/
+
+void DIA_encodingQt4::setFrameCount(uint32_t nb)
+{
+          ADM_assert(window);
+          snprintf(string,79,"%"LU,nb);
+          WRITE(labelFrame);
+
+}
+/**
     \fn    setPercent
     \brief display percent of saved file
 */
@@ -185,6 +192,9 @@
 void DIA_encodingQt4::setPercent(uint32_t p)
 {
           ADM_assert(window);
+          printf("Percent:%u\n",p);
+          WIDGET(progressBar)->setValue(p);
+          UI_purge();
 }
 /**
     \fn setAudioCodec(const char *n)

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h	2010-03-01 06:22:14 UTC (rev 5958)
@@ -49,17 +49,22 @@
     ~DIA_encodingQt4( );
     
 protected:
-    encodingWindow *window;
+    void setTotalSize(uint64_t size);
+    void setAudioSize(uint64_t size);
+    void setPercent(uint32_t percent);
     void setFps(uint32_t fps);
+    void setFrameCount(uint32_t nb);
+
+public:    
+    void *WINDOW;
+    
     void setPhasis(const char *n);
     void setAudioCodec(const char *n);
     void setVideoCodec(const char *n);
     void setBitrate(uint32_t br,uint32_t globalbr);
     void setContainer(const char *container);
     void setQuantIn(int size);
-    void setTotalSize(uint64_t size);
-    void setAudioSize(uint64_t size);
-    void setPercent(uint32_t percent);
     bool isAlive( void );
+    
 };
 #endif	// Q_encoding_h

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/encoding.ui
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/encoding.ui	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/encoding.ui	2010-03-01 06:22:14 UTC (rev 5958)
@@ -1,473 +1,379 @@
-<ui version="4.0" >
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
  <class>encodingDialog</class>
- <widget class="QDialog" name="encodingDialog" >
-  <property name="geometry" >
+ <widget class="QDialog" name="encodingDialog">
+  <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>444</width>
-    <height>326</height>
+    <height>353</height>
    </rect>
   </property>
-  <property name="windowTitle" >
+  <property name="windowTitle">
    <string>Encoding...</string>
   </property>
-  <layout class="QVBoxLayout" >
-   <property name="spacing" >
+  <layout class="QVBoxLayout">
+   <property name="spacing">
     <number>6</number>
    </property>
-   <property name="leftMargin" >
+   <property name="margin">
     <number>9</number>
    </property>
-   <property name="topMargin" >
-    <number>9</number>
-   </property>
-   <property name="rightMargin" >
-    <number>9</number>
-   </property>
-   <property name="bottomMargin" >
-    <number>9</number>
-   </property>
    <item>
-    <layout class="QVBoxLayout" >
-     <property name="spacing" >
+    <layout class="QVBoxLayout">
+     <property name="spacing">
       <number>6</number>
      </property>
-     <property name="leftMargin" >
+     <property name="margin">
       <number>0</number>
      </property>
-     <property name="topMargin" >
-      <number>0</number>
-     </property>
-     <property name="rightMargin" >
-      <number>0</number>
-     </property>
-     <property name="bottomMargin" >
-      <number>0</number>
-     </property>
      <item>
-      <layout class="QGridLayout" >
-       <property name="leftMargin" >
+      <layout class="QGridLayout">
+       <property name="margin">
         <number>0</number>
        </property>
-       <property name="topMargin" >
-        <number>0</number>
-       </property>
-       <property name="rightMargin" >
-        <number>0</number>
-       </property>
-       <property name="bottomMargin" >
-        <number>0</number>
-       </property>
-       <property name="horizontalSpacing" >
+       <property name="spacing">
         <number>12</number>
        </property>
-       <property name="verticalSpacing" >
-        <number>12</number>
-       </property>
-       <item row="0" column="0" >
-        <widget class="QGroupBox" name="groupBox" >
-         <property name="sizePolicy" >
-          <sizepolicy vsizetype="Preferred" hsizetype="Maximum" >
+       <item row="0" column="0">
+        <widget class="QGroupBox" name="groupBox">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Maximum" vsizetype="Preferred">
            <horstretch>1</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
-         <property name="minimumSize" >
+         <property name="minimumSize">
           <size>
            <width>190</width>
            <height>0</height>
           </size>
          </property>
-         <property name="title" >
+         <property name="title">
           <string/>
          </property>
-         <layout class="QGridLayout" >
-          <property name="leftMargin" >
+         <layout class="QGridLayout">
+          <property name="margin">
            <number>9</number>
           </property>
-          <property name="topMargin" >
-           <number>9</number>
-          </property>
-          <property name="rightMargin" >
-           <number>9</number>
-          </property>
-          <property name="bottomMargin" >
-           <number>9</number>
-          </property>
-          <property name="horizontalSpacing" >
+          <property name="spacing">
            <number>6</number>
           </property>
-          <property name="verticalSpacing" >
-           <number>6</number>
-          </property>
-          <item row="0" column="0" >
-           <widget class="QLabel" name="label_2" >
-            <property name="font" >
+          <item row="0" column="0">
+           <widget class="QLabel" name="label_2">
+            <property name="font">
              <font>
               <weight>75</weight>
               <bold>true</bold>
              </font>
             </property>
-            <property name="text" >
+            <property name="text">
              <string>Phase:</string>
             </property>
            </widget>
           </item>
-          <item row="1" column="0" >
-           <widget class="QLabel" name="label_4" >
-            <property name="font" >
+          <item row="1" column="0">
+           <widget class="QLabel" name="label_4">
+            <property name="font">
              <font>
               <weight>75</weight>
               <bold>true</bold>
              </font>
             </property>
-            <property name="text" >
+            <property name="text">
              <string>Video Codec:</string>
             </property>
            </widget>
           </item>
-          <item row="1" column="1" >
-           <widget class="QLabel" name="labelVidCodec" >
-            <property name="text" >
+          <item row="1" column="1">
+           <widget class="QLabel" name="labelVidCodec">
+            <property name="text">
              <string>None</string>
             </property>
            </widget>
           </item>
-          <item row="0" column="1" >
-           <widget class="QLabel" name="labelPhasis" >
-            <property name="text" >
+          <item row="0" column="1">
+           <widget class="QLabel" name="labelPhasis">
+            <property name="text">
              <string>None</string>
             </property>
            </widget>
           </item>
-          <item row="3" column="1" >
-           <widget class="QLabel" name="labelContainer" >
-            <property name="text" >
+          <item row="3" column="1">
+           <widget class="QLabel" name="labelContainer">
+            <property name="text">
              <string>Unknown</string>
             </property>
            </widget>
           </item>
-          <item row="3" column="0" >
-           <widget class="QLabel" name="label_8" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
+          <item row="3" column="0">
+           <widget class="QLabel" name="label_8">
+            <property name="text">
+             <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Container:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt; font-weight:600;&quot;&gt;Container:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
             </property>
            </widget>
           </item>
-          <item row="2" column="1" >
-           <widget class="QLabel" name="labelAudCodec" >
-            <property name="text" >
+          <item row="2" column="1">
+           <widget class="QLabel" name="labelAudCodec">
+            <property name="text">
              <string>None</string>
             </property>
            </widget>
           </item>
-          <item row="2" column="0" >
-           <widget class="QLabel" name="label_6" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
+          <item row="2" column="0">
+           <widget class="QLabel" name="label_6">
+            <property name="text">
+             <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Audio Codec:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt; font-weight:600;&quot;&gt;Audio Codec:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
             </property>
            </widget>
           </item>
          </layout>
         </widget>
        </item>
-       <item row="1" column="1" >
-        <widget class="QGroupBox" name="groupBox_4" >
-         <property name="sizePolicy" >
-          <sizepolicy vsizetype="Preferred" hsizetype="Expanding" >
+       <item row="1" column="1">
+        <widget class="QGroupBox" name="groupBox_4">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
-         <property name="minimumSize" >
+         <property name="minimumSize">
           <size>
            <width>210</width>
            <height>0</height>
           </size>
          </property>
-         <property name="title" >
+         <property name="title">
           <string/>
          </property>
-         <layout class="QGridLayout" >
-          <property name="leftMargin" >
+         <layout class="QGridLayout">
+          <property name="margin">
            <number>9</number>
           </property>
-          <property name="topMargin" >
-           <number>9</number>
-          </property>
-          <property name="rightMargin" >
-           <number>9</number>
-          </property>
-          <property name="bottomMargin" >
-           <number>9</number>
-          </property>
-          <property name="horizontalSpacing" >
+          <property name="spacing">
            <number>6</number>
           </property>
-          <property name="verticalSpacing" >
-           <number>6</number>
-          </property>
-          <item row="2" column="1" >
-           <widget class="QLabel" name="labelFps" >
-            <property name="text" >
+          <item row="2" column="1">
+           <widget class="QLabel" name="labelFps">
+            <property name="text">
              <string>0</string>
             </property>
            </widget>
           </item>
-          <item row="1" column="1" >
-           <widget class="QLabel" name="labelETA" >
-            <property name="text" >
+          <item row="1" column="1">
+           <widget class="QLabel" name="labelETA">
+            <property name="text">
              <string>Unknown</string>
             </property>
            </widget>
           </item>
-          <item row="0" column="1" >
-           <widget class="QLabel" name="labelElapsed" >
-            <property name="text" >
+          <item row="0" column="1">
+           <widget class="QLabel" name="labelElapsed">
+            <property name="text">
              <string>00:00:00</string>
             </property>
            </widget>
           </item>
-          <item row="0" column="0" >
-           <widget class="QLabel" name="label_24" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
+          <item row="0" column="0">
+           <widget class="QLabel" name="label_24">
+            <property name="text">
+             <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Elapsed:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt; font-weight:600;&quot;&gt;Elapsed:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
             </property>
            </widget>
           </item>
-          <item row="1" column="0" >
-           <widget class="QLabel" name="label_26" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
+          <item row="1" column="0">
+           <widget class="QLabel" name="label_26">
+            <property name="text">
+             <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Time Remaining:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt; font-weight:600;&quot;&gt;Time Remaining:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
             </property>
            </widget>
           </item>
-          <item row="2" column="0" >
-           <widget class="QLabel" name="label_28" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
+          <item row="2" column="0">
+           <widget class="QLabel" name="label_28">
+            <property name="text">
+             <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Frames/sec:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt; font-weight:600;&quot;&gt;Frames/sec:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
             </property>
            </widget>
           </item>
          </layout>
         </widget>
        </item>
-       <item row="1" column="0" >
-        <widget class="QGroupBox" name="groupBox_3" >
-         <property name="sizePolicy" >
-          <sizepolicy vsizetype="Preferred" hsizetype="Preferred" >
+       <item row="1" column="0">
+        <widget class="QGroupBox" name="groupBox_3">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
-         <property name="minimumSize" >
+         <property name="minimumSize">
           <size>
            <width>180</width>
            <height>0</height>
           </size>
          </property>
-         <property name="title" >
+         <property name="title">
           <string/>
          </property>
-         <layout class="QGridLayout" >
-          <property name="leftMargin" >
+         <layout class="QGridLayout">
+          <property name="margin">
            <number>9</number>
           </property>
-          <property name="topMargin" >
-           <number>9</number>
-          </property>
-          <property name="rightMargin" >
-           <number>9</number>
-          </property>
-          <property name="bottomMargin" >
-           <number>9</number>
-          </property>
-          <property name="horizontalSpacing" >
+          <property name="spacing">
            <number>6</number>
           </property>
-          <property name="verticalSpacing" >
-           <number>6</number>
-          </property>
-          <item row="2" column="1" >
-           <widget class="QLabel" name="labelTotalSize" >
-            <property name="text" >
+          <item row="2" column="1">
+           <widget class="QLabel" name="labelTotalSize">
+            <property name="text">
              <string>0 MB</string>
             </property>
            </widget>
           </item>
-          <item row="2" column="0" >
-           <widget class="QLabel" name="label_22" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
+          <item row="2" column="0">
+           <widget class="QLabel" name="label_22">
+            <property name="text">
+             <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Total Size:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt; font-weight:600;&quot;&gt;Total Size:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
             </property>
            </widget>
           </item>
-          <item row="1" column="1" >
-           <widget class="QLabel" name="labelAudioSize" >
-            <property name="text" >
+          <item row="1" column="1">
+           <widget class="QLabel" name="labelAudioSize">
+            <property name="text">
              <string>0 MB</string>
             </property>
            </widget>
           </item>
-          <item row="1" column="0" >
-           <widget class="QLabel" name="label_20" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
+          <item row="1" column="0">
+           <widget class="QLabel" name="label_20">
+            <property name="text">
+             <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Audio Size:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt; font-weight:600;&quot;&gt;Audio Size:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
             </property>
            </widget>
           </item>
-          <item row="0" column="1" >
-           <widget class="QLabel" name="labelVideoSize" >
-            <property name="text" >
+          <item row="0" column="1">
+           <widget class="QLabel" name="labelVideoSize">
+            <property name="text">
              <string>0 MB</string>
             </property>
-            <property name="alignment" >
+            <property name="alignment">
              <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
             </property>
            </widget>
           </item>
-          <item row="0" column="0" >
-           <widget class="QLabel" name="label_18" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
+          <item row="0" column="0">
+           <widget class="QLabel" name="label_18">
+            <property name="text">
+             <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Video Size:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt; font-weight:600;&quot;&gt;Video Size:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
             </property>
            </widget>
           </item>
          </layout>
         </widget>
        </item>
-       <item row="0" column="1" >
-        <widget class="QGroupBox" name="groupBox_2" >
-         <property name="sizePolicy" >
-          <sizepolicy vsizetype="Preferred" hsizetype="Expanding" >
+       <item row="0" column="1">
+        <widget class="QGroupBox" name="groupBox_2">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
-         <property name="minimumSize" >
+         <property name="minimumSize">
           <size>
            <width>210</width>
            <height>0</height>
           </size>
          </property>
-         <property name="title" >
+         <property name="title">
           <string/>
          </property>
-         <layout class="QGridLayout" >
-          <property name="leftMargin" >
+         <layout class="QGridLayout">
+          <property name="margin">
            <number>9</number>
           </property>
-          <property name="topMargin" >
-           <number>9</number>
-          </property>
-          <property name="rightMargin" >
-           <number>9</number>
-          </property>
-          <property name="bottomMargin" >
-           <number>9</number>
-          </property>
-          <property name="horizontalSpacing" >
+          <property name="spacing">
            <number>6</number>
           </property>
-          <property name="verticalSpacing" >
-           <number>6</number>
-          </property>
-          <item row="0" column="0" >
-           <widget class="QLabel" name="label_10" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
+          <item row="0" column="0">
+           <widget class="QLabel" name="label_10">
+            <property name="text">
+             <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Processed Frames:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt; font-weight:600;&quot;&gt;Processed Frames:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
             </property>
            </widget>
           </item>
-          <item row="1" column="0" >
-           <widget class="QLabel" name="label_12" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
-p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Total Frames:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
-            </property>
-           </widget>
-          </item>
-          <item row="0" column="1" >
-           <widget class="QLabel" name="labelFrame" >
-            <property name="text" >
+          <item row="0" column="1">
+           <widget class="QLabel" name="labelFrame">
+            <property name="text">
              <string>0</string>
             </property>
-            <property name="alignment" >
+            <property name="alignment">
              <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
             </property>
            </widget>
           </item>
-          <item row="3" column="1" >
-           <widget class="QLabel" name="labelVidBitrate" >
-            <property name="text" >
+          <item row="2" column="1">
+           <widget class="QLabel" name="labelVidBitrate">
+            <property name="text">
              <string>0 kB/s</string>
             </property>
            </widget>
           </item>
-          <item row="3" column="0" >
-           <widget class="QLabel" name="label_16" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
+          <item row="2" column="0">
+           <widget class="QLabel" name="label_16">
+            <property name="text">
+             <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Average Bitrate:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt; font-weight:600;&quot;&gt;Average Bitrate:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
             </property>
            </widget>
           </item>
-          <item row="2" column="1" >
-           <widget class="QLabel" name="labelQz" >
-            <property name="text" >
+          <item row="1" column="1">
+           <widget class="QLabel" name="labelQz">
+            <property name="text">
              <string>0</string>
             </property>
            </widget>
           </item>
-          <item row="2" column="0" >
-           <widget class="QLabel" name="label_14" >
-            <property name="text" >
-             <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;style type="text/css">
+          <item row="1" column="0">
+           <widget class="QLabel" name="label_14">
+            <property name="text">
+             <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style>&lt;/head>&lt;body style=" font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;">
-&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:8pt; font-weight:600;">Quantiser:&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'MS Shell Dlg 2'; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt; font-weight:600;&quot;&gt;Quantiser:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
             </property>
            </widget>
           </item>
-          <item row="1" column="1" >
-           <widget class="QLabel" name="labelTotalFrame" >
-            <property name="text" >
-             <string>0</string>
-            </property>
-           </widget>
-          </item>
          </layout>
         </widget>
        </item>
@@ -475,10 +381,10 @@
      </item>
      <item>
       <spacer>
-       <property name="orientation" >
+       <property name="orientation">
         <enum>Qt::Vertical</enum>
        </property>
-       <property name="sizeHint" >
+       <property name="sizeHint" stdset="0">
         <size>
          <width>20</width>
          <height>6</height>
@@ -487,21 +393,21 @@
       </spacer>
      </item>
      <item>
-      <widget class="QProgressBar" name="progressBar" >
-       <property name="value" >
+      <widget class="QProgressBar" name="progressBar">
+       <property name="value">
         <number>0</number>
        </property>
-       <property name="orientation" >
+       <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
       </widget>
      </item>
      <item>
       <spacer>
-       <property name="orientation" >
+       <property name="orientation">
         <enum>Qt::Vertical</enum>
        </property>
-       <property name="sizeHint" >
+       <property name="sizeHint" stdset="0">
         <size>
          <width>20</width>
          <height>10</height>
@@ -510,35 +416,26 @@
       </spacer>
      </item>
      <item>
-      <layout class="QHBoxLayout" >
-       <property name="spacing" >
+      <layout class="QHBoxLayout">
+       <property name="spacing">
         <number>6</number>
        </property>
-       <property name="leftMargin" >
+       <property name="margin">
         <number>0</number>
        </property>
-       <property name="topMargin" >
-        <number>0</number>
-       </property>
-       <property name="rightMargin" >
-        <number>0</number>
-       </property>
-       <property name="bottomMargin" >
-        <number>0</number>
-       </property>
        <item>
-        <widget class="QCheckBox" name="checkBoxShutdown" >
-         <property name="text" >
+        <widget class="QCheckBox" name="checkBoxShutdown">
+         <property name="text">
           <string>Shut down computer when finished</string>
          </property>
         </widget>
        </item>
        <item>
         <spacer>
-         <property name="orientation" >
+         <property name="orientation">
           <enum>Qt::Horizontal</enum>
          </property>
-         <property name="sizeHint" >
+         <property name="sizeHint" stdset="0">
           <size>
            <width>40</width>
            <height>20</height>
@@ -547,39 +444,39 @@
         </spacer>
        </item>
        <item>
-        <widget class="QLabel" name="label" >
-         <property name="text" >
+        <widget class="QLabel" name="label">
+         <property name="text">
           <string>Priority:</string>
          </property>
         </widget>
        </item>
        <item>
-        <widget class="QComboBox" name="comboBoxPriority" >
-         <property name="currentIndex" >
+        <widget class="QComboBox" name="comboBoxPriority">
+         <property name="currentIndex">
           <number>2</number>
          </property>
          <item>
-          <property name="text" >
+          <property name="text">
            <string>High</string>
           </property>
          </item>
          <item>
-          <property name="text" >
+          <property name="text">
            <string>Above Normal</string>
           </property>
          </item>
          <item>
-          <property name="text" >
+          <property name="text">
            <string>Normal</string>
           </property>
          </item>
          <item>
-          <property name="text" >
+          <property name="text">
            <string>Below Normal</string>
           </property>
          </item>
          <item>
-          <property name="text" >
+          <property name="text">
            <string>Low</string>
           </property>
          </item>
@@ -588,28 +485,19 @@
       </layout>
      </item>
      <item>
-      <layout class="QVBoxLayout" >
-       <property name="spacing" >
+      <layout class="QVBoxLayout">
+       <property name="spacing">
         <number>6</number>
        </property>
-       <property name="leftMargin" >
+       <property name="margin">
         <number>0</number>
        </property>
-       <property name="topMargin" >
-        <number>0</number>
-       </property>
-       <property name="rightMargin" >
-        <number>0</number>
-       </property>
-       <property name="bottomMargin" >
-        <number>0</number>
-       </property>
        <item>
         <spacer>
-         <property name="orientation" >
+         <property name="orientation">
           <enum>Qt::Vertical</enum>
          </property>
-         <property name="sizeHint" >
+         <property name="sizeHint" stdset="0">
           <size>
            <width>20</width>
            <height>2</height>
@@ -618,18 +506,18 @@
         </spacer>
        </item>
        <item>
-        <widget class="Line" name="line" >
-         <property name="orientation" >
+        <widget class="Line" name="line">
+         <property name="orientation">
           <enum>Qt::Horizontal</enum>
          </property>
         </widget>
        </item>
        <item>
         <spacer>
-         <property name="orientation" >
+         <property name="orientation">
           <enum>Qt::Vertical</enum>
          </property>
-         <property name="sizeHint" >
+         <property name="sizeHint" stdset="0">
           <size>
            <width>20</width>
            <height>20</height>
@@ -640,28 +528,19 @@
       </layout>
      </item>
      <item>
-      <layout class="QHBoxLayout" >
-       <property name="spacing" >
+      <layout class="QHBoxLayout">
+       <property name="spacing">
         <number>6</number>
        </property>
-       <property name="leftMargin" >
+       <property name="margin">
         <number>0</number>
        </property>
-       <property name="topMargin" >
-        <number>0</number>
-       </property>
-       <property name="rightMargin" >
-        <number>0</number>
-       </property>
-       <property name="bottomMargin" >
-        <number>0</number>
-       </property>
        <item>
         <spacer>
-         <property name="orientation" >
+         <property name="orientation">
           <enum>Qt::Horizontal</enum>
          </property>
-         <property name="sizeHint" >
+         <property name="sizeHint" stdset="0">
           <size>
            <width>40</width>
            <height>20</height>
@@ -670,11 +549,11 @@
         </spacer>
        </item>
        <item>
-        <widget class="QPushButton" name="pushButton" >
-         <property name="text" >
+        <widget class="QPushButton" name="pushButton">
+         <property name="text">
           <string>Pause / Abort</string>
          </property>
-         <property name="default" >
+         <property name="default">
           <bool>true</bool>
          </property>
         </widget>

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2010-03-01 06:22:14 UTC (rev 5958)
@@ -71,6 +71,7 @@
         bool initVideo(ADM_videoStream *stream);
         bool initAudio(uint32_t nbAudioTrack,ADM_audioStream **audio);
         bool initialized;
+  virtual   const char *getContainerName(void)=0;
 public:
                 muxerFFmpeg();
         virtual ~muxerFFmpeg();

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h	2010-03-01 06:22:14 UTC (rev 5958)
@@ -25,7 +25,7 @@
             uint64_t videoDelay;
 
 
-            DIA_workingBase *encoding;
+            
 public:
                       ADM_videoStream() {videoDelay=0;} ;
             virtual ~ADM_videoStream() {};
@@ -56,7 +56,7 @@
 
                 uint64_t videoIncrement; // Used/set by initUI
                 uint64_t videoDuration;
-                DIA_workingBase  *encoding;
+                DIA_encodingBase  *encoding;
                 
 public:
                           ADM_muxer() {vStream=NULL;aStreams=NULL;nbAStreams=0;encoding=NULL;};
@@ -68,7 +68,7 @@
         virtual  bool     close(void)=0; 
         
         virtual  bool     initUI(const char *title);
-        virtual  bool     updateUI(uint64_t time);
+        virtual  bool     updateUI(void);
         virtual  bool     closeUI(void);
         virtual  bool     useGlobalHeader(void) {return false;}
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-03-01 06:22:14 UTC (rev 5958)
@@ -377,29 +377,21 @@
     f*=1000000;
     videoIncrement=(uint64_t)f;
 
+    
 
-
     ADM_info("avg fps=%u\n",vStream->getAvgFps1000());
     AVRational *scale=&(video_st->codec->time_base);
     uint64_t videoDuration=vStream->getVideoDuration();
 
-    encoding=createWorking(title);
-
+    encoding=createEncoding(videoDuration);
+    encoding->setContainer(getContainerName());
     MuxAudioPacket audioPackets[nbAStreams];
 
     while(true==vStream->getPacket(&len, buffer, bufSize,&pts,&dts,&flags))
     {
 	AVPacket pkt;
 
-            float p=1;
-            if(videoDuration)
-            {
-                    p=lastVideoDts;
-                    p/=videoDuration;
-                    p=p*100;
-            }
-
-            encoding->update((uint32_t)p);
+            encoding->refresh();
             if(!encoding->isAlive())
             {
                 result=false;
@@ -421,6 +413,7 @@
             {
                 lastVideoDts=dts;
             }
+            encoding->pushVideoFrame(len,0,lastVideoDts);
             muxerRescaleVideoTimeDts(&dts,lastVideoDts);
             muxerRescaleVideoTime(&pts);
             aprintf("[FF:V] RawDts:%lu Scaled Dts:%lu\n",rawDts,dts);
@@ -484,6 +477,7 @@
                     AVPacket pkt;
                     uint64_t rescaledDts;
                     rescaledDts=audioTrack->dts;
+                    encoding->pushAudioFrame(audioTrack->size);
                     muxerRescaleAudioTime(&rescaledDts,a->getInfo()->frequency);
                    //printf("[FF] A: Video frame  %d, audio Dts :%"LLU" size :%"LU" nbSample : %"LU" rescaled:%"LLU"\n",
                      //               written,audioTrack->dts,audioTrack->size,audioTrack->samples,rescaledDts);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp	2010-03-01 06:22:14 UTC (rev 5958)
@@ -69,13 +69,13 @@
 */
 bool     ADM_muxer::initUI(const char *title)
 {
- float f=(float)vStream->getAvgFps1000();
+        float f=(float)vStream->getAvgFps1000();
         f=1000./f;
         f*=1000000;
         videoIncrement=(uint64_t)f;  // Video increment in AVI-Tick
         videoDuration=vStream->getVideoDuration();
 
-        encoding=createWorking(title);
+        encoding=createEncoding(videoDuration);
         return true;
 }
 /**
@@ -84,12 +84,10 @@
         @return false if abort request, true if keep going
 */
 
-bool     ADM_muxer::updateUI(uint64_t time)
+bool     ADM_muxer::updateUI(void)
 {
             ADM_assert(encoding);
-            uint32_t  percent=(100*time)/videoDuration;
-            if(percent>100) percent=100;
-            encoding->update(percent);
+            encoding->refresh();
             if(!encoding->isAlive()) 
             {
                 return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h	2010-03-01 06:22:14 UTC (rev 5958)
@@ -45,14 +45,18 @@
                 virtual      ~DIA_encodingBase( );
                 
                 virtual void reset( void );
+protected:
+                virtual void setFps(uint32_t fps1000)=0;
+                virtual void setPercent(uint32_t percent)=0;
+                virtual void setAudioSize(uint64_t size)=0;
+                virtual void setTotalSize(uint64_t size)=0;
+                virtual void setFrameCount(uint32_t nb)=0;
+
+public:
                 virtual void setPhasis(const char *n)=0;
                 virtual void setVideoCodec(const char *n)=0;
                 virtual void setAudioCodec(const char *n)=0;
-                virtual void setFps(uint32_t fps1000)=0;
-                virtual void setPercent(uint32_t percent)=0;
                 virtual void setContainer(const char *container)=0;
-                virtual void setAudioSize(uint64_t size)=0;
-                virtual void setTotalSize(uint64_t size)=0;
                 virtual bool isAlive(void)=0;
 
                 virtual void pushVideoFrame(uint32_t size, uint32_t quant,uint64_t timeUs);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-01 06:22:14 UTC (rev 5958)
@@ -19,8 +19,11 @@
 
 #include <math.h>
 #define  ETA_SAMPLE_PERIOD 60000 //Use last n millis to calculate ETA
-#define  GUI_UPDATE_RATE 500    // Ms
+#define  GUI_UPDATE_RATE 1000    // Ms
 extern void UI_purge(void);
+/**
+    \fn DIA_encodingBase
+*/
 DIA_encodingBase::DIA_encodingBase( uint64_t duration )
 {
         _originalPriority=getpriority(PRIO_PROCESS, 0);
@@ -30,20 +33,19 @@
 #endif
         reset();
 }
+/**
+    \fn DIA_encodingBase
+*/
 
-void DIA_stop( void)
-{
-	printf("Stop request\n");
-
-}
-
-
 DIA_encodingBase::~DIA_encodingBase( )
 {
 #ifdef __WIN32
 	setpriority(PRIO_PROCESS, 0, _originalPriority);
 #endif
 }
+/**
+    \fn reset
+*/
 
 void DIA_encodingBase::reset(void)
 {
@@ -56,8 +58,11 @@
         _lastClock=0;
         _fps_average=0;
         clock.reset();
-
+        UI_purge();
 }
+/**
+    \fn pushVideoFrame
+*/
 
 void DIA_encodingBase::pushVideoFrame(uint32_t size, uint32_t quant,uint64_t timeUs)
 {
@@ -65,10 +70,18 @@
           _currentFrameCount++;
           _currentDurationUs=timeUs;
 }
+/**
+    \fn pushAudioFrame
+*/
+
 void DIA_encodingBase::pushAudioFrame(uint32_t size)
 {
           _audioSize+=size;
 }
+/**
+    \fn refresh
+*/
+
 void DIA_encodingBase::refresh(void)
 {
           uint32_t time=clock.getElapsedMS();
@@ -78,17 +91,23 @@
                 uint32_t deltaFrame=_currentFrameCount-_lastFrameCount;
                 if(deltaFrame)
                 {
-                    deltaFrame*=1000;
-                    deltaFrame/=deltaTime;
-                    _fps_average=((float)deltaFrame)/1000.;
-                    setFps(deltaFrame);
-                    float percent=_currentDurationUs/_totalDurationUs;
+                    //printf("**********************************DFrame=%d, DTime=%d\n",(int)deltaFrame,(int)deltaTime);
+                    _fps_average=((float)deltaFrame);
+                    _fps_average/=deltaTime;
+                    _fps_average*=1000;
+                    //printf("************** Fps:%d\n",(int)_fps_average);
+                    setFps(_fps_average);
+                    float percent=(float)_currentDurationUs/(float)_totalDurationUs;
                     if(percent>1.0) percent=1.0;
                     percent*=100;
                     setPercent((uint32_t)percent);
+                    setFrameCount(_currentFrameCount);
                 }
                 _nextUpdate=time+GUI_UPDATE_RATE;
                 setAudioSize(_audioSize);
+                setTotalSize(_audioSize+_videoSize);
+                _lastFrameCount=_currentFrameCount;
+                _lastClock=time;
                 UI_purge();
           }
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp	2010-03-01 06:22:14 UTC (rev 5958)
@@ -118,6 +118,7 @@
                             clk->setTimeUs(audioDts);
                         }
                     nb=writter.saveAudioFrame(audioIndex,audioSize,audioBuffer) ;
+                    encoding->pushAudioFrame(audioSize);
                     clk->advanceBySample(nbSample);
                     //printf("%u vs %u\n",audioDts/1000,(lastVideoDts+videoIncrement)/1000);
                     if(audioDts!=ADM_NO_PTS)
@@ -155,13 +156,15 @@
     lastVideoDts=dts;
 
     initUI("Saving Avi");
-    
+    encoding->setContainer("AVI/OpenDML");
 
     while(1)
     {
+            
             if(dts>aviTime+videoIncrement)
             {
                 writter.saveVideoFrame( 0, 0,videoBuffer); // Insert dummy video frame
+                encoding->pushVideoFrame(0,0,dts);
             }else
             {
                 if(!writter.saveVideoFrame( len, flags,videoBuffer))  // Put our real video
@@ -170,6 +173,7 @@
                         result=false;
                         goto abt;
                 }
+                encoding->pushVideoFrame(len,0,dts);
                 if(false==vStream->getPacket(&len, videoBuffer, bufSize,&pts,&dts,&flags)) goto abt;
                 if(dts==ADM_NO_PTS)
                 {
@@ -180,7 +184,7 @@
 
             fillAudio(aviTime+videoIncrement);    // and matching audio
 
-            if(updateUI(aviTime)==false)
+            if(updateUI()==false)
             {  
                 result=false;
                 goto abt;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h	2010-03-01 06:22:14 UTC (rev 5958)
@@ -23,7 +23,7 @@
 class muxerFlv : public muxerFFmpeg
 {
 protected:
-
+        const char *getContainerName(void) {return "Flv";};
 public:
                 muxerFlv();
         virtual ~muxerFlv();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h	2010-03-01 06:22:14 UTC (rev 5958)
@@ -24,6 +24,7 @@
 {
 protected:
         bool muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts);
+        const char *getContainerName(void) {return "Matroska";};
 public:
                 muxerMkv();
         virtual ~muxerMkv();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h	2010-03-01 06:22:14 UTC (rev 5958)
@@ -31,6 +31,7 @@
 class muxerMP4 : public muxerFFmpeg
 {
 protected:
+        const char *getContainerName(void) {return "Mp4";};
 public:
                 muxerMP4();
         virtual ~muxerMP4();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp	2010-03-01 06:22:14 UTC (rev 5958)
@@ -85,7 +85,7 @@
     {
         if(dts==ADM_NO_PTS)
             dts=lastVideoDts+videoIncrement;
-        if(updateUI(dts)==false)
+        if(updateUI()==false)
         {
             result=false;
             goto abt;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h	2010-03-01 06:22:14 UTC (rev 5958)
@@ -42,7 +42,7 @@
         bool verifyCompatibility(bool nonCompliantOk, uint32_t muxingType,
                                     ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a, 
                                     const char **er);
-
+        const char *getContainerName(void) {return "Mpeg PS";};
 public:
                 muxerffPS();
         virtual ~muxerffPS();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.h	2010-03-01 06:22:09 UTC (rev 5957)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.h	2010-03-01 06:22:14 UTC (rev 5958)
@@ -31,7 +31,7 @@
 protected:
         
         bool muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts);
-
+        const char *getContainerName(void) {return "Mpeg TS";};
 public:
                 muxerffTS();
         virtual ~muxerffTS();



From mean at mail.berlios.de  Mon Mar  1 07:22:33 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Mar 2010 07:22:33 +0100
Subject: [Avidemux-svn-commit] r5959 - in branches/avidemux_2.6_branch_mean:
	avidemux/qt4/ADM_userInterfaces/ADM_dialog
	avidemux_core/ADM_coreMuxer/include avidemux_core/ADM_coreMuxer/src
	avidemux_core/ADM_coreUI/include avidemux_core/ADM_coreUI/src
Message-ID: <201003010622.o216MXeC000241@sheep.berlios.de>

Author: mean
Date: 2010-03-01 07:22:32 +0100 (Mon, 01 Mar 2010)
New Revision: 5959

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerInternal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
Log:
[UI] More hooking of encoding dialog when saving

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2010-03-01 06:22:14 UTC (rev 5958)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2010-03-01 06:22:32 UTC (rev 5959)
@@ -278,7 +278,34 @@
           WRITE(labelAudioSize);
 
 }
+
 /**
+    \fn setAudioSizeIn(int size)
+    \brief display elapsed time since saving start
+*/
+void DIA_encodingQt4::setElapsedTimeMs(uint32_t nb)
+{
+          ADM_assert(window);
+          uint64_t mb=nb;
+          mb*=1000;
+          strcpy(string,ADM_us2plain(mb));
+          WRITE(labelElapsed);
+}
+
+/**
+    \fn setRemainingTimeMS
+    \brief display remaining time (ETA)
+*/
+void DIA_encodingQt4::setRemainingTimeMS(uint32_t nb)
+{
+          ADM_assert(window);
+          uint64_t mb=nb;
+          mb*=1000;
+          strcpy(string,ADM_us2plain(mb));
+          WRITE(labelETA);
+}
+
+/**
     \fn isAlive( void )
     \brief return 0 if the window was killed or cancel button press, 1 otherwisearchForward
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h	2010-03-01 06:22:14 UTC (rev 5958)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h	2010-03-01 06:22:32 UTC (rev 5959)
@@ -54,6 +54,8 @@
     void setPercent(uint32_t percent);
     void setFps(uint32_t fps);
     void setFrameCount(uint32_t nb);
+    void setElapsedTimeMs(uint32_t nb);
+    void setRemainingTimeMS(uint32_t nb);
 
 public:    
     void *WINDOW;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerInternal.h	2010-03-01 06:22:14 UTC (rev 5958)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerInternal.h	2010-03-01 06:22:32 UTC (rev 5959)
@@ -16,7 +16,7 @@
 #ifndef  ADM_muxerInternal_H
 #define  ADM_muxerInternal_H
 
-#define ADM_MUXER_API_VERSION 4
+#define ADM_MUXER_API_VERSION 5
 #include <stddef.h>
 #include "ADM_dynamicLoading.h"
 #include "ADM_muxer.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-03-01 06:22:14 UTC (rev 5958)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-03-01 06:22:32 UTC (rev 5959)
@@ -383,7 +383,7 @@
     AVRational *scale=&(video_st->codec->time_base);
     uint64_t videoDuration=vStream->getVideoDuration();
 
-    encoding=createEncoding(videoDuration);
+    initUI("Saving");
     encoding->setContainer(getContainerName());
     MuxAudioPacket audioPackets[nbAStreams];
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp	2010-03-01 06:22:14 UTC (rev 5958)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp	2010-03-01 06:22:32 UTC (rev 5959)
@@ -16,6 +16,8 @@
 #include "ADM_default.h"
 #include "ADM_muxerInternal.h"
 #include "ADM_muxerUtils.h"
+#include "fourcc.h"
+extern const char *getStrFromAudioCodec( uint32_t codec);
 /**
     \fn rescaleFps
     \brief Rescale fps to be accurate (i.e. 23.976 become 24000/1001)
@@ -76,6 +78,10 @@
         videoDuration=vStream->getVideoDuration();
 
         encoding=createEncoding(videoDuration);
+        // Set video stream etc...
+        encoding->setVideoCodec(fourCC::tostring(vStream->getFCC()));
+        if(!nbAStreams) encoding->setAudioCodec("None");
+                else    encoding->setAudioCodec(getStrFromAudioCodec(aStreams[0]->getInfo()->encoding));
         return true;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h	2010-03-01 06:22:14 UTC (rev 5958)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h	2010-03-01 06:22:32 UTC (rev 5959)
@@ -34,7 +34,9 @@
                 float     _fps_average;
                 uint32_t  _average_bitrate;
                 uint64_t  _totalDurationUs;
-                uint64_t  _currentDurationUs;
+                uint64_t  _currentDts;
+                uint64_t  _lastDts;
+                uint64_t  _remainingTimeUs;    // ERA
                 uint64_t  _totalSize;
                 uint64_t  _audioSize;
                 uint64_t  _videoSize;
@@ -51,6 +53,9 @@
                 virtual void setAudioSize(uint64_t size)=0;
                 virtual void setTotalSize(uint64_t size)=0;
                 virtual void setFrameCount(uint32_t nb)=0;
+                virtual void setElapsedTimeMs(uint32_t nb)=0;
+                virtual void setRemainingTimeMS(uint32_t nb)=0;
+            
 
 public:
                 virtual void setPhasis(const char *n)=0;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-01 06:22:14 UTC (rev 5958)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-01 06:22:32 UTC (rev 5959)
@@ -51,12 +51,15 @@
 {
         _lastFrameCount=0;
         _currentFrameCount=0;
+        _currentDts=0;
+        _lastDts=0;
         _totalSize=0;
         _audioSize=0;
         _videoSize=0;
         _nextUpdate=GUI_UPDATE_RATE;
         _lastClock=0;
         _fps_average=0;
+        _remainingTimeUs=0;
         clock.reset();
         UI_purge();
 }
@@ -68,7 +71,7 @@
 {
           _videoSize+=size;
           _currentFrameCount++;
-          _currentDurationUs=timeUs;
+          _currentDts=timeUs;
 }
 /**
     \fn pushAudioFrame
@@ -89,6 +92,7 @@
           {
                 uint32_t deltaTime=time-_lastClock;
                 uint32_t deltaFrame=_currentFrameCount-_lastFrameCount;
+                uint64_t deltaDts=_currentDts-_lastDts;
                 if(deltaFrame)
                 {
                     //printf("**********************************DFrame=%d, DTime=%d\n",(int)deltaFrame,(int)deltaTime);
@@ -97,16 +101,36 @@
                     _fps_average*=1000;
                     //printf("************** Fps:%d\n",(int)_fps_average);
                     setFps(_fps_average);
-                    float percent=(float)_currentDurationUs/(float)_totalDurationUs;
+                    float percent=(float)_currentDts/(float)_totalDurationUs;
                     if(percent>1.0) percent=1.0;
                     percent*=100;
                     setPercent((uint32_t)percent);
                     setFrameCount(_currentFrameCount);
+                    setElapsedTimeMs(time);
                 }
+                if(deltaDts )
+                {
+                    float dtsPerSec=deltaDts;
+                    dtsPerSec/=deltaTime;
+                    dtsPerSec/=1000.;  // dts advance per second
+                    float leftDts=_totalDurationUs-_currentDts;
+                    //printf("***************%u to encoding\n",(int)(leftDts/1000000));
+                    //printf("Advanc=%d ms/sec\n",(int)(dtsPerSec*1000));
+                    if(dtsPerSec>0.01)
+                    {
+                        leftDts=leftDts/dtsPerSec;
+                        
+                        leftDts/=1000.; // us -> ms
+                        //printf("***************%u s left\n",(int)(leftDts/1000));
+                        setRemainingTimeMS((uint32_t)leftDts);
+                    }
+                    
+                }
                 _nextUpdate=time+GUI_UPDATE_RATE;
                 setAudioSize(_audioSize);
                 setTotalSize(_audioSize+_videoSize);
                 _lastFrameCount=_currentFrameCount;
+                _lastDts=_currentDts;
                 _lastClock=time;
                 UI_purge();
           }



From mean at mail.berlios.de  Mon Mar  1 07:22:39 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Mar 2010 07:22:39 +0100
Subject: [Avidemux-svn-commit] r5960 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src
Message-ID: <201003010622.o216MdOx000445@sheep.berlios.de>

Author: mean
Date: 2010-03-01 07:22:39 +0100 (Mon, 01 Mar 2010)
New Revision: 5960

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
Log:
[filer] Dont use previous filter conf as default, but ours

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2010-03-01 06:22:32 UTC (rev 5959)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2010-03-01 06:22:39 UTC (rev 5960)
@@ -61,7 +61,7 @@
 FilterInfo  *ADM_coreVideoFilter::getInfo(void)
 {
     ADM_assert(previousFilter);
-    return previousFilter->getInfo();
+    return &info; //previousFilter->getInfo();
 }
 /**
     \fn goToTime



From mean at mail.berlios.de  Mon Mar  1 07:22:43 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Mar 2010 07:22:43 +0100
Subject: [Avidemux-svn-commit] r5961 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop
Message-ID: <201003010622.o216MhPx000536@sheep.berlios.de>

Author: mean
Date: 2010-03-01 07:22:42 +0100 (Mon, 01 Mar 2010)
New Revision: 5961

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp
Log:
[crop] Copy pts/... info also

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp	2010-03-01 06:22:39 UTC (rev 5960)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp	2010-03-01 06:22:42 UTC (rev 5961)
@@ -142,6 +142,8 @@
                         src2+=x;
                         dest+=line;
                 }	
+            //printf("Cropt:Dts = %"LLU"\n",image->Pts);
+            image->copyInfo(original);     
             return 1;
 }
 /**



From mean at mail.berlios.de  Mon Mar  1 19:43:45 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Mar 2010 19:43:45 +0100
Subject: [Avidemux-svn-commit] r5962 - in
	branches/avidemux_2.5_branch_gruntster: cmake
	cmake_compile_check plugins/ADM_audioEncoders/aften
Message-ID: <201003011843.o21Ihj5s013404@sheep.berlios.de>

Author: mean
Date: 2010-03-01 19:43:44 +0100 (Mon, 01 Mar 2010)
New Revision: 5962

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioEncoderLibs.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake
   branches/avidemux_2.5_branch_gruntster/cmake_compile_check/aften_check.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp
Log:
[Aften] Add support for aften svn as bundled by ubuntu + fix compilation flags for aften 0.8  and 0.8svn, probably still broken for 0.5/6/7

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioEncoderLibs.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioEncoderLibs.cmake	2010-03-01 06:22:42 UTC (rev 5961)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioEncoderLibs.cmake	2010-03-01 18:43:44 UTC (rev 5962)
@@ -18,19 +18,24 @@
 				AFTEN_TEST_COMPILE_RESULT
 				${CMAKE_BINARY_DIR}
 				"${AVIDEMUX_SOURCE_DIR}/cmake_compile_check/aften_check.cpp"
-				CMAKE_FLAGS "-DINCLUDE_DIRECTORIES=${AFTEN_INCLUDE_DIR}" "-DLINK_LIBRARIES=${AFTEN_LIBRARY_DIR}")
+				CMAKE_FLAGS "-DINCLUDE_DIRECTORIES=${AFTEN_INCLUDE_DIR}" "-DLINK_LIBRARIES:string=${AFTEN_LIBRARY_DIR}"
+                                 OUTPUT_VARIABLE AFTEN_OUTPUT
+                                )
 		ENDIF (NOT DEFINED AFTEN_TEST_RUN_RESULT)
-
-		IF (AFTEN_TEST_RUN_RESULT EQUAL 8)
+#                MESSAGE(STATUS ${AFTEN_TEST_COMPILE_RESULT} ${AFTEN_OUTPUT})
+		IF (AFTEN_TEST_RUN_RESULT EQUAL 99)
+			MESSAGE(STATUS "  version: 0.0.8svn")
+			SET(USE_AFTEN_08_SVN 1)
+		ELSEIF (AFTEN_TEST_RUN_RESULT EQUAL 8)
 			MESSAGE(STATUS "  version: 0.0.8")
 			SET(USE_AFTEN_08 1)
 		ELSEIF (AFTEN_TEST_RUN_RESULT EQUAL 7)
 			MESSAGE(STATUS "  version: 0.07")
 			SET(USE_AFTEN_07 1)
-		ELSE (AFTEN_TEST_RUN_RESULT EQUAL 8)
-			MESSAGE(STATUS "Warning: Unable to determine Aften version - support for Aften will be turned off")
+		ELSE (AFTEN_TEST_RUN_RESULT EQUAL 99)
+			MESSAGE(STATUS "Warning: Unable to determine Aften version - support for Aften will be turned off ${AFTEN_TEST_RUN_RESULT}")
 			SET(USE_AFTEN 0)
-		ENDIF (AFTEN_TEST_RUN_RESULT EQUAL 8)
+		ENDIF (AFTEN_TEST_RUN_RESULT EQUAL 99)
 	ENDIF (AFTEN_FOUND)
 ELSE (AFTEN)
 	MESSAGE("${MSG_DISABLE_OPTION}")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake	2010-03-01 06:22:42 UTC (rev 5961)
+++ branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake	2010-03-01 18:43:44 UTC (rev 5962)
@@ -36,6 +36,7 @@
 #cmakedefine USE_AFTEN
 #cmakedefine USE_AFTEN_07	// 0.07
 #cmakedefine USE_AFTEN_08	// 0.0.8
+#cmakedefine USE_AFTEN_08_SVN	// 0.0.8_svn
 
 #if ${CONFIG_HEADER_TYPE} == ADM_BUILD_GTK || ${CONFIG_HEADER_TYPE} == ADM_BUILD_QT4
 /* aRts detected */
@@ -107,4 +108,4 @@
 #define QT_TR_NOOP(String) translate (PACKAGE, String)
 // FIXME - end
 
-#endif
\ No newline at end of file
+#endif

Modified: branches/avidemux_2.5_branch_gruntster/cmake_compile_check/aften_check.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake_compile_check/aften_check.cpp	2010-03-01 06:22:42 UTC (rev 5961)
+++ branches/avidemux_2.5_branch_gruntster/cmake_compile_check/aften_check.cpp	2010-03-01 18:43:44 UTC (rev 5962)
@@ -1,3 +1,4 @@
+#include <stdio.h>
 #include <string.h>
 #include <aften/aften.h>
 
@@ -4,11 +5,13 @@
 int main(int argc, char **argv)
 {
 	const char* aftenVersion = aften_get_version();
-
+//        fprintf(stderr,"Aften version = %s\n",aftenVersion);
 	if (strcmp(aftenVersion, "0.07") == 0)
 		return 7;
 	else if (strcmp(aftenVersion, "0.0.8") == 0)
 		return 8;
+        else if (strcmp(aftenVersion, "SVN") == 0)
+                return 99;
 
 	return 0;
 }

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt	2010-03-01 06:22:42 UTC (rev 5961)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt	2010-03-01 18:43:44 UTC (rev 5962)
@@ -7,6 +7,12 @@
 	TARGET_LINK_LIBRARIES(ADM_ae_aften ${AFTEN_LIBRARY_DIR} ADM_core ADM_coreAudio ADM_coreUI)
 
 	ADD_TARGET_CFLAGS(ADM_ae_aften "-I${AFTEN_INCLUDE_DIR}")
+        if(USE_AFTEN_08_SVN)
+                ADD_DEFINITIONS(-DUSE_AFTEN_08_SVN)
+        endif(USE_AFTEN_08_SVN)
+        if(USE_AFTEN_08)
+                ADD_DEFINITIONS(-DUSE_AFTEN_08)
+        endif(USE_AFTEN_08)
 
 	INIT_AUDIO_ENCODER(ADM_ae_aften)
 	INSTALL_AUDIOENCODER(ADM_ae_aften)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp	2010-03-01 06:22:42 UTC (rev 5961)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp	2010-03-01 18:43:44 UTC (rev 5962)
@@ -183,7 +183,11 @@
 		aften_remap_wav_to_a52(ptr, 256*6, _wavheader->channels, A52_SAMPLE_FMT_FLT, _HANDLE->acmod);
 #endif
 
-        r=aften_encode_frame(_HANDLE, dest,(void *)ptr);
+        r=aften_encode_frame(_HANDLE, dest,(void *)ptr
+#ifdef USE_AFTEN_08_SVN
+            ,256*6
+#endif
+        );
         if(r<0)
         {
           printf("[Aften] Encoding error %d\n",r);



From mean at mail.berlios.de  Mon Mar  1 19:49:55 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Mar 2010 19:49:55 +0100
Subject: [Avidemux-svn-commit] r5963 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften
Message-ID: <201003011849.o21Intcr016914@sheep.berlios.de>

Author: mean
Date: 2010-03-01 19:49:54 +0100 (Mon, 01 Mar 2010)
New Revision: 5963

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp
Log:
[aften] Fix channel reordering, backport from 2.6, fixes #81, refs #60

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp	2010-03-01 18:43:44 UTC (rev 5962)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp	2010-03-01 18:49:54 UTC (rev 5963)
@@ -88,6 +88,33 @@
 #else
   _HANDLE->system.n_threads=1;
 #endif
+
+#define ADM_CH_(XX) CHTYP_##XX
+  switch(channels)
+  {
+    case 1:
+        outputChannelMapping[1] = ADM_CH_(FRONT_LEFT);
+        break;
+    case 2:
+        outputChannelMapping[0] = ADM_CH_(FRONT_LEFT);
+        outputChannelMapping[1] = ADM_CH_(FRONT_RIGHT);
+      break;
+    default :
+
+    CHANNEL_TYPE *f=outputChannelMapping;
+
+        *f++ = ADM_CH_(FRONT_LEFT);
+        *f++ = ADM_CH_(FRONT_CENTER);
+        *f++ = ADM_CH_(FRONT_RIGHT);
+
+        *f++ = ADM_CH_(REAR_LEFT);
+        *f++ = ADM_CH_(REAR_RIGHT);
+
+        *f++ = ADM_CH_(LFE);
+        break;
+  }
+
+
 };
 
 /**
@@ -176,13 +203,7 @@
         }
         ptr=(void *)&(tmpbuffer[tmphead]);
         ADM_assert(tmptail>=tmphead);
-
-#ifdef USE_AFTEN_05
-		aften_remap_wav_to_a52(ptr, 256*6, _wavheader->channels, A52_SAMPLE_FMT_FLT, _HANDLE->acmod, _HANDLE->lfe);
-#else
-		aften_remap_wav_to_a52(ptr, 256*6, _wavheader->channels, A52_SAMPLE_FMT_FLT, _HANDLE->acmod);
-#endif
-
+        reorderChannels(&(tmpbuffer[tmphead]),256*6,_incoming->getChannelMapping(),outputChannelMapping);
         r=aften_encode_frame(_HANDLE, dest,(void *)ptr
 #ifdef USE_AFTEN_08_SVN
             ,256*6



From mean at mail.berlios.de  Thu Mar  4 07:39:09 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 4 Mar 2010 07:39:09 +0100
Subject: [Avidemux-svn-commit] r5971 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	. yadif
Message-ID: <201003040639.o246d911018106@sheep.berlios.de>

Author: mean
Date: 2010-03-04 07:39:08 +0100 (Thu, 04 Mar 2010)
New Revision: 5971

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif_desc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
Log:
[filter] Add yadif (broken/uncomplete)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-03-04 06:39:07 UTC (rev 5970)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-03-04 06:39:08 UTC (rev 5971)
@@ -2,3 +2,4 @@
 ADD_SUBDIRECTORY(verticalFlip)
 ADD_SUBDIRECTORY(resize)
 ADD_SUBDIRECTORY(crop)
+ADD_SUBDIRECTORY(yadif)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif.conf	2010-03-04 06:39:07 UTC (rev 5970)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif.conf	2010-03-04 06:39:08 UTC (rev 5971)
@@ -0,0 +1,2 @@
+uint32_t:mode
+uint32_t:order

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif.h	2010-03-04 06:39:07 UTC (rev 5970)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif.h	2010-03-04 06:39:08 UTC (rev 5971)
@@ -0,0 +1,9 @@
+// Automatically generated, do not edit!
+#ifndef ADM_yadif_CONF_H
+#define ADM_yadif_CONF_H
+typedef struct {
+   uint32_t mode;
+   uint32_t order;
+}yadif;
+#endif //yadif
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif_desc.cpp	2010-03-04 06:39:07 UTC (rev 5970)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/yadif_desc.cpp	2010-03-04 06:39:08 UTC (rev 5971)
@@ -0,0 +1,6 @@
+// Automatically generated, do not edit!
+const ADM_paramList yadif_param[]={
+ {"mode",offsetof( yadif,mode),"uint32_t",ADM_param_uint32_t},
+ {"order",offsetof( yadif,order),"uint32_t",ADM_param_uint32_t},
+{NULL,0,NULL}
+};



From mean at mail.berlios.de  Thu Mar  4 07:39:07 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 4 Mar 2010 07:39:07 +0100
Subject: [Avidemux-svn-commit] r5970 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage:
	include src
Message-ID: <201003040639.o246d7Q2018079@sheep.berlios.de>

Author: mean
Date: 2010-03-04 07:39:07 +0100 (Thu, 04 Mar 2010)
New Revision: 5970

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_videoFilterCache.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_videoFilterCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt
Log:
[filterCache] Prep work for filterCache. Uncomplete/broken

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_videoFilterCache.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_videoFilterCache.h	2010-03-03 18:50:26 UTC (rev 5969)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_videoFilterCache.h	2010-03-04 06:39:07 UTC (rev 5970)
@@ -12,7 +12,10 @@
 
 #ifndef __ADM_CACHE__
 #define __ADM_CACHE__
-#include "ADM_videoFilter.h"
+#include "ADM_coreVideoFilter.h"
+/**
+    \struct videoCacheEntry
+*/
 typedef struct vidCacheEntry
 {
 		uint32_t 	frameNum;
@@ -21,23 +24,24 @@
 		uint32_t	lastUse;
 
 }vidCacheEntry;
-
+/**
+    \class VideoCache
+*/
 class VideoCache
 {
 	private:
-		vidCacheEntry	*entry;
-		ADV_Info 	info;
-		uint32_t	counter;
-		uint32_t 	nbEntry;
+		vidCacheEntry	    *entry;
+		uint32_t	        counter;
+		uint32_t 	        nbEntry;
+		FilterInfo           info;
+		ADM_coreVideoFilter *incoming;
 		
-		AVDMGenericVideoStream *incoming;
 		
+		int32_t 	        searchFrame( uint32_t frame);
+		int32_t 	        searchPtr( ADMImage *ptr);
 		
-		int32_t 	searchFrame( uint32_t frame);
-		int32_t 	searchPtr( ADMImage *ptr);
-		
 	public:
-		VideoCache(uint32_t nb,AVDMGenericVideoStream *in);
+		VideoCache(uint32_t nb,ADM_coreVideoFilter *in);
 		~VideoCache(void);
 		
 		ADMImage *getImage(uint32_t frame);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_videoFilterCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_videoFilterCache.cpp	2010-03-03 18:50:26 UTC (rev 5969)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_videoFilterCache.cpp	2010-03-04 06:39:07 UTC (rev 5970)
@@ -1,26 +1,29 @@
-//
-// C++ Implementation: ADM_cache
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
+/** *************************************************************************
+        \file                  ADM_videoFilterCache.cpp
+        \brief Cache/buffer for video filter
+		\author (c) 2008/2010 Mean, fixounet at free.fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
 #include "ADM_default.h"
+#include "ADM_videoFilterCache.h"
 
-//#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_videoFilter.h"
-
 #if 1
 #define aprintf(...) {}
 #else
 #define aprintf printf
 #endif
 
-VideoCache::VideoCache(uint32_t nb,AVDMGenericVideoStream *in)
+VideoCache::VideoCache(uint32_t nb,ADM_coreVideoFilter *in)
 {
 uint32_t sz;
 	nbEntry=nb;
@@ -34,7 +37,6 @@
 		entry[i].frameBuffer	=new ADMImage(info.width,info.height);	
 		entry[i].frameNum	=0xffff0000;
 		entry[i].frameLock	=0;
-		entry[i].lastUse	=0xffff0000;
 	}	
 	counter=0;
 }
@@ -96,7 +98,9 @@
 	return 1;
 
 }
-//_____________________________________________
+/**
+    \fn getImage
+*/
 ADMImage *VideoCache::getImage(uint32_t frame)
 {
 int32_t i;
@@ -138,7 +142,7 @@
 	// Target is the new cache we will use
 
 	ptr=entry[target].frameBuffer;
-	if(!incoming->getFrameNumberNoAlloc(frame,&len,ptr,&flags)) return NULL;
+    if(!incoming->getNextFrame(entry[target].frameBuffer)) return NULL;
 	// Update LRU info
 	entry[target].frameLock++;
 	entry[target].frameNum=frame;
@@ -147,4 +151,4 @@
 	return ptr;
 	
 }
-
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt	2010-03-03 18:50:26 UTC (rev 5969)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt	2010-03-04 06:39:07 UTC (rev 5970)
@@ -1,6 +1,6 @@
 SET(ADM_coreImage_SRCS 
 #        ADM_videoFilter.cpp  
-        #ADM_videoFilterCache.cpp
+        ADM_videoFilterCache.cpp
         ADM_image.cpp  
         ADM_imageUtils.cpp
         ADM_imageResizer.cpp



From mean at mail.berlios.de  Thu Mar  4 07:39:10 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 4 Mar 2010 07:39:10 +0100
Subject: [Avidemux-svn-commit] r5972 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif
Message-ID: <201003040639.o246dA51018138@sheep.berlios.de>

Author: mean
Date: 2010-03-04 07:39:10 +0100 (Thu, 04 Mar 2010)
New Revision: 5972

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif_asm.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/CMakeLists.txt
Log:
[filter] Add yadif (broken/uncomplete), part 2

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp	2010-03-04 06:39:08 UTC (rev 5971)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp	2010-03-04 06:39:10 UTC (rev 5972)
@@ -0,0 +1,387 @@
+/*
+	Yadif C-plugin for Avisynth 2.5 - Yet Another DeInterlacing Filter
+	Copyright (C)2007 Alexander G. Balakhnin aka Fizick  http://avisynth.org.ru
+    Port of YADIF filter from MPlayer
+	Copyright (C) 2006 Michael Niedermayer <michaelni at gmx.at>
+
+    This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+    Avisynth_C plugin
+	Assembler optimized for GNU C compiler
+
+*/
+/*
+  Ported to avidemux by mean
+  Same license as original (?GPL)
+*/
+
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "ADM_videoFilterCache.h"
+#include "DIA_factory.h"
+#include "yadif.h"
+#include "yadif_desc.cpp"
+//************************************************
+#define MIN(a,b) ((a) > (b) ? (b) : (a))
+#define MAX(a,b) ((a) < (b) ? (b) : (a))
+#define ABS(a) ((a) > 0 ? (a) : (-(a)))
+
+#define MIN3(a,b,c) MIN(MIN(a,b),c)
+#define MAX3(a,b,c) MAX(MAX(a,b),c)
+
+//===========================================================================//
+#ifdef ADM_CPU_X86
+extern "C"
+{
+void filter_line_mmx2(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity);
+}
+#endif
+//
+/**
+    \class yadifFilter
+*/
+class yadifFilter : public  ADM_coreVideoFilter
+{
+protected:
+                    ADMImage    *original;
+                    yadif       configuration;
+                    void        updateInfo(void);
+                    VideoCache  *vidCache;
+public:
+                    yadifFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                    ~yadifFilter();
+
+       virtual const char   *getConfiguration(void);                 /// Return  current configuration as a human readable string
+       virtual bool         getNextFrame(ADMImage *image);           /// Return the next image
+	   virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+       virtual bool         configure(void) ;                        /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   yadifFilter,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_INTERLACING,            // Category
+                        "yadif",            // internal name (must be uniq!)
+                        "Yadif",            // Display name
+                        "Yadif, port of avisynth version (c) Fizick." // Description
+                    );
+
+//
+static void filter_plane(int mode, uint8_t *dst, int dst_stride, const uint8_t *prev0, const uint8_t *cur0, const uint8_t *next0, int refs, int w, int h, int parity, int tff, int mmx);
+
+
+/**
+    \fn constructor
+*/
+yadifFilter::yadifFilter(ADM_coreVideoFilter *in, CONFcouple *setup): ADM_coreVideoFilter(in,setup)
+{
+    original=new ADMImage(in->getInfo()->width,in->getInfo()->height);
+    if(!setup || !ADM_paramLoad(setup,yadif_param,&configuration))
+    {
+        // Default value
+        configuration.mode=0;
+        configuration.order=1;
+    }
+    vidCache = new VideoCache (10, in);
+    updateInfo();
+}
+/**
+    \fn destructor
+*/
+yadifFilter::~yadifFilter()
+{
+        delete  original;
+        original=NULL;
+       
+        delete vidCache;
+        vidCache = NULL;
+}
+/**
+    \fn updateInfo
+*/
+
+void yadifFilter::updateInfo(void)
+{
+   memcpy(&info,previousFilter->getInfo(),sizeof(info)); 
+  if(configuration.mode &1 ) // Bob
+  {
+    info.totalDuration*=2;
+    info.frameIncrement/=2;
+  }
+}
+/**
+    \fn updateInfo
+*/
+bool yadifFilter::configure( void) 
+{
+    
+     diaMenuEntry tMode[]={
+                             {0,      QT_TR_NOOP("Temporal & spatial check"),NULL},
+                             {1,   QT_TR_NOOP("Bob, temporal & spatial check"),NULL},
+                             {2,      QT_TR_NOOP("Skip spatial temporal check"),NULL},
+                             {3,  QT_TR_NOOP("Bob, skip spatial temporal check"),NULL}
+          };
+     diaMenuEntry tOrder[]={
+                             {0,      QT_TR_NOOP("Bottom field first"),NULL},
+                             {1,   QT_TR_NOOP("Top field first"),NULL}
+          };
+  
+     diaElemMenu mMode(&(configuration.mode),   QT_TR_NOOP("_Mode:"), 4,tMode);
+     diaElemMenu morder(&(configuration.order),   QT_TR_NOOP("_Order:"), 2,tOrder);
+     
+     diaElem *elems[]={&mMode,&morder};
+     
+     if(diaFactoryRun(QT_TR_NOOP("yadif"),sizeof(elems)/sizeof(diaElem *),elems))
+     {
+        updateInfo();
+        return 1;
+     }
+     return 0;
+}
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         yadifFilter::getCoupledConf(CONFcouple **couples)
+{
+    return ADM_paramSave(couples, yadif_param,&configuration);
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *yadifFilter::getConfiguration(void)
+{
+    static char conf[80];
+    conf[0]=0;
+    snprintf(conf,80,"yadif : mode=%d, order=%d\n",
+                (int)configuration.mode, (int)configuration.order);
+    return conf;
+}
+
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+bool yadifFilter::getNextFrame(ADMImage *image)
+{
+#if 0
+        int mode;
+        int parity;
+        int tff;
+        int iplane;
+        int cpu;
+        int n;
+        ADMImage *src, *dst, * prev, *next;
+
+    
+        mode = configuration.mode;
+
+        if (mode & 1) 
+                n = (frame>>1); // bob
+        else
+                n = frame;
+
+        src = vidCache->getImage(n);
+  // Request frame 'n' from the child (source) clip.
+
+        if (n>0)
+                prev =  vidCache->getImage( n-1); // get previous frame
+        else
+                prev= vidCache->getImage(0); // get very first frame
+
+        if (n< _in->getInfo()->nb_frames-1)
+                next = vidCache->getImage( n+1); // get next frame
+        else
+                next = vidCache->getImage( _in->getInfo()->nb_frames-1); // get last frame
+
+        dst = data;
+        
+        if(!prev || !src || !next)
+        {
+            printf("Failed to read frame for frame %u\n",frame);
+            vidCache->unlockAll();
+            return 0;
+        }
+        
+  // Construct a frame based on the information of the current frame
+  // contained in the "vi" struct.
+#if 0 //MEANX
+        if (configuration.order == -1)
+//		tff = avs_is_tff(&p->vi) == 0 ? 0 : 1; // 0 or 1
+                tff = avs_get_parity(p->child, n) ? 1 : 0; // 0 or 1
+        else
+#endif
+                tff = configuration.order;	
+        
+        parity = (mode & 1) ? (frame & 1) ^ (1^tff) : (tff ^ 1);  // 0 or 1
+
+      //MEANX  cpu = avs_get_cpu_flags(p->env);
+
+        for (iplane = 0; iplane<3; iplane++)
+        {
+                ADM_PLANE plane = (iplane==0) ? PLANAR_Y : (iplane==1) ? PLANAR_U : PLANAR_V;
+
+                const unsigned char* srcp = src->GetWritePtr(plane);
+          // Request a Read pointer from the current source frame
+
+                const unsigned char* prevp0 = prev->GetWritePtr( plane);
+                unsigned char* prevp = (unsigned char*) prevp0; // with same pitch
+          // Request a Read pointer from the prev source frame.
+
+                const unsigned char* nextp0 = next->GetWritePtr( plane);
+                unsigned char* nextp = (unsigned char*) nextp0; // with same pitch
+          // Request a Read pointer from the next source frame.
+
+                unsigned char* dstp = dst->GetWritePtr( plane);
+                // Request a Write pointer from the newly created destination image.
+          // You can request a writepointer to images that have just been
+
+                const int dst_pitch = dst->GetPitch( plane);
+          // Requests pitch (length of a line) of the destination image.
+          // For more information on pitch see: http://www.avisynth.org/index.php?page=WorkingWithImages
+                // (short version - pitch is always equal to or greater than width to allow for seriously fast assembly code)
+
+                const int width =dst->GetPitch( plane);
+          // Requests rowsize (number of used bytes in a line.
+          // See the link above for more information.
+
+                const int height = dst->GetHeight( plane);
+          // Requests the height of the destination image.
+
+                const int src_pitch = src->GetPitch(plane);
+                const int prev_pitch = prev->GetPitch(plane);
+                const int next_pitch = next->GetPitch(plane);
+
+                // in v.0.1-0.3  all source pitches are  assumed equal (for simplicity)
+                                // consider other (rare) case
+                if (prev_pitch != src_pitch)
+                {
+                    prevp = (unsigned char *)ADM_alloc(height*src_pitch);
+                    int h;
+                    for (h=0; h<0; h++)
+                      memcpy(prevp+h*src_pitch, prevp0+h*prev_pitch, width);
+                }
+                    
+                if (next_pitch != src_pitch)
+                {
+                    nextp = (unsigned char *)ADM_alloc(height*src_pitch);
+                    int h;
+                    for (h=0; h<0; h++)
+                      memcpy(nextp+h*src_pitch, nextp0+h*next_pitch, width);
+                }
+                    
+                filter_plane(mode, dstp, dst_pitch, prevp, srcp, nextp, src_pitch, width, height, parity, tff, 0);
+                if (prev_pitch != src_pitch)
+                        ADM_dealloc(prevp);
+                if (next_pitch != src_pitch)
+                        ADM_dealloc(nextp);
+        }
+       vidCache->unlockAll();
+#endif
+      return 1;
+}
+//****************
+
+static void filter_line_c(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity){
+    int x;
+    const uint8_t *prev2= parity ? prev : cur ;
+    const uint8_t *next2= parity ? cur  : next;
+    for(x=0; x<w; x++){
+        int c= cur[-refs];
+        int d= (prev2[0] + next2[0])>>1;
+        int e= cur[+refs];
+        int temporal_diff0= ABS(prev2[0] - next2[0]);
+        int temporal_diff1=( ABS(prev[-refs] - c) + ABS(prev[+refs] - e) )>>1;
+        int temporal_diff2=( ABS(next[-refs] - c) + ABS(next[+refs] - e) )>>1;
+        int diff= MAX3(temporal_diff0>>1, temporal_diff1, temporal_diff2);
+        int spatial_pred= (c+e)>>1;
+        int spatial_score= ABS(cur[-refs-1] - cur[+refs-1]) + ABS(c-e)
+                         + ABS(cur[-refs+1] - cur[+refs+1]) - 1;
+
+#define CHECK(j)\
+    {   int score= ABS(cur[-refs-1+ j] - cur[+refs-1- j])\
+                 + ABS(cur[-refs  + j] - cur[+refs  - j])\
+                 + ABS(cur[-refs+1+ j] - cur[+refs+1- j]);\
+        if(score < spatial_score){\
+            spatial_score= score;\
+            spatial_pred= (cur[-refs  + j] + cur[+refs  - j])>>1;\
+
+        CHECK(-1) CHECK(-2) }} }}
+        CHECK( 1) CHECK( 2) }} }}
+
+        if(mode<2){
+            int b= (prev2[-2*refs] + next2[-2*refs])>>1;
+            int f= (prev2[+2*refs] + next2[+2*refs])>>1;
+#if 0
+            int a= cur[-3*refs];
+            int g= cur[+3*refs];
+            int max= MAX3(d-e, d-c, MIN3(MAX(b-c,f-e),MAX(b-c,b-a),MAX(f-g,f-e)) );
+            int min= MIN3(d-e, d-c, MAX3(MIN(b-c,f-e),MIN(b-c,b-a),MIN(f-g,f-e)) );
+#else
+            int max= MAX3(d-e, d-c, MIN(b-c, f-e));
+            int min= MIN3(d-e, d-c, MAX(b-c, f-e));
+#endif
+
+            diff= MAX3(diff, min, -max);
+        }
+
+        if(spatial_pred > d + diff)
+           spatial_pred = d + diff;
+        else if(spatial_pred < d - diff)
+           spatial_pred = d - diff;
+
+        dst[0] = spatial_pred;
+
+        dst++;
+        cur++;
+        prev++;
+        next++;
+        prev2++;
+        next2++;
+    }
+}
+
+void filter_plane(int mode, uint8_t *dst, int dst_stride, const uint8_t *prev0, const uint8_t *cur0, const uint8_t *next0, int refs, int w, int h, int parity, int tff, int mmx)
+{
+void (*filter_line)(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity);
+	int y;
+	filter_line = filter_line_c;
+#ifdef ADM_CPU_X86
+	if (CpuCaps::hasMMXEXT()) 
+		filter_line = filter_line_mmx2;
+#endif
+
+        memcpy(dst, cur0, w);
+        memcpy(dst + dst_stride, cur0 + refs, w);
+        for(y=2; y<h-1; y++){
+            if(((y ^ parity) & 1)){
+                const uint8_t *prev= prev0 + y*refs;
+                const uint8_t *cur = cur0 + y*refs;
+                const uint8_t *next= next0 + y*refs;
+                uint8_t *dst2= dst + y*dst_stride;
+                filter_line(mode, dst2, prev, cur, next, w, refs, (parity ^ tff));
+            }else{
+                memcpy(dst + y*dst_stride, cur0 + y*refs, w);
+            }
+        }
+        memcpy(dst + (h-1)*dst_stride, cur0 + (h-1)*refs, w);
+
+#ifdef ADM_CPU_X86
+	if (CpuCaps::hasMMXEXT()) 
+		asm volatile("emms");
+#endif
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif_asm.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif_asm.c	2010-03-04 06:39:08 UTC (rev 5971)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif_asm.c	2010-03-04 06:39:10 UTC (rev 5972)
@@ -0,0 +1,226 @@
+#include <stdlib.h>
+#include <inttypes.h>
+
+#include "ADM_default.h"
+
+#ifdef ADM_CPU_X86
+#ifdef ADM_CPU_64BIT
+typedef int64_t x86_reg;
+#else
+typedef int32_t x86_reg;
+#endif
+
+#define LOAD4(mem,dst) \
+            "movd      "mem", "#dst" \n\t"\
+            "punpcklbw %%mm7, "#dst" \n\t"
+
+#define PABS(tmp,dst) \
+            "pxor     "#tmp", "#tmp" \n\t"\
+            "psubw    "#dst", "#tmp" \n\t"\
+            "pmaxsw   "#tmp", "#dst" \n\t"
+
+#define CHECK(pj,mj) \
+            "movq "#pj"(%[cur],%[mrefs]), %%mm2 \n\t" /* cur[x-refs-1+j] */\
+            "movq "#mj"(%[cur],%[prefs]), %%mm3 \n\t" /* cur[x+refs-1-j] */\
+            "movq      %%mm2, %%mm4 \n\t"\
+            "movq      %%mm2, %%mm5 \n\t"\
+            "pxor      %%mm3, %%mm4 \n\t"\
+            "pavgb     %%mm3, %%mm5 \n\t"\
+            "pand     %[pb1], %%mm4 \n\t"\
+            "psubusb   %%mm4, %%mm5 \n\t"\
+            "psrlq     $8,    %%mm5 \n\t"\
+            "punpcklbw %%mm7, %%mm5 \n\t" /* (cur[x-refs+j] + cur[x+refs-j])>>1 */\
+            "movq      %%mm2, %%mm4 \n\t"\
+            "psubusb   %%mm3, %%mm2 \n\t"\
+            "psubusb   %%mm4, %%mm3 \n\t"\
+            "pmaxub    %%mm3, %%mm2 \n\t"\
+            "movq      %%mm2, %%mm3 \n\t"\
+            "movq      %%mm2, %%mm4 \n\t" /* ABS(cur[x-refs-1+j] - cur[x+refs-1-j]) */\
+            "psrlq      $8,   %%mm3 \n\t" /* ABS(cur[x-refs  +j] - cur[x+refs  -j]) */\
+            "psrlq     $16,   %%mm4 \n\t" /* ABS(cur[x-refs+1+j] - cur[x+refs+1-j]) */\
+            "punpcklbw %%mm7, %%mm2 \n\t"\
+            "punpcklbw %%mm7, %%mm3 \n\t"\
+            "punpcklbw %%mm7, %%mm4 \n\t"\
+            "paddw     %%mm3, %%mm2 \n\t"\
+            "paddw     %%mm4, %%mm2 \n\t" /* score */
+
+#define CHECK1 \
+            "movq      %%mm0, %%mm3 \n\t"\
+            "pcmpgtw   %%mm2, %%mm3 \n\t" /* if(score < spatial_score) */\
+            "pminsw    %%mm2, %%mm0 \n\t" /* spatial_score= score; */\
+            "movq      %%mm3, %%mm6 \n\t"\
+            "pand      %%mm3, %%mm5 \n\t"\
+            "pandn     %%mm1, %%mm3 \n\t"\
+            "por       %%mm5, %%mm3 \n\t"\
+            "movq      %%mm3, %%mm1 \n\t" /* spatial_pred= (cur[x-refs+j] + cur[x+refs-j])>>1; */
+
+#define CHECK2 /* pretend not to have checked dir=2 if dir=1 was bad.\
+                  hurts both quality and speed, but matches the C version. */\
+            "paddw    %[pw1], %%mm6 \n\t"\
+            "psllw     $14,   %%mm6 \n\t"\
+            "paddsw    %%mm6, %%mm2 \n\t"\
+            "movq      %%mm0, %%mm3 \n\t"\
+            "pcmpgtw   %%mm2, %%mm3 \n\t"\
+            "pminsw    %%mm2, %%mm0 \n\t"\
+            "pand      %%mm3, %%mm5 \n\t"\
+            "pandn     %%mm1, %%mm3 \n\t"\
+            "por       %%mm5, %%mm3 \n\t"\
+            "movq      %%mm3, %%mm1 \n\t"
+
+void filter_line_mmx2(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity){
+    static const uint64_t pw_1 = 0x0001000100010001ULL;
+    static const uint64_t pb_1 = 0x0101010101010101ULL;
+//    const int mode = p->mode;
+    uint64_t tmp0, tmp1, tmp2, tmp3;
+    int x;
+
+#define FILTER\
+    for(x=0; x<w; x+=4){\
+        asm volatile(\
+            "pxor      %%mm7, %%mm7 \n\t"\
+            LOAD4("(%[cur],%[mrefs])", %%mm0) /* c = cur[x-refs] */\
+            LOAD4("(%[cur],%[prefs])", %%mm1) /* e = cur[x+refs] */\
+            LOAD4("(%["prev2"])", %%mm2) /* prev2[x] */\
+            LOAD4("(%["next2"])", %%mm3) /* next2[x] */\
+            "movq      %%mm3, %%mm4 \n\t"\
+            "paddw     %%mm2, %%mm3 \n\t"\
+            "psraw     $1,    %%mm3 \n\t" /* d = (prev2[x] + next2[x])>>1 */\
+            "movq      %%mm0, %[tmp0] \n\t" /* c */\
+            "movq      %%mm3, %[tmp1] \n\t" /* d */\
+            "movq      %%mm1, %[tmp2] \n\t" /* e */\
+            "psubw     %%mm4, %%mm2 \n\t"\
+            PABS(      %%mm4, %%mm2) /* temporal_diff0 */\
+            LOAD4("(%[prev],%[mrefs])", %%mm3) /* prev[x-refs] */\
+            LOAD4("(%[prev],%[prefs])", %%mm4) /* prev[x+refs] */\
+            "psubw     %%mm0, %%mm3 \n\t"\
+            "psubw     %%mm1, %%mm4 \n\t"\
+            PABS(      %%mm5, %%mm3)\
+            PABS(      %%mm5, %%mm4)\
+            "paddw     %%mm4, %%mm3 \n\t" /* temporal_diff1 */\
+            "psrlw     $1,    %%mm2 \n\t"\
+            "psrlw     $1,    %%mm3 \n\t"\
+            "pmaxsw    %%mm3, %%mm2 \n\t"\
+            LOAD4("(%[next],%[mrefs])", %%mm3) /* next[x-refs] */\
+            LOAD4("(%[next],%[prefs])", %%mm4) /* next[x+refs] */\
+            "psubw     %%mm0, %%mm3 \n\t"\
+            "psubw     %%mm1, %%mm4 \n\t"\
+            PABS(      %%mm5, %%mm3)\
+            PABS(      %%mm5, %%mm4)\
+            "paddw     %%mm4, %%mm3 \n\t" /* temporal_diff2 */\
+            "psrlw     $1,    %%mm3 \n\t"\
+            "pmaxsw    %%mm3, %%mm2 \n\t"\
+            "movq      %%mm2, %[tmp3] \n\t" /* diff */\
+\
+            "paddw     %%mm0, %%mm1 \n\t"\
+            "paddw     %%mm0, %%mm0 \n\t"\
+            "psubw     %%mm1, %%mm0 \n\t"\
+            "psrlw     $1,    %%mm1 \n\t" /* spatial_pred */\
+            PABS(      %%mm2, %%mm0)      /* ABS(c-e) */\
+\
+            "movq -1(%[cur],%[mrefs]), %%mm2 \n\t" /* cur[x-refs-1] */\
+            "movq -1(%[cur],%[prefs]), %%mm3 \n\t" /* cur[x+refs-1] */\
+            "movq      %%mm2, %%mm4 \n\t"\
+            "psubusb   %%mm3, %%mm2 \n\t"\
+            "psubusb   %%mm4, %%mm3 \n\t"\
+            "pmaxub    %%mm3, %%mm2 \n\t"\
+            "pshufw $9,%%mm2, %%mm3 \n\t"\
+            "punpcklbw %%mm7, %%mm2 \n\t" /* ABS(cur[x-refs-1] - cur[x+refs-1]) */\
+            "punpcklbw %%mm7, %%mm3 \n\t" /* ABS(cur[x-refs+1] - cur[x+refs+1]) */\
+            "paddw     %%mm2, %%mm0 \n\t"\
+            "paddw     %%mm3, %%mm0 \n\t"\
+            "psubw    %[pw1], %%mm0 \n\t" /* spatial_score */\
+\
+            CHECK(-2,0)\
+            CHECK1\
+            CHECK(-3,1)\
+            CHECK2\
+            CHECK(0,-2)\
+            CHECK1\
+            CHECK(1,-3)\
+            CHECK2\
+\
+            /* if(p->mode<2) ... */\
+            "movq    %[tmp3], %%mm6 \n\t" /* diff */\
+            "cmp       $2, %[mode] \n\t"\
+            "jge       1f \n\t"\
+            LOAD4("(%["prev2"],%[mrefs],2)", %%mm2) /* prev2[x-2*refs] */\
+            LOAD4("(%["next2"],%[mrefs],2)", %%mm4) /* next2[x-2*refs] */\
+            LOAD4("(%["prev2"],%[prefs],2)", %%mm3) /* prev2[x+2*refs] */\
+            LOAD4("(%["next2"],%[prefs],2)", %%mm5) /* next2[x+2*refs] */\
+            "paddw     %%mm4, %%mm2 \n\t"\
+            "paddw     %%mm5, %%mm3 \n\t"\
+            "psrlw     $1,    %%mm2 \n\t" /* b */\
+            "psrlw     $1,    %%mm3 \n\t" /* f */\
+            "movq    %[tmp0], %%mm4 \n\t" /* c */\
+            "movq    %[tmp1], %%mm5 \n\t" /* d */\
+            "movq    %[tmp2], %%mm7 \n\t" /* e */\
+            "psubw     %%mm4, %%mm2 \n\t" /* b-c */\
+            "psubw     %%mm7, %%mm3 \n\t" /* f-e */\
+            "movq      %%mm5, %%mm0 \n\t"\
+            "psubw     %%mm4, %%mm5 \n\t" /* d-c */\
+            "psubw     %%mm7, %%mm0 \n\t" /* d-e */\
+            "movq      %%mm2, %%mm4 \n\t"\
+            "pminsw    %%mm3, %%mm2 \n\t"\
+            "pmaxsw    %%mm4, %%mm3 \n\t"\
+            "pmaxsw    %%mm5, %%mm2 \n\t"\
+            "pminsw    %%mm5, %%mm3 \n\t"\
+            "pmaxsw    %%mm0, %%mm2 \n\t" /* max */\
+            "pminsw    %%mm0, %%mm3 \n\t" /* min */\
+            "pxor      %%mm4, %%mm4 \n\t"\
+            "pmaxsw    %%mm3, %%mm6 \n\t"\
+            "psubw     %%mm2, %%mm4 \n\t" /* -max */\
+            "pmaxsw    %%mm4, %%mm6 \n\t" /* diff= MAX3(diff, min, -max); */\
+            "1: \n\t"\
+\
+            "movq    %[tmp1], %%mm2 \n\t" /* d */\
+            "movq      %%mm2, %%mm3 \n\t"\
+            "psubw     %%mm6, %%mm2 \n\t" /* d-diff */\
+            "paddw     %%mm6, %%mm3 \n\t" /* d+diff */\
+            "pmaxsw    %%mm2, %%mm1 \n\t"\
+            "pminsw    %%mm3, %%mm1 \n\t" /* d = clip(spatial_pred, d-diff, d+diff); */\
+            "packuswb  %%mm1, %%mm1 \n\t"\
+\
+            :[tmp0]"=m"(tmp0),\
+             [tmp1]"=m"(tmp1),\
+             [tmp2]"=m"(tmp2),\
+             [tmp3]"=m"(tmp3)\
+            :[prev] "r"(prev),\
+             [cur]  "r"(cur),\
+             [next] "r"(next),\
+             [prefs]"r"((x86_reg)refs),\
+             [mrefs]"r"((x86_reg)-refs),\
+             [pw1]  "m"(pw_1),\
+             [pb1]  "m"(pb_1),\
+             [mode] "g"(mode)\
+        );\
+        asm volatile("movd %%mm1, %0" :"=m"(*dst));\
+        dst += 4;\
+        prev+= 4;\
+        cur += 4;\
+        next+= 4;\
+    }
+
+    if(parity){
+#define prev2 "prev"
+#define next2 "cur"
+        FILTER
+#undef prev2
+#undef next2
+    }else{
+#define prev2 "cur"
+#define next2 "next"
+        FILTER
+#undef prev2
+#undef next2
+    }
+}
+#undef LOAD4
+#undef PABS
+#undef CHECK
+#undef CHECK1
+#undef CHECK2
+#undef FILTER
+#endif
+
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/CMakeLists.txt	2010-03-04 06:39:08 UTC (rev 5971)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/CMakeLists.txt	2010-03-04 06:39:10 UTC (rev 5972)
@@ -0,0 +1,8 @@
+INCLUDE(vf_plugin)
+
+SET(ADM_vf_yadif_SRCS ADM_vidYadif.cpp ADM_vidYadif_asm.c)
+
+ADD_VIDEO_FILTER(ADM_vf_yadif ${ADM_vf_yadif_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_yadif)
+INSTALL_VIDEO_FILTER(ADM_vf_yadif)



From mean at mail.berlios.de  Wed Mar  3 19:50:26 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 3 Mar 2010 19:50:26 +0100
Subject: [Avidemux-svn-commit] r5969 -
	branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_dialog
Message-ID: <201003031850.o23IoQJ4029104@sheep.berlios.de>

Author: mean
Date: 2010-03-03 19:50:26 +0100 (Wed, 03 Mar 2010)
New Revision: 5969

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_dialog/DIA_none.cpp
Log:
[Cli] Move ui_purge to core_ui

Modified: branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_dialog/DIA_none.cpp	2010-03-03 18:50:25 UTC (rev 5968)
+++ branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_userInterfaces/ADM_dialog/DIA_none.cpp	2010-03-03 18:50:26 UTC (rev 5969)
@@ -114,7 +114,6 @@
 static const UI_FUNCTIONS_T UI_Hooks=
     {
         ADM_RENDER_API_VERSION_NUMBER,
-        UI_purge,
         UI_getWindowInfo,
         UI_updateDrawWindowSize,
         UI_rgbDraw,



From mean at mail.berlios.de  Wed Mar  3 19:50:25 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 3 Mar 2010 19:50:25 +0100
Subject: [Avidemux-svn-commit] r5968 - in
	branches/avidemux_2.6_branch_mean/avidemux/gtk: ADM_UIs/src
	ADM_userInterfaces/ADM_dialog ADM_userInterfaces/ADM_gui2
Message-ID: <201003031850.o23IoP3w029084@sheep.berlios.de>

Author: mean
Date: 2010-03-03 19:50:25 +0100 (Wed, 03 Mar 2010)
New Revision: 5968

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/toolkit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/toolkit_dialog.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp
Log:
[Gtk] Move ui_purge to core_ui

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/toolkit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/toolkit.cpp	2010-03-03 18:50:22 UTC (rev 5967)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/toolkit.cpp	2010-03-03 18:50:25 UTC (rev 5968)
@@ -134,15 +134,6 @@
 
 }
 
-void UI_purge( void )
-{
-        
-        while (gtk_events_pending())
-                                {
-                                                  gtk_main_iteration();
-                              }
-
-}
 // read an entry as an integer
 
 int gtk_read_entry(GtkWidget *entry)

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/toolkit_dialog.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/toolkit_dialog.cpp	2010-03-03 18:50:22 UTC (rev 5967)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/toolkit_dialog.cpp	2010-03-03 18:50:25 UTC (rev 5968)
@@ -351,10 +351,29 @@
 extern int GUI_Alternate(const char *title,const char *choice1,const char *choice2);
 extern DIA_workingBase *createWorking(const char *title);
 extern DIA_encodingBase *createEncodingGtk(uint32_t fps1000);
+
+void getVersion(uint32_t *maj,uint32_t *minor)
+{
+    *maj=ADM_CORE_TOOLKIT_MAJOR;
+    *minor=ADM_CORE_TOOLKIT_MINOR;
+}
+/**
+    \fn UI_purge
+    \brief make sure Gtk process events & refresh the windows
+*/
+void UI_purge( void )
+{        
+        while (gtk_events_pending())
+                                {
+                                                  gtk_main_iteration();
+                              }
+	
+}
 } // End of namespace
 
 static CoreToolkitDescriptor GtkCoreToolkitDescriptor=
 {
+        &ADM_GtkCoreUIToolkit::getVersion,
 		&ADM_GtkCoreUIToolkit::GUI_Info_HIG,
 		&ADM_GtkCoreUIToolkit::GUI_Error_HIG,
 		&ADM_GtkCoreUIToolkit::GUI_Confirmation_HIG,
@@ -364,8 +383,9 @@
 		&ADM_GtkCoreUIToolkit::GUI_Verbose,
 		&ADM_GtkCoreUIToolkit::GUI_Quiet,
 		&ADM_GtkCoreUIToolkit::GUI_isQuiet,
-        &ADM_GtkCoreUIToolkit::createWorking
-        // &ADM_GtkCoreUIToolkit::createEncodingQt4
+        &ADM_GtkCoreUIToolkit::createWorking,
+        NULL, 
+        &ADM_GtkCoreUIToolkit::UI_purge
 };
 
 void InitCoreToolkit(void )

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp	2010-03-03 18:50:22 UTC (rev 5967)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp	2010-03-03 18:50:25 UTC (rev 5968)
@@ -1400,7 +1400,6 @@
 static const UI_FUNCTIONS_T UI_Hooks=
     {
         ADM_RENDER_API_VERSION_NUMBER,
-        UI_purge,
         UI_getWindowInfo,
         UI_updateDrawWindowSize,
         UI_rgbDraw,



From mean at mail.berlios.de  Wed Mar  3 19:50:18 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 3 Mar 2010 19:50:18 +0100
Subject: [Avidemux-svn-commit] r5965 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <201003031850.o23IoIKr029009@sheep.berlios.de>

Author: mean
Date: 2010-03-03 19:50:18 +0100 (Wed, 03 Mar 2010)
New Revision: 5965

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp
Log:
[mkv/Demuxer] Compute the missing audio timestamps, needed for ogg/vorbis

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2010-03-03 18:50:16 UTC (rev 5964)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2010-03-03 18:50:18 UTC (rev 5965)
@@ -80,8 +80,11 @@
     uint32_t                    _currentLace;
     uint32_t                    _maxLace;
     uint32_t                    _Laces[MKV_MAX_LACES];
+    uint64_t                    _laceIncrementUs;
+    uint64_t                    _lastDtsBase;
 
     uint8_t                     goToBlock(uint32_t x);
+    bool                        initLaces(uint32_t nbLaces,uint64_t time);
  
 public:
                                   mkvAccess(const char *name,mkvTrak *track);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp	2010-03-03 18:50:16 UTC (rev 5964)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp	2010-03-03 18:50:18 UTC (rev 5965)
@@ -19,7 +19,11 @@
 #include "ADM_a52info.h"
 #include "ADM_dcainfo.h"
 
+#if 0
+#define vprintf printf
+#else
 #define vprintf(...) {}
+#endif
 
 /**
     \fn mkvAccess
@@ -182,6 +186,25 @@
 
 }
 /**
+    \fn initLaces
+    \brief start a bunch of lace, compute the missing DTSs
+*/
+bool mkvAccess::initLaces(uint32_t nbLaces,uint64_t time)
+{
+                _maxLace=nbLaces;
+                _currentLace=1; 
+                _lastDtsBase=time;
+                _currentBlock++;
+                if(_currentBlock<_track->index.size()) // is it not the last block
+                {
+                    uint64_t deltaTime=_track->index[_currentBlock].Dts;
+                    deltaTime-=time;
+                    _laceIncrementUs=deltaTime/nbLaces;
+                    vprintf("***************DeltaTime : %"LLU" inc:%"LLU"\n",deltaTime,_laceIncrementUs);
+                } // else keep lastIncrement, which is as good as a random value
+                return true;
+}
+/**
     \fn getPacket
 */
 bool    mkvAccess::getPacket(uint8_t *dest, uint32_t *packlen, uint32_t maxSize,uint64_t *timecode)
@@ -191,7 +214,7 @@
   uint64_t id;
   ADM_MKV_TYPE type;
   const char *ss;
-  vprintf("Enter: Currently at :%llx\n",_clusterParser->tell());
+//  vprintf("Enter: Currently at :%llx\n",_clusterParser->tell());
 
     // Have we still lace to go ?
     if(_currentLace<_maxLace)
@@ -200,7 +223,8 @@
       *packlen= _Laces[_currentLace];
       ADM_assert(*packlen<maxSize);
       vprintf("Continuing lacing : %u bytes, lacing %u/%u\n",*packlen,_currentLace,_maxLace);
-      *timecode=ADM_AUDIO_NO_DTS;
+      *timecode=_lastDtsBase+_laceIncrementUs*_currentLace;
+       vprintf(">>>>>>>>> %"LLU" \n",*timecode);
       _currentLace++;
       return true;
     }
@@ -218,14 +242,14 @@
      uint8_t flags=_parser->readu8();
      int     lacing=((flags>>1)&3);
         vprintf("[MKV] Lacing : %u\n",lacing);
+     *timecode=time;
      switch(lacing)
             {
               case 0 : // no lacing
 
-                      vprintf("No lacing :%d bytes\n",remaining);
+                      vprintf("No lacing :%d bytes\n",(int)size);
                       _parser->readBin(dest,size);
-                      *packlen=size;
-                      *timecode=time;
+                      *packlen=size;                      
                       _currentLace=_maxLace=0;
                       _currentBlock++;
                       return 1;
@@ -248,14 +272,13 @@
                           size-=v;
                           _Laces[i]=lce;
                         }
-                        _currentLace=1;
+
                         // The first one has Dts
                          _parser->readBin(dest,_Laces[0]);
                         *packlen=_Laces[0];
-                        *timecode=time;
-                        _Laces[nbLaces-1]=size; // Last lace is remaining size
-                        _currentBlock++;
-                        _maxLace=nbLaces;
+                        _Laces[nbLaces-1]=size;
+
+                        initLaces(nbLaces,time);
                         return 1;
                       }
 
@@ -271,13 +294,11 @@
                         {
                           _Laces[i]=bsize;
                         }
-                        _currentLace=1;
-                        _maxLace=nbLaces;
+                        _parser->readBin(dest,bsize);
+                        *packlen=bsize;
                         // The first one has Dts
-                         _parser->readBin(dest,bsize);
-                        *packlen=bsize;
-                        *timecode=time;
-                        _currentBlock++;
+                        initLaces(nbLaces,time);
+                       
                         return 1;
                       }
                       break;
@@ -310,18 +331,14 @@
                         uint64_t consumed=head+size-tail;
 
                         _Laces[nbLaces-1]=consumed-sum;
-                        _maxLace=nbLaces;
 
-
-                      // Take the 1st laces, it has timestamp
-                      _parser->readBin(dest,_Laces[0]);
-                      *packlen= _Laces[0];
-                      ADM_assert(*packlen<maxSize);
-                      vprintf("Continuing lacing : dts : %lu %u bytes, lacing %u/%u\n",time,*packlen,_currentLace,_maxLace);
-                      *timecode=time;
-                      _currentBlock++;
-                      _currentLace=1;
-                      return 1;
+                          // Take the 1st laces, it has timestamp
+                          _parser->readBin(dest,_Laces[0]);
+                          *packlen= _Laces[0];
+                          ADM_assert(*packlen<maxSize);
+                          vprintf("Continuing lacing : dts : %lu %u bytes, lacing %u/%u\n",time,*packlen,_currentLace,_maxLace);
+                          initLaces(nbLaces,time);
+                          return 1;
                 }
                       break;
               default:



From mean at mail.berlios.de  Wed Mar  3 19:50:16 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 3 Mar 2010 19:50:16 +0100
Subject: [Avidemux-svn-commit] r5964 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins:
	ADM_muxers/muxerDummy ADM_videoEncoder ADM_videoEncoder/null
Message-ID: <201003031850.o23IoGoT028987@sheep.berlios.de>

Author: mean
Date: 2010-03-03 19:50:16 +0100 (Wed, 03 Mar 2010)
New Revision: 5964

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullPlugin.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerDummy/ADM_dummy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/CMakeLists.txt
Log:
[dummy] Add dummy encoder to measure speed of reading/demuxing + modify dummy muxer to actually fetch video frames

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerDummy/ADM_dummy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerDummy/ADM_dummy.cpp	2010-03-01 18:49:54 UTC (rev 5963)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerDummy/ADM_dummy.cpp	2010-03-03 18:50:16 UTC (rev 5964)
@@ -6,13 +6,46 @@
 bool muxerDummy::open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a)
 {
                 printf("[DummyMuxer] Opening %s\n",file);
+                vStream=s;
                 return true;
 }
 
 bool muxerDummy::save(void) 
 {
-        printf("[dummyMuxer] Save\n");
-        return true;
+    ADM_info("[dummy] Saving\n");
+    uint32_t bufSize=vStream->getWidth()*vStream->getHeight()*3;
+    uint8_t   *audioBuffer;
+    uint8_t   *videoBuffer;
+    uint32_t  len,flags;
+    uint64_t  pts,dts;
+    uint32_t  written=0;
+
+    audioBuffer=new uint8_t[10*4*8*1024];
+    videoBuffer=new uint8_t[bufSize];
+
+    ADM_info("[dummy]avg fps=%u\n",vStream->getAvgFps1000());
+
+    initUI("Saving dummy");
+    encoding->setContainer("dummy");
+
+    while(1)
+    {
+        if(false==vStream->getPacket(&len, videoBuffer, bufSize,&pts,&dts,&flags)) goto abt;
+        encoding->pushVideoFrame(len,0,dts);
+        if(updateUI()==false)
+        {  
+            goto abt;
+        }
+        written++;
+    }
+abt:
+    closeUI();
+    delete [] videoBuffer;
+    videoBuffer=NULL;
+    delete [] audioBuffer;
+    audioBuffer=NULL;
+    ADM_info("[dummy] Wrote %d frames, nb audio streams %d\n",written,nbAStreams);
+    return true;
 }
 bool muxerDummy::close(void) 
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/CMakeLists.txt	2010-03-01 18:49:54 UTC (rev 5963)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/CMakeLists.txt	2010-03-03 18:50:16 UTC (rev 5964)
@@ -1,6 +1,3 @@
-#ADD_SUBDIRECTORY(ADM_vidEnc_x264)
-#ADD_SUBDIRECTORY(ADM_vidEnc_xvid)
-#ADD_SUBDIRECTORY(x264)
 ADD_SUBDIRECTORY(yv12)
 ADD_SUBDIRECTORY(png)
 ADD_SUBDIRECTORY(jpeg)
@@ -9,3 +6,4 @@
 ADD_SUBDIRECTORY(ffMpeg2)
 ADD_SUBDIRECTORY(ffMsMpeg4)
 ADD_SUBDIRECTORY(ffFlv1)
+ADD_SUBDIRECTORY(null)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/CMakeLists.txt	2010-03-01 18:49:54 UTC (rev 5963)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/CMakeLists.txt	2010-03-03 18:50:16 UTC (rev 5964)
@@ -0,0 +1,12 @@
+INCLUDE(ve_plugin)
+
+SET(null_SRCS 
+        nullEncoder.cpp  
+        nullPlugin.cpp
+)
+INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})
+
+ADD_LIBRARY(ADM_ve_null SHARED ${null_SRCS})
+
+INIT_VIDEO_ENCODER(ADM_ve_null)
+INSTALL_VIDEO_ENCODER(ADM_ve_null)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.cpp	2010-03-01 18:49:54 UTC (rev 5963)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.cpp	2010-03-03 18:50:16 UTC (rev 5964)
@@ -0,0 +1,69 @@
+/***************************************************************************
+                          \file nullEncoder.cpp
+                          \brief dummy encoder
+                             -------------------
+    
+    copyright            : (C) 2002/2010 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "nullEncoder.h"
+#include "DIA_factory.h"
+
+//
+/**
+        \fn ADM_nullEncoder
+*/
+ADM_nullEncoder::ADM_nullEncoder(ADM_coreVideoFilter *src,bool globalHeader) : ADM_coreVideoEncoder(src)
+{
+    ADM_info("[null] Creating.\n");
+    int w,h;
+    FilterInfo *info=src->getInfo();
+    w=info->width;
+    h=info->height;
+    image=new ADMImage(w,h);
+   
+}
+/** 
+    \fn ~ADM_nullEncoder
+*/
+ADM_nullEncoder::~ADM_nullEncoder()
+{
+    ADM_info("[null] Destroying.\n");
+    if(image) delete image;
+    image=NULL;
+    
+}
+/**
+    \fn getFourcc
+*/
+const  char        *ADM_nullEncoder::getFourcc(void)
+{
+    return "null";
+}
+/**
+    \fn encode
+*/
+bool         ADM_nullEncoder::encode (ADMBitstream * out)
+{
+    if(source->getNextFrame(image)==false)
+    {
+        printf("[null] Cannot get next image\n");
+        return false;
+    }
+    out->len=1;
+    out->data[0]=0;
+    out->pts=out->dts=image->Pts;
+    out->flags=AVI_KEY_FRAME;
+    return true;
+}
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.h	2010-03-01 18:49:54 UTC (rev 5963)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.h	2010-03-03 18:50:16 UTC (rev 5964)
@@ -0,0 +1,39 @@
+/***************************************************************************
+                          \fn ADM_VideoEncoders
+                          \brief Internal handling of video encoders
+                             -------------------
+    
+    copyright            : (C) 2002/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_null_ENCODER_H
+#define ADM_null_ENCODER_H
+#include "ADM_coreVideoEncoder.h"
+/**
+        \class ADM_nullEncoder
+        \brief Dummy encoder that does nothing
+
+*/
+
+class ADM_nullEncoder : public ADM_coreVideoEncoder
+{
+protected:
+public:
+
+                           ADM_nullEncoder(ADM_coreVideoFilter *src,bool globalHeader);
+                           ~ADM_nullEncoder();
+virtual        bool        encode (ADMBitstream * out);
+virtual const  char        *getFourcc(void);
+};
+
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullPlugin.cpp	2010-03-01 18:49:54 UTC (rev 5963)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullPlugin.cpp	2010-03-03 18:50:16 UTC (rev 5964)
@@ -0,0 +1,33 @@
+/***************************************************************************
+                          \fn     nullEncoder
+                          \brief  Plugin for  dummy encoder
+                             -------------------
+    
+    copyright            : (C) 2002/2010 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "nullEncoder.h"
+#include "ADM_coreVideoEncoderInternal.h"
+
+extern bool         nullConfigure(void);
+
+ADM_DECLARE_VIDEO_ENCODER_PREAMBLE(ADM_nullEncoder);
+ADM_DECLARE_VIDEO_ENCODER_MAIN("null",
+                               "null",
+                               "Null Encoder (c) 2010 Mean",
+                                NULL, // No configuration
+                                ADM_UI_ALL,
+                                1,0,0,
+                                NULL, // conf template
+                                NULL // conf var
+);



From mean at mail.berlios.de  Wed Mar  3 19:50:21 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 3 Mar 2010 19:50:21 +0100
Subject: [Avidemux-svn-commit] r5966 - in branches/avidemux_2.6_branch_mean:
	avidemux/common avidemux/common/ADM_render
	avidemux/qt4/ADM_userInterfaces/ADM_dialog
	avidemux/qt4/ADM_userInterfaces/ADM_gui
	avidemux_core/ADM_coreUI/include avidemux_core/ADM_coreUI/src
Message-ID: <201003031850.o23IoLJd029033@sheep.berlios.de>

Author: mean
Date: 2010-03-03 19:50:20 +0100 (Wed, 03 Mar 2010)
New Revision: 5966

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_renderInternal.h
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreToolkit.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreUI_internal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_coreToolkit.cpp
Log:
[UI] Move UI_Purge from render to coreToolkit so that it can be used anywhere

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp	2010-03-03 18:50:18 UTC (rev 5965)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp	2010-03-03 18:50:20 UTC (rev 5966)
@@ -20,6 +20,7 @@
 
 #include "config.h"
 #include "ADM_default.h"
+#include "DIA_coreToolkit.h"
 #include "GUI_render.h"
 #include "GUI_renderInternal.h"
 #include "GUI_accelRender.h"
@@ -83,11 +84,6 @@
 //**************************************
 //**************************************
 #define RENDER_CHECK(x) {ADM_assert(HookFunc);ADM_assert(HookFunc->x);}
-static void MUI_purge(void) 
-{
-  RENDER_CHECK(UI_purge); 
-  HookFunc->UI_purge();
- }
 void MUI_getWindowInfo(void *draw, GUI_WindowInfo *xinfo)
 {
   RENDER_CHECK(UI_getWindowInfo);
@@ -170,7 +166,7 @@
         phyH=ph;
   
         updateWindowSize( draw,w,h);
-        MUI_purge();
+        UI_purge();
         return 1;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_renderInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_renderInternal.h	2010-03-03 18:50:18 UTC (rev 5965)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_renderInternal.h	2010-03-03 18:50:20 UTC (rev 5966)
@@ -16,12 +16,11 @@
 #ifndef GUI_RENDER_INTERNAL_H
 #define GUI_RENDER_INTERNAL_H
 
-#define ADM_RENDER_API_VERSION_NUMBER 2
+#define ADM_RENDER_API_VERSION_NUMBER 3
 #include "GUI_render.h"
 typedef struct
 {
   int   apiVersion;
-  void (*UI_purge)(void);
   void (*UI_getWindowInfo)(void *draw, GUI_WindowInfo *xinfo);
   void (*UI_updateDrawWindowSize)(void *win,uint32_t w,uint32_t h);
   void (*UI_rgbDraw)(void *widg,uint32_t w, uint32_t h,uint8_t *ptr);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2010-03-03 18:50:18 UTC (rev 5965)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2010-03-03 18:50:20 UTC (rev 5966)
@@ -30,7 +30,7 @@
 #include "ADM_commonUI/DIA_busy.h"
 #include "ADM_commonUI/GUI_ui.h"
 #include "DIA_enter.h"
-
+#include "DIA_coreToolkit.h"
 #include "ADM_vidMisc.h"
 #include "ADM_preview.h"
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp	2010-03-03 18:50:18 UTC (rev 5965)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp	2010-03-03 18:50:20 UTC (rev 5966)
@@ -13,8 +13,10 @@
  *                                                                         *
  ***************************************************************************/
 #include "ADM_inttype.h"
+#include <QtCore/QCoreApplication>
 #include <QtGui/QDialog>
 #include <QtGui/QMessageBox>
+#include <QtGui/QWidget>
 #include "DIA_coreToolkit.h"
 #include "DIA_coreUI_internal.h"
 #include "ADM_default.h"
@@ -228,10 +230,22 @@
 //****************************************************************************************************
 extern DIA_workingBase *createWorking(const char *title);
 extern DIA_encodingBase *createEncoding(uint64_t duration);
+
+void getVersion(uint32_t *maj,uint32_t *minor)
+{
+    *maj=ADM_CORE_TOOLKIT_MAJOR;
+    *minor=ADM_CORE_TOOLKIT_MINOR;
 }
 
+void UI_purge( void )
+{
+	QCoreApplication::processEvents ();
+}
+}
+
 static CoreToolkitDescriptor Qt4CoreToolkitDescriptor=
 {
+		&ADM_Qt4CoreUIToolkit::getVersion,
 		&ADM_Qt4CoreUIToolkit::GUI_Info_HIG,
 		&ADM_Qt4CoreUIToolkit::GUI_Error_HIG,
 		&ADM_Qt4CoreUIToolkit::GUI_Confirmation_HIG,
@@ -241,8 +255,9 @@
 		&ADM_Qt4CoreUIToolkit::GUI_Verbose,
 		&ADM_Qt4CoreUIToolkit::GUI_Quiet,
 		&ADM_Qt4CoreUIToolkit::GUI_isQuiet,
-                &ADM_Qt4CoreUIToolkit::createWorking,
-                &ADM_Qt4CoreUIToolkit::createEncoding
+        &ADM_Qt4CoreUIToolkit::createWorking,
+        &ADM_Qt4CoreUIToolkit::createEncoding,
+        &ADM_Qt4CoreUIToolkit::UI_purge
 };
 
 void InitCoreToolkit(void )

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2010-03-03 18:50:18 UTC (rev 5965)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2010-03-03 18:50:20 UTC (rev 5966)
@@ -545,7 +545,6 @@
 static const UI_FUNCTIONS_T UI_Hooks=
     {
         ADM_RENDER_API_VERSION_NUMBER,
-        UI_purge,
         UI_getWindowInfo,
         UI_updateDrawWindowSize,
         UI_rgbDraw,
@@ -800,10 +799,6 @@
 	return success;
 }
 
-void UI_purge( void )
-{
-	QCoreApplication::processEvents ();
-}
 
 
 //*******************************************

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp	2010-03-03 18:50:18 UTC (rev 5965)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp	2010-03-03 18:50:20 UTC (rev 5966)
@@ -30,15 +30,15 @@
 //#include "Q_seekablePreview.h"
 #include "../ADM_render/GUI_render.h"
 #include "../ADM_render/GUI_accelRender.h"
+#include "DIA_coreToolkit.h"
     
 void UI_QT4VideoWidget(QFrame *host);
 static QFrame *hostFrame=NULL;
 static AccelRender *accelRender=NULL;
 static uint8_t *lastImage=NULL;
 extern QWidget *QuiMainWindows;
- 
-extern void UI_purge( void );
 
+
 void DIA_previewInit(uint32_t width, uint32_t height) {}
 uint8_t DIA_previewUpdate(uint8_t *data) {return 1;}
 void DIA_previewEnd(void) {}

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreToolkit.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreToolkit.h	2010-03-03 18:50:18 UTC (rev 5965)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreToolkit.h	2010-03-03 18:50:20 UTC (rev 5966)
@@ -51,6 +51,7 @@
 // Is the UI in quiet mode ?
 uint8_t			GUI_isQuiet(void);
 //
+void            UI_purge(void);
 //
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreUI_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreUI_internal.h	2010-03-03 18:50:18 UTC (rev 5965)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_coreUI_internal.h	2010-03-03 18:50:20 UTC (rev 5966)
@@ -20,6 +20,8 @@
 #include "DIA_factory.h"
 #include "DIA_working.h"
 #include "DIA_encoding.h"
+#define ADM_CORE_TOOLKIT_MAJOR 1
+#define ADM_CORE_TOOLKIT_MINOR 1
 // Dia enter
 typedef struct
 {
@@ -116,6 +118,7 @@
 uint8_t DIA_factoryInit(FactoryDescriptor *d);
 
 // This is for coreToolkit UI elements
+typedef void            GET_CORE_TOOLKIT_VERSION(uint32_t *maj, uint32_t *minor);
 typedef void            CREATE_GUI_INFO_HIG(const ADM_LOG_LEVEL level,const char *primary, const char *secondary_format);
 typedef void            CREATE_GUI_ERROR_HIG(const char *primary, const char *secondary_format);
 typedef int             CREATE_GUI_CONFIRMATION_HIG(const char *button_confirm, const char *primary, const char *secondary_format);
@@ -127,9 +130,11 @@
 typedef uint8_t			CREATE_GUI_IS_GUIET(void);
 typedef DIA_workingBase  *CREATE_GUI_WORKING(const char *title);
 typedef DIA_encodingBase *CREATE_GUI_ENCODING(uint64_t duration);
+typedef void             UI_PURGE(void);
 // GUI_Sleep is internal
 typedef struct
 {
+    GET_CORE_TOOLKIT_VERSION    *getVersion;
 	CREATE_GUI_INFO_HIG 		*infoHig;
 	CREATE_GUI_ERROR_HIG		*errorHig;
 	CREATE_GUI_CONFIRMATION_HIG *confirmationHig;
@@ -141,6 +146,7 @@
 	CREATE_GUI_IS_GUIET 		*isQuiet;
     CREATE_GUI_WORKING          *createWorking;
     CREATE_GUI_ENCODING         *createEncoding;
+    UI_PURGE                    *uiPurge;
 }CoreToolkitDescriptor;
 //
 uint8_t  DIA_toolkitInit(CoreToolkitDescriptor *d);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_coreToolkit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_coreToolkit.cpp	2010-03-03 18:50:18 UTC (rev 5965)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_coreToolkit.cpp	2010-03-03 18:50:20 UTC (rev 5966)
@@ -27,8 +27,15 @@
  */
 uint8_t  DIA_toolkitInit(CoreToolkitDescriptor *d)
 {
-	uint32_t major,minor,patch;
+	uint32_t major,minor;
 	Toolkit=d;
+    Toolkit->getVersion(&major,&minor);
+    printf("[UI Toolkit] Running version %02d:%02d\n",(int)major,(int)minor);
+    if(major!=ADM_CORE_TOOLKIT_MAJOR || minor!=ADM_CORE_TOOLKIT_MINOR)
+    {
+        ADM_error("UI Toolkit version mistmatch, expected %02d:%02d\n",ADM_CORE_TOOLKIT_MAJOR,ADM_CORE_TOOLKIT_MINOR);
+        ADM_assert(0);
+    }
 	return 1;
 }
 /**
@@ -237,4 +244,11 @@
 //    return new DIA_encodingDummy(duration);
     return NULL;
 } 
+/**
+    \fn UI_Purge
+*/
+void UI_purge(void)
+{
+    if(Toolkit->uiPurge) Toolkit->uiPurge();
+}
 // EOF



From mean at mail.berlios.de  Wed Mar  3 19:50:23 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 3 Mar 2010 19:50:23 +0100
Subject: [Avidemux-svn-commit] r5967 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src
Message-ID: <201003031850.o23IoNqY029058@sheep.berlios.de>

Author: mean
Date: 2010-03-03 19:50:22 +0100 (Wed, 03 Mar 2010)
New Revision: 5967

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl
Log:
[Js] SetContainer, warn + we only need one arg as minimum

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux.cpp	2010-03-03 18:50:20 UTC (rev 5966)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux.cpp	2010-03-03 18:50:22 UTC (rev 5967)
@@ -32,6 +32,7 @@
         ADM_error("Cannot find muxer for format=%s\n",cont);
         return false;
     }
+    ADM_info("setting container as index %d\n",idx);
     UI_SetCurrentFormat(idx);
     return true;
 }
@@ -100,15 +101,22 @@
 extern "C" int   jsSetContainer(const char *a,const char **b) {return 0;}
 JSBool jsAdmsetContainer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {// begin Codec
-    
+        
         // default return value
         *rval = BOOLEAN_TO_JSVAL(false);
         if(argc < 1)
-                return JS_FALSE;
+        {
+            jsLog(JS_LOG_NORMAL,"setContainer needs at least one arg\n");
+            return JS_FALSE;
+        }
+        
         if(JSVAL_IS_STRING(argv[0]) == false)
+        {
+                jsLog(JS_LOG_NORMAL,"setContainer needs at string arg\n");
                 return JS_FALSE;
+        }
         char *str = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        
+         jsLog(JS_LOG_NORMAL,"[JS] Selecting container :%s\n",str);
         if(A_setContainer(str))
         {
             CONFcouple *c;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c	2010-03-03 18:50:20 UTC (rev 5966)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c	2010-03-03 18:50:22 UTC (rev 5967)
@@ -20,10 +20,6 @@
         printf("Constructor invoked\n");
 }
 
-#ifdef HAVE_ALLOCA_H
-#include <alloca.h>
-#endif
-#include <stdlib.h>
 #include <string.h>
 #include <wchar.h>
 #include <jsapi.h>
@@ -42,9 +38,6 @@
 #ifndef JS_FS_END
 #define JS_FS_END {NULL, NULL, 0, 0, 0}
 #endif
-#ifdef HAVE_ALLOCA_H
-static size_t jj_alloca_limit = 0;
-#endif
 static JSPropertySpec jj_static_ps[] = {
     {NULL, 0, 0, NULL, NULL}
 };
@@ -208,34 +201,34 @@
 jjadmloadVideo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSObject *var35;
+    char *var40;
     int var36;
     int var39;
-    char *var40;
     int var41;
     jsval var42;
     JSString *var43;
-    jsval var389;
+    jsval var234;
     size_t var44;
     size_t var45;
     int var47;
-    jschar *var48;
-    jsval var390;
-    jsval var49;
+    jschar *var46;
+    jsval var235;
+    jsval var48;
     JSBool var34;
     var35 = NULL;
+    var40 = NULL;
     var36 = 0;
     var39 = 0;
-    var40 = NULL;
     var41 = 0;
     var42 = JSVAL_NULL;
     var43 = NULL;
-    var389 = JSVAL_NULL;
+    var234 = JSVAL_NULL;
     var44 = 0;
     var45 = 0;
     var47 = 0;
-    var48 = NULL;
-    var390 = JSVAL_NULL;
-    var49 = JSVAL_NULL;
+    var46 = NULL;
+    var235 = JSVAL_NULL;
+    var48 = JSVAL_NULL;
     var34 = JS_FALSE;
     var35 = obj;
     var39 = argc;
@@ -247,48 +240,39 @@
     if (!var43) {
         goto do_return;
     }
-    var389 = STRING_TO_JSVAL(var43);
-    argv[argc+0] = var389;
+    var234 = STRING_TO_JSVAL(var43);
+    argv[argc+0] = var234;
     var44 = JS_GetStringLength(var43);
     var45 = 1;
     var45 += var44;
-#ifdef HAVE_ALLOCA
-    if (var45 < jj_alloca_limit) {
-        var40 = alloca(var45);
-    } else {
-#endif
-        var40 = malloc(var45);
-        if (!var40) {
-            goto do_return;
-        } else {
-            var47 = 1;
-        }
-#ifdef HAVE_ALLOCA
+    var40 = JS_malloc(cx, var45);
+    if (!var40) {
+        goto do_return;
     }
-#endif
-    var48 = JS_GetStringChars(var43);
-    var390 = STRING_TO_JSVAL(var43);
-    argv[argc+1] = var390;
+    var47 = 1;
+    var46 = JS_GetStringChars(var43);
+    var235 = STRING_TO_JSVAL(var43);
+    argv[argc+1] = var235;
     {
         size_t i;
         for (i = 0; i < var44; ++i) {
-            var40[i] = wctob(var48[i]);
+            var40[i] = wctob(var46[i]);
         }
         var40[var44] = '\0';
     }
     }
     var36 = jsLoadVideo(var40);
-    if (JS_NewNumberValue(cx, var36, &var49) != JS_TRUE) {
+    if (JS_NewNumberValue(cx, var36, &var48) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+2] = var49;
+    argv[argc+2] = var48;
     if (rval) {
-        *rval = var49;
+        *rval = var48;
     }
     var34 = JS_TRUE;
     do_return:
     if (var47) {
-        free(var40);
+        JS_free(cx, var40);
         var40 = NULL;
         var47 = 0;
     }
@@ -297,1723 +281,869 @@
 static JSBool
 jjadmclearSegments(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var51;
-    int var52;
-    int var55;
-    jsval var56;
-    JSBool var50;
-    var51 = NULL;
-    var52 = 0;
-    var55 = 0;
-    var56 = JSVAL_NULL;
-    var50 = JS_FALSE;
-    var51 = obj;
-    var55 = argc;
-    var52 = jsClearSegments();
-    if (JS_NewNumberValue(cx, var52, &var56) != JS_TRUE) {
+    JSObject *var50;
+    int var51;
+    int var54;
+    jsval var55;
+    JSBool var49;
+    var50 = NULL;
+    var51 = 0;
+    var54 = 0;
+    var55 = JSVAL_NULL;
+    var49 = JS_FALSE;
+    var50 = obj;
+    var54 = argc;
+    var51 = jsClearSegments();
+    if (JS_NewNumberValue(cx, var51, &var55) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var56;
+    argv[argc+0] = var55;
     if (rval) {
-        *rval = var56;
+        *rval = var55;
     }
-    var50 = JS_TRUE;
+    var49 = JS_TRUE;
     do_return:
-    return var50;
+    return var49;
 }
 static JSBool
 jjadmappendVideo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var58;
-    int var59;
-    int var62;
-    char *var63;
-    int var64;
-    jsval var65;
-    JSString *var66;
-    jsval var393;
+    JSObject *var57;
+    char *var62;
+    int var58;
+    int var61;
+    int var63;
+    jsval var64;
+    JSString *var65;
+    jsval var238;
+    size_t var66;
     size_t var67;
-    size_t var68;
-    int var70;
-    jschar *var71;
-    jsval var394;
-    jsval var72;
-    JSBool var57;
-    var58 = NULL;
-    var59 = 0;
-    var62 = 0;
-    var63 = NULL;
-    var64 = 0;
-    var65 = JSVAL_NULL;
-    var66 = NULL;
-    var393 = JSVAL_NULL;
+    int var69;
+    jschar *var68;
+    jsval var239;
+    jsval var70;
+    JSBool var56;
+    var57 = NULL;
+    var62 = NULL;
+    var58 = 0;
+    var61 = 0;
+    var63 = 0;
+    var64 = JSVAL_NULL;
+    var65 = NULL;
+    var238 = JSVAL_NULL;
+    var66 = 0;
     var67 = 0;
-    var68 = 0;
-    var70 = 0;
-    var71 = NULL;
-    var394 = JSVAL_NULL;
-    var72 = JSVAL_NULL;
-    var57 = JS_FALSE;
-    var58 = obj;
-    var62 = argc;
-    var64 = 0;
-    var64 = var64 < var62;
-    if (var64) {
-    var65 = argv[0];
-    var66 = JS_ValueToString(cx, var65);
-    if (!var66) {
+    var69 = 0;
+    var68 = NULL;
+    var239 = JSVAL_NULL;
+    var70 = JSVAL_NULL;
+    var56 = JS_FALSE;
+    var57 = obj;
+    var61 = argc;
+    var63 = 0;
+    var63 = var63 < var61;
+    if (var63) {
+    var64 = argv[0];
+    var65 = JS_ValueToString(cx, var64);
+    if (!var65) {
         goto do_return;
     }
-    var393 = STRING_TO_JSVAL(var66);
-    argv[argc+0] = var393;
-    var67 = JS_GetStringLength(var66);
-    var68 = 1;
-    var68 += var67;
-#ifdef HAVE_ALLOCA
-    if (var68 < jj_alloca_limit) {
-        var63 = alloca(var68);
-    } else {
-#endif
-        var63 = malloc(var68);
-        if (!var63) {
-            goto do_return;
-        } else {
-            var70 = 1;
-        }
-#ifdef HAVE_ALLOCA
+    var238 = STRING_TO_JSVAL(var65);
+    argv[argc+0] = var238;
+    var66 = JS_GetStringLength(var65);
+    var67 = 1;
+    var67 += var66;
+    var62 = JS_malloc(cx, var67);
+    if (!var62) {
+        goto do_return;
     }
-#endif
-    var71 = JS_GetStringChars(var66);
-    var394 = STRING_TO_JSVAL(var66);
-    argv[argc+1] = var394;
+    var69 = 1;
+    var68 = JS_GetStringChars(var65);
+    var239 = STRING_TO_JSVAL(var65);
+    argv[argc+1] = var239;
     {
         size_t i;
-        for (i = 0; i < var67; ++i) {
-            var63[i] = wctob(var71[i]);
+        for (i = 0; i < var66; ++i) {
+            var62[i] = wctob(var68[i]);
         }
-        var63[var67] = '\0';
+        var62[var66] = '\0';
     }
     }
-    var59 = jsAppendVideo(var63);
-    if (JS_NewNumberValue(cx, var59, &var72) != JS_TRUE) {
+    var58 = jsAppendVideo(var62);
+    if (JS_NewNumberValue(cx, var58, &var70) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+2] = var72;
+    argv[argc+2] = var70;
     if (rval) {
-        *rval = var72;
+        *rval = var70;
     }
-    var57 = JS_TRUE;
+    var56 = JS_TRUE;
     do_return:
-    if (var70) {
-        free(var63);
-        var63 = NULL;
-        var70 = 0;
+    if (var69) {
+        JS_free(cx, var62);
+        var62 = NULL;
+        var69 = 0;
     }
-    return var57;
+    return var56;
 }
 static JSBool
 jjadmaddSegment(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var74;
-    int var75;
-    int var78;
-    int var79;
-    int var82;
-    jsval var83;
-    int32 var84;
-    double var80;
-    int var85;
-    jsval var86;
-    jsdouble var87;
-    double var81;
-    int var88;
+    JSObject *var72;
+    int var77;
+    double var78;
+    double var79;
+    int var73;
+    int var76;
+    int var80;
+    jsval var81;
+    int32 var82;
+    int var83;
+    jsval var84;
+    jsdouble var85;
+    int var86;
+    jsval var87;
+    jsdouble var88;
     jsval var89;
-    jsdouble var90;
-    jsval var91;
-    JSBool var73;
-    var74 = NULL;
-    var75 = 0;
-    var78 = 0;
-    var79 = 0;
+    JSBool var71;
+    var72 = NULL;
+    var77 = 0;
+    var78 = 0.0;
+    var79 = 0.0;
+    var73 = 0;
+    var76 = 0;
+    var80 = 0;
+    var81 = JSVAL_NULL;
     var82 = 0;
-    var83 = JSVAL_NULL;
-    var84 = 0;
-    var80 = 0.0;
-    var85 = 0;
-    var86 = JSVAL_NULL;
-    var87 = 0.0;
-    var81 = 0.0;
-    var88 = 0;
+    var83 = 0;
+    var84 = JSVAL_NULL;
+    var85 = 0.0;
+    var86 = 0;
+    var87 = JSVAL_NULL;
+    var88 = 0.0;
     var89 = JSVAL_NULL;
-    var90 = 0.0;
-    var91 = JSVAL_NULL;
-    var73 = JS_FALSE;
-    var74 = obj;
-    var78 = argc;
-    var82 = 0;
-    var82 = var82 < var78;
-    if (var82) {
-    var83 = argv[0];
-    if (JS_ValueToInt32(cx, var83, &var84) != JS_TRUE) {
+    var71 = JS_FALSE;
+    var72 = obj;
+    var76 = argc;
+    var80 = 0;
+    var80 = var80 < var76;
+    if (var80) {
+    var81 = argv[0];
+    if (JS_ValueToInt32(cx, var81, &var82) != JS_TRUE) {
         goto do_return;
     }
-    var79 = (int)var84;
+    var77 = (int)var82;
     }
-    var85 = 1;
-    var85 = var85 < var78;
-    if (var85) {
-    var86 = argv[1];
-    if (JS_ValueToNumber(cx, var86, &var87) != JS_TRUE) {
+    var83 = 1;
+    var83 = var83 < var76;
+    if (var83) {
+    var84 = argv[1];
+    if (JS_ValueToNumber(cx, var84, &var85) != JS_TRUE) {
         goto do_return;
     }
-    var80 = (double)var87;
+    var78 = (double)var85;
     }
-    var88 = 2;
-    var88 = var88 < var78;
-    if (var88) {
-    var89 = argv[2];
-    if (JS_ValueToNumber(cx, var89, &var90) != JS_TRUE) {
+    var86 = 2;
+    var86 = var86 < var76;
+    if (var86) {
+    var87 = argv[2];
+    if (JS_ValueToNumber(cx, var87, &var88) != JS_TRUE) {
         goto do_return;
     }
-    var81 = (double)var90;
+    var79 = (double)var88;
     }
-    var75 = jsAddSegment(var79, var80, var81);
-    if (JS_NewNumberValue(cx, var75, &var91) != JS_TRUE) {
+    var73 = jsAddSegment(var77, var78, var79);
+    if (JS_NewNumberValue(cx, var73, &var89) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var91;
+    argv[argc+0] = var89;
     if (rval) {
-        *rval = var91;
+        *rval = var89;
     }
-    var73 = JS_TRUE;
+    var71 = JS_TRUE;
     do_return:
-    return var73;
+    return var71;
 }
 static JSBool
 jjadmsetPostProc(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var93;
-    int var94;
+    JSObject *var91;
+    int var96;
     int var97;
     int var98;
-    int var101;
-    jsval var102;
-    int32 var103;
+    int var92;
+    int var95;
     int var99;
-    int var104;
-    jsval var105;
-    int32 var106;
-    int var100;
-    int var107;
+    jsval var100;
+    int32 var101;
+    int var102;
+    jsval var103;
+    int32 var104;
+    int var105;
+    jsval var106;
+    int32 var107;
     jsval var108;
-    int32 var109;
-    jsval var110;
-    JSBool var92;
-    var93 = NULL;
-    var94 = 0;
+    JSBool var90;
+    var91 = NULL;
+    var96 = 0;
     var97 = 0;
     var98 = 0;
-    var101 = 0;
-    var102 = JSVAL_NULL;
-    var103 = 0;
+    var92 = 0;
+    var95 = 0;
     var99 = 0;
+    var100 = JSVAL_NULL;
+    var101 = 0;
+    var102 = 0;
+    var103 = JSVAL_NULL;
     var104 = 0;
-    var105 = JSVAL_NULL;
-    var106 = 0;
-    var100 = 0;
+    var105 = 0;
+    var106 = JSVAL_NULL;
     var107 = 0;
     var108 = JSVAL_NULL;
-    var109 = 0;
-    var110 = JSVAL_NULL;
-    var92 = JS_FALSE;
-    var93 = obj;
-    var97 = argc;
-    var101 = 0;
-    var101 = var101 < var97;
-    if (var101) {
-    var102 = argv[0];
-    if (JS_ValueToInt32(cx, var102, &var103) != JS_TRUE) {
+    var90 = JS_FALSE;
+    var91 = obj;
+    var95 = argc;
+    var99 = 0;
+    var99 = var99 < var95;
+    if (var99) {
+    var100 = argv[0];
+    if (JS_ValueToInt32(cx, var100, &var101) != JS_TRUE) {
         goto do_return;
     }
-    var98 = (int)var103;
+    var96 = (int)var101;
     }
-    var104 = 1;
-    var104 = var104 < var97;
-    if (var104) {
-    var105 = argv[1];
-    if (JS_ValueToInt32(cx, var105, &var106) != JS_TRUE) {
+    var102 = 1;
+    var102 = var102 < var95;
+    if (var102) {
+    var103 = argv[1];
+    if (JS_ValueToInt32(cx, var103, &var104) != JS_TRUE) {
         goto do_return;
     }
-    var99 = (int)var106;
+    var97 = (int)var104;
     }
-    var107 = 2;
-    var107 = var107 < var97;
-    if (var107) {
-    var108 = argv[2];
-    if (JS_ValueToInt32(cx, var108, &var109) != JS_TRUE) {
+    var105 = 2;
+    var105 = var105 < var95;
+    if (var105) {
+    var106 = argv[2];
+    if (JS_ValueToInt32(cx, var106, &var107) != JS_TRUE) {
         goto do_return;
     }
-    var100 = (int)var109;
+    var98 = (int)var107;
     }
-    var94 = jsSetPostProc(var98, var99, var100);
-    if (JS_NewNumberValue(cx, var94, &var110) != JS_TRUE) {
+    var92 = jsSetPostProc(var96, var97, var98);
+    if (JS_NewNumberValue(cx, var92, &var108) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var110;
+    argv[argc+0] = var108;
     if (rval) {
-        *rval = var110;
+        *rval = var108;
     }
-    var92 = JS_TRUE;
+    var90 = JS_TRUE;
     do_return:
-    return var92;
+    return var90;
 }
 static JSBool
 jjadmgetWidth(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var112;
-    int var113;
-    int var116;
-    jsval var117;
-    JSBool var111;
-    var112 = NULL;
-    var113 = 0;
-    var116 = 0;
-    var117 = JSVAL_NULL;
-    var111 = JS_FALSE;
-    var112 = obj;
-    var116 = argc;
-    var113 = jsGetWidth();
-    if (JS_NewNumberValue(cx, var113, &var117) != JS_TRUE) {
+    JSObject *var110;
+    int var111;
+    int var114;
+    jsval var115;
+    JSBool var109;
+    var110 = NULL;
+    var111 = 0;
+    var114 = 0;
+    var115 = JSVAL_NULL;
+    var109 = JS_FALSE;
+    var110 = obj;
+    var114 = argc;
+    var111 = jsGetWidth();
+    if (JS_NewNumberValue(cx, var111, &var115) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var117;
+    argv[argc+0] = var115;
     if (rval) {
-        *rval = var117;
+        *rval = var115;
     }
-    var111 = JS_TRUE;
+    var109 = JS_TRUE;
     do_return:
-    return var111;
+    return var109;
 }
 static JSBool
 jjadmgetHeight(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var119;
-    int var120;
-    int var123;
-    jsval var124;
-    JSBool var118;
-    var119 = NULL;
-    var120 = 0;
-    var123 = 0;
-    var124 = JSVAL_NULL;
-    var118 = JS_FALSE;
-    var119 = obj;
-    var123 = argc;
-    var120 = jsGetHeight();
-    if (JS_NewNumberValue(cx, var120, &var124) != JS_TRUE) {
+    JSObject *var117;
+    int var118;
+    int var121;
+    jsval var122;
+    JSBool var116;
+    var117 = NULL;
+    var118 = 0;
+    var121 = 0;
+    var122 = JSVAL_NULL;
+    var116 = JS_FALSE;
+    var117 = obj;
+    var121 = argc;
+    var118 = jsGetHeight();
+    if (JS_NewNumberValue(cx, var118, &var122) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var124;
+    argv[argc+0] = var122;
     if (rval) {
-        *rval = var124;
+        *rval = var122;
     }
-    var118 = JS_TRUE;
+    var116 = JS_TRUE;
     do_return:
-    return var118;
+    return var116;
 }
 static JSBool
 jjadmgetFps1000(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var126;
-    int var127;
-    int var130;
-    jsval var131;
-    JSBool var125;
-    var126 = NULL;
-    var127 = 0;
-    var130 = 0;
-    var131 = JSVAL_NULL;
-    var125 = JS_FALSE;
-    var126 = obj;
-    var130 = argc;
-    var127 = jsGetFps1000();
-    if (JS_NewNumberValue(cx, var127, &var131) != JS_TRUE) {
+    JSObject *var124;
+    int var125;
+    int var128;
+    jsval var129;
+    JSBool var123;
+    var124 = NULL;
+    var125 = 0;
+    var128 = 0;
+    var129 = JSVAL_NULL;
+    var123 = JS_FALSE;
+    var124 = obj;
+    var128 = argc;
+    var125 = jsGetFps1000();
+    if (JS_NewNumberValue(cx, var125, &var129) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var131;
+    argv[argc+0] = var129;
     if (rval) {
-        *rval = var131;
+        *rval = var129;
     }
-    var125 = JS_TRUE;
+    var123 = JS_TRUE;
     do_return:
-    return var125;
+    return var123;
 }
 static JSBool
 jjadmgetVideoCodec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var133;
-    char *var134;
-    int var137;
-    jsval var138;
-    JSString *var139;
-    jsval var401;
-    char *var140;
-    jsval var402;
-    JSBool var132;
-    var133 = NULL;
-    var134 = NULL;
-    var137 = 0;
-    var138 = JSVAL_NULL;
-    var139 = NULL;
-    var401 = JSVAL_NULL;
-    var140 = NULL;
-    var402 = JSVAL_NULL;
-    var132 = JS_FALSE;
-    var133 = obj;
-    var137 = argc;
-    var134 = jsGetVideoCodec();
-    if (var134) {
-    var139 = JS_NewStringCopyZ(cx, var134);
-    if (!var139) {
+    JSObject *var131;
+    char *var132;
+    int var135;
+    jsval var136;
+    JSString *var137;
+    jsval var246;
+    char *var138;
+    jsval var247;
+    JSBool var130;
+    var131 = NULL;
+    var132 = NULL;
+    var135 = 0;
+    var136 = JSVAL_NULL;
+    var137 = NULL;
+    var246 = JSVAL_NULL;
+    var138 = NULL;
+    var247 = JSVAL_NULL;
+    var130 = JS_FALSE;
+    var131 = obj;
+    var135 = argc;
+    var132 = jsGetVideoCodec();
+    if (var132) {
+    var137 = JS_NewStringCopyZ(cx, var132);
+    if (!var137) {
         goto do_return;
     }
-    var401 = STRING_TO_JSVAL(var139);
-    argv[argc+0] = var401;
+    var246 = STRING_TO_JSVAL(var137);
+    argv[argc+0] = var246;
     } else {
-    var140 = "";
-    var139 = JS_InternString(cx, var140);
-    if (!var139) {
+    var138 = "";
+    var137 = JS_InternString(cx, var138);
+    if (!var137) {
         goto do_return;
     }
-    var402 = STRING_TO_JSVAL(var139);
-    argv[argc+1] = var402;
+    var247 = STRING_TO_JSVAL(var137);
+    argv[argc+1] = var247;
     }
-    var138 = STRING_TO_JSVAL(var139);
+    var136 = STRING_TO_JSVAL(var137);
     if (rval) {
-        *rval = var138;
+        *rval = var136;
     }
-    var132 = JS_TRUE;
+    var130 = JS_TRUE;
     do_return:
-    return var132;
+    return var130;
 }
 static JSBool
 jjadmaudioReset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var142;
-    int var143;
-    int var146;
-    jsval var147;
-    JSBool var141;
-    var142 = NULL;
-    var143 = 0;
-    var146 = 0;
-    var147 = JSVAL_NULL;
-    var141 = JS_FALSE;
-    var142 = obj;
-    var146 = argc;
-    var143 = jsAudioReset();
-    if (JS_NewNumberValue(cx, var143, &var147) != JS_TRUE) {
+    JSObject *var140;
+    int var141;
+    int var144;
+    jsval var145;
+    JSBool var139;
+    var140 = NULL;
+    var141 = 0;
+    var144 = 0;
+    var145 = JSVAL_NULL;
+    var139 = JS_FALSE;
+    var140 = obj;
+    var144 = argc;
+    var141 = jsAudioReset();
+    if (JS_NewNumberValue(cx, var141, &var145) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var147;
+    argv[argc+0] = var145;
     if (rval) {
-        *rval = var147;
+        *rval = var145;
     }
-    var141 = JS_TRUE;
+    var139 = JS_TRUE;
     do_return:
-    return var141;
+    return var139;
 }
 static JSBool
 jjadmaudioMixer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var149;
-    int var150;
+    JSObject *var147;
+    char *var152;
+    int var148;
+    int var151;
     int var153;
-    char *var154;
-    int var155;
-    jsval var156;
-    JSString *var157;
-    jsval var404;
-    size_t var158;
-    size_t var159;
-    int var161;
-    jschar *var162;
-    jsval var405;
-    jsval var163;
-    JSBool var148;
-    var149 = NULL;
-    var150 = 0;
+    jsval var154;
+    JSString *var155;
+    jsval var249;
+    size_t var156;
+    size_t var157;
+    int var159;
+    jschar *var158;
+    jsval var250;
+    jsval var160;
+    JSBool var146;
+    var147 = NULL;
+    var152 = NULL;
+    var148 = 0;
+    var151 = 0;
     var153 = 0;
-    var154 = NULL;
-    var155 = 0;
-    var156 = JSVAL_NULL;
-    var157 = NULL;
-    var404 = JSVAL_NULL;
-    var158 = 0;
+    var154 = JSVAL_NULL;
+    var155 = NULL;
+    var249 = JSVAL_NULL;
+    var156 = 0;
+    var157 = 0;
     var159 = 0;
-    var161 = 0;
-    var162 = NULL;
-    var405 = JSVAL_NULL;
-    var163 = JSVAL_NULL;
-    var148 = JS_FALSE;
-    var149 = obj;
-    var153 = argc;
-    var155 = 0;
-    var155 = var155 < var153;
-    if (var155) {
-    var156 = argv[0];
-    var157 = JS_ValueToString(cx, var156);
-    if (!var157) {
+    var158 = NULL;
+    var250 = JSVAL_NULL;
+    var160 = JSVAL_NULL;
+    var146 = JS_FALSE;
+    var147 = obj;
+    var151 = argc;
+    var153 = 0;
+    var153 = var153 < var151;
+    if (var153) {
+    var154 = argv[0];
+    var155 = JS_ValueToString(cx, var154);
+    if (!var155) {
         goto do_return;
     }
-    var404 = STRING_TO_JSVAL(var157);
-    argv[argc+0] = var404;
-    var158 = JS_GetStringLength(var157);
-    var159 = 1;
-    var159 += var158;
-#ifdef HAVE_ALLOCA
-    if (var159 < jj_alloca_limit) {
-        var154 = alloca(var159);
-    } else {
-#endif
-        var154 = malloc(var159);
-        if (!var154) {
-            goto do_return;
-        } else {
-            var161 = 1;
-        }
-#ifdef HAVE_ALLOCA
+    var249 = STRING_TO_JSVAL(var155);
+    argv[argc+0] = var249;
+    var156 = JS_GetStringLength(var155);
+    var157 = 1;
+    var157 += var156;
+    var152 = JS_malloc(cx, var157);
+    if (!var152) {
+        goto do_return;
     }
-#endif
-    var162 = JS_GetStringChars(var157);
-    var405 = STRING_TO_JSVAL(var157);
-    argv[argc+1] = var405;
+    var159 = 1;
+    var158 = JS_GetStringChars(var155);
+    var250 = STRING_TO_JSVAL(var155);
+    argv[argc+1] = var250;
     {
         size_t i;
-        for (i = 0; i < var158; ++i) {
-            var154[i] = wctob(var162[i]);
+        for (i = 0; i < var156; ++i) {
+            var152[i] = wctob(var158[i]);
         }
-        var154[var158] = '\0';
+        var152[var156] = '\0';
     }
     }
-    var150 = jsAudioMixer(var154);
-    if (JS_NewNumberValue(cx, var150, &var163) != JS_TRUE) {
+    var148 = jsAudioMixer(var152);
+    if (JS_NewNumberValue(cx, var148, &var160) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+2] = var163;
+    argv[argc+2] = var160;
     if (rval) {
-        *rval = var163;
+        *rval = var160;
     }
-    var148 = JS_TRUE;
+    var146 = JS_TRUE;
     do_return:
-    if (var161) {
-        free(var154);
-        var154 = NULL;
-        var161 = 0;
+    if (var159) {
+        JS_free(cx, var152);
+        var152 = NULL;
+        var159 = 0;
     }
-    return var148;
+    return var146;
 }
 static JSBool
 jjadmclearVideoFilters(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var165;
+    JSObject *var162;
+    int var163;
     int var166;
-    int var169;
-    jsval var170;
-    JSBool var164;
-    var165 = NULL;
+    jsval var167;
+    JSBool var161;
+    var162 = NULL;
+    var163 = 0;
     var166 = 0;
-    var169 = 0;
-    var170 = JSVAL_NULL;
-    var164 = JS_FALSE;
-    var165 = obj;
-    var169 = argc;
-    var166 = jsClearVideoFilters();
-    if (JS_NewNumberValue(cx, var166, &var170) != JS_TRUE) {
+    var167 = JSVAL_NULL;
+    var161 = JS_FALSE;
+    var162 = obj;
+    var166 = argc;
+    var163 = jsClearVideoFilters();
+    if (JS_NewNumberValue(cx, var163, &var167) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var170;
+    argv[argc+0] = var167;
     if (rval) {
-        *rval = var170;
+        *rval = var167;
     }
-    var164 = JS_TRUE;
+    var161 = JS_TRUE;
     do_return:
-    return var164;
+    return var161;
 }
 static JSBool
 jjadmvideoCodec_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var172;
+    JSObject *var169;
+    char *var174;
+    int var170;
     int var173;
-    int var176;
-    char *var177;
-    int var179;
-    jsval var180;
-    JSString *var181;
-    jsval var408;
-    size_t var182;
-    size_t var183;
-    int var185;
-    jschar *var186;
-    jsval var409;
-    char **var178;
-    int var187;
-    jsval var188;
-    JSObject *var189;
-    jsval var410;
-    jsuint var190;
-    size_t var194;
-    JSString *var195;
-    size_t var196;
-    JSString **var202;
-    int var219;
-    jsuint var197;
-    jsint var198;
-    JSBool var199;
-    jsval var200;
-    JSString *var201;
-    jsval var411;
-    size_t var205;
-    jsuint var203;
-    jsint var204;
-    JSString *var207;
-    size_t var206;
-    size_t var208;
-    char var217;
-    size_t var218;
-    char *var209;
-    int var220;
-    char *var210;
-    size_t var211;
-    int var221;
-    char *var214;
-    jsuint var212;
-    jsint var213;
-    JSString *var216;
-    size_t var215;
-    jschar *var222;
-    jsval var412;
-    jsval var223;
-    JSBool var171;
-    var172 = NULL;
+    int var175;
+    jsval var176;
+    JSString *var177;
+    jsval var253;
+    size_t var178;
+    size_t var179;
+    int var181;
+    jschar *var180;
+    jsval var254;
+    jsval var182;
+    JSBool var168;
+    var169 = NULL;
+    var174 = NULL;
+    var170 = 0;
     var173 = 0;
-    var176 = 0;
+    var175 = 0;
+    var176 = JSVAL_NULL;
     var177 = NULL;
+    var253 = JSVAL_NULL;
+    var178 = 0;
     var179 = 0;
-    var180 = JSVAL_NULL;
-    var181 = NULL;
-    var408 = JSVAL_NULL;
-    var182 = 0;
-    var183 = 0;
-    var185 = 0;
-    var186 = NULL;
-    var409 = JSVAL_NULL;
-    var178 = NULL;
-    var187 = 0;
-    var188 = JSVAL_NULL;
-    var189 = NULL;
-    var410 = JSVAL_NULL;
-    var190 = 0;
-    var194 = 0;
-    var195 = NULL;
-    var196 = 0;
-    var202 = NULL;
-    var219 = 0;
-    var197 = 0;
-    var198 = 0;
-    var199 = JS_FALSE;
-    var200 = JSVAL_NULL;
-    var201 = NULL;
-    var411 = JSVAL_NULL;
-    var205 = 0;
-    var203 = 0;
-    var204 = 0;
-    var207 = NULL;
-    var206 = 0;
-    var208 = 0;
-    var217 = 0;
-    var218 = 0;
-    var209 = NULL;
-    var220 = 0;
-    var210 = NULL;
-    var211 = 0;
-    var221 = 0;
-    var214 = NULL;
-    var212 = 0;
-    var213 = 0;
-    var216 = NULL;
-    var215 = 0;
-    var222 = NULL;
-    var412 = JSVAL_NULL;
-    var223 = JSVAL_NULL;
-    var171 = JS_FALSE;
-    var172 = obj;
-    var176 = argc;
-    var179 = 0;
-    var179 = var179 < var176;
-    if (var179) {
-    var180 = argv[0];
-    var181 = JS_ValueToString(cx, var180);
-    if (!var181) {
+    var181 = 0;
+    var180 = NULL;
+    var254 = JSVAL_NULL;
+    var182 = JSVAL_NULL;
+    var168 = JS_FALSE;
+    var169 = obj;
+    var173 = argc;
+    var175 = 0;
+    var175 = var175 < var173;
+    if (var175) {
+    var176 = argv[0];
+    var177 = JS_ValueToString(cx, var176);
+    if (!var177) {
         goto do_return;
     }
-    var408 = STRING_TO_JSVAL(var181);
-    argv[argc+0] = var408;
-    var182 = JS_GetStringLength(var181);
-    var183 = 1;
-    var183 += var182;
-#ifdef HAVE_ALLOCA
-    if (var183 < jj_alloca_limit) {
-        var177 = alloca(var183);
-    } else {
-#endif
-        var177 = malloc(var183);
-        if (!var177) {
-            goto do_return;
-        } else {
-            var185 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var186 = JS_GetStringChars(var181);
-    var409 = STRING_TO_JSVAL(var181);
-    argv[argc+1] = var409;
-    {
-        size_t i;
-        for (i = 0; i < var182; ++i) {
-            var177[i] = wctob(var186[i]);
-        }
-        var177[var182] = '\0';
-    }
-    }
-    var187 = 1;
-    var187 = var187 < var176;
-    if (var187) {
-    var188 = argv[1];
-    if (JS_ValueToObject(cx, var188, &var189) != JS_TRUE) {
+    var253 = STRING_TO_JSVAL(var177);
+    argv[argc+0] = var253;
+    var178 = JS_GetStringLength(var177);
+    var179 = 1;
+    var179 += var178;
+    var174 = JS_malloc(cx, var179);
+    if (!var174) {
         goto do_return;
     }
-    var410 = OBJECT_TO_JSVAL(var189);
-    argv[argc+2] = var410;
-    if (JS_GetArrayLength(cx, var189, &var190) != JS_TRUE) {
-        goto do_return;
-    }
-    var194 = var190;
-    var196 = sizeof(var195);
-    var194 *= var196;
-#ifdef HAVE_ALLOCA
-    if (var194 < jj_alloca_limit) {
-        var202 = alloca(var194);
-    } else {
-#endif
-        var202 = malloc(var194);
-        if (!var202) {
-            goto do_return;
-        } else {
-            var219 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var197 = var190;
-    var198 = -1;
-    while (var197)
+    var181 = 1;
+    var180 = JS_GetStringChars(var177);
+    var254 = STRING_TO_JSVAL(var177);
+    argv[argc+1] = var254;
     {
-    var197 += var198;
-    var199 = JS_GetElement(cx, var189, var197, &var200);
-    var201 = JS_ValueToString(cx, var200);
-    if (!var201) {
-        goto do_return;
-    }
-    var411 = STRING_TO_JSVAL(var201);
-    argv[argc+3] = var411;
-    var202[var197] = var201;
-    }
-    var205 = 0;
-    var203 = var190;
-    var204 = -1;
-    while (var203)
-    {
-    var203 += var204;
-    var207 = var202[var203];
-    var206 = JS_GetStringLength(var207);
-    var205 += var206;
-    var208 = 1;
-    var205 += var208;
-    }
-    var218 = sizeof(var217);
-    var218 *= var205;
-#ifdef HAVE_ALLOCA
-    if (var218 < jj_alloca_limit) {
-        var209 = alloca(var218);
-    } else {
-#endif
-        var209 = malloc(var218);
-        if (!var209) {
-            goto do_return;
-        } else {
-            var220 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var211 = sizeof(var210);
-    var211 *= var190;
-#ifdef HAVE_ALLOCA
-    if (var211 < jj_alloca_limit) {
-        var178 = alloca(var211);
-    } else {
-#endif
-        var178 = malloc(var211);
-        if (!var178) {
-            goto do_return;
-        } else {
-            var221 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var214 = var209;
-    var214 += var205;
-    var212 = var190;
-    var213 = -1;
-    while (var212)
-    {
-    var212 += var213;
-    var216 = var202[var212];
-    var215 = JS_GetStringLength(var216);
-    var214 -= var215;
-    var214 += var213;
-    var222 = JS_GetStringChars(var216);
-    var412 = STRING_TO_JSVAL(var216);
-    argv[argc+4] = var412;
-    {
         size_t i;
-        for (i = 0; i < var215; ++i) {
-            var214[i] = wctob(var222[i]);
+        for (i = 0; i < var178; ++i) {
+            var174[i] = wctob(var180[i]);
         }
-        var214[var215] = '\0';
+        var174[var178] = '\0';
     }
-    var178[var212] = var214;
     }
-    }
-    var173 = jsVideoCodec(var177, var178);
-    if (JS_NewNumberValue(cx, var173, &var223) != JS_TRUE) {
+    var170 = jsVideoCodec(var174);
+    if (JS_NewNumberValue(cx, var170, &var182) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+5] = var223;
+    argv[argc+2] = var182;
     if (rval) {
-        *rval = var223;
+        *rval = var182;
     }
-    var171 = JS_TRUE;
+    var168 = JS_TRUE;
     do_return:
-    if (var221) {
-        free(var178);
-        var178 = NULL;
-        var221 = 0;
+    if (var181) {
+        JS_free(cx, var174);
+        var174 = NULL;
+        var181 = 0;
     }
-    if (var220) {
-        free(var209);
-        var209 = NULL;
-        var220 = 0;
-    }
-    if (var219) {
-        free(var202);
-        var202 = NULL;
-        var219 = 0;
-    }
-    if (var185) {
-        free(var177);
-        var177 = NULL;
-        var185 = 0;
-    }
-    return var171;
+    return var168;
 }
 static JSBool
 jjadmaddVideoFilter_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var225;
-    int var226;
-    int var229;
-    char *var230;
-    int var232;
-    jsval var233;
-    JSString *var234;
-    jsval var414;
-    size_t var235;
-    size_t var236;
-    int var238;
-    jschar *var239;
-    jsval var415;
-    char **var231;
-    int var240;
-    jsval var241;
-    JSObject *var242;
-    jsval var416;
-    jsuint var243;
-    size_t var247;
-    JSString *var248;
-    size_t var249;
-    JSString **var255;
-    int var272;
-    jsuint var250;
-    jsint var251;
-    JSBool var252;
-    jsval var253;
-    JSString *var254;
-    jsval var417;
-    size_t var258;
-    jsuint var256;
-    jsint var257;
-    JSString *var260;
-    size_t var259;
-    size_t var261;
-    char var270;
-    size_t var271;
-    char *var262;
-    int var273;
-    char *var263;
-    size_t var264;
-    int var274;
-    char *var267;
-    jsuint var265;
-    jsint var266;
-    JSString *var269;
-    size_t var268;
-    jschar *var275;
-    jsval var418;
-    jsval var276;
-    JSBool var224;
-    var225 = NULL;
-    var226 = 0;
-    var229 = 0;
-    var230 = NULL;
-    var232 = 0;
-    var233 = JSVAL_NULL;
-    var234 = NULL;
-    var414 = JSVAL_NULL;
-    var235 = 0;
-    var236 = 0;
-    var238 = 0;
-    var239 = NULL;
-    var415 = JSVAL_NULL;
-    var231 = NULL;
-    var240 = 0;
-    var241 = JSVAL_NULL;
-    var242 = NULL;
-    var416 = JSVAL_NULL;
-    var243 = 0;
-    var247 = 0;
-    var248 = NULL;
-    var249 = 0;
-    var255 = NULL;
-    var272 = 0;
-    var250 = 0;
-    var251 = 0;
-    var252 = JS_FALSE;
-    var253 = JSVAL_NULL;
-    var254 = NULL;
-    var417 = JSVAL_NULL;
-    var258 = 0;
-    var256 = 0;
-    var257 = 0;
-    var260 = NULL;
-    var259 = 0;
-    var261 = 0;
-    var270 = 0;
-    var271 = 0;
-    var262 = NULL;
-    var273 = 0;
-    var263 = NULL;
-    var264 = 0;
-    var274 = 0;
-    var267 = NULL;
-    var265 = 0;
-    var266 = 0;
-    var269 = NULL;
-    var268 = 0;
-    var275 = NULL;
-    var418 = JSVAL_NULL;
-    var276 = JSVAL_NULL;
-    var224 = JS_FALSE;
-    var225 = obj;
-    var229 = argc;
-    var232 = 0;
-    var232 = var232 < var229;
-    if (var232) {
-    var233 = argv[0];
-    var234 = JS_ValueToString(cx, var233);
-    if (!var234) {
+    JSObject *var184;
+    char *var189;
+    int var185;
+    int var188;
+    int var190;
+    jsval var191;
+    JSString *var192;
+    jsval var256;
+    size_t var193;
+    size_t var194;
+    int var196;
+    jschar *var195;
+    jsval var257;
+    jsval var197;
+    JSBool var183;
+    var184 = NULL;
+    var189 = NULL;
+    var185 = 0;
+    var188 = 0;
+    var190 = 0;
+    var191 = JSVAL_NULL;
+    var192 = NULL;
+    var256 = JSVAL_NULL;
+    var193 = 0;
+    var194 = 0;
+    var196 = 0;
+    var195 = NULL;
+    var257 = JSVAL_NULL;
+    var197 = JSVAL_NULL;
+    var183 = JS_FALSE;
+    var184 = obj;
+    var188 = argc;
+    var190 = 0;
+    var190 = var190 < var188;
+    if (var190) {
+    var191 = argv[0];
+    var192 = JS_ValueToString(cx, var191);
+    if (!var192) {
         goto do_return;
     }
-    var414 = STRING_TO_JSVAL(var234);
-    argv[argc+0] = var414;
-    var235 = JS_GetStringLength(var234);
-    var236 = 1;
-    var236 += var235;
-#ifdef HAVE_ALLOCA
-    if (var236 < jj_alloca_limit) {
-        var230 = alloca(var236);
-    } else {
-#endif
-        var230 = malloc(var236);
-        if (!var230) {
-            goto do_return;
-        } else {
-            var238 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var239 = JS_GetStringChars(var234);
-    var415 = STRING_TO_JSVAL(var234);
-    argv[argc+1] = var415;
-    {
-        size_t i;
-        for (i = 0; i < var235; ++i) {
-            var230[i] = wctob(var239[i]);
-        }
-        var230[var235] = '\0';
-    }
-    }
-    var240 = 1;
-    var240 = var240 < var229;
-    if (var240) {
-    var241 = argv[1];
-    if (JS_ValueToObject(cx, var241, &var242) != JS_TRUE) {
+    var256 = STRING_TO_JSVAL(var192);
+    argv[argc+0] = var256;
+    var193 = JS_GetStringLength(var192);
+    var194 = 1;
+    var194 += var193;
+    var189 = JS_malloc(cx, var194);
+    if (!var189) {
         goto do_return;
     }
-    var416 = OBJECT_TO_JSVAL(var242);
-    argv[argc+2] = var416;
-    if (JS_GetArrayLength(cx, var242, &var243) != JS_TRUE) {
-        goto do_return;
-    }
-    var247 = var243;
-    var249 = sizeof(var248);
-    var247 *= var249;
-#ifdef HAVE_ALLOCA
-    if (var247 < jj_alloca_limit) {
-        var255 = alloca(var247);
-    } else {
-#endif
-        var255 = malloc(var247);
-        if (!var255) {
-            goto do_return;
-        } else {
-            var272 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var250 = var243;
-    var251 = -1;
-    while (var250)
+    var196 = 1;
+    var195 = JS_GetStringChars(var192);
+    var257 = STRING_TO_JSVAL(var192);
+    argv[argc+1] = var257;
     {
-    var250 += var251;
-    var252 = JS_GetElement(cx, var242, var250, &var253);
-    var254 = JS_ValueToString(cx, var253);
-    if (!var254) {
-        goto do_return;
-    }
-    var417 = STRING_TO_JSVAL(var254);
-    argv[argc+3] = var417;
-    var255[var250] = var254;
-    }
-    var258 = 0;
-    var256 = var243;
-    var257 = -1;
-    while (var256)
-    {
-    var256 += var257;
-    var260 = var255[var256];
-    var259 = JS_GetStringLength(var260);
-    var258 += var259;
-    var261 = 1;
-    var258 += var261;
-    }
-    var271 = sizeof(var270);
-    var271 *= var258;
-#ifdef HAVE_ALLOCA
-    if (var271 < jj_alloca_limit) {
-        var262 = alloca(var271);
-    } else {
-#endif
-        var262 = malloc(var271);
-        if (!var262) {
-            goto do_return;
-        } else {
-            var273 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var264 = sizeof(var263);
-    var264 *= var243;
-#ifdef HAVE_ALLOCA
-    if (var264 < jj_alloca_limit) {
-        var231 = alloca(var264);
-    } else {
-#endif
-        var231 = malloc(var264);
-        if (!var231) {
-            goto do_return;
-        } else {
-            var274 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var267 = var262;
-    var267 += var258;
-    var265 = var243;
-    var266 = -1;
-    while (var265)
-    {
-    var265 += var266;
-    var269 = var255[var265];
-    var268 = JS_GetStringLength(var269);
-    var267 -= var268;
-    var267 += var266;
-    var275 = JS_GetStringChars(var269);
-    var418 = STRING_TO_JSVAL(var269);
-    argv[argc+4] = var418;
-    {
         size_t i;
-        for (i = 0; i < var268; ++i) {
-            var267[i] = wctob(var275[i]);
+        for (i = 0; i < var193; ++i) {
+            var189[i] = wctob(var195[i]);
         }
-        var267[var268] = '\0';
+        var189[var193] = '\0';
     }
-    var231[var265] = var267;
     }
-    }
-    var226 = jsVideoFilter(var230, var231);
-    if (JS_NewNumberValue(cx, var226, &var276) != JS_TRUE) {
+    var185 = jsVideoFilter(var189);
+    if (JS_NewNumberValue(cx, var185, &var197) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+5] = var276;
+    argv[argc+2] = var197;
     if (rval) {
-        *rval = var276;
+        *rval = var197;
     }
-    var224 = JS_TRUE;
+    var183 = JS_TRUE;
     do_return:
-    if (var274) {
-        free(var231);
-        var231 = NULL;
-        var274 = 0;
+    if (var196) {
+        JS_free(cx, var189);
+        var189 = NULL;
+        var196 = 0;
     }
-    if (var273) {
-        free(var262);
-        var262 = NULL;
-        var273 = 0;
-    }
-    if (var272) {
-        free(var255);
-        var255 = NULL;
-        var272 = 0;
-    }
-    if (var238) {
-        free(var230);
-        var230 = NULL;
-        var238 = 0;
-    }
-    return var224;
+    return var183;
 }
 static JSBool
 jjadmaudioCodec_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var278;
-    int var279;
-    int var282;
-    char *var283;
-    int var285;
-    jsval var286;
-    JSString *var287;
-    jsval var420;
-    size_t var288;
-    size_t var289;
-    int var291;
-    jschar *var292;
-    jsval var421;
-    char **var284;
-    int var293;
-    jsval var294;
-    JSObject *var295;
-    jsval var422;
-    jsuint var296;
-    size_t var300;
-    JSString *var301;
-    size_t var302;
-    JSString **var308;
-    int var325;
-    jsuint var303;
-    jsint var304;
-    JSBool var305;
-    jsval var306;
-    JSString *var307;
-    jsval var423;
-    size_t var311;
-    jsuint var309;
-    jsint var310;
-    JSString *var313;
-    size_t var312;
-    size_t var314;
-    char var323;
-    size_t var324;
-    char *var315;
-    int var326;
-    char *var316;
-    size_t var317;
-    int var327;
-    char *var320;
-    jsuint var318;
-    jsint var319;
-    JSString *var322;
-    size_t var321;
-    jschar *var328;
-    jsval var424;
-    jsval var329;
-    JSBool var277;
-    var278 = NULL;
-    var279 = 0;
-    var282 = 0;
-    var283 = NULL;
-    var285 = 0;
-    var286 = JSVAL_NULL;
-    var287 = NULL;
-    var420 = JSVAL_NULL;
-    var288 = 0;
-    var289 = 0;
-    var291 = 0;
-    var292 = NULL;
-    var421 = JSVAL_NULL;
-    var284 = NULL;
-    var293 = 0;
-    var294 = JSVAL_NULL;
-    var295 = NULL;
-    var422 = JSVAL_NULL;
-    var296 = 0;
-    var300 = 0;
-    var301 = NULL;
-    var302 = 0;
-    var308 = NULL;
-    var325 = 0;
-    var303 = 0;
-    var304 = 0;
-    var305 = JS_FALSE;
-    var306 = JSVAL_NULL;
-    var307 = NULL;
-    var423 = JSVAL_NULL;
-    var311 = 0;
-    var309 = 0;
-    var310 = 0;
-    var313 = NULL;
-    var312 = 0;
-    var314 = 0;
-    var323 = 0;
-    var324 = 0;
-    var315 = NULL;
-    var326 = 0;
-    var316 = NULL;
-    var317 = 0;
-    var327 = 0;
-    var320 = NULL;
-    var318 = 0;
-    var319 = 0;
-    var322 = NULL;
-    var321 = 0;
-    var328 = NULL;
-    var424 = JSVAL_NULL;
-    var329 = JSVAL_NULL;
-    var277 = JS_FALSE;
-    var278 = obj;
-    var282 = argc;
-    var285 = 0;
-    var285 = var285 < var282;
-    if (var285) {
-    var286 = argv[0];
-    var287 = JS_ValueToString(cx, var286);
-    if (!var287) {
+    JSObject *var199;
+    char *var204;
+    int var200;
+    int var203;
+    int var205;
+    jsval var206;
+    JSString *var207;
+    jsval var259;
+    size_t var208;
+    size_t var209;
+    int var211;
+    jschar *var210;
+    jsval var260;
+    jsval var212;
+    JSBool var198;
+    var199 = NULL;
+    var204 = NULL;
+    var200 = 0;
+    var203 = 0;
+    var205 = 0;
+    var206 = JSVAL_NULL;
+    var207 = NULL;
+    var259 = JSVAL_NULL;
+    var208 = 0;
+    var209 = 0;
+    var211 = 0;
+    var210 = NULL;
+    var260 = JSVAL_NULL;
+    var212 = JSVAL_NULL;
+    var198 = JS_FALSE;
+    var199 = obj;
+    var203 = argc;
+    var205 = 0;
+    var205 = var205 < var203;
+    if (var205) {
+    var206 = argv[0];
+    var207 = JS_ValueToString(cx, var206);
+    if (!var207) {
         goto do_return;
     }
-    var420 = STRING_TO_JSVAL(var287);
-    argv[argc+0] = var420;
-    var288 = JS_GetStringLength(var287);
-    var289 = 1;
-    var289 += var288;
-#ifdef HAVE_ALLOCA
-    if (var289 < jj_alloca_limit) {
-        var283 = alloca(var289);
-    } else {
-#endif
-        var283 = malloc(var289);
-        if (!var283) {
-            goto do_return;
-        } else {
-            var291 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var292 = JS_GetStringChars(var287);
-    var421 = STRING_TO_JSVAL(var287);
-    argv[argc+1] = var421;
-    {
-        size_t i;
-        for (i = 0; i < var288; ++i) {
-            var283[i] = wctob(var292[i]);
-        }
-        var283[var288] = '\0';
-    }
-    }
-    var293 = 1;
-    var293 = var293 < var282;
-    if (var293) {
-    var294 = argv[1];
-    if (JS_ValueToObject(cx, var294, &var295) != JS_TRUE) {
+    var259 = STRING_TO_JSVAL(var207);
+    argv[argc+0] = var259;
+    var208 = JS_GetStringLength(var207);
+    var209 = 1;
+    var209 += var208;
+    var204 = JS_malloc(cx, var209);
+    if (!var204) {
         goto do_return;
     }
-    var422 = OBJECT_TO_JSVAL(var295);
-    argv[argc+2] = var422;
-    if (JS_GetArrayLength(cx, var295, &var296) != JS_TRUE) {
-        goto do_return;
-    }
-    var300 = var296;
-    var302 = sizeof(var301);
-    var300 *= var302;
-#ifdef HAVE_ALLOCA
-    if (var300 < jj_alloca_limit) {
-        var308 = alloca(var300);
-    } else {
-#endif
-        var308 = malloc(var300);
-        if (!var308) {
-            goto do_return;
-        } else {
-            var325 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var303 = var296;
-    var304 = -1;
-    while (var303)
+    var211 = 1;
+    var210 = JS_GetStringChars(var207);
+    var260 = STRING_TO_JSVAL(var207);
+    argv[argc+1] = var260;
     {
-    var303 += var304;
-    var305 = JS_GetElement(cx, var295, var303, &var306);
-    var307 = JS_ValueToString(cx, var306);
-    if (!var307) {
-        goto do_return;
-    }
-    var423 = STRING_TO_JSVAL(var307);
-    argv[argc+3] = var423;
-    var308[var303] = var307;
-    }
-    var311 = 0;
-    var309 = var296;
-    var310 = -1;
-    while (var309)
-    {
-    var309 += var310;
-    var313 = var308[var309];
-    var312 = JS_GetStringLength(var313);
-    var311 += var312;
-    var314 = 1;
-    var311 += var314;
-    }
-    var324 = sizeof(var323);
-    var324 *= var311;
-#ifdef HAVE_ALLOCA
-    if (var324 < jj_alloca_limit) {
-        var315 = alloca(var324);
-    } else {
-#endif
-        var315 = malloc(var324);
-        if (!var315) {
-            goto do_return;
-        } else {
-            var326 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var317 = sizeof(var316);
-    var317 *= var296;
-#ifdef HAVE_ALLOCA
-    if (var317 < jj_alloca_limit) {
-        var284 = alloca(var317);
-    } else {
-#endif
-        var284 = malloc(var317);
-        if (!var284) {
-            goto do_return;
-        } else {
-            var327 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var320 = var315;
-    var320 += var311;
-    var318 = var296;
-    var319 = -1;
-    while (var318)
-    {
-    var318 += var319;
-    var322 = var308[var318];
-    var321 = JS_GetStringLength(var322);
-    var320 -= var321;
-    var320 += var319;
-    var328 = JS_GetStringChars(var322);
-    var424 = STRING_TO_JSVAL(var322);
-    argv[argc+4] = var424;
-    {
         size_t i;
-        for (i = 0; i < var321; ++i) {
-            var320[i] = wctob(var328[i]);
+        for (i = 0; i < var208; ++i) {
+            var204[i] = wctob(var210[i]);
         }
-        var320[var321] = '\0';
+        var204[var208] = '\0';
     }
-    var284[var318] = var320;
     }
-    }
-    var279 = jsAudioCodec(var283, var284);
-    if (JS_NewNumberValue(cx, var279, &var329) != JS_TRUE) {
+    var200 = jsAudioCodec(var204);
+    if (JS_NewNumberValue(cx, var200, &var212) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+5] = var329;
+    argv[argc+2] = var212;
     if (rval) {
-        *rval = var329;
+        *rval = var212;
     }
-    var277 = JS_TRUE;
+    var198 = JS_TRUE;
     do_return:
-    if (var327) {
-        free(var284);
-        var284 = NULL;
-        var327 = 0;
+    if (var211) {
+        JS_free(cx, var204);
+        var204 = NULL;
+        var211 = 0;
     }
-    if (var326) {
-        free(var315);
-        var315 = NULL;
-        var326 = 0;
-    }
-    if (var325) {
-        free(var308);
-        var308 = NULL;
-        var325 = 0;
-    }
-    if (var291) {
-        free(var283);
-        var283 = NULL;
-        var291 = 0;
-    }
-    return var277;
+    return var198;
 }
 static JSBool
 jjadmsetContainer_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var331;
-    int var332;
-    int var335;
-    char *var336;
-    int var338;
-    jsval var339;
-    JSString *var340;
-    jsval var426;
-    size_t var341;
-    size_t var342;
-    int var344;
-    jschar *var345;
-    jsval var427;
-    char **var337;
-    int var346;
-    jsval var347;
-    JSObject *var348;
-    jsval var428;
-    jsuint var349;
-    size_t var353;
-    JSString *var354;
-    size_t var355;
-    JSString **var361;
-    int var378;
-    jsuint var356;
-    jsint var357;
-    JSBool var358;
-    jsval var359;
-    JSString *var360;
-    jsval var429;
-    size_t var364;
-    jsuint var362;
-    jsint var363;
-    JSString *var366;
-    size_t var365;
-    size_t var367;
-    char var376;
-    size_t var377;
-    char *var368;
-    int var379;
-    char *var369;
-    size_t var370;
-    int var380;
-    char *var373;
-    jsuint var371;
-    jsint var372;
-    JSString *var375;
-    size_t var374;
-    jschar *var381;
-    jsval var430;
-    jsval var382;
-    JSBool var330;
-    var331 = NULL;
-    var332 = 0;
-    var335 = 0;
-    var336 = NULL;
-    var338 = 0;
-    var339 = JSVAL_NULL;
-    var340 = NULL;
-    var426 = JSVAL_NULL;
-    var341 = 0;
-    var342 = 0;
-    var344 = 0;
-    var345 = NULL;
-    var427 = JSVAL_NULL;
-    var337 = NULL;
-    var346 = 0;
-    var347 = JSVAL_NULL;
-    var348 = NULL;
-    var428 = JSVAL_NULL;
-    var349 = 0;
-    var353 = 0;
-    var354 = NULL;
-    var355 = 0;
-    var361 = NULL;
-    var378 = 0;
-    var356 = 0;
-    var357 = 0;
-    var358 = JS_FALSE;
-    var359 = JSVAL_NULL;
-    var360 = NULL;
-    var429 = JSVAL_NULL;
-    var364 = 0;
-    var362 = 0;
-    var363 = 0;
-    var366 = NULL;
-    var365 = 0;
-    var367 = 0;
-    var376 = 0;
-    var377 = 0;
-    var368 = NULL;
-    var379 = 0;
-    var369 = NULL;
-    var370 = 0;
-    var380 = 0;
-    var373 = NULL;
-    var371 = 0;
-    var372 = 0;
-    var375 = NULL;
-    var374 = 0;
-    var381 = NULL;
-    var430 = JSVAL_NULL;
-    var382 = JSVAL_NULL;
-    var330 = JS_FALSE;
-    var331 = obj;
-    var335 = argc;
-    var338 = 0;
-    var338 = var338 < var335;
-    if (var338) {
-    var339 = argv[0];
-    var340 = JS_ValueToString(cx, var339);
-    if (!var340) {
+    JSObject *var214;
+    char *var219;
+    int var215;
+    int var218;
+    int var220;
+    jsval var221;
+    JSString *var222;
+    jsval var262;
+    size_t var223;
+    size_t var224;
+    int var226;
+    jschar *var225;
+    jsval var263;
+    jsval var227;
+    JSBool var213;
+    var214 = NULL;
+    var219 = NULL;
+    var215 = 0;
+    var218 = 0;
+    var220 = 0;
+    var221 = JSVAL_NULL;
+    var222 = NULL;
+    var262 = JSVAL_NULL;
+    var223 = 0;
+    var224 = 0;
+    var226 = 0;
+    var225 = NULL;
+    var263 = JSVAL_NULL;
+    var227 = JSVAL_NULL;
+    var213 = JS_FALSE;
+    var214 = obj;
+    var218 = argc;
+    var220 = 0;
+    var220 = var220 < var218;
+    if (var220) {
+    var221 = argv[0];
+    var222 = JS_ValueToString(cx, var221);
+    if (!var222) {
         goto do_return;
     }
-    var426 = STRING_TO_JSVAL(var340);
-    argv[argc+0] = var426;
-    var341 = JS_GetStringLength(var340);
-    var342 = 1;
-    var342 += var341;
-#ifdef HAVE_ALLOCA
-    if (var342 < jj_alloca_limit) {
-        var336 = alloca(var342);
-    } else {
-#endif
-        var336 = malloc(var342);
-        if (!var336) {
-            goto do_return;
-        } else {
-            var344 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var345 = JS_GetStringChars(var340);
-    var427 = STRING_TO_JSVAL(var340);
-    argv[argc+1] = var427;
-    {
-        size_t i;
-        for (i = 0; i < var341; ++i) {
-            var336[i] = wctob(var345[i]);
-        }
-        var336[var341] = '\0';
-    }
-    }
-    var346 = 1;
-    var346 = var346 < var335;
-    if (var346) {
-    var347 = argv[1];
-    if (JS_ValueToObject(cx, var347, &var348) != JS_TRUE) {
+    var262 = STRING_TO_JSVAL(var222);
+    argv[argc+0] = var262;
+    var223 = JS_GetStringLength(var222);
+    var224 = 1;
+    var224 += var223;
+    var219 = JS_malloc(cx, var224);
+    if (!var219) {
         goto do_return;
     }
-    var428 = OBJECT_TO_JSVAL(var348);
-    argv[argc+2] = var428;
-    if (JS_GetArrayLength(cx, var348, &var349) != JS_TRUE) {
-        goto do_return;
-    }
-    var353 = var349;
-    var355 = sizeof(var354);
-    var353 *= var355;
-#ifdef HAVE_ALLOCA
-    if (var353 < jj_alloca_limit) {
-        var361 = alloca(var353);
-    } else {
-#endif
-        var361 = malloc(var353);
-        if (!var361) {
-            goto do_return;
-        } else {
-            var378 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var356 = var349;
-    var357 = -1;
-    while (var356)
+    var226 = 1;
+    var225 = JS_GetStringChars(var222);
+    var263 = STRING_TO_JSVAL(var222);
+    argv[argc+1] = var263;
     {
-    var356 += var357;
-    var358 = JS_GetElement(cx, var348, var356, &var359);
-    var360 = JS_ValueToString(cx, var359);
-    if (!var360) {
-        goto do_return;
-    }
-    var429 = STRING_TO_JSVAL(var360);
-    argv[argc+3] = var429;
-    var361[var356] = var360;
-    }
-    var364 = 0;
-    var362 = var349;
-    var363 = -1;
-    while (var362)
-    {
-    var362 += var363;
-    var366 = var361[var362];
-    var365 = JS_GetStringLength(var366);
-    var364 += var365;
-    var367 = 1;
-    var364 += var367;
-    }
-    var377 = sizeof(var376);
-    var377 *= var364;
-#ifdef HAVE_ALLOCA
-    if (var377 < jj_alloca_limit) {
-        var368 = alloca(var377);
-    } else {
-#endif
-        var368 = malloc(var377);
-        if (!var368) {
-            goto do_return;
-        } else {
-            var379 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var370 = sizeof(var369);
-    var370 *= var349;
-#ifdef HAVE_ALLOCA
-    if (var370 < jj_alloca_limit) {
-        var337 = alloca(var370);
-    } else {
-#endif
-        var337 = malloc(var370);
-        if (!var337) {
-            goto do_return;
-        } else {
-            var380 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var373 = var368;
-    var373 += var364;
-    var371 = var349;
-    var372 = -1;
-    while (var371)
-    {
-    var371 += var372;
-    var375 = var361[var371];
-    var374 = JS_GetStringLength(var375);
-    var373 -= var374;
-    var373 += var372;
-    var381 = JS_GetStringChars(var375);
-    var430 = STRING_TO_JSVAL(var375);
-    argv[argc+4] = var430;
-    {
         size_t i;
-        for (i = 0; i < var374; ++i) {
-            var373[i] = wctob(var381[i]);
+        for (i = 0; i < var223; ++i) {
+            var219[i] = wctob(var225[i]);
         }
-        var373[var374] = '\0';
+        var219[var223] = '\0';
     }
-    var337[var371] = var373;
     }
-    }
-    var332 = jsSetContainer(var336, var337);
-    if (JS_NewNumberValue(cx, var332, &var382) != JS_TRUE) {
+    var215 = jsSetContainer(var219);
+    if (JS_NewNumberValue(cx, var215, &var227) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+5] = var382;
+    argv[argc+2] = var227;
     if (rval) {
-        *rval = var382;
+        *rval = var227;
     }
-    var330 = JS_TRUE;
+    var213 = JS_TRUE;
     do_return:
-    if (var380) {
-        free(var337);
-        var337 = NULL;
-        var380 = 0;
+    if (var226) {
+        JS_free(cx, var219);
+        var219 = NULL;
+        var226 = 0;
     }
-    if (var379) {
-        free(var368);
-        var368 = NULL;
-        var379 = 0;
-    }
-    if (var378) {
-        free(var361);
-        var361 = NULL;
-        var378 = 0;
-    }
-    if (var344) {
-        free(var336);
-        var336 = NULL;
-        var344 = 0;
-    }
-    return var330;
+    return var213;
 }
 static JSBool
 jjadm__construct__(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var384;
-    int var388;
-    JSBool var383;
-    var384 = NULL;
-    var388 = 0;
-    var383 = JS_FALSE;
-    var384 = obj;
-    var388 = argc;
+    JSObject *var229;
+    int var233;
+    JSBool var228;
+    var229 = NULL;
+    var233 = 0;
+    var228 = JS_FALSE;
+    var229 = obj;
+    var233 = argc;
     jsAvidemux();
-    var383 = JS_TRUE;
-    return var383;
+    var228 = JS_TRUE;
+    return var228;
 }
 static JSPropertySpec jjadm_static_ps[] = {
     {"markerA", 0, 0|JSPROP_ENUMERATE, jjadmmarkerA_get, jjadmmarkerA_set},
@@ -2037,10 +1167,10 @@
     JS_FS("audioReset", jjadmaudioReset, 0, 0, 1),
     JS_FS("audioMixer", jjadmaudioMixer, 1, 0, 3),
     JS_FS("clearVideoFilters", jjadmclearVideoFilters, 0, 0, 1),
-    JS_FS("videoCodec", jsAdmvideoCodec,  2, 0, 6),
-    JS_FS("addVideoFilter", jsAdmaddVideoFilter,  2, 0, 6),
-    JS_FS("audioCodec", jsAdmaudioCodec,  2, 0, 6),
-    JS_FS("setContainer", jsAdmsetContainer,  2, 0, 6),
+    JS_FS("videoCodec", jsAdmvideoCodec,  1, 0, 3),
+    JS_FS("addVideoFilter", jsAdmaddVideoFilter,  1, 0, 3),
+    JS_FS("audioCodec", jsAdmaudioCodec,  1, 0, 3),
+    JS_FS("setContainer", jsAdmsetContainer,  1, 0, 3),
     JS_FS_END
 };
 static JSFunctionSpec jjadm_fs[] = {

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl	2010-03-03 18:50:20 UTC (rev 5966)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl	2010-03-03 18:50:22 UTC (rev 5967)
@@ -25,10 +25,10 @@
         function int clearVideoFilters   : jsClearVideoFilters() <static>;
         
 /* Override as jsapigen cannot handle multiple args the way we need it to */
-        function int videoCodec_ignore     : jsVideoCodec(cstring,cstring[])   <static>;
-        function int addVideoFilter_ignore : jsVideoFilter(cstring,cstring[])   <static>;
-        function int audioCodec_ignore     : jsAudioCodec(cstring,cstring[])   <static>;
-        function int setContainer_ignore   : jsSetContainer(cstring,cstring[])   <static>;
+        function int videoCodec_ignore     : jsVideoCodec(cstring)     <static>;
+        function int addVideoFilter_ignore : jsVideoFilter(cstring)    <static>;
+        function int audioCodec_ignore     : jsAudioCodec(cstring)     <static>;
+        function int setContainer_ignore   : jsSetContainer(cstring)   <static>;
 /* Properties */
         property double markerA            : jsGetMarkerA,jsSetMarkerA <static>;
         property double markerB            : jsGetMarkerB,jsSetMarkerB <static>;



From mean at mail.berlios.de  Fri Mar  5 07:18:37 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Mar 2010 07:18:37 +0100
Subject: [Avidemux-svn-commit] r5973 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif
Message-ID: <201003050618.o256IbTl014261@sheep.berlios.de>

Author: mean
Date: 2010-03-05 07:18:35 +0100 (Fri, 05 Mar 2010)
New Revision: 5973

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp
Log:
[yadif] update to new filter scheme

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp	2010-03-04 06:39:10 UTC (rev 5972)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp	2010-03-05 06:18:35 UTC (rev 5973)
@@ -62,10 +62,10 @@
                     yadifFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
                     ~yadifFilter();
 
-       virtual const char   *getConfiguration(void);                 /// Return  current configuration as a human readable string
-       virtual bool         getNextFrame(ADMImage *image);           /// Return the next image
-	   virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
-       virtual bool         configure(void) ;                        /// Start graphical user interface
+        virtual const char   *getConfiguration(void);                 /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);           /// Return the next image
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;                        /// Start graphical user interface
 };
 
 // Add the hook to make it valid plugin
@@ -175,9 +175,9 @@
     \fn getConfiguration
     \brief Return current setting as a string
 */
-bool yadifFilter::getNextFrame(ADMImage *image)
+bool yadifFilter::getNextFrame(uint32_t *fn,ADMImage *image)
 {
-#if 0
+
         int mode;
         int parity;
         int tff;
@@ -190,9 +190,9 @@
         mode = configuration.mode;
 
         if (mode & 1) 
-                n = (frame>>1); // bob
+                n = (nextFrame>>1); // bob
         else
-                n = frame;
+                n = nextFrame;
 
         src = vidCache->getImage(n);
   // Request frame 'n' from the child (source) clip.
@@ -200,18 +200,16 @@
         if (n>0)
                 prev =  vidCache->getImage( n-1); // get previous frame
         else
-                prev= vidCache->getImage(0); // get very first frame
+                prev= src; // get very first frame
 
-        if (n< _in->getInfo()->nb_frames-1)
-                next = vidCache->getImage( n+1); // get next frame
-        else
-                next = vidCache->getImage( _in->getInfo()->nb_frames-1); // get last frame
+        next=vidCache->getImage(n+1);
+        if(!next) next=src;
 
-        dst = data;
+        dst = image;
         
         if(!prev || !src || !next)
         {
-            printf("Failed to read frame for frame %u\n",frame);
+            printf("Failed to read frame for frame %u\n",nextFrame);
             vidCache->unlockAll();
             return 0;
         }
@@ -226,7 +224,7 @@
 #endif
                 tff = configuration.order;	
         
-        parity = (mode & 1) ? (frame & 1) ^ (1^tff) : (tff ^ 1);  // 0 or 1
+        parity = (mode & 1) ? (nextFrame & 1) ^ (1^tff) : (tff ^ 1);  // 0 or 1
 
       //MEANX  cpu = avs_get_cpu_flags(p->env);
 
@@ -289,8 +287,8 @@
                 if (next_pitch != src_pitch)
                         ADM_dealloc(nextp);
         }
-       vidCache->unlockAll();
-#endif
+      vidCache->unlockAll();
+      nextFrame++;
       return 1;
 }
 //****************



From mean at mail.berlios.de  Fri Mar  5 07:18:56 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Mar 2010 07:18:56 +0100
Subject: [Avidemux-svn-commit] r5974 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_videoFilter2/include
	avidemux/common/ADM_videoFilter2/src
	avidemux_core/ADM_coreImage/include avidemux_core/ADM_coreImage/src
	avidemux_core/ADM_coreVideoFilter/include
	avidemux_core/ADM_coreVideoFilter/src
	avidemux_plugins/ADM_videoEncoder/null
	avidemux_plugins/ADM_videoEncoder/png
	avidemux_plugins/ADM_videoEncoder/yv12
	avidemux_plugins/ADM_videoFilters6/dummy
	avidemux_plugins/ADM_videoFilters6/verticalFlip
Message-ID: <201003050618.o256IuEj014527@sheep.berlios.de>

Author: mean
Date: 2010-03-05 07:18:44 +0100 (Fri, 05 Mar 2010)
New Revision: 5974

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_videoFilterCache.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_videoFilterCache.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/png/ADM_pngEncoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/yv12/ADM_yv12Encoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/verticalFlip/verticalFlip.cpp
Log:
[filter] Add a sort-of-frame-number to the api, reintroduce video cache

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h	2010-03-05 06:18:44 UTC (rev 5974)
@@ -31,14 +31,13 @@
         FilterInfo          bridgeInfo;
         bool                firstImage;
         uint32_t            lastSentImage;
-        virtual bool        nextFrame(ADMImage *image);    /// Return the next image
 public:
                             ADM_videoFilterBridge(uint64_t startTime, uint64_t endTime);
                             ~ADM_videoFilterBridge();
        virtual bool         goToTime(uint64_t usSeek);  
-       virtual bool         getNextFrame(ADMImage *image);      
-	   virtual FilterInfo  *getInfo(void);                                      /// Return picture parameters after this filter
-	   virtual bool         getCoupledConf(CONFcouple **couples) {*couples=NULL;return true;} ; /// Return the current filter configuration
+       virtual bool         getNextFrame(uint32_t *frameNumber,ADMImage *image);      
+       virtual FilterInfo  *getInfo(void);                                      /// Return picture parameters after this filter
+       virtual bool         getCoupledConf(CONFcouple **couples) {*couples=NULL;return true;} ; /// Return the current filter configuration
 
         bool                rewind(void);
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp	2010-03-05 06:18:44 UTC (rev 5974)
@@ -65,7 +65,7 @@
     \fn getNextFrame
     \brief
 */
-bool         ADM_videoFilterBridge::nextFrame(ADMImage *image)
+bool         ADM_videoFilterBridge::getNextFrame(uint32_t *frameNumber,ADMImage *image)
 {
 again:
     bool r=false;
@@ -74,9 +74,12 @@
         firstImage=false;
         r=video_body->samePicture(image);
         lastSentImage=0;
+        *frameNumber=nextFrame=0;
     }else
     {
         r=   video_body->nextPicture(image);
+        nextFrame++;
+        *frameNumber=nextFrame;
         lastSentImage++;
     }
     if(r==false) return false;
@@ -97,16 +100,6 @@
     return true;
 }
 /**
-    \fn getFrame
-    \brief This one is special. the lower level can only do sequential access
-            so we in case of non-sequential access we rely on the cache of decoded image.
-            (TODO)
-*/
-bool         ADM_videoFilterBridge::getNextFrame(ADMImage *image)
-{  
-        return nextFrame(image);
-}
-/**
     \fn ADM_videoFilterBridge
 
 */

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_videoFilterCache.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_videoFilterCache.h	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_videoFilterCache.h	2010-03-05 06:18:44 UTC (rev 5974)
@@ -1,52 +0,0 @@
-//
-// C++ Interface: ADM_cache
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#ifndef __ADM_CACHE__
-#define __ADM_CACHE__
-#include "ADM_coreVideoFilter.h"
-/**
-    \struct videoCacheEntry
-*/
-typedef struct vidCacheEntry
-{
-		uint32_t 	frameNum;
-		ADMImage 	*frameBuffer;
-		uint8_t		frameLock;		
-		uint32_t	lastUse;
-
-}vidCacheEntry;
-/**
-    \class VideoCache
-*/
-class VideoCache
-{
-	private:
-		vidCacheEntry	    *entry;
-		uint32_t	        counter;
-		uint32_t 	        nbEntry;
-		FilterInfo           info;
-		ADM_coreVideoFilter *incoming;
-		
-		
-		int32_t 	        searchFrame( uint32_t frame);
-		int32_t 	        searchPtr( ADMImage *ptr);
-		
-	public:
-		VideoCache(uint32_t nb,ADM_coreVideoFilter *in);
-		~VideoCache(void);
-		
-		ADMImage *getImage(uint32_t frame);
-		uint8_t unlockAll(void);
-		uint8_t unlock(ADMImage  *frame);
-		uint8_t purge(void);
-};
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_videoFilterCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_videoFilterCache.cpp	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_videoFilterCache.cpp	2010-03-05 06:18:44 UTC (rev 5974)
@@ -1,154 +0,0 @@
-/** *************************************************************************
-        \file                  ADM_videoFilterCache.cpp
-        \brief Cache/buffer for video filter
-		\author (c) 2008/2010 Mean, fixounet at free.fr
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "ADM_default.h"
-#include "ADM_videoFilterCache.h"
-
-#if 1
-#define aprintf(...) {}
-#else
-#define aprintf printf
-#endif
-
-VideoCache::VideoCache(uint32_t nb,ADM_coreVideoFilter *in)
-{
-uint32_t sz;
-	nbEntry=nb;
-	incoming=in;
-	memcpy(&info,in->getInfo(),sizeof(info));
-	// Ready buffers
-	entry=new vidCacheEntry[nbEntry];
-	sz=(info.width*info.height*3)>>1;
-	for(uint32_t i=0;i<nbEntry;i++)
-	{
-		entry[i].frameBuffer	=new ADMImage(info.width,info.height);	
-		entry[i].frameNum	=0xffff0000;
-		entry[i].frameLock	=0;
-	}	
-	counter=0;
-}
-//_____________________________________________
-VideoCache::~ VideoCache()
-{
-	for(uint32_t i=0;i<nbEntry;i++)
-	{
-		delete  entry[i].frameBuffer;
-	}
-	delete [] entry;
-	
-}
-//_____________________________________________
-int32_t VideoCache::searchFrame( uint32_t frame)
-{
-	for(uint32_t i=0;i<nbEntry;i++)
-	{
-		if(entry[i].frameNum==frame) return i;
-	}
-	return -1;
-}
-//_____________________________________________
-int32_t 	 VideoCache::searchPtr( ADMImage *ptr)
-{
-	for(uint32_t i=0;i<nbEntry;i++)
-	{
-		if(entry[i].frameBuffer==ptr) return i;
-	}
-	return -1;
-}
-//_____________________________________________
-uint8_t  VideoCache::unlockAll(void)
-{
-	for(uint32_t i=0;i<nbEntry;i++)
-	{		
-		entry[i].frameLock=0;		
-	}
-	return 1;
-}
-//_____________________________________________
-uint8_t  VideoCache::unlock(ADMImage *frame)
-{
-int32_t k;
-	k=searchPtr(frame) ;
-	ADM_assert(k>=0);
-	entry[k].frameLock--;	
-	return 1;	
-}
-//_____________________________________________
-uint8_t  VideoCache::purge(void)
-{
-	for(uint32_t i=0;i<nbEntry;i++)
-	{		
-		entry[i].frameLock=0;
-		entry[i].frameNum=0xffff0000;	
-		entry[i].lastUse=0xffff0000;	
-	}
-	return 1;
-
-}
-/**
-    \fn getImage
-*/
-ADMImage *VideoCache::getImage(uint32_t frame)
-{
-int32_t i;
-uint32_t tryz=nbEntry;
-uint32_t len,flags;
-ADMImage *ptr=NULL;
-
-	// Already there ?
-	if((i=searchFrame(frame))>=0)
-	{
-		aprintf("Cache : Cache hit %d buffer %d\n",frame,i);
-		entry[i].frameLock++;
-		entry[i].lastUse=counter;
-		counter++;
-		return entry[i].frameBuffer;	
-	}
-	// Else get it!
-	
-	// First elect a new buffer, we do it by 
-	// using a RLU scheme
-	
-	uint32_t deltamax=0,delta;
-	uint32_t target=0xfff;
-	aprintf("Cache : Cache miss %d\n",frame);
-	//for(uint32_t i=0;i<nbEntry;i++) printf("%d(%d) ",frameNum[i],frameLock[i]);printf("\n");
-	for(uint32_t i=0;i<nbEntry;i++)
-	{
-		if(entry[i].frameLock) continue; 	// don"t consider locked frames
-		
-		
-		delta=abs((int)counter-(int)entry[i].lastUse);
-		if(delta>deltamax)
-		{
-			deltamax=delta;
-			target=i;
-		}
-	}
-	ADM_assert(target!=0xfff);
-	// Target is the new cache we will use
-
-	ptr=entry[target].frameBuffer;
-    if(!incoming->getNextFrame(entry[target].frameBuffer)) return NULL;
-	// Update LRU info
-	entry[target].frameLock++;
-	entry[target].frameNum=frame;
-	entry[target].lastUse=counter;
-	counter++;	
-	return ptr;
-	
-}
-// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt	2010-03-05 06:18:44 UTC (rev 5974)
@@ -1,6 +1,5 @@
 SET(ADM_coreImage_SRCS 
 #        ADM_videoFilter.cpp  
-        ADM_videoFilterCache.cpp
         ADM_image.cpp  
         ADM_imageUtils.cpp
         ADM_imageResizer.cpp

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-03-05 06:18:44 UTC (rev 5974)
@@ -18,6 +18,7 @@
 
 #include "ADM_confCouple.h"
 #include "ADM_image.h"
+#include "ADM_videoFilterCache.h"
 /**
     \struct FilterInfo
     \brief Describes the video stream at this point in the filter chain
@@ -38,20 +39,21 @@
 {
 protected:
             FilterInfo           info;
-            uint32_t             nextFrame;
+            uint32_t             nextFrame; // next frame to fetch, it is reset to 0 after a seek!
+            VideoCache           *vidCache;
 public:
             ADM_coreVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf=NULL);
             ~ADM_coreVideoFilter();
 
        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
        virtual bool         goToTime(uint64_t usSeek);              
-       virtual bool         getNextFrame(ADMImage *image)=0;              /// Dont mix getFrame & getNextFrame !
-	   virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
-	   virtual bool         getCoupledConf(CONFcouple **couples)=0 ;   /// Return the current filter configuration
+       virtual bool         getNextFrame(uint32_t *frameNumber,ADMImage *image)=0;              /// Dont mix getFrame & getNextFrame !
+       virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+       virtual bool         getCoupledConf(CONFcouple **couples)=0 ;   /// Return the current filter configuration
        virtual bool         configure(void) {return true;}             /// Start graphical user interface
 protected:
             ADM_coreVideoFilter *previousFilter;
 };
 
 #endif
-// EOF
\ No newline at end of file
+// EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h (from rev 5973, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_videoFilterCache.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_videoFilterCache.h	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h	2010-03-05 06:18:44 UTC (rev 5974)
@@ -0,0 +1,52 @@
+//
+// C++ Interface: ADM_cache
+//
+// Description: 
+//
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#ifndef __ADM_CACHE__
+#define __ADM_CACHE__
+class ADM_coreVideoFilter;
+#include "ADM_image.h"
+/**
+    \struct videoCacheEntry
+*/
+typedef struct vidCacheEntry
+{
+		uint32_t 	frameNum;
+		ADMImage 	*frameBuffer;
+		uint8_t		frameLock;		
+		uint32_t	lastUse;
+
+}vidCacheEntry;
+/**
+    \class VideoCache
+*/
+class VideoCache
+{
+	private:
+		vidCacheEntry	        *entry;
+		uint32_t	        counter;
+		uint32_t 	        nbEntry;
+		ADM_coreVideoFilter     *incoming;
+		
+		
+		int32_t 	        searchFrame( uint32_t frame);
+		int32_t 	        searchPtr( ADMImage *ptr);
+		
+	public:
+		VideoCache(uint32_t nb,ADM_coreVideoFilter *in);
+		~VideoCache(void);
+		
+		ADMImage *getImage(uint32_t frame);
+		uint8_t unlockAll(void);
+		uint8_t unlock(ADMImage  *frame);
+		uint8_t flush(void);
+};
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2010-03-05 06:18:44 UTC (rev 5974)
@@ -38,6 +38,7 @@
 {
     previousFilter=previous;
     nextFrame=0;
+    vidCache=NULL;
     if(previous) memcpy(&info,previous->getInfo(),sizeof(info));
 }
 /**
@@ -45,7 +46,8 @@
 */
  ADM_coreVideoFilter:: ~ADM_coreVideoFilter()
 {
-
+        if(vidCache) delete vidCache;
+        vidCache=NULL;
 }
 /**
     \fn getConfiguration
@@ -77,6 +79,8 @@
     float newSeek=usSeek;
     newSeek/=thisIncrement;
     newSeek*=oldIncrement;
+    if(vidCache) vidCache->flush();
+    nextFrame=0;
     return  previousFilter->goToTime((uint64_t)newSeek);
 
 }

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp (from rev 5973, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_videoFilterCache.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_videoFilterCache.cpp	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp	2010-03-05 06:18:44 UTC (rev 5974)
@@ -0,0 +1,158 @@
+/** *************************************************************************
+        \file                  ADM_videoFilterCache.cpp
+        \brief Cache/buffer for video filter
+		\author (c) 2008/2010 Mean, fixounet at free.fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_videoFilterCache.h"
+#include "ADM_coreVideoFilter.h"
+#if 1
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+
+VideoCache::VideoCache(uint32_t nb,ADM_coreVideoFilter *in)
+{
+uint32_t sz;
+	nbEntry=nb;
+	incoming=in;
+	// Ready buffers
+	entry=new vidCacheEntry[nbEntry];
+        uint32_t w=in->getInfo()->width;
+        uint32_t h=in->getInfo()->height;
+
+	sz=(w*h*3)>>1;
+	for(uint32_t i=0;i<nbEntry;i++)
+	{
+		entry[i].frameBuffer	=new ADMImage(w,h);	
+		entry[i].frameNum	=0xffff0000;
+		entry[i].frameLock	=0;
+	}	
+	counter=0;
+}
+//_____________________________________________
+VideoCache::~ VideoCache()
+{
+	for(uint32_t i=0;i<nbEntry;i++)
+	{
+		delete  entry[i].frameBuffer;
+	}
+	delete [] entry;
+	
+}
+//_____________________________________________
+int32_t VideoCache::searchFrame( uint32_t frame)
+{
+	for(uint32_t i=0;i<nbEntry;i++)
+	{
+		if(entry[i].frameNum==frame) return i;
+	}
+	return -1;
+}
+//_____________________________________________
+int32_t 	 VideoCache::searchPtr( ADMImage *ptr)
+{
+	for(uint32_t i=0;i<nbEntry;i++)
+	{
+		if(entry[i].frameBuffer==ptr) return i;
+	}
+	return -1;
+}
+//_____________________________________________
+uint8_t  VideoCache::unlockAll(void)
+{
+	for(uint32_t i=0;i<nbEntry;i++)
+	{		
+		entry[i].frameLock=0;		
+	}
+	return 1;
+}
+//_____________________________________________
+uint8_t  VideoCache::unlock(ADMImage *frame)
+{
+int32_t k;
+	k=searchPtr(frame) ;
+	ADM_assert(k>=0);
+	entry[k].frameLock--;	
+	return 1;	
+}
+//_____________________________________________
+uint8_t  VideoCache::flush(void)
+{
+	for(uint32_t i=0;i<nbEntry;i++)
+	{		
+		entry[i].frameLock=0;
+		entry[i].frameNum=0xffff0000;	
+		entry[i].lastUse=0xffff0000;	
+	}
+	return 1;
+
+}
+/**
+    \fn getImage
+*/
+ADMImage *VideoCache::getImage(uint32_t frame)
+{
+int32_t i;
+uint32_t tryz=nbEntry;
+uint32_t len,flags;
+ADMImage *ptr=NULL;
+
+	// Already there ?
+	if((i=searchFrame(frame))>=0)
+	{
+		aprintf("Cache : Cache hit %d buffer %d\n",frame,i);
+		entry[i].frameLock++;
+		entry[i].lastUse=counter;
+		counter++;
+		return entry[i].frameBuffer;	
+	}
+	// Else get it!
+	
+	// First elect a new buffer, we do it by 
+	// using a RLU scheme
+	
+	uint32_t deltamax=0,delta;
+	uint32_t target=0xfff;
+	aprintf("Cache : Cache miss %d\n",frame);
+	//for(uint32_t i=0;i<nbEntry;i++) printf("%d(%d) ",frameNum[i],frameLock[i]);printf("\n");
+	for(uint32_t i=0;i<nbEntry;i++)
+	{
+		if(entry[i].frameLock) continue; 	// don"t consider locked frames
+		
+		
+		delta=abs((int)counter-(int)entry[i].lastUse);
+		if(delta>deltamax)
+		{
+			deltamax=delta;
+			target=i;
+		}
+	}
+	ADM_assert(target!=0xfff);
+	// Target is the new cache we will use
+
+	ptr=entry[target].frameBuffer;
+        uint32_t nb;
+        if(!incoming->getNextFrame(&nb,entry[target].frameBuffer)) return NULL;
+        ADM_assert(nb==frame);
+	// Update LRU info
+	entry[target].frameLock++;
+	entry[target].frameNum=nb;
+	entry[target].lastUse=counter;
+	counter++;	
+	return ptr;
+	
+}
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/CMakeLists.txt	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/CMakeLists.txt	2010-03-05 06:18:44 UTC (rev 5974)
@@ -1,6 +1,7 @@
 SET(ADM_CoreVideoFilter_SRCS 
 	ADM_coreVideoFilter.cpp
         DIA_flyDialog.cpp
+        ADM_videoFilterCache.cpp
 )
 
 ADD_LIBRARY(ADM_coreVideoFilter6 SHARED ${ADM_CoreVideoFilter_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp	2010-03-05 06:18:44 UTC (rev 5974)
@@ -221,6 +221,7 @@
 uint8_t    ADM_flyDialog::sliderChanged(void)
 {
   uint32_t fn= sliderGet();
+  uint32_t frameNumber;
   uint32_t len,flags;
   
     ADM_assert(_yuvBuffer);
@@ -233,7 +234,7 @@
     time/=ADM_FLY_SLIDER_MAX;
     time*=_in->getInfo()->totalDuration;
     _in->goToTime(time);
-    if(!_in->getNextFrame(_yuvBuffer))
+    if(!_in->getNextFrame(&frameNumber,_yuvBuffer))
     {
       ADM_warning("[FlyDialog] Cannot get frame %u\n",fn); 
       return 0;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.cpp	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/null/nullEncoder.cpp	2010-03-05 06:18:44 UTC (rev 5974)
@@ -55,7 +55,8 @@
 */
 bool         ADM_nullEncoder::encode (ADMBitstream * out)
 {
-    if(source->getNextFrame(image)==false)
+    uint32_t fn;
+    if(source->getNextFrame(&fn,image)==false)
     {
         printf("[null] Cannot get next image\n");
         return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/png/ADM_pngEncoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/png/ADM_pngEncoder.cpp	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/png/ADM_pngEncoder.cpp	2010-03-05 06:18:44 UTC (rev 5974)
@@ -45,7 +45,8 @@
 */
 bool         ADM_pngEncoder::encode (ADMBitstream * out)
 {
-    if(source->getNextFrame(image)==false)
+    uint32_t fn;
+    if(source->getNextFrame(&fn,image)==false)
     {
         printf("[YV12] Cannot get next image\n");
         return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/yv12/ADM_yv12Encoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/yv12/ADM_yv12Encoder.cpp	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/yv12/ADM_yv12Encoder.cpp	2010-03-05 06:18:44 UTC (rev 5974)
@@ -45,7 +45,8 @@
 */
 bool         ADM_yv12Encoder::encode (ADMBitstream * out)
 {
-    if(source->getNextFrame(image)==false)
+    uint32_t fn;
+    if(source->getNextFrame(&fn,image)==false)
     {
         printf("[YV12] Cannot get next image\n");
         return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp	2010-03-05 06:18:44 UTC (rev 5974)
@@ -27,11 +27,11 @@
                     dummyVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
                     ~dummyVideoFilter();
 
-       virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
-       virtual bool         getNextFrame(ADMImage *image);    /// Return the next image
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *frameNumner,ADMImage *image);    /// Return the next image
 	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
-	   virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
-       virtual bool         configure(void) {return true;}             /// Start graphical user interface
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) {return true;}             /// Start graphical user interface
 };
 
 // Add the hook to make it valid plugin
@@ -68,10 +68,10 @@
     \fn getFrame
     \brief Get a processed frame
 */
-bool dummyVideoFilter::getNextFrame(ADMImage *image)
+bool dummyVideoFilter::getNextFrame(uint32_t *fn,ADMImage *image)
 {
     // since we do nothing, just get the output of previous filter
-    return previousFilter->getNextFrame(image);
+    return previousFilter->getNextFrame(fn,image);
 }
 /**
     \fn getCoupledConf
@@ -92,4 +92,4 @@
     return "Dummy Filter.";
 }
 // Normally not needed :virtual FilterInfo  *getInfo(void)
-//EOF
\ No newline at end of file
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/verticalFlip/verticalFlip.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/verticalFlip/verticalFlip.cpp	2010-03-05 06:18:35 UTC (rev 5973)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/verticalFlip/verticalFlip.cpp	2010-03-05 06:18:44 UTC (rev 5974)
@@ -27,11 +27,11 @@
                     verticalFlipFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
                     ~verticalFlipFilter();
 
-       virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
-       virtual bool         getNextFrame(ADMImage *image);    /// Return the next image
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
 	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
-	   virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
-       virtual bool         configure(void) {return true;}             /// Start graphical user interface
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) {return true;}             /// Start graphical user interface
 };
 
 // Add the hook to make it valid plugin
@@ -82,10 +82,10 @@
     \fn getFrame
     \brief Get a processed frame
 */
-bool verticalFlipFilter::getNextFrame(ADMImage *image)
+bool verticalFlipFilter::getNextFrame(uint32_t *fn,ADMImage *image)
 {
     // since we do nothing, just get the output of previous filter
-    if(false==previousFilter->getNextFrame(image))
+    if(false==previousFilter->getNextFrame(fn,image))
     {
         ADM_warning("FlipFilter : Cannot get frame\n");
         return false;



From mean at mail.berlios.de  Fri Mar  5 07:19:03 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Mar 2010 07:19:03 +0100
Subject: [Avidemux-svn-commit] r5975 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src
Message-ID: <201003050619.o256J3f7014568@sheep.berlios.de>

Author: mean
Date: 2010-03-05 07:19:02 +0100 (Fri, 05 Mar 2010)
New Revision: 5975

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
Log:
[videofilter] Api change

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-03-05 06:18:44 UTC (rev 5974)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-03-05 06:19:02 UTC (rev 5975)
@@ -224,7 +224,8 @@
 {
 
     uint8_t *from;
-    if(source->getNextFrame(image)==false)
+    uint32_t nb;
+    if(source->getNextFrame(&nb,image)==false)
     {
         printf("[ff] Cannot get next image\n");
         return false;



From mean at mail.berlios.de  Fri Mar  5 07:19:12 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Mar 2010 07:19:12 +0100
Subject: [Avidemux-svn-commit] r5976 -
	branches/avidemux_2.6_branch_mean/cmake
Message-ID: <201003050619.o256JCX6014679@sheep.berlios.de>

Author: mean
Date: 2010-03-05 07:19:09 +0100 (Fri, 05 Mar 2010)
New Revision: 5976

Modified:
   branches/avidemux_2.6_branch_mean/cmake/admConfigHelper.cmake
Log:
[cmake] Typo

Modified: branches/avidemux_2.6_branch_mean/cmake/admConfigHelper.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admConfigHelper.cmake	2010-03-05 06:19:02 UTC (rev 5975)
+++ branches/avidemux_2.6_branch_mean/cmake/admConfigHelper.cmake	2010-03-05 06:19:09 UTC (rev 5976)
@@ -99,7 +99,7 @@
 		MESSAGE(STATUS "Could not find ${_function} in ${_lib}")
 		
 		IF (VERBOSE)
-			MESSAGE(${OUTPUT})
+			MESSAGE(STATUS ${OUTPUT})
 		ENDIF (VERBOSE)
 	ENDIF (${_varToSet})	
 ENDMACRO (ADM_CHECK_FUNCTION_EXISTS)



From mean at mail.berlios.de  Fri Mar  5 07:19:15 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Mar 2010 07:19:15 +0100
Subject: [Avidemux-svn-commit] r5977 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include
Message-ID: <201003050619.o256JF9k014777@sheep.berlios.de>

Author: mean
Date: 2010-03-05 07:19:15 +0100 (Fri, 05 Mar 2010)
New Revision: 5977

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilterInternal.h
Log:
[videoFilter] Bump api version

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilterInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilterInternal.h	2010-03-05 06:19:09 UTC (rev 5976)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilterInternal.h	2010-03-05 06:19:15 UTC (rev 5977)
@@ -12,7 +12,7 @@
 #include "ADM_paramList.h"
 #include "ADM_coreUtils.h"
 
-#define VF_API_VERSION 2
+#define VF_API_VERSION 3
 /* These are the 6 functions exported by each plugin ...*/
 typedef ADM_coreVideoFilter  *(ADM_vf_CreateFunction)(ADM_coreVideoFilter *previous,CONFcouple *conf);
 typedef void              (ADM_vf_DeleteFunction)(ADM_coreVideoFilter *codec);



From mean at mail.berlios.de  Fri Mar  5 07:19:18 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Mar 2010 07:19:18 +0100
Subject: [Avidemux-svn-commit] r5978 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter:
	include src
Message-ID: <201003050619.o256JITl014861@sheep.berlios.de>

Author: mean
Date: 2010-03-05 07:19:18 +0100 (Fri, 05 Mar 2010)
New Revision: 5978

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp
Log:
[filterCache] rename field for more clarity

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h	2010-03-05 06:19:15 UTC (rev 5977)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h	2010-03-05 06:19:18 UTC (rev 5978)
@@ -20,7 +20,7 @@
 typedef struct vidCacheEntry
 {
 		uint32_t 	frameNum;
-		ADMImage 	*frameBuffer;
+		ADMImage 	*image;
 		uint8_t		frameLock;		
 		uint32_t	lastUse;
 
@@ -31,10 +31,10 @@
 class VideoCache
 {
 	private:
-		vidCacheEntry	        *entry;
+		vidCacheEntry	    *entry;
 		uint32_t	        counter;
 		uint32_t 	        nbEntry;
-		ADM_coreVideoFilter     *incoming;
+		ADM_coreVideoFilter *incoming;
 		
 		
 		int32_t 	        searchFrame( uint32_t frame);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp	2010-03-05 06:19:15 UTC (rev 5977)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp	2010-03-05 06:19:18 UTC (rev 5978)
@@ -36,7 +36,7 @@
 	sz=(w*h*3)>>1;
 	for(uint32_t i=0;i<nbEntry;i++)
 	{
-		entry[i].frameBuffer	=new ADMImage(w,h);	
+		entry[i].image	=new ADMImage(w,h);	
 		entry[i].frameNum	=0xffff0000;
 		entry[i].frameLock	=0;
 	}	
@@ -47,7 +47,7 @@
 {
 	for(uint32_t i=0;i<nbEntry;i++)
 	{
-		delete  entry[i].frameBuffer;
+		delete  entry[i].image;
 	}
 	delete [] entry;
 	
@@ -66,7 +66,7 @@
 {
 	for(uint32_t i=0;i<nbEntry;i++)
 	{
-		if(entry[i].frameBuffer==ptr) return i;
+		if(entry[i].image==ptr) return i;
 	}
 	return -1;
 }
@@ -108,16 +108,16 @@
 int32_t i;
 uint32_t tryz=nbEntry;
 uint32_t len,flags;
-ADMImage *ptr=NULL;
 
 	// Already there ?
 	if((i=searchFrame(frame))>=0)
 	{
-		aprintf("Cache : Cache hit %d buffer %d\n",frame,i);
+        ADMImage *img=entry[i].image;
+		aprintf("[cache]  old image  frame %d with PTS=%"LLU"\n",(int)frame,img->Pts);
 		entry[i].frameLock++;
 		entry[i].lastUse=counter;
 		counter++;
-		return entry[i].frameBuffer;	
+		return img;	
 	}
 	// Else get it!
 	
@@ -143,16 +143,18 @@
 	ADM_assert(target!=0xfff);
 	// Target is the new cache we will use
 
-	ptr=entry[target].frameBuffer;
+
         uint32_t nb;
-        if(!incoming->getNextFrame(&nb,entry[target].frameBuffer)) return NULL;
+        ADMImage *img=entry[target].image;
+        if(!incoming->getNextFrame(&nb,img)) return NULL;
         ADM_assert(nb==frame);
+        aprintf("[cache] New image Got frame %d with PTS=%"LLU"\n",(int)nb,img->Pts);
 	// Update LRU info
 	entry[target].frameLock++;
 	entry[target].frameNum=nb;
 	entry[target].lastUse=counter;
 	counter++;	
-	return ptr;
+	return img;
 	
 }
 // EOF



From mean at mail.berlios.de  Fri Mar  5 07:19:26 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Mar 2010 07:19:26 +0100
Subject: [Avidemux-svn-commit] r5979 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	crop resize yadif
Message-ID: <201003050619.o256JQvO014906@sheep.berlios.de>

Author: mean
Date: 2010-03-05 07:19:24 +0100 (Fri, 05 Mar 2010)
New Revision: 5979

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resize/swScaleResize.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp
Log:
[filter] update qt4/... filter to new scheme + fix yadif pts a bit

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp	2010-03-05 06:19:18 UTC (rev 5978)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp	2010-03-05 06:19:24 UTC (rev 5979)
@@ -38,7 +38,7 @@
         virtual                 ~CropFilter();
 
        virtual const char   *getConfiguration(void);          /// Return  current configuration as a human readable string
-       virtual bool         getNextFrame(ADMImage *image);    /// Return the next image
+       virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
        //virtual FilterInfo  *getInfo(void);                    /// Return picture parameters after this filter
 	   virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
        virtual bool         configure(void) ;                 /// Start graphical user interface
@@ -100,11 +100,11 @@
     \fn getNextFrame
 
 */
-bool         CropFilter::getNextFrame(ADMImage *image)
+bool         CropFilter::getNextFrame(uint32_t *fn,ADMImage *image)
 {
 FilterInfo  *prevInfo=previousFilter->getInfo();
 			// read uncompressed frame
-       		if(!previousFilter->getNextFrame(original)) return false;
+       		if(!previousFilter->getNextFrame(fn,original)) return false;
        		
        		// Crop Y luma
        		uint32_t y,x,line;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resize/swScaleResize.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resize/swScaleResize.cpp	2010-03-05 06:19:18 UTC (rev 5978)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resize/swScaleResize.cpp	2010-03-05 06:19:24 UTC (rev 5979)
@@ -62,7 +62,7 @@
                     ~swScaleResizeFilter();
 
        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
-       virtual bool         getNextFrame(ADMImage *image);    /// Return the next image
+       virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
        virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
 	   virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
        virtual bool         configure(void) ;             /// Start graphical user interface
@@ -117,10 +117,10 @@
     \fn getFrame
     \brief Get a processed frame
 */
-bool swScaleResizeFilter::getNextFrame(ADMImage *image)
+bool swScaleResizeFilter::getNextFrame(uint32_t *fn,ADMImage *image)
 {
     // since we do nothing, just get the output of previous filter
-    if(false==previousFilter->getNextFrame(original))
+    if(false==previousFilter->getNextFrame(fn,original))
     {
         ADM_warning("swResize : Cannot get frame\n");
         return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp	2010-03-05 06:19:18 UTC (rev 5978)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp	2010-03-05 06:19:24 UTC (rev 5979)
@@ -185,28 +185,35 @@
         int cpu;
         int n;
         ADMImage *src, *dst, * prev, *next;
-
+        
     
         mode = configuration.mode;
 
         if (mode & 1) 
+        {
                 n = (nextFrame>>1); // bob
+        }
         else
                 n = nextFrame;
 
         src = vidCache->getImage(n);
-  // Request frame 'n' from the child (source) clip.
-
+        if(!src) return false;
+        
+  
+        // If possible get previous image...
         if (n>0)
                 prev =  vidCache->getImage( n-1); // get previous frame
         else
                 prev= src; // get very first frame
 
+        ADM_assert(prev);
         next=vidCache->getImage(n+1);
         if(!next) next=src;
+        ADM_assert(next);
+        
+        dst = image;
+        dst->copyInfo(src);
 
-        dst = image;
-        
         if(!prev || !src || !next)
         {
             printf("Failed to read frame for frame %u\n",nextFrame);
@@ -288,7 +295,15 @@
                         ADM_dealloc(nextp);
         }
       vidCache->unlockAll();
+      
+      if (mode & 1) 
+      {
+            if(nextFrame&1)
+                image->Pts+= info.frameIncrement;
+      }
+      //printf("out PTs=%"LLU", nextFrame=%d,inc=%d\n",image->Pts,(int)nextFrame,(int)info.frameIncrement);
       nextFrame++;
+      
       return 1;
 }
 //****************



From mean at mail.berlios.de  Fri Mar  5 07:19:34 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Mar 2010 07:19:34 +0100
Subject: [Avidemux-svn-commit] r5980 - in branches/avidemux_2.6_branch_mean:
	avidemux avidemux/common avidemux_core/ADM_coreAudio/src
Message-ID: <201003050619.o256JYCu014961@sheep.berlios.de>

Author: mean
Date: 2010-03-05 07:19:31 +0100 (Fri, 05 Mar 2010)
New Revision: 5980

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp
Log:
[audio] Move getStrFromAudio to coreAudio so that it can be used by plugins

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp	2010-03-05 06:19:24 UTC (rev 5979)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp	2010-03-05 06:19:31 UTC (rev 5980)
@@ -1,34 +0,0 @@
-/**
-    PlaceHolder
-*/
-#include "ADM_default.h"
-#include "ADM_audioCodecEnum.h"
-
-/**
-        \fn getStrFromAudioCodec
-        \brief Return a plain string from the codec_id
-*/
-const char *getStrFromAudioCodec( uint32_t codec)
-{
-      switch(codec)
-      {
-              case WAV_DTS: return QT_TR_NOOP("DTS");
-              case WAV_PCM: return QT_TR_NOOP("PCM");
-              case WAV_MP2: return QT_TR_NOOP("MP2");
-              case WAV_MP3: return QT_TR_NOOP("MP3");
-              case WAV_WMA:  return QT_TR_NOOP("WMA");
-              case WAV_LPCM: return QT_TR_NOOP("LPCM");
-              case WAV_AC3:  return QT_TR_NOOP("AC3");
-              case WAV_EAC3:  return QT_TR_NOOP("E-AC3");
-              case WAV_OGG_VORBIS: return QT_TR_NOOP("Ogg Vorbis");
-              case WAV_MP4: return QT_TR_NOOP("MP4");
-              case WAV_AAC: return QT_TR_NOOP("AAC");
-              case WAV_QDM2: return QT_TR_NOOP("QDM2");
-              case WAV_AMRNB: return QT_TR_NOOP("AMR-NB");
-              case WAV_MSADPCM: return QT_TR_NOOP("MSADPCM");
-              case WAV_ULAW: return QT_TR_NOOP("ULAW");
-              case WAV_IMAADPCM: return QT_TR_NOOP("IMA ADPCM");
-              case WAV_8BITS_UNSIGNED:return QT_TR_NOOP("8-bit PCM");
-      }
-      return QT_TR_NOOP("Unknown codec");
-}

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-03-05 06:19:24 UTC (rev 5979)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-03-05 06:19:31 UTC (rev 5980)
@@ -48,7 +48,6 @@
 ../common/gui_savenew.cpp  
 ../common/main.cpp  
 ../common/gui_action.cpp
-../common/gui_audio.cpp
 ../common/gui_blackframes.cpp
 ../common/ADM_gettext.cpp
 )

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp	2010-03-05 06:19:24 UTC (rev 5979)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp	2010-03-05 06:19:31 UTC (rev 5980)
@@ -10,7 +10,7 @@
 #include "ADM_audioStreamEac3.h"
 #include "ADM_audioStreamDCA.h"
 #include "ADM_audioStreamConstantChunk.h"
-
+#include "ADM_audioCodecEnum.h"
 /**
     \fn ADM_audioStream
     \brief constructor
@@ -154,5 +154,35 @@
     }
 
 }
+
+/**
+        \fn getStrFromAudioCodec
+        \brief Return a plain string from the codec_id
+*/
+const char *getStrFromAudioCodec( uint32_t codec)
+{
+      switch(codec)
+      {
+              case WAV_DTS: return QT_TR_NOOP("DTS");
+              case WAV_PCM: return QT_TR_NOOP("PCM");
+              case WAV_MP2: return QT_TR_NOOP("MP2");
+              case WAV_MP3: return QT_TR_NOOP("MP3");
+              case WAV_WMA:  return QT_TR_NOOP("WMA");
+              case WAV_LPCM: return QT_TR_NOOP("LPCM");
+              case WAV_AC3:  return QT_TR_NOOP("AC3");
+              case WAV_EAC3:  return QT_TR_NOOP("E-AC3");
+              case WAV_OGG_VORBIS: return QT_TR_NOOP("Ogg Vorbis");
+              case WAV_MP4: return QT_TR_NOOP("MP4");
+              case WAV_AAC: return QT_TR_NOOP("AAC");
+              case WAV_QDM2: return QT_TR_NOOP("QDM2");
+              case WAV_AMRNB: return QT_TR_NOOP("AMR-NB");
+              case WAV_MSADPCM: return QT_TR_NOOP("MSADPCM");
+              case WAV_ULAW: return QT_TR_NOOP("ULAW");
+              case WAV_IMAADPCM: return QT_TR_NOOP("IMA ADPCM");
+              case WAV_8BITS_UNSIGNED:return QT_TR_NOOP("8-bit PCM");
+      }
+      return QT_TR_NOOP("Unknown codec");
+}
+
 // EOF
 



From mean at mail.berlios.de  Sun Mar  7 18:56:37 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 7 Mar 2010 18:56:37 +0100
Subject: [Avidemux-svn-commit] r5981 - in
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces:
	ADM_dialog ADM_filters
Message-ID: <201003071756.o27Hubi7007195@sheep.berlios.de>

Author: mean
Date: 2010-03-07 18:56:36 +0100 (Sun, 07 Mar 2010)
New Revision: 5981

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h
Log:
[ui] Re-enable seekable preview for qt4

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h	2010-03-05 06:19:31 UTC (rev 5980)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/DIA_flyPreview.h	2010-03-07 17:56:36 UTC (rev 5981)
@@ -22,7 +22,7 @@
 	uint8_t upload(void) {return 1;}
 	uint8_t cleanup(void) {return 1;}
 
-	flySeekablePreview(uint32_t width, uint32_t height, AVDMGenericVideoStream *videoStream, void *canvas, void *slider) : 
+	flySeekablePreview(uint32_t width, uint32_t height, ADM_coreVideoFilter *videoStream, void *canvas, void *slider) : 
 	  ADM_flyDialogQt4(width, height, videoStream, canvas, slider, 0, RESIZE_AUTO) {delete[] _rgbBufferOut; _rgbBufferOut = NULL;};
 	virtual ~flySeekablePreview(void) {_rgbBufferOut = NULL;};
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/CMakeLists.txt	2010-03-05 06:19:31 UTC (rev 5980)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/CMakeLists.txt	2010-03-07 17:56:36 UTC (rev 5981)
@@ -1,13 +1,13 @@
 SET(ADM_LIB ADM_filtersQt4)
 
-QT4_WRAP_UI(${ADM_LIB}_header  mainfilter.ui )# seekablePreview.ui)
-QT4_WRAP_CPP(${ADM_LIB}_source  Q_mainfilter.h )# Q_seekablePreview.h)
+QT4_WRAP_UI(${ADM_LIB}_header  mainfilter.ui  seekablePreview.ui)
+QT4_WRAP_CPP(${ADM_LIB}_source  Q_mainfilter.h  Q_seekablePreview.h)
 QT4_ADD_RESOURCES(${ADM_LIB}_resource  filter.qrc)
 
 SET(${ADM_LIB}_SRCS
 	filter_none.cpp  
         Q_mainfilter.cpp 
-        #Q_seekablePreview.cpp 
+        Q_seekablePreview.cpp 
         ${${ADM_LIB}_header}  ${${ADM_LIB}_source}  ${${ADM_LIB}_resource})
 
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp	2010-03-05 06:19:31 UTC (rev 5980)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp	2010-03-07 17:56:36 UTC (rev 5981)
@@ -107,12 +107,48 @@
 	else
 		label->setBackgroundRole(QPalette::Base);
 }
-
+/**
+    \fn preview
+*/
 void filtermainWindow::preview(bool b)
 {
+   QListWidgetItem *item=activeList->currentItem();
+   if(!item)
+   {
+      printf("No selection\n");
+      return;
+   }
+    
+     int itag=item->type();
+     ADM_assert(itag>=ACTIVE_FILTER_BASE);
+     itag-=ACTIVE_FILTER_BASE;
+     /* Filter 0 is the decoder ...*/
+     ADM_info("Rank : %d\n",itag); 
+     ADM_coreVideoFilter     *filter=ADM_vf_getInstance(itag);
+     ADM_assert(filter);
+	if (previewDialog)
+		previewDialog->resetVideoStream(filter);
+	else
+	{
+		previewDialog = new Ui_seekablePreviewWindow(this, filter, previewFrameIndex);
+		connect(previewDialog, SIGNAL(accepted()), this, SLOT(closePreview()));
 
+		if (previewDialogX != INT_MIN)
+			previewDialog->move(previewDialogX, previewDialogY);
+	}
+	previewDialog->show();
 }
 
+void filtermainWindow::closePreview()
+{
+	if (previewDialog)
+	{		
+		delete previewDialog;
+		previewDialog = NULL;
+	}
+
+}
+
 /**
         \fn     void setSelected(int sel)
         \brief  Set the sel line as selected in the active filter window
@@ -219,7 +255,8 @@
      ADM_assert(itag>=ACTIVE_FILTER_BASE);
      itag-=ACTIVE_FILTER_BASE;
      /* Filter 0 is the decoder ...*/
-      ADM_info("Rank : %d\n",itag); 
+     ADM_info("Rank : %d\n",itag); 
+   
    //   ADM_assert(itag);
      /**/
         ADM_vf_configureFilterAtIndex(itag);
@@ -477,7 +514,22 @@
     displayFamily(0);
     buildActiveFilterList();
 	setSelected(nb_active_filter - 1);
+
+	previewDialog = NULL;
+	previewDialogX = INT_MIN;
+	previewDialogY = INT_MIN;
+	//previewFrameIndex = curframe;
+
  }
+/**
+    \fn dtor
+*/
+filtermainWindow::~filtermainWindow()
+{
+    if(previewDialog) delete previewDialog;
+    previewDialog=NULL;
+
+}
 /*******************************************************/
 
 int GUI_handleVFilter(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h	2010-03-05 06:19:31 UTC (rev 5980)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h	2010-03-07 17:56:36 UTC (rev 5981)
@@ -4,6 +4,7 @@
 #include <QtGui/QItemDelegate>
 #include "ui_mainfilter.h"
 #include "ADM_inttype.h"
+#include "Q_seekablePreview.h"
 class FilterItemEventFilter : public QObject
 {
 	Q_OBJECT
@@ -33,12 +34,16 @@
 
 public:
 	filtermainWindow();
+    ~filtermainWindow();
 	void buildActiveFilterList(void);
 
 	Ui_mainFilterDialog ui;
 	QListWidget *availableList;
 	QListWidget *activeList;
-
+protected:
+	uint32_t previewFrameIndex;
+	int previewDialogX, previewDialogY;
+	Ui_seekablePreviewWindow *previewDialog;
 public slots:
 	void VCD(bool b);
 	void DVD(bool b);
@@ -55,6 +60,7 @@
 	void filterFamilyClick(QListWidgetItem *item);
 	void filterFamilyClick(int  item);
 	void preview(bool b);
+    void closePreview(void);
 
 private:
 	void setSelected(int sel);

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp	2010-03-05 06:19:31 UTC (rev 5980)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp	2010-03-07 17:56:36 UTC (rev 5981)
@@ -17,7 +17,7 @@
 
 #include "Q_seekablePreview.h"
 
-Ui_seekablePreviewWindow::Ui_seekablePreviewWindow(QWidget *parent, AVDMGenericVideoStream *videoStream, uint32_t defaultFrame) : QDialog(parent)
+Ui_seekablePreviewWindow::Ui_seekablePreviewWindow(QWidget *parent, ADM_coreVideoFilter *videoStream, uint32_t defaultFrame) : QDialog(parent)
 {
 	ui.setupUi(this);
 
@@ -37,7 +37,7 @@
 	delete canvas;
 }
 
-void Ui_seekablePreviewWindow::resetVideoStream(AVDMGenericVideoStream *videoStream)
+void Ui_seekablePreviewWindow::resetVideoStream(ADM_coreVideoFilter *videoStream)
 {
 	if (seekablePreview)
 		delete seekablePreview;

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h	2010-03-05 06:19:31 UTC (rev 5980)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h	2010-03-07 17:56:36 UTC (rev 5981)
@@ -30,9 +30,9 @@
 	ADM_QCanvas *canvas;
 	flySeekablePreview *seekablePreview;
 	Ui_seekablePreviewDialog ui;
-	Ui_seekablePreviewWindow(QWidget *parent, AVDMGenericVideoStream *videoStream, uint32_t defaultFrame = 0);
+	Ui_seekablePreviewWindow(QWidget *parent, ADM_coreVideoFilter *videoStream, uint32_t defaultFrame = 0);
 	~Ui_seekablePreviewWindow();
-	void resetVideoStream(AVDMGenericVideoStream *videoStream);
+	void resetVideoStream(ADM_coreVideoFilter *videoStream);
 	uint32_t frameIndex();
 
 public slots:



From mean at mail.berlios.de  Sun Mar  7 18:56:44 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 7 Mar 2010 18:56:44 +0100
Subject: [Avidemux-svn-commit] r5982 - in branches/avidemux_2.6_branch_mean:
	avidemux/qt4/ADM_userInterfaces/ADM_filters
	avidemux_core/ADM_coreVideoFilter/include
	avidemux_core/ADM_coreVideoFilter/src
Message-ID: <201003071756.o27Huijh007407@sheep.berlios.de>

Author: mean
Date: 2010-03-07 18:56:41 +0100 (Sun, 07 Mar 2010)
New Revision: 5982

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/seekablePreview.ui
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp
Log:
[ui] Handle seekable preview + nextImage

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp	2010-03-07 17:56:36 UTC (rev 5981)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp	2010-03-07 17:56:41 UTC (rev 5982)
@@ -130,11 +130,12 @@
 		previewDialog->resetVideoStream(filter);
 	else
 	{
-		previewDialog = new Ui_seekablePreviewWindow(this, filter, previewFrameIndex);
+		previewDialog = new Ui_seekablePreviewWindow(this, filter, 0);
 		connect(previewDialog, SIGNAL(accepted()), this, SLOT(closePreview()));
-
+#if 0
 		if (previewDialogX != INT_MIN)
 			previewDialog->move(previewDialogX, previewDialogY);
+#endif
 	}
 	previewDialog->show();
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h	2010-03-07 17:56:36 UTC (rev 5981)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h	2010-03-07 17:56:41 UTC (rev 5982)
@@ -41,7 +41,7 @@
 	QListWidget *availableList;
 	QListWidget *activeList;
 protected:
-	uint32_t previewFrameIndex;
+	
 	int previewDialogX, previewDialogY;
 	Ui_seekablePreviewWindow *previewDialog;
 public slots:

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp	2010-03-07 17:56:36 UTC (rev 5981)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.cpp	2010-03-07 17:56:41 UTC (rev 5982)
@@ -28,7 +28,8 @@
 	seekablePreview->sliderSet(defaultFrame);
 	seekablePreview->sliderChanged();
 
-	connect(ui.horizontalSlider, SIGNAL(valueChanged(int)), this, SLOT(sliderChanged(int)));
+	connect(ui.horizontalSlider, SIGNAL(valueChanged(int)), this, SLOT(sliderChanged(int)));
+    connect(ui.next,SIGNAL(clicked()),this,SLOT(nextImage()));
 }
 
 Ui_seekablePreviewWindow::~Ui_seekablePreviewWindow()
@@ -36,7 +37,10 @@
 	delete seekablePreview;
 	delete canvas;
 }
-
+void Ui_seekablePreviewWindow::nextImage(void)
+{
+    seekablePreview->nextImage();
+}
 void Ui_seekablePreviewWindow::resetVideoStream(ADM_coreVideoFilter *videoStream)
 {
 	if (seekablePreview)

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h	2010-03-07 17:56:36 UTC (rev 5981)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_seekablePreview.h	2010-03-07 17:56:41 UTC (rev 5982)
@@ -36,5 +36,6 @@
 	uint32_t frameIndex();
 
 public slots:
-	void sliderChanged(int value);
+	void sliderChanged(int value);
+    void nextImage(void);
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/seekablePreview.ui
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/seekablePreview.ui	2010-03-07 17:56:36 UTC (rev 5981)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/seekablePreview.ui	2010-03-07 17:56:41 UTC (rev 5982)
@@ -1,7 +1,8 @@
-<ui version="4.0" >
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
  <class>seekablePreviewDialog</class>
- <widget class="QDialog" name="seekablePreviewDialog" >
-  <property name="geometry" >
+ <widget class="QDialog" name="seekablePreviewDialog">
+  <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
@@ -9,39 +10,58 @@
     <height>300</height>
    </rect>
   </property>
-  <property name="windowTitle" >
+  <property name="sizePolicy">
+   <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+    <horstretch>0</horstretch>
+    <verstretch>0</verstretch>
+   </sizepolicy>
+  </property>
+  <property name="windowTitle">
    <string>Preview</string>
   </property>
-  <layout class="QVBoxLayout" >
-   <property name="margin" >
+  <layout class="QVBoxLayout">
+   <property name="spacing">
+    <number>6</number>
+   </property>
+   <property name="margin">
     <number>9</number>
    </property>
-   <property name="spacing" >
-    <number>6</number>
-   </property>
    <item>
-    <widget class="QFrame" name="frame" >
-     <property name="frameShape" >
+    <widget class="QFrame" name="frame">
+     <property name="frameShape">
       <enum>QFrame::StyledPanel</enum>
      </property>
-     <property name="frameShadow" >
+     <property name="frameShadow">
       <enum>QFrame::Raised</enum>
      </property>
     </widget>
    </item>
    <item>
-    <widget class="QSlider" name="horizontalSlider" >
-     <property name="orientation" >
+    <widget class="QSlider" name="horizontalSlider">
+     <property name="orientation">
       <enum>Qt::Horizontal</enum>
      </property>
     </widget>
    </item>
    <item>
-    <widget class="QDialogButtonBox" name="buttonBox" >
-     <property name="orientation" >
+    <widget class="QPushButton" name="next">
+     <property name="sizePolicy">
+      <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
+       <horstretch>0</horstretch>
+       <verstretch>0</verstretch>
+      </sizepolicy>
+     </property>
+     <property name="text">
+      <string>next</string>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <widget class="QDialogButtonBox" name="buttonBox">
+     <property name="orientation">
       <enum>Qt::Horizontal</enum>
      </property>
-     <property name="standardButtons" >
+     <property name="standardButtons">
       <set>QDialogButtonBox::Ok</set>
      </property>
     </widget>
@@ -56,11 +76,11 @@
    <receiver>seekablePreviewDialog</receiver>
    <slot>accept()</slot>
    <hints>
-    <hint type="sourcelabel" >
+    <hint type="sourcelabel">
      <x>207</x>
      <y>306</y>
     </hint>
-    <hint type="destinationlabel" >
+    <hint type="destinationlabel">
      <x>207</x>
      <y>177</y>
     </hint>

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h	2010-03-07 17:56:36 UTC (rev 5981)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h	2010-03-07 17:56:41 UTC (rev 5982)
@@ -86,10 +86,11 @@
           void copyYuvFinalToRgb(void);
           void copyYuvScratchToRgb(void);
           void copyRgbFinalToDisplay(void);
+
           
   public:
           void recomputeSize(void);
-         
+          virtual bool nextImage(void);
   public:
           void    *_cookie; // whatever
           void    *_slider; // widget

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp	2010-03-07 17:56:36 UTC (rev 5981)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp	2010-03-07 17:56:41 UTC (rev 5982)
@@ -234,9 +234,19 @@
     time/=ADM_FLY_SLIDER_MAX;
     time*=_in->getInfo()->totalDuration;
     _in->goToTime(time);
+   
+
+   return nextImage();
+}
+/**
+    \fn nextImage
+*/
+bool ADM_flyDialog::nextImage(void)
+{
+    uint32_t frameNumber;
     if(!_in->getNextFrame(&frameNumber,_yuvBuffer))
     {
-      ADM_warning("[FlyDialog] Cannot get frame %u\n",fn); 
+      ADM_warning("[FlyDialog] Cannot get frame %u\n",frameNumber); 
       return 0;
     }
 
@@ -252,7 +262,6 @@
 		copyYuvScratchToRgb();
         process();
     }
-
     return display();
 }
 /**



From mean at mail.berlios.de  Sun Mar  7 18:56:56 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 7 Mar 2010 18:56:56 +0100
Subject: [Avidemux-svn-commit] r5983 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_videoFilter2/src
	avidemux_core/ADM_coreVideoFilter/include
	avidemux_core/ADM_coreVideoFilter/src
	avidemux_plugins/ADM_videoFilters6/yadif
Message-ID: <201003071756.o27HuuBf007592@sheep.berlios.de>

Author: mean
Date: 2010-03-07 18:56:53 +0100 (Sun, 07 Mar 2010)
New Revision: 5983

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilterInternal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp
Log:
[videoFilter] Fix seeking on videoFilter, cleaner cache, dont declare yadif VidCache twice

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp	2010-03-07 17:56:41 UTC (rev 5982)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp	2010-03-07 17:56:53 UTC (rev 5983)
@@ -34,7 +34,7 @@
         endTime=total-startTime+1;
     }
     this->endTime=endTime;
-    
+    myName="Bridge";
     aviInfo fo;
     video_body->getVideoInfo(&fo);
     bridgeInfo.width=fo.width;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-03-07 17:56:41 UTC (rev 5982)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-03-07 17:56:53 UTC (rev 5983)
@@ -41,6 +41,7 @@
             FilterInfo           info;
             uint32_t             nextFrame; // next frame to fetch, it is reset to 0 after a seek!
             VideoCache           *vidCache;
+            const char           *myName;
 public:
             ADM_coreVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf=NULL);
             ~ADM_coreVideoFilter();

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilterInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilterInternal.h	2010-03-07 17:56:41 UTC (rev 5982)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilterInternal.h	2010-03-07 17:56:53 UTC (rev 5983)
@@ -12,7 +12,7 @@
 #include "ADM_paramList.h"
 #include "ADM_coreUtils.h"
 
-#define VF_API_VERSION 3
+#define VF_API_VERSION 4
 /* These are the 6 functions exported by each plugin ...*/
 typedef ADM_coreVideoFilter  *(ADM_vf_CreateFunction)(ADM_coreVideoFilter *previous,CONFcouple *conf);
 typedef void              (ADM_vf_DeleteFunction)(ADM_coreVideoFilter *codec);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h	2010-03-07 17:56:41 UTC (rev 5982)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h	2010-03-07 17:56:53 UTC (rev 5983)
@@ -23,6 +23,7 @@
 		ADMImage 	*image;
 		uint8_t		frameLock;		
 		uint32_t	lastUse;
+        bool        freeEntry;
 
 }vidCacheEntry;
 /**
@@ -39,6 +40,7 @@
 		
 		int32_t 	        searchFrame( uint32_t frame);
 		int32_t 	        searchPtr( ADMImage *ptr);
+        int                 searchFreeEntry(void);
 		
 	public:
 		VideoCache(uint32_t nb,ADM_coreVideoFilter *in);
@@ -48,5 +50,6 @@
 		uint8_t unlockAll(void);
 		uint8_t unlock(ADMImage  *frame);
 		uint8_t flush(void);
+        void    dump(void);
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2010-03-07 17:56:41 UTC (rev 5982)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2010-03-07 17:56:53 UTC (rev 5983)
@@ -39,6 +39,7 @@
     previousFilter=previous;
     nextFrame=0;
     vidCache=NULL;
+    myName="default";
     if(previous) memcpy(&info,previous->getInfo(),sizeof(info));
 }
 /**
@@ -71,16 +72,18 @@
 */
 bool         ADM_coreVideoFilter::goToTime(uint64_t usSeek)
 {
+    ADM_info("%s:Video filter seeking\n",myName);
     float thisIncrement=info.frameIncrement;
     float oldIncrement=previousFilter->getInfo()->frameIncrement;
     ADM_assert(thisIncrement);
     ADM_assert(oldIncrement);
+    if(vidCache) vidCache->flush();
+    nextFrame=0;
+
     if(thisIncrement==oldIncrement) return previousFilter->goToTime(usSeek);
     float newSeek=usSeek;
     newSeek/=thisIncrement;
     newSeek*=oldIncrement;
-    if(vidCache) vidCache->flush();
-    nextFrame=0;
     return  previousFilter->goToTime((uint64_t)newSeek);
 
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp	2010-03-07 17:56:41 UTC (rev 5982)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp	2010-03-07 17:56:53 UTC (rev 5983)
@@ -22,7 +22,9 @@
 #else
 #define aprintf printf
 #endif
-
+/**
+    \fn ctor
+*/
 VideoCache::VideoCache(uint32_t nb,ADM_coreVideoFilter *in)
 {
 uint32_t sz;
@@ -39,10 +41,13 @@
 		entry[i].image	=new ADMImage(w,h);	
 		entry[i].frameNum	=0xffff0000;
 		entry[i].frameLock	=0;
+        entry[i].freeEntry=true;
 	}	
 	counter=0;
 }
-//_____________________________________________
+/**
+    \fn dtor
+*/
 VideoCache::~ VideoCache()
 {
 	for(uint32_t i=0;i<nbEntry;i++)
@@ -50,14 +55,18 @@
 		delete  entry[i].image;
 	}
 	delete [] entry;
+    entry=NULL;
 	
 }
-//_____________________________________________
+/**
+    \fn searchFrame
+    \brief Search an entry by its frameNumber
+*/
 int32_t VideoCache::searchFrame( uint32_t frame)
 {
 	for(uint32_t i=0;i<nbEntry;i++)
 	{
-		if(entry[i].frameNum==frame) return i;
+		if(entry[i].frameNum==frame&& entry[i].freeEntry==false) return i;
 	}
 	return -1;
 }
@@ -66,7 +75,7 @@
 {
 	for(uint32_t i=0;i<nbEntry;i++)
 	{
-		if(entry[i].image==ptr) return i;
+		if(entry[i].image==ptr && entry[i].freeEntry==false) return i;
 	}
 	return -1;
 }
@@ -88,19 +97,54 @@
 	entry[k].frameLock--;	
 	return 1;	
 }
-//_____________________________________________
+/**
+    \fn flush
+    \brief Empty cache
+*/
 uint8_t  VideoCache::flush(void)
 {
+    printf("Flushing video Cache\n");
 	for(uint32_t i=0;i<nbEntry;i++)
 	{		
 		entry[i].frameLock=0;
 		entry[i].frameNum=0xffff0000;	
 		entry[i].lastUse=0xffff0000;	
+        entry[i].freeEntry=true;
 	}
 	return 1;
 
 }
 /**
+     \fn searchFreeEntry
+
+*/
+int VideoCache::searchFreeEntry(void)
+{
+    // Search a free one
+    for(uint32_t i=0;i<nbEntry;i++)
+	{
+        if(entry[i].freeEntry==true) return i;
+    }
+    // Search the oldest one
+    uint32_t deltamax=0,delta;
+	uint32_t target=0xfff;
+	aprintf("Cache : Cache miss %d\n",frame);
+	//for(uint32_t i=0;i<nbEntry;i++) printf("%d(%d) ",frameNum[i],frameLock[i]);printf("\n");
+	for(uint32_t i=0;i<nbEntry;i++)
+	{
+		if(entry[i].frameLock) continue; 	// don"t consider locked frames
+
+		delta=abs((int)counter-(int)entry[i].lastUse);
+		if(delta>deltamax)
+		{
+			deltamax=delta;
+			target=i;
+		}
+	}
+    ADM_assert(target!=0xfff);
+    return target;
+}
+/**
     \fn getImage
 */
 ADMImage *VideoCache::getImage(uint32_t frame)
@@ -119,42 +163,40 @@
 		counter++;
 		return img;	
 	}
-	// Else get it!
-	
-	// First elect a new buffer, we do it by 
-	// using a RLU scheme
-	
-	uint32_t deltamax=0,delta;
-	uint32_t target=0xfff;
-	aprintf("Cache : Cache miss %d\n",frame);
-	//for(uint32_t i=0;i<nbEntry;i++) printf("%d(%d) ",frameNum[i],frameLock[i]);printf("\n");
+	int target=searchFreeEntry();
+    uint32_t nb;
+    ADMImage *img=entry[target].image;
+    if(!incoming->getNextFrame(&nb,img)) return NULL;
+    if(nb!=frame)
+    {
+        ADM_error("Expected frame %d, got frame %d\n",(int)frame,(int)nb);
+        dump();
+        ADM_assert(0);
+    }
+    ADM_assert(nb==frame);
+    aprintf(">>>>>>>>>>>>>>>>>>>>>>>>>>[cache] New image Got frame %d with PTS=%"LLU"\n",(int)nb,img->Pts);
+    // Update LRU info
+    entry[target].frameLock++;
+    entry[target].frameNum=nb;
+    entry[target].lastUse=counter;
+    entry[target].freeEntry=false;
+    counter++;	
+    return img;
+}
+/**
+    \fn dump
+*/
+void VideoCache::dump(void)
+{
 	for(uint32_t i=0;i<nbEntry;i++)
-	{
-		if(entry[i].frameLock) continue; 	// don"t consider locked frames
-		
-		
-		delta=abs((int)counter-(int)entry[i].lastUse);
-		if(delta>deltamax)
-		{
-			deltamax=delta;
-			target=i;
-		}
+	{		
+        printf("Entry %d/%d, frameNum %d lock %d lastUse %d\n",
+                i,nbEntry,
+                
+                (int)entry[i].frameNum,
+                (int)entry[i].frameLock,
+                (int)entry[i].lastUse);
 	}
-	ADM_assert(target!=0xfff);
-	// Target is the new cache we will use
 
-
-        uint32_t nb;
-        ADMImage *img=entry[target].image;
-        if(!incoming->getNextFrame(&nb,img)) return NULL;
-        ADM_assert(nb==frame);
-        aprintf("[cache] New image Got frame %d with PTS=%"LLU"\n",(int)nb,img->Pts);
-	// Update LRU info
-	entry[target].frameLock++;
-	entry[target].frameNum=nb;
-	entry[target].lastUse=counter;
-	counter++;	
-	return img;
-	
 }
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp	2010-03-07 17:56:41 UTC (rev 5982)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/yadif/ADM_vidYadif.cpp	2010-03-07 17:56:53 UTC (rev 5983)
@@ -57,7 +57,6 @@
                     ADMImage    *original;
                     yadif       configuration;
                     void        updateInfo(void);
-                    VideoCache  *vidCache;
 public:
                     yadifFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
                     ~yadifFilter();
@@ -96,6 +95,7 @@
     }
     vidCache = new VideoCache (10, in);
     updateInfo();
+    myName="yadif";
 }
 /**
     \fn destructor



From mean at mail.berlios.de  Mon Mar  8 07:25:24 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 8 Mar 2010 07:25:24 +0100
Subject: [Avidemux-svn-commit] r5984 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4
Message-ID: <201003080625.o286POW4014303@sheep.berlios.de>

Author: mean
Date: 2010-03-08 07:25:22 +0100 (Mon, 08 Mar 2010)
New Revision: 5984

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
Log:
[win32] Fix link order

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2010-03-07 17:56:53 UTC (rev 5983)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2010-03-08 06:25:22 UTC (rev 5984)
@@ -76,10 +76,10 @@
 #############################################
 # Add qt specific libs
 #############################################
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_guiQt4)
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_filtersQt4)
 TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_UIQT46)
 TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_dialogQt4)
-TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_guiQt4)
-TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_filtersQt4)
 TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_internalVideoFilter6)
 TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_UIQT46)
 TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_guiQt4)



From mean at mail.berlios.de  Mon Mar  8 19:30:13 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 8 Mar 2010 19:30:13 +0100
Subject: [Avidemux-svn-commit] r5985 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <201003081830.o28IUDRd032208@sheep.berlios.de>

Author: mean
Date: 2010-03-08 19:30:10 +0100 (Mon, 08 Mar 2010)
New Revision: 5985

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
Log:
[mkv] dont delay video twice

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-03-08 06:25:22 UTC (rev 5984)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-03-08 18:30:10 UTC (rev 5985)
@@ -256,12 +256,7 @@
         
         adj=maxDelta-track->index[0].Pts;
         ADM_info("Delaying video by %"LLU" us\n",adj);
-        
-        for(int i=0;i<nb;i++)
-                track->index[i].Pts+=adj;
-    
-    
-        printf("[mkv] Delaying audio by %"LLU" us\n",adj);
+        ADM_info("[mkv] Delaying audio by %"LLU" us\n",adj);
         for(int i=0;i<_nbAudioTrack+1;i++)
             delayTrack(&(_tracks[i]),adj);
     }



From mean at mail.berlios.de  Tue Mar  9 07:29:34 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 9 Mar 2010 07:29:34 +0100
Subject: [Avidemux-svn-commit] r5986 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder:
	. xvid4
Message-ID: <201003090629.o296TXh6001644@sheep.berlios.de>

Author: mean
Date: 2010-03-09 07:29:31 +0100 (Tue, 09 Mar 2010)
New Revision: 5986

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Plugin.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder_desc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/CMakeLists.txt
Log:
[xvid] initial dummy import of xvid4

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/CMakeLists.txt	2010-03-08 18:30:10 UTC (rev 5985)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/CMakeLists.txt	2010-03-09 06:29:31 UTC (rev 5986)
@@ -7,3 +7,4 @@
 ADD_SUBDIRECTORY(ffMsMpeg4)
 ADD_SUBDIRECTORY(ffFlv1)
 ADD_SUBDIRECTORY(null)
+ADD_SUBDIRECTORY(xvid4)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-08 18:30:10 UTC (rev 5985)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-09 06:29:31 UTC (rev 5986)
@@ -0,0 +1,316 @@
+/***************************************************************************
+                          \fn ADM_ffMpeg4
+                          \brief Front end for libavcodec Mpeg4 asp encoder
+                             -------------------
+    
+    copyright            : (C) 2002/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_lavcodec.h"
+#include "ADM_default.h"
+#if 0
+#include "ADM_xvid4.h"
+#undef ADM_MINIMAL_UI_INTERFACE // we need the full UI
+#include "DIA_factory.h"
+
+#if 1
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+
+FFcodecSettings Mp4Settings=
+{
+    {
+    COMPRESS_CQ, //COMPRESSION_MODE  mode;
+    2,              // uint32_t          qz;           /// Quantizer
+    1500,           //uint32_t          bitrate;      /// In kb/s 
+    700,            //uint32_t          finalsize;    /// In ?
+    1500,           //uint32_t          avg_bitrate;  /// avg_bitrate is in kb/s!!
+    ADM_ENC_CAP_CBR+ADM_ENC_CAP_CQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_2PASS_BR+ADM_ENC_CAP_GLOBAL+ADM_ENC_CAP_SAME
+    },
+    {
+        ADM_AVCODEC_SETTING_VERSION,
+        2, // Multithreaded
+          ME_EPZS,			// ME
+          0,				// GMC     
+          1,				// 4MV
+          0,				// _QPEL;   
+          1,				// _TREILLIS_QUANT
+          2,				// qmin;
+          31,				// qmax;
+          3,				// max_qdiff;
+          2,				// max_b_frames;
+          0,				// mpeg_quant;
+          1,				// is_luma_elim_threshold
+          -2,				// luma_elim_threshold;
+          1,				// is_chroma_elim_threshold
+          -5,				// chroma_elim_threshold;
+          0.05,				//lumi_masking;
+          1,				// is lumi
+          0.01,				//dark_masking; 
+          1,				// is dark
+          0.5,				// qcompress amount of qscale change between easy & hard scenes (0.0-1.0
+          0.5,				// qblur;    amount of qscale smoothing over time (0.0-1.0) 
+          0,				// min bitrate in kB/S
+          0,				// max bitrate
+          0,				// user matrix
+          250,				// gop size
+          0,				// interlaced
+          0,				// WLA: bottom-field-first
+          0,				// wide screen
+          2,				// mb eval = distortion
+          8000,				// vratetol 8Meg
+          0,				// is temporal
+          0.0,				// temporal masking
+          0,				// is spatial
+          0.0,				// spatial masking
+          0,				// NAQ
+          0,                // xvid rc
+          0,                // buffersize
+          0,                // override ratecontrol
+          0				    // DUMMY 
+    }
+};
+/**
+        \fn ADM_ffMpeg4Encoder
+*/
+ADM_ffMpeg4Encoder::ADM_ffMpeg4Encoder(ADM_coreVideoFilter *src,bool globalHeader) : ADM_coreVideoEncoderFFmpeg(src,&Mp4Settings,globalHeader)
+{
+    printf("[ffMpeg4Encoder] Creating.\n");
+   
+
+}
+
+/**
+    \fn setup
+*/
+bool ADM_ffMpeg4Encoder::setup(void)
+{
+    
+    switch(Settings.params.mode)
+    {
+      case COMPRESS_2PASS:
+      case COMPRESS_2PASS_BITRATE:
+           if(false==setupPass())
+            {
+                printf("[ffmpeg] Multipass setup failed\n");
+                return false;
+            }
+            break;
+      case COMPRESS_SAME:
+      case COMPRESS_CQ:
+            _context->flags |= CODEC_FLAG_QSCALE;
+            _context->bit_rate = 0;
+            break;
+      case COMPRESS_CBR:
+              _context->bit_rate=Settings.params.bitrate*1000; // kb->b;
+            break;
+     default:
+            return false;
+    }
+    presetContext(&Settings);
+    if(false== ADM_coreVideoEncoderFFmpeg::setup(CODEC_ID_MPEG4))
+        return false;
+
+    printf("[ffMpeg] Setup ok\n");
+    return true;
+}
+
+
+/** 
+    \fn ~ADM_ffMpeg4Encoder
+*/
+ADM_ffMpeg4Encoder::~ADM_ffMpeg4Encoder()
+{
+    printf("[ffMpeg4Encoder] Destroying.\n");
+   
+    
+}
+
+/**
+    \fn encode
+*/
+bool         ADM_ffMpeg4Encoder::encode (ADMBitstream * out)
+{
+int sz,q;
+again:
+    sz=0;
+    if(false==preEncode()) // Pop - out the frames stored in the queue due to B-frames
+    {
+        if ((sz = avcodec_encode_video (_context, out->data, out->bufferSize, NULL)) <= 0)
+        {
+            printf("[ffmpeg4] Error %d encoding video\n",sz);
+            return false;
+        }
+        printf("[ffmpeg4] Popping delayed bframes (%d)\n",sz);
+        goto link;
+        return false;
+    }
+    q=image->_Qp;
+    
+    if(!q) q=2;
+    switch(Settings.params.mode)
+    {
+      case COMPRESS_SAME:
+                // Keep same frame type & same Qz as the incoming frame...
+            _frame.quality = (int) floor (FF_QP2LAMBDA * q+ 0.5);
+
+            if(image->flags & AVI_KEY_FRAME)    _frame.pict_type=FF_I_TYPE;
+            else if(image->flags & AVI_B_FRAME) _frame.pict_type=FF_B_TYPE;
+            else                                _frame.pict_type=FF_P_TYPE;
+
+            break;
+      case COMPRESS_2PASS:
+      case COMPRESS_2PASS_BITRATE:
+            switch(pass)
+            {
+                case 1: 
+                        break;
+                case 2: 
+                        break; // Get Qz for this frame...
+            }
+      case COMPRESS_CQ:
+            _frame.quality = (int) floor (FF_QP2LAMBDA * Settings.params.qz+ 0.5);
+            break;
+      case COMPRESS_CBR:
+            break;
+     default:
+            printf("[ffMpeg4] Unsupported encoding mode\n");
+            return false;
+    }
+    aprintf("[CODEC] Flags = 0x%x, QSCALE=%x, bit_rate=%d, quality=%d qz=%d incoming qz=%d\n",_context->flags,CODEC_FLAG_QSCALE,
+                                     _context->bit_rate,  _frame.quality, _frame.quality/ FF_QP2LAMBDA,q);     
+    
+    _frame.reordered_opaque=image->Pts;
+    if ((sz = avcodec_encode_video (_context, out->data, out->bufferSize, &_frame)) < 0)
+    {
+        printf("[ffmpeg4] Error %d encoding video\n",sz);
+        return false;
+    }
+    
+    if(sz==0) // no pic, probably pre filling, try again
+        goto again;
+link:
+    postEncode(out,sz);
+   
+    return true;
+}
+
+/**
+    \fn isDualPass
+
+*/
+bool         ADM_ffMpeg4Encoder::isDualPass(void) 
+{
+    if(Settings.params.mode==COMPRESS_2PASS || Settings.params.mode==COMPRESS_2PASS_BITRATE ) return true;
+    return false;
+
+}
+
+/**
+    \fn jpegConfigure
+    \brief UI configuration for jpeg encoder
+*/
+
+bool         ffMpeg4Configure(void)
+{         
+diaMenuEntry meE[]={
+  {1,QT_TR_NOOP("None")},
+  {2,QT_TR_NOOP("Full")},
+  {3,QT_TR_NOOP("Log")},
+  {4,QT_TR_NOOP("Phods")},
+  {5,QT_TR_NOOP("EPZS")},
+  {6,QT_TR_NOOP("X1")}
+};       
+
+diaMenuEntry qzE[]={
+  {0,QT_TR_NOOP("H.263")},
+  {1,QT_TR_NOOP("MPEG")}
+};       
+
+diaMenuEntry rdE[]={
+  {0,QT_TR_NOOP("MB comparison")},
+  {1,QT_TR_NOOP("Fewest bits (vhq)")},
+  {2,QT_TR_NOOP("Rate distortion")}
+};     
+diaMenuEntry threads[]={
+  {0,QT_TR_NOOP("One thread")},
+  {2,QT_TR_NOOP("Two threads)")},
+  {3,QT_TR_NOOP("Three threads")},
+  {99,QT_TR_NOOP("Auto (#cpu)")}
+};     
+
+
+        FFcodecSettings *conf=&Mp4Settings;
+
+uint32_t me=(uint32_t)conf->lavcSettings.me_method;  
+#define PX(x) &(conf->lavcSettings.x)
+
+         diaElemBitrate   bitrate(&(Mp4Settings.params),NULL);
+         diaElemMenu      meM(&me,QT_TR_NOOP("Matrices"),4,meE);
+         diaElemMenu      threadM(PX(MultiThreaded),QT_TR_NOOP("Threading"),4,threads);
+         diaElemUInteger  qminM(PX(qmin),QT_TR_NOOP("Mi_n. quantizer:"),1,31);
+         diaElemUInteger  qmaxM(PX(qmax),QT_TR_NOOP("Ma_x. quantizer:"),1,31);
+         diaElemUInteger  qdiffM(PX(max_qdiff),QT_TR_NOOP("Max. quantizer _difference:"),1,31);
+         
+         diaElemToggle    fourMv(PX(_4MV),QT_TR_NOOP("4_MV"));
+         diaElemToggle    trellis(PX(_TRELLIS_QUANT),QT_TR_NOOP("_Trellis quantization"));
+         
+         diaElemToggle    qpel(PX(_QPEL),QT_TR_NOOP("_Quarter pixel"));
+         diaElemToggle    gmc(PX(_GMC),QT_TR_NOOP("_GMC"));
+
+         
+         diaElemUInteger  max_b_frames(PX(max_b_frames),QT_TR_NOOP("_Number of B frames:"),0,32);
+         diaElemMenu     qzM(PX(mpeg_quant),QT_TR_NOOP("_Quantization type:"),2,qzE);
+         
+         diaElemMenu     rdM(PX(mb_eval),QT_TR_NOOP("_Macroblock decision:"),3,rdE);
+         
+         diaElemUInteger filetol(PX(vratetol),QT_TR_NOOP("_Filesize tolerance (kb):"),0,100000);
+         
+         diaElemFloat    qzComp(PX(qcompress),QT_TR_NOOP("_Quantizer compression:"),0,1);
+         diaElemFloat    qzBlur(PX(qblur),QT_TR_NOOP("Quantizer _blur:"),0,1);
+         
+        diaElemUInteger GopSize(PX(gop_size),QT_TR_NOOP("_Gop Size:"),1,500); 
+          /* First Tab : encoding mode */
+        diaElem *diamode[]={&GopSize,&threadM,&bitrate};
+        diaElemTabs tabMode(QT_TR_NOOP("User Interface"),3,diamode);
+        
+        /* 2nd Tab : ME */
+        diaElemFrame frameMe(QT_TR_NOOP("Advanced Simple Profile"));
+        
+        frameMe.swallow(&max_b_frames);
+        frameMe.swallow(&qpel);
+        frameMe.swallow(&gmc);
+        
+        diaElem *diaME[]={&fourMv,&frameMe};
+        diaElemTabs tabME(QT_TR_NOOP("Motion Estimation"),2,diaME);
+        /* 3nd Tab : Qz */
+        
+         diaElem *diaQze[]={&qzM,&rdM,&qminM,&qmaxM,&qdiffM,&trellis};
+        diaElemTabs tabQz(QT_TR_NOOP("Quantization"),6,diaQze);
+        
+        /* 4th Tab : RControl */
+        
+         diaElem *diaRC[]={&filetol,&qzComp,&qzBlur};
+        diaElemTabs tabRC(QT_TR_NOOP("Rate Control"),3,diaRC);
+        
+         diaElemTabs *tabs[]={&tabMode,&tabME,&tabQz,&tabRC};
+        if( diaFactoryRunTabs(QT_TR_NOOP("libavcodec MPEG-4 configuration"),4,tabs))
+        {
+          conf->lavcSettings.me_method=(Motion_Est_ID)me;
+          return true;
+        }
+         return false;
+}
+// EOF
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h	2010-03-08 18:30:10 UTC (rev 5985)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h	2010-03-09 06:29:31 UTC (rev 5986)
@@ -0,0 +1,47 @@
+/***************************************************************************
+                          \fn ADM_VideoEncoders
+                          \brief Internal handling of video encoders
+                             -------------------
+    
+    copyright            : (C) 2002/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_xvid4_H
+#define ADM_xvid4_H
+#include "ADM_coreVideoEncoder.h"
+#include "ADM_encoderConf.h"
+#include "xvid4_encoder.h"
+/**
+        \class ADM_ffMpeg4Encoder
+        \brief Dummy encoder that does nothing
+
+*/
+class xvid4Encoder : public ADM_coreVideoEncoder
+{
+protected:
+               
+           
+               int             plane;
+               
+public:
+
+                           xvid4Encoder(ADM_coreVideoFilter *src,bool globalHeader);
+virtual                    ~xvid4Encoder();
+virtual        bool        setup(void); 
+virtual        bool        encode (ADMBitstream * out);
+virtual const  char        *getFourcc(void) {return "DIVX";}
+
+virtual        bool         isDualPass(void) ;
+
+};
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt	2010-03-08 18:30:10 UTC (rev 5985)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt	2010-03-09 06:29:31 UTC (rev 5986)
@@ -0,0 +1,12 @@
+INCLUDE(ve_plugin)
+
+SET(xvid4_SRCS 
+        ADM_xvid4.cpp
+        xvid4Plugin.cpp
+)
+INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})
+
+ADD_LIBRARY(ADM_ve_xvid4 SHARED ${xvid4_SRCS})
+
+INIT_VIDEO_ENCODER(ADM_ve_xvid4)
+INSTALL_VIDEO_ENCODER(ADM_ve_xvid4)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Plugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Plugin.cpp	2010-03-08 18:30:10 UTC (rev 5985)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Plugin.cpp	2010-03-09 06:29:31 UTC (rev 5986)
@@ -0,0 +1,33 @@
+/***************************************************************************
+                          \fn     xvid4Plugin
+                          \brief  Plugin for xvid4 dummy encoder
+                             -------------------
+    
+    copyright            : (C) 2002/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_xvid4.h"
+#include "ADM_coreVideoEncoderInternal.h"
+#include "xvid4_encoder_desc.cpp"
+extern bool         xvid4Configure(void);
+extern xvid4_encoder xvid4Settings;
+ADM_DECLARE_VIDEO_ENCODER_PREAMBLE(xvid4Encoder);
+ADM_DECLARE_VIDEO_ENCODER_MAIN("xvid4",
+                               "Mpeg4 ASP (xvid4)",
+                               "Xvid4 based mpeg4 Encoder (c) 2009 Mean",
+                                xvid4Configure, // No configuration
+                                ADM_UI_ALL,
+                                1,0,0,
+                                xvid4_encoder_param, // conf template
+                                &xvid4Settings // conf var
+);

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.conf	2010-03-08 18:30:10 UTC (rev 5985)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.conf	2010-03-09 06:29:31 UTC (rev 5986)
@@ -0,0 +1,8 @@
+video_encode:params
+uint32_t:rdMode
+uint32_t:motionEstimation
+uint32_t:cqmMode
+uint32_t:arMode
+uint32_t:maxBFrame
+uint32_t:maxKeyFrameInterval
+bool:trellis

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h	2010-03-08 18:30:10 UTC (rev 5985)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h	2010-03-09 06:29:31 UTC (rev 5986)
@@ -0,0 +1,15 @@
+// Automatically generated, do not edit!
+#ifndef ADM_xvid4_encoder_CONF_H
+#define ADM_xvid4_encoder_CONF_H
+typedef struct {
+   COMPRES_PARAMS params;
+   uint32_t rdMode;
+   uint32_t motionEstimation;
+   uint32_t cqmMode;
+   uint32_t arMode;
+   uint32_t maxBFrame;
+   uint32_t maxKeyFrameInterval;
+   bool trellis;
+}xvid4_encoder;
+#endif //xvid4_encoder
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder_desc.cpp	2010-03-08 18:30:10 UTC (rev 5985)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder_desc.cpp	2010-03-09 06:29:31 UTC (rev 5986)
@@ -0,0 +1,12 @@
+// Automatically generated, do not edit!
+const ADM_paramList xvid4_encoder_param[]={
+ {"params",offsetof( xvid4_encoder,params),"COMPRES_PARAMS",ADM_param_video_encode},
+ {"rdMode",offsetof( xvid4_encoder,rdMode),"uint32_t",ADM_param_uint32_t},
+ {"motionEstimation",offsetof( xvid4_encoder,motionEstimation),"uint32_t",ADM_param_uint32_t},
+ {"cqmMode",offsetof( xvid4_encoder,cqmMode),"uint32_t",ADM_param_uint32_t},
+ {"arMode",offsetof( xvid4_encoder,arMode),"uint32_t",ADM_param_uint32_t},
+ {"maxBFrame",offsetof( xvid4_encoder,maxBFrame),"uint32_t",ADM_param_uint32_t},
+ {"maxKeyFrameInterval",offsetof( xvid4_encoder,maxKeyFrameInterval),"uint32_t",ADM_param_uint32_t},
+ {"trellis",offsetof( xvid4_encoder,trellis),"bool",ADM_param_bool},
+{NULL,0,NULL}
+};



From mean at mail.berlios.de  Tue Mar  9 07:29:43 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 9 Mar 2010 07:29:43 +0100
Subject: [Avidemux-svn-commit] r5987 -
	branches/avidemux_2.6_branch_mean/addons/avisynthproxy
Message-ID: <201003090629.o296ThWG001762@sheep.berlios.de>

Author: mean
Date: 2010-03-09 07:29:39 +0100 (Tue, 09 Mar 2010)
New Revision: 5987

Modified:
   branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.cpp
   branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.sln
   branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.h
   branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.idb
Log:
[avsproxy] Resync

Modified: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.cpp	2010-03-09 06:29:31 UTC (rev 5986)
+++ branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.cpp	2010-03-09 06:29:39 UTC (rev 5987)
@@ -17,7 +17,7 @@
 #define INT_MAX 0x7fffffff
 #endif
 
-#define MY_VERSION "Avs2YUV 0.24 ADM_1.1"
+#define MY_VERSION "Avs2YUV 0.24 ADM_1.2"
 #define MAX_FH 10
 #include "winsock2.h"
 #define Log printf
@@ -49,7 +49,7 @@
 	char *audioBuffer=new char[48000*6*2];
 	char *audioBufferData=audioBuffer+sizeof(avsAudioFrame);
 
-	printf("AvsSocket Proxy, derivated from avs2yuv by  Loren Merritt \n");
+	printf("AvsSocket Proxy, derivated from avs2yuv by  Loren Merritt "MY_VERSION" \n");
 	fflush(stdout);
 	
 	
@@ -333,12 +333,15 @@
 		// audio part
 		info.frequency=inf.SamplesPerSecond(); // 0 means no audio
 		info.channels=inf.AudioChannels();
-		if(inf.SampleType()!=SAMPLE_INT16)
+		if(info.frequency)
 		{
-			printf("Only int16 for audio and not %d!\n",(int)inf.SampleType());
-			fflush(stdout);
-			handleError();
-			return false;	
+			if(inf.SampleType()!=SAMPLE_INT16)
+			{
+				printf("Only int16 for audio and not %d!\n",(int)inf.SampleType());
+				fflush(stdout);
+				handleError();
+				return false;	
+			}
 		}
 		if(!inf.IsYV12()) 
 		{

Modified: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.sln
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.sln	2010-03-09 06:29:31 UTC (rev 5986)
+++ branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.sln	2010-03-09 06:29:39 UTC (rev 5987)
@@ -1,6 +1,6 @@
 ???
-Microsoft Visual Studio Solution File, Format Version 9.00
-# Visual Studio 2005
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual C++ Express 2008
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "avsproxy", "avsproxy.vcproj", "{FDA95A7F-919C-4343-96C6-FB0F59FFE5B0}"
 EndProject
 Global


Property changes on: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.sln
___________________________________________________________________
Name: svn:executable
   + *

Modified: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.h	2010-03-09 06:29:31 UTC (rev 5986)
+++ branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.h	2010-03-09 06:29:39 UTC (rev 5987)
@@ -7,7 +7,7 @@
 #include "proxytype.h"
 #ifndef SKET_H
 #define SKET_H
-#define DEBUG
+//#define DEBUG
 #define MAGGIC 0xDEADBEEF
 
 typedef struct SktHeader

Modified: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.idb
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.idb	2010-03-09 06:29:31 UTC (rev 5986)
+++ branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.idb	2010-03-09 06:29:39 UTC (rev 5987)
@@ -1,40 +1,35 @@
 Microsoft C/C++ MSF 7.00
-DS

+DS


 
 
 
-

-
-
-
-
-
-
-
-
-

dks\windows\v6.0a\include\ktmtypes.h
inversedeps/c:\program files (x86)\microsoft visual studio 9.0\vc\include\vadefs.h


files\microsoft sdks\windows\v6.0a\include\winsmcrd.h
oft sdks\windows\v6.0a\include\ktmtypes.h


r/inversedeps/c:\program files\microsoft sdks\windows\v6.0a\include\guiddef.h
ef.h
-
-
xception
+
versedeps/c:\program files\microsoft sdks\windows\v6.0a\include\reason.h
sual studio 9.0\vc\include\stdlib.h


microsoft visual studio 9.0\vc\include\exception
 
 
 
-
+
+


clude\guiddef.h
+
+
A
+
+
+
+
	??a
 
-
-
-
+

+
 
-
nversedeps/c:\program files (x86)\microsoft visual studio 9.0\vc\include\climits
m files (x86)\microsoft visual studio 9.0\vc\include\vector
S
+
poppack.h
/d:\avidemux_2.6_branch_mean\addons\avisynthproxy\sket.h


ersedeps/c:\program files\microsoft sdks\windows\v6.0a\include\guiddef.h

s (x86)\microsoft visual studio 9.0\vc\include\iosfwd
 
 
 
-

m files\microsoft sdDRS 8

lude\xstddef

+
+
deps/c:\program files\microsoft sdks\windows\v6.0a\include\ddeml.h

studio 9.0\vc\include\eh.h
/mr/inversedeps/c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
 
 
 
 
-
-


















+


















 
 
 



From mean at mail.berlios.de  Tue Mar  9 07:29:47 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 9 Mar 2010 07:29:47 +0100
Subject: [Avidemux-svn-commit] r5988 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4
Message-ID: <201003090629.o296TlME001904@sheep.berlios.de>

Author: mean
Date: 2010-03-09 07:29:47 +0100 (Tue, 09 Mar 2010)
New Revision: 5988

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Plugin.cpp
Log:
[xvid] change title

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Plugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Plugin.cpp	2010-03-09 06:29:39 UTC (rev 5987)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Plugin.cpp	2010-03-09 06:29:47 UTC (rev 5988)
@@ -24,7 +24,7 @@
 ADM_DECLARE_VIDEO_ENCODER_PREAMBLE(xvid4Encoder);
 ADM_DECLARE_VIDEO_ENCODER_MAIN("xvid4",
                                "Mpeg4 ASP (xvid4)",
-                               "Xvid4 based mpeg4 Encoder (c) 2009 Mean",
+                               "Xvid4 based mpeg4 Encoder (c) 2010 Mean/Gruntster",
                                 xvid4Configure, // No configuration
                                 ADM_UI_ALL,
                                 1,0,0,



From mean at mail.berlios.de  Wed Mar 10 20:01:31 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 10 Mar 2010 20:01:31 +0100
Subject: [Avidemux-svn-commit] r5989 - in branches/avidemux_2.6_branch_mean:
	avidemux_plugins/ADM_videoEncoder/xvid4 cmake
Message-ID: <201003101901.o2AJ1VgS010522@sheep.berlios.de>

Author: mean
Date: 2010-03-10 20:01:30 +0100 (Wed, 10 Mar 2010)
New Revision: 5989

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h
   branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake
Log:
[xvid] Slightly better xvid4 import, not working. It is only a very simple xvid4 encoder to make sure it fits in the framework. It is also useful to check that 2.6 is not way slower than 2.5

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-09 06:29:47 UTC (rev 5988)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-10 19:01:30 UTC (rev 5989)
@@ -1,9 +1,9 @@
 /***************************************************************************
-                          \fn ADM_ffMpeg4
-                          \brief Front end for libavcodec Mpeg4 asp encoder
+                          \fn ADM_Xvid4
+                          \brief Front end for xvid4 Mpeg4 asp encoder
                              -------------------
     
-    copyright            : (C) 2002/2009 by mean
+    copyright            : (C) 2002/2009 by mean/gruntster
     email                : fixounet at free.fr
  ***************************************************************************/
 
@@ -15,9 +15,8 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "ADM_lavcodec.h"
+
 #include "ADM_default.h"
-#if 0
 #include "ADM_xvid4.h"
 #undef ADM_MINIMAL_UI_INTERFACE // we need the full UI
 #include "DIA_factory.h"
@@ -28,7 +27,9 @@
 #define aprintf printf
 #endif
 
-FFcodecSettings Mp4Settings=
+#define MMSET(x) memset(&(x),0,sizeof(x))
+
+xvid4_encoder xvid4Settings=
 {
     {
     COMPRESS_CQ, //COMPRESSION_MODE  mode;
@@ -38,91 +39,166 @@
     1500,           //uint32_t          avg_bitrate;  /// avg_bitrate is in kb/s!!
     ADM_ENC_CAP_CBR+ADM_ENC_CAP_CQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_2PASS_BR+ADM_ENC_CAP_GLOBAL+ADM_ENC_CAP_SAME
     },
-    {
-        ADM_AVCODEC_SETTING_VERSION,
-        2, // Multithreaded
-          ME_EPZS,			// ME
-          0,				// GMC     
-          1,				// 4MV
-          0,				// _QPEL;   
-          1,				// _TREILLIS_QUANT
-          2,				// qmin;
-          31,				// qmax;
-          3,				// max_qdiff;
-          2,				// max_b_frames;
-          0,				// mpeg_quant;
-          1,				// is_luma_elim_threshold
-          -2,				// luma_elim_threshold;
-          1,				// is_chroma_elim_threshold
-          -5,				// chroma_elim_threshold;
-          0.05,				//lumi_masking;
-          1,				// is lumi
-          0.01,				//dark_masking; 
-          1,				// is dark
-          0.5,				// qcompress amount of qscale change between easy & hard scenes (0.0-1.0
-          0.5,				// qblur;    amount of qscale smoothing over time (0.0-1.0) 
-          0,				// min bitrate in kB/S
-          0,				// max bitrate
-          0,				// user matrix
-          250,				// gop size
-          0,				// interlaced
-          0,				// WLA: bottom-field-first
-          0,				// wide screen
-          2,				// mb eval = distortion
-          8000,				// vratetol 8Meg
-          0,				// is temporal
-          0.0,				// temporal masking
-          0,				// is spatial
-          0.0,				// spatial masking
-          0,				// NAQ
-          0,                // xvid rc
-          0,                // buffersize
-          0,                // override ratecontrol
-          0				    // DUMMY 
-    }
+    
+            false, //mpegQuant
+            0, // rdMode
+            0, // MotionEstimation
+            0, // cqmMode
+            0, // arMode
+            0, // MaxBframe
+            0, // MaxKeyInterval
+            true // Trellis
+    
 };
+
+typedef enum
+{
+        ME_NONE = 0,
+        ME_LOW = XVID_ME_HALFPELREFINE16,
+        ME_MEDIUM = XVID_ME_HALFPELREFINE16 | XVID_ME_ADVANCEDDIAMOND16,
+        ME_HIGH = XVID_ME_HALFPELREFINE16 | XVID_ME_EXTSEARCH16 | XVID_ME_HALFPELREFINE8 | XVID_ME_USESQUARES16
+} MotionEstimationMode;
+
+uint32_t motionMode[4]=
+{
+    ME_NONE,ME_LOW,ME_MEDIUM,ME_HIGH
+};
+
+typedef enum
+{
+        INTERLACED_NONE,
+        INTERLACED_BFF,
+        INTERLACED_TFF
+} InterlacedMode;
+
+typedef enum
+{
+        RD_NONE = -1,
+        RD_DCT_ME = 0,
+        RD_HPEL_QPEL_16 = RD_DCT_ME | XVID_ME_HALFPELREFINE16_RD | XVID_ME_QUARTERPELREFINE16_RD,
+        RD_HPEL_QPEL_8 = RD_HPEL_QPEL_16 | XVID_ME_HALFPELREFINE8_RD | XVID_ME_QUARTERPELREFINE8_RD | XVID_ME_CHECKPREDICTION_RD,
+        RD_SQUARE = RD_HPEL_QPEL_8 | XVID_ME_EXTSEARCH_RD
+} RateDistortionMode;
+uint32_t rdMode[5]=
+{
+    RD_NONE,
+    RD_DCT_ME,
+    RD_HPEL_QPEL_16,
+    RD_HPEL_QPEL_8,
+    RD_SQUARE
+};
+
 /**
-        \fn ADM_ffMpeg4Encoder
+        \fn xvid4Encoder
 */
-ADM_ffMpeg4Encoder::ADM_ffMpeg4Encoder(ADM_coreVideoFilter *src,bool globalHeader) : ADM_coreVideoEncoderFFmpeg(src,&Mp4Settings,globalHeader)
+xvid4Encoder::xvid4Encoder(ADM_coreVideoFilter *src,bool globalHeader) : ADM_coreVideoEncoder(src)
 {
-    printf("[ffMpeg4Encoder] Creating.\n");
-   
+    printf("[xvid4] Creating.\n");
+    this->globalHeader=globalHeader;
+    handle=NULL;
+    MMSET(xvid_enc_frame);
+}
+/**
+    \fn query
+    \brief query xvid about version and flags
+*/
+bool xvid4Encoder::query(void)
+{
 
+ xvid_gbl_init_t   xvid_gbl_init2;
+ xvid_gbl_info_t   xvid_gbl_info;
+ 
+  MMSET (xvid_gbl_init2);
+  MMSET (xvid_gbl_info);
+
+  printf ("[xvid] Initializing global Xvid 4\n");
+  xvid_gbl_init2.version = XVID_VERSION;
+  xvid_global (NULL, XVID_GBL_INIT, &xvid_gbl_init2, NULL);
+  xvid_gbl_info.version = XVID_VERSION;
+  xvid_global (NULL, XVID_GBL_INFO, &xvid_gbl_info, NULL);
+
+  if (xvid_gbl_info.build)
+      printf ("[xvid] Build: %s\n", xvid_gbl_info.build);
+
+  printf ("[xvid] SIMD supported: (%x)\n", xvid_gbl_info.cpu_flags);
+#define CPUF(x) if(xvid_gbl_info.cpu_flags  & XVID_CPU_##x) printf("\t\t"#x"\n");
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+  CPUF (MMX);
+  CPUF (MMXEXT);
+  CPUF (SSE);
+  CPUF (SSE2);
+  CPUF (3DNOW);
+  CPUF (3DNOWEXT);
+#endif
 }
-
 /**
     \fn setup
 */
-bool ADM_ffMpeg4Encoder::setup(void)
+bool xvid4Encoder::setup(void)
 {
-    
-    switch(Settings.params.mode)
+  ADM_info("Xvid4, setting up");
+  query();
+  xvid_enc_create_t xvid_enc_create;
+  // Here we go...
+  MMSET (xvid_enc_create);
+  xvid_enc_create.version = XVID_VERSION;
+  xvid_enc_create.width = getWidth();
+  xvid_enc_create.height =getHeight();
+  
+  single.version = XVID_VERSION;
+
+    switch(xvid4Settings.params.mode)
     {
       case COMPRESS_2PASS:
       case COMPRESS_2PASS_BITRATE:
+#if 0
            if(false==setupPass())
             {
-                printf("[ffmpeg] Multipass setup failed\n");
+                ADM_warning("[xvid4] Multipass setup failed\n");
                 return false;
             }
+#endif
             break;
       case COMPRESS_SAME:
       case COMPRESS_CQ:
-            _context->flags |= CODEC_FLAG_QSCALE;
-            _context->bit_rate = 0;
-            break;
       case COMPRESS_CBR:
-              _context->bit_rate=Settings.params.bitrate*1000; // kb->b;
+                  MMSET (single);
+                  plugins[0].func = xvid_plugin_single;
+                  plugins[0].param = &single;
+
+                  single.version = XVID_VERSION;
+                  switch(xvid4Settings.params.mode)
+                  {
+                    case COMPRESS_CBR:
+                            single.bitrate = xvid4Settings.params.bitrate*1000;
+                            break;
+                    case COMPRESS_CQ:
+                    case COMPRESS_SAME:
+
+                            break;
+                   }
             break;
      default:
             return false;
     }
-    presetContext(&Settings);
-    if(false== ADM_coreVideoEncoderFFmpeg::setup(CODEC_ID_MPEG4))
-        return false;
+   
 
-    printf("[ffMpeg] Setup ok\n");
+  xvid_enc_create.plugins = plugins;
+  xvid_enc_create.num_plugins = 1;
+
+    //Framerate
+    xvid_enc_create.fincr = 1000;
+    xvid_enc_create.fbase = 25000;
+    int xerr = xvid_encore (NULL, XVID_ENC_CREATE, &xvid_enc_create, NULL);
+    if (xerr < 0)
+    {
+      ADM_error ("[xvid] init error: %d\n", xerr);
+      return false;
+    }
+
+    handle = xvid_enc_create.handle;
+    image=new ADMImage(getWidth(),getHeight());
+    ADM_info("Xvid4, setup ok\n");
     return true;
 }
 
@@ -130,79 +206,47 @@
 /** 
     \fn ~ADM_ffMpeg4Encoder
 */
-ADM_ffMpeg4Encoder::~ADM_ffMpeg4Encoder()
+xvid4Encoder::~xvid4Encoder()
 {
-    printf("[ffMpeg4Encoder] Destroying.\n");
-   
-    
+    ADM_info("[xvid4] Destroying.\n");
+    if(handle)
+    {
+        xvid_encore(handle, XVID_ENC_DESTROY, NULL, NULL);
+        handle=NULL;
+    }
 }
 
 /**
     \fn encode
 */
-bool         ADM_ffMpeg4Encoder::encode (ADMBitstream * out)
+bool         xvid4Encoder::encode (ADMBitstream * out)
 {
-int sz,q;
-again:
-    sz=0;
-    if(false==preEncode()) // Pop - out the frames stored in the queue due to B-frames
+    // 1 fetch a frame...
+    uint32_t nb;
+    if(source->getNextFrame(&nb,image)==false)
     {
-        if ((sz = avcodec_encode_video (_context, out->data, out->bufferSize, NULL)) <= 0)
-        {
-            printf("[ffmpeg4] Error %d encoding video\n",sz);
-            return false;
-        }
-        printf("[ffmpeg4] Popping delayed bframes (%d)\n",sz);
-        goto link;
+        ADM_warning("[xvid4] Cannot get next image\n");
         return false;
     }
-    q=image->_Qp;
-    
-    if(!q) q=2;
-    switch(Settings.params.mode)
+    // 2-premable
+    if(false==preAmble(image))
     {
-      case COMPRESS_SAME:
-                // Keep same frame type & same Qz as the incoming frame...
-            _frame.quality = (int) floor (FF_QP2LAMBDA * q+ 0.5);
-
-            if(image->flags & AVI_KEY_FRAME)    _frame.pict_type=FF_I_TYPE;
-            else if(image->flags & AVI_B_FRAME) _frame.pict_type=FF_B_TYPE;
-            else                                _frame.pict_type=FF_P_TYPE;
-
-            break;
-      case COMPRESS_2PASS:
-      case COMPRESS_2PASS_BITRATE:
-            switch(pass)
-            {
-                case 1: 
-                        break;
-                case 2: 
-                        break; // Get Qz for this frame...
-            }
-      case COMPRESS_CQ:
-            _frame.quality = (int) floor (FF_QP2LAMBDA * Settings.params.qz+ 0.5);
-            break;
-      case COMPRESS_CBR:
-            break;
-     default:
-            printf("[ffMpeg4] Unsupported encoding mode\n");
-            return false;
+        ADM_warning("[Xvid4] preAmble failed\n");
+        return false;
     }
-    aprintf("[CODEC] Flags = 0x%x, QSCALE=%x, bit_rate=%d, quality=%d qz=%d incoming qz=%d\n",_context->flags,CODEC_FLAG_QSCALE,
-                                     _context->bit_rate,  _frame.quality, _frame.quality/ FF_QP2LAMBDA,q);     
-    
-    _frame.reordered_opaque=image->Pts;
-    if ((sz = avcodec_encode_video (_context, out->data, out->bufferSize, &_frame)) < 0)
+    int size = xvid_encore(handle, XVID_ENC_ENCODE, &xvid_enc_frame, &xvid_enc_stats);
+    if (size < 0)
     {
-        printf("[ffmpeg4] Error %d encoding video\n",sz);
+        ADM_error("[Xvid] Error performing encode %d\n", size);
         return false;
     }
     
-    if(sz==0) // no pic, probably pre filling, try again
-        goto again;
-link:
-    postEncode(out,sz);
-   
+    // 3-encode
+    if(false==postAmble(out,size))
+    {
+        ADM_warning("[Xvid4] postAmble failed\n");
+        return false;     
+    }
     return true;
 }
 
@@ -210,107 +254,121 @@
     \fn isDualPass
 
 */
-bool         ADM_ffMpeg4Encoder::isDualPass(void) 
+bool         xvid4Encoder::isDualPass(void) 
 {
-    if(Settings.params.mode==COMPRESS_2PASS || Settings.params.mode==COMPRESS_2PASS_BITRATE ) return true;
+    if(xvid4Settings.params.mode==COMPRESS_2PASS || xvid4Settings.params.mode==COMPRESS_2PASS_BITRATE ) return true;
     return false;
 
 }
 
 /**
-    \fn jpegConfigure
-    \brief UI configuration for jpeg encoder
+        \fn preAmble
+        \fn prepare a frame to be encoded
 */
+bool  xvid4Encoder::preAmble (ADMImage * in)
+{
+  MMSET (xvid_enc_stats);
 
-bool         ffMpeg4Configure(void)
-{         
-diaMenuEntry meE[]={
-  {1,QT_TR_NOOP("None")},
-  {2,QT_TR_NOOP("Full")},
-  {3,QT_TR_NOOP("Log")},
-  {4,QT_TR_NOOP("Phods")},
-  {5,QT_TR_NOOP("EPZS")},
-  {6,QT_TR_NOOP("X1")}
-};       
+  xvid_enc_frame.version = XVID_VERSION;
+  xvid_enc_stats.version = XVID_VERSION;
 
-diaMenuEntry qzE[]={
-  {0,QT_TR_NOOP("H.263")},
-  {1,QT_TR_NOOP("MPEG")}
-};       
+  /* Bind output buffer */
 
-diaMenuEntry rdE[]={
-  {0,QT_TR_NOOP("MB comparison")},
-  {1,QT_TR_NOOP("Fewest bits (vhq)")},
-  {2,QT_TR_NOOP("Rate distortion")}
-};     
-diaMenuEntry threads[]={
-  {0,QT_TR_NOOP("One thread")},
-  {2,QT_TR_NOOP("Two threads)")},
-  {3,QT_TR_NOOP("Three threads")},
-  {99,QT_TR_NOOP("Auto (#cpu)")}
-};     
+  xvid_enc_frame.length = 0;
+  if (xvid4Settings.mpegQuant)
+    xvid_enc_frame.vol_flags |= XVID_VOL_MPEGQUANT;
+ 
 
+#define SVOP(x,y) if(xvid4Settings.x) xvid_enc_frame.vop_flags|=XVID_VOP_##y
 
-        FFcodecSettings *conf=&Mp4Settings;
+  xvid_enc_frame.motion = motionMode[xvid4Settings.motionEstimation];
+  xvid_enc_frame.vop_flags|=XVID_VOP_INTER4V;
+  xvid_enc_frame.vop_flags |= XVID_VOP_HALFPEL;
+  
+  SVOP (trellis, TRELLISQUANT);
+ // SVOP (hqac, HQACPRED);
+ // SVOP (bvhq, RD_BVOP);
+//  SVOP (chroma_opt, CHROMAOPT);
+  
+  // ME 
+  //if (_param.chroma_me)
+  //  {
+    //  xvid_enc_frame.motion |= XVID_ME_CHROMA_BVOP;
+      //xvid_enc_frame.motion |= XVID_ME_CHROMA_PVOP;
+    //}
+ 
 
-uint32_t me=(uint32_t)conf->lavcSettings.me_method;  
-#define PX(x) &(conf->lavcSettings.x)
+    xvid_enc_frame.motion|=rdMode[xvid4Settings.rdMode];
+ 
+#if 0
 
-         diaElemBitrate   bitrate(&(Mp4Settings.params),NULL);
-         diaElemMenu      meM(&me,QT_TR_NOOP("Matrices"),4,meE);
-         diaElemMenu      threadM(PX(MultiThreaded),QT_TR_NOOP("Threading"),4,threads);
-         diaElemUInteger  qminM(PX(qmin),QT_TR_NOOP("Mi_n. quantizer:"),1,31);
-         diaElemUInteger  qmaxM(PX(qmax),QT_TR_NOOP("Ma_x. quantizer:"),1,31);
-         diaElemUInteger  qdiffM(PX(max_qdiff),QT_TR_NOOP("Max. quantizer _difference:"),1,31);
-         
-         diaElemToggle    fourMv(PX(_4MV),QT_TR_NOOP("4_MV"));
-         diaElemToggle    trellis(PX(_TRELLIS_QUANT),QT_TR_NOOP("_Trellis quantization"));
-         
-         diaElemToggle    qpel(PX(_QPEL),QT_TR_NOOP("_Quarter pixel"));
-         diaElemToggle    gmc(PX(_GMC),QT_TR_NOOP("_GMC"));
+  if (_param.turbo)
+    {
+      xvid_enc_frame.motion |= XVID_ME_FASTREFINE16;
+      xvid_enc_frame.motion |= XVID_ME_FASTREFINE8;
+      xvid_enc_frame.motion |= XVID_ME_SKIP_DELTASEARCH;
+      xvid_enc_frame.motion |= XVID_ME_FAST_MODEINTERPOLATE;
+      xvid_enc_frame.motion |= XVID_ME_BFRAME_EARLYSTOP;
+    }
+#endif
+  //xvid_enc_frame.bframe_threshold = _param.bframe_threshold;
 
-         
-         diaElemUInteger  max_b_frames(PX(max_b_frames),QT_TR_NOOP("_Number of B frames:"),0,32);
-         diaElemMenu     qzM(PX(mpeg_quant),QT_TR_NOOP("_Quantization type:"),2,qzE);
-         
-         diaElemMenu     rdM(PX(mb_eval),QT_TR_NOOP("_Macroblock decision:"),3,rdE);
-         
-         diaElemUInteger filetol(PX(vratetol),QT_TR_NOOP("_Filesize tolerance (kb):"),0,100000);
-         
-         diaElemFloat    qzComp(PX(qcompress),QT_TR_NOOP("_Quantizer compression:"),0,1);
-         diaElemFloat    qzBlur(PX(qblur),QT_TR_NOOP("Quantizer _blur:"),0,1);
-         
-        diaElemUInteger GopSize(PX(gop_size),QT_TR_NOOP("_Gop Size:"),1,500); 
-          /* First Tab : encoding mode */
-        diaElem *diamode[]={&GopSize,&threadM,&bitrate};
-        diaElemTabs tabMode(QT_TR_NOOP("User Interface"),3,diamode);
-        
-        /* 2nd Tab : ME */
-        diaElemFrame frameMe(QT_TR_NOOP("Advanced Simple Profile"));
-        
-        frameMe.swallow(&max_b_frames);
-        frameMe.swallow(&qpel);
-        frameMe.swallow(&gmc);
-        
-        diaElem *diaME[]={&fourMv,&frameMe};
-        diaElemTabs tabME(QT_TR_NOOP("Motion Estimation"),2,diaME);
-        /* 3nd Tab : Qz */
-        
-         diaElem *diaQze[]={&qzM,&rdM,&qminM,&qmaxM,&qdiffM,&trellis};
-        diaElemTabs tabQz(QT_TR_NOOP("Quantization"),6,diaQze);
-        
-        /* 4th Tab : RControl */
-        
-         diaElem *diaRC[]={&filetol,&qzComp,&qzBlur};
-        diaElemTabs tabRC(QT_TR_NOOP("Rate Control"),3,diaRC);
-        
-         diaElemTabs *tabs[]={&tabMode,&tabME,&tabQz,&tabRC};
-        if( diaFactoryRunTabs(QT_TR_NOOP("libavcodec MPEG-4 configuration"),4,tabs))
-        {
-          conf->lavcSettings.me_method=(Motion_Est_ID)me;
-          return true;
-        }
-         return false;
+  xvid_enc_frame.input.csp = XVID_CSP_YV12;
+  xvid_enc_frame.input.stride[0] = getWidth();
+  xvid_enc_frame.input.stride[1] = getWidth()>>1;
+  xvid_enc_frame.input.stride[2] = getWidth()>> 1;
+  xvid_enc_frame.type = XVID_TYPE_AUTO;
+
+
+  /* Set up motion estimation flags */
+  xvid_enc_frame.input.plane[0] = YPLANE(in);
+  xvid_enc_frame.input.plane[1] = UPLANE(in);
+  xvid_enc_frame.input.plane[2] = VPLANE(in);
+#if 0
+  xvid_enc_frame.par_width = _param.par_width;
+  xvid_enc_frame.par_height = _param.par_height;
+  //printf("Using AR : %u x %u\n",xvid_enc_frame.par_width,xvid_enc_frame.par_height );
+  if (xvid_enc_frame.par_width != xvid_enc_frame.par_height)
+      xvid_enc_frame.par = XVID_PAR_EXT;
+  else
+      xvid_enc_frame.par = XVID_PAR_11_VGA;
+
+  /* Custome matrices */
+  if(_param.useCustomIntra) 
+  {
+  if(!xvid_enc_frame.quant_intra_matrix)  
+      printf("[xvid] Using custom intra matrix\n");
+      xvid_enc_frame.quant_intra_matrix=_param.intraMatrix;
+  }
+  if(_param.useCustomInter)
+  {
+    if(!xvid_enc_frame.quant_inter_matrix)
+      printf("[xvid] Using custom inter matrix\n");
+     xvid_enc_frame.quant_inter_matrix=_param.interMatrix;
+  }
+#endif
+  return 1;
 }
+/**
+    \fn postAmble
+    \brief update after a frame has been succesfully encoded
+*/
+bool xvid4Encoder::postAmble (ADMBitstream * out,int size)
+{
+  out->flags = 0;
+  if (xvid_enc_frame.out_flags & XVID_KEYFRAME)
+    {
+      out->flags = AVI_KEY_FRAME;
+    }
+  else if (xvid_enc_stats.type == XVID_TYPE_BVOP)
+    {
+      out->flags = AVI_B_FRAME;
+
+    }
+  out->len=size;
+  //out->pts=ADM_NO_PTS;
+  //out->dts=ADM_NO_PTS;
+  return 1;
+}
 // EOF
-#endif
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h	2010-03-09 06:29:47 UTC (rev 5988)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h	2010-03-10 19:01:30 UTC (rev 5989)
@@ -1,9 +1,9 @@
 /***************************************************************************
-                          \fn ADM_VideoEncoders
+                          \fn xvid4Encoder
                           \brief Internal handling of video encoders
                              -------------------
     
-    copyright            : (C) 2002/2009 by mean
+    copyright            : (C) 2002/2010 by mean/gruntster
     email                : fixounet at free.fr
  ***************************************************************************/
 
@@ -20,18 +20,29 @@
 #include "ADM_coreVideoEncoder.h"
 #include "ADM_encoderConf.h"
 #include "xvid4_encoder.h"
+#include "xvid.h"
 /**
-        \class ADM_ffMpeg4Encoder
-        \brief Dummy encoder that does nothing
+        \class xvid4Encoder
+        \brief Xvid4 mpeg4 encoder
 
 */
 class xvid4Encoder : public ADM_coreVideoEncoder
 {
 protected:
                
-           
+               void           *handle;
                int             plane;
-               
+               bool            globalHeader;
+               bool            preAmble (ADMImage * in);
+               bool            postAmble (ADMBitstream * out,int size);
+               bool            query(void);
+
+                xvid_plugin_single_t single;
+                xvid_plugin_2pass1_t pass1;
+                xvid_plugin_2pass2_t pass2;
+                xvid_enc_frame_t xvid_enc_frame;
+                xvid_enc_stats_t xvid_enc_stats;
+                xvid_enc_plugin_t plugins[7];
 public:
 
                            xvid4Encoder(ADM_coreVideoFilter *src,bool globalHeader);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt	2010-03-09 06:29:47 UTC (rev 5988)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt	2010-03-10 19:01:30 UTC (rev 5989)
@@ -1,3 +1,4 @@
+
 INCLUDE(ve_plugin)
 
 SET(xvid4_SRCS 
@@ -3,9 +4,17 @@
         ADM_xvid4.cpp
         xvid4Plugin.cpp
+        xvid4Dialog.cpp
 )
+include(admCheckXvid)
+checkXvid()
+IF(USE_XVID)
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})
 
+INCLUDE_DIRECTORIES(${XVID_INCLUDE_DIR})
+LINK_DIRECTORIES(${XVID_LIBRARY_DIR})
 ADD_LIBRARY(ADM_ve_xvid4 SHARED ${xvid4_SRCS})
+TARGET_LINK_LIBRARIES(ADM_ve_xvid4 xvidcore )
 
 INIT_VIDEO_ENCODER(ADM_ve_xvid4)
 INSTALL_VIDEO_ENCODER(ADM_ve_xvid4)
+ENDIF(USE_XVID)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp	2010-03-09 06:29:47 UTC (rev 5988)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp	2010-03-10 19:01:30 UTC (rev 5989)
@@ -0,0 +1,129 @@
+/***************************************************************************
+                          \fn ADM_Xvid4
+                          \brief Front end for xvid4 Mpeg4 asp encoder
+                             -------------------
+    
+    copyright            : (C) 2002/2009 by mean/gruntster
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_xvid4.h"
+#undef ADM_MINIMAL_UI_INTERFACE // we need the full UI
+#include "DIA_factory.h"
+
+#if 1
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+/**
+    \fn jpegConfigure
+    \brief UI configuration for jpeg encoder
+*/
+extern xvid4_encoder xvid4Settings;
+bool         xvid4Configure(void)
+{         
+
+diaMenuEntry meE[]={
+  {0,QT_TR_NOOP("None")},
+  {1,QT_TR_NOOP("Low")},
+  {2,QT_TR_NOOP("Medium")},
+  {3,QT_TR_NOOP("Full")}
+};       
+
+diaMenuEntry qzE[]={
+  {0,QT_TR_NOOP("H.263")},
+  {1,QT_TR_NOOP("MPEG")}
+};       
+/*
+diaMenuEntry rdE[]={
+  {0,QT_TR_NOOP("MB comparison")},
+  {1,QT_TR_NOOP("Fewest bits (vhq)")},
+  {2,QT_TR_NOOP("Rate distortion")}
+};     
+diaMenuEntry threads[]={
+  {0,QT_TR_NOOP("One thread")},
+  {2,QT_TR_NOOP("Two threads)")},
+  {3,QT_TR_NOOP("Three threads")},
+  {99,QT_TR_NOOP("Auto (#cpu)")}
+};     
+
+
+        FFcodecSettings *conf=&Mp4Settings;
+
+uint32_t me=(uint32_t)conf->lavcSettings.me_method;  
+*/
+#define PX(x) &(xvid4Settings.x)
+
+         diaElemBitrate   bitrate(&(xvid4Settings.params),NULL);
+         diaElemMenu      meM(PX(motionEstimation),QT_TR_NOOP("MotionEstimation"),4,meE);
+/*
+         diaElemMenu      threadM(PX(MultiThreaded),QT_TR_NOOP("Threading"),4,threads);
+         diaElemUInteger  qminM(PX(qmin),QT_TR_NOOP("Mi_n. quantizer:"),1,31);
+         diaElemUInteger  qmaxM(PX(qmax),QT_TR_NOOP("Ma_x. quantizer:"),1,31);
+         diaElemUInteger  qdiffM(PX(max_qdiff),QT_TR_NOOP("Max. quantizer _difference:"),1,31);
+         
+         diaElemToggle    fourMv(PX(_4MV),QT_TR_NOOP("4_MV"));
+*/
+         uint32_t trelBol=*PX(trellis);
+         diaElemToggle    trellis(&trelBol,QT_TR_NOOP("_Trellis quantization"));
+/*         
+         diaElemToggle    qpel(PX(_QPEL),QT_TR_NOOP("_Quarter pixel"));
+         diaElemToggle    gmc(PX(_GMC),QT_TR_NOOP("_GMC"));
+*/
+         
+         diaElemUInteger  max_b_frames(PX(maxBFrame),QT_TR_NOOP("_Number of B frames:"),0,32);
+/*
+         diaElemMenu     qzM(PX(mpeg_quant),QT_TR_NOOP("_Quantization type:"),2,qzE);
+         
+         diaElemMenu     rdM(PX(mb_eval),QT_TR_NOOP("_Macroblock decision:"),3,rdE);
+         
+         diaElemUInteger filetol(PX(vratetol),QT_TR_NOOP("_Filesize tolerance (kb):"),0,100000);
+         
+         diaElemFloat    qzComp(PX(qcompress),QT_TR_NOOP("_Quantizer compression:"),0,1);
+         diaElemFloat    qzBlur(PX(qblur),QT_TR_NOOP("Quantizer _blur:"),0,1);
+         */
+        diaElemUInteger GopSize(PX(maxKeyFrameInterval),QT_TR_NOOP("_Gop Size:"),1,500); 
+          /* First Tab : encoding mode */
+        diaElem *diamode[]={&bitrate,&meM,&trellis,&max_b_frames,&GopSize};
+        diaElemTabs tabMode(QT_TR_NOOP("User Interface"),5,diamode);
+        
+        /* 2nd Tab : ME */
+        diaElemFrame frameMe(QT_TR_NOOP("Advanced Simple Profile"));
+        
+        
+        frameMe.swallow(&meM);
+        frameMe.swallow(&trellis);
+        frameMe.swallow(&max_b_frames);
+        frameMe.swallow(&GopSize);
+        frameMe.swallow(&bitrate);
+        
+        diaElem *diaME[]={&frameMe};
+        diaElemTabs tabME(QT_TR_NOOP("Motion Estimation"),1,diaME);
+        /* 3nd Tab : Qz */
+       #if 0 
+         diaElem *diaQze[]={&qzM,&rdM,&qminM,&qmaxM,&qdiffM,&trellis};
+        diaElemTabs tabQz(QT_TR_NOOP("Quantization"),6,diaQze);
+        
+        /* 4th Tab : RControl */
+        
+         diaElem *diaRC[]={&filetol,&qzComp,&qzBlur};
+        diaElemTabs tabRC(QT_TR_NOOP("Rate Control"),3,diaRC);
+        #endif
+         diaElemTabs *tabs[]={&tabME};
+        if( diaFactoryRunTabs(QT_TR_NOOP("libavcodec MPEG-4 configuration"),1,tabs))
+        {
+            *PX(trellis)= trelBol;
+            return true;
+        }
+         return false;
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h	2010-03-09 06:29:47 UTC (rev 5988)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h	2010-03-10 19:01:30 UTC (rev 5989)
@@ -3,6 +3,7 @@
 #define ADM_xvid4_encoder_CONF_H
 typedef struct {
    COMPRES_PARAMS params;
+   bool     mpegQuant;
    uint32_t rdMode;
    uint32_t motionEstimation;
    uint32_t cqmMode;

Modified: branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake	2010-03-09 06:29:47 UTC (rev 5988)
+++ branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake	2010-03-10 19:01:30 UTC (rev 5989)
@@ -1,5 +1,4 @@
 MACRO(checkXvid)
-	IF (NOT XVID_CHECKED)
 		OPTION(XVID "" ON)
 
 		MESSAGE(STATUS "Checking for Xvid")
@@ -8,13 +7,9 @@
 		IF (XVID)
 			FIND_HEADER_AND_LIB(XVID xvid.h xvidcore xvid_plugin_single)
 			PRINT_LIBRARY_INFO("Xvid" XVID_FOUND "${XVID_INCLUDE_DIR}" "${XVID_LIBRARY_DIR}")
+                        SET(USE_XVID 1)
 		ELSE (XVID)
 			MESSAGE("${MSG_DISABLE_OPTION}")
 		ENDIF (XVID)
-
-		SET(ENV{ADM_HAVE_XVID} ${XVID_FOUND})
-		SET(XVID_CHECKED 1)
-
 		MESSAGE("")
-	ENDIF (NOT XVID_CHECKED)
-ENDMACRO(checkXvid)
\ No newline at end of file
+ENDMACRO(checkXvid)



From mean at mail.berlios.de  Thu Mar 11 20:00:12 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 11 Mar 2010 20:00:12 +0100
Subject: [Avidemux-svn-commit] r5990 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4
Message-ID: <201003111900.o2BJ0CHK021724@sheep.berlios.de>

Author: mean
Date: 2010-03-11 20:00:10 +0100 (Thu, 11 Mar 2010)
New Revision: 5990

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
Log:
[xvid] Better init, it is still missing PTS/DTS handling

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-10 19:01:30 UTC (rev 5989)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-11 19:00:10 UTC (rev 5990)
@@ -66,19 +66,13 @@
 
 typedef enum
 {
-        INTERLACED_NONE,
-        INTERLACED_BFF,
-        INTERLACED_TFF
-} InterlacedMode;
-
-typedef enum
-{
         RD_NONE = -1,
         RD_DCT_ME = 0,
         RD_HPEL_QPEL_16 = RD_DCT_ME | XVID_ME_HALFPELREFINE16_RD | XVID_ME_QUARTERPELREFINE16_RD,
         RD_HPEL_QPEL_8 = RD_HPEL_QPEL_16 | XVID_ME_HALFPELREFINE8_RD | XVID_ME_QUARTERPELREFINE8_RD | XVID_ME_CHECKPREDICTION_RD,
         RD_SQUARE = RD_HPEL_QPEL_8 | XVID_ME_EXTSEARCH_RD
 } RateDistortionMode;
+
 uint32_t rdMode[5]=
 {
     RD_NONE,
@@ -173,6 +167,8 @@
                             single.bitrate = xvid4Settings.params.bitrate*1000;
                             break;
                     case COMPRESS_CQ:
+                            
+                            break;
                     case COMPRESS_SAME:
 
                             break;
@@ -234,6 +230,7 @@
         ADM_warning("[Xvid4] preAmble failed\n");
         return false;
     }
+    xvid_enc_frame.bitstream = out->data;
     int size = xvid_encore(handle, XVID_ENC_ENCODE, &xvid_enc_frame, &xvid_enc_stats);
     if (size < 0)
     {
@@ -347,6 +344,8 @@
      xvid_enc_frame.quant_inter_matrix=_param.interMatrix;
   }
 #endif
+    if(xvid4Settings.params.mode==COMPRESS_CQ)
+            xvid_enc_frame.quant=xvid4Settings.params.qz;
   return 1;
 }
 /**



From mean at mail.berlios.de  Thu Mar 11 20:00:16 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 11 Mar 2010 20:00:16 +0100
Subject: [Avidemux-svn-commit] r5991 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder:
	include src
Message-ID: <201003111900.o2BJ0GQe021752@sheep.berlios.de>

Author: mean
Date: 2010-03-11 20:00:14 +0100 (Thu, 11 Mar 2010)
New Revision: 5991

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoder.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
Log:
[VideoEncoder] Some parts are not specific to ffmpeg related encoder, move them to base class

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoder.h	2010-03-11 19:00:10 UTC (rev 5990)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoder.h	2010-03-11 19:00:14 UTC (rev 5991)
@@ -21,7 +21,12 @@
 #include "ADM_coreVideoFilter.h"
 #include "ADM_bitstream.h"
 #include "ADM_frameType.h"
+#include <vector>
+using std::vector;
 #include "stddef.h"
+/**
+
+*/
 typedef enum
 {
     ADM_ENCODER_OPTION_MOV_MODE=1
@@ -29,6 +34,14 @@
 }ADM_coreEncoderOption;
 
 /**
+
+*/
+typedef struct
+{
+    uint64_t internalTS;
+    uint64_t realTS;
+}ADM_timeMapping;
+/**
     \class ADM_coreVideoEncoder
     \brief base class for VideoEncoder
 */
@@ -38,6 +51,9 @@
                             ADM_coreVideoFilter *source;
                             ADMImage            *image;
                             uint64_t            encoderDelay;
+                            vector <ADM_timeMapping>mapper;
+                            bool                getRealPtsFromInternal(uint64_t val,uint64_t *dts,uint64_t *pts);
+                            vector <uint64_t>queueOfDts;
 public:
                             ADM_coreVideoEncoder(ADM_coreVideoFilter *src);
 virtual                     ~ADM_coreVideoEncoder();
@@ -55,6 +71,6 @@
 virtual        bool        setPassAndLogFile(int pass,const char *name) {return false;}
                uint64_t    getEncoderDelay(void){return encoderDelay;}
 };
-
+bool usSecondsToFrac(uint64_t useconds, int *n,int *d);
 #endif
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h	2010-03-11 19:00:10 UTC (rev 5990)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h	2010-03-11 19:00:14 UTC (rev 5991)
@@ -24,13 +24,6 @@
 #include "ADM_coreVideoEncoderFFmpeg_param.h"
 #include "FFcodecSettings.h"
 
-#include <vector>
-using std::vector;
-typedef struct
-{
-    uint64_t lavTS;
-    uint64_t realTS;
-}ADM_timeMapping;
 
 /**
     \class ADM_coreVideoEncoderFFmpeg
@@ -52,9 +45,7 @@
                bool             _isMT; // True if multithreaded
                bool             _globalHeader;
                float            timeScaler;
-               vector <ADM_timeMapping>mapper;
-               bool             getRealPtsFromLav(uint64_t val,uint64_t *dts,uint64_t *pts);
-               vector <uint64_t>queueOfDts;
+              
 protected:
     virtual               bool             prolog(void); 
     virtual               bool             preEncode(void); 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoder.cpp	2010-03-11 19:00:10 UTC (rev 5990)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoder.cpp	2010-03-11 19:00:14 UTC (rev 5991)
@@ -17,7 +17,10 @@
  ***************************************************************************/
 #include "ADM_default.h"
 #include "ADM_coreVideoEncoder.h"
-
+extern "C" 
+{
+#include "ADM_lavcodec.h"
+}
 /**
     \fn ADM_coreVideoEncoder
 */                          
@@ -36,4 +39,72 @@
     if(image) delete image;
     image=NULL;
 }
+typedef struct
+{
+    uint64_t mn,mx;
+    int n,d;
+
+}TimeIncrementType;
+
+TimeIncrementType fpsTable[]=
+{
+    {  40000,40000,1 ,25},
+    {  20000,20000,1 ,50},
+    {  33360,33369,1001,30000},
+    {  41700,41710,1001,24000},
+}; 
+
+/**
+    \fn usSecondsToFrac
+    \brief Convert a duration in useconds into Rationnal
+*/
+bool usSecondsToFrac(uint64_t useconds, int *n,int *d)
+{
+    // First search for known value...
+    int nb=sizeof(fpsTable)/sizeof(TimeIncrementType);
+    for(int i=0;i<nb;i++)
+    {
+        TimeIncrementType *t=fpsTable+i;
+        if( useconds>=t->mn && useconds<=t->mx)
+        {
+            *n=t->n;
+            *d=t->d;
+            return true;
+        }
+    }
+    int nn,dd;
+    av_reduce(&nn,&dd, useconds, 1000000, 0xFFF0); // mpeg4 allows a maximum of 1<<16-1 as time base, should be enough for most case
+    ADM_info("%"LLU" us -> %d / %d (old)\n",useconds,nn,dd);
+    *n=nn;
+    *d=dd;
+
+    return true;
+}
+
+/**
+    \fn getRealPtsFromInternal
+    \brief Lookup in the stored value to get the exact pts from the truncated one 
+*/
+bool ADM_coreVideoEncoder::getRealPtsFromInternal(uint64_t val,uint64_t *dts,uint64_t *pts)
+{
+    int n=mapper.size();
+    for(int i=0;i<n;i++)
+    {
+        if(mapper[i].internalTS==val)
+        {
+            *pts=mapper[i].realTS;
+            mapper.erase(mapper.begin()+i);
+            // Now get DTS, it is min (lastDTS+inc, PTS-delay)
+            ADM_assert(queueOfDts.size());
+            *dts=queueOfDts[0];
+            queueOfDts.erase(queueOfDts.begin());
+            return true;
+        }
+    }
+    ADM_warning("Cannot find PTS : %"LLU"\n",val);  
+    for(int i=0;i<n;i++) ADM_warning("%d : %"LLU"\n",i,mapper[i].internalTS);
+    ADM_assert(0);
+    return false;
+
+}
 // EOF
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-03-11 19:00:10 UTC (rev 5990)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-03-11 19:00:14 UTC (rev 5991)
@@ -28,48 +28,8 @@
 #endif
 
 #define LAVS(x) Settings.lavcSettings.x
-typedef struct
-{
-    uint64_t mn,mx;
-    int n,d;
 
-}TimeIncrementType;
-
-TimeIncrementType fpsTable[]=
-{
-    {  40000,40000,1 ,25},
-    {  20000,20000,1 ,50},
-    {  33360,33369,1001,30000},
-    {  41700,41710,1001,24000},
-}; 
-
 /**
-    \fn usSecondsToFrac
-    \brief Convert a duration in useconds into Rationnal
-*/
-bool usSecondsToFrac(uint64_t useconds, int *n,int *d)
-{
-    // First search for known value...
-    int nb=sizeof(fpsTable)/sizeof(TimeIncrementType);
-    for(int i=0;i<nb;i++)
-    {
-        TimeIncrementType *t=fpsTable+i;
-        if( useconds>=t->mn && useconds<=t->mx)
-        {
-            *n=t->n;
-            *d=t->d;
-            return true;
-        }
-    }
-    int nn,dd;
-    av_reduce(&nn,&dd, useconds, 1000000, 0xFFF0); // mpeg4 allows a maximum of 1<<16-1 as time base, should be enough for most case
-    ADM_info("%"LLU" us -> %d / %d (old)\n",useconds,nn,dd);
-    *n=nn;
-    *d=dd;
-
-    return true;
-}
-/**
     \fn ADM_coreVideoEncoderFFmpeg
     \brief Constructor
 
@@ -241,7 +201,7 @@
 
     ADM_timeMapping map; // Store real PTS <->lav value mapping
     map.realTS=p;
-    map.lavTS=_frame.pts;
+    map.internalTS=_frame.pts;
     mapper.push_back(map);
 
     aprintf("Codec> incoming pts=%"LLU"\n",image->Pts);
@@ -373,32 +333,6 @@
   return true;
 }
 /**
-    \fn getRealPtsFromLav
-    \brief Lookup in the stored value to get the exact pts from the truncated one from lav
-*/
-bool ADM_coreVideoEncoderFFmpeg::getRealPtsFromLav(uint64_t val,uint64_t *dts,uint64_t *pts)
-{
-    int n=mapper.size();
-    for(int i=0;i<n;i++)
-    {
-        if(mapper[i].lavTS==val)
-        {
-            *pts=mapper[i].realTS;
-            mapper.erase(mapper.begin()+i);
-            // Now get DTS, it is min (lastDTS+inc, PTS-delay)
-            ADM_assert(queueOfDts.size());
-            *dts=queueOfDts[0];
-            queueOfDts.erase(queueOfDts.begin());
-            return true;
-        }
-    }
-    ADM_warning("Cannot find PTS : %"LLU"\n",val);  
-    for(int i=0;i<n;i++) ADM_warning("%d : %"LLU"\n",i,mapper[i].lavTS);
-    ADM_assert(0);
-    return false;
-
-}
-/**
         \fn postEncode
         \brief update bitstream info from output of lavcodec
 */
@@ -425,7 +359,7 @@
         out->flags=AVI_B_FRAME;
     
     // Update PTS/Dts
-    getRealPtsFromLav(_context->coded_frame->pts,&(out->dts),&(out->pts));
+    getRealPtsFromInternal(_context->coded_frame->pts,&(out->dts),&(out->pts));
     
     
     aprintf("Codec>Out pts=%"LLU" us, out Dts=%"LLU"\n",out->pts,out->dts);    



From mean at mail.berlios.de  Thu Mar 11 20:00:20 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 11 Mar 2010 20:00:20 +0100
Subject: [Avidemux-svn-commit] r5992 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4
Message-ID: <201003111900.o2BJ0K8n021781@sheep.berlios.de>

Author: mean
Date: 2010-03-11 20:00:17 +0100 (Thu, 11 Mar 2010)
New Revision: 5992

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h
Log:
[Xvid4] Simplistic xvid4 encoding plugin

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-11 19:00:14 UTC (rev 5991)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-11 19:00:17 UTC (rev 5992)
@@ -82,6 +82,8 @@
     RD_SQUARE
 };
 
+static uint32_t outFrameStatic=0;
+
 /**
         \fn xvid4Encoder
 */
@@ -91,6 +93,7 @@
     this->globalHeader=globalHeader;
     handle=NULL;
     MMSET(xvid_enc_frame);
+    frameNum=0;
 }
 /**
     \fn query
@@ -179,12 +182,17 @@
     }
    
 
+  plugins[1].func = xvid4Encoder::hook;
+  plugins[1].param = &outFrameNum;
   xvid_enc_create.plugins = plugins;
-  xvid_enc_create.num_plugins = 1;
+  xvid_enc_create.num_plugins = 2;
 
     //Framerate
-    xvid_enc_create.fincr = 1000;
-    xvid_enc_create.fbase = 25000;
+    int n,d;    
+    uint64_t f=source->getInfo()->frameIncrement;
+    usSecondsToFrac(f,&n,&d);
+    xvid_enc_create.fincr = n;
+    xvid_enc_create.fbase = d;
     int xerr = xvid_encore (NULL, XVID_ENC_CREATE, &xvid_enc_create, NULL);
     if (xerr < 0)
     {
@@ -194,6 +202,13 @@
 
     handle = xvid_enc_create.handle;
     image=new ADMImage(getWidth(),getHeight());
+    uint64_t inc=source->getInfo()->frameIncrement;
+    if(inc<30000) // Less than 30 ms , fps > 30 fps it is probably field
+     {
+            inc*=2;
+            ADM_warning("It is probably field encoded, doubling increment\n");
+     }
+    encoderDelay=inc*xvid4Settings.maxBFrame;
     ADM_info("Xvid4, setup ok\n");
     return true;
 }
@@ -219,12 +234,22 @@
 {
     // 1 fetch a frame...
     uint32_t nb;
+    // update
+    
     if(source->getNextFrame(&nb,image)==false)
     {
         ADM_warning("[xvid4] Cannot get next image\n");
         return false;
     }
-    // 2-premable
+    // Store Pts/DTS
+    ADM_timeMapping map; // Store real PTS <->lav value mapping
+    map.realTS=image->Pts+getEncoderDelay();
+ //   printf("Pushing fn=%d Time=%"LLU"\n",frameNum,map.realTS);
+    map.internalTS=frameNum++;
+    mapper.push_back(map);
+    queueOfDts.push_back(image->Pts);
+
+    // 2-preamble
     if(false==preAmble(image))
     {
         ADM_warning("[Xvid4] preAmble failed\n");
@@ -365,9 +390,26 @@
 
     }
   out->len=size;
-  //out->pts=ADM_NO_PTS;
-  //out->dts=ADM_NO_PTS;
+  // update Pts/DTS
+  outFrameNum=outFrameStatic;
+//  printf("Popping fn=%d at %"LLX"\n",(int)outFrameNum,&outFrameNum);
+  getRealPtsFromInternal(outFrameNum,&(out->dts),&(out->pts)); 
   return 1;
 }
+/**
+    \fn hook
+    \brief glue to retrieve frame number and get PTS/DTS later
+*/
+int xvid4Encoder::hook (void *handle, int opt, void *param1, void *param2)
+{
+  xvid_plg_data_t *data = (xvid_plg_data_t *) param1;
+ //printf("plugin called with %u (%"LLX" %"LLX")\n",opt,param1,param2);
+  // printf("Pass %d value %d\n",opt,data->frame_num);
+  if (opt == XVID_PLG_FRAME)
+    {
+     outFrameStatic = data->frame_num;
+    }
+  return 0;
+}
 // EOF
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h	2010-03-11 19:00:14 UTC (rev 5991)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h	2010-03-11 19:00:17 UTC (rev 5992)
@@ -43,6 +43,8 @@
                 xvid_enc_frame_t xvid_enc_frame;
                 xvid_enc_stats_t xvid_enc_stats;
                 xvid_enc_plugin_t plugins[7];
+                uint32_t        frameNum;
+                uint32_t        outFrameNum;
 public:
 
                            xvid4Encoder(ADM_coreVideoFilter *src,bool globalHeader);
@@ -52,6 +54,7 @@
 virtual const  char        *getFourcc(void) {return "DIVX";}
 
 virtual        bool         isDualPass(void) ;
+static         int          hook (void *handle, int opt, void *param1, void *param2);
 
 };
 



From mean at mail.berlios.de  Thu Mar 11 20:00:22 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 11 Mar 2010 20:00:22 +0100
Subject: [Avidemux-svn-commit] r5993 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4
Message-ID: <201003111900.o2BJ0MwC021803@sheep.berlios.de>

Author: mean
Date: 2010-03-11 20:00:21 +0100 (Thu, 11 Mar 2010)
New Revision: 5993

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt
Log:
[xvid4] Cmakelist, cosmetic

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt	2010-03-11 19:00:17 UTC (rev 5992)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/CMakeLists.txt	2010-03-11 19:00:21 UTC (rev 5993)
@@ -9,13 +9,10 @@
 include(admCheckXvid)
 checkXvid()
 IF(USE_XVID)
-INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})
-
-INCLUDE_DIRECTORIES(${XVID_INCLUDE_DIR})
-LINK_DIRECTORIES(${XVID_LIBRARY_DIR})
-ADD_LIBRARY(ADM_ve_xvid4 SHARED ${xvid4_SRCS})
-TARGET_LINK_LIBRARIES(ADM_ve_xvid4 xvidcore )
-
-INIT_VIDEO_ENCODER(ADM_ve_xvid4)
-INSTALL_VIDEO_ENCODER(ADM_ve_xvid4)
+  INCLUDE_DIRECTORIES(${XVID_INCLUDE_DIR})
+  LINK_DIRECTORIES(${XVID_LIBRARY_DIR})
+  ADD_LIBRARY(ADM_ve_xvid4 SHARED ${xvid4_SRCS})
+  TARGET_LINK_LIBRARIES(ADM_ve_xvid4 xvidcore )
+  INIT_VIDEO_ENCODER(ADM_ve_xvid4)
+  INSTALL_VIDEO_ENCODER(ADM_ve_xvid4)
 ENDIF(USE_XVID)



From mean at mail.berlios.de  Sat Mar 13 12:15:18 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Mar 2010 12:15:18 +0100
Subject: [Avidemux-svn-commit] r5994 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4
Message-ID: <201003131115.o2DBFIZH025947@sheep.berlios.de>

Author: mean
Date: 2010-03-13 12:15:17 +0100 (Sat, 13 Mar 2010)
New Revision: 5994

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
Log:
[xvid] better one way, worse another

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-11 19:00:21 UTC (rev 5993)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-13 11:15:17 UTC (rev 5994)
@@ -21,12 +21,13 @@
 #undef ADM_MINIMAL_UI_INTERFACE // we need the full UI
 #include "DIA_factory.h"
 
-#if 1
+#if 0
 #define aprintf(...) {}
 #else
 #define aprintf printf
 #endif
 
+
 #define MMSET(x) memset(&(x),0,sizeof(x))
 
 xvid4_encoder xvid4Settings=
@@ -41,12 +42,12 @@
     },
     
             false, //mpegQuant
-            0, // rdMode
-            0, // MotionEstimation
+            3, // rdMode
+            3, // MotionEstimation
             0, // cqmMode
             0, // arMode
-            0, // MaxBframe
-            0, // MaxKeyInterval
+            2, // MaxBframe
+            200, // MaxKeyInterval
             true // Trellis
     
 };
@@ -187,6 +188,8 @@
   xvid_enc_create.plugins = plugins;
   xvid_enc_create.num_plugins = 2;
 
+  xvid_enc_create.max_bframes = xvid4Settings.maxBFrame;
+  xvid_enc_create.max_key_interval = xvid4Settings.maxKeyFrameInterval;
     //Framerate
     int n,d;    
     uint64_t f=source->getInfo()->frameIncrement;
@@ -235,7 +238,7 @@
     // 1 fetch a frame...
     uint32_t nb;
     // update
-    
+again:    
     if(source->getNextFrame(&nb,image)==false)
     {
         ADM_warning("[xvid4] Cannot get next image\n");
@@ -244,7 +247,7 @@
     // Store Pts/DTS
     ADM_timeMapping map; // Store real PTS <->lav value mapping
     map.realTS=image->Pts+getEncoderDelay();
- //   printf("Pushing fn=%d Time=%"LLU"\n",frameNum,map.realTS);
+    aprintf("Pushing fn=%d Time=%"LLU"\n",frameNum,map.realTS);
     map.internalTS=frameNum++;
     mapper.push_back(map);
     queueOfDts.push_back(image->Pts);
@@ -262,7 +265,11 @@
         ADM_error("[Xvid] Error performing encode %d\n", size);
         return false;
     }
-    
+    if(!size)
+    {
+        ADM_info("Dummy null frame\n");
+        goto again;
+    }
     // 3-encode
     if(false==postAmble(out,size))
     {
@@ -299,8 +306,15 @@
   xvid_enc_frame.length = 0;
   if (xvid4Settings.mpegQuant)
     xvid_enc_frame.vol_flags |= XVID_VOL_MPEGQUANT;
- 
 
+   switch(xvid4Settings.params.mode)
+    {
+      case COMPRESS_SAME:
+      case COMPRESS_CQ:
+            xvid_enc_frame.quant = xvid4Settings.params.qz;
+            break;
+      default:break;
+    }
 #define SVOP(x,y) if(xvid4Settings.x) xvid_enc_frame.vop_flags|=XVID_VOP_##y
 
   xvid_enc_frame.motion = motionMode[xvid4Settings.motionEstimation];
@@ -392,8 +406,11 @@
   out->len=size;
   // update Pts/DTS
   outFrameNum=outFrameStatic;
-//  printf("Popping fn=%d at %"LLX"\n",(int)outFrameNum,&outFrameNum);
-  getRealPtsFromInternal(outFrameNum,&(out->dts),&(out->pts)); 
+  aprintf("Popping fn=%d size=%d flags=0x%x\n",(int)outFrameNum,(int)size,(int)out->flags);
+    getRealPtsFromInternal(outFrameNum,&(out->dts),&(out->pts)); 
+    out->dts=frameNum*source->getInfo()->frameIncrement;
+    out->pts=out->dts+encoderDelay
+;
   return 1;
 }
 /**
@@ -404,9 +421,10 @@
 {
   xvid_plg_data_t *data = (xvid_plg_data_t *) param1;
  //printf("plugin called with %u (%"LLX" %"LLX")\n",opt,param1,param2);
-  // printf("Pass %d value %d\n",opt,data->frame_num);
-  if (opt == XVID_PLG_FRAME)
+  
+  if (opt == 0*XVID_PLG_AFTER+1*XVID_PLG_FRAME)
     {
+     printf("Pass %d value %d\n",opt,data->frame_num);
      outFrameStatic = data->frame_num;
     }
   return 0;



From mean at mail.berlios.de  Sat Mar 13 12:15:19 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Mar 2010 12:15:19 +0100
Subject: [Avidemux-svn-commit] r5995 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4
Message-ID: <201003131115.o2DBFJeO025959@sheep.berlios.de>

Author: mean
Date: 2010-03-13 12:15:19 +0100 (Sat, 13 Mar 2010)
New Revision: 5995

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h
Log:
[Xvid4] Rederive PTS/DTS correctly (hackish)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-13 11:15:17 UTC (rev 5994)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-13 11:15:19 UTC (rev 5995)
@@ -21,7 +21,7 @@
 #undef ADM_MINIMAL_UI_INTERFACE // we need the full UI
 #include "DIA_factory.h"
 
-#if 0
+#if 1
 #define aprintf(...) {}
 #else
 #define aprintf printf
@@ -85,6 +85,7 @@
 
 static uint32_t outFrameStatic=0;
 
+
 /**
         \fn xvid4Encoder
 */
@@ -95,6 +96,8 @@
     handle=NULL;
     MMSET(xvid_enc_frame);
     frameNum=0;
+    backRef=fwdRef=refIndex=0;
+        
 }
 /**
     \fn query
@@ -119,8 +122,8 @@
       printf ("[xvid] Build: %s\n", xvid_gbl_info.build);
 
   printf ("[xvid] SIMD supported: (%x)\n", xvid_gbl_info.cpu_flags);
-#define CPUF(x) if(xvid_gbl_info.cpu_flags  & XVID_CPU_##x) printf("\t\t"#x"\n");
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+#define CPUF(x) if(xvid_gbl_info.cpu_flags  & XVID_CPU_##x) printf("\t\t"#x" ON\n"); else  printf("\t\t"#x" Off\n");
+#if defined( ARCH_X86)  
   CPUF (MMX);
   CPUF (MMXEXT);
   CPUF (SSE);
@@ -139,6 +142,7 @@
   xvid_enc_create_t xvid_enc_create;
   // Here we go...
   MMSET (xvid_enc_create);
+  MMSET(single);
   xvid_enc_create.version = XVID_VERSION;
   xvid_enc_create.width = getWidth();
   xvid_enc_create.height =getHeight();
@@ -160,15 +164,13 @@
       case COMPRESS_SAME:
       case COMPRESS_CQ:
       case COMPRESS_CBR:
-                  MMSET (single);
+                  
                   plugins[0].func = xvid_plugin_single;
                   plugins[0].param = &single;
-
-                  single.version = XVID_VERSION;
                   switch(xvid4Settings.params.mode)
                   {
                     case COMPRESS_CBR:
-                            single.bitrate = xvid4Settings.params.bitrate*1000;
+                            single.bitrate = xvid4Settings.params.bitrate*1000; // b/s
                             break;
                     case COMPRESS_CQ:
                             
@@ -184,7 +186,7 @@
    
 
   plugins[1].func = xvid4Encoder::hook;
-  plugins[1].param = &outFrameNum;
+  plugins[1].param = NULL;
   xvid_enc_create.plugins = plugins;
   xvid_enc_create.num_plugins = 2;
 
@@ -248,6 +250,7 @@
     ADM_timeMapping map; // Store real PTS <->lav value mapping
     map.realTS=image->Pts+getEncoderDelay();
     aprintf("Pushing fn=%d Time=%"LLU"\n",frameNum,map.realTS);
+   
     map.internalTS=frameNum++;
     mapper.push_back(map);
     queueOfDts.push_back(image->Pts);
@@ -360,6 +363,7 @@
   xvid_enc_frame.input.plane[0] = YPLANE(in);
   xvid_enc_frame.input.plane[1] = UPLANE(in);
   xvid_enc_frame.input.plane[2] = VPLANE(in);
+  
 #if 0
   xvid_enc_frame.par_width = _param.par_width;
   xvid_enc_frame.par_height = _param.par_height;
@@ -405,12 +409,26 @@
     }
   out->len=size;
   // update Pts/DTS
-  outFrameNum=outFrameStatic;
-  aprintf("Popping fn=%d size=%d flags=0x%x\n",(int)outFrameNum,(int)size,(int)out->flags);
-    getRealPtsFromInternal(outFrameNum,&(out->dts),&(out->pts)); 
-    out->dts=frameNum*source->getInfo()->frameIncrement;
-    out->pts=out->dts+encoderDelay
-;
+  currentRef=outFrameStatic;
+  uint32_t myFrame;
+  if(out->flags==AVI_B_FRAME)
+    {
+        myFrame=backRef+refIndex;
+        refIndex++;
+    }else
+    {
+        backRef=fwdRef;
+        fwdRef=currentRef;
+        myFrame=fwdRef;
+        refIndex=1;
+    }
+  aprintf("Popping outframe=%d back=%d fwd=0%d index=%d => %d\n",
+                (int)outFrameStatic,
+                (int)backRef,
+                (int)fwdRef,
+                (int)refIndex,
+                (int)myFrame);
+  getRealPtsFromInternal(myFrame,&(out->dts),&(out->pts)); 
   return 1;
 }
 /**
@@ -422,10 +440,9 @@
   xvid_plg_data_t *data = (xvid_plg_data_t *) param1;
  //printf("plugin called with %u (%"LLX" %"LLX")\n",opt,param1,param2);
   
-  if (opt == 0*XVID_PLG_AFTER+1*XVID_PLG_FRAME)
+  if (opt==XVID_PLG_FRAME )//|| opt==XVID_PLG_FRAME)
     {
-     printf("Pass %d value %d\n",opt,data->frame_num);
-     outFrameStatic = data->frame_num;
+        outFrameStatic=data->frame_num;
     }
   return 0;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h	2010-03-13 11:15:17 UTC (rev 5994)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h	2010-03-13 11:15:19 UTC (rev 5995)
@@ -43,8 +43,12 @@
                 xvid_enc_frame_t xvid_enc_frame;
                 xvid_enc_stats_t xvid_enc_stats;
                 xvid_enc_plugin_t plugins[7];
+
                 uint32_t        frameNum;
-                uint32_t        outFrameNum;
+                uint32_t        currentRef;
+                uint32_t        backRef;
+                uint32_t        fwdRef;
+                uint32_t        refIndex;
 public:
 
                            xvid4Encoder(ADM_coreVideoFilter *src,bool globalHeader);



From mean at mail.berlios.de  Sat Mar 13 12:15:21 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Mar 2010 12:15:21 +0100
Subject: [Avidemux-svn-commit] r5996 - in branches/avidemux_2.6_branch_mean:
	avidemux_plugins/ADM_videoEncoder/xvid4 cmake
Message-ID: <201003131115.o2DBFLNY025971@sheep.berlios.de>

Author: mean
Date: 2010-03-13 12:15:21 +0100 (Sat, 13 Mar 2010)
New Revision: 5996

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder_desc.cpp
   branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake
Log:
[xvid] add more options, partially hook them to dialog

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-13 11:15:19 UTC (rev 5995)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-13 11:15:21 UTC (rev 5996)
@@ -40,15 +40,19 @@
     1500,           //uint32_t          avg_bitrate;  /// avg_bitrate is in kb/s!!
     ADM_ENC_CAP_CBR+ADM_ENC_CAP_CQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_2PASS_BR+ADM_ENC_CAP_GLOBAL+ADM_ENC_CAP_SAME
     },
-    
-            false, //mpegQuant
+            XVID_PROFILE_AS_L4, // Profile
             3, // rdMode
             3, // MotionEstimation
             0, // cqmMode
             0, // arMode
             2, // MaxBframe
             200, // MaxKeyInterval
-            true // Trellis
+            
+            99, // nbThreads
+            true, // rdOnBframe
+            true, //bool:hqAcPred
+            true, //bool:optimizeChrome
+            true, // Trellis
     
 };
 
@@ -123,7 +127,7 @@
 
   printf ("[xvid] SIMD supported: (%x)\n", xvid_gbl_info.cpu_flags);
 #define CPUF(x) if(xvid_gbl_info.cpu_flags  & XVID_CPU_##x) printf("\t\t"#x" ON\n"); else  printf("\t\t"#x" Off\n");
-#if defined( ARCH_X86)  
+#if defined( ADM_CPU_X86)  
   CPUF (MMX);
   CPUF (MMXEXT);
   CPUF (SSE);
@@ -146,9 +150,22 @@
   xvid_enc_create.version = XVID_VERSION;
   xvid_enc_create.width = getWidth();
   xvid_enc_create.height =getHeight();
-  
-  single.version = XVID_VERSION;
+  xvid_enc_create.profile=xvid4Settings.profile;
 
+  int thread;
+    switch(xvid4Settings.nbThreads)
+    {
+        default:
+        case 0:case 1: thread=1;break;
+        case 3: case 4:
+        case 2: thread=xvid4Settings.nbThreads;break;
+        
+        case 99: thread=ADM_cpu_num_processors();break;
+    }
+    ADM_info("[Xvid] Using %d threads\n",(int)thread);
+    xvid_enc_create.num_threads=thread;
+    single.version = XVID_VERSION;
+
     switch(xvid4Settings.params.mode)
     {
       case COMPRESS_2PASS:
@@ -184,7 +201,7 @@
             return false;
     }
    
-
+  
   plugins[1].func = xvid4Encoder::hook;
   plugins[1].param = NULL;
   xvid_enc_create.plugins = plugins;
@@ -307,7 +324,7 @@
   /* Bind output buffer */
 
   xvid_enc_frame.length = 0;
-  if (xvid4Settings.mpegQuant)
+  if (xvid4Settings.cqmMode==1)
     xvid_enc_frame.vol_flags |= XVID_VOL_MPEGQUANT;
 
    switch(xvid4Settings.params.mode)
@@ -325,9 +342,9 @@
   xvid_enc_frame.vop_flags |= XVID_VOP_HALFPEL;
   
   SVOP (trellis, TRELLISQUANT);
- // SVOP (hqac, HQACPRED);
- // SVOP (bvhq, RD_BVOP);
-//  SVOP (chroma_opt, CHROMAOPT);
+  SVOP (hqAcPred, HQACPRED);
+  SVOP (rdOnBFrame, RD_BVOP);
+  SVOP (optimizeChrome, CHROMAOPT);
   
   // ME 
   //if (_param.chroma_me)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp	2010-03-13 11:15:19 UTC (rev 5995)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp	2010-03-13 11:15:21 UTC (rev 5996)
@@ -42,7 +42,8 @@
 
 diaMenuEntry qzE[]={
   {0,QT_TR_NOOP("H.263")},
-  {1,QT_TR_NOOP("MPEG")}
+  {1,QT_TR_NOOP("MPEG")},
+  {2,QT_TR_NOOP("Custom")}
 };       
 /*
 diaMenuEntry rdE[]={
@@ -82,9 +83,9 @@
 */
          
          diaElemUInteger  max_b_frames(PX(maxBFrame),QT_TR_NOOP("_Number of B frames:"),0,32);
-/*
-         diaElemMenu     qzM(PX(mpeg_quant),QT_TR_NOOP("_Quantization type:"),2,qzE);
-         
+
+         diaElemMenu     qzM(PX(cqmMode),QT_TR_NOOP("_Quantization type:"),2,qzE);
+/*         
          diaElemMenu     rdM(PX(mb_eval),QT_TR_NOOP("_Macroblock decision:"),3,rdE);
          
          diaElemUInteger filetol(PX(vratetol),QT_TR_NOOP("_Filesize tolerance (kb):"),0,100000);
@@ -106,6 +107,7 @@
         frameMe.swallow(&max_b_frames);
         frameMe.swallow(&GopSize);
         frameMe.swallow(&bitrate);
+        frameMe.swallow(&qzM);
         
         diaElem *diaME[]={&frameMe};
         diaElemTabs tabME(QT_TR_NOOP("Motion Estimation"),1,diaME);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.conf	2010-03-13 11:15:19 UTC (rev 5995)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.conf	2010-03-13 11:15:21 UTC (rev 5996)
@@ -1,8 +1,13 @@
 video_encode:params
+uint32_t:profile
 uint32_t:rdMode
 uint32_t:motionEstimation
 uint32_t:cqmMode
 uint32_t:arMode
 uint32_t:maxBFrame
 uint32_t:maxKeyFrameInterval
+uint32_t:nbThreads
+bool:rdOnBFrame
+bool:hqAcPred
+bool:optimizeChrome
 bool:trellis

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h	2010-03-13 11:15:19 UTC (rev 5995)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder.h	2010-03-13 11:15:21 UTC (rev 5996)
@@ -3,13 +3,17 @@
 #define ADM_xvid4_encoder_CONF_H
 typedef struct {
    COMPRES_PARAMS params;
-   bool     mpegQuant;
+   uint32_t profile;
    uint32_t rdMode;
    uint32_t motionEstimation;
    uint32_t cqmMode;
    uint32_t arMode;
    uint32_t maxBFrame;
    uint32_t maxKeyFrameInterval;
+   uint32_t nbThreads;
+   bool rdOnBFrame;
+   bool hqAcPred;
+   bool optimizeChrome;
    bool trellis;
 }xvid4_encoder;
 #endif //xvid4_encoder

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder_desc.cpp	2010-03-13 11:15:19 UTC (rev 5995)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4_encoder_desc.cpp	2010-03-13 11:15:21 UTC (rev 5996)
@@ -1,12 +1,17 @@
 // Automatically generated, do not edit!
 const ADM_paramList xvid4_encoder_param[]={
  {"params",offsetof( xvid4_encoder,params),"COMPRES_PARAMS",ADM_param_video_encode},
+ {"profile",offsetof( xvid4_encoder,profile),"uint32_t",ADM_param_uint32_t},
  {"rdMode",offsetof( xvid4_encoder,rdMode),"uint32_t",ADM_param_uint32_t},
  {"motionEstimation",offsetof( xvid4_encoder,motionEstimation),"uint32_t",ADM_param_uint32_t},
  {"cqmMode",offsetof( xvid4_encoder,cqmMode),"uint32_t",ADM_param_uint32_t},
  {"arMode",offsetof( xvid4_encoder,arMode),"uint32_t",ADM_param_uint32_t},
  {"maxBFrame",offsetof( xvid4_encoder,maxBFrame),"uint32_t",ADM_param_uint32_t},
  {"maxKeyFrameInterval",offsetof( xvid4_encoder,maxKeyFrameInterval),"uint32_t",ADM_param_uint32_t},
+ {"nbThreads",offsetof( xvid4_encoder,nbThreads),"uint32_t",ADM_param_uint32_t},
+ {"rdOnBFrame",offsetof( xvid4_encoder,rdOnBFrame),"bool",ADM_param_bool},
+ {"hqAcPred",offsetof( xvid4_encoder,hqAcPred),"bool",ADM_param_bool},
+ {"optimizeChrome",offsetof( xvid4_encoder,optimizeChrome),"bool",ADM_param_bool},
  {"trellis",offsetof( xvid4_encoder,trellis),"bool",ADM_param_bool},
 {NULL,0,NULL}
 };

Modified: branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake	2010-03-13 11:15:19 UTC (rev 5995)
+++ branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake	2010-03-13 11:15:21 UTC (rev 5996)
@@ -10,6 +10,8 @@
                         SET(USE_XVID 1)
 		ELSE (XVID)
 			MESSAGE("${MSG_DISABLE_OPTION}")
+                        SET(XVID_INCLUDE_DIR "")
+                        SET(XVID_LIBRARY_DIR "")
 		ENDIF (XVID)
 		MESSAGE("")
 ENDMACRO(checkXvid)



From mean at mail.berlios.de  Sat Mar 13 12:21:17 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Mar 2010 12:21:17 +0100
Subject: [Avidemux-svn-commit] r5997 -
	branches/avidemux_2.6_branch_mean/cmake
Message-ID: <201003131121.o2DBLH7A026330@sheep.berlios.de>

Author: mean
Date: 2010-03-13 12:21:17 +0100 (Sat, 13 Mar 2010)
New Revision: 5997

Modified:
   branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake
Log:
[xvid] Change cmake check for xvid

Modified: branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake	2010-03-13 11:15:21 UTC (rev 5996)
+++ branches/avidemux_2.6_branch_mean/cmake/admCheckXvid.cmake	2010-03-13 11:21:17 UTC (rev 5997)
@@ -7,11 +7,11 @@
 		IF (XVID)
 			FIND_HEADER_AND_LIB(XVID xvid.h xvidcore xvid_plugin_single)
 			PRINT_LIBRARY_INFO("Xvid" XVID_FOUND "${XVID_INCLUDE_DIR}" "${XVID_LIBRARY_DIR}")
-                        SET(USE_XVID 1)
+                        IF(XVID_FOUND)
+                                SET(USE_XVID 1)
+                        ENDIF(XVID_FOUND)
 		ELSE (XVID)
 			MESSAGE("${MSG_DISABLE_OPTION}")
-                        SET(XVID_INCLUDE_DIR "")
-                        SET(XVID_LIBRARY_DIR "")
 		ENDIF (XVID)
 		MESSAGE("")
 ENDMACRO(checkXvid)



From mean at mail.berlios.de  Sun Mar 14 12:03:08 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 14 Mar 2010 12:03:08 +0100
Subject: [Avidemux-svn-commit] r5998 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4
Message-ID: <201003141103.o2EB38m3025706@sheep.berlios.de>

Author: mean
Date: 2010-03-14 12:03:08 +0100 (Sun, 14 Mar 2010)
New Revision: 5998

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp
Log:
[xvid] More UI

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-13 11:21:17 UTC (rev 5997)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-14 11:03:08 UTC (rev 5998)
@@ -345,7 +345,8 @@
   SVOP (hqAcPred, HQACPRED);
   SVOP (rdOnBFrame, RD_BVOP);
   SVOP (optimizeChrome, CHROMAOPT);
-  
+  if(xvid4Settings.rdMode!=0)
+    xvid_enc_frame.vop_flags|=XVID_VOP_MODEDECISION_RD;
   // ME 
   //if (_param.chroma_me)
   //  {

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp	2010-03-13 11:21:17 UTC (rev 5997)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/xvid4Dialog.cpp	2010-03-14 11:03:08 UTC (rev 5998)
@@ -44,50 +44,56 @@
   {0,QT_TR_NOOP("H.263")},
   {1,QT_TR_NOOP("MPEG")},
   {2,QT_TR_NOOP("Custom")}
-};       
-/*
+};      
+diaMenuEntry profileE[]={
+{ XVID_PROFILE_S_L0  ,"Simple Level0"},
+{ XVID_PROFILE_S_L1  ,"Simple Level1"},
+{ XVID_PROFILE_S_L2  ,"Simple Level2"},
+{ XVID_PROFILE_S_L3  ,"Simple Level3"},
+{ XVID_PROFILE_AS_L0 ,"Adv. Simple Level0"},
+{ XVID_PROFILE_AS_L1 ,"Adv. Simple Level1"},
+{ XVID_PROFILE_AS_L2 ,"Adv. Simple Level2"},
+{ XVID_PROFILE_AS_L3 ,"Adv. Simple Level3"},
+{ XVID_PROFILE_AS_L4 ,"Adv. Simple Level4"},
+}; 
+
 diaMenuEntry rdE[]={
-  {0,QT_TR_NOOP("MB comparison")},
-  {1,QT_TR_NOOP("Fewest bits (vhq)")},
-  {2,QT_TR_NOOP("Rate distortion")}
-};     
+  {0,QT_TR_NOOP("None")},
+  {1,QT_TR_NOOP("DCT")},
+  {2,QT_TR_NOOP("Qpel16")},
+  {3,QT_TR_NOOP("Qpel8")},
+  {4,QT_TR_NOOP("Square")}
+};    
+
 diaMenuEntry threads[]={
-  {0,QT_TR_NOOP("One thread")},
+  {1,QT_TR_NOOP("One thread")},
   {2,QT_TR_NOOP("Two threads)")},
   {3,QT_TR_NOOP("Three threads")},
   {99,QT_TR_NOOP("Auto (#cpu)")}
 };     
 
 
-        FFcodecSettings *conf=&Mp4Settings;
-
-uint32_t me=(uint32_t)conf->lavcSettings.me_method;  
-*/
 #define PX(x) &(xvid4Settings.x)
 
          diaElemBitrate   bitrate(&(xvid4Settings.params),NULL);
          diaElemMenu      meM(PX(motionEstimation),QT_TR_NOOP("MotionEstimation"),4,meE);
+
+         diaElemMenu      threadM(PX(nbThreads),QT_TR_NOOP("Threading"),4,threads);
 /*
-         diaElemMenu      threadM(PX(MultiThreaded),QT_TR_NOOP("Threading"),4,threads);
          diaElemUInteger  qminM(PX(qmin),QT_TR_NOOP("Mi_n. quantizer:"),1,31);
          diaElemUInteger  qmaxM(PX(qmax),QT_TR_NOOP("Ma_x. quantizer:"),1,31);
          diaElemUInteger  qdiffM(PX(max_qdiff),QT_TR_NOOP("Max. quantizer _difference:"),1,31);
-         
-         diaElemToggle    fourMv(PX(_4MV),QT_TR_NOOP("4_MV"));
 */
          uint32_t trelBol=*PX(trellis);
-         diaElemToggle    trellis(&trelBol,QT_TR_NOOP("_Trellis quantization"));
-/*         
-         diaElemToggle    qpel(PX(_QPEL),QT_TR_NOOP("_Quarter pixel"));
-         diaElemToggle    gmc(PX(_GMC),QT_TR_NOOP("_GMC"));
-*/
-         
+         diaElemToggle    trellis(&trelBol,QT_TR_NOOP("_Trellis quantization"));         
          diaElemUInteger  max_b_frames(PX(maxBFrame),QT_TR_NOOP("_Number of B frames:"),0,32);
 
          diaElemMenu     qzM(PX(cqmMode),QT_TR_NOOP("_Quantization type:"),2,qzE);
-/*         
-         diaElemMenu     rdM(PX(mb_eval),QT_TR_NOOP("_Macroblock decision:"),3,rdE);
          
+         diaElemMenu     rdM(PX(rdMode),QT_TR_NOOP("_Macroblock decision:"),5,rdE);
+
+         diaElemMenu     profileM(PX(profile),QT_TR_NOOP("Profile:"),9,profileE);
+         /*
          diaElemUInteger filetol(PX(vratetol),QT_TR_NOOP("_Filesize tolerance (kb):"),0,100000);
          
          diaElemFloat    qzComp(PX(qcompress),QT_TR_NOOP("_Quantizer compression:"),0,1);
@@ -95,34 +101,31 @@
          */
         diaElemUInteger GopSize(PX(maxKeyFrameInterval),QT_TR_NOOP("_Gop Size:"),1,500); 
           /* First Tab : encoding mode */
-        diaElem *diamode[]={&bitrate,&meM,&trellis,&max_b_frames,&GopSize};
-        diaElemTabs tabMode(QT_TR_NOOP("User Interface"),5,diamode);
-        
-        /* 2nd Tab : ME */
+       
         diaElemFrame frameMe(QT_TR_NOOP("Advanced Simple Profile"));
-        
-        
-        frameMe.swallow(&meM);
-        frameMe.swallow(&trellis);
+        frameMe.swallow(&profileM);
         frameMe.swallow(&max_b_frames);
         frameMe.swallow(&GopSize);
         frameMe.swallow(&bitrate);
-        frameMe.swallow(&qzM);
+       
         
         diaElem *diaME[]={&frameMe};
         diaElemTabs tabME(QT_TR_NOOP("Motion Estimation"),1,diaME);
-        /* 3nd Tab : Qz */
-       #if 0 
-         diaElem *diaQze[]={&qzM,&rdM,&qminM,&qmaxM,&qdiffM,&trellis};
-        diaElemTabs tabQz(QT_TR_NOOP("Quantization"),6,diaQze);
+
+        /* 2nd Tab : Qz */
+       
+         diaElem *diaQze[]={&qzM,&rdM,&meM,&trellis};
+        diaElemTabs tabQz(QT_TR_NOOP("Quantization"),4,diaQze);
         
-        /* 4th Tab : RControl */
-        
+        /* 3th Tab : thread */
+         diaElem *diaThread[]={&threadM};
+         diaElemTabs tabThread(QT_TR_NOOP("Threads"),1,diaThread);
+        #if 0
          diaElem *diaRC[]={&filetol,&qzComp,&qzBlur};
         diaElemTabs tabRC(QT_TR_NOOP("Rate Control"),3,diaRC);
         #endif
-         diaElemTabs *tabs[]={&tabME};
-        if( diaFactoryRunTabs(QT_TR_NOOP("libavcodec MPEG-4 configuration"),1,tabs))
+         diaElemTabs *tabs[]={&tabME,&tabQz,&tabThread};
+        if( diaFactoryRunTabs(QT_TR_NOOP("Xvid4 MPEG-4 ASP configuration"),3,tabs))
         {
             *PX(trellis)= trelBol;
             return true;



From mean at mail.berlios.de  Mon Mar 15 19:30:12 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 15 Mar 2010 19:30:12 +0100
Subject: [Avidemux-svn-commit] r5999 - in
	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_audio
	plugins/ADM_audioDecoders/ADM_ad_ac3
Message-ID: <201003151830.o2FIUCas005554@sheep.berlios.de>

Author: mean
Date: 2010-03-15 19:30:11 +0100 (Mon, 15 Mar 2010)
New Revision: 5999

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_a52info.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp
Log:
[Ac3] Handle dual channel audio, fixes #84

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_a52info.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_a52info.cpp	2010-03-14 11:03:08 UTC (rev 5998)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_a52info.cpp	2010-03-15 18:30:11 UTC (rev 5999)
@@ -123,6 +123,7 @@
 		*fq=(uint32_t)ifq;
 		*br=(uint32_t)ibr>>3;
 		switch (flags & A52_CHANNEL_MASK) {
+                        case A52_CHANNEL:
 			case A52_MONO:
 				*chan = 1;
 			break;

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp	2010-03-14 11:03:08 UTC (rev 5998)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp	2010-03-15 18:30:11 UTC (rev 5999)
@@ -136,6 +136,7 @@
 			*(p_ch_type++) = CHTYP_LFE;
 		}
 		switch (flags & A52_CHANNEL_MASK) {
+			case A52_CHANNEL:
 			case A52_MONO:
 				*(p_ch_type++) = CHTYP_MONO;
 			break;



From mean at mail.berlios.de  Mon Mar 15 19:52:33 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 15 Mar 2010 19:52:33 +0100
Subject: [Avidemux-svn-commit] r6000 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src
Message-ID: <201003151852.o2FIqXHE009933@sheep.berlios.de>

Author: mean
Date: 2010-03-15 19:52:32 +0100 (Mon, 15 Mar 2010)
New Revision: 6000

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
Log:
[dia_encoding] average fps & eta overtime

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-15 18:30:11 UTC (rev 5999)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-15 18:52:32 UTC (rev 6000)
@@ -95,10 +95,12 @@
                 uint64_t deltaDts=_currentDts-_lastDts;
                 if(deltaFrame)
                 {
+                    float thisAverage;
                     //printf("**********************************DFrame=%d, DTime=%d\n",(int)deltaFrame,(int)deltaTime);
-                    _fps_average=((float)deltaFrame);
-                    _fps_average/=deltaTime;
-                    _fps_average*=1000;
+                    thisAverage=((float)deltaFrame);
+                    thisAverage/=deltaTime;
+                    thisAverage*=1000;
+                    _fps_average=_fps_average*0.5+0.5*thisAverage;
                     //printf("************** Fps:%d\n",(int)_fps_average);
                     setFps(_fps_average);
                     float percent=(float)_currentDts/(float)_totalDurationUs;
@@ -119,7 +121,8 @@
                     if(dtsPerSec>0.01)
                     {
                         leftDts=leftDts/dtsPerSec;
-                        
+                        _remainingTimeUs=(_remainingTimeUs/2)+(leftDts/2);
+                        leftDts=_remainingTimeUs;
                         leftDts/=1000.; // us -> ms
                         //printf("***************%u s left\n",(int)(leftDts/1000));
                         setRemainingTimeMS((uint32_t)leftDts);



From mean at mail.berlios.de  Mon Mar 15 19:52:35 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 15 Mar 2010 19:52:35 +0100
Subject: [Avidemux-svn-commit] r6001 - in branches/avidemux_2.6_branch_mean:
	avidemux/qt4/ADM_userInterfaces/ADM_dialog
	avidemux_core/ADM_coreUI/include avidemux_core/ADM_coreUI/src
Message-ID: <201003151852.o2FIqZCF009962@sheep.berlios.de>

Author: mean
Date: 2010-03-15 19:52:35 +0100 (Mon, 15 Mar 2010)
New Revision: 6001

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
Log:
[ui/encoding] update average bitrate

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2010-03-15 18:52:32 UTC (rev 6000)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2010-03-15 18:52:35 UTC (rev 6001)
@@ -291,8 +291,30 @@
           strcpy(string,ADM_us2plain(mb));
           WRITE(labelElapsed);
 }
+/**
+    \fn setAverageQz(int size)
+    \brief display average quantizer used
+*/
 
+void DIA_encodingQt4::setAverageQz(uint32_t nb)
+{
+          ADM_assert(window);
+          snprintf(string,79,"%"LU,nb);
+          WRITE(labelQz);
+}
 /**
+    \fn setAverageBitrateKbits(int size)
+    \brief display average bitrate in kb/s
+*/
+
+void DIA_encodingQt4::setAverageBitrateKbits(uint32_t kb)
+{
+          ADM_assert(window);
+          snprintf(string,79,"%"LU" kbits/s",kb);
+          WRITE(labelVidBitrate);
+}
+
+/**
     \fn setRemainingTimeMS
     \brief display remaining time (ETA)
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h	2010-03-15 18:52:32 UTC (rev 6000)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.h	2010-03-15 18:52:35 UTC (rev 6001)
@@ -56,6 +56,8 @@
     void setFrameCount(uint32_t nb);
     void setElapsedTimeMs(uint32_t nb);
     void setRemainingTimeMS(uint32_t nb);
+    void setAverageQz(uint32_t nb);
+    void setAverageBitrateKbits(uint32_t kb);
 
 public:    
     void *WINDOW;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h	2010-03-15 18:52:32 UTC (rev 6000)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_encoding.h	2010-03-15 18:52:35 UTC (rev 6001)
@@ -21,6 +21,13 @@
     \class DIA_encodingBase
     \brief Base class for encoding dialog
 */
+#define ADM_ENCODING_SAMPLE 32 // must be a power of 2
+typedef struct
+{
+    uint64_t sampleTime;
+    uint64_t size;
+    uint32_t qz;
+}encodingSample;
 
 class DIA_encodingBase
 {
@@ -41,6 +48,8 @@
                 uint64_t  _audioSize;
                 uint64_t  _videoSize;
                 uint32_t  _originalPriority;
+                encodingSample samples[ADM_ENCODING_SAMPLE];
+                uint32_t  sampleIndex;
         
 public:
                              DIA_encodingBase( uint64_t duration );
@@ -55,6 +64,8 @@
                 virtual void setFrameCount(uint32_t nb)=0;
                 virtual void setElapsedTimeMs(uint32_t nb)=0;
                 virtual void setRemainingTimeMS(uint32_t nb)=0;
+                virtual void setAverageQz(uint32_t nb)=0;
+                virtual void setAverageBitrateKbits(uint32_t kb)=0;
             
 
 public:

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-15 18:52:32 UTC (rev 6000)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-15 18:52:35 UTC (rev 6001)
@@ -21,6 +21,8 @@
 #define  ETA_SAMPLE_PERIOD 60000 //Use last n millis to calculate ETA
 #define  GUI_UPDATE_RATE 1000    // Ms
 extern void UI_purge(void);
+
+#define aprintf(...) {}
 /**
     \fn DIA_encodingBase
 */
@@ -60,6 +62,8 @@
         _lastClock=0;
         _fps_average=0;
         _remainingTimeUs=0;
+        sampleIndex=0;
+        memset(samples,0,sizeof(samples));
         clock.reset();
         UI_purge();
 }
@@ -72,6 +76,11 @@
           _videoSize+=size;
           _currentFrameCount++;
           _currentDts=timeUs;
+          encodingSample *cur=samples+(sampleIndex%ADM_ENCODING_SAMPLE);
+          cur->qz=quant;
+          cur->sampleTime=timeUs;
+          cur->size=_videoSize;
+          sampleIndex++;
 }
 /**
     \fn pushAudioFrame
@@ -93,6 +102,34 @@
                 uint32_t deltaTime=time-_lastClock;
                 uint32_t deltaFrame=_currentFrameCount-_lastFrameCount;
                 uint64_t deltaDts=_currentDts-_lastDts;
+                if(sampleIndex>ADM_ENCODING_SAMPLE)
+                {
+                    uint32_t qSum=0;
+                    for(int i=0;i<ADM_ENCODING_SAMPLE;i++)
+                            qSum+=samples[i].qz;
+                    qSum/=ADM_ENCODING_SAMPLE;
+                    aprintf("Q:%d\n",qSum);
+                    setAverageQz(qSum);
+                }
+
+                if(sampleIndex>ADM_ENCODING_SAMPLE)
+                {
+                    int start=sampleIndex%ADM_ENCODING_SAMPLE;
+                    int end=(sampleIndex+ADM_ENCODING_SAMPLE-1)%ADM_ENCODING_SAMPLE;
+                    uint64_t deltaTime=samples[end].sampleTime-samples[start].sampleTime;
+                    uint64_t deltaSize=samples[end].size-samples[start].size;
+                    printf("dTime:%d dSize:%d\n",deltaTime,deltaSize);
+                    if(deltaTime>1000)
+                    {
+                        float delta;
+                        delta=deltaSize;
+                        delta/=deltaTime;
+                        delta*=8; // byte -> bit
+                        delta*=1000; // b/us -> kb/s
+                        aprintf("br:%d\n",(int)delta);
+                        setAverageBitrateKbits((uint32_t)delta);
+                    }
+                }
                 if(deltaFrame)
                 {
                     float thisAverage;
@@ -135,8 +172,9 @@
                 _lastFrameCount=_currentFrameCount;
                 _lastDts=_currentDts;
                 _lastClock=time;
-                UI_purge();
+           
           }
+          UI_purge();
 }
 //EOF
 



From mean at mail.berlios.de  Mon Mar 15 19:52:37 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 15 Mar 2010 19:52:37 +0100
Subject: [Avidemux-svn-commit] r6002 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4
Message-ID: <201003151852.o2FIqbst009987@sheep.berlios.de>

Author: mean
Date: 2010-03-15 19:52:36 +0100 (Mon, 15 Mar 2010)
New Revision: 6002

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h
Log:
[xvid4] update out quantizer

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-15 18:52:35 UTC (rev 6001)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-15 18:52:36 UTC (rev 6002)
@@ -188,6 +188,12 @@
                   {
                     case COMPRESS_CBR:
                             single.bitrate = xvid4Settings.params.bitrate*1000; // b/s
+                            ADM_info("[xvid4] Bitrate = %d kb/s\n",int(single.bitrate /1000));
+/*
+                            single. reaction_delay_factor; 
+                            single. averaging_period;      
+                            single. buffer;                
+*/
                             break;
                     case COMPRESS_CQ:
                             
@@ -209,6 +215,13 @@
 
   xvid_enc_create.max_bframes = xvid4Settings.maxBFrame;
   xvid_enc_create.max_key_interval = xvid4Settings.maxKeyFrameInterval;
+    // dummy
+    for(int i=0;i<3;i++)
+    {
+        xvid_enc_create.min_quant[i]=2;
+        xvid_enc_create.max_quant[i]=31;
+    }
+    
     //Framerate
     int n,d;    
     uint64_t f=source->getInfo()->frameIncrement;
@@ -291,7 +304,7 @@
         goto again;
     }
     // 3-encode
-    if(false==postAmble(out,size))
+    if(false==postAmble(out,&xvid_enc_stats,size))
     {
         ADM_warning("[Xvid4] postAmble failed\n");
         return false;     
@@ -413,7 +426,7 @@
     \fn postAmble
     \brief update after a frame has been succesfully encoded
 */
-bool xvid4Encoder::postAmble (ADMBitstream * out,int size)
+bool xvid4Encoder::postAmble (ADMBitstream * out,xvid_enc_stats_t *stat,int size)
 {
   out->flags = 0;
   if (xvid_enc_frame.out_flags & XVID_KEYFRAME)
@@ -440,6 +453,8 @@
         myFrame=fwdRef;
         refIndex=1;
     }
+  out->out_quantizer=stat->quant;
+  aprintf("XvidQ:%d\n",(int)out->out_quantizer);
   aprintf("Popping outframe=%d back=%d fwd=0%d index=%d => %d\n",
                 (int)outFrameStatic,
                 (int)backRef,
@@ -457,7 +472,7 @@
 {
   xvid_plg_data_t *data = (xvid_plg_data_t *) param1;
  //printf("plugin called with %u (%"LLX" %"LLX")\n",opt,param1,param2);
-  
+ 
   if (opt==XVID_PLG_FRAME )//|| opt==XVID_PLG_FRAME)
     {
         outFrameStatic=data->frame_num;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h	2010-03-15 18:52:35 UTC (rev 6001)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.h	2010-03-15 18:52:36 UTC (rev 6002)
@@ -34,7 +34,7 @@
                int             plane;
                bool            globalHeader;
                bool            preAmble (ADMImage * in);
-               bool            postAmble (ADMBitstream * out,int size);
+               bool            postAmble (ADMBitstream * out,xvid_enc_stats_t *stat,int size);
                bool            query(void);
 
                 xvid_plugin_single_t single;



From mean at mail.berlios.de  Mon Mar 15 19:52:39 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 15 Mar 2010 19:52:39 +0100
Subject: [Avidemux-svn-commit] r6003 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreAudioParser/src
	avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3
Message-ID: <201003151852.o2FIqdWd010011@sheep.berlios.de>

Author: mean
Date: 2010-03-15 19:52:38 +0100 (Mon, 15 Mar 2010)
New Revision: 6003

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_a52info.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp
Log:
[AC3] Fix dual audio ac3 , ref #84

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_a52info.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_a52info.cpp	2010-03-15 18:52:36 UTC (rev 6002)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_a52info.cpp	2010-03-15 18:52:38 UTC (rev 6003)
@@ -123,6 +123,7 @@
 		*fq=(uint32_t)ifq;
 		*br=(uint32_t)ibr>>3;
 		switch (flags & A52_CHANNEL_MASK) {
+            case A52_CHANNEL:
 			case A52_MONO:
 				*chan = 1;
 			break;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp	2010-03-15 18:52:36 UTC (rev 6002)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp	2010-03-15 18:52:38 UTC (rev 6003)
@@ -140,6 +140,7 @@
 			*(p_ch_type++) = ADM_CH_LFE;
 		}
 		switch (flags & A52_CHANNEL_MASK) {
+            case A52_CHANNEL:
 			case A52_MONO:
 				*(p_ch_type++) = ADM_CH_MONO;
 			break;
@@ -170,6 +171,7 @@
 				*(p_ch_type++) = ADM_CH_REAR_LEFT;
 				*(p_ch_type++) = ADM_CH_REAR_RIGHT;
 			break;
+            
 			case A52_3F2R:
 				*(p_ch_type++) = ADM_CH_FRONT_LEFT;
 				*(p_ch_type++) = ADM_CH_FRONT_CENTER;



From mean at mail.berlios.de  Mon Mar 15 19:52:41 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 15 Mar 2010 19:52:41 +0100
Subject: [Avidemux-svn-commit] r6004 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src
Message-ID: <201003151852.o2FIqfDC010033@sheep.berlios.de>

Author: mean
Date: 2010-03-15 19:52:40 +0100 (Mon, 15 Mar 2010)
New Revision: 6004

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
Log:
[ui/encoding] Silence ui

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-15 18:52:38 UTC (rev 6003)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2010-03-15 18:52:40 UTC (rev 6004)
@@ -118,7 +118,7 @@
                     int end=(sampleIndex+ADM_ENCODING_SAMPLE-1)%ADM_ENCODING_SAMPLE;
                     uint64_t deltaTime=samples[end].sampleTime-samples[start].sampleTime;
                     uint64_t deltaSize=samples[end].size-samples[start].size;
-                    printf("dTime:%d dSize:%d\n",deltaTime,deltaSize);
+                    aprintf("dTime:%d dSize:%d\n",deltaTime,deltaSize);
                     if(deltaTime>1000)
                     {
                         float delta;



From mean at mail.berlios.de  Mon Mar 15 19:52:42 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 15 Mar 2010 19:52:42 +0100
Subject: [Avidemux-svn-commit] r6005 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4
Message-ID: <201003151852.o2FIqgo0010066@sheep.berlios.de>

Author: mean
Date: 2010-03-15 19:52:42 +0100 (Mon, 15 Mar 2010)
New Revision: 6005

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
Log:
[xvid] Set sane default for bquant_ratio / bquant_offset, turn glosed gop on

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-15 18:52:40 UTC (rev 6004)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/xvid4/ADM_xvid4.cpp	2010-03-15 18:52:42 UTC (rev 6005)
@@ -151,6 +151,10 @@
   xvid_enc_create.width = getWidth();
   xvid_enc_create.height =getHeight();
   xvid_enc_create.profile=xvid4Settings.profile;
+ // Some sane defaults...
+  xvid_enc_create.bquant_ratio = 150;
+  xvid_enc_create.bquant_offset = 100;
+  xvid_enc_create.global |= XVID_GLOBAL_CLOSED_GOP ;
 
   int thread;
     switch(xvid4Settings.nbThreads)
@@ -455,13 +459,19 @@
     }
   out->out_quantizer=stat->quant;
   aprintf("XvidQ:%d\n",(int)out->out_quantizer);
-  aprintf("Popping outframe=%d back=%d fwd=0%d index=%d => %d\n",
+  aprintf("Popping flags=%x fnum=%d back=%d fwd=0%d index=%d => %d\n",
+                (int)out->flags,
                 (int)outFrameStatic,
                 (int)backRef,
                 (int)fwdRef,
                 (int)refIndex,
                 (int)myFrame);
+#if 1
   getRealPtsFromInternal(myFrame,&(out->dts),&(out->pts)); 
+#else
+    out->dts=frameNum*source->getInfo()->frameIncrement;
+    out->pts=out->dts+encoderDelay;
+#endif
   return 1;
 }
 /**



From mean at mail.berlios.de  Thu Mar 18 07:49:41 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 18 Mar 2010 07:49:41 +0100
Subject: [Avidemux-svn-commit] r6006 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_muxerGate/include
	avidemux/common/ADM_muxerGate/src
	avidemux_core/ADM_coreMuxer/include avidemux_core/ADM_coreMuxer/src
Message-ID: <201003180649.o2I6nf0b025311@sheep.berlios.de>

Author: mean
Date: 2010-03-18 07:49:39 +0100 (Thu, 18 Mar 2010)
New Revision: 6006

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoProcess.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerInternal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
Log:
[Muxer/VStream] Change api to be symetric with the demuxer one

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h	2010-03-15 18:52:42 UTC (rev 6005)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h	2010-03-18 06:49:39 UTC (rev 6006)
@@ -23,8 +23,7 @@
              ADM_videoStreamCopy(uint64_t startTime,uint64_t endTime);
     virtual ~ADM_videoStreamCopy();
 
-virtual     bool     getPacket(uint32_t *len, uint8_t *data, uint32_t maxLen,uint64_t *pts,uint64_t *dts,
-                                    uint32_t *flags);
+virtual     bool     getPacket(ADMBitstream *out);
 virtual     bool     getExtraData(uint32_t *extraLen, uint8_t **extraData) ;
 virtual     bool     providePts(void);
 virtual     uint64_t getVideoDuration(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoProcess.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoProcess.h	2010-03-15 18:52:42 UTC (rev 6005)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoProcess.h	2010-03-18 06:49:39 UTC (rev 6006)
@@ -30,15 +30,14 @@
 {
 protected:
             
-            ADMBitstream         *bitstream;
+   
             ADM_coreVideoEncoder *encoder;
             uint8_t              *data;
 public:
              ADM_videoStreamProcess(ADM_coreVideoEncoder *encoder);
     virtual ~ADM_videoStreamProcess();
 
-virtual     bool     getPacket(uint32_t *len, uint8_t *data, uint32_t maxLen,uint64_t *pts,uint64_t *dts,
-                                    uint32_t *flags);
+virtual     bool     getPacket(ADMBitstream *out);
 virtual     bool     getExtraData(uint32_t *extraLen, uint8_t **extraData) ;
 virtual     bool     providePts(void) {return true;}
 virtual     uint64_t getVideoDuration(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2010-03-15 18:52:42 UTC (rev 6005)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2010-03-18 06:49:39 UTC (rev 6006)
@@ -100,20 +100,18 @@
 /**
     \fn getPacket
 */
-bool  ADM_videoStreamCopy::getPacket(uint32_t *len, uint8_t *data, uint32_t maxLen,
-                    uint64_t *pts,uint64_t *dts,
-                    uint32_t *flags)
+bool  ADM_videoStreamCopy::getPacket(ADMBitstream *out)
 {
     if(true==eofMet) return false;
 again:
-    image.data=data;
+    image.data=out->data;
     if(false==video_body->getCompressedPicture(videoDelay,&image))
     {
             ADM_warning(" Get packet failed ");
             return false;
     }
-    *len=image.dataLength;
-    ADM_assert(*len<maxLen);
+    out->len=image.dataLength;
+    ADM_assert(out->len<out->bufferSize);
 #if 0
     if(image.demuxerPts!=ADM_NO_PTS)
         if(image.demuxerPts<startTimePts)   
@@ -125,8 +123,8 @@
             }
         }
 #endif
-    *pts=rescaleTs(image.demuxerPts);
-    *dts=rescaleTs(image.demuxerDts);
+    out->pts=rescaleTs(image.demuxerPts);
+    out->dts=rescaleTs(image.demuxerDts);
     if(image.demuxerPts!=ADM_NO_PTS)
     {
           if(image.demuxerDts!=ADM_NO_PTS)
@@ -144,7 +142,7 @@
             return false;
         }   
     }
-    *flags=image.flags;
+    out->flags=image.flags;
     currentFrame++;
     return true;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp	2010-03-15 18:52:42 UTC (rev 6005)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp	2010-03-18 06:49:39 UTC (rev 6006)
@@ -36,9 +36,6 @@
     averageFps1000=(uint32_t)f;
     printf("[StreamProcess] Average FPS1000=%"LU"\n",averageFps1000);
     isCFR=false;
-    bitstream=new ADMBitstream(width*height*4);
-    data=new uint8_t [width*height*4];
-    bitstream->data=data;
     videoDelay=encoder->getEncoderDelay();
     printf("[StreamProcess] Video Encoder Delay=%"LLU"ms\n",videoDelay/1000);
 }
@@ -47,9 +44,6 @@
 */
 ADM_videoStreamProcess::~ADM_videoStreamProcess()
 {
-    if(bitstream)
-        delete bitstream;
-    bitstream=NULL;
     if(encoder) delete encoder;
     encoder=NULL;
     if(data) delete [] data;
@@ -67,17 +61,10 @@
 /**
     \fn getPacket
 */
-bool  ADM_videoStreamProcess::getPacket(uint32_t *len, uint8_t *data, uint32_t maxLen,
-                    uint64_t *pts,uint64_t *dts,
-                    uint32_t *flags)
+bool  ADM_videoStreamProcess::getPacket(ADMBitstream *out)
 {
-    if(false==encoder->encode(bitstream)) return false;
-    ADM_assert(bitstream->len<maxLen);
-    memcpy(data,bitstream->data,bitstream->len);
-    *len=bitstream->len;
-    *pts=bitstream->pts;
-    *dts=bitstream->dts;
-    *flags=bitstream->flags;
+    if(false==encoder->encode(out)) return false;
+    ADM_assert(out->len<out->bufferSize);
     return true;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h	2010-03-15 18:52:42 UTC (rev 6005)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h	2010-03-18 06:49:39 UTC (rev 6006)
@@ -11,6 +11,7 @@
 #include "DIA_working.h"
 #include "DIA_coreToolkit.h"
 #include "DIA_encoding.h"
+#include "ADM_bitstream.h"
 
 /**
     \class ADM_videoStream
@@ -36,8 +37,7 @@
             uint32_t getAvgFps1000(void) {return averageFps1000;}
             uint64_t getVideoDelay(void) {return videoDelay;}
 
-virtual     bool     getPacket(uint32_t *len, uint8_t *data, uint32_t maxLen,uint64_t *pts,uint64_t *dts,
-                                        uint32_t *flags)=0;
+virtual     bool     getPacket(ADMBitstream *out)=0;
 virtual     bool     getExtraData(uint32_t *extraLen, uint8_t **extraData) {*extraLen=0;*extraData=NULL;return true;};
 virtual     bool     providePts(void) {return false;}
 virtual     uint64_t getVideoDuration(void) {return 1;}

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerInternal.h	2010-03-15 18:52:42 UTC (rev 6005)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerInternal.h	2010-03-18 06:49:39 UTC (rev 6006)
@@ -16,7 +16,7 @@
 #ifndef  ADM_muxerInternal_H
 #define  ADM_muxerInternal_H
 
-#define ADM_MUXER_API_VERSION 5
+#define ADM_MUXER_API_VERSION 6
 #include <stddef.h>
 #include "ADM_dynamicLoading.h"
 #include "ADM_muxer.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-03-15 18:52:42 UTC (rev 6005)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-03-18 06:49:39 UTC (rev 6006)
@@ -364,8 +364,7 @@
     printf("[FF] Saving\n");
     uint32_t bufSize=vStream->getWidth()*vStream->getHeight()*3;
     uint8_t *buffer=new uint8_t[bufSize];
-    uint32_t len,flags;
-    uint64_t pts,dts,rawDts;
+    uint64_t rawDts;
     uint64_t lastVideoDts=0;
     uint64_t videoIncrement;
     int ret;
@@ -386,8 +385,10 @@
     initUI("Saving");
     encoding->setContainer(getContainerName());
     MuxAudioPacket audioPackets[nbAStreams];
+    ADMBitstream out(bufSize);
+    out.data=buffer;
 
-    while(true==vStream->getPacket(&len, buffer, bufSize,&pts,&dts,&flags))
+    while(true==vStream->getPacket(&out))
     {
 	AVPacket pkt;
 
@@ -397,44 +398,44 @@
                 result=false;
                 break;
             }
-            int64_t xpts=(int64_t)pts;
-            int64_t xdts=(int64_t)dts;
-            if(pts==ADM_NO_PTS) xpts=-1;
-            if(dts==ADM_NO_PTS) xdts=-1;
+            int64_t xpts=(int64_t)out.pts;
+            int64_t xdts=(int64_t)out.dts;
+            if(out.pts==ADM_NO_PTS) xpts=-1;
+            if(out.dts==ADM_NO_PTS) xdts=-1;
             aprintf("[FF:V] Pts: %"LLD" DTS:%"LLD" ms\n",xpts/1000,xdts/1000);
 
             aprintf("[FF:V] LastDts:%08"LLU" Dts:%08"LLU" (%04"LLU") Delta : %"LLU"\n",
-                        lastVideoDts,dts,dts/1000000,dts-lastVideoDts);
-            rawDts=dts;
+                        lastVideoDts,out.dts,out.dts/1000000,out.dts-lastVideoDts);
+            rawDts=out.dts;
             if(rawDts==ADM_NO_PTS)
             {
                 lastVideoDts+=videoIncrement;
             }else
             {
-                lastVideoDts=dts;
+                lastVideoDts=out.dts;
             }
-            encoding->pushVideoFrame(len,0,lastVideoDts);
-            muxerRescaleVideoTimeDts(&dts,lastVideoDts);
-            muxerRescaleVideoTime(&pts);
-            aprintf("[FF:V] RawDts:%lu Scaled Dts:%lu\n",rawDts,dts);
-            aprintf("[FF:V] Rescaled: Len : %d flags:%x Pts:%"LLU" Dts:%"LLU"\n",len,flags,pts,dts);
+            encoding->pushVideoFrame(out.len,out.in_quantizer,lastVideoDts);
+            muxerRescaleVideoTimeDts(&(out.dts),lastVideoDts);
+            muxerRescaleVideoTime(&(out.pts));
+            aprintf("[FF:V] RawDts:%lu Scaled Dts:%lu\n",rawDts,out.dts);
+            aprintf("[FF:V] Rescaled: Len : %d flags:%x Pts:%"LLU" Dts:%"LLU"\n",out.len,out.flags,out.pts,out.dts);
 
             av_init_packet(&pkt);
-            pkt.dts=dts;
+            pkt.dts=out.dts;
             if(vStream->providePts()==true)
             {
-                pkt.pts=pts;
+                pkt.pts=out.pts;
             }else
             {
                 pkt.pts=pkt.dts;
             }
             pkt.stream_index=0;
             pkt.data= buffer;
-            pkt.size= len;
-            if(flags & 0x10) // FIXME AVI_KEY_FRAME
+            pkt.size= out.len;
+            if(out.flags & 0x10) // FIXME AVI_KEY_FRAME
                         pkt.flags |= PKT_FLAG_KEY;
             ret =writePacket( &pkt);
-            aprintf("[FF]Frame:%u, DTS=%08lu PTS=%08lu\n",written,dts,pts);
+            aprintf("[FF]Frame:%u, DTS=%08lu PTS=%08lu\n",written,out.dts,out.pts);
             if(false==ret)
             {
                 printf("[FF]Error writing video packet\n");



From mean at mail.berlios.de  Thu Mar 18 07:49:45 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 18 Mar 2010 07:49:45 +0100
Subject: [Avidemux-svn-commit] r6007 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:
	muxerAvi muxerDummy muxerRaw
Message-ID: <201003180649.o2I6njdA025387@sheep.berlios.de>

Author: mean
Date: 2010-03-18 07:49:43 +0100 (Thu, 18 Mar 2010)
New Revision: 6007

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerDummy/ADM_dummy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp
Log:
[muxer] Update muxer to new API

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp	2010-03-18 06:49:39 UTC (rev 6006)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp	2010-03-18 06:49:43 UTC (rev 6007)
@@ -138,8 +138,8 @@
     printf("[AviMuxer] Saving\n");
     uint32_t bufSize=vStream->getWidth()*vStream->getHeight()*3;
     bool result=true;
-    uint32_t len,flags;
-    uint64_t pts,dts,rawDts;
+   
+    uint64_t rawDts;
     uint64_t lastVideoDts=0;
     int ret;
     int written=0;
@@ -149,11 +149,12 @@
     videoBuffer=new uint8_t[bufSize];
 
     ADM_info("[AviMuxer]avg fps=%u\n",vStream->getAvgFps1000());
-
+    ADMBitstream in(bufSize);
+    in.data=videoBuffer;
     uint64_t aviTime=0;
-    if(false==vStream->getPacket(&len, videoBuffer, bufSize,&pts,&dts,&flags)) goto abt;
-    if(dts==ADM_NO_PTS) dts=0;
-    lastVideoDts=dts;
+    if(false==vStream->getPacket(&in)) goto abt;
+    if(in.dts==ADM_NO_PTS) in.dts=0;
+    lastVideoDts=in.dts;
 
     initUI("Saving Avi");
     encoding->setContainer("AVI/OpenDML");
@@ -161,25 +162,25 @@
     while(1)
     {
             
-            if(dts>aviTime+videoIncrement)
+            if(in.dts>aviTime+videoIncrement)
             {
                 writter.saveVideoFrame( 0, 0,videoBuffer); // Insert dummy video frame
-                encoding->pushVideoFrame(0,0,dts);
+                encoding->pushVideoFrame(0,0,in.dts);
             }else
             {
-                if(!writter.saveVideoFrame( len, flags,videoBuffer))  // Put our real video
+                if(!writter.saveVideoFrame( in.len, in.flags,videoBuffer))  // Put our real video
                 {
                         ADM_warning("[AviMuxer] Error writting video frame\n");
                         result=false;
                         goto abt;
                 }
-                encoding->pushVideoFrame(len,0,dts);
-                if(false==vStream->getPacket(&len, videoBuffer, bufSize,&pts,&dts,&flags)) goto abt;
-                if(dts==ADM_NO_PTS)
+                encoding->pushVideoFrame(in.len,in.in_quantizer,in.dts);
+                if(false==vStream->getPacket(&in)) goto abt;
+                if(in.dts==ADM_NO_PTS)
                 {
-                    dts=lastVideoDts+videoIncrement;
+                    in.dts=lastVideoDts+videoIncrement;
                 }
-                lastVideoDts=dts;
+                lastVideoDts=in.dts;
             }
 
             fillAudio(aviTime+videoIncrement);    // and matching audio

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerDummy/ADM_dummy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerDummy/ADM_dummy.cpp	2010-03-18 06:49:39 UTC (rev 6006)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerDummy/ADM_dummy.cpp	2010-03-18 06:49:43 UTC (rev 6007)
@@ -19,10 +19,10 @@
     uint32_t  len,flags;
     uint64_t  pts,dts;
     uint32_t  written=0;
-
+    ADMBitstream in(bufSize);
     audioBuffer=new uint8_t[10*4*8*1024];
     videoBuffer=new uint8_t[bufSize];
-
+    in.data=videoBuffer;
     ADM_info("[dummy]avg fps=%u\n",vStream->getAvgFps1000());
 
     initUI("Saving dummy");
@@ -30,8 +30,8 @@
 
     while(1)
     {
-        if(false==vStream->getPacket(&len, videoBuffer, bufSize,&pts,&dts,&flags)) goto abt;
-        encoding->pushVideoFrame(len,0,dts);
+        if(false==vStream->getPacket(&in)) goto abt;
+        encoding->pushVideoFrame(in.len,in.in_quantizer,in.dts);
         if(updateUI()==false)
         {  
             goto abt;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp	2010-03-18 06:49:39 UTC (rev 6006)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerRaw/muxerRaw.cpp	2010-03-18 06:49:43 UTC (rev 6007)
@@ -74,23 +74,23 @@
     printf("[RAW] Saving\n");
     uint32_t bufSize=vStream->getWidth()*vStream->getHeight()*3;
     uint8_t *buffer=new uint8_t[bufSize];
-    uint32_t len,flags;
-    uint64_t pts,dts,rawDts;
+    uint64_t rawDts;
     uint64_t lastVideoDts=0;
     int written=0;
     bool result=true;
-
+    ADMBitstream in(bufSize);
+    in.data=buffer;
     initUI("Saving raw video");
-    while(true==vStream->getPacket(&len, buffer, bufSize,&pts,&dts,&flags))
+    while(true==vStream->getPacket(&in))
     {
-        if(dts==ADM_NO_PTS)
-            dts=lastVideoDts+videoIncrement;
+        if(in.dts==ADM_NO_PTS)
+            in.dts=lastVideoDts+videoIncrement;
         if(updateUI()==false)
         {
             result=false;
             goto abt;
         }
-        fwrite(buffer,len,1,file);
+        fwrite(buffer,in.len,1,file);
         written++;
 
     }



From mean at mail.berlios.de  Thu Mar 18 07:49:47 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 18 Mar 2010 07:49:47 +0100
Subject: [Avidemux-svn-commit] r6008 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_audioFilter/include
	avidemux/common/ADM_audioFilter/src
	avidemux_core/ADM_coreUtils/include avidemux_core/ADM_coreUtils/src
Message-ID: <201003180649.o2I6nlrY025429@sheep.berlios.de>

Author: mean
Date: 2010-03-18 07:49:46 +0100 (Thu, 18 Mar 2010)
New Revision: 6008

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/include/audiofilter_thread.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/CMakeLists.txt
Log:
[threading] Factorize thread worker code into ADM_threadQueue baseclass

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/include/audiofilter_thread.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/include/audiofilter_thread.h	2010-03-18 06:49:43 UTC (rev 6007)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/include/audiofilter_thread.h	2010-03-18 06:49:46 UTC (rev 6008)
@@ -16,46 +16,19 @@
 #define AUDM_ACCESS_THREAD_H
 
 #include "ADM_audioStream.h"
-#include "ADM_threads.h"
-using std::vector;
-#include <vector>
+#include "ADM_threadQueue.h"
 
 
-
 /**
-    \struct ADM_audioPacket
-*/
-typedef struct
-{
-    uint8_t *data;
-    uint32_t dataLen;
-    uint64_t dts;
-}ADM_audioPacket;
-typedef  vector <ADM_audioPacket> ListOfAudioPacket;
-
-typedef enum
-{
-    RunStateIdle,
-    RunStateRunning,
-    RunStateStopOrder,
-    RunStateStopped
-}RunState;
-
-/**
     \class ADM_audioAccess_thread
     \brief Wrap ADM_audioAccess inside a thread
 
 */
-class ADM_audioAccess_thread : public ADM_audioAccess
+class ADM_audioAccess_thread : public ADM_audioAccess,public ADM_threadQueue
 {
   protected:
                 ADM_audioAccess   *son;
-                ListOfAudioPacket list;
-                admMutex          *mutex;
-                admCond           *cond;
-                bool              started;
-volatile        RunState          threadState;
-                pthread_t         myThread;
+              
   public:
 
 
@@ -76,9 +49,9 @@
                                     /// Grab extra data
                 virtual bool      getExtraData(uint32_t *l, uint8_t **d);
 
-                virtual bool    getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts);
-                virtual bool    isCBR(void) {return son->isCBR();};
-                void            run(void);
+                virtual bool      getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts);
+                virtual bool      isCBR(void) {return son->isCBR();};
+                virtual bool      runAction(void);
 };
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp	2010-03-18 06:49:43 UTC (rev 6007)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp	2010-03-18 06:49:46 UTC (rev 6008)
@@ -31,14 +31,10 @@
     \fn ADM_audioAccess_thread
     \brief
 */
-ADM_audioAccess_thread::ADM_audioAccess_thread(ADM_audioAccess *son)
+ADM_audioAccess_thread::ADM_audioAccess_thread(ADM_audioAccess *son) :ADM_threadQueue()
 {
     this->son=son;
     ADM_info("Swallowing audio access into a thread\n");
-    mutex=new admMutex("audioAccess");
-    cond=new admCond(mutex);
-    threadState=RunStateIdle;
-    started=false;
     
 }
 /**
@@ -49,29 +45,12 @@
 ADM_audioAccess_thread::~ADM_audioAccess_thread()
 {
     ADM_info("Killing audio thread and son\n");
-    // ask the thread to stop
-    
-    if(started)
-    {
-        mutex->lock();
-        if(threadState==RunStateRunning)
-        {   
-            ADM_info("Asking the thread to stop\n");
-            threadState=RunStateStopOrder;
-            mutex->unlock();
-            int count=100;
-            while(count)
-            {
-                if(threadState==RunStateStopped) break;
-                ADM_usleep(1000*100); // Slep 100 ms
-            }
-        }else mutex->unlock();
-    }
+   
     // Empty the list...
     int nb=list.size();
     for(int i=0;i<nb;i++)
     {
-        ADM_audioPacket *pkt=&(list[i]);
+        ADM_queuePacket *pkt=&(list[i]);
         if(pkt->data) delete [] pkt->data;
         pkt->data=NULL;
     }
@@ -116,18 +95,7 @@
 {
     if(false==started)
     {
-        ADM_info("Starting thread...\n");
-        if(pthread_create(&myThread,NULL, boomerang, this))
-        {
-            ADM_error("ERROR CREATING THREAD\n");
-            ADM_assert(0);
-        }
-        while(threadState==RunStateIdle)
-        {
-            ADM_usleep(10000);
-        }
-        ADM_info("Thread created and started\n");
-        started=true;
+        startThread();      
     }
     while(1)
     {
@@ -136,7 +104,7 @@
         {
             //
             // Dequeue one item
-            ADM_audioPacket *pkt=&(list[0]);
+            ADM_queuePacket *pkt=&(list[0]);
             ADM_assert(pkt->data);
             ADM_assert(pkt->dataLen<maxSize);
             memcpy(buffer,pkt->data,pkt->dataLen);
@@ -162,13 +130,12 @@
     return false;
 }
 /**
-    \fn run
+    \fn runAction
     \brief entry point for thread
 */
-void ADM_audioAccess_thread::run(void)
+bool ADM_audioAccess_thread::runAction(void)
 {
     #define CHUNK_SIZE (48000*sizeof(float)*6)
-    threadState=RunStateRunning;
     uint8_t *buffer=new uint8_t[CHUNK_SIZE];
     uint32_t size;
     uint64_t dts;
@@ -179,7 +146,7 @@
             ADM_info("Audio Thread, no more data\n");
             goto theEnd;
         }
-        ADM_audioPacket p;
+        ADM_queuePacket p;
         p.data=new uint8_t[size];
         memcpy(p.data,buffer,size);
         p.dataLen=size;
@@ -205,7 +172,7 @@
 
 theEnd:
     delete [] buffer;
-    threadState=RunStateStopped;
+    return true;
 }
 /**
     \fn ADM_threadifyAudioAccess

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h	2010-03-18 06:49:43 UTC (rev 6007)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h	2010-03-18 06:49:46 UTC (rev 6008)
@@ -0,0 +1,72 @@
+/***************************************************************************
+            \file ADM_threadQueue.cpp
+            \brief Create a thread that fills a queue from another part
+            \author  (c) 2010 Mean , fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_THREAD_QUEUE_H
+#define ADM_THREAD_QUEUE_H
+#include "ADM_threads.h"
+
+using namespace std;
+#include <vector>
+
+
+
+/**
+    \struct ADM_audioPacket
+*/
+typedef struct
+{
+    uint8_t *data;
+    uint32_t dataLen;
+    uint64_t dts;
+    uint64_t pts;
+}ADM_queuePacket;
+
+typedef  vector <ADM_queuePacket> ListOfQueuePacket;
+
+typedef enum
+{
+    RunStateIdle,
+    RunStateRunning,
+    RunStateStopOrder,
+    RunStateStopped
+}RunState;
+
+/**
+    \class ADM_threadQueue
+    \brief Wrap queue/thread
+
+*/
+class ADM_threadQueue
+{
+  protected:
+                ListOfQueuePacket list;
+                admMutex          *mutex;
+                admCond           *cond;
+                bool              started;
+volatile        RunState          threadState;
+                pthread_t         myThread;
+  public:
+
+
+                                    ADM_threadQueue() ;
+                virtual             ~ADM_threadQueue();
+                void                run(void);
+protected:
+        virtual bool                runAction(void)=0; 
+                bool                startThread(void);
+};
+
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp	2010-03-18 06:49:43 UTC (rev 6007)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp	2010-03-18 06:49:46 UTC (rev 6008)
@@ -0,0 +1,95 @@
+/***************************************************************************
+            \file ADM_threadQueue.cpp
+            \brief Create a thread that fills a queue from another part
+            \author  (c) 2010 Mean , fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_threadQueue.h"
+#include <math.h>
+
+static void *boomerang(void *x)
+{
+    ADM_threadQueue *a=(ADM_threadQueue *)x;
+    a->run();
+}
+
+/**
+    \fn ADM_audioAccess_thread
+    \brief
+*/
+ADM_threadQueue::ADM_threadQueue(void)
+{
+    mutex=new admMutex("audioAccess");
+    cond=new admCond(mutex);
+    threadState=RunStateIdle;
+    started=false;    
+}
+/**
+    \fn ~ADM_threadQueue
+    \brief
+*/
+
+ADM_threadQueue::~ADM_threadQueue()
+{
+    ADM_info("Killing audio thread and son\n");
+    // ask the thread to stop
+    
+    if(started)
+    {
+        mutex->lock();
+        if(threadState==RunStateRunning)
+        {   
+            ADM_info("Asking the thread to stop\n");
+            threadState=RunStateStopOrder;
+            mutex->unlock();
+            int count=100;
+            while(count)
+            {
+                if(threadState==RunStateStopped) break;
+                ADM_usleep(1000*100); // Slep 100 ms
+            }
+        }else mutex->unlock();
+    }
+   
+}
+
+/**
+    \fn run
+    \brief entry point for thread
+*/
+void ADM_threadQueue::run(void)
+{
+    
+    threadState=RunStateRunning;
+    runAction();
+    threadState=RunStateStopped;
+}
+/**
+    \fn startThread
+*/
+bool ADM_threadQueue::startThread(void)
+{
+      ADM_info("Starting thread...\n");
+        if(pthread_create(&myThread,NULL, boomerang, this))
+        {
+            ADM_error("ERROR CREATING THREAD\n");
+            ADM_assert(0);
+        }
+        while(threadState==RunStateIdle)
+        {
+            ADM_usleep(10000);
+        }
+        ADM_info("Thread created and started\n");
+        started=true;
+        return true;
+}
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/CMakeLists.txt	2010-03-18 06:49:43 UTC (rev 6007)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/CMakeLists.txt	2010-03-18 06:49:46 UTC (rev 6008)
@@ -10,6 +10,7 @@
 ADM_file.cpp
 ADM_paramList.cpp
 ADM_coreCodecMapping.cpp
+ADM_threadQueue.cpp
 prefs.cpp)
 
 ADD_LIBRARY(ADM_coreUtils6 SHARED ${ADM_coreUtils_SRCS})



From mean at mail.berlios.de  Thu Mar 18 07:49:49 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 18 Mar 2010 07:49:49 +0100
Subject: [Avidemux-svn-commit] r6009 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include
Message-ID: <201003180649.o2I6nnMO025462@sheep.berlios.de>

Author: mean
Date: 2010-03-18 07:49:48 +0100 (Thu, 18 Mar 2010)
New Revision: 6009

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
Log:
[coreVideoFilter] Dtor is virtual

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-03-18 06:49:46 UTC (rev 6008)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-03-18 06:49:48 UTC (rev 6009)
@@ -43,8 +43,8 @@
             VideoCache           *vidCache;
             const char           *myName;
 public:
-            ADM_coreVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf=NULL);
-            ~ADM_coreVideoFilter();
+                            ADM_coreVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf=NULL);
+       virtual             ~ADM_coreVideoFilter();
 
        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
        virtual bool         goToTime(uint64_t usSeek);              



From mean at mail.berlios.de  Thu Mar 18 07:49:50 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 18 Mar 2010 07:49:50 +0100
Subject: [Avidemux-svn-commit] r6010 - in
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2:
	include src
Message-ID: <201003180649.o2I6noxn025494@sheep.berlios.de>

Author: mean
Date: 2010-03-18 07:49:50 +0100 (Thu, 18 Mar 2010)
New Revision: 6010

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/CMakeLists.txt
Log:
[videoFilter] Threadify videoFilterQueue

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h	2010-03-18 06:49:48 UTC (rev 6009)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h	2010-03-18 06:49:50 UTC (rev 6010)
@@ -0,0 +1,44 @@
+/**
+        \file  ADM_filterThread.h
+        \brief Queue buffered filter. A dedicated thread is filling the queue. To be put just before encoder
+        \author mean, fixounet at free.fr
+*/
+
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ ***************************************************************************/
+#ifndef ADM_FILTER_THREAD_H
+#define ADM_FILTER_THREAD_H
+#include "ADM_coreVideoFilter.h"
+#include "ADM_threadQueue.h"
+#define ADM_THREAD_QUEUE_SIZE 4
+/**
+ *  \class ADM_videoFilterQueue
+ *  \brief 
+ */
+class ADM_videoFilterQueue : public ADM_coreVideoFilter,public ADM_threadQueue
+{
+protected:
+             ListOfQueuePacket freeList;
+public:
+                            ADM_videoFilterQueue(ADM_coreVideoFilter *son,CONFcouple *conf=NULL);
+       virtual              ~ADM_videoFilterQueue();
+
+       virtual const char   *getConfiguration(void) {return "NONE";}                    
+       virtual bool         getCoupledConf(CONFcouple **couples) {*couples=NULL;return true;} ;   /// Return the current filter configuration
+       virtual bool         configure(void) {return true;}             /// Start graphical user interface
+/**/
+       virtual bool         goToTime(uint64_t usSeek); 
+       virtual bool         getNextFrame(uint32_t *frameNumber,ADMImage *image);     
+       virtual FilterInfo  *getInfo(void)    ;
+
+protected:
+        virtual bool                runAction(void); 
+};
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2010-03-18 06:49:48 UTC (rev 6009)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2010-03-18 06:49:50 UTC (rev 6010)
@@ -0,0 +1,154 @@
+/**
+        \file  ADM_filterThread.cpp
+        \brief Queue buffered filter. A dedicated thread is filling the queue. To be put just before encoder
+        \author mean, fixounet at free.fr
+*/
+
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_videoFilterApi.h"
+#include "ADM_videoFilters.h"
+#include "ADM_filterThread.h"
+/**
+    \fn     ADM_videoFilterQueue
+    \brief
+*/
+ADM_videoFilterQueue::ADM_videoFilterQueue(ADM_coreVideoFilter *previous,CONFcouple *conf ):
+                ADM_coreVideoFilter(previous,conf)
+{
+    // Allocate buffer
+    for(int i=0;i<ADM_THREAD_QUEUE_SIZE;i++)
+    {
+        ADM_queuePacket item;
+        item.data=(uint8_t *)new ADMImage(info.width,info.height);
+        freeList.push_back(item);
+    }
+}
+/**
+    \fn ~ADM_videoFilterQueue
+    \brief
+*/
+ADM_videoFilterQueue::~ADM_videoFilterQueue()
+{
+        ADM_info("Destroying video threadQueue\n");
+        int i;
+        i=freeList.size();
+        for(int j=0;j<i;j++)
+        {
+            ADMImage *image=(ADMImage *)freeList[j].data;
+            delete image;
+        }
+        freeList.clear();
+        i=list.size();
+        for(int j=0;j<i;j++)
+        {
+            ADMImage *image=(ADMImage *)list[j].data;
+            delete image;
+        }
+        list.clear();
+
+}
+/**
+    \fn     goToTime
+    \brief
+*/
+bool         ADM_videoFilterQueue::goToTime(uint64_t usSeek)
+{
+        ADM_assert(0);
+        return false;
+}
+/**
+    \fn     getNextFrame
+    \brief
+*/
+bool         ADM_videoFilterQueue::getNextFrame(uint32_t *frameNumber,ADMImage *image)
+{
+     if(false==started)
+        {
+            startThread();      
+        }
+        while(1)
+        {
+            mutex->lock();
+            if(list.size())
+            {
+                //
+                // Dequeue one item
+                ADM_queuePacket *pkt=&(list[0]);
+                ADM_assert(pkt->data);
+                ADMImage *source=(ADMImage *)pkt->data;
+                *frameNumber=pkt->pts;
+                image->duplicateFull(source);
+                list.erase(list.begin());
+                freeList.push_back(*pkt);
+                mutex->unlock();
+                return true;
+            }
+            // If no item, thread still alive ?
+            if(threadState==RunStateStopped)
+            {
+                ADM_info("Audio thread stopped, no more data\n");
+                mutex->unlock();
+                return false;
+            }
+            mutex->unlock();
+            ADM_usleep(10*1000); // wait 10 ms
+        }
+        return false;
+}
+/**
+    \fn     getInfo
+    \brief
+*/
+FilterInfo   *ADM_videoFilterQueue::getInfo(void)    
+{
+        return previousFilter->getInfo();
+}
+/**
+    \fn
+    \brief
+*/
+bool         ADM_videoFilterQueue::runAction(void)
+{
+    while(1)
+    {
+        if(threadState==RunStateStopOrder)  
+        {
+            ADM_info("Audio Thread, received stop order\n");
+            goto theEnd;
+        }
+        mutex->lock();
+        if(!freeList.size())
+        {
+            mutex->unlock();
+            ADM_usleep(2000);
+            continue;
+        }
+        uint32_t fn=0;
+        ADM_queuePacket pkt=(list[0]);
+        ADM_assert(pkt.data);
+        ADMImage *source=(ADMImage *)pkt.data;
+        list.erase(freeList.begin());
+        mutex->unlock();
+
+        if(false==previousFilter->getNextFrame(&fn,source))
+        {
+            pkt.pts=fn;
+            ADM_info("Video Thread, no more data\n");
+            mutex->lock();
+            freeList.push_back(pkt);
+            mutex->unlock();
+            goto theEnd;
+        }
+    }
+theEnd:
+        ADM_info("Exiting video thread loop\n");
+}
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/CMakeLists.txt	2010-03-18 06:49:48 UTC (rev 6009)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/CMakeLists.txt	2010-03-18 06:49:50 UTC (rev 6010)
@@ -3,5 +3,6 @@
         ADM_filterChain.cpp
         ADM_pluginLoad.cpp
         ADM_videoFilters.cpp
+        ADM_filterThread.cpp
 )
 ADD_LIBRARY(ADM_internalVideoFilter6 STATIC ${ADM_internalVideoFilter_SRCS})



From mean at mail.berlios.de  Thu Mar 18 20:21:10 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 18 Mar 2010 20:21:10 +0100
Subject: [Avidemux-svn-commit] r6011 - in
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2:
	include src
Message-ID: <201003181921.o2IJLANJ005060@sheep.berlios.de>

Author: mean
Date: 2010-03-18 20:21:10 +0100 (Thu, 18 Mar 2010)
New Revision: 6011

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterChain.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilters.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/CMakeLists.txt
Log:
[filter] End of filterChain is a threadQueue

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h	2010-03-18 06:49:50 UTC (rev 6010)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h	2010-03-18 19:21:10 UTC (rev 6011)
@@ -16,7 +16,7 @@
 #define ADM_FILTER_THREAD_H
 #include "ADM_coreVideoFilter.h"
 #include "ADM_threadQueue.h"
-#define ADM_THREAD_QUEUE_SIZE 4
+#define ADM_THREAD_QUEUE_SIZE 8
 /**
  *  \class ADM_videoFilterQueue
  *  \brief 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterChain.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterChain.cpp	2010-03-18 06:49:50 UTC (rev 6010)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterChain.cpp	2010-03-18 19:21:10 UTC (rev 6011)
@@ -1,26 +0,0 @@
-/***************************************************************************
-                          \fn ADM_filterChain.cpp
-                          \brief Base class for Video Filters
-                           (c) Mean 2009
-
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "ADM_default.h"
-#include "ADM_coreVideoFilter.h"
-#include "ADM_filterChain.h"
-#include "ADM_videoFilterBridge.h"
-
-
-
-
-// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2010-03-18 06:49:50 UTC (rev 6010)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2010-03-18 19:21:10 UTC (rev 6011)
@@ -23,6 +23,8 @@
 ADM_videoFilterQueue::ADM_videoFilterQueue(ADM_coreVideoFilter *previous,CONFcouple *conf ):
                 ADM_coreVideoFilter(previous,conf)
 {
+    // 
+    myName="threadQueue";
     // Allocate buffer
     for(int i=0;i<ADM_THREAD_QUEUE_SIZE;i++)
     {
@@ -38,16 +40,16 @@
 ADM_videoFilterQueue::~ADM_videoFilterQueue()
 {
         ADM_info("Destroying video threadQueue\n");
-        int i;
-        i=freeList.size();
-        for(int j=0;j<i;j++)
+        int fCount;
+        fCount=freeList.size();
+        for(int j=0;j<fCount;j++)
         {
             ADMImage *image=(ADMImage *)freeList[j].data;
             delete image;
         }
         freeList.clear();
-        i=list.size();
-        for(int j=0;j<i;j++)
+        int count=list.size();
+        for(int j=0;j<fCount;j++)
         {
             ADMImage *image=(ADMImage *)list[j].data;
             delete image;
@@ -81,13 +83,13 @@
             {
                 //
                 // Dequeue one item
-                ADM_queuePacket *pkt=&(list[0]);
-                ADM_assert(pkt->data);
-                ADMImage *source=(ADMImage *)pkt->data;
-                *frameNumber=pkt->pts;
+                ADM_queuePacket pkt=(list[0]);
+                ADM_assert(pkt.data);
+                ADMImage *source=(ADMImage *)pkt.data;
+                *frameNumber=pkt.pts;
                 image->duplicateFull(source);
                 list.erase(list.begin());
-                freeList.push_back(*pkt);
+                freeList.push_back(pkt);
                 mutex->unlock();
                 return true;
             }
@@ -132,21 +134,27 @@
             continue;
         }
         uint32_t fn=0;
-        ADM_queuePacket pkt=(list[0]);
+        ADM_queuePacket pkt=(freeList[0]);
         ADM_assert(pkt.data);
         ADMImage *source=(ADMImage *)pkt.data;
-        list.erase(freeList.begin());
+        freeList.erase(freeList.begin());
         mutex->unlock();
 
         if(false==previousFilter->getNextFrame(&fn,source))
         {
-            pkt.pts=fn;
+           
             ADM_info("Video Thread, no more data\n");
             mutex->lock();
             freeList.push_back(pkt);
             mutex->unlock();
             goto theEnd;
         }
+        // Got it, push it
+        mutex->lock();
+        pkt.pts=fn;
+        list.push_back(pkt);
+        mutex->unlock();
+
     }
 theEnd:
         ADM_info("Exiting video thread loop\n");

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilters.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilters.cpp	2010-03-18 06:49:50 UTC (rev 6010)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilters.cpp	2010-03-18 19:21:10 UTC (rev 6011)
@@ -1,11 +1,9 @@
 /**
         \file  ADM_videoFilters.cpp
         \brief Handle current filter list
+        \author mean fixounet at free.fr 2010
 
-
 */
-
-
 /***************************************************************************
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -18,6 +16,7 @@
 #include "ADM_videoFilters.h"
 #include "ADM_videoFilterBridge.h"
 #include "ADM_filterChain.h"
+#include "ADM_filterThread.h"
 static ADM_coreVideoFilter *bridge=NULL;
 
 std::vector<ADM_VideoFilterElement> ADM_VideoFilters;
@@ -228,6 +227,13 @@
             f=nw;
             chain->push_back(nw);
     }
+    // Last create the thread
+#if 1
+    int m=chain->size();
+    ADM_coreVideoFilter *last=(*chain)[m-1];
+    ADM_videoFilterQueue *thread=new ADM_videoFilterQueue(last);
+    chain->push_back(thread);
+#endif
     return chain;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/CMakeLists.txt	2010-03-18 06:49:50 UTC (rev 6010)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/CMakeLists.txt	2010-03-18 19:21:10 UTC (rev 6011)
@@ -1,6 +1,5 @@
 SET(ADM_internalVideoFilter_SRCS 
 	ADM_videoFilterBridge.cpp
-        ADM_filterChain.cpp
         ADM_pluginLoad.cpp
         ADM_videoFilters.cpp
         ADM_filterThread.cpp



From mean at mail.berlios.de  Thu Mar 18 20:21:12 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 18 Mar 2010 20:21:12 +0100
Subject: [Avidemux-svn-commit] r6012 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include
Message-ID: <201003181921.o2IJLCu1005073@sheep.berlios.de>

Author: mean
Date: 2010-03-18 20:21:12 +0100 (Thu, 18 Mar 2010)
New Revision: 6012

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoProcess.h
Log:
[VideoProcess] Cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoProcess.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoProcess.h	2010-03-18 19:21:10 UTC (rev 6011)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoProcess.h	2010-03-18 19:21:12 UTC (rev 6012)
@@ -29,10 +29,7 @@
 class ADM_videoStreamProcess: public ADM_videoStream
 {
 protected:
-            
-   
             ADM_coreVideoEncoder *encoder;
-            uint8_t              *data;
 public:
              ADM_videoStreamProcess(ADM_coreVideoEncoder *encoder);
     virtual ~ADM_videoStreamProcess();



From mean at mail.berlios.de  Thu Mar 18 20:21:13 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 18 Mar 2010 20:21:13 +0100
Subject: [Avidemux-svn-commit] r6013 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src
Message-ID: <201003181921.o2IJLDEb005086@sheep.berlios.de>

Author: mean
Date: 2010-03-18 20:21:13 +0100 (Thu, 18 Mar 2010)
New Revision: 6013

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp
Log:
[VideoProcess] Cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp	2010-03-18 19:21:12 UTC (rev 6012)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp	2010-03-18 19:21:13 UTC (rev 6013)
@@ -46,8 +46,6 @@
 {
     if(encoder) delete encoder;
     encoder=NULL;
-    if(data) delete [] data;
-    data=NULL;
 }
 /**
     \fn getExtraData



From mean at mail.berlios.de  Fri Mar 19 07:33:11 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 19 Mar 2010 07:33:11 +0100
Subject: [Avidemux-svn-commit] r6014 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_videoFilter2/src avidemux_core/ADM_coreUtils/src
Message-ID: <201003190633.o2J6XBQ8006855@sheep.berlios.de>

Author: mean
Date: 2010-03-19 07:33:11 +0100 (Fri, 19 Mar 2010)
New Revision: 6014

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp
Log:
[videoQueue] Use cond rather than sleep to synchronize threads

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2010-03-18 19:21:13 UTC (rev 6013)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2010-03-19 06:33:11 UTC (rev 6014)
@@ -90,6 +90,10 @@
                 image->duplicateFull(source);
                 list.erase(list.begin());
                 freeList.push_back(pkt);
+                if(cond->iswaiting())
+                {
+                    cond->wakeup();
+                }
                 mutex->unlock();
                 return true;
             }
@@ -129,10 +133,14 @@
         mutex->lock();
         if(!freeList.size())
         {
-            mutex->unlock();
-            ADM_usleep(2000);
+            cond->wait(); // Will unlock mutex
             continue;
         }
+        if(threadState==RunStateStopOrder)  
+        {
+            ADM_info("Audio Thread, received stop order\n");
+            goto theEnd;
+        }
         uint32_t fn=0;
         ADM_queuePacket pkt=(freeList[0]);
         ADM_assert(pkt.data);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp	2010-03-18 19:21:13 UTC (rev 6013)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp	2010-03-19 06:33:11 UTC (rev 6014)
@@ -31,7 +31,8 @@
     mutex=new admMutex("audioAccess");
     cond=new admCond(mutex);
     threadState=RunStateIdle;
-    started=false;    
+    started=false;   
+    cond=new admCond(mutex);
 }
 /**
     \fn ~ADM_threadQueue
@@ -50,6 +51,10 @@
         {   
             ADM_info("Asking the thread to stop\n");
             threadState=RunStateStopOrder;
+            if(cond->iswaiting())
+            {
+                cond->wakeup();
+            }
             mutex->unlock();
             int count=100;
             while(count)
@@ -59,7 +64,10 @@
             }
         }else mutex->unlock();
     }
-   
+    if(cond) delete cond;
+    if(mutex) delete mutex;
+    cond=NULL;
+    mutex=NULL;
 }
 
 /**



From mean at mail.berlios.de  Tue Mar 23 15:54:39 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 15:54:39 +0100
Subject: [Avidemux-svn-commit] r6015 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_audioFilter/src
	avidemux/common/ADM_videoFilter2/include
	avidemux_core/ADM_coreUtils/include
Message-ID: <201003231454.o2NEsdZn008829@sheep.berlios.de>

Author: mean
Date: 2010-03-23 15:54:39 +0100 (Tue, 23 Mar 2010)
New Revision: 6015

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h
Log:
[audioThread] Use pre-allocated buffers to avoid memcpy+alloc

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp	2010-03-19 06:33:11 UTC (rev 6014)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp	2010-03-23 14:54:39 UTC (rev 6015)
@@ -19,7 +19,8 @@
 #include "audiofilter_thread.h"
 #include <math.h>
 
-#define MAX_CHUNK_IN_QUEUE 50
+#define MAX_CHUNK_IN_QUEUE 10
+#define CHUNK_SIZE (20*1024) // should be more than enough
 
 static void *boomerang(void *x)
 {
@@ -35,6 +36,12 @@
 {
     this->son=son;
     ADM_info("Swallowing audio access into a thread\n");
+    for(int i=0;i<MAX_CHUNK_IN_QUEUE;i++)
+    {
+            ADM_queuePacket pkt;
+            pkt.data=new uint8_t[CHUNK_SIZE];
+            freeList.push_back(pkt);
+    }
     
 }
 /**
@@ -55,6 +62,16 @@
         pkt->data=NULL;
     }
     list.clear();
+
+    nb=freeList.size();
+    for(int i=0;i<nb;i++)
+    {
+        ADM_queuePacket *pkt=&(freeList[i]);
+        if(pkt->data) delete [] pkt->data;
+        pkt->data=NULL;
+    }
+    freeList.clear();
+
     // Thread stopped, we can kill the son
     delete son;
 }
@@ -104,17 +121,23 @@
         {
             //
             // Dequeue one item
-            ADM_queuePacket *pkt=&(list[0]);
-            ADM_assert(pkt->data);
-            ADM_assert(pkt->dataLen<maxSize);
-            memcpy(buffer,pkt->data,pkt->dataLen);
-            *dts=pkt->dts;
-            //printf("popping Packet with DTS=%"LLD", size=%d\n",*dts,(int)pkt->dataLen);
-            *size=pkt->dataLen;
-            delete [] pkt->data;
-            pkt->data=NULL;
+            ADM_queuePacket pkt=list[0];
             list.erase(list.begin());
             mutex->unlock();
+            ADM_assert(pkt.data);
+            ADM_assert(pkt.dataLen<maxSize);
+            ADM_assert(pkt.dataLen<CHUNK_SIZE);
+            memcpy(buffer,pkt.data,pkt.dataLen);
+            *dts=pkt.dts;
+            //printf("popping Packet with DTS=%"LLD", size=%d\n",*dts,(int)pkt->dataLen);
+            *size=pkt.dataLen;
+            mutex->lock();
+            freeList.push_back(pkt);
+            if(cond->iswaiting())
+            {
+                cond->wakeup();
+            }
+            mutex->unlock();
             return true;
         }
         // If no item, thread still alive ?
@@ -125,7 +148,7 @@
             return false;
         }
         mutex->unlock();
-        ADM_usleep(10*1000); // wait 10 ms
+        ADM_usleep(2*1000); // wait 10 ms
     }
     return false;
 }
@@ -135,43 +158,37 @@
 */
 bool ADM_audioAccess_thread::runAction(void)
 {
-    #define CHUNK_SIZE (48000*sizeof(float)*6)
-    uint8_t *buffer=new uint8_t[CHUNK_SIZE];
-    uint32_t size;
-    uint64_t dts;
     while(1)
     {
-        if(false==son->getPacket(buffer,&size,CHUNK_SIZE,&dts))
+        if(threadState==RunStateStopOrder)  
         {
-            ADM_info("Audio Thread, no more data\n");
+            ADM_info("Audio Thread, received stop order\n");
             goto theEnd;
         }
-        ADM_queuePacket p;
-        p.data=new uint8_t[size];
-        memcpy(p.data,buffer,size);
-        p.dataLen=size;
-        p.dts=dts;
         mutex->lock();
-        list.push_back(p);
-        //printf("Pushing Packet with DTS=%"LLD",size=%d\n",dts,(int)size);
+        if(!freeList.size())
+        {
+            cond->wait();
+            continue;
+        }
+        ADM_queuePacket pkt=(freeList[0]);
+        ADM_assert(pkt.data);
+        freeList.erase(freeList.begin());
         mutex->unlock();
-        if(threadState==RunStateStopOrder)  
+
+        if(false==son->getPacket(pkt.data,&(pkt.dataLen),CHUNK_SIZE,&(pkt.dts)))
         {
-            ADM_info("Audio Thread, received stop order\n");
+            ADM_info("Audio Thread, no more data\n");
             goto theEnd;
         }
-        while(1)
-        {
-            int n=list.size();
-            if(n<MAX_CHUNK_IN_QUEUE) break;
-            ADM_usleep(20*1000); // Fixme: replace by thread signals
-            if(threadState==RunStateStopOrder) goto theEnd;
-        }
-            
+      
+        mutex->lock();
+        list.push_back(pkt);
+        //printf("Pushing Packet with DTS=%"LLD",size=%d\n",dts,(int)size);
+        mutex->unlock();
     }
 
 theEnd:
-    delete [] buffer;
     return true;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h	2010-03-19 06:33:11 UTC (rev 6014)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h	2010-03-23 14:54:39 UTC (rev 6015)
@@ -24,7 +24,7 @@
 class ADM_videoFilterQueue : public ADM_coreVideoFilter,public ADM_threadQueue
 {
 protected:
-             ListOfQueuePacket freeList;
+           
 public:
                             ADM_videoFilterQueue(ADM_coreVideoFilter *son,CONFcouple *conf=NULL);
        virtual              ~ADM_videoFilterQueue();

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h	2010-03-19 06:33:11 UTC (rev 6014)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h	2010-03-23 14:54:39 UTC (rev 6015)
@@ -51,6 +51,7 @@
 {
   protected:
                 ListOfQueuePacket list;
+                ListOfQueuePacket freeList;
                 admMutex          *mutex;
                 admCond           *cond;
                 bool              started;



From mean at mail.berlios.de  Tue Mar 23 15:54:41 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 15:54:41 +0100
Subject: [Avidemux-svn-commit] r6016 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4
Message-ID: <201003231454.o2NEsfBL008839@sheep.berlios.de>

Author: mean
Date: 2010-03-23 15:54:41 +0100 (Tue, 23 Mar 2010)
New Revision: 6016

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
Log:
[MP4] If no ctts atom, dts=pts

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2010-03-23 14:54:39 UTC (rev 6015)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2010-03-23 14:54:41 UTC (rev 6016)
@@ -994,10 +994,15 @@
           if(info.Ctts)
           {
             updateCtts(&info);
+          }else 
+          {
+                // No ctts, dts=pts
+                for(int i=0;i<_videostream.dwLength;i++)
+                {
+                     _tracks[0].index[i].pts= _tracks[0].index[i].dts;
+                }
           }
-
-
-           VDEO.index[0].intra=AVI_KEY_FRAME;
+          VDEO.index[0].intra=AVI_KEY_FRAME;
         }
           break;
     case TRACK_AUDIO:



From mean at mail.berlios.de  Tue Mar 23 15:54:46 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 15:54:46 +0100
Subject: [Avidemux-svn-commit] r6017 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <201003231454.o2NEskih008875@sheep.berlios.de>

Author: mean
Date: 2010-03-23 15:54:45 +0100 (Tue, 23 Mar 2010)
New Revision: 6017

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
Log:
[Editor] Better PtsFromDts and DtsFromPts computation for mpeg2 style

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.cpp	2010-03-23 14:54:41 UTC (rev 6016)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.cpp	2010-03-23 14:54:45 UTC (rev 6017)
@@ -24,7 +24,71 @@
 #define GOT_NO_DTS 1
 #define GOT_NONE   3
 #define GOT_BOTH   0
+/* Specific cases */
+static bool setDtsFromPts(vidHeader *hdr,uint64_t timeIncrementUs,uint64_t *delay);
+static bool setPtsFromDts(vidHeader *hdr,uint64_t timeIncrementUs,uint64_t *delay);
+static bool updatePtsAndDts(vidHeader *hdr,uint64_t timeIncrementUs,uint64_t *delay);
 /**
+    \fn ADM_computeMissingPtsDts
+
+*/
+bool ADM_computeMP124MissingPtsDts(vidHeader *hdr,uint64_t timeIncrementUs,uint64_t *delay)
+{
+    aviInfo info;
+    uint32_t flags;
+    hdr->getVideoInfo(&info);
+    uint32_t nDts=0,nPts=0;
+    uint32_t nbB=0;
+    uint64_t pts,dts;
+    // Look how much bframes + how much valid PTS/DTS we have....
+    for(int i=0;i<info.nb_frames;i++)
+    {
+        hdr->getFlags(i,&flags);
+        if(flags & AVI_B_FRAME)
+                nbB++;
+        if(true!=hdr->getPtsDts(i,&pts,&dts))
+        {
+            goto next;
+        }
+        if(pts!=ADM_NO_PTS)
+            nPts++;
+        if(dts!=ADM_NO_PTS)
+            nDts++;
+    }
+next:
+        ADM_info("Out of %"LD" frames, we have %"LD" valid DTS and %"LD" valid PTS\n",info.nb_frames,nDts,nPts);
+        ADM_info("We also have %"LD" bframes\n",nbB);
+        // No b frames, PTS=DTS
+        if(!nbB)
+        {
+            delay=0;
+            return setPtsEqualDts(hdr,timeIncrementUs);
+        }
+        // Case 1 : We have both, nothing to do
+        if(nDts>=info.nb_frames-2 && nPts>=info.nb_frames-2)
+         {
+                ADM_info("Nothing to do\n");
+                *delay=0;
+                return true;
+         }
+        // Case 2: We have PTS but not DTS
+        if(nPts>=info.nb_frames-2 )
+        {
+            ADM_info("Got PTS, compute dts\n");
+            return setDtsFromPts(hdr,timeIncrementUs,delay);
+        }
+        // Case 3: We have DTS but not PTS
+        if(nDts>=info.nb_frames-2 )
+        {
+            ADM_info("Got DTS, compute  PTS\n");
+            return setPtsFromDts(hdr,timeIncrementUs,delay);
+        }
+        // Case 4: We have a bit of both
+        ADM_info("Get some dts and pts\n");
+        return updatePtsAndDts(hdr,timeIncrementUs,delay);
+}
+
+/**
     \fn setPtsEqualDts
     \brief for Low delay codec, set PTS=DTS, fill the missing values
 */
@@ -84,96 +148,121 @@
     return true;
 }
 /**
-    \fn setMpeg4PtsFromDts
+    \fn setDtsFromPts
     \brief For mpeg4 SP/ASP, recompute PTS DTS using the simple I/P/B frame reordering
     Works also for mpeg1/2
     It absolutely NEEDS to have the proper frame type set (PTS/DTS/...)
 */
-bool setMpeg4PtsFromDts(vidHeader *hdr,uint64_t timeIncrementUs)
+bool setPtsFromDts(vidHeader *hdr,uint64_t timeIncrementUs,uint64_t *delay)
 {
-    bool bframe=false;
+    int last=0;
+    int nbFrames;
+    int nbBframe=0;
+    int maxBframe=0;
+    uint32_t flags;
+    int nbB=0;
+    uint64_t pts,dts;
+
     aviInfo info;
-    uint32_t flags;
     hdr->getVideoInfo(&info);
-
-    uint64_t lastPts=ADM_NO_PTS;
-    uint64_t lastDts=ADM_NO_PTS;
-    // Scan to see if we have b-frames
-    for(int i=0;i<info.nb_frames;i++)
+    nbFrames=info.nb_frames;
+    for(int i=1;i<nbFrames;i++)
     {
         hdr->getFlags(i,&flags);
         if(flags & AVI_B_FRAME)
+                nbB++;
+        if(true!=hdr->getPtsDts(i,&pts,&dts))
         {
-            bframe=true;
-            break;
+                    ADM_warning("Cannot get PTS/DTS\n");
+                    return false;
         }
+        if(flags & AVI_B_FRAME) nbBframe++;
+        else        
+            {
+                if(nbBframe>maxBframe) maxBframe=nbBframe;
+                nbBframe=0;
+            }
     }
-    if(false==bframe)
+
+    for(int i=1;i<nbFrames;i++)
     {
-        ADM_info("No B frame found, settings PTS=DTS\n");
-        return setPtsEqualDts(hdr,timeIncrementUs);
+        hdr->getFlags(i,&flags);
+        hdr->getPtsDts(i,&pts,&dts);
+        if(flags & AVI_B_FRAME)
+        {
+            pts=dts;
+            hdr->setPtsDts(i,pts,dts);
+            nbBframe++;
+        }
+        else
+        {
+            uint64_t oldPts,oldDts;
+            uint64_t fwdPts,fwdDts;
+              hdr->getPtsDts(last,&oldPts,&oldDts);
+              hdr->getPtsDts(nbBframe+last+1,&fwdPts,&fwdDts);
+              oldPts=fwdDts;
+              hdr->setPtsDts(last,oldPts,oldDts);
+            nbBframe=0;
+            last=i;
+        }
     }
-#if 0
-    for(int i=0;i<info.nb_frames;i++)
+    return 1;
+}
+
+/**
+    \fn setDtsFromPts
+    \brief 
+*/
+bool setDtsFromPts(vidHeader *hdr,uint64_t timeIncrementUs,uint64_t *delay)
+{
+    *delay=0;
+    int last=0;
+    int nbFrames;
+    int nbBframe=0;
+    int maxBframe=0;
+    uint32_t flags;
+    int nbB=0;
+    uint64_t pts,dts;
+
+    aviInfo info;
+    hdr->getVideoInfo(&info);
+    nbFrames=info.nb_frames;
+    for(int i=1;i<nbFrames;i++)
     {
-        uint64_t pts,dts;
+        hdr->getFlags(i,&flags);
         if(true!=hdr->getPtsDts(i,&pts,&dts))
         {
-            printf("[Editor] GetPtsDts failed for frame %"LU"\n",i);
-            return false;
+                    ADM_warning("Cannot get PTS/DTS\n");
+                    return false;
         }
-        int k=0;
-        if(pts==ADM_NO_PTS) k+=GOT_NO_PTS;
-        if(dts==ADM_NO_PTS) k+=GOT_NO_DTS;
-        switch(k)
+        if(flags & AVI_B_FRAME)
         {
-            case GOT_BOTH : // Got both
-                    lastPts=pts;
-                    lastDts=dts;
-                continue;            
-                break;
-            case GOT_NONE: // Got none
-                {
-                        if(lastDts!=ADM_NO_PTS)
-                        {
-                            lastDts+=timeIncrementUs; // Say this one = previous + timeIncrement
-                            dts=lastDts;
-                        }else
-                            continue;   // We dont have a previous skip that one
-                }
-                break;
-            case GOT_NO_DTS :  // got only pts
-                        if(lastDts!=ADM_NO_PTS)
-                        {
-                            lastDts+=timeIncrementUs; // Say this one = previous + timeIncrement
-                            dts=lastDts;
-                        }else
-                            continue;   // We dont have a previous skip that one
-                        //
-                        ADM_assert(dts<=pts);
-                // Dts from PTS
-                break;
-            case GOT_NO_PTS: // got only dts
-                lastDts=dts;
-                {
-                    uint32_t flags;
-                    hdr->getFlags(i,&flags);
-                    if(flags & AVI_B_FRAME) pts=dts;
-                }
-                // Pts from DTS
-                break;
-            default:
-                ADM_assert(0);
-                break;
+                
+                nbB++;
+                dts=pts;
+                hdr->setPtsDts(i,pts,dts);
+                continue;
         }
-        ADM_assert(dts<=pts);
-        // update
-        if(true!=hdr->setPtsDts(i,pts,dts))
-        {
-            printf("[Editor] SetPtsDts failed for frame %"LU"\n",i);
-            return false;
-        }
+   
+        uint64_t oldPts,oldDts;
+        uint64_t fwdPts,fwdDts;
+          hdr->getPtsDts(last,&oldPts,&oldDts);
+          dts=oldPts;
+          hdr->setPtsDts(i,pts,dts);
+        nbBframe=0;
+        last=i;
     }
-#endif
+    return 1;
+}
+
+/**
+    \fn setPtsFromDts
+    \brief Fill in the missing PTS DTS. We got some but not all.
+*/
+bool updatePtsAndDts(vidHeader *hdr,uint64_t timeIncrementUs,uint64_t *delay)
+{
+    *delay=0;
+    ADM_error("SetPtsFromDts not implemented\n");
     return true;
 }
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.h	2010-03-23 14:54:41 UTC (rev 6016)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.h	2010-03-23 14:54:45 UTC (rev 6017)
@@ -20,6 +20,7 @@
 #include "ADM_Video.h"
 
 bool setPtsEqualDts(vidHeader *hdr,uint64_t timeIncrementUs);
-bool setMpeg4PtsFromDts(vidHeader *hdr,uint64_t timeIncrementUs);
+// Valid for mpeg1/2/4 SP type 
+bool ADM_computeMP124MissingPtsDts(vidHeader *hdr,uint64_t timeIncrementUs,uint64_t *delay);
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2010-03-23 14:54:41 UTC (rev 6016)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2010-03-23 14:54:45 UTC (rev 6017)
@@ -300,26 +300,24 @@
     {
         ADM_info("[Editor] no decoder to check for B- frame\n");
     }else
-    {
-       
-        if(video._aviheader->providePts()==false) // Else we rely on demuxer PTS
+    {       
+        ADM_info("[Editor] This container does not provide PTS \n");
+        if(video.decoder->bFramePossible())
         {
-            ADM_info("[Editor] This container does not provide PTS \n");
-            if(video.decoder->bFramePossible())
+            printf("[Editor] B- frame possible with that codec \n");
+            if(isMpeg4Compatible(info.fcc) || isMpeg12Compatible(info.fcc))
             {
-                printf("[Editor] B- frame possible with that codec \n");
-                if(isMpeg4Compatible(info.fcc) || isMpeg12Compatible(info.fcc))
-                {
-                    ADM_info("[Editor] It is mpeg4-SP/ASP, try to guess all PTS\n");                        
-                    setMpeg4PtsFromDts(video._aviheader,video.timeIncrementInUs);
-                }
+                ADM_info("[Editor] It is mpeg4-SP/ASP, try to guess all PTS\n");             
+                uint64_t delay;
+                ADM_computeMP124MissingPtsDts(video._aviheader,video.timeIncrementInUs,&delay);
+                _segments.updateRefVideo(&video);
             }
-            else   
-            {
-                    printf("[Editor] No B frame with that codec, PTS=DTS\n");
-                    setPtsEqualDts(video._aviheader,video.timeIncrementInUs);
-            }
         }
+        else   
+        {
+                printf("[Editor] No B frame with that codec, PTS=DTS\n");
+                setPtsEqualDts(video._aviheader,video.timeIncrementInUs);
+        }
      }
   
   return 1;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-03-23 14:54:41 UTC (rev 6016)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-03-23 14:54:45 UTC (rev 6017)
@@ -35,6 +35,30 @@
     deleteAll();
 }
 /**
+    \fn updateRefVideo
+    \brief Update start time
+*/
+bool        ADM_EditorSegment::updateRefVideo(_VIDEOS *ref)
+{
+    int n=videos.size();
+    ADM_assert(n);
+    vidHeader *demuxer=	ref->_aviheader;
+    vidHeader *demuxer2=	videos[n-1]._aviheader;
+    ADM_assert(demuxer==demuxer2);
+    
+    
+    uint64_t pts,dts;
+    
+        demuxer->getPtsDts(0,&pts,&dts);
+        if(pts!=ADM_NO_PTS )
+        {
+            ADM_warning("Updating firstFramePTS, The first frame has a PTS >0, adjusting to %"LLU" ms\n",pts/1000);
+            ref->firstFramePts=pts;
+        }
+    updateStartTime();
+    return true;
+}
+/**
     \fn addReferenceVideo
     \brief Add a new source video, fill in the missing info + create automatically the matching seg
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2010-03-23 14:54:41 UTC (rev 6016)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2010-03-23 14:54:45 UTC (rev 6017)
@@ -109,6 +109,7 @@
                         ~ADM_EditorSegment();
 
             bool        addReferenceVideo(_VIDEOS *ref);
+            bool        updateRefVideo(_VIDEOS *ref);
             bool        deleteAll(void);
 
             bool        resetSegment(void);



From mean at mail.berlios.de  Tue Mar 23 15:54:48 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 15:54:48 +0100
Subject: [Avidemux-svn-commit] r6018 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml
Message-ID: <201003231454.o2NEsmaW008885@sheep.berlios.de>

Author: mean
Date: 2010-03-23 15:54:47 +0100 (Tue, 23 Mar 2010)
New Revision: 6018

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp
Log:
[openDML] Better mpegReorder to get PTS/DTS, but dont use it as it is done by editor

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp	2010-03-23 14:54:45 UTC (rev 6017)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp	2010-03-23 14:54:47 UTC (rev 6018)
@@ -543,8 +543,9 @@
                 printf("\nOpenDML file successfully read..\n");
                 if(ret==1) 
                 {
+                    removeEmptyFrames();
                     computePtsDts();
-                    removeEmptyFrames();
+                    
                 }
                 return ret;
 }
@@ -596,13 +597,7 @@
        idx->dts=frameToUs(i);
     }
     _idx[0].pts=0;
-    // If it is mpeg4-SP compatible ?
-    // We can only call it here because the frames are marked as b frame!
-    if(isMpeg4Compatible(_videostream.fccHandler))
-    {
-        mpegReorder();
-    }   
-    return 1;
+  
 }
 /**
     \fn mpegReorder
@@ -612,17 +607,38 @@
 uint8_t OpenDMLHeader::mpegReorder(void)
 {
     int last=0;
+    int nbBframe=0;
+    int maxBframe=0;
     for(int i=1;i<_videostream.dwLength;i++)
     {
+        if(_idx[i].intra & AVI_B_FRAME) nbBframe++;
+        else        
+            {
+                if(nbBframe>maxBframe) maxBframe=nbBframe;
+                nbBframe=0;
+            }
+    }
+    ADM_info("Found max %d sequential bframes\n",maxBframe);
+    if(!maxBframe)
+    {
+        ADM_info("No b frame, pts=dts\n");
+        for(int i=1;i<_videostream.dwLength;i++)
+            _idx[i].pts=_idx[i].dts;
+        ptsAvailable=1;
+        return true;
+    }
+
+    for(int i=1;i<_videostream.dwLength;i++)
+    {
         if(_idx[i].intra & AVI_B_FRAME)
         {
-            _idx[i].pts=frameToUs(i-1);
-        }else
+            _idx[i].pts=_idx[i].dts;
+            nbBframe++;
+        }
+        else
         {
-            if(last)
-            {
-                _idx[last].pts=frameToUs(i-1);
-            }
+            _idx[last].pts=_idx[nbBframe+last+1].dts;
+            nbBframe=0;
             last=i;
         }
     }



From mean at mail.berlios.de  Tue Mar 23 15:54:49 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 15:54:49 +0100
Subject: [Avidemux-svn-commit] r6019 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreMuxer/src avidemux_plugins/ADM_muxers/muxerAvi
Message-ID: <201003231454.o2NEsn6S008895@sheep.berlios.de>

Author: mean
Date: 2010-03-23 15:54:49 +0100 (Tue, 23 Mar 2010)
New Revision: 6019

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp
Log:
[encoding] use out_quantizer everywhere

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-03-23 14:54:47 UTC (rev 6018)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-03-23 14:54:49 UTC (rev 6019)
@@ -414,7 +414,7 @@
             {
                 lastVideoDts=out.dts;
             }
-            encoding->pushVideoFrame(out.len,out.in_quantizer,lastVideoDts);
+            encoding->pushVideoFrame(out.len,out.out_quantizer,lastVideoDts);
             muxerRescaleVideoTimeDts(&(out.dts),lastVideoDts);
             muxerRescaleVideoTime(&(out.pts));
             aprintf("[FF:V] RawDts:%lu Scaled Dts:%lu\n",rawDts,out.dts);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp	2010-03-23 14:54:47 UTC (rev 6018)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/muxerAvi.cpp	2010-03-23 14:54:49 UTC (rev 6019)
@@ -174,7 +174,7 @@
                         result=false;
                         goto abt;
                 }
-                encoding->pushVideoFrame(in.len,in.in_quantizer,in.dts);
+                encoding->pushVideoFrame(in.len,in.out_quantizer,in.dts);
                 if(false==vStream->getPacket(&in)) goto abt;
                 if(in.dts==ADM_NO_PTS)
                 {



From mean at mail.berlios.de  Tue Mar 23 15:54:55 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 15:54:55 +0100
Subject: [Avidemux-svn-commit] r6021 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264
Message-ID: <201003231454.o2NEst0U008949@sheep.berlios.de>

Author: mean
Date: 2010-03-23 15:54:55 +0100 (Tue, 23 Mar 2010)
New Revision: 6021

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Dialog.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder_desc.cpp
Log:
[x264] Very very basic encoder support

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp	2010-03-23 14:54:51 UTC (rev 6020)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp	2010-03-23 14:54:55 UTC (rev 6021)
@@ -27,44 +27,56 @@
 #define aprintf printf
 #endif
 
-
+extern "C" 
+{
+static void        logger( void *cooki, int i_level, const char *psz, va_list list)
+{
+    static char buffer[2048];
+    vsnprintf(buffer,2048,psz,list);
+    printf(">>%s\n",buffer);
+}
+}
 #define MMSET(x) memset(&(x),0,sizeof(x))
 
-x264_encoder x264Settings;
-#if 0
-=
+x264_encoder x264Settings=
 {
     {
     COMPRESS_CQ, //COMPRESSION_MODE  mode;
-    2,              // uint32_t          qz;           /// Quantizer
+    15,              // uint32_t          qz;           /// Quantizer
     1500,           //uint32_t          bitrate;      /// In kb/s 
     700,            //uint32_t          finalsize;    /// In ?
     1500,           //uint32_t          avg_bitrate;  /// avg_bitrate is in kb/s!!
-    ADM_ENC_CAP_CBR+ADM_ENC_CAP_CQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_2PASS_BR+ADM_ENC_CAP_GLOBAL+ADM_ENC_CAP_SAME
+    ADM_ENC_CAP_CBR+ADM_ENC_CAP_CQ+0*COMPRESS_AQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_2PASS_BR+ADM_ENC_CAP_GLOBAL+ADM_ENC_CAP_SAME
     },
-            XVID_PROFILE_AS_L4, // Profile
-            3, // rdMode
-            3, // MotionEstimation
-            0, // cqmMode
-            0, // arMode
-            2, // MaxBframe
-            200, // MaxKeyInterval
-            
-            99, // nbThreads
-            true, // rdOnBframe
-            true, //bool:hqAcPred
-            true, //bool:optimizeChrome
-            true, // Trellis
+    2, // uint32_t MaxRefFrames;
+    20, //uint32_t MinIdr;
+    50, //uint32_t MaxIdr;
+    2,  // threads
+   true, //bool _8x8;
+   true, //bool _8x8P;
+   true, //bool _8x8B;
+   true, //bool _4x4;
+   true, //bool _8x8I;
+   true, //bool _4x4I;
+   2, //uint32_t MaxBFrame;
+   30, //uint32_t profile;
+   true, //bool CABAC;
+   true, //bool Trellis;     
     
 };
-#endif
 /**
         \fn x264Encoder
 */
 x264Encoder::x264Encoder(ADM_coreVideoFilter *src,bool globalHeader) : ADM_coreVideoEncoder(src)
 {
-    printf("[x264] Creating.\n");
+    ADM_info("[x264] Creating.\n");
     handle=NULL;
+    extraData=NULL;
+    extraDataLen=0;
+    seiUserDataLen=0;
+    seiUserData=NULL;
+    pic=NULL;
+    
 }
 /**
     \fn setup
@@ -72,13 +84,15 @@
 bool x264Encoder::setup(void)
 {
   ADM_info("x264, setting up");
+  image=new ADMImage(getWidth(),getHeight());
   MMSET(param);
-
-  param.i_threads = 2;
+  x264_param_default( &param);
+  param.pf_log=logger;
+  param.i_threads = x264Settings.threads;
   param.i_width = getWidth();
   param.i_height = getHeight();
   param.i_csp = X264_CSP_I420;
-
+ 
     //Framerate
     int n,d;    
     uint64_t f=source->getInfo()->frameIncrement;
@@ -107,8 +121,7 @@
   // BframeReduction ?
   // PartitionDecision ?
   MKPARAMF(rc.f_qcompress,BitrateVariability);
-  
-  param.i_frame_reference = 1;
+
   // update for Sadarax dialog
   MKPARAM(rc.i_vbv_max_bitrate,vbv_max_bitrate);
   MKPARAM(rc.i_vbv_buffer_size,vbv_buffer_size);
@@ -123,19 +136,24 @@
   MKPARAM(rc.i_qp_min,MinQp);
   MKPARAM(rc.i_qp_max,MaxQp);
   MKPARAM(rc.i_qp_step,QpStep);
-  MKPARAM(i_frame_reference,MaxRefFrames);
   MKPARAM(i_scenecut_threshold,SceneCut);
-  MKPARAM(i_keyint_min,MinIdr);
-  MKPARAM(i_keyint_max,MaxIdr);
-  MKPARAM(i_bframe,MaxBFrame);
   MKPARAM(i_bframe_bias,Bias);
   MKPARAM( b_bframe_pyramid,BasReference );
   MKPARAM(analyse. b_bidir_me,BidirME );
   MKPARAM( b_bframe_adaptive, Adaptative);
   MKPARAM( analyse.b_weighted_bipred, Weighted);
+  MKPARAM(analyse.i_subpel_refine,PartitionDecision+1);
+#endif
+  MKPARAM(i_frame_reference,MaxRefFrames);
+  
+  MKPARAM(i_keyint_min,MinIdr);
+  MKPARAM(i_keyint_max,MaxIdr);
+  MKPARAM(i_bframe,MaxBFrame);
+
   MKPARAM( b_cabac , CABAC);
   MKPARAM( analyse.i_trellis, Trellis);
-  MKPARAM(analyse.i_subpel_refine,PartitionDecision+1);
+
+#if 0  
 #define MIN_RDO 6
   if(zparam->PartitionDecision+1>=MIN_RDO)
   {
@@ -153,21 +171,25 @@
   
   MKPARAM(analyse.i_me_method,Method);
   MKPARAM(analyse.i_me_range,Range);
+  MKPARAM(i_bframe_bias,Bias);
+  MKPARAM( b_bframe_pyramid,BasReference );
+  MKPARAM(analyse. b_bidir_me,BidirME );
+  MKPARAM( b_bframe_adaptive, Adaptative);
+  MKPARAM( analyse.b_weighted_bipred, Weighted);
+#endif
 //  MKPARAM(PartitionDecision,Method);
   MKPARAM(analyse.b_transform_8x8,_8x8);
-  MKPARAM(analyse.b_mixed_references,MixedRefs);
-  MKPARAM(analyse.i_noise_reduction,NoiseReduction);
   
-#define MES(x,y) if(zparam->x) {param.analyse.inter |=X264_ANALYSE_##y;printf("[x264] "#x" is on\n");}
+#define MES(x,y) if(x264Settings.x) {param.analyse.inter |=X264_ANALYSE_##y;printf("[x264] "#x" is on\n");}
   param.analyse.inter=0;
   MES(  _8x8P,  PSUB16x16);
   MES(  _8x8B,  BSUB16x16);
   MES(  _4x4,   PSUB8x8);
   MES(  _8x8I,  I8x8);
   MES(  _4x4I,  I4x4);
-#endif
 
-  param.i_log_level=X264_LOG_INFO;
+
+  param.i_log_level=X264_LOG_DEBUG; //INFO;
  
   
   if(globalHeader)
@@ -182,14 +204,45 @@
     return 0;
   }
 
-  pic =  new    x264_picture_t;
+  pic=new x264_picture_t;
+  x264_picture_alloc( pic, X264_CSP_I420, getWidth(),getHeight());
   ADM_info("x264, setup ok\n");
   if (globalHeader)
     return createHeader ();
   return true;
 }
+/**
+    \fn encodeNals
+*/
+int x264Encoder::encodeNals(uint8_t *buf, int size, x264_nal_t *nals, int nalCount, bool skipSei)
+{
+    uint8_t *p = buf;
+    int i;
 
+    if (seiUserDataLen > 0 && nalCount > 0)
+        {
+        memcpy(p, seiUserData, seiUserDataLen);
+        p += seiUserDataLen;
+        seiUserDataLen = 0;
+    }
 
+    for (i = 0; i < nalCount; i++)
+        {
+        if (skipSei && nals[i].i_type == NAL_SEI)
+                {
+            seiUserDataLen = nals[i].i_payload;
+            seiUserData = new uint8_t[seiUserDataLen];
+            memcpy(seiUserData, nals[i].p_payload, nals[i].i_payload);
+            continue;
+        }
+
+        memcpy(p, nals[i].p_payload, nals[i].i_payload);
+        p += nals[i].i_payload;
+    }
+
+    return p - buf;
+}
+
 /**
         \fn createHeader
         \brief create esds header, needed for mp4/mov
@@ -201,108 +254,14 @@
 
 bool x264Encoder::createHeader (void)
 {
-#if 0
-  x264_nal_t *
-    nal;
-  int
-    nal_count;
-  uint32_t
-    offset = 0;;
-  uint8_t    buffer[MAX_HEADER_X264];
-  uint8_t    picParam[MAX_HEADER_X264];
-  uint8_t    seqParam[MAX_HEADER_X264];
-  uint8_t    sei[MAX_HEADER_X264];
-  int	     picParamLen = 0, seqParamLen = 0,seiParamLen=0, len;
-  int
-    sz;
 
-  // 1024 bytes should be enough
-  extraData = new uint8_t[MAX_HEADER_X264];
-  extraSize = 0;
+  x264_nal_t *nal;
+  int        nalCount;
 
-  x264_t *x264=(x264_t *)_handle;
-  //x264->i_frame=0; // force write_sei_params
-  if (x264_encoder_headers (x264, &nal, &nal_count))
-    {
-      printf ("[x264] Cannot create header\n");
-      return 0;
-    }
-  printf ("[x264] Nb nal: %d\n", nal_count);
+    extraDataLen = x264_encoder_headers(handle, &nal, &nalCount);
+    extraData = new uint8_t[extraDataLen];
+    extraDataLen = encodeNals(extraData, extraDataLen, nal, nalCount, true);
 
-  // Now encode them
-  for (int i = 0; i < nal_count; i++)
-    {
-	  switch(nal[i].i_type)
-	  {
-	  case H264_NAL_TYPE_SEQ_PARAM:
-		  	sz = x264_nal_encode (seqParam, &seqParamLen, 0, &nal[i]);
-		  	break;
-	  case H264_NAL_TYPE_PIC_PARAM:
-		  	sz = x264_nal_encode (picParam, &picParamLen, 0, &nal[i]);
-		  	break;
-	  case H264_NAL_TYPE_SEI:
-		  	sz = x264_nal_encode (sei, &seiParamLen, 0, &nal[i]);
-		  	break;
-	  default:
-		  printf ("[x264] ?? type %d in nal %d\n", nal[i].i_type, i);
-		  sz = x264_nal_encode (buffer, &len, 0, &nal[i]);
-	 }
-    if (sz <= 0)
-	{
-	  printf ("[x264] Cannot encode nal header %d\n", i);
-	  return 0;
-	}
-    }
-  // Now that we got all the nals encoded, time to build the avcC atom
-  // Check we have everything we want
-  if (!picParamLen || !seqParamLen)
-    {
-      printf ("[x264] Seqparam or PicParam not found\n");
-      return 0;
-    }
-
-
-
-  // Fill header
-  extraData[0] = 1;		// Version
-  extraData[1] = seqParam[1];	//0x42; // AVCProfileIndication
-  extraData[2] = seqParam[2];	//0x00; // profile_compatibility
-  extraData[3] = seqParam[3];	//0x0D; // AVCLevelIndication
-
-  extraData[4] = 0xFC + 3;	// lengthSizeMinusOne 
-  extraData[5] = 0xE0 + 1;	// nonReferenceDegredationPriorityLow        
-
-  offset = 6;
-
-
-
-  extraData[offset] = seqParamLen >> 8;
-  extraData[offset + 1] = seqParamLen & 0xff;
-  offset += 2;
-  memcpy (extraData + offset, seqParam, seqParamLen);
-  offset += seqParamLen;
-
-  
-  extraData[offset] = 1;	// numOfPictureParameterSets
-  offset++;
-  extraData[offset] = (picParamLen) >> 8;
-  extraData[offset + 1] = (picParamLen) & 0xff;
-  offset += 2;
-  memcpy (extraData + offset, picParam, picParamLen);
-  offset += picParamLen;
-
-  // Where x264 stores all its header, save it for later use
-  if(seiParamLen) 
-  {
-	  	_seiUserDataLen=seiParamLen;
-	  	_seiUserData=new uint8_t[_seiUserDataLen];
-	  	memcpy(_seiUserData,sei,_seiUserDataLen);
-  }
-
-  extraSize = offset;
-
-  ADM_assert (offset < MAX_HEADER_X264);
-#endif
   return 1;
 }
 /** 
@@ -319,17 +278,21 @@
     if (pic)
     {
       // picture_clean ?
-      delete	pic;
+      x264_picture_clean(pic);
+      delete pic;
       pic = NULL;
     }
-#if 0
-  if(_seiUserData)
+    if(extraData)
+    {
+        delete [] extraData;
+        extraData=NULL;
+    }
+
+  if(seiUserData)
   {
-	  delete [] _seiUserData;
-	  _seiUserData=NULL;
+	  delete [] seiUserData;
+	  seiUserData=NULL;
   }
-#endif
-   
 }
 
 /**
@@ -407,14 +370,12 @@
 {
       pic->img.i_csp = X264_CSP_I420;
       pic->img.i_plane = 3;
-
       pic->img.plane[0] = YPLANE(in);
       pic->img.plane[2] = UPLANE(in);
       pic->img.plane[1] = VPLANE(in);
       pic->img.i_stride[0] = getWidth();
       pic->img.i_stride[1] = getWidth()/2;
       pic->img.i_stride[2] = getWidth()/2;
-
       pic->i_type = X264_TYPE_AUTO;
       pic->i_pts = in->Pts;
   return 1;
@@ -425,78 +386,56 @@
 */
 bool x264Encoder::postAmble (ADMBitstream * out,uint32_t nbNals,x264_nal_t *nal,x264_picture_t *picout)
 {
+        int size = encodeNals(out->data, out->bufferSize, nal, nbNals, false);
 
-  uint32_t      size = 0, thisnal = 0;
-  uint8_t *     dout = out->data;
-  int           sizemax = 0;
+        if (size < 0)
+        {
+                ADM_error("[x264] Error encoding NALs\n");
+                return false;
+        }
+        out->len=size;
+        out->pts =  picout->i_pts+getEncoderDelay();	
+        switch (picout->i_type)
+        {
+        case X264_TYPE_IDR:
+          out->flags = AVI_KEY_FRAME;
+          /* First frame ?*/
 #if 0
-  for (uint32_t i = 0; i < nbNals; i++)
-    {
-      sizemax = 0xfffffff;;
-      if (!param.b_repeat_headers)
-    	  size += 4;
-      thisnal =	x264_nal_encode (dout + size, &sizemax, param.b_repeat_headers, &nal[i]);
-      if (!param.b_repeat_headers)
-      {			// Need to put size (assuming nal_size=4)
-    	  dout[size + 0 - 4] = (thisnal >> 24) & 0xff;
-    	  dout[size + 1 - 4] = (thisnal >> 16) & 0xff;
-    	  dout[size + 2 - 4] = (thisnal >> 8) & 0xff;
-    	  dout[size + 3 - 4] = (thisnal >> 0) & 0xff;
-      }
-      size += thisnal;
-    }
+          if(!param.b_repeat_headers && _seiUserData && !pic_out.i_pts)
+          {
+              // Put our SEI front...
+              // first a temp location...
+              uint8_t tmpBuffer[size];
+              memcpy(tmpBuffer,out->data,size);
+              // Put back out SEI and add Size
+              dout[0]=(_seiUserDataLen>>24)&0xff;
+              dout[1]=(_seiUserDataLen>>16)&0xff;
+              dout[2]=(_seiUserDataLen>>8)&0xff;
+              dout[3]=(_seiUserDataLen>>0)&0xff;
+              memcpy(dout+4,_seiUserData,_seiUserDataLen);
+              memcpy(dout+4+_seiUserDataLen,tmpBuffer,size);
+              size+=4+_seiUserDataLen;
+              out->len = size; // update total size
+          }
 #endif
-
-  out->len = size;
-  out->pts =  picout->i_pts+getEncoderDelay();	
-//    if(admParam.BasReference)
-//    {
-//  printf("%u +=%u\n",out->ptsFrame,admParam.MaxBFrame);
-//      out->ptsFrame+=admParam.MaxBFrame;
-//    }
-  //printf("Frame :%lld \n",pic_out.i_pts);
-  switch (picout->i_type)
-    {
-    case X264_TYPE_IDR:
-      out->flags = AVI_KEY_FRAME;
-      /* First frame ?*/
-#if 0
-      if(!param.b_repeat_headers && _seiUserData && !pic_out.i_pts)
-      {
-    	  // Put our SEI front...
-    	  // first a temp location...
-    	  uint8_t tmpBuffer[size];
-    	  memcpy(tmpBuffer,out->data,size);
-    	  // Put back out SEI and add Size
-    	  dout[0]=(_seiUserDataLen>>24)&0xff;
-    	  dout[1]=(_seiUserDataLen>>16)&0xff;
-    	  dout[2]=(_seiUserDataLen>>8)&0xff;
-    	  dout[3]=(_seiUserDataLen>>0)&0xff;
-    	  memcpy(dout+4,_seiUserData,_seiUserDataLen);
-    	  memcpy(dout+4+_seiUserDataLen,tmpBuffer,size);
-    	  size+=4+_seiUserDataLen;
-    	  out->len = size; // update total size
-      }
-#endif
-      break;
-    case X264_TYPE_I:
-      out->flags = AVI_P_FRAME;
-      break;
-    case X264_TYPE_P:
-      out->flags = AVI_P_FRAME;
-      break;
-    case X264_TYPE_B:
-    case X264_TYPE_BREF:
-      out->flags = AVI_B_FRAME;
-      break;
-    default:
-      printf ("[x264] Unknown image type: %d\n", picout->i_type);
-      //ADM_assert(0);
-    }
-    
-    //
-  out->out_quantizer = picout->i_qpplus1;
-  return 1;
+          break;
+        case X264_TYPE_I:
+          out->flags = AVI_P_FRAME;
+          break;
+        case X264_TYPE_P:
+          out->flags = AVI_P_FRAME;
+          break;
+        case X264_TYPE_B:
+        case X264_TYPE_BREF:
+          out->flags = AVI_B_FRAME;
+          break;
+        default:
+          ADM_error ("[x264] Unknown image type: %d\n", picout->i_type);
+          //ADM_assert(0);
+        }
+        out->out_quantizer = picout->i_qpplus1;
+        return true;
 }
+
 // EOF
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.h	2010-03-23 14:54:51 UTC (rev 6020)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.h	2010-03-23 14:54:55 UTC (rev 6021)
@@ -40,6 +40,11 @@
                bool            preAmble (ADMImage * in);
                bool            postAmble (ADMBitstream * out,uint32_t nbNals,x264_nal_t *nal,x264_picture_t *picout);
                bool            createHeader(void);
+               int             encodeNals(uint8_t *buf, int size, x264_nal_t *nals, int nalCount, bool skipSei);
+               uint32_t        extraDataLen;
+               uint8_t         *extraData;
+               uint32_t        seiUserDataLen;
+               uint8_t         *seiUserData ;
 
                
 public:
@@ -48,8 +53,8 @@
 virtual                    ~x264Encoder();
 virtual        bool        setup(void); 
 virtual        bool        encode (ADMBitstream * out);
-virtual const  char        *getFourcc(void) {return "X264";}
-
+virtual const  char        *getFourcc(void) {return "H264";}
+virtual        bool         getExtraData(uint32_t *l,uint8_t **d) {*l=extraDataLen;*d=extraData;return true;}
 virtual        bool         isDualPass(void) ;
 
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Dialog.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Dialog.cpp	2010-03-23 14:54:51 UTC (rev 6020)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Dialog.cpp	2010-03-23 14:54:55 UTC (rev 6021)
@@ -32,39 +32,8 @@
 extern x264_encoder x264Settings;
 bool         x264Configure(void)
 {         
-#if 0
-diaMenuEntry meE[]={
-  {0,QT_TR_NOOP("None")},
-  {1,QT_TR_NOOP("Low")},
-  {2,QT_TR_NOOP("Medium")},
-  {3,QT_TR_NOOP("Full")}
-};       
 
-diaMenuEntry qzE[]={
-  {0,QT_TR_NOOP("H.263")},
-  {1,QT_TR_NOOP("MPEG")},
-  {2,QT_TR_NOOP("Custom")}
-};      
-diaMenuEntry profileE[]={
-{ XVID_PROFILE_S_L0  ,"Simple Level0"},
-{ XVID_PROFILE_S_L1  ,"Simple Level1"},
-{ XVID_PROFILE_S_L2  ,"Simple Level2"},
-{ XVID_PROFILE_S_L3  ,"Simple Level3"},
-{ XVID_PROFILE_AS_L0 ,"Adv. Simple Level0"},
-{ XVID_PROFILE_AS_L1 ,"Adv. Simple Level1"},
-{ XVID_PROFILE_AS_L2 ,"Adv. Simple Level2"},
-{ XVID_PROFILE_AS_L3 ,"Adv. Simple Level3"},
-{ XVID_PROFILE_AS_L4 ,"Adv. Simple Level4"},
-}; 
 
-diaMenuEntry rdE[]={
-  {0,QT_TR_NOOP("None")},
-  {1,QT_TR_NOOP("DCT")},
-  {2,QT_TR_NOOP("Qpel16")},
-  {3,QT_TR_NOOP("Qpel8")},
-  {4,QT_TR_NOOP("Square")}
-};    
-
 diaMenuEntry threads[]={
   {1,QT_TR_NOOP("One thread")},
   {2,QT_TR_NOOP("Two threads)")},
@@ -73,37 +42,23 @@
 };     
 
 
-#define PX(x) &(xvid4Settings.x)
+#define PX(x) &(x264Settings.x)
 
-         diaElemBitrate   bitrate(&(xvid4Settings.params),NULL);
-         diaElemMenu      meM(PX(motionEstimation),QT_TR_NOOP("MotionEstimation"),4,meE);
+         diaElemBitrate   bitrate(&(x264Settings.params),NULL);
+         diaElemMenu      threadM(PX(threads),QT_TR_NOOP("Threading"),4,threads);
+         uint32_t trelBol=*PX(Trellis);
+         uint32_t cabacBol=*PX(CABAC);
 
-         diaElemMenu      threadM(PX(nbThreads),QT_TR_NOOP("Threading"),4,threads);
-/*
-         diaElemUInteger  qminM(PX(qmin),QT_TR_NOOP("Mi_n. quantizer:"),1,31);
-         diaElemUInteger  qmaxM(PX(qmax),QT_TR_NOOP("Ma_x. quantizer:"),1,31);
-         diaElemUInteger  qdiffM(PX(max_qdiff),QT_TR_NOOP("Max. quantizer _difference:"),1,31);
-*/
-         uint32_t trelBol=*PX(trellis);
          diaElemToggle    trellis(&trelBol,QT_TR_NOOP("_Trellis quantization"));         
-         diaElemUInteger  max_b_frames(PX(maxBFrame),QT_TR_NOOP("_Number of B frames:"),0,32);
+         diaElemToggle    cabac(&cabacBol,QT_TR_NOOP("Cabac encoding"));         
 
-         diaElemMenu     qzM(PX(cqmMode),QT_TR_NOOP("_Quantization type:"),2,qzE);
-         
-         diaElemMenu     rdM(PX(rdMode),QT_TR_NOOP("_Macroblock decision:"),5,rdE);
-
-         diaElemMenu     profileM(PX(profile),QT_TR_NOOP("Profile:"),9,profileE);
-         /*
-         diaElemUInteger filetol(PX(vratetol),QT_TR_NOOP("_Filesize tolerance (kb):"),0,100000);
-         
-         diaElemFloat    qzComp(PX(qcompress),QT_TR_NOOP("_Quantizer compression:"),0,1);
-         diaElemFloat    qzBlur(PX(qblur),QT_TR_NOOP("Quantizer _blur:"),0,1);
-         */
-        diaElemUInteger GopSize(PX(maxKeyFrameInterval),QT_TR_NOOP("_Gop Size:"),1,500); 
+         diaElemUInteger GopSize(PX(MaxIdr),QT_TR_NOOP("_Gop Size:"),1,500); 
+         diaElemUInteger max_b_frames(PX(MaxBFrame),QT_TR_NOOP("Max B Frames:"),0,5); 
           /* First Tab : encoding mode */
        
-        diaElemFrame frameMe(QT_TR_NOOP("Advanced Simple Profile"));
-        frameMe.swallow(&profileM);
+        
+         diaElemFrame frameMe(QT_TR_NOOP("Main"));
+        frameMe.swallow(&cabac);
         frameMe.swallow(&max_b_frames);
         frameMe.swallow(&GopSize);
         frameMe.swallow(&bitrate);
@@ -114,24 +69,20 @@
 
         /* 2nd Tab : Qz */
        
-         diaElem *diaQze[]={&qzM,&rdM,&meM,&trellis};
-        diaElemTabs tabQz(QT_TR_NOOP("Quantization"),4,diaQze);
+         diaElem *diaQze[]={&trellis};
+        diaElemTabs tabQz(QT_TR_NOOP("Quantization"),1,diaQze);
         
         /* 3th Tab : thread */
          diaElem *diaThread[]={&threadM};
          diaElemTabs tabThread(QT_TR_NOOP("Threads"),1,diaThread);
-        #if 0
-         diaElem *diaRC[]={&filetol,&qzComp,&qzBlur};
-        diaElemTabs tabRC(QT_TR_NOOP("Rate Control"),3,diaRC);
-        #endif
-         diaElemTabs *tabs[]={&tabME,&tabQz,&tabThread};
-        if( diaFactoryRunTabs(QT_TR_NOOP("Xvid4 MPEG-4 ASP configuration"),3,tabs))
+      
+        diaElemTabs *tabs[]={&tabME,&tabQz,&tabThread};
+        if( diaFactoryRunTabs(QT_TR_NOOP("X264 MPEG-4 AVC configuration"),3,tabs))
         {
-            *PX(trellis)= trelBol;
+            *PX(Trellis)= trelBol;
+            *PX(CABAC)= cabacBol;
             return true;
         }
 
          return false;
-#endif
-    return true;
 }
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder.conf	2010-03-23 14:54:51 UTC (rev 6020)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder.conf	2010-03-23 14:54:55 UTC (rev 6021)
@@ -1,13 +1,15 @@
 video_encode:params
+uint32_t:MaxRefFrames;
+uint32_t:MinIdr;
+uint32_t:MaxIdr;
+uint32_t:threads;
+bool:_8x8;
+bool:_8x8P;
+bool:_8x8B;
+bool:_4x4;
+bool:_8x8I;
+bool:_4x4I;
+uint32_t:MaxBFrame;
 uint32_t:profile
-uint32_t:rdMode
-uint32_t:motionEstimation
-uint32_t:cqmMode
-uint32_t:arMode
-uint32_t:maxBFrame
-uint32_t:maxKeyFrameInterval
-uint32_t:nbThreads
-bool:rdOnBFrame
-bool:hqAcPred
-bool:optimizeChrome
-bool:trellis
+bool:CABAC;
+bool:Trellis;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder.h	2010-03-23 14:54:51 UTC (rev 6020)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder.h	2010-03-23 14:54:55 UTC (rev 6021)
@@ -3,18 +3,20 @@
 #define ADM_x264_encoder_CONF_H
 typedef struct {
    COMPRES_PARAMS params;
+   uint32_t MaxRefFrames;
+   uint32_t MinIdr;
+   uint32_t MaxIdr;
+   uint32_t threads;
+   bool _8x8;
+   bool _8x8P;
+   bool _8x8B;
+   bool _4x4;
+   bool _8x8I;
+   bool _4x4I;
+   uint32_t MaxBFrame;
    uint32_t profile;
-   uint32_t rdMode;
-   uint32_t motionEstimation;
-   uint32_t cqmMode;
-   uint32_t arMode;
-   uint32_t maxBFrame;
-   uint32_t maxKeyFrameInterval;
-   uint32_t nbThreads;
-   bool rdOnBFrame;
-   bool hqAcPred;
-   bool optimizeChrome;
-   bool trellis;
+   bool CABAC;
+   bool Trellis;
 }x264_encoder;
 #endif //x264_encoder
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder_desc.cpp	2010-03-23 14:54:51 UTC (rev 6020)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/x264_encoder_desc.cpp	2010-03-23 14:54:55 UTC (rev 6021)
@@ -1,17 +1,19 @@
 // Automatically generated, do not edit!
 const ADM_paramList x264_encoder_param[]={
  {"params",offsetof( x264_encoder,params),"COMPRES_PARAMS",ADM_param_video_encode},
+ {"MaxRefFrames",offsetof( x264_encoder,MaxRefFrames),"uint32_t",ADM_param_uint32_t},
+ {"MinIdr",offsetof( x264_encoder,MinIdr),"uint32_t",ADM_param_uint32_t},
+ {"MaxIdr",offsetof( x264_encoder,MaxIdr),"uint32_t",ADM_param_uint32_t},
+ {"threads",offsetof( x264_encoder,threads),"uint32_t",ADM_param_uint32_t},
+ {"_8x8",offsetof( x264_encoder,_8x8),"bool",ADM_param_bool},
+ {"_8x8P",offsetof( x264_encoder,_8x8P),"bool",ADM_param_bool},
+ {"_8x8B",offsetof( x264_encoder,_8x8B),"bool",ADM_param_bool},
+ {"_4x4",offsetof( x264_encoder,_4x4),"bool",ADM_param_bool},
+ {"_8x8I",offsetof( x264_encoder,_8x8I),"bool",ADM_param_bool},
+ {"_4x4I",offsetof( x264_encoder,_4x4I),"bool",ADM_param_bool},
+ {"MaxBFrame",offsetof( x264_encoder,MaxBFrame),"uint32_t",ADM_param_uint32_t},
  {"profile",offsetof( x264_encoder,profile),"uint32_t",ADM_param_uint32_t},
- {"rdMode",offsetof( x264_encoder,rdMode),"uint32_t",ADM_param_uint32_t},
- {"motionEstimation",offsetof( x264_encoder,motionEstimation),"uint32_t",ADM_param_uint32_t},
- {"cqmMode",offsetof( x264_encoder,cqmMode),"uint32_t",ADM_param_uint32_t},
- {"arMode",offsetof( x264_encoder,arMode),"uint32_t",ADM_param_uint32_t},
- {"maxBFrame",offsetof( x264_encoder,maxBFrame),"uint32_t",ADM_param_uint32_t},
- {"maxKeyFrameInterval",offsetof( x264_encoder,maxKeyFrameInterval),"uint32_t",ADM_param_uint32_t},
- {"nbThreads",offsetof( x264_encoder,nbThreads),"uint32_t",ADM_param_uint32_t},
- {"rdOnBFrame",offsetof( x264_encoder,rdOnBFrame),"bool",ADM_param_bool},
- {"hqAcPred",offsetof( x264_encoder,hqAcPred),"bool",ADM_param_bool},
- {"optimizeChrome",offsetof( x264_encoder,optimizeChrome),"bool",ADM_param_bool},
- {"trellis",offsetof( x264_encoder,trellis),"bool",ADM_param_bool},
+ {"CABAC",offsetof( x264_encoder,CABAC),"bool",ADM_param_bool},
+ {"Trellis",offsetof( x264_encoder,Trellis),"bool",ADM_param_bool},
 {NULL,0,NULL}
 };



From mean at mail.berlios.de  Tue Mar 23 15:54:57 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 15:54:57 +0100
Subject: [Avidemux-svn-commit] r6022 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi
Message-ID: <201003231454.o2NEsv2Y008959@sheep.berlios.de>

Author: mean
Date: 2010-03-23 15:54:56 +0100 (Tue, 23 Mar 2010)
New Revision: 6022

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_aviwrite.cpp
Log:
[AviMuxer] Fill both fields with video codec

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_aviwrite.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_aviwrite.cpp	2010-03-23 14:54:55 UTC (rev 6021)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_aviwrite.cpp	2010-03-23 14:54:56 UTC (rev 6022)
@@ -1162,7 +1162,7 @@
 static void mx_streamHeaderFromVideo(AVIStreamHeader *header,ADM_videoStream *video)
 {
 	header->fccType=fourCC::get((uint8_t *)"vids");  //uint32_t	fccType;
-	header->fccType=video->getFCC(); //uint32_t	fccHandler;
+	header->fccHandler=video->getFCC(); //uint32_t	fccHandler;
 	header->dwFlags=0; //int32_t	dwFlags;	/* Contains AVITF_* flags */
 	header->wPriority=0; //int16_t	wPriority;	/* dwPriority - splited for audio */
 	header->wLanguage=0; //int16_t	wLanguage;



From mean at mail.berlios.de  Tue Mar 23 15:54:58 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 15:54:58 +0100
Subject: [Avidemux-svn-commit] r6023 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264
Message-ID: <201003231454.o2NEswn0008969@sheep.berlios.de>

Author: mean
Date: 2010-03-23 15:54:58 +0100 (Tue, 23 Mar 2010)
New Revision: 6023

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/CMakeLists.txt
Log:
[x264] better integration of a very simple x264 front end

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp	2010-03-23 14:54:56 UTC (rev 6022)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp	2010-03-23 14:54:58 UTC (rev 6023)
@@ -23,8 +23,10 @@
 
 #if 1
 #define aprintf(...) {}
+#define avsnprintf(...) {}
 #else
 #define aprintf printf
+#define avsnprintf vsnprintf
 #endif
 
 extern "C" 
@@ -32,8 +34,8 @@
 static void        logger( void *cooki, int i_level, const char *psz, va_list list)
 {
     static char buffer[2048];
-    vsnprintf(buffer,2048,psz,list);
-    printf(">>%s\n",buffer);
+    avsnprintf(buffer,2048,psz,list);
+    aprintf(">>%s\n",buffer);
 }
 }
 #define MMSET(x) memset(&(x),0,sizeof(x))
@@ -46,7 +48,13 @@
     1500,           //uint32_t          bitrate;      /// In kb/s 
     700,            //uint32_t          finalsize;    /// In ?
     1500,           //uint32_t          avg_bitrate;  /// avg_bitrate is in kb/s!!
-    ADM_ENC_CAP_CBR+ADM_ENC_CAP_CQ+0*COMPRESS_AQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_2PASS_BR+ADM_ENC_CAP_GLOBAL+ADM_ENC_CAP_SAME
+        ADM_ENC_CAP_CBR+
+        ADM_ENC_CAP_CQ+
+        ADM_ENC_CAP_AQ+
+        ADM_ENC_CAP_2PASS+
+        ADM_ENC_CAP_2PASS_BR+
+        ADM_ENC_CAP_GLOBAL+
+        ADM_ENC_CAP_SAME
     },
     2, // uint32_t MaxRefFrames;
     20, //uint32_t MinIdr;
@@ -75,142 +83,9 @@
     extraDataLen=0;
     seiUserDataLen=0;
     seiUserData=NULL;
-    pic=NULL;
-    
+    this->globalHeader=globalHeader;
 }
-/**
-    \fn setup
-*/
-bool x264Encoder::setup(void)
-{
-  ADM_info("x264, setting up");
-  image=new ADMImage(getWidth(),getHeight());
-  MMSET(param);
-  x264_param_default( &param);
-  param.pf_log=logger;
-  param.i_threads = x264Settings.threads;
-  param.i_width = getWidth();
-  param.i_height = getHeight();
-  param.i_csp = X264_CSP_I420;
- 
-    //Framerate
-    int n,d;    
-    uint64_t f=source->getInfo()->frameIncrement;
-    usSecondsToFrac(f,&n,&d);
-    param.i_fps_num = n;
-    param.i_fps_den = d;
 
-
-#define MKPARAM(x,y) {param.x = x264Settings.y;printf("[x264] "#x" = %d\n",param.x);}
-#define MKPARAMF(x,y) {param.x = (float)x264Settings.y / 100; printf("[x264] "#x" = %.2f\n",param.x);}
-
-#if 0
-  if (zparam->AR_AsInput) {
-    param.vui.i_sar_width = video_body->getPARWidth();
-    param.vui.i_sar_height = video_body->getPARHeight();
-  } else {
-    MKPARAM(vui.i_sar_width , AR_Num);	// FIXME
-    MKPARAM(vui.i_sar_height, AR_Den);
-  }
-  if(zparam->idc)
-  {
-    MKPARAM(i_level_idc,idc);
-    printf("[x264] *** Forcing level = %d\n",param.i_level_idc);
-  }
-  // KeyframeBoost ?
-  // BframeReduction ?
-  // PartitionDecision ?
-  MKPARAMF(rc.f_qcompress,BitrateVariability);
-
-  // update for Sadarax dialog
-  MKPARAM(rc.i_vbv_max_bitrate,vbv_max_bitrate);
-  MKPARAM(rc.i_vbv_buffer_size,vbv_buffer_size);
-  MKPARAMF(rc.f_vbv_buffer_init,vbv_buffer_init);
-  
-  MKPARAM (analyse.b_fast_pskip,fastPSkip);
-  MKPARAM (analyse.b_dct_decimate,DCTDecimate);
-  MKPARAM (b_interlaced,interlaced);
-      
-  //
-  MKPARAM(analyse.i_direct_mv_pred,DirectMode+1);
-  MKPARAM(rc.i_qp_min,MinQp);
-  MKPARAM(rc.i_qp_max,MaxQp);
-  MKPARAM(rc.i_qp_step,QpStep);
-  MKPARAM(i_scenecut_threshold,SceneCut);
-  MKPARAM(i_bframe_bias,Bias);
-  MKPARAM( b_bframe_pyramid,BasReference );
-  MKPARAM(analyse. b_bidir_me,BidirME );
-  MKPARAM( b_bframe_adaptive, Adaptative);
-  MKPARAM( analyse.b_weighted_bipred, Weighted);
-  MKPARAM(analyse.i_subpel_refine,PartitionDecision+1);
-#endif
-  MKPARAM(i_frame_reference,MaxRefFrames);
-  
-  MKPARAM(i_keyint_min,MinIdr);
-  MKPARAM(i_keyint_max,MaxIdr);
-  MKPARAM(i_bframe,MaxBFrame);
-
-  MKPARAM( b_cabac , CABAC);
-  MKPARAM( analyse.i_trellis, Trellis);
-
-#if 0  
-#define MIN_RDO 6
-  if(zparam->PartitionDecision+1>=MIN_RDO)
-  {
-      int rank,parity;
-      rank=((zparam->PartitionDecision+1-MIN_RDO)>>1)+MIN_RDO;
-      parity=(zparam->PartitionDecision+1-MIN_RDO)&1;
-      
-      param.analyse.i_subpel_refine=rank;
-      param.analyse.b_bframe_rdo=parity;
-  }
-  MKPARAM(analyse.b_chroma_me,ChromaME);
-  MKPARAM(b_deblocking_filter,DeblockingFilter);
-  MKPARAM(i_deblocking_filter_alphac0,Strength );
-  MKPARAM(i_deblocking_filter_beta, Threshold);
-  
-  MKPARAM(analyse.i_me_method,Method);
-  MKPARAM(analyse.i_me_range,Range);
-  MKPARAM(i_bframe_bias,Bias);
-  MKPARAM( b_bframe_pyramid,BasReference );
-  MKPARAM(analyse. b_bidir_me,BidirME );
-  MKPARAM( b_bframe_adaptive, Adaptative);
-  MKPARAM( analyse.b_weighted_bipred, Weighted);
-#endif
-//  MKPARAM(PartitionDecision,Method);
-  MKPARAM(analyse.b_transform_8x8,_8x8);
-  
-#define MES(x,y) if(x264Settings.x) {param.analyse.inter |=X264_ANALYSE_##y;printf("[x264] "#x" is on\n");}
-  param.analyse.inter=0;
-  MES(  _8x8P,  PSUB16x16);
-  MES(  _8x8B,  BSUB16x16);
-  MES(  _4x4,   PSUB8x8);
-  MES(  _8x8I,  I8x8);
-  MES(  _4x4I,  I4x4);
-
-
-  param.i_log_level=X264_LOG_DEBUG; //INFO;
- 
-  
-  if(globalHeader)
-      param.b_repeat_headers=0;
-  else
-      param.b_repeat_headers=1;
-
-  handle = x264_encoder_open (&param);
-  if (!handle)
-  {
-    ADM_error("Cannot initialize x264\n");
-    return 0;
-  }
-
-  pic=new x264_picture_t;
-  x264_picture_alloc( pic, X264_CSP_I420, getWidth(),getHeight());
-  ADM_info("x264, setup ok\n");
-  if (globalHeader)
-    return createHeader ();
-  return true;
-}
 /**
     \fn encodeNals
 */
@@ -275,13 +150,7 @@
       x264_encoder_close (handle);
       handle = NULL;
     }
-    if (pic)
-    {
-      // picture_clean ?
-      x264_picture_clean(pic);
-      delete pic;
-      pic = NULL;
-    }
+    
     if(extraData)
     {
         delete [] extraData;
@@ -309,16 +178,7 @@
         ADM_warning("[x264] Cannot get next image\n");
         return false;
     }
-#if 0
-    // Store Pts/DTS
-    ADM_timeMapping map; // Store real PTS <->lav value mapping
-    map.realTS=image->Pts+getEncoderDelay();
-    aprintf("Pushing fn=%d Time=%"LLU"\n",frameNum,map.realTS);
-   
-    map.internalTS=frameNum++;
-    mapper.push_back(map);
     queueOfDts.push_back(image->Pts);
-#endif
     // 2-preamble
     if(false==preAmble(image))
     {
@@ -326,22 +186,25 @@
         return false;
     }
     //
-      x264_nal_t *    nal;
-      int    nbNal = 0;
+      x264_nal_t        *nal;
+      int               nbNal = 0;
       x264_picture_t    pic_out;
 
       out->flags = 0;
       
-     
-      int er=x264_encoder_encode (handle, &nal, &nbNal, pic, &pic_out);
-      if(er<0)
+        int er=x264_encoder_encode (handle, &nal, &nbNal, &pic, &pic_out);
+        if(er<0)
         {
           ADM_error ("[x264] Error encoding %d\n",er);
           return false;
         }
+        if(!nbNal)
+        {
+            ADM_info("[x264] Null frame\n");
+            goto again;
+        }
 
 
-
     // 3-encode
     if(false==postAmble(out,nbNal,nal,&pic_out))
     {
@@ -368,17 +231,18 @@
 */
 bool  x264Encoder::preAmble (ADMImage * in)
 {
-      pic->img.i_csp = X264_CSP_I420;
-      pic->img.i_plane = 3;
-      pic->img.plane[0] = YPLANE(in);
-      pic->img.plane[2] = UPLANE(in);
-      pic->img.plane[1] = VPLANE(in);
-      pic->img.i_stride[0] = getWidth();
-      pic->img.i_stride[1] = getWidth()/2;
-      pic->img.i_stride[2] = getWidth()/2;
-      pic->i_type = X264_TYPE_AUTO;
-      pic->i_pts = in->Pts;
-  return 1;
+    MMSET(pic);
+      pic.img.i_csp = X264_CSP_I420;
+      pic.img.i_plane = 3;
+      pic.img.plane[0] = YPLANE(in);
+      pic.img.plane[2] = UPLANE(in);
+      pic.img.plane[1] = VPLANE(in);
+      pic.img.i_stride[0] = getWidth();
+      pic.img.i_stride[1] = getWidth()/2;
+      pic.img.i_stride[2] = getWidth()/2;
+      pic.i_type = X264_TYPE_AUTO;
+      pic.i_pts = in->Pts;
+  return true;
 }
 /**
     \fn postAmble
@@ -395,29 +259,31 @@
         }
         out->len=size;
         out->pts =  picout->i_pts+getEncoderDelay();	
+        out->dts=queueOfDts[0];
+        queueOfDts.erase(queueOfDts.begin());
         switch (picout->i_type)
         {
         case X264_TYPE_IDR:
           out->flags = AVI_KEY_FRAME;
-          /* First frame ?*/
-#if 0
-          if(!param.b_repeat_headers && _seiUserData && !pic_out.i_pts)
+          /* First Idr ?*/
+          if(!param.b_repeat_headers && seiUserData && firstIdr==true)
           {
               // Put our SEI front...
               // first a temp location...
+              firstIdr=false;
               uint8_t tmpBuffer[size];
               memcpy(tmpBuffer,out->data,size);
+              uint8_t *dout=out->data;
               // Put back out SEI and add Size
-              dout[0]=(_seiUserDataLen>>24)&0xff;
-              dout[1]=(_seiUserDataLen>>16)&0xff;
-              dout[2]=(_seiUserDataLen>>8)&0xff;
-              dout[3]=(_seiUserDataLen>>0)&0xff;
-              memcpy(dout+4,_seiUserData,_seiUserDataLen);
-              memcpy(dout+4+_seiUserDataLen,tmpBuffer,size);
-              size+=4+_seiUserDataLen;
+              dout[0]=(seiUserDataLen>>24)&0xff;
+              dout[1]=(seiUserDataLen>>16)&0xff;
+              dout[2]=(seiUserDataLen>>8)&0xff;
+              dout[3]=(seiUserDataLen>>0)&0xff;
+              memcpy(dout+4,seiUserData,seiUserDataLen);
+              memcpy(dout+4+seiUserDataLen,tmpBuffer,size);
+              size+=4+seiUserDataLen;
               out->len = size; // update total size
           }
-#endif
           break;
         case X264_TYPE_I:
           out->flags = AVI_P_FRAME;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.h	2010-03-23 14:54:56 UTC (rev 6022)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.h	2010-03-23 14:54:58 UTC (rev 6023)
@@ -34,7 +34,7 @@
 protected:
                x264_param_t     param;
                x264_t          *handle;
-               x264_picture_t  *pic;
+               x264_picture_t  pic;
                int             plane;
                bool            globalHeader;
                bool            preAmble (ADMImage * in);
@@ -45,6 +45,7 @@
                uint8_t         *extraData;
                uint32_t        seiUserDataLen;
                uint8_t         *seiUserData ;
+               bool            firstIdr;
 
                
 public:

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp	2010-03-23 14:54:56 UTC (rev 6022)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp	2010-03-23 14:54:58 UTC (rev 6023)
@@ -0,0 +1,326 @@
+/***************************************************************************
+                          \fn ADM_x264
+                          \brief Front end for x264 Mpeg4 asp encoder
+                             -------------------
+    
+    copyright            : (C) 2002/2009 by mean/gruntster
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_x264.h"
+#undef ADM_MINIMAL_UI_INTERFACE // we need the full UI
+#include "DIA_factory.h"
+#include "DIA_coreToolkit.h"
+#if 1
+#define aprintf(...) {}
+#define avsnprintf(...) {}
+#else
+#define aprintf printf
+#define avsnprintf vsnprintf
+#endif
+static void dumpx264Setup(x264_param_t *param);
+extern "C" 
+{
+static void        logger( void *cooki, int i_level, const char *psz, va_list list)
+{
+    static char buffer[2048];
+    avsnprintf(buffer,2048,psz,list);
+    aprintf(">>%s\n",buffer);
+}
+}
+#define MMSET(x) memset(&(x),0,sizeof(x))
+
+extern x264_encoder x264Settings;
+
+/**
+    \fn setup
+*/
+bool x264Encoder::setup(void)
+{
+  ADM_info("x264, setting up");
+  firstIdr=true;
+  image=new ADMImage(getWidth(),getHeight());
+  MMSET(param);
+  x264_param_default( &param);
+  param.pf_log=logger;
+  switch(x264Settings.threads)
+  {
+    case 0: case 1: case 2:  param.i_threads = x264Settings.threads;break;
+    case 99:break; //auto
+    default: ADM_error("UNKNOWN NB OF THREADS\n");break;
+  }
+  param.i_width = getWidth();
+  param.i_height = getHeight();
+  param.i_csp = X264_CSP_I420;
+ 
+    //Framerate
+    int n,d;    
+    uint64_t f=source->getInfo()->frameIncrement;
+    usSecondsToFrac(f,&n,&d);
+    param.i_fps_num = n;
+    param.i_fps_den = d;
+
+
+#define MKPARAM(x,y) {param.x = x264Settings.y;printf("[x264] "#x" = %d\n",param.x);}
+#define MKPARAMF(x,y) {param.x = (float)x264Settings.y / 100; printf("[x264] "#x" = %.2f\n",param.x);}
+
+#if 0
+  if (zparam->AR_AsInput) {
+    param.vui.i_sar_width = video_body->getPARWidth();
+    param.vui.i_sar_height = video_body->getPARHeight();
+  } else {
+    MKPARAM(vui.i_sar_width , AR_Num);	// FIXME
+    MKPARAM(vui.i_sar_height, AR_Den);
+  }
+  if(zparam->idc)
+  {
+    MKPARAM(i_level_idc,idc);
+    printf("[x264] *** Forcing level = %d\n",param.i_level_idc);
+  }
+  // KeyframeBoost ?
+  // BframeReduction ?
+  // PartitionDecision ?
+  MKPARAMF(rc.f_qcompress,BitrateVariability);
+
+  // update for Sadarax dialog
+  MKPARAM(rc.i_vbv_max_bitrate,vbv_max_bitrate);
+  MKPARAM(rc.i_vbv_buffer_size,vbv_buffer_size);
+  MKPARAMF(rc.f_vbv_buffer_init,vbv_buffer_init);
+  
+  MKPARAM (analyse.b_fast_pskip,fastPSkip);
+  MKPARAM (analyse.b_dct_decimate,DCTDecimate);
+  MKPARAM (b_interlaced,interlaced);
+      
+  //
+  MKPARAM(analyse.i_direct_mv_pred,DirectMode+1);
+  MKPARAM(rc.i_qp_min,MinQp);
+  MKPARAM(rc.i_qp_max,MaxQp);
+  MKPARAM(rc.i_qp_step,QpStep);
+  MKPARAM(i_scenecut_threshold,SceneCut);
+  MKPARAM(i_bframe_bias,Bias);
+  MKPARAM( b_bframe_pyramid,BasReference );
+  MKPARAM(analyse. b_bidir_me,BidirME );
+  MKPARAM( b_bframe_adaptive, Adaptative);
+  MKPARAM( analyse.b_weighted_bipred, Weighted);
+  MKPARAM(analyse.i_subpel_refine,PartitionDecision+1);
+#endif
+  MKPARAM(i_frame_reference,MaxRefFrames);
+  
+  MKPARAM(i_keyint_min,MinIdr);
+  MKPARAM(i_keyint_max,MaxIdr);
+  MKPARAM(i_bframe,MaxBFrame);
+
+  MKPARAM( b_cabac , CABAC);
+  MKPARAM( analyse.i_trellis, Trellis);
+
+#if 0  
+#define MIN_RDO 6
+  if(zparam->PartitionDecision+1>=MIN_RDO)
+  {
+      int rank,parity;
+      rank=((zparam->PartitionDecision+1-MIN_RDO)>>1)+MIN_RDO;
+      parity=(zparam->PartitionDecision+1-MIN_RDO)&1;
+      
+      param.analyse.i_subpel_refine=rank;
+      param.analyse.b_bframe_rdo=parity;
+  }
+  MKPARAM(analyse.b_chroma_me,ChromaME);
+  MKPARAM(b_deblocking_filter,DeblockingFilter);
+  MKPARAM(i_deblocking_filter_alphac0,Strength );
+  MKPARAM(i_deblocking_filter_beta, Threshold);
+  
+  MKPARAM(analyse.i_me_method,Method);
+  MKPARAM(analyse.i_me_range,Range);
+  MKPARAM(i_bframe_bias,Bias);
+  MKPARAM( b_bframe_pyramid,BasReference );
+  MKPARAM(analyse. b_bidir_me,BidirME );
+  MKPARAM( b_bframe_adaptive, Adaptative);
+  MKPARAM( analyse.b_weighted_bipred, Weighted);
+#endif
+//  MKPARAM(PartitionDecision,Method);
+  MKPARAM(analyse.b_transform_8x8,_8x8);
+  
+#define MES(x,y) if(x264Settings.x) {param.analyse.inter |=X264_ANALYSE_##y;printf("[x264] "#x" is on\n");}
+  param.analyse.inter=0;
+  MES(  _8x8P,  PSUB16x16);
+  MES(  _8x8B,  BSUB16x16);
+  MES(  _4x4,   PSUB8x8);
+  MES(  _8x8I,  I8x8);
+  MES(  _4x4I,  I4x4);
+
+
+  param.i_log_level=X264_LOG_INFO; //INFO;
+  
+  
+  switch(x264Settings.params.mode)
+  {
+      
+      case COMPRESS_AQ: param.rc.i_rc_method = X264_RC_CRF;
+                        param.rc.f_rf_constant = x264Settings.params.qz;
+                        break;
+      case COMPRESS_CQ: param.rc.i_rc_method = X264_RC_CQP;
+                        param.rc.i_qp_constant = x264Settings.params.qz;
+                        break;
+
+      case COMPRESS_CBR:
+                        param.rc.i_rc_method = X264_RC_ABR;
+                        param.rc.i_bitrate =  x264Settings.params.bitrate*1000;
+                        break;
+        default:
+                        GUI_Error_HIG("Not coded","this mode has notbeen implemented\n");
+                        return false;
+                        break;
+
+  }
+
+  if(globalHeader)
+      param.b_repeat_headers=0;
+  else
+      param.b_repeat_headers=1;
+  dumpx264Setup(&param);
+  handle = x264_encoder_open (&param);
+  if (!handle)
+  {
+    ADM_error("Cannot initialize x264\n");
+    return 0;
+  }
+
+  
+  ADM_info("x264, setup ok\n");
+  if (globalHeader)
+    return createHeader ();
+  return true;
+}
+/**
+    \fn dumpx264Setup
+*/
+void dumpx264Setup(x264_param_t *param)
+{
+#define PI(x) printf(#x"\t:%d\n",(int)param->x);
+    PI(cpu);
+    PI(i_threads);
+    PI(b_sliced_threads);
+    PI(b_deterministic);
+    PI(i_sync_lookahead);
+
+    PI(i_width); 
+    PI(i_height); 
+    PI(i_width); 
+    PI(i_level_idc); 
+    PI(i_frame_total);
+
+#define VI(x) printf(#x"\t:%d\n",(int)param->vui.x);
+
+    VI(i_sar_height);
+    VI(i_sar_width);
+    VI(i_overscan);
+    VI(i_vidformat);
+    VI(b_fullrange);
+    VI(i_colorprim);
+    VI(i_transfer);
+    VI(i_colmatrix);
+    VI(i_chroma_loc);
+
+    PI(i_fps_num);
+    PI(i_fps_den);
+        
+    PI(i_frame_reference);
+    PI(i_keyint_max);
+
+    PI(i_keyint_min);
+    PI(i_scenecut_threshold);
+
+    PI(i_bframe);
+    PI(i_bframe_adaptive);
+    PI(i_bframe_bias);
+    PI(i_bframe_pyramid);
+
+    PI(b_deblocking_filter);
+    PI(i_deblocking_filter_alphac0);
+    PI(i_deblocking_filter_beta);
+
+    PI(b_cabac);
+    PI(i_cabac_init_idc);
+
+    PI(b_interlaced);
+    PI(b_constrained_intra);
+
+#define AI(x) printf(#x"\t:%d\n",(int)param->analyse.x);
+    printf("*************************************\n");
+    printf("*********     Analyse       *********\n");
+    printf("*************************************\n");
+
+    AI(intra);
+    AI(inter);
+
+    AI(b_transform_8x8);
+    AI(i_weighted_pred);
+    AI(b_weighted_bipred);
+    AI(i_weighted_pred);
+    AI(i_chroma_qp_offset);
+    
+    AI(i_me_method);
+    AI(i_me_range);
+    AI(i_mv_range_thread);
+    AI(i_subpel_refine);
+    AI(b_chroma_me);
+    AI(b_mixed_references);
+    AI(i_trellis);
+    AI(b_fast_pskip);
+
+    AI(b_dct_decimate);
+    AI(i_noise_reduction);
+    AI(f_psy_rd);
+    AI(f_psy_trellis);
+    AI(b_psy);
+
+    PI(b_aud);
+    PI(b_repeat_headers);
+    PI(b_annexb);
+
+    PI(i_sps_id);
+
+    PI(i_slice_max_size);
+    PI(i_slice_max_mbs);
+    PI(i_slice_count);
+
+#define RI(x) printf(#x"\t:%d\n",(int)param->rc.x)
+#define RF(x) printf(#x"\t:%f\n",(float)param->rc.x)
+    printf("*************************************\n");
+    printf("*********     RC            *********\n");
+    printf("*************************************\n");
+    RI(i_rc_method);
+    RI(i_qp_constant);
+    RF(f_rf_constant);
+    RI(i_qp_min);
+    RI(i_qp_max);
+    RI(i_qp_step);
+
+
+    RI(i_bitrate);
+    RI(i_qp_constant);
+    RF(f_rate_tolerance);
+    RI(i_vbv_max_bitrate);
+    RI(i_vbv_buffer_size);
+    RF(f_vbv_buffer_init);
+    RF(f_ip_factor);
+    RF(f_pb_factor);
+
+    RI(i_aq_mode);
+    RF(f_aq_strength);
+    RI(b_mb_tree);
+    RI(i_lookahead);
+
+}
+// EOF
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/CMakeLists.txt	2010-03-23 14:54:56 UTC (rev 6022)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/CMakeLists.txt	2010-03-23 14:54:58 UTC (rev 6023)
@@ -5,6 +5,7 @@
         ADM_x264.cpp
         ADM_x264Plugin.cpp
         ADM_x264Dialog.cpp
+        ADM_x264Setup.cpp
 )
 include(admCheckX264)
 checkX264()



From mean at mail.berlios.de  Tue Mar 23 15:55:00 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 15:55:00 +0100
Subject: [Avidemux-svn-commit] r6024 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_audioFilter/src
	avidemux/common/ADM_videoFilter2/src
	avidemux_core/ADM_coreUtils/include avidemux_core/ADM_coreUtils/src
Message-ID: <201003231455.o2NEt0sl009011@sheep.berlios.de>

Author: mean
Date: 2010-03-23 15:55:00 +0100 (Tue, 23 Mar 2010)
New Revision: 6024

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp
Log:
[threads] Properly stop video/audio encoding thread

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp	2010-03-23 14:54:58 UTC (rev 6023)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_thread.cpp	2010-03-23 14:55:00 UTC (rev 6024)
@@ -51,8 +51,7 @@
 
 ADM_audioAccess_thread::~ADM_audioAccess_thread()
 {
-    ADM_info("Killing audio thread and son\n");
-   
+    stopThread();
     // Empty the list...
     int nb=list.size();
     for(int i=0;i<nb;i++)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2010-03-23 14:54:58 UTC (rev 6023)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2010-03-23 14:55:00 UTC (rev 6024)
@@ -39,7 +39,7 @@
 */
 ADM_videoFilterQueue::~ADM_videoFilterQueue()
 {
-        ADM_info("Destroying video threadQueue\n");
+        stopThread();
         int fCount;
         fCount=freeList.size();
         for(int j=0;j<fCount;j++)
@@ -49,7 +49,7 @@
         }
         freeList.clear();
         int count=list.size();
-        for(int j=0;j<fCount;j++)
+        for(int j=0;j<count;j++)
         {
             ADMImage *image=(ADMImage *)list[j].data;
             delete image;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h	2010-03-23 14:54:58 UTC (rev 6023)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_threadQueue.h	2010-03-23 14:55:00 UTC (rev 6024)
@@ -66,6 +66,7 @@
 protected:
         virtual bool                runAction(void)=0; 
                 bool                startThread(void);
+                bool                stopThread(void);
 };
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp	2010-03-23 14:54:58 UTC (rev 6023)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp	2010-03-23 14:55:00 UTC (rev 6024)
@@ -100,4 +100,30 @@
         started=true;
         return true;
 }
+
+/**
+    \fn stopThread
+*/
+bool ADM_threadQueue::stopThread(void)
+{
+        ADM_info("Destroying threadQueue\n");
+        int clockDown=10;
+        mutex->lock();
+        if(threadState==RunStateRunning)
+        {
+            threadState=RunStateStopOrder;
+            mutex->unlock();
+            while(threadState!=RunStateStopped && clockDown)
+            {
+                
+                ADM_usleep(50*1000);
+                clockDown--;
+            };
+            ADM_info("Thread stopped, continuing dtor\n");
+        }else   
+        {
+                mutex->unlock();
+        }
+        return true;
+}
 // EOF



From mean at mail.berlios.de  Tue Mar 23 15:55:02 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 15:55:02 +0100
Subject: [Avidemux-svn-commit] r6025 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264
Message-ID: <201003231455.o2NEt2eU009031@sheep.berlios.de>

Author: mean
Date: 2010-03-23 15:55:02 +0100 (Tue, 23 Mar 2010)
New Revision: 6025

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp
Log:
[x264] Slightly better CQ/CRF mode

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp	2010-03-23 14:55:00 UTC (rev 6024)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp	2010-03-23 14:55:02 UTC (rev 6025)
@@ -43,7 +43,7 @@
 x264_encoder x264Settings=
 {
     {
-    COMPRESS_CQ, //COMPRESSION_MODE  mode;
+    COMPRESS_AQ, //COMPRESSION_MODE  mode;
     15,              // uint32_t          qz;           /// Quantizer
     1500,           //uint32_t          bitrate;      /// In kb/s 
     700,            //uint32_t          finalsize;    /// In ?
@@ -51,15 +51,15 @@
         ADM_ENC_CAP_CBR+
         ADM_ENC_CAP_CQ+
         ADM_ENC_CAP_AQ+
-        ADM_ENC_CAP_2PASS+
-        ADM_ENC_CAP_2PASS_BR+
+        0*ADM_ENC_CAP_2PASS+
+        0*ADM_ENC_CAP_2PASS_BR+
         ADM_ENC_CAP_GLOBAL+
-        ADM_ENC_CAP_SAME
+        0*ADM_ENC_CAP_SAME
     },
     2, // uint32_t MaxRefFrames;
-    20, //uint32_t MinIdr;
-    50, //uint32_t MaxIdr;
-    2,  // threads
+    10, //uint32_t MinIdr;
+    150, //uint32_t MaxIdr;
+    99,  // threads (auto)
    true, //bool _8x8;
    true, //bool _8x8P;
    true, //bool _8x8B;
@@ -68,8 +68,8 @@
    true, //bool _4x4I;
    2, //uint32_t MaxBFrame;
    30, //uint32_t profile;
-   true, //bool CABAC;
-   true, //bool Trellis;     
+   false, //bool CABAC;
+   false, //bool Trellis;     
     
 };
 /**
@@ -99,6 +99,8 @@
         memcpy(p, seiUserData, seiUserDataLen);
         p += seiUserDataLen;
         seiUserDataLen = 0;
+        delete [] seiUserData;
+        seiUserData=NULL;
     }
 
     for (i = 0; i < nalCount; i++)
@@ -261,6 +263,8 @@
         out->pts =  picout->i_pts+getEncoderDelay();	
         out->dts=queueOfDts[0];
         queueOfDts.erase(queueOfDts.begin());
+        aprintf("pts = %"LLU", dts=%"LLU", pts+delay=%"LLU" delta=%"LLU"\n",picout->i_pts,out->dts,out->pts,
+                    out->pts-out->dts);
         switch (picout->i_type)
         {
         case X264_TYPE_IDR:

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp	2010-03-23 14:55:00 UTC (rev 6024)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp	2010-03-23 14:55:02 UTC (rev 6025)
@@ -48,6 +48,7 @@
 bool x264Encoder::setup(void)
 {
   ADM_info("x264, setting up");
+  
   firstIdr=true;
   image=new ADMImage(getWidth(),getHeight());
   MMSET(param);
@@ -69,8 +70,8 @@
     usSecondsToFrac(f,&n,&d);
     param.i_fps_num = n;
     param.i_fps_den = d;
+    encoderDelay=f*x264Settings.MaxBFrame;
 
-
 #define MKPARAM(x,y) {param.x = x264Settings.y;printf("[x264] "#x" = %d\n",param.x);}
 #define MKPARAMF(x,y) {param.x = (float)x264Settings.y / 100; printf("[x264] "#x" = %.2f\n",param.x);}
 



From mean at mail.berlios.de  Tue Mar 23 19:28:19 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 19:28:19 +0100
Subject: [Avidemux-svn-commit] r6026 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264
Message-ID: <201003231828.o2NISJF9011139@sheep.berlios.de>

Author: mean
Date: 2010-03-23 19:28:18 +0100 (Tue, 23 Mar 2010)
New Revision: 6026

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp
Log:
[x264] Change default, CRF=20 + cabac on + trellis on

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp	2010-03-23 14:55:02 UTC (rev 6025)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264.cpp	2010-03-23 18:28:18 UTC (rev 6026)
@@ -44,7 +44,7 @@
 {
     {
     COMPRESS_AQ, //COMPRESSION_MODE  mode;
-    15,              // uint32_t          qz;           /// Quantizer
+    20,              // uint32_t          qz;           /// Quantizer
     1500,           //uint32_t          bitrate;      /// In kb/s 
     700,            //uint32_t          finalsize;    /// In ?
     1500,           //uint32_t          avg_bitrate;  /// avg_bitrate is in kb/s!!
@@ -68,8 +68,8 @@
    true, //bool _4x4I;
    2, //uint32_t MaxBFrame;
    30, //uint32_t profile;
-   false, //bool CABAC;
-   false, //bool Trellis;     
+   true, //bool CABAC;
+   true, //bool Trellis;     
     
 };
 /**



From mean at mail.berlios.de  Tue Mar 23 19:28:21 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Mar 2010 19:28:21 +0100
Subject: [Avidemux-svn-commit] r6027 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src
Message-ID: <201003231828.o2NISLPe011183@sheep.berlios.de>

Author: mean
Date: 2010-03-23 19:28:21 +0100 (Tue, 23 Mar 2010)
New Revision: 6027

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp
Log:
[threadQueue] Avoid deadlock when killing the thread

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp	2010-03-23 18:28:18 UTC (rev 6026)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_threadQueue.cpp	2010-03-23 18:28:21 UTC (rev 6027)
@@ -112,6 +112,11 @@
         if(threadState==RunStateRunning)
         {
             threadState=RunStateStopOrder;
+            if(cond->iswaiting())
+            {
+                cond->wakeup();
+            }
+        
             mutex->unlock();
             while(threadState!=RunStateStopped && clockDown)
             {



From gruntster at mail.berlios.de  Sat Mar 27 22:04:55 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 27 Mar 2010 22:04:55 +0100
Subject: [Avidemux-svn-commit] r6028 - in
	branches/avidemux_2.5_branch_gruntster/cmake: . patches
Message-ID: <201003272104.o2RL4tLN001251@sheep.berlios.de>

Author: gruntster
Date: 2010-03-27 22:04:46 +0100 (Sat, 27 Mar 2010)
New Revision: 6028

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo_enc.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_file.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch
Log:
[ffmpeg] update FFmpeg to r22703 & libswscale to r30970

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,7 +1,7 @@
 include(admFFmpegUtil)
 
-set(FFMPEG_VERSION 22111)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=35b04ac6a5ed6d7e4c7db1945dae4d061ca5000b;sf=tgz
-set(SWSCALE_VERSION 30800)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=9f92a66140e3ecd928be9f3359a4560c491c5047;sf=tgz
+set(FFMPEG_VERSION 22703)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=bb116bdcfc2d1059af8475e861c6998c688cb55b;sf=tgz
+set(SWSCALE_VERSION 30970)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=efc190382dc560b47ab559ff6ecdce77dbc0c1e7;sf=tgz
 
 set(LIBRARY_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries")
 set(FFMPEG_SOURCE_DIR "${LIBRARY_SOURCE_DIR}/ffmpeg")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,19 +1,19 @@
-*** libavcodec/avcodec.h.old	Sun Feb 28 18:41:01 2010
---- libavcodec/avcodec.h	Sun Feb 28 18:41:01 2010
+*** libavcodec/avcodec.h.old	Sat Mar 27 20:05:32 2010
+--- libavcodec/avcodec.h	Sat Mar 27 20:05:32 2010
 ***************
-*** 589,594 ****
---- 589,596 ----
-  #define CODEC_FLAG2_NON_LINEAR_QUANT 0x00010000 ///< Use MPEG-2 nonlinear quantizer.
-  #define CODEC_FLAG2_BIT_RESERVOIR 0x00020000 ///< Use a bit reservoir when encoding if possible
+*** 594,599 ****
+--- 594,601 ----
   #define CODEC_FLAG2_MBTREE        0x00040000 ///< Use macroblock tree ratecontrol (x264 only)
+  #define CODEC_FLAG2_PSY           0x00080000 ///< Use psycho visual optimizations.
+  #define CODEC_FLAG2_SSIM          0x00100000 ///< Compute SSIM during encoding, error[] values are undefined.
 + //MEANX: NEVER EVER USE CLOSED GOP ?
 + #define CODEC_FLAG2_32_PULLDOWN   0x80000000
   
   /* Unsupported options :
    *              Syntax Arithmetic coding (SAC)
 ***************
-*** 1458,1463 ****
---- 1460,1466 ----
+*** 1464,1469 ****
+--- 1466,1472 ----
        * - decoding: unused
        */
       int rc_max_rate;
@@ -22,8 +22,8 @@
       /**
        * minimum bitrate
 ***************
-*** 1472,1477 ****
---- 1475,1482 ----
+*** 1478,1483 ****
+--- 1481,1488 ----
        * - decoding: unused
        */
       int rc_buffer_size;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,8 +1,8 @@
-*** libavcodec/ffv1.c.old	Thu Aug 27 21:15:58 2009
---- libavcodec/ffv1.c	Thu Aug 27 21:15:58 2009
+*** libavcodec/ffv1.c.old	Sat Mar 27 20:05:33 2010
+--- libavcodec/ffv1.c	Sat Mar 27 20:05:33 2010
 ***************
-*** 1071,1076 ****
---- 1071,1078 ----
+*** 1070,1075 ****
+--- 1070,1077 ----
           clear_state(f);
       }else{
           p->key_frame= 0;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,12 +1,14 @@
-*** libavcodec/h263dec.c.old	Sun Jan 17 19:05:15 2010
---- libavcodec/h263dec.c	Sun Jan 17 19:05:15 2010
+*** libavcodec/h263dec.c.old	Sat Mar 27 20:05:34 2010
+--- libavcodec/h263dec.c	Sat Mar 27 20:05:34 2010
 ***************
 *** 119,124 ****
---- 119,141 ----
+--- 119,143 ----
   
       return 0;
   }
 + /* MeanX : Ugly patch to detect vo ppacked stuff ... */
++ int av_is_voppacked(AVCodecContext *avctx, int *vop_packed, int *gmc, int *qpel);
++ 
 + int av_is_voppacked(AVCodecContext *avctx, int *vop_packed, int *gmc, int *qpel)
 + {
 +     MpegEncContext *s = avctx->priv_data;
@@ -28,7 +30,7 @@
   {
 ***************
 *** 414,419 ****
---- 431,442 ----
+--- 433,444 ----
       } else {
           ret = h263_decode_picture_header(s);
       }
@@ -43,7 +45,7 @@
   
 ***************
 *** 707,712 ****
---- 730,743 ----
+--- 732,745 ----
   
   assert(s->current_picture.pict_type == s->current_picture_ptr->pict_type);
   assert(s->current_picture.pict_type == s->pict_type);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,12 +1,14 @@
-*** libavcodec/h264.c.old	Sun Feb 28 18:41:04 2010
---- libavcodec/h264.c	Sun Feb 28 18:41:04 2010
+*** libavcodec/h264.c.old	Sat Mar 27 20:05:35 2010
+--- libavcodec/h264.c	Sat Mar 27 20:05:35 2010
 ***************
-*** 3117,3122 ****
---- 3117,3133 ----
+*** 3116,3121 ****
+--- 3116,3134 ----
       return 0;
   }
   
 + /* MEANX */
++ int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc);
++ 
 + int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc)
 + {
 +       H264Context *h = avctx->priv_data;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,8 +1,8 @@
-*** libavcodec/mpeg12.c.old	Sat Dec 19 22:15:50 2009
---- libavcodec/mpeg12.c	Sat Dec 19 22:15:50 2009
+*** libavcodec/mpeg12.c.old	Sat Mar 27 20:05:36 2010
+--- libavcodec/mpeg12.c	Sat Mar 27 20:05:36 2010
 ***************
-*** 1946,1951 ****
---- 1946,1956 ----
+*** 1948,1953 ****
+--- 1948,1958 ----
           ff_er_frame_end(s);
   
           MPV_frame_end(s);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,7 +1,7 @@
-*** libavcodec/mpegvideo.c.old	Sat Jan 23 11:31:10 2010
---- libavcodec/mpegvideo.c	Sat Jan 23 11:31:10 2010
+*** libavcodec/mpegvideo.c.old	Sat Mar 27 20:05:38 2010
+--- libavcodec/mpegvideo.c	Sat Mar 27 20:05:39 2010
 ***************
-*** 614,620 ****
+*** 646,652 ****
       FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
   
       s->parse_context.state= -1;
@@ -9,7 +9,7 @@
          s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
          s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
          s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
---- 614,624 ----
+--- 646,656 ----
       FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
   
       s->parse_context.state= -1;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo_enc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo_enc.c.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo_enc.c.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,8 +1,8 @@
-*** libavcodec/mpegvideo_enc.c.old	Sun Jan 17 19:05:25 2010
---- libavcodec/mpegvideo_enc.c	Sun Jan 17 19:05:25 2010
+*** libavcodec/mpegvideo_enc.c.old	Sat Mar 27 20:05:40 2010
+--- libavcodec/mpegvideo_enc.c	Sat Mar 27 20:05:40 2010
 ***************
-*** 366,377 ****
---- 366,379 ----
+*** 367,378 ****
+--- 367,380 ----
   
           av_log(avctx, AV_LOG_INFO, "Warning vbv_delay will be set to 0xFFFF (=VBR) as the specified vbv buffer is too large for the given bitrate!\n");
       }
@@ -18,8 +18,8 @@
       if(s->obmc && s->avctx->mb_decision != FF_MB_DECISION_SIMPLE){
           av_log(avctx, AV_LOG_ERROR, "OBMC is only supported with simple mb decision\n");
 ***************
-*** 412,421 ****
---- 414,425 ----
+*** 413,422 ****
+--- 415,426 ----
           return -1;
       }
   

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,8 +1,8 @@
-*** libavcodec/utils.c.old	Sun Feb 28 18:41:09 2010
---- libavcodec/utils.c	Sun Feb 28 18:41:09 2010
+*** libavcodec/utils.c.old	Sat Mar 27 20:05:41 2010
+--- libavcodec/utils.c	Sat Mar 27 20:05:41 2010
 ***************
-*** 637,646 ****
---- 637,648 ----
+*** 638,647 ****
+--- 638,649 ----
   
       if((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size){
           //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
@@ -16,7 +16,7 @@
           *frame_size_ptr < avctx->channels * avctx->frame_size * sizeof(int16_t)){
               av_log(avctx, AV_LOG_ERROR, "buffer %d too small\n", *frame_size_ptr);
 ***************
-*** 1079,1085 ****
+*** 1080,1086 ****
           return -1;
       }
   #if !HAVE_MKSTEMP
@@ -24,7 +24,7 @@
   #else
       snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
       fd = mkstemp(*filename);
---- 1081,1087 ----
+--- 1082,1088 ----
           return -1;
       }
   #if !HAVE_MKSTEMP

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_file.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_file.c.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_file.c.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,8 +1,8 @@
-*** libavformat/file.c.old	Mon Feb  2 19:49:57 2009
---- libavformat/file.c	Mon Feb  2 19:49:56 2009
+*** libavformat/file.c.old	Sat Mar 27 20:05:42 2010
+--- libavformat/file.c	Sat Mar 27 20:05:42 2010
 ***************
 *** 30,35 ****
---- 30,101 ----
+--- 30,104 ----
   #include <stdlib.h>
   #include "os_support.h"
   
@@ -10,6 +10,9 @@
 + #ifdef __WIN32
 + #include <windows.h>
 + 
++ int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString);
++ int ADM_open(const char *path, int oflag, ...);
++ 
 + int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString)
 + {
 + 	int wideCharStringLength = MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, NULL, 0);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,5 +1,5 @@
-*** libavformat/flvenc.c.old	Tue Nov 24 18:58:08 2009
---- libavformat/flvenc.c	Tue Nov 24 18:58:08 2009
+*** libavformat/flvenc.c.old	Sat Mar 27 20:05:43 2010
+--- libavformat/flvenc.c	Sat Mar 27 20:05:43 2010
 ***************
 *** 406,412 ****
       "video/x-flv",
@@ -20,11 +20,13 @@
       CODEC_ID_ADPCM_SWF,
 ***************
 *** 418,420 ****
---- 419,427 ----
+--- 419,429 ----
       .codec_tag= (const AVCodecTag* const []){flv_video_codec_ids, flv_audio_codec_ids, 0},
       .flags= AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
   };
 + // MEANX
++ int flvenc_init(void);
++ 
 + int flvenc_init(void)
 + {
 +     av_register_output_format(&flv_muxer);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,8 +1,8 @@
-*** libavformat/matroskaenc.c.old	Sat Jan 23 11:31:16 2010
---- libavformat/matroskaenc.c	Sat Jan 23 11:31:16 2010
+*** libavformat/matroskaenc.c.old	Sat Mar 27 20:05:45 2010
+--- libavformat/matroskaenc.c	Sat Mar 27 20:05:45 2010
 ***************
-*** 395,400 ****
---- 395,401 ----
+*** 403,408 ****
+--- 403,409 ----
   
   static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec)
   {
@@ -11,8 +11,8 @@
       int header_len[3];
       int first_header_size;
 ***************
-*** 419,424 ****
---- 420,447 ----
+*** 427,432 ****
+--- 428,455 ----
           put_buffer(pb, header_start[j], header_len[j]);
   
       return 0;
@@ -42,46 +42,45 @@
   
   static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
 ***************
-*** 536,541 ****
---- 559,583 ----
+*** 546,551 ****
+--- 569,592 ----
           put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
           put_ebml_float(pb, MATROSKA_ID_TRACKTIMECODESCALE, 1.0);
   
-+ 		/**  MEANX : Add a default duration for video **/
-+ 		if(codec->codec_type==CODEC_TYPE_VIDEO)
-+ 		{
-+ 			if(codec->time_base.den && codec->time_base.num)
-+ 			{
-+ 				int num = codec->time_base.num;
-+ 				int den = codec->time_base.den;
-+ 				unsigned int default_duration;
-+ 				float period = num;
++  		/**  MEANX : Add a default duration for video **/
++  		if(codec->codec_type==CODEC_TYPE_VIDEO)
++  		{
++  			if(codec->time_base.den && codec->time_base.num)
++  			{
++  				int num = codec->time_base.num;
++  				int den = codec->time_base.den;
++  				unsigned int default_duration;
++  				float period = num;
++  
++  				period /= den;
++  				period *= 1000*1000*1000; // in ns
++  				default_duration = (unsigned int)floor(period);
++  				put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, default_duration);
++  			}
++  		}
++  		/**  MEANX : Add a default duration for video **/
 + 
-+ 				period /= den;
-+ 				period *= 1000*1000*1000; // in ns
-+ 				default_duration = (unsigned int)floor(period);
-+ 				put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, default_duration);
-+ 			}
-+ 		}
-+ 
-+ 		/**  MEANX : Add a default duration for video **/
-+ 
-          if ((tag = av_metadata_get(st->metadata, "description", NULL, 0)))
+          if ((tag = av_metadata_get(st->metadata, "title", NULL, 0)))
               put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value);
           tag = av_metadata_get(st->metadata, "language", NULL, 0);
 ***************
-*** 955,957 ****
---- 997,1009 ----
+*** 1004,1006 ****
+--- 1045,1057 ----
       .flags = AVFMT_GLOBALHEADER,
       .codec_tag = (const AVCodecTag* const []){ff_codec_wav_tags, 0},
   };
 + // MEANX
 + //
++ int matroskaenc_init(void);
++ 
 + int matroskaenc_init(void)
 + {
 +     av_register_output_format(&matroska_muxer);
 +     return 0;
 + }
 + // /MEANX
-+ 
-+ 

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch	2010-03-23 18:28:21 UTC (rev 6027)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch	2010-03-27 21:04:46 UTC (rev 6028)
@@ -1,12 +1,14 @@
-*** libavformat/movenc.c.old	Thu Jan  7 19:26:12 2010
---- libavformat/movenc.c	Thu Jan  7 19:26:12 2010
+*** libavformat/movenc.c.old	Sat Mar 27 20:05:46 2010
+--- libavformat/movenc.c	Sat Mar 27 20:05:46 2010
 ***************
-*** 2138,2140 ****
---- 2138,2152 ----
+*** 2140,2142 ****
+--- 2140,2156 ----
       .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
   };
   #endif
 + /* MEANX */
++ int movenc_init(void);
++ 
 + int movenc_init(void)
 + {
 +     av_register_output_format(&mov_muxer);



From gruntster at mail.berlios.de  Tue Mar 30 21:21:36 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 30 Mar 2010 21:21:36 +0200
Subject: [Avidemux-svn-commit] r6029 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc:
	. mpeg2enc
Message-ID: <201003301921.o2UJLaTH003966@sheep.berlios.de>

Author: gruntster
Date: 2010-03-30 21:21:29 +0200 (Tue, 30 Mar 2010)
New Revision: 6029

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/Mpeg2Param.xsd
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/encoder.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Encoder.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Options.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Options.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2enc/mpeg2enc_if.cc
Log:
[mpeg2enc] more moving mpeg2enc to plugin

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/CMakeLists.txt	2010-03-27 21:04:46 UTC (rev 6028)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/CMakeLists.txt	2010-03-30 19:21:29 UTC (rev 6029)
@@ -4,7 +4,7 @@
 add_subdirectory(mpeg2enc)
 SET(ADM_vidEnc_mpeg2enc_SRCS  interface.c  encoder.cpp  mpeg2Encoder.cpp  mpeg2Options.cpp)
 
-INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR} ${LIBXML2_INCLUDE_DIR} ../common/pluginOptions ../common/xvidRateCtl)
+INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR} ${LIBXML2_INCLUDE_DIR} ../common/pluginOptions ../common/xvidRateCtl mpeg2enc)
 ADD_DEFINITIONS(${LIBXML2_DEFINITIONS} -DMPEG2_PLUGIN_CONFIG_DIR="mpegenc")
 
 ADD_LIBRARY(ADM_vidEnc_mpeg2enc SHARED ${ADM_vidEnc_mpeg2enc_SRCS})

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/Mpeg2Param.xsd
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/Mpeg2Param.xsd	2010-03-27 21:04:46 UTC (rev 6028)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/Mpeg2Param.xsd	2010-03-30 19:21:29 UTC (rev 6029)
@@ -48,6 +48,14 @@
                 </xs:simpleType>
               </xs:element>
               <xs:element name="widescreen" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="streamType" minOccurs="0">
+                <xs:simpleType>
+                  <xs:restriction base="xs:string">
+                    <xs:enumeration value="dvd"/>
+                    <xs:enumeration value="svcd"/>
+                  </xs:restriction>
+                </xs:simpleType>
+              </xs:element>
               <xs:element name="interlaced" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:string">
@@ -62,19 +70,10 @@
                   <xs:restriction base="xs:string">
                     <xs:enumeration value="default"/>
                     <xs:enumeration value="tmpgenc"/>
-                    <xs:enumeration value="anime"/>
                     <xs:enumeration value="kvcd"/>
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="gopSize" minOccurs="0">
-                <xs:simpleType>
-                  <xs:restriction base="xs:integer">
-                    <xs:minInclusive value="1"/>
-                    <xs:maxInclusive value="30"/>
-                  </xs:restriction>
-                </xs:simpleType>
-              </xs:element>
             </xs:sequence>
           </xs:complexType>
         </xs:element>

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/encoder.cpp	2010-03-27 21:04:46 UTC (rev 6028)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/encoder.cpp	2010-03-30 19:21:29 UTC (rev 6029)
@@ -18,6 +18,7 @@
 #include "encoder.h"
 #include "mpeg2Encoder.h"
 #include "ADM_inttype.h"
+#include "mpeg2enc.h"
 
 int uiType;
 
@@ -25,7 +26,12 @@
 
 static int encoderIds[] = { 0 };
 static Mpeg2encEncoder* encoders[] = {&mpeg2};
+static int supportedCsps[] = { ADM_CSP_YV12 };
 
+extern int mpegenc_init(mpeg2parm *incoming,int width, int height, int fps1000);
+extern int mpegenc_encode(char *in, char *out, int *size, int *flags, int *quant);
+extern int mpegenc_setQuantizer(int q);
+
 extern "C"
 {
 	void *mpeg2encEncoder_getPointers(int _uiType, int *count)
@@ -189,7 +195,16 @@
 	_fpsDen = properties->fpsDen;
 
 	_frameCount = properties->frameCount;
+	_bufferSize = (properties->width * properties->height) + 2 * ((properties->width + 1 >> 1) * (properties->height + 1 >> 1));
+	_buffer = new uint8_t[_bufferSize];
 
+	memset(&_param, 0, sizeof(mpeg2parm));
+	_param.setDefault();
+	_param.searchrad = 16; // speed up
+
+	properties->supportedCspsCount = 1;
+	properties->supportedCsps = supportedCsps;
+
 	return ADM_VIDENC_ERR_SUCCESS;
 }
 
@@ -213,6 +228,9 @@
 	_openPass = true;
 	_currentPass++;
 
+	if (!mpegenc_init(&_param, _width, _height, (_fpsNum * 1000) / _fpsDen))
+		return ADM_VIDENC_ERR_FAILED;
+
 	return ADM_VIDENC_ERR_SUCCESS;
 }
 
@@ -221,6 +239,19 @@
 	if (!_opened)
 		return ADM_VIDENC_ERR_CLOSED;
 
+	int flags, size, qz;
+
+	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_CQP)
+		mpegenc_setQuantizer(_encodeOptions.encodeModeParameter);
+
+	if (!mpegenc_encode((char*)encodeParams->frameData, (char*)_buffer, &size, &flags, &qz))
+		return ADM_VIDENC_ERR_FAILED;
+
+	encodeParams->frameType = getFrameType(flags);
+	encodeParams->encodedDataSize = size;
+	encodeParams->encodedData = _buffer;
+	encodeParams->quantiser = qz;
+
 	return ADM_VIDENC_ERR_SUCCESS;
 }
 
@@ -232,6 +263,12 @@
 	if (_openPass)
 		_openPass = false;
 
+	if (_buffer)
+	{
+		delete [] _buffer;
+		_buffer = NULL;
+	}
+
 	return ADM_VIDENC_ERR_SUCCESS;
 }
 
@@ -245,3 +282,16 @@
 
 	return ADM_VIDENC_ERR_SUCCESS;
 }
+
+int Mpeg2encEncoder::getFrameType(int flags)
+{
+	switch (flags)
+	{
+		case I_TYPE:
+			return ADM_VIDENC_FRAMETYPE_IDR;
+		case B_TYPE:
+			return ADM_VIDENC_FRAMETYPE_B;
+		default:
+			return ADM_VIDENC_FRAMETYPE_P;
+	}
+}

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/encoder.h	2010-03-27 21:04:46 UTC (rev 6028)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/encoder.h	2010-03-30 19:21:29 UTC (rev 6029)
@@ -25,6 +25,8 @@
 	#include "ADM_vidEnc_plugin.h"
 }
 
+#include "mpeg2parm.h"
+
 class Mpeg2encEncoder
 {
 	protected:
@@ -35,6 +37,14 @@
 		int _currentPass, _passCount;
 		bool _opened, _openPass;
 
+		uint8_t *_buffer;
+		int _bufferSize;
+
+		vidEncOptions _encodeOptions;
+		mpeg2parm _param;
+
+		int getFrameType(int flags);
+
 	public:
 		virtual ~Mpeg2encEncoder(void);
 		virtual const char* getEncoderName(void);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Encoder.cpp	2010-03-27 21:04:46 UTC (rev 6028)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Encoder.cpp	2010-03-30 19:21:29 UTC (rev 6029)
@@ -18,6 +18,7 @@
 
 #include "ADM_inttype.h"
 #include "mpeg2Encoder.h"
+#include "format_codes.h"
 
 extern int _uiType;
 static bool changedConfig(const char* fileName, ConfigMenuType configType);
@@ -72,6 +73,10 @@
 {
 	loadSettings(&_encodeOptions, &_options);
 
+	diaMenuEntry streamM[] = {		
+		{0, "DVD"},
+		{1, "Super Video CD"}};
+
 	diaMenuEntry wideM[] = {
 		{0, "4:3"},
 		{1, "16:9"}};
@@ -91,11 +96,11 @@
 
 	diaElemBitrate ctlBitrate(&_bitrateParam, NULL);
 	diaElemUInteger ctlMaxb(&_maxBitrate, "Ma_x. bitrate:", 100, 9000);
+	diaElemMenu ctlStreamType(&_streamType, "Stream _type:", 2, streamM);
 	diaElemMenu ctlWidescreen(&_widescreen, "Aspect _ratio:", 2, wideM);
 	diaElemMenu ctlMatrix(&_userMatrix, "_Matrices:", 4, matrixM);
-	diaElemUInteger ctlGop(&_gopSize, "_GOP size:", 1, 30);
 	diaElemMenu ctlInterW(&_interlaced, "_Interlacing:", 3, interM);
-	diaElem *elmGeneral[6]= {&ctlBitrate, &ctlMaxb, &ctlWidescreen, &ctlInterW, &ctlMatrix, &ctlGop};
+	diaElem *elmGeneral[6] = {&ctlBitrate, &ctlMaxb, &ctlStreamType, &ctlWidescreen, &ctlInterW, &ctlMatrix};
 
 	diaElemConfigMenu ctlConfigMenu(configName, &configType, _options.getUserConfigDirectory(), _options.getSystemConfigDirectory(),
 		changedConfig, serializeConfig, elmGeneral, 6);
@@ -133,7 +138,7 @@
 		_widescreen = options->getWidescreen();
 		_interlaced = options->getInterlaced();
 		_userMatrix = options->getMatrix();
-		_gopSize = options->getGopSize();
+		_streamType = options->getStreamType();
 
 		updateEncodeProperties(encodeOptions);
 	}
@@ -171,7 +176,7 @@
 	options->setWidescreen(_widescreen);
 	options->setInterlaced((Mpeg2InterlacedMode)_interlaced);
 	options->setMatrix((Mpeg2MatrixMode)_userMatrix);
-	options->setGopSize(_gopSize);
+	options->setStreamType((Mpeg2StreamTypeMode)_streamType);
 }
 
 bool changedConfig(const char* configName, ConfigMenuType configType)
@@ -272,19 +277,80 @@
 		return ADM_VIDENC_ERR_FAILED;
 }
 
-int Mpeg2Encoder::beginPass(vidEncPassParameters *passParameters)
+int Mpeg2Encoder::open(vidEncVideoProperties *properties)
 {
+	int ret = Mpeg2encEncoder::open(properties);
 
+	switch (_options.getMatrix())
+	{
+		case MPEG2_MATRIX_TMPGENC:
+			_param.hf_quant = 4;
+			break;
+		case MPEG2_MATRIX_KVCD:
+			_param.hf_quant = 3;
+			break;
+		default:
+			_param.hf_quant = 0;
+	}
+
+	if(_options.getWidescreen())
+		_param.aspect_ratio = 3;
+	else
+		_param.aspect_ratio = 2;
+
+	if (_options.getInterlaced() == MPEG2_INTERLACED_NONE)
+	{
+		_param.fieldenc = 0;
+	}
+	else
+	{
+		_param.fieldenc = 1;
+
+		if (_options.getInterlaced() == MPEG2_INTERLACED_BFF)
+			_param.input_interlacing = 2;
+		else
+			_param.input_interlacing = 1;
+	}
+
+	if (_options.getMaxBitrate() == 0)
+	{
+		_param.bitrate = 50000000;
+		_param.ignore_constraints = 1;
+	}
+	else
+		_param.bitrate = _options.getMaxBitrate() * 1000;
+
+	if (_options.getStreamType() == MPEG2_STREAMTYPE_SVCD)
+		_param.format = MPEG_FORMAT_SVCD;
+	else
+		_param.format = MPEG_FORMAT_DVD;
+
+	if (((_fpsNum * 1000) / _fpsDen) == 25000) // PAL
+		_param.min_GOP_size = _param.max_GOP_size = 15;
+	else
+		_param.min_GOP_size = _param.max_GOP_size = 18;
+
+	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_CQP)
+		_param.quant = _encodeOptions.encodeModeParameter;
+	else
+		_param.quant = 0;
+
+	return ret;
 }
 
+int Mpeg2Encoder::beginPass(vidEncPassParameters *passParameters)
+{
+	return Mpeg2encEncoder::beginPass(passParameters);
+}
+
 int Mpeg2Encoder::encodeFrame(vidEncEncodeParameters *encodeParams)
 {
-
+	return Mpeg2encEncoder::encodeFrame(encodeParams);
 }
 
 int Mpeg2Encoder::finishPass(void)
 {
-
+	return Mpeg2encEncoder::finishPass();
 }
 
 void Mpeg2Encoder::updateEncodeProperties(vidEncOptions *encodeOptions)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Encoder.h	2010-03-27 21:04:46 UTC (rev 6028)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Encoder.h	2010-03-30 19:21:29 UTC (rev 6029)
@@ -31,13 +31,12 @@
 {
 	private:
 		COMPRES_PARAMS _bitrateParam;
-		unsigned int _maxBitrate, _widescreen, _interlaced, _userMatrix, _gopSize;
+		unsigned int _maxBitrate, _streamType, _widescreen, _interlaced, _userMatrix;
 
 		char configName[PATH_MAX];
 		ConfigMenuType configType;
 
 		Mpeg2Options _options;
-		vidEncOptions _encodeOptions;
 		vidEncVideoProperties _properties;
 
 		int _bufferSize;
@@ -58,6 +57,7 @@
 		void saveSettings(vidEncOptions *encodeOptions, Mpeg2Options *options);
 		int getOptions(vidEncOptions *encodeOptions, char *pluginOptions, int bufferSize);
 		int setOptions(vidEncOptions *encodeOptions, const char *pluginOptions);
+		int open(vidEncVideoProperties *properties);
 		int beginPass(vidEncPassParameters *passParameters);
 		int encodeFrame(vidEncEncodeParameters *encodeParams);
 		int finishPass(void);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Options.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Options.cpp	2010-03-27 21:04:46 UTC (rev 6028)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Options.cpp	2010-03-30 19:21:29 UTC (rev 6029)
@@ -41,10 +41,10 @@
 	PluginOptions::reset();
 
 	setMaxBitrate(2500);
+	setStreamType(MPEG2_STREAMTYPE_DVD);
 	setWidescreen(false);
 	setInterlaced(MPEG2_INTERLACED_NONE);
 	setMatrix(MPEG2_MATRIX_DEFAULT);
-	setGopSize(12);
 }
 
 unsigned int Mpeg2Options::getMaxBitrate(void)
@@ -86,19 +86,19 @@
 
 void Mpeg2Options::setMatrix(Mpeg2MatrixMode matrix)
 {
-	if (matrix == MPEG2_MATRIX_DEFAULT || matrix == MPEG2_MATRIX_TMPGENC || matrix == MPEG2_MATRIX_ANIME || matrix == MPEG2_MATRIX_KVCD)
+	if (matrix == MPEG2_MATRIX_DEFAULT || matrix == MPEG2_MATRIX_TMPGENC || matrix == MPEG2_MATRIX_KVCD)
 		_matrix = matrix;
 }
 
-unsigned int Mpeg2Options::getGopSize(void)
+Mpeg2StreamTypeMode Mpeg2Options::getStreamType(void)
 {
-	return _gopSize;
+	return _streamType;
 }
 
-void Mpeg2Options::setGopSize(unsigned int gopSize)
+void Mpeg2Options::setStreamType(Mpeg2StreamTypeMode streamType)
 {
-	if (gopSize >= 1 && gopSize <= 30)
-		_gopSize = gopSize;
+	if (streamType == MPEG2_STREAMTYPE_DVD || streamType == MPEG2_STREAMTYPE_SVCD)
+		_streamType = streamType;
 }
 
 void Mpeg2Options::addOptionsToXml(xmlNodePtr xmlNodeRoot)
@@ -111,6 +111,18 @@
 	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"maxBitrate", number2String(xmlBuffer, bufferSize, getMaxBitrate()));
 	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"widescreen", boolean2String(xmlBuffer, bufferSize, getWidescreen()));
 
+	switch (getStreamType())
+	{
+		case MPEG2_STREAMTYPE_SVCD:
+			strcpy((char*)xmlBuffer, "svcd");
+			break;
+		default:
+			strcpy((char*)xmlBuffer, "dvd");
+			break;
+	}
+
+	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"streamType", xmlBuffer);
+
 	switch (getInterlaced())
 	{
 		case MPEG2_INTERLACED_BFF:
@@ -131,9 +143,6 @@
 		case MPEG2_MATRIX_TMPGENC:
 			strcpy((char*)xmlBuffer, "tmpgenc");
 			break;
-		case MPEG2_MATRIX_ANIME:
-			strcpy((char*)xmlBuffer, "anime");
-			break;
 		case MPEG2_MATRIX_KVCD:
 			strcpy((char*)xmlBuffer, "kvcd");
 			break;
@@ -141,8 +150,6 @@
 			strcpy((char*)xmlBuffer, "default");
 			break;
 	}
-
-	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"gopSize", number2String(xmlBuffer, bufferSize, getGopSize()));
 }
 
 void Mpeg2Options::parseOptions(xmlNode *node)
@@ -157,6 +164,15 @@
 				setMaxBitrate(atoi(content));
 			else if (strcmp((char*)xmlChild->name, "widescreen") == 0)
 				setWidescreen(string2Boolean(content));
+			else if (strcmp((char*)xmlChild->name, "streamType") == 0)
+			{
+				Mpeg2StreamTypeMode mode = MPEG2_STREAMTYPE_DVD;
+
+				if (strcmp(content, "svcd") == 0)
+					mode = MPEG2_STREAMTYPE_SVCD;
+
+				setStreamType(mode);
+			}
 			else if (strcmp((char*)xmlChild->name, "interlaced") == 0)
 			{
 				Mpeg2InterlacedMode mode = MPEG2_INTERLACED_NONE;
@@ -174,15 +190,11 @@
 
 				if (strcmp(content, "tmpgenc") == 0)
 					mode = MPEG2_MATRIX_TMPGENC;
-				else if (strcmp(content, "anime") == 0)
-					mode = MPEG2_MATRIX_ANIME;
 				else if (strcmp(content, "kvcd") == 0)
 					mode = MPEG2_MATRIX_KVCD;
 
 				setMatrix(mode);
 			}
-			else if (strcmp((char*)xmlChild->name, "gopSize") == 0)
-				setGopSize(atoi(content));
 
 			xmlFree(content);
 		}

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Options.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Options.h	2010-03-27 21:04:46 UTC (rev 6028)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2Options.h	2010-03-30 19:21:29 UTC (rev 6029)
@@ -39,17 +39,23 @@
 {
 	MPEG2_MATRIX_DEFAULT,
 	MPEG2_MATRIX_TMPGENC,
-	MPEG2_MATRIX_ANIME,
 	MPEG2_MATRIX_KVCD
 } Mpeg2MatrixMode;
 
+typedef enum
+{
+	MPEG2_STREAMTYPE_DVD,
+	MPEG2_STREAMTYPE_SVCD
+} Mpeg2StreamTypeMode;
+
 class Mpeg2Options : public PluginOptions
 {
 protected:
-	unsigned int _maxBitrate, _gopSize;
+	unsigned int _maxBitrate;
 	bool _widescreen;
 	Mpeg2InterlacedMode _interlaced;
 	Mpeg2MatrixMode _matrix;
+	Mpeg2StreamTypeMode _streamType;
 
 	void addOptionsToXml(xmlNodePtr xmlNodeRoot);
 	void parseOptions(xmlNode *node);
@@ -70,8 +76,8 @@
 	Mpeg2MatrixMode getMatrix(void);
 	void setMatrix(Mpeg2MatrixMode matrix);
 
-	unsigned int getGopSize(void);
-	void setGopSize(unsigned int gopSize);
+	Mpeg2StreamTypeMode getStreamType(void);
+	void setStreamType(Mpeg2StreamTypeMode streamType);
 };
 
 #endif	// mpeg2Options_h

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2enc/mpeg2enc_if.cc
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2enc/mpeg2enc_if.cc	2010-03-27 21:04:46 UTC (rev 6028)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_mpeg2enc/mpeg2enc/mpeg2enc_if.cc	2010-03-30 19:21:29 UTC (rev 6029)
@@ -104,6 +104,55 @@
 static  int fedPictures=0;
 /* MeanX stuff */
  unsigned char *mpeg2enc_buffer=NULL;
+
+void printParams(mpeg2parm *param)
+{
+	printf("format: %d\n", param->format);
+	printf("bitrate: %d\n", param->bitrate);
+	printf("nonvid_bitrate: %d\n", param->nonvid_bitrate);
+	printf("quant: %d\n", param->quant);
+	printf("searchrad: %d\n", param->searchrad);
+	printf("mpeg: %d\n", param->mpeg);
+	printf("aspect_ratio: %d\n", param->aspect_ratio);
+	printf("frame_rate: %d\n", param->frame_rate);
+	printf("fieldenc: %d\n", param->fieldenc);
+
+	printf("norm: %d\n", param->norm);
+	printf("_44_red: %d\n", param->_44_red);
+	printf("_22_red: %d\n", param->_22_red);
+	printf("hf_quant: %d\n", param->hf_quant);
+	printf("hf_q_boost: %f\n", param->hf_q_boost);
+	printf("act_boost: %f\n", param->act_boost);
+	printf("boost_var_ceil: %f\n", param->boost_var_ceil);
+	printf("video_buffer_size: %d\n", param->video_buffer_size);
+	printf("seq_length_limit: %d\n", param->seq_length_limit);
+	printf("min_GOP_size: %d\n", param->min_GOP_size);
+	printf("max_GOP_size: %d\n", param->max_GOP_size);
+	printf("closed_GOPs: %d\n", param->closed_GOPs);
+	printf("preserve_B: %d\n", param->preserve_B);
+	printf("Bgrp_size: %d\n", param->Bgrp_size);
+	printf("num_cpus: %d\n", param->num_cpus);
+	printf("_32_pulldown: %d\n", param->_32_pulldown);
+	printf("svcd_scan_data: %d\n", param->svcd_scan_data);
+	printf("seq_hdr_every_gop: %d\n", param->seq_hdr_every_gop);
+	printf("seq_end_every_gop: %d\n", param->seq_end_every_gop);
+	printf("still_size: %d\n", param->still_size);
+	printf("pad_stills_to_vbv_buffer_size: %d\n", param->pad_stills_to_vbv_buffer_size);
+	printf("vbv_buffer_still_size: %d\n", param->vbv_buffer_still_size);
+	printf("force_interlacing: %d\n", param->force_interlacing);
+
+	printf("input_interlacing: %d\n", param->input_interlacing);
+	printf("hack_svcd_hds_bug: %d\n", param->hack_svcd_hds_bug);
+	printf("hack_altscan_bug: %d\n", param->hack_altscan_bug);
+	printf("mpeg2_dc_prec: %d\n", param->mpeg2_dc_prec);
+	printf("ignore_constraints: %d\n", param->ignore_constraints);
+	
+	//printf("custom_intra_quantizer_matrix[64];
+	//printf("custom_nonintra_quantizer_matrix[64];
+
+	printf("noPadding: %d\n", param->noPadding);
+}
+
 int mpegenc_init(mpeg2parm *incoming,int  width, int  height, int  fps1000)
 {
 /*
@@ -230,6 +279,9 @@
 	putseq_init();
 	aprintf("opt->enc_height2 :%d opt->enc_width: %d opt->enc_height2:%d \n",
 		opt->enc_height2,opt->enc_width,opt->enc_height);
+
+	//printParams(param);
+
 	return 1;
 }
 int mpegenc_encode(  char *in,   char *out, int *size,int *flags,int *quant)
@@ -258,18 +310,8 @@
 		#warning : Approximate..
 		*quant=map_non_linear_mquant[*quant];
 		*size=mpeg2enc_buffer-(unsigned char *)out;
-		switch(type)
-		{
-			case I_TYPE:
-						*flags=AVI_KEY_FRAME;
-						break;
-			case B_TYPE:
-						*flags=AVI_B_FRAME;
-						break;
-			default:
-						*flags=0;
-						break;
-		}
+		*flags = type;
+
 		return 1;
 
 }



From mean at mail.berlios.de  Wed Mar 31 19:59:37 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 31 Mar 2010 19:59:37 +0200
Subject: [Avidemux-svn-commit] r6030 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI
Message-ID: <201003311759.o2VHxbZq018977@sheep.berlios.de>

Author: mean
Date: 2010-03-31 19:59:36 +0200 (Wed, 31 Mar 2010)
New Revision: 6030

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp
Log:
[prefs] message level filter was not saved, closes #83

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp	2010-03-30 19:21:29 UTC (rev 6029)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp	2010-03-31 17:59:36 UTC (rev 6030)
@@ -441,7 +441,8 @@
                 prefs->set(FEATURE_TRYAUTOIDX, useAutoIndex);
                 // Auto swap A/B
                 prefs->set(FEATURE_SWAP_IF_A_GREATER_THAN_B, useSwap);
-
+                //
+                prefs->set(MESSAGE_LEVEL,msglevel);
                 // Disable nuv sync
                 prefs->set(FEATURE_DISABLE_NUV_RESYNC, useNuv);
                 // Use tray while encoding



From mean at mail.berlios.de  Wed Mar 31 19:59:42 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 31 Mar 2010 19:59:42 +0200
Subject: [Avidemux-svn-commit] r6031 - branches/avidemux_2.5_branch_gruntster
Message-ID: <201003311759.o2VHxg3q018998@sheep.berlios.de>

Author: mean
Date: 2010-03-31 19:59:41 +0200 (Wed, 31 Mar 2010)
New Revision: 6031

Modified:
   branches/avidemux_2.5_branch_gruntster/bootStrap_debug.sh
Log:
[bootstrap] Fix bootstrap_debug

Modified: branches/avidemux_2.5_branch_gruntster/bootStrap_debug.sh
===================================================================
--- branches/avidemux_2.5_branch_gruntster/bootStrap_debug.sh	2010-03-31 17:59:36 UTC (rev 6030)
+++ branches/avidemux_2.5_branch_gruntster/bootStrap_debug.sh	2010-03-31 17:59:41 UTC (rev 6031)
@@ -15,7 +15,7 @@
 rm -Rf buildMain_debug
 mkdir -p buildMain_debug
 cd buildMain_debug
-cmake -DCMAKE_EDIT_COMMAND=vim -DCMAKE_BUILD_TYPE=Debug --DCMAKE_INSTALL_PREFIX=$PREFIX -DAVIDEMUX_INSTALL_PREFIX=$PREFIX -G "CodeBlocks - Unix Makefiles" .. || fail cmake
+cmake -DCMAKE_EDIT_COMMAND=vim -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=$PREFIX -DAVIDEMUX_INSTALL_PREFIX=$PREFIX -G "CodeBlocks - Unix Makefiles" .. || fail cmake
 make -j 3 || fail make_main
 sudo make install || fail install_main
 sudo ldconfig
@@ -25,7 +25,7 @@
 rm -Rf buildPlugins_debug
 mkdir -p buildPlugins_debug
 cd buildPlugins_debug
-cmake -DCMAKE_EDIT_COMMAND=vim -DCMAKE_BUILD_TYPE=Debug --DCMAKE_INSTALL_PREFIX=$PREFIX -DAVIDEMUX_INSTALL_PREFIX=$PREFIX  -DAVIDEMUX_SOURCE_DIR=$TOP/  -DAVIDEMUX_CORECONFIG_DIR=$TOP/buildMain_debug/config -G "CodeBlocks - Unix Makefiles" ../plugins || fail cmake_plugins
+cmake -DCMAKE_EDIT_COMMAND=vim -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=$PREFIX -DAVIDEMUX_INSTALL_PREFIX=$PREFIX  -DAVIDEMUX_SOURCE_DIR=$TOP/  -DAVIDEMUX_CORECONFIG_DIR=$TOP/buildMain_debug/config -G "CodeBlocks - Unix Makefiles" ../plugins || fail cmake_plugins
 make -j 3  || fail make_plugins
 sudo make install
 echo "*  All Done  *"



From mean at mail.berlios.de  Wed Mar 31 19:59:49 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 31 Mar 2010 19:59:49 +0200
Subject: [Avidemux-svn-commit] r6032 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer
Message-ID: <201003311759.o2VHxnun019022@sheep.berlios.de>

Author: mean
Date: 2010-03-31 19:59:49 +0200 (Wed, 31 Mar 2010)
New Revision: 6032

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.cpp
Log:
[mpeg demuxer] fix bad usage of getFlags() method

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.cpp	2010-03-31 17:59:41 UTC (rev 6031)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.cpp	2010-03-31 17:59:49 UTC (rev 6032)
@@ -654,7 +654,8 @@
 
         if(framenum>=_nbFrames) return 0;
         
-        img->flags=getFlags(framenum,&f);
+        if(!getFlags(framenum,&f)) return 0;
+        img->flags=f;
 
         idx=&(_index[framenum]);
         img->dataLength=idx->size;



