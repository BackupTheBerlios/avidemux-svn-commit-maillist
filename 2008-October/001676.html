<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4436 - in branches/avidemux_2.4_branch: .	avidemux avidemux/ADM_codecs avidemux/ADM_colorspace	avidemux/ADM_libraries/ADM_lavcodec	avidemux/ADM_libraries/ADM_utilities
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4436%20-%20in%20branches/avidemux_2.4_branch%3A%20.%0A%09avidemux%20avidemux/ADM_codecs%20avidemux/ADM_colorspace%0A%09avidemux/ADM_libraries/ADM_lavcodec%0A%09avidemux/ADM_libraries/ADM_utilities&In-Reply-To=%3C200810031105.m93B5ZrX014750%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001675.html">
   <LINK REL="Next"  HREF="001677.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4436 - in branches/avidemux_2.4_branch: .	avidemux avidemux/ADM_codecs avidemux/ADM_colorspace	avidemux/ADM_libraries/ADM_lavcodec	avidemux/ADM_libraries/ADM_utilities</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4436%20-%20in%20branches/avidemux_2.4_branch%3A%20.%0A%09avidemux%20avidemux/ADM_codecs%20avidemux/ADM_colorspace%0A%09avidemux/ADM_libraries/ADM_lavcodec%0A%09avidemux/ADM_libraries/ADM_utilities&In-Reply-To=%3C200810031105.m93B5ZrX014750%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4436 - in branches/avidemux_2.4_branch: .	avidemux avidemux/ADM_codecs avidemux/ADM_colorspace	avidemux/ADM_libraries/ADM_lavcodec	avidemux/ADM_libraries/ADM_utilities">gruntster at mail.berlios.de
       </A><BR>
    <I>Fri Oct  3 13:05:35 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001675.html">[Avidemux-svn-commit] r4435 - in	branches/avidemux_2.4_branch/platforms/windows:	build_scripts/avidemux_2.4 installer
</A></li>
        <LI>Next message: <A HREF="001677.html">[Avidemux-svn-commit] r4437 -	branches/avidemux_2.4_branch/platforms/windows/installer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1676">[ date ]</a>
              <a href="thread.html#1676">[ thread ]</a>
              <a href="subject.html#1676">[ subject ]</a>
              <a href="author.html#1676">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2008-10-03 13:05:09 +0200 (Fri, 03 Oct 2008)
New Revision: 4436

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/png.c
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_png.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_png.h
Modified:
   branches/avidemux_2.4_branch/ConfigureChecks.cmake
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_imageLoader.cpp
   branches/avidemux_2.4_branch/avidemux/CMakeLists.txt
   branches/avidemux_2.4_branch/config.h.cmake
   branches/avidemux_2.4_branch/configure.in.in
Log:
[png] use libavcodec for PNG decoding to support more colour depths rather than adding more plumbing around libpng. Also remove libpng as a dependency. (FS#508)

Modified: branches/avidemux_2.4_branch/ConfigureChecks.cmake
===================================================================
--- branches/avidemux_2.4_branch/ConfigureChecks.cmake	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/ConfigureChecks.cmake	2008-10-03 11:05:09 UTC (rev 4436)
@@ -32,8 +32,8 @@
 		SET(ADM_CPU_X86_64 1)
 	ELSEIF (${CMAKE_SYSTEM_PROCESSOR} STREQUAL &quot;ppc&quot;)
 		SET(ADM_CPU_PPC 1)
-	ELSEIF (${CMAKE_SYSTEM_PROCESSOR} STREQUAL &quot;ppc64&quot;)
-		SET(ADM_CPU_PPC 1)
+	ELSEIF (${CMAKE_SYSTEM_PROCESSOR} STREQUAL &quot;ppc64&quot;)
+		SET(ADM_CPU_PPC 1)
 		SET(ARCH_64_BITS 1)	
 	ENDIF (${CMAKE_SYSTEM_PROCESSOR} STREQUAL &quot;i386&quot; OR ${CMAKE_SYSTEM_PROCESSOR} STREQUAL &quot;i586&quot; OR ${CMAKE_SYSTEM_PROCESSOR} STREQUAL &quot;i686&quot;)
 ENDIF (WIN32)
@@ -502,11 +502,6 @@
 SET(CMAKE_REQUIRED_LIBRARIES)
 
 ########################################
-# PNG
-########################################
-ADM_CHECK_HL(libPNG png.h png png_malloc USE_PNG)
-
-########################################
 # FAAD
 ########################################
 ADM_CHECK_HL(FAAD faad.h faad faacDecInit USE_FAAD_P)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-10-03 11:05:09 UTC (rev 4436)
@@ -65,7 +65,6 @@
 #include &quot;ADM_codecs/ADM_theora_dec.h&quot;
 #endif
 #include &quot;ADM_codecs/ADM_mpeg.h&quot;
-#include &quot;ADM_codecs/ADM_png.h&quot;
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 #include &lt;ADM_assert.h&gt;
 #include &quot;prefs.h&quot;
@@ -266,13 +265,11 @@
 
       return (decoders *) (new decoderFFhuff (w, h, extraLen, extraData,bpp));
     }
-#ifdef USE_PNG
   if (fourCC::check (fcc, (uint8_t *) &quot;PNG &quot;))
     {
 
-      return (decoders *) (new decoderPng (w, h));
+      return (decoders *) (new decoderFFPng (w, h));
     }
-#endif
  if (fourCC::check (fcc, (uint8_t *) &quot;cvid&quot;))
     {
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2008-10-03 11:05:09 UTC (rev 4436)
@@ -417,7 +417,9 @@
       // we do it or not
       out-&gt;_colorspace = ADM_COLOR_YV12;
       break;
-
+	case PIX_FMT_RGB24:
+	  out-&gt;_colorspace = ADM_COLOR_RGB24;
+	  break;
     case PIX_FMT_RGBA32:
       out-&gt;_colorspace = ADM_COLOR_RGB32A;
       break;
@@ -425,9 +427,11 @@
       out-&gt;_colorspace = ADM_COLOR_RGB555;
       break;
     case PIX_FMT_GRAY8:
-//      out-&gt;_colorspace = ADM_COLOR_RGB555;
       out-&gt;_colorspace = ADM_COLOR_GRAY8;
       break;
+    case PIX_FMT_PAL8:
+      out-&gt;_colorspace = ADM_COLOR_PAL8;
+      break;
     default:
       printf (&quot;[lavc] Unhandled colorspace: %d\n&quot;, _context-&gt;pix_fmt);
       return 0;
@@ -554,6 +558,11 @@
   _context-&gt;pix_fmt = PIX_FMT_GRAY8;
 }
 
+decoderFFPng::decoderFFPng (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  WRAP_Open (CODEC_ID_PNG);
+}
+
 decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
 	   h)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h	2008-10-03 11:05:09 UTC (rev 4436)
@@ -261,6 +261,12 @@
   decoderFFY800 (uint32_t w, uint32_t h);
 };
 
+class decoderFFPng : public decoderFF
+{
+public:
+	decoderFFPng(uint32_t w, uint32_t h);
+};
+
 class decoderFFMJPEG:public decoderFF
 {
 protected:

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_png.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_png.cpp	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_png.cpp	2008-10-03 11:05:09 UTC (rev 4436)
@@ -1,178 +0,0 @@
-/***************************************************************************
-                          ADM_png.cpp  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#ifdef USE_PNG
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-
-#include &quot;ADM_utilities/default.h&quot;
-
-#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_png.h&quot;
-
-#include &quot;png.h&quot;
-#include &lt;ADM_assert.h&gt;
-
-#define PNG_PTR ((png_structp)png_ptr)
-#define INFO_PTR ((png_infop)info_ptr)
-#define INFO_END ((png_infop)end_info)
-/*
-   	Initialize codec
-*/
-static void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length);
-
-void decoderPng::recalc (void)
-{
-  int mul;
-  if (colorspace == ADM_COLOR_RGB24)
-    mul = 3;
-
-  else
-    mul = 4;
-  for (int i = 0; i &lt; _h; i++)
-    rows[i] = decoded + mul * _w * i;
-}
-
-
-decoderPng::decoderPng (uint32_t w, uint32_t h):decoders (w, h)
-{
-  rows = NULL;
-  decoded = NULL;
-  colorspace = ADM_COLOR_RGB24;
-
-  //****************************
-  // Prepare the decoded buffer*
-  //****************************
-  decoded = new uint8_t[4 * w * h];	// We take a bit more to be able to decode 32 bits png
-  // without causing a segfault
-  rows = new uint8_t *[h];
-  recalc ();
-}
- void decoderPng::Init (void)
-{
-  png_ptr =
-    (void *) png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-  ADM_assert (png_ptr);
-  info_ptr = (void *) png_create_info_struct (PNG_PTR);
-  ADM_assert (info_ptr);
-  end_info = (void *) png_create_info_struct (PNG_PTR);
-  ADM_assert (end_info);
-  memset (&amp;io, 0, sizeof (io));
-  png_set_read_fn (PNG_PTR, &amp;io, user_read_data);
-  png_set_rows (PNG_PTR, INFO_PTR, (png_byte **) rows);
-}
-void decoderPng::Cleanup (void)
-{
-  png_destroy_read_struct ((png_structpp) &amp; png_ptr, (png_infopp) &amp; info_ptr,
-			   (png_infopp) &amp; end_info);
-}
-decoderPng::~decoderPng ()
-{
-  delete[]rows;
-  delete[]decoded;
-}
-/*
-   	Uncompress frame, set flags if needed
-*/
-uint8_t decoderPng::uncompress(ADMCompressedImage * in, ADMImage * out)
-{
-  int bpp;
-  int colortype;
-
-  // Check if it is png, and fill it
-  if (!!png_sig_cmp (in-&gt;data, 0, 8))
-
-    {
-      printf (&quot;[PNG] wrong sig\n&quot;);
-      return 0;
-    }
-
-  //
-  //
-gain2:
-  Init ();
-  io.data = in-&gt;data;
-  io.size = in-&gt;dataLength;
-  io.cur = 0;
-  png_read_png (PNG_PTR, INFO_PTR, PNG_TRANSFORM_IDENTITY, NULL);
-
-  // Check if it is 24 or 32 bits RGB 
-  bpp = png_get_bit_depth (PNG_PTR, INFO_PTR);
-//   printf(&quot;Bpp:%u\n&quot;,bpp);
-  // if needed we change colorspace 
-  colortype = png_get_color_type (PNG_PTR, INFO_PTR);
-  // 
-  if (colorspace == ADM_COLOR_RGB24 &amp;&amp; colortype == PNG_COLOR_TYPE_RGB_ALPHA)	// RGB32
-    {
-
-      // Switch to 32 bits
-      colorspace = ADM_COLOR_RGB32A;
-      recalc ();
-      goto gain2;
-    }
-
-  else if (colorspace == ADM_COLOR_RGB32A &amp;&amp; colortype == PNG_COLOR_TYPE_RGB)
-
-    {
-
-      // Switch to 24 bits
-      colorspace = ADM_COLOR_RGB24;
-      recalc ();
-      goto gain2;
-    }
-  ADM_assert (out-&gt;_isRef);
-  out-&gt;_planes[0] = decoded;
-  out-&gt;_planes[1] = NULL;
-  out-&gt;_planes[2] = NULL;
-  if (colorspace == ADM_COLOR_RGB32A)
-    out-&gt;_planeStride[0] = _w * 4;
-
-  else
-    out-&gt;_planeStride[0] = _w * 3;
-  out-&gt;_planeStride[1] = 0;
-  out-&gt;_planeStride[2] = 0;
-  out-&gt;_colorspace = colorspace;
-  Cleanup ();
-  return 1;
-}
-
-// ******************************************************
-//    Memory based IO
-// ******************************************************
-void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length)
-{
-  memAccess *ac;
-  ac = (memAccess *) png_get_io_ptr (png_ptr);
-  ADM_assert (length + ac-&gt;cur &lt;= ac-&gt;size);	// or &lt; ?
-  memcpy (data, ac-&gt;data + ac-&gt;cur, length);
-  ac-&gt;cur += length;
-} 
-
-void user_write_data (png_structp png_ptr, png_bytep data, png_size_t length)
-{
-} 
-
-void user_flush_data (png_structp png_ptr)
-{
-}
-//EOF
-#endif /*  */

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_png.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_png.h	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_png.h	2008-10-03 11:05:09 UTC (rev 4436)
@@ -1,78 +0,0 @@
-/***************************************************************************
-                          ADM_png  -  description
-                             -------------------
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
- 
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/ 
-#ifndef PNG_H_A
-#define PNG_H_A
-#ifdef USE_PNG
-
-typedef struct memAccess 
-{
-  
-int size;
-   
-int cur;
-   
-uint8_t * data;
-
-
-} memAccess;
-
-
-class decoderPng:public decoders 
-{
-
-protected:
-memAccess io;
-  
-ADM_colorspace colorspace;
-  
-void *png_ptr;
-  
-void *info_ptr;
-  
-void *end_info;
-  
-
-uint8_t ** rows;
-  
-uint8_t * decoded;
-  
-void Init (void);
-  
-void Cleanup (void);
-  
-void recalc (void);
-
-public:
-decoderPng (uint32_t w, uint32_t h);
-  
-virtual ~ decoderPng ();
-  
-virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
-  
-uint8_t dontcopy (void)
-  {
-    return 1;
-  }
-
-
-
-};
-
-#endif /* 
- */
-#endif /* 
- */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt	2008-10-03 11:05:09 UTC (rev 4436)
@@ -1,6 +1,6 @@
 
 SET(ADM_codecs_SRCS 
-ADM_codecs.cpp  ADM_ffmpeg.cpp  ADM_mjpegEncode.cpp  ADM_png.cpp    ADM_theora_dec.cpp  ADM_x264.cpp   ADM_xvid.cpp     ADM_xvideco.cpp
+ADM_codecs.cpp  ADM_ffmpeg.cpp  ADM_mjpegEncode.cpp  ADM_theora_dec.cpp  ADM_x264.cpp   ADM_xvid.cpp     ADM_xvideco.cpp
 ADM_ffmp43.cpp  ADM_mjpeg.cpp   ADM_mpeg.cpp         ADM_rgb16.cpp  ADM_uyvy.cpp        ADM_xvid4.cpp  ADM_xvidcvs.cpp
 )
 ADD_LIBRARY(ADM_codecs STATIC ${ADM_codecs_SRCS})

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am	2008-10-03 11:05:09 UTC (rev 4436)
@@ -8,7 +8,7 @@
 libADM_codecs_a_SOURCES =  ADM_theora_dec.cpp ADM_ffmp43.cpp \
 	ADM_mjpegEncode.cpp ADM_rgb16.cpp ADM_xvid.cpp ADM_xvideco.cpp ADM_mjpeg.cpp ADM_ffmpeg.cpp \
 	ADM_codecs.cpp ADM_ffmpegConfig.h ADM_mpeg.h ADM_mpeg.cpp  \
-	ADM_xvidcvs.cpp ADM_xvid4.cpp ADM_uyvy.cpp ADM_x264.cpp ADM_png.cpp
+	ADM_xvidcvs.cpp ADM_xvid4.cpp ADM_uyvy.cpp ADM_x264.cpp
 
 
 EXTRA_DIST =  ADM_codec.h         ADM_divxEncode.h    ADM_mjpegEncode.cpp  ADM_theora_dec.h \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.cpp	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.cpp	2008-10-03 11:05:09 UTC (rev 4436)
@@ -511,8 +511,9 @@
                 case ADM_COLOR_RGB16:c=PIX_FMT_RGB565;break;
                 case ADM_COLOR_YUV411:c=PIX_FMT_YUV411P;break;
 				case ADM_COLOR_YUV422:c=PIX_FMT_YUV422P;break;
-				case ADM_COLOR_YUV444:c=PIX_FMT_YUV444P;break;
+				case ADM_COLOR_YUV444:c=PIX_FMT_YUV444P;break;
                 case ADM_COLOR_GRAY8:c=PIX_FMT_GRAY8;break;
+				case ADM_COLOR_PAL8:c=PIX_FMT_PAL8;break;
                 default: ADM_assert(0);
     }
          _context=(void *)sws_getContext(

Modified: branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.h	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.h	2008-10-03 11:05:09 UTC (rev 4436)
@@ -34,7 +34,8 @@
     ADM_COLOR_YUV422P,
 	ADM_COLOR_YUV411,
 	ADM_COLOR_YUV444,
-	ADM_COLOR_GRAY8
+	ADM_COLOR_GRAY8,
+	ADM_COLOR_PAL8
  } ADM_colorspace;
 #define ADM_COLOR_BACKWARD 0x8000
 #define ADM_COLOR_MASK     0x7FFF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-10-03 11:05:09 UTC (rev 4436)
@@ -17,7 +17,7 @@
 		truemotion1.c flac.c g726.c 	qtrle.c lcl.c 	snow.c  
 		rangecoder.c bitstream.c h264idct.c h261.c libamr.c tscc.c 
 		resample2.c pthread.c qdm2.c bitstream_filter.c eval.c 
-		vc1.c vc1dsp.c vp56.c  vp6.c vp5.c indeo2.c smacker.c  opt.c
+		vc1.c vc1dsp.c vp56.c  vp6.c vp5.c indeo2.c smacker.c  opt.c  png.c
                 fraps.c dnxhddata.h  dnxhddec.c
                 mpeg12data.c  mpegaudiodata.c  msmpeg4data.c   vc1data.c   vp56data.c mjpegbdec.c
                 h263_parser.c

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2008-10-03 11:05:09 UTC (rev 4436)
@@ -57,7 +57,7 @@
 		truemotion1.c flac.c g726.c 	qtrle.c lcl.c 	snow.c  \
 		rangecoder.c bitstream.c h264idct.c h261.c libamr.c tscc.c \
 		resample2.c pthread.c qdm2.c bitstream_filter.c eval.c \
-		vc1.c vc1dsp.c vp56.c vp56data.c vp6.c vp5.c indeo2.c indeo3.c  smacker.c  opt.c \
+		vc1.c vc1dsp.c vp56.c vp56data.c vp6.c vp5.c indeo2.c indeo3.c  smacker.c  opt.c  png.c \
 		 fraps.c dnxhddata.h  dnxhddec.c	\
                 mpeg12data.c  mpegaudiodata.c  msmpeg4data.c   vc1data.c   vp56data.c mjpegbdec.c \
                 h263_parser.c \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c	2008-10-03 11:05:09 UTC (rev 4436)
@@ -136,7 +136,6 @@
     DECLARE_DECODER (H261, h261);
 	DECLARE_DECODER (H263I, h263i);
     DECLARE_DECODER (JPEGLS, jpegls);
-    DECLARE_DECODER (PNG, png);
     DECLARE_DECODER (QTRLE, qtrle);
     DECLARE_DECODER (ROQ, roq);
     DECLARE_DECODER (SGI, sgi);
@@ -351,4 +350,6 @@
 printf(&quot;#define ENABLE_BFIN      0\n&quot;);
 printf(&quot;#define ENABLE_SMALL      0\n&quot;);
 printf(&quot;#define CONFIG_SNOW_ENCODER      1\n&quot;);
+printf(&quot;#define ENABLE_PNG_DECODER      1\n&quot;);
+printf(&quot;#define CONFIG_PNG_DECODER      1\n&quot;);
 }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h	2008-10-03 11:05:09 UTC (rev 4436)
@@ -122,7 +122,6 @@
 #define ENABLE_H261_DECODER 0
 #define ENABLE_H263I_DECODER 0
 #define ENABLE_JPEGLS_DECODER 0
-#define ENABLE_PNG_DECODER 0
 #define ENABLE_QTRLE_DECODER 0
 #define ENABLE_ROQ_DECODER 0
 #define ENABLE_SGI_DECODER 0
@@ -319,3 +318,5 @@
 #define ENABLE_BFIN      0
 #define ENABLE_SMALL      0
 #define CONFIG_SNOW_ENCODER      1
+#define ENABLE_PNG_DECODER      1
+#define CONFIG_PNG_DECODER      1

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/png.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/png.c	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/png.c	2008-10-03 11:05:09 UTC (rev 4436)
@@ -0,0 +1,938 @@
+/*
+ * PNG image format
+ * Copyright (c) 2003 Fabrice Bellard.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include &quot;avcodec.h&quot;
+#include &quot;bytestream.h&quot;
+
+/* TODO:
+ * - add 2, 4 and 16 bit depth support
+ * - use filters when generating a png (better compression)
+ */
+
+#include &lt;zlib.h&gt;
+
+//#define DEBUG
+
+#define PNG_COLOR_MASK_PALETTE    1
+#define PNG_COLOR_MASK_COLOR      2
+#define PNG_COLOR_MASK_ALPHA      4
+
+#define PNG_COLOR_TYPE_GRAY 0
+#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
+#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
+#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
+#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
+
+#define PNG_FILTER_VALUE_NONE  0
+#define PNG_FILTER_VALUE_SUB   1
+#define PNG_FILTER_VALUE_UP    2
+#define PNG_FILTER_VALUE_AVG   3
+#define PNG_FILTER_VALUE_PAETH 4
+
+#define PNG_IHDR      0x0001
+#define PNG_IDAT      0x0002
+#define PNG_ALLIMAGE  0x0004
+#define PNG_PLTE      0x0008
+
+#define NB_PASSES 7
+
+#define IOBUF_SIZE 4096
+
+typedef struct PNGContext {
+    uint8_t *bytestream;
+    uint8_t *bytestream_start;
+    uint8_t *bytestream_end;
+    AVFrame picture;
+
+    int state;
+    int width, height;
+    int bit_depth;
+    int color_type;
+    int compression_type;
+    int interlace_type;
+    int filter_type;
+    int channels;
+    int bits_per_pixel;
+    int bpp;
+
+    uint8_t *image_buf;
+    int image_linesize;
+    uint32_t palette[256];
+    uint8_t *crow_buf;
+    uint8_t *last_row;
+    uint8_t *tmp_row;
+    int pass;
+    int crow_size; /* compressed row size (include filter type) */
+    int row_size; /* decompressed row size */
+    int pass_row_size; /* decompress row size of the current pass */
+    int y;
+    z_stream zstream;
+    uint8_t buf[IOBUF_SIZE];
+} PNGContext;
+
+static const uint8_t pngsig[8] = {137, 80, 78, 71, 13, 10, 26, 10};
+
+/* Mask to determine which y pixels are valid in a pass */
+static const uint8_t png_pass_ymask[NB_PASSES] = {
+    0x80, 0x80, 0x08, 0x88, 0x22, 0xaa, 0x55,
+};
+
+/* Mask to determine which y pixels can be written in a pass */
+static const uint8_t png_pass_dsp_ymask[NB_PASSES] = {
+    0xff, 0xff, 0x0f, 0xcc, 0x33, 0xff, 0x55,
+};
+
+/* minimum x value */
+static const uint8_t png_pass_xmin[NB_PASSES] = {
+    0, 4, 0, 2, 0, 1, 0
+};
+
+/* x shift to get row width */
+static const uint8_t png_pass_xshift[NB_PASSES] = {
+    3, 3, 2, 2, 1, 1, 0
+};
+
+/* Mask to determine which pixels are valid in a pass */
+static const uint8_t png_pass_mask[NB_PASSES] = {
+    0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff
+};
+
+/* Mask to determine which pixels to overwrite while displaying */
+static const uint8_t png_pass_dsp_mask[NB_PASSES] = {
+    0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff
+};
+#if 0
+static int png_probe(AVProbeData *pd)
+{
+    if (pd-&gt;buf_size &gt;= 8 &amp;&amp;
+        memcmp(pd-&gt;buf, pngsig, 8) == 0)
+        return AVPROBE_SCORE_MAX;
+    else
+        return 0;
+}
+#endif
+static void *png_zalloc(void *opaque, unsigned int items, unsigned int size)
+{
+    if(items &gt;= UINT_MAX / size)
+        return NULL;
+    return av_malloc(items * size);
+}
+
+static void png_zfree(void *opaque, void *ptr)
+{
+    av_free(ptr);
+}
+
+static int png_get_nb_channels(int color_type)
+{
+    int channels;
+    channels = 1;
+    if ((color_type &amp; (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)) ==
+        PNG_COLOR_MASK_COLOR)
+        channels = 3;
+    if (color_type &amp; PNG_COLOR_MASK_ALPHA)
+        channels++;
+    return channels;
+}
+
+/* compute the row size of an interleaved pass */
+static int png_pass_row_size(int pass, int bits_per_pixel, int width)
+{
+    int shift, xmin, pass_width;
+
+    xmin = png_pass_xmin[pass];
+    if (width &lt;= xmin)
+        return 0;
+    shift = png_pass_xshift[pass];
+    pass_width = (width - xmin + (1 &lt;&lt; shift) - 1) &gt;&gt; shift;
+    return (pass_width * bits_per_pixel + 7) &gt;&gt; 3;
+}
+
+/* NOTE: we try to construct a good looking image at each pass. width
+   is the original image width. We also do pixel format convertion at
+   this stage */
+static void png_put_interlaced_row(uint8_t *dst, int width,
+                                   int bits_per_pixel, int pass,
+                                   int color_type, const uint8_t *src)
+{
+    int x, mask, dsp_mask, j, src_x, b, bpp;
+    uint8_t *d;
+    const uint8_t *s;
+
+    mask = png_pass_mask[pass];
+    dsp_mask = png_pass_dsp_mask[pass];
+    switch(bits_per_pixel) {
+    case 1:
+        /* we must initialize the line to zero before writing to it */
+        if (pass == 0)
+            memset(dst, 0, (width + 7) &gt;&gt; 3);
+        src_x = 0;
+        for(x = 0; x &lt; width; x++) {
+            j = (x &amp; 7);
+            if ((dsp_mask &lt;&lt; j) &amp; 0x80) {
+                b = (src[src_x &gt;&gt; 3] &gt;&gt; (7 - (src_x &amp; 7))) &amp; 1;
+                dst[x &gt;&gt; 3] |= b &lt;&lt; (7 - j);
+            }
+            if ((mask &lt;&lt; j) &amp; 0x80)
+                src_x++;
+        }
+        break;
+    default:
+        bpp = bits_per_pixel &gt;&gt; 3;
+        d = dst;
+        s = src;
+        if (color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
+            for(x = 0; x &lt; width; x++) {
+                j = x &amp; 7;
+                if ((dsp_mask &lt;&lt; j) &amp; 0x80) {
+                    *(uint32_t *)d = (s[3] &lt;&lt; 24) | (s[0] &lt;&lt; 16) | (s[1] &lt;&lt; 8) | s[2];
+                }
+                d += bpp;
+                if ((mask &lt;&lt; j) &amp; 0x80)
+                    s += bpp;
+            }
+        } else {
+            for(x = 0; x &lt; width; x++) {
+                j = x &amp; 7;
+                if ((dsp_mask &lt;&lt; j) &amp; 0x80) {
+                    memcpy(d, s, bpp);
+                }
+                d += bpp;
+                if ((mask &lt;&lt; j) &amp; 0x80)
+                    s += bpp;
+            }
+        }
+        break;
+    }
+}
+
+#ifdef CONFIG_ENCODERS
+static void png_get_interlaced_row(uint8_t *dst, int row_size,
+                                   int bits_per_pixel, int pass,
+                                   const uint8_t *src, int width)
+{
+    int x, mask, dst_x, j, b, bpp;
+    uint8_t *d;
+    const uint8_t *s;
+
+    mask = png_pass_mask[pass];
+    switch(bits_per_pixel) {
+    case 1:
+        memset(dst, 0, row_size);
+        dst_x = 0;
+        for(x = 0; x &lt; width; x++) {
+            j = (x &amp; 7);
+            if ((mask &lt;&lt; j) &amp; 0x80) {
+                b = (src[x &gt;&gt; 3] &gt;&gt; (7 - j)) &amp; 1;
+                dst[dst_x &gt;&gt; 3] |= b &lt;&lt; (7 - (dst_x &amp; 7));
+                dst_x++;
+            }
+        }
+        break;
+    default:
+        bpp = bits_per_pixel &gt;&gt; 3;
+        d = dst;
+        s = src;
+        for(x = 0; x &lt; width; x++) {
+            j = x &amp; 7;
+            if ((mask &lt;&lt; j) &amp; 0x80) {
+                memcpy(d, s, bpp);
+                d += bpp;
+            }
+            s += bpp;
+        }
+        break;
+    }
+}
+#endif
+
+/* XXX: optimize */
+/* NOTE: 'dst' can be equal to 'last' */
+static void png_filter_row(uint8_t *dst, int filter_type,
+                           uint8_t *src, uint8_t *last, int size, int bpp)
+{
+    int i, p;
+
+    switch(filter_type) {
+    case PNG_FILTER_VALUE_NONE:
+        memcpy(dst, src, size);
+        break;
+    case PNG_FILTER_VALUE_SUB:
+        for(i = 0; i &lt; bpp; i++) {
+            dst[i] = src[i];
+        }
+        for(i = bpp; i &lt; size; i++) {
+            p = dst[i - bpp];
+            dst[i] = p + src[i];
+        }
+        break;
+    case PNG_FILTER_VALUE_UP:
+        for(i = 0; i &lt; size; i++) {
+            p = last[i];
+            dst[i] = p + src[i];
+        }
+        break;
+    case PNG_FILTER_VALUE_AVG:
+        for(i = 0; i &lt; bpp; i++) {
+            p = (last[i] &gt;&gt; 1);
+            dst[i] = p + src[i];
+        }
+        for(i = bpp; i &lt; size; i++) {
+            p = ((dst[i - bpp] + last[i]) &gt;&gt; 1);
+            dst[i] = p + src[i];
+        }
+        break;
+    case PNG_FILTER_VALUE_PAETH:
+        for(i = 0; i &lt; bpp; i++) {
+            p = last[i];
+            dst[i] = p + src[i];
+        }
+        for(i = bpp; i &lt; size; i++) {
+            int a, b, c, pa, pb, pc;
+
+            a = dst[i - bpp];
+            b = last[i];
+            c = last[i - bpp];
+
+            p = b - c;
+            pc = a - c;
+
+            pa = abs(p);
+            pb = abs(pc);
+            pc = abs(p + pc);
+
+            if (pa &lt;= pb &amp;&amp; pa &lt;= pc)
+                p = a;
+            else if (pb &lt;= pc)
+                p = b;
+            else
+                p = c;
+            dst[i] = p + src[i];
+        }
+        break;
+    }
+}
+
+#ifdef CONFIG_ENCODERS
+static void convert_from_rgb32(uint8_t *dst, const uint8_t *src, int width)
+{
+    uint8_t *d;
+    int j;
+    unsigned int v;
+
+    d = dst;
+    for(j = 0; j &lt; width; j++) {
+        v = ((const uint32_t *)src)[j];
+        d[0] = v &gt;&gt; 16;
+        d[1] = v &gt;&gt; 8;
+        d[2] = v;
+        d[3] = v &gt;&gt; 24;
+        d += 4;
+    }
+}
+#endif
+
+#ifdef CONFIG_DECODERS
+static void convert_to_rgb32(uint8_t *dst, const uint8_t *src, int width)
+{
+    int j;
+    unsigned int r, g, b, a;
+
+    for(j = 0;j &lt; width; j++) {
+        r = src[0];
+        g = src[1];
+        b = src[2];
+        a = src[3];
+        *(uint32_t *)dst = (a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
+        dst += 4;
+        src += 4;
+    }
+}
+
+/* process exactly one decompressed row */
+static void png_handle_row(PNGContext *s)
+{
+    uint8_t *ptr, *last_row;
+    int got_line;
+
+    if (!s-&gt;interlace_type) {
+        ptr = s-&gt;image_buf + s-&gt;image_linesize * s-&gt;y;
+        /* need to swap bytes correctly for RGB_ALPHA */
+        if (s-&gt;color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
+            png_filter_row(s-&gt;tmp_row, s-&gt;crow_buf[0], s-&gt;crow_buf + 1,
+                           s-&gt;last_row, s-&gt;row_size, s-&gt;bpp);
+            memcpy(s-&gt;last_row, s-&gt;tmp_row, s-&gt;row_size);
+            convert_to_rgb32(ptr, s-&gt;tmp_row, s-&gt;width);
+        } else {
+            /* in normal case, we avoid one copy */
+            if (s-&gt;y == 0)
+                last_row = s-&gt;last_row;
+            else
+                last_row = ptr - s-&gt;image_linesize;
+
+            png_filter_row(ptr, s-&gt;crow_buf[0], s-&gt;crow_buf + 1,
+                           last_row, s-&gt;row_size, s-&gt;bpp);
+        }
+        s-&gt;y++;
+        if (s-&gt;y == s-&gt;height) {
+            s-&gt;state |= PNG_ALLIMAGE;
+        }
+    } else {
+        got_line = 0;
+        for(;;) {
+            ptr = s-&gt;image_buf + s-&gt;image_linesize * s-&gt;y;
+            if ((png_pass_ymask[s-&gt;pass] &lt;&lt; (s-&gt;y &amp; 7)) &amp; 0x80) {
+                /* if we already read one row, it is time to stop to
+                   wait for the next one */
+                if (got_line)
+                    break;
+                png_filter_row(s-&gt;tmp_row, s-&gt;crow_buf[0], s-&gt;crow_buf + 1,
+                               s-&gt;last_row, s-&gt;pass_row_size, s-&gt;bpp);
+                memcpy(s-&gt;last_row, s-&gt;tmp_row, s-&gt;pass_row_size);
+                got_line = 1;
+            }
+            if ((png_pass_dsp_ymask[s-&gt;pass] &lt;&lt; (s-&gt;y &amp; 7)) &amp; 0x80) {
+                /* NOTE: RGB32 is handled directly in png_put_interlaced_row */
+                png_put_interlaced_row(ptr, s-&gt;width, s-&gt;bits_per_pixel, s-&gt;pass,
+                                       s-&gt;color_type, s-&gt;last_row);
+            }
+            s-&gt;y++;
+            if (s-&gt;y == s-&gt;height) {
+                for(;;) {
+                    if (s-&gt;pass == NB_PASSES - 1) {
+                        s-&gt;state |= PNG_ALLIMAGE;
+                        goto the_end;
+                    } else {
+                        s-&gt;pass++;
+                        s-&gt;y = 0;
+                        s-&gt;pass_row_size = png_pass_row_size(s-&gt;pass,
+                                                             s-&gt;bits_per_pixel,
+                                                             s-&gt;width);
+                        s-&gt;crow_size = s-&gt;pass_row_size + 1;
+                        if (s-&gt;pass_row_size != 0)
+                            break;
+                        /* skip pass if empty row */
+                    }
+                }
+            }
+        }
+    the_end: ;
+    }
+}
+
+static int png_decode_idat(PNGContext *s, int length)
+{
+    int ret;
+    s-&gt;zstream.avail_in = length;
+    s-&gt;zstream.next_in = s-&gt;bytestream;
+    s-&gt;bytestream += length;
+
+    if(s-&gt;bytestream &gt; s-&gt;bytestream_end)
+        return -1;
+
+    /* decode one line if possible */
+    while (s-&gt;zstream.avail_in &gt; 0) {
+        ret = inflate(&amp;s-&gt;zstream, Z_PARTIAL_FLUSH);
+        if (ret != Z_OK &amp;&amp; ret != Z_STREAM_END) {
+            return -1;
+        }
+        if (s-&gt;zstream.avail_out == 0) {
+            if (!(s-&gt;state &amp; PNG_ALLIMAGE)) {
+                png_handle_row(s);
+            }
+            s-&gt;zstream.avail_out = s-&gt;crow_size;
+            s-&gt;zstream.next_out = s-&gt;crow_buf;
+        }
+    }
+    return 0;
+}
+
+static int decode_frame(AVCodecContext *avctx,
+                        void *data, int *data_size,
+                        uint8_t *buf, int buf_size)
+{
+    PNGContext * const s = avctx-&gt;priv_data;
+    AVFrame *picture = data;
+    AVFrame * const p= (AVFrame*)&amp;s-&gt;picture;
+    uint32_t tag, length;
+    int ret, crc;
+
+    s-&gt;bytestream_start=
+    s-&gt;bytestream= buf;
+    s-&gt;bytestream_end= buf + buf_size;
+
+    /* check signature */
+    if (memcmp(s-&gt;bytestream, pngsig, 8) != 0)
+        return -1;
+    s-&gt;bytestream+= 8;
+    s-&gt;y=
+    s-&gt;state=0;
+//    memset(s, 0, sizeof(PNGContext));
+    /* init the zlib */
+    s-&gt;zstream.zalloc = png_zalloc;
+    s-&gt;zstream.zfree = png_zfree;
+    s-&gt;zstream.opaque = NULL;
+    ret = inflateInit(&amp;s-&gt;zstream);
+    if (ret != Z_OK)
+        return -1;
+    for(;;) {
+        int tag32;
+        if (s-&gt;bytestream &gt;= s-&gt;bytestream_end)
+            goto fail;
+        length = bytestream_get_be32(&amp;s-&gt;bytestream);
+        if (length &gt; 0x7fffffff)
+            goto fail;
+        tag32 = bytestream_get_be32(&amp;s-&gt;bytestream);
+        tag = bswap_32(tag32);
+#ifdef DEBUG
+        av_log(avctx, AV_LOG_DEBUG, &quot;png: tag=%c%c%c%c length=%u\n&quot;,
+               (tag &amp; 0xff),
+               ((tag &gt;&gt; 8) &amp; 0xff),
+               ((tag &gt;&gt; 16) &amp; 0xff),
+               ((tag &gt;&gt; 24) &amp; 0xff), length);
+#endif
+        switch(tag) {
+        case MKTAG('I', 'H', 'D', 'R'):
+            if (length != 13)
+                goto fail;
+            s-&gt;width = bytestream_get_be32(&amp;s-&gt;bytestream);
+            s-&gt;height = bytestream_get_be32(&amp;s-&gt;bytestream);
+            if(avcodec_check_dimensions(avctx, s-&gt;width, s-&gt;height)){
+                s-&gt;width= s-&gt;height= 0;
+                goto fail;
+            }
+            s-&gt;bit_depth = *s-&gt;bytestream++;
+            s-&gt;color_type = *s-&gt;bytestream++;
+            s-&gt;compression_type = *s-&gt;bytestream++;
+            s-&gt;filter_type = *s-&gt;bytestream++;
+            s-&gt;interlace_type = *s-&gt;bytestream++;
+            crc = bytestream_get_be32(&amp;s-&gt;bytestream);
+            s-&gt;state |= PNG_IHDR;
+#ifdef DEBUG
+            av_log(avctx, AV_LOG_DEBUG, &quot;width=%d height=%d depth=%d color_type=%d compression_type=%d filter_type=%d interlace_type=%d\n&quot;,
+                   s-&gt;width, s-&gt;height, s-&gt;bit_depth, s-&gt;color_type,
+                   s-&gt;compression_type, s-&gt;filter_type, s-&gt;interlace_type);
+#endif
+            break;
+        case MKTAG('I', 'D', 'A', 'T'):
+            if (!(s-&gt;state &amp; PNG_IHDR))
+                goto fail;
+            if (!(s-&gt;state &amp; PNG_IDAT)) {
+                /* init image info */
+                avctx-&gt;width = s-&gt;width;
+                avctx-&gt;height = s-&gt;height;
+
+                s-&gt;channels = png_get_nb_channels(s-&gt;color_type);
+                s-&gt;bits_per_pixel = s-&gt;bit_depth * s-&gt;channels;
+                s-&gt;bpp = (s-&gt;bits_per_pixel + 7) &gt;&gt; 3;
+                s-&gt;row_size = (avctx-&gt;width * s-&gt;bits_per_pixel + 7) &gt;&gt; 3;
+
+                if (s-&gt;bit_depth == 8 &amp;&amp;
+                    s-&gt;color_type == PNG_COLOR_TYPE_RGB) {
+                    avctx-&gt;pix_fmt = PIX_FMT_RGB24;
+                } else if (s-&gt;bit_depth == 8 &amp;&amp;
+                           s-&gt;color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
+                    avctx-&gt;pix_fmt = PIX_FMT_RGB32;
+                } else if (s-&gt;bit_depth == 8 &amp;&amp;
+                           s-&gt;color_type == PNG_COLOR_TYPE_GRAY) {
+                    avctx-&gt;pix_fmt = PIX_FMT_GRAY8;
+                } else if (s-&gt;bit_depth == 16 &amp;&amp;
+                           s-&gt;color_type == PNG_COLOR_TYPE_GRAY) {
+                    avctx-&gt;pix_fmt = PIX_FMT_GRAY16BE;
+                } else if (s-&gt;bit_depth == 1 &amp;&amp;
+                           s-&gt;color_type == PNG_COLOR_TYPE_GRAY) {
+                    avctx-&gt;pix_fmt = PIX_FMT_MONOBLACK;
+                } else if (s-&gt;color_type == PNG_COLOR_TYPE_PALETTE) {
+                    avctx-&gt;pix_fmt = PIX_FMT_PAL8;
+                } else {
+                    goto fail;
+                }
+                if(p-&gt;data[0])
+                    avctx-&gt;release_buffer(avctx, p);
+
+                p-&gt;reference= 0;
+                if(avctx-&gt;get_buffer(avctx, p) &lt; 0){
+                    av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed\n&quot;);
+                    goto fail;
+                }
+                p-&gt;pict_type= FF_I_TYPE;
+                p-&gt;key_frame= 1;
+                p-&gt;interlaced_frame = !!s-&gt;interlace_type;
+
+                /* compute the compressed row size */
+                if (!s-&gt;interlace_type) {
+                    s-&gt;crow_size = s-&gt;row_size + 1;
+                } else {
+                    s-&gt;pass = 0;
+                    s-&gt;pass_row_size = png_pass_row_size(s-&gt;pass,
+                                                         s-&gt;bits_per_pixel,
+                                                         s-&gt;width);
+                    s-&gt;crow_size = s-&gt;pass_row_size + 1;
+                }
+#ifdef DEBUG
+                av_log(avctx, AV_LOG_DEBUG, &quot;row_size=%d crow_size =%d\n&quot;,
+                       s-&gt;row_size, s-&gt;crow_size);
+#endif
+                s-&gt;image_buf = p-&gt;data[0];
+                s-&gt;image_linesize = p-&gt;linesize[0];
+                /* copy the palette if needed */
+                if (s-&gt;color_type == PNG_COLOR_TYPE_PALETTE)
+                    memcpy(p-&gt;data[1], s-&gt;palette, 256 * sizeof(uint32_t));
+                /* empty row is used if differencing to the first row */
+                s-&gt;last_row = av_mallocz(s-&gt;row_size);
+                if (!s-&gt;last_row)
+                    goto fail;
+                if (s-&gt;interlace_type ||
+                    s-&gt;color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
+                    s-&gt;tmp_row = av_malloc(s-&gt;row_size);
+                    if (!s-&gt;tmp_row)
+                        goto fail;
+                }
+                /* compressed row */
+                s-&gt;crow_buf = av_malloc(s-&gt;row_size + 1);
+                if (!s-&gt;crow_buf)
+                    goto fail;
+                s-&gt;zstream.avail_out = s-&gt;crow_size;
+                s-&gt;zstream.next_out = s-&gt;crow_buf;
+            }
+            s-&gt;state |= PNG_IDAT;
+            if (png_decode_idat(s, length) &lt; 0)
+                goto fail;
+            /* skip crc */
+            crc = bytestream_get_be32(&amp;s-&gt;bytestream);
+            break;
+        case MKTAG('P', 'L', 'T', 'E'):
+            {
+                int n, i, r, g, b;
+
+                if ((length % 3) != 0 || length &gt; 256 * 3)
+                    goto skip_tag;
+                /* read the palette */
+                n = length / 3;
+                for(i=0;i&lt;n;i++) {
+                    r = *s-&gt;bytestream++;
+                    g = *s-&gt;bytestream++;
+                    b = *s-&gt;bytestream++;
+                    s-&gt;palette[i] = (0xff &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
+                }
+                for(;i&lt;256;i++) {
+                    s-&gt;palette[i] = (0xff &lt;&lt; 24);
+                }
+                s-&gt;state |= PNG_PLTE;
+                crc = bytestream_get_be32(&amp;s-&gt;bytestream);
+            }
+            break;
+        case MKTAG('t', 'R', 'N', 'S'):
+            {
+                int v, i;
+
+                /* read the transparency. XXX: Only palette mode supported */
+                if (s-&gt;color_type != PNG_COLOR_TYPE_PALETTE ||
+                    length &gt; 256 ||
+                    !(s-&gt;state &amp; PNG_PLTE))
+                    goto skip_tag;
+                for(i=0;i&lt;length;i++) {
+                    v = *s-&gt;bytestream++;
+                    s-&gt;palette[i] = (s-&gt;palette[i] &amp; 0x00ffffff) | (v &lt;&lt; 24);
+                }
+                crc = bytestream_get_be32(&amp;s-&gt;bytestream);
+            }
+            break;
+        case MKTAG('I', 'E', 'N', 'D'):
+            if (!(s-&gt;state &amp; PNG_ALLIMAGE))
+                goto fail;
+            crc = bytestream_get_be32(&amp;s-&gt;bytestream);
+            goto exit_loop;
+        default:
+            /* skip tag */
+        skip_tag:
+            s-&gt;bytestream += length + 4;
+            break;
+        }
+    }
+ exit_loop:
+    *picture= *(AVFrame*)&amp;s-&gt;picture;
+    *data_size = sizeof(AVPicture);
+
+    ret = s-&gt;bytestream - s-&gt;bytestream_start;
+ the_end:
+    inflateEnd(&amp;s-&gt;zstream);
+    av_freep(&amp;s-&gt;crow_buf);
+    av_freep(&amp;s-&gt;last_row);
+    av_freep(&amp;s-&gt;tmp_row);
+    return ret;
+ fail:
+    ret = -1;
+    goto the_end;
+}
+#endif
+
+#ifdef CONFIG_ENCODERS
+static void png_write_chunk(uint8_t **f, uint32_t tag,
+                            const uint8_t *buf, int length)
+{
+    uint32_t crc;
+    uint8_t tagbuf[4];
+
+    bytestream_put_be32(f, length);
+    crc = crc32(0, Z_NULL, 0);
+    AV_WL32(tagbuf, tag);
+    crc = crc32(crc, tagbuf, 4);
+    bytestream_put_be32(f, bswap_32(tag));
+    if (length &gt; 0) {
+        crc = crc32(crc, buf, length);
+        memcpy(*f, buf, length);
+        *f += length;
+    }
+    bytestream_put_be32(f, crc);
+}
+
+/* XXX: do filtering */
+static int png_write_row(PNGContext *s, const uint8_t *data, int size)
+{
+    int ret;
+
+    s-&gt;zstream.avail_in = size;
+    s-&gt;zstream.next_in = (uint8_t *)data;
+    while (s-&gt;zstream.avail_in &gt; 0) {
+        ret = deflate(&amp;s-&gt;zstream, Z_NO_FLUSH);
+        if (ret != Z_OK)
+            return -1;
+        if (s-&gt;zstream.avail_out == 0) {
+            if(s-&gt;bytestream_end - s-&gt;bytestream &gt; IOBUF_SIZE + 100)
+                png_write_chunk(&amp;s-&gt;bytestream, MKTAG('I', 'D', 'A', 'T'), s-&gt;buf, IOBUF_SIZE);
+            s-&gt;zstream.avail_out = IOBUF_SIZE;
+            s-&gt;zstream.next_out = s-&gt;buf;
+        }
+    }
+    return 0;
+}
+#endif /* CONFIG_ENCODERS */
+
+static int common_init(AVCodecContext *avctx){
+    PNGContext *s = avctx-&gt;priv_data;
+
+    avcodec_get_frame_defaults((AVFrame*)&amp;s-&gt;picture);
+    avctx-&gt;coded_frame= (AVFrame*)&amp;s-&gt;picture;
+//    s-&gt;avctx= avctx;
+
+    return 0;
+}
+
+#ifdef CONFIG_ENCODERS
+static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){
+    PNGContext *s = avctx-&gt;priv_data;
+    AVFrame *pict = data;
+    AVFrame * const p= (AVFrame*)&amp;s-&gt;picture;
+    int bit_depth, color_type, y, len, row_size, ret, is_progressive;
+    int bits_per_pixel, pass_row_size;
+    uint8_t *ptr;
+    uint8_t *crow_buf = NULL;
+    uint8_t *tmp_buf = NULL;
+
+    *p = *pict;
+    p-&gt;pict_type= FF_I_TYPE;
+    p-&gt;key_frame= 1;
+
+    s-&gt;bytestream_start=
+    s-&gt;bytestream= buf;
+    s-&gt;bytestream_end= buf+buf_size;
+
+    is_progressive = !!(avctx-&gt;flags &amp; CODEC_FLAG_INTERLACED_DCT);
+    switch(avctx-&gt;pix_fmt) {
+    case PIX_FMT_RGB32:
+        bit_depth = 8;
+        color_type = PNG_COLOR_TYPE_RGB_ALPHA;
+        break;
+    case PIX_FMT_RGB24:
+        bit_depth = 8;
+        color_type = PNG_COLOR_TYPE_RGB;
+        break;
+    case PIX_FMT_GRAY8:
+        bit_depth = 8;
+        color_type = PNG_COLOR_TYPE_GRAY;
+        break;
+    case PIX_FMT_MONOBLACK:
+        bit_depth = 1;
+        color_type = PNG_COLOR_TYPE_GRAY;
+        break;
+    case PIX_FMT_PAL8:
+        bit_depth = 8;
+        color_type = PNG_COLOR_TYPE_PALETTE;
+        break;
+    default:
+        return -1;
+    }
+    bits_per_pixel = png_get_nb_channels(color_type) * bit_depth;
+    row_size = (avctx-&gt;width * bits_per_pixel + 7) &gt;&gt; 3;
+
+    s-&gt;zstream.zalloc = png_zalloc;
+    s-&gt;zstream.zfree = png_zfree;
+    s-&gt;zstream.opaque = NULL;
+    ret = deflateInit2(&amp;s-&gt;zstream, Z_DEFAULT_COMPRESSION,
+                       Z_DEFLATED, 15, 8, Z_DEFAULT_STRATEGY);
+    if (ret != Z_OK)
+        return -1;
+    crow_buf = av_malloc(row_size + 1);
+    if (!crow_buf)
+        goto fail;
+    if (is_progressive) {
+        tmp_buf = av_malloc(row_size + 1);
+        if (!tmp_buf)
+            goto fail;
+    }
+
+    /* write png header */
+    memcpy(s-&gt;bytestream, pngsig, 8);
+    s-&gt;bytestream += 8;
+
+    AV_WB32(s-&gt;buf, avctx-&gt;width);
+    AV_WB32(s-&gt;buf + 4, avctx-&gt;height);
+    s-&gt;buf[8] = bit_depth;
+    s-&gt;buf[9] = color_type;
+    s-&gt;buf[10] = 0; /* compression type */
+    s-&gt;buf[11] = 0; /* filter type */
+    s-&gt;buf[12] = is_progressive; /* interlace type */
+
+    png_write_chunk(&amp;s-&gt;bytestream, MKTAG('I', 'H', 'D', 'R'), s-&gt;buf, 13);
+
+    /* put the palette if needed */
+    if (color_type == PNG_COLOR_TYPE_PALETTE) {
+        int has_alpha, alpha, i;
+        unsigned int v;
+        uint32_t *palette;
+        uint8_t *alpha_ptr;
+
+        palette = (uint32_t *)p-&gt;data[1];
+        ptr = s-&gt;buf;
+        alpha_ptr = s-&gt;buf + 256 * 3;
+        has_alpha = 0;
+        for(i = 0; i &lt; 256; i++) {
+            v = palette[i];
+            alpha = v &gt;&gt; 24;
+            if (alpha &amp;&amp; alpha != 0xff)
+                has_alpha = 1;
+            *alpha_ptr++ = alpha;
+            bytestream_put_be24(&amp;ptr, v);
+        }
+        png_write_chunk(&amp;s-&gt;bytestream, MKTAG('P', 'L', 'T', 'E'), s-&gt;buf, 256 * 3);
+        if (has_alpha) {
+            png_write_chunk(&amp;s-&gt;bytestream, MKTAG('t', 'R', 'N', 'S'), s-&gt;buf + 256 * 3, 256);
+        }
+    }
+
+    /* now put each row */
+    s-&gt;zstream.avail_out = IOBUF_SIZE;
+    s-&gt;zstream.next_out = s-&gt;buf;
+    if (is_progressive) {
+        uint8_t *ptr1;
+        int pass;
+
+        for(pass = 0; pass &lt; NB_PASSES; pass++) {
+            /* NOTE: a pass is completely omited if no pixels would be
+               output */
+            pass_row_size = png_pass_row_size(pass, bits_per_pixel, avctx-&gt;width);
+            if (pass_row_size &gt; 0) {
+                for(y = 0; y &lt; avctx-&gt;height; y++) {
+                    if ((png_pass_ymask[pass] &lt;&lt; (y &amp; 7)) &amp; 0x80) {
+                        ptr = p-&gt;data[0] + y * p-&gt;linesize[0];
+                        if (color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
+                            convert_from_rgb32(tmp_buf, ptr, avctx-&gt;width);
+                            ptr1 = tmp_buf;
+                        } else {
+                            ptr1 = ptr;
+                        }
+                        png_get_interlaced_row(crow_buf + 1, pass_row_size,
+                                               bits_per_pixel, pass,
+                                               ptr1, avctx-&gt;width);
+                        crow_buf[0] = PNG_FILTER_VALUE_NONE;
+                        png_write_row(s, crow_buf, pass_row_size + 1);
+                    }
+                }
+            }
+        }
+    } else {
+        for(y = 0; y &lt; avctx-&gt;height; y++) {
+            ptr = p-&gt;data[0] + y * p-&gt;linesize[0];
+            if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+                convert_from_rgb32(crow_buf + 1, ptr, avctx-&gt;width);
+            else
+                memcpy(crow_buf + 1, ptr, row_size);
+            crow_buf[0] = PNG_FILTER_VALUE_NONE;
+            png_write_row(s, crow_buf, row_size + 1);
+        }
+    }
+    /* compress last bytes */
+    for(;;) {
+        ret = deflate(&amp;s-&gt;zstream, Z_FINISH);
+        if (ret == Z_OK || ret == Z_STREAM_END) {
+            len = IOBUF_SIZE - s-&gt;zstream.avail_out;
+            if (len &gt; 0 &amp;&amp; s-&gt;bytestream_end - s-&gt;bytestream &gt; len + 100) {
+                png_write_chunk(&amp;s-&gt;bytestream, MKTAG('I', 'D', 'A', 'T'), s-&gt;buf, len);
+            }
+            s-&gt;zstream.avail_out = IOBUF_SIZE;
+            s-&gt;zstream.next_out = s-&gt;buf;
+            if (ret == Z_STREAM_END)
+                break;
+        } else {
+            goto fail;
+        }
+    }
+    png_write_chunk(&amp;s-&gt;bytestream, MKTAG('I', 'E', 'N', 'D'), NULL, 0);
+
+    ret = s-&gt;bytestream - s-&gt;bytestream_start;
+ the_end:
+    av_free(crow_buf);
+    av_free(tmp_buf);
+    deflateEnd(&amp;s-&gt;zstream);
+    return ret;
+ fail:
+    ret = -1;
+    goto the_end;
+}
+#endif
+
+#ifdef CONFIG_PNG_DECODER
+AVCodec png_decoder = {
+    &quot;png&quot;,
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_PNG,
+    sizeof(PNGContext),
+    common_init,
+    NULL,
+    NULL, //decode_end,
+    decode_frame,
+    0 /*CODEC_CAP_DR1*/ /*| CODEC_CAP_DRAW_HORIZ_BAND*/,
+    NULL
+};
+#endif
+
+#ifdef CONFIG_PNG_ENCODER
+AVCodec png_encoder = {
+    &quot;png&quot;,
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_PNG,
+    sizeof(PNGContext),
+    common_init,
+    encode_frame,
+    NULL, //encode_end,
+    .pix_fmts= (enum PixelFormat[]){PIX_FMT_RGB24, PIX_FMT_RGB32, PIX_FMT_PAL8, PIX_FMT_GRAY8, PIX_FMT_MONOBLACK, -1},
+};
+#endif // CONFIG_PNG_ENCODER

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_imageLoader.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_imageLoader.cpp	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_imageLoader.cpp	2008-10-03 11:05:09 UTC (rev 4436)
@@ -30,7 +30,6 @@
 
 #include &quot;ADM_codecs/ADM_codec.h&quot;
 #include &quot;ADM_codecs/ADM_ffmp43.h&quot;
-#include &quot;ADM_codecs/ADM_png.h&quot;
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 #include &quot;ADM_toolkit/bitmap.h&quot;
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
@@ -339,7 +338,7 @@
     
  	   ADMImage tmpImage(w,h,1);
     	// Decode PNG
-    	decoderPng decoder(w,h);
+    	decoderFFPng decoder(w,h);
     	ADMCompressedImage bin;
     	bin.data=data;
     	bin.dataLength=size; // This is more than actually, but who cares...
@@ -347,9 +346,14 @@
     	decoder.uncompress (&amp;bin, &amp;tmpImage);
     	
     	ADMImage *image=new ADMImage(w,h);
-    	COL_RGB24_to_YV12( w, h,tmpImage._planes[0],image-&gt;data);
-    
+
+		COL_Generic2YV12 *convert = new COL_Generic2YV12(tmpImage._width, tmpImage._height, tmpImage._colorspace);
+
+		convert-&gt;transform(tmpImage._planes, tmpImage._planeStride, image-&gt;data);
+
+    	delete convert;
     	delete [] data;
+
     	return image;		
 }
 /**

Modified: branches/avidemux_2.4_branch/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/CMakeLists.txt	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/avidemux/CMakeLists.txt	2008-10-03 11:05:09 UTC (rev 4436)
@@ -274,23 +274,6 @@
 	add_libs_all_targets(fontconfig)
 endif(USE_FONTCONFIG)
 
-# png
-if(USE_PNG)
-	TARGET_LINK_LIBRARIES(avidemux2_cli png)
-	
-	if(GTK_FOUND)
-		TARGET_LINK_LIBRARIES(avidemux2_gtk png)
-	endif(GTK_FOUND)
-	
-	if (QT4_FOUND)
-		if (ADM_OS_APPLE AND NOT QT_USE_FRAMEWORKS)
-			TARGET_LINK_LIBRARIES(avidemux2_qt4 png)
-		elseif (NOT ADM_OS_APPLE)
-			TARGET_LINK_LIBRARIES(avidemux2_qt4 png)
-		endif (ADM_OS_APPLE AND NOT QT_USE_FRAMEWORKS)
-	endif (QT4_FOUND)
-endif(USE_PNG)
-
 # Xml2
 add_libs_all_targets(xml2)
 

Modified: branches/avidemux_2.4_branch/config.h.cmake
===================================================================
--- branches/avidemux_2.4_branch/config.h.cmake	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/config.h.cmake	2008-10-03 11:05:09 UTC (rev 4436)
@@ -230,9 +230,6 @@
 /* use libmad */
 #cmakedefine USE_MP3
 
-/* libpng is available */
-#cmakedefine USE_PNG
-
 /* use libsamplerate */
 #cmakedefine USE_SRC
 

Modified: branches/avidemux_2.4_branch/configure.in.in
===================================================================
--- branches/avidemux_2.4_branch/configure.in.in	2008-10-02 21:03:22 UTC (rev 4435)
+++ branches/avidemux_2.4_branch/configure.in.in	2008-10-03 11:05:09 UTC (rev 4436)
@@ -651,16 +651,6 @@
 	fi
 fi
 
-dnl __________________ libpng _________________
-AC_MSG_CHECKING(for libpng)
-have_png=yes
-AC_CHECK_HEADER(png.h,,have_png=no)
-AC_CHECK_LIB(png,png_malloc,,have_png=no)
- 
-if test &quot;x$have_png&quot; = &quot;xyes&quot;; then
-	AC_DEFINE(USE_PNG,1,[libpng is available])
-fi
-
 dnl _______________ OS dep stuff ______________
 
 dnl ------- lrintf --------
@@ -1408,6 +1398,8 @@
 AC_DEFINE(CONFIG_DVVIDEO_DECODER,1,[CONFIG_FFV1_ENCODER])
 AC_DEFINE(CONFIG_WMV2_DECODER,1,[CONFIG_FFV1_ENCODER])
 AC_DEFINE(CONFIG_WMV1_DECODER,1,[CONFIG_FFV1_ENCODER])
+AC_DEFINE(CONFIG_PNG_DECODER,1,[CONFIG_PNG_DECODER])
+AC_DEFINE(ENABLE_PNG_DECODER,1,[ENABLE_PNG_DECODER])
 AC_DEFINE(CONFIG_MUXERS,1,[CONFIG_MUXERS])
 AC_DEFINE(CONFIG_TG2_MUXER,1,[CONFIG_MUXERS])
 AC_DEFINE(CONFIG_TGP_MUXER,1,[CONFIG_MUXERS])


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001675.html">[Avidemux-svn-commit] r4435 - in	branches/avidemux_2.4_branch/platforms/windows:	build_scripts/avidemux_2.4 installer
</A></li>
	<LI>Next message: <A HREF="001677.html">[Avidemux-svn-commit] r4437 -	branches/avidemux_2.4_branch/platforms/windows/installer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1676">[ date ]</a>
              <a href="thread.html#1676">[ thread ]</a>
              <a href="subject.html#1676">[ subject ]</a>
              <a href="author.html#1676">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
