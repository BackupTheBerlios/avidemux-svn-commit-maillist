<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4184 - in	branches/avidemux_2.5_branch_gruntster: avidemux	avidemux/ADM_audiodevice	avidemux/ADM_userInterfaces/ADM_commonUI cmake plugins	plugins/ADM_audioDevices plugins/ADM_audioDevices/Alsa	plugins/ADM_audioDevices/Arts plugins/ADM_audioDevices/AudioCore	plugins/ADM_audioDevices/Esd plugins/ADM_audioDevices/Jack	plugins/ADM_audioDevices/Oss plugins/ADM_audioDevices/Sdl	plugins/ADM_audioDevices/Win32
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4184%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster%3A%20avidemux%0A%09avidemux/ADM_audiodevice%0A%09avidemux/ADM_userInterfaces/ADM_commonUI%20cmake%20plugins%0A%09plugins/ADM_audioDevices%20plugins/ADM_audioDevices/Alsa%0A%09plugins/ADM_audioDevices/Arts%20plugins/ADM_audioDevices/AudioCore%0A%09plugins/ADM_audioDevices/Esd%20plugins/ADM_audioDevices/Jack%0A%09plugins/ADM_audioDevices/Oss%20plugins/ADM_audioDevices/Sdl%0A%09plugins/ADM_audioDevices/Win32&In-Reply-To=%3C200807031929.m63JTRrA029122%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001436.html">
   <LINK REL="Next"  HREF="001439.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4184 - in	branches/avidemux_2.5_branch_gruntster: avidemux	avidemux/ADM_audiodevice	avidemux/ADM_userInterfaces/ADM_commonUI cmake plugins	plugins/ADM_audioDevices plugins/ADM_audioDevices/Alsa	plugins/ADM_audioDevices/Arts plugins/ADM_audioDevices/AudioCore	plugins/ADM_audioDevices/Esd plugins/ADM_audioDevices/Jack	plugins/ADM_audioDevices/Oss plugins/ADM_audioDevices/Sdl	plugins/ADM_audioDevices/Win32</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4184%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster%3A%20avidemux%0A%09avidemux/ADM_audiodevice%0A%09avidemux/ADM_userInterfaces/ADM_commonUI%20cmake%20plugins%0A%09plugins/ADM_audioDevices%20plugins/ADM_audioDevices/Alsa%0A%09plugins/ADM_audioDevices/Arts%20plugins/ADM_audioDevices/AudioCore%0A%09plugins/ADM_audioDevices/Esd%20plugins/ADM_audioDevices/Jack%0A%09plugins/ADM_audioDevices/Oss%20plugins/ADM_audioDevices/Sdl%0A%09plugins/ADM_audioDevices/Win32&In-Reply-To=%3C200807031929.m63JTRrA029122%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4184 - in	branches/avidemux_2.5_branch_gruntster: avidemux	avidemux/ADM_audiodevice	avidemux/ADM_userInterfaces/ADM_commonUI cmake plugins	plugins/ADM_audioDevices plugins/ADM_audioDevices/Alsa	plugins/ADM_audioDevices/Arts plugins/ADM_audioDevices/AudioCore	plugins/ADM_audioDevices/Esd plugins/ADM_audioDevices/Jack	plugins/ADM_audioDevices/Oss plugins/ADM_audioDevices/Sdl	plugins/ADM_audioDevices/Win32">mean at mail.berlios.de
       </A><BR>
    <I>Thu Jul  3 21:29:27 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001436.html">[Avidemux-svn-commit] r4183 -	branches/avidemux_2.5_branch_gruntster/plugins
</A></li>
        <LI>Next message: <A HREF="001439.html">[Avidemux-svn-commit] r4185 - in	branches/avidemux_2.5_branch_gruntster: . avidemux	avidemux/ADM_audiodevice	avidemux/ADM_userInterfaces/ADM_commonUI cmake	plugins/ADM_audioDevices plugins/ADM_audioDevices/Alsa	plugins/ADM_audioDevices/Esd	plugins/ADM_audioDevices/PulseAudioSimple
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1437">[ date ]</a>
              <a href="thread.html#1437">[ thread ]</a>
              <a href="subject.html#1437">[ subject ]</a>
              <a href="author.html#1437">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-07-03 21:29:25 +0200 (Thu, 03 Jul 2008)
New Revision: 4184

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audioDeviceInternal.h
   branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
Log:
[AudioDevice] Skeleton for plugins


Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audioDeviceInternal.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audioDeviceInternal.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audioDeviceInternal.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,82 @@
+/**
+    \fn ADM_audioDeviceInternal.h
+    \brief Macros and stuff to write audioDevice plugins
+
+
+
+*/
+#ifndef ADM_audioDeviceInternal_H
+#define ADM_audioDeviceInternal_H
+
+#define ADM_AUDIO_DEVICE_API_VERSION 1
+#include &quot;ADM_dynamicLoading.h&quot;
+class ADM_AudioDevices :public ADM_LibWrapper
+{
+public:
+        int         initialised;
+        audioDevice *(*createAudioDevice)();
+        void         (*deleteAudioDevice)(audioDevice *device);
+        uint8_t      (*getVersion)(uint32_t *major,uint32_t *minor,uint32_t *patch);
+        // Only initialized once
+        const char    *name;
+        const char    *descriptor;
+        uint32_t apiVersion;
+
+        ADM_AudioDevices(const char *file) : ADM_LibWrapper()
+		{
+        const char   *(*getDescriptor)();
+        uint32_t     (*getApiVersion)();
+        const char  *(*getAudioDeviceName)();
+
+			initialised = (loadLibrary(file) &amp;&amp; getSymbols(6,
+				&amp;createAudioDevice, &quot;create&quot;,
+				&amp;deleteAudioDevice, &quot;destroy&quot;,
+
+				&amp;getAudioDeviceName, &quot;getName&quot;,
+				&amp;getApiVersion, &quot;getApiVersion&quot;,
+				&amp;getVersion, &quot;getVersion&quot;,
+				&amp;getDescriptor, &quot;getDescriptor&quot;));
+                if(initialised)
+                {
+                    name=getAudioDeviceName();
+                    apiVersion=getApiVersion();
+                    descriptor=getDescriptor();
+                    printf(&quot;Name :%s ApiVersion :%d\n&quot;,name,apiVersion);
+                }else
+                {
+                    printf(&quot;Symbol loading failed for %s\n&quot;,file);
+                }
+		}
+        ADM_AudioDevices(const char *name,const char *desc, 
+                                uint8_t      (*getVersion)(uint32_t *major,uint32_t *minor,uint32_t *patch),
+                                audioDevice *(*createAudioDevice)(),
+                                void         (*deleteAudioDevice)(audioDevice *device)) : ADM_LibWrapper()
+		{
+
+                    this-&gt;name=name;
+                    this-&gt;descriptor=desc;
+                    this-&gt;apiVersion=ADM_AUDIO_DEVICE_API_VERSION;
+                    this-&gt;createAudioDevice=createAudioDevice;
+                    this-&gt;deleteAudioDevice=deleteAudioDevice;
+                    this-&gt;getVersion=getVersion;
+                    
+		}
+      
+};
+
+#define ADM_DECLARE_AUDIODEVICE(name,Class,major,minor,patch,desc) \
+extern &quot;C&quot; { \
+const char *getName(void) {return #name;}\
+uint32_t getApiVersion(void) {return ADM_AUDIO_DEVICE_API_VERSION;} \
+const char *getDescriptor(void ) {return desc;} \
+ audioDevice *create(void){return new Class;} \
+ void destroy(audioDevice *z){Class *a=(Class *)z;delete a;} \
+uint8_t getVersion(uint32_t *mmajor,uint32_t *mminor,uint32_t *ppatch) \
+    {\
+        *mmajor=major;\
+        *mminor=minor;\
+        *ppatch=patch;\
+        return 1;\
+    } \
+}
+#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -14,169 +14,199 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include &quot;config.h&quot;
+#include &lt;vector&gt;
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_audiodevice.h&quot;
+#include &quot;audio_out.h&quot;
+#include &quot;ADM_audioDeviceInternal.h&quot;
+#include &quot;prefs.h&quot;
 
-#ifdef HAVE_AUDIO
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;errno.h&gt;
+std::vector &lt;ADM_AudioDevices *&gt; ListOfAudioDevices;
 
-#include &quot;avi_vars.h&quot;
-#include &quot;prefs.h&quot;
 
-#include &quot;ADM_assert.h&quot;
-#include &quot;ADM_audiodevice.h&quot;
+static audioDevice *device=NULL;
+static AUDIO_DEVICE  currentDevice=0; //0 is always dummy
 
-#include &quot;ADM_audiodevice/ADM_deviceoss.h&quot;
+static AUDIO_DEVICE ADM_audioByName(const char *name);
+static const char *ADM_audioById(AUDIO_DEVICE id);
 
-#ifdef USE_ARTS
-#include &lt;artsc.h&gt;
-#include &quot;ADM_audiodevice/ADM_deviceArts.h&quot;
-#endif
 
-#ifdef ALSA_SUPPORT
-#include &quot;ADM_audiodevice/ADM_deviceALSA.h&quot;
-#endif
+// --------- couple of stubs for dummy device  -------------
+static uint8_t      DummyGetVersion(uint32_t *major,uint32_t *minor,uint32_t *patch)
+{
+    *major=1;
+    *minor=0;
+    *patch=0;
+    return 0;
+}
+audioDevice *DummyCreateAudioDevice(void)
+{
+    return new dummyAudioDevice;
+}
+void DummyDeleteAudioDevice(audioDevice *z)
+{
+    dummyAudioDevice *a=(dummyAudioDevice *)z;
+}
+// --------- couple of stubs for dummy device  -------------
+uint32_t ADM_av_getNbDevices(void);
+bool     ADM_av_getDeviceInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
 
-#ifdef USE_SDL
-#include &quot;ADM_audiodevice/ADM_deviceSDL.h&quot;
-#endif
+/**
+        \fn ADM_av_getNbDevices
+        \brief Returns the number of av filter plugins except one
+*/
+uint32_t ADM_av_getNbDevices(void)
+{
+    return ListOfAudioDevices.size()-1;
+}
+/**
+    \fn     ADM_av_getDeviceInfo
+    \brief  Get Infos about the filter#th plugin
+*/
+bool     ADM_av_getDeviceInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch)
+{
+    filter++;
+    ADM_assert(filter&lt;ListOfAudioDevices.size());
+    ListOfAudioDevices[filter]-&gt;getVersion(major,minor,patch);
+    *name=ListOfAudioDevices[filter]-&gt;name;
+    return true;
+}
+/**
+    \fn tryLoadingFilterPlugin
+    \brief Try loading the file given as argument as an audio device plugin
 
-#ifdef __WIN32
-#include &quot;ADM_audiodevice/ADM_deviceWin32.h&quot;
-#endif
+*/
+#define Fail(x) {printf(&quot;%s:&quot;#x&quot;\n&quot;,file);goto er;}
+static bool tryLoadingFilterPlugin(const char *file)
+{
+	ADM_AudioDevices *dll=new ADM_AudioDevices(file);
+    if(!dll-&gt;initialised) Fail(CannotLoad);
+    if(dll-&gt;apiVersion!=ADM_AUDIO_DEVICE_API_VERSION) Fail(WrongApiVersion);
 
-#ifdef USE_ESD
-#include &quot;ADM_deviceEsd.h&quot;
-#endif
+    ListOfAudioDevices.push_back(dll); // Needed for cleanup. FIXME TODO Delete it.
+    printf(&quot;[Filters] Registered filter %s as  %s\n&quot;,file,dll-&gt;descriptor);
+    return true;
+	// Fail!
+er:
+	delete dll;
+	return false;
 
-#ifdef USE_JACK
-#include &quot;ADM_deviceJack.h&quot;
+}
+/**
+ * 	\fn ADM_av_loadPlugins
+ *  \brief load all audio device plugins
+ */
+uint8_t ADM_av_loadPlugins(const char *path)
+{
+#define MAX_EXTERNAL_FILTER 100
+// FIXME Factorize
+#ifdef __WIN32
+#define SHARED_LIB_EXT &quot;dll&quot;
+#elif defined(__APPLE__)
+#define SHARED_LIB_EXT &quot;dylib&quot;
+#else
+#define SHARED_LIB_EXT &quot;so&quot;
 #endif
 
-#ifdef __APPLE__
-#include &quot;ADM_audiodevice/ADM_deviceAudioCore.h&quot;
-#endif
+	char *files[MAX_EXTERNAL_FILTER];
+	uint32_t nbFile;
 
-#include &quot;gui_action.hxx&quot;
-#include &quot;audio_out.h&quot;
 
+    // PushBack our dummy one : TODO FIXME
+    ADM_AudioDevices *dummyDevice=new ADM_AudioDevices(&quot;Dummy&quot;,&quot;Dummy audio device&quot;, 
+                                DummyGetVersion,
+                                DummyCreateAudioDevice,
+                                DummyDeleteAudioDevice);
+    
+    ListOfAudioDevices.push_back(dummyDevice); 
+	memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
+	printf(&quot;[ADM_av_plugin] Scanning directory %s\n&quot;,path);
 
+	if(!buildDirectoryContent(&amp;nbFile, path, files, MAX_EXTERNAL_FILTER, SHARED_LIB_EXT))
+	{
+		printf(&quot;[ADM_av_plugin] Cannot parse plugin\n&quot;);
+		return 0;
+	}
 
+	for(int i=0;i&lt;nbFile;i++)
+		tryLoadingFilterPlugin(files[i]);
 
+	printf(&quot;[ADM_av_plugin] Scanning done\n&quot;);
 
-audioDevice::audioDevice(void) {
+	return 1;
 }
-
 /**
-		in=0 -&gt; arts1
-		in=1 -&gt; alsa
+    \fn AVDM_audioSave
+    \brief Save in Prefs the current audio Device
+
 */
 
-audioDevice *device=NULL;
-static AUDIO_DEVICE  currentDevice=DEVICE_DUMMY;
-static AUDIO_DEVICE ADM_audioByName(const char *name);
-static const char *ADM_audioById(AUDIO_DEVICE id);
-
 void AVDM_audioSave( void )
 {
 const char *string;
 		string=ADM_audioById(currentDevice);
 		prefs-&gt;set(DEVICE_AUDIODEVICE, string);
-	
-
 }
+/**
+    \fn ADM_audioByName
+    \brief Returns the Id of the given string 
+
+*/
 AUDIO_DEVICE ADM_audioByName(const char *name)
 {
 	if(!name) return (AUDIO_DEVICE)0;
-	for(uint32_t i=0;i&lt;sizeof(audioDeviceList)/sizeof(DEVICELIST);i++)
+	for(uint32_t i=0;i&lt;ListOfAudioDevices.size();i++)
 	{
-		if(!strcmp(name,audioDeviceList[i].name))
+		if(!strcasecmp(name,ListOfAudioDevices[i]-&gt;name))
 		{
-			return audioDeviceList[i].id;
+			return i;
 		}	
 	}
 	printf(&quot;Device not found :%s\n&quot;,name);
 	return (AUDIO_DEVICE)0;
 
 }
+/**
+    \fn ADM_audioById
+    \brief Returns the name of a device from its Id
+*/
 const char *ADM_audioById(AUDIO_DEVICE id)
 {
-	
-	for(uint32_t i=0;i&lt;sizeof(audioDeviceList)/sizeof(DEVICELIST);i++)
-	{
-		if(audioDeviceList[i].id==id)
-		{
-			return audioDeviceList[i].name;
-		}	
-	}
-	printf(&quot;Device not found :%d\n&quot;,id);
-	return (const char *)&quot;Unknown!&quot;;
-
+	ADM_assert(id&lt;ListOfAudioDevices.size());
+    return ListOfAudioDevices[id]-&gt;name;
 }
-
+/**
+    \fn AVDM_getCurrentDevice
+    \brief
+*/
 AUDIO_DEVICE AVDM_getCurrentDevice( void)
 {
 	return currentDevice;
 }
-
+/**
+    \fn AVDM_audioInit
+    \brief
+*/
 void AVDM_audioInit(void )
 {
 uint8_t init=0;
 char *name=NULL;
-AUDIO_DEVICE id;
+AUDIO_DEVICE id=0;
 
 		if(prefs-&gt;get(DEVICE_AUDIODEVICE, &amp;name))
 		{
 		id=ADM_audioByName(name);
 		ADM_dealloc(name);
 		name=NULL;	
-		if(!id) id=DEVICE_DUMMY;
-		switch(id)
-		{
-
-			case DEVICE_ARTS:									
-			case DEVICE_ALSA:
-			case DEVICE_COREAUDIO:
-			case DEVICE_SDL:
-			case DEVICE_WIN32:
-			case DEVICE_ESD:
-			case DEVICE_JACK:
-			
-						printf(&quot;Using real audio device\n&quot;);
-						AVDM_switch(id);
-						init=1;	
-						break;				
-			case DEVICE_DUMMY:
-			default:
-						printf(&quot;Using dummy audio device\n&quot;);
-						init=1;
-						AVDM_switch(id);
-						break;
+        }
 		
-		}
-		}
-		// Fallback
-		if(init==0)
-		{
-		#ifdef OSS_SUPPORT
-			AVDM_switch(DEVICE_OSS);			
-			printf(&quot;\n Using OSS\n&quot;);
-		#else
-			#ifdef __WIN32
-			AVDM_switch(DEVICE_WIN32);
-			#else
-                #ifdef USE_ESD
-			        AVDM_switch(DEVICE_ESD);
-                #else
-			        AVDM_switch(DEVICE_DUMMY);
-			        printf(&quot;\n Using dummy\n&quot;);
-                #endif
-			#endif
-		#endif
-		}
+		
+        AVDM_switch(id);
 }
-
+/**
+        \fn AVDM_cleanup
+        \brief Current device is no longer used, delete
+*/
 void AVDM_cleanup(void)
 {
 	if(device)
@@ -194,93 +224,37 @@
 		delete device;
 		device=NULL;
 	}
+    ADM_assert(action&lt;ListOfAudioDevices.size());
+    device=ListOfAudioDevices[action]-&gt;createAudioDevice();
+    currentDevice=action;
 
-	 currentDevice=DEVICE_DUMMY;
-	switch(action)
-	{
-#ifdef __APPLE__
-		  case  DEVICE_COREAUDIO :
-								device=new 	 coreAudioDevice;
-								currentDevice=DEVICE_COREAUDIO;;
-								printf(&quot;Using Darwin coreaudio i/f\n&quot;);
-								break;
-
-#endif
-#if defined(OSS_SUPPORT)
-		  case  DEVICE_OSS :
-								device=new 	 ossAudioDevice;
-								currentDevice=DEVICE_OSS;;
-								break;
-#endif
-#if defined(USE_ESD)
-		  case  DEVICE_ESD :
-								device=new 	 esdAudioDevice;
-								currentDevice=DEVICE_ESD;;
-								break;
-#endif
-#if defined(USE_JACK)
-		  case  DEVICE_JACK:
-								device=new 	 jackAudioDevice;
-								currentDevice=DEVICE_JACK;
-								break;
-#endif
-#ifdef USE_ARTS
-		case DEVICE_ARTS:
-								device=new 	 artsAudioDevice;
-							 	currentDevice=DEVICE_ARTS;
-								break;
-
-#endif
-#ifdef ALSA_SUPPORT
-		case DEVICE_ALSA:
-								device=new 	 alsaAudioDevice;
-							 	currentDevice=DEVICE_ALSA;
-								break;
-
-#endif
-#ifdef USE_SDL
-		case DEVICE_SDL:
-								device=new sdlAudioDevice;
-								currentDevice=DEVICE_SDL;
-								break;
-#endif
-
-#ifdef __WIN32
-		case DEVICE_WIN32:
-								device=new win32AudioDevice;
-								currentDevice=DEVICE_WIN32;
-								break;
-#endif
-
-
-		 case  DEVICE_DUMMY:
-					default:
-								device=new 	 dummyAudioDevice;
-								currentDevice=DEVICE_DUMMY;
-								break;
-
-	}
-
 }
+/**
+    \fn AVDM_AudioClose
+    \brief Stop playback
 
-//_______________________________________________
-//
-//
-//_______________________________________________
+*/
 void AVDM_AudioClose(void)
 {
 	device-&gt;stop();
 }
 
-//_______________________________________________
-//
-//
-//_______________________________________________
+/**
+    \fn AVDM_AudioSetup
+    \brief Initialize a device
+
+*/
 uint32_t AVDM_AudioSetup(uint32_t fq, uint8_t channel)
 {
 	
 	return device-&gt;init(channel,fq);
 }
+/**
+    \fn AVDM_setVolume
+    \brief Set the volume (0..100)
+
+*/
+
 uint8_t         AVDM_setVolume(int volume)
 {
         printf(&quot;New volume :%d\n&quot;,volume);
@@ -288,18 +262,24 @@
         return 1;
 
 }
-//_______________________________________________
-//
-//
-//_______________________________________________
+/**
+    \fn AVDM_AudioPlay
+    \brief Send float data to be played immediately by the device
+
+*/
 uint8_t AVDM_AudioPlay(float *ptr, uint32_t nb)
 {
 	return device-&gt;play(nb,ptr);
 }
-#else
-void dummy_func_make_gcc_happy( void );
-void dummy_func_make_gcc_happy( void )
-{
-}
+//**
+dummyAudioDevice::dummyAudioDevice(void) {};
+dummyAudioDevice::~dummyAudioDevice(void) {};
+uint8_t dummyAudioDevice::init(uint32_t channels, uint32_t fq)
+                                {printf(&quot;Null audio device\n&quot;); UNUSED_ARG(fq); UNUSED_ARG(channels); return 1;}
+uint8_t dummyAudioDevice::play(uint32_t len, float *data)
+                                {UNUSED_ARG(len); UNUSED_ARG(data); return 1;}
+uint8_t dummyAudioDevice::stop(void)
+                                { return 1;}
 
-#endif
+
+//**

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -12,32 +12,36 @@
 #ifndef ADM_AUDIODEVICE_H
 #define ADM_AUDIODEVICE_H
 
-#include &quot;ADM_assert.h&quot;
+// Converts float to int16_t with dithering
+extern void dither16(float *start, uint32_t nb, uint8_t channels);
 
-void dither16(float *start, uint32_t nb, uint8_t channels);
-
  class audioDevice
  {
         protected:
-			uint8_t _channels;
+                        uint32_t _channels; /// # of channels we want to setup
+                        uint32_t _frequency;/// Frequency we want to setup
 
         public:
-                                        audioDevice(void);
-                        virtual uint8_t init(uint8_t channel, uint32_t fq ) {ADM_assert(0);return 0;}
-                        virtual uint8_t stop(void) {ADM_assert(0);return 0;}
-                        virtual uint8_t play(uint32_t len, float *data) {ADM_assert(0);return 0;}
-                        virtual uint8_t setVolume(int volume) {return 1;}
+                                        audioDevice(void) {};
+                        virtual         ~audioDevice() {};
+                        virtual uint8_t  init(uint32_t channel, uint32_t fq ) =0;
+                        virtual uint8_t  stop(void)=0;
+                        virtual uint8_t  play(uint32_t len, float *data) =0;
+                        virtual uint8_t  setVolume(int volume) {return 1;}
+                        virtual uint32_t getLatencyMs(void) {return 0;}
 }   ;
-
+/**
+    \class dummyAudioDevice
+    \brief this dummy is used when no suitable device have been found.
+*/
 class dummyAudioDevice : public audioDevice
 {
 		  public:
-                                        dummyAudioDevice(void) {};
-                        virtual uint8_t init(uint8_t channels, uint32_t fq)
-                                {printf(&quot;Null audio device\n&quot;); UNUSED_ARG(fq); UNUSED_ARG(channels); return 1;}
-                        virtual uint8_t play(uint32_t len, float *data)
-                                {UNUSED_ARG(len); UNUSED_ARG(data); return 1;}
-                        virtual uint8_t stop(void) {return 1;}
+                                        dummyAudioDevice(void) ;
+                                        ~dummyAudioDevice(void);
+                        virtual uint8_t init(uint32_t channels, uint32_t fq);
+                        virtual uint8_t play(uint32_t len, float *data);
+                        virtual uint8_t stop(void) ;
 }   ;
 
 #endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,355 +0,0 @@
-/***************************************************************************
-                          ADM_deviceAlsa.cpp  -  description
-                             -------------------
-
-	Strongly derivated from code sample from alsa-project.org with some bits
-		from mplayer concerning the swparams
-
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;sys/types.h&gt;
-#include &quot;prefs.h&quot;
-
-
-#ifdef ALSA_SUPPORT
-#include &lt;alsa/asoundlib.h&gt;
-#include &quot;ADM_assert.h&quot;
-
-#include &quot;ADM_default.h&quot;
-
-
-#include &quot;ADM_audiodevice.h&quot;
-#include  &quot;ADM_audiodevice/ADM_deviceALSA.h&quot;
-
-#include &quot;ADM_assert.h&quot;
-
-/* Handle for the PCM device */
-snd_pcm_t *pcm_handle;
-
-    alsaAudioDevice::alsaAudioDevice( void )
-    {
-		_init=0;
-    }
-
-uint8_t alsaAudioDevice::init( uint8_t channel,uint32_t fq )
-{
-	int dir=0;
-
-	_channels=channel;
-	_init=0;
-   /* Playback stream */
-    snd_pcm_stream_t stream = SND_PCM_STREAM_PLAYBACK;
-
-    /* This structure contains information about    */
-    /* the hardware and can be used to specify the  */
-    /* configuration to be used for the PCM stream. */
-    snd_pcm_hw_params_t *hwparams;
-    snd_pcm_sw_params_t *swparams;
-
-
-  static char *pcm_name;
-  if( prefs-&gt;get(DEVICE_AUDIO_ALSA_DEVICE, &amp;pcm_name) != RC_OK )
-               pcm_name = ADM_strdup(&quot;plughw:0,0&quot;);
-
- /* Allocate the snd_pcm_hw_params_t structure on the stack. */
-    snd_pcm_hw_params_alloca(&amp;hwparams);
-    snd_pcm_sw_params_alloca(&amp;swparams);
-    /* Open PCM. The last parameter of this function is the mode. */
-    /* If this is set to 0, the standard mode is used. Possible   */
-    /* other values are SND_PCM_NONBLOCK and SND_PCM_ASYNC.       */
-    /* If SND_PCM_NONBLOCK is used, read / write access to the    */
-    /* PCM device will return immediately. If SND_PCM_ASYNC is    */
-    /* specified, SIGIO will be emitted whenever a period has     */
-    /* been completely processed by the soundcard.                */
-    if (snd_pcm_open(&amp;pcm_handle, pcm_name, stream, SND_PCM_NONBLOCK) &lt; 0) {
-      fprintf(stderr, &quot;Error opening PCM device %s\n&quot;, pcm_name);
-      return(0);
-    }
-    // past this point we got _init=1 -&gt; partially initialized
-    _init=1;
-      /* Init hwparams with full configuration space */
-    if (snd_pcm_hw_params_any(pcm_handle, hwparams) &lt; 0) {
-      fprintf(stderr, &quot;Can not configure this PCM device.\n&quot;);
-      ADM_dealloc(pcm_name);
-      return(0);
-    }
-    ADM_dealloc(pcm_name);
-    /* Set access type. This can be either    */
-    /* SND_PCM_ACCESS_RW_INTERLEAVED or       */
-    /* SND_PCM_ACCESS_RW_NONINTERLEAVED.      */
-    /* There are also access types for MMAPed */
-    /* access, but this is beyond the scope   */
-    /* of this introduction.                  */
-    if (snd_pcm_hw_params_set_access(pcm_handle, hwparams, SND_PCM_ACCESS_RW_INTERLEAVED) &lt; 0) {
-      fprintf(stderr, &quot;Error setting access.\n&quot;);
-      return(0);
-    }
-
-    /* Set sample format */
-//    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_FLOAT) &lt; 0) { //need more test
-    //  fprintf(stderr, &quot;Error setting float format.\n&quot;);
-
-#ifdef ADM_BIG_ENDIAN
-    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_S16_BE) &lt; 0)
-#else
-    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_S16_LE) &lt; 0)
-#endif
-    {
-      fprintf(stderr, &quot;Error setting format.\n&quot;);
-      return(0);
-    }
-	//}
-    /* Set sample rate. If the exact rate is not supported */
-    /* by the hardware, use nearest possible rate.         */
-    int exact_rate;
-    dir=0;
-    exact_rate = snd_pcm_hw_params_set_rate_near(pcm_handle, hwparams, &amp;fq, &amp;dir);
-    if (dir != 0) {
-      fprintf(stderr, &quot;The rate %lu Hz is not supported by your hardware.\n  ==&gt; Using %d Hz instead.\n&quot;, fq, exact_rate);
-    }
-
-    /* Set number of channels */
-    if (snd_pcm_hw_params_set_channels(pcm_handle, hwparams, channel) &lt; 0) {
-      fprintf(stderr, &quot;Error setting channels.\n&quot;);
-      return(0);
-    }
-#if 0
-    	uint32_t periods=fq*2*channel*10;
-	uint32_t periodsize=1;
-    /* Set number of periods. Periods used to be called fragments. */
-    if (snd_pcm_hw_params_set_periods(pcm_handle, hwparams, periods, 0) &lt; 0) {
-      fprintf(stderr, &quot;Error setting periods.\n&quot;);
-      return(0);
-    }
-#else
-
- 	unsigned int buffer_time = 800000;
-	int er;
-	unsigned int buff;
-	dir=0;
-
-	if ((er=snd_pcm_hw_params_set_buffer_time_near(pcm_handle, hwparams, &amp;buffer_time, &amp;dir)) &lt; 0)
-	  {
-	    printf(&quot;Error : hw_params_set_buffer_time\n&quot;);
-	    return(0);
-	  }
-	  // unsigned ?
-	  dir=0;
-	  buff=buffer_time&gt;&gt;2;
-	snd_pcm_hw_params_set_period_time_near(pcm_handle, hwparams, &amp;buff, &amp;dir) ;
-#if 0
-	if (snd_pcm_hw_params_set_period_time_near(pcm_handle, hwparams, buffer_time&gt;&gt;2, 0) &lt; 0)
-	  /* original: alsa_buffer_time/ao_data.bps */
-	  {
-	    printf(&quot;Error : hw_params_set_period_time\n&quot;);
-	    return(0);
-	  }
-#endif
-#endif
-
-
-/*
-If your hardware does not support a buffersize of 2^n, you can use the function snd_pcm_hw_params_set_buffer_size_near. This works similar to snd_pcm_hw_params_set_rate_near. Now we apply the configuration to the PCM device pointed to by pcm_handle. This will also prepare the PCM device.
-*/
-
-
-    /* Apply HW parameter settings to */
-    /* PCM device and prepare device  */
-    if (snd_pcm_hw_params(pcm_handle, hwparams) &lt; 0) {
-      fprintf(stderr, &quot;Error setting HW params.\n&quot;);
-      return(0);
-    }
-
- 	if (snd_pcm_sw_params_current(pcm_handle, swparams) &lt; 0)
-	    {
-	      printf(&quot;Error setting SW params.\n&quot;);
-	      return(0);
-	    }
-
- 	// be sure that playback starts immediatly (or near)
-	  if (snd_pcm_sw_params_set_avail_min(pcm_handle, swparams, 4) &lt; 0)
-	    {
-	      printf(&quot;Error setting set_avail_min \n&quot;);
-	      return(0);
-	    }
-
-	  if (snd_pcm_sw_params(pcm_handle, swparams) &lt; 0)
-	    {
-	      printf(&quot;Error:snd_pcm_sw_params\n &quot;);
-	      return(0);
-	    }
-
-
-      if ( snd_pcm_prepare(pcm_handle) &lt; 0)
-	{
-	  printf(&quot;Error : snd_pcm_prepare\n&quot;);
-	  return(0);
-	}
-
-        printf(&quot;[Alsa]Success initializing: fq :%u channel %u\n&quot;,fq,channel);
-
-    // 2=fully initialized
-    _init=2;
-    return 1;
-}
-
-
-uint8_t alsaAudioDevice::play( uint32_t len, float *data )
-{
-	int ret;
-        int16_t *pcm;
-	/* Write num_frames frames from buffer data to    */
-	/* the PCM device pointed to by pcm_handle.       */
-	/* Returns the number of frames actually written. */
-
-	dither16(data, len, _channels);
-
-	if(2!=_init) return 0;
-        len=len/_channels;
-        pcm=(int16_t *)data;
-    	while(1)
-	{
-        	ret=snd_pcm_writei(pcm_handle, pcm, len);
-		if(ret==(int)len)
-		{
-			return 1;
-		}
-
-		if(ret&lt;0)
-		{
-			switch(ret)
-			{
-				case    -EAGAIN :
-					//wait a bit to flush datas
-					printf(&quot;ALSA EAGAIN\n&quot;);
-					snd_pcm_wait(pcm_handle, 1000);
-					continue;
-
-				case    -EPIPE:
-					printf(&quot;ALSA EPIPE\n&quot;);
-					snd_pcm_prepare(pcm_handle);
-					continue;
-				default:
-					printf(&quot;ALSA Error %d : Play %s (len=%lu)\n&quot;,ret, snd_strerror(ret),len);
-					return 1;
-			}
-		}
-		else
-		{
-			//if(len&lt;2) return 1;
-			len-=ret;
-                        pcm+=(ret*_channels);
-		}
-	}
-	return 1;
-}
-
- uint8_t alsaAudioDevice::stop( void )
- {
- // we have at least a partial initialization
- if(_init)
- {
-       /* Stop PCM device and drop pending frames */
-    snd_pcm_drop(pcm_handle);
-
-    /* Stop PCM device after pending frames have been played */
-    snd_pcm_drain(pcm_handle);
-      if (snd_pcm_close(pcm_handle) &lt; 0)
-      {
-		printf(&quot;\n Troubles closing alsa\n&quot;);
-
-      }
-     }
-     _init=0;
-     return 1;
-}
-
-uint8_t alsaAudioDevice::setVolume(int volume){
-  snd_mixer_t *mixer_handle;
-  char *pcm_name;
-  uint32_t which_vol;
-  int rc;
-
-	if( prefs-&gt;get(DEVICE_AUDIO_ALSA_DEVICE, &amp;pcm_name) != RC_OK )
-		pcm_name = ADM_strdup(&quot;hw:0&quot;);
-	if( prefs-&gt;get(FEATURE_AUDIOBAR_USES_MASTER,&amp;which_vol) != RC_OK )
-		which_vol = 0;
-
-	if( (rc=snd_mixer_open(&amp;mixer_handle,0)) &lt; 0 ){
-		printf(&quot;ALSA: snd_mixer_open failed: %d\n&quot;,rc);
-		ADM_dealloc(pcm_name);
-		return 0;
-	}
-// MEANX: Cannot use the real name, does not work with dmix
-	if( (rc=snd_mixer_attach(mixer_handle,&quot;hw:0&quot;)) &lt; 0 ){
-		printf(&quot;ALSA: snd_mixer_attach failed: %d, %s\n&quot;,rc, snd_strerror (rc));
-		snd_mixer_close(mixer_handle);
-		ADM_dealloc(pcm_name);
-		return 0;
-	}
-	ADM_dealloc(pcm_name);
-	if( (rc=snd_mixer_selem_register(mixer_handle,NULL,NULL)) &lt; 0 ){
-		printf(&quot;ALSA: snd_mixer_selem_register failed: %d\n&quot;,rc);
-		snd_mixer_close(mixer_handle);
-		return 0;
-	}
-	if( (rc=snd_mixer_load(mixer_handle)) &lt; 0 ){
-		printf(&quot;ALSA: snd_mixer_load failed: %d\n&quot;,rc);
-		snd_mixer_close(mixer_handle);
-		return 0;
-	}
-	{ snd_mixer_elem_t *elem;
-	  snd_mixer_selem_id_t *sid;
-	  const char *str;
-		snd_mixer_selem_id_alloca(&amp;sid);
-		for (elem = snd_mixer_first_elem(mixer_handle);
-		     elem;
-		     elem = snd_mixer_elem_next(elem)) {
-			snd_mixer_selem_get_id(elem, sid);
-			str = snd_mixer_selem_id_get_name(sid);
-			if( (which_vol == 0 &amp;&amp; !strcmp(str,&quot;PCM&quot;))   ||
-			    (which_vol == 1 &amp;&amp; !strcmp(str,&quot;Master&quot;))  ){
-			  long val=0, min=0, max=0;
-				snd_mixer_selem_get_playback_volume_range(elem,&amp;min,&amp;max);
-				/*
-				if( (rc=snd_mixer_selem_get_playback_volume(elem,SND_MIXER_SCHN_FRONT_LEFT,&amp;val)) &lt; 0 ){
-					printf(&quot;ALSA: snd_mixer_selem_get_playback_volume failed: %d\n&quot;,rc);
-				}
-				printf(&quot;ALSA: old val: %lu\n&quot;,val*100/max);
-				*/
-				if( (rc=snd_mixer_selem_set_playback_volume_all(elem,volume*max/100)) &lt; 0 ){
-					printf(&quot;ALSA: snd_mixer_selem_set_playback_volume_all failed: %d\n&quot;,rc);
-				}
-				printf(&quot;ALSA: new %s val: %lu\n&quot;,(which_vol?&quot;master&quot;:&quot;pcm&quot;),volume);
-				break;
-			}
-		}
-	}
-	snd_mixer_close(mixer_handle);
-	return 0;
-}
-
-#else
-void dummy_alsa_fun( void);
-void dummy_alsa_fun( void)
- {
-}
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,35 +0,0 @@
-/***************************************************************************
-                          ADM_deviceAlsa.h  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifdef ALSA_SUPPORT
-	 class alsaAudioDevice : public audioDevice
-	 {
-		 protected :
-				//	0-&gt; no init done
-				//	1-&gt; device opened but init failed
-				//	2-&gt;fully initialized
-				uint32_t _init;
-		  public:
-					alsaAudioDevice(void);
-		     		virtual uint8_t init(uint8_t channel,uint32_t fq);
-	    			virtual uint8_t play(uint32_t len, float *data);
-		      		virtual uint8_t stop(void) ;
-				uint8_t setVolume(int volume);
-		 }     ;
-#endif
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,121 +0,0 @@
-/***************************************************************************
-                          ADM_deviceArts.cpp  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-#ifdef USE_ARTS
-#include &lt;artsc.h&gt;
-
-#include &quot;ADM_audiodevice.h&quot;
-#include  &quot;ADM_audiodevice/ADM_deviceoss.h&quot;
-#include  &quot;ADM_audiodevice/ADM_deviceArts.h&quot;
-
-uint8_t artsInitialized=0;
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t  artsAudioDevice::stop(void) {
-		if(!_stream)
-		{
-			printf(&quot;\n Arts: no stream\n&quot;);
-			return 0;
-		}
-
-		arts_close_stream(_stream);
-		// apparently arts 3.2 alpha does not like this
-	   	//arts_free();
-		_stream=NULL;
-		printf(&quot;\n Arts stopped\n&quot;);
-    	return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t artsAudioDevice::init(uint8_t channels, uint32_t fq)
-{
-	_channels = channels;
-
-    if(_stream)
-    	{
-			printf(&quot;\n purging previous instance\n&quot;);
-			stop();
-		}
-    printf(&quot;\n Arts  : %lu Hz, %lu channels&quot;, fq, channels);
-	if(!artsInitialized)
-	{
-		if(arts_init())
-		{
-			printf(&quot;\n Error initializing artsd\n&quot;);
-			return 0;
-		}
-		artsInitialized=1;
-	}
-
-	_stream=arts_play_stream(fq, 16,channels, &quot;Avidemux&quot;);
-
-	if(!_stream)
-	 {
-		printf(&quot;\n Problem setting fq/channel, aborting\n&quot;);
-		arts_free();
-		return 0;
-	}
-	arts_stream_set(_stream, ARTS_P_BLOCKING, 1);
-	arts_stream_set(_stream, ARTS_P_BUFFER_TIME, 50); // Ask for 1 sec buffer
-	//arts_stream_set(_stream,  ARTS_P_PACKET_SETTINGS, (11&lt;&lt;16)+10);
-
-
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t artsAudioDevice::play(uint32_t len, float *data)
- {
-
-	if(!_stream) return 0;
-
-	dither16(data, len, _channels);
-
-	return arts_write(_stream, data, len*2);
-}
-
-/*
-** JSC     Mon Nov 28 19:20:06 CET 2005
-** based on <A HREF="http://www.arts-project.org/doc/mcop-doc/artsd-faq.html">http://www.arts-project.org/doc/mcop-doc/artsd-faq.html</A>
-** arts only works with OSS devices (or alsa devices using oss emulation)
-** so we only need OSS support here
-*/
-uint8_t artsAudioDevice::setVolume(int volume){
-#ifdef OSS_SUPPORT
-        ossAudioDevice dev;
-        dev.setVolume(volume);
-#endif
-        return 1;
-}
-
-#else
-void dummy_art_func( void);
-void dummy_art_func( void)
- {
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,33 +0,0 @@
-/***************************************************************************
-                          ADM_deviceArts.h  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
- #ifdef USE_ARTS
-                 class artsAudioDevice : public audioDevice
-	 {
-		 protected :
-		 		arts_stream_t _stream;
-		  public:
-		  			artsAudioDevice() {_stream=NULL;}
-				virtual ~artsAudioDevice() {stop();}
-		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
-	    			virtual uint8_t play(uint32_t len, float *data);
-		      		virtual uint8_t stop(void);
-				uint8_t setVolume(int volume);
-		 };
-#endif
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,260 +0,0 @@
-/***************************************************************************
-                          ADM_deviceAudioCore.cpp  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#ifdef __APPLE__
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;AudioUnit/AudioUnit.h&gt;
-
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_assert.h&quot;
-#include &quot;ADM_audiodevice.h&quot;
-#include &quot;ADM_audiodevice/ADM_deviceAudioCore.h&quot;
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME  MODULE_ADEVICE
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#define BUFFER_SIZE (500*48000)
-
-static Component comp = NULL;
-static int16_t audioBuffer[BUFFER_SIZE];
-static AudioUnit theOutputUnit;
-static uint32_t rd_ptr = 0;
-static uint32_t wr_ptr = 0;
-static pthread_mutex_t lock;
-
-static OSStatus MyRenderer(void *inRefCon, AudioUnitRenderActionFlags *inActionFlags,
-	const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData);
-static OSStatus OverloadListenerProc(AudioDeviceID inDevice, UInt32 inChannel, Boolean isInput,
-	AudioDevicePropertyID inPropertyID, void* inClientData);
-
-OSStatus OverloadListenerProc(AudioDeviceID inDevice, UInt32 inChannel, Boolean isInput,
-	AudioDevicePropertyID inPropertyID, void* inClientData)
-{
-	printf (&quot;[CoreAudio] *** Overload detected on device playing audio ***\n&quot;);
-	return noErr;
-}
-
-uint8_t coreAudioDevice::setVolume(int volume) {}
-
-coreAudioDevice::coreAudioDevice(void) 
-{
-	printf(&quot;[CoreAudio] Creating CoreAudio device\n&quot;);
-	_inUse=0;
-	pthread_mutex_init(&amp;lock, NULL);
-	pthread_mutex_unlock(&amp;lock);
-}
-
-uint8_t coreAudioDevice::stop(void) 
-{
-	if (_inUse)
-		verify_noerr(AudioOutputUnitStop(theOutputUnit));
-
-	// Clean up
-	CloseComponent(theOutputUnit);
-	_inUse=0;
-
-	return 1;
-}
-
-OSStatus MyRenderer(void *inRefCon, AudioUnitRenderActionFlags *inActionFlags, const AudioTimeStamp *inTimeStamp,
-	UInt32 inBusNumber, UInt32 inChannel, AudioBufferList *ioData)
-{
-	pthread_mutex_lock(&amp;lock);
-	uint32_t nb_sample = ioData-&gt;mBuffers[0].mDataByteSize &gt;&gt; 1;
-	uint32_t left = 0;
-	uint8_t *in, *out;
-
-	in = (uint8_t*)&amp;audioBuffer[rd_ptr];
-	out = (uint8_t*)ioData-&gt;mBuffers[0].mData;
-	aprintf(&quot;[CoreAudio] Fill: rd %lu, wr %lu, nb asked %lu\n&quot;, rd_ptr, wr_ptr, nb_sample);
-
-	if(wr_ptr&gt;rd_ptr)
-	{
-		left=wr_ptr-rd_ptr-1;
-
-		if(left&gt;nb_sample)
-		{
-			memcpy(out,in,nb_sample*2);
-			rd_ptr+=nb_sample;
-		}
-
-		else
-		{
-			memcpy(out,in,left*2);
-			memset(out+left*2,0,(nb_sample-left)*2);
-			rd_ptr+=left;
-		}
-	}
-	else
-	{
-		// wrap
-		left=BUFFER_SIZE-rd_ptr-1;
-		if(left&gt;nb_sample)
-		{
-			memcpy(out,in,nb_sample*2);
-			rd_ptr+=nb_sample;
-		}
-		else
-		{
-			memcpy(out,in,left*2);
-			out+=left*2;
-			rd_ptr=0;
-			in=(uint8_t *)&amp;audioBuffer[0];
-			nb_sample-=left;
-			if(nb_sample&gt;wr_ptr-1) nb_sample=wr_ptr-1;
-			memcpy(out,in,nb_sample*2);
-			rd_ptr=nb_sample;	
-		}
-	}
-
-	pthread_mutex_unlock(&amp;lock);
-	return 0;
-}
-
-#define CHECK_RESULT(msg) \
-    if (err != noErr) \
-	{ \
-		printf(&quot;[CoreAudio] Failed to initialise CoreAudio: &quot; msg &quot;\n&quot;); \
-        return 0; \
-    }
-
-uint8_t coreAudioDevice::init(uint8_t channels, uint32_t fq) 
-{
-	_channels = channels;
-
-	OSStatus err;
-	ComponentDescription desc;
-	AURenderCallbackStruct input;
-	AudioStreamBasicDescription streamFormat;
-	AudioDeviceID theDevice;
-
-	desc.componentType = kAudioUnitType_Output;
-	desc.componentSubType = kAudioUnitSubType_HALOutput;
-	desc.componentManufacturer = kAudioUnitManufacturer_Apple;
-	desc.componentFlags = 0;
-	desc.componentFlagsMask = 0;
-
-	comp = FindNextComponent(NULL, &amp;desc);
-
-	if (comp == NULL)
-	{
-		printf(&quot;[CoreAudio] Failed to find component\n&quot;);
-		return 0;
-	}
-
-	err = OpenAComponent(comp, &amp;theOutputUnit);
-	CHECK_RESULT(&quot;OpenAComponent&quot;)
-
-	err = AudioUnitInitialize(theOutputUnit);
-	CHECK_RESULT(&quot;AudioUnitInitialize&quot;)
-	
-	// Set up a callback function to generate output to the output unit
-	input.inputProc = MyRenderer;
-	input.inputProcRefCon = NULL;
-	
-	err = AudioUnitSetProperty(theOutputUnit, 
-					kAudioUnitProperty_SetRenderCallback,
-					kAudioUnitScope_Global,
-					0,
-					&amp;input, 
-					sizeof(input));
-	CHECK_RESULT(&quot;AudioUnitSetProperty [SetInputCallback]&quot;)
-
-	streamFormat.mSampleRate = fq;
-	streamFormat.mFormatID = kAudioFormatLinearPCM;
-	streamFormat.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger | kLinearPCMFormatFlagIsPacked;
-
-	streamFormat.mBytesPerPacket = channels * sizeof (UInt16);
-	streamFormat.mFramesPerPacket = 1;
-	streamFormat.mBytesPerFrame = channels * sizeof (UInt16);
-	streamFormat.mChannelsPerFrame = channels;
-	streamFormat.mBitsPerChannel = sizeof (UInt16) * 8;
-	
-	err = AudioUnitSetProperty(theOutputUnit,
-		kAudioUnitProperty_StreamFormat,
-		kAudioUnitScope_Input,
-		0,
-		&amp;streamFormat,
-		sizeof(streamFormat));
-	CHECK_RESULT(&quot;AudioUnitSetProperty [StreamFormat]&quot;)
-	
-	printf(&quot;[CoreAudio] Rendering source:\n&quot;);
-	printf(&quot;[CoreAudio] \tSampleRate = %f,\n&quot;, streamFormat.mSampleRate);
-	printf(&quot;[CoreAudio] \tBytesPerPacket = %ld,\n&quot;, streamFormat.mBytesPerPacket);
-	printf(&quot;[CoreAudio] \tFramesPerPacket = %ld,\n&quot;, streamFormat.mFramesPerPacket);
-	printf(&quot;[CoreAudio] \tBytesPerFrame = %ld,\n&quot;, streamFormat.mBytesPerFrame);
-	printf(&quot;[CoreAudio] \tBitsPerChannel = %ld,\n&quot;, streamFormat.mBitsPerChannel);
-	printf(&quot;[CoreAudio] \tChannelsPerFrame = %ld\n&quot;, streamFormat.mChannelsPerFrame);
-
-    return 1;
-}
-
-uint8_t coreAudioDevice::play(uint32_t len, float *data)
- {
- 	// First put stuff into the buffer
-	uint8_t *src;
-	uint32_t left;
-
-	dither16(data, len, _channels);
-
-	pthread_mutex_lock(&amp;lock);
-
-	// Check we have room left
-	if(wr_ptr&gt;=rd_ptr)
-		left=BUFFER_SIZE-(wr_ptr-rd_ptr);
-	else
-		left=rd_ptr-wr_ptr;
-
-	if(len+1&gt;left)
-	{
-		printf(&quot;[CoreAudio] Buffer full!\n&quot;);
-		pthread_mutex_unlock(&amp;lock);
-		return 0;
-	}
-
-	// We have room left, copy it
-	src=(uint8_t *)&amp;audioBuffer[wr_ptr];
-
-	if(wr_ptr+len&lt;BUFFER_SIZE)
-	{
-		memcpy(src,data,len*2);
-		wr_ptr+=len;
-	}
-	else
-	{
-		left=BUFFER_SIZE-wr_ptr-1;
-		memcpy(src,data,left*2);
-		memcpy(audioBuffer,data+left*2,(len-left)*2);
-		wr_ptr=len-left;	
-	}
-	//aprintf(&quot;AudioCore: Putting %lu bytes rd:%lu wr:%lu \n&quot;,len*2,rd_ptr,wr_ptr);
-	pthread_mutex_unlock(&amp;lock);	
-
-	_inUse=1;
-	verify_noerr(AudioOutputUnitStart(theOutputUnit));
-
-	return 1;
-}
-#else
-void dummy_ac_func(void);
-void dummy_ac_func(void)
-{
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,26 +0,0 @@
-//
-// C++ Interface: ADM_deviceAudioCore
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#ifdef __APPLE__
-
-	        class coreAudioDevice : public audioDevice
-	 {
-		 protected :
-					uint8_t				_inUse;
-		  public:
-		  				coreAudioDevice(void);
-		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
-	    			virtual uint8_t play(uint32_t len, float *data);
-		      		virtual uint8_t stop(void);
-					virtual uint8_t setVolume(int volume);
-		 }     ;
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,111 +0,0 @@
-/***************************************************************************
-                          ADM_deviceEsd.cpp  -  description
-
-  ESD support as output audio device
-                          
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#if defined(USE_ESD)
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;errno.h&gt;
-
-#include &lt;fcntl.h&gt;
-#include &lt;sys/ioctl.h&gt;
-#include &lt;esd.h&gt;
-
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_audiodevice.h&quot;
-#include &quot;ADM_assert.h&quot;
-#include &quot;ADM_audiodevice/ADM_deviceoss.h&quot;
-#include &quot;ADM_audiodevice/ADM_deviceALSA.h&quot;
-#include  &quot;ADM_audiodevice/ADM_deviceEsd.h&quot;
-
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t  esdAudioDevice::stop(void) {
-    if (esdDevice &gt; 0) {
-        esd_close(esdDevice);
-        esdDevice = 0;
-    }
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t esdAudioDevice::init(uint8_t channels, uint32_t fq) 
-{
-esd_format_t format;
-_channels = channels;
-
-    format=ESD_STREAM | ESD_PLAY | ESD_BITS16;
-    if(channels==1) format|=ESD_MONO;
-        else format|=ESD_STEREO;
-
-    printf(&quot;\n ESD  : %lu Hz, %lu channels&quot;, fq, channels);
-    esdDevice=esd_play_stream(format,fq,NULL,&quot;avidemux&quot;);
-    if(esdDevice&lt;=0) 
-    {
-        printf(&quot;Esd open failed\n&quot;);
-        return 0;
-    }
-    printf(&quot;Esd open succeedeed\n&quot;);
-    /*
-#ifdef ADM_BIG_ENDIAN    
-    int fmt = AFMT_S16_BE;
-#else
-    int fmt = AFMT_S16_LE;
-#endif    
-*/
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t esdAudioDevice::play(uint32_t len, float *data)
-{
-	dither16(data, len, _channels);
-	write(esdDevice, data, len*2);
-	return 1;
-}
-
-uint8_t esdAudioDevice::setVolume(int volume){
-#ifdef OSS_SUPPORT
-	ossAudioDevice dev;
-	dev.setVolume(volume);
-#else
-#ifdef ALSA_SUPPORT
-	alsaAudioDevice dev;
-	dev.setVolume(volume);
-#endif
-#endif
-	return 1;
-}
-
-#else
-void dummy_ess_func( void);
-void dummy_ess_func( void)
- {
-}
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,29 +0,0 @@
-/***************************************************************************
-                          ADM_deviceEsd.h  -  description
-                             -------------------
-                             Audio device for ESD sound daemon
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef USE_ESD
-class esdAudioDevice : public audioDevice
-	 {
-		 protected :
-                    int esdDevice;
-		  public:
-		  			esdAudioDevice(void) {esdDevice=-1;}
-		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
-	    			virtual uint8_t play(uint32_t len, float *data);
-		      		virtual uint8_t stop(void);
-				uint8_t setVolume(int volume);
-		 }     ;
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,251 +0,0 @@
-//
-// Author: Mihail Zenkov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">mihail.zenkov at gmail.com</A>&gt;, (C) 2007
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#include &quot;config.h&quot;
-
-#if defined(USE_JACK)
-#include &lt;unistd.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdint.h&gt;
-
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_audiodevice.h&quot;
-#include &quot;ADM_assert.h&quot;
-#include &quot;ADM_audiodevice/ADM_deviceoss.h&quot;
-#include &quot;ADM_audiodevice/ADM_deviceALSA.h&quot;
-#include &quot;ADM_audiodevice/ADM_deviceJack.h&quot;
-
-
-#define BUFSIZE 16385
-
-jackAudioDevice::jackAudioDevice()
-{
-	client = NULL;
-	ringbuffer = NULL;
-	#ifdef USE_SRC
-	src_out_buf = NULL;
-	src_state = NULL;
-	#endif
-}
-
-void jackAudioDevice::jack_shutdown(void *arg)
-{
-	((jackAudioDevice*)arg)-&gt;stop();
-}
-
-uint8_t jackAudioDevice::stop()
-{
-	if (client) {
-		printf(&quot;[JACK] Stop\n&quot;);
-		jack_client_close(client);
-		client = NULL;
-		if (ringbuffer)
-			jack_ringbuffer_free(ringbuffer);
-		ringbuffer = NULL;
-		#ifdef USE_SRC
-		delete src_out_buf;
-		src_out_buf = NULL;
-		src_delete(src_state);
-		src_state = NULL;
-		#endif
-	}
-
-	return 1;
-}
-
-uint8_t jackAudioDevice::init(uint8_t channels, uint32_t fq)
-{
-	jack_status_t status;
-	_channels = channels;
-
-	if (sizeof(jack_default_audio_sample_t) != sizeof(float)) {
-		printf(&quot;[JACK] jack_default_audio_sample_t != float\n&quot;);
-		return 0;
-	}
-
-	client = jack_client_open(&quot;avidemux&quot;, JackNullOption, &amp;status, NULL);
-
-	if (client == NULL) {
-		printf(&quot;[JACK] jack_client_open() failed, status = 0x%2.0x\n&quot;, status);
-		if (status &amp; JackServerFailed)
-			printf((&quot;[JACK] Unable to connect to server\n&quot;));
-		return 0;
-	}
-
-	if (status &amp; JackServerStarted)
-		printf(&quot;[JACK] Server started\n&quot;);
-
-	if (jack_get_sample_rate(client) == fq) {
-		jack_set_process_callback(client, process_callback, this);
-	} else {
-		printf(&quot;[JACK] audio stream sample rate: %i\n&quot;, fq);
-		printf(&quot;[JACK] jack server sample rate: %i\n&quot;, (int)jack_get_sample_rate(client));
-		#ifdef USE_SRC
-			src_out_buf = new float[BUFSIZE * channels];
-			src_state = src_new(SRC_SINC_FASTEST, channels, NULL);
-			if (!src_state) {
-				printf(&quot;[JACK] Can't init libsamplerate\n&quot;);
-				stop();
-				return 0;
-			}
-			src_data.data_out = src_out_buf;
-			src_data.output_frames = BUFSIZE;
-			src_data.src_ratio = jack_get_sample_rate(client) / (double)fq;
-			src_data.end_of_input = 0;
-//			printf(&quot;[JACK] ratio: %f\n&quot;, src_data.src_ratio);
-		#else
-			printf(&quot;[JACK] For play this, you need avidemux compiled with libsamplerate support\n&quot;);
-			stop();
-			return 0;
-		#endif
-	}
-
-	ringbuffer = jack_ringbuffer_create(BUFSIZE * channels * sizeof(jack_default_audio_sample_t));
-
-	jack_set_process_callback(client, process_callback, this);
-	jack_on_shutdown(client, jack_shutdown, this);
-
-	char name[10];
-	for (int i = 0; i &lt; channels; i++) {
-		snprintf(name, 10, &quot;output-%d&quot;, i);
-		ports[i] = jack_port_register(client, name, JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, 0);
-		if (!ports[i]) {
-			printf(&quot;[JACK] Can't create new port\n&quot;);
-			stop();
-			return 0;
-		}
-	}
-
-	if (jack_activate(client)) {
-		printf(&quot;[JACK] Cannot activate client\n&quot;);
-		stop();
-		return 0;
-	}
-
-	const char **input_ports = jack_get_ports(client, NULL, NULL, JackPortIsInput|JackPortIsPhysical);
-
-	for (int i = 0; i &lt; channels &amp;&amp; input_ports[i]; i++) {
-		if (jack_connect(client, jack_port_name(ports[i]), input_ports[i]))
-			printf(&quot;[JACK] Connecting failed\n&quot;);
-	}
-
-	if (channels == 1 &amp;&amp; input_ports[1])
-		if (jack_connect(client, jack_port_name(ports[0]), input_ports[1]))
-			printf(&quot;[JACK] Connecting failed\n&quot;);
-
-	return 1;
-}
-
-int jackAudioDevice::process(jack_nframes_t nframes)
-{
-	jack_default_audio_sample_t *pbuf[_channels];
-	for (int c = 0; c &lt; _channels; c++)
-		pbuf[c] = (jack_default_audio_sample_t *) jack_port_get_buffer(ports[c], nframes);
-
-	size_t read = jack_ringbuffer_read_space(ringbuffer) / sizeof(jack_default_audio_sample_t) / _channels;
-
-	if (read &gt; nframes)
-		read = nframes;
-
-	int i;
-	for (i = 0; i &lt; read; i++)
-		for (int c = 0; c &lt; _channels; c++) {
-			jack_ringbuffer_read(ringbuffer, (char *)pbuf[c], sizeof(jack_default_audio_sample_t));
-			pbuf[c]++;
-		}
-
-	for (; i &lt; nframes; i++)
-		for (int c = 0; c &lt; _channels; c++) {
-			pbuf[c] = 0;
-			pbuf[c]++;
-		}
-
-	if (read != nframes)
-		printf(&quot;[JACK] UNDERRUN!\n&quot;);
-
-	return 0;
-}
-
-int jackAudioDevice::process_callback(jack_nframes_t nframes, void* arg)
-{
-	return ((jackAudioDevice*)arg)-&gt;process(nframes);
-}
-
-
-uint8_t jackAudioDevice::play(uint32_t len, float *data)
-{
-//	static int min = 5000;
-	static int sleep = (int)((float)BUFSIZE / jack_get_sample_rate(client) / 2. * 1000000.);
-	size_t write;
-	float writef;
-	len /= _channels;
-
-	#ifdef USE_SRC
-	if (src_out_buf) {
-		while (len) {
-			writef = jack_ringbuffer_write_space(ringbuffer);
-			writef /= src_data.src_ratio * sizeof(jack_default_audio_sample_t) * _channels;
-			write = (size_t)writef;
-			if (write &gt;= len) {
-				src_data.data_in = data;
-				src_data.input_frames = len;
-				src_process(src_state, &amp;src_data);
-				jack_ringbuffer_write(ringbuffer,
-					(char *)src_out_buf,
-					src_data.output_frames_gen * sizeof(jack_default_audio_sample_t) * _channels);
-/*
-				if (len != src_data.input_frames_used)
-					printf(&quot;[JACK] len %i != %i input_frames_used\n&quot;, len, src_data.input_frames_used);
-				if (len &lt; min)
-					min = len;
-				printf(&quot;[JACK] %i %i %i %f %i\n&quot;,min, src_data.input_frames_used, src_data.output_frames_gen, writef, len);
-				data += src_data.input_frames_used * _channels;
-				len -= src_data.input_frames_used;
-*/
-				return 1;
-			} else {
-				printf(&quot;[JACK] OVERRUN!\n&quot;);
-				usleep(sleep);
-			}
-		}
-	} else
-	#endif
-	while (len) {
-		writef = jack_ringbuffer_write_space(ringbuffer);
-		writef /= sizeof(jack_default_audio_sample_t) * _channels;
-		write = (size_t)writef;
-		if (write &gt;= len) {
-			jack_ringbuffer_write(ringbuffer, (char *)data, len * sizeof(jack_default_audio_sample_t) * _channels);
-			return 1;
-		} else {
-			printf(&quot;[JACK] OVERRUN!\n&quot;);
-			usleep(sleep);
-		}
-	}
-
-        return 1;
-}
-
-uint8_t jackAudioDevice::setVolume(int volume){
-#ifdef OSS_SUPPORT
-	ossAudioDevice dev;
-	dev.setVolume(volume);
-#else
-#ifdef ALSA_SUPPORT
-	alsaAudioDevice dev;
-	dev.setVolume(volume);
-#endif
-#endif
-	return 1;
-}
-
-#else
-void dummy_jack_func( void);
-void dummy_jack_func( void)
-{
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,43 +0,0 @@
-//
-// Author: Mihail Zenkov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">mihail.zenkov at gmail.com</A>&gt;, (C) 2007
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#ifdef USE_JACK
-
-
-#include &lt;jack/jack.h&gt;
-#include &lt;jack/ringbuffer.h&gt;
-
-#ifdef USE_SRC
-#include &lt;samplerate.h&gt;
-#endif
-
-#define MAX_CHANNELS 9
-
-class jackAudioDevice : public audioDevice
-{
-public:
-	jackAudioDevice();
-	virtual uint8_t init(uint8_t channel,uint32_t fq);
-	virtual uint8_t play(uint32_t len, float *data);
-	virtual uint8_t stop();
-	uint8_t setVolume(int volume);
-	int process(jack_nframes_t nframes);
-
-protected:
-	static void jack_shutdown(void *arg);
-	static int process_callback(jack_nframes_t nframes, void *arg);
-
-	jack_port_t *ports[MAX_CHANNELS];
-	jack_client_t *client;
-	jack_ringbuffer_t *ringbuffer;
-	#ifdef USE_SRC
-	float *src_out_buf;
-	SRC_STATE *src_state;
-	SRC_DATA src_data;
-	#endif
-};
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,276 +0,0 @@
-//
-// C++ Implementation: ADM_deviceSDL
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#include &quot;config.h&quot;
-#include &lt;errno.h&gt;
-
-
-#include &quot;ADM_default.h&quot;
-  
- 
-#ifdef USE_SDL
-#include &quot;SDL.h&quot;
-
-
-
-#include &quot;ADM_audiodevice.h&quot;
-#include &quot;ADM_audiodevice/ADM_deviceoss.h&quot;
-#include &quot;ADM_audiodevice/ADM_deviceALSA.h&quot;
-#include &quot;ADM_audiodevice/ADM_deviceSDL.h&quot;
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME  MODULE_ADEVICE
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-static int16_t  		*audioBuffer=NULL;
-static uint32_t 		frameCount=0;
-static uint32_t			rd_ptr=0;
-static uint32_t			wr_ptr=0;
-
-extern &quot;C&quot;
-{
-static void SDL_callback(void *userdata, Uint8 *stream, int len);
-}
-
-#ifdef __APPLE__
-#define BUFFER_SIZE (500*48000)
-#else
-#define BUFFER_SIZE (2*48000)
-#endif
-
-//_______________________________________________
-//
-//_______________________________________________
-
-
-//_______________________________________________
-//
-//_______________________________________________
-
-sdlAudioDevice::sdlAudioDevice(void) 
-{
-	printf(&quot;Creating SDL Audio device\n&quot;);
-	_inUse=0;
-	wr_ptr=rd_ptr=0;
-}
-//_______________________________________________
-//
-//_______________________________________________
-uint8_t  sdlAudioDevice::stop(void) 
-{
-	if(audioBuffer)
-	{
-		delete [] audioBuffer;
-		audioBuffer=NULL;
-	}
-	
-		SDL_PauseAudio(1); // First pause it
-		SDL_CloseAudio();
-		SDL_QuitSubSystem(SDL_INIT_AUDIO);
-	
-	// Clean up
-	//CloseComponent(theOutputUnit);
-	_inUse=0;
-    	wr_ptr=rd_ptr=0;
-	printf(&quot;Closing SDL audio\n&quot;);
-	return 1;
-}
-//_______________________________________________
-//  We have to fill len data to stream pointer
-//_______________________________________________
-void SDL_callback(void *userdata, Uint8 *stream, int len)
-{
-
-
-	
-	uint32_t nb_sample=len&gt;&gt;1;
-	uint32_t left=0;
-	uint8_t *in,*out;
-
-	in=(uint8_t *)&amp;audioBuffer[rd_ptr];
-	out=(uint8_t *)stream;
-	aprintf(&quot;sdl : Fill : rd %lu wr:%lu nb asked:%lu \n&quot;,rd_ptr,wr_ptr,nb_sample);
-	if(wr_ptr&gt;rd_ptr)
-	{
-		left=wr_ptr-rd_ptr-1;	
-		if(left&gt;nb_sample)
-		{
-			memcpy(out,in,nb_sample*2);
-			rd_ptr+=nb_sample;
-		}
-		else
-		{
-			memcpy(out,in,left*2);
-			memset(out+left*2,0,(nb_sample-left)*2);
-			rd_ptr+=left;
-		}
-	}
-	else
-	{
-		// wrap
-		left=BUFFER_SIZE-rd_ptr-1;
-		if(left&gt;nb_sample)
-		{
-			memcpy(out,in,nb_sample*2);
-			rd_ptr+=nb_sample;
-		}
-		else
-		{
-			memcpy(out,in,left*2);
-			out+=left*2;
-			rd_ptr=0;
-			in=(uint8_t *)&amp;audioBuffer[0];
-			nb_sample-=left;
-			if(nb_sample&gt;wr_ptr-1) nb_sample=wr_ptr-1;
-			memcpy(out,in,nb_sample*2);
-			rd_ptr=nb_sample;	
-		}
-	}
-	
-
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t sdlAudioDevice::init(uint8_t channels, uint32_t fq) 
-{
-SDL_AudioSpec spec,result;
-_channels = channels;
-		
-		printf(&quot;[SDL] Opening audio, fq=%d\n&quot;,fq);
-
-		if(_inUse) 
-		{
-			printf(&quot;[SDL] Already running ?\n&quot;);
-			return 1; // ???
-		}
-		
-		if (SDL_InitSubSystem(SDL_INIT_AUDIO) &lt; 0) 
-		{
-			printf(&quot;[SDL] FAILED initialising Audio subsystem\n&quot;);
-			printf(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
-			return 0;
-		}
-		memset(&amp;spec,0,sizeof(spec));
-		memset(&amp;result,0,sizeof(result));
-		spec.freq=fq;
-		spec.channels=channels;
-		spec.samples=65536&gt;&gt;4; // 1 second worth of audio
-		spec.callback=SDL_callback;
-		spec.userdata=NULL;
-		spec.format=AUDIO_S16;
-	
-		int res=SDL_OpenAudio(&amp;spec,&amp;result);
-		if(res&lt;0)
-		{
-			printf(&quot;[SDL] Audio device FAILED to open\n&quot;);
-			printf(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
-
-			printf(&quot;fq   %d \n&quot;,spec.freq);
-			printf(&quot;chan %d \n&quot;, spec.channels);
-			printf(&quot;samples %d \n&quot;,spec.samples);
-			printf(&quot;format %d \n&quot;,spec.format);
-			
-			printf(&quot;fq   %d \n&quot;,result.freq);
-			printf(&quot;chan %d \n&quot;, result.channels);
-			printf(&quot;samples %d \n&quot;,result.samples);
-			printf(&quot;format %d \n&quot;,result.format);
-
-			return 0;
-		}
-		
-	frameCount=0;
-	
-	audioBuffer=new int16_t[BUFFER_SIZE]; // between hald a sec and a sec should be enough :)
-	
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t sdlAudioDevice::play(uint32_t len, float *data)
- {
- 	// First put stuff into the buffer
-	uint8_t *src;
-	uint32_t left;
-
-	dither16(data, len, _channels);
-	
-	// Check we have room left
-	if(wr_ptr&gt;=rd_ptr)
-	{
-		left=BUFFER_SIZE-(wr_ptr-rd_ptr);
-	}
-	else
-	{
-		left=rd_ptr-wr_ptr;
-	}
-	if(len+1&gt;left)
-	{
-		printf(&quot;AudioCore:Buffer full!\n&quot;);
-		
-		return 0;
-	}
-
-	// We have room left, copy it
-	src=(uint8_t *)&amp;audioBuffer[wr_ptr];
-	
-	SDL_LockAudio();
-	
-	if(wr_ptr+len&lt;BUFFER_SIZE)
-	{
-		memcpy(src,data,len*2);
-		wr_ptr+=len;
-	}
-	else
-	{
-		left=BUFFER_SIZE-wr_ptr-1;
-		memcpy(src,data,left*2);
-		memcpy(audioBuffer,data+left*2,(len-left)*2);
-		wr_ptr=len-left;	
-	}
-	
-	//aprintf(&quot;AudioSDL: Putting %lu bytes rd:%lu wr:%lu \n&quot;,len*2,rd_ptr,wr_ptr);
-	SDL_UnlockAudio();
- 	if(!frameCount)
-	{
-		_inUse=1;
-		SDL_PauseAudio(0);;
-	}
-	
-	return 1;
-}
-
-uint8_t sdlAudioDevice::setVolume(int volume){
-#ifdef OSS_SUPPORT
-        ossAudioDevice dev;
-        dev.setVolume(volume);
-#else
-#ifdef ALSA_SUPPORT
-        alsaAudioDevice dev;
-        dev.setVolume(volume);
-#endif
-#endif
-	return 1;
-}
-
-#else
-void dummy_as_func( void);
-void dummy_as_func( void)
- {
-}
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,26 +0,0 @@
-//
-// C++ Interface: ADM_deviceSDL
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#ifdef USE_SDL
-
-	        class sdlAudioDevice : public audioDevice
-	 {
-		 protected :
-					uint8_t				_inUse;
-		  public:
-		  				sdlAudioDevice(void);
-		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
-	    			virtual uint8_t play(uint32_t len, float *data);
-		      		virtual uint8_t stop(void);
-				uint8_t setVolume(int volume);
-		 }     ;
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,192 +0,0 @@
-//
-// C++ Implementation: ADM_deviceWin32
-//
-// Description: 
-// C++ Implementation: ADM_deviceWin32
-// Use MM layer to output sound
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-
-#include &quot;config.h&quot;
-
-#ifdef __WIN32
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;windows.h&gt;
-
-#include &quot;fourcc.h&quot; 
-#include &quot;ADM_assert.h&quot;
-#include &quot;ADM_audiodevice.h&quot;
-#include &quot;ADM_audiodevice/ADM_deviceWin32.h&quot;
-
-#define MODULE_NAME  MODULE_ADEVICE
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#define NB_BUCKET 8
-
-static uint32_t bucketSize;
-static HWAVEOUT myDevice;
-static MMRESULT myError;
-
-static void handleMM(MMRESULT err);
-
-WAVEHDR waveHdr[NB_BUCKET];	
-
-win32AudioDevice::win32AudioDevice(void) 
-{
-	printf(&quot;[Win32] Creating audio device\n&quot;);
-	_inUse=0;
-}
-
-uint8_t win32AudioDevice::stop(void) 
-{
-	if (!_inUse)
-		return 0;
-
-	printf(&quot;[Win32] Closing audio\n&quot;);
-
-	waveOutReset(myDevice);		
-
-	for (uint32_t i = 0; i &lt; NB_BUCKET; i++)
-		waveOutUnprepareHeader(myDevice, &amp;waveHdr[i], sizeof(WAVEHDR));
-
-	myError = waveOutClose(myDevice);
-
-	if (myError != MMSYSERR_NOERROR)
-	{
-		printf(&quot;[Win32] Close failed %d\n&quot;, myError);
-		handleMM(myError);
-		return 0;
-	}
-
-	for (uint32_t i = 0; i &lt; NB_BUCKET; i++)
-		delete[] waveHdr[i].lpData;
-
-	_inUse=0;
-	myDevice = NULL;
-
-	return 1;
-}
-
-uint8_t win32AudioDevice::init(uint8_t channels, uint32_t fq) 
-{
-	printf(&quot;[Win32] Opening Audio, channels=%u freq=%u\n&quot;,channels, fq);
-
-	if (_inUse) 
-	{
-		printf(&quot;[Win32] Already running?\n&quot;);
-		return 0;
-	}
-
-	_inUse = 1;
-	_channels = channels;
-	bucketSize = channels * fq;
-
-	WAVEFORMATEX wav;
-
-	memset(&amp;wav, 0, sizeof(WAVEFORMATEX));
-
-	wav.wFormatTag = WAVE_FORMAT_PCM;
-	wav.nSamplesPerSec = fq;
-	wav.nChannels = channels;
-	wav.nBlockAlign = 2 * channels;
-	wav.nAvgBytesPerSec = 2 * channels * fq;
-	wav.wBitsPerSample = 16;
-
-	myError = waveOutOpen(&amp;myDevice, WAVE_MAPPER, &amp;wav, NULL, NULL, CALLBACK_NULL);
-
-	if (MMSYSERR_NOERROR != myError)
-	{
-		printf(&quot;[Win32] waveOutOpen failed\n&quot;);
-		handleMM(myError);
-		return 0;
-	}
-
-	for (uint32_t i = 0; i &lt; NB_BUCKET; i++)
-	{
-		memset(&amp;waveHdr[i], 0, sizeof(WAVEHDR));
-
-		waveHdr[i].dwBufferLength = bucketSize;
-		waveHdr[i].lpData = (char*)new uint8_t[bucketSize];
-
-		if (waveOutPrepareHeader(myDevice, &amp;waveHdr[i], sizeof(WAVEHDR)) != MMSYSERR_NOERROR)
-			printf(&quot;[Win32] waveOutPrepareHeader error\n&quot;);
-
-		waveHdr[i].dwBufferLength = 0;
-		waveHdr[i].dwFlags |= WHDR_DONE;
-	}
-
-	return 1;
-}
-
-uint8_t  win32AudioDevice::setVolume(int volume) 
-{
-	uint32_t value;
-
-	value = (0xffff * volume) / 100;
-	value = value + (value &lt;&lt; 16);
-
-	waveOutSetVolume(myDevice, value);
-
-	return 1;
-}
-
-uint8_t win32AudioDevice::play(uint32_t len, float *data)
-{
-	if (len == 0)
-		return 1;
-
-	dither16(data, len, _channels);
-	len *= 2;
-	uint8_t success = 0;
-
-	for (uint32_t i = 0; i &lt; NB_BUCKET; i++)
-	{
-		if (waveHdr[i].dwFlags &amp; WHDR_DONE)
-		{
-			waveHdr[i].dwFlags &amp;= ~WHDR_DONE;
-
-			if (len &gt; bucketSize)
-				waveHdr[i].dwBufferLength = bucketSize;
-			else
-				waveHdr[i].dwBufferLength = len;
-
-			memcpy(waveHdr[i].lpData, data, waveHdr[i].dwBufferLength);
-			data += waveHdr[i].dwBufferLength;
-			len -= waveHdr[i].dwBufferLength;
-
-			if (waveOutWrite(myDevice, &amp;waveHdr[i], sizeof(WAVEHDR)) == MMSYSERR_NOERROR)
-				success = 1;
-			else
-				break;
-		}
-
-		if (len == 0)
-			break;
-	}
-
-	if (len != 0)
-	{
-		printf(&quot;[Win32] No audio buffer available, %u bytes discarded\n&quot;, len);
-		return 0;
-	}
-
-	return success;
-}
-
-void handleMM(MMRESULT err)
-{
-#define ERMM(x) if(err==x) printf(&quot;[Win32] &quot;#x&quot;\n&quot;);
-
-	ERMM(MMSYSERR_ALLOCATED);
-	ERMM(MMSYSERR_BADDEVICEID);
-	ERMM(MMSYSERR_NODRIVER);
-	ERMM(WAVERR_BADFORMAT);
-	ERMM(WAVERR_SYNC);
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,26 +0,0 @@
-//
-// C++ Interface: ADM_deviceWin32
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#ifdef __WIN32
-
-class win32AudioDevice : public audioDevice
-{
-protected:
-	uint8_t	_inUse;
-public:
-	win32AudioDevice(void);
-	virtual uint8_t init(uint8_t channels, uint32_t fq);
-	virtual uint8_t play(uint32_t len, float *data);
-	virtual uint8_t stop(void);
-	virtual uint8_t setVolume(int volume);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,179 +0,0 @@
-/***************************************************************************
-                          ADM_deviceoss.cpp  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#ifdef OSS_SUPPORT
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;errno.h&gt;
-
-#include &lt;fcntl.h&gt;
-#include &lt;sys/ioctl.h&gt;
-
-#if defined(ADM_BSD_FAMILY) &amp;&amp; !defined(__FreeBSD__) &amp;&amp; !defined(__OpenBSD__)
-	#include &lt;soundcard.h&gt;
-	const char *dsp = DEVOSSAUDIO;;
-
-#elif defined(__OpenBSD__)
-	#include &lt;soundcard.h&gt;
-	const char *dsp = &quot;/dev/audio&quot;;
-	const char *device_mixer = &quot;/dev/mixer&quot;;
-
-#else
-	#include &lt;sys/soundcard.h&gt;
-	const char *dsp = &quot;/dev/dsp&quot;;
-        const char *device_mixer = &quot;/dev/mixer&quot;;
-
-#endif
- 
- 
-
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_audiodevice.h&quot;
-#include &quot;ADM_assert.h&quot;
-#include  &quot;ADM_audiodevice/ADM_deviceoss.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;prefs.h&quot;
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t  ossAudioDevice::setVolume(int volume) 
-{
-        int fd;
-	int ret;
-	uint32_t which_vol = 0;
-
-	prefs-&gt;get(FEATURE_AUDIOBAR_USES_MASTER,&amp;which_vol);
-        fd=open(device_mixer,O_RDONLY);
-        if(!fd)
-        {
-                printf(&quot;OSS: cannot open mixer\n&quot;);
-                return 0;
-        }
-        printf(&quot;Oss: New %s volume %d\n&quot;,(which_vol?&quot;master&quot;:&quot;pcm&quot;),volume);
-        // Assuming stereo
-        volume=volume+(volume&lt;&lt;8);
-	if( which_vol ){
-        	ret = ioctl(fd, MIXER_WRITE(SOUND_MIXER_VOLUME), &amp;volume);
-	}else{
-        	ret = ioctl(fd, MIXER_WRITE(SOUND_MIXER_PCM   ), &amp;volume);
-	}
-        close(fd);
-
-	if( ret ){
-		if( errno == EBADF ){
-			printf(&quot;set mixer failed: %u (possible access issue)\n&quot;,errno);
-		}else{
-			printf(&quot;set mixer failed: %u\n&quot;,errno);
-		}
-	}
-        return 1;
-
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t  ossAudioDevice::stop(void) {
-    if (oss_fd &gt; 0) {
-        close(oss_fd);
-        oss_fd = 0;
-    }
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t ossAudioDevice::init(uint8_t channels, uint32_t fq) 
-{
-	_channels = channels;
- 
-    printf(&quot;\n OSS  : %lu Hz, %lu channels&quot;, fq, channels);
-    // open OSS device
-    oss_fd = open(dsp, O_WRONLY | O_NONBLOCK);
-    if (oss_fd == -1) {
-	if( errno == EACCES )
-	{
-          GUI_Error_HIG(QT_TR_NOOP(&quot;Could not open OSS audio device&quot;), QT_TR_NOOP(&quot;Check the permissions for /dev/dsp.&quot;));
-	  }
-	else
-           printf(&quot;\n Error initializing OSS: Error : %d&quot;, errno);
-        return 0;
-    }
-    // seems ok, set up audio 
-    if (ioctl (oss_fd, SNDCTL_DSP_SPEED, &amp;fq) &lt; 0) {
-        printf(&quot;\n Error setting up OSS(SPEED): Error : %d&quot;, errno);
-        return 0;
-    }
-    if (channels &gt; 2) {
-        if (ioctl (oss_fd, SNDCTL_DSP_CHANNELS, &amp;channels) &lt; 0) {
-	    printf(&quot;\n Error setting up OSS(CHANNELS): Error : %d&quot;, errno);
-	    return 0;
-        }
-    } else {
-        int chan = channels - 1;
-        if (ioctl (oss_fd, SNDCTL_DSP_STEREO, &amp;chan) &lt; 0) {
-	    printf(&quot;\n Error setting up OSS(STEREO): Error : %d&quot;, errno);
-	    return 0;
-        }
-    }
-#ifdef ADM_BIG_ENDIAN    
-    int fmt = AFMT_S16_BE;
-#else
-    int fmt = AFMT_S16_LE;
-#endif    
-    if (ioctl (oss_fd, SNDCTL_DSP_SETFMT, &amp;fmt) &lt; 0) {
-        printf(&quot;\n Error setting up OSS(FORMAT): Error : %d&quot;, errno);
-        return 0;
-    }
-
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t ossAudioDevice::play(uint32_t len, float *data)
-{
-	uint32_t w;
-
-	if (!oss_fd)
-		return 0;
-
-	dither16(data, len, _channels);
-
-	w = write(oss_fd, data, len*2);
-        if(w!=len*2)
-        {
-          printf(&quot;[OSS] Warning : %u / %u\n&quot;,w,len*2); 
-        }
-	return 1;
-}
-#else
-void dummy_oss_func( void);
-void dummy_oss_func( void)
- {
-}
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,29 +0,0 @@
-/***************************************************************************
-                          ADM_deviceoss.h  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef OSS_SUPPORT
-class ossAudioDevice : public audioDevice
-{
-protected :
-                                int oss_fd;
-public:
-                                        ossAudioDevice(void) {oss_fd=0;}
-                        virtual uint8_t init(uint8_t channels, uint32_t fq);
-                        virtual uint8_t play(uint32_t len, float *data);
-                        virtual uint8_t stop(void);
-			uint8_t setVolume(int volume);
-}     ;
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,11 +1,11 @@
 SET(ADM_audiodevice_SRCS 
-	ADM_audiodevice.cpp  ADM_deviceArts.cpp       ADM_deviceEsd.cpp  ADM_deviceSDL.cpp    oss_out.cpp
-	ADM_deviceALSA.cpp   ADM_deviceAudioCore.cpp  ADM_deviceoss.cpp  ADM_deviceWin32.cpp  ADM_deviceJack.cpp)
+	ADM_audiodevice.cpp  
+	)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_audiodevice ${ADM_audiodevice_SRCS})
 
-SDLify(ADM_deviceSDL.cpp)
+#SDLify(ADM_deviceSDL.cpp)
 
-IF (USE_ARTS)
-	ADD_CFLAGS_ALL_TARGETS(ADM_audiodevice ${ARTS_CFLAGS})
-ENDIF (USE_ARTS)
\ No newline at end of file
+#IF (USE_ARTS)
+	#ADD_CFLAGS_ALL_TARGETS(ADM_audiodevice ${ARTS_CFLAGS})
+#ENDIF (USE_ARTS)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -17,60 +17,10 @@
 
 #ifndef AUDIOOUPUT_H
 #define AUDIOOUPUT_H
-//#include &quot;avi_vars.h&quot;
-#ifdef HAVE_AUDIO
-typedef enum
-{
-	DEVICE_OSS=1,
-	DEVICE_DUMMY,
-	DEVICE_ARTS,
-	DEVICE_ALSA,
-	DEVICE_COREAUDIO,
-	DEVICE_SDL,
-	DEVICE_WIN32,
-	DEVICE_ESD,
-	DEVICE_JACK
-}AUDIO_DEVICE;
 
-typedef struct 
-{
-	AUDIO_DEVICE id;
-	const char	     *name;
-}DEVICELIST;
-#define MKADID(x) {DEVICE_##x,#x}
-static const DEVICELIST audioDeviceList[]=
-{
-	
-#ifdef OSS_SUPPORT	
-	MKADID(OSS),
-#endif	
-#ifdef USE_ARTS
-	MKADID(ARTS),
-#endif	
-#ifdef ALSA_SUPPORT
-	MKADID(ALSA),
-#endif	
-#ifdef __APPLE__
-	MKADID(COREAUDIO),
-#endif
-#if	defined(USE_SDL) &amp;&amp; !defined(__WIN32)	
-	MKADID(SDL),
-#endif	
-#ifdef __WIN32	
-	MKADID(WIN32),
-#endif	
-#ifdef USE_ESD	
-	MKADID(ESD),
-#endif	
-#ifdef USE_JACK	
-	MKADID(JACK),
-#endif	
+typedef int AUDIO_DEVICE;
 
-	MKADID(DUMMY)
-};
-
-
-void 		AVDM_audioSave( void );
+void 		AVDM_audioSave( void ); /// Save in Prefs the current audio Device
 void 		AVDM_audioInit( void );
 void		AVDM_cleanup(void);
 void 		AVDM_switch( AUDIO_DEVICE action );
@@ -82,4 +32,4 @@
 uint8_t         AVDM_setVolume(int volume);
 
 #endif
-#endif
+

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp
===================================================================

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -19,6 +19,8 @@
 /* Functions we need to get infos */
 uint32_t ADM_ad_getNbFilters(void);
 bool     ADM_ad_getFilterInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
+uint32_t ADM_av_getNbDevices(void);
+bool     ADM_av_getDeviceInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
 uint32_t ADM_ve_getNbEncoders(void);
 bool     ADM_ve_getEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
 
@@ -32,6 +34,7 @@
 {
     uint32_t aNbPlugin=ADM_ad_getNbFilters();
     uint32_t veNbPlugin=ADM_ve_getNbEncoders();
+    uint32_t avNbPlugin=ADM_av_getNbDevices();
 
     // Audio Plugins
 
@@ -88,17 +91,48 @@
             veText[i]=new diaElemReadOnlyText(infoString,versionString);
             frameVE.swallow(veText[i]);
     }
+
     diaElem *diaVE[]={&amp;frameVE};
     diaElemTabs tabVE(QT_TR_NOOP(&quot;Video Encoder&quot;),1,diaVE);
 
+    // Audio Device
+    printf(&quot;[AudioDevice Plugins] Found %u plugins\n&quot;,avNbPlugin);
+    diaElemReadOnlyText *avText[avNbPlugin];
+    diaElemFrame frameAV(QT_TR_NOOP(&quot;Audio Device Plugins&quot;));
+    
+ for(int i=0;i&lt;avNbPlugin;i++)
+    {
+        const char *name;
+        uint32_t major,minor,patch;
+        char versionString[256];
+        char infoString[256];
+        char *end;
+            ADM_av_getDeviceInfo(i, &amp;name,&amp;major,&amp;minor,&amp;patch);
+            snprintf(versionString,255,&quot;%02d.%02d.%02d&quot;,major,minor,patch);
+            strncpy(infoString,name,255);
+            if(strlen(infoString))
+            {
+                end=strlen(infoString)+infoString-1;
+                // Remove trailing line feed
+                while(*end==0x0a || *end==0x0d) *end--=0;
+            }
+            avText[i]=new diaElemReadOnlyText(infoString,versionString);
+            frameAV.swallow(avText[i]);
+    }
+    diaElem *diaAV[]={&amp;frameAV};
+    diaElemTabs tabAV(QT_TR_NOOP(&quot;Audio Device&quot;),1,diaAV);
+
     // /Encoder
-    diaElemTabs *tabs[]={&amp;tabAudio,&amp;tabVE};
-    diaFactoryRunTabs(QT_TR_NOOP(&quot;Plugins Info&quot;),2,tabs);
 
+    diaElemTabs *tabs[]={&amp;tabAudio,&amp;tabVE,&amp;tabAV};
+    diaFactoryRunTabs(QT_TR_NOOP(&quot;Plugins Info&quot;),3,tabs);
+
     for(int i=0;i&lt;aNbPlugin;i++)
         delete aText[i];
     for(int i=0;i&lt;veNbPlugin;i++)
         delete veText[i];
+    for(int i=0;i&lt;avNbPlugin;i++)
+        delete avText[i];
 
     return 1;
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -288,6 +288,7 @@
 
 		diaMenuEntry audioEntries[] =
 		{
+#if 0
 		#ifdef ALSA_SUPPORT
 			{DEVICE_ALSA, QT_TR_NOOP(&quot;ALSA&quot;)},
 		#endif
@@ -312,12 +313,13 @@
 		#ifdef __WIN32
 			{DEVICE_WIN32, QT_TR_NOOP(&quot;Win32&quot;)},
 		#endif
-			{DEVICE_DUMMY, QT_TR_NOOP(&quot;None&quot;)}
+#endif
+			{0, QT_TR_NOOP(&quot;None&quot;)}
 		};
 
         diaElemMenu menuAudio(&amp;newdevice,QT_TR_NOOP(&quot;_Audio output:&quot;), sizeof(audioEntries)/sizeof(diaMenuEntry),audioEntries,&quot;&quot;);
                 
-#ifdef ALSA_SUPPORT
+#if 0 //def ALSA_SUPPORT
 		diaElemText entryAlsaDevice(&amp;alsaDevice,QT_TR_NOOP(&quot;ALSA _device:&quot;),NULL);
 
           int z,m;
@@ -372,16 +374,20 @@
         diaElemTabs tabOutput(QT_TR_NOOP(&quot;Output&quot;),4,(diaElem **)diaOutput);
         
         /* Audio */
-#if defined(ALSA_SUPPORT)
+
+#if 0 //defined(ALSA_SUPPORT)
         diaElem *diaAudio[]={&amp;menuMixer,&amp;menuVolume,&amp;menuAudio,&amp;entryAlsaDevice};
         diaElemTabs tabAudio(QT_TR_NOOP(&quot;Audio&quot;),4,(diaElem **)diaAudio);
-#elif defined(OSS_SUPPORT)
+//#elif defined(OSS_SUPPORT)
         diaElem *diaAudio[]={&amp;menuMixer,&amp;menuVolume,&amp;menuAudio};
         diaElemTabs tabAudio(QT_TR_NOOP(&quot;Audio&quot;),3,(diaElem **)diaAudio);
-#else
+#endif
+
+#if 1
         diaElem *diaAudio[]={&amp;menuMixer,&amp;menuAudio};
         diaElemTabs tabAudio(QT_TR_NOOP(&quot;Audio&quot;),2,(diaElem **)diaAudio);
 #endif
+
         
         /* Video */
         diaElem *diaVideo[]={&amp;menuVideoMode,&amp;framePP};

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -294,20 +294,6 @@
       ADM_aviUISetMuxer();
       return;
       break;
-#ifdef HAVE_AUDIO      
-    	case ACT_SelectDevOSS:
-				   AVDM_switch (DEVICE_OSS);
-				   return;break;
-    	case ACT_SelectDevDummy:
-				   AVDM_switch (DEVICE_DUMMY);
-				   return;break;
-    	case ACT_SelectDevArts:
-				   AVDM_switch (DEVICE_ARTS);
-				   return;break;
-	case ACT_SelectDevALSA:
-				   AVDM_switch (DEVICE_ALSA);
-				   return;break;
-#endif                                  
     case ACT_Fast:
       ADM_assert(0);
       break;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -71,6 +71,7 @@
 extern void getUIDescription(char*);
 extern uint8_t ADM_ad_loadPlugins(const char *path);
 extern uint8_t ADM_vf_loadPlugins(const char *path);
+extern uint8_t ADM_av_loadPlugins(const char *path);
 extern void loadPlugins(void);
 extern void InitFactory(void);
 extern void InitCoreToolkit(void);
@@ -226,19 +227,24 @@
 	//***************Plugins *********************
 	// Load system wide audio decoder plugin
 #ifdef __APPLE__
-	char *adPlugins = ADM_getInstallRelativePath(&quot;../Resources/lib&quot;,&quot;ADM_plugins&quot;,&quot;audioDecoder&quot;);
-	char *vfPlugins = ADM_getInstallRelativePath(&quot;../Resources/lib&quot;,&quot;ADM_plugins&quot;,&quot;videoFilter&quot;);
+    const char *startDir=&quot;../Resources/lib&quot;;
 #else
-	char *adPlugins = ADM_getInstallRelativePath(&quot;lib&quot;,&quot;ADM_plugins&quot;,&quot;audioDecoder&quot;);
-	char *vfPlugins = ADM_getInstallRelativePath(&quot;lib&quot;,&quot;ADM_plugins&quot;,&quot;videoFilter&quot;);
+    const char *startDir=&quot;lib&quot;;
 #endif
+	char *adPlugins = ADM_getInstallRelativePath(startDir,&quot;ADM_plugins&quot;,&quot;audioDecoder&quot;);
+	char *vfPlugins = ADM_getInstallRelativePath(startDir,&quot;ADM_plugins&quot;,&quot;videoFilter&quot;);
+    char *avPlugins = ADM_getInstallRelativePath(startDir,&quot;ADM_plugins&quot;,&quot;audioDevices&quot;);    
 
+
 	ADM_ad_loadPlugins(adPlugins);
 	delete [] adPlugins;
 
 	ADM_vf_loadPlugins(vfPlugins);
 	delete [] vfPlugins;
 
+    ADM_av_loadPlugins(avPlugins);
+    delete [] avPlugins;
+
 	// load local audio decoder plugins
 	adPlugins=ADM_getHomeRelativePath(&quot;plugins&quot;,&quot;audioDecoder&quot;);
 	ADM_ad_loadPlugins(adPlugins);

Added: branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,8 @@
+MACRO(INIT_AUDIO_DEVICE _lib)
+	INCLUDE_DIRECTORIES(&quot;${CMAKE_SOURCE_DIR}/../avidemux/ADM_core/include&quot;)
+	INCLUDE_DIRECTORIES(&quot;${CMAKE_SOURCE_DIR}/../avidemux/ADM_audiodevice/&quot;)
+ENDMACRO(INIT_AUDIO_DEVICE)
+
+MACRO(INSTALL_AUDIODEVICE _lib)
+	INSTALL(TARGETS ${_lib} DESTINATION &quot;${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins/audioDevices/&quot;)
+ENDMACRO(INSTALL_AUDIODEVICE)

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,346 @@
+/***************************************************************************
+                          ADM_deviceAlsa.cpp  -  description
+                             -------------------
+
+	Strongly derivated from code sample from alsa-project.org with some bits
+		from mplayer concerning the swparams
+
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &lt;unistd.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;sys/types.h&gt;
+
+
+
+
+#include &lt;alsa/asoundlib.h&gt;
+#include  &quot;ADM_audiodevice.h&quot;
+#include  &quot;ADM_audioDeviceInternal.h&quot;
+#include  &quot;ADM_deviceALSA.h&quot;
+
+
+ADM_DECLARE_AUDIODEVICE(Alsa,alsaAudioDevice,1,0,0,&quot;Alsa audio device (c) mean&quot;);
+
+/* Handle for the PCM device */
+snd_pcm_t *pcm_handle;
+
+    alsaAudioDevice::alsaAudioDevice( void )
+    {
+		_init=0;
+    }
+
+uint8_t alsaAudioDevice::init( uint32_t channel,uint32_t fq )
+{
+	int dir=0;
+
+	_channels=channel;
+	_init=0;
+   /* Playback stream */
+    snd_pcm_stream_t stream = SND_PCM_STREAM_PLAYBACK;
+
+    /* This structure contains information about    */
+    /* the hardware and can be used to specify the  */
+    /* configuration to be used for the PCM stream. */
+    snd_pcm_hw_params_t *hwparams;
+    snd_pcm_sw_params_t *swparams;
+
+
+  static char *pcm_name;
+//  if( prefs-&gt;get(DEVICE_AUDIO_ALSA_DEVICE, &amp;pcm_name) != RC_OK )
+               pcm_name = ADM_strdup(&quot;dmix&quot;);
+
+ /* Allocate the snd_pcm_hw_params_t structure on the stack. */
+    snd_pcm_hw_params_alloca(&amp;hwparams);
+    snd_pcm_sw_params_alloca(&amp;swparams);
+    /* Open PCM. The last parameter of this function is the mode. */
+    /* If this is set to 0, the standard mode is used. Possible   */
+    /* other values are SND_PCM_NONBLOCK and SND_PCM_ASYNC.       */
+    /* If SND_PCM_NONBLOCK is used, read / write access to the    */
+    /* PCM device will return immediately. If SND_PCM_ASYNC is    */
+    /* specified, SIGIO will be emitted whenever a period has     */
+    /* been completely processed by the soundcard.                */
+    if (snd_pcm_open(&amp;pcm_handle, pcm_name, stream, SND_PCM_NONBLOCK) &lt; 0) {
+      fprintf(stderr, &quot;Error opening PCM device %s\n&quot;, pcm_name);
+      return(0);
+    }
+    // past this point we got _init=1 -&gt; partially initialized
+    _init=1;
+      /* Init hwparams with full configuration space */
+    if (snd_pcm_hw_params_any(pcm_handle, hwparams) &lt; 0) {
+      fprintf(stderr, &quot;Can not configure this PCM device.\n&quot;);
+      ADM_dealloc(pcm_name);
+      return(0);
+    }
+    ADM_dealloc(pcm_name);
+    /* Set access type. This can be either    */
+    /* SND_PCM_ACCESS_RW_INTERLEAVED or       */
+    /* SND_PCM_ACCESS_RW_NONINTERLEAVED.      */
+    /* There are also access types for MMAPed */
+    /* access, but this is beyond the scope   */
+    /* of this introduction.                  */
+    if (snd_pcm_hw_params_set_access(pcm_handle, hwparams, SND_PCM_ACCESS_RW_INTERLEAVED) &lt; 0) {
+      fprintf(stderr, &quot;Error setting access.\n&quot;);
+      return(0);
+    }
+
+    /* Set sample format */
+//    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_FLOAT) &lt; 0) { //need more test
+    //  fprintf(stderr, &quot;Error setting float format.\n&quot;);
+
+#ifdef ADM_BIG_ENDIAN
+    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_S16_BE) &lt; 0)
+#else
+    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_S16_LE) &lt; 0)
+#endif
+    {
+      fprintf(stderr, &quot;Error setting format.\n&quot;);
+      return(0);
+    }
+	//}
+    /* Set sample rate. If the exact rate is not supported */
+    /* by the hardware, use nearest possible rate.         */
+    int exact_rate;
+    dir=0;
+    exact_rate = snd_pcm_hw_params_set_rate_near(pcm_handle, hwparams, &amp;fq, &amp;dir);
+    if (dir != 0) {
+      fprintf(stderr, &quot;The rate %lu Hz is not supported by your hardware.\n  ==&gt; Using %d Hz instead.\n&quot;, fq, exact_rate);
+    }
+
+    /* Set number of channels */
+    if (snd_pcm_hw_params_set_channels(pcm_handle, hwparams, channel) &lt; 0) {
+      fprintf(stderr, &quot;Error setting channels.\n&quot;);
+      return(0);
+    }
+#if 0
+    	uint32_t periods=fq*2*channel*10;
+	uint32_t periodsize=1;
+    /* Set number of periods. Periods used to be called fragments. */
+    if (snd_pcm_hw_params_set_periods(pcm_handle, hwparams, periods, 0) &lt; 0) {
+      fprintf(stderr, &quot;Error setting periods.\n&quot;);
+      return(0);
+    }
+#else
+
+ 	unsigned int buffer_time = 800000;
+	int er;
+	unsigned int buff;
+	dir=0;
+
+	if ((er=snd_pcm_hw_params_set_buffer_time_near(pcm_handle, hwparams, &amp;buffer_time, &amp;dir)) &lt; 0)
+	  {
+	    printf(&quot;Error : hw_params_set_buffer_time\n&quot;);
+	    return(0);
+	  }
+	  // unsigned ?
+	  dir=0;
+	  buff=buffer_time&gt;&gt;2;
+	snd_pcm_hw_params_set_period_time_near(pcm_handle, hwparams, &amp;buff, &amp;dir) ;
+#if 0
+	if (snd_pcm_hw_params_set_period_time_near(pcm_handle, hwparams, buffer_time&gt;&gt;2, 0) &lt; 0)
+	  /* original: alsa_buffer_time/ao_data.bps */
+	  {
+	    printf(&quot;Error : hw_params_set_period_time\n&quot;);
+	    return(0);
+	  }
+#endif
+#endif
+
+
+/*
+If your hardware does not support a buffersize of 2^n, you can use the function snd_pcm_hw_params_set_buffer_size_near. This works similar to snd_pcm_hw_params_set_rate_near. Now we apply the configuration to the PCM device pointed to by pcm_handle. This will also prepare the PCM device.
+*/
+
+
+    /* Apply HW parameter settings to */
+    /* PCM device and prepare device  */
+    if (snd_pcm_hw_params(pcm_handle, hwparams) &lt; 0) {
+      fprintf(stderr, &quot;Error setting HW params.\n&quot;);
+      return(0);
+    }
+
+ 	if (snd_pcm_sw_params_current(pcm_handle, swparams) &lt; 0)
+	    {
+	      printf(&quot;Error setting SW params.\n&quot;);
+	      return(0);
+	    }
+
+ 	// be sure that playback starts immediatly (or near)
+	  if (snd_pcm_sw_params_set_avail_min(pcm_handle, swparams, 4) &lt; 0)
+	    {
+	      printf(&quot;Error setting set_avail_min \n&quot;);
+	      return(0);
+	    }
+
+	  if (snd_pcm_sw_params(pcm_handle, swparams) &lt; 0)
+	    {
+	      printf(&quot;Error:snd_pcm_sw_params\n &quot;);
+	      return(0);
+	    }
+
+
+      if ( snd_pcm_prepare(pcm_handle) &lt; 0)
+	{
+	  printf(&quot;Error : snd_pcm_prepare\n&quot;);
+	  return(0);
+	}
+
+        printf(&quot;[Alsa]Success initializing: fq :%u channel %u\n&quot;,fq,channel);
+
+    // 2=fully initialized
+    _init=2;
+    return 1;
+}
+
+
+uint8_t alsaAudioDevice::play( uint32_t len, float *data )
+{
+	int ret;
+        int16_t *pcm;
+	/* Write num_frames frames from buffer data to    */
+	/* the PCM device pointed to by pcm_handle.       */
+	/* Returns the number of frames actually written. */
+
+	dither16(data, len, _channels);
+
+	if(2!=_init) return 0;
+        len=len/_channels;
+        pcm=(int16_t *)data;
+    	while(1)
+	{
+        	ret=snd_pcm_writei(pcm_handle, pcm, len);
+		if(ret==(int)len)
+		{
+			return 1;
+		}
+
+		if(ret&lt;0)
+		{
+			switch(ret)
+			{
+				case    -EAGAIN :
+					//wait a bit to flush datas
+					printf(&quot;ALSA EAGAIN\n&quot;);
+					snd_pcm_wait(pcm_handle, 1000);
+					continue;
+
+				case    -EPIPE:
+					printf(&quot;ALSA EPIPE\n&quot;);
+					snd_pcm_prepare(pcm_handle);
+					continue;
+				default:
+					printf(&quot;ALSA Error %d : Play %s (len=%lu)\n&quot;,ret, snd_strerror(ret),len);
+					return 1;
+			}
+		}
+		else
+		{
+			//if(len&lt;2) return 1;
+			len-=ret;
+                        pcm+=(ret*_channels);
+		}
+	}
+	return 1;
+}
+
+ uint8_t alsaAudioDevice::stop( void )
+ {
+ // we have at least a partial initialization
+ if(_init)
+ {
+       /* Stop PCM device and drop pending frames */
+    snd_pcm_drop(pcm_handle);
+
+    /* Stop PCM device after pending frames have been played */
+    snd_pcm_drain(pcm_handle);
+      if (snd_pcm_close(pcm_handle) &lt; 0)
+      {
+		printf(&quot;\n Troubles closing alsa\n&quot;);
+
+      }
+     }
+     _init=0;
+     return 1;
+}
+
+uint8_t alsaAudioDevice::setVolume(int volume){
+  snd_mixer_t *mixer_handle;
+  char *pcm_name;
+  uint32_t which_vol;
+  int rc;
+/*
+	if( prefs-&gt;get(DEVICE_AUDIO_ALSA_DEVICE, &amp;pcm_name) != RC_OK )
+		pcm_name = ADM_strdup(&quot;hw:0&quot;);
+	if( prefs-&gt;get(FEATURE_AUDIOBAR_USES_MASTER,&amp;which_vol) != RC_OK )
+		which_vol = 0;
+*/
+    pcm_name = ADM_strdup(&quot;hw:0&quot;);
+    which_vol = 0;
+	if( (rc=snd_mixer_open(&amp;mixer_handle,0)) &lt; 0 ){
+		printf(&quot;ALSA: snd_mixer_open failed: %d\n&quot;,rc);
+		ADM_dealloc(pcm_name);
+		return 0;
+	}
+// MEANX: Cannot use the real name, does not work with dmix
+	if( (rc=snd_mixer_attach(mixer_handle,&quot;hw:0&quot;)) &lt; 0 ){
+		printf(&quot;ALSA: snd_mixer_attach failed: %d, %s\n&quot;,rc, snd_strerror (rc));
+		snd_mixer_close(mixer_handle);
+		ADM_dealloc(pcm_name);
+		return 0;
+	}
+	ADM_dealloc(pcm_name);
+	if( (rc=snd_mixer_selem_register(mixer_handle,NULL,NULL)) &lt; 0 ){
+		printf(&quot;ALSA: snd_mixer_selem_register failed: %d\n&quot;,rc);
+		snd_mixer_close(mixer_handle);
+		return 0;
+	}
+	if( (rc=snd_mixer_load(mixer_handle)) &lt; 0 ){
+		printf(&quot;ALSA: snd_mixer_load failed: %d\n&quot;,rc);
+		snd_mixer_close(mixer_handle);
+		return 0;
+	}
+	{ snd_mixer_elem_t *elem;
+	  snd_mixer_selem_id_t *sid;
+	  const char *str;
+		snd_mixer_selem_id_alloca(&amp;sid);
+		for (elem = snd_mixer_first_elem(mixer_handle);
+		     elem;
+		     elem = snd_mixer_elem_next(elem)) {
+			snd_mixer_selem_get_id(elem, sid);
+			str = snd_mixer_selem_id_get_name(sid);
+			if( (which_vol == 0 &amp;&amp; !strcmp(str,&quot;PCM&quot;))   ||
+			    (which_vol == 1 &amp;&amp; !strcmp(str,&quot;Master&quot;))  ){
+			  long val=0, min=0, max=0;
+				snd_mixer_selem_get_playback_volume_range(elem,&amp;min,&amp;max);
+				/*
+				if( (rc=snd_mixer_selem_get_playback_volume(elem,SND_MIXER_SCHN_FRONT_LEFT,&amp;val)) &lt; 0 ){
+					printf(&quot;ALSA: snd_mixer_selem_get_playback_volume failed: %d\n&quot;,rc);
+				}
+				printf(&quot;ALSA: old val: %lu\n&quot;,val*100/max);
+				*/
+				if( (rc=snd_mixer_selem_set_playback_volume_all(elem,volume*max/100)) &lt; 0 ){
+					printf(&quot;ALSA: snd_mixer_selem_set_playback_volume_all failed: %d\n&quot;,rc);
+				}
+				printf(&quot;ALSA: new %s val: %lu\n&quot;,(which_vol?&quot;master&quot;:&quot;pcm&quot;),volume);
+				break;
+			}
+		}
+	}
+	snd_mixer_close(mixer_handle);
+	return 0;
+}
+
+//EOF

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,35 @@
+/***************************************************************************
+                          ADM_deviceAlsa.h  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+	 class alsaAudioDevice : public audioDevice
+	 {
+		 protected :
+				//	0-&gt; no init done
+				//	1-&gt; device opened but init failed
+				//	2-&gt;fully initialized
+				uint32_t _init;
+		  public:
+                                    alsaAudioDevice(void);
+		     		virtual uint8_t init(uint32_t channel,uint32_t fq);
+	    			virtual uint8_t play(uint32_t len, float *data);
+		      		virtual uint8_t stop(void) ;
+                    virtual uint8_t setVolume(int volume);
+		 }     ;
+//EOF
+
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,10 @@
+INCLUDE(av_plugin)
+
+
+SET(ADM_av_alsa_SRCS ADM_deviceALSA.cpp)
+
+ADD_LIBRARY(ADM_av_alsa SHARED ${ADM_av_alsa_SRCS})
+#TARGET_LINK_LIBRARIES(ADM_av_alsa ADM_libalsa)
+
+INIT_AUDIO_DEVICE(ADM_av_alsa)
+INSTALL_AUDIODEVICE(ADM_av_alsa)

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,121 @@
+/***************************************************************************
+                          ADM_deviceArts.cpp  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;config.h&quot;
+#include &quot;ADM_default.h&quot;
+
+#ifdef USE_ARTS
+#include &lt;artsc.h&gt;
+
+#include &quot;ADM_audiodevice.h&quot;
+#include  &quot;ADM_audiodevice/ADM_deviceoss.h&quot;
+#include  &quot;ADM_audiodevice/ADM_deviceArts.h&quot;
+
+uint8_t artsInitialized=0;
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t  artsAudioDevice::stop(void) {
+		if(!_stream)
+		{
+			printf(&quot;\n Arts: no stream\n&quot;);
+			return 0;
+		}
+
+		arts_close_stream(_stream);
+		// apparently arts 3.2 alpha does not like this
+	   	//arts_free();
+		_stream=NULL;
+		printf(&quot;\n Arts stopped\n&quot;);
+    	return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t artsAudioDevice::init(uint8_t channels, uint32_t fq)
+{
+	_channels = channels;
+
+    if(_stream)
+    	{
+			printf(&quot;\n purging previous instance\n&quot;);
+			stop();
+		}
+    printf(&quot;\n Arts  : %lu Hz, %lu channels&quot;, fq, channels);
+	if(!artsInitialized)
+	{
+		if(arts_init())
+		{
+			printf(&quot;\n Error initializing artsd\n&quot;);
+			return 0;
+		}
+		artsInitialized=1;
+	}
+
+	_stream=arts_play_stream(fq, 16,channels, &quot;Avidemux&quot;);
+
+	if(!_stream)
+	 {
+		printf(&quot;\n Problem setting fq/channel, aborting\n&quot;);
+		arts_free();
+		return 0;
+	}
+	arts_stream_set(_stream, ARTS_P_BLOCKING, 1);
+	arts_stream_set(_stream, ARTS_P_BUFFER_TIME, 50); // Ask for 1 sec buffer
+	//arts_stream_set(_stream,  ARTS_P_PACKET_SETTINGS, (11&lt;&lt;16)+10);
+
+
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t artsAudioDevice::play(uint32_t len, float *data)
+ {
+
+	if(!_stream) return 0;
+
+	dither16(data, len, _channels);
+
+	return arts_write(_stream, data, len*2);
+}
+
+/*
+** JSC     Mon Nov 28 19:20:06 CET 2005
+** based on <A HREF="http://www.arts-project.org/doc/mcop-doc/artsd-faq.html">http://www.arts-project.org/doc/mcop-doc/artsd-faq.html</A>
+** arts only works with OSS devices (or alsa devices using oss emulation)
+** so we only need OSS support here
+*/
+uint8_t artsAudioDevice::setVolume(int volume){
+#ifdef OSS_SUPPORT
+        ossAudioDevice dev;
+        dev.setVolume(volume);
+#endif
+        return 1;
+}
+
+#else
+void dummy_art_func( void);
+void dummy_art_func( void)
+ {
+}
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,33 @@
+/***************************************************************************
+                          ADM_deviceArts.h  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ #ifdef USE_ARTS
+                 class artsAudioDevice : public audioDevice
+	 {
+		 protected :
+		 		arts_stream_t _stream;
+		  public:
+		  			artsAudioDevice() {_stream=NULL;}
+				virtual ~artsAudioDevice() {stop();}
+		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
+	    			virtual uint8_t play(uint32_t len, float *data);
+		      		virtual uint8_t stop(void);
+				uint8_t setVolume(int volume);
+		 };
+#endif
+
+

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,260 @@
+/***************************************************************************
+                          ADM_deviceAudioCore.cpp  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#ifdef __APPLE__
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;pthread.h&gt;
+#include &lt;AudioUnit/AudioUnit.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_assert.h&quot;
+#include &quot;ADM_audiodevice.h&quot;
+#include &quot;ADM_audiodevice/ADM_deviceAudioCore.h&quot;
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME  MODULE_ADEVICE
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#define BUFFER_SIZE (500*48000)
+
+static Component comp = NULL;
+static int16_t audioBuffer[BUFFER_SIZE];
+static AudioUnit theOutputUnit;
+static uint32_t rd_ptr = 0;
+static uint32_t wr_ptr = 0;
+static pthread_mutex_t lock;
+
+static OSStatus MyRenderer(void *inRefCon, AudioUnitRenderActionFlags *inActionFlags,
+	const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData);
+static OSStatus OverloadListenerProc(AudioDeviceID inDevice, UInt32 inChannel, Boolean isInput,
+	AudioDevicePropertyID inPropertyID, void* inClientData);
+
+OSStatus OverloadListenerProc(AudioDeviceID inDevice, UInt32 inChannel, Boolean isInput,
+	AudioDevicePropertyID inPropertyID, void* inClientData)
+{
+	printf (&quot;[CoreAudio] *** Overload detected on device playing audio ***\n&quot;);
+	return noErr;
+}
+
+uint8_t coreAudioDevice::setVolume(int volume) {}
+
+coreAudioDevice::coreAudioDevice(void) 
+{
+	printf(&quot;[CoreAudio] Creating CoreAudio device\n&quot;);
+	_inUse=0;
+	pthread_mutex_init(&amp;lock, NULL);
+	pthread_mutex_unlock(&amp;lock);
+}
+
+uint8_t coreAudioDevice::stop(void) 
+{
+	if (_inUse)
+		verify_noerr(AudioOutputUnitStop(theOutputUnit));
+
+	// Clean up
+	CloseComponent(theOutputUnit);
+	_inUse=0;
+
+	return 1;
+}
+
+OSStatus MyRenderer(void *inRefCon, AudioUnitRenderActionFlags *inActionFlags, const AudioTimeStamp *inTimeStamp,
+	UInt32 inBusNumber, UInt32 inChannel, AudioBufferList *ioData)
+{
+	pthread_mutex_lock(&amp;lock);
+	uint32_t nb_sample = ioData-&gt;mBuffers[0].mDataByteSize &gt;&gt; 1;
+	uint32_t left = 0;
+	uint8_t *in, *out;
+
+	in = (uint8_t*)&amp;audioBuffer[rd_ptr];
+	out = (uint8_t*)ioData-&gt;mBuffers[0].mData;
+	aprintf(&quot;[CoreAudio] Fill: rd %lu, wr %lu, nb asked %lu\n&quot;, rd_ptr, wr_ptr, nb_sample);
+
+	if(wr_ptr&gt;rd_ptr)
+	{
+		left=wr_ptr-rd_ptr-1;
+
+		if(left&gt;nb_sample)
+		{
+			memcpy(out,in,nb_sample*2);
+			rd_ptr+=nb_sample;
+		}
+
+		else
+		{
+			memcpy(out,in,left*2);
+			memset(out+left*2,0,(nb_sample-left)*2);
+			rd_ptr+=left;
+		}
+	}
+	else
+	{
+		// wrap
+		left=BUFFER_SIZE-rd_ptr-1;
+		if(left&gt;nb_sample)
+		{
+			memcpy(out,in,nb_sample*2);
+			rd_ptr+=nb_sample;
+		}
+		else
+		{
+			memcpy(out,in,left*2);
+			out+=left*2;
+			rd_ptr=0;
+			in=(uint8_t *)&amp;audioBuffer[0];
+			nb_sample-=left;
+			if(nb_sample&gt;wr_ptr-1) nb_sample=wr_ptr-1;
+			memcpy(out,in,nb_sample*2);
+			rd_ptr=nb_sample;	
+		}
+	}
+
+	pthread_mutex_unlock(&amp;lock);
+	return 0;
+}
+
+#define CHECK_RESULT(msg) \
+    if (err != noErr) \
+	{ \
+		printf(&quot;[CoreAudio] Failed to initialise CoreAudio: &quot; msg &quot;\n&quot;); \
+        return 0; \
+    }
+
+uint8_t coreAudioDevice::init(uint8_t channels, uint32_t fq) 
+{
+	_channels = channels;
+
+	OSStatus err;
+	ComponentDescription desc;
+	AURenderCallbackStruct input;
+	AudioStreamBasicDescription streamFormat;
+	AudioDeviceID theDevice;
+
+	desc.componentType = kAudioUnitType_Output;
+	desc.componentSubType = kAudioUnitSubType_HALOutput;
+	desc.componentManufacturer = kAudioUnitManufacturer_Apple;
+	desc.componentFlags = 0;
+	desc.componentFlagsMask = 0;
+
+	comp = FindNextComponent(NULL, &amp;desc);
+
+	if (comp == NULL)
+	{
+		printf(&quot;[CoreAudio] Failed to find component\n&quot;);
+		return 0;
+	}
+
+	err = OpenAComponent(comp, &amp;theOutputUnit);
+	CHECK_RESULT(&quot;OpenAComponent&quot;)
+
+	err = AudioUnitInitialize(theOutputUnit);
+	CHECK_RESULT(&quot;AudioUnitInitialize&quot;)
+	
+	// Set up a callback function to generate output to the output unit
+	input.inputProc = MyRenderer;
+	input.inputProcRefCon = NULL;
+	
+	err = AudioUnitSetProperty(theOutputUnit, 
+					kAudioUnitProperty_SetRenderCallback,
+					kAudioUnitScope_Global,
+					0,
+					&amp;input, 
+					sizeof(input));
+	CHECK_RESULT(&quot;AudioUnitSetProperty [SetInputCallback]&quot;)
+
+	streamFormat.mSampleRate = fq;
+	streamFormat.mFormatID = kAudioFormatLinearPCM;
+	streamFormat.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger | kLinearPCMFormatFlagIsPacked;
+
+	streamFormat.mBytesPerPacket = channels * sizeof (UInt16);
+	streamFormat.mFramesPerPacket = 1;
+	streamFormat.mBytesPerFrame = channels * sizeof (UInt16);
+	streamFormat.mChannelsPerFrame = channels;
+	streamFormat.mBitsPerChannel = sizeof (UInt16) * 8;
+	
+	err = AudioUnitSetProperty(theOutputUnit,
+		kAudioUnitProperty_StreamFormat,
+		kAudioUnitScope_Input,
+		0,
+		&amp;streamFormat,
+		sizeof(streamFormat));
+	CHECK_RESULT(&quot;AudioUnitSetProperty [StreamFormat]&quot;)
+	
+	printf(&quot;[CoreAudio] Rendering source:\n&quot;);
+	printf(&quot;[CoreAudio] \tSampleRate = %f,\n&quot;, streamFormat.mSampleRate);
+	printf(&quot;[CoreAudio] \tBytesPerPacket = %ld,\n&quot;, streamFormat.mBytesPerPacket);
+	printf(&quot;[CoreAudio] \tFramesPerPacket = %ld,\n&quot;, streamFormat.mFramesPerPacket);
+	printf(&quot;[CoreAudio] \tBytesPerFrame = %ld,\n&quot;, streamFormat.mBytesPerFrame);
+	printf(&quot;[CoreAudio] \tBitsPerChannel = %ld,\n&quot;, streamFormat.mBitsPerChannel);
+	printf(&quot;[CoreAudio] \tChannelsPerFrame = %ld\n&quot;, streamFormat.mChannelsPerFrame);
+
+    return 1;
+}
+
+uint8_t coreAudioDevice::play(uint32_t len, float *data)
+ {
+ 	// First put stuff into the buffer
+	uint8_t *src;
+	uint32_t left;
+
+	dither16(data, len, _channels);
+
+	pthread_mutex_lock(&amp;lock);
+
+	// Check we have room left
+	if(wr_ptr&gt;=rd_ptr)
+		left=BUFFER_SIZE-(wr_ptr-rd_ptr);
+	else
+		left=rd_ptr-wr_ptr;
+
+	if(len+1&gt;left)
+	{
+		printf(&quot;[CoreAudio] Buffer full!\n&quot;);
+		pthread_mutex_unlock(&amp;lock);
+		return 0;
+	}
+
+	// We have room left, copy it
+	src=(uint8_t *)&amp;audioBuffer[wr_ptr];
+
+	if(wr_ptr+len&lt;BUFFER_SIZE)
+	{
+		memcpy(src,data,len*2);
+		wr_ptr+=len;
+	}
+	else
+	{
+		left=BUFFER_SIZE-wr_ptr-1;
+		memcpy(src,data,left*2);
+		memcpy(audioBuffer,data+left*2,(len-left)*2);
+		wr_ptr=len-left;	
+	}
+	//aprintf(&quot;AudioCore: Putting %lu bytes rd:%lu wr:%lu \n&quot;,len*2,rd_ptr,wr_ptr);
+	pthread_mutex_unlock(&amp;lock);	
+
+	_inUse=1;
+	verify_noerr(AudioOutputUnitStart(theOutputUnit));
+
+	return 1;
+}
+#else
+void dummy_ac_func(void);
+void dummy_ac_func(void)
+{
+}
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,26 @@
+//
+// C++ Interface: ADM_deviceAudioCore
+//
+// Description: 
+//
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifdef __APPLE__
+
+	        class coreAudioDevice : public audioDevice
+	 {
+		 protected :
+					uint8_t				_inUse;
+		  public:
+		  				coreAudioDevice(void);
+		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
+	    			virtual uint8_t play(uint32_t len, float *data);
+		      		virtual uint8_t stop(void);
+					virtual uint8_t setVolume(int volume);
+		 }     ;
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(Alsa)

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,111 @@
+/***************************************************************************
+                          ADM_deviceEsd.cpp  -  description
+
+  ESD support as output audio device
+                          
+    copyright            : (C) 2005 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#if defined(USE_ESD)
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;errno.h&gt;
+
+#include &lt;fcntl.h&gt;
+#include &lt;sys/ioctl.h&gt;
+#include &lt;esd.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_audiodevice.h&quot;
+#include &quot;ADM_assert.h&quot;
+#include &quot;ADM_audiodevice/ADM_deviceoss.h&quot;
+#include &quot;ADM_audiodevice/ADM_deviceALSA.h&quot;
+#include  &quot;ADM_audiodevice/ADM_deviceEsd.h&quot;
+
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t  esdAudioDevice::stop(void) {
+    if (esdDevice &gt; 0) {
+        esd_close(esdDevice);
+        esdDevice = 0;
+    }
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t esdAudioDevice::init(uint8_t channels, uint32_t fq) 
+{
+esd_format_t format;
+_channels = channels;
+
+    format=ESD_STREAM | ESD_PLAY | ESD_BITS16;
+    if(channels==1) format|=ESD_MONO;
+        else format|=ESD_STEREO;
+
+    printf(&quot;\n ESD  : %lu Hz, %lu channels&quot;, fq, channels);
+    esdDevice=esd_play_stream(format,fq,NULL,&quot;avidemux&quot;);
+    if(esdDevice&lt;=0) 
+    {
+        printf(&quot;Esd open failed\n&quot;);
+        return 0;
+    }
+    printf(&quot;Esd open succeedeed\n&quot;);
+    /*
+#ifdef ADM_BIG_ENDIAN    
+    int fmt = AFMT_S16_BE;
+#else
+    int fmt = AFMT_S16_LE;
+#endif    
+*/
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t esdAudioDevice::play(uint32_t len, float *data)
+{
+	dither16(data, len, _channels);
+	write(esdDevice, data, len*2);
+	return 1;
+}
+
+uint8_t esdAudioDevice::setVolume(int volume){
+#ifdef OSS_SUPPORT
+	ossAudioDevice dev;
+	dev.setVolume(volume);
+#else
+#ifdef ALSA_SUPPORT
+	alsaAudioDevice dev;
+	dev.setVolume(volume);
+#endif
+#endif
+	return 1;
+}
+
+#else
+void dummy_ess_func( void);
+void dummy_ess_func( void)
+ {
+}
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,29 @@
+/***************************************************************************
+                          ADM_deviceEsd.h  -  description
+                             -------------------
+                             Audio device for ESD sound daemon
+    copyright            : (C) 2005 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifdef USE_ESD
+class esdAudioDevice : public audioDevice
+	 {
+		 protected :
+                    int esdDevice;
+		  public:
+		  			esdAudioDevice(void) {esdDevice=-1;}
+		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
+	    			virtual uint8_t play(uint32_t len, float *data);
+		      		virtual uint8_t stop(void);
+				uint8_t setVolume(int volume);
+		 }     ;
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,251 @@
+//
+// Author: Mihail Zenkov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">mihail.zenkov at gmail.com</A>&gt;, (C) 2007
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include &quot;config.h&quot;
+
+#if defined(USE_JACK)
+#include &lt;unistd.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdint.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_audiodevice.h&quot;
+#include &quot;ADM_assert.h&quot;
+#include &quot;ADM_audiodevice/ADM_deviceoss.h&quot;
+#include &quot;ADM_audiodevice/ADM_deviceALSA.h&quot;
+#include &quot;ADM_audiodevice/ADM_deviceJack.h&quot;
+
+
+#define BUFSIZE 16385
+
+jackAudioDevice::jackAudioDevice()
+{
+	client = NULL;
+	ringbuffer = NULL;
+	#ifdef USE_SRC
+	src_out_buf = NULL;
+	src_state = NULL;
+	#endif
+}
+
+void jackAudioDevice::jack_shutdown(void *arg)
+{
+	((jackAudioDevice*)arg)-&gt;stop();
+}
+
+uint8_t jackAudioDevice::stop()
+{
+	if (client) {
+		printf(&quot;[JACK] Stop\n&quot;);
+		jack_client_close(client);
+		client = NULL;
+		if (ringbuffer)
+			jack_ringbuffer_free(ringbuffer);
+		ringbuffer = NULL;
+		#ifdef USE_SRC
+		delete src_out_buf;
+		src_out_buf = NULL;
+		src_delete(src_state);
+		src_state = NULL;
+		#endif
+	}
+
+	return 1;
+}
+
+uint8_t jackAudioDevice::init(uint8_t channels, uint32_t fq)
+{
+	jack_status_t status;
+	_channels = channels;
+
+	if (sizeof(jack_default_audio_sample_t) != sizeof(float)) {
+		printf(&quot;[JACK] jack_default_audio_sample_t != float\n&quot;);
+		return 0;
+	}
+
+	client = jack_client_open(&quot;avidemux&quot;, JackNullOption, &amp;status, NULL);
+
+	if (client == NULL) {
+		printf(&quot;[JACK] jack_client_open() failed, status = 0x%2.0x\n&quot;, status);
+		if (status &amp; JackServerFailed)
+			printf((&quot;[JACK] Unable to connect to server\n&quot;));
+		return 0;
+	}
+
+	if (status &amp; JackServerStarted)
+		printf(&quot;[JACK] Server started\n&quot;);
+
+	if (jack_get_sample_rate(client) == fq) {
+		jack_set_process_callback(client, process_callback, this);
+	} else {
+		printf(&quot;[JACK] audio stream sample rate: %i\n&quot;, fq);
+		printf(&quot;[JACK] jack server sample rate: %i\n&quot;, (int)jack_get_sample_rate(client));
+		#ifdef USE_SRC
+			src_out_buf = new float[BUFSIZE * channels];
+			src_state = src_new(SRC_SINC_FASTEST, channels, NULL);
+			if (!src_state) {
+				printf(&quot;[JACK] Can't init libsamplerate\n&quot;);
+				stop();
+				return 0;
+			}
+			src_data.data_out = src_out_buf;
+			src_data.output_frames = BUFSIZE;
+			src_data.src_ratio = jack_get_sample_rate(client) / (double)fq;
+			src_data.end_of_input = 0;
+//			printf(&quot;[JACK] ratio: %f\n&quot;, src_data.src_ratio);
+		#else
+			printf(&quot;[JACK] For play this, you need avidemux compiled with libsamplerate support\n&quot;);
+			stop();
+			return 0;
+		#endif
+	}
+
+	ringbuffer = jack_ringbuffer_create(BUFSIZE * channels * sizeof(jack_default_audio_sample_t));
+
+	jack_set_process_callback(client, process_callback, this);
+	jack_on_shutdown(client, jack_shutdown, this);
+
+	char name[10];
+	for (int i = 0; i &lt; channels; i++) {
+		snprintf(name, 10, &quot;output-%d&quot;, i);
+		ports[i] = jack_port_register(client, name, JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, 0);
+		if (!ports[i]) {
+			printf(&quot;[JACK] Can't create new port\n&quot;);
+			stop();
+			return 0;
+		}
+	}
+
+	if (jack_activate(client)) {
+		printf(&quot;[JACK] Cannot activate client\n&quot;);
+		stop();
+		return 0;
+	}
+
+	const char **input_ports = jack_get_ports(client, NULL, NULL, JackPortIsInput|JackPortIsPhysical);
+
+	for (int i = 0; i &lt; channels &amp;&amp; input_ports[i]; i++) {
+		if (jack_connect(client, jack_port_name(ports[i]), input_ports[i]))
+			printf(&quot;[JACK] Connecting failed\n&quot;);
+	}
+
+	if (channels == 1 &amp;&amp; input_ports[1])
+		if (jack_connect(client, jack_port_name(ports[0]), input_ports[1]))
+			printf(&quot;[JACK] Connecting failed\n&quot;);
+
+	return 1;
+}
+
+int jackAudioDevice::process(jack_nframes_t nframes)
+{
+	jack_default_audio_sample_t *pbuf[_channels];
+	for (int c = 0; c &lt; _channels; c++)
+		pbuf[c] = (jack_default_audio_sample_t *) jack_port_get_buffer(ports[c], nframes);
+
+	size_t read = jack_ringbuffer_read_space(ringbuffer) / sizeof(jack_default_audio_sample_t) / _channels;
+
+	if (read &gt; nframes)
+		read = nframes;
+
+	int i;
+	for (i = 0; i &lt; read; i++)
+		for (int c = 0; c &lt; _channels; c++) {
+			jack_ringbuffer_read(ringbuffer, (char *)pbuf[c], sizeof(jack_default_audio_sample_t));
+			pbuf[c]++;
+		}
+
+	for (; i &lt; nframes; i++)
+		for (int c = 0; c &lt; _channels; c++) {
+			pbuf[c] = 0;
+			pbuf[c]++;
+		}
+
+	if (read != nframes)
+		printf(&quot;[JACK] UNDERRUN!\n&quot;);
+
+	return 0;
+}
+
+int jackAudioDevice::process_callback(jack_nframes_t nframes, void* arg)
+{
+	return ((jackAudioDevice*)arg)-&gt;process(nframes);
+}
+
+
+uint8_t jackAudioDevice::play(uint32_t len, float *data)
+{
+//	static int min = 5000;
+	static int sleep = (int)((float)BUFSIZE / jack_get_sample_rate(client) / 2. * 1000000.);
+	size_t write;
+	float writef;
+	len /= _channels;
+
+	#ifdef USE_SRC
+	if (src_out_buf) {
+		while (len) {
+			writef = jack_ringbuffer_write_space(ringbuffer);
+			writef /= src_data.src_ratio * sizeof(jack_default_audio_sample_t) * _channels;
+			write = (size_t)writef;
+			if (write &gt;= len) {
+				src_data.data_in = data;
+				src_data.input_frames = len;
+				src_process(src_state, &amp;src_data);
+				jack_ringbuffer_write(ringbuffer,
+					(char *)src_out_buf,
+					src_data.output_frames_gen * sizeof(jack_default_audio_sample_t) * _channels);
+/*
+				if (len != src_data.input_frames_used)
+					printf(&quot;[JACK] len %i != %i input_frames_used\n&quot;, len, src_data.input_frames_used);
+				if (len &lt; min)
+					min = len;
+				printf(&quot;[JACK] %i %i %i %f %i\n&quot;,min, src_data.input_frames_used, src_data.output_frames_gen, writef, len);
+				data += src_data.input_frames_used * _channels;
+				len -= src_data.input_frames_used;
+*/
+				return 1;
+			} else {
+				printf(&quot;[JACK] OVERRUN!\n&quot;);
+				usleep(sleep);
+			}
+		}
+	} else
+	#endif
+	while (len) {
+		writef = jack_ringbuffer_write_space(ringbuffer);
+		writef /= sizeof(jack_default_audio_sample_t) * _channels;
+		write = (size_t)writef;
+		if (write &gt;= len) {
+			jack_ringbuffer_write(ringbuffer, (char *)data, len * sizeof(jack_default_audio_sample_t) * _channels);
+			return 1;
+		} else {
+			printf(&quot;[JACK] OVERRUN!\n&quot;);
+			usleep(sleep);
+		}
+	}
+
+        return 1;
+}
+
+uint8_t jackAudioDevice::setVolume(int volume){
+#ifdef OSS_SUPPORT
+	ossAudioDevice dev;
+	dev.setVolume(volume);
+#else
+#ifdef ALSA_SUPPORT
+	alsaAudioDevice dev;
+	dev.setVolume(volume);
+#endif
+#endif
+	return 1;
+}
+
+#else
+void dummy_jack_func( void);
+void dummy_jack_func( void)
+{
+}
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,43 @@
+//
+// Author: Mihail Zenkov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">mihail.zenkov at gmail.com</A>&gt;, (C) 2007
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#ifdef USE_JACK
+
+
+#include &lt;jack/jack.h&gt;
+#include &lt;jack/ringbuffer.h&gt;
+
+#ifdef USE_SRC
+#include &lt;samplerate.h&gt;
+#endif
+
+#define MAX_CHANNELS 9
+
+class jackAudioDevice : public audioDevice
+{
+public:
+	jackAudioDevice();
+	virtual uint8_t init(uint8_t channel,uint32_t fq);
+	virtual uint8_t play(uint32_t len, float *data);
+	virtual uint8_t stop();
+	uint8_t setVolume(int volume);
+	int process(jack_nframes_t nframes);
+
+protected:
+	static void jack_shutdown(void *arg);
+	static int process_callback(jack_nframes_t nframes, void *arg);
+
+	jack_port_t *ports[MAX_CHANNELS];
+	jack_client_t *client;
+	jack_ringbuffer_t *ringbuffer;
+	#ifdef USE_SRC
+	float *src_out_buf;
+	SRC_STATE *src_state;
+	SRC_DATA src_data;
+	#endif
+};
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,179 @@
+/***************************************************************************
+                          ADM_deviceoss.cpp  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#ifdef OSS_SUPPORT
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;errno.h&gt;
+
+#include &lt;fcntl.h&gt;
+#include &lt;sys/ioctl.h&gt;
+
+#if defined(ADM_BSD_FAMILY) &amp;&amp; !defined(__FreeBSD__) &amp;&amp; !defined(__OpenBSD__)
+	#include &lt;soundcard.h&gt;
+	const char *dsp = DEVOSSAUDIO;;
+
+#elif defined(__OpenBSD__)
+	#include &lt;soundcard.h&gt;
+	const char *dsp = &quot;/dev/audio&quot;;
+	const char *device_mixer = &quot;/dev/mixer&quot;;
+
+#else
+	#include &lt;sys/soundcard.h&gt;
+	const char *dsp = &quot;/dev/dsp&quot;;
+        const char *device_mixer = &quot;/dev/mixer&quot;;
+
+#endif
+ 
+ 
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_audiodevice.h&quot;
+#include &quot;ADM_assert.h&quot;
+#include  &quot;ADM_audiodevice/ADM_deviceoss.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;prefs.h&quot;
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t  ossAudioDevice::setVolume(int volume) 
+{
+        int fd;
+	int ret;
+	uint32_t which_vol = 0;
+
+	prefs-&gt;get(FEATURE_AUDIOBAR_USES_MASTER,&amp;which_vol);
+        fd=open(device_mixer,O_RDONLY);
+        if(!fd)
+        {
+                printf(&quot;OSS: cannot open mixer\n&quot;);
+                return 0;
+        }
+        printf(&quot;Oss: New %s volume %d\n&quot;,(which_vol?&quot;master&quot;:&quot;pcm&quot;),volume);
+        // Assuming stereo
+        volume=volume+(volume&lt;&lt;8);
+	if( which_vol ){
+        	ret = ioctl(fd, MIXER_WRITE(SOUND_MIXER_VOLUME), &amp;volume);
+	}else{
+        	ret = ioctl(fd, MIXER_WRITE(SOUND_MIXER_PCM   ), &amp;volume);
+	}
+        close(fd);
+
+	if( ret ){
+		if( errno == EBADF ){
+			printf(&quot;set mixer failed: %u (possible access issue)\n&quot;,errno);
+		}else{
+			printf(&quot;set mixer failed: %u\n&quot;,errno);
+		}
+	}
+        return 1;
+
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t  ossAudioDevice::stop(void) {
+    if (oss_fd &gt; 0) {
+        close(oss_fd);
+        oss_fd = 0;
+    }
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t ossAudioDevice::init(uint8_t channels, uint32_t fq) 
+{
+	_channels = channels;
+ 
+    printf(&quot;\n OSS  : %lu Hz, %lu channels&quot;, fq, channels);
+    // open OSS device
+    oss_fd = open(dsp, O_WRONLY | O_NONBLOCK);
+    if (oss_fd == -1) {
+	if( errno == EACCES )
+	{
+          GUI_Error_HIG(QT_TR_NOOP(&quot;Could not open OSS audio device&quot;), QT_TR_NOOP(&quot;Check the permissions for /dev/dsp.&quot;));
+	  }
+	else
+           printf(&quot;\n Error initializing OSS: Error : %d&quot;, errno);
+        return 0;
+    }
+    // seems ok, set up audio 
+    if (ioctl (oss_fd, SNDCTL_DSP_SPEED, &amp;fq) &lt; 0) {
+        printf(&quot;\n Error setting up OSS(SPEED): Error : %d&quot;, errno);
+        return 0;
+    }
+    if (channels &gt; 2) {
+        if (ioctl (oss_fd, SNDCTL_DSP_CHANNELS, &amp;channels) &lt; 0) {
+	    printf(&quot;\n Error setting up OSS(CHANNELS): Error : %d&quot;, errno);
+	    return 0;
+        }
+    } else {
+        int chan = channels - 1;
+        if (ioctl (oss_fd, SNDCTL_DSP_STEREO, &amp;chan) &lt; 0) {
+	    printf(&quot;\n Error setting up OSS(STEREO): Error : %d&quot;, errno);
+	    return 0;
+        }
+    }
+#ifdef ADM_BIG_ENDIAN    
+    int fmt = AFMT_S16_BE;
+#else
+    int fmt = AFMT_S16_LE;
+#endif    
+    if (ioctl (oss_fd, SNDCTL_DSP_SETFMT, &amp;fmt) &lt; 0) {
+        printf(&quot;\n Error setting up OSS(FORMAT): Error : %d&quot;, errno);
+        return 0;
+    }
+
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t ossAudioDevice::play(uint32_t len, float *data)
+{
+	uint32_t w;
+
+	if (!oss_fd)
+		return 0;
+
+	dither16(data, len, _channels);
+
+	w = write(oss_fd, data, len*2);
+        if(w!=len*2)
+        {
+          printf(&quot;[OSS] Warning : %u / %u\n&quot;,w,len*2); 
+        }
+	return 1;
+}
+#else
+void dummy_oss_func( void);
+void dummy_oss_func( void)
+ {
+}
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,29 @@
+/***************************************************************************
+                          ADM_deviceoss.h  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifdef OSS_SUPPORT
+class ossAudioDevice : public audioDevice
+{
+protected :
+                                int oss_fd;
+public:
+                                        ossAudioDevice(void) {oss_fd=0;}
+                        virtual uint8_t init(uint8_t channels, uint32_t fq);
+                        virtual uint8_t play(uint32_t len, float *data);
+                        virtual uint8_t stop(void);
+			uint8_t setVolume(int volume);
+}     ;
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,276 @@
+//
+// C++ Implementation: ADM_deviceSDL
+//
+// Description: 
+//
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include &quot;config.h&quot;
+#include &lt;errno.h&gt;
+
+
+#include &quot;ADM_default.h&quot;
+  
+ 
+#ifdef USE_SDL
+#include &quot;SDL.h&quot;
+
+
+
+#include &quot;ADM_audiodevice.h&quot;
+#include &quot;ADM_audiodevice/ADM_deviceoss.h&quot;
+#include &quot;ADM_audiodevice/ADM_deviceALSA.h&quot;
+#include &quot;ADM_audiodevice/ADM_deviceSDL.h&quot;
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME  MODULE_ADEVICE
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+static int16_t  		*audioBuffer=NULL;
+static uint32_t 		frameCount=0;
+static uint32_t			rd_ptr=0;
+static uint32_t			wr_ptr=0;
+
+extern &quot;C&quot;
+{
+static void SDL_callback(void *userdata, Uint8 *stream, int len);
+}
+
+#ifdef __APPLE__
+#define BUFFER_SIZE (500*48000)
+#else
+#define BUFFER_SIZE (2*48000)
+#endif
+
+//_______________________________________________
+//
+//_______________________________________________
+
+
+//_______________________________________________
+//
+//_______________________________________________
+
+sdlAudioDevice::sdlAudioDevice(void) 
+{
+	printf(&quot;Creating SDL Audio device\n&quot;);
+	_inUse=0;
+	wr_ptr=rd_ptr=0;
+}
+//_______________________________________________
+//
+//_______________________________________________
+uint8_t  sdlAudioDevice::stop(void) 
+{
+	if(audioBuffer)
+	{
+		delete [] audioBuffer;
+		audioBuffer=NULL;
+	}
+	
+		SDL_PauseAudio(1); // First pause it
+		SDL_CloseAudio();
+		SDL_QuitSubSystem(SDL_INIT_AUDIO);
+	
+	// Clean up
+	//CloseComponent(theOutputUnit);
+	_inUse=0;
+    	wr_ptr=rd_ptr=0;
+	printf(&quot;Closing SDL audio\n&quot;);
+	return 1;
+}
+//_______________________________________________
+//  We have to fill len data to stream pointer
+//_______________________________________________
+void SDL_callback(void *userdata, Uint8 *stream, int len)
+{
+
+
+	
+	uint32_t nb_sample=len&gt;&gt;1;
+	uint32_t left=0;
+	uint8_t *in,*out;
+
+	in=(uint8_t *)&amp;audioBuffer[rd_ptr];
+	out=(uint8_t *)stream;
+	aprintf(&quot;sdl : Fill : rd %lu wr:%lu nb asked:%lu \n&quot;,rd_ptr,wr_ptr,nb_sample);
+	if(wr_ptr&gt;rd_ptr)
+	{
+		left=wr_ptr-rd_ptr-1;	
+		if(left&gt;nb_sample)
+		{
+			memcpy(out,in,nb_sample*2);
+			rd_ptr+=nb_sample;
+		}
+		else
+		{
+			memcpy(out,in,left*2);
+			memset(out+left*2,0,(nb_sample-left)*2);
+			rd_ptr+=left;
+		}
+	}
+	else
+	{
+		// wrap
+		left=BUFFER_SIZE-rd_ptr-1;
+		if(left&gt;nb_sample)
+		{
+			memcpy(out,in,nb_sample*2);
+			rd_ptr+=nb_sample;
+		}
+		else
+		{
+			memcpy(out,in,left*2);
+			out+=left*2;
+			rd_ptr=0;
+			in=(uint8_t *)&amp;audioBuffer[0];
+			nb_sample-=left;
+			if(nb_sample&gt;wr_ptr-1) nb_sample=wr_ptr-1;
+			memcpy(out,in,nb_sample*2);
+			rd_ptr=nb_sample;	
+		}
+	}
+	
+
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t sdlAudioDevice::init(uint8_t channels, uint32_t fq) 
+{
+SDL_AudioSpec spec,result;
+_channels = channels;
+		
+		printf(&quot;[SDL] Opening audio, fq=%d\n&quot;,fq);
+
+		if(_inUse) 
+		{
+			printf(&quot;[SDL] Already running ?\n&quot;);
+			return 1; // ???
+		}
+		
+		if (SDL_InitSubSystem(SDL_INIT_AUDIO) &lt; 0) 
+		{
+			printf(&quot;[SDL] FAILED initialising Audio subsystem\n&quot;);
+			printf(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
+			return 0;
+		}
+		memset(&amp;spec,0,sizeof(spec));
+		memset(&amp;result,0,sizeof(result));
+		spec.freq=fq;
+		spec.channels=channels;
+		spec.samples=65536&gt;&gt;4; // 1 second worth of audio
+		spec.callback=SDL_callback;
+		spec.userdata=NULL;
+		spec.format=AUDIO_S16;
+	
+		int res=SDL_OpenAudio(&amp;spec,&amp;result);
+		if(res&lt;0)
+		{
+			printf(&quot;[SDL] Audio device FAILED to open\n&quot;);
+			printf(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
+
+			printf(&quot;fq   %d \n&quot;,spec.freq);
+			printf(&quot;chan %d \n&quot;, spec.channels);
+			printf(&quot;samples %d \n&quot;,spec.samples);
+			printf(&quot;format %d \n&quot;,spec.format);
+			
+			printf(&quot;fq   %d \n&quot;,result.freq);
+			printf(&quot;chan %d \n&quot;, result.channels);
+			printf(&quot;samples %d \n&quot;,result.samples);
+			printf(&quot;format %d \n&quot;,result.format);
+
+			return 0;
+		}
+		
+	frameCount=0;
+	
+	audioBuffer=new int16_t[BUFFER_SIZE]; // between hald a sec and a sec should be enough :)
+	
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t sdlAudioDevice::play(uint32_t len, float *data)
+ {
+ 	// First put stuff into the buffer
+	uint8_t *src;
+	uint32_t left;
+
+	dither16(data, len, _channels);
+	
+	// Check we have room left
+	if(wr_ptr&gt;=rd_ptr)
+	{
+		left=BUFFER_SIZE-(wr_ptr-rd_ptr);
+	}
+	else
+	{
+		left=rd_ptr-wr_ptr;
+	}
+	if(len+1&gt;left)
+	{
+		printf(&quot;AudioCore:Buffer full!\n&quot;);
+		
+		return 0;
+	}
+
+	// We have room left, copy it
+	src=(uint8_t *)&amp;audioBuffer[wr_ptr];
+	
+	SDL_LockAudio();
+	
+	if(wr_ptr+len&lt;BUFFER_SIZE)
+	{
+		memcpy(src,data,len*2);
+		wr_ptr+=len;
+	}
+	else
+	{
+		left=BUFFER_SIZE-wr_ptr-1;
+		memcpy(src,data,left*2);
+		memcpy(audioBuffer,data+left*2,(len-left)*2);
+		wr_ptr=len-left;	
+	}
+	
+	//aprintf(&quot;AudioSDL: Putting %lu bytes rd:%lu wr:%lu \n&quot;,len*2,rd_ptr,wr_ptr);
+	SDL_UnlockAudio();
+ 	if(!frameCount)
+	{
+		_inUse=1;
+		SDL_PauseAudio(0);;
+	}
+	
+	return 1;
+}
+
+uint8_t sdlAudioDevice::setVolume(int volume){
+#ifdef OSS_SUPPORT
+        ossAudioDevice dev;
+        dev.setVolume(volume);
+#else
+#ifdef ALSA_SUPPORT
+        alsaAudioDevice dev;
+        dev.setVolume(volume);
+#endif
+#endif
+	return 1;
+}
+
+#else
+void dummy_as_func( void);
+void dummy_as_func( void)
+ {
+}
+
+#endif
+

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,26 @@
+//
+// C++ Interface: ADM_deviceSDL
+//
+// Description: 
+//
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifdef USE_SDL
+
+	        class sdlAudioDevice : public audioDevice
+	 {
+		 protected :
+					uint8_t				_inUse;
+		  public:
+		  				sdlAudioDevice(void);
+		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
+	    			virtual uint8_t play(uint32_t len, float *data);
+		      		virtual uint8_t stop(void);
+				uint8_t setVolume(int volume);
+		 }     ;
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,192 @@
+//
+// C++ Implementation: ADM_deviceWin32
+//
+// Description: 
+// C++ Implementation: ADM_deviceWin32
+// Use MM layer to output sound
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+
+#include &quot;config.h&quot;
+
+#ifdef __WIN32
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;windows.h&gt;
+
+#include &quot;fourcc.h&quot; 
+#include &quot;ADM_assert.h&quot;
+#include &quot;ADM_audiodevice.h&quot;
+#include &quot;ADM_audiodevice/ADM_deviceWin32.h&quot;
+
+#define MODULE_NAME  MODULE_ADEVICE
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#define NB_BUCKET 8
+
+static uint32_t bucketSize;
+static HWAVEOUT myDevice;
+static MMRESULT myError;
+
+static void handleMM(MMRESULT err);
+
+WAVEHDR waveHdr[NB_BUCKET];	
+
+win32AudioDevice::win32AudioDevice(void) 
+{
+	printf(&quot;[Win32] Creating audio device\n&quot;);
+	_inUse=0;
+}
+
+uint8_t win32AudioDevice::stop(void) 
+{
+	if (!_inUse)
+		return 0;
+
+	printf(&quot;[Win32] Closing audio\n&quot;);
+
+	waveOutReset(myDevice);		
+
+	for (uint32_t i = 0; i &lt; NB_BUCKET; i++)
+		waveOutUnprepareHeader(myDevice, &amp;waveHdr[i], sizeof(WAVEHDR));
+
+	myError = waveOutClose(myDevice);
+
+	if (myError != MMSYSERR_NOERROR)
+	{
+		printf(&quot;[Win32] Close failed %d\n&quot;, myError);
+		handleMM(myError);
+		return 0;
+	}
+
+	for (uint32_t i = 0; i &lt; NB_BUCKET; i++)
+		delete[] waveHdr[i].lpData;
+
+	_inUse=0;
+	myDevice = NULL;
+
+	return 1;
+}
+
+uint8_t win32AudioDevice::init(uint8_t channels, uint32_t fq) 
+{
+	printf(&quot;[Win32] Opening Audio, channels=%u freq=%u\n&quot;,channels, fq);
+
+	if (_inUse) 
+	{
+		printf(&quot;[Win32] Already running?\n&quot;);
+		return 0;
+	}
+
+	_inUse = 1;
+	_channels = channels;
+	bucketSize = channels * fq;
+
+	WAVEFORMATEX wav;
+
+	memset(&amp;wav, 0, sizeof(WAVEFORMATEX));
+
+	wav.wFormatTag = WAVE_FORMAT_PCM;
+	wav.nSamplesPerSec = fq;
+	wav.nChannels = channels;
+	wav.nBlockAlign = 2 * channels;
+	wav.nAvgBytesPerSec = 2 * channels * fq;
+	wav.wBitsPerSample = 16;
+
+	myError = waveOutOpen(&amp;myDevice, WAVE_MAPPER, &amp;wav, NULL, NULL, CALLBACK_NULL);
+
+	if (MMSYSERR_NOERROR != myError)
+	{
+		printf(&quot;[Win32] waveOutOpen failed\n&quot;);
+		handleMM(myError);
+		return 0;
+	}
+
+	for (uint32_t i = 0; i &lt; NB_BUCKET; i++)
+	{
+		memset(&amp;waveHdr[i], 0, sizeof(WAVEHDR));
+
+		waveHdr[i].dwBufferLength = bucketSize;
+		waveHdr[i].lpData = (char*)new uint8_t[bucketSize];
+
+		if (waveOutPrepareHeader(myDevice, &amp;waveHdr[i], sizeof(WAVEHDR)) != MMSYSERR_NOERROR)
+			printf(&quot;[Win32] waveOutPrepareHeader error\n&quot;);
+
+		waveHdr[i].dwBufferLength = 0;
+		waveHdr[i].dwFlags |= WHDR_DONE;
+	}
+
+	return 1;
+}
+
+uint8_t  win32AudioDevice::setVolume(int volume) 
+{
+	uint32_t value;
+
+	value = (0xffff * volume) / 100;
+	value = value + (value &lt;&lt; 16);
+
+	waveOutSetVolume(myDevice, value);
+
+	return 1;
+}
+
+uint8_t win32AudioDevice::play(uint32_t len, float *data)
+{
+	if (len == 0)
+		return 1;
+
+	dither16(data, len, _channels);
+	len *= 2;
+	uint8_t success = 0;
+
+	for (uint32_t i = 0; i &lt; NB_BUCKET; i++)
+	{
+		if (waveHdr[i].dwFlags &amp; WHDR_DONE)
+		{
+			waveHdr[i].dwFlags &amp;= ~WHDR_DONE;
+
+			if (len &gt; bucketSize)
+				waveHdr[i].dwBufferLength = bucketSize;
+			else
+				waveHdr[i].dwBufferLength = len;
+
+			memcpy(waveHdr[i].lpData, data, waveHdr[i].dwBufferLength);
+			data += waveHdr[i].dwBufferLength;
+			len -= waveHdr[i].dwBufferLength;
+
+			if (waveOutWrite(myDevice, &amp;waveHdr[i], sizeof(WAVEHDR)) == MMSYSERR_NOERROR)
+				success = 1;
+			else
+				break;
+		}
+
+		if (len == 0)
+			break;
+	}
+
+	if (len != 0)
+	{
+		printf(&quot;[Win32] No audio buffer available, %u bytes discarded\n&quot;, len);
+		return 0;
+	}
+
+	return success;
+}
+
+void handleMM(MMRESULT err)
+{
+#define ERMM(x) if(err==x) printf(&quot;[Win32] &quot;#x&quot;\n&quot;);
+
+	ERMM(MMSYSERR_ALLOCATED);
+	ERMM(MMSYSERR_BADDEVICEID);
+	ERMM(MMSYSERR_NODRIVER);
+	ERMM(WAVERR_BADFORMAT);
+	ERMM(WAVERR_SYNC);
+}
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,26 @@
+//
+// C++ Interface: ADM_deviceWin32
+//
+// Description: 
+//
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifdef __WIN32
+
+class win32AudioDevice : public audioDevice
+{
+protected:
+	uint8_t	_inUse;
+public:
+	win32AudioDevice(void);
+	virtual uint8_t init(uint8_t channels, uint32_t fq);
+	virtual uint8_t play(uint32_t len, float *data);
+	virtual uint8_t stop(void);
+	virtual uint8_t setVolume(int volume);
+};
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001436.html">[Avidemux-svn-commit] r4183 -	branches/avidemux_2.5_branch_gruntster/plugins
</A></li>
	<LI>Next message: <A HREF="001439.html">[Avidemux-svn-commit] r4185 - in	branches/avidemux_2.5_branch_gruntster: . avidemux	avidemux/ADM_audiodevice	avidemux/ADM_userInterfaces/ADM_commonUI cmake	plugins/ADM_audioDevices plugins/ADM_audioDevices/Alsa	plugins/ADM_audioDevices/Esd	plugins/ADM_audioDevices/PulseAudioSimple
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1437">[ date ]</a>
              <a href="thread.html#1437">[ thread ]</a>
              <a href="subject.html#1437">[ subject ]</a>
              <a href="author.html#1437">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
