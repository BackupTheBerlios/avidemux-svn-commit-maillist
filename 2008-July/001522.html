<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4281 - in	branches/avidemux_2.4_branch/avidemux/ADM_libraries:	ADM_lavcodec ADM_lavutil
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4281%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries%3A%0A%09ADM_lavcodec%20ADM_lavutil&In-Reply-To=%3C200807241820.m6OIKeLf005759%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001521.html">
   <LINK REL="Next"  HREF="001523.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4281 - in	branches/avidemux_2.4_branch/avidemux/ADM_libraries:	ADM_lavcodec ADM_lavutil</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4281%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries%3A%0A%09ADM_lavcodec%20ADM_lavutil&In-Reply-To=%3C200807241820.m6OIKeLf005759%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4281 - in	branches/avidemux_2.4_branch/avidemux/ADM_libraries:	ADM_lavcodec ADM_lavutil">gruntster at mail.berlios.de
       </A><BR>
    <I>Thu Jul 24 20:20:40 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001521.html">[Avidemux-svn-commit] r4280 -	branches/avidemux_2.4_branch/avidemux/ADM_script
</A></li>
        <LI>Next message: <A HREF="001523.html">[Avidemux-svn-commit] r4282 -	branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1522">[ date ]</a>
              <a href="thread.html#1522">[ thread ]</a>
              <a href="subject.html#1522">[ subject ]</a>
              <a href="author.html#1522">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2008-07-24 20:20:17 +0200 (Thu, 24 Jul 2008)
New Revision: 4281

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rectangle.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264data.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/svq3.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.h
Log:
[h264] update H.264 decoder (libavcodec r14288)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-07-24 18:20:17 UTC (rev 4281)
@@ -10,7 +10,7 @@
 		jfdctfst.c 	jfdctint.c 	jrevdct.c 	mace.c 	mdct.c 	 	mjpeg.c 
 		motion_est.c 	mpeg12.c 	mpegaudio.c 	mpegaudiodec.c 	mpegvideo.c 	msmpeg4.c 	 
 		pcm.c 	ratecontrol.c 	raw.c 	resample.c 	rv10.c 	simple_idct.c 	svq1.c 
-		utils.c 	wmadec.c 	indeo3.c 	vp3.c 	vp3dsp.c 	h264.c 	ffv1.c 	ra144.c 	ra288.c 
+		utils.c 	wmadec.c 	indeo3.c 	vp3.c 	vp3dsp.c 	h264.c 	h264pred.c  ffv1.c 	ra144.c 	ra288.c 
 		golomb.c 	4xm.c 	cabac.c 	asv1.c vcr1.c cljr.c 	faandct.c 	 	parser.c 
 		roqvideo.c 	xan.c 	rpza.c 	msrle.c 	msvideo1.c 	cinepak.c 	vqavideo.c 
 		idcinvideo.c 	smc.c 	flicvideo.c 	interplayvideo.c 	dpcm.c 	8bps.c vmdav.c 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.c	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.c	2008-07-24 18:20:17 UTC (rev 4281)
@@ -32,12 +32,23 @@
 #include &quot;h264data.h&quot;
 #include &quot;h264_parser.h&quot;
 #include &quot;golomb.h&quot;
+#include &quot;rectangle.h&quot;
 
 #include &quot;cabac.h&quot;
+#ifdef ARCH_X86
+//#include &quot;i386/h264_i386.h&quot;
+#endif
 
 //#undef NDEBUG
 #include &lt;assert.h&gt;
 
+/**
+ * Value of Picture.reference when Picture is not a reference picture, but
+ * is held for delayed output.
+ */
+#define DELAYED_PIC_REF 4
+#define ENABLE_GRAY 0
+
 static VLC coeff_token_vlc[4];
 static VLC chroma_dc_coeff_token_vlc;
 
@@ -80,110 +91,24 @@
   }
 /* MeanX */
 
-
-/**
- * fill a rectangle.
- * @param h height of the rectangle, should be a constant
- * @param w width of the rectangle, should be a constant
- * @param size the size of val (1 or 4), should be a constant
- */
-static av_always_inline void fill_rectangle(void *vp, int w, int h, int stride, uint32_t val, int size){
-    uint8_t *p= (uint8_t*)vp;
-    assert(size==1 || size==4);
-    assert(w&lt;=4);
-
-    w      *= size;
-    stride *= size;
-
-    assert((((long)vp)&amp;(FFMIN(w, STRIDE_ALIGN)-1)) == 0);
-    assert((stride&amp;(w-1))==0);
-    if(w==2){
-        const uint16_t v= size==4 ? val : val*0x0101;
-        *(uint16_t*)(p + 0*stride)= v;
-        if(h==1) return;
-        *(uint16_t*)(p + 1*stride)= v;
-        if(h==2) return;
-        *(uint16_t*)(p + 2*stride)=
-        *(uint16_t*)(p + 3*stride)= v;
-    }else if(w==4){
-        const uint32_t v= size==4 ? val : val*0x01010101;
-        *(uint32_t*)(p + 0*stride)= v;
-        if(h==1) return;
-        *(uint32_t*)(p + 1*stride)= v;
-        if(h==2) return;
-        *(uint32_t*)(p + 2*stride)=
-        *(uint32_t*)(p + 3*stride)= v;
-    }else if(w==8){
-    //gcc can't optimize 64bit math on x86_32
-#if defined(ARCH_X86_64) || (defined(MP_WORDSIZE) &amp;&amp; MP_WORDSIZE &gt;= 64)
-        const uint64_t v= val*0x0100000001ULL;
-        *(uint64_t*)(p + 0*stride)= v;
-        if(h==1) return;
-        *(uint64_t*)(p + 1*stride)= v;
-        if(h==2) return;
-        *(uint64_t*)(p + 2*stride)=
-        *(uint64_t*)(p + 3*stride)= v;
-    }else if(w==16){
-        const uint64_t v= val*0x0100000001ULL;
-        *(uint64_t*)(p + 0+0*stride)=
-        *(uint64_t*)(p + 8+0*stride)=
-        *(uint64_t*)(p + 0+1*stride)=
-        *(uint64_t*)(p + 8+1*stride)= v;
-        if(h==2) return;
-        *(uint64_t*)(p + 0+2*stride)=
-        *(uint64_t*)(p + 8+2*stride)=
-        *(uint64_t*)(p + 0+3*stride)=
-        *(uint64_t*)(p + 8+3*stride)= v;
-#else
-        *(uint32_t*)(p + 0+0*stride)=
-        *(uint32_t*)(p + 4+0*stride)= val;
-        if(h==1) return;
-        *(uint32_t*)(p + 0+1*stride)=
-        *(uint32_t*)(p + 4+1*stride)= val;
-        if(h==2) return;
-        *(uint32_t*)(p + 0+2*stride)=
-        *(uint32_t*)(p + 4+2*stride)=
-        *(uint32_t*)(p + 0+3*stride)=
-        *(uint32_t*)(p + 4+3*stride)= val;
-    }else if(w==16){
-        *(uint32_t*)(p + 0+0*stride)=
-        *(uint32_t*)(p + 4+0*stride)=
-        *(uint32_t*)(p + 8+0*stride)=
-        *(uint32_t*)(p +12+0*stride)=
-        *(uint32_t*)(p + 0+1*stride)=
-        *(uint32_t*)(p + 4+1*stride)=
-        *(uint32_t*)(p + 8+1*stride)=
-        *(uint32_t*)(p +12+1*stride)= val;
-        if(h==2) return;
-        *(uint32_t*)(p + 0+2*stride)=
-        *(uint32_t*)(p + 4+2*stride)=
-        *(uint32_t*)(p + 8+2*stride)=
-        *(uint32_t*)(p +12+2*stride)=
-        *(uint32_t*)(p + 0+3*stride)=
-        *(uint32_t*)(p + 4+3*stride)=
-        *(uint32_t*)(p + 8+3*stride)=
-        *(uint32_t*)(p +12+3*stride)= val;
-#endif
-    }else
-        assert(0);
-    assert(h==4);
-}
-
 static void fill_caches(H264Context *h, int mb_type, int for_deblock){
     MpegEncContext * const s = &amp;h-&gt;s;
-    const int mb_xy= s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+    const int mb_xy= h-&gt;mb_xy;
     int topleft_xy, top_xy, topright_xy, left_xy[2];
     int topleft_type, top_type, topright_type, left_type[2];
     int left_block[8];
+    int topleft_partition= -1;
     int i;
 
+    top_xy     = mb_xy  - (s-&gt;mb_stride &lt;&lt; FIELD_PICTURE);
+
     //FIXME deblocking could skip the intra and nnz parts.
-    if(for_deblock &amp;&amp; (h-&gt;slice_num == 1 || h-&gt;slice_table[mb_xy] == h-&gt;slice_table[mb_xy-s-&gt;mb_stride]) &amp;&amp; !FRAME_MBAFF)
+    if(for_deblock &amp;&amp; (h-&gt;slice_num == 1 || h-&gt;slice_table[mb_xy] == h-&gt;slice_table[top_xy]) &amp;&amp; !FRAME_MBAFF)
         return;
 
-    //wow what a mess, why didn't they simplify the interlacing&amp;intra stuff, i can't imagine that these complex rules are worth it
+    /* Wow, what a mess, why didn't they simplify the interlacing &amp; intra
+     * stuff, I can't imagine that these complex rules are worth it. */
 
-    top_xy     = mb_xy  - s-&gt;mb_stride;
     topleft_xy = top_xy - 1;
     topright_xy= top_xy + 1;
     left_xy[1] = left_xy[0] = mb_xy-1;
@@ -218,6 +143,10 @@
                 : (!curr_mb_frame_flag &amp;&amp; !topleft_mb_frame_flag) // top macroblock
                 ) {
             topleft_xy -= s-&gt;mb_stride;
+        } else if(bottom &amp;&amp; curr_mb_frame_flag &amp;&amp; !left_mb_frame_flag) {
+            topleft_xy += s-&gt;mb_stride;
+            // take topleft mv from the middle of the mb, as opposed to all other modes which use the bottom-right partition
+            topleft_partition = 0;
         }
         if (bottom
                 ? !curr_mb_frame_flag // bottom macroblock
@@ -495,8 +424,8 @@
                 continue;
 
             if(USES_LIST(topleft_type, list)){
-                const int b_xy = h-&gt;mb2b_xy[topleft_xy] + 3 + 3*h-&gt;b_stride;
-                const int b8_xy= h-&gt;mb2b8_xy[topleft_xy] + 1 + h-&gt;b8_stride;
+                const int b_xy = h-&gt;mb2b_xy[topleft_xy] + 3 + h-&gt;b_stride + (topleft_partition &amp; 2*h-&gt;b_stride);
+                const int b8_xy= h-&gt;mb2b8_xy[topleft_xy] + 1 + (topleft_partition &amp; h-&gt;b8_stride);
                 *(uint32_t*)h-&gt;mv_cache[list][scan8[0] - 1 - 1*8]= *(uint32_t*)s-&gt;current_picture.motion_val[list][b_xy];
                 h-&gt;ref_cache[list][scan8[0] - 1 - 1*8]= s-&gt;current_picture.ref_index[list][b8_xy];
             }else{
@@ -564,7 +493,7 @@
                 *(uint32_t*)h-&gt;mvd_cache [list][scan8[4 ]]=
                 *(uint32_t*)h-&gt;mvd_cache [list][scan8[12]]= 0;
 
-                if(h-&gt;slice_type == B_TYPE){
+                if(h-&gt;slice_type == FF_B_TYPE){
                     fill_rectangle(&amp;h-&gt;direct_cache[scan8[0]], 4, 4, 8, 0, 1);
 
                     if(IS_DIRECT(top_type)){
@@ -633,8 +562,7 @@
 }
 
 static inline void write_back_intra_pred_mode(H264Context *h){
-    MpegEncContext * const s = &amp;h-&gt;s;
-    const int mb_xy= s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+    const int mb_xy= h-&gt;mb_xy;
 
     h-&gt;intra4x4_pred_mode[mb_xy][0]= h-&gt;intra4x4_pred_mode_cache[7+8*1];
     h-&gt;intra4x4_pred_mode[mb_xy][1]= h-&gt;intra4x4_pred_mode_cache[7+8*2];
@@ -729,8 +657,7 @@
 }
 
 static inline void write_back_non_zero_count(H264Context *h){
-    MpegEncContext * const s = &amp;h-&gt;s;
-    const int mb_xy= s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+    const int mb_xy= h-&gt;mb_xy;
 
     h-&gt;non_zero_count[mb_xy][0]= h-&gt;non_zero_count_cache[7+8*1];
     h-&gt;non_zero_count[mb_xy][1]= h-&gt;non_zero_count_cache[7+8*2];
@@ -793,7 +720,7 @@
 #define SET_DIAG_MV(MV_OP, REF_OP, X4, Y4)\
                 const int x4 = X4, y4 = Y4;\
                 const int mb_type = mb_types[(x4&gt;&gt;2)+(y4&gt;&gt;2)*s-&gt;mb_stride];\
-                if(!USES_LIST(mb_type,list) &amp;&amp; !IS_8X8(mb_type))\
+                if(!USES_LIST(mb_type,list))\
                     return LIST_NOT_USED;\
                 mv = s-&gt;current_picture_ptr-&gt;motion_val[list][x4 + y4*h-&gt;b_stride];\
                 h-&gt;mv_cache[list][scan8[0]-2][0] = mv[0];\
@@ -814,7 +741,7 @@
                &amp;&amp; !IS_INTERLACED(mb_types[h-&gt;left_mb_xy[0]])
                &amp;&amp; i &gt;= scan8[0]+8){
                 // leftshift will turn LIST_NOT_USED into PART_NOT_AVAILABLE, but that's ok.
-                SET_DIAG_MV(&gt;&gt;1, &lt;&lt;1, s-&gt;mb_x*4-1, (s-&gt;mb_y&amp;~1)*4 - 1 + ((i-scan8[0])&gt;&gt;3)*2);
+                SET_DIAG_MV(/2, &lt;&lt;1, s-&gt;mb_x*4-1, (s-&gt;mb_y&amp;~1)*4 - 1 + ((i-scan8[0])&gt;&gt;3)*2);
             }
         }
 #undef SET_DIAG_MV
@@ -1005,16 +932,16 @@
     Picture * const ref1 = &amp;h-&gt;ref_list[1][0];
     Picture * const cur = s-&gt;current_picture_ptr;
     int list, i, j;
-    if(cur-&gt;pict_type == I_TYPE)
+    if(cur-&gt;pict_type == FF_I_TYPE)
         cur-&gt;ref_count[0] = 0;
-    if(cur-&gt;pict_type != B_TYPE)
+    if(cur-&gt;pict_type != FF_B_TYPE)
         cur-&gt;ref_count[1] = 0;
     for(list=0; list&lt;2; list++){
         cur-&gt;ref_count[list] = h-&gt;ref_count[list];
         for(j=0; j&lt;h-&gt;ref_count[list]; j++)
             cur-&gt;ref_poc[list][j] = h-&gt;ref_list[list][j].poc;
     }
-    if(cur-&gt;pict_type != B_TYPE || h-&gt;direct_spatial_mv_pred)
+    if(cur-&gt;pict_type != FF_B_TYPE || h-&gt;direct_spatial_mv_pred)
         return;
     for(list=0; list&lt;2; list++){
         for(i=0; i&lt;ref1-&gt;ref_count[list]; i++){
@@ -1040,7 +967,7 @@
 
 static inline void pred_direct_motion(H264Context * const h, int *mb_type){
     MpegEncContext * const s = &amp;h-&gt;s;
-    const int mb_xy =   s-&gt;mb_x +   s-&gt;mb_y*s-&gt;mb_stride;
+    const int mb_xy =   h-&gt;mb_xy;
     const int b8_xy = 2*s-&gt;mb_x + 2*s-&gt;mb_y*h-&gt;b8_stride;
     const int b4_xy = 4*s-&gt;mb_x + 4*s-&gt;mb_y*h-&gt;b_stride;
     const int mb_type_col = h-&gt;ref_list[1][0].mb_type[mb_xy];
@@ -1109,14 +1036,76 @@
         }
 
         if(ref[1] &lt; 0){
-            *mb_type &amp;= ~MB_TYPE_P0L1;
-            sub_mb_type &amp;= ~MB_TYPE_P0L1;
+            if(!is_b8x8)
+                *mb_type &amp;= ~MB_TYPE_L1;
+            sub_mb_type &amp;= ~MB_TYPE_L1;
         }else if(ref[0] &lt; 0){
-            *mb_type &amp;= ~MB_TYPE_P0L0;
-            sub_mb_type &amp;= ~MB_TYPE_P0L0;
+            if(!is_b8x8)
+                *mb_type &amp;= ~MB_TYPE_L0;
+            sub_mb_type &amp;= ~MB_TYPE_L0;
         }
 
-        if(IS_16X16(*mb_type)){
+        if(IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col)){
+            int pair_xy = s-&gt;mb_x + (s-&gt;mb_y&amp;~1)*s-&gt;mb_stride;
+            int mb_types_col[2];
+            int b8_stride = h-&gt;b8_stride;
+            int b4_stride = h-&gt;b_stride;
+
+            *mb_type = (*mb_type &amp; ~MB_TYPE_16x16) | MB_TYPE_8x8;
+
+            if(IS_INTERLACED(*mb_type)){
+                mb_types_col[0] = h-&gt;ref_list[1][0].mb_type[pair_xy];
+                mb_types_col[1] = h-&gt;ref_list[1][0].mb_type[pair_xy+s-&gt;mb_stride];
+                if(s-&gt;mb_y&amp;1){
+                    l1ref0 -= 2*b8_stride;
+                    l1ref1 -= 2*b8_stride;
+                    l1mv0 -= 4*b4_stride;
+                    l1mv1 -= 4*b4_stride;
+                }
+                b8_stride *= 3;
+                b4_stride *= 6;
+            }else{
+                int cur_poc = s-&gt;current_picture_ptr-&gt;poc;
+                int *col_poc = h-&gt;ref_list[1]-&gt;field_poc;
+                int col_parity = FFABS(col_poc[0] - cur_poc) &gt;= FFABS(col_poc[1] - cur_poc);
+                int dy = 2*col_parity - (s-&gt;mb_y&amp;1);
+                mb_types_col[0] =
+                mb_types_col[1] = h-&gt;ref_list[1][0].mb_type[pair_xy + col_parity*s-&gt;mb_stride];
+                l1ref0 += dy*b8_stride;
+                l1ref1 += dy*b8_stride;
+                l1mv0 += 2*dy*b4_stride;
+                l1mv1 += 2*dy*b4_stride;
+                b8_stride = 0;
+            }
+
+            for(i8=0; i8&lt;4; i8++){
+                int x8 = i8&amp;1;
+                int y8 = i8&gt;&gt;1;
+                int xy8 = x8+y8*b8_stride;
+                int xy4 = 3*x8+y8*b4_stride;
+                int a=0, b=0;
+
+                if(is_b8x8 &amp;&amp; !IS_DIRECT(h-&gt;sub_mb_type[i8]))
+                    continue;
+                h-&gt;sub_mb_type[i8] = sub_mb_type;
+
+                fill_rectangle(&amp;h-&gt;ref_cache[0][scan8[i8*4]], 2, 2, 8, (uint8_t)ref[0], 1);
+                fill_rectangle(&amp;h-&gt;ref_cache[1][scan8[i8*4]], 2, 2, 8, (uint8_t)ref[1], 1);
+                if(!IS_INTRA(mb_types_col[y8])
+                   &amp;&amp; (   (l1ref0[xy8] == 0 &amp;&amp; FFABS(l1mv0[xy4][0]) &lt;= 1 &amp;&amp; FFABS(l1mv0[xy4][1]) &lt;= 1)
+                       || (l1ref0[xy8]  &lt; 0 &amp;&amp; l1ref1[xy8] == 0 &amp;&amp; FFABS(l1mv1[xy4][0]) &lt;= 1 &amp;&amp; FFABS(l1mv1[xy4][1]) &lt;= 1))){
+                    if(ref[0] &gt; 0)
+                        a= pack16to32(mv[0][0],mv[0][1]);
+                    if(ref[1] &gt; 0)
+                        b= pack16to32(mv[1][0],mv[1][1]);
+                }else{
+                    a= pack16to32(mv[0][0],mv[0][1]);
+                    b= pack16to32(mv[1][0],mv[1][1]);
+                }
+                fill_rectangle(&amp;h-&gt;mv_cache[0][scan8[i8*4]], 2, 2, 8, a, 4);
+                fill_rectangle(&amp;h-&gt;mv_cache[1][scan8[i8*4]], 2, 2, 8, b, 4);
+            }
+        }else if(IS_16X16(*mb_type)){
             int a=0, b=0;
 
             fill_rectangle(&amp;h-&gt;ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);
@@ -1383,7 +1372,7 @@
         }
     }
 
-    if(h-&gt;slice_type == B_TYPE &amp;&amp; h-&gt;pps.cabac){
+    if(h-&gt;slice_type == FF_B_TYPE &amp;&amp; h-&gt;pps.cabac){
         if(IS_8X8(mb_type)){
             uint8_t *direct_table = &amp;h-&gt;direct_table[b8_xy];
             direct_table[1+0*h-&gt;b8_stride] = IS_DIRECT(h-&gt;sub_mb_type[1]) ? 1 : 0;
@@ -1400,7 +1389,7 @@
  * @param dst_length is the number of decoded bytes FIXME here or a decode rbsp tailing?
  * @returns decoded bytes, might be src+1 if no escapes
  */
-static uint8_t *decode_nal(H264Context *h, uint8_t *src, int *dst_length, int *consumed, int length){
+static const uint8_t *decode_nal(H264Context *h, const uint8_t *src, int *dst_length, int *consumed, int length){
     int i, si, di;
     uint8_t *dst;
     int bufidx;
@@ -1467,7 +1456,7 @@
  * identifies the exact end of the bitstream
  * @return the length of the trailing, or 0 if damaged
  */
-static int decode_rbsp_trailing(H264Context *h, uint8_t *src){
+static int decode_rbsp_trailing(H264Context *h, const uint8_t *src){
     int v= *src;
     int r;
 
@@ -1614,7 +1603,7 @@
     return h-&gt;pps.chroma_qp_table[t][qscale &amp; 0xff];
 }
 
-//FIXME need to check that this does not overflow signed 32 bit for low qp, i am not sure, it's very close
+//FIXME need to check that this does not overflow signed 32 bit for low qp, I am not sure, it's very close
 //FIXME check that gcc inlines this (and optimizes intra &amp; separate_dc stuff away)
 static inline int quantize_c(DCTELEM *block, uint8_t *scantable, int qscale, int intra, int separate_dc){
     int i;
@@ -1693,719 +1682,6 @@
     return last_non_zero;
 }
 
-static void pred4x4_vertical_c(uint8_t *src, uint8_t *topright, int stride){
-    const uint32_t a= ((uint32_t*)(src-stride))[0];
-    ((uint32_t*)(src+0*stride))[0]= a;
-    ((uint32_t*)(src+1*stride))[0]= a;
-    ((uint32_t*)(src+2*stride))[0]= a;
-    ((uint32_t*)(src+3*stride))[0]= a;
-}
-
-static void pred4x4_horizontal_c(uint8_t *src, uint8_t *topright, int stride){
-    ((uint32_t*)(src+0*stride))[0]= src[-1+0*stride]*0x01010101;
-    ((uint32_t*)(src+1*stride))[0]= src[-1+1*stride]*0x01010101;
-    ((uint32_t*)(src+2*stride))[0]= src[-1+2*stride]*0x01010101;
-    ((uint32_t*)(src+3*stride))[0]= src[-1+3*stride]*0x01010101;
-}
-
-static void pred4x4_dc_c(uint8_t *src, uint8_t *topright, int stride){
-    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride]
-                   + src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 4) &gt;&gt;3;
-
-    ((uint32_t*)(src+0*stride))[0]=
-    ((uint32_t*)(src+1*stride))[0]=
-    ((uint32_t*)(src+2*stride))[0]=
-    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
-}
-
-static void pred4x4_left_dc_c(uint8_t *src, uint8_t *topright, int stride){
-    const int dc= (  src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 2) &gt;&gt;2;
-
-    ((uint32_t*)(src+0*stride))[0]=
-    ((uint32_t*)(src+1*stride))[0]=
-    ((uint32_t*)(src+2*stride))[0]=
-    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
-}
-
-static void pred4x4_top_dc_c(uint8_t *src, uint8_t *topright, int stride){
-    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride] + 2) &gt;&gt;2;
-
-    ((uint32_t*)(src+0*stride))[0]=
-    ((uint32_t*)(src+1*stride))[0]=
-    ((uint32_t*)(src+2*stride))[0]=
-    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
-}
-
-static void pred4x4_128_dc_c(uint8_t *src, uint8_t *topright, int stride){
-    ((uint32_t*)(src+0*stride))[0]=
-    ((uint32_t*)(src+1*stride))[0]=
-    ((uint32_t*)(src+2*stride))[0]=
-    ((uint32_t*)(src+3*stride))[0]= 128U*0x01010101U;
-}
-
-
-#define LOAD_TOP_RIGHT_EDGE\
-    const int av_unused t4= topright[0];\
-    const int av_unused t5= topright[1];\
-    const int av_unused t6= topright[2];\
-    const int av_unused t7= topright[3];\
-
-#define LOAD_LEFT_EDGE\
-    const int av_unused l0= src[-1+0*stride];\
-    const int av_unused l1= src[-1+1*stride];\
-    const int av_unused l2= src[-1+2*stride];\
-    const int av_unused l3= src[-1+3*stride];\
-
-#define LOAD_TOP_EDGE\
-    const int av_unused t0= src[ 0-1*stride];\
-    const int av_unused t1= src[ 1-1*stride];\
-    const int av_unused t2= src[ 2-1*stride];\
-    const int av_unused t3= src[ 3-1*stride];\
-
-static void pred4x4_down_right_c(uint8_t *src, uint8_t *topright, int stride){
-    const int lt= src[-1-1*stride];
-    LOAD_TOP_EDGE
-    LOAD_LEFT_EDGE
-
-    src[0+3*stride]=(l3 + 2*l2 + l1 + 2)&gt;&gt;2;
-    src[0+2*stride]=
-    src[1+3*stride]=(l2 + 2*l1 + l0 + 2)&gt;&gt;2;
-    src[0+1*stride]=
-    src[1+2*stride]=
-    src[2+3*stride]=(l1 + 2*l0 + lt + 2)&gt;&gt;2;
-    src[0+0*stride]=
-    src[1+1*stride]=
-    src[2+2*stride]=
-    src[3+3*stride]=(l0 + 2*lt + t0 + 2)&gt;&gt;2;
-    src[1+0*stride]=
-    src[2+1*stride]=
-    src[3+2*stride]=(lt + 2*t0 + t1 + 2)&gt;&gt;2;
-    src[2+0*stride]=
-    src[3+1*stride]=(t0 + 2*t1 + t2 + 2)&gt;&gt;2;
-    src[3+0*stride]=(t1 + 2*t2 + t3 + 2)&gt;&gt;2;
-}
-
-static void pred4x4_down_left_c(uint8_t *src, uint8_t *topright, int stride){
-    LOAD_TOP_EDGE
-    LOAD_TOP_RIGHT_EDGE
-//    LOAD_LEFT_EDGE
-
-    src[0+0*stride]=(t0 + t2 + 2*t1 + 2)&gt;&gt;2;
-    src[1+0*stride]=
-    src[0+1*stride]=(t1 + t3 + 2*t2 + 2)&gt;&gt;2;
-    src[2+0*stride]=
-    src[1+1*stride]=
-    src[0+2*stride]=(t2 + t4 + 2*t3 + 2)&gt;&gt;2;
-    src[3+0*stride]=
-    src[2+1*stride]=
-    src[1+2*stride]=
-    src[0+3*stride]=(t3 + t5 + 2*t4 + 2)&gt;&gt;2;
-    src[3+1*stride]=
-    src[2+2*stride]=
-    src[1+3*stride]=(t4 + t6 + 2*t5 + 2)&gt;&gt;2;
-    src[3+2*stride]=
-    src[2+3*stride]=(t5 + t7 + 2*t6 + 2)&gt;&gt;2;
-    src[3+3*stride]=(t6 + 3*t7 + 2)&gt;&gt;2;
-}
-
-static void pred4x4_vertical_right_c(uint8_t *src, uint8_t *topright, int stride){
-    const int lt= src[-1-1*stride];
-    LOAD_TOP_EDGE
-    LOAD_LEFT_EDGE
-
-    src[0+0*stride]=
-    src[1+2*stride]=(lt + t0 + 1)&gt;&gt;1;
-    src[1+0*stride]=
-    src[2+2*stride]=(t0 + t1 + 1)&gt;&gt;1;
-    src[2+0*stride]=
-    src[3+2*stride]=(t1 + t2 + 1)&gt;&gt;1;
-    src[3+0*stride]=(t2 + t3 + 1)&gt;&gt;1;
-    src[0+1*stride]=
-    src[1+3*stride]=(l0 + 2*lt + t0 + 2)&gt;&gt;2;
-    src[1+1*stride]=
-    src[2+3*stride]=(lt + 2*t0 + t1 + 2)&gt;&gt;2;
-    src[2+1*stride]=
-    src[3+3*stride]=(t0 + 2*t1 + t2 + 2)&gt;&gt;2;
-    src[3+1*stride]=(t1 + 2*t2 + t3 + 2)&gt;&gt;2;
-    src[0+2*stride]=(lt + 2*l0 + l1 + 2)&gt;&gt;2;
-    src[0+3*stride]=(l0 + 2*l1 + l2 + 2)&gt;&gt;2;
-}
-
-static void pred4x4_vertical_left_c(uint8_t *src, uint8_t *topright, int stride){
-    LOAD_TOP_EDGE
-    LOAD_TOP_RIGHT_EDGE
-
-    src[0+0*stride]=(t0 + t1 + 1)&gt;&gt;1;
-    src[1+0*stride]=
-    src[0+2*stride]=(t1 + t2 + 1)&gt;&gt;1;
-    src[2+0*stride]=
-    src[1+2*stride]=(t2 + t3 + 1)&gt;&gt;1;
-    src[3+0*stride]=
-    src[2+2*stride]=(t3 + t4+ 1)&gt;&gt;1;
-    src[3+2*stride]=(t4 + t5+ 1)&gt;&gt;1;
-    src[0+1*stride]=(t0 + 2*t1 + t2 + 2)&gt;&gt;2;
-    src[1+1*stride]=
-    src[0+3*stride]=(t1 + 2*t2 + t3 + 2)&gt;&gt;2;
-    src[2+1*stride]=
-    src[1+3*stride]=(t2 + 2*t3 + t4 + 2)&gt;&gt;2;
-    src[3+1*stride]=
-    src[2+3*stride]=(t3 + 2*t4 + t5 + 2)&gt;&gt;2;
-    src[3+3*stride]=(t4 + 2*t5 + t6 + 2)&gt;&gt;2;
-}
-
-static void pred4x4_horizontal_up_c(uint8_t *src, uint8_t *topright, int stride){
-    LOAD_LEFT_EDGE
-
-    src[0+0*stride]=(l0 + l1 + 1)&gt;&gt;1;
-    src[1+0*stride]=(l0 + 2*l1 + l2 + 2)&gt;&gt;2;
-    src[2+0*stride]=
-    src[0+1*stride]=(l1 + l2 + 1)&gt;&gt;1;
-    src[3+0*stride]=
-    src[1+1*stride]=(l1 + 2*l2 + l3 + 2)&gt;&gt;2;
-    src[2+1*stride]=
-    src[0+2*stride]=(l2 + l3 + 1)&gt;&gt;1;
-    src[3+1*stride]=
-    src[1+2*stride]=(l2 + 2*l3 + l3 + 2)&gt;&gt;2;
-    src[3+2*stride]=
-    src[1+3*stride]=
-    src[0+3*stride]=
-    src[2+2*stride]=
-    src[2+3*stride]=
-    src[3+3*stride]=l3;
-}
-
-static void pred4x4_horizontal_down_c(uint8_t *src, uint8_t *topright, int stride){
-    const int lt= src[-1-1*stride];
-    LOAD_TOP_EDGE
-    LOAD_LEFT_EDGE
-
-    src[0+0*stride]=
-    src[2+1*stride]=(lt + l0 + 1)&gt;&gt;1;
-    src[1+0*stride]=
-    src[3+1*stride]=(l0 + 2*lt + t0 + 2)&gt;&gt;2;
-    src[2+0*stride]=(lt + 2*t0 + t1 + 2)&gt;&gt;2;
-    src[3+0*stride]=(t0 + 2*t1 + t2 + 2)&gt;&gt;2;
-    src[0+1*stride]=
-    src[2+2*stride]=(l0 + l1 + 1)&gt;&gt;1;
-    src[1+1*stride]=
-    src[3+2*stride]=(lt + 2*l0 + l1 + 2)&gt;&gt;2;
-    src[0+2*stride]=
-    src[2+3*stride]=(l1 + l2+ 1)&gt;&gt;1;
-    src[1+2*stride]=
-    src[3+3*stride]=(l0 + 2*l1 + l2 + 2)&gt;&gt;2;
-    src[0+3*stride]=(l2 + l3 + 1)&gt;&gt;1;
-    src[1+3*stride]=(l1 + 2*l2 + l3 + 2)&gt;&gt;2;
-}
-
-void ff_pred16x16_vertical_c(uint8_t *src, int stride){
-    int i;
-    const uint32_t a= ((uint32_t*)(src-stride))[0];
-    const uint32_t b= ((uint32_t*)(src-stride))[1];
-    const uint32_t c= ((uint32_t*)(src-stride))[2];
-    const uint32_t d= ((uint32_t*)(src-stride))[3];
-
-    for(i=0; i&lt;16; i++){
-        ((uint32_t*)(src+i*stride))[0]= a;
-        ((uint32_t*)(src+i*stride))[1]= b;
-        ((uint32_t*)(src+i*stride))[2]= c;
-        ((uint32_t*)(src+i*stride))[3]= d;
-    }
-}
-
-void ff_pred16x16_horizontal_c(uint8_t *src, int stride){
-    int i;
-
-    for(i=0; i&lt;16; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]=
-        ((uint32_t*)(src+i*stride))[2]=
-        ((uint32_t*)(src+i*stride))[3]= src[-1+i*stride]*0x01010101;
-    }
-}
-
-void ff_pred16x16_dc_c(uint8_t *src, int stride){
-    int i, dc=0;
-
-    for(i=0;i&lt;16; i++){
-        dc+= src[-1+i*stride];
-    }
-
-    for(i=0;i&lt;16; i++){
-        dc+= src[i-stride];
-    }
-
-    dc= 0x01010101*((dc + 16)&gt;&gt;5);
-
-    for(i=0; i&lt;16; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]=
-        ((uint32_t*)(src+i*stride))[2]=
-        ((uint32_t*)(src+i*stride))[3]= dc;
-    }
-}
-
-void ff_pred16x16_left_dc_c(uint8_t *src, int stride){
-    int i, dc=0;
-
-    for(i=0;i&lt;16; i++){
-        dc+= src[-1+i*stride];
-    }
-
-    dc= 0x01010101*((dc + 8)&gt;&gt;4);
-
-    for(i=0; i&lt;16; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]=
-        ((uint32_t*)(src+i*stride))[2]=
-        ((uint32_t*)(src+i*stride))[3]= dc;
-    }
-}
-
-void ff_pred16x16_top_dc_c(uint8_t *src, int stride){
-    int i, dc=0;
-
-    for(i=0;i&lt;16; i++){
-        dc+= src[i-stride];
-    }
-    dc= 0x01010101*((dc + 8)&gt;&gt;4);
-
-    for(i=0; i&lt;16; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]=
-        ((uint32_t*)(src+i*stride))[2]=
-        ((uint32_t*)(src+i*stride))[3]= dc;
-    }
-}
-
-void ff_pred16x16_128_dc_c(uint8_t *src, int stride){
-    int i;
-
-    for(i=0; i&lt;16; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]=
-        ((uint32_t*)(src+i*stride))[2]=
-        ((uint32_t*)(src+i*stride))[3]= 0x01010101U*128U;
-    }
-}
-
-static inline void pred16x16_plane_compat_c(uint8_t *src, int stride, const int svq3){
-  int i, j, k;
-  int a;
-  uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
-  const uint8_t * const src0 = src+7-stride;
-  const uint8_t *src1 = src+8*stride-1;
-  const uint8_t *src2 = src1-2*stride;      // == src+6*stride-1;
-  int H = src0[1] - src0[-1];
-  int V = src1[0] - src2[ 0];
-  for(k=2; k&lt;=8; ++k) {
-    src1 += stride; src2 -= stride;
-    H += k*(src0[k] - src0[-k]);
-    V += k*(src1[0] - src2[ 0]);
-  }
-  if(svq3){
-    H = ( 5*(H/4) ) / 16;
-    V = ( 5*(V/4) ) / 16;
-
-    /* required for 100% accuracy */
-    i = H; H = V; V = i;
-  }else{
-    H = ( 5*H+32 ) &gt;&gt; 6;
-    V = ( 5*V+32 ) &gt;&gt; 6;
-  }
-
-  a = 16*(src1[0] + src2[16] + 1) - 7*(V+H);
-  for(j=16; j&gt;0; --j) {
-    int b = a;
-    a += V;
-    for(i=-16; i&lt;0; i+=4) {
-      src[16+i] = cm[ (b    ) &gt;&gt; 5 ];
-      src[17+i] = cm[ (b+  H) &gt;&gt; 5 ];
-      src[18+i] = cm[ (b+2*H) &gt;&gt; 5 ];
-      src[19+i] = cm[ (b+3*H) &gt;&gt; 5 ];
-      b += 4*H;
-    }
-    src += stride;
-  }
-}
-
-void ff_pred16x16_plane_c(uint8_t *src, int stride){
-    pred16x16_plane_compat_c(src, stride, 0);
-}
-
-void ff_pred8x8_vertical_c(uint8_t *src, int stride){
-    int i;
-    const uint32_t a= ((uint32_t*)(src-stride))[0];
-    const uint32_t b= ((uint32_t*)(src-stride))[1];
-
-    for(i=0; i&lt;8; i++){
-        ((uint32_t*)(src+i*stride))[0]= a;
-        ((uint32_t*)(src+i*stride))[1]= b;
-    }
-}
-
-void ff_pred8x8_horizontal_c(uint8_t *src, int stride){
-    int i;
-
-    for(i=0; i&lt;8; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]= src[-1+i*stride]*0x01010101;
-    }
-}
-
-void ff_pred8x8_128_dc_c(uint8_t *src, int stride){
-    int i;
-
-    for(i=0; i&lt;8; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]= 0x01010101U*128U;
-    }
-}
-
-void ff_pred8x8_left_dc_c(uint8_t *src, int stride){
-    int i;
-    int dc0, dc2;
-
-    dc0=dc2=0;
-    for(i=0;i&lt;4; i++){
-        dc0+= src[-1+i*stride];
-        dc2+= src[-1+(i+4)*stride];
-    }
-    dc0= 0x01010101*((dc0 + 2)&gt;&gt;2);
-    dc2= 0x01010101*((dc2 + 2)&gt;&gt;2);
-
-    for(i=0; i&lt;4; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]= dc0;
-    }
-    for(i=4; i&lt;8; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]= dc2;
-    }
-}
-
-void ff_pred8x8_top_dc_c(uint8_t *src, int stride){
-    int i;
-    int dc0, dc1;
-
-    dc0=dc1=0;
-    for(i=0;i&lt;4; i++){
-        dc0+= src[i-stride];
-        dc1+= src[4+i-stride];
-    }
-    dc0= 0x01010101*((dc0 + 2)&gt;&gt;2);
-    dc1= 0x01010101*((dc1 + 2)&gt;&gt;2);
-
-    for(i=0; i&lt;4; i++){
-        ((uint32_t*)(src+i*stride))[0]= dc0;
-        ((uint32_t*)(src+i*stride))[1]= dc1;
-    }
-    for(i=4; i&lt;8; i++){
-        ((uint32_t*)(src+i*stride))[0]= dc0;
-        ((uint32_t*)(src+i*stride))[1]= dc1;
-    }
-}
-
-
-void ff_pred8x8_dc_c(uint8_t *src, int stride){
-    int i;
-    int dc0, dc1, dc2, dc3;
-
-    dc0=dc1=dc2=0;
-    for(i=0;i&lt;4; i++){
-        dc0+= src[-1+i*stride] + src[i-stride];
-        dc1+= src[4+i-stride];
-        dc2+= src[-1+(i+4)*stride];
-    }
-    dc3= 0x01010101*((dc1 + dc2 + 4)&gt;&gt;3);
-    dc0= 0x01010101*((dc0 + 4)&gt;&gt;3);
-    dc1= 0x01010101*((dc1 + 2)&gt;&gt;2);
-    dc2= 0x01010101*((dc2 + 2)&gt;&gt;2);
-
-    for(i=0; i&lt;4; i++){
-        ((uint32_t*)(src+i*stride))[0]= dc0;
-        ((uint32_t*)(src+i*stride))[1]= dc1;
-    }
-    for(i=4; i&lt;8; i++){
-        ((uint32_t*)(src+i*stride))[0]= dc2;
-        ((uint32_t*)(src+i*stride))[1]= dc3;
-    }
-}
-
-void ff_pred8x8_plane_c(uint8_t *src, int stride){
-  int j, k;
-  int a;
-  uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
-  const uint8_t * const src0 = src+3-stride;
-  const uint8_t *src1 = src+4*stride-1;
-  const uint8_t *src2 = src1-2*stride;      // == src+2*stride-1;
-  int H = src0[1] - src0[-1];
-  int V = src1[0] - src2[ 0];
-  for(k=2; k&lt;=4; ++k) {
-    src1 += stride; src2 -= stride;
-    H += k*(src0[k] - src0[-k]);
-    V += k*(src1[0] - src2[ 0]);
-  }
-  H = ( 17*H+16 ) &gt;&gt; 5;
-  V = ( 17*V+16 ) &gt;&gt; 5;
-
-  a = 16*(src1[0] + src2[8]+1) - 3*(V+H);
-  for(j=8; j&gt;0; --j) {
-    int b = a;
-    a += V;
-    src[0] = cm[ (b    ) &gt;&gt; 5 ];
-    src[1] = cm[ (b+  H) &gt;&gt; 5 ];
-    src[2] = cm[ (b+2*H) &gt;&gt; 5 ];
-    src[3] = cm[ (b+3*H) &gt;&gt; 5 ];
-    src[4] = cm[ (b+4*H) &gt;&gt; 5 ];
-    src[5] = cm[ (b+5*H) &gt;&gt; 5 ];
-    src[6] = cm[ (b+6*H) &gt;&gt; 5 ];
-    src[7] = cm[ (b+7*H) &gt;&gt; 5 ];
-    src += stride;
-  }
-}
-
-#define SRC(x,y) src[(x)+(y)*stride]
-#define PL(y) \
-    const int l##y = (SRC(-1,y-1) + 2*SRC(-1,y) + SRC(-1,y+1) + 2) &gt;&gt; 2;
-#define PREDICT_8x8_LOAD_LEFT \
-    const int l0 = ((has_topleft ? SRC(-1,-1) : SRC(-1,0)) \
-                     + 2*SRC(-1,0) + SRC(-1,1) + 2) &gt;&gt; 2; \
-    PL(1) PL(2) PL(3) PL(4) PL(5) PL(6) \
-    const int l7 av_unused = (SRC(-1,6) + 3*SRC(-1,7) + 2) &gt;&gt; 2
-
-#define PT(x) \
-    const int t##x = (SRC(x-1,-1) + 2*SRC(x,-1) + SRC(x+1,-1) + 2) &gt;&gt; 2;
-#define PREDICT_8x8_LOAD_TOP \
-    const int t0 = ((has_topleft ? SRC(-1,-1) : SRC(0,-1)) \
-                     + 2*SRC(0,-1) + SRC(1,-1) + 2) &gt;&gt; 2; \
-    PT(1) PT(2) PT(3) PT(4) PT(5) PT(6) \
-    const int t7 av_unused = ((has_topright ? SRC(8,-1) : SRC(7,-1)) \
-                     + 2*SRC(7,-1) + SRC(6,-1) + 2) &gt;&gt; 2
-
-#define PTR(x) \
-    t##x = (SRC(x-1,-1) + 2*SRC(x,-1) + SRC(x+1,-1) + 2) &gt;&gt; 2;
-#define PREDICT_8x8_LOAD_TOPRIGHT \
-    int t8, t9, t10, t11, t12, t13, t14, t15; \
-    if(has_topright) { \
-        PTR(8) PTR(9) PTR(10) PTR(11) PTR(12) PTR(13) PTR(14) \
-        t15 = (SRC(14,-1) + 3*SRC(15,-1) + 2) &gt;&gt; 2; \
-    } else t8=t9=t10=t11=t12=t13=t14=t15= SRC(7,-1);
-
-#define PREDICT_8x8_LOAD_TOPLEFT \
-    const int lt = (SRC(-1,0) + 2*SRC(-1,-1) + SRC(0,-1) + 2) &gt;&gt; 2
-
-#define PREDICT_8x8_DC(v) \
-    int y; \
-    for( y = 0; y &lt; 8; y++ ) { \
-        ((uint32_t*)src)[0] = \
-        ((uint32_t*)src)[1] = v; \
-        src += stride; \
-    }
-
-static void pred8x8l_128_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_DC(0x80808080);
-}
-static void pred8x8l_left_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_LEFT;
-    const uint32_t dc = ((l0+l1+l2+l3+l4+l5+l6+l7+4) &gt;&gt; 3) * 0x01010101;
-    PREDICT_8x8_DC(dc);
-}
-static void pred8x8l_top_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    const uint32_t dc = ((t0+t1+t2+t3+t4+t5+t6+t7+4) &gt;&gt; 3) * 0x01010101;
-    PREDICT_8x8_DC(dc);
-}
-static void pred8x8l_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_LEFT;
-    PREDICT_8x8_LOAD_TOP;
-    const uint32_t dc = ((l0+l1+l2+l3+l4+l5+l6+l7
-                         +t0+t1+t2+t3+t4+t5+t6+t7+8) &gt;&gt; 4) * 0x01010101;
-    PREDICT_8x8_DC(dc);
-}
-static void pred8x8l_horizontal_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_LEFT;
-#define ROW(y) ((uint32_t*)(src+y*stride))[0] =\
-               ((uint32_t*)(src+y*stride))[1] = 0x01010101 * l##y
-    ROW(0); ROW(1); ROW(2); ROW(3); ROW(4); ROW(5); ROW(6); ROW(7);
-#undef ROW
-}
-static void pred8x8l_vertical_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    int y;
-    PREDICT_8x8_LOAD_TOP;
-    src[0] = t0;
-    src[1] = t1;
-    src[2] = t2;
-    src[3] = t3;
-    src[4] = t4;
-    src[5] = t5;
-    src[6] = t6;
-    src[7] = t7;
-    for( y = 1; y &lt; 8; y++ )
-        *(uint64_t*)(src+y*stride) = *(uint64_t*)src;
-}
-static void pred8x8l_down_left_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    PREDICT_8x8_LOAD_TOPRIGHT;
-    SRC(0,0)= (t0 + 2*t1 + t2 + 2) &gt;&gt; 2;
-    SRC(0,1)=SRC(1,0)= (t1 + 2*t2 + t3 + 2) &gt;&gt; 2;
-    SRC(0,2)=SRC(1,1)=SRC(2,0)= (t2 + 2*t3 + t4 + 2) &gt;&gt; 2;
-    SRC(0,3)=SRC(1,2)=SRC(2,1)=SRC(3,0)= (t3 + 2*t4 + t5 + 2) &gt;&gt; 2;
-    SRC(0,4)=SRC(1,3)=SRC(2,2)=SRC(3,1)=SRC(4,0)= (t4 + 2*t5 + t6 + 2) &gt;&gt; 2;
-    SRC(0,5)=SRC(1,4)=SRC(2,3)=SRC(3,2)=SRC(4,1)=SRC(5,0)= (t5 + 2*t6 + t7 + 2) &gt;&gt; 2;
-    SRC(0,6)=SRC(1,5)=SRC(2,4)=SRC(3,3)=SRC(4,2)=SRC(5,1)=SRC(6,0)= (t6 + 2*t7 + t8 + 2) &gt;&gt; 2;
-    SRC(0,7)=SRC(1,6)=SRC(2,5)=SRC(3,4)=SRC(4,3)=SRC(5,2)=SRC(6,1)=SRC(7,0)= (t7 + 2*t8 + t9 + 2) &gt;&gt; 2;
-    SRC(1,7)=SRC(2,6)=SRC(3,5)=SRC(4,4)=SRC(5,3)=SRC(6,2)=SRC(7,1)= (t8 + 2*t9 + t10 + 2) &gt;&gt; 2;
-    SRC(2,7)=SRC(3,6)=SRC(4,5)=SRC(5,4)=SRC(6,3)=SRC(7,2)= (t9 + 2*t10 + t11 + 2) &gt;&gt; 2;
-    SRC(3,7)=SRC(4,6)=SRC(5,5)=SRC(6,4)=SRC(7,3)= (t10 + 2*t11 + t12 + 2) &gt;&gt; 2;
-    SRC(4,7)=SRC(5,6)=SRC(6,5)=SRC(7,4)= (t11 + 2*t12 + t13 + 2) &gt;&gt; 2;
-    SRC(5,7)=SRC(6,6)=SRC(7,5)= (t12 + 2*t13 + t14 + 2) &gt;&gt; 2;
-    SRC(6,7)=SRC(7,6)= (t13 + 2*t14 + t15 + 2) &gt;&gt; 2;
-    SRC(7,7)= (t14 + 3*t15 + 2) &gt;&gt; 2;
-}
-static void pred8x8l_down_right_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    PREDICT_8x8_LOAD_LEFT;
-    PREDICT_8x8_LOAD_TOPLEFT;
-    SRC(0,7)= (l7 + 2*l6 + l5 + 2) &gt;&gt; 2;
-    SRC(0,6)=SRC(1,7)= (l6 + 2*l5 + l4 + 2) &gt;&gt; 2;
-    SRC(0,5)=SRC(1,6)=SRC(2,7)= (l5 + 2*l4 + l3 + 2) &gt;&gt; 2;
-    SRC(0,4)=SRC(1,5)=SRC(2,6)=SRC(3,7)= (l4 + 2*l3 + l2 + 2) &gt;&gt; 2;
-    SRC(0,3)=SRC(1,4)=SRC(2,5)=SRC(3,6)=SRC(4,7)= (l3 + 2*l2 + l1 + 2) &gt;&gt; 2;
-    SRC(0,2)=SRC(1,3)=SRC(2,4)=SRC(3,5)=SRC(4,6)=SRC(5,7)= (l2 + 2*l1 + l0 + 2) &gt;&gt; 2;
-    SRC(0,1)=SRC(1,2)=SRC(2,3)=SRC(3,4)=SRC(4,5)=SRC(5,6)=SRC(6,7)= (l1 + 2*l0 + lt + 2) &gt;&gt; 2;
-    SRC(0,0)=SRC(1,1)=SRC(2,2)=SRC(3,3)=SRC(4,4)=SRC(5,5)=SRC(6,6)=SRC(7,7)= (l0 + 2*lt + t0 + 2) &gt;&gt; 2;
-    SRC(1,0)=SRC(2,1)=SRC(3,2)=SRC(4,3)=SRC(5,4)=SRC(6,5)=SRC(7,6)= (lt + 2*t0 + t1 + 2) &gt;&gt; 2;
-    SRC(2,0)=SRC(3,1)=SRC(4,2)=SRC(5,3)=SRC(6,4)=SRC(7,5)= (t0 + 2*t1 + t2 + 2) &gt;&gt; 2;
-    SRC(3,0)=SRC(4,1)=SRC(5,2)=SRC(6,3)=SRC(7,4)= (t1 + 2*t2 + t3 + 2) &gt;&gt; 2;
-    SRC(4,0)=SRC(5,1)=SRC(6,2)=SRC(7,3)= (t2 + 2*t3 + t4 + 2) &gt;&gt; 2;
-    SRC(5,0)=SRC(6,1)=SRC(7,2)= (t3 + 2*t4 + t5 + 2) &gt;&gt; 2;
-    SRC(6,0)=SRC(7,1)= (t4 + 2*t5 + t6 + 2) &gt;&gt; 2;
-    SRC(7,0)= (t5 + 2*t6 + t7 + 2) &gt;&gt; 2;
-
-}
-static void pred8x8l_vertical_right_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    PREDICT_8x8_LOAD_LEFT;
-    PREDICT_8x8_LOAD_TOPLEFT;
-    SRC(0,6)= (l5 + 2*l4 + l3 + 2) &gt;&gt; 2;
-    SRC(0,7)= (l6 + 2*l5 + l4 + 2) &gt;&gt; 2;
-    SRC(0,4)=SRC(1,6)= (l3 + 2*l2 + l1 + 2) &gt;&gt; 2;
-    SRC(0,5)=SRC(1,7)= (l4 + 2*l3 + l2 + 2) &gt;&gt; 2;
-    SRC(0,2)=SRC(1,4)=SRC(2,6)= (l1 + 2*l0 + lt + 2) &gt;&gt; 2;
-    SRC(0,3)=SRC(1,5)=SRC(2,7)= (l2 + 2*l1 + l0 + 2) &gt;&gt; 2;
-    SRC(0,1)=SRC(1,3)=SRC(2,5)=SRC(3,7)= (l0 + 2*lt + t0 + 2) &gt;&gt; 2;
-    SRC(0,0)=SRC(1,2)=SRC(2,4)=SRC(3,6)= (lt + t0 + 1) &gt;&gt; 1;
-    SRC(1,1)=SRC(2,3)=SRC(3,5)=SRC(4,7)= (lt + 2*t0 + t1 + 2) &gt;&gt; 2;
-    SRC(1,0)=SRC(2,2)=SRC(3,4)=SRC(4,6)= (t0 + t1 + 1) &gt;&gt; 1;
-    SRC(2,1)=SRC(3,3)=SRC(4,5)=SRC(5,7)= (t0 + 2*t1 + t2 + 2) &gt;&gt; 2;
-    SRC(2,0)=SRC(3,2)=SRC(4,4)=SRC(5,6)= (t1 + t2 + 1) &gt;&gt; 1;
-    SRC(3,1)=SRC(4,3)=SRC(5,5)=SRC(6,7)= (t1 + 2*t2 + t3 + 2) &gt;&gt; 2;
-    SRC(3,0)=SRC(4,2)=SRC(5,4)=SRC(6,6)= (t2 + t3 + 1) &gt;&gt; 1;
-    SRC(4,1)=SRC(5,3)=SRC(6,5)=SRC(7,7)= (t2 + 2*t3 + t4 + 2) &gt;&gt; 2;
-    SRC(4,0)=SRC(5,2)=SRC(6,4)=SRC(7,6)= (t3 + t4 + 1) &gt;&gt; 1;
-    SRC(5,1)=SRC(6,3)=SRC(7,5)= (t3 + 2*t4 + t5 + 2) &gt;&gt; 2;
-    SRC(5,0)=SRC(6,2)=SRC(7,4)= (t4 + t5 + 1) &gt;&gt; 1;
-    SRC(6,1)=SRC(7,3)= (t4 + 2*t5 + t6 + 2) &gt;&gt; 2;
-    SRC(6,0)=SRC(7,2)= (t5 + t6 + 1) &gt;&gt; 1;
-    SRC(7,1)= (t5 + 2*t6 + t7 + 2) &gt;&gt; 2;
-    SRC(7,0)= (t6 + t7 + 1) &gt;&gt; 1;
-}
-static void pred8x8l_horizontal_down_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    PREDICT_8x8_LOAD_LEFT;
-    PREDICT_8x8_LOAD_TOPLEFT;
-    SRC(0,7)= (l6 + l7 + 1) &gt;&gt; 1;
-    SRC(1,7)= (l5 + 2*l6 + l7 + 2) &gt;&gt; 2;
-    SRC(0,6)=SRC(2,7)= (l5 + l6 + 1) &gt;&gt; 1;
-    SRC(1,6)=SRC(3,7)= (l4 + 2*l5 + l6 + 2) &gt;&gt; 2;
-    SRC(0,5)=SRC(2,6)=SRC(4,7)= (l4 + l5 + 1) &gt;&gt; 1;
-    SRC(1,5)=SRC(3,6)=SRC(5,7)= (l3 + 2*l4 + l5 + 2) &gt;&gt; 2;
-    SRC(0,4)=SRC(2,5)=SRC(4,6)=SRC(6,7)= (l3 + l4 + 1) &gt;&gt; 1;
-    SRC(1,4)=SRC(3,5)=SRC(5,6)=SRC(7,7)= (l2 + 2*l3 + l4 + 2) &gt;&gt; 2;
-    SRC(0,3)=SRC(2,4)=SRC(4,5)=SRC(6,6)= (l2 + l3 + 1) &gt;&gt; 1;
-    SRC(1,3)=SRC(3,4)=SRC(5,5)=SRC(7,6)= (l1 + 2*l2 + l3 + 2) &gt;&gt; 2;
-    SRC(0,2)=SRC(2,3)=SRC(4,4)=SRC(6,5)= (l1 + l2 + 1) &gt;&gt; 1;
-    SRC(1,2)=SRC(3,3)=SRC(5,4)=SRC(7,5)= (l0 + 2*l1 + l2 + 2) &gt;&gt; 2;
-    SRC(0,1)=SRC(2,2)=SRC(4,3)=SRC(6,4)= (l0 + l1 + 1) &gt;&gt; 1;
-    SRC(1,1)=SRC(3,2)=SRC(5,3)=SRC(7,4)= (lt + 2*l0 + l1 + 2) &gt;&gt; 2;
-    SRC(0,0)=SRC(2,1)=SRC(4,2)=SRC(6,3)= (lt + l0 + 1) &gt;&gt; 1;
-    SRC(1,0)=SRC(3,1)=SRC(5,2)=SRC(7,3)= (l0 + 2*lt + t0 + 2) &gt;&gt; 2;
-    SRC(2,0)=SRC(4,1)=SRC(6,2)= (t1 + 2*t0 + lt + 2) &gt;&gt; 2;
-    SRC(3,0)=SRC(5,1)=SRC(7,2)= (t2 + 2*t1 + t0 + 2) &gt;&gt; 2;
-    SRC(4,0)=SRC(6,1)= (t3 + 2*t2 + t1 + 2) &gt;&gt; 2;
-    SRC(5,0)=SRC(7,1)= (t4 + 2*t3 + t2 + 2) &gt;&gt; 2;
-    SRC(6,0)= (t5 + 2*t4 + t3 + 2) &gt;&gt; 2;
-    SRC(7,0)= (t6 + 2*t5 + t4 + 2) &gt;&gt; 2;
-}
-static void pred8x8l_vertical_left_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    PREDICT_8x8_LOAD_TOPRIGHT;
-    SRC(0,0)= (t0 + t1 + 1) &gt;&gt; 1;
-    SRC(0,1)= (t0 + 2*t1 + t2 + 2) &gt;&gt; 2;
-    SRC(0,2)=SRC(1,0)= (t1 + t2 + 1) &gt;&gt; 1;
-    SRC(0,3)=SRC(1,1)= (t1 + 2*t2 + t3 + 2) &gt;&gt; 2;
-    SRC(0,4)=SRC(1,2)=SRC(2,0)= (t2 + t3 + 1) &gt;&gt; 1;
-    SRC(0,5)=SRC(1,3)=SRC(2,1)= (t2 + 2*t3 + t4 + 2) &gt;&gt; 2;
-    SRC(0,6)=SRC(1,4)=SRC(2,2)=SRC(3,0)= (t3 + t4 + 1) &gt;&gt; 1;
-    SRC(0,7)=SRC(1,5)=SRC(2,3)=SRC(3,1)= (t3 + 2*t4 + t5 + 2) &gt;&gt; 2;
-    SRC(1,6)=SRC(2,4)=SRC(3,2)=SRC(4,0)= (t4 + t5 + 1) &gt;&gt; 1;
-    SRC(1,7)=SRC(2,5)=SRC(3,3)=SRC(4,1)= (t4 + 2*t5 + t6 + 2) &gt;&gt; 2;
-    SRC(2,6)=SRC(3,4)=SRC(4,2)=SRC(5,0)= (t5 + t6 + 1) &gt;&gt; 1;
-    SRC(2,7)=SRC(3,5)=SRC(4,3)=SRC(5,1)= (t5 + 2*t6 + t7 + 2) &gt;&gt; 2;
-    SRC(3,6)=SRC(4,4)=SRC(5,2)=SRC(6,0)= (t6 + t7 + 1) &gt;&gt; 1;
-    SRC(3,7)=SRC(4,5)=SRC(5,3)=SRC(6,1)= (t6 + 2*t7 + t8 + 2) &gt;&gt; 2;
-    SRC(4,6)=SRC(5,4)=SRC(6,2)=SRC(7,0)= (t7 + t8 + 1) &gt;&gt; 1;
-    SRC(4,7)=SRC(5,5)=SRC(6,3)=SRC(7,1)= (t7 + 2*t8 + t9 + 2) &gt;&gt; 2;
-    SRC(5,6)=SRC(6,4)=SRC(7,2)= (t8 + t9 + 1) &gt;&gt; 1;
-    SRC(5,7)=SRC(6,5)=SRC(7,3)= (t8 + 2*t9 + t10 + 2) &gt;&gt; 2;
-    SRC(6,6)=SRC(7,4)= (t9 + t10 + 1) &gt;&gt; 1;
-    SRC(6,7)=SRC(7,5)= (t9 + 2*t10 + t11 + 2) &gt;&gt; 2;
-    SRC(7,6)= (t10 + t11 + 1) &gt;&gt; 1;
-    SRC(7,7)= (t10 + 2*t11 + t12 + 2) &gt;&gt; 2;
-}
-static void pred8x8l_horizontal_up_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_LEFT;
-    SRC(0,0)= (l0 + l1 + 1) &gt;&gt; 1;
-    SRC(1,0)= (l0 + 2*l1 + l2 + 2) &gt;&gt; 2;
-    SRC(0,1)=SRC(2,0)= (l1 + l2 + 1) &gt;&gt; 1;
-    SRC(1,1)=SRC(3,0)= (l1 + 2*l2 + l3 + 2) &gt;&gt; 2;
-    SRC(0,2)=SRC(2,1)=SRC(4,0)= (l2 + l3 + 1) &gt;&gt; 1;
-    SRC(1,2)=SRC(3,1)=SRC(5,0)= (l2 + 2*l3 + l4 + 2) &gt;&gt; 2;
-    SRC(0,3)=SRC(2,2)=SRC(4,1)=SRC(6,0)= (l3 + l4 + 1) &gt;&gt; 1;
-    SRC(1,3)=SRC(3,2)=SRC(5,1)=SRC(7,0)= (l3 + 2*l4 + l5 + 2) &gt;&gt; 2;
-    SRC(0,4)=SRC(2,3)=SRC(4,2)=SRC(6,1)= (l4 + l5 + 1) &gt;&gt; 1;
-    SRC(1,4)=SRC(3,3)=SRC(5,2)=SRC(7,1)= (l4 + 2*l5 + l6 + 2) &gt;&gt; 2;
-    SRC(0,5)=SRC(2,4)=SRC(4,3)=SRC(6,2)= (l5 + l6 + 1) &gt;&gt; 1;
-    SRC(1,5)=SRC(3,4)=SRC(5,3)=SRC(7,2)= (l5 + 2*l6 + l7 + 2) &gt;&gt; 2;
-    SRC(0,6)=SRC(2,5)=SRC(4,4)=SRC(6,3)= (l6 + l7 + 1) &gt;&gt; 1;
-    SRC(1,6)=SRC(3,5)=SRC(5,4)=SRC(7,3)= (l6 + 3*l7 + 2) &gt;&gt; 2;
-    SRC(0,7)=SRC(1,7)=SRC(2,6)=SRC(2,7)=SRC(3,6)=
-    SRC(3,7)=SRC(4,5)=SRC(4,6)=SRC(4,7)=SRC(5,5)=
-    SRC(5,6)=SRC(5,7)=SRC(6,4)=SRC(6,5)=SRC(6,6)=
-    SRC(6,7)=SRC(7,4)=SRC(7,5)=SRC(7,6)=SRC(7,7)= l7;
-}
-#undef PREDICT_8x8_LOAD_LEFT
-#undef PREDICT_8x8_LOAD_TOP
-#undef PREDICT_8x8_LOAD_TOPLEFT
-#undef PREDICT_8x8_LOAD_TOPRIGHT
-#undef PREDICT_8x8_DC
-#undef PTR
-#undef PT
-#undef PL
-#undef SRC
-
 static inline void mc_dir_part(H264Context *h, Picture *pic, int n, int square, int chroma_height, int delta, int list,
                            uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
                            int src_x_offset, int src_y_offset,
@@ -2422,7 +1698,7 @@
     const int full_mx= mx&gt;&gt;2;
     const int full_my= my&gt;&gt;2;
     const int pic_width  = 16*s-&gt;mb_width;
-    const int pic_height = 16*s-&gt;mb_height &gt;&gt; MB_MBAFF;
+    const int pic_height = 16*s-&gt;mb_height &gt;&gt; MB_FIELD;
 
     if(!pic-&gt;data[0]) //FIXME this is unacceptable, some senseable error concealment must be done for missing reference frames
         return;
@@ -2444,11 +1720,11 @@
         qpix_op[luma_xy](dest_y + delta, src_y + delta, h-&gt;mb_linesize);
     }
 
-    if(s-&gt;flags&amp;CODEC_FLAG_GRAY) return;
+    if(ENABLE_GRAY &amp;&amp; s-&gt;flags&amp;CODEC_FLAG_GRAY) return;
 
-    if(MB_MBAFF){
+    if(MB_FIELD){
         // chroma offset when predicting from a field of opposite parity
-        my += 2 * ((s-&gt;mb_y &amp; 1) - (h-&gt;ref_cache[list][scan8[n]] &amp; 1));
+        my += 2 * ((s-&gt;mb_y &amp; 1) - (pic-&gt;reference - 1));
         emu |= (my&gt;&gt;3) &lt; 0 || (my&gt;&gt;3) + 8 &gt;= (pic_height&gt;&gt;1);
     }
     src_cb= pic-&gt;data[1] + (mx&gt;&gt;3) + (my&gt;&gt;3)*h-&gt;mb_uvlinesize;
@@ -2481,7 +1757,7 @@
     dest_cb +=   x_offset +   y_offset*h-&gt;mb_uvlinesize;
     dest_cr +=   x_offset +   y_offset*h-&gt;mb_uvlinesize;
     x_offset += 8*s-&gt;mb_x;
-    y_offset += 8*(s-&gt;mb_y &gt;&gt; MB_MBAFF);
+    y_offset += 8*(s-&gt;mb_y &gt;&gt; MB_FIELD);
 
     if(list0){
         Picture *ref= &amp;h-&gt;ref_list[0][ h-&gt;ref_cache[0][ scan8[n] ] ];
@@ -2514,7 +1790,7 @@
     dest_cb +=   x_offset +   y_offset*h-&gt;mb_uvlinesize;
     dest_cr +=   x_offset +   y_offset*h-&gt;mb_uvlinesize;
     x_offset += 8*s-&gt;mb_x;
-    y_offset += 8*(s-&gt;mb_y &gt;&gt; MB_MBAFF);
+    y_offset += 8*(s-&gt;mb_y &gt;&gt; MB_FIELD);
 
     if(list0 &amp;&amp; list1){
         /* don't optimize for luma-only case, since B-frames usually
@@ -2607,7 +1883,7 @@
                       qpel_mc_func (*qpix_avg)[16], h264_chroma_mc_func (*chroma_avg),
                       h264_weight_func *weight_op, h264_biweight_func *weight_avg){
     MpegEncContext * const s = &amp;h-&gt;s;
-    const int mb_xy= s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+    const int mb_xy= h-&gt;mb_xy;
     const int mb_type= s-&gt;current_picture.mb_type[mb_xy];
 
     assert(IS_INTER(mb_type));
@@ -2728,57 +2004,9 @@
     }
 }
 
-/**
- * Sets the intra prediction function pointers.
- */
-static void init_pred_ptrs(H264Context *h){
-//    MpegEncContext * const s = &amp;h-&gt;s;
-
-    h-&gt;pred4x4[VERT_PRED           ]= pred4x4_vertical_c;
-    h-&gt;pred4x4[HOR_PRED            ]= pred4x4_horizontal_c;
-    h-&gt;pred4x4[DC_PRED             ]= pred4x4_dc_c;
-    h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED ]= pred4x4_down_left_c;
-    h-&gt;pred4x4[DIAG_DOWN_RIGHT_PRED]= pred4x4_down_right_c;
-    h-&gt;pred4x4[VERT_RIGHT_PRED     ]= pred4x4_vertical_right_c;
-    h-&gt;pred4x4[HOR_DOWN_PRED       ]= pred4x4_horizontal_down_c;
-    h-&gt;pred4x4[VERT_LEFT_PRED      ]= pred4x4_vertical_left_c;
-    h-&gt;pred4x4[HOR_UP_PRED         ]= pred4x4_horizontal_up_c;
-    h-&gt;pred4x4[LEFT_DC_PRED        ]= pred4x4_left_dc_c;
-    h-&gt;pred4x4[TOP_DC_PRED         ]= pred4x4_top_dc_c;
-    h-&gt;pred4x4[DC_128_PRED         ]= pred4x4_128_dc_c;
-
-    h-&gt;pred8x8l[VERT_PRED           ]= pred8x8l_vertical_c;
-    h-&gt;pred8x8l[HOR_PRED            ]= pred8x8l_horizontal_c;
-    h-&gt;pred8x8l[DC_PRED             ]= pred8x8l_dc_c;
-    h-&gt;pred8x8l[DIAG_DOWN_LEFT_PRED ]= pred8x8l_down_left_c;
-    h-&gt;pred8x8l[DIAG_DOWN_RIGHT_PRED]= pred8x8l_down_right_c;
-    h-&gt;pred8x8l[VERT_RIGHT_PRED     ]= pred8x8l_vertical_right_c;
-    h-&gt;pred8x8l[HOR_DOWN_PRED       ]= pred8x8l_horizontal_down_c;
-    h-&gt;pred8x8l[VERT_LEFT_PRED      ]= pred8x8l_vertical_left_c;
-    h-&gt;pred8x8l[HOR_UP_PRED         ]= pred8x8l_horizontal_up_c;
-    h-&gt;pred8x8l[LEFT_DC_PRED        ]= pred8x8l_left_dc_c;
-    h-&gt;pred8x8l[TOP_DC_PRED         ]= pred8x8l_top_dc_c;
-    h-&gt;pred8x8l[DC_128_PRED         ]= pred8x8l_128_dc_c;
-
-    h-&gt;pred8x8[DC_PRED8x8     ]= ff_pred8x8_dc_c;
-    h-&gt;pred8x8[VERT_PRED8x8   ]= ff_pred8x8_vertical_c;
-    h-&gt;pred8x8[HOR_PRED8x8    ]= ff_pred8x8_horizontal_c;
-    h-&gt;pred8x8[PLANE_PRED8x8  ]= ff_pred8x8_plane_c;
-    h-&gt;pred8x8[LEFT_DC_PRED8x8]= ff_pred8x8_left_dc_c;
-    h-&gt;pred8x8[TOP_DC_PRED8x8 ]= ff_pred8x8_top_dc_c;
-    h-&gt;pred8x8[DC_128_PRED8x8 ]= ff_pred8x8_128_dc_c;
-
-    h-&gt;pred16x16[DC_PRED8x8     ]= ff_pred16x16_dc_c;
-    h-&gt;pred16x16[VERT_PRED8x8   ]= ff_pred16x16_vertical_c;
-    h-&gt;pred16x16[HOR_PRED8x8    ]= ff_pred16x16_horizontal_c;
-    h-&gt;pred16x16[PLANE_PRED8x8  ]= ff_pred16x16_plane_c;
-    h-&gt;pred16x16[LEFT_DC_PRED8x8]= ff_pred16x16_left_dc_c;
-    h-&gt;pred16x16[TOP_DC_PRED8x8 ]= ff_pred16x16_top_dc_c;
-    h-&gt;pred16x16[DC_128_PRED8x8 ]= ff_pred16x16_128_dc_c;
-}
-
 static void free_tables(H264Context *h){
     int i;
+    H264Context *hx;
     av_freep(&amp;h-&gt;intra4x4_pred_mode);
     av_freep(&amp;h-&gt;chroma_pred_mode_table);
     av_freep(&amp;h-&gt;cbp_table);
@@ -2787,20 +2015,24 @@
     av_freep(&amp;h-&gt;direct_table);
     av_freep(&amp;h-&gt;non_zero_count);
     av_freep(&amp;h-&gt;slice_table_base);
-    av_freep(&amp;h-&gt;top_borders[1]);
-    av_freep(&amp;h-&gt;top_borders[0]);
     h-&gt;slice_table= NULL;
 
     av_freep(&amp;h-&gt;mb2b_xy);
     av_freep(&amp;h-&gt;mb2b8_xy);
 
-    av_freep(&amp;h-&gt;s.obmc_scratchpad);
-
     for(i = 0; i &lt; MAX_SPS_COUNT; i++)
         av_freep(h-&gt;sps_buffers + i);
 
     for(i = 0; i &lt; MAX_PPS_COUNT; i++)
         av_freep(h-&gt;pps_buffers + i);
+
+    for(i = 0; i &lt; h-&gt;s.avctx-&gt;thread_count; i++) {
+        hx = h-&gt;thread_context[i];
+        if(!hx) continue;
+        av_freep(&amp;hx-&gt;top_borders[1]);
+        av_freep(&amp;hx-&gt;top_borders[0]);
+        av_freep(&amp;hx-&gt;s.obmc_scratchpad);
+    }
 }
 
 static void init_dequant8_coeff_table(H264Context *h){
@@ -2881,16 +2113,12 @@
 
     CHECKED_ALLOCZ(h-&gt;non_zero_count    , big_mb_num * 16 * sizeof(uint8_t))
     CHECKED_ALLOCZ(h-&gt;slice_table_base  , (big_mb_num+s-&gt;mb_stride) * sizeof(uint8_t))
-    CHECKED_ALLOCZ(h-&gt;top_borders[0]    , s-&gt;mb_width * (16+8+8) * sizeof(uint8_t))
-    CHECKED_ALLOCZ(h-&gt;top_borders[1]    , s-&gt;mb_width * (16+8+8) * sizeof(uint8_t))
     CHECKED_ALLOCZ(h-&gt;cbp_table, big_mb_num * sizeof(uint16_t))
 
-    if( h-&gt;pps.cabac ) {
-        CHECKED_ALLOCZ(h-&gt;chroma_pred_mode_table, big_mb_num * sizeof(uint8_t))
-        CHECKED_ALLOCZ(h-&gt;mvd_table[0], 32*big_mb_num * sizeof(uint16_t));
-        CHECKED_ALLOCZ(h-&gt;mvd_table[1], 32*big_mb_num * sizeof(uint16_t));
-        CHECKED_ALLOCZ(h-&gt;direct_table, 32*big_mb_num * sizeof(uint8_t));
-    }
+    CHECKED_ALLOCZ(h-&gt;chroma_pred_mode_table, big_mb_num * sizeof(uint8_t))
+    CHECKED_ALLOCZ(h-&gt;mvd_table[0], 32*big_mb_num * sizeof(uint16_t));
+    CHECKED_ALLOCZ(h-&gt;mvd_table[1], 32*big_mb_num * sizeof(uint16_t));
+    CHECKED_ALLOCZ(h-&gt;direct_table, 32*big_mb_num * sizeof(uint8_t));
 
     memset(h-&gt;slice_table_base, -1, (big_mb_num+s-&gt;mb_stride)  * sizeof(uint8_t));
     h-&gt;slice_table= h-&gt;slice_table_base + s-&gt;mb_stride*2 + 1;
@@ -2919,6 +2147,38 @@
     return -1;
 }
 
+/**
+ * Mimic alloc_tables(), but for every context thread.
+ */
+static void clone_tables(H264Context *dst, H264Context *src){
+    dst-&gt;intra4x4_pred_mode       = src-&gt;intra4x4_pred_mode;
+    dst-&gt;non_zero_count           = src-&gt;non_zero_count;
+    dst-&gt;slice_table              = src-&gt;slice_table;
+    dst-&gt;cbp_table                = src-&gt;cbp_table;
+    dst-&gt;mb2b_xy                  = src-&gt;mb2b_xy;
+    dst-&gt;mb2b8_xy                 = src-&gt;mb2b8_xy;
+    dst-&gt;chroma_pred_mode_table   = src-&gt;chroma_pred_mode_table;
+    dst-&gt;mvd_table[0]             = src-&gt;mvd_table[0];
+    dst-&gt;mvd_table[1]             = src-&gt;mvd_table[1];
+    dst-&gt;direct_table             = src-&gt;direct_table;
+
+    dst-&gt;s.obmc_scratchpad = NULL;
+    ff_h264_pred_init(&amp;dst-&gt;hpc, src-&gt;s.codec_id);
+}
+
+/**
+ * Init context
+ * Allocate buffers which are not shared amongst multiple threads.
+ */
+static int context_init(H264Context *h){
+    CHECKED_ALLOCZ(h-&gt;top_borders[0], h-&gt;s.mb_width * (16+8+8) * sizeof(uint8_t))
+    CHECKED_ALLOCZ(h-&gt;top_borders[1], h-&gt;s.mb_width * (16+8+8) * sizeof(uint8_t))
+
+    return 0;
+fail:
+    return -1; // free_tables will clean up for us
+}
+
 static void common_init(H264Context *h){
     MpegEncContext * const s = &amp;h-&gt;s;
 
@@ -2926,7 +2186,7 @@
     s-&gt;height = s-&gt;avctx-&gt;height;
     s-&gt;codec_id= s-&gt;avctx-&gt;codec-&gt;id;
 
-    init_pred_ptrs(h);
+    ff_h264_pred_init(&amp;h-&gt;hpc, s-&gt;codec_id);
 
     h-&gt;dequant_coeff_pps= -1;
     s-&gt;unrestricted_mv=1;
@@ -2950,9 +2210,14 @@
 
     // set defaults
 //    s-&gt;decode_mb= ff_h263_decode_mb;
+    s-&gt;quarter_sample = 1;
     s-&gt;low_delay= 1;
-    avctx-&gt;pix_fmt= PIX_FMT_YUV420P;
 
+    if(avctx-&gt;codec_id == CODEC_ID_SVQ3)
+        avctx-&gt;pix_fmt= PIX_FMT_YUVJ420P;
+    else
+        avctx-&gt;pix_fmt= PIX_FMT_YUV420P;
+
     decode_init_vlc();
 
     if(avctx-&gt;extradata_size &gt; 0 &amp;&amp; avctx-&gt;extradata &amp;&amp;
@@ -2963,6 +2228,7 @@
         h-&gt;is_avc = 0;
     }
 
+    h-&gt;thread_context[0] = h;
     return 0;
 }
 
@@ -2973,6 +2239,13 @@
     if(MPV_frame_start(s, s-&gt;avctx) &lt; 0)
         return -1;
     ff_er_frame_start(s);
+    /*
+     * MPV_frame_start uses pict_type to derive key_frame.
+     * This is incorrect for H.264; IDR markings must be used.
+     * Zero here; IDR markings per slice in frame or fields are OR'd in later.
+     * See decode_nal_units().
+     */
+    s-&gt;current_picture_ptr-&gt;key_frame= 0;
 
     assert(s-&gt;linesize &amp;&amp; s-&gt;uvlinesize);
 
@@ -2989,14 +2262,16 @@
 
     /* can't be in alloc_tables because linesize isn't known there.
      * FIXME: redo bipred weight to not require extra buffer? */
-    if(!s-&gt;obmc_scratchpad)
-        s-&gt;obmc_scratchpad = av_malloc(16*2*s-&gt;linesize + 8*2*s-&gt;uvlinesize);
+    for(i = 0; i &lt; s-&gt;avctx-&gt;thread_count; i++)
+        if(!h-&gt;thread_context[i]-&gt;s.obmc_scratchpad)
+            h-&gt;thread_context[i]-&gt;s.obmc_scratchpad = av_malloc(16*2*s-&gt;linesize + 8*2*s-&gt;uvlinesize);
 
     /* some macroblocks will be accessed before they're available */
-    if(FRAME_MBAFF)
+    if(FRAME_MBAFF || s-&gt;avctx-&gt;thread_count &gt; 1)
         memset(h-&gt;slice_table, -1, (s-&gt;mb_height*s-&gt;mb_stride-1) * sizeof(uint8_t));
 
 //    s-&gt;decode= (s-&gt;flags&amp;CODEC_FLAG_PSNR) || !s-&gt;encoding || s-&gt;current_picture.reference /*|| h-&gt;contains_intra*/ || 1;
+    s-&gt;current_picture_ptr-&gt;reference= 0;
     return 0;
 }
 
@@ -3018,7 +2293,7 @@
     *(uint64_t*)(h-&gt;top_borders[0][s-&gt;mb_x]+0)= *(uint64_t*)(src_y +  16*linesize);
     *(uint64_t*)(h-&gt;top_borders[0][s-&gt;mb_x]+8)= *(uint64_t*)(src_y +8+16*linesize);
 
-    if(simple || !(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
+    if(simple || !ENABLE_GRAY || !(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
         h-&gt;left_border[17  ]= h-&gt;top_borders[0][s-&gt;mb_x][16+7];
         h-&gt;left_border[17+9]= h-&gt;top_borders[0][s-&gt;mb_x][24+7];
         for(i=1; i&lt;9; i++){
@@ -3039,7 +2314,7 @@
     int mb_xy;
 
     if(h-&gt;deblocking_filter == 2) {
-        mb_xy = s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+        mb_xy = h-&gt;mb_xy;
         deblock_left = h-&gt;slice_table[mb_xy] == h-&gt;slice_table[mb_xy - 1];
         deblock_top  = h-&gt;slice_table[mb_xy] == h-&gt;slice_table[h-&gt;top_mb_xy];
     } else {
@@ -3071,7 +2346,7 @@
         }
     }
 
-    if(simple || !(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
+    if(simple || !ENABLE_GRAY || !(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
         if(deblock_left){
             for(i = !deblock_top; i&lt;9; i++){
                 XCHG(h-&gt;left_border[i+17  ], src_cb[i*uvlinesize], temp8, xchg);
@@ -3106,7 +2381,7 @@
     *(uint64_t*)(h-&gt;top_borders[1][s-&gt;mb_x]+0)= *(uint64_t*)(src_y +  33*linesize);
     *(uint64_t*)(h-&gt;top_borders[1][s-&gt;mb_x]+8)= *(uint64_t*)(src_y +8+33*linesize);
 
-    if(!(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
+    if(!ENABLE_GRAY || !(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
         h-&gt;left_border[34     ]= h-&gt;top_borders[0][s-&gt;mb_x][16+7];
         h-&gt;left_border[34+   1]= h-&gt;top_borders[1][s-&gt;mb_x][16+7];
         h-&gt;left_border[34+18  ]= h-&gt;top_borders[0][s-&gt;mb_x][24+7];
@@ -3158,7 +2433,7 @@
         }
     }
 
-    if(!(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
+    if(!ENABLE_GRAY || !(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
         if(deblock_left){
             for(i = (!deblock_top) &lt;&lt; 1; i&lt;18; i++){
                 XCHG(h-&gt;left_border[i+34   ], src_cb[i*uvlinesize], temp8, xchg);
@@ -3178,7 +2453,7 @@
     MpegEncContext * const s = &amp;h-&gt;s;
     const int mb_x= s-&gt;mb_x;
     const int mb_y= s-&gt;mb_y;
-    const int mb_xy= mb_x + mb_y*s-&gt;mb_stride;
+    const int mb_xy= h-&gt;mb_xy;
     const int mb_type= s-&gt;current_picture.mb_type[mb_xy];
     uint8_t  *dest_y, *dest_cb, *dest_cr;
     int linesize, uvlinesize /*dct_offset*/;
@@ -3212,13 +2487,13 @@
                     continue;
                 if(IS_16X16(mb_type)){
                     int8_t *ref = &amp;h-&gt;ref_cache[list][scan8[0]];
-                    fill_rectangle(ref, 4, 4, 8, 16+*ref^(s-&gt;mb_y&amp;1), 1);
+                    fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s-&gt;mb_y&amp;1), 1);
                 }else{
                     for(i=0; i&lt;16; i+=4){
                         //FIXME can refs be smaller than 8x8 when !direct_8x8_inference ?
                         int ref = h-&gt;ref_cache[list][scan8[i]];
                         if(ref &gt;= 0)
-                            fill_rectangle(&amp;h-&gt;ref_cache[list][scan8[i]], 2, 2, 8, 16+ref^(s-&gt;mb_y&amp;1), 1);
+                            fill_rectangle(&amp;h-&gt;ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s-&gt;mb_y&amp;1), 1);
                     }
                 }
             }
@@ -3280,9 +2555,9 @@
             if(h-&gt;deblocking_filter &amp;&amp; (simple || !FRAME_MBAFF))
                 xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, simple);
 
-            if(simple || !(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
-                h-&gt;pred8x8[ h-&gt;chroma_pred_mode ](dest_cb, uvlinesize);
-                h-&gt;pred8x8[ h-&gt;chroma_pred_mode ](dest_cr, uvlinesize);
+            if(simple || !ENABLE_GRAY || !(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
+                h-&gt;hpc.pred8x8[ h-&gt;chroma_pred_mode ](dest_cb, uvlinesize);
+                h-&gt;hpc.pred8x8[ h-&gt;chroma_pred_mode ](dest_cr, uvlinesize);
             }
 
             if(IS_INTRA4x4(mb_type)){
@@ -3292,7 +2567,7 @@
                             uint8_t * const ptr= dest_y + block_offset[i];
                             const int dir= h-&gt;intra4x4_pred_mode_cache[ scan8[i] ];
                             const int nnz = h-&gt;non_zero_count_cache[ scan8[i] ];
-                            h-&gt;pred8x8l[ dir ](ptr, (h-&gt;topleft_samples_available&lt;&lt;i)&amp;0x8000,
+                            h-&gt;hpc.pred8x8l[ dir ](ptr, (h-&gt;topleft_samples_available&lt;&lt;i)&amp;0x8000,
                                                    (h-&gt;topright_samples_available&lt;&lt;i)&amp;0x4000, linesize);
                             if(nnz){
                                 if(nnz == 1 &amp;&amp; h-&gt;mb[i*16])
@@ -3319,7 +2594,7 @@
                         }else
                             topright= NULL;
 
-                        h-&gt;pred4x4[ dir ](ptr, topright, linesize);
+                        h-&gt;hpc.pred4x4[ dir ](ptr, topright, linesize);
                         nnz = h-&gt;non_zero_count_cache[ scan8[i] ];
                         if(nnz){
                             if(is_h264){
@@ -3333,10 +2608,10 @@
                     }
                 }
             }else{
-                h-&gt;pred16x16[ h-&gt;intra16x16_pred_mode ](dest_y , linesize);
+                h-&gt;hpc.pred16x16[ h-&gt;intra16x16_pred_mode ](dest_y , linesize);
                 if(is_h264){
                     if(!transform_bypass)
-                        h264_luma_dc_dequant_idct_c(h-&gt;mb, s-&gt;qscale, h-&gt;dequant4_coeff[IS_INTRA(mb_type) ? 0:3][s-&gt;qscale][0]);
+                        h264_luma_dc_dequant_idct_c(h-&gt;mb, s-&gt;qscale, h-&gt;dequant4_coeff[0][s-&gt;qscale][0]);
                 }else
                     svq3_luma_dc_dequant_idct_c(h-&gt;mb, s-&gt;qscale);
             }
@@ -3381,7 +2656,7 @@
             }
         }
 
-        if(simple || !(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
+        if(simple || !ENABLE_GRAY || !(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
             uint8_t *dest[2] = {dest_cb, dest_cr};
             if(transform_bypass){
                 idct_add = idct_dc_add = s-&gt;dsp.add_pixels4;
@@ -3428,14 +2703,14 @@
             backup_pair_border(h, pair_dest_y, pair_dest_cb, pair_dest_cr, s-&gt;linesize, s-&gt;uvlinesize);
             // deblock a pair
             // top
-            s-&gt;mb_y--;
+            s-&gt;mb_y--; h-&gt;mb_xy -= s-&gt;mb_stride;
             tprintf(h-&gt;s.avctx, &quot;call mbaff filter_mb mb_x:%d mb_y:%d pair_dest_y = %p, dest_y = %p\n&quot;, mb_x, mb_y, pair_dest_y, dest_y);
             fill_caches(h, mb_type_top, 1); //FIXME don't fill stuff which isn't used by filter_mb
             h-&gt;chroma_qp[0] = get_chroma_qp(h, 0, s-&gt;current_picture.qscale_table[mb_xy]);
             h-&gt;chroma_qp[1] = get_chroma_qp(h, 1, s-&gt;current_picture.qscale_table[mb_xy]);
             filter_mb(h, mb_x, mb_y, pair_dest_y, pair_dest_cb, pair_dest_cr, linesize, uvlinesize);
             // bottom
-            s-&gt;mb_y++;
+            s-&gt;mb_y++; h-&gt;mb_xy += s-&gt;mb_stride;
             tprintf(h-&gt;s.avctx, &quot;call mbaff filter_mb\n&quot;);
             fill_caches(h, mb_type_bottom, 1); //FIXME don't fill stuff which isn't used by filter_mb
             h-&gt;chroma_qp[0] = get_chroma_qp(h, 0, s-&gt;current_picture.qscale_table[mb_xy+s-&gt;mb_stride]);
@@ -3466,13 +2741,12 @@
 
 static void hl_decode_mb(H264Context *h){
     MpegEncContext * const s = &amp;h-&gt;s;
-    const int mb_x= s-&gt;mb_x;
-    const int mb_y= s-&gt;mb_y;
-    const int mb_xy= mb_x + mb_y*s-&gt;mb_stride;
+    const int mb_xy= h-&gt;mb_xy;
     const int mb_type= s-&gt;current_picture.mb_type[mb_xy];
-    int is_complex = FRAME_MBAFF || MB_FIELD || IS_INTRA_PCM(mb_type) || s-&gt;codec_id != CODEC_ID_H264 || (s-&gt;flags&amp;CODEC_FLAG_GRAY) || s-&gt;encoding;
+    int is_complex = FRAME_MBAFF || MB_FIELD || IS_INTRA_PCM(mb_type) || s-&gt;codec_id != CODEC_ID_H264 ||
+                    (ENABLE_GRAY &amp;&amp; (s-&gt;flags&amp;CODEC_FLAG_GRAY)) || (ENABLE_H264_ENCODER &amp;&amp; s-&gt;encoding) || ENABLE_SMALL;
 
-    if(!s-&gt;decode)
+    if(ENABLE_H264_ENCODER &amp;&amp; !s-&gt;decode)
         return;
 
     if (is_complex)
@@ -3480,16 +2754,131 @@
     else hl_decode_mb_simple(h);
 }
 
+static void pic_as_field(Picture *pic, const int parity){
+    int i;
+    for (i = 0; i &lt; 4; ++i) {
+        if (parity == PICT_BOTTOM_FIELD)
+            pic-&gt;data[i] += pic-&gt;linesize[i];
+        pic-&gt;reference = parity;
+        pic-&gt;linesize[i] *= 2;
+    }
+}
+
+static int split_field_copy(Picture *dest, Picture *src,
+                            int parity, int id_add){
+    int match = !!(src-&gt;reference &amp; parity);
+
+    if (match) {
+        *dest = *src;
+        pic_as_field(dest, parity);
+        dest-&gt;pic_id *= 2;
+        dest-&gt;pic_id += id_add;
+    }
+
+    return match;
+}
+
 /**
+ * Split one reference list into field parts, interleaving by parity
+ * as per H.264 spec section 8.2.4.2.5. Output fields have their data pointers
+ * set to look at the actual start of data for that field.
+ *
+ * @param dest output list
+ * @param dest_len maximum number of fields to put in dest
+ * @param src the source reference list containing fields and/or field pairs
+ *            (aka short_ref/long_ref, or
+ *             refFrameListXShortTerm/refFrameListLongTerm in spec-speak)
+ * @param src_len number of Picture's in source (pairs and unmatched fields)
+ * @param parity the parity of the picture being decoded/needing
+ *        these ref pics (PICT_{TOP,BOTTOM}_FIELD)
+ * @return number of fields placed in dest
+ */
+static int split_field_half_ref_list(Picture *dest, int dest_len,
+                                     Picture *src,  int src_len,  int parity){
+    int same_parity   = 1;
+    int same_i        = 0;
+    int opp_i         = 0;
+    int out_i;
+    int field_output;
+
+    for (out_i = 0; out_i &lt; dest_len; out_i += field_output) {
+        if (same_parity &amp;&amp; same_i &lt; src_len) {
+            field_output = split_field_copy(dest + out_i, src + same_i,
+                                            parity, 1);
+            same_parity = !field_output;
+            same_i++;
+
+        } else if (opp_i &lt; src_len) {
+            field_output = split_field_copy(dest + out_i, src + opp_i,
+                                            PICT_FRAME - parity, 0);
+            same_parity = field_output;
+            opp_i++;
+
+        } else {
+            break;
+        }
+    }
+
+    return out_i;
+}
+
+/**
+ * Split the reference frame list into a reference field list.
+ * This implements H.264 spec 8.2.4.2.5 for a combined input list.
+ * The input list contains both reference field pairs and
+ * unmatched reference fields; it is ordered as spec describes
+ * RefPicListX for frames in 8.2.4.2.1 and 8.2.4.2.3, except that
+ * unmatched field pairs are also present. Conceptually this is equivalent
+ * to concatenation of refFrameListXShortTerm with refFrameListLongTerm.
+ *
+ * @param dest output reference list where ordered fields are to be placed
+ * @param dest_len max number of fields to place at dest
+ * @param src source reference list, as described above
+ * @param src_len number of pictures (pairs and unmatched fields) in src
+ * @param parity parity of field being currently decoded
+ *        (one of PICT_{TOP,BOTTOM}_FIELD)
+ * @param long_i index into src array that holds first long reference picture,
+ *        or src_len if no long refs present.
+ */
+static int split_field_ref_list(Picture *dest, int dest_len,
+                                Picture *src,  int src_len,
+                                int parity,    int long_i){
+
+    int i = split_field_half_ref_list(dest, dest_len, src, long_i, parity);
+    dest += i;
+    dest_len -= i;
+
+    i += split_field_half_ref_list(dest, dest_len, src + long_i,
+                                   src_len - long_i, parity);
+    return i;
+}
+
+/**
  * fills the default_ref_list.
  */
 static int fill_default_ref_list(H264Context *h){
     MpegEncContext * const s = &amp;h-&gt;s;
     int i;
     int smallest_poc_greater_than_current = -1;
+    int structure_sel;
     Picture sorted_short_ref[32];
+    Picture field_entry_list[2][32];
+    Picture *frame_list[2];
 
-    if(h-&gt;slice_type==B_TYPE){
+    if (FIELD_PICTURE) {
+        structure_sel = PICT_FRAME;
+        frame_list[0] = field_entry_list[0];
+        frame_list[1] = field_entry_list[1];
+    } else {
+        structure_sel = 0;
+        frame_list[0] = h-&gt;default_ref_list[0];
+        frame_list[1] = h-&gt;default_ref_list[1];
+    }
+
+    if(h-&gt;slice_type==FF_B_TYPE){
+        int list;
+        int len[2];
+        int short_len[2];
         int out_i;
         int limit= INT_MIN;
 
@@ -3517,79 +2906,100 @@
                 }
             }
         }
-    }
 
-    if(s-&gt;picture_structure == PICT_FRAME){
-        if(h-&gt;slice_type==B_TYPE){
-            int list;
-            tprintf(h-&gt;s.avctx, &quot;current poc: %d, smallest_poc_greater_than_current: %d\n&quot;, s-&gt;current_picture_ptr-&gt;poc, smallest_poc_greater_than_current);
+        tprintf(h-&gt;s.avctx, &quot;current poc: %d, smallest_poc_greater_than_current: %d\n&quot;, s-&gt;current_picture_ptr-&gt;poc, smallest_poc_greater_than_current);
 
-            // find the largest poc
-            for(list=0; list&lt;2; list++){
-                int index = 0;
-                int j= -99;
-                int step= list ? -1 : 1;
+        // find the largest poc
+        for(list=0; list&lt;2; list++){
+            int index = 0;
+            int j= -99;
+            int step= list ? -1 : 1;
 
-                for(i=0; i&lt;h-&gt;short_ref_count &amp;&amp; index &lt; h-&gt;ref_count[list]; i++, j+=step) {
-                    while(j&lt;0 || j&gt;= h-&gt;short_ref_count){
-                        if(j != -99 &amp;&amp; step == (list ? -1 : 1))
-                            return -1;
-                        step = -step;
-                        j= smallest_poc_greater_than_current + (step&gt;&gt;1);
-                    }
-                    if(sorted_short_ref[j].reference != 3) continue;
-                    h-&gt;default_ref_list[list][index  ]= sorted_short_ref[j];
-                    h-&gt;default_ref_list[list][index++].pic_id= sorted_short_ref[j].frame_num;
+            for(i=0; i&lt;h-&gt;short_ref_count &amp;&amp; index &lt; h-&gt;ref_count[list]; i++, j+=step) {
+                int sel;
+                while(j&lt;0 || j&gt;= h-&gt;short_ref_count){
+                    if(j != -99 &amp;&amp; step == (list ? -1 : 1))
+                        return -1;
+                    step = -step;
+                    j= smallest_poc_greater_than_current + (step&gt;&gt;1);
                 }
+                sel = sorted_short_ref[j].reference | structure_sel;
+                if(sel != PICT_FRAME) continue;
+                frame_list[list][index  ]= sorted_short_ref[j];
+                frame_list[list][index++].pic_id= sorted_short_ref[j].frame_num;
+            }
+            short_len[list] = index;
 
-                for(i = 0; i &lt; 16 &amp;&amp; index &lt; h-&gt;ref_count[ list ]; i++){
-                    if(h-&gt;long_ref[i] == NULL) continue;
-                    if(h-&gt;long_ref[i]-&gt;reference != 3) continue;
+            for(i = 0; i &lt; 16 &amp;&amp; index &lt; h-&gt;ref_count[ list ]; i++){
+                int sel;
+                if(h-&gt;long_ref[i] == NULL) continue;
+                sel = h-&gt;long_ref[i]-&gt;reference | structure_sel;
+                if(sel != PICT_FRAME) continue;
 
-                    h-&gt;default_ref_list[ list ][index  ]= *h-&gt;long_ref[i];
-                    h-&gt;default_ref_list[ list ][index++].pic_id= i;;
-                }
+                frame_list[ list ][index  ]= *h-&gt;long_ref[i];
+                frame_list[ list ][index++].pic_id= i;
+            }
+            len[list] = index;
+        }
 
-                if(list &amp;&amp; (smallest_poc_greater_than_current&lt;=0 || smallest_poc_greater_than_current&gt;=h-&gt;short_ref_count) &amp;&amp; (1 &lt; index)){
-                    // swap the two first elements of L1 when
-                    // L0 and L1 are identical
-                    Picture temp= h-&gt;default_ref_list[1][0];
-                    h-&gt;default_ref_list[1][0] = h-&gt;default_ref_list[1][1];
-                    h-&gt;default_ref_list[1][1] = temp;
-                }
+        for(list=0; list&lt;2; list++){
+            if (FIELD_PICTURE)
+                len[list] = split_field_ref_list(h-&gt;default_ref_list[list],
+                                                 h-&gt;ref_count[list],
+                                                 frame_list[list],
+                                                 len[list],
+                                                 s-&gt;picture_structure,
+                                                 short_len[list]);
 
-                if(index &lt; h-&gt;ref_count[ list ])
-                    memset(&amp;h-&gt;default_ref_list[list][index], 0, sizeof(Picture)*(h-&gt;ref_count[ list ] - index));
-            }
-        }else{
-            int index=0;
-            for(i=0; i&lt;h-&gt;short_ref_count; i++){
-                if(h-&gt;short_ref[i]-&gt;reference != 3) continue; //FIXME refernce field shit
-                h-&gt;default_ref_list[0][index  ]= *h-&gt;short_ref[i];
-                h-&gt;default_ref_list[0][index++].pic_id= h-&gt;short_ref[i]-&gt;frame_num;
-            }
-            for(i = 0; i &lt; 16; i++){
-                if(h-&gt;long_ref[i] == NULL) continue;
-                if(h-&gt;long_ref[i]-&gt;reference != 3) continue;
-                h-&gt;default_ref_list[0][index  ]= *h-&gt;long_ref[i];
-                h-&gt;default_ref_list[0][index++].pic_id= i;;
-            }
-            if(index &lt; h-&gt;ref_count[0])
-                memset(&amp;h-&gt;default_ref_list[0][index], 0, sizeof(Picture)*(h-&gt;ref_count[0] - index));
+            // swap the two first elements of L1 when L0 and L1 are identical
+            if(list &amp;&amp; len[0] &gt; 1 &amp;&amp; len[0] == len[1])
+                for(i=0; h-&gt;default_ref_list[0][i].data[0] == h-&gt;default_ref_list[1][i].data[0]; i++)
+                    if(i == len[0]){
+                        FFSWAP(Picture, h-&gt;default_ref_list[1][0], h-&gt;default_ref_list[1][1]);
+                        break;
+                    }
+
+            if(len[list] &lt; h-&gt;ref_count[ list ])
+                memset(&amp;h-&gt;default_ref_list[list][len[list]], 0, sizeof(Picture)*(h-&gt;ref_count[ list ] - len[list]));
         }
-    }else{ //FIELD
-        if(h-&gt;slice_type==B_TYPE){
-        }else{
-            //FIXME second field balh
+
+
+    }else{
+        int index=0;
+        int short_len;
+        for(i=0; i&lt;h-&gt;short_ref_count; i++){
+            int sel;
+            sel = h-&gt;short_ref[i]-&gt;reference | structure_sel;
+            if(sel != PICT_FRAME) continue;
+            frame_list[0][index  ]= *h-&gt;short_ref[i];
+            frame_list[0][index++].pic_id= h-&gt;short_ref[i]-&gt;frame_num;
         }
+        short_len = index;
+        for(i = 0; i &lt; 16; i++){
+            int sel;
+            if(h-&gt;long_ref[i] == NULL) continue;
+            sel = h-&gt;long_ref[i]-&gt;reference | structure_sel;
+            if(sel != PICT_FRAME) continue;
+            frame_list[0][index  ]= *h-&gt;long_ref[i];
+            frame_list[0][index++].pic_id= i;
+        }
+
+        if (FIELD_PICTURE)
+            index = split_field_ref_list(h-&gt;default_ref_list[0],
+                                         h-&gt;ref_count[0], frame_list[0],
+                                         index, s-&gt;picture_structure,
+                                         short_len);
+
+        if(index &lt; h-&gt;ref_count[0])
+            memset(&amp;h-&gt;default_ref_list[0][index], 0, sizeof(Picture)*(h-&gt;ref_count[0] - index));
     }
 #ifdef TRACE
     for (i=0; i&lt;h-&gt;ref_count[0]; i++) {
         tprintf(h-&gt;s.avctx, &quot;List0: %s fn:%d 0x%p\n&quot;, (h-&gt;default_ref_list[0][i].long_ref ? &quot;LT&quot; : &quot;ST&quot;), h-&gt;default_ref_list[0][i].pic_id, h-&gt;default_ref_list[0][i].data[0]);
     }
-    if(h-&gt;slice_type==B_TYPE){
+    if(h-&gt;slice_type==FF_B_TYPE){
         for (i=0; i&lt;h-&gt;ref_count[1]; i++) {
-            tprintf(h-&gt;s.avctx, &quot;List1: %s fn:%d 0x%p\n&quot;, (h-&gt;default_ref_list[1][i].long_ref ? &quot;LT&quot; : &quot;ST&quot;), h-&gt;default_ref_list[1][i].pic_id, h-&gt;default_ref_list[0][i].data[0]);
+            tprintf(h-&gt;s.avctx, &quot;List1: %s fn:%d 0x%p\n&quot;, (h-&gt;default_ref_list[1][i].long_ref ? &quot;LT&quot; : &quot;ST&quot;), h-&gt;default_ref_list[1][i].pic_id, h-&gt;default_ref_list[1][i].data[0]);
         }
     }
 #endif
@@ -3599,13 +3009,37 @@
 static void print_short_term(H264Context *h);
 static void print_long_term(H264Context *h);
 
+/**
+ * Extract structure information about the picture described by pic_num in
+ * the current decoding context (frame or field). Note that pic_num is
+ * picture number without wrapping (so, 0&lt;=pic_num&lt;max_pic_num).
+ * @param pic_num picture number for which to extract structure information
+ * @param structure one of PICT_XXX describing structure of picture
+ *                      with pic_num
+ * @return frame number (short term) or long term index of picture
+ *         described by pic_num
+ */
+static int pic_num_extract(H264Context *h, int pic_num, int *structure){
+    MpegEncContext * const s = &amp;h-&gt;s;
+
+    *structure = s-&gt;picture_structure;
+    if(FIELD_PICTURE){
+        if (!(pic_num &amp; 1))
+            /* opposite field */
+            *structure ^= PICT_FRAME;
+        pic_num &gt;&gt;= 1;
+    }
+
+    return pic_num;
+}
+
 static int decode_ref_pic_list_reordering(H264Context *h){
     MpegEncContext * const s = &amp;h-&gt;s;
-    int list, index;
+    int list, index, pic_structure;
 
     print_short_term(h);
     print_long_term(h);
-    if(h-&gt;slice_type==I_TYPE || h-&gt;slice_type==SI_TYPE) return 0; //FIXME move before func
+    if(h-&gt;slice_type==FF_I_TYPE || h-&gt;slice_type==FF_SI_TYPE) return 0; //FIXME move before func
 
     for(list=0; list&lt;h-&gt;list_count; list++){
         memcpy(h-&gt;ref_list[list], h-&gt;default_ref_list[list], sizeof(Picture)*h-&gt;ref_count[list]);
@@ -3630,8 +3064,9 @@
                 if(reordering_of_pic_nums_idc&lt;3){
                     if(reordering_of_pic_nums_idc&lt;2){
                         const unsigned int abs_diff_pic_num= get_ue_golomb(&amp;s-&gt;gb) + 1;
+                        int frame_num;
 
-                        if(abs_diff_pic_num &gt;= h-&gt;max_pic_num){
+                        if(abs_diff_pic_num &gt; h-&gt;max_pic_num){
                             av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;abs_diff_pic_num overflow\n&quot;);
                             return -1;
                         }
@@ -3640,25 +3075,34 @@
                         else                                pred+= abs_diff_pic_num;
                         pred &amp;= h-&gt;max_pic_num - 1;
 
+                        frame_num = pic_num_extract(h, pred, &amp;pic_structure);
+
                         for(i= h-&gt;short_ref_count-1; i&gt;=0; i--){
                             ref = h-&gt;short_ref[i];
-                            assert(ref-&gt;reference == 3);
+                            assert(ref-&gt;reference);
                             assert(!ref-&gt;long_ref);
-                            if(ref-&gt;data[0] != NULL &amp;&amp; ref-&gt;frame_num == pred &amp;&amp; ref-&gt;long_ref == 0) // ignore non existing pictures by testing data[0] pointer
+                            if(ref-&gt;data[0] != NULL &amp;&amp;
+                                   ref-&gt;frame_num == frame_num &amp;&amp;
+                                   (ref-&gt;reference &amp; pic_structure) &amp;&amp;
+                                   ref-&gt;long_ref == 0) // ignore non existing pictures by testing data[0] pointer
                                 break;
                         }
                         if(i&gt;=0)
-                            ref-&gt;pic_id= ref-&gt;frame_num;
+                            ref-&gt;pic_id= pred;
                     }else{
+                        int long_idx;
                         pic_id= get_ue_golomb(&amp;s-&gt;gb); //long_term_pic_idx
-                        if(pic_id&gt;31){
+
+                        long_idx= pic_num_extract(h, pic_id, &amp;pic_structure);
+
+                        if(long_idx&gt;31){
                             av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;long_term_pic_idx overflow\n&quot;);
                             return -1;
                         }
-                        ref = h-&gt;long_ref[pic_id];
-                        if(ref){
+                        ref = h-&gt;long_ref[long_idx];
+                        assert(!(ref &amp;&amp; !ref-&gt;reference));
+                        if(ref &amp;&amp; (ref-&gt;reference &amp; pic_structure)){
                             ref-&gt;pic_id= pic_id;
-                            assert(ref-&gt;reference == 3);
                             assert(ref-&gt;long_ref);
                             i=0;
                         }else{
@@ -3678,6 +3122,9 @@
                             h-&gt;ref_list[list][i]= h-&gt;ref_list[list][i-1];
                         }
                         h-&gt;ref_list[list][index]= *ref;
+                        if (FIELD_PICTURE){
+                            pic_as_field(&amp;h-&gt;ref_list[list][index], pic_structure);
+                        }
                     }
                 }else{
                     av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;illegal reordering_of_pic_nums_idc\n&quot;);
@@ -3693,7 +3140,7 @@
         }
     }
 
-    if(h-&gt;slice_type==B_TYPE &amp;&amp; !h-&gt;direct_spatial_mv_pred)
+    if(h-&gt;slice_type==FF_B_TYPE &amp;&amp; !h-&gt;direct_spatial_mv_pred)
         direct_dist_scale_factor(h);
     direct_ref_list_init(h);
     return 0;
@@ -3708,9 +3155,11 @@
             field[0] = *frame;
             for(j=0; j&lt;3; j++)
                 field[0].linesize[j] &lt;&lt;= 1;
+            field[0].reference = PICT_TOP_FIELD;
             field[1] = field[0];
             for(j=0; j&lt;3; j++)
                 field[1].data[j] += frame-&gt;linesize[j];
+            field[1].reference = PICT_BOTTOM_FIELD;
 
             h-&gt;luma_weight[list][16+2*i] = h-&gt;luma_weight[list][16+2*i+1] = h-&gt;luma_weight[list][i];
             h-&gt;luma_offset[list][16+2*i] = h-&gt;luma_offset[list][16+2*i+1] = h-&gt;luma_offset[list][i];
@@ -3774,7 +3223,7 @@
                 }
             }
         }
-        if(h-&gt;slice_type != B_TYPE) break;
+        if(h-&gt;slice_type != FF_B_TYPE) break;
     }
     h-&gt;use_weight= h-&gt;use_weight || h-&gt;use_weight_chroma;
     return 0;
@@ -3816,17 +3265,32 @@
     }
 }
 
-static inline void unreference_pic(H264Context *h, Picture *pic){
+/**
+ * Mark a picture as no longer needed for reference. The refmask
+ * argument allows unreferencing of individual fields or the whole frame.
+ * If the picture becomes entirely unreferenced, but is being held for
+ * display purposes, it is marked as such.
+ * @param refmask mask of fields to unreference; the mask is bitwise
+ *                anded with the reference marking of pic
+ * @return non-zero if pic becomes entirely unreferenced (except possibly
+ *         for display purposes) zero if one of the fields remains in
+ *         reference
+ */
+static inline int unreference_pic(H264Context *h, Picture *pic, int refmask){
     int i;
-    pic-&gt;reference=0;
-    if(pic == h-&gt;delayed_output_pic)
-        pic-&gt;reference=1;
-    else{
-        for(i = 0; h-&gt;delayed_pic[i]; i++)
-            if(pic == h-&gt;delayed_pic[i]){
-                pic-&gt;reference=1;
-                break;
-            }
+    if (pic-&gt;reference &amp;= refmask) {
+        return 0;
+    } else {
+        if(pic == h-&gt;delayed_output_pic)
+            pic-&gt;reference=DELAYED_PIC_REF;
+        else{
+            for(i = 0; h-&gt;delayed_pic[i]; i++)
+                if(pic == h-&gt;delayed_pic[i]){
+                    pic-&gt;reference=DELAYED_PIC_REF;
+                    break;
+                }
+        }
+        return 1;
     }
 }
 
@@ -3838,14 +3302,14 @@
 
     for(i=0; i&lt;16; i++){
         if (h-&gt;long_ref[i] != NULL) {
-            unreference_pic(h, h-&gt;long_ref[i]);
+            unreference_pic(h, h-&gt;long_ref[i], 0);
             h-&gt;long_ref[i]= NULL;
         }
     }
     h-&gt;long_ref_count=0;
 
     for(i=0; i&lt;h-&gt;short_ref_count; i++){
-        unreference_pic(h, h-&gt;short_ref[i]);
+        unreference_pic(h, h-&gt;short_ref[i], 0);
         h-&gt;short_ref[i]= NULL;
     }
     h-&gt;short_ref_count=0;
@@ -3855,7 +3319,7 @@
 static void flush_dpb(AVCodecContext *avctx){
     H264Context *h= avctx-&gt;priv_data;
     int i;
-    for(i=0; i&lt;16; i++) {
+    for(i=0; i&lt;MAX_DELAYED_PIC_COUNT; i++) {
         if(h-&gt;delayed_pic[i])
             h-&gt;delayed_pic[i]-&gt;reference= 0;
         h-&gt;delayed_pic[i]= NULL;
@@ -3866,27 +3330,28 @@
     idr(h);
     if(h-&gt;s.current_picture_ptr)
         h-&gt;s.current_picture_ptr-&gt;reference= 0;
+    h-&gt;s.first_field= 0;
+    ff_mpeg_flush(avctx);
 }
 
 /**
- *
- * @return the removed picture or NULL if an error occurs
+ * Find a Picture in the short term reference list by frame number.
+ * @param frame_num frame number to search for
+ * @param idx the index into h-&gt;short_ref where returned picture is found
+ *            undefined if no picture found.
+ * @return pointer to the found picture, or NULL if no pic with the provided
+ *                 frame number is found
  */
-static Picture * remove_short(H264Context *h, int frame_num){
+static Picture * find_short(H264Context *h, int frame_num, int *idx){
     MpegEncContext * const s = &amp;h-&gt;s;
     int i;
 
-    if(s-&gt;avctx-&gt;debug&amp;FF_DEBUG_MMCO)
-        av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;remove short %d count %d\n&quot;, frame_num, h-&gt;short_ref_count);
-
     for(i=0; i&lt;h-&gt;short_ref_count; i++){
         Picture *pic= h-&gt;short_ref[i];
         if(s-&gt;avctx-&gt;debug&amp;FF_DEBUG_MMCO)
             av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;%d %d %p\n&quot;, i, pic-&gt;frame_num, pic);
-        if(pic-&gt;frame_num == frame_num){
-            h-&gt;short_ref[i]= NULL;
-            memmove(&amp;h-&gt;short_ref[i], &amp;h-&gt;short_ref[i+1], (h-&gt;short_ref_count - i - 1)*sizeof(Picture*));
-            h-&gt;short_ref_count--;
+        if(pic-&gt;frame_num == frame_num) {
+            *idx = i;
             return pic;
         }
     }
@@ -3894,15 +3359,58 @@
 }
 
 /**
+ * Remove a picture from the short term reference list by its index in
+ * that list.  This does no checking on the provided index; it is assumed
+ * to be valid. Other list entries are shifted down.
+ * @param i index into h-&gt;short_ref of picture to remove.
+ */
+static void remove_short_at_index(H264Context *h, int i){
+    assert(i &gt;= 0 &amp;&amp; i &lt; h-&gt;short_ref_count);
+    h-&gt;short_ref[i]= NULL;
+    if (--h-&gt;short_ref_count)
+        memmove(&amp;h-&gt;short_ref[i], &amp;h-&gt;short_ref[i+1], (h-&gt;short_ref_count - i)*sizeof(Picture*));
+}
+
+/**
  *
  * @return the removed picture or NULL if an error occurs
  */
+static Picture * remove_short(H264Context *h, int frame_num){
+    MpegEncContext * const s = &amp;h-&gt;s;
+    Picture *pic;
+    int i;
+
+    if(s-&gt;avctx-&gt;debug&amp;FF_DEBUG_MMCO)
+        av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;remove short %d count %d\n&quot;, frame_num, h-&gt;short_ref_count);
+
+    pic = find_short(h, frame_num, &amp;i);
+    if (pic)
+        remove_short_at_index(h, i);
+
+    return pic;
+}
+
+/**
+ * Remove a picture from the long term reference list by its index in
+ * that list.  This does no checking on the provided index; it is assumed
+ * to be valid. The removed entry is set to NULL. Other entries are unaffected.
+ * @param i index into h-&gt;long_ref of picture to remove.
+ */
+static void remove_long_at_index(H264Context *h, int i){
+    h-&gt;long_ref[i]= NULL;
+    h-&gt;long_ref_count--;
+}
+
+/**
+ *
+ * @return the removed picture or NULL if an error occurs
+ */
 static Picture * remove_long(H264Context *h, int i){
     Picture *pic;
 
     pic= h-&gt;long_ref[i];
-    h-&gt;long_ref[i]= NULL;
-    if(pic) h-&gt;long_ref_count--;
+    if (pic)
+        remove_long_at_index(h, i);
 
     return pic;
 }
@@ -3943,77 +3451,143 @@
 static int execute_ref_pic_marking(H264Context *h, MMCO *mmco, int mmco_count){
     MpegEncContext * const s = &amp;h-&gt;s;
     int i, j;
-    int current_is_long=0;
+    int current_ref_assigned=0;
     Picture *pic;
 
     if((s-&gt;avctx-&gt;debug&amp;FF_DEBUG_MMCO) &amp;&amp; mmco_count==0)
         av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;no mmco here\n&quot;);
 
     for(i=0; i&lt;mmco_count; i++){
+        int structure, frame_num, unref_pic;
         if(s-&gt;avctx-&gt;debug&amp;FF_DEBUG_MMCO)
-            av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;mmco:%d %d %d\n&quot;, h-&gt;mmco[i].opcode, h-&gt;mmco[i].short_frame_num, h-&gt;mmco[i].long_index);
+            av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;mmco:%d %d %d\n&quot;, h-&gt;mmco[i].opcode, h-&gt;mmco[i].short_pic_num, h-&gt;mmco[i].long_arg);
 
         switch(mmco[i].opcode){
         case MMCO_SHORT2UNUSED:
-            pic= remove_short(h, mmco[i].short_frame_num);
-            if(pic)
-                unreference_pic(h, pic);
-            else if(s-&gt;avctx-&gt;debug&amp;FF_DEBUG_MMCO)
-                av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;mmco: remove_short() failure\n&quot;);
+            if(s-&gt;avctx-&gt;debug&amp;FF_DEBUG_MMCO)
+                av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;mmco: unref short %d count %d\n&quot;, h-&gt;mmco[i].short_pic_num, h-&gt;short_ref_count);
+            frame_num = pic_num_extract(h, mmco[i].short_pic_num, &amp;structure);
+            pic = find_short(h, frame_num, &amp;j);
+            if (pic) {
+                if (unreference_pic(h, pic, structure ^ PICT_FRAME))
+                    remove_short_at_index(h, j);
+            } else if(s-&gt;avctx-&gt;debug&amp;FF_DEBUG_MMCO)
+                av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;mmco: unref short failure\n&quot;);
             break;
         case MMCO_SHORT2LONG:
-            pic= remove_long(h, mmco[i].long_index);
-            if(pic) unreference_pic(h, pic);
+            if (FIELD_PICTURE &amp;&amp; mmco[i].long_arg &lt; h-&gt;long_ref_count &amp;&amp;
+                    h-&gt;long_ref[mmco[i].long_arg]-&gt;frame_num ==
+                                              mmco[i].short_pic_num / 2) {
+                /* do nothing, we've already moved this field pair. */
+            } else {
+                int frame_num = mmco[i].short_pic_num &gt;&gt; FIELD_PICTURE;
 
-            h-&gt;long_ref[ mmco[i].long_index ]= remove_short(h, mmco[i].short_frame_num);
-            if (h-&gt;long_ref[ mmco[i].long_index ]){
-                h-&gt;long_ref[ mmco[i].long_index ]-&gt;long_ref=1;
-                h-&gt;long_ref_count++;
+                pic= remove_long(h, mmco[i].long_arg);
+                if(pic) unreference_pic(h, pic, 0);
+
+                h-&gt;long_ref[ mmco[i].long_arg ]= remove_short(h, frame_num);
+                if (h-&gt;long_ref[ mmco[i].long_arg ]){
+                    h-&gt;long_ref[ mmco[i].long_arg ]-&gt;long_ref=1;
+                    h-&gt;long_ref_count++;
+                }
             }
             break;
         case MMCO_LONG2UNUSED:
-            pic= remove_long(h, mmco[i].long_index);
-            if(pic)
-                unreference_pic(h, pic);
-            else if(s-&gt;avctx-&gt;debug&amp;FF_DEBUG_MMCO)
-                av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;mmco: remove_long() failure\n&quot;);
+            j = pic_num_extract(h, mmco[i].long_arg, &amp;structure);
+            pic = h-&gt;long_ref[j];
+            if (pic) {
+                if (unreference_pic(h, pic, structure ^ PICT_FRAME))
+                    remove_long_at_index(h, j);
+            } else if(s-&gt;avctx-&gt;debug&amp;FF_DEBUG_MMCO)
+                av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;mmco: unref long failure\n&quot;);
             break;
         case MMCO_LONG:
-            pic= remove_long(h, mmco[i].long_index);
-            if(pic) unreference_pic(h, pic);
+            unref_pic = 1;
+            if (FIELD_PICTURE &amp;&amp; !s-&gt;first_field) {
+                if (h-&gt;long_ref[mmco[i].long_arg] == s-&gt;current_picture_ptr) {
+                    /* Just mark second field as referenced */
+                    unref_pic = 0;
+                } else if (s-&gt;current_picture_ptr-&gt;reference) {
+                    /* First field in pair is in short term list or
+                     * at a different long term index.
+                     * This is not allowed; see 7.4.3, notes 2 and 3.
+                     * Report the problem and keep the pair where it is,
+                     * and mark this field valid.
+                     */
+                    av_log(h-&gt;s.avctx, AV_LOG_ERROR,
+                        &quot;illegal long term reference assignment for second &quot;
+                        &quot;field in complementary field pair (first field is &quot;
+                        &quot;short term or has non-matching long index)\n&quot;);
+                    unref_pic = 0;
+                }
+            }
 
-            h-&gt;long_ref[ mmco[i].long_index ]= s-&gt;current_picture_ptr;
-            h-&gt;long_ref[ mmco[i].long_index ]-&gt;long_ref=1;
-            h-&gt;long_ref_count++;
+            if (unref_pic) {
+                pic= remove_long(h, mmco[i].long_arg);
+                if(pic) unreference_pic(h, pic, 0);
 
-            current_is_long=1;
+                h-&gt;long_ref[ mmco[i].long_arg ]= s-&gt;current_picture_ptr;
+                h-&gt;long_ref[ mmco[i].long_arg ]-&gt;long_ref=1;
+                h-&gt;long_ref_count++;
+            }
+
+            s-&gt;current_picture_ptr-&gt;reference |= s-&gt;picture_structure;
+            current_ref_assigned=1;
             break;
         case MMCO_SET_MAX_LONG:
-            assert(mmco[i].long_index &lt;= 16);
+            assert(mmco[i].long_arg &lt;= 16);
             // just remove the long term which index is greater than new max
-            for(j = mmco[i].long_index; j&lt;16; j++){
+            for(j = mmco[i].long_arg; j&lt;16; j++){
                 pic = remove_long(h, j);
-                if (pic) unreference_pic(h, pic);
+                if (pic) unreference_pic(h, pic, 0);
             }
             break;
         case MMCO_RESET:
             while(h-&gt;short_ref_count){
                 pic= remove_short(h, h-&gt;short_ref[0]-&gt;frame_num);
-                if(pic) unreference_pic(h, pic);
+                if(pic) unreference_pic(h, pic, 0);
             }
             for(j = 0; j &lt; 16; j++) {
                 pic= remove_long(h, j);
-                if(pic) unreference_pic(h, pic);
+                if(pic) unreference_pic(h, pic, 0);
             }
             break;
         default: assert(0);
         }
     }
 
-    if(!current_is_long){
+    if (!current_ref_assigned &amp;&amp; FIELD_PICTURE &amp;&amp;
+            !s-&gt;first_field &amp;&amp; s-&gt;current_picture_ptr-&gt;reference) {
+
+        /* Second field of complementary field pair; the first field of
+         * which is already referenced. If short referenced, it
+         * should be first entry in short_ref. If not, it must exist
+         * in long_ref; trying to put it on the short list here is an
+         * error in the encoded bit stream (ref: 7.4.3, NOTE 2 and 3).
+         */
+        if (h-&gt;short_ref_count &amp;&amp; h-&gt;short_ref[0] == s-&gt;current_picture_ptr) {
+            /* Just mark the second field valid */
+            s-&gt;current_picture_ptr-&gt;reference = PICT_FRAME;
+        } else if (s-&gt;current_picture_ptr-&gt;long_ref) {
+            av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;illegal short term reference &quot;
+                                             &quot;assignment for second field &quot;
+                                             &quot;in complementary field pair &quot;
+                                             &quot;(first field is long term)\n&quot;);
+        } else {
+            /*
+             * First field in reference, but not in any sensible place on our
+             * reference lists. This shouldn't happen unless reference
+             * handling somewhere else is wrong.
+             */
+            assert(0);
+        }
+        current_ref_assigned = 1;
+    }
+
+    if(!current_ref_assigned){
         pic= remove_short(h, s-&gt;current_picture_ptr-&gt;frame_num);
         if(pic){
-            unreference_pic(h, pic);
+            unreference_pic(h, pic, 0);
             av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;illegal short term buffer state detected\n&quot;);
         }
 
@@ -4023,8 +3597,34 @@
         h-&gt;short_ref[0]= s-&gt;current_picture_ptr;
         h-&gt;short_ref[0]-&gt;long_ref=0;
         h-&gt;short_ref_count++;
+        s-&gt;current_picture_ptr-&gt;reference |= s-&gt;picture_structure;
     }
 
+    if (h-&gt;long_ref_count + h-&gt;short_ref_count &gt; h-&gt;sps.ref_frame_count){
+
+        /* We have too many reference frames, probably due to corrupted
+         * stream. Need to discard one frame. Prevents overrun of the
+         * short_ref and long_ref buffers.
+         */
+        av_log(h-&gt;s.avctx, AV_LOG_ERROR,
+               &quot;number of reference frames exceeds max (probably &quot;
+               &quot;corrupt input), discarding one\n&quot;);
+
+        if (h-&gt;long_ref_count) {
+            for (i = 0; i &lt; 16; ++i)
+                if (h-&gt;long_ref[i])
+                    break;
+
+            assert(i &lt; 16);
+            pic = h-&gt;long_ref[i];
+            remove_long_at_index(h, i);
+        } else {
+            pic = h-&gt;short_ref[h-&gt;short_ref_count - 1];
+            remove_short_at_index(h, h-&gt;short_ref_count - 1);
+        }
+        unreference_pic(h, pic, 0);
+    }
+
     print_short_term(h);
     print_long_term(h);
     return 0;
@@ -4036,8 +3636,8 @@
 
     if(h-&gt;nal_unit_type == NAL_IDR_SLICE){ //FIXME fields
         s-&gt;broken_link= get_bits1(gb) -1;
-        h-&gt;mmco[0].long_index= get_bits1(gb) - 1; // current_long_term_idx
-        if(h-&gt;mmco[0].long_index == -1)
+        h-&gt;mmco[0].long_arg= get_bits1(gb) - 1; // current_long_term_idx
+        if(h-&gt;mmco[0].long_arg == -1)
             h-&gt;mmco_index= 0;
         else{
             h-&gt;mmco[0].opcode= MMCO_LONG;
@@ -4050,19 +3650,19 @@
 
                 h-&gt;mmco[i].opcode= opcode;
                 if(opcode==MMCO_SHORT2UNUSED || opcode==MMCO_SHORT2LONG){
-                    h-&gt;mmco[i].short_frame_num= (h-&gt;frame_num - get_ue_golomb(gb) - 1) &amp; ((1&lt;&lt;h-&gt;sps.log2_max_frame_num)-1); //FIXME fields
-/*                    if(h-&gt;mmco[i].short_frame_num &gt;= h-&gt;short_ref_count || h-&gt;short_ref[ h-&gt;mmco[i].short_frame_num ] == NULL){
+                    h-&gt;mmco[i].short_pic_num= (h-&gt;curr_pic_num - get_ue_golomb(gb) - 1) &amp; (h-&gt;max_pic_num - 1);
+/*                    if(h-&gt;mmco[i].short_pic_num &gt;= h-&gt;short_ref_count || h-&gt;short_ref[ h-&gt;mmco[i].short_pic_num ] == NULL){
                         av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;illegal short ref in memory management control operation %d\n&quot;, mmco);
                         return -1;
                     }*/
                 }
                 if(opcode==MMCO_SHORT2LONG || opcode==MMCO_LONG2UNUSED || opcode==MMCO_LONG || opcode==MMCO_SET_MAX_LONG){
-                    unsigned int long_index= get_ue_golomb(gb);
-                    if(/*h-&gt;mmco[i].long_index &gt;= h-&gt;long_ref_count || h-&gt;long_ref[ h-&gt;mmco[i].long_index ] == NULL*/ long_index &gt;= 16){
+                    unsigned int long_arg= get_ue_golomb(gb);
+                    if(long_arg &gt;= 32 || (long_arg &gt;= 16 &amp;&amp; !(opcode == MMCO_LONG2UNUSED &amp;&amp; FIELD_PICTURE))){
                         av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;illegal long ref in memory management control operation %d\n&quot;, opcode);
                         return -1;
                     }
-                    h-&gt;mmco[i].long_index= long_index;
+                    h-&gt;mmco[i].long_arg= long_arg;
                 }
 
                 if(opcode &gt; (unsigned)MMCO_LONG){
@@ -4076,10 +3676,17 @@
         }else{
             assert(h-&gt;long_ref_count + h-&gt;short_ref_count &lt;= h-&gt;sps.ref_frame_count);
 
-            if(h-&gt;long_ref_count + h-&gt;short_ref_count == h-&gt;sps.ref_frame_count){ //FIXME fields
+            if(h-&gt;short_ref_count &amp;&amp; h-&gt;long_ref_count + h-&gt;short_ref_count == h-&gt;sps.ref_frame_count &amp;&amp;
+                    !(FIELD_PICTURE &amp;&amp; !s-&gt;first_field &amp;&amp; s-&gt;current_picture_ptr-&gt;reference)) {
                 h-&gt;mmco[0].opcode= MMCO_SHORT2UNUSED;
-                h-&gt;mmco[0].short_frame_num= h-&gt;short_ref[ h-&gt;short_ref_count - 1 ]-&gt;frame_num;
+                h-&gt;mmco[0].short_pic_num= h-&gt;short_ref[ h-&gt;short_ref_count - 1 ]-&gt;frame_num;
                 h-&gt;mmco_index= 1;
+                if (FIELD_PICTURE) {
+                    h-&gt;mmco[0].short_pic_num *= 2;
+                    h-&gt;mmco[1].opcode= MMCO_SHORT2UNUSED;
+                    h-&gt;mmco[1].short_pic_num= h-&gt;mmco[0].short_pic_num + 1;
+                    h-&gt;mmco_index= 2;
+                }
             }else
                 h-&gt;mmco_index= 0;
         }
@@ -4167,12 +3774,18 @@
         field_poc[1]= poc;
     }
 
-    if(s-&gt;picture_structure != PICT_BOTTOM_FIELD)
+    if(s-&gt;picture_structure != PICT_BOTTOM_FIELD) {
         s-&gt;current_picture_ptr-&gt;field_poc[0]= field_poc[0];
-    if(s-&gt;picture_structure != PICT_TOP_FIELD)
+        s-&gt;current_picture_ptr-&gt;poc = field_poc[0];
+    }
+    if(s-&gt;picture_structure != PICT_TOP_FIELD) {
         s-&gt;current_picture_ptr-&gt;field_poc[1]= field_poc[1];
-    if(s-&gt;picture_structure == PICT_FRAME) // FIXME field pix?
-        s-&gt;current_picture_ptr-&gt;poc= FFMIN(field_poc[0], field_poc[1]);
+        s-&gt;current_picture_ptr-&gt;poc = field_poc[1];
+    }
+    if(!FIELD_PICTURE || !s-&gt;first_field) {
+        Picture *cur = s-&gt;current_picture_ptr;
+        cur-&gt;poc= FFMIN(cur-&gt;field_poc[0], cur-&gt;field_poc[1]);
+    }
 
     return 0;
 }
@@ -4226,27 +3839,70 @@
         h-&gt;field_scan8x8_cavlc_q0  = h-&gt;field_scan8x8_cavlc;
     }
 }
+
 /**
+ * Replicates H264 &quot;master&quot; context to thread contexts.
+ */
+static void clone_slice(H264Context *dst, H264Context *src)
+{
+    memcpy(dst-&gt;block_offset,     src-&gt;block_offset, sizeof(dst-&gt;block_offset));
+    dst-&gt;s.current_picture_ptr  = src-&gt;s.current_picture_ptr;
+    dst-&gt;s.current_picture      = src-&gt;s.current_picture;
+    dst-&gt;s.linesize             = src-&gt;s.linesize;
+    dst-&gt;s.uvlinesize           = src-&gt;s.uvlinesize;
+    dst-&gt;s.first_field          = src-&gt;s.first_field;
+
+    dst-&gt;prev_poc_msb           = src-&gt;prev_poc_msb;
+    dst-&gt;prev_poc_lsb           = src-&gt;prev_poc_lsb;
+    dst-&gt;prev_frame_num_offset  = src-&gt;prev_frame_num_offset;
+    dst-&gt;prev_frame_num         = src-&gt;prev_frame_num;
+    dst-&gt;short_ref_count        = src-&gt;short_ref_count;
+
+    memcpy(dst-&gt;short_ref,        src-&gt;short_ref,        sizeof(dst-&gt;short_ref));
+    memcpy(dst-&gt;long_ref,         src-&gt;long_ref,         sizeof(dst-&gt;long_ref));
+    memcpy(dst-&gt;default_ref_list, src-&gt;default_ref_list, sizeof(dst-&gt;default_ref_list));
+    memcpy(dst-&gt;ref_list,         src-&gt;ref_list,         sizeof(dst-&gt;ref_list));
+
+    memcpy(dst-&gt;dequant4_coeff,   src-&gt;dequant4_coeff,   sizeof(src-&gt;dequant4_coeff));
+    memcpy(dst-&gt;dequant8_coeff,   src-&gt;dequant8_coeff,   sizeof(src-&gt;dequant8_coeff));
+}
+
+/**
  * decodes a slice header.
- * this will allso call MPV_common_init() and frame_start() as needed
+ * This will also call MPV_common_init() and frame_start() as needed.
+ *
+ * @param h h264context
+ * @param h0 h264 master context (differs from 'h' when doing sliced based parallel decoding)
+ *
+ * @return 0 if okay, &lt;0 if an error occurred, 1 if decoding must not be multithreaded
  */
-static int decode_slice_header(H264Context *h){
+static int decode_slice_header(H264Context *h, H264Context *h0){
     MpegEncContext * const s = &amp;h-&gt;s;
+    MpegEncContext * const s0 = &amp;h0-&gt;s;
     unsigned int first_mb_in_slice;
     unsigned int pps_id;
     int num_ref_idx_active_override_flag;
-    static const uint8_t slice_type_map[5]= {P_TYPE, B_TYPE, I_TYPE, SP_TYPE, SI_TYPE};
-    unsigned int slice_type, tmp;
+    static const uint8_t slice_type_map[5]= {FF_P_TYPE, FF_B_TYPE, FF_I_TYPE, FF_SP_TYPE, FF_SI_TYPE};
+    unsigned int slice_type, tmp, i;
     int default_ref_list_done = 0;
+    int last_pic_structure;
 
-    s-&gt;current_picture.reference= h-&gt;nal_ref_idc != 0;
     s-&gt;dropable= h-&gt;nal_ref_idc == 0;
 
+    if((s-&gt;avctx-&gt;flags2 &amp; CODEC_FLAG2_FAST) &amp;&amp; !h-&gt;nal_ref_idc){
+        s-&gt;me.qpel_put= s-&gt;dsp.put_2tap_qpel_pixels_tab;
+        s-&gt;me.qpel_avg= s-&gt;dsp.avg_2tap_qpel_pixels_tab;
+    }else{
+        s-&gt;me.qpel_put= s-&gt;dsp.put_h264_qpel_pixels_tab;
+        s-&gt;me.qpel_avg= s-&gt;dsp.avg_h264_qpel_pixels_tab;
+    }
+
     first_mb_in_slice= get_ue_golomb(&amp;s-&gt;gb);
 
     if((s-&gt;flags2 &amp; CODEC_FLAG2_CHUNKS) &amp;&amp; first_mb_in_slice == 0){
-        h-&gt;slice_num = 0;
-        s-&gt;current_picture_ptr= NULL;
+        h0-&gt;current_slice = 0;
+        if (!s0-&gt;first_field)
+            s-&gt;current_picture_ptr= NULL;
     }
 
     slice_type= get_ue_golomb(&amp;s-&gt;gb);
@@ -4261,32 +3917,37 @@
         h-&gt;slice_type_fixed=0;
 
     slice_type= slice_type_map[ slice_type ];
-    if (slice_type == I_TYPE
-        || (h-&gt;slice_num != 0 &amp;&amp; slice_type == h-&gt;slice_type) ) {
+    if (slice_type == FF_I_TYPE
+        || (h0-&gt;current_slice != 0 &amp;&amp; slice_type == h0-&gt;last_slice_type) ) {
         default_ref_list_done = 1;
     }
     h-&gt;slice_type= slice_type;
 
     s-&gt;pict_type= h-&gt;slice_type; // to make a few old func happy, it's wrong though
+    if (s-&gt;pict_type == FF_B_TYPE &amp;&amp; s0-&gt;last_picture_ptr == NULL) {
+        av_log(h-&gt;s.avctx, AV_LOG_ERROR,
+               &quot;B picture before any references, skipping\n&quot;);
+        return -1;
+    }
 
     pps_id= get_ue_golomb(&amp;s-&gt;gb);
     if(pps_id&gt;=MAX_PPS_COUNT){
         av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;pps_id out of range\n&quot;);
         return -1;
     }
-    if(!h-&gt;pps_buffers[pps_id]) {
+    if(!h0-&gt;pps_buffers[pps_id]) {
         av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;non existing PPS referenced\n&quot;);
         return -1;
     }
-    h-&gt;pps= *h-&gt;pps_buffers[pps_id];
+    h-&gt;pps= *h0-&gt;pps_buffers[pps_id];
 
-    if(!h-&gt;sps_buffers[h-&gt;pps.sps_id]) {
+    if(!h0-&gt;sps_buffers[h-&gt;pps.sps_id]) {
         av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;non existing SPS referenced\n&quot;);
         return -1;
     }
-    h-&gt;sps = *h-&gt;sps_buffers[h-&gt;pps.sps_id];
+    h-&gt;sps = *h0-&gt;sps_buffers[h-&gt;pps.sps_id];
 
-    if(h-&gt;dequant_coeff_pps != pps_id){
+    if(h == h0 &amp;&amp; h-&gt;dequant_coeff_pps != pps_id){
         h-&gt;dequant_coeff_pps = pps_id;
         init_dequant_tables(h);
     }
@@ -4297,24 +3958,44 @@
     h-&gt;b_stride=  s-&gt;mb_width*4;
     h-&gt;b8_stride= s-&gt;mb_width*2;
 
-    s-&gt;width = 16*s-&gt;mb_width - 2*(h-&gt;sps.crop_left + h-&gt;sps.crop_right );
+    s-&gt;width = 16*s-&gt;mb_width - 2*FFMIN(h-&gt;sps.crop_right, 7);
     if(h-&gt;sps.frame_mbs_only_flag)
-        s-&gt;height= 16*s-&gt;mb_height - 2*(h-&gt;sps.crop_top  + h-&gt;sps.crop_bottom);
+        s-&gt;height= 16*s-&gt;mb_height - 2*FFMIN(h-&gt;sps.crop_bottom, 7);
     else
-        s-&gt;height= 16*s-&gt;mb_height - 4*(h-&gt;sps.crop_top  + h-&gt;sps.crop_bottom); //FIXME recheck
+        s-&gt;height= 16*s-&gt;mb_height - 4*FFMIN(h-&gt;sps.crop_bottom, 3);
 
     if (s-&gt;context_initialized
         &amp;&amp; (   s-&gt;width != s-&gt;avctx-&gt;width || s-&gt;height != s-&gt;avctx-&gt;height)) {
+        if(h != h0)
+            return -1;   // width / height changed during parallelized decoding
         free_tables(h);
         MPV_common_end(s);
     }
     if (!s-&gt;context_initialized) {
+        if(h != h0)
+            return -1;  // we cant (re-)initialize context during parallel decoding
         if (MPV_common_init(s) &lt; 0)
             return -1;
+        s-&gt;first_field = 0;
 
         init_scan_tables(h);
         alloc_tables(h);
 
+        for(i = 1; i &lt; s-&gt;avctx-&gt;thread_count; i++) {
+            H264Context *c;
+            c = h-&gt;thread_context[i] = av_malloc(sizeof(H264Context));
+            memcpy(c, h-&gt;s.thread_context[i], sizeof(MpegEncContext));
+            memset(&amp;c-&gt;s + 1, 0, sizeof(H264Context) - sizeof(MpegEncContext));
+            c-&gt;sps = h-&gt;sps;
+            c-&gt;pps = h-&gt;pps;
+            init_scan_tables(c);
+            clone_tables(c, h);
+        }
+
+        for(i = 0; i &lt; s-&gt;avctx-&gt;thread_count; i++)
+            if(context_init(h-&gt;thread_context[i]) &lt; 0)
+                return -1;
+
         s-&gt;avctx-&gt;width = s-&gt;width;
         s-&gt;avctx-&gt;height = s-&gt;height;
         s-&gt;avctx-&gt;sample_aspect_ratio= h-&gt;sps.sar;
@@ -4330,42 +4011,90 @@
         }
     }
 
-    if(h-&gt;slice_num == 0){
-        if(frame_start(h) &lt; 0)
-            return -1;
-    }
-
-    s-&gt;current_picture_ptr-&gt;frame_num= //FIXME frame_num cleanup
     h-&gt;frame_num= get_bits(&amp;s-&gt;gb, h-&gt;sps.log2_max_frame_num);
 
     h-&gt;mb_mbaff = 0;
     h-&gt;mb_aff_frame = 0;
+    last_pic_structure = s0-&gt;picture_structure;
     if(h-&gt;sps.frame_mbs_only_flag){
         s-&gt;picture_structure= PICT_FRAME;
     }else{
         if(get_bits1(&amp;s-&gt;gb)) { //field_pic_flag
             s-&gt;picture_structure= PICT_TOP_FIELD + get_bits1(&amp;s-&gt;gb); //bottom_field_flag
-            av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;PAFF interlacing is not implemented\n&quot;);
         } else {
             s-&gt;picture_structure= PICT_FRAME;
             h-&gt;mb_aff_frame = h-&gt;sps.mb_aff;
         }
     }
+
+    if(h0-&gt;current_slice == 0){
+        /* See if we have a decoded first field looking for a pair... */
+        if (s0-&gt;first_field) {
+            assert(s0-&gt;current_picture_ptr);
+            assert(s0-&gt;current_picture_ptr-&gt;data[0]);
+            assert(s0-&gt;current_picture_ptr-&gt;reference != DELAYED_PIC_REF);
+
+            /* figure out if we have a complementary field pair */
+            if (!FIELD_PICTURE || s-&gt;picture_structure == last_pic_structure) {
+                /*
+                 * Previous field is unmatched. Don't display it, but let it
+                 * remain for reference if marked as such.
+                 */
+                s0-&gt;current_picture_ptr = NULL;
+                s0-&gt;first_field = FIELD_PICTURE;
+
+            } else {
+                if (h-&gt;nal_ref_idc &amp;&amp;
+                        s0-&gt;current_picture_ptr-&gt;reference &amp;&amp;
+                        s0-&gt;current_picture_ptr-&gt;frame_num != h-&gt;frame_num) {
+                    /*
+                     * This and previous field were reference, but had
+                     * different frame_nums. Consider this field first in
+                     * pair. Throw away previous field except for reference
+                     * purposes.
+                     */
+                    s0-&gt;first_field = 1;
+                    s0-&gt;current_picture_ptr = NULL;
+
+                } else {
+                    /* Second field in complementary pair */
+                    s0-&gt;first_field = 0;
+                }
+            }
+
+        } else {
+            /* Frame or first field in a potentially complementary pair */
+            assert(!s0-&gt;current_picture_ptr);
+            s0-&gt;first_field = FIELD_PICTURE;
+        }
+
+        if((!FIELD_PICTURE || s0-&gt;first_field) &amp;&amp; frame_start(h) &lt; 0) {
+            s0-&gt;first_field = 0;
+            return -1;
+        }
+    }
+    if(h != h0)
+        clone_slice(h, h0);
+
+    s-&gt;current_picture_ptr-&gt;frame_num= h-&gt;frame_num; //FIXME frame_num cleanup
+
     assert(s-&gt;mb_num == s-&gt;mb_width * s-&gt;mb_height);
-    if(first_mb_in_slice &lt;&lt; h-&gt;mb_aff_frame &gt;= s-&gt;mb_num ||
+    if(first_mb_in_slice &lt;&lt; FIELD_OR_MBAFF_PICTURE &gt;= s-&gt;mb_num ||
        first_mb_in_slice                    &gt;= s-&gt;mb_num){
         av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;first_mb_in_slice overflow\n&quot;);
         return -1;
     }
     s-&gt;resync_mb_x = s-&gt;mb_x = first_mb_in_slice % s-&gt;mb_width;
-    s-&gt;resync_mb_y = s-&gt;mb_y = (first_mb_in_slice / s-&gt;mb_width) &lt;&lt; h-&gt;mb_aff_frame;
+    s-&gt;resync_mb_y = s-&gt;mb_y = (first_mb_in_slice / s-&gt;mb_width) &lt;&lt; FIELD_OR_MBAFF_PICTURE;
+    if (s-&gt;picture_structure == PICT_BOTTOM_FIELD)
+        s-&gt;resync_mb_y = s-&gt;mb_y = s-&gt;mb_y + 1;
     assert(s-&gt;mb_y &lt; s-&gt;mb_height);
 
     if(s-&gt;picture_structure==PICT_FRAME){
         h-&gt;curr_pic_num=   h-&gt;frame_num;
         h-&gt;max_pic_num= 1&lt;&lt; h-&gt;sps.log2_max_frame_num;
     }else{
-        h-&gt;curr_pic_num= 2*h-&gt;frame_num;
+        h-&gt;curr_pic_num= 2*h-&gt;frame_num + 1;
         h-&gt;max_pic_num= 1&lt;&lt;(h-&gt;sps.log2_max_frame_num + 1);
     }
 
@@ -4398,17 +4127,17 @@
     h-&gt;ref_count[0]= h-&gt;pps.ref_count[0];
     h-&gt;ref_count[1]= h-&gt;pps.ref_count[1];
 
-    if(h-&gt;slice_type == P_TYPE || h-&gt;slice_type == SP_TYPE || h-&gt;slice_type == B_TYPE){
-        if(h-&gt;slice_type == B_TYPE){
+    if(h-&gt;slice_type == FF_P_TYPE || h-&gt;slice_type == FF_SP_TYPE || h-&gt;slice_type == FF_B_TYPE){
+        if(h-&gt;slice_type == FF_B_TYPE){
             h-&gt;direct_spatial_mv_pred= get_bits1(&amp;s-&gt;gb);
-            if(h-&gt;sps.mb_aff &amp;&amp; h-&gt;direct_spatial_mv_pred)
-                av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;MBAFF + spatial direct mode is not implemented\n&quot;);
+            if(FIELD_PICTURE &amp;&amp; h-&gt;direct_spatial_mv_pred)
+                av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;PAFF + spatial direct mode is not implemented\n&quot;);
         }
         num_ref_idx_active_override_flag= get_bits1(&amp;s-&gt;gb);
 
         if(num_ref_idx_active_override_flag){
             h-&gt;ref_count[0]= get_ue_golomb(&amp;s-&gt;gb) + 1;
-            if(h-&gt;slice_type==B_TYPE)
+            if(h-&gt;slice_type==FF_B_TYPE)
                 h-&gt;ref_count[1]= get_ue_golomb(&amp;s-&gt;gb) + 1;
 
             if(h-&gt;ref_count[0]-1 &gt; 32-1 || h-&gt;ref_count[1]-1 &gt; 32-1){
@@ -4417,7 +4146,7 @@
                 return -1;
             }
         }
-        if(h-&gt;slice_type == B_TYPE)
+        if(h-&gt;slice_type == FF_B_TYPE)
             h-&gt;list_count= 2;
         else
             h-&gt;list_count= 1;
@@ -4431,21 +4160,21 @@
     if(decode_ref_pic_list_reordering(h) &lt; 0)
         return -1;
 
-    if(   (h-&gt;pps.weighted_pred          &amp;&amp; (h-&gt;slice_type == P_TYPE || h-&gt;slice_type == SP_TYPE ))
-       || (h-&gt;pps.weighted_bipred_idc==1 &amp;&amp; h-&gt;slice_type==B_TYPE ) )
+    if(   (h-&gt;pps.weighted_pred          &amp;&amp; (h-&gt;slice_type == FF_P_TYPE || h-&gt;slice_type == FF_SP_TYPE ))
+       || (h-&gt;pps.weighted_bipred_idc==1 &amp;&amp; h-&gt;slice_type==FF_B_TYPE ) )
         pred_weight_table(h);
-    else if(h-&gt;pps.weighted_bipred_idc==2 &amp;&amp; h-&gt;slice_type==B_TYPE)
+    else if(h-&gt;pps.weighted_bipred_idc==2 &amp;&amp; h-&gt;slice_type==FF_B_TYPE)
         implicit_weight_table(h);
     else
         h-&gt;use_weight = 0;
 
-    if(s-&gt;current_picture.reference)
-        decode_ref_pic_marking(h, &amp;s-&gt;gb);
+    if(h-&gt;nal_ref_idc)
+        decode_ref_pic_marking(h0, &amp;s-&gt;gb);
 
     if(FRAME_MBAFF)
         fill_mbaff_ref_list(h);
 
-    if( h-&gt;slice_type != I_TYPE &amp;&amp; h-&gt;slice_type != SI_TYPE &amp;&amp; h-&gt;pps.cabac ){
+    if( h-&gt;slice_type != FF_I_TYPE &amp;&amp; h-&gt;slice_type != FF_SI_TYPE &amp;&amp; h-&gt;pps.cabac ){
         tmp = get_ue_golomb(&amp;s-&gt;gb);
         if(tmp &gt; 2){
             av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;cabac_init_idc overflow\n&quot;);
@@ -4464,10 +4193,10 @@
     h-&gt;chroma_qp[0] = get_chroma_qp(h, 0, s-&gt;qscale);
     h-&gt;chroma_qp[1] = get_chroma_qp(h, 1, s-&gt;qscale);
     //FIXME qscale / qp ... stuff
-    if(h-&gt;slice_type == SP_TYPE){
+    if(h-&gt;slice_type == FF_SP_TYPE){
         get_bits1(&amp;s-&gt;gb); /* sp_for_switch_flag */
     }
-    if(h-&gt;slice_type==SP_TYPE || h-&gt;slice_type == SI_TYPE){
+    if(h-&gt;slice_type==FF_SP_TYPE || h-&gt;slice_type == FF_SI_TYPE){
         get_se_golomb(&amp;s-&gt;gb); /* slice_qs_delta */
     }
 
@@ -4489,24 +4218,42 @@
             h-&gt;slice_beta_offset = get_se_golomb(&amp;s-&gt;gb) &lt;&lt; 1;
         }
     }
+
     if(   s-&gt;avctx-&gt;skip_loop_filter &gt;= AVDISCARD_ALL
-       ||(s-&gt;avctx-&gt;skip_loop_filter &gt;= AVDISCARD_NONKEY &amp;&amp; h-&gt;slice_type != I_TYPE)
-       ||(s-&gt;avctx-&gt;skip_loop_filter &gt;= AVDISCARD_BIDIR  &amp;&amp; h-&gt;slice_type == B_TYPE)
+       ||(s-&gt;avctx-&gt;skip_loop_filter &gt;= AVDISCARD_NONKEY &amp;&amp; h-&gt;slice_type != FF_I_TYPE)
+       ||(s-&gt;avctx-&gt;skip_loop_filter &gt;= AVDISCARD_BIDIR  &amp;&amp; h-&gt;slice_type == FF_B_TYPE)
        ||(s-&gt;avctx-&gt;skip_loop_filter &gt;= AVDISCARD_NONREF &amp;&amp; h-&gt;nal_ref_idc == 0))
         h-&gt;deblocking_filter= 0;
 
+    if(h-&gt;deblocking_filter == 1 &amp;&amp; h0-&gt;max_contexts &gt; 1) {
+        if(s-&gt;avctx-&gt;flags2 &amp; CODEC_FLAG2_FAST) {
+            /* Cheat slightly for speed:
+               Do not bother to deblock across slices. */
+            h-&gt;deblocking_filter = 2;
+        } else {
+            h0-&gt;max_contexts = 1;
+            if(!h0-&gt;single_decode_warning) {
+                av_log(s-&gt;avctx, AV_LOG_INFO, &quot;Cannot parallelize deblocking type 1, decoding such frames in sequential order\n&quot;);
+                h0-&gt;single_decode_warning = 1;
+            }
+            if(h != h0)
+                return 1; // deblocking switched inside frame
+        }
+    }
+
 #if 0 //FMO
     if( h-&gt;pps.num_slice_groups &gt; 1  &amp;&amp; h-&gt;pps.mb_slice_group_map_type &gt;= 3 &amp;&amp; h-&gt;pps.mb_slice_group_map_type &lt;= 5)
         slice_group_change_cycle= get_bits(&amp;s-&gt;gb, ?);
 #endif
 
-    h-&gt;slice_num++;
+    h0-&gt;last_slice_type = slice_type;
+    h-&gt;slice_num = ++h0-&gt;current_slice;
 
     h-&gt;emu_edge_width= (s-&gt;flags&amp;CODEC_FLAG_EMU_EDGE) ? 0 : 16;
-    h-&gt;emu_edge_height= FRAME_MBAFF ? 0 : h-&gt;emu_edge_width;
+    h-&gt;emu_edge_height= (FRAME_MBAFF || FIELD_PICTURE) ? 0 : h-&gt;emu_edge_width;
 
     if(s-&gt;avctx-&gt;debug&amp;FF_DEBUG_PICT_INFO){
-        av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;slice:%d %s mb:%d %c pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s\n&quot;,
+        av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;slice:%d %s mb:%d %c pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n&quot;,
                h-&gt;slice_num,
                (s-&gt;picture_structure==PICT_FRAME ? &quot;F&quot; : s-&gt;picture_structure==PICT_TOP_FIELD ? &quot;T&quot; : &quot;B&quot;),
                first_mb_in_slice,
@@ -4517,18 +4264,11 @@
                s-&gt;qscale,
                h-&gt;deblocking_filter, h-&gt;slice_alpha_c0_offset/2, h-&gt;slice_beta_offset/2,
                h-&gt;use_weight,
-               h-&gt;use_weight==1 &amp;&amp; h-&gt;use_weight_chroma ? &quot;c&quot; : &quot;&quot;
+               h-&gt;use_weight==1 &amp;&amp; h-&gt;use_weight_chroma ? &quot;c&quot; : &quot;&quot;,
+               h-&gt;slice_type == FF_B_TYPE ? (h-&gt;direct_spatial_mv_pred ? &quot;SPAT&quot; : &quot;TEMP&quot;) : &quot;&quot;
                );
     }
 
-    if((s-&gt;avctx-&gt;flags2 &amp; CODEC_FLAG2_FAST) &amp;&amp; !s-&gt;current_picture.reference){
-        s-&gt;me.qpel_put= s-&gt;dsp.put_2tap_qpel_pixels_tab;
-        s-&gt;me.qpel_avg= s-&gt;dsp.avg_2tap_qpel_pixels_tab;
-    }else{
-        s-&gt;me.qpel_put= s-&gt;dsp.put_h264_qpel_pixels_tab;
-        s-&gt;me.qpel_avg= s-&gt;dsp.avg_h264_qpel_pixels_tab;
-    }
-
     return 0;
 }
 
@@ -4570,7 +4310,7 @@
  * @param n block index
  * @param scantable scantable
  * @param max_coeff number of coefficients in the block
- * @return &lt;0 if an error occured
+ * @return &lt;0 if an error occurred
  */
 static int decode_residual(H264Context *h, GetBitContext *gb, DCTELEM *block, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff){
     MpegEncContext * const s = &amp;h-&gt;s;
@@ -4629,12 +4369,11 @@
                 level_code= (prefix&lt;&lt;suffix_length) + get_bits(gb, suffix_length); //part
             else
                 level_code= prefix + get_bits(gb, 4); //part
-        }else if(prefix==15){
-            level_code= (prefix&lt;&lt;suffix_length) + get_bits(gb, 12); //part
-            if(suffix_length==0) level_code+=15; //FIXME doesn't make (much)sense
         }else{
-            av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;prefix too large at %d %d\n&quot;, s-&gt;mb_x, s-&gt;mb_y);
-            return -1;
+            level_code= (15&lt;&lt;suffix_length) + get_bits(gb, prefix-3); //part
+            if(suffix_length==0) level_code+=15; //FIXME doesn't make (much)sense
+            if(prefix&gt;=16)
+                level_code += (1&lt;&lt;(prefix-3))-4096;
         }
 
         if(trailing_ones &lt; 3) level_code += 2;
@@ -4652,11 +4391,10 @@
             prefix = get_level_prefix(gb);
             if(prefix&lt;15){
                 level_code = (prefix&lt;&lt;suffix_length) + get_bits(gb, suffix_length);
-            }else if(prefix==15){
-                level_code =  (prefix&lt;&lt;suffix_length) + get_bits(gb, 12);
             }else{
-                av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;prefix too large at %d %d\n&quot;, s-&gt;mb_x, s-&gt;mb_y);
-                return -1;
+                level_code = (15&lt;&lt;suffix_length) + get_bits(gb, prefix-3);
+                if(prefix&gt;=16)
+                    level_code += (1&lt;&lt;(prefix-3))-4096;
             }
             mask= -(level_code&amp;1);
             level[i]= (((2+level_code)&gt;&gt;1) ^ mask) - mask;
@@ -4720,7 +4458,7 @@
 
 static void predict_field_decoding_flag(H264Context *h){
     MpegEncContext * const s = &amp;h-&gt;s;
-    const int mb_xy= s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+    const int mb_xy= h-&gt;mb_xy;
     int mb_type = (h-&gt;slice_table[mb_xy-1] == h-&gt;slice_num)
                 ? s-&gt;current_picture.mb_type[mb_xy-1]
                 : (h-&gt;slice_table[mb_xy-s-&gt;mb_stride] == h-&gt;slice_num)
@@ -4734,7 +4472,7 @@
  */
 static void decode_mb_skip(H264Context *h){
     MpegEncContext * const s = &amp;h-&gt;s;
-    const int mb_xy= s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+    const int mb_xy= h-&gt;mb_xy;
     int mb_type=0;
 
     memset(h-&gt;non_zero_count[mb_xy], 0, 16);
@@ -4743,7 +4481,7 @@
     if(MB_FIELD)
         mb_type|= MB_TYPE_INTERLACED;
 
-    if( h-&gt;slice_type == B_TYPE )
+    if( h-&gt;slice_type == FF_B_TYPE )
     {
         // just for fill_caches. pred_direct_motion will set the real mb_type
         mb_type|= MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2|MB_TYPE_SKIP;
@@ -4776,17 +4514,19 @@
  */
 static int decode_mb_cavlc(H264Context *h){
     MpegEncContext * const s = &amp;h-&gt;s;
-    const int mb_xy= s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+    int mb_xy;
     int partition_count;
     unsigned int mb_type, cbp;
     int dct8x8_allowed= h-&gt;pps.transform_8x8_mode;
 
+    mb_xy = h-&gt;mb_xy = s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+
     s-&gt;dsp.clear_blocks(h-&gt;mb); //FIXME avoid if already clear (move after skip handlong?
 
     tprintf(s-&gt;avctx, &quot;pic:%d mb:%d/%d\n&quot;, h-&gt;frame_num, s-&gt;mb_x, s-&gt;mb_y);
     cbp = 0; /* avoid warning. FIXME: find a solution without slowing
                 down the code */
-    if(h-&gt;slice_type != I_TYPE &amp;&amp; h-&gt;slice_type != SI_TYPE){
+    if(h-&gt;slice_type != FF_I_TYPE &amp;&amp; h-&gt;slice_type != FF_SI_TYPE){
         if(s-&gt;mb_skip_run==-1)
             s-&gt;mb_skip_run= get_ue_golomb(&amp;s-&gt;gb);
 
@@ -4810,7 +4550,7 @@
     h-&gt;prev_mb_skipped= 0;
 
     mb_type= get_ue_golomb(&amp;s-&gt;gb);
-    if(h-&gt;slice_type == B_TYPE){
+    if(h-&gt;slice_type == FF_B_TYPE){
         if(mb_type &lt; 23){
             partition_count= b_mb_type_info[mb_type].partition_count;
             mb_type=         b_mb_type_info[mb_type].type;
@@ -4818,7 +4558,7 @@
             mb_type -= 23;
             goto decode_intra_mb;
         }
-    }else if(h-&gt;slice_type == P_TYPE /*|| h-&gt;slice_type == SP_TYPE */){
+    }else if(h-&gt;slice_type == FF_P_TYPE /*|| h-&gt;slice_type == FF_SP_TYPE */){
         if(mb_type &lt; 5){
             partition_count= p_mb_type_info[mb_type].partition_count;
             mb_type=         p_mb_type_info[mb_type].type;
@@ -4827,7 +4567,7 @@
             goto decode_intra_mb;
         }
     }else{
-       assert(h-&gt;slice_type == I_TYPE);
+       assert(h-&gt;slice_type == FF_I_TYPE);
 decode_intra_mb:
         if(mb_type &gt; 25){
             av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;mb_type %d in %c slice too large at %d %d\n&quot;, mb_type, av_get_pict_type_char(h-&gt;slice_type), s-&gt;mb_x, s-&gt;mb_y);
@@ -4933,7 +4673,7 @@
     }else if(partition_count==4){
         int i, j, sub_partition_count[4], list, ref[2][4];
 
-        if(h-&gt;slice_type == B_TYPE){
+        if(h-&gt;slice_type == FF_B_TYPE){
             for(i=0; i&lt;4; i++){
                 h-&gt;sub_mb_type[i]= get_ue_golomb(&amp;s-&gt;gb);
                 if(h-&gt;sub_mb_type[i] &gt;=13){
@@ -4952,7 +4692,7 @@
                 h-&gt;ref_cache[1][scan8[12]] = PART_NOT_AVAILABLE;
             }
         }else{
-            assert(h-&gt;slice_type == P_TYPE || h-&gt;slice_type == SP_TYPE); //FIXME SP correct ?
+            assert(h-&gt;slice_type == FF_P_TYPE || h-&gt;slice_type == FF_SP_TYPE); //FIXME SP correct ?
             for(i=0; i&lt;4; i++){
                 h-&gt;sub_mb_type[i]= get_ue_golomb(&amp;s-&gt;gb);
                 if(h-&gt;sub_mb_type[i] &gt;=4){
@@ -5323,9 +5063,9 @@
 static int decode_cabac_mb_type( H264Context *h ) {
     MpegEncContext * const s = &amp;h-&gt;s;
 
-    if( h-&gt;slice_type == I_TYPE ) {
+    if( h-&gt;slice_type == FF_I_TYPE ) {
         return decode_cabac_intra_mb_type(h, 3, 1);
-    } else if( h-&gt;slice_type == P_TYPE ) {
+    } else if( h-&gt;slice_type == FF_P_TYPE ) {
         if( get_cabac_noinline( &amp;h-&gt;cabac, &amp;h-&gt;cabac_state[14] ) == 0 ) {
             /* P-type */
             if( get_cabac_noinline( &amp;h-&gt;cabac, &amp;h-&gt;cabac_state[15] ) == 0 ) {
@@ -5338,7 +5078,7 @@
         } else {
             return decode_cabac_intra_mb_type(h, 17, 0) + 5;
         }
-    } else if( h-&gt;slice_type == B_TYPE ) {
+    } else if( h-&gt;slice_type == FF_B_TYPE ) {
         const int mba_xy = h-&gt;left_mb_xy[0];
         const int mbb_xy = h-&gt;top_mb_xy;
         int ctx = 0;
@@ -5398,9 +5138,9 @@
         }else
             mbb_xy = mb_x + (mb_y-1)*s-&gt;mb_stride;
     }else{
-        int mb_xy = mb_x + mb_y*s-&gt;mb_stride;
+        int mb_xy = h-&gt;mb_xy;
         mba_xy = mb_xy - 1;
-        mbb_xy = mb_xy - s-&gt;mb_stride;
+        mbb_xy = mb_xy - (s-&gt;mb_stride &lt;&lt; FIELD_PICTURE);
     }
 
     if( h-&gt;slice_table[mba_xy] == h-&gt;slice_num &amp;&amp; !IS_SKIP( s-&gt;current_picture.mb_type[mba_xy] ))
@@ -5408,7 +5148,7 @@
     if( h-&gt;slice_table[mbb_xy] == h-&gt;slice_num &amp;&amp; !IS_SKIP( s-&gt;current_picture.mb_type[mbb_xy] ))
         ctx++;
 
-    if( h-&gt;slice_type == B_TYPE )
+    if( h-&gt;slice_type == FF_B_TYPE )
         ctx += 13;
     return get_cabac_noinline( &amp;h-&gt;cabac, &amp;h-&gt;cabac_state[11+ctx] );
 }
@@ -5453,65 +5193,20 @@
         return 3;
 }
 
-static const uint8_t block_idx_x[16] = {
-    0, 1, 0, 1, 2, 3, 2, 3, 0, 1, 0, 1, 2, 3, 2, 3
-};
-static const uint8_t block_idx_y[16] = {
-    0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3
-};
-static const uint8_t block_idx_xy[4][4] = {
-    { 0, 2, 8,  10},
-    { 1, 3, 9,  11},
-    { 4, 6, 12, 14},
-    { 5, 7, 13, 15}
-};
-
 static int decode_cabac_mb_cbp_luma( H264Context *h) {
-    int cbp = 0;
-    int cbp_b = -1;
-    int i8x8;
+    int cbp_b, cbp_a, ctx, cbp = 0;
 
-    if( h-&gt;slice_table[h-&gt;top_mb_xy] == h-&gt;slice_num ) {
-        cbp_b = h-&gt;top_cbp;
-        tprintf(h-&gt;s.avctx, &quot;cbp_b = top_cbp = %x\n&quot;, cbp_b);
-    }
+    cbp_a = h-&gt;slice_table[h-&gt;left_mb_xy[0]] == h-&gt;slice_num ? h-&gt;left_cbp : -1;
+    cbp_b = h-&gt;slice_table[h-&gt;top_mb_xy]     == h-&gt;slice_num ? h-&gt;top_cbp  : -1;
 
-    for( i8x8 = 0; i8x8 &lt; 4; i8x8++ ) {
-        int cbp_a = -1;
-        int x, y;
-        int ctx = 0;
-
-        x = block_idx_x[4*i8x8];
-        y = block_idx_y[4*i8x8];
-
-        if( x &gt; 0 )
-            cbp_a = cbp;
-        else if( h-&gt;slice_table[h-&gt;left_mb_xy[0]] == h-&gt;slice_num ) {
-            cbp_a = h-&gt;left_cbp;
-            tprintf(h-&gt;s.avctx, &quot;cbp_a = left_cbp = %x\n&quot;, cbp_a);
-        }
-
-        if( y &gt; 0 )
-            cbp_b = cbp;
-
-        /* No need to test for skip as we put 0 for skip block */
-        /* No need to test for IPCM as we put 1 for IPCM block */
-        if( cbp_a &gt;= 0 ) {
-            int i8x8a = block_idx_xy[(x-1)&amp;0x03][y]/4;
-            if( ((cbp_a &gt;&gt; i8x8a)&amp;0x01) == 0 )
-                ctx++;
-        }
-
-        if( cbp_b &gt;= 0 ) {
-            int i8x8b = block_idx_xy[x][(y-1)&amp;0x03]/4;
-            if( ((cbp_b &gt;&gt; i8x8b)&amp;0x01) == 0 )
-                ctx += 2;
-        }
-
-        if( get_cabac( &amp;h-&gt;cabac, &amp;h-&gt;cabac_state[73 + ctx] ) ) {
-            cbp |= 1 &lt;&lt; i8x8;
-        }
-    }
+    ctx = !(cbp_a &amp; 0x02) + 2 * !(cbp_b &amp; 0x04);
+    cbp |= get_cabac_noinline(&amp;h-&gt;cabac, &amp;h-&gt;cabac_state[73 + ctx]);
+    ctx = !(cbp   &amp; 0x01) + 2 * !(cbp_b &amp; 0x08);
+    cbp |= get_cabac_noinline(&amp;h-&gt;cabac, &amp;h-&gt;cabac_state[73 + ctx]) &lt;&lt; 1;
+    ctx = !(cbp_a &amp; 0x08) + 2 * !(cbp   &amp; 0x01);
+    cbp |= get_cabac_noinline(&amp;h-&gt;cabac, &amp;h-&gt;cabac_state[73 + ctx]) &lt;&lt; 2;
+    ctx = !(cbp   &amp; 0x04) + 2 * !(cbp   &amp; 0x02);
+    cbp |= get_cabac_noinline(&amp;h-&gt;cabac, &amp;h-&gt;cabac_state[73 + ctx]) &lt;&lt; 3;
     return cbp;
 }
 static int decode_cabac_mb_cbp_chroma( H264Context *h) {
@@ -5533,16 +5228,9 @@
     return 1 + get_cabac_noinline( &amp;h-&gt;cabac, &amp;h-&gt;cabac_state[77 + ctx] );
 }
 static int decode_cabac_mb_dqp( H264Context *h) {
-    MpegEncContext * const s = &amp;h-&gt;s;
-    int mbn_xy;
     int   ctx = 0;
     int   val = 0;
 
-    if( s-&gt;mb_x &gt; 0 )
-        mbn_xy = s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride - 1;
-    else
-        mbn_xy = s-&gt;mb_width - 1 + (s-&gt;mb_y-1)*s-&gt;mb_stride;
-
     if( h-&gt;last_qscale_diff != 0 )
         ctx++;
 
@@ -5597,7 +5285,7 @@
     int ref  = 0;
     int ctx  = 0;
 
-    if( h-&gt;slice_type == B_TYPE) {
+    if( h-&gt;slice_type == FF_B_TYPE) {
         if( refa &gt; 0 &amp;&amp; !h-&gt;direct_cache[scan8[n] - 1] )
             ctx++;
         if( refb &gt; 0 &amp;&amp; !h-&gt;direct_cache[scan8[n] - 8] )
@@ -5665,23 +5353,27 @@
     return get_cabac_bypass_sign( &amp;h-&gt;cabac, -mvd );
 }
 
-static inline int get_cabac_cbf_ctx( H264Context *h, int cat, int idx ) {
+static av_always_inline int get_cabac_cbf_ctx( H264Context *h, int cat, int idx, int is_dc ) {
     int nza, nzb;
     int ctx = 0;
 
-    if( cat == 0 ) {
-        nza = h-&gt;left_cbp&amp;0x100;
-        nzb = h-&gt; top_cbp&amp;0x100;
-    } else if( cat == 1 || cat == 2 ) {
-        nza = h-&gt;non_zero_count_cache[scan8[idx] - 1];
-        nzb = h-&gt;non_zero_count_cache[scan8[idx] - 8];
-    } else if( cat == 3 ) {
-        nza = (h-&gt;left_cbp&gt;&gt;(6+idx))&amp;0x01;
-        nzb = (h-&gt; top_cbp&gt;&gt;(6+idx))&amp;0x01;
+    if( is_dc ) {
+        if( cat == 0 ) {
+            nza = h-&gt;left_cbp&amp;0x100;
+            nzb = h-&gt; top_cbp&amp;0x100;
+        } else {
+            nza = (h-&gt;left_cbp&gt;&gt;(6+idx))&amp;0x01;
+            nzb = (h-&gt; top_cbp&gt;&gt;(6+idx))&amp;0x01;
+        }
     } else {
-        assert(cat == 4);
-        nza = h-&gt;non_zero_count_cache[scan8[16+idx] - 1];
-        nzb = h-&gt;non_zero_count_cache[scan8[16+idx] - 8];
+        if( cat == 4 ) {
+            nza = h-&gt;non_zero_count_cache[scan8[16+idx] - 1];
+            nzb = h-&gt;non_zero_count_cache[scan8[16+idx] - 8];
+        } else {
+            assert(cat == 1 || cat == 2);
+            nza = h-&gt;non_zero_count_cache[scan8[idx] - 1];
+            nzb = h-&gt;non_zero_count_cache[scan8[idx] - 8];
+        }
     }
 
     if( nza &gt; 0 )
@@ -5693,15 +5385,14 @@
     return ctx + 4 * cat;
 }
 
-static const attribute_used uint8_t last_coeff_flag_offset_8x8[63] = {
+DECLARE_ASM_CONST(1, uint8_t, last_coeff_flag_offset_8x8[63]) = {
     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
     5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8
 };
 
-static int decode_cabac_residual( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff) {
-    const int mb_xy  = h-&gt;s.mb_x + h-&gt;s.mb_y*h-&gt;s.mb_stride;
+static av_always_inline void decode_cabac_residual_internal( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff, int is_dc ) {
     static const int significant_coeff_flag_offset[2][6] = {
       { 105+0, 105+15, 105+29, 105+44, 105+47, 402 },
       { 277+0, 277+15, 277+29, 277+44, 277+47, 436 }
@@ -5723,15 +5414,25 @@
         9, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,13,13, 9,
         9,10,10, 8,13,13, 9, 9,10,10,14,14,14,14,14 }
     };
+    /* node ctx: 0..3: abslevel1 (with abslevelgt1 == 0).
+     * 4..7: abslevelgt1 + 3 (and abslevel1 doesn't matter).
+     * map node ctx =&gt; cabac ctx for level=1 */
+    static const uint8_t coeff_abs_level1_ctx[8] = { 1, 2, 3, 4, 0, 0, 0, 0 };
+    /* map node ctx =&gt; cabac ctx for level&gt;1 */
+    static const uint8_t coeff_abs_levelgt1_ctx[8] = { 5, 5, 5, 5, 6, 7, 8, 9 };
+    static const uint8_t coeff_abs_level_transition[2][8] = {
+    /* update node ctx after decoding a level=1 */
+        { 1, 2, 3, 3, 4, 5, 6, 7 },
+    /* update node ctx after decoding a level&gt;1 */
+        { 4, 4, 4, 4, 5, 6, 7, 7 }
+    };
 
     int index[64];
 
     int av_unused last;
     int coeff_count = 0;
+    int node_ctx = 0;
 
-    int abslevel1 = 1;
-    int abslevelgt1 = 0;
-
     uint8_t *significant_coeff_ctx_base;
     uint8_t *last_coeff_ctx_base;
     uint8_t *abs_level_m1_ctx_base;
@@ -5759,18 +5460,21 @@
      */
 
     /* read coded block flag */
-    if( cat != 5 ) {
-        if( get_cabac( CC, &amp;h-&gt;cabac_state[85 + get_cabac_cbf_ctx( h, cat, n ) ] ) == 0 ) {
-            if( cat == 1 || cat == 2 )
-                h-&gt;non_zero_count_cache[scan8[n]] = 0;
-            else if( cat == 4 )
-                h-&gt;non_zero_count_cache[scan8[16+n]] = 0;
+    if( is_dc || cat != 5 ) {
+        if( get_cabac( CC, &amp;h-&gt;cabac_state[85 + get_cabac_cbf_ctx( h, cat, n, is_dc ) ] ) == 0 ) {
+            if( !is_dc ) {
+                if( cat == 4 )
+                    h-&gt;non_zero_count_cache[scan8[16+n]] = 0;
+                else
+                    h-&gt;non_zero_count_cache[scan8[n]] = 0;
+            }
+
 #ifdef CABAC_ON_STACK
             h-&gt;cabac.range     = cc.range     ;
             h-&gt;cabac.low       = cc.low       ;
             h-&gt;cabac.bytestream= cc.bytestream;
 #endif
-            return 0;
+            return;
         }
     }
 
@@ -5781,7 +5485,7 @@
     abs_level_m1_ctx_base = h-&gt;cabac_state
         + coeff_abs_level_m1_offset[cat];
 
-    if( cat == 5 ) {
+    if( !is_dc &amp;&amp; cat == 5 ) {
 #define DECODE_SIGNIFICANCE( coefs, sig_off, last_off ) \
         for(last= 0; last &lt; coefs; last++) { \
             uint8_t *sig_ctx = significant_coeff_ctx_base + sig_off; \
@@ -5798,7 +5502,7 @@
             index[coeff_count++] = last;\
         }
         const uint8_t *sig_off = significant_coeff_flag_offset_8x8[MB_FIELD];
-#if defined(ARCH_X86) &amp;&amp; defined(CONFIG_7REGS) &amp;&amp; defined(HAVE_EBX_AVAILABLE) &amp;&amp; !defined(BROKEN_RELOCATIONS)
+#if defined(ARCH_X86) &amp;&amp; defined(HAVE_7REGS) &amp;&amp; defined(HAVE_EBX_AVAILABLE) &amp;&amp; !defined(BROKEN_RELOCATIONS)
         coeff_count= decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, sig_off);
     } else {
         coeff_count= decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index);
@@ -5810,34 +5514,39 @@
     }
     assert(coeff_count &gt; 0);
 
-    if( cat == 0 )
-        h-&gt;cbp_table[mb_xy] |= 0x100;
-    else if( cat == 1 || cat == 2 )
-        h-&gt;non_zero_count_cache[scan8[n]] = coeff_count;
-    else if( cat == 3 )
-        h-&gt;cbp_table[mb_xy] |= 0x40 &lt;&lt; n;
-    else if( cat == 4 )
-        h-&gt;non_zero_count_cache[scan8[16+n]] = coeff_count;
-    else {
-        assert( cat == 5 );
-        fill_rectangle(&amp;h-&gt;non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);
+    if( is_dc ) {
+        if( cat == 0 )
+            h-&gt;cbp_table[h-&gt;mb_xy] |= 0x100;
+        else
+            h-&gt;cbp_table[h-&gt;mb_xy] |= 0x40 &lt;&lt; n;
+    } else {
+        if( cat == 5 )
+            fill_rectangle(&amp;h-&gt;non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);
+        else if( cat == 4 )
+            h-&gt;non_zero_count_cache[scan8[16+n]] = coeff_count;
+        else {
+            assert( cat == 1 || cat == 2 );
+            h-&gt;non_zero_count_cache[scan8[n]] = coeff_count;
+        }
     }
 
-    for( coeff_count--; coeff_count &gt;= 0; coeff_count-- ) {
-        uint8_t *ctx = (abslevelgt1 != 0 ? 0 : FFMIN( 4, abslevel1 )) + abs_level_m1_ctx_base;
+    while( coeff_count-- ) {
+        uint8_t *ctx = coeff_abs_level1_ctx[node_ctx] + abs_level_m1_ctx_base;
+
         int j= scantable[index[coeff_count]];
 
         if( get_cabac( CC, ctx ) == 0 ) {
-            if( !qmul ) {
+            node_ctx = coeff_abs_level_transition[0][node_ctx];
+            if( is_dc ) {
                 block[j] = get_cabac_bypass_sign( CC, -1);
             }else{
-                block[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) &gt;&gt; 6;;
+                block[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) &gt;&gt; 6;
             }
-
-            abslevel1++;
         } else {
             int coeff_abs = 2;
-            ctx = 5 + FFMIN( 4, abslevelgt1 ) + abs_level_m1_ctx_base;
+            ctx = coeff_abs_levelgt1_ctx[node_ctx] + abs_level_m1_ctx_base;
+            node_ctx = coeff_abs_level_transition[1][node_ctx];
+
             while( coeff_abs &lt; 15 &amp;&amp; get_cabac( CC, ctx ) ) {
                 coeff_abs++;
             }
@@ -5855,15 +5564,11 @@
                 coeff_abs+= 14;
             }
 
-            if( !qmul ) {
-                if( get_cabac_bypass( CC ) ) block[j] = -coeff_abs;
-                else                                block[j] =  coeff_abs;
+            if( is_dc ) {
+                block[j] = get_cabac_bypass_sign( CC, -coeff_abs );
             }else{
-                if( get_cabac_bypass( CC ) ) block[j] = (-coeff_abs * qmul[j] + 32) &gt;&gt; 6;
-                else                                block[j] = ( coeff_abs * qmul[j] + 32) &gt;&gt; 6;
+                block[j] = (get_cabac_bypass_sign( CC, -coeff_abs ) * qmul[j] + 32) &gt;&gt; 6;
             }
-
-            abslevelgt1++;
         }
     }
 #ifdef CABAC_ON_STACK
@@ -5871,13 +5576,32 @@
             h-&gt;cabac.low       = cc.low       ;
             h-&gt;cabac.bytestream= cc.bytestream;
 #endif
-    return 0;
+
 }
 
+#ifndef CONFIG_SMALL
+static void decode_cabac_residual_dc( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff ) {
+    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 1);
+}
+
+static void decode_cabac_residual_nondc( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff ) {
+    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 0);
+}
+#endif
+
+static void decode_cabac_residual( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff ) {
+#ifdef CONFIG_SMALL
+    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, cat == 0 || cat == 3);
+#else
+    if( cat == 0 || cat == 3 ) decode_cabac_residual_dc(h, block, cat, n, scantable, qmul, max_coeff);
+    else decode_cabac_residual_nondc(h, block, cat, n, scantable, qmul, max_coeff);
+#endif
+}
+
 static inline void compute_mb_neighbors(H264Context *h)
 {
     MpegEncContext * const s = &amp;h-&gt;s;
-    const int mb_xy  = s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+    const int mb_xy  = h-&gt;mb_xy;
     h-&gt;top_mb_xy     = mb_xy - s-&gt;mb_stride;
     h-&gt;left_mb_xy[0] = mb_xy - 1;
     if(FRAME_MBAFF){
@@ -5896,6 +5620,8 @@
         if (left_mb_frame_flag != curr_mb_frame_flag) {
             h-&gt;left_mb_xy[0] = pair_xy - 1;
         }
+    } else if (FIELD_PICTURE) {
+        h-&gt;top_mb_xy -= s-&gt;mb_stride;
     }
     return;
 }
@@ -5906,14 +5632,16 @@
  */
 static int decode_mb_cabac(H264Context *h) {
     MpegEncContext * const s = &amp;h-&gt;s;
-    const int mb_xy= s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+    int mb_xy;
     int mb_type, partition_count, cbp = 0;
     int dct8x8_allowed= h-&gt;pps.transform_8x8_mode;
 
+    mb_xy = h-&gt;mb_xy = s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+
     s-&gt;dsp.clear_blocks(h-&gt;mb); //FIXME avoid if already clear (move after skip handlong?)
 
     tprintf(s-&gt;avctx, &quot;pic:%d mb:%d/%d\n&quot;, h-&gt;frame_num, s-&gt;mb_x, s-&gt;mb_y);
-    if( h-&gt;slice_type != I_TYPE &amp;&amp; h-&gt;slice_type != SI_TYPE ) {
+    if( h-&gt;slice_type != FF_I_TYPE &amp;&amp; h-&gt;slice_type != FF_SI_TYPE ) {
         int skip;
         /* a skipped mb needs the aff flag from the following mb */
         if( FRAME_MBAFF &amp;&amp; s-&gt;mb_x==0 &amp;&amp; (s-&gt;mb_y&amp;1)==0 )
@@ -5958,7 +5686,7 @@
         return -1;
     }
 
-    if( h-&gt;slice_type == B_TYPE ) {
+    if( h-&gt;slice_type == FF_B_TYPE ) {
         if( mb_type &lt; 23 ){
             partition_count= b_mb_type_info[mb_type].partition_count;
             mb_type=         b_mb_type_info[mb_type].type;
@@ -5966,7 +5694,7 @@
             mb_type -= 23;
             goto decode_intra_mb;
         }
-    } else if( h-&gt;slice_type == P_TYPE ) {
+    } else if( h-&gt;slice_type == FF_P_TYPE ) {
         if( mb_type &lt; 5) {
             partition_count= p_mb_type_info[mb_type].partition_count;
             mb_type=         p_mb_type_info[mb_type].type;
@@ -5975,7 +5703,7 @@
             goto decode_intra_mb;
         }
     } else {
-       assert(h-&gt;slice_type == I_TYPE);
+       assert(h-&gt;slice_type == FF_I_TYPE);
 decode_intra_mb:
         partition_count = 0;
         cbp= i_mb_type_info[mb_type].cbp;
@@ -6035,6 +5763,7 @@
         // All coeffs are present
         memset(h-&gt;non_zero_count[mb_xy], 16, 16);
         s-&gt;current_picture.mb_type[mb_xy]= mb_type;
+        h-&gt;last_qscale_diff = 0;
         return 0;
     }
 
@@ -6078,7 +5807,7 @@
     } else if( partition_count == 4 ) {
         int i, j, sub_partition_count[4], list, ref[2][4];
 
-        if( h-&gt;slice_type == B_TYPE ) {
+        if( h-&gt;slice_type == FF_B_TYPE ) {
             for( i = 0; i &lt; 4; i++ ) {
                 h-&gt;sub_mb_type[i] = decode_cabac_b_mb_sub_type( h );
                 sub_partition_count[i]= b_sub_mb_type_info[ h-&gt;sub_mb_type[i] ].partition_count;
@@ -6087,6 +5816,10 @@
             if( IS_DIRECT(h-&gt;sub_mb_type[0] | h-&gt;sub_mb_type[1] |
                           h-&gt;sub_mb_type[2] | h-&gt;sub_mb_type[3]) ) {
                 pred_direct_motion(h, &amp;mb_type);
+                h-&gt;ref_cache[0][scan8[4]] =
+                h-&gt;ref_cache[1][scan8[4]] =
+                h-&gt;ref_cache[0][scan8[12]] =
+                h-&gt;ref_cache[1][scan8[12]] = PART_NOT_AVAILABLE;
                 if( h-&gt;ref_count[0] &gt; 1 || h-&gt;ref_count[1] &gt; 1 ) {
                     for( i = 0; i &lt; 4; i++ )
                         if( IS_DIRECT(h-&gt;sub_mb_type[i]) )
@@ -6122,11 +5855,11 @@
 
         for(list=0; list&lt;h-&gt;list_count; list++){
             for(i=0; i&lt;4; i++){
+                h-&gt;ref_cache[list][ scan8[4*i]   ]=h-&gt;ref_cache[list][ scan8[4*i]+1 ];
                 if(IS_DIRECT(h-&gt;sub_mb_type[i])){
                     fill_rectangle(h-&gt;mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 4);
                     continue;
                 }
-                h-&gt;ref_cache[list][ scan8[4*i]   ]=h-&gt;ref_cache[list][ scan8[4*i]+1 ];
 
                 if(IS_DIR(h-&gt;sub_mb_type[i], 0, list) &amp;&amp; !IS_DIRECT(h-&gt;sub_mb_type[i])){
                     const int sub_mb_type= h-&gt;sub_mb_type[i];
@@ -6285,6 +6018,7 @@
 
     if( cbp || IS_INTRA16x16( mb_type ) ) {
         const uint8_t *scan, *scan8x8, *dc_scan;
+        const uint32_t *qmul;
         int dqp;
 
         if(IS_INTERLACED(mb_type)){
@@ -6313,13 +6047,13 @@
         if( IS_INTRA16x16( mb_type ) ) {
             int i;
             //av_log( s-&gt;avctx, AV_LOG_ERROR, &quot;INTRA16x16 DC\n&quot; );
-            if( decode_cabac_residual( h, h-&gt;mb, 0, 0, dc_scan, NULL, 16) &lt; 0)
-                return -1;
+            decode_cabac_residual( h, h-&gt;mb, 0, 0, dc_scan, NULL, 16);
+
             if( cbp&amp;15 ) {
+                qmul = h-&gt;dequant4_coeff[0][s-&gt;qscale];
                 for( i = 0; i &lt; 16; i++ ) {
                     //av_log( s-&gt;avctx, AV_LOG_ERROR, &quot;INTRA16x16 AC:%d\n&quot;, i );
-                    if( decode_cabac_residual(h, h-&gt;mb + 16*i, 1, i, scan + 1, h-&gt;dequant4_coeff[0][s-&gt;qscale], 15) &lt; 0 )
-                        return -1;
+                    decode_cabac_residual(h, h-&gt;mb + 16*i, 1, i, scan + 1, qmul, 15);
                 }
             } else {
                 fill_rectangle(&amp;h-&gt;non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1);
@@ -6329,17 +6063,17 @@
             for( i8x8 = 0; i8x8 &lt; 4; i8x8++ ) {
                 if( cbp &amp; (1&lt;&lt;i8x8) ) {
                     if( IS_8x8DCT(mb_type) ) {
-                        if( decode_cabac_residual(h, h-&gt;mb + 64*i8x8, 5, 4*i8x8,
-                            scan8x8, h-&gt;dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s-&gt;qscale], 64) &lt; 0 )
-                            return -1;
-                    } else
-                    for( i4x4 = 0; i4x4 &lt; 4; i4x4++ ) {
-                        const int index = 4*i8x8 + i4x4;
-                        //av_log( s-&gt;avctx, AV_LOG_ERROR, &quot;Luma4x4: %d\n&quot;, index );
+                        decode_cabac_residual(h, h-&gt;mb + 64*i8x8, 5, 4*i8x8,
+                            scan8x8, h-&gt;dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s-&gt;qscale], 64);
+                    } else {
+                        qmul = h-&gt;dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s-&gt;qscale];
+                        for( i4x4 = 0; i4x4 &lt; 4; i4x4++ ) {
+                            const int index = 4*i8x8 + i4x4;
+                            //av_log( s-&gt;avctx, AV_LOG_ERROR, &quot;Luma4x4: %d\n&quot;, index );
 //START_TIMER
-                        if( decode_cabac_residual(h, h-&gt;mb + 16*index, 2, index, scan, h-&gt;dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s-&gt;qscale], 16) &lt; 0 )
-                            return -1;
+                            decode_cabac_residual(h, h-&gt;mb + 16*index, 2, index, scan, qmul, 16);
 //STOP_TIMER(&quot;decode_residual&quot;)
+                        }
                     }
                 } else {
                     uint8_t * const nnz= &amp;h-&gt;non_zero_count_cache[ scan8[4*i8x8] ];
@@ -6352,20 +6086,18 @@
             int c;
             for( c = 0; c &lt; 2; c++ ) {
                 //av_log( s-&gt;avctx, AV_LOG_ERROR, &quot;INTRA C%d-DC\n&quot;,c );
-                if( decode_cabac_residual(h, h-&gt;mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4) &lt; 0)
-                    return -1;
+                decode_cabac_residual(h, h-&gt;mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4);
             }
         }
 
         if( cbp&amp;0x20 ) {
             int c, i;
             for( c = 0; c &lt; 2; c++ ) {
-                const uint32_t *qmul = h-&gt;dequant4_coeff[c+1+(IS_INTRA( mb_type ) ? 0:3)][h-&gt;chroma_qp[c]];
+                qmul = h-&gt;dequant4_coeff[c+1+(IS_INTRA( mb_type ) ? 0:3)][h-&gt;chroma_qp[c]];
                 for( i = 0; i &lt; 4; i++ ) {
                     const int index = 16 + 4 * c + i;
                     //av_log( s-&gt;avctx, AV_LOG_ERROR, &quot;INTRA C%d-AC %d\n&quot;,c, index - 16 );
-                    if( decode_cabac_residual(h, h-&gt;mb + 16*index, 4, index - 16, scan + 1, qmul, 15) &lt; 0)
-                        return -1;
+                    decode_cabac_residual(h, h-&gt;mb + 16*index, 4, index - 16, scan + 1, qmul, 15);
                 }
             }
         } else {
@@ -6699,12 +6431,13 @@
 
 static void filter_mb_fast( H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize) {
     MpegEncContext * const s = &amp;h-&gt;s;
+    int mb_y_firstrow = s-&gt;picture_structure == PICT_BOTTOM_FIELD;
     int mb_xy, mb_type;
     int qp, qp0, qp1, qpc, qpc0, qpc1, qp_thresh;
 
-    mb_xy = mb_x + mb_y*s-&gt;mb_stride;
+    mb_xy = h-&gt;mb_xy;
 
-    if(mb_x==0 || mb_y==0 || !s-&gt;dsp.h264_loop_filter_strength || h-&gt;pps.chroma_qp_diff ||
+    if(mb_x==0 || mb_y==mb_y_firstrow || !s-&gt;dsp.h264_loop_filter_strength || h-&gt;pps.chroma_qp_diff ||
        (h-&gt;deblocking_filter == 2 &amp;&amp; (h-&gt;slice_table[mb_xy] != h-&gt;slice_table[h-&gt;top_mb_xy] ||
                                       h-&gt;slice_table[mb_xy] != h-&gt;slice_table[mb_xy - 1]))) {
         filter_mb(h, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);
@@ -6731,17 +6464,18 @@
     if( IS_INTRA(mb_type) ) {
         int16_t bS4[4] = {4,4,4,4};
         int16_t bS3[4] = {3,3,3,3};
+        int16_t *bSH = FIELD_PICTURE ? bS3 : bS4;
         if( IS_8x8DCT(mb_type) ) {
             filter_mb_edgev( h, &amp;img_y[4*0], linesize, bS4, qp0 );
             filter_mb_edgev( h, &amp;img_y[4*2], linesize, bS3, qp );
-            filter_mb_edgeh( h, &amp;img_y[4*0*linesize], linesize, bS4, qp1 );
+            filter_mb_edgeh( h, &amp;img_y[4*0*linesize], linesize, bSH, qp1 );
             filter_mb_edgeh( h, &amp;img_y[4*2*linesize], linesize, bS3, qp );
         } else {
             filter_mb_edgev( h, &amp;img_y[4*0], linesize, bS4, qp0 );
             filter_mb_edgev( h, &amp;img_y[4*1], linesize, bS3, qp );
             filter_mb_edgev( h, &amp;img_y[4*2], linesize, bS3, qp );
             filter_mb_edgev( h, &amp;img_y[4*3], linesize, bS3, qp );
-            filter_mb_edgeh( h, &amp;img_y[4*0*linesize], linesize, bS4, qp1 );
+            filter_mb_edgeh( h, &amp;img_y[4*0*linesize], linesize, bSH, qp1 );
             filter_mb_edgeh( h, &amp;img_y[4*1*linesize], linesize, bS3, qp );
             filter_mb_edgeh( h, &amp;img_y[4*2*linesize], linesize, bS3, qp );
             filter_mb_edgeh( h, &amp;img_y[4*3*linesize], linesize, bS3, qp );
@@ -6750,9 +6484,9 @@
         filter_mb_edgecv( h, &amp;img_cb[2*2], uvlinesize, bS3, qpc );
         filter_mb_edgecv( h, &amp;img_cr[2*0], uvlinesize, bS4, qpc0 );
         filter_mb_edgecv( h, &amp;img_cr[2*2], uvlinesize, bS3, qpc );
-        filter_mb_edgech( h, &amp;img_cb[2*0*uvlinesize], uvlinesize, bS4, qpc1 );
+        filter_mb_edgech( h, &amp;img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1 );
         filter_mb_edgech( h, &amp;img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc );
-        filter_mb_edgech( h, &amp;img_cr[2*0*uvlinesize], uvlinesize, bS4, qpc1 );
+        filter_mb_edgech( h, &amp;img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1 );
         filter_mb_edgech( h, &amp;img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc );
         return;
     } else {
@@ -6771,12 +6505,12 @@
             int step = IS_8x8DCT(mb_type) ? 2 : 1;
             edges = (mb_type &amp; MB_TYPE_16x16) &amp;&amp; !(h-&gt;cbp &amp; 15) ? 1 : 4;
             s-&gt;dsp.h264_loop_filter_strength( bS, h-&gt;non_zero_count_cache, h-&gt;ref_cache, h-&gt;mv_cache,
-                                              (h-&gt;slice_type == B_TYPE), edges, step, mask_edge0, mask_edge1 );
+                                              (h-&gt;slice_type == FF_B_TYPE), edges, step, mask_edge0, mask_edge1 );
         }
         if( IS_INTRA(s-&gt;current_picture.mb_type[mb_xy-1]) )
             bSv[0][0] = 0x0004000400040004ULL;
         if( IS_INTRA(s-&gt;current_picture.mb_type[h-&gt;top_mb_xy]) )
-            bSv[1][0] = 0x0004000400040004ULL;
+            bSv[1][0] = FIELD_PICTURE ? 0x0003000300030003ULL : 0x0004000400040004ULL;
 
 #define FILTER(hv,dir,edge)\
         if(bSv[dir][edge]) {\
@@ -6817,14 +6551,14 @@
     int dir;
     /* FIXME: A given frame may occupy more than one position in
      * the reference list. So ref2frm should be populated with
-     * frame numbers, not indices. */
+     * frame numbers, not indexes. */
     static const int ref2frm[34] = {-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
                                     16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};
 
     //for sufficiently low qp, filtering wouldn't do anything
     //this is a conservative estimate: could also check beta_offset and more accurate chroma_qp
     if(!FRAME_MBAFF){
-        int qp_thresh = 15 - h-&gt;slice_alpha_c0_offset - FFMAX(0, FFMAX(h-&gt;pps.chroma_qp_index_offset[0], h-&gt;pps.chroma_qp_index_offset[1]));
+        int qp_thresh = 15 - h-&gt;slice_alpha_c0_offset - FFMAX3(0, h-&gt;pps.chroma_qp_index_offset[0], h-&gt;pps.chroma_qp_index_offset[1]);
         int qp = s-&gt;current_picture.qscale_table[mb_xy];
         if(qp &lt;= qp_thresh
            &amp;&amp; (mb_x == 0 || ((qp + s-&gt;current_picture.qscale_table[mb_xy-1] + 1)&gt;&gt;1) &lt;= qp_thresh)
@@ -7002,7 +6736,7 @@
                     int b_idx= 8 + 4 + edge * (dir ? 8:1);
                     int bn_idx= b_idx - (dir ? 8:1);
                     int v = 0;
-                    for( l = 0; !v &amp;&amp; l &lt; 1 + (h-&gt;slice_type == B_TYPE); l++ ) {
+                    for( l = 0; !v &amp;&amp; l &lt; 1 + (h-&gt;slice_type == FF_B_TYPE); l++ ) {
                         v |= ref2frm[h-&gt;ref_cache[l][b_idx]+2] != ref2frm[h-&gt;ref_cache[l][bn_idx]+2] ||
                              FFABS( h-&gt;mv_cache[l][b_idx][0] - h-&gt;mv_cache[l][bn_idx][0] ) &gt;= 4 ||
                              FFABS( h-&gt;mv_cache[l][b_idx][1] - h-&gt;mv_cache[l][bn_idx][1] ) &gt;= mvy_limit;
@@ -7026,7 +6760,7 @@
                     else if(!mv_done)
                     {
                         bS[i] = 0;
-                        for( l = 0; l &lt; 1 + (h-&gt;slice_type == B_TYPE); l++ ) {
+                        for( l = 0; l &lt; 1 + (h-&gt;slice_type == FF_B_TYPE); l++ ) {
                             if( ref2frm[h-&gt;ref_cache[l][b_idx]+2] != ref2frm[h-&gt;ref_cache[l][bn_idx]+2] ||
                                 FFABS( h-&gt;mv_cache[l][b_idx][0] - h-&gt;mv_cache[l][bn_idx][0] ) &gt;= 4 ||
                                 FFABS( h-&gt;mv_cache[l][b_idx][1] - h-&gt;mv_cache[l][bn_idx][1] ) &gt;= mvy_limit ) {
@@ -7069,7 +6803,7 @@
     }
 }
 
-static int decode_slice(H264Context *h){
+static int decode_slice(struct AVCodecContext *avctx, H264Context *h){
     MpegEncContext * const s = &amp;h-&gt;s;
     const int part_mask= s-&gt;partitioned_frame ? (AC_END|AC_ERROR) : 0x7F;
 
@@ -7089,7 +6823,7 @@
         /* calculate pre-state */
         for( i= 0; i &lt; 460; i++ ) {
             int pre;
-            if( h-&gt;slice_type == I_TYPE )
+            if( h-&gt;slice_type == FF_I_TYPE )
                 pre = av_clip( ((cabac_context_init_I[i][0] * s-&gt;qscale) &gt;&gt;4 ) + cabac_context_init_I[i][1], 1, 126 );
             else
                 pre = av_clip( ((cabac_context_init_PB[h-&gt;cabac_init_idc][i][0] * s-&gt;qscale) &gt;&gt;4 ) + cabac_context_init_PB[h-&gt;cabac_init_idc][i][1], 1, 126 );
@@ -7128,7 +6862,7 @@
                 s-&gt;mb_x = 0;
                 ff_draw_horiz_band(s, 16*s-&gt;mb_y, 16);
                 ++s-&gt;mb_y;
-                if(FRAME_MBAFF) {
+                if(FIELD_OR_MBAFF_PICTURE) {
                     ++s-&gt;mb_y;
                 }
             }
@@ -7165,7 +6899,7 @@
                 s-&gt;mb_x=0;
                 ff_draw_horiz_band(s, 16*s-&gt;mb_y, 16);
                 ++s-&gt;mb_y;
-                if(FRAME_MBAFF) {
+                if(FIELD_OR_MBAFF_PICTURE) {
                     ++s-&gt;mb_y;
                 }
                 if(s-&gt;mb_y &gt;= s-&gt;mb_height){
@@ -7334,7 +7068,7 @@
         if( aspect_ratio_idc == EXTENDED_SAR ) {
             sps-&gt;sar.num= get_bits(&amp;s-&gt;gb, 16);
             sps-&gt;sar.den= get_bits(&amp;s-&gt;gb, 16);
-        }else if(aspect_ratio_idc &lt; 14){
+        }else if(aspect_ratio_idc &lt; sizeof(pixel_aspect)/sizeof(*pixel_aspect)){
             sps-&gt;sar=  pixel_aspect[aspect_ratio_idc];
         }else{
             av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;illegal aspect ratio\n&quot;);
@@ -7529,8 +7263,9 @@
     }
 
     tmp= get_ue_golomb(&amp;s-&gt;gb);
-    if(tmp &gt; MAX_PICTURE_COUNT-2){
+    if(tmp &gt; MAX_PICTURE_COUNT-2 || tmp &gt;= 32){
         av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;too many reference frames\n&quot;);
+        return -1;
     }
     sps-&gt;ref_frame_count= tmp;
     sps-&gt;gaps_in_frame_num_allowed_flag= get_bits1(&amp;s-&gt;gb);
@@ -7568,6 +7303,9 @@
         if(sps-&gt;crop_left || sps-&gt;crop_top){
             av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;insane cropping not completely supported, this could look slightly wrong ...\n&quot;);
         }
+        if(sps-&gt;crop_right &gt;= 8 || sps-&gt;crop_bottom &gt;= (8&gt;&gt; !h-&gt;sps.frame_mbs_only_flag)){
+            av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;brainfart cropping not supported, this could look slightly wrong ...\n&quot;);
+        }
     }else{
         sps-&gt;crop_left  =
         sps-&gt;crop_right =
@@ -7714,10 +7452,50 @@
     return 0;
 }
 
-static int decode_nal_units(H264Context *h, uint8_t *buf, int buf_size){
+/**
+ * Call decode_slice() for each context.
+ *
+ * @param h h264 master context
+ * @param context_count number of contexts to execute
+ */
+static void execute_decode_slices(H264Context *h, int context_count){
     MpegEncContext * const s = &amp;h-&gt;s;
     AVCodecContext * const avctx= s-&gt;avctx;
+    H264Context *hx;
+    int i;
+
+    if(context_count == 1) {
+        decode_slice(avctx, h);
+    } else {
+        for(i = 1; i &lt; context_count; i++) {
+            hx = h-&gt;thread_context[i];
+            hx-&gt;s.error_resilience = avctx-&gt;error_resilience;
+            hx-&gt;s.error_count = 0;
+        }
+
+        avctx-&gt;execute(avctx, (void *)decode_slice,
+                       (void **)h-&gt;thread_context, NULL, context_count);
+
+        /* pull back stuff from slices to master context */
+        hx = h-&gt;thread_context[context_count - 1];
+        s-&gt;mb_x = hx-&gt;s.mb_x;
+        s-&gt;mb_y = hx-&gt;s.mb_y;
+        s-&gt;dropable = hx-&gt;s.dropable;
+        s-&gt;picture_structure = hx-&gt;s.picture_structure;
+        for(i = 1; i &lt; context_count; i++)
+            h-&gt;s.error_count += h-&gt;thread_context[i]-&gt;s.error_count;
+    }
+}
+
+
+static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){
+    MpegEncContext * const s = &amp;h-&gt;s;
+    AVCodecContext * const avctx= s-&gt;avctx;
     int buf_index=0;
+    H264Context *hx; ///&lt; thread context
+    int context_count = 0;
+
+    h-&gt;max_contexts = avctx-&gt;thread_count;
 #if 0
     int i;
     for(i=0; i&lt;50; i++){
@@ -7725,16 +7503,18 @@
     }
 #endif
     if(!(s-&gt;flags2 &amp; CODEC_FLAG2_CHUNKS)){
-        h-&gt;slice_num = 0;
-        s-&gt;current_picture_ptr= NULL;
+        h-&gt;current_slice = 0;
+        if (!s-&gt;first_field)
+            s-&gt;current_picture_ptr= NULL;
     }
 
     for(;;){
         int consumed;
         int dst_length;
         int bit_length;
-        uint8_t *ptr;
+        const uint8_t *ptr;
         int i, nalsize = 0;
+        int err;
 
         if(h-&gt;is_avc) {
             if(buf_index &gt;= buf_size) break;
@@ -7763,7 +7543,9 @@
             buf_index+=3;
         }
 
-        ptr= decode_nal(h, buf + buf_index, &amp;dst_length, &amp;consumed, h-&gt;is_avc ? nalsize : buf_size - buf_index);
+        hx = h-&gt;thread_context[context_count];
+
+        ptr= decode_nal(hx, buf + buf_index, &amp;dst_length, &amp;consumed, h-&gt;is_avc ? nalsize : buf_size - buf_index);
         if (ptr==NULL || dst_length &lt; 0){
             return -1;
         }
@@ -7772,11 +7554,13 @@
         bit_length= !dst_length ? 0 : (8*dst_length - decode_rbsp_trailing(h, ptr + dst_length - 1));
 
         if(s-&gt;avctx-&gt;debug&amp;FF_DEBUG_STARTCODE){
-            av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;NAL %d at %d/%d length %d\n&quot;, h-&gt;nal_unit_type, buf_index, buf_size, dst_length);
+            av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;NAL %d at %d/%d length %d\n&quot;, hx-&gt;nal_unit_type, buf_index, buf_size, dst_length);
         }
 
-        if (h-&gt;is_avc &amp;&amp; (nalsize != consumed))
+        if (h-&gt;is_avc &amp;&amp; (nalsize != consumed)){
             av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;AVC: Consumed only %d bytes instead of %d\n&quot;, consumed, nalsize);
+            consumed= nalsize;
+        }
 
         buf_index += consumed;
 
@@ -7784,53 +7568,56 @@
            ||(avctx-&gt;skip_frame &gt;= AVDISCARD_NONREF &amp;&amp; h-&gt;nal_ref_idc  == 0))
             continue;
 
-        switch(h-&gt;nal_unit_type){
+      again:
+        err = 0;
+        switch(hx-&gt;nal_unit_type){
         case NAL_IDR_SLICE:
+            if (h-&gt;nal_unit_type != NAL_IDR_SLICE) {
+                av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;Invalid mix of idr and non-idr slices&quot;);
+                return -1;
+            }
             idr(h); //FIXME ensure we don't loose some frames if there is reordering
         case NAL_SLICE:
-            init_get_bits(&amp;s-&gt;gb, ptr, bit_length);
-            h-&gt;intra_gb_ptr=
-            h-&gt;inter_gb_ptr= &amp;s-&gt;gb;
-            s-&gt;data_partitioning = 0;
+            init_get_bits(&amp;hx-&gt;s.gb, ptr, bit_length);
+            hx-&gt;intra_gb_ptr=
+            hx-&gt;inter_gb_ptr= &amp;hx-&gt;s.gb;
+            hx-&gt;s.data_partitioning = 0;
 
-            if(decode_slice_header(h) &lt; 0){
-                av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;decode_slice_header error\n&quot;);
-                break;
-            }
-            s-&gt;current_picture_ptr-&gt;key_frame= (h-&gt;nal_unit_type == NAL_IDR_SLICE);
-            if(h-&gt;redundant_pic_count==0 &amp;&amp; s-&gt;hurry_up &lt; 5
-               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_NONREF || h-&gt;nal_ref_idc)
-               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_BIDIR  || h-&gt;slice_type!=B_TYPE)
-               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_NONKEY || h-&gt;slice_type==I_TYPE)
+            if((err = decode_slice_header(hx, h)))
+               break;
+
+            s-&gt;current_picture_ptr-&gt;key_frame|= (hx-&gt;nal_unit_type == NAL_IDR_SLICE);
+            if(hx-&gt;redundant_pic_count==0 &amp;&amp; hx-&gt;s.hurry_up &lt; 5
+               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_NONREF || hx-&gt;nal_ref_idc)
+               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_BIDIR  || hx-&gt;slice_type!=FF_B_TYPE)
+               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_NONKEY || hx-&gt;slice_type==FF_I_TYPE)
                &amp;&amp; avctx-&gt;skip_frame &lt; AVDISCARD_ALL)
-                decode_slice(h);
+                context_count++;
             break;
         case NAL_DPA:
-            init_get_bits(&amp;s-&gt;gb, ptr, bit_length);
-            h-&gt;intra_gb_ptr=
-            h-&gt;inter_gb_ptr= NULL;
-            s-&gt;data_partitioning = 1;
+            init_get_bits(&amp;hx-&gt;s.gb, ptr, bit_length);
+            hx-&gt;intra_gb_ptr=
+            hx-&gt;inter_gb_ptr= NULL;
+            hx-&gt;s.data_partitioning = 1;
 
-            if(decode_slice_header(h) &lt; 0){
-                av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;decode_slice_header error\n&quot;);
-            }
+            err = decode_slice_header(hx, h);
             break;
         case NAL_DPB:
-            init_get_bits(&amp;h-&gt;intra_gb, ptr, bit_length);
-            h-&gt;intra_gb_ptr= &amp;h-&gt;intra_gb;
+            init_get_bits(&amp;hx-&gt;intra_gb, ptr, bit_length);
+            hx-&gt;intra_gb_ptr= &amp;hx-&gt;intra_gb;
             break;
         case NAL_DPC:
-            init_get_bits(&amp;h-&gt;inter_gb, ptr, bit_length);
-            h-&gt;inter_gb_ptr= &amp;h-&gt;inter_gb;
+            init_get_bits(&amp;hx-&gt;inter_gb, ptr, bit_length);
+            hx-&gt;inter_gb_ptr= &amp;hx-&gt;inter_gb;
 
-            if(h-&gt;redundant_pic_count==0 &amp;&amp; h-&gt;intra_gb_ptr &amp;&amp; s-&gt;data_partitioning
+            if(hx-&gt;redundant_pic_count==0 &amp;&amp; hx-&gt;intra_gb_ptr &amp;&amp; hx-&gt;s.data_partitioning
                &amp;&amp; s-&gt;context_initialized
                &amp;&amp; s-&gt;hurry_up &lt; 5
-               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_NONREF || h-&gt;nal_ref_idc)
-               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_BIDIR  || h-&gt;slice_type!=B_TYPE)
-               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_NONKEY || h-&gt;slice_type==I_TYPE)
+               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_NONREF || hx-&gt;nal_ref_idc)
+               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_BIDIR  || hx-&gt;slice_type!=FF_B_TYPE)
+               &amp;&amp; (avctx-&gt;skip_frame &lt; AVDISCARD_NONKEY || hx-&gt;slice_type==FF_I_TYPE)
                &amp;&amp; avctx-&gt;skip_frame &lt; AVDISCARD_ALL)
-                decode_slice(h);
+                context_count++;
             break;
         case NAL_SEI:
             init_get_bits(&amp;s-&gt;gb, ptr, bit_length);
@@ -7860,10 +7647,29 @@
         case NAL_AUXILIARY_SLICE:
             break;
         default:
-            av_log(avctx, AV_LOG_ERROR, &quot;Unknown NAL code: %d\n&quot;, h-&gt;nal_unit_type);
+            av_log(avctx, AV_LOG_DEBUG, &quot;Unknown NAL code: %d (%d bits)\n&quot;, h-&gt;nal_unit_type, bit_length);
         }
-    }
 
+        if(context_count == h-&gt;max_contexts) {
+            execute_decode_slices(h, context_count);
+            context_count = 0;
+        }
+
+        if (err &lt; 0)
+            av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;decode_slice_header error\n&quot;);
+        else if(err == 1) {
+            /* Slice could not be decoded in parallel mode, copy down
+             * NAL unit stuff to context 0 and restart. Note that
+             * rbsp_buffer is not transfered, but since we no longer
+             * run in parallel mode this should not be an issue. */
+            h-&gt;nal_unit_type = hx-&gt;nal_unit_type;
+            h-&gt;nal_ref_idc   = hx-&gt;nal_ref_idc;
+            hx = h;
+            goto again;
+        }
+    }
+    if(context_count)
+        execute_decode_slices(h, context_count);
     return buf_index;
 }
 
@@ -7886,7 +7692,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     H264Context *h = avctx-&gt;priv_data;
     MpegEncContext *s = &amp;h-&gt;s;
@@ -7896,6 +7702,15 @@
     s-&gt;flags= avctx-&gt;flags;
     s-&gt;flags2= avctx-&gt;flags2;
 
+    if(s-&gt;flags&amp;CODEC_FLAG_TRUNCATED){
+        const int next= ff_h264_find_frame_end(h, buf, buf_size);
+        assert((buf_size &gt; 0) || (next == END_NOT_FOUND));
+
+        if( ff_combine_frame(&amp;s-&gt;parse_context, next, &amp;buf, &amp;buf_size) &lt; 0 )
+          return buf_size;
+//printf(&quot;next:%d buf_size:%d last_index:%d\n&quot;, next, buf_size, s-&gt;parse_context.last_index);
+    }
+
    /* no supplementary picture */
     if (buf_size == 0) {
         Picture *out;
@@ -7921,14 +7736,6 @@
         return 0;
     }
 
-    if(s-&gt;flags&amp;CODEC_FLAG_TRUNCATED){
-        int next= ff_h264_find_frame_end(h, buf, buf_size);
-
-        if( ff_combine_frame(&amp;s-&gt;parse_context, next, (const uint8_t **)&amp;buf, &amp;buf_size) &lt; 0 )
-            return buf_size;
-//printf(&quot;next:%d buf_size:%d last_index:%d\n&quot;, next, buf_size, s-&gt;parse_context.last_index);
-    }
-
     if(h-&gt;is_avc &amp;&amp; !h-&gt;got_avcC) {
         int i, cnt, nalsize;
         unsigned char *p = avctx-&gt;extradata;
@@ -7980,6 +7787,7 @@
         return -1;
 
     if(!(s-&gt;flags2 &amp; CODEC_FLAG2_CHUNKS) &amp;&amp; !s-&gt;current_picture_ptr){
+        if (avctx-&gt;skip_frame &gt;= AVDISCARD_NONREF || s-&gt;hurry_up) return 0;
         av_log(avctx, AV_LOG_ERROR, &quot;no frame!\n&quot;);
         return -1;
     }
@@ -7997,87 +7805,109 @@
 
         h-&gt;prev_frame_num_offset= h-&gt;frame_num_offset;
         h-&gt;prev_frame_num= h-&gt;frame_num;
-        if(s-&gt;current_picture_ptr-&gt;reference){
+        if(!s-&gt;dropable) {
             h-&gt;prev_poc_msb= h-&gt;poc_msb;
             h-&gt;prev_poc_lsb= h-&gt;poc_lsb;
-        }
-        if(s-&gt;current_picture_ptr-&gt;reference)
             execute_ref_pic_marking(h, h-&gt;mmco, h-&gt;mmco_index);
+        }
 
-        ff_er_frame_end(s);
+        /*
+         * FIXME: Error handling code does not seem to support interlaced
+         * when slices span multiple rows
+         * The ff_er_add_slice calls don't work right for bottom
+         * fields; they cause massive erroneous error concealing
+         * Error marking covers both fields (top and bottom).
+         * This causes a mismatched s-&gt;error_count
+         * and a bad error table. Further, the error count goes to
+         * INT_MAX when called for bottom field, because mb_y is
+         * past end by one (callers fault) and resync_mb_y != 0
+         * causes problems for the first MB line, too.
+         */
+        if (!FIELD_PICTURE)
+            ff_er_frame_end(s);
 
         MPV_frame_end(s);
 
-    //FIXME do something with unavailable reference frames
+        if (s-&gt;first_field) {
+            /* Wait for second field. */
+            *data_size = 0;
 
+        } else {
+            cur-&gt;interlaced_frame = FIELD_OR_MBAFF_PICTURE;
+            /* Derive top_field_first from field pocs. */
+            cur-&gt;top_field_first = cur-&gt;field_poc[0] &lt; cur-&gt;field_poc[1];
+
+        //FIXME do something with unavailable reference frames
+
 #if 0 //decode order
-        *data_size = sizeof(AVFrame);
+            *data_size = sizeof(AVFrame);
 #else
-        /* Sort B-frames into display order */
+            /* Sort B-frames into display order */
 
-        if(h-&gt;sps.bitstream_restriction_flag
-           &amp;&amp; s-&gt;avctx-&gt;has_b_frames &lt; h-&gt;sps.num_reorder_frames){
-            s-&gt;avctx-&gt;has_b_frames = h-&gt;sps.num_reorder_frames;
-            s-&gt;low_delay = 0;
-        }
+            if(h-&gt;sps.bitstream_restriction_flag
+               &amp;&amp; s-&gt;avctx-&gt;has_b_frames &lt; h-&gt;sps.num_reorder_frames){
+                s-&gt;avctx-&gt;has_b_frames = h-&gt;sps.num_reorder_frames;
+                s-&gt;low_delay = 0;
+            }
 
-        pics = 0;
-        while(h-&gt;delayed_pic[pics]) pics++;
+            pics = 0;
+            while(h-&gt;delayed_pic[pics]) pics++;
 
-        assert(pics+1 &lt; sizeof(h-&gt;delayed_pic) / sizeof(h-&gt;delayed_pic[0]));
+            assert(pics &lt;= MAX_DELAYED_PIC_COUNT);
 
-        h-&gt;delayed_pic[pics++] = cur;
-        if(cur-&gt;reference == 0)
-            cur-&gt;reference = 1;
+            h-&gt;delayed_pic[pics++] = cur;
+            if(cur-&gt;reference == 0)
+                cur-&gt;reference = DELAYED_PIC_REF;
 
-        cross_idr = 0;
-        for(i=0; h-&gt;delayed_pic[i]; i++)
-            if(h-&gt;delayed_pic[i]-&gt;key_frame || h-&gt;delayed_pic[i]-&gt;poc==0)
-                cross_idr = 1;
+            cross_idr = 0;
+            for(i=0; h-&gt;delayed_pic[i]; i++)
+                if(h-&gt;delayed_pic[i]-&gt;key_frame || h-&gt;delayed_pic[i]-&gt;poc==0)
+                    cross_idr = 1;
 
-        out = h-&gt;delayed_pic[0];
-        out_idx = 0;
-        for(i=1; h-&gt;delayed_pic[i] &amp;&amp; !h-&gt;delayed_pic[i]-&gt;key_frame; i++)
-            if(h-&gt;delayed_pic[i]-&gt;poc &lt; out-&gt;poc){
-                out = h-&gt;delayed_pic[i];
-                out_idx = i;
-            }
+            out = h-&gt;delayed_pic[0];
+            out_idx = 0;
+            for(i=1; h-&gt;delayed_pic[i] &amp;&amp; !h-&gt;delayed_pic[i]-&gt;key_frame; i++)
+                if(h-&gt;delayed_pic[i]-&gt;poc &lt; out-&gt;poc){
+                    out = h-&gt;delayed_pic[i];
+                    out_idx = i;
+                }
 
-        out_of_order = !cross_idr &amp;&amp; prev &amp;&amp; out-&gt;poc &lt; prev-&gt;poc;
-        if(h-&gt;sps.bitstream_restriction_flag &amp;&amp; s-&gt;avctx-&gt;has_b_frames &gt;= h-&gt;sps.num_reorder_frames)
-            { }
-        else if(prev &amp;&amp; pics &lt;= s-&gt;avctx-&gt;has_b_frames)
-            out = prev;
-        else if((out_of_order &amp;&amp; pics-1 == s-&gt;avctx-&gt;has_b_frames &amp;&amp; pics &lt; 15)
-           || (s-&gt;low_delay &amp;&amp;
-            ((!cross_idr &amp;&amp; prev &amp;&amp; out-&gt;poc &gt; prev-&gt;poc + 2)
-             || cur-&gt;pict_type == B_TYPE)))
-        {
-            s-&gt;low_delay = 0;
-            s-&gt;avctx-&gt;has_b_frames++;
-            out = prev;
-        }
-        else if(out_of_order)
-            out = prev;
+            out_of_order = !cross_idr &amp;&amp; prev &amp;&amp; out-&gt;poc &lt; prev-&gt;poc;
 
-        if(out_of_order || pics &gt; s-&gt;avctx-&gt;has_b_frames){
-            for(i=out_idx; h-&gt;delayed_pic[i]; i++)
-                h-&gt;delayed_pic[i] = h-&gt;delayed_pic[i+1];
-        }
+            if(prev &amp;&amp; pics &lt;= s-&gt;avctx-&gt;has_b_frames || out_of_order)
+                out = prev;
 
-        if(prev == out)
-            *data_size = 0;
-        else
-            *data_size = sizeof(AVFrame);
-        if(prev &amp;&amp; prev != out &amp;&amp; prev-&gt;reference == 1)
-            prev-&gt;reference = 0;
-        h-&gt;delayed_output_pic = out;
+            if(h-&gt;sps.bitstream_restriction_flag &amp;&amp; s-&gt;avctx-&gt;has_b_frames &gt;= h-&gt;sps.num_reorder_frames)
+                { }
+            else if((out_of_order &amp;&amp; pics-1 == s-&gt;avctx-&gt;has_b_frames &amp;&amp; pics &lt; 15)
+               || (s-&gt;low_delay &amp;&amp;
+                ((!cross_idr &amp;&amp; prev &amp;&amp; out-&gt;poc &gt; prev-&gt;poc + 2)
+                 || cur-&gt;pict_type == FF_B_TYPE)))
+            {
+                s-&gt;low_delay = 0;
+                s-&gt;avctx-&gt;has_b_frames++;
+                out = prev;
+            }
+
+            if(out_of_order || pics &gt; s-&gt;avctx-&gt;has_b_frames){
+                for(i=out_idx; h-&gt;delayed_pic[i]; i++)
+                    h-&gt;delayed_pic[i] = h-&gt;delayed_pic[i+1];
+            }
+
+            if(prev == out)
+                *data_size = 0;
+            else
+                *data_size = sizeof(AVFrame);
+            if(prev &amp;&amp; prev != out &amp;&amp; prev-&gt;reference == DELAYED_PIC_REF)
+                prev-&gt;reference = 0;
+            h-&gt;delayed_output_pic = out;
 #endif
 
-        if(out)
-            *pict= *(AVFrame*)out;
-        else
-            av_log(avctx, AV_LOG_DEBUG, &quot;no picture\n&quot;);
+            if(out)
+                *pict= *(AVFrame*)out;
+            else
+                av_log(avctx, AV_LOG_DEBUG, &quot;no picture\n&quot;);
+        }
     }
 
     assert(pict-&gt;data[0] || !*data_size);
@@ -8086,7 +7916,7 @@
 #if 0 //?
 
     /* Return the Picture timestamp as the frame number */
-    /* we substract 1 because it is added on utils.c    */
+    /* we subtract 1 because it is added on utils.c     */
     avctx-&gt;frame_number = s-&gt;picture_number - 1;
 #endif
     return get_consumed_bytes(s, buf_index, buf_size);
@@ -8111,10 +7941,12 @@
 }
 #endif
 
-#if 0 //selftest
+#ifdef TEST
+#undef printf
+#undef random
 #define COUNT 8000
 #define SIZE (COUNT*40)
-int main(){
+int main(void){
     int i;
     uint8_t temp[SIZE];
     PutBitContext pb;
@@ -8174,6 +8006,7 @@
         STOP_TIMER(&quot;get_se_golomb&quot;);
     }
 
+#if 0
     printf(&quot;testing 4x4 (I)DCT\n&quot;);
 
     DCTELEM block[16];
@@ -8213,14 +8046,12 @@
         }
     }
     printf(&quot;error=%f max_error=%d\n&quot;, ((float)error)/COUNT/16, (int)max_error );
-#if 0
     printf(&quot;testing quantizer\n&quot;);
     for(qp=0; qp&lt;52; qp++){
         for(i=0; i&lt;16; i++)
             src1_block[i]= src2_block[i]= random()%255;
 
     }
-#endif
     printf(&quot;Testing NAL layer\n&quot;);
 
     uint8_t bitstream[COUNT];
@@ -8276,13 +8107,14 @@
             return -1;
         }
     }
+#endif
 
     printf(&quot;Testing RBSP\n&quot;);
 
 
     return 0;
 }
-#endif
+#endif /* TEST */
 
 
 static int decode_end(AVCodecContext *avctx)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -1,387 +1,427 @@
-/*
- * H.26L/H.264/AVC/JVT/14496-10/... encoder/decoder
- * Copyright (c) 2003 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file h264.h
- * H.264 / AVC / MPEG4 part10 codec.
- * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
- */
-
-#ifndef H264_H
-#define H264_H
-
-#include &quot;dsputil.h&quot;
-#include &quot;cabac.h&quot;
-#include &quot;mpegvideo.h&quot;
-
-#define interlaced_dct interlaced_dct_is_a_bad_name
-#define mb_intra mb_intra_is_not_initialized_see_mb_type
-
-#define LUMA_DC_BLOCK_INDEX   25
-#define CHROMA_DC_BLOCK_INDEX 26
-
-#define CHROMA_DC_COEFF_TOKEN_VLC_BITS 8
-#define COEFF_TOKEN_VLC_BITS           8
-#define TOTAL_ZEROS_VLC_BITS           9
-#define CHROMA_DC_TOTAL_ZEROS_VLC_BITS 3
-#define RUN_VLC_BITS                   3
-#define RUN7_VLC_BITS                  6
-
-#define MAX_SPS_COUNT 32
-#define MAX_PPS_COUNT 256
-
-#define MAX_MMCO_COUNT 66
-
-/* Compiling in interlaced support reduces the speed
- * of progressive decoding by about 2%. */
-#define ALLOW_INTERLACE
-
-#ifdef ALLOW_INTERLACE
-#define MB_MBAFF h-&gt;mb_mbaff
-#define MB_FIELD h-&gt;mb_field_decoding_flag
-#define FRAME_MBAFF h-&gt;mb_aff_frame
-#else
-#define MB_MBAFF 0
-#define MB_FIELD 0
-#define FRAME_MBAFF 0
-#undef  IS_INTERLACED
-#define IS_INTERLACED(mb_type) 0
-#endif
-
-/**
- * Sequence parameter set
- */
-typedef struct SPS{
-
-    int profile_idc;
-    int level_idc;
-    int transform_bypass;              ///&lt; qpprime_y_zero_transform_bypass_flag
-    int log2_max_frame_num;            ///&lt; log2_max_frame_num_minus4 + 4
-    int poc_type;                      ///&lt; pic_order_cnt_type
-    int log2_max_poc_lsb;              ///&lt; log2_max_pic_order_cnt_lsb_minus4
-    int delta_pic_order_always_zero_flag;
-    int offset_for_non_ref_pic;
-    int offset_for_top_to_bottom_field;
-    int poc_cycle_length;              ///&lt; num_ref_frames_in_pic_order_cnt_cycle
-    int ref_frame_count;               ///&lt; num_ref_frames
-    int gaps_in_frame_num_allowed_flag;
-    int mb_width;                      ///&lt; frame_width_in_mbs_minus1 + 1
-    int mb_height;                     ///&lt; frame_height_in_mbs_minus1 + 1
-    int frame_mbs_only_flag;
-    int mb_aff;                        ///&lt;mb_adaptive_frame_field_flag
-    int direct_8x8_inference_flag;
-    int crop;                   ///&lt; frame_cropping_flag
-    int crop_left;              ///&lt; frame_cropping_rect_left_offset
-    int crop_right;             ///&lt; frame_cropping_rect_right_offset
-    int crop_top;               ///&lt; frame_cropping_rect_top_offset
-    int crop_bottom;            ///&lt; frame_cropping_rect_bottom_offset
-    int vui_parameters_present_flag;
-    AVRational sar;
-    int timing_info_present_flag;
-    uint32_t num_units_in_tick;
-    uint32_t time_scale;
-    int fixed_frame_rate_flag;
-    short offset_for_ref_frame[256]; //FIXME dyn aloc?
-    int bitstream_restriction_flag;
-    int num_reorder_frames;
-    int scaling_matrix_present;
-    uint8_t scaling_matrix4[6][16];
-    uint8_t scaling_matrix8[2][64];
-}SPS;
-
-/**
- * Picture parameter set
- */
-typedef struct PPS{
-    unsigned int sps_id;
-    int cabac;                  ///&lt; entropy_coding_mode_flag
-    int pic_order_present;      ///&lt; pic_order_present_flag
-    int slice_group_count;      ///&lt; num_slice_groups_minus1 + 1
-    int mb_slice_group_map_type;
-    unsigned int ref_count[2];  ///&lt; num_ref_idx_l0/1_active_minus1 + 1
-    int weighted_pred;          ///&lt; weighted_pred_flag
-    int weighted_bipred_idc;
-    int init_qp;                ///&lt; pic_init_qp_minus26 + 26
-    int init_qs;                ///&lt; pic_init_qs_minus26 + 26
-    int chroma_qp_index_offset[2];
-    int deblocking_filter_parameters_present; ///&lt; deblocking_filter_parameters_present_flag
-    int constrained_intra_pred; ///&lt; constrained_intra_pred_flag
-    int redundant_pic_cnt_present; ///&lt; redundant_pic_cnt_present_flag
-    int transform_8x8_mode;     ///&lt; transform_8x8_mode_flag
-    uint8_t scaling_matrix4[6][16];
-    uint8_t scaling_matrix8[2][64];
-    uint8_t chroma_qp_table[2][256];  ///&lt; pre-scaled (with chroma_qp_index_offset) version of qp_table
-    int chroma_qp_diff;
-}PPS;
-
-/**
- * Memory management control operation opcode.
- */
-typedef enum MMCOOpcode{
-    MMCO_END=0,
-    MMCO_SHORT2UNUSED,
-    MMCO_LONG2UNUSED,
-    MMCO_SHORT2LONG,
-    MMCO_SET_MAX_LONG,
-    MMCO_RESET,
-    MMCO_LONG,
-} MMCOOpcode;
-
-/**
- * Memory management control operation.
- */
-typedef struct MMCO{
-    MMCOOpcode opcode;
-    int short_frame_num;
-    int long_index;
-} MMCO;
-
-/**
- * H264Context
- */
-typedef struct H264Context{
-    MpegEncContext s;
-    int nal_ref_idc;
-    int nal_unit_type;
-    uint8_t *rbsp_buffer[2];
-    unsigned int rbsp_buffer_size[2];
-
-    /**
-      * Used to parse AVC variant of h264
-      */
-    int is_avc; ///&lt; this flag is != 0 if codec is avc1
-    int got_avcC; ///&lt; flag used to parse avcC data only once
-    int nal_length_size; ///&lt; Number of bytes used for nal length (1, 2 or 4)
-
-    int chroma_qp[2]; //QPc
-
-    int prev_mb_skipped;
-    int next_mb_skipped;
-
-    //prediction stuff
-    int chroma_pred_mode;
-    int intra16x16_pred_mode;
-
-    int top_mb_xy;
-    int left_mb_xy[2];
-
-    int8_t intra4x4_pred_mode_cache[5*8];
-    int8_t (*intra4x4_pred_mode)[8];
-    void (*pred4x4  [9+3])(uint8_t *src, uint8_t *topright, int stride);//FIXME move to dsp?
-    void (*pred8x8l [9+3])(uint8_t *src, int topleft, int topright, int stride);
-    void (*pred8x8  [4+3])(uint8_t *src, int stride);
-    void (*pred16x16[4+3])(uint8_t *src, int stride);
-    unsigned int topleft_samples_available;
-    unsigned int top_samples_available;
-    unsigned int topright_samples_available;
-    unsigned int left_samples_available;
-    uint8_t (*top_borders[2])[16+2*8];
-    uint8_t left_border[2*(17+2*9)];
-
-    /**
-     * non zero coeff count cache.
-     * is 64 if not available.
-     */
-    DECLARE_ALIGNED_8(uint8_t, non_zero_count_cache[6*8]);
-    uint8_t (*non_zero_count)[16];
-
-    /**
-     * Motion vector cache.
-     */
-    DECLARE_ALIGNED_8(int16_t, mv_cache[2][5*8][2]);
-    DECLARE_ALIGNED_8(int8_t, ref_cache[2][5*8]);
-#define LIST_NOT_USED -1 //FIXME rename?
-#define PART_NOT_AVAILABLE -2
-
-    /**
-     * is 1 if the specific list MV&amp;references are set to 0,0,-2.
-     */
-    int mv_cache_clean[2];
-
-    /**
-     * number of neighbors (top and/or left) that used 8x8 dct
-     */
-    int neighbor_transform_size;
-
-    /**
-     * block_offset[ 0..23] for frame macroblocks
-     * block_offset[24..47] for field macroblocks
-     */
-    int block_offset[2*(16+8)];
-
-    uint32_t *mb2b_xy; //FIXME are these 4 a good idea?
-    uint32_t *mb2b8_xy;
-    int b_stride; //FIXME use s-&gt;b4_stride
-    int b8_stride;
-
-    int mb_linesize;   ///&lt; may be equal to s-&gt;linesize or s-&gt;linesize*2, for mbaff
-    int mb_uvlinesize;
-
-    int emu_edge_width;
-    int emu_edge_height;
-
-    int halfpel_flag;
-    int thirdpel_flag;
-
-    int unknown_svq3_flag;
-    int next_slice_index;
-
-    SPS *sps_buffers[MAX_SPS_COUNT];
-    SPS sps; ///&lt; current sps
-
-    PPS *pps_buffers[MAX_PPS_COUNT];
-    /**
-     * current pps
-     */
-    PPS pps; //FIXME move to Picture perhaps? (-&gt;no) do we need that?
-
-    uint32_t dequant4_buffer[6][52][16];
-    uint32_t dequant8_buffer[2][52][64];
-    uint32_t (*dequant4_coeff[6])[16];
-    uint32_t (*dequant8_coeff[2])[64];
-    int dequant_coeff_pps;     ///&lt; reinit tables when pps changes
-
-    int slice_num;
-    uint8_t *slice_table_base;
-    uint8_t *slice_table;      ///&lt; slice_table_base + 2*mb_stride + 1
-    int slice_type;
-    int slice_type_fixed;
-
-    //interlacing specific flags
-    int mb_aff_frame;
-    int mb_field_decoding_flag;
-    int mb_mbaff;              ///&lt; mb_aff_frame &amp;&amp; mb_field_decoding_flag
-
-    unsigned int sub_mb_type[4];
-
-    //POC stuff
-    int poc_lsb;
-    int poc_msb;
-    int delta_poc_bottom;
-    int delta_poc[2];
-    int frame_num;
-    int prev_poc_msb;             ///&lt; poc_msb of the last reference pic for POC type 0
-    int prev_poc_lsb;             ///&lt; poc_lsb of the last reference pic for POC type 0
-    int frame_num_offset;         ///&lt; for POC type 2
-    int prev_frame_num_offset;    ///&lt; for POC type 2
-    int prev_frame_num;           ///&lt; frame_num of the last pic for POC type 1/2
-
-    /**
-     * frame_num for frames or 2*frame_num for field pics.
-     */
-    int curr_pic_num;
-
-    /**
-     * max_frame_num or 2*max_frame_num for field pics.
-     */
-    int max_pic_num;
-
-    //Weighted pred stuff
-    int use_weight;
-    int use_weight_chroma;
-    int luma_log2_weight_denom;
-    int chroma_log2_weight_denom;
-    int luma_weight[2][48];
-    int luma_offset[2][48];
-    int chroma_weight[2][48][2];
-    int chroma_offset[2][48][2];
-    int implicit_weight[48][48];
-
-    //deblock
-    int deblocking_filter;         ///&lt; disable_deblocking_filter_idc with 1&lt;-&gt;0
-    int slice_alpha_c0_offset;
-    int slice_beta_offset;
-
-    int redundant_pic_count;
-
-    int direct_spatial_mv_pred;
-    int dist_scale_factor[16];
-    int dist_scale_factor_field[32];
-    int map_col_to_list0[2][16];
-    int map_col_to_list0_field[2][32];
-
-    /**
-     * num_ref_idx_l0/1_active_minus1 + 1
-     */
-    unsigned int ref_count[2];   ///&lt; counts frames or fields, depending on current mb mode
-    unsigned int list_count;
-    Picture *short_ref[32];
-    Picture *long_ref[32];
-    Picture default_ref_list[2][32];
-    Picture ref_list[2][48];     ///&lt; 0..15: frame refs, 16..47: mbaff field refs
-    Picture *delayed_pic[18]; //FIXME size?
-    Picture *delayed_output_pic;
-
-    /**
-     * memory management control operations buffer.
-     */
-    MMCO mmco[MAX_MMCO_COUNT];
-    int mmco_index;
-
-    int long_ref_count;  ///&lt; number of actual long term references
-    int short_ref_count; ///&lt; number of actual short term references
-
-    //data partitioning
-    GetBitContext intra_gb;
-    GetBitContext inter_gb;
-    GetBitContext *intra_gb_ptr;
-    GetBitContext *inter_gb_ptr;
-
-    DECLARE_ALIGNED_8(DCTELEM, mb[16*24]);
-    DCTELEM mb_padding[256];        ///&lt; as mb is addressed by scantable[i] and scantable is uint8_t we can either check that i is not to large or ensure that there is some unused stuff after mb
-
-    /**
-     * Cabac
-     */
-    CABACContext cabac;
-    uint8_t      cabac_state[460];
-    int          cabac_init_idc;
-
-    /* 0x100 -&gt; non null luma_dc, 0x80/0x40 -&gt; non null chroma_dc (cb/cr), 0x?0 -&gt; chroma_cbp(0,1,2), 0x0? luma_cbp */
-    uint16_t     *cbp_table;
-    int cbp;
-    int top_cbp;
-    int left_cbp;
-    /* chroma_pred_mode for i4x4 or i16x16, else 0 */
-    uint8_t     *chroma_pred_mode_table;
-    int         last_qscale_diff;
-    int16_t     (*mvd_table[2])[2];
-    DECLARE_ALIGNED_8(int16_t, mvd_cache[2][5*8][2]);
-    uint8_t     *direct_table;
-    uint8_t     direct_cache[5*8];
-
-    uint8_t zigzag_scan[16];
-    uint8_t zigzag_scan8x8[64];
-    uint8_t zigzag_scan8x8_cavlc[64];
-    uint8_t field_scan[16];
-    uint8_t field_scan8x8[64];
-    uint8_t field_scan8x8_cavlc[64];
-    const uint8_t *zigzag_scan_q0;
-    const uint8_t *zigzag_scan8x8_q0;
-    const uint8_t *zigzag_scan8x8_cavlc_q0;
-    const uint8_t *field_scan_q0;
-    const uint8_t *field_scan8x8_q0;
-    const uint8_t *field_scan8x8_cavlc_q0;
-
-    int x264_build;
-}H264Context;
-
-#endif /* H264_H */
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... encoder/decoder
+ * Copyright (c) 2003 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file h264.h
+ * H.264 / AVC / MPEG4 part10 codec.
+ * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ */
+
+#ifndef FFMPEG_H264_H
+#define FFMPEG_H264_H
+
+#include &quot;dsputil.h&quot;
+#include &quot;cabac.h&quot;
+#include &quot;mpegvideo.h&quot;
+#include &quot;h264pred.h&quot;
+
+#define interlaced_dct interlaced_dct_is_a_bad_name
+#define mb_intra mb_intra_is_not_initialized_see_mb_type
+
+#define LUMA_DC_BLOCK_INDEX   25
+#define CHROMA_DC_BLOCK_INDEX 26
+
+#define CHROMA_DC_COEFF_TOKEN_VLC_BITS 8
+#define COEFF_TOKEN_VLC_BITS           8
+#define TOTAL_ZEROS_VLC_BITS           9
+#define CHROMA_DC_TOTAL_ZEROS_VLC_BITS 3
+#define RUN_VLC_BITS                   3
+#define RUN7_VLC_BITS                  6
+
+#define MAX_SPS_COUNT 32
+#define MAX_PPS_COUNT 256
+
+#define MAX_MMCO_COUNT 66
+
+#define MAX_DELAYED_PIC_COUNT 16
+
+/* Compiling in interlaced support reduces the speed
+ * of progressive decoding by about 2%. */
+#define ALLOW_INTERLACE
+
+#ifdef ALLOW_INTERLACE
+#define MB_MBAFF h-&gt;mb_mbaff
+#define MB_FIELD h-&gt;mb_field_decoding_flag
+#define FRAME_MBAFF h-&gt;mb_aff_frame
+#define FIELD_PICTURE (s-&gt;picture_structure != PICT_FRAME)
+#else
+#define MB_MBAFF 0
+#define MB_FIELD 0
+#define FRAME_MBAFF 0
+#define FIELD_PICTURE 0
+#undef  IS_INTERLACED
+#define IS_INTERLACED(mb_type) 0
+#endif
+#define FIELD_OR_MBAFF_PICTURE (FRAME_MBAFF || FIELD_PICTURE)
+
+#ifndef ENABLE_H264_ENCODER
+#define ENABLE_H264_ENCODER 0
+#endif
+
+/**
+ * Sequence parameter set
+ */
+typedef struct SPS{
+
+    int profile_idc;
+    int level_idc;
+    int transform_bypass;              ///&lt; qpprime_y_zero_transform_bypass_flag
+    int log2_max_frame_num;            ///&lt; log2_max_frame_num_minus4 + 4
+    int poc_type;                      ///&lt; pic_order_cnt_type
+    int log2_max_poc_lsb;              ///&lt; log2_max_pic_order_cnt_lsb_minus4
+    int delta_pic_order_always_zero_flag;
+    int offset_for_non_ref_pic;
+    int offset_for_top_to_bottom_field;
+    int poc_cycle_length;              ///&lt; num_ref_frames_in_pic_order_cnt_cycle
+    int ref_frame_count;               ///&lt; num_ref_frames
+    int gaps_in_frame_num_allowed_flag;
+    int mb_width;                      ///&lt; pic_width_in_mbs_minus1 + 1
+    int mb_height;                     ///&lt; pic_height_in_map_units_minus1 + 1
+    int frame_mbs_only_flag;
+    int mb_aff;                        ///&lt;mb_adaptive_frame_field_flag
+    int direct_8x8_inference_flag;
+    int crop;                   ///&lt; frame_cropping_flag
+    unsigned int crop_left;            ///&lt; frame_cropping_rect_left_offset
+    unsigned int crop_right;           ///&lt; frame_cropping_rect_right_offset
+    unsigned int crop_top;             ///&lt; frame_cropping_rect_top_offset
+    unsigned int crop_bottom;          ///&lt; frame_cropping_rect_bottom_offset
+    int vui_parameters_present_flag;
+    AVRational sar;
+    int timing_info_present_flag;
+    uint32_t num_units_in_tick;
+    uint32_t time_scale;
+    int fixed_frame_rate_flag;
+    short offset_for_ref_frame[256]; //FIXME dyn aloc?
+    int bitstream_restriction_flag;
+    int num_reorder_frames;
+    int scaling_matrix_present;
+    uint8_t scaling_matrix4[6][16];
+    uint8_t scaling_matrix8[2][64];
+}SPS;
+
+/**
+ * Picture parameter set
+ */
+typedef struct PPS{
+    unsigned int sps_id;
+    int cabac;                  ///&lt; entropy_coding_mode_flag
+    int pic_order_present;      ///&lt; pic_order_present_flag
+    int slice_group_count;      ///&lt; num_slice_groups_minus1 + 1
+    int mb_slice_group_map_type;
+    unsigned int ref_count[2];  ///&lt; num_ref_idx_l0/1_active_minus1 + 1
+    int weighted_pred;          ///&lt; weighted_pred_flag
+    int weighted_bipred_idc;
+    int init_qp;                ///&lt; pic_init_qp_minus26 + 26
+    int init_qs;                ///&lt; pic_init_qs_minus26 + 26
+    int chroma_qp_index_offset[2];
+    int deblocking_filter_parameters_present; ///&lt; deblocking_filter_parameters_present_flag
+    int constrained_intra_pred; ///&lt; constrained_intra_pred_flag
+    int redundant_pic_cnt_present; ///&lt; redundant_pic_cnt_present_flag
+    int transform_8x8_mode;     ///&lt; transform_8x8_mode_flag
+    uint8_t scaling_matrix4[6][16];
+    uint8_t scaling_matrix8[2][64];
+    uint8_t chroma_qp_table[2][256];  ///&lt; pre-scaled (with chroma_qp_index_offset) version of qp_table
+    int chroma_qp_diff;
+}PPS;
+
+/**
+ * Memory management control operation opcode.
+ */
+typedef enum MMCOOpcode{
+    MMCO_END=0,
+    MMCO_SHORT2UNUSED,
+    MMCO_LONG2UNUSED,
+    MMCO_SHORT2LONG,
+    MMCO_SET_MAX_LONG,
+    MMCO_RESET,
+    MMCO_LONG,
+} MMCOOpcode;
+
+/**
+ * Memory management control operation.
+ */
+typedef struct MMCO{
+    MMCOOpcode opcode;
+    int short_pic_num;  ///&lt; pic_num without wrapping (pic_num &amp; max_pic_num)
+    int long_arg;       ///&lt; index, pic_num, or num long refs depending on opcode
+} MMCO;
+
+/**
+ * H264Context
+ */
+typedef struct H264Context{
+    MpegEncContext s;
+    int nal_ref_idc;
+    int nal_unit_type;
+    uint8_t *rbsp_buffer[2];
+    unsigned int rbsp_buffer_size[2];
+
+    /**
+      * Used to parse AVC variant of h264
+      */
+    int is_avc; ///&lt; this flag is != 0 if codec is avc1
+    int got_avcC; ///&lt; flag used to parse avcC data only once
+    int nal_length_size; ///&lt; Number of bytes used for nal length (1, 2 or 4)
+
+    int chroma_qp[2]; //QPc
+
+    int prev_mb_skipped;
+    int next_mb_skipped;
+
+    //prediction stuff
+    int chroma_pred_mode;
+    int intra16x16_pred_mode;
+
+    int top_mb_xy;
+    int left_mb_xy[2];
+
+    int8_t intra4x4_pred_mode_cache[5*8];
+    int8_t (*intra4x4_pred_mode)[8];
+    H264PredContext hpc;
+    unsigned int topleft_samples_available;
+    unsigned int top_samples_available;
+    unsigned int topright_samples_available;
+    unsigned int left_samples_available;
+    uint8_t (*top_borders[2])[16+2*8];
+    uint8_t left_border[2*(17+2*9)];
+
+    /**
+     * non zero coeff count cache.
+     * is 64 if not available.
+     */
+    DECLARE_ALIGNED_8(uint8_t, non_zero_count_cache[6*8]);
+    uint8_t (*non_zero_count)[16];
+
+    /**
+     * Motion vector cache.
+     */
+    DECLARE_ALIGNED_8(int16_t, mv_cache[2][5*8][2]);
+    DECLARE_ALIGNED_8(int8_t, ref_cache[2][5*8]);
+#define LIST_NOT_USED -1 //FIXME rename?
+#define PART_NOT_AVAILABLE -2
+
+    /**
+     * is 1 if the specific list MV&amp;references are set to 0,0,-2.
+     */
+    int mv_cache_clean[2];
+
+    /**
+     * number of neighbors (top and/or left) that used 8x8 dct
+     */
+    int neighbor_transform_size;
+
+    /**
+     * block_offset[ 0..23] for frame macroblocks
+     * block_offset[24..47] for field macroblocks
+     */
+    int block_offset[2*(16+8)];
+
+    uint32_t *mb2b_xy; //FIXME are these 4 a good idea?
+    uint32_t *mb2b8_xy;
+    int b_stride; //FIXME use s-&gt;b4_stride
+    int b8_stride;
+
+    int mb_linesize;   ///&lt; may be equal to s-&gt;linesize or s-&gt;linesize*2, for mbaff
+    int mb_uvlinesize;
+
+    int emu_edge_width;
+    int emu_edge_height;
+
+    int halfpel_flag;
+    int thirdpel_flag;
+
+    int unknown_svq3_flag;
+    int next_slice_index;
+
+    SPS *sps_buffers[MAX_SPS_COUNT];
+    SPS sps; ///&lt; current sps
+
+    PPS *pps_buffers[MAX_PPS_COUNT];
+    /**
+     * current pps
+     */
+    PPS pps; //FIXME move to Picture perhaps? (-&gt;no) do we need that?
+
+    uint32_t dequant4_buffer[6][52][16];
+    uint32_t dequant8_buffer[2][52][64];
+    uint32_t (*dequant4_coeff[6])[16];
+    uint32_t (*dequant8_coeff[2])[64];
+    int dequant_coeff_pps;     ///&lt; reinit tables when pps changes
+
+    int slice_num;
+    uint8_t *slice_table_base;
+    uint8_t *slice_table;      ///&lt; slice_table_base + 2*mb_stride + 1
+    int slice_type;
+    int slice_type_fixed;
+
+    //interlacing specific flags
+    int mb_aff_frame;
+    int mb_field_decoding_flag;
+    int mb_mbaff;              ///&lt; mb_aff_frame &amp;&amp; mb_field_decoding_flag
+
+    unsigned int sub_mb_type[4];
+
+    //POC stuff
+    int poc_lsb;
+    int poc_msb;
+    int delta_poc_bottom;
+    int delta_poc[2];
+    int frame_num;
+    int prev_poc_msb;             ///&lt; poc_msb of the last reference pic for POC type 0
+    int prev_poc_lsb;             ///&lt; poc_lsb of the last reference pic for POC type 0
+    int frame_num_offset;         ///&lt; for POC type 2
+    int prev_frame_num_offset;    ///&lt; for POC type 2
+    int prev_frame_num;           ///&lt; frame_num of the last pic for POC type 1/2
+
+    /**
+     * frame_num for frames or 2*frame_num+1 for field pics.
+     */
+    int curr_pic_num;
+
+    /**
+     * max_frame_num or 2*max_frame_num for field pics.
+     */
+    int max_pic_num;
+
+    //Weighted pred stuff
+    int use_weight;
+    int use_weight_chroma;
+    int luma_log2_weight_denom;
+    int chroma_log2_weight_denom;
+    int luma_weight[2][48];
+    int luma_offset[2][48];
+    int chroma_weight[2][48][2];
+    int chroma_offset[2][48][2];
+    int implicit_weight[48][48];
+
+    //deblock
+    int deblocking_filter;         ///&lt; disable_deblocking_filter_idc with 1&lt;-&gt;0
+    int slice_alpha_c0_offset;
+    int slice_beta_offset;
+
+    int redundant_pic_count;
+
+    int direct_spatial_mv_pred;
+    int dist_scale_factor[16];
+    int dist_scale_factor_field[32];
+    int map_col_to_list0[2][16];
+    int map_col_to_list0_field[2][32];
+
+    /**
+     * num_ref_idx_l0/1_active_minus1 + 1
+     */
+    unsigned int ref_count[2];   ///&lt; counts frames or fields, depending on current mb mode
+    unsigned int list_count;
+    Picture *short_ref[32];
+    Picture *long_ref[32];
+    Picture default_ref_list[2][32]; ///&lt; base reference list for all slices of a coded picture
+    Picture ref_list[2][48];         /**&lt; 0..15: frame refs, 16..47: mbaff field refs.
+                                          Reordered version of default_ref_list
+                                          according to picture reordering in slice header */
+    Picture *delayed_pic[MAX_DELAYED_PIC_COUNT+2]; //FIXME size?
+    Picture *delayed_output_pic;
+
+    /**
+     * memory management control operations buffer.
+     */
+    MMCO mmco[MAX_MMCO_COUNT];
+    int mmco_index;
+
+    int long_ref_count;  ///&lt; number of actual long term references
+    int short_ref_count; ///&lt; number of actual short term references
+
+    //data partitioning
+    GetBitContext intra_gb;
+    GetBitContext inter_gb;
+    GetBitContext *intra_gb_ptr;
+    GetBitContext *inter_gb_ptr;
+
+    DECLARE_ALIGNED_16(DCTELEM, mb[16*24]);
+    DCTELEM mb_padding[256];        ///&lt; as mb is addressed by scantable[i] and scantable is uint8_t we can either check that i is not too large or ensure that there is some unused stuff after mb
+
+    /**
+     * Cabac
+     */
+    CABACContext cabac;
+    uint8_t      cabac_state[460];
+    int          cabac_init_idc;
+
+    /* 0x100 -&gt; non null luma_dc, 0x80/0x40 -&gt; non null chroma_dc (cb/cr), 0x?0 -&gt; chroma_cbp(0,1,2), 0x0? luma_cbp */
+    uint16_t     *cbp_table;
+    int cbp;
+    int top_cbp;
+    int left_cbp;
+    /* chroma_pred_mode for i4x4 or i16x16, else 0 */
+    uint8_t     *chroma_pred_mode_table;
+    int         last_qscale_diff;
+    int16_t     (*mvd_table[2])[2];
+    DECLARE_ALIGNED_8(int16_t, mvd_cache[2][5*8][2]);
+    uint8_t     *direct_table;
+    uint8_t     direct_cache[5*8];
+
+    uint8_t zigzag_scan[16];
+    uint8_t zigzag_scan8x8[64];
+    uint8_t zigzag_scan8x8_cavlc[64];
+    uint8_t field_scan[16];
+    uint8_t field_scan8x8[64];
+    uint8_t field_scan8x8_cavlc[64];
+    const uint8_t *zigzag_scan_q0;
+    const uint8_t *zigzag_scan8x8_q0;
+    const uint8_t *zigzag_scan8x8_cavlc_q0;
+    const uint8_t *field_scan_q0;
+    const uint8_t *field_scan8x8_q0;
+    const uint8_t *field_scan8x8_cavlc_q0;
+
+    int x264_build;
+
+    /**
+     * @defgroup multithreading Members for slice based multithreading
+     * @{
+     */
+    struct H264Context *thread_context[MAX_THREADS];
+
+    /**
+     * current slice number, used to initalize slice_num of each thread/context
+     */
+    int current_slice;
+
+    /**
+     * Max number of threads / contexts.
+     * This is equal to AVCodecContext.thread_count unless
+     * multithreaded decoding is impossible, in which case it is
+     * reduced to 1.
+     */
+    int max_contexts;
+
+    /**
+     *  1 if the single thread fallback warning has already been
+     *  displayed, 0 otherwise.
+     */
+    int single_decode_warning;
+
+    int last_slice_type;
+    /** @} */
+
+    int mb_xy;
+
+}H264Context;
+
+#endif /* FFMPEG_H264_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -1,39 +1,39 @@
-/*
- * H.26L/H.264/AVC/JVT/14496-10/... parser
- * Copyright (c) 2003 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file h264_parser.h
- * H.264 / AVC / MPEG4 part10 parser.
- * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
- */
-
-#ifndef H264_PARSER_H
-#define H264_PARSER_H
-
-#include &quot;h264.h&quot;
-
-/**
- * finds the end of the current frame in the bitstream.
- * @return the position of the first byte of the next frame, or -1
- */
-int ff_h264_find_frame_end(H264Context *h, const uint8_t *buf, int buf_size);
-
-#endif /* H264_PARSER_H */
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... parser
+ * Copyright (c) 2003 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file h264_parser.h
+ * H.264 / AVC / MPEG4 part10 parser.
+ * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ */
+
+#ifndef FFMPEG_H264_PARSER_H
+#define FFMPEG_H264_PARSER_H
+
+#include &quot;h264.h&quot;
+
+/**
+ * finds the end of the current frame in the bitstream.
+ * @return the position of the first byte of the next frame, or -1
+ */
+int ff_h264_find_frame_end(H264Context *h, const uint8_t *buf, int buf_size);
+
+#endif /* FFMPEG_H264_PARSER_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264data.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264data.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264data.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -26,37 +26,14 @@
  * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
  */
 
-#ifndef AVCODEC_H264DATA_H
-#define AVCODEC_H264DATA_H
+#ifndef FFMPEG_H264DATA_H
+#define FFMPEG_H264DATA_H
 
 #include &lt;stdint.h&gt;
-#include &quot;mpegvideo.h&quot;
 #include &quot;rational.h&quot;
+#include &quot;mpegvideo.h&quot;
 
-#define VERT_PRED             0
-#define HOR_PRED              1
-#define DC_PRED               2
-#define DIAG_DOWN_LEFT_PRED   3
-#define DIAG_DOWN_RIGHT_PRED  4
-#define VERT_RIGHT_PRED       5
-#define HOR_DOWN_PRED         6
-#define VERT_LEFT_PRED        7
-#define HOR_UP_PRED           8
 
-#define LEFT_DC_PRED          9
-#define TOP_DC_PRED           10
-#define DC_128_PRED           11
-
-
-#define DC_PRED8x8            0
-#define HOR_PRED8x8           1
-#define VERT_PRED8x8          2
-#define PLANE_PRED8x8         3
-
-#define LEFT_DC_PRED8x8       4
-#define TOP_DC_PRED8x8        5
-#define DC_128_PRED8x8        6
-
 #define EXTENDED_SAR          255
 
 /* NAL unit types */
@@ -77,7 +54,7 @@
 NAL_AUXILIARY_SLICE=19
 };
 
-static const AVRational pixel_aspect[14]={
+static const AVRational pixel_aspect[17]={
  {0, 1},
  {1, 1},
  {12, 11},
@@ -92,10 +69,13 @@
  {15, 11},
  {64, 33},
  {160,99},
+ {4, 3},
+ {3, 2},
+ {2, 1},
 };
 
 static const uint8_t golomb_to_pict_type[5]=
-{P_TYPE, B_TYPE, I_TYPE, SP_TYPE, SI_TYPE};
+{FF_P_TYPE, FF_B_TYPE, FF_I_TYPE, FF_SP_TYPE, FF_SI_TYPE};
 
 static const uint8_t pict_type_to_golomb[7]=
 {-1, 2, 0, 1, -1, 4, 3};
@@ -544,7 +524,7 @@
    24,25,27,28,30,32,33,35
 }};
 
-static const int dequant4_coeff_init[6][3]={
+static const uint8_t dequant4_coeff_init[6][3]={
   {10,13,16},
   {11,14,18},
   {13,16,20},
@@ -553,10 +533,10 @@
   {18,23,29},
 };
 
-static const int dequant8_coeff_init_scan[16] = {
+static const uint8_t dequant8_coeff_init_scan[16] = {
   0,3,4,3, 3,1,5,1, 4,5,2,5, 3,1,5,1
 };
-static const int dequant8_coeff_init[6][6]={
+static const uint8_t dequant8_coeff_init[6][6]={
   {20,18,32,19,25,24},
   {22,19,35,21,28,26},
   {26,23,42,24,33,31},
@@ -624,7 +604,7 @@
 
 
 /* Deblocking filter (p153) */
-static const int alpha_table[52*3] = {
+static const uint8_t alpha_table[52*3] = {
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
@@ -640,7 +620,7 @@
    255,255,255,255,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,
 };
-static const int beta_table[52*3] = {
+static const uint8_t beta_table[52*3] = {
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
@@ -656,7 +636,7 @@
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 };
-static const int tc0_table[52*3][3] = {
+static const uint8_t tc0_table[52*3][3] = {
     { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 },
     { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 },
     { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 },
@@ -688,7 +668,7 @@
 
 /* Cabac pre state table */
 
-static const int cabac_context_init_I[460][2] =
+static const int8_t cabac_context_init_I[460][2] =
 {
     /* 0 - 10 */
     { 20, -15 }, {  2, 54 },  {  3,  74 }, { 20, -15 },
@@ -857,7 +837,7 @@
     {  29,   9 }, {  35,  20 }, {  29,  36 }, {  14,  67 }
 };
 
-static const int cabac_context_init_PB[3][460][2] =
+static const int8_t cabac_context_init_PB[3][460][2] =
 {
     /* i_cabac_init_idc == 0 */
     {
@@ -1328,4 +1308,4 @@
     }
 };
 
-#endif // AVCODEC_H264DATA_H
+#endif /* FFMPEG_H264DATA_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.c	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.c	2008-07-24 18:20:17 UTC (rev 4281)
@@ -0,0 +1,1073 @@
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... encoder/decoder
+ * Copyright (c) 2003 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file h264pred.c
+ * H.264 / AVC / MPEG4 part10 prediction functions.
+ * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ */
+
+#include &quot;avcodec.h&quot;
+#include &quot;mpegvideo.h&quot;
+#include &quot;h264pred.h&quot;
+
+static void pred4x4_vertical_c(uint8_t *src, uint8_t *topright, int stride){
+    const uint32_t a= ((uint32_t*)(src-stride))[0];
+    ((uint32_t*)(src+0*stride))[0]= a;
+    ((uint32_t*)(src+1*stride))[0]= a;
+    ((uint32_t*)(src+2*stride))[0]= a;
+    ((uint32_t*)(src+3*stride))[0]= a;
+}
+
+static void pred4x4_horizontal_c(uint8_t *src, uint8_t *topright, int stride){
+    ((uint32_t*)(src+0*stride))[0]= src[-1+0*stride]*0x01010101;
+    ((uint32_t*)(src+1*stride))[0]= src[-1+1*stride]*0x01010101;
+    ((uint32_t*)(src+2*stride))[0]= src[-1+2*stride]*0x01010101;
+    ((uint32_t*)(src+3*stride))[0]= src[-1+3*stride]*0x01010101;
+}
+
+static void pred4x4_dc_c(uint8_t *src, uint8_t *topright, int stride){
+    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride]
+                   + src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 4) &gt;&gt;3;
+
+    ((uint32_t*)(src+0*stride))[0]=
+    ((uint32_t*)(src+1*stride))[0]=
+    ((uint32_t*)(src+2*stride))[0]=
+    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
+}
+
+static void pred4x4_left_dc_c(uint8_t *src, uint8_t *topright, int stride){
+    const int dc= (  src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 2) &gt;&gt;2;
+
+    ((uint32_t*)(src+0*stride))[0]=
+    ((uint32_t*)(src+1*stride))[0]=
+    ((uint32_t*)(src+2*stride))[0]=
+    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
+}
+
+static void pred4x4_top_dc_c(uint8_t *src, uint8_t *topright, int stride){
+    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride] + 2) &gt;&gt;2;
+
+    ((uint32_t*)(src+0*stride))[0]=
+    ((uint32_t*)(src+1*stride))[0]=
+    ((uint32_t*)(src+2*stride))[0]=
+    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
+}
+
+static void pred4x4_128_dc_c(uint8_t *src, uint8_t *topright, int stride){
+    ((uint32_t*)(src+0*stride))[0]=
+    ((uint32_t*)(src+1*stride))[0]=
+    ((uint32_t*)(src+2*stride))[0]=
+    ((uint32_t*)(src+3*stride))[0]= 128U*0x01010101U;
+}
+
+
+#define LOAD_TOP_RIGHT_EDGE\
+    const int av_unused t4= topright[0];\
+    const int av_unused t5= topright[1];\
+    const int av_unused t6= topright[2];\
+    const int av_unused t7= topright[3];\
+
+#define LOAD_DOWN_LEFT_EDGE\
+    const int av_unused l4= src[-1+4*stride];\
+    const int av_unused l5= src[-1+5*stride];\
+    const int av_unused l6= src[-1+6*stride];\
+    const int av_unused l7= src[-1+7*stride];\
+
+#define LOAD_LEFT_EDGE\
+    const int av_unused l0= src[-1+0*stride];\
+    const int av_unused l1= src[-1+1*stride];\
+    const int av_unused l2= src[-1+2*stride];\
+    const int av_unused l3= src[-1+3*stride];\
+
+#define LOAD_TOP_EDGE\
+    const int av_unused t0= src[ 0-1*stride];\
+    const int av_unused t1= src[ 1-1*stride];\
+    const int av_unused t2= src[ 2-1*stride];\
+    const int av_unused t3= src[ 3-1*stride];\
+
+static void pred4x4_down_right_c(uint8_t *src, uint8_t *topright, int stride){
+    const int lt= src[-1-1*stride];
+    LOAD_TOP_EDGE
+    LOAD_LEFT_EDGE
+
+    src[0+3*stride]=(l3 + 2*l2 + l1 + 2)&gt;&gt;2;
+    src[0+2*stride]=
+    src[1+3*stride]=(l2 + 2*l1 + l0 + 2)&gt;&gt;2;
+    src[0+1*stride]=
+    src[1+2*stride]=
+    src[2+3*stride]=(l1 + 2*l0 + lt + 2)&gt;&gt;2;
+    src[0+0*stride]=
+    src[1+1*stride]=
+    src[2+2*stride]=
+    src[3+3*stride]=(l0 + 2*lt + t0 + 2)&gt;&gt;2;
+    src[1+0*stride]=
+    src[2+1*stride]=
+    src[3+2*stride]=(lt + 2*t0 + t1 + 2)&gt;&gt;2;
+    src[2+0*stride]=
+    src[3+1*stride]=(t0 + 2*t1 + t2 + 2)&gt;&gt;2;
+    src[3+0*stride]=(t1 + 2*t2 + t3 + 2)&gt;&gt;2;
+}
+
+static void pred4x4_down_left_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+//    LOAD_LEFT_EDGE
+
+    src[0+0*stride]=(t0 + t2 + 2*t1 + 2)&gt;&gt;2;
+    src[1+0*stride]=
+    src[0+1*stride]=(t1 + t3 + 2*t2 + 2)&gt;&gt;2;
+    src[2+0*stride]=
+    src[1+1*stride]=
+    src[0+2*stride]=(t2 + t4 + 2*t3 + 2)&gt;&gt;2;
+    src[3+0*stride]=
+    src[2+1*stride]=
+    src[1+2*stride]=
+    src[0+3*stride]=(t3 + t5 + 2*t4 + 2)&gt;&gt;2;
+    src[3+1*stride]=
+    src[2+2*stride]=
+    src[1+3*stride]=(t4 + t6 + 2*t5 + 2)&gt;&gt;2;
+    src[3+2*stride]=
+    src[2+3*stride]=(t5 + t7 + 2*t6 + 2)&gt;&gt;2;
+    src[3+3*stride]=(t6 + 3*t7 + 2)&gt;&gt;2;
+}
+
+static void pred4x4_down_left_svq3_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_TOP_EDGE
+    LOAD_LEFT_EDGE
+    const av_unused int unu0= t0;
+    const av_unused int unu1= l0;
+
+    src[0+0*stride]=(l1 + t1)&gt;&gt;1;
+    src[1+0*stride]=
+    src[0+1*stride]=(l2 + t2)&gt;&gt;1;
+    src[2+0*stride]=
+    src[1+1*stride]=
+    src[0+2*stride]=
+    src[3+0*stride]=
+    src[2+1*stride]=
+    src[1+2*stride]=
+    src[0+3*stride]=
+    src[3+1*stride]=
+    src[2+2*stride]=
+    src[1+3*stride]=
+    src[3+2*stride]=
+    src[2+3*stride]=
+    src[3+3*stride]=(l3 + t3)&gt;&gt;1;
+}
+
+static void pred4x4_down_left_rv40_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+    LOAD_LEFT_EDGE
+    LOAD_DOWN_LEFT_EDGE
+
+    src[0+0*stride]=(t0 + t2 + 2*t1 + 2 + l0 + l2 + 2*l1 + 2)&gt;&gt;3;
+    src[1+0*stride]=
+    src[0+1*stride]=(t1 + t3 + 2*t2 + 2 + l1 + l3 + 2*l2 + 2)&gt;&gt;3;
+    src[2+0*stride]=
+    src[1+1*stride]=
+    src[0+2*stride]=(t2 + t4 + 2*t3 + 2 + l2 + l4 + 2*l3 + 2)&gt;&gt;3;
+    src[3+0*stride]=
+    src[2+1*stride]=
+    src[1+2*stride]=
+    src[0+3*stride]=(t3 + t5 + 2*t4 + 2 + l3 + l5 + 2*l4 + 2)&gt;&gt;3;
+    src[3+1*stride]=
+    src[2+2*stride]=
+    src[1+3*stride]=(t4 + t6 + 2*t5 + 2 + l4 + l6 + 2*l5 + 2)&gt;&gt;3;
+    src[3+2*stride]=
+    src[2+3*stride]=(t5 + t7 + 2*t6 + 2 + l5 + l7 + 2*l6 + 2)&gt;&gt;3;
+    src[3+3*stride]=(t6 + t7 + 1 + l6 + l7 + 1)&gt;&gt;2;
+}
+
+static void pred4x4_down_left_rv40_notop_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+    LOAD_DOWN_LEFT_EDGE
+
+    src[0+0*stride]=(l0 + l2 + 2*l1 + 2)&gt;&gt;2;
+    src[1+0*stride]=
+    src[0+1*stride]=(l1 + l3 + 2*l2 + 2)&gt;&gt;2;
+    src[2+0*stride]=
+    src[1+1*stride]=
+    src[0+2*stride]=(l2 + l4 + 2*l3 + 2)&gt;&gt;2;
+    src[3+0*stride]=
+    src[2+1*stride]=
+    src[1+2*stride]=
+    src[0+3*stride]=(l3 + l5 + 2*l4 + 2)&gt;&gt;2;
+    src[3+1*stride]=
+    src[2+2*stride]=
+    src[1+3*stride]=(l4 + l6 + 2*l5 + 2)&gt;&gt;2;
+    src[3+2*stride]=
+    src[2+3*stride]=(l5 + l7 + 2*l6 + 2)&gt;&gt;2;
+    src[3+3*stride]=(l6 + l7 + 1)&gt;&gt;1;
+}
+
+static void pred4x4_down_left_rv40_nodown_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+    LOAD_LEFT_EDGE
+
+    src[0+0*stride]=(t0 + t2 + 2*t1 + 2 + l0 + l2 + 2*l1 + 2)&gt;&gt;3;
+    src[1+0*stride]=
+    src[0+1*stride]=(t1 + t3 + 2*t2 + 2 + l1 + l3 + 2*l2 + 2)&gt;&gt;3;
+    src[2+0*stride]=
+    src[1+1*stride]=
+    src[0+2*stride]=(t2 + t4 + 2*t3 + 2 + l2 + 3*l3 + 2)&gt;&gt;3;
+    src[3+0*stride]=
+    src[2+1*stride]=
+    src[1+2*stride]=
+    src[0+3*stride]=(t3 + t5 + 2*t4 + 2 + l3*4 + 2)&gt;&gt;3;
+    src[3+1*stride]=
+    src[2+2*stride]=
+    src[1+3*stride]=(t4 + t6 + 2*t5 + 2 + l3*4 + 2)&gt;&gt;3;
+    src[3+2*stride]=
+    src[2+3*stride]=(t5 + t7 + 2*t6 + 2 + l3*4 + 2)&gt;&gt;3;
+    src[3+3*stride]=(t6 + t7 + 1 + 2*l3 + 1)&gt;&gt;2;
+}
+
+static void pred4x4_vertical_right_c(uint8_t *src, uint8_t *topright, int stride){
+    const int lt= src[-1-1*stride];
+    LOAD_TOP_EDGE
+    LOAD_LEFT_EDGE
+
+    src[0+0*stride]=
+    src[1+2*stride]=(lt + t0 + 1)&gt;&gt;1;
+    src[1+0*stride]=
+    src[2+2*stride]=(t0 + t1 + 1)&gt;&gt;1;
+    src[2+0*stride]=
+    src[3+2*stride]=(t1 + t2 + 1)&gt;&gt;1;
+    src[3+0*stride]=(t2 + t3 + 1)&gt;&gt;1;
+    src[0+1*stride]=
+    src[1+3*stride]=(l0 + 2*lt + t0 + 2)&gt;&gt;2;
+    src[1+1*stride]=
+    src[2+3*stride]=(lt + 2*t0 + t1 + 2)&gt;&gt;2;
+    src[2+1*stride]=
+    src[3+3*stride]=(t0 + 2*t1 + t2 + 2)&gt;&gt;2;
+    src[3+1*stride]=(t1 + 2*t2 + t3 + 2)&gt;&gt;2;
+    src[0+2*stride]=(lt + 2*l0 + l1 + 2)&gt;&gt;2;
+    src[0+3*stride]=(l0 + 2*l1 + l2 + 2)&gt;&gt;2;
+}
+
+static void pred4x4_vertical_left_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+
+    src[0+0*stride]=(t0 + t1 + 1)&gt;&gt;1;
+    src[1+0*stride]=
+    src[0+2*stride]=(t1 + t2 + 1)&gt;&gt;1;
+    src[2+0*stride]=
+    src[1+2*stride]=(t2 + t3 + 1)&gt;&gt;1;
+    src[3+0*stride]=
+    src[2+2*stride]=(t3 + t4+ 1)&gt;&gt;1;
+    src[3+2*stride]=(t4 + t5+ 1)&gt;&gt;1;
+    src[0+1*stride]=(t0 + 2*t1 + t2 + 2)&gt;&gt;2;
+    src[1+1*stride]=
+    src[0+3*stride]=(t1 + 2*t2 + t3 + 2)&gt;&gt;2;
+    src[2+1*stride]=
+    src[1+3*stride]=(t2 + 2*t3 + t4 + 2)&gt;&gt;2;
+    src[3+1*stride]=
+    src[2+3*stride]=(t3 + 2*t4 + t5 + 2)&gt;&gt;2;
+    src[3+3*stride]=(t4 + 2*t5 + t6 + 2)&gt;&gt;2;
+}
+
+static void pred4x4_vertical_left_rv40(uint8_t *src, uint8_t *topright, int stride,
+                                      const int l0, const int l1, const int l2, const int l3, const int l4){
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+
+    src[0+0*stride]=(2*t0 + 2*t1 + l1 + 2*l2 + l3 + 4)&gt;&gt;3;
+    src[1+0*stride]=
+    src[0+2*stride]=(t1 + t2 + 1)&gt;&gt;1;
+    src[2+0*stride]=
+    src[1+2*stride]=(t2 + t3 + 1)&gt;&gt;1;
+    src[3+0*stride]=
+    src[2+2*stride]=(t3 + t4+ 1)&gt;&gt;1;
+    src[3+2*stride]=(t4 + t5+ 1)&gt;&gt;1;
+    src[0+1*stride]=(t0 + 2*t1 + t2 + l2 + 2*l3 + l4 + 4)&gt;&gt;3;
+    src[1+1*stride]=
+    src[0+3*stride]=(t1 + 2*t2 + t3 + 2)&gt;&gt;2;
+    src[2+1*stride]=
+    src[1+3*stride]=(t2 + 2*t3 + t4 + 2)&gt;&gt;2;
+    src[3+1*stride]=
+    src[2+3*stride]=(t3 + 2*t4 + t5 + 2)&gt;&gt;2;
+    src[3+3*stride]=(t4 + 2*t5 + t6 + 2)&gt;&gt;2;
+}
+
+static void pred4x4_vertical_left_rv40_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+    LOAD_DOWN_LEFT_EDGE
+
+    pred4x4_vertical_left_rv40(src, topright, stride, l0, l1, l2, l3, l4);
+}
+
+static void pred4x4_vertical_left_rv40_nodown_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+
+    pred4x4_vertical_left_rv40(src, topright, stride, l0, l1, l2, l3, l3);
+}
+
+static void pred4x4_horizontal_up_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+
+    src[0+0*stride]=(l0 + l1 + 1)&gt;&gt;1;
+    src[1+0*stride]=(l0 + 2*l1 + l2 + 2)&gt;&gt;2;
+    src[2+0*stride]=
+    src[0+1*stride]=(l1 + l2 + 1)&gt;&gt;1;
+    src[3+0*stride]=
+    src[1+1*stride]=(l1 + 2*l2 + l3 + 2)&gt;&gt;2;
+    src[2+1*stride]=
+    src[0+2*stride]=(l2 + l3 + 1)&gt;&gt;1;
+    src[3+1*stride]=
+    src[1+2*stride]=(l2 + 2*l3 + l3 + 2)&gt;&gt;2;
+    src[3+2*stride]=
+    src[1+3*stride]=
+    src[0+3*stride]=
+    src[2+2*stride]=
+    src[2+3*stride]=
+    src[3+3*stride]=l3;
+}
+
+static void pred4x4_horizontal_up_rv40_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+    LOAD_DOWN_LEFT_EDGE
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+
+    src[0+0*stride]=(t1 + 2*t2 + t3 + 2*l0 + 2*l1 + 4)&gt;&gt;3;
+    src[1+0*stride]=(t2 + 2*t3 + t4 + l0 + 2*l1 + l2 + 4)&gt;&gt;3;
+    src[2+0*stride]=
+    src[0+1*stride]=(t3 + 2*t4 + t5 + 2*l1 + 2*l2 + 4)&gt;&gt;3;
+    src[3+0*stride]=
+    src[1+1*stride]=(t4 + 2*t5 + t6 + l1 + 2*l2 + l3 + 4)&gt;&gt;3;
+    src[2+1*stride]=
+    src[0+2*stride]=(t5 + 2*t6 + t7 + 2*l2 + 2*l3 + 4)&gt;&gt;3;
+    src[3+1*stride]=
+    src[1+2*stride]=(t6 + 3*t7 + l2 + 3*l3 + 4)&gt;&gt;3;
+    src[3+2*stride]=
+    src[1+3*stride]=(l3 + 2*l4 + l5 + 2)&gt;&gt;2;
+    src[0+3*stride]=
+    src[2+2*stride]=(t6 + t7 + l3 + l4 + 2)&gt;&gt;2;
+    src[2+3*stride]=(l4 + l5 + 1)&gt;&gt;1;
+    src[3+3*stride]=(l4 + 2*l5 + l6 + 2)&gt;&gt;2;
+}
+
+static void pred4x4_horizontal_up_rv40_nodown_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+
+    src[0+0*stride]=(t1 + 2*t2 + t3 + 2*l0 + 2*l1 + 4)&gt;&gt;3;
+    src[1+0*stride]=(t2 + 2*t3 + t4 + l0 + 2*l1 + l2 + 4)&gt;&gt;3;
+    src[2+0*stride]=
+    src[0+1*stride]=(t3 + 2*t4 + t5 + 2*l1 + 2*l2 + 4)&gt;&gt;3;
+    src[3+0*stride]=
+    src[1+1*stride]=(t4 + 2*t5 + t6 + l1 + 2*l2 + l3 + 4)&gt;&gt;3;
+    src[2+1*stride]=
+    src[0+2*stride]=(t5 + 2*t6 + t7 + 2*l2 + 2*l3 + 4)&gt;&gt;3;
+    src[3+1*stride]=
+    src[1+2*stride]=(t6 + 3*t7 + l2 + 3*l3 + 4)&gt;&gt;3;
+    src[3+2*stride]=
+    src[1+3*stride]=l3;
+    src[0+3*stride]=
+    src[2+2*stride]=(t6 + t7 + 2*l3 + 2)&gt;&gt;2;
+    src[2+3*stride]=
+    src[3+3*stride]=l3;
+}
+
+static void pred4x4_horizontal_down_c(uint8_t *src, uint8_t *topright, int stride){
+    const int lt= src[-1-1*stride];
+    LOAD_TOP_EDGE
+    LOAD_LEFT_EDGE
+
+    src[0+0*stride]=
+    src[2+1*stride]=(lt + l0 + 1)&gt;&gt;1;
+    src[1+0*stride]=
+    src[3+1*stride]=(l0 + 2*lt + t0 + 2)&gt;&gt;2;
+    src[2+0*stride]=(lt + 2*t0 + t1 + 2)&gt;&gt;2;
+    src[3+0*stride]=(t0 + 2*t1 + t2 + 2)&gt;&gt;2;
+    src[0+1*stride]=
+    src[2+2*stride]=(l0 + l1 + 1)&gt;&gt;1;
+    src[1+1*stride]=
+    src[3+2*stride]=(lt + 2*l0 + l1 + 2)&gt;&gt;2;
+    src[0+2*stride]=
+    src[2+3*stride]=(l1 + l2+ 1)&gt;&gt;1;
+    src[1+2*stride]=
+    src[3+3*stride]=(l0 + 2*l1 + l2 + 2)&gt;&gt;2;
+    src[0+3*stride]=(l2 + l3 + 1)&gt;&gt;1;
+    src[1+3*stride]=(l1 + 2*l2 + l3 + 2)&gt;&gt;2;
+}
+
+static void pred16x16_vertical_c(uint8_t *src, int stride){
+    int i;
+    const uint32_t a= ((uint32_t*)(src-stride))[0];
+    const uint32_t b= ((uint32_t*)(src-stride))[1];
+    const uint32_t c= ((uint32_t*)(src-stride))[2];
+    const uint32_t d= ((uint32_t*)(src-stride))[3];
+
+    for(i=0; i&lt;16; i++){
+        ((uint32_t*)(src+i*stride))[0]= a;
+        ((uint32_t*)(src+i*stride))[1]= b;
+        ((uint32_t*)(src+i*stride))[2]= c;
+        ((uint32_t*)(src+i*stride))[3]= d;
+    }
+}
+
+static void pred16x16_horizontal_c(uint8_t *src, int stride){
+    int i;
+
+    for(i=0; i&lt;16; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]=
+        ((uint32_t*)(src+i*stride))[2]=
+        ((uint32_t*)(src+i*stride))[3]= src[-1+i*stride]*0x01010101;
+    }
+}
+
+static void pred16x16_dc_c(uint8_t *src, int stride){
+    int i, dc=0;
+
+    for(i=0;i&lt;16; i++){
+        dc+= src[-1+i*stride];
+    }
+
+    for(i=0;i&lt;16; i++){
+        dc+= src[i-stride];
+    }
+
+    dc= 0x01010101*((dc + 16)&gt;&gt;5);
+
+    for(i=0; i&lt;16; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]=
+        ((uint32_t*)(src+i*stride))[2]=
+        ((uint32_t*)(src+i*stride))[3]= dc;
+    }
+}
+
+static void pred16x16_left_dc_c(uint8_t *src, int stride){
+    int i, dc=0;
+
+    for(i=0;i&lt;16; i++){
+        dc+= src[-1+i*stride];
+    }
+
+    dc= 0x01010101*((dc + 8)&gt;&gt;4);
+
+    for(i=0; i&lt;16; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]=
+        ((uint32_t*)(src+i*stride))[2]=
+        ((uint32_t*)(src+i*stride))[3]= dc;
+    }
+}
+
+static void pred16x16_top_dc_c(uint8_t *src, int stride){
+    int i, dc=0;
+
+    for(i=0;i&lt;16; i++){
+        dc+= src[i-stride];
+    }
+    dc= 0x01010101*((dc + 8)&gt;&gt;4);
+
+    for(i=0; i&lt;16; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]=
+        ((uint32_t*)(src+i*stride))[2]=
+        ((uint32_t*)(src+i*stride))[3]= dc;
+    }
+}
+
+static void pred16x16_128_dc_c(uint8_t *src, int stride){
+    int i;
+
+    for(i=0; i&lt;16; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]=
+        ((uint32_t*)(src+i*stride))[2]=
+        ((uint32_t*)(src+i*stride))[3]= 0x01010101U*128U;
+    }
+}
+
+static inline void pred16x16_plane_compat_c(uint8_t *src, int stride, const int svq3, const int rv40){
+  int i, j, k;
+  int a;
+  uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
+  const uint8_t * const src0 = src+7-stride;
+  const uint8_t *src1 = src+8*stride-1;
+  const uint8_t *src2 = src1-2*stride;      // == src+6*stride-1;
+  int H = src0[1] - src0[-1];
+  int V = src1[0] - src2[ 0];
+  for(k=2; k&lt;=8; ++k) {
+    src1 += stride; src2 -= stride;
+    H += k*(src0[k] - src0[-k]);
+    V += k*(src1[0] - src2[ 0]);
+  }
+  if(svq3){
+    H = ( 5*(H/4) ) / 16;
+    V = ( 5*(V/4) ) / 16;
+
+    /* required for 100% accuracy */
+    i = H; H = V; V = i;
+  }else if(rv40){
+    H = ( H + (H&gt;&gt;2) ) &gt;&gt; 4;
+    V = ( V + (V&gt;&gt;2) ) &gt;&gt; 4;
+  }else{
+    H = ( 5*H+32 ) &gt;&gt; 6;
+    V = ( 5*V+32 ) &gt;&gt; 6;
+  }
+
+  a = 16*(src1[0] + src2[16] + 1) - 7*(V+H);
+  for(j=16; j&gt;0; --j) {
+    int b = a;
+    a += V;
+    for(i=-16; i&lt;0; i+=4) {
+      src[16+i] = cm[ (b    ) &gt;&gt; 5 ];
+      src[17+i] = cm[ (b+  H) &gt;&gt; 5 ];
+      src[18+i] = cm[ (b+2*H) &gt;&gt; 5 ];
+      src[19+i] = cm[ (b+3*H) &gt;&gt; 5 ];
+      b += 4*H;
+    }
+    src += stride;
+  }
+}
+
+static void pred16x16_plane_c(uint8_t *src, int stride){
+    pred16x16_plane_compat_c(src, stride, 0, 0);
+}
+
+static void pred16x16_plane_svq3_c(uint8_t *src, int stride){
+    pred16x16_plane_compat_c(src, stride, 1, 0);
+}
+
+static void pred16x16_plane_rv40_c(uint8_t *src, int stride){
+    pred16x16_plane_compat_c(src, stride, 0, 1);
+}
+
+static void pred8x8_vertical_c(uint8_t *src, int stride){
+    int i;
+    const uint32_t a= ((uint32_t*)(src-stride))[0];
+    const uint32_t b= ((uint32_t*)(src-stride))[1];
+
+    for(i=0; i&lt;8; i++){
+        ((uint32_t*)(src+i*stride))[0]= a;
+        ((uint32_t*)(src+i*stride))[1]= b;
+    }
+}
+
+static void pred8x8_horizontal_c(uint8_t *src, int stride){
+    int i;
+
+    for(i=0; i&lt;8; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= src[-1+i*stride]*0x01010101;
+    }
+}
+
+static void pred8x8_128_dc_c(uint8_t *src, int stride){
+    int i;
+
+    for(i=0; i&lt;8; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= 0x01010101U*128U;
+    }
+}
+
+static void pred8x8_left_dc_c(uint8_t *src, int stride){
+    int i;
+    int dc0, dc2;
+
+    dc0=dc2=0;
+    for(i=0;i&lt;4; i++){
+        dc0+= src[-1+i*stride];
+        dc2+= src[-1+(i+4)*stride];
+    }
+    dc0= 0x01010101*((dc0 + 2)&gt;&gt;2);
+    dc2= 0x01010101*((dc2 + 2)&gt;&gt;2);
+
+    for(i=0; i&lt;4; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= dc0;
+    }
+    for(i=4; i&lt;8; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= dc2;
+    }
+}
+
+static void pred8x8_left_dc_rv40_c(uint8_t *src, int stride){
+    int i;
+    int dc0;
+
+    dc0=0;
+    for(i=0;i&lt;8; i++)
+        dc0+= src[-1+i*stride];
+    dc0= 0x01010101*((dc0 + 4)&gt;&gt;3);
+
+    for(i=0; i&lt;8; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= dc0;
+    }
+}
+
+static void pred8x8_top_dc_c(uint8_t *src, int stride){
+    int i;
+    int dc0, dc1;
+
+    dc0=dc1=0;
+    for(i=0;i&lt;4; i++){
+        dc0+= src[i-stride];
+        dc1+= src[4+i-stride];
+    }
+    dc0= 0x01010101*((dc0 + 2)&gt;&gt;2);
+    dc1= 0x01010101*((dc1 + 2)&gt;&gt;2);
+
+    for(i=0; i&lt;4; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc0;
+        ((uint32_t*)(src+i*stride))[1]= dc1;
+    }
+    for(i=4; i&lt;8; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc0;
+        ((uint32_t*)(src+i*stride))[1]= dc1;
+    }
+}
+
+static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
+    int i;
+    int dc0;
+
+    dc0=0;
+    for(i=0;i&lt;8; i++)
+        dc0+= src[i-stride];
+    dc0= 0x01010101*((dc0 + 4)&gt;&gt;3);
+
+    for(i=0; i&lt;8; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= dc0;
+    }
+}
+
+
+static void pred8x8_dc_c(uint8_t *src, int stride){
+    int i;
+    int dc0, dc1, dc2, dc3;
+
+    dc0=dc1=dc2=0;
+    for(i=0;i&lt;4; i++){
+        dc0+= src[-1+i*stride] + src[i-stride];
+        dc1+= src[4+i-stride];
+        dc2+= src[-1+(i+4)*stride];
+    }
+    dc3= 0x01010101*((dc1 + dc2 + 4)&gt;&gt;3);
+    dc0= 0x01010101*((dc0 + 4)&gt;&gt;3);
+    dc1= 0x01010101*((dc1 + 2)&gt;&gt;2);
+    dc2= 0x01010101*((dc2 + 2)&gt;&gt;2);
+
+    for(i=0; i&lt;4; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc0;
+        ((uint32_t*)(src+i*stride))[1]= dc1;
+    }
+    for(i=4; i&lt;8; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc2;
+        ((uint32_t*)(src+i*stride))[1]= dc3;
+    }
+}
+
+static void pred8x8_dc_rv40_c(uint8_t *src, int stride){
+    int i;
+    int dc0=0;
+
+    for(i=0;i&lt;4; i++){
+        dc0+= src[-1+i*stride] + src[i-stride];
+        dc0+= src[4+i-stride];
+        dc0+= src[-1+(i+4)*stride];
+    }
+    dc0= 0x01010101*((dc0 + 8)&gt;&gt;4);
+
+    for(i=0; i&lt;4; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc0;
+        ((uint32_t*)(src+i*stride))[1]= dc0;
+    }
+    for(i=4; i&lt;8; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc0;
+        ((uint32_t*)(src+i*stride))[1]= dc0;
+    }
+}
+
+static void pred8x8_plane_c(uint8_t *src, int stride){
+  int j, k;
+  int a;
+  uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
+  const uint8_t * const src0 = src+3-stride;
+  const uint8_t *src1 = src+4*stride-1;
+  const uint8_t *src2 = src1-2*stride;      // == src+2*stride-1;
+  int H = src0[1] - src0[-1];
+  int V = src1[0] - src2[ 0];
+  for(k=2; k&lt;=4; ++k) {
+    src1 += stride; src2 -= stride;
+    H += k*(src0[k] - src0[-k]);
+    V += k*(src1[0] - src2[ 0]);
+  }
+  H = ( 17*H+16 ) &gt;&gt; 5;
+  V = ( 17*V+16 ) &gt;&gt; 5;
+
+  a = 16*(src1[0] + src2[8]+1) - 3*(V+H);
+  for(j=8; j&gt;0; --j) {
+    int b = a;
+    a += V;
+    src[0] = cm[ (b    ) &gt;&gt; 5 ];
+    src[1] = cm[ (b+  H) &gt;&gt; 5 ];
+    src[2] = cm[ (b+2*H) &gt;&gt; 5 ];
+    src[3] = cm[ (b+3*H) &gt;&gt; 5 ];
+    src[4] = cm[ (b+4*H) &gt;&gt; 5 ];
+    src[5] = cm[ (b+5*H) &gt;&gt; 5 ];
+    src[6] = cm[ (b+6*H) &gt;&gt; 5 ];
+    src[7] = cm[ (b+7*H) &gt;&gt; 5 ];
+    src += stride;
+  }
+}
+
+#define SRC(x,y) src[(x)+(y)*stride]
+#define PL(y) \
+    const int l##y = (SRC(-1,y-1) + 2*SRC(-1,y) + SRC(-1,y+1) + 2) &gt;&gt; 2;
+#define PREDICT_8x8_LOAD_LEFT \
+    const int l0 = ((has_topleft ? SRC(-1,-1) : SRC(-1,0)) \
+                     + 2*SRC(-1,0) + SRC(-1,1) + 2) &gt;&gt; 2; \
+    PL(1) PL(2) PL(3) PL(4) PL(5) PL(6) \
+    const int l7 av_unused = (SRC(-1,6) + 3*SRC(-1,7) + 2) &gt;&gt; 2
+
+#define PT(x) \
+    const int t##x = (SRC(x-1,-1) + 2*SRC(x,-1) + SRC(x+1,-1) + 2) &gt;&gt; 2;
+#define PREDICT_8x8_LOAD_TOP \
+    const int t0 = ((has_topleft ? SRC(-1,-1) : SRC(0,-1)) \
+                     + 2*SRC(0,-1) + SRC(1,-1) + 2) &gt;&gt; 2; \
+    PT(1) PT(2) PT(3) PT(4) PT(5) PT(6) \
+    const int t7 av_unused = ((has_topright ? SRC(8,-1) : SRC(7,-1)) \
+                     + 2*SRC(7,-1) + SRC(6,-1) + 2) &gt;&gt; 2
+
+#define PTR(x) \
+    t##x = (SRC(x-1,-1) + 2*SRC(x,-1) + SRC(x+1,-1) + 2) &gt;&gt; 2;
+#define PREDICT_8x8_LOAD_TOPRIGHT \
+    int t8, t9, t10, t11, t12, t13, t14, t15; \
+    if(has_topright) { \
+        PTR(8) PTR(9) PTR(10) PTR(11) PTR(12) PTR(13) PTR(14) \
+        t15 = (SRC(14,-1) + 3*SRC(15,-1) + 2) &gt;&gt; 2; \
+    } else t8=t9=t10=t11=t12=t13=t14=t15= SRC(7,-1);
+
+#define PREDICT_8x8_LOAD_TOPLEFT \
+    const int lt = (SRC(-1,0) + 2*SRC(-1,-1) + SRC(0,-1) + 2) &gt;&gt; 2
+
+#define PREDICT_8x8_DC(v) \
+    int y; \
+    for( y = 0; y &lt; 8; y++ ) { \
+        ((uint32_t*)src)[0] = \
+        ((uint32_t*)src)[1] = v; \
+        src += stride; \
+    }
+
+static void pred8x8l_128_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_DC(0x80808080);
+}
+static void pred8x8l_left_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_LEFT;
+    const uint32_t dc = ((l0+l1+l2+l3+l4+l5+l6+l7+4) &gt;&gt; 3) * 0x01010101;
+    PREDICT_8x8_DC(dc);
+}
+static void pred8x8l_top_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    const uint32_t dc = ((t0+t1+t2+t3+t4+t5+t6+t7+4) &gt;&gt; 3) * 0x01010101;
+    PREDICT_8x8_DC(dc);
+}
+static void pred8x8l_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_LEFT;
+    PREDICT_8x8_LOAD_TOP;
+    const uint32_t dc = ((l0+l1+l2+l3+l4+l5+l6+l7
+                         +t0+t1+t2+t3+t4+t5+t6+t7+8) &gt;&gt; 4) * 0x01010101;
+    PREDICT_8x8_DC(dc);
+}
+static void pred8x8l_horizontal_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_LEFT;
+#define ROW(y) ((uint32_t*)(src+y*stride))[0] =\
+               ((uint32_t*)(src+y*stride))[1] = 0x01010101 * l##y
+    ROW(0); ROW(1); ROW(2); ROW(3); ROW(4); ROW(5); ROW(6); ROW(7);
+#undef ROW
+}
+static void pred8x8l_vertical_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    int y;
+    PREDICT_8x8_LOAD_TOP;
+    src[0] = t0;
+    src[1] = t1;
+    src[2] = t2;
+    src[3] = t3;
+    src[4] = t4;
+    src[5] = t5;
+    src[6] = t6;
+    src[7] = t7;
+    for( y = 1; y &lt; 8; y++ )
+        *(uint64_t*)(src+y*stride) = *(uint64_t*)src;
+}
+static void pred8x8l_down_left_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    PREDICT_8x8_LOAD_TOPRIGHT;
+    SRC(0,0)= (t0 + 2*t1 + t2 + 2) &gt;&gt; 2;
+    SRC(0,1)=SRC(1,0)= (t1 + 2*t2 + t3 + 2) &gt;&gt; 2;
+    SRC(0,2)=SRC(1,1)=SRC(2,0)= (t2 + 2*t3 + t4 + 2) &gt;&gt; 2;
+    SRC(0,3)=SRC(1,2)=SRC(2,1)=SRC(3,0)= (t3 + 2*t4 + t5 + 2) &gt;&gt; 2;
+    SRC(0,4)=SRC(1,3)=SRC(2,2)=SRC(3,1)=SRC(4,0)= (t4 + 2*t5 + t6 + 2) &gt;&gt; 2;
+    SRC(0,5)=SRC(1,4)=SRC(2,3)=SRC(3,2)=SRC(4,1)=SRC(5,0)= (t5 + 2*t6 + t7 + 2) &gt;&gt; 2;
+    SRC(0,6)=SRC(1,5)=SRC(2,4)=SRC(3,3)=SRC(4,2)=SRC(5,1)=SRC(6,0)= (t6 + 2*t7 + t8 + 2) &gt;&gt; 2;
+    SRC(0,7)=SRC(1,6)=SRC(2,5)=SRC(3,4)=SRC(4,3)=SRC(5,2)=SRC(6,1)=SRC(7,0)= (t7 + 2*t8 + t9 + 2) &gt;&gt; 2;
+    SRC(1,7)=SRC(2,6)=SRC(3,5)=SRC(4,4)=SRC(5,3)=SRC(6,2)=SRC(7,1)= (t8 + 2*t9 + t10 + 2) &gt;&gt; 2;
+    SRC(2,7)=SRC(3,6)=SRC(4,5)=SRC(5,4)=SRC(6,3)=SRC(7,2)= (t9 + 2*t10 + t11 + 2) &gt;&gt; 2;
+    SRC(3,7)=SRC(4,6)=SRC(5,5)=SRC(6,4)=SRC(7,3)= (t10 + 2*t11 + t12 + 2) &gt;&gt; 2;
+    SRC(4,7)=SRC(5,6)=SRC(6,5)=SRC(7,4)= (t11 + 2*t12 + t13 + 2) &gt;&gt; 2;
+    SRC(5,7)=SRC(6,6)=SRC(7,5)= (t12 + 2*t13 + t14 + 2) &gt;&gt; 2;
+    SRC(6,7)=SRC(7,6)= (t13 + 2*t14 + t15 + 2) &gt;&gt; 2;
+    SRC(7,7)= (t14 + 3*t15 + 2) &gt;&gt; 2;
+}
+static void pred8x8l_down_right_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    PREDICT_8x8_LOAD_LEFT;
+    PREDICT_8x8_LOAD_TOPLEFT;
+    SRC(0,7)= (l7 + 2*l6 + l5 + 2) &gt;&gt; 2;
+    SRC(0,6)=SRC(1,7)= (l6 + 2*l5 + l4 + 2) &gt;&gt; 2;
+    SRC(0,5)=SRC(1,6)=SRC(2,7)= (l5 + 2*l4 + l3 + 2) &gt;&gt; 2;
+    SRC(0,4)=SRC(1,5)=SRC(2,6)=SRC(3,7)= (l4 + 2*l3 + l2 + 2) &gt;&gt; 2;
+    SRC(0,3)=SRC(1,4)=SRC(2,5)=SRC(3,6)=SRC(4,7)= (l3 + 2*l2 + l1 + 2) &gt;&gt; 2;
+    SRC(0,2)=SRC(1,3)=SRC(2,4)=SRC(3,5)=SRC(4,6)=SRC(5,7)= (l2 + 2*l1 + l0 + 2) &gt;&gt; 2;
+    SRC(0,1)=SRC(1,2)=SRC(2,3)=SRC(3,4)=SRC(4,5)=SRC(5,6)=SRC(6,7)= (l1 + 2*l0 + lt + 2) &gt;&gt; 2;
+    SRC(0,0)=SRC(1,1)=SRC(2,2)=SRC(3,3)=SRC(4,4)=SRC(5,5)=SRC(6,6)=SRC(7,7)= (l0 + 2*lt + t0 + 2) &gt;&gt; 2;
+    SRC(1,0)=SRC(2,1)=SRC(3,2)=SRC(4,3)=SRC(5,4)=SRC(6,5)=SRC(7,6)= (lt + 2*t0 + t1 + 2) &gt;&gt; 2;
+    SRC(2,0)=SRC(3,1)=SRC(4,2)=SRC(5,3)=SRC(6,4)=SRC(7,5)= (t0 + 2*t1 + t2 + 2) &gt;&gt; 2;
+    SRC(3,0)=SRC(4,1)=SRC(5,2)=SRC(6,3)=SRC(7,4)= (t1 + 2*t2 + t3 + 2) &gt;&gt; 2;
+    SRC(4,0)=SRC(5,1)=SRC(6,2)=SRC(7,3)= (t2 + 2*t3 + t4 + 2) &gt;&gt; 2;
+    SRC(5,0)=SRC(6,1)=SRC(7,2)= (t3 + 2*t4 + t5 + 2) &gt;&gt; 2;
+    SRC(6,0)=SRC(7,1)= (t4 + 2*t5 + t6 + 2) &gt;&gt; 2;
+    SRC(7,0)= (t5 + 2*t6 + t7 + 2) &gt;&gt; 2;
+
+}
+static void pred8x8l_vertical_right_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    PREDICT_8x8_LOAD_LEFT;
+    PREDICT_8x8_LOAD_TOPLEFT;
+    SRC(0,6)= (l5 + 2*l4 + l3 + 2) &gt;&gt; 2;
+    SRC(0,7)= (l6 + 2*l5 + l4 + 2) &gt;&gt; 2;
+    SRC(0,4)=SRC(1,6)= (l3 + 2*l2 + l1 + 2) &gt;&gt; 2;
+    SRC(0,5)=SRC(1,7)= (l4 + 2*l3 + l2 + 2) &gt;&gt; 2;
+    SRC(0,2)=SRC(1,4)=SRC(2,6)= (l1 + 2*l0 + lt + 2) &gt;&gt; 2;
+    SRC(0,3)=SRC(1,5)=SRC(2,7)= (l2 + 2*l1 + l0 + 2) &gt;&gt; 2;
+    SRC(0,1)=SRC(1,3)=SRC(2,5)=SRC(3,7)= (l0 + 2*lt + t0 + 2) &gt;&gt; 2;
+    SRC(0,0)=SRC(1,2)=SRC(2,4)=SRC(3,6)= (lt + t0 + 1) &gt;&gt; 1;
+    SRC(1,1)=SRC(2,3)=SRC(3,5)=SRC(4,7)= (lt + 2*t0 + t1 + 2) &gt;&gt; 2;
+    SRC(1,0)=SRC(2,2)=SRC(3,4)=SRC(4,6)= (t0 + t1 + 1) &gt;&gt; 1;
+    SRC(2,1)=SRC(3,3)=SRC(4,5)=SRC(5,7)= (t0 + 2*t1 + t2 + 2) &gt;&gt; 2;
+    SRC(2,0)=SRC(3,2)=SRC(4,4)=SRC(5,6)= (t1 + t2 + 1) &gt;&gt; 1;
+    SRC(3,1)=SRC(4,3)=SRC(5,5)=SRC(6,7)= (t1 + 2*t2 + t3 + 2) &gt;&gt; 2;
+    SRC(3,0)=SRC(4,2)=SRC(5,4)=SRC(6,6)= (t2 + t3 + 1) &gt;&gt; 1;
+    SRC(4,1)=SRC(5,3)=SRC(6,5)=SRC(7,7)= (t2 + 2*t3 + t4 + 2) &gt;&gt; 2;
+    SRC(4,0)=SRC(5,2)=SRC(6,4)=SRC(7,6)= (t3 + t4 + 1) &gt;&gt; 1;
+    SRC(5,1)=SRC(6,3)=SRC(7,5)= (t3 + 2*t4 + t5 + 2) &gt;&gt; 2;
+    SRC(5,0)=SRC(6,2)=SRC(7,4)= (t4 + t5 + 1) &gt;&gt; 1;
+    SRC(6,1)=SRC(7,3)= (t4 + 2*t5 + t6 + 2) &gt;&gt; 2;
+    SRC(6,0)=SRC(7,2)= (t5 + t6 + 1) &gt;&gt; 1;
+    SRC(7,1)= (t5 + 2*t6 + t7 + 2) &gt;&gt; 2;
+    SRC(7,0)= (t6 + t7 + 1) &gt;&gt; 1;
+}
+static void pred8x8l_horizontal_down_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    PREDICT_8x8_LOAD_LEFT;
+    PREDICT_8x8_LOAD_TOPLEFT;
+    SRC(0,7)= (l6 + l7 + 1) &gt;&gt; 1;
+    SRC(1,7)= (l5 + 2*l6 + l7 + 2) &gt;&gt; 2;
+    SRC(0,6)=SRC(2,7)= (l5 + l6 + 1) &gt;&gt; 1;
+    SRC(1,6)=SRC(3,7)= (l4 + 2*l5 + l6 + 2) &gt;&gt; 2;
+    SRC(0,5)=SRC(2,6)=SRC(4,7)= (l4 + l5 + 1) &gt;&gt; 1;
+    SRC(1,5)=SRC(3,6)=SRC(5,7)= (l3 + 2*l4 + l5 + 2) &gt;&gt; 2;
+    SRC(0,4)=SRC(2,5)=SRC(4,6)=SRC(6,7)= (l3 + l4 + 1) &gt;&gt; 1;
+    SRC(1,4)=SRC(3,5)=SRC(5,6)=SRC(7,7)= (l2 + 2*l3 + l4 + 2) &gt;&gt; 2;
+    SRC(0,3)=SRC(2,4)=SRC(4,5)=SRC(6,6)= (l2 + l3 + 1) &gt;&gt; 1;
+    SRC(1,3)=SRC(3,4)=SRC(5,5)=SRC(7,6)= (l1 + 2*l2 + l3 + 2) &gt;&gt; 2;
+    SRC(0,2)=SRC(2,3)=SRC(4,4)=SRC(6,5)= (l1 + l2 + 1) &gt;&gt; 1;
+    SRC(1,2)=SRC(3,3)=SRC(5,4)=SRC(7,5)= (l0 + 2*l1 + l2 + 2) &gt;&gt; 2;
+    SRC(0,1)=SRC(2,2)=SRC(4,3)=SRC(6,4)= (l0 + l1 + 1) &gt;&gt; 1;
+    SRC(1,1)=SRC(3,2)=SRC(5,3)=SRC(7,4)= (lt + 2*l0 + l1 + 2) &gt;&gt; 2;
+    SRC(0,0)=SRC(2,1)=SRC(4,2)=SRC(6,3)= (lt + l0 + 1) &gt;&gt; 1;
+    SRC(1,0)=SRC(3,1)=SRC(5,2)=SRC(7,3)= (l0 + 2*lt + t0 + 2) &gt;&gt; 2;
+    SRC(2,0)=SRC(4,1)=SRC(6,2)= (t1 + 2*t0 + lt + 2) &gt;&gt; 2;
+    SRC(3,0)=SRC(5,1)=SRC(7,2)= (t2 + 2*t1 + t0 + 2) &gt;&gt; 2;
+    SRC(4,0)=SRC(6,1)= (t3 + 2*t2 + t1 + 2) &gt;&gt; 2;
+    SRC(5,0)=SRC(7,1)= (t4 + 2*t3 + t2 + 2) &gt;&gt; 2;
+    SRC(6,0)= (t5 + 2*t4 + t3 + 2) &gt;&gt; 2;
+    SRC(7,0)= (t6 + 2*t5 + t4 + 2) &gt;&gt; 2;
+}
+static void pred8x8l_vertical_left_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    PREDICT_8x8_LOAD_TOPRIGHT;
+    SRC(0,0)= (t0 + t1 + 1) &gt;&gt; 1;
+    SRC(0,1)= (t0 + 2*t1 + t2 + 2) &gt;&gt; 2;
+    SRC(0,2)=SRC(1,0)= (t1 + t2 + 1) &gt;&gt; 1;
+    SRC(0,3)=SRC(1,1)= (t1 + 2*t2 + t3 + 2) &gt;&gt; 2;
+    SRC(0,4)=SRC(1,2)=SRC(2,0)= (t2 + t3 + 1) &gt;&gt; 1;
+    SRC(0,5)=SRC(1,3)=SRC(2,1)= (t2 + 2*t3 + t4 + 2) &gt;&gt; 2;
+    SRC(0,6)=SRC(1,4)=SRC(2,2)=SRC(3,0)= (t3 + t4 + 1) &gt;&gt; 1;
+    SRC(0,7)=SRC(1,5)=SRC(2,3)=SRC(3,1)= (t3 + 2*t4 + t5 + 2) &gt;&gt; 2;
+    SRC(1,6)=SRC(2,4)=SRC(3,2)=SRC(4,0)= (t4 + t5 + 1) &gt;&gt; 1;
+    SRC(1,7)=SRC(2,5)=SRC(3,3)=SRC(4,1)= (t4 + 2*t5 + t6 + 2) &gt;&gt; 2;
+    SRC(2,6)=SRC(3,4)=SRC(4,2)=SRC(5,0)= (t5 + t6 + 1) &gt;&gt; 1;
+    SRC(2,7)=SRC(3,5)=SRC(4,3)=SRC(5,1)= (t5 + 2*t6 + t7 + 2) &gt;&gt; 2;
+    SRC(3,6)=SRC(4,4)=SRC(5,2)=SRC(6,0)= (t6 + t7 + 1) &gt;&gt; 1;
+    SRC(3,7)=SRC(4,5)=SRC(5,3)=SRC(6,1)= (t6 + 2*t7 + t8 + 2) &gt;&gt; 2;
+    SRC(4,6)=SRC(5,4)=SRC(6,2)=SRC(7,0)= (t7 + t8 + 1) &gt;&gt; 1;
+    SRC(4,7)=SRC(5,5)=SRC(6,3)=SRC(7,1)= (t7 + 2*t8 + t9 + 2) &gt;&gt; 2;
+    SRC(5,6)=SRC(6,4)=SRC(7,2)= (t8 + t9 + 1) &gt;&gt; 1;
+    SRC(5,7)=SRC(6,5)=SRC(7,3)= (t8 + 2*t9 + t10 + 2) &gt;&gt; 2;
+    SRC(6,6)=SRC(7,4)= (t9 + t10 + 1) &gt;&gt; 1;
+    SRC(6,7)=SRC(7,5)= (t9 + 2*t10 + t11 + 2) &gt;&gt; 2;
+    SRC(7,6)= (t10 + t11 + 1) &gt;&gt; 1;
+    SRC(7,7)= (t10 + 2*t11 + t12 + 2) &gt;&gt; 2;
+}
+static void pred8x8l_horizontal_up_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_LEFT;
+    SRC(0,0)= (l0 + l1 + 1) &gt;&gt; 1;
+    SRC(1,0)= (l0 + 2*l1 + l2 + 2) &gt;&gt; 2;
+    SRC(0,1)=SRC(2,0)= (l1 + l2 + 1) &gt;&gt; 1;
+    SRC(1,1)=SRC(3,0)= (l1 + 2*l2 + l3 + 2) &gt;&gt; 2;
+    SRC(0,2)=SRC(2,1)=SRC(4,0)= (l2 + l3 + 1) &gt;&gt; 1;
+    SRC(1,2)=SRC(3,1)=SRC(5,0)= (l2 + 2*l3 + l4 + 2) &gt;&gt; 2;
+    SRC(0,3)=SRC(2,2)=SRC(4,1)=SRC(6,0)= (l3 + l4 + 1) &gt;&gt; 1;
+    SRC(1,3)=SRC(3,2)=SRC(5,1)=SRC(7,0)= (l3 + 2*l4 + l5 + 2) &gt;&gt; 2;
+    SRC(0,4)=SRC(2,3)=SRC(4,2)=SRC(6,1)= (l4 + l5 + 1) &gt;&gt; 1;
+    SRC(1,4)=SRC(3,3)=SRC(5,2)=SRC(7,1)= (l4 + 2*l5 + l6 + 2) &gt;&gt; 2;
+    SRC(0,5)=SRC(2,4)=SRC(4,3)=SRC(6,2)= (l5 + l6 + 1) &gt;&gt; 1;
+    SRC(1,5)=SRC(3,4)=SRC(5,3)=SRC(7,2)= (l5 + 2*l6 + l7 + 2) &gt;&gt; 2;
+    SRC(0,6)=SRC(2,5)=SRC(4,4)=SRC(6,3)= (l6 + l7 + 1) &gt;&gt; 1;
+    SRC(1,6)=SRC(3,5)=SRC(5,4)=SRC(7,3)= (l6 + 3*l7 + 2) &gt;&gt; 2;
+    SRC(0,7)=SRC(1,7)=SRC(2,6)=SRC(2,7)=SRC(3,6)=
+    SRC(3,7)=SRC(4,5)=SRC(4,6)=SRC(4,7)=SRC(5,5)=
+    SRC(5,6)=SRC(5,7)=SRC(6,4)=SRC(6,5)=SRC(6,6)=
+    SRC(6,7)=SRC(7,4)=SRC(7,5)=SRC(7,6)=SRC(7,7)= l7;
+}
+#undef PREDICT_8x8_LOAD_LEFT
+#undef PREDICT_8x8_LOAD_TOP
+#undef PREDICT_8x8_LOAD_TOPLEFT
+#undef PREDICT_8x8_LOAD_TOPRIGHT
+#undef PREDICT_8x8_DC
+#undef PTR
+#undef PT
+#undef PL
+#undef SRC
+
+/**
+ * Sets the intra prediction function pointers.
+ */
+void ff_h264_pred_init(H264PredContext *h, int codec_id){
+//    MpegEncContext * const s = &amp;h-&gt;s;
+
+    if(codec_id != CODEC_ID_RV40){
+        h-&gt;pred4x4[VERT_PRED           ]= pred4x4_vertical_c;
+        h-&gt;pred4x4[HOR_PRED            ]= pred4x4_horizontal_c;
+        h-&gt;pred4x4[DC_PRED             ]= pred4x4_dc_c;
+        if(codec_id == CODEC_ID_SVQ3)
+            h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED ]= pred4x4_down_left_svq3_c;
+        else
+            h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED ]= pred4x4_down_left_c;
+        h-&gt;pred4x4[DIAG_DOWN_RIGHT_PRED]= pred4x4_down_right_c;
+        h-&gt;pred4x4[VERT_RIGHT_PRED     ]= pred4x4_vertical_right_c;
+        h-&gt;pred4x4[HOR_DOWN_PRED       ]= pred4x4_horizontal_down_c;
+        h-&gt;pred4x4[VERT_LEFT_PRED      ]= pred4x4_vertical_left_c;
+        h-&gt;pred4x4[HOR_UP_PRED         ]= pred4x4_horizontal_up_c;
+        h-&gt;pred4x4[LEFT_DC_PRED        ]= pred4x4_left_dc_c;
+        h-&gt;pred4x4[TOP_DC_PRED         ]= pred4x4_top_dc_c;
+        h-&gt;pred4x4[DC_128_PRED         ]= pred4x4_128_dc_c;
+    }else{
+        h-&gt;pred4x4[VERT_PRED           ]= pred4x4_vertical_c;
+        h-&gt;pred4x4[HOR_PRED            ]= pred4x4_horizontal_c;
+        h-&gt;pred4x4[DC_PRED             ]= pred4x4_dc_c;
+        h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED ]= pred4x4_down_left_rv40_c;
+        h-&gt;pred4x4[DIAG_DOWN_RIGHT_PRED]= pred4x4_down_right_c;
+        h-&gt;pred4x4[VERT_RIGHT_PRED     ]= pred4x4_vertical_right_c;
+        h-&gt;pred4x4[HOR_DOWN_PRED       ]= pred4x4_horizontal_down_c;
+        h-&gt;pred4x4[VERT_LEFT_PRED      ]= pred4x4_vertical_left_rv40_c;
+        h-&gt;pred4x4[HOR_UP_PRED         ]= pred4x4_horizontal_up_rv40_c;
+        h-&gt;pred4x4[LEFT_DC_PRED        ]= pred4x4_left_dc_c;
+        h-&gt;pred4x4[TOP_DC_PRED         ]= pred4x4_top_dc_c;
+        h-&gt;pred4x4[DC_128_PRED         ]= pred4x4_128_dc_c;
+        h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED_RV40_NODOWN]= pred4x4_down_left_rv40_nodown_c;
+        h-&gt;pred4x4[HOR_UP_PRED_RV40_NODOWN]= pred4x4_horizontal_up_rv40_nodown_c;
+        h-&gt;pred4x4[VERT_LEFT_PRED_RV40_NODOWN]= pred4x4_vertical_left_rv40_nodown_c;
+    }
+
+    h-&gt;pred8x8l[VERT_PRED           ]= pred8x8l_vertical_c;
+    h-&gt;pred8x8l[HOR_PRED            ]= pred8x8l_horizontal_c;
+    h-&gt;pred8x8l[DC_PRED             ]= pred8x8l_dc_c;
+    h-&gt;pred8x8l[DIAG_DOWN_LEFT_PRED ]= pred8x8l_down_left_c;
+    h-&gt;pred8x8l[DIAG_DOWN_RIGHT_PRED]= pred8x8l_down_right_c;
+    h-&gt;pred8x8l[VERT_RIGHT_PRED     ]= pred8x8l_vertical_right_c;
+    h-&gt;pred8x8l[HOR_DOWN_PRED       ]= pred8x8l_horizontal_down_c;
+    h-&gt;pred8x8l[VERT_LEFT_PRED      ]= pred8x8l_vertical_left_c;
+    h-&gt;pred8x8l[HOR_UP_PRED         ]= pred8x8l_horizontal_up_c;
+    h-&gt;pred8x8l[LEFT_DC_PRED        ]= pred8x8l_left_dc_c;
+    h-&gt;pred8x8l[TOP_DC_PRED         ]= pred8x8l_top_dc_c;
+    h-&gt;pred8x8l[DC_128_PRED         ]= pred8x8l_128_dc_c;
+
+    h-&gt;pred8x8[VERT_PRED8x8   ]= pred8x8_vertical_c;
+    h-&gt;pred8x8[HOR_PRED8x8    ]= pred8x8_horizontal_c;
+    h-&gt;pred8x8[PLANE_PRED8x8  ]= pred8x8_plane_c;
+    if(codec_id != CODEC_ID_RV40){
+        h-&gt;pred8x8[DC_PRED8x8     ]= pred8x8_dc_c;
+        h-&gt;pred8x8[LEFT_DC_PRED8x8]= pred8x8_left_dc_c;
+        h-&gt;pred8x8[TOP_DC_PRED8x8 ]= pred8x8_top_dc_c;
+    }else{
+        h-&gt;pred8x8[DC_PRED8x8     ]= pred8x8_dc_rv40_c;
+        h-&gt;pred8x8[LEFT_DC_PRED8x8]= pred8x8_left_dc_rv40_c;
+        h-&gt;pred8x8[TOP_DC_PRED8x8 ]= pred8x8_top_dc_rv40_c;
+    }
+    h-&gt;pred8x8[DC_128_PRED8x8 ]= pred8x8_128_dc_c;
+
+    h-&gt;pred16x16[DC_PRED8x8     ]= pred16x16_dc_c;
+    h-&gt;pred16x16[VERT_PRED8x8   ]= pred16x16_vertical_c;
+    h-&gt;pred16x16[HOR_PRED8x8    ]= pred16x16_horizontal_c;
+    h-&gt;pred16x16[PLANE_PRED8x8  ]= pred16x16_plane_c;
+    switch(codec_id){
+    case CODEC_ID_SVQ3:
+       h-&gt;pred16x16[PLANE_PRED8x8  ]= pred16x16_plane_svq3_c;
+       break;
+    case CODEC_ID_RV40:
+       h-&gt;pred16x16[PLANE_PRED8x8  ]= pred16x16_plane_rv40_c;
+       break;
+    default:
+       h-&gt;pred16x16[PLANE_PRED8x8  ]= pred16x16_plane_c;
+    }
+    h-&gt;pred16x16[LEFT_DC_PRED8x8]= pred16x16_left_dc_c;
+    h-&gt;pred16x16[TOP_DC_PRED8x8 ]= pred16x16_top_dc_c;
+    h-&gt;pred16x16[DC_128_PRED8x8 ]= pred16x16_128_dc_c;
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -0,0 +1,77 @@
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... encoder/decoder
+ * Copyright (c) 2003 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file h264pred.h
+ * H.264 / AVC / MPEG4 prediction functions.
+ * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ */
+
+#ifndef FFMPEG_H264PRED_H
+#define FFMPEG_H264PRED_H
+
+#include &quot;common.h&quot;
+
+/**
+ * Prediction types
+ */
+//@{
+#define VERT_PRED             0
+#define HOR_PRED              1
+#define DC_PRED               2
+#define DIAG_DOWN_LEFT_PRED   3
+#define DIAG_DOWN_RIGHT_PRED  4
+#define VERT_RIGHT_PRED       5
+#define HOR_DOWN_PRED         6
+#define VERT_LEFT_PRED        7
+#define HOR_UP_PRED           8
+
+#define LEFT_DC_PRED          9
+#define TOP_DC_PRED           10
+#define DC_128_PRED           11
+
+#define DIAG_DOWN_LEFT_PRED_RV40_NODOWN   12
+#define HOR_UP_PRED_RV40_NODOWN           13
+#define VERT_LEFT_PRED_RV40_NODOWN        14
+
+#define DC_PRED8x8            0
+#define HOR_PRED8x8           1
+#define VERT_PRED8x8          2
+#define PLANE_PRED8x8         3
+
+#define LEFT_DC_PRED8x8       4
+#define TOP_DC_PRED8x8        5
+#define DC_128_PRED8x8        6
+//@}
+
+/**
+ * Context for storing H.264 prediction functions
+ */
+typedef struct H264PredContext{
+    void (*pred4x4  [9+3+3])(uint8_t *src, uint8_t *topright, int stride);//FIXME move to dsp?
+    void (*pred8x8l [9+3])(uint8_t *src, int topleft, int topright, int stride);
+    void (*pred8x8  [4+3])(uint8_t *src, int stride);
+    void (*pred16x16[4+3])(uint8_t *src, int stride);
+}H264PredContext;
+
+void ff_h264_pred_init(H264PredContext *h, int codec_id);
+
+#endif /* FFMPEG_H264PRED_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rectangle.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rectangle.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rectangle.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -0,0 +1,121 @@
+/*
+ * rectangle filling function
+ * Copyright (c) 2003 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file rectangle.h
+ * useful rectangle filling function
+ * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ */
+
+#ifndef FFMPEG_RECTANGLE_H
+#define FFMPEG_RECTANGLE_H
+
+#include &quot;common.h&quot;
+
+/**
+ * fill a rectangle.
+ * @param h height of the rectangle, should be a constant
+ * @param w width of the rectangle, should be a constant
+ * @param size the size of val (1 or 4), should be a constant
+ */
+static av_always_inline void fill_rectangle(void *vp, int w, int h, int stride, uint32_t val, int size){
+    uint8_t *p= (uint8_t*)vp;
+    assert(size==1 || size==4);
+    assert(w&lt;=4);
+
+    w      *= size;
+    stride *= size;
+
+    assert((((long)vp)&amp;(FFMIN(w, STRIDE_ALIGN)-1)) == 0);
+    assert((stride&amp;(w-1))==0);
+    if(w==2){
+        const uint16_t v= size==4 ? val : val*0x0101;
+        *(uint16_t*)(p + 0*stride)= v;
+        if(h==1) return;
+        *(uint16_t*)(p + 1*stride)= v;
+        if(h==2) return;
+        *(uint16_t*)(p + 2*stride)= v;
+        *(uint16_t*)(p + 3*stride)= v;
+    }else if(w==4){
+        const uint32_t v= size==4 ? val : val*0x01010101;
+        *(uint32_t*)(p + 0*stride)= v;
+        if(h==1) return;
+        *(uint32_t*)(p + 1*stride)= v;
+        if(h==2) return;
+        *(uint32_t*)(p + 2*stride)= v;
+        *(uint32_t*)(p + 3*stride)= v;
+    }else if(w==8){
+    //gcc can't optimize 64bit math on x86_32
+#ifdef HAVE_FAST_64BIT
+        const uint64_t v= val*0x0100000001ULL;
+        *(uint64_t*)(p + 0*stride)= v;
+        if(h==1) return;
+        *(uint64_t*)(p + 1*stride)= v;
+        if(h==2) return;
+        *(uint64_t*)(p + 2*stride)= v;
+        *(uint64_t*)(p + 3*stride)= v;
+    }else if(w==16){
+        const uint64_t v= val*0x0100000001ULL;
+        *(uint64_t*)(p + 0+0*stride)= v;
+        *(uint64_t*)(p + 8+0*stride)= v;
+        *(uint64_t*)(p + 0+1*stride)= v;
+        *(uint64_t*)(p + 8+1*stride)= v;
+        if(h==2) return;
+        *(uint64_t*)(p + 0+2*stride)= v;
+        *(uint64_t*)(p + 8+2*stride)= v;
+        *(uint64_t*)(p + 0+3*stride)= v;
+        *(uint64_t*)(p + 8+3*stride)= v;
+#else
+        *(uint32_t*)(p + 0+0*stride)= val;
+        *(uint32_t*)(p + 4+0*stride)= val;
+        if(h==1) return;
+        *(uint32_t*)(p + 0+1*stride)= val;
+        *(uint32_t*)(p + 4+1*stride)= val;
+        if(h==2) return;
+        *(uint32_t*)(p + 0+2*stride)= val;
+        *(uint32_t*)(p + 4+2*stride)= val;
+        *(uint32_t*)(p + 0+3*stride)= val;
+        *(uint32_t*)(p + 4+3*stride)= val;
+    }else if(w==16){
+        *(uint32_t*)(p + 0+0*stride)= val;
+        *(uint32_t*)(p + 4+0*stride)= val;
+        *(uint32_t*)(p + 8+0*stride)= val;
+        *(uint32_t*)(p +12+0*stride)= val;
+        *(uint32_t*)(p + 0+1*stride)= val;
+        *(uint32_t*)(p + 4+1*stride)= val;
+        *(uint32_t*)(p + 8+1*stride)= val;
+        *(uint32_t*)(p +12+1*stride)= val;
+        if(h==2) return;
+        *(uint32_t*)(p + 0+2*stride)= val;
+        *(uint32_t*)(p + 4+2*stride)= val;
+        *(uint32_t*)(p + 8+2*stride)= val;
+        *(uint32_t*)(p +12+2*stride)= val;
+        *(uint32_t*)(p + 0+3*stride)= val;
+        *(uint32_t*)(p + 4+3*stride)= val;
+        *(uint32_t*)(p + 8+3*stride)= val;
+        *(uint32_t*)(p +12+3*stride)= val;
+#endif
+    }else
+        assert(0);
+    assert(h==4);
+}
+
+#endif /* FFMPEG_RECTANGLE_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/svq3.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/svq3.c	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/svq3.c	2008-07-24 18:20:17 UTC (rev 4281)
@@ -180,34 +180,6 @@
     }
 }
 
-static void pred4x4_down_left_svq3_c(uint8_t *src, uint8_t *topright, int stride){
-    LOAD_TOP_EDGE
-    LOAD_LEFT_EDGE
-    const av_unused int unu0= t0;
-    const av_unused int unu1= l0;
-
-    src[0+0*stride]=(l1 + t1)&gt;&gt;1;
-    src[1+0*stride]=
-    src[0+1*stride]=(l2 + t2)&gt;&gt;1;
-    src[2+0*stride]=
-    src[1+1*stride]=
-    src[0+2*stride]=
-    src[3+0*stride]=
-    src[2+1*stride]=
-    src[1+2*stride]=
-    src[0+3*stride]=
-    src[3+1*stride]=
-    src[2+2*stride]=
-    src[1+3*stride]=
-    src[3+2*stride]=
-    src[2+3*stride]=
-    src[3+3*stride]=(l3 + t3)&gt;&gt;1;
-}
-
-static void pred16x16_plane_svq3_c(uint8_t *src, int stride){
-    pred16x16_plane_compat_c(src, stride, 1);
-}
-
 static inline int svq3_decode_block (GetBitContext *gb, DCTELEM *block,
                                      int index, const int type) {
 
@@ -439,7 +411,7 @@
   uint32_t vlc;
   int8_t *top, *left;
   MpegEncContext *const s = (MpegEncContext *) h;
-  const int mb_xy = s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+  const int mb_xy = h-&gt;mb_xy;
   const int b_xy = 4*s-&gt;mb_x + 4*s-&gt;mb_y*h-&gt;b_stride;
 
   h-&gt;top_samples_available        = (s-&gt;mb_y == 0) ? 0x33FF : 0xFFFF;
@@ -447,10 +419,10 @@
   h-&gt;topright_samples_available        = 0xFFFF;
 
   if (mb_type == 0) {           /* SKIP */
-    if (s-&gt;pict_type == P_TYPE || s-&gt;next_picture.mb_type[mb_xy] == -1) {
+    if (s-&gt;pict_type == FF_P_TYPE || s-&gt;next_picture.mb_type[mb_xy] == -1) {
       svq3_mc_dir_part (s, 16*s-&gt;mb_x, 16*s-&gt;mb_y, 16, 16, 0, 0, 0, 0, 0, 0);
 
-      if (s-&gt;pict_type == B_TYPE) {
+      if (s-&gt;pict_type == FF_B_TYPE) {
         svq3_mc_dir_part (s, 16*s-&gt;mb_x, 16*s-&gt;mb_y, 16, 16, 0, 0, 0, 0, 1, 1);
       }
 
@@ -465,9 +437,9 @@
       mb_type = MB_TYPE_16x16;
     }
   } else if (mb_type &lt; 8) {     /* INTER */
-    if (h-&gt;thirdpel_flag &amp;&amp; h-&gt;halfpel_flag == !get_bits (&amp;s-&gt;gb, 1)) {
+    if (h-&gt;thirdpel_flag &amp;&amp; h-&gt;halfpel_flag == !get_bits1 (&amp;s-&gt;gb)) {
       mode = THIRDPEL_MODE;
-    } else if (h-&gt;halfpel_flag &amp;&amp; h-&gt;thirdpel_flag == !get_bits (&amp;s-&gt;gb, 1)) {
+    } else if (h-&gt;halfpel_flag &amp;&amp; h-&gt;thirdpel_flag == !get_bits1 (&amp;s-&gt;gb)) {
       mode = HALFPEL_MODE;
     } else {
       mode = FULLPEL_MODE;
@@ -511,15 +483,15 @@
       }else
         memset (&amp;h-&gt;ref_cache[m][scan8[0] - 1*8 - 1], PART_NOT_AVAILABLE, 8);
 
-      if (s-&gt;pict_type != B_TYPE)
+      if (s-&gt;pict_type != FF_B_TYPE)
         break;
     }
 
     /* decode motion vector(s) and form prediction(s) */
-    if (s-&gt;pict_type == P_TYPE) {
+    if (s-&gt;pict_type == FF_P_TYPE) {
       if(svq3_mc_dir (h, (mb_type - 1), mode, 0, 0) &lt; 0)
         return -1;
-    } else {        /* B_TYPE */
+    } else {        /* FF_B_TYPE */
       if (mb_type != 2) {
         if(svq3_mc_dir (h, 0, mode, 0, 0) &lt; 0)
           return -1;
@@ -618,11 +590,11 @@
     mb_type = MB_TYPE_INTRA16x16;
   }
 
-  if (!IS_INTER(mb_type) &amp;&amp; s-&gt;pict_type != I_TYPE) {
+  if (!IS_INTER(mb_type) &amp;&amp; s-&gt;pict_type != FF_I_TYPE) {
     for (i=0; i &lt; 4; i++) {
       memset (s-&gt;current_picture.motion_val[0][b_xy + i*h-&gt;b_stride], 0, 4*2*sizeof(int16_t));
     }
-    if (s-&gt;pict_type == B_TYPE) {
+    if (s-&gt;pict_type == FF_B_TYPE) {
       for (i=0; i &lt; 4; i++) {
         memset (s-&gt;current_picture.motion_val[1][b_xy + i*h-&gt;b_stride], 0, 4*2*sizeof(int16_t));
       }
@@ -631,12 +603,12 @@
   if (!IS_INTRA4x4(mb_type)) {
     memset (h-&gt;intra4x4_pred_mode[mb_xy], DC_PRED, 8);
   }
-  if (!IS_SKIP(mb_type) || s-&gt;pict_type == B_TYPE) {
+  if (!IS_SKIP(mb_type) || s-&gt;pict_type == FF_B_TYPE) {
     memset (h-&gt;non_zero_count_cache + 8, 0, 4*9*sizeof(uint8_t));
     s-&gt;dsp.clear_blocks(h-&gt;mb);
   }
 
-  if (!IS_INTRA16x16(mb_type) &amp;&amp; (!IS_SKIP(mb_type) || s-&gt;pict_type == B_TYPE)) {
+  if (!IS_INTRA16x16(mb_type) &amp;&amp; (!IS_SKIP(mb_type) || s-&gt;pict_type == FF_B_TYPE)) {
     if ((vlc = svq3_get_ue_golomb (&amp;s-&gt;gb)) &gt;= 48){
       av_log(h-&gt;s.avctx, AV_LOG_ERROR, &quot;cbp_vlc=%d\n&quot;, vlc);
       return -1;
@@ -644,7 +616,7 @@
 
     cbp = IS_INTRA(mb_type) ? golomb_to_intra4x4_cbp[vlc] : golomb_to_inter_cbp[vlc];
   }
-  if (IS_INTRA16x16(mb_type) || (s-&gt;pict_type != I_TYPE &amp;&amp; s-&gt;adaptive_quant &amp;&amp; cbp)) {
+  if (IS_INTRA16x16(mb_type) || (s-&gt;pict_type != FF_I_TYPE &amp;&amp; s-&gt;adaptive_quant &amp;&amp; cbp)) {
     s-&gt;qscale += svq3_get_se_golomb (&amp;s-&gt;gb);
 
     if (s-&gt;qscale &gt; 31){
@@ -709,7 +681,7 @@
 
 static int svq3_decode_slice_header (H264Context *h) {
   MpegEncContext *const s = (MpegEncContext *) h;
-  const int mb_xy = s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+  const int mb_xy = h-&gt;mb_xy;
   int i, header;
 
   header = get_bits (&amp;s-&gt;gb, 8);
@@ -748,7 +720,7 @@
     i = (s-&gt;mb_num &lt; 64) ? 6 : (1 + av_log2 (s-&gt;mb_num - 1));
     s-&gt;mb_skip_run = get_bits (&amp;s-&gt;gb, i) - (s-&gt;mb_x + (s-&gt;mb_y * s-&gt;mb_width));
   } else {
-    get_bits1 (&amp;s-&gt;gb);
+    skip_bits1 (&amp;s-&gt;gb);
     s-&gt;mb_skip_run = 0;
   }
 
@@ -757,17 +729,17 @@
   s-&gt;adaptive_quant = get_bits1 (&amp;s-&gt;gb);
 
   /* unknown fields */
-  get_bits1 (&amp;s-&gt;gb);
+  skip_bits1 (&amp;s-&gt;gb);
 
   if (h-&gt;unknown_svq3_flag) {
-    get_bits1 (&amp;s-&gt;gb);
+    skip_bits1 (&amp;s-&gt;gb);
   }
 
-  get_bits1 (&amp;s-&gt;gb);
-  get_bits (&amp;s-&gt;gb, 2);
+  skip_bits1 (&amp;s-&gt;gb);
+  skip_bits (&amp;s-&gt;gb, 2);
 
   while (get_bits1 (&amp;s-&gt;gb)) {
-    get_bits (&amp;s-&gt;gb, 8);
+    skip_bits (&amp;s-&gt;gb, 8);
   }
 
   /* reset intra predictors and invalidate motion vector references */
@@ -788,7 +760,7 @@
 
 static int svq3_decode_frame (AVCodecContext *avctx,
                               void *data, int *data_size,
-                              uint8_t *buf, int buf_size) {
+                              const uint8_t *buf, int buf_size) {
   MpegEncContext *const s = avctx-&gt;priv_data;
   H264Context *const h = avctx-&gt;priv_data;
   int m, mb_type;
@@ -802,8 +774,6 @@
   if (!s-&gt;context_initialized) {
     s-&gt;width = avctx-&gt;width;
     s-&gt;height = avctx-&gt;height;
-    h-&gt;pred4x4[DIAG_DOWN_LEFT_PRED] = pred4x4_down_left_svq3_c;
-    h-&gt;pred16x16[PLANE_PRED8x8] = pred16x16_plane_svq3_c;
     h-&gt;halfpel_flag = 1;
     h-&gt;thirdpel_flag = 1;
     h-&gt;unknown_svq3_flag = 0;
@@ -834,26 +804,26 @@
 
       /* 'frame size code' and optional 'width, height' */
       if (get_bits (&amp;gb, 3) == 7) {
-        get_bits (&amp;gb, 12);
-        get_bits (&amp;gb, 12);
+        skip_bits (&amp;gb, 12);
+        skip_bits (&amp;gb, 12);
       }
 
       h-&gt;halfpel_flag = get_bits1 (&amp;gb);
       h-&gt;thirdpel_flag = get_bits1 (&amp;gb);
 
       /* unknown fields */
-      get_bits1 (&amp;gb);
-      get_bits1 (&amp;gb);
-      get_bits1 (&amp;gb);
-      get_bits1 (&amp;gb);
+      skip_bits1 (&amp;gb);
+      skip_bits1 (&amp;gb);
+      skip_bits1 (&amp;gb);
+      skip_bits1 (&amp;gb);
 
       s-&gt;low_delay = get_bits1 (&amp;gb);
 
       /* unknown field */
-      get_bits1 (&amp;gb);
+      skip_bits1 (&amp;gb);
 
       while (get_bits1 (&amp;gb)) {
-        get_bits (&amp;gb, 8);
+        skip_bits (&amp;gb, 8);
       }
 
       h-&gt;unknown_svq3_flag = get_bits1 (&amp;gb);
@@ -865,6 +835,7 @@
   if (buf_size == 0) {
     if (s-&gt;next_picture_ptr &amp;&amp; !s-&gt;low_delay) {
       *(AVFrame *) data = *(AVFrame *) &amp;s-&gt;next_picture;
+      s-&gt;next_picture_ptr= NULL;
       *data_size = sizeof(AVFrame);
     }
     return 0;
@@ -872,7 +843,7 @@
 
   init_get_bits (&amp;s-&gt;gb, buf, 8*buf_size);
 
-  s-&gt;mb_x = s-&gt;mb_y = 0;
+  s-&gt;mb_x = s-&gt;mb_y = h-&gt;mb_xy = 0;
 
   if (svq3_decode_slice_header (h))
     return -1;
@@ -881,29 +852,29 @@
   s-&gt;picture_number = h-&gt;slice_num;
 
   if(avctx-&gt;debug&amp;FF_DEBUG_PICT_INFO){
-      av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;%c hpel:%d, tpel:%d aqp:%d qp:%d\n&quot;,
+      av_log(h-&gt;s.avctx, AV_LOG_DEBUG, &quot;%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\n&quot;,
       av_get_pict_type_char(s-&gt;pict_type), h-&gt;halfpel_flag, h-&gt;thirdpel_flag,
-      s-&gt;adaptive_quant, s-&gt;qscale
+      s-&gt;adaptive_quant, s-&gt;qscale, h-&gt;slice_num
       );
   }
 
   /* for hurry_up==5 */
   s-&gt;current_picture.pict_type = s-&gt;pict_type;
-  s-&gt;current_picture.key_frame = (s-&gt;pict_type == I_TYPE);
+  s-&gt;current_picture.key_frame = (s-&gt;pict_type == FF_I_TYPE);
 
   /* Skip B-frames if we do not have reference frames. */
-  if (s-&gt;last_picture_ptr == NULL &amp;&amp; s-&gt;pict_type == B_TYPE) return 0;
+  if (s-&gt;last_picture_ptr == NULL &amp;&amp; s-&gt;pict_type == FF_B_TYPE) return 0;
   /* Skip B-frames if we are in a hurry. */
-  if (avctx-&gt;hurry_up &amp;&amp; s-&gt;pict_type == B_TYPE) return 0;
+  if (avctx-&gt;hurry_up &amp;&amp; s-&gt;pict_type == FF_B_TYPE) return 0;
   /* Skip everything if we are in a hurry &gt;= 5. */
   if (avctx-&gt;hurry_up &gt;= 5) return 0;
-  if(  (avctx-&gt;skip_frame &gt;= AVDISCARD_NONREF &amp;&amp; s-&gt;pict_type==B_TYPE)
-     ||(avctx-&gt;skip_frame &gt;= AVDISCARD_NONKEY &amp;&amp; s-&gt;pict_type!=I_TYPE)
+  if(  (avctx-&gt;skip_frame &gt;= AVDISCARD_NONREF &amp;&amp; s-&gt;pict_type==FF_B_TYPE)
+     ||(avctx-&gt;skip_frame &gt;= AVDISCARD_NONKEY &amp;&amp; s-&gt;pict_type!=FF_I_TYPE)
      || avctx-&gt;skip_frame &gt;= AVDISCARD_ALL)
       return 0;
 
   if (s-&gt;next_p_frame_damaged) {
-    if (s-&gt;pict_type == B_TYPE)
+    if (s-&gt;pict_type == FF_B_TYPE)
       return 0;
     else
       s-&gt;next_p_frame_damaged = 0;
@@ -912,7 +883,7 @@
   if (frame_start (h) &lt; 0)
     return -1;
 
-  if (s-&gt;pict_type == B_TYPE) {
+  if (s-&gt;pict_type == FF_B_TYPE) {
     h-&gt;frame_num_offset = (h-&gt;slice_num - h-&gt;prev_frame_num);
 
     if (h-&gt;frame_num_offset &lt; 0) {
@@ -945,6 +916,7 @@
 
   for (s-&gt;mb_y=0; s-&gt;mb_y &lt; s-&gt;mb_height; s-&gt;mb_y++) {
     for (s-&gt;mb_x=0; s-&gt;mb_x &lt; s-&gt;mb_width; s-&gt;mb_x++) {
+      h-&gt;mb_xy = s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
 
       if ( (get_bits_count(&amp;s-&gt;gb) + 7) &gt;= s-&gt;gb.size_in_bits &amp;&amp;
           ((get_bits_count(&amp;s-&gt;gb) &amp; 7) == 0 || show_bits (&amp;s-&gt;gb, (-get_bits_count(&amp;s-&gt;gb) &amp; 7)) == 0)) {
@@ -960,9 +932,9 @@
 
       mb_type = svq3_get_ue_golomb (&amp;s-&gt;gb);
 
-      if (s-&gt;pict_type == I_TYPE) {
+      if (s-&gt;pict_type == FF_I_TYPE) {
         mb_type += 8;
-      } else if (s-&gt;pict_type == B_TYPE &amp;&amp; mb_type &gt;= 4) {
+      } else if (s-&gt;pict_type == FF_B_TYPE &amp;&amp; mb_type &gt;= 4) {
         mb_type += 4;
       }
       if (mb_type &gt; 33 || svq3_decode_mb (h, mb_type)) {
@@ -974,9 +946,9 @@
         hl_decode_mb (h);
       }
 
-      if (s-&gt;pict_type != B_TYPE &amp;&amp; !s-&gt;low_delay) {
+      if (s-&gt;pict_type != FF_B_TYPE &amp;&amp; !s-&gt;low_delay) {
         s-&gt;current_picture.mb_type[s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride] =
-                        (s-&gt;pict_type == P_TYPE &amp;&amp; mb_type &lt; 8) ? (mb_type - 1) : -1;
+                        (s-&gt;pict_type == FF_P_TYPE &amp;&amp; mb_type &lt; 8) ? (mb_type - 1) : -1;
       }
     }
 
@@ -985,7 +957,7 @@
 
   MPV_frame_end(s);
 
-  if (s-&gt;pict_type == B_TYPE || s-&gt;low_delay) {
+  if (s-&gt;pict_type == FF_B_TYPE || s-&gt;low_delay) {
     *(AVFrame *) data = *(AVFrame *) &amp;s-&gt;current_picture;
   } else {
     *(AVFrame *) data = *(AVFrame *) &amp;s-&gt;last_picture;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -81,7 +81,9 @@
 #define FFSIGN(a) ((a) &gt; 0 ? 1 : -1)
 
 #define FFMAX(a,b) ((a) &gt; (b) ? (a) : (b))
+#define FFMAX3(a,b,c) FFMAX(FFMAX(a,b),c)
 #define FFMIN(a,b) ((a) &gt; (b) ? (b) : (a))
+#define FFMIN3(a,b,c) FFMIN(FFMIN(a,b),c)
 
 #define FFSWAP(type,a,b) do{type SWAP_tmp= b; b= a; a= SWAP_tmp;}while(0)
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -26,10 +26,20 @@
 #ifndef AV_MEM_H
 #define AV_MEM_H
 
-#ifdef __GNUC__
-  #define DECLARE_ALIGNED(n,t,v)       t v __attribute__ ((aligned (n)))
-#else
-  #define DECLARE_ALIGNED(n,t,v)      __declspec(align(n)) t v
+#ifdef __ICC
+    #define DECLARE_ALIGNED(n,t,v)      t v __attribute__ ((aligned (n)))
+    #define DECLARE_ASM_CONST(n,t,v)    const t __attribute__ ((aligned (n))) v
+#elif defined(__GNUC__)
+    #define DECLARE_ALIGNED(n,t,v)      t v __attribute__ ((aligned (n)))
+    #define DECLARE_ASM_CONST(n,t,v)    static const t v attribute_used __attribute__ ((aligned (n)))
+#elif defined(_MSC_VER)
+    #define DECLARE_ALIGNED(n,t,v)      __declspec(align(n)) t v
+    #define DECLARE_ASM_CONST(n,t,v)    __declspec(align(n)) static const t v
+#elif defined(HAVE_INLINE_ASM)
+    #error The asm code needs alignment, but we do not know how to do it for this compiler.
+#else
+    #define DECLARE_ALIGNED(n,t,v)      t v
+    #define DECLARE_ASM_CONST(n,t,v)    static const t v
 #endif
 
 /**


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001521.html">[Avidemux-svn-commit] r4280 -	branches/avidemux_2.4_branch/avidemux/ADM_script
</A></li>
	<LI>Next message: <A HREF="001523.html">[Avidemux-svn-commit] r4282 -	branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1522">[ date ]</a>
              <a href="thread.html#1522">[ thread ]</a>
              <a href="subject.html#1522">[ subject ]</a>
              <a href="author.html#1522">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
