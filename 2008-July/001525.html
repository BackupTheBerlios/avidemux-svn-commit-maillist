<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4284 - in	branches/avidemux_2.4_branch/avidemux: ADM_infoExtractor	ADM_inputs/ADM_mpegdemuxer
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4284%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20ADM_infoExtractor%0A%09ADM_inputs/ADM_mpegdemuxer&In-Reply-To=%3C200807261236.m6QCaUhP005873%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001524.html">
   <LINK REL="Next"  HREF="001526.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4284 - in	branches/avidemux_2.4_branch/avidemux: ADM_infoExtractor	ADM_inputs/ADM_mpegdemuxer</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4284%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20ADM_infoExtractor%0A%09ADM_inputs/ADM_mpegdemuxer&In-Reply-To=%3C200807261236.m6QCaUhP005873%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4284 - in	branches/avidemux_2.4_branch/avidemux: ADM_infoExtractor	ADM_inputs/ADM_mpegdemuxer">gruntster at mail.berlios.de
       </A><BR>
    <I>Sat Jul 26 14:36:30 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001524.html">[Avidemux-svn-commit] r4283 - in	branches/avidemux_2.4_branch/avidemux: ADM_infoExtractor	ADM_inputs/ADM_mpegdemuxer
</A></li>
        <LI>Next message: <A HREF="001526.html">[Avidemux-svn-commit] r4285 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_infoExtractor ADM_inputs/ADM_mpegdemuxer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1525">[ date ]</a>
              <a href="thread.html#1525">[ thread ]</a>
              <a href="subject.html#1525">[ subject ]</a>
              <a href="author.html#1525">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2008-07-26 14:36:11 +0200 (Sat, 26 Jul 2008)
New Revision: 4284

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp
Log:
[TS] extract DAR from H.264 in MPEG-TS files

Modified: branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-25 17:50:39 UTC (rev 4283)
+++ branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-26 12:36:11 UTC (rev 4284)
@@ -1,352 +1,355 @@
-/***************************************************************************
-                          ADM_infoextractor
-                             -------------------
-           - extract additionnal info from header (mp4/h263)                  
-**************************************************************************/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-
-#include &lt;string.h&gt;
-
-#include &quot;math.h&quot;
-
-#include &lt;ADM_assert.h&gt;
-#include &quot;default.h&quot;
-#include &quot;ADM_editor/ADM_Video.h&quot;
-
-
-#include &quot;fourcc.h&quot;
-#include &quot;ADM_mp4/ADM_mp4.h&quot;
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_3GP
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-extern &quot;C&quot;
-{
-#include &quot;common.h&quot;
-#include &quot;bswap.h&quot;
-#define INT_MAX (0x7FFFFFFF)
-#include &quot;ADM_lavcodec/bitstream.h&quot;
-#include &quot;ADM_lavcodec/golomb.h&quot;
-}
-
-#include &quot;ADM_infoExtractor/ADM_h264_tag.h&quot;
-
-static void refineH264FrameType(uint8_t *head,uint8_t *tail,uint32_t *flags);
-/*
-    Extract width &amp; height from vol header passed as arg
-
-
-*/
-uint8_t extractMpeg4Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h,uint32_t *time_inc)
-{
-    // Search startcode
-    uint8_t b;
-    uint32_t idx=0;
-    uint32_t mw,mh;
-    uint32_t timeVal;
-    
-    //mixDump(data,dataSize);
-    //printf(&quot;\n&quot;);
-    while(1)
-    {
-        uint32_t startcode=0xffffffff;
-        while(dataSize&gt;2)
-        {
-            startcode=(startcode&lt;&lt;8)+data[idx];
-            idx++;
-            dataSize--;
-            if((startcode&amp;0xffffff)==1) break;
-        }
-        if(dataSize&gt;2)
-        {
-            //printf(&quot;Startcodec:%x\n&quot;,data[idx]);
-            if((data[idx]&amp;0xF0)==0x20) //VOL start
-            {
-                dataSize--;
-                idx++;
-#if 0
-                printf(&quot;VOL Header:\n&quot;);
-
-                if(dataSize&lt;16)
-                {
-                  mixDump(data+idx,dataSize);printf(&quot;\n&quot;);
-                }
-                else
-                {
-                  mixDump(data+idx,16);printf(&quot;\n&quot;);
-                }
-#endif
-                // Here we go !
-                GetBitContext s;
-                init_get_bits( &amp;s,data+idx, dataSize*8);
-                //
-                skip_bits1(&amp;s); // Random access
-                skip_bits(&amp;s,8); // Obj type indication
-                if(get_bits(&amp;s,1)) // VO od 
-                {
-                      skip_bits(&amp;s,4); // Ver
-                      skip_bits(&amp;s,3);  // Priority
-                }
-                if(get_bits(&amp;s,4)==15) // custom A/R
-                {
-                      skip_bits(&amp;s,8);
-                      skip_bits(&amp;s,8);
-                }
-                if(get_bits(&amp;s,1)) // Vol control param
-                {
-                      skip_bits(&amp;s,2);   //Chroma
-                      skip_bits(&amp;s,1);   // Low delay
-                      if(get_bits(&amp;s,1)) // VBV Info
-                      {
-                        skip_bits(&amp;s,16);
-                        skip_bits(&amp;s,16);
-                        skip_bits(&amp;s,16);
-                        skip_bits(&amp;s,15);
-                        skip_bits(&amp;s,16);
-                      }
-                  }
-                 skip_bits(&amp;s,2); //  Shape
-                 skip_bits(&amp;s,1); //  Marker
-                 timeVal=get_bits(&amp;s,16); // Time increment
-                 *time_inc = av_log2(timeVal - 1) + 1;
-                 if (*time_inc &lt; 1)
-                    *time_inc = 1;
-                 skip_bits(&amp;s,1); //  Marker
-                 if(get_bits(&amp;s,1)) // Fixed vop rate, compute how much bits needed
-                 {
-                     get_bits(&amp;s, *time_inc);
-                 }
-                  skip_bits(&amp;s,1); //  Marker
-                  mw=get_bits(&amp;s,13);
-                  skip_bits(&amp;s,1); //  Marker
-                  mh=get_bits(&amp;s,13);
-                // /Here we go
-                //printf(&quot;%d x %d \n&quot;,mw,mh);
-                *h=mh;
-                *w=mw;
-                return 1;;
-                // Free get bits ?
-                // WTF ?
-            }
-            continue;
-        }
-        else
-        {
-            printf(&quot;No more startcode\n&quot;);
-            // Free get bits ?
-            return 0;
-            
-        }
-    }
-    
-    return 0;
-}
-/**
-    \fn extractVopInfo
-    \brief extract info from vop : Vop type, module time base, time inc
-    
-    Warning this function expects data to start AFTER startcode, contrarily to other functions here!
-*/
-
-uint8_t extractVopInfo(uint8_t *data, uint32_t len,uint32_t timeincbits,uint32_t *vopType,uint32_t *modulo, uint32_t *time_inc,uint32_t *vopcoded)
-{
-   GetBitContext s;
-   int vop;
-   uint32_t vp,tinc;
-           init_get_bits( &amp;s,data, len*8);
-           vop=get_bits(&amp;s,2);
-           switch(vop)
-           {
-             case 0: vp=AVI_KEY_FRAME;break;
-             case 1: vp=0;break;
-             case 2: vp=AVI_B_FRAME;break;
-             case 3: vp=0;break;  // D FRAME ????
-             default:
-                printf(&quot;Unknown vop type :%d\n&quot;,vop);
-                return 0;
-           }
-           /* Read modulo */
-           int imodulo=0;
-           while (get_bits1(&amp;s) != 0)
-                  imodulo++;
-           if(!get_bits1(&amp;s))
-           {
-              printf(&quot;Wrong marker1\n&quot;);
-              return 0; 
-           }
-           
-           /* Read time */
-           tinc=get_bits(&amp;s,timeincbits);
-           /* Marker */
-            if(!get_bits1(&amp;s))
-           {
-              printf(&quot;Wrong marker2\n&quot;);
-              return 0; 
-           }
-           /* Vop coded */
-           *modulo=imodulo;
-           *vopcoded=get_bits1(&amp;s);
-           *vopType=vp;
-           *time_inc=tinc;
-           return 1;
-}
-/**
-      \brief extractH263FLVInfo
-      \fn Extract width/height from FLV header
-*/
-uint8_t extractH263FLVInfo(uint8_t *buffer,uint32_t len,uint32_t *w,uint32_t *h)
-{
-        GetBitContext gb;
-        int format;
-        init_get_bits( &amp;gb,buffer, len*8);
-        if (get_bits_long(&amp;gb, 17) != 1) {
-            printf(&quot;[FLV]Wrong FLV1 header\n&quot;);
-            return 0;
-        }
-        format = get_bits(&amp;gb, 5);
-        if (format != 0 &amp;&amp; format != 1) {
-            printf(&quot;[FLV]Wrong FLV1 header format\n&quot;);
-            return 0;        }
-        
-        get_bits(&amp;gb, 8); /* picture timestamp */
-        format = get_bits(&amp;gb, 3);
-        switch (format) {
-        case 0:
-            *w = get_bits(&amp;gb, 8);
-            *h = get_bits(&amp;gb, 8);
-            break;
-        case 1:
-            *w = get_bits(&amp;gb, 16);
-            *h = get_bits(&amp;gb, 16);
-            break;
-        case 2:
-            *w = 352;
-            *h = 288;
-            break;
-        case 3:
-            *w = 176;
-            *h = 144;
-            break;
-        case 4:
-            *w = 128;
-            *h = 96;
-            break;
-        case 5:
-            *w = 320;
-            *h = 240;
-            break;
-        case 6:
-            *w = 160;
-            *h = 120;
-            break;
-        default:
-             printf(&quot;[FLV]Wrong width format\n&quot;);
-             return 0;
-            break;
-        }
-        return 1;
-}
-/*
-        Extract H263 width &amp; height from header
-
-*/
-uint8_t extractH263Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h)
-{
-uint32_t val;
-                GetBitContext s;
-                init_get_bits( &amp;s,data, dataSize*8);
-                
-                 mixDump(data,10);
-                 val=get_bits(&amp;s,16);
-                 if(val)
-                 {
-                    printf(&quot;incorrect H263 header sync\n&quot;);
-                    return 0;
-                 }
-                 val=get_bits(&amp;s,6);
-                 if(val!=0x20)
-                 {
-                    printf(&quot;incorrect H263 header sync (2)\n&quot;);
-                    return 0;
-                 }
-                 //
-                 skip_bits(&amp;s,8); // timestamps in 30 fps tick
-                 skip_bits(&amp;s,1); // Marker
-                 skip_bits(&amp;s,1); // Id
-                 skip_bits(&amp;s,1); // Split
-                 skip_bits(&amp;s,1); // Document Camera indicator
-                 skip_bits(&amp;s,1); // Full Picture Freeze Release
-                 val=get_bits(&amp;s,3);
-                 switch(val)
-                 {
-                   
-                    case 1: *w=128;*h=96;return 1;break;
-                    case 2: *w=176;*h=144;return 1;break;
-                    case 6:
-                    case 7:
-                            printf(&quot;H263+:Todo\n&quot;);
-                    default:
-                        printf(&quot;Invalid format\n&quot;);return 0;break;
-                 }
-                 return 0;
-}
-/**
-    \fn unescapeH264
-    \brief Remove escape stuff
-
-*/
-static uint32_t unescapeH264(uint32_t len,uint8_t *in, uint8_t *out)
-{
-  uint32_t outlen=0;
-  uint8_t *tail=in+len;
-    if(len&lt;3) return 0;
-    while(in&lt;tail-3)
-    {
-      if(!in[0]  &amp;&amp; !in[1] &amp;&amp; in[2]==3)
-      {
-        out[0]=0;
-        out[1]=0;
-        out+=2;
-        outlen+=2;
-        in+=3; 
-      }
-      *out++=*in++;
-      outlen++;
-    }
-    // copy last bytes
-    uint32_t left=tail-in;
-    memcpy(out,in,left);
-    outlen+=left;
-    return outlen;
-    
-}
-
-static uint8_t extractVUIInfo(GetBitContext *s, uint32_t *fps1000)
-{
-	*fps1000 = 0;
-
+/***************************************************************************
+                          ADM_infoextractor
+                             -------------------
+           - extract additionnal info from header (mp4/h263)                  
+**************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;ADM_assert.h&quot;
+#include &quot;default.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+
+
+#include &quot;fourcc.h&quot;
+#include &quot;ADM_mp4/ADM_mp4.h&quot;
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_3GP
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+extern &quot;C&quot;
+{
+#include &quot;common.h&quot;
+#include &quot;bswap.h&quot;
+#define INT_MAX (0x7FFFFFFF)
+#include &quot;ADM_lavcodec/bitstream.h&quot;
+#include &quot;ADM_lavcodec/golomb.h&quot;
+}
+
+#include &quot;ADM_infoExtractor/ADM_h264_tag.h&quot;
+
+static void refineH264FrameType(uint8_t *head,uint8_t *tail,uint32_t *flags);
+/*
+    Extract width &amp; height from vol header passed as arg
+
+
+*/
+uint8_t extractMpeg4Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h,uint32_t *time_inc)
+{
+    // Search startcode
+    uint8_t b;
+    uint32_t idx=0;
+    uint32_t mw,mh;
+    uint32_t timeVal;
+    
+    //mixDump(data,dataSize);
+    //printf(&quot;\n&quot;);
+    while(1)
+    {
+        uint32_t startcode=0xffffffff;
+        while(dataSize&gt;2)
+        {
+            startcode=(startcode&lt;&lt;8)+data[idx];
+            idx++;
+            dataSize--;
+            if((startcode&amp;0xffffff)==1) break;
+        }
+        if(dataSize&gt;2)
+        {
+            //printf(&quot;Startcodec:%x\n&quot;,data[idx]);
+            if((data[idx]&amp;0xF0)==0x20) //VOL start
+            {
+                dataSize--;
+                idx++;
+#if 0
+                printf(&quot;VOL Header:\n&quot;);
+
+                if(dataSize&lt;16)
+                {
+                  mixDump(data+idx,dataSize);printf(&quot;\n&quot;);
+                }
+                else
+                {
+                  mixDump(data+idx,16);printf(&quot;\n&quot;);
+                }
+#endif
+                // Here we go !
+                GetBitContext s;
+                init_get_bits( &amp;s,data+idx, dataSize*8);
+                //
+                skip_bits1(&amp;s); // Random access
+                skip_bits(&amp;s,8); // Obj type indication
+                if(get_bits(&amp;s,1)) // VO od 
+                {
+                      skip_bits(&amp;s,4); // Ver
+                      skip_bits(&amp;s,3);  // Priority
+                }
+                if(get_bits(&amp;s,4)==15) // custom A/R
+                {
+                      skip_bits(&amp;s,8);
+                      skip_bits(&amp;s,8);
+                }
+                if(get_bits(&amp;s,1)) // Vol control param
+                {
+                      skip_bits(&amp;s,2);   //Chroma
+                      skip_bits(&amp;s,1);   // Low delay
+                      if(get_bits(&amp;s,1)) // VBV Info
+                      {
+                        skip_bits(&amp;s,16);
+                        skip_bits(&amp;s,16);
+                        skip_bits(&amp;s,16);
+                        skip_bits(&amp;s,15);
+                        skip_bits(&amp;s,16);
+                      }
+                  }
+                 skip_bits(&amp;s,2); //  Shape
+                 skip_bits(&amp;s,1); //  Marker
+                 timeVal=get_bits(&amp;s,16); // Time increment
+                 *time_inc = av_log2(timeVal - 1) + 1;
+                 if (*time_inc &lt; 1)
+                    *time_inc = 1;
+                 skip_bits(&amp;s,1); //  Marker
+                 if(get_bits(&amp;s,1)) // Fixed vop rate, compute how much bits needed
+                 {
+                     get_bits(&amp;s, *time_inc);
+                 }
+                  skip_bits(&amp;s,1); //  Marker
+                  mw=get_bits(&amp;s,13);
+                  skip_bits(&amp;s,1); //  Marker
+                  mh=get_bits(&amp;s,13);
+                // /Here we go
+                //printf(&quot;%d x %d \n&quot;,mw,mh);
+                *h=mh;
+                *w=mw;
+                return 1;;
+                // Free get bits ?
+                // WTF ?
+            }
+            continue;
+        }
+        else
+        {
+            printf(&quot;No more startcode\n&quot;);
+            // Free get bits ?
+            return 0;
+            
+        }
+    }
+    
+    return 0;
+}
+/**
+    \fn extractVopInfo
+    \brief extract info from vop : Vop type, module time base, time inc
+    
+    Warning this function expects data to start AFTER startcode, contrarily to other functions here!
+*/
+
+uint8_t extractVopInfo(uint8_t *data, uint32_t len,uint32_t timeincbits,uint32_t *vopType,uint32_t *modulo, uint32_t *time_inc,uint32_t *vopcoded)
+{
+   GetBitContext s;
+   int vop;
+   uint32_t vp,tinc;
+           init_get_bits( &amp;s,data, len*8);
+           vop=get_bits(&amp;s,2);
+           switch(vop)
+           {
+             case 0: vp=AVI_KEY_FRAME;break;
+             case 1: vp=0;break;
+             case 2: vp=AVI_B_FRAME;break;
+             case 3: vp=0;break;  // D FRAME ????
+             default:
+                printf(&quot;Unknown vop type :%d\n&quot;,vop);
+                return 0;
+           }
+           /* Read modulo */
+           int imodulo=0;
+           while (get_bits1(&amp;s) != 0)
+                  imodulo++;
+           if(!get_bits1(&amp;s))
+           {
+              printf(&quot;Wrong marker1\n&quot;);
+              return 0; 
+           }
+           
+           /* Read time */
+           tinc=get_bits(&amp;s,timeincbits);
+           /* Marker */
+            if(!get_bits1(&amp;s))
+           {
+              printf(&quot;Wrong marker2\n&quot;);
+              return 0; 
+           }
+           /* Vop coded */
+           *modulo=imodulo;
+           *vopcoded=get_bits1(&amp;s);
+           *vopType=vp;
+           *time_inc=tinc;
+           return 1;
+}
+/**
+      \brief extractH263FLVInfo
+      \fn Extract width/height from FLV header
+*/
+uint8_t extractH263FLVInfo(uint8_t *buffer,uint32_t len,uint32_t *w,uint32_t *h)
+{
+        GetBitContext gb;
+        int format;
+        init_get_bits( &amp;gb,buffer, len*8);
+        if (get_bits_long(&amp;gb, 17) != 1) {
+            printf(&quot;[FLV]Wrong FLV1 header\n&quot;);
+            return 0;
+        }
+        format = get_bits(&amp;gb, 5);
+        if (format != 0 &amp;&amp; format != 1) {
+            printf(&quot;[FLV]Wrong FLV1 header format\n&quot;);
+            return 0;        }
+        
+        get_bits(&amp;gb, 8); /* picture timestamp */
+        format = get_bits(&amp;gb, 3);
+        switch (format) {
+        case 0:
+            *w = get_bits(&amp;gb, 8);
+            *h = get_bits(&amp;gb, 8);
+            break;
+        case 1:
+            *w = get_bits(&amp;gb, 16);
+            *h = get_bits(&amp;gb, 16);
+            break;
+        case 2:
+            *w = 352;
+            *h = 288;
+            break;
+        case 3:
+            *w = 176;
+            *h = 144;
+            break;
+        case 4:
+            *w = 128;
+            *h = 96;
+            break;
+        case 5:
+            *w = 320;
+            *h = 240;
+            break;
+        case 6:
+            *w = 160;
+            *h = 120;
+            break;
+        default:
+             printf(&quot;[FLV]Wrong width format\n&quot;);
+             return 0;
+            break;
+        }
+        return 1;
+}
+/*
+        Extract H263 width &amp; height from header
+
+*/
+uint8_t extractH263Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h)
+{
+uint32_t val;
+                GetBitContext s;
+                init_get_bits( &amp;s,data, dataSize*8);
+                
+                 mixDump(data,10);
+                 val=get_bits(&amp;s,16);
+                 if(val)
+                 {
+                    printf(&quot;incorrect H263 header sync\n&quot;);
+                    return 0;
+                 }
+                 val=get_bits(&amp;s,6);
+                 if(val!=0x20)
+                 {
+                    printf(&quot;incorrect H263 header sync (2)\n&quot;);
+                    return 0;
+                 }
+                 //
+                 skip_bits(&amp;s,8); // timestamps in 30 fps tick
+                 skip_bits(&amp;s,1); // Marker
+                 skip_bits(&amp;s,1); // Id
+                 skip_bits(&amp;s,1); // Split
+                 skip_bits(&amp;s,1); // Document Camera indicator
+                 skip_bits(&amp;s,1); // Full Picture Freeze Release
+                 val=get_bits(&amp;s,3);
+                 switch(val)
+                 {
+                   
+                    case 1: *w=128;*h=96;return 1;break;
+                    case 2: *w=176;*h=144;return 1;break;
+                    case 6:
+                    case 7:
+                            printf(&quot;H263+:Todo\n&quot;);
+                    default:
+                        printf(&quot;Invalid format\n&quot;);return 0;break;
+                 }
+                 return 0;
+}
+/**
+    \fn unescapeH264
+    \brief Remove escape stuff
+
+*/
+static uint32_t unescapeH264(uint32_t len,uint8_t *in, uint8_t *out)
+{
+  uint32_t outlen=0;
+  uint8_t *tail=in+len;
+    if(len&lt;3) return 0;
+    while(in&lt;tail-3)
+    {
+      if(!in[0]  &amp;&amp; !in[1] &amp;&amp; in[2]==3)
+      {
+        out[0]=0;
+        out[1]=0;
+        out+=2;
+        outlen+=2;
+        in+=3; 
+      }
+      *out++=*in++;
+      outlen++;
+    }
+    // copy last bytes
+    uint32_t left=tail-in;
+    memcpy(out,in,left);
+    outlen+=left;
+    return outlen;
+    
+}
+
+static uint8_t extractVUIInfo(GetBitContext *s, uint32_t *fps1000, uint32_t *darNum, uint32_t *darDen)
+{
+	*fps1000 = *darNum = *darDen = 0;
+
 	if (get_bits1(s))
 	{
 		unsigned int aspect_ratio_information = get_bits(s, 8);
 
 		if (aspect_ratio_information == 255)
 		{
-			get_bits(s, 16);
-			get_bits(s, 16);
+			*darNum = get_bits_long(s, 16);
+			*darDen = get_bits_long(s, 16);
 		}
+		else if (aspect_ratio_information &lt; sizeof(pixel_aspect) / sizeof(*pixel_aspect))
+		{
+			*darNum = pixel_aspect[aspect_ratio_information].num;
+			*darDen = pixel_aspect[aspect_ratio_information].den;
+		}
 	}
 
 	if (get_bits1(s))	// overscan
@@ -383,86 +386,86 @@
 			*fps1000 /= 2;
 	}
 
-	return 1;
-}
-
-/**
-    \fn extractSPSInfo
-    \brief Extract info from H264 SPS
-    See 7.3.2.1 of 14496-10
-*/
-uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000)
-{
-   GetBitContext s;
-   
-   uint32_t profile,constraint,level,pic_order_cnt_type,w,h, mbh, frame_mbs_only;
-   uint8_t buf[len];
-   uint32_t outlen;
-   uint32_t id,dum;
-   
-           outlen=unescapeH264(len,data,buf);
-           init_get_bits( &amp;s,buf, outlen*8);
-            
-           profile=get_bits(&amp;s,8);
-           constraint=get_bits(&amp;s,8)&gt;&gt;5;
-           level=get_bits(&amp;s,8);
-           id=get_ue_golomb(&amp;s); // Seq parameter set id           
-           printf(&quot;[H264]Profile : %u, Level :%u, SPSid:%u\n&quot;,profile,level,id);
-           if(profile&gt;=100) // ?? Borrowed from H264.C/FFMPEG
-           {
-              printf(&quot;[H264]Warning : High profile\n&quot;);
-              if(get_ue_golomb(&amp;s) == 3) //chroma_format_idc
-                get_bits1(&amp;s);  //residual_color_transform_flag
-            get_ue_golomb(&amp;s);  //bit_depth_luma_minus8
-            get_ue_golomb(&amp;s);  //bit_depth_chroma_minus8
-            get_bits1(&amp;s);
-			if (get_bits1(&amp;s))
-				get_bits(&amp;s, 8);
-           }
-           
-
-           dum=get_ue_golomb(&amp;s); // log2_max_frame_num_minus4
-           printf(&quot;[H264]Log2maxFrame-4:%u\n&quot;,dum);
-           pic_order_cnt_type=get_ue_golomb(&amp;s);
-           printf(&quot;[H264]Pic Order Cnt Type:%u\n&quot;,pic_order_cnt_type);
-           if(!pic_order_cnt_type) // pic_order_cnt_type
-           {
-              dum=get_ue_golomb(&amp;s); //log2_max_pic_order_cnt_lsb_minus4
-              printf(&quot;[H264]Log2maxPix-4:%u\n&quot;,dum);
-           }else
-           {
-             if(pic_order_cnt_type==1)
-             {
-                 get_bits1(&amp;s);   //delta_pic_order_always_zero_flag
-                 get_se_golomb(&amp;s);   //offset_for_non_ref_pic
-                 get_se_golomb(&amp;s);  // offset_for_top_to_bottom_field
-                 int i=get_ue_golomb(&amp;s);  //num_ref_frames_in_pic_order_cnt_cycle
-
-                 for(int j=0;j&lt;i;j++)
-                 {
-                      get_se_golomb(&amp;s);
-                 }
-             }else 
-             {
-               printf(&quot;Error in SPS\n&quot;);
-               return 0;
-             }
-           }
-           dum=get_ue_golomb(&amp;s);     //num_ref_frames
-           printf(&quot;[H264] # of ref frames : %u\n&quot;,dum);
-           get_bits1(&amp;s);         // gaps_in_frame_num_value_allowed_flag
-		   w = get_ue_golomb(&amp;s) + 1;   //pic_width_in_mbs_minus1
-
-		   mbh = get_ue_golomb(&amp;s) + 1;
-		   frame_mbs_only = get_bits1(&amp;s);
-		   h = (2 - frame_mbs_only) * mbh;   //pic_height_in_mbs_minus1
-
-           printf(&quot;[H264] Width in mb -1  :%d\n&quot;,w); 
-           printf(&quot;[H264] Height in mb -1 :%d\n&quot;, h);
-
-		   *wwidth = w * 16;
-		   *hheight= h * 16;
-           
+	return 1;
+}
+
+/**
+    \fn extractSPSInfo
+    \brief Extract info from H264 SPS
+    See 7.3.2.1 of 14496-10
+*/
+uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000, uint32_t *darNum, uint32_t *darDen)
+{
+   GetBitContext s;
+   
+   uint32_t profile,constraint,level,pic_order_cnt_type,w,h, mbh, frame_mbs_only;
+   uint8_t buf[len];
+   uint32_t outlen;
+   uint32_t id,dum;
+   
+           outlen=unescapeH264(len,data,buf);
+           init_get_bits( &amp;s,buf, outlen*8);
+            
+           profile=get_bits(&amp;s,8);
+           constraint=get_bits(&amp;s,8)&gt;&gt;5;
+           level=get_bits(&amp;s,8);
+           id=get_ue_golomb(&amp;s); // Seq parameter set id           
+           printf(&quot;[H264]Profile : %u, Level :%u, SPSid:%u\n&quot;,profile,level,id);
+           if(profile&gt;=100) // ?? Borrowed from H264.C/FFMPEG
+           {
+              printf(&quot;[H264]Warning : High profile\n&quot;);
+              if(get_ue_golomb(&amp;s) == 3) //chroma_format_idc
+                get_bits1(&amp;s);  //residual_color_transform_flag
+            get_ue_golomb(&amp;s);  //bit_depth_luma_minus8
+            get_ue_golomb(&amp;s);  //bit_depth_chroma_minus8
+            get_bits1(&amp;s);
+			if (get_bits1(&amp;s))
+				get_bits(&amp;s, 8);
+           }
+           
+
+           dum=get_ue_golomb(&amp;s); // log2_max_frame_num_minus4
+           printf(&quot;[H264]Log2maxFrame-4:%u\n&quot;,dum);
+           pic_order_cnt_type=get_ue_golomb(&amp;s);
+           printf(&quot;[H264]Pic Order Cnt Type:%u\n&quot;,pic_order_cnt_type);
+           if(!pic_order_cnt_type) // pic_order_cnt_type
+           {
+              dum=get_ue_golomb(&amp;s); //log2_max_pic_order_cnt_lsb_minus4
+              printf(&quot;[H264]Log2maxPix-4:%u\n&quot;,dum);
+           }else
+           {
+             if(pic_order_cnt_type==1)
+             {
+                 get_bits1(&amp;s);   //delta_pic_order_always_zero_flag
+                 get_se_golomb(&amp;s);   //offset_for_non_ref_pic
+                 get_se_golomb(&amp;s);  // offset_for_top_to_bottom_field
+                 int i=get_ue_golomb(&amp;s);  //num_ref_frames_in_pic_order_cnt_cycle
+
+                 for(int j=0;j&lt;i;j++)
+                 {
+                      get_se_golomb(&amp;s);
+                 }
+             }else 
+             {
+               printf(&quot;Error in SPS\n&quot;);
+               return 0;
+             }
+           }
+           dum=get_ue_golomb(&amp;s);     //num_ref_frames
+           printf(&quot;[H264] # of ref frames : %u\n&quot;,dum);
+           get_bits1(&amp;s);         // gaps_in_frame_num_value_allowed_flag
+		   w = get_ue_golomb(&amp;s) + 1;   //pic_width_in_mbs_minus1
+
+		   mbh = get_ue_golomb(&amp;s) + 1;
+		   frame_mbs_only = get_bits1(&amp;s);
+		   h = (2 - frame_mbs_only) * mbh;   //pic_height_in_mbs_minus1
+
+           printf(&quot;[H264] Width in mb -1  :%d\n&quot;,w); 
+           printf(&quot;[H264] Height in mb -1 :%d\n&quot;, h);
+
+		   *wwidth = w * 16;
+		   *hheight= h * 16;
+           
 		   if (!frame_mbs_only)
 			   get_bits1(&amp;s);
 
@@ -477,128 +480,128 @@
 		   }
 
 		   if(get_bits1(&amp;s))
-			   extractVUIInfo(&amp;s, fps1000);
-
-           return 1;
-}
-/**
-      \fn extractH264FrameType
-      \brief return frametype in flags (KEY_FRAME or 0). To be used only with  mkv/mp4 nal type (i.e. no startcode)
-      
-*/
-uint8_t extractH264FrameType(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags)
-{
-  uint8_t *head=buffer, *tail=buffer+len;
-  uint8_t stream;
-  
-  uint32_t val,hnt;  
-  
-// FIXME :  no startcode only !
-  
-  while(head+4&lt;tail)
-  {
-    
-              uint32_t length=(head[0]&lt;&lt;24) + (head[1]&lt;&lt;16) +(head[2]&lt;&lt;8)+(head[3]);
-              if(length&gt;len||length&lt;6)
-              {
-                printf(&quot;Warning , incomplete nal (%u/%u),(%0x/%0x)\n&quot;,length,len,length,len);
-                *flags=0;
-                return 0;
-              }
-              head+=4; // Skip nal lenth
-              length-=4;
-              stream=*(head++)&amp;0x1F;
-                switch(stream)
-                {
-                  case NAL_IDR: 
-                                  *flags=AVI_KEY_FRAME;
-                                  
-                                  return 1;
-                                  break; 
-                  case NAL_NON_IDR: 
-                                  refineH264FrameType(head,tail,flags);
-                                  return 1;
-                                  break;
-                  default:
-                          printf(&quot;??0x%x\n&quot;,stream);
-                          head+=length-5;
-                          continue;
-                }
-  }
-  printf(&quot;No stream\n&quot;);
-  return 0;
-}
-
-/**
-      \fn extractH264FrameType_startCode
-      \brief return frametype in flags (KEY_FRAME or 0). To be used only with  avi / mpeg TS nal type (i.e. with startcode)
-      
-*/
-uint8_t extractH264FrameType_startCode(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags)
-{
-  uint8_t *head=buffer, *tail=buffer+len;
-  uint8_t stream;
-#define NAL_NON_IDR       1
-#define NAL_IDR           5
-#define NAL_SEI           6
-
-  uint32_t val,hnt;  
-  
-// FIXME :  no startcode only !
-  
-  while(head+4&lt;tail)
-  {
-          // Search startcode
-      
-                hnt=(head[0]&lt;&lt;24) + (head[1]&lt;&lt;16) +(head[2]&lt;&lt;8)+(head[3]);
-                head+=4;
-                while((hnt!=1) &amp;&amp; head&lt;tail)
-                {
-
-                        hnt&lt;&lt;=8;
-                        val=*head++;
-                        hnt+=val;
-                }
-                if(head&gt;=tail) break;
-                stream=*(head++) &amp;0x1f;
-                switch(stream)
-                {
-                  case NAL_IDR: 
-                                  *flags=AVI_KEY_FRAME;
-                                 // printf(&quot;IDR\n&quot;);
-                                  return 1;
-                                  break; 
-                  case NAL_NON_IDR: 
-                                  refineH264FrameType(head,tail,flags);
-                                  return 1;
-                                  break;
-                  default:
-                          printf(&quot;??0x%x\n&quot;,stream);
-                          continue;
-                }
-  }
-  printf(&quot;No stream\n&quot;);
-  return 0;
-}
-/**
-    \fn refineH264FrameType
-    \brief Try to detect B slice, warning the stream is not escaped!
-*/
-void refineH264FrameType(uint8_t *head,uint8_t *tail,uint32_t *flags)
-{
-GetBitContext s;
-uint32_t sliceType;
-            *flags=0;
-            init_get_bits(&amp;s,head, (tail-head)*8);
-            get_ue_golomb(&amp;s);
-            sliceType= get_ue_golomb(&amp;s);
-            if(sliceType &gt; 9) 
-            {
-              printf(&quot;Weird Slice %d\n&quot;,sliceType);
-              return ;
-            }
-            if(sliceType &gt; 4)
-                sliceType -= 5;
-            if(sliceType==3) *flags=AVI_B_FRAME;  
-}
-//EOF
+			   extractVUIInfo(&amp;s, fps1000, darNum, darDen);
+
+           return 1;
+}
+/**
+      \fn extractH264FrameType
+      \brief return frametype in flags (KEY_FRAME or 0). To be used only with  mkv/mp4 nal type (i.e. no startcode)
+      
+*/
+uint8_t extractH264FrameType(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags)
+{
+  uint8_t *head=buffer, *tail=buffer+len;
+  uint8_t stream;
+  
+  uint32_t val,hnt;  
+  
+// FIXME :  no startcode only !
+  
+  while(head+4&lt;tail)
+  {
+    
+              uint32_t length=(head[0]&lt;&lt;24) + (head[1]&lt;&lt;16) +(head[2]&lt;&lt;8)+(head[3]);
+              if(length&gt;len||length&lt;6)
+              {
+                printf(&quot;Warning , incomplete nal (%u/%u),(%0x/%0x)\n&quot;,length,len,length,len);
+                *flags=0;
+                return 0;
+              }
+              head+=4; // Skip nal lenth
+              length-=4;
+              stream=*(head++)&amp;0x1F;
+                switch(stream)
+                {
+                  case NAL_IDR: 
+                                  *flags=AVI_KEY_FRAME;
+                                  
+                                  return 1;
+                                  break; 
+                  case NAL_NON_IDR: 
+                                  refineH264FrameType(head,tail,flags);
+                                  return 1;
+                                  break;
+                  default:
+                          printf(&quot;??0x%x\n&quot;,stream);
+                          head+=length-5;
+                          continue;
+                }
+  }
+  printf(&quot;No stream\n&quot;);
+  return 0;
+}
+
+/**
+      \fn extractH264FrameType_startCode
+      \brief return frametype in flags (KEY_FRAME or 0). To be used only with  avi / mpeg TS nal type (i.e. with startcode)
+      
+*/
+uint8_t extractH264FrameType_startCode(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags)
+{
+  uint8_t *head=buffer, *tail=buffer+len;
+  uint8_t stream;
+#define NAL_NON_IDR       1
+#define NAL_IDR           5
+#define NAL_SEI           6
+
+  uint32_t val,hnt;  
+  
+// FIXME :  no startcode only !
+  
+  while(head+4&lt;tail)
+  {
+          // Search startcode
+      
+                hnt=(head[0]&lt;&lt;24) + (head[1]&lt;&lt;16) +(head[2]&lt;&lt;8)+(head[3]);
+                head+=4;
+                while((hnt!=1) &amp;&amp; head&lt;tail)
+                {
+
+                        hnt&lt;&lt;=8;
+                        val=*head++;
+                        hnt+=val;
+                }
+                if(head&gt;=tail) break;
+                stream=*(head++) &amp;0x1f;
+                switch(stream)
+                {
+                  case NAL_IDR: 
+                                  *flags=AVI_KEY_FRAME;
+                                 // printf(&quot;IDR\n&quot;);
+                                  return 1;
+                                  break; 
+                  case NAL_NON_IDR: 
+                                  refineH264FrameType(head,tail,flags);
+                                  return 1;
+                                  break;
+                  default:
+                          printf(&quot;??0x%x\n&quot;,stream);
+                          continue;
+                }
+  }
+  printf(&quot;No stream\n&quot;);
+  return 0;
+}
+/**
+    \fn refineH264FrameType
+    \brief Try to detect B slice, warning the stream is not escaped!
+*/
+void refineH264FrameType(uint8_t *head,uint8_t *tail,uint32_t *flags)
+{
+GetBitContext s;
+uint32_t sliceType;
+            *flags=0;
+            init_get_bits(&amp;s,head, (tail-head)*8);
+            get_ue_golomb(&amp;s);
+            sliceType= get_ue_golomb(&amp;s);
+            if(sliceType &gt; 9) 
+            {
+              printf(&quot;Weird Slice %d\n&quot;,sliceType);
+              return ;
+            }
+            if(sliceType &gt; 4)
+                sliceType -= 5;
+            if(sliceType==3) *flags=AVI_B_FRAME;  
+}
+//EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2008-07-25 17:50:39 UTC (rev 4283)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2008-07-26 12:36:11 UTC (rev 4284)
@@ -240,15 +240,10 @@
               
         printf(&quot;*********Indexing Ended (%d audio tracks)***********\n&quot;,nbTracks);
 
-         switch(run.imageAR)
-         {
-           case 1: 	qfprintf(out,&quot;# Video Aspect Ratio : %s\n&quot;, &quot;1:1&quot; );break;
-           case 2: 	qfprintf(out,&quot;# Video Aspect Ratio : %s\n&quot;, &quot;4:3&quot; );break;
-           case 3: 	qfprintf(out,&quot;# Video Aspect Ratio : %s\n&quot;, &quot;16:9&quot; );break;
-           default:
-              printf(&quot;imageAR=%u\n&quot;,run.imageAR);
-              GUI_Error_HIG(QT_TR_NOOP(&quot;Can't determine aspect ratio&quot;),NULL);
-	}
+		if (run.imageDarNum == 0 || run.imageDarDen == 0)
+			GUI_Error_HIG(QT_TR_NOOP(&quot;Can't determine aspect ratio&quot;),NULL);
+		else
+			qfprintf(out,&quot;# Video Aspect Ratio : %d:%d\n&quot;, run.imageDarNum, run.imageDarDen);
 
         /* Now update......... */
           fseeko(out,0,SEEK_SET);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-25 17:50:39 UTC (rev 4283)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-26 12:36:11 UTC (rev 4284)
@@ -22,7 +22,7 @@
 #include &lt;math.h&gt;
 
 #include &quot;default.h&quot;
-#include &lt;ADM_assert.h&gt;
+#include &quot;ADM_assert.h&quot;
 
 
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
@@ -54,7 +54,7 @@
 static const char Type[5]={'X','I','P','B','P'};
 
 
-extern uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000);
+extern uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000, uint32_t *darNum, uint32_t *darDen);
 
 dmx_videoIndexerH264::dmx_videoIndexerH264(dmx_runData *run) : dmx_videoIndexer(run)
 {
@@ -150,13 +150,11 @@
               {
                     // Our firt frame is here
                     // Important to initialize the mpeg decoder !
-                    _run-&gt;imageAR = 1;	// 1:1 to suppress warning
-
                       uint8_t buffer[60] ; // should be enough
                       uint64_t xA,xR;
                       _run-&gt;demuxer-&gt;getPos(&amp;xA,&amp;xR);
                       _run-&gt;demuxer-&gt;read(buffer,60);
-                      if(extractSPSInfo(buffer,60,&amp;( _run-&gt;imageW),&amp;( _run-&gt;imageH),&amp;(_run-&gt;imageFPS)))
+                      if(extractSPSInfo(buffer,60,&amp;( _run-&gt;imageW),&amp;( _run-&gt;imageH),&amp;(_run-&gt;imageFPS),&amp;(_run-&gt;imageDarNum),&amp;(_run-&gt;imageDarDen)))
                       {
                             seq_found=1;
                             startFrame(1,syncAbs,syncRel);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h	2008-07-25 17:50:39 UTC (rev 4283)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h	2008-07-26 12:36:11 UTC (rev 4284)
@@ -47,7 +47,7 @@
       uint32_t nbImage;
       uint32_t nbPushed,nbGop;      
       uint32_t nbTrack;
-      uint32_t imageW,imageH,imageFPS,imageAR;
+      uint32_t imageW,imageH,imageFPS, imageDarNum, imageDarDen;
       TimeStamp firstStamp,lastStamp; /* Time code hh:mm:ss */
       
 }dmx_runData;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp	2008-07-25 17:50:39 UTC (rev 4283)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp	2008-07-26 12:36:11 UTC (rev 4284)
@@ -22,7 +22,7 @@
 #include &lt;math.h&gt;
 
 #include &quot;default.h&quot;
-#include &lt;ADM_assert.h&gt;
+#include &quot;ADM_assert.h&quot;
 
 
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
@@ -107,7 +107,7 @@
 uint8_t streamid;   
 uint32_t temporal_ref,ftype,val;
 uint64_t pts,dts;
-
+uint32_t imageAR;
       
 
       while(1)
@@ -147,7 +147,29 @@
                               _run-&gt;imageW=val&gt;&gt;20;
                               _run-&gt;imageW=((_run-&gt;imageW+15)&amp;~15);
                               _run-&gt;imageH= (((val&gt;&gt;8) &amp; 0xfff)+15)&amp; ~15;
-                              _run-&gt;imageAR=(val&gt;&gt;4)&amp;0xf;
+
+							  imageAR = (val &gt;&gt; 4) &amp; 0xf;
+
+							  switch (imageAR)
+							  {
+								  case 1:
+									  _run-&gt;imageDarNum = 1;
+									  _run-&gt;imageDarDen = 1;
+									  break;
+								  case 2:
+									  _run-&gt;imageDarNum = 4;
+									  _run-&gt;imageDarDen = 3;
+									  break;
+								  case 3:
+									  _run-&gt;imageDarNum = 16;
+									  _run-&gt;imageDarDen = 9;
+									  break;
+								  default:
+									  _run-&gt;imageDarNum = 0;
+									  _run-&gt;imageDarDen = 0;
+									  printf(&quot;imageAR = %u\n&quot;, imageAR);
+							  }
+
                               _run-&gt;imageFPS= FPS[val &amp; 0xf];
                               demuxer-&gt;forward(4);
                               break;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001524.html">[Avidemux-svn-commit] r4283 - in	branches/avidemux_2.4_branch/avidemux: ADM_infoExtractor	ADM_inputs/ADM_mpegdemuxer
</A></li>
	<LI>Next message: <A HREF="001526.html">[Avidemux-svn-commit] r4285 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_infoExtractor ADM_inputs/ADM_mpegdemuxer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1525">[ date ]</a>
              <a href="thread.html#1525">[ thread ]</a>
              <a href="subject.html#1525">[ subject ]</a>
              <a href="author.html#1525">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
