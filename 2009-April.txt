From gruntster at mail.berlios.de  Thu Apr  2 15:24:25 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 2 Apr 2009 15:24:25 +0200
Subject: [Avidemux-svn-commit] r4721 - in
	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_audio
	avidemux/ADM_codecs avidemux/ADM_core/src
	avidemux/ADM_infoExtractor avidemux/ADM_outputs/oplug_avi
	cmake cmake/patches
Message-ID: <200904021324.n32DOPxa012942@sheep.berlios.de>

Author: gruntster
Date: 2009-04-02 15:24:10 +0200 (Thu, 02 Apr 2009)
New Revision: 4721

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_dcainfo.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_cpuCap.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisavecopy_pack.cpp
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavutil_mem.c.patch
Log:
[ffmpeg] update FFmpeg to r18300 & libswscale r29120

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_dcainfo.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_dcainfo.cpp	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_dcainfo.cpp	2009-04-02 13:24:10 UTC (rev 4721)
@@ -14,13 +14,13 @@
 #include <stdio.h>
 #include "ADM_default.h"
 #include "ADM_audio/ADM_dcainfo.h"
+
 extern "C"
 {
-#include "libavutil/common.h"
-#include "libavutil/bswap.h"
+#define INT_BIT (CHAR_BIT * sizeof(int))
 #include "libavcodec/bitstream.h"
+}
 
-}
 #include "ADM_assert.h"
 
 /*

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp	2009-04-02 13:24:10 UTC (rev 4721)
@@ -205,7 +205,7 @@
 
   _context->width = _w;
   _context->height = _h;
-  _context->pix_fmt = PIX_FMT_YUV420P;	//PIX_FMT_RGBA32
+  _context->pix_fmt = PIX_FMT_YUV420P;
   //_context->debug=1;
 
   _internalBuffer = new uint8_t[w * h * 3];
@@ -422,7 +422,7 @@
 	case PIX_FMT_RGB24:
 	  out->_colorspace = ADM_COLOR_RGB24;
 	  break;
-    case PIX_FMT_RGBA32:
+    case PIX_FMT_RGB32:
       out->_colorspace = ADM_COLOR_RGB32A;
       break;
     case PIX_FMT_RGB555:

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_cpuCap.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_cpuCap.cpp	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_cpuCap.cpp	2009-04-02 13:24:10 UTC (rev 4721)
@@ -34,13 +34,6 @@
 }
 
 
-#ifdef ADM_CPU_X86
-extern "C" 
-{
-#include "libavcodec/dsputil.h"
-}
-#endif
-
 #define cpuid(index,eax,ebx,ecx,edx)\
     __asm __volatile\
         ("mov %%"REG_b", %%"REG_S"\n\t"\

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2009-04-02 13:24:10 UTC (rev 4721)
@@ -26,9 +26,7 @@
 
 extern "C"
 {
-#include "libavutil/common.h"
-#include "libavutil/bswap.h"
-#define INT_MAX (0x7FFFFFFF)
+#define INT_BIT (CHAR_BIT * sizeof(int))
 #include "libavcodec/bitstream.h"
 #include "libavcodec/golomb.h"
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisavecopy_pack.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisavecopy_pack.cpp	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisavecopy_pack.cpp	2009-04-02 13:24:10 UTC (rev 4721)
@@ -334,7 +334,7 @@
 {
 #undef av_always_inline
 #define av_always_inline inline
-#include "libavutil/bswap.h"
+#define INT_BIT (CHAR_BIT * sizeof(int))
 #include "libavcodec/bitstream.h"
 }
 void putNvop(ADMBitstream *data,uint32_t timebits, uint32_t timeincval)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-04-02 13:24:10 UTC (rev 4721)
@@ -1,8 +1,8 @@
 include(admFFmpegUtil)
 find_package(Subversion)
 
-set(FFMPEG_VERSION 17480)
-set(SWSCALE_VERSION 28690)
+set(FFMPEG_VERSION 18300)
+set(SWSCALE_VERSION 29120)
 set(FFMPEG_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries/ffmpeg")
 set(FFMPEG_BINARY_DIR "${CMAKE_BINARY_DIR}/avidemux/ADM_libraries/ffmpeg")
 
@@ -14,7 +14,7 @@
 set(FFMPEG_PARSERS  h263  h264  mpeg4video)
 set(FFMPEG_PROTOCOLS  file)
 set(FFMPEG_FLAGS  --enable-shared --disable-static --disable-filters --disable-protocols --disable-indevs --disable-outdevs --disable-bsfs
-				  --disable-parsers --disable-decoders --disable-encoders --disable-demuxers --disable-muxers --enable-postproc --enable-swscale --enable-gpl 
+				  --disable-parsers --disable-decoders --disable-encoders --disable-demuxers --disable-muxers --enable-postproc --enable-gpl 
 				  --prefix=${CMAKE_INSTALL_PREFIX})
 
 if (NOT VERBOSE)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2009-04-02 13:24:10 UTC (rev 4721)
@@ -1,8 +1,8 @@
-*** libavcodec/avcodec.h.old	Sat Feb 21 16:10:58 2009
---- libavcodec/avcodec.h	Sat Feb 21 16:10:57 2009
+*** libavcodec/avcodec.h.old	Wed Apr  1 18:35:35 2009
+--- libavcodec/avcodec.h	Wed Apr  1 18:35:35 2009
 ***************
-*** 501,506 ****
---- 501,508 ----
+*** 505,510 ****
+--- 505,512 ----
   #define CODEC_FLAG2_CHUNKS        0x00008000 ///< Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.
   #define CODEC_FLAG2_NON_LINEAR_QUANT 0x00010000 ///< Use MPEG-2 nonlinear quantizer.
   #define CODEC_FLAG2_BIT_RESERVOIR 0x00020000 ///< Use a bit reservoir when encoding if possible
@@ -12,8 +12,8 @@
   /* Unsupported options :
    *              Syntax Arithmetic coding (SAC)
 ***************
-*** 1290,1295 ****
---- 1292,1298 ----
+*** 1302,1307 ****
+--- 1304,1310 ----
        * - decoding: unused
        */
       int rc_max_rate;
@@ -22,8 +22,8 @@
       /**
        * minimum bitrate
 ***************
-*** 1304,1309 ****
---- 1307,1314 ----
+*** 1316,1321 ****
+--- 1319,1326 ----
        * - decoding: unused
        */
       int rc_buffer_size;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2009-04-02 13:24:10 UTC (rev 4721)
@@ -1,8 +1,8 @@
-*** libavcodec/h263dec.c.old	Mon Feb  2 19:49:50 2009
---- libavcodec/h263dec.c	Mon Feb  2 19:49:49 2009
+*** libavcodec/h263dec.c.old	Wed Apr  1 18:35:37 2009
+--- libavcodec/h263dec.c	Wed Apr  1 18:35:37 2009
 ***************
-*** 118,123 ****
---- 118,140 ----
+*** 120,125 ****
+--- 120,142 ----
   
       return 0;
   }
@@ -27,8 +27,8 @@
   av_cold int ff_h263_decode_end(AVCodecContext *avctx)
   {
 ***************
-*** 409,414 ****
---- 426,437 ----
+*** 418,423 ****
+--- 435,446 ----
       } else {
           ret = h263_decode_picture_header(s);
       }
@@ -42,8 +42,8 @@
       if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_size);
   
 ***************
-*** 687,692 ****
---- 710,723 ----
+*** 706,711 ****
+--- 729,742 ----
   
   assert(s->current_picture.pict_type == s->current_picture_ptr->pict_type);
   assert(s->current_picture.pict_type == s->pict_type);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2009-04-02 13:24:10 UTC (rev 4721)
@@ -1,8 +1,8 @@
-*** libavcodec/h264.c.old	Sat Feb 21 16:11:02 2009
---- libavcodec/h264.c	Sat Feb 21 16:11:02 2009
+*** libavcodec/h264.c.old	Wed Apr  1 18:35:37 2009
+--- libavcodec/h264.c	Wed Apr  1 18:35:37 2009
 ***************
-*** 8091,8096 ****
---- 8091,8107 ----
+*** 8104,8109 ****
+--- 8104,8120 ----
       return 0;
   }
   

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch	2009-04-02 13:24:10 UTC (rev 4721)
@@ -1,8 +1,8 @@
-*** libavcodec/mpeg12.c.old	Sat Feb 21 16:11:03 2009
---- libavcodec/mpeg12.c	Sat Feb 21 16:11:03 2009
+*** libavcodec/mpeg12.c.old	Wed Apr  1 18:35:38 2009
+--- libavcodec/mpeg12.c	Wed Apr  1 18:35:38 2009
 ***************
-*** 1922,1927 ****
---- 1922,1932 ----
+*** 1952,1957 ****
+--- 1952,1962 ----
           ff_er_frame_end(s);
   
           MPV_frame_end(s);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2009-04-02 13:24:10 UTC (rev 4721)
@@ -1,7 +1,7 @@
-*** libavcodec/mpegvideo.c.old	Sat Feb 21 16:11:05 2009
---- libavcodec/mpegvideo.c	Sat Feb 21 16:11:05 2009
+*** libavcodec/mpegvideo.c.old	Wed Apr  1 18:35:39 2009
+--- libavcodec/mpegvideo.c	Wed Apr  1 18:35:39 2009
 ***************
-*** 563,569 ****
+*** 606,612 ****
       CHECKED_ALLOCZ(s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE);
   
       s->parse_context.state= -1;
@@ -9,7 +9,7 @@
          s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
          s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
          s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
---- 563,573 ----
+--- 606,616 ----
       CHECKED_ALLOCZ(s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE);
   
       s->parse_context.state= -1;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2009-04-02 13:24:10 UTC (rev 4721)
@@ -1,8 +1,8 @@
-*** libavcodec/utils.c.old	Sat Feb 21 16:11:07 2009
---- libavcodec/utils.c	Sat Feb 21 16:11:07 2009
+*** libavcodec/utils.c.old	Wed Apr  1 18:35:40 2009
+--- libavcodec/utils.c	Wed Apr  1 18:35:40 2009
 ***************
-*** 543,552 ****
---- 543,554 ----
+*** 555,564 ****
+--- 555,566 ----
   
       if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
           //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
@@ -16,7 +16,7 @@
           *frame_size_ptr < avctx->channels * avctx->frame_size * sizeof(int16_t)){
               av_log(avctx, AV_LOG_ERROR, "buffer %d too small\n", *frame_size_ptr);
 ***************
-*** 957,963 ****
+*** 969,975 ****
           return -1;
       }
   #if !HAVE_MKSTEMP
@@ -24,7 +24,7 @@
   #else
       snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
       fd = mkstemp(*filename);
---- 959,965 ----
+--- 971,977 ----
           return -1;
       }
   #if !HAVE_MKSTEMP

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2009-04-02 13:24:10 UTC (rev 4721)
@@ -1,8 +1,8 @@
-*** libavformat/matroskaenc.c.old	Sat Feb 21 16:11:12 2009
---- libavformat/matroskaenc.c	Sat Feb 21 16:11:12 2009
+*** libavformat/matroskaenc.c.old	Wed Apr  1 18:35:42 2009
+--- libavformat/matroskaenc.c	Wed Apr  1 18:35:42 2009
 ***************
-*** 394,399 ****
---- 394,400 ----
+*** 395,400 ****
+--- 395,401 ----
   
   static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec)
   {
@@ -11,8 +11,8 @@
       int header_len[3];
       int first_header_size;
 ***************
-*** 418,423 ****
---- 419,446 ----
+*** 419,424 ****
+--- 420,447 ----
           put_buffer(pb, header_start[j], header_len[j]);
   
       return 0;
@@ -40,10 +40,10 @@
 + #endif
   }
   
-  #define FLAC_STREAMINFO_SIZE 34
+  static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
 ***************
-*** 555,560 ****
---- 578,600 ----
+*** 534,539 ****
+--- 557,579 ----
           put_ebml_uint (pb, MATROSKA_ID_TRACKNUMBER     , i + 1);
           put_ebml_uint (pb, MATROSKA_ID_TRACKUID        , i + 1);
           put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
@@ -68,8 +68,8 @@
           if ((tag = av_metadata_get(st->metadata, "description", NULL, 0)))
               put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value);
 ***************
-*** 928,930 ****
---- 968,980 ----
+*** 907,909 ****
+--- 947,959 ----
       .flags = AVFMT_GLOBALHEADER,
       .codec_tag = (const AVCodecTag* const []){codec_wav_tags, 0},
   };

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch	2009-04-02 13:24:10 UTC (rev 4721)
@@ -1,9 +1,9 @@
-*** libavformat/movenc.c.old	Sat Feb 21 16:11:13 2009
---- libavformat/movenc.c	Sat Feb 21 16:11:13 2009
+*** libavformat/movenc.c.old	Wed Apr  1 18:35:42 2009
+--- libavformat/movenc.c	Wed Apr  1 18:35:42 2009
 ***************
-*** 1925,1927 ****
---- 1925,1939 ----
-      .codec_tag = (const AVCodecTag* const []){ff_mp4_obj_type, 0},
+*** 1960,1962 ****
+--- 1960,1974 ----
+      .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
   };
   #endif
 + /* MEANX */

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavutil_mem.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavutil_mem.c.patch	2009-03-31 05:31:32 UTC (rev 4720)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavutil_mem.c.patch	2009-04-02 13:24:10 UTC (rev 4721)
@@ -1,7 +1,7 @@
-*** libavutil/mem.c.old	Mon Feb  2 20:01:23 2009
---- libavutil/mem.c	Mon Feb  2 20:01:22 2009
+*** libavutil/mem.c.old	Wed Apr  1 18:35:44 2009
+--- libavutil/mem.c	Wed Apr  1 18:35:44 2009
 ***************
-*** 46,131 ****
+*** 46,132 ****
   
   void *av_malloc(unsigned int size)
   {
@@ -22,7 +22,8 @@
 !     ptr = (char*)ptr + diff;
 !     ((char*)ptr)[-1]= diff;
 ! #elif HAVE_POSIX_MEMALIGN
-!     posix_memalign(&ptr,16,size);
+!     if (posix_memalign(&ptr,16,size))
+!         ptr = NULL;
 ! #elif HAVE_MEMALIGN
 !     ptr = memalign(16,size);
 !     /* Why 64?
@@ -135,7 +136,7 @@
 ! 		return av_malloc(newsize);
 ! 
 ! 	if (!newsize) 
-! 	{    	
+! 	{
 ! 		av_free(ptr);
 ! 		return NULL;
 ! 	}



From mean at mail.berlios.de  Tue Apr  7 07:39:45 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 7 Apr 2009 07:39:45 +0200
Subject: [Avidemux-svn-commit] r4722 -
	branches/avidemux_2.6_branch_mean/avidemux
Message-ID: <200904070539.n375djsb009658@sheep.berlios.de>

Author: mean
Date: 2009-04-07 07:39:44 +0200 (Tue, 07 Apr 2009)
New Revision: 4722

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
Log:
[ALl] Simplify CMakeList

Modified: branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-04-02 13:24:10 UTC (rev 4721)
+++ branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-04-07 05:39:44 UTC (rev 4722)
@@ -55,17 +55,6 @@
 INCLUDE_DIRECTORIES("${CMAKE_BINARY_DIR}/config")
 # temp
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_audioFilter_old/")
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_core/include")
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreUI/include")
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreImage/include")
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreAudio/include")
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreAudioEncoder/include")
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_audioFilter/include")
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_audioParser/include")
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreUtils/include")
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreAudioDevice/include")
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreDemuxer/include")
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreMuxer/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_libraries/")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_libraries/ADM_ffmpeg/libavutil")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_libraries/ADM_ffmpeg/")
@@ -76,6 +65,28 @@
 	INCLUDE_DIRECTORIES(${GETTEXT_INCLUDE_DIR})
 ENDIF (GETTEXT_FOUND)
 
+###########################################
+#  Our own shared libs
+###########################################
+SET(ADM_CORES
+        ADM_core
+        ADM_coreUI
+        ADM_coreImage
+        ADM_audioParser
+        ADM_coreAudioEncoder
+        ADM_coreAudio
+        ADM_audioFilter
+        ADM_coreDemuxer
+        ADM_coreDemuxerMpeg
+        ADM_coreAudioDevice
+        ADM_coreUtils
+        ADM_coreMuxer
+)
+FOREACH(_current ${ADM_CORES})
+        INCLUDE_DIRECTORIES(${_current}/include)
+ENDFOREACH(_current ${ADM_CORES})
+
+
 ########################################
 # Embed resources for executables
 ########################################
@@ -177,7 +188,6 @@
 ########################################
 SET(ADM_SUBDIR 
 	ADM_audioFilter_old
-	#ADM_audioEncoder
 	ADM_editor
 	ADM_muxerGate
 	ADM_audiocodec
@@ -186,8 +196,6 @@
 	ADM_filter
 	ADM_videoFilter
 	ADM_video
-	#ADM_audiodevice
-	#ADM_ocr
 )
 FOREACH(_current ${ADM_SUBDIR})
 	ADD_SUBDIRECTORY(${_current})
@@ -195,52 +203,12 @@
 ENDFOREACH(_current ${ADM_SUBDIR})
 
 ###########################################
-# Construct ADM_outputs
+# Construct ADM_UIs
 ###########################################
-#ADD_SUBDIRECTORY(ADM_outputs)
-
-SET(ADM_OUTPUTS	
-	#oplug_avi
-	#oplug_mp4
-	#oplug_mpeg
-	#oplug_mpegFF
-	#oplug_ogm
-	#oplug_flv
-	#oplug_dummy
-	#ADM_outputs)
-)
-
-ADD_ADMLIB_ALL_TARGETS(${ADM_OUTPUTS})
-
-###########################################
-# Construct ADM_inputs
-###########################################
-#ADD_SUBDIRECTORY(ADM_inputs)
 ADD_SUBDIRECTORY(ADM_UIs)
 
-SET(ADM_INPUTS
-	#ADM_asf
-	#ADM_avsproxy
-	#ADM_h263
-	#ADM_inpics
-	#ADM_matroska
-	#ADM_mp4
-	#ADM_mpegdemuxer
-	#ADM_nuv
-	#ADM_ogm
-	#ADM_openDML
-	#ADM_flv
-	#ADM_amv
-)
 
-ADD_ADMLIB_ALL_TARGETS(${ADM_INPUTS})
 #########################################
-# Mpeg Indexer (Mpeg TS/PS/...)
-#########################################
-#ADD_SUBDIRECTORY(ADM_mpegIndexer)
-#ADD_ADMLIB_ALL_TARGETS(ADM_mpegIndexer)
-
-#########################################
 # Tails
 #########################################
 SET(ADM_TAILS
@@ -261,9 +229,7 @@
 ADD_SUBDIRECTORY(ADM_libraries)
 
 ADD_ADMLIB_ALL_TARGETS(
-	#ADM_mplex
 	ADM_libmpeg2enc
-	#ADM_lvemux
 	ADM_xvidratectl
 )
 ADD_LIB_ALL_TARGETS(
@@ -336,36 +302,12 @@
                 ADM_render_qt4
 )
 ENDIF (ADM_UI_QT4)
+# Add the core libs
+FOREACH(_current ${ADM_CORES})
+	ADD_SUBDIRECTORY(${_current})
+	ADD_LIB_ALL_TARGETS(${_current})
+ENDFOREACH(_current ${ADM_CORES})
 
-
-###########################################
-#  Our own shared libs
-###########################################
-ADD_SUBDIRECTORY(ADM_core)
-ADD_LIB_ALL_TARGETS(ADM_core)
-ADD_SUBDIRECTORY(ADM_coreUI)
-ADD_LIB_ALL_TARGETS(ADM_coreUI)
-ADD_SUBDIRECTORY(ADM_coreImage)
-ADD_LIB_ALL_TARGETS(ADM_coreImage)
-ADD_SUBDIRECTORY(ADM_audioParser)
-ADD_LIB_ALL_TARGETS(ADM_audioParser)
-ADD_SUBDIRECTORY(ADM_coreAudioEncoder)
-ADD_LIB_ALL_TARGETS(ADM_coreAudioEncoder)
-ADD_SUBDIRECTORY(ADM_coreAudio)
-ADD_LIB_ALL_TARGETS(ADM_coreAudio)
-ADD_SUBDIRECTORY(ADM_audioFilter)
-ADD_LIB_ALL_TARGETS(ADM_audioFilter)
-ADD_SUBDIRECTORY(ADM_coreDemuxer)
-ADD_LIB_ALL_TARGETS(ADM_coreDemuxer)
-ADD_SUBDIRECTORY(ADM_coreDemuxerMpeg)
-ADD_LIB_ALL_TARGETS(ADM_coreDemuxerMpeg)
-ADD_SUBDIRECTORY(ADM_coreAudioDevice)
-ADD_LIB_ALL_TARGETS(ADM_coreAudioDevice)
-ADD_SUBDIRECTORY(ADM_coreUtils)
-ADD_LIB_ALL_TARGETS(ADM_coreUtils)
-ADD_SUBDIRECTORY(ADM_coreMuxer)
-ADD_LIB_ALL_TARGETS(ADM_coreMuxer)
-
 # To be removed
 #ADD_SUBDIRECTORY(ADM_audioEncoder)
 



From mean at mail.berlios.de  Tue Apr  7 07:39:51 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 7 Apr 2009 07:39:51 +0200
Subject: [Avidemux-svn-commit] r4723 - in branches/avidemux_2.6_branch_mean:
	avidemux/ADM_coreDemuxerMpeg/include
	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers
	plugins/ADM_demuxers/MpegTS
Message-ID: <200904070539.n375dpDA009673@sheep.berlios.de>

Author: mean
Date: 2009-04-07 07:39:51 +0200 (Tue, 07 Apr 2009)
New Revision: 4723

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/CMakeLists.txt
Log:
[Demuxer:MpegTs] Skeleton

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,96 @@
+/**
+    dmxPSPacket.cpp
+
+*/
+
+#ifndef DMXPSPACKET_H
+#define DMXPSPACKET_H
+
+#include "dmxPacket.h"
+#include "ADM_Video.h"
+
+
+
+/**
+    \class psPacket
+*/
+class psPacket : public ADMMpegPacket
+{
+protected:
+    uint8_t             getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
+public:
+                        psPacket(void);
+    virtual            ~psPacket();
+    virtual bool        open(const char *filenames,FP_TYPE append);
+    virtual bool        close(void);
+    virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
+    virtual uint64_t    getPos(void);
+    virtual bool        setPos(uint64_t pos);
+};
+/**
+    \class psPacketLinear
+*/
+#define ADM_PACKET_LINEAR 10*1024
+
+class psPacketLinear : public psPacket
+{
+protected:
+        uint8_t  myPid;
+        uint64_t startAt;
+        uint32_t bufferLen;
+        uint64_t bufferPts;
+        uint64_t bufferDts;
+        uint32_t bufferIndex;
+        uint8_t  buffer[ADM_PACKET_LINEAR];
+        bool     eof;
+        bool     refill(void);
+        uint64_t oldStartAt;
+        uint32_t oldBufferLen;
+        uint64_t oldBufferPts;
+        uint64_t oldBufferDts;
+        uint32_t consumed;
+
+public:
+                psPacketLinear(uint8_t pid);
+                ~psPacketLinear();
+        uint32_t getConsumed(void);
+        uint8_t  readi8();
+        uint16_t readi16();
+        uint32_t readi32();
+        bool     sync(uint8_t *pid);
+        bool    read(uint32_t len, uint8_t *buffer);
+        bool    forward(uint32_t v);
+        bool    stillOk(void) {return !eof;};
+        bool    getInfo(dmxPacketInfo *info);
+        bool    seek(uint64_t packetStart, uint32_t offset);
+        bool    changePid(uint32_t pid) ;
+};
+/**
+    \class psPacketLinearTracker
+*/
+typedef struct
+{
+    uint32_t count;
+    uint32_t size;
+    
+    uint64_t startAt;
+    uint32_t startCount;
+    uint32_t startSize;
+    uint64_t startDts;
+}packetStats;
+
+class psPacketLinearTracker : public psPacketLinear
+{
+protected:
+      packetStats stats[256];
+
+public:
+                        psPacketLinearTracker(uint8_t pid);
+                        ~psPacketLinearTracker();
+         packetStats    *getStat(int intdex);
+         bool           resetStats(void);
+virtual  bool           getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
+};
+
+
+#endif
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,653 @@
+/**
+    \file dmxPSPacket
+    \brief Packet demuxer for mpeg PS
+    copyright            : (C) 2005-2008 by mean
+    email                : fixounet at free.fr
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+
+#include "dmxPSPacket.h"
+#include "dmx_mpegstartcode.h"
+
+/**
+    \fn psPacket
+    \brief ctor
+*/
+psPacket::psPacket(void) 
+{
+
+}
+/**
+    \fn psPacket
+    \brief dtor
+*/
+psPacket::~psPacket()
+{
+    close();
+}
+/**
+    \fn open
+    \brief dtor
+*/
+bool psPacket::open(const char *filenames,FP_TYPE append)
+{
+    _file=new fileParser();
+    if(!_file->open(filenames,&append))
+    {
+        printf("[DmxPS] cannot open %s\n",filenames);
+        delete _file;
+        _file=NULL;
+        return false;
+    }
+    _size=_file->getSize();
+    return true;
+}
+/**
+    \fn close
+    \brief dtor
+*/
+bool psPacket::close(void)
+{
+    if(_file)
+    {
+        delete _file;
+        _file=NULL;
+    }
+    return true;
+}
+/**
+    \fn getPos
+*/
+uint64_t    psPacket::getPos(void)
+{
+    return 0;
+}
+/**
+    \fn setPos
+*/
+
+bool    psPacket::setPos(uint64_t pos)
+{
+    if(!_file->setpos(pos))
+    {
+        printf("[psPacket] Cannot seek to %"LLX"\n", pos);
+        return false;
+    }
+}
+
+/**
+    \fn getPacket
+*/      
+bool        psPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)
+{
+uint32_t globstream,len;
+uint8_t  stream,substream;
+uint64_t pts,dts;
+        // Resync on our stream
+_again2:
+        *pid=0;
+        if(!_file->sync(&stream)) 
+        {
+                uint64_t pos;
+                _file->getpos(&pos);
+                printf("[DmxPS] cannot sync  at "LLU"/"LLU"\n",pos,_size);
+                return false;
+        }
+// Position of this packet just before startcode
+        _file->getpos(startAt);
+        *startAt-=4;
+// Handle out of band stuff        
+        if(stream==PACK_START_CODE) 
+        {
+        		_file->forward(8);
+        		goto _again2;
+        }
+        if( stream==PADDING_CODE ||stream==SYSTEM_START_CODE) 
+        {
+                        len=_file->read16i();
+                        //printf("\tForwarding %lu bytes\n",len);
+        		_file->forward(len);
+        		goto _again2;
+        }
+        // Only keep relevant parts
+        // i.e. a/v : C0 C9 E0 E9
+        // subs 20-29
+        // private data 1/2
+#define INSIDE(min,max) (stream>=min && stream<max)
+        if(!(  INSIDE(0xC0,0xC9) || INSIDE(0xE0,0xE9) || INSIDE(0x20,0x29) || stream==PRIVATE_STREAM_1 || stream==PRIVATE_STREAM_2
+        			)) goto _again2;
+        // Ok we got a candidate
+        if(!getPacketInfo(stream,&substream,&len,&pts,&dts))   
+        {
+                goto _again2;
+        }
+        
+        //printf("Main Stream :%x substream :%x\n",stream,substream);
+        if(stream==PRIVATE_STREAM_1) globstream=0xFF00+substream;
+                else                 globstream=stream;
+
+        *pid=globstream;
+        *opts=pts;
+        *odts=dts;
+        *packetSize=len;
+        if(len>     maxSize)
+        {
+                printf("[DmxPS] Packet too big %d vs %d\n",len,maxSize);
+        }
+        if(!_file->read32(len,buffer)) return false;
+        return true;
+       
+}
+/**
+
+    \fn getPacketInfo
+    \brief       Retrieve info about the packet we just met.It is assumed that parser is just after the packet startcode
+
+*/
+
+uint8_t psPacket::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
+{
+
+//uint32_t un ,deux;
+uint64_t size=0;
+uint8_t c,d;
+uint8_t align=0;
+                        
+                *substream=0xff;
+                *opts=ADM_NO_PTS;
+                *odts=ADM_NO_PTS;
+                
+                                        
+                size=_file->read16i();
+                if((stream==PADDING_CODE) || 
+                	 (stream==PRIVATE_STREAM_2)
+                        ||(stream==SYSTEM_START_CODE) //?
+                        ) // special case, no header
+                        {
+                                *olen=size;      
+                                return 1;
+                        }
+                                
+                        //      remove padding if any                                           
+        
+                while((c=_file->read8i()) == 0xff) 
+                {
+                        size--;
+                }
+//----------------------------------------------------------------------------
+//-------------------------------MPEG-2 PES packet style----------------------
+//----------------------------------------------------------------------------
+                if(((c&0xC0)==0x80))
+                {
+                        uint32_t ptsdts,len;
+                        //printf("\n mpeg2 type \n");
+                        //_muxTypeMpeg2=1;
+                        // c= copyright and stuff       
+                        //printf(" %x align\n",c);      
+                        if(c & 4) align=1;      
+                        c=_file->read8i();     // PTS/DTS
+                        //printf("%x ptsdts\n",c
+                        ptsdts=c>>6;
+                        // header len
+                        len=_file->read8i();
+                        size-=3;  
+
+                        switch(ptsdts)
+                        {
+                                case 2: // PTS=1 DTS=0
+                                        if(len>=5)
+                                        {
+                                                uint64_t pts1,pts2,pts0;
+                                                //      printf("\n PTS10\n");
+                                                        pts0=_file->read8i();  
+                                                        pts1=_file->read16i(); 
+                                                        pts2=_file->read16i();                 
+                                                        len-=5;
+                                                        size-=5;
+                                                        *opts=(pts1>>1)<<15;
+                                                        *opts+=pts2>>1;
+                                                        *opts+=(((pts0&6)>>1)<<30);
+                                        }
+                                        break;
+                                case 3: // PTS=1 DTS=1
+                                                #define PTS11_ADV 10 // nut monkey
+                                                if(len>=PTS11_ADV)
+                                                {
+                                                        uint32_t skip=PTS11_ADV;
+                                                        uint64_t pts1,pts2,dts,pts0;
+                                                                //      printf("\n PTS10\n");
+                                                                pts0=_file->read8i();  
+                                                                pts1=_file->read16i(); 
+                                                                pts2=_file->read16i(); 
+                                                                                        
+                                                                *opts=(pts1>>1)<<15;
+                                                                *opts+=pts2>>1;
+                                                                *opts+=(((pts0&6)>>1)<<30);
+                                                                pts0=_file->read8i();  
+                                                                pts1=_file->read16i(); 
+                                                                pts2=_file->read16i();                 
+                                                                dts=(pts1>>1)<<15;
+                                                                dts+=pts2>>1;
+                                                                dts+=(((pts0&6)>>1)<<30);
+                                                                len-=skip;
+                                                                size-=skip;
+                                                                *odts=dts;
+                                                                        //printf("DTS: %lx\n",dts);                
+                                                   }
+                                                   break;               
+                                case 1:
+                                                return 0;//ADM_assert(0); // forbidden !
+                                                break;
+                                case 0: 
+                                                // printf("\n PTS00\n");
+                                                break; // no pts nor dts
+                                                                                
+                                                            
+                        }  
+// Extension bit        
+// >stealthdave<                                
+
+                        // Skip remaining headers if any
+                        if(len) 
+                        {
+                                _file->forward(len);
+                                size=size-len;
+                        }
+                                
+                if(stream==PRIVATE_STREAM_1)
+                {
+                        if(size>5)
+                        {
+                        // read sub id
+                               *substream=_file->read8i();
+  //                    printf("\n Subid : %x",*subid);
+                                switch(*substream)
+                                {
+                                // DTS
+                                        case 0x88:case 0x89:case 0x8A:case 0x8B:
+                                        
+                                                *substream=*substream-0x48;
+                                                break;
+
+                                //AC3
+                                        case 0x80:case 0x81:case 0x82:case 0x83:
+                                        case 0x84:case 0x85:case 0x86:case 0x87:
+                                                *substream=*substream-0x80;
+                                                break;
+                                // PCM
+                                        case 0xA0:case 0xA1:case 0xa2:case 0xa3:
+                                        case 0xA4:case 0xA5:case 0xa6:case 0xa7:
+                                                // we have an additionnal header
+                                                // of 3 bytes
+                                                _file->forward(3);
+                                                size-=3;
+                                                break;
+                                // Subs
+                                case 0x20:case 0x21:case 0x22:case 0x23:
+                                case 0x24:case 0x25:case 0x26:case 0x27:
+                                                break;
+                             
+                                default:
+                                                doNoComplainAnyMore++;
+                                                if(doNoComplainAnyMore<10)
+                                                    printf("[DmxPS]Unkown substream %x\n",*substream);
+                                                *substream=0xff;
+                                }
+                                // skip audio header (if not sub)
+                                if(*substream>0x26 || *substream<0x20)
+                                {
+                                        _file->forward(3);
+                                        size-=3;
+                                }
+                                size--;
+                        }
+                }
+               //    printf(" pid %x size : %x len %x\n",sid,size,len);
+                *olen=size;
+                return 1;
+        }
+//----------------------------------------------------------------------------------------------                
+//-------------------------------MPEG-1 PES packet style----------------------                                  
+//----------------------------------------------------------------------------------------------                                        
+           if(0) //_muxTypeMpeg2)
+                {
+                        printf("[DmxPS]*** packet type 1 inside type 2 ?????*****\n");
+                        return 0; // mmmm                       
+                }
+          // now look at  STD buffer size if present
+          // 01xxxxxxxxx
+          if ((c>>6) == 1) 
+          {       // 01
+                        size-=2;
+                        _file->read8i();                       // skip one byte
+                        c=_file->read8i();   // then another
+           }                       
+           // PTS/DTS
+           switch(c>>4)
+           {
+                case 2:
+                {
+                        // 0010 xxxx PTS only
+                        uint64_t pts1,pts2,pts0;
+                                        size -= 4;
+                                        pts0=(c>>1) &7;
+                                        pts1=_file->read16i()>>1;
+                                        pts2=_file->read16i()>>1;
+                                        *opts=pts2+(pts1<<15)+(pts0<<30);
+                                        break;
+                  }
+                  case 3:
+                  {               // 0011 xxxx
+                        uint64_t pts1,pts2,pts0;
+                                        size -= 9;
+                                                                        
+                                        pts0=(c>>1) &7;
+                                        pts1=_file->read16i()>>1;
+                                        pts2=_file->read16i()>>1;
+                                        *opts=pts2+(pts1<<15)+(pts0<<30);
+                                        _file->forward(5);
+                   }                                                               
+                   break;
+                   
+                case 1:
+                        // 0001 xxx             
+                        // PTSDTS=01 not allowed                        
+                                return 0;
+                                break; 
+                }
+                                                                
+
+                if(!align)      
+                        size--;         
+        *olen=size;
+        return 1;
+}
+//************************************************************************************
+
+#define ADM_PACKET_LINEAR 10*1024
+/**
+    \fn psPacket
+*/
+psPacketLinear::psPacketLinear(uint8_t pid) : psPacket()
+{
+    oldStartAt=startAt=0xfffffff;
+    oldBufferLen=bufferLen=0;
+    bufferIndex=0;
+    myPid=pid;
+    eof=false;
+}
+/**
+    \fn ~psPacket
+*/
+psPacketLinear::~psPacketLinear() 
+{
+}
+/**
+    \fn refill
+*/
+bool psPacketLinear::refill(void) 
+{
+// In case a startcode spawns across 2 packets
+// we have to keep track of the old one
+        oldBufferDts=bufferDts;
+        oldBufferPts=bufferPts;
+        oldStartAt=startAt;
+        oldBufferLen=bufferLen;
+        if( false== getPacketOfType(myPid,ADM_PACKET_LINEAR, &bufferLen,&bufferPts,&bufferDts,buffer,&startAt)) 
+        {
+            printf("[PsPacketLinear] Refill failed for pid :%x\n",myPid);
+            bufferIndex=bufferLen=0;
+            return false;
+        }
+        //printf("Refill : At :%"LLX" size :%"LD"\n",startAt,bufferLen);
+        bufferIndex=0;
+        return true;
+}
+/**
+    \fn readi8
+*/
+uint8_t psPacketLinear::readi8(void)
+{
+    consumed++;
+    if(bufferIndex<bufferLen)
+    {
+        return buffer[bufferIndex++];
+    }
+    if(false==refill()) 
+    {
+        eof=1;
+        return 0;
+    }
+    ADM_assert(bufferLen);
+    bufferIndex=1;
+    return buffer[0];
+    
+}
+/**
+    \fn readi16
+*/
+uint16_t psPacketLinear::readi16(void)
+{
+    if(bufferIndex+1<bufferLen)
+    {
+        uint16_t v=(buffer[bufferIndex]<<8)+buffer[bufferIndex+1];;
+        bufferIndex+=2;
+        consumed+=2;
+        return v;
+    }
+    return (readi8()<<8)+readi8();
+}
+/**
+    \fn readi32
+*/
+uint32_t psPacketLinear::readi32(void)
+{
+    if(bufferIndex+3<bufferLen)
+    {
+        uint8_t *p=buffer+bufferIndex;
+        uint32_t v=(p[0]<<24)+(p[1]<<16)+(p[2]<<8)+p[3];
+        bufferIndex+=4;
+        consumed+=4;
+        return v;
+    }
+    return (readi16()<<16)+readi16();
+}
+/**
+    \fn forward
+*/
+bool psPacketLinear::forward(uint32_t v)
+{
+next:
+ uint32_t delta=bufferLen-bufferIndex;
+    if(v>100*1000)
+    {
+        ADM_assert(0);
+    }
+    if(v<=delta)
+    {
+        bufferIndex+=v;
+        consumed+=v;
+        return true;
+    }
+    // v>delta
+    v-=delta;
+    if(!refill()) return false;
+    goto next;
+}
+
+/**
+    \fn bool    read(uint32_t len, uint8_t *buffer);
+    \brief
+*/
+bool    psPacketLinear::read(uint32_t len, uint8_t *out)
+{
+    // Enough already ?
+    while(len)
+    {
+        uint32_t avail=bufferLen-bufferIndex;
+        uint32_t chunk=avail;
+        if(chunk>len) chunk=len;
+#if 0
+        printf("len:%ld avail:%ld chunk %ld index:%d size:%d\n",
+                len,avail,chunk,bufferIndex,bufferLen);
+#endif
+        memcpy(out,buffer+bufferIndex,chunk);
+        bufferIndex+=chunk;
+        len-=chunk;
+        out+=chunk;
+        consumed+=chunk;
+        if(bufferIndex==bufferLen)
+        {
+            //printf("Refill\n");
+            if(false==refill()) return false;
+        }
+    }
+    return true;
+}
+/**
+        \fn getInfo
+        \brief Returns info about the current (or previous if it spawns) packet.
+            It is expected that the caller will do -4 to the index to get the start of the 
+            startCode
+*/
+bool    psPacketLinear::getInfo(dmxPacketInfo *info)
+{
+    if(bufferIndex<4)
+    {
+        info->startAt=this->oldStartAt;
+        info->offset=oldBufferLen+bufferIndex;
+        info->pts=oldBufferPts;
+        info->dts=oldBufferDts;
+
+    }else
+    {
+        info->startAt=this->startAt;
+        info->offset=bufferIndex;
+        info->pts=bufferPts;
+        info->dts=bufferDts;
+    }
+    return true;
+
+};
+/**
+    \fn seek
+    \brief Async jump
+*/
+bool    psPacketLinear::seek(uint64_t packetStart, uint32_t offset)
+{
+    if(!_file->setpos(packetStart))
+    {
+        printf("[psPacket] Cannot seek to %"LLX"\n",packetStart);
+        return 0;
+    }
+    if(!refill())
+    {
+        printf("[PsPacketLinear] Seek to %"LLX":%"LX" failed\n",packetStart,offset);
+        return false;
+    }
+    ADM_assert(offset<bufferLen);
+    bufferIndex=offset;
+    
+    return true;
+}
+/**
+    \fn getConsumed
+    \brief returns the # of bytes consumed since the last call
+*/
+uint32_t psPacketLinear::getConsumed(void)
+{
+    uint32_t c=consumed;
+    consumed=0;
+    return c;
+}
+/**
+    \fn changePid
+    \brief change the pid of the stream we read (used when probing all tracks)
+*/
+bool    psPacketLinear::changePid(uint32_t pid) 
+{
+    myPid=(pid&0xff);
+    bufferLen=bufferIndex=0;
+    return true;
+}
+/* ********************************************************* */
+/**
+    \fn psPacketLinearTracker
+*/
+ psPacketLinearTracker::psPacketLinearTracker(uint8_t pid)  : psPacketLinear(pid)
+{
+   resetStats();
+}
+/**
+    \fn ~psPacketLinearTracker
+*/
+psPacketLinearTracker::~psPacketLinearTracker()
+{
+
+    
+}
+/**
+        \fn getStat
+*/
+packetStats    *psPacketLinearTracker::getStat(int index)
+{   
+    if(index<0 || index>=256) ADM_assert(0);
+    return stats+index;
+}
+/**
+    \fn getPacketgetPacketOfType
+    \brief Keep track of all the packets we have seen so far.
+    Usefull to detect the streams present and to look up the PTS/DTS of audio streams for the audio part of the index
+*/
+bool           psPacketLinearTracker::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
+{
+ bool xit=false;
+    uint8_t tmppid;
+    while(1)
+    {
+        if(true!=getPacket(maxSize,&tmppid,packetSize,pts,dts,buffer,startAt))
+                return false;
+        else
+        {
+                // Update 
+                ADM_assert(tmppid<0x100);
+                packetStats *p=stats+tmppid;
+                uint64_t ts=*pts;
+                if(ts==ADM_NO_PTS) ts=*dts;
+                if(ts!=ADM_NO_PTS)
+                {
+                    p->startCount=p->count;
+                    p->startAt=*startAt;
+                    p->startSize=p->size;
+                    p->startDts=ts;
+                }
+                p->count++;
+                p->size+=*packetSize;
+                if(tmppid==pid) return true;
+        }
+    }
+    return false;
+}
+/**
+    \fn resetStats
+*/
+bool           psPacketLinearTracker::resetStats(void)
+{
+    memset(stats,0,sizeof(stats));
+    for(int i=0;i<256;i++)
+    {
+        packetStats *p=stats+i;
+        p->startDts=ADM_NO_PTS;
+    }
+}
+//EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/CMakeLists.txt	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/CMakeLists.txt	2009-04-07 05:39:51 UTC (rev 4723)
@@ -4,4 +4,5 @@
 ADD_SUBDIRECTORY(Matroska)
 ADD_SUBDIRECTORY(OpenDml)
 ADD_SUBDIRECTORY(MpegPS)
+ADD_SUBDIRECTORY(MpegTS)
 #

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,353 @@
+/***************************************************************************
+    copyright            : (C) 2007/2009 by mean
+    email                : fixounet at free.fr
+    
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_indexFile.h"
+#include "ADM_ps.h"
+
+#include <math.h>
+
+uint32_t ADM_UsecFromFps1000(uint32_t fps1000);
+
+/**
+      \fn open
+      \brief open the flv file, gather infos and build index(es).
+*/
+
+uint8_t psHeader::open(const char *name)
+{
+    char idxName[strlen(name)+4];
+    bool r=false;
+    FP_TYPE appendType=FP_DONT_APPEND;
+    uint32_t append;
+    char *type;
+    uint64_t startDts;
+
+    sprintf(idxName,"%s.idx",name);
+    indexFile index;
+    if(!index.open(idxName))
+    {
+        printf("[psDemux] Cannot open index file %s\n",idxName);
+        return false;
+    }
+    if(!index.readSection("System"))
+    {
+        printf("[psDemux] Cannot read system section\n");
+        goto abt;
+    }
+    type=index.getAsString("Type");
+    if(!type || type[0]!='P')
+    {
+        printf("[psDemux] Incorrect or not found type\n");
+        goto abt;
+    }
+    append=index.getAsUint32("Append");
+    printf("[psDemux] Append=%"LU"\n",append);
+    if(append) appendType=FP_APPEND;
+    if(!parser.open(name,&appendType))
+    {
+        printf("[psDemux] Cannot open root file\n",name);
+        goto abt;
+    }
+    if(!readVideo(&index)) 
+    {
+        printf("[psDemux] Cannot read Video section of %s\n",idxName);
+        goto abt;
+    }
+    if(!readAudio(&index,name)) 
+    {
+        printf("[psDemux] Cannot read Audio section of %s => No audio\n",idxName);
+    }
+    if(!readIndex(&index))
+    {
+        printf("[psDemux] Cannot read index for file %s\n",idxName);
+        goto abt;
+    }
+    updatePtsDts();
+    _videostream.dwLength= _mainaviheader.dwTotalFrames=ListOfFrames.size();
+    printf("[psDemux] Found %d video frames\n",_videostream.dwLength);
+    if(_videostream.dwLength)_isvideopresent=1;
+//***********
+    
+    psPacket=new psPacketLinear(0xE0);
+    if(psPacket->open(name,appendType)==false) 
+    {
+        printf("psDemux] Cannot psPacket open the file\n");
+        goto abt;
+    }
+    r=true;
+    for(int i=0;i<listOfAudioTracks.size();i++)
+    {
+        ADM_psTrackDescriptor *desc=listOfAudioTracks[i];
+        ADM_audioStream *audioStream=ADM_audioCreateStream(&desc->header,desc->access);
+        if(!audioStream)
+        {
+            
+        }else       
+        {
+                desc->stream=audioStream;
+        }
+    }
+abt:
+    index.close();
+    printf("[psDemuxer] Loaded %d\n",r);
+    return r;
+}
+/**
+        \fn getVideoDuration
+        \brief Returns duration of video in us
+*/
+uint64_t psHeader::getVideoDuration(void)
+{
+    float f;
+        f=1000*1000*1000;
+        f/=_videostream.dwRate; // in uss
+        
+        f*=ListOfFrames.size();
+     return (uint64_t)f;
+}
+
+
+/**
+    \fn getAudioInfo
+    \brief returns wav header for stream i (=0)
+*/
+WAVHeader *psHeader::getAudioInfo(uint32_t i )
+{
+        if(!listOfAudioTracks.size()) return NULL;
+      ADM_assert(i<listOfAudioTracks.size());
+      return listOfAudioTracks[i]->stream->getInfo();
+      
+}
+/**
+   \fn getAudioStream
+*/
+
+uint8_t   psHeader::getAudioStream(uint32_t i,ADM_audioStream  **audio)
+{
+    if(!listOfAudioTracks.size())
+    {
+            *audio=NULL;
+            return true;
+    }
+  ADM_assert(i<listOfAudioTracks.size());
+  *audio=listOfAudioTracks[i]->stream;
+  return true; 
+}
+/**
+    \fn getNbAudioStreams
+
+*/
+uint8_t   psHeader::getNbAudioStreams(void)
+{
+ 
+  return listOfAudioTracks.size(); 
+}
+/*
+    __________________________________________________________
+*/
+
+void psHeader::Dump(void)
+{
+ 
+}
+/**
+    \fn close
+    \brief cleanup
+*/
+
+uint8_t psHeader::close(void)
+{
+    // Destroy index
+    while(ListOfFrames.size())
+    {
+        delete ListOfFrames[0];
+        ListOfFrames.erase(ListOfFrames.begin());
+    }
+    if(psPacket)
+    {
+        psPacket->close();
+        delete psPacket;
+        psPacket=NULL;
+    }
+}
+/**
+    \fn psHeader
+    \brief constructor
+*/
+
+ psHeader::psHeader( void ) : vidHeader()
+{ 
+    interlaced=false;
+    lastFrame=0xffffffff;
+    
+}
+/**
+    \fn psHeader
+    \brief destructor
+*/
+
+ psHeader::~psHeader(  )
+{
+  close();
+}
+
+
+/**
+    \fn setFlag
+    \brief Returns timestamp in us of frame "frame" (PTS)
+*/
+
+  uint8_t  psHeader::setFlag(uint32_t frame,uint32_t flags)
+{
+   
+     uint32_t f=2;
+     if(flags & AVI_KEY_FRAME) f=1;
+     if(flags & AVI_B_FRAME) f=3;
+     if(frame>=ListOfFrames.size()) return 0;
+      ListOfFrames[frame]->type=f;
+    return 1;
+}
+/**
+    \fn getFlags
+    \brief Returns timestamp in us of frame "frame" (PTS)
+*/
+
+uint32_t psHeader::getFlags(uint32_t frame,uint32_t *flags)
+{
+    if(frame>=ListOfFrames.size()) return 0;
+    uint32_t f=ListOfFrames[frame]->type;
+    switch(f)
+    {
+        case 1: *flags=AVI_KEY_FRAME;break;
+        case 2: *flags=0;break;
+        case 3: *flags=AVI_B_FRAME;break;
+    }
+    return  1;
+}
+
+/**
+    \fn getTime
+    \brief Returns timestamp in us of frame "frame" (PTS)
+*/
+uint64_t psHeader::getTime(uint32_t frame)
+{
+   if(frame>=ListOfFrames.size()) return 0;
+    uint64_t pts=ListOfFrames[frame]->pts;
+    return pts;
+}
+/**
+    \fn timeConvert
+    \brief FIXME
+*/
+uint64_t psHeader::timeConvert(uint64_t x)
+{
+    if(x==ADM_NO_PTS) return ADM_NO_PTS;
+    x=x-ListOfFrames[0]->dts;
+    x=x*1000;
+    x/=90;
+    return x;
+
+}
+/**
+        \fn getFrame
+*/
+
+uint8_t  psHeader::getFrame(uint32_t frame,ADMCompressedImage *img)
+{
+    if(frame>=ListOfFrames.size()) return 0;
+    dmxFrame *pk=ListOfFrames[frame];
+    if(frame==(lastFrame+1) && pk->type!=1)
+    {
+        lastFrame++;
+        bool r=psPacket->read(pk->len,img->data);
+             img->dataLength=pk->len;
+             img->demuxerFrameNo=frame;
+             img->demuxerDts=pk->dts;
+             img->demuxerPts=pk->pts;
+             //printf("[>>>] %d:%02x %02x %02x %02x\n",frame,img->data[0],img->data[1],img->data[2],img->data[3]);
+             getFlags(frame,&(img->flags));
+             return r;
+    }
+    if(pk->type==1)
+    {
+        if(!psPacket->seek(pk->startAt,pk->index)) return false;
+         bool r=psPacket->read(pk->len,img->data);
+             img->dataLength=pk->len;
+             img->demuxerFrameNo=frame;
+             img->demuxerDts=pk->dts;
+             img->demuxerPts=pk->pts;
+             getFlags(frame,&(img->flags));
+             //printf("[>>>] %d:%02x %02x %02x %02x\n",frame,img->data[0],img->data[1],img->data[2],img->data[3]);
+             lastFrame=frame;
+             return r;
+
+    }
+    printf(" [PsDemux] lastFrame :%d this frame :%d\n",lastFrame,frame);
+    return false;
+}
+/**
+        \fn getExtraHeaderData
+*/
+uint8_t  psHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
+{
+                *len=0; //_tracks[0].extraDataLen;
+                *data=NULL; //_tracks[0].extraData;
+                return true;            
+}
+
+/**
+      \fn getFrameSize
+      \brief return the size of frame frame
+*/
+uint8_t psHeader::getFrameSize (uint32_t frame, uint32_t * size)
+{
+    if(frame>=ListOfFrames.size()) return 0;
+    *size=ListOfFrames[frame]->len;
+    return true;
+}
+
+/**
+    \fn getPtsDts
+*/
+bool    psHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+    if(frame>=ListOfFrames.size()) return false;
+    dmxFrame *pk=ListOfFrames[frame];
+
+    *dts=pk->dts;
+    *pts=pk->pts;
+    return true;
+}
+/**
+        \fn setPtsDts
+*/
+bool    psHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+      if(frame>=ListOfFrames.size()) return false;
+    dmxFrame *pk=ListOfFrames[frame];
+
+    pk->dts=dts;
+    pk->pts=pts;
+    return true;
+
+
+}
+
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,180 @@
+/***************************************************************************
+                         ADM_PS
+                             -------------------
+    begin                : Mon Jun 3 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+
+
+#ifndef ADM_PS_H
+#define ADM_PS_H
+
+#include "ADM_Video.h"
+#include "ADM_audioStream.h"
+#include "dmx_io.h"
+#include "ADM_indexFile.h"
+#include "dmxPSPacket.h"
+#include <vector>
+using std::vector;
+/**
+    \struct dmxFrame
+*/
+typedef struct 
+{
+    uint64_t  startAt;
+    uint32_t  index;
+    uint8_t   type; // 1=I 2=P 3=B
+    uint64_t  pts;
+    uint64_t  dts;
+    uint32_t  len;
+}dmxFrame;
+/**
+    \struct ADM_psAudioSeekPoint
+    \brief The dts are stored in rescaled us. Warning the low level getpacket is getting absolute 90 khzTick
+*/
+typedef struct
+{            
+      uint64_t position;
+      uint64_t dts;
+      uint32_t size;
+
+}ADM_psAudioSeekPoint;
+
+/**
+    \fn ADM_psAccess
+*/
+class ADM_psAccess : public ADM_audioAccess
+{
+protected:
+                
+                psPacket        demuxer;
+                uint8_t         pid;
+                uint64_t        dtsOffset;
+                
+public:
+                bool            setTimeOffset(uint64_t of) {dtsOffset=of;return true;}
+                vector          <ADM_psAudioSeekPoint >seekPoints;
+                                  ADM_psAccess(const char *name,uint8_t pid,bool append); 
+                virtual           ~ADM_psAccess();
+                                    /// Hint, the stream is pure CBR (AC3,MP2,MP3)
+                virtual bool      isCBR(void) { return true;}
+                                    /// Return true if the demuxer can seek in time
+                virtual bool      canSeekTime(void) {return true;};
+                                    /// Return true if the demuxer can seek by offser
+                virtual bool      canSeekOffset(void) {return false;};
+                                    /// Return true if we can have the audio duration
+                virtual bool      canGetDuration(void) {return true;};
+                                    /// Returns audio duration in us
+                virtual uint64_t  getDurationInUs(void) ;
+                                    /// Go to a given time
+                virtual bool      goToTime(uint64_t timeUs) ;
+                                    /// Get a packet
+                virtual bool      getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts);
+
+                        bool      push(uint64_t at, uint64_t dts,uint32_t size);
+                                    /// Convert raw timestamp to scaled timestamp in us
+                uint64_t          timeConvert(uint64_t x);
+
+                virtual uint32_t  getLength(void);
+
+};
+/**
+    \class ADM_psTrackDescriptor
+*/
+class ADM_psTrackDescriptor
+{
+public:
+        ADM_audioStream *stream;
+        ADM_psAccess    *access;
+        WAVHeader       header;
+        ADM_psTrackDescriptor()
+            {
+                stream=NULL;
+                access=NULL;
+            }
+        ~ADM_psTrackDescriptor()
+            {
+                if(stream) delete stream;
+                stream=NULL;
+                if(access) delete access;
+                access=NULL;
+            }
+
+
+};
+
+/**
+    \Class psHeader
+    \brief mpeg ps demuxer
+
+*/
+class psHeader         :public vidHeader
+{
+  protected:
+    
+    bool    interlaced;
+    bool    readVideo(indexFile *index);
+    bool    readAudio(indexFile *index,const char *name);
+    bool    readIndex(indexFile *index);
+
+    bool    processVideoIndex(char *buffer);
+    bool    processAudioIndex(char *buffer);
+
+    std::vector <dmxFrame *> ListOfFrames;      
+    fileParser      parser;
+    uint32_t       lastFrame;
+    psPacketLinear *psPacket;
+    uint64_t        timeConvert(uint64_t x);
+    bool            updatePtsDts(void);
+protected:
+    vector <ADM_psTrackDescriptor *>listOfAudioTracks;
+  public:
+
+
+    virtual   void          Dump(void);
+
+            psHeader( void ) ;
+   virtual  ~psHeader(  ) ;
+// AVI io
+    virtual uint8_t  open(const char *name);
+    virtual uint8_t  close(void) ;
+  //__________________________
+  //  Info
+  //__________________________
+
+  //__________________________
+  //  Audio
+  //__________________________
+virtual 	WAVHeader              *getAudioInfo(uint32_t i )  ;
+virtual 	uint8_t                 getAudioStream(uint32_t i,ADM_audioStream  **audio);
+virtual     uint8_t                 getNbAudioStreams(void);
+// Frames
+  //__________________________
+  //  video
+  //__________________________
+
+    virtual uint8_t  setFlag(uint32_t frame,uint32_t flags);
+    virtual uint32_t getFlags(uint32_t frame,uint32_t *flags);
+    virtual uint8_t  getFrame(uint32_t framenum,ADMCompressedImage *img);
+    virtual uint64_t getTime(uint32_t frame);
+            uint8_t  getExtraHeaderData(uint32_t *len, uint8_t **data);
+    virtual uint64_t getVideoDuration(void);
+    virtual uint8_t  getFrameSize(uint32_t frame,uint32_t *size) ;
+virtual   bool       getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+virtual   bool       setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
+
+};
+#endif
+
+

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,138 @@
+/***************************************************************************
+    \file ADM_psAudio.cpp
+
+    copyright            : (C) 2006/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_Video.h"
+
+#include <string.h>
+#include <math.h>
+
+#include "ADM_ps.h"
+
+#if 0
+    #define aprintf printf
+#else
+    #define aprintf(...) {}
+#endif
+
+/**
+    \fn ADM_psAccess
+*/
+ADM_psAccess::ADM_psAccess(const char *name,uint8_t pid,bool append)
+{
+FP_TYPE fp=FP_DONT_APPEND;
+        if(append) fp=FP_APPEND;
+        this->pid=pid;
+        if(!demuxer.open(name,fp)) ADM_assert(0);
+}
+
+/**
+    \fn ~ADM_psAccess
+*/
+ADM_psAccess::~ADM_psAccess()
+{
+    demuxer.close();
+}
+/**
+    \fn push
+    \brief add a seek point.
+*/
+bool      ADM_psAccess::push(uint64_t at, uint64_t dts,uint32_t size)
+{
+ADM_psAudioSeekPoint s;
+            s.position=at;
+            s.dts=dts;
+            s.size=size;
+            seekPoints.push_back(s);
+            return true;
+}
+/**
+    \fn getLength
+*/
+uint32_t  ADM_psAccess::getLength(void)
+{
+  return (seekPoints[seekPoints.size()-1].size);
+
+}
+/**
+    \fn getDurationInUs
+*/
+uint64_t  ADM_psAccess::getDurationInUs(void)
+{
+    // Take last seek point; should be accurate enough
+    return timeConvert(seekPoints[seekPoints.size()-1].dts);
+}
+/**
+    \fn goToTime
+    \brief Rememember seekPoint.dts time is already scaled and in us
+*/                              
+bool      ADM_psAccess::goToTime(uint64_t timeUs)
+{
+    // Convert time in us to scaled 90 kHz tick
+    
+    if(timeUs<seekPoints[0].dts)
+    {
+            aprintf("[PsAudio] Requested %"LU" tick before 1st seek point at :%"LU"\n",(uint32_t)timeUs/1000,(uint32_t)seekPoints[0].dts/1000);
+            demuxer.setPos(seekPoints[0].position);
+            return true;
+    }
+
+    for(int i=1;i<seekPoints.size();i++)
+    {
+        if(seekPoints[i].dts >=timeUs )
+        {
+            aprintf("[PsAudio] Requested %"LU" tick seeking to  at :%"LU" us (next is %"LU"ms \n",(uint32_t)timeUs/1000,
+                    (uint32_t)seekPoints[i-1].dts/1000,
+                    (uint32_t)seekPoints[i].dts/1000);
+            demuxer.setPos(seekPoints[i-1].position);
+            return true;
+        }
+    }
+    return false;
+}
+/**
+    \fn timeConvert
+    \brief Convert time in ticks raw from the stream to avidemux time in us starting from the beginning of the file
+*/
+uint64_t ADM_psAccess::timeConvert(uint64_t x)
+{
+    if(x==ADM_NO_PTS) return ADM_NO_PTS;
+    x=x-dtsOffset;
+    x=x*1000;
+    x/=90;
+    return x;
+
+}
+/**
+    \fn getPacket
+*/
+bool      ADM_psAccess::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
+{
+uint64_t p,d,start;
+    if(false==demuxer.getPacketOfType(pid,maxSize,size,&p,&d,buffer,&start)) return false;
+    if(d==ADM_NO_PTS) *dts=p;
+            else *dts=d;
+    *dts=timeConvert(*dts);
+    if(*dts!=ADM_NO_PTS) 
+    {
+        aprintf("[psAudio] getPacket dts = %"LU" ms\n",(uint32_t)*dts/1000);
+    }
+
+    return true;
+}
+
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,234 @@
+/**
+    \file ADM_psAudioProbe.cpp
+    \brief Handle index file reading
+    copyright            : (C) 2009 by mean
+    email                : fixounet at free.fr
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_audiodef.h"
+#include "dmxPSPacket.h"
+#include "ADM_psAudioProbe.h"
+//
+#include "ADM_a52info.h"
+#include "ADM_mp3info.h"
+#include "ADM_dcainfo.h"
+// Number of video packet seen to be enough to sample the audio tracks
+#define PROBE_PACKET_VIDEO_COUNT 500
+// Max size of a packet. Usually it is a bit more than 2300, so 10000 should be safe
+#define PACKET_PROBE_SIZE 10000
+// Minimum of packet seen to declare it valid
+#define PROBE_MIN_PACKET 5
+#define PROBE_MIN_SIZE   5000
+
+#define MP2_AUDIO_VALUE 0xC0
+#define LPCM_AUDIO_VALUE 0xA0
+#define DTS_AC3_AUDIO_VALUE 0x00
+
+static bool addAudioTrack(int pid, listOfPsAudioTracks *list, psPacketLinearTracker *p);
+static bool psCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize);
+/**
+    \fn listOfPsAudioTracks
+    \brief returns a list of audio track found, null if none found
+
+*/
+listOfPsAudioTracks *psProbeAudio(const char *fileName)
+{
+    uint32_t size;
+    uint64_t dts,pts,startAt;
+    uint8_t buffer[PACKET_PROBE_SIZE];
+    uint64_t fileSize;
+
+    listOfPsAudioTracks *tracks=new listOfPsAudioTracks;
+    psPacketLinearTracker *packet=new psPacketLinearTracker(0xE0);
+
+    printf("[MpegPS] Probing audio for %s\n",fileName);
+
+    if(!packet->open(fileName,FP_APPEND)) goto end;
+    fileSize=packet->getSize();
+
+    packet->setPos(fileSize/2); // Jump in the middle of the stream
+
+    while(packet->getPacketOfType(0xE0,PACKET_PROBE_SIZE,&size,&dts,&pts,buffer,&startAt))
+    {
+        packetStats *stat=packet->getStat(0xE0);
+        if(stat->count > PROBE_PACKET_VIDEO_COUNT)
+                break;
+    }
+    // Now synthetize
+    for(int i=0x0;i<0xFF;i++)   
+    {
+        packetStats *stat=packet->getStat(i);
+        if(stat->count)
+        {
+            printf("[PsProbeAudo] Pid:%x count:%"LX" size:%"LD"\n",i,stat->count,stat->size);
+        }
+
+         if(stat->count>=PROBE_MIN_PACKET && stat->size>PROBE_MIN_SIZE)
+         {
+                packet->setPos(fileSize/2); 
+                addAudioTrack(i,tracks,packet);
+         }
+
+    }
+
+end:
+    printf("[PsDemux] Audio probe done, found %lu tracks\n",tracks->size());
+    delete packet;
+    
+    if(tracks->size()==0) 
+    {   
+        delete tracks;
+        return NULL;
+    }
+    return tracks;
+}
+/**
+    \fn addAudioTrack
+    \brief gather information about audio & add audio track to the list
+
+*/
+bool addAudioTrack(int pid, listOfPsAudioTracks *list, psPacketLinearTracker *p)
+{
+#define PROBE_ANALYZE_SIZE 6000 // Should be enough in all cases (need ~ 2 blocks)
+uint8_t audioBuffer[PROBE_ANALYZE_SIZE];
+        uint64_t pts,dts,startAt;
+        uint32_t packetSize;
+
+        //
+        int masked=pid&0xF0;
+        if(masked!=MP2_AUDIO_VALUE &&  // MP2
+            masked!=LPCM_AUDIO_VALUE && // PCM
+            masked!=DTS_AC3_AUDIO_VALUE  // AC3 & DTS
+            ) return false;
+
+        // Go back where we were
+        p->changePid(pid); 
+        p->getPacketOfType(pid,PROBE_ANALYZE_SIZE, &packetSize,&pts,&dts,audioBuffer,&startAt);
+        //Realign
+        p->seek(startAt,0);
+        int rd=PROBE_ANALYZE_SIZE;
+        if(!p->read(PROBE_ANALYZE_SIZE,audioBuffer))
+            return false;
+        psAudioTrackInfo *info=new psAudioTrackInfo;
+        info->esID=pid;
+        uint32_t fq,br,chan,off;
+        switch(pid & 0xF0)
+        {
+            case LPCM_AUDIO_VALUE: // LPCM
+                            info->header.frequency=48000;
+                            info->header.channels=2;
+                            info->header.byterate=48000*4;
+                            info->header.encoding=WAV_LPCM;
+                            break;
+            case MP2_AUDIO_VALUE: // MP2
+                            {
+                                if(! psCheckMp2Audio(&(info->header),audioBuffer,rd))
+                                {
+                                    printf("[PsProbeAudio] Failed to get info on track :%x (MP2)\n",pid);
+                                    goto er;
+                                }
+                            }
+                            break;
+            case DTS_AC3_AUDIO_VALUE: // AC3 or DTS
+                            if(pid>=0x8) // DTS
+                            {
+                                info->header.encoding=WAV_DTS;
+                                uint32_t flags,nbSample;
+                                if(!ADM_DCAGetInfo(audioBuffer, rd, &fq, &br, &chan,&off,&flags,&nbSample))
+                                {
+                                        printf("[PsProbeAudio] Failed to get info on track :%x\n",pid);
+                                        goto er;
+                                }
+                                info->header.frequency=fq;
+                                info->header.channels=chan;
+                                info->header.byterate=(br);
+                                break;
+                            }else // AC3
+                            {
+                                info->header.encoding=WAV_AC3;
+                                if(!ADM_AC3GetInfo(audioBuffer, rd, &fq, &br, &chan,&off))
+                                {
+                                        printf("[PsProbeAudio] Failed to get info on track :%x\n",pid);
+                                        goto er;
+                                }
+                                info->header.frequency=fq;
+                                info->header.channels=chan;
+                                info->header.byterate=(br);
+                                break;
+                            }
+                            
+            default:
+                        ADM_assert(0);
+
+        }
+        list->push_back(info);
+        return true;
+er:
+        delete info;
+        return false;
+}
+/**
+        \fn DestroyListOfPsAudioTracks
+        \brief cleanly destroy it
+*/
+bool DestroyListOfPsAudioTracks(listOfPsAudioTracks *list)
+{
+    while( list->size())
+    {
+        delete (*list)[0];
+        list->erase(list->begin());
+    }
+    delete list;
+    return true;
+}
+/**
+    \fn psCheckMp2Audio
+    \brief Wait to have 2 audio packets to make sure it is not a false detection (that happens with mp2/mp3 audio)
+*/
+bool psCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize)
+{
+    MpegAudioInfo mpeg,first;
+    uint32_t off2,off;
+
+    hdr->encoding=WAV_MP2;
+again:
+    if(!getMpegFrameInfo(data, dataSize, &first,NULL,&off))
+    {
+            return false;
+    }
+    if(dataSize<(off+first.size))
+    {
+        return false;
+    }
+    if(!getMpegFrameInfo(data+off+first.size, dataSize-off-first.size, &mpeg,NULL,&off2))
+    {
+            return false;
+    }
+    if(off2) // false detectio ?
+    {
+        printf("[psAudioProbe] Mp2 : False MP2 header at %"LU"\n",off);
+        if(dataSize<4) return false;
+        data+=3;
+        dataSize-=3;
+        goto again;
+    }
+    hdr->frequency=mpeg.samplerate;
+    if(mpeg.mode==3)
+        hdr->channels=1;
+    else
+        hdr->channels=2;
+    hdr->byterate=(mpeg.bitrate*1000)>>3;
+    return true;
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,34 @@
+/**
+    \file ADM_psAudioProbe.h
+    \brief Probe audio tracks by brute force analysus of the file
+    copyright            : (C) 2009 by mean
+    email                : fixounet at free.fr
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_PS_AUDIO_PROBE_H
+#define ADM_PS_AUDIO_PROBE_H
+#include <vector>
+using std::vector;
+typedef struct
+{
+    WAVHeader header;
+    uint8_t   esID;
+}psAudioTrackInfo;
+
+typedef vector <psAudioTrackInfo*> listOfPsAudioTracks;
+
+/// Returns a list of audio tracks found in the file.
+listOfPsAudioTracks *psProbeAudio(const char *fileName);
+bool DestroyListOfPsAudioTracks(listOfPsAudioTracks *list);
+
+
+#endif
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,181 @@
+/**
+    \fn ComputeTimeStamp
+    \brief Compute and fill the missing PTS/DTS
+
+*/
+
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_indexFile.h"
+#include "ADM_ps.h"
+
+#include <math.h>
+
+#define DMX_RECOMPUTE_PTS_DTS_MAX 20
+
+#if 1
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+/**
+        \fn updatePtsDts
+        \brief Update the PTS/DTS
+
+TODO / FIXME : Handle wrap
+TODO / FIXME : Handle PTS reordering 
+*/
+
+bool psHeader::updatePtsDts(void)
+{
+        uint64_t lastDts=0,lastPts=0,dtsIncrement=0;
+
+
+        // For audio, The first packet in the seekpoints happens a bit after the action
+        // It means some audio may have been seen since we locked on video.
+        // So we compute the DTS of the first real packet
+        // by using the size field and byterate and arbitrarily make it begins
+        // at video
+        for(int i=0;i<listOfAudioTracks.size();i++)
+        {
+            vector          <ADM_psAudioSeekPoint > *seekPoints=&(listOfAudioTracks[i]->access->seekPoints);
+            uint64_t secondDts=(*seekPoints)[0].dts;
+            uint64_t secondSize=(*seekPoints)[0].size;
+            if(secondSize && listOfAudioTracks[i]->header.byterate)
+            {
+                    // it is actually an offset in time to the 2nd packet Dts
+                double  firstFloatDts=secondSize*1000*1000.; 
+                        firstFloatDts/=listOfAudioTracks[i]->header.byterate; // in us
+                uint64_t firstDts=(uint64_t)firstFloatDts;
+
+                        if(firstDts>secondDts) firstDts=0;
+                            else firstDts=secondDts-firstDts;
+
+                // Now add our seek point
+                ADM_psAudioSeekPoint sk;
+                sk.dts=firstDts;
+                sk.size=0;
+                sk.position=ListOfFrames[0]->startAt;
+                (*seekPoints).insert( (*seekPoints).begin(),sk);
+
+            }
+        }
+
+
+        // Make sure everyone starts at 0
+        // Search first timestamp (audio/video)
+
+        switch( _videostream.dwRate)
+        {
+            case 25000:   dtsIncrement=40000;break;
+            case 23976:   dtsIncrement=41708;break;
+            case 29970:   dtsIncrement=33367;break;
+            default : dtsIncrement=1;
+                    printf("[psDemux] Fps not handled for DTS increment\n");
+
+        }
+        uint64_t startDts=ListOfFrames[0]->dts;
+        uint64_t startPts=ListOfFrames[0]->pts;
+        // Special case when we dont have DTS but only PTS
+        if(startDts==ADM_NO_PTS) // Do we have DTS ?
+        {
+            if(startPts!=ADM_NO_PTS)
+            {
+                if(startPts>=2*dtsIncrement)
+                {
+                    startDts=startPts-2*dtsIncrement;
+                } else startDts=0;
+                ListOfFrames[0]->dts=startDts;
+            }
+        }
+        for(int i=0;i<listOfAudioTracks.size();i++)
+        {
+            uint64_t a=listOfAudioTracks[i]->access->seekPoints[0].dts;
+            if(a<startDts) startDts=a;
+        }
+        // Rescale all so that it starts ~ 0
+        // Video..
+        for(int i=0;i<ListOfFrames.size();i++)
+        {
+            dmxFrame *f=ListOfFrames[i];
+            if(f->pts!=ADM_NO_PTS) f->pts-=startDts;
+            if(f->dts!=ADM_NO_PTS) f->dts-=startDts;
+        }
+        // Audio start at 0 too
+        for(int i=0;i<listOfAudioTracks.size();i++)
+        {
+            ADM_psTrackDescriptor *track=listOfAudioTracks[i];
+            ADM_psAccess    *access=track->access;
+            access->setTimeOffset(startDts);
+        }
+
+        // Now fill in the missing timestamp and convert to us
+        // for video
+        // We are sure to have both PTS & DTS for 1st image
+        // Guess missing DTS/PTS for video
+        int noUpdate=0;
+        for(int i=0;i<ListOfFrames.size();i++)
+        {
+            dmxFrame *frame=ListOfFrames[i];
+            aprintf("[psUpdate] frame:%d raw DTS: %"LLD" PTS:%"LLD"\n",i,frame->dts,frame->pts);
+            if(frame->pts==ADM_NO_PTS || frame->dts==ADM_NO_PTS)
+            {
+                noUpdate++;
+                // We have PTS or DTS and it has been a long time we did not have both
+                if(noUpdate>DMX_RECOMPUTE_PTS_DTS_MAX && frame->type==1 && (frame->pts!=ADM_NO_PTS || frame->dts!=ADM_NO_PTS))
+                {
+                    if(frame->pts!=ADM_NO_PTS)
+                    {
+                        frame->dts=frame->pts-2*dtsIncrement;
+                    }else   
+                    {
+                        frame->pts=frame->dts+2*dtsIncrement;
+                    }
+                    uint64_t oldDts=lastDts;
+                    frame->dts=lastDts=timeConvert(frame->dts);
+                    frame->pts=lastPts=timeConvert(frame->pts);
+                    if(oldDts>lastDts) printf("[psRead] Warning DTS going backward frame %d, old:%"LLD" new:%"LLD" delta=%"LLD"\n",
+                                                       i,oldDts/1000,lastDts/1000,(oldDts-lastDts)/1000);
+
+                }else
+                {
+                    lastDts+=dtsIncrement;
+                    lastPts+=dtsIncrement;
+                    frame->dts=lastDts;
+                    frame->pts=ADM_NO_PTS;
+                }
+            }else    // We got both, use them  
+            {
+                
+                frame->dts=lastDts=timeConvert(frame->dts);
+                frame->pts=lastPts=timeConvert(frame->pts);
+            }
+        }
+        // convert to us for Audio tracks (seek points)
+        for(int i=0;i<listOfAudioTracks.size();i++)
+        {
+            ADM_psTrackDescriptor *track=listOfAudioTracks[i];
+            ADM_psAccess    *access=track->access;
+            
+            for(int j=0;j<access->seekPoints.size();j++)
+            {
+                if( access->seekPoints[j].dts!=ADM_NO_PTS) 
+                    access->seekPoints[j].dts=access->timeConvert( access->seekPoints[j].dts);
+            }
+        }
+#if 0
+        for(int i=0;i<ListOfFrames.size();i++)
+        {
+            dmxFrame *frame=ListOfFrames[i];
+            int64_t pts,dts;
+            pts=frame->pts;
+            dts=frame->dts;
+            if(pts!=ADM_NO_PTS) pts/=1000;
+            if(dts!=ADM_NO_PTS) dts/=1000;
+            printf("[psVideo] Framex %d PTS:%"LLD" ms DTS:%"LLD" ms, delta %"LLD" ms\n",i,pts,dts,pts-dts);
+        }
+#endif
+        return 1;
+                    
+}

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,408 @@
+/***************************************************************************
+                        Mpeg2 in PS indexer                                            
+                             
+    
+    copyright            : (C) 2005/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_demuxerInternal.h"
+#include "fourcc.h"
+
+#include "dmxPSPacket.h"
+
+#include "avidemutils.h"
+#include "ADM_quota.h"
+#include "ADM_psAudioProbe.h"
+#include "DIA_working.h"
+
+static const char Type[5]={'X','I','P','B','P'};
+
+static const uint32_t FPS[16]={
+                0,                      // 0
+                23976,          // 1 (23.976 fps) - FILM
+                24000,          // 2 (24.000 fps)
+                25000,          // 3 (25.000 fps) - PAL
+                29970,          // 4 (29.970 fps) - NTSC
+                30000,          // 5 (30.000 fps)
+                50000,          // 6 (50.000 fps) - PAL noninterlaced
+                59940,          // 7 (59.940 fps) - NTSC noninterlaced
+                60000,          // 8 (60.000 fps)
+                0,                      // 9
+                0,                      // 10
+                0,                      // 11
+                0,                      // 12
+                0,                      // 13
+                0,                      // 14
+                0                       // 15
+        };
+
+typedef struct
+{
+    uint32_t w;
+    uint32_t h;
+    uint32_t fps;
+    uint32_t interlaced;
+    uint32_t ar;
+}PSVideo;
+
+typedef enum
+{
+    idx_startAtImage,
+    idx_startAtGopOrSeq
+}indexerState;
+typedef struct
+{
+    uint64_t pts,dts,startAt;
+    uint32_t offset;
+    uint32_t frameType;
+    uint32_t nbPics;
+    indexerState state;
+    psPacketLinear *pkt;
+    int32_t        nextOffset;
+}indexerData;
+
+typedef enum
+{
+    markStart,
+    markEnd,
+    markNow
+}markType;
+
+/**
+    \class PsIndexer
+*/
+class PsIndexer
+{
+protected:
+        FILE *index;
+        psPacketLinearTracker *pkt;
+        listOfPsAudioTracks *audioTracks;
+        DIA_workingBase  *ui;
+public:
+                PsIndexer(void);
+                ~PsIndexer();
+        bool    run(const char *file);
+        bool    writeVideo(PSVideo *video);
+        bool    writeAudio(void);
+        bool    writeSystem(const char *filename,bool append);
+        bool    Mark(indexerData *data,dmxPacketInfo *s,markType update);
+
+};
+/**
+      \fn psIndexer 
+      \brief main indexing loop for mpeg2 payload
+*/
+uint8_t   psIndexer(const char *file)
+{
+bool r;
+    PsIndexer *dx=new PsIndexer;
+    r=dx->run(file);
+    delete dx;
+    return r;
+}
+
+/**
+    \fn PsIndexer
+*/
+PsIndexer::PsIndexer(void)
+{
+    index=NULL;
+    pkt=NULL;
+    audioTracks=NULL;
+    ui=createWorking ("Indexing");
+}
+
+/**
+    \fn ~PsIndexer
+*/
+PsIndexer::~PsIndexer()
+{
+    if(index) qfclose(index);
+    if(pkt) delete pkt;
+    if( audioTracks) DestroyListOfPsAudioTracks(audioTracks);
+    if(ui) delete ui;
+    ui=NULL;
+}
+/**
+    \fn run
+*/  
+bool PsIndexer::run(const char *file)
+{
+uint32_t temporal_ref,val;
+uint64_t fullSize;
+uint8_t buffer[50*1024];
+bool seq_found=false;
+
+PSVideo video;
+indexerData  data;    
+dmxPacketInfo info;
+
+    memset(&data,0,sizeof(data));
+    char indexName[strlen(file)+5];
+    sprintf(indexName,"%s.idx",file);
+    index=qfopen(indexName,"wt");
+    if(!index)
+    {
+        printf("[PsIndex] Cannot create %s\n",indexName);
+        return false;
+    }
+    writeSystem(file,true);
+    pkt=new psPacketLinearTracker(0xE0);
+
+    audioTracks=psProbeAudio(file);
+    if(audioTracks)
+    {
+        for(int i=0;i<audioTracks->size();i++)
+        {
+                printf("[PsProbe] Found audio Track %d, pid=%x\n",i,(*audioTracks)[i]->esID);
+                WAVHeader *hdr=&((*audioTracks)[i]->header);
+                printf("[PsProbe] codec    : 0x%x \n",hdr->encoding);
+                printf("[PsProbe] frequency: %"LU" Hz\n",hdr->frequency);
+                printf("[PsProbe] channel  : %"LU" \n",hdr->channels);
+                printf("[PsProbe] byterate : %"LU" Byte/s\n",hdr->byterate);
+
+        }
+
+    }
+
+    FP_TYPE append=FP_APPEND;
+    pkt->open(file,append);
+    data.pkt=pkt;
+    fullSize=pkt->getSize();
+      while(1)
+      {
+        uint32_t code=0xffff+0xffff0000;
+        while((code&0x00ffffff)!=1 && pkt->stillOk())
+        {
+            code=(code<<8)+pkt->readi8();
+        }
+        if(!pkt->stillOk()) break;
+        uint8_t startCode=pkt->readi8();
+
+        pkt->getInfo(&info);
+        info.offset-=4;
+
+          switch(startCode)
+                  {
+                  case 0xB3: // sequence start
+                          Mark(&data,&info,markStart);
+                          data.state=idx_startAtGopOrSeq;
+                          if(seq_found)
+                          {
+                                  pkt->forward(8);  // Ignore
+                                  continue;
+                          }
+                          //
+                          seq_found=1;
+                          val=pkt->readi32();
+                          video.w=val>>20;
+                          video.w=((video.w+15)&~15);
+                          video.h= (((val>>8) & 0xfff)+15)& ~15;
+
+                          video.ar = (val >> 4) & 0xf;
+
+                          
+                          video.fps= FPS[val & 0xf];
+                          pkt->forward(4);
+                          writeVideo(&video);
+                          writeAudio();
+                          pkt->resetStats();
+                          qfprintf(index,"[Data]");
+                          break;
+                  case 0xb8: // GOP
+                          // Update ui
+                            {
+                                float pos=data.startAt;
+                                pos=pos/(float)fullSize;
+                                pos*=100;
+                                ui->update( (uint32_t)pos);
+
+                            }
+
+                          if(!seq_found) continue;
+                          if(data.state==idx_startAtGopOrSeq) 
+                          {         
+                                  continue;;
+                          }
+                          
+                          Mark(&data,&info,markStart);
+                          data.state=idx_startAtGopOrSeq;
+                          break;
+                  case 0x00 : // picture
+                        {
+                          int type;
+                          markType update=markNow;
+                          if(!seq_found)
+                          { 
+                                  continue;
+                                  printf("[psIndexer]No sequence start yet, skipping..\n");
+                          }
+                          
+                          val=pkt->readi16();
+                          temporal_ref=val>>6;
+                          type=7 & (val>>3);
+                          if( type<1 ||  type>3)
+                          {
+                                  printf("[Indexer]Met illegal pic at %"LLX" + %"LX"\n",
+                                                  info.startAt,info.offset);
+                                  continue;
+                          }
+                          
+                          
+                          if(data.state==idx_startAtGopOrSeq) 
+                          {
+                                update=markEnd;
+                          }
+                          data.frameType=type;
+                          Mark(&data,&info,update);
+                          data.state=idx_startAtImage;
+                          data.nbPics++;
+                        }
+                          break;
+                  default:
+                    break;
+                  }
+      }
+    
+        printf("\n");
+        Mark(&data,&info,markStart);
+        qfprintf(index,"\n[End]\n");
+        qfclose(index);
+        index=NULL;
+        if(audioTracks) DestroyListOfPsAudioTracks( audioTracks);
+        audioTracks=NULL;
+        delete pkt;
+        pkt=NULL;
+        return 1; 
+}
+/**
+    \fn   Mark
+    \brief update the file
+
+    The offset part is due to the fact that we read 2 bytes from the pic header to know the pic type.
+    So when going from a pic to a pic, it is self cancelling.
+    If the beginning is not a pic, but a gop start for example, we had to add/remove those.
+
+*/
+bool  PsIndexer::Mark(indexerData *data,dmxPacketInfo *info,markType update)
+{
+    int offset=data->nextOffset;
+    data->nextOffset=0;
+    
+     if( update==markStart)
+     {
+                offset=2;
+     }
+    if(update==markStart || update==markNow)
+    {
+        if(data->nbPics)
+        {
+            // Write previous image data (size) : TODO
+            qfprintf(index,":%06"LX" ",data->pkt->getConsumed()+offset); // Size
+        }
+        else data->pkt->getConsumed();
+    }
+    if(update==markEnd || update==markNow)
+    {
+        if(data->frameType==1)
+        {
+            // If audio, also dump audio
+            if(audioTracks)
+            {
+                qfprintf(index,"\nAudio bf:%08"LLX" ",data->startAt);
+                for(int i=0;i<audioTracks->size();i++)
+                {
+                    uint8_t e=(*audioTracks)[i]->esID;
+                    packetStats *s=pkt->getStat(e);
+                    
+                    qfprintf(index,"Pes:%x:%08"LLX":%"LD":%"LLD" ",e,s->startAt,s->startSize,s->startDts);
+                }
+                
+            }
+            // start a new line
+            qfprintf(index,"\nVideo at:%08"LLX":%04"LX" Pts:%08"LLD":%08"LLD" ",data->startAt,data->offset,info->pts,info->dts);
+            data->nextOffset=-2;
+        }
+    
+        qfprintf(index,"%c",Type[data->frameType]);
+    }
+    if(update==markEnd || update==markNow)
+    {
+        data->pts=info->pts;
+        data->dts=info->dts;
+    }
+    if(update==markStart || update==markNow)
+    {
+        data->startAt=info->startAt;
+        data->offset=info->offset;
+    }
+}
+
+/**
+    \fn writeVideo
+    \brief Write Video section of index file
+*/
+bool PsIndexer::writeVideo(PSVideo *video)
+{
+    qfprintf(index,"[Video]\n");
+    qfprintf(index,"Width=%d\n",video->w);
+    qfprintf(index,"Height=%d\n",video->h);
+    qfprintf(index,"Fps=%d\n",video->fps);
+    qfprintf(index,"Interlaced=%d\n",video->interlaced);
+    qfprintf(index,"AR=%d\n",video->ar);
+    return true;
+}
+/**
+    \fn writeSystem
+    \brief Write system part of index file
+*/
+bool PsIndexer::writeSystem(const char *filename,bool append)
+{
+    qfprintf(index,"PSD1\n");
+    qfprintf(index,"[System]\n");
+    qfprintf(index,"Type=P\n");
+    qfprintf(index,"File=%s\n",filename);
+    qfprintf(index,"Append=%d\n",append);
+    return true;
+}
+/**
+    \fn     writeAudio
+    \brief  Write audio headers
+*/
+bool PsIndexer::writeAudio(void)
+{
+    if(!audioTracks) return false;
+    qfprintf(index,"[Audio]\n");
+    qfprintf(index,"Tracks=%d\n",audioTracks->size());
+    for(int i=0;i<audioTracks->size();i++)
+    {
+        char head[30];
+        psAudioTrackInfo *t=(*audioTracks)[i];
+        sprintf(head,"Track%1d",i);
+        qfprintf(index,"%s.pid=%x\n",head,t->esID);
+        qfprintf(index,"%s.codec=%d\n",head,t->header.encoding);
+        qfprintf(index,"%s.fq=%d\n",head,t->header.frequency);
+        qfprintf(index,"%s.chan=%d\n",head,t->header.channels);
+        qfprintf(index,"%s.br=%d\n",head,t->header.byterate);
+    }
+    return true;
+}
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+
+//
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,98 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+      See lavformat/flv[dec/env].c for detail
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_ps.h"
+#include "ADM_demuxerInternal.h"
+#include "fourcc.h"
+#include "avidemutils.h"
+
+ADM_DEMUXER_BEGIN( psHeader,
+                    1,0,0,
+                    "ps",
+                    "mpeg ps demuxer plugin (c) Mean 2007/2008"
+                );
+
+static bool detectPs(const char *file);
+uint8_t   psIndexer(const char *file);
+/**
+    \fn Probe
+*/
+
+extern "C"  uint32_t         probe(uint32_t magic, const char *fileName)
+{
+char index[strlen(fileName)+4];
+int count=0;
+    if(!detectPs(fileName))
+    {
+        printf(" [PS Demuxer] Not a ps file\n");
+        return false;
+    }
+
+    sprintf(index,"%s.idx",fileName);
+again:    
+    if(ADM_fileExist(index)) 
+    {
+        printf(" [PS Demuxer] There is an index for that file \n");
+        FILE *f=fopen(index,"rt");
+        char signature[10];
+        fread(signature,4,1,f);
+        signature[4]=0;
+        fclose(f);
+        if(!strcmp(signature,"PSD1")) return 50;
+        printf("[PsDemuxer] Not a valid index\n");
+        return false;
+    }
+    if(count) return false;
+    printf("[PSDemuxer] Creating index..\n");
+    count++;
+    if(true==psIndexer(fileName)) goto again;
+    printf("[PSDemuxer] Failed..\n");
+   return 0;
+}
+#define PROBE_SIZE (1024*1024)
+/**
+    \fn detectPs
+    \brief returns true if the file seems to be mpeg PS
+
+*/
+bool detectPs(const char *file)
+{
+    uint8_t *buffer=new uint8_t [PROBE_SIZE];
+    uint32_t bufferSize;
+    uint32_t nbPacket,nbMatch=0;
+
+    FILE *f=fopen(file,"rb");
+    if(!f) return false;
+    bufferSize=fread(buffer,1,PROBE_SIZE,f);
+    fclose(f);
+    nbPacket=bufferSize/2300;
+    uint8_t *head,*tail;
+    head=buffer;
+    tail=buffer+bufferSize;
+    uint8_t code;
+    uint32_t offset;
+    while(ADM_findMpegStartCode(head,tail,&code,&offset))
+    {
+        head+=offset;
+        if(code==0xE0) nbMatch++;
+    }
+    printf(" match :%d / %d (probeSize:%d)\n",nbMatch,nbPacket,bufferSize);
+    if(nbMatch>nbPacket/3)
+        return true;
+    return false;
+    
+
+}
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,237 @@
+/***************************************************************************
+    copyright            : (C) 2007/2009 by mean
+    email                : fixounet at free.fr
+    
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_indexFile.h"
+#include "ADM_ps.h"
+
+#include <math.h>
+/**
+        \fn readIndex
+        \brief Read the [video] section of the index file
+
+*/
+bool    psHeader::readIndex(indexFile *index)
+{
+char buffer[2000];
+bool firstAudio=true;
+        printf("[psDemuxer] Reading index\n");
+        if(!index->goToSection("Data")) return false;
+      
+        while(1)
+        {
+            if(!index->readString(2000,(uint8_t *)buffer)) return true;
+            if(buffer[0]=='[') return true;
+            if(buffer[0]==0xa || buffer[0]==0xd) continue; // blank line
+            // Now split the line
+            if(!strncmp(buffer,"Video ",6))
+            {
+                processVideoIndex(buffer+6);
+            }
+            if(!strncmp(buffer,"Audio ",6))
+            {
+                if(firstAudio) 
+                    firstAudio=false; // Ignore first line
+                else
+                    processAudioIndex(buffer+6);
+            }
+        }
+    return true;
+}
+/**
+    \fn processAudioIndex
+    \brief process audio seek points from a line from the index file
+*/
+bool psHeader::processAudioIndex(char *buffer)
+{
+    int64_t startAt,dts;
+    uint32_t size;
+    uint32_t pes;
+    char *head,*tail;
+    int trackNb=0;
+        sscanf(buffer,"bf:%"LLX,&startAt);
+        head=strstr(buffer," ");
+        if(!head) return false;
+        head++;
+        while(tail=strstr(head," "))
+        {
+            if(4!=sscanf(head,"Pes:%"LX":%"LLX":%"LD":%"LLD" ",&pes,&startAt,&size,&dts))
+            {
+// qfprintf(index,"Pes:%x:%08"LLX":%"LD":%LLD ",e,s->startAt,s->startSize,s->startDts);
+                printf("[PsHeader::processAudioIndex] Reading index %s failed\n",buffer);
+            }
+            head=tail+1;
+            ADM_psAccess *track=listOfAudioTracks[trackNb]->access;
+            track->push(startAt,dts,size);
+
+            trackNb++;
+            //printf("[%s] => %"LX" Dts:%"LLD" Size:%"LLD"\n",buffer,pes,dts,size);
+            if(strlen(head)<4) break;
+        }
+        return true;
+
+}
+
+/**
+    \fn processVideoIndex
+    \brief process an mpeg index entry from a line from the index file
+*/
+bool psHeader::processVideoIndex(char *buffer)
+{
+            char *head=buffer;
+            uint64_t pts,dts,startAt;
+            uint32_t offset;
+            if(4!=sscanf(head,"at:%"LLX":%"LX" Pts:%"LLD":%"LLD,&startAt,&offset,&pts,&dts))
+            {
+                    printf("[psDemuxer] cannot read fields in  :%s\n",buffer);
+                    return false;
+            }
+            
+            char *start=strstr(buffer," I:");
+            if(!start) return true;
+            start+=1;
+            int count=0;
+            while(1)
+            {
+                char *cur=start;
+                char type=1;
+                char *next;
+                uint32_t len;
+                type=*cur;
+                if(type==0x0a || type==0x0d) break;
+                cur++;
+                if(*(cur)!=':')
+                {
+                    printf("[psDemux]  instead of : (%c %x %x):\n",*cur,*(cur-1),*cur);
+                }
+                *cur++;
+                next=strstr(start," ");
+                ADM_assert(1==sscanf(cur,"%"LX,&len));
+                
+                
+                dmxFrame *frame=new dmxFrame;
+                if(!count)
+                {
+                    frame->pts=pts;
+                    frame->dts=dts;
+
+                    frame->startAt=startAt;
+                    frame->index=offset;
+
+                }else       
+                {
+                    frame->pts=ADM_NO_PTS;
+                    frame->dts=ADM_NO_PTS;
+                    frame->startAt=0;
+                    frame->index=0;
+                }
+                switch(type)
+                {
+                    case 'I': frame->type=1;break;
+                    case 'P': frame->type=2;break;
+                    case 'B': frame->type=3;break;
+                    default: ADM_assert(0);
+                }
+                frame->len=len;
+                ListOfFrames.push_back(frame);
+                count++;
+                if(!next) 
+                {
+                    break;
+                }
+                start=next+1;
+            }
+
+        return true;
+}
+
+/**
+        \fn readVideo
+        \brief Read the [video] section of the index file
+
+*/
+bool    psHeader::readVideo(indexFile *index)
+{
+    printf("[psDemuxer] Reading Video\n");
+    if(!index->readSection("Video")) return false;
+    uint32_t w,h,fps,ar;
+    
+    w=index->getAsUint32("Width");
+    h=index->getAsUint32("height");
+    fps=index->getAsUint32("Fps");
+
+    if(!w || !h || !fps) return false;
+
+    interlaced=index->getAsUint32("Interlaced");
+    
+    _video_bih.biWidth=_mainaviheader.dwWidth=w ;
+    _video_bih.biHeight=_mainaviheader.dwHeight=h;             
+    _videostream.dwScale=1000;
+    _videostream.dwRate=fps;
+
+    _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"MPEG");
+
+    return true;
+}
+/**
+        \fn readAudio
+        \brief Read the [Audio] section of the index file
+
+*/
+bool    psHeader::readAudio(indexFile *index,const char *name)
+{
+    printf("[psDemuxer] Reading Audio\n");
+    if(!index->readSection("Audio")) return false;
+    uint32_t nbTracks;
+    
+    nbTracks=index->getAsUint32("Tracks");
+    if(!nbTracks)
+    {
+        printf("[PsDemux] No audio\n");
+        return true;
+    }
+    for(int i=0;i<nbTracks;i++)
+    {
+        char header[40];
+        char body[40];
+        uint32_t fq,chan,br,codec,pid;
+        sprintf(header,"Track%d.",i);
+#define readInt(x,y) {sprintf(body,"%s"#y,header);x=index->getAsUint32(body);printf("%02d:"#y"=%"LU"\n",i,x);}
+#define readHex(x,y) {sprintf(body,"%s"#y,header);x=index->getAsHex(body);printf("%02x:"#y"=%"LU"\n",i,x);}
+        readInt(fq,fq);
+        readInt(br,br);
+        readInt(chan,chan);
+        readInt(codec,codec);
+        readHex(pid,pid);
+        WAVHeader hdr;
+            hdr.frequency=fq;
+            hdr.byterate=br;
+            hdr.channels=chan;
+            hdr.encoding=codec;
+        ADM_psAccess *access=new ADM_psAccess(name,pid,true);
+            ADM_psTrackDescriptor *desc=new ADM_psTrackDescriptor;
+            desc->stream=NULL;
+            desc->access=access;
+            memcpy(&(desc->header),&hdr,sizeof(hdr));
+            listOfAudioTracks.push_back(desc);
+
+
+    }
+    return true;
+}
+//EOF
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-07 05:39:44 UTC (rev 4722)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-07 05:39:51 UTC (rev 4723)
@@ -0,0 +1,18 @@
+include(dm_plugin)
+SET(ADM_ts_SRCS 
+	ADM_ts.cpp
+	ADM_tsPlugin.cpp
+	ADM_tsIndex.cpp
+	ADM_tsReadIndex.cpp
+	ADM_tsAudio.cpp
+	ADM_tsAudioProbe.cpp
+	ADM_tsAudioProbe.h
+        ADM_tsComputeTimeStamp.cpp
+)
+
+ADD_LIBRARY(ADM_dm_ts SHARED ${ADM_ts_SRCS})
+TARGET_LINK_LIBRARIES(ADM_dm_ts ADM_coreDemuxerMpeg ADM_audioParser)
+INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreDemuxerMpeg/include")
+
+INIT_DEMUXER(ADM_dm_ts)
+INSTALL_DEMUXER(ADM_dm_ts)



From mean at mail.berlios.de  Tue Apr  7 07:39:57 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 7 Apr 2009 07:39:57 +0200
Subject: [Avidemux-svn-commit] r4724 -
	branches/avidemux_2.6_branch_mean/avidemux
Message-ID: <200904070539.n375dvlT009683@sheep.berlios.de>

Author: mean
Date: 2009-04-07 07:39:56 +0200 (Tue, 07 Apr 2009)
New Revision: 4724

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/main.cpp
Log:
[Main] dont load video filter, we dont use them for the moment

Modified: branches/avidemux_2.6_branch_mean/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/main.cpp	2009-04-07 05:39:51 UTC (rev 4723)
+++ branches/avidemux_2.6_branch_mean/avidemux/main.cpp	2009-04-07 05:39:56 UTC (rev 4724)
@@ -244,10 +244,10 @@
 
 	ADM_ad_loadPlugins(adPlugins);
 	delete [] adPlugins;
-
+#if 0 // Dont load video filter now
 	ADM_vf_loadPlugins(vfPlugins);
 	delete [] vfPlugins;
-
+#endif
     ADM_av_loadPlugins(avPlugins);
     delete [] avPlugins;
 



From mean at mail.berlios.de  Tue Apr  7 07:39:59 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 7 Apr 2009 07:39:59 +0200
Subject: [Avidemux-svn-commit] r4725 -
	branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src
Message-ID: <200904070539.n375dxWw009698@sheep.berlios.de>

Author: mean
Date: 2009-04-07 07:39:59 +0200 (Tue, 07 Apr 2009)
New Revision: 4725

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_dynamicLoading.cpp
Log:
[dynLoad] Use local symbols (merge from gruntster)

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_dynamicLoading.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_dynamicLoading.cpp	2009-04-07 05:39:56 UTC (rev 4724)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_core/src/ADM_dynamicLoading.cpp	2009-04-07 05:39:59 UTC (rev 4725)
@@ -91,7 +91,7 @@
 		return true;
 	}
 #else
-	hinstLib = dlopen(path, RTLD_NOW | RTLD_GLOBAL);
+	hinstLib = dlopen(path, RTLD_NOW | RTLD_LOCAL);
 	
 	if (hinstLib == NULL)
 	{



From mean at mail.berlios.de  Tue Apr  7 07:40:02 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 7 Apr 2009 07:40:02 +0200
Subject: [Avidemux-svn-commit] r4726 - in
	branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg:
	include src
Message-ID: <200904070540.n375e2dO009736@sheep.berlios.de>

Author: mean
Date: 2009-04-07 07:40:01 +0200 (Tue, 07 Apr 2009)
New Revision: 4726

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp
Log:
[DemuxerMpeg] Skeleton for Ts demuxer (commmon part)

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:39:59 UTC (rev 4725)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:40:01 UTC (rev 4726)
@@ -1,10 +1,10 @@
 /**
-    dmxPSPacket.cpp
+    dmxtsPacket.cpp
 
 */
 
-#ifndef DMXPSPACKET_H
-#define DMXPSPACKET_H
+#ifndef DMXtsPacket_H
+#define DMXtsPacket_H
 
 #include "dmxPacket.h"
 #include "ADM_Video.h"
@@ -12,15 +12,15 @@
 
 
 /**
-    \class psPacket
+    \class tsPacket
 */
-class psPacket : public ADMMpegPacket
+class tsPacket : public ADMMpegPacket
 {
 protected:
     uint8_t             getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
 public:
-                        psPacket(void);
-    virtual            ~psPacket();
+                        tsPacket(void);
+    virtual            ~tsPacket();
     virtual bool        open(const char *filenames,FP_TYPE append);
     virtual bool        close(void);
     virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
@@ -28,11 +28,11 @@
     virtual bool        setPos(uint64_t pos);
 };
 /**
-    \class psPacketLinear
+    \class tsPacketLinear
 */
 #define ADM_PACKET_LINEAR 10*1024
 
-class psPacketLinear : public psPacket
+class tsPacketLinear : public tsPacket
 {
 protected:
         uint8_t  myPid;
@@ -51,8 +51,8 @@
         uint32_t consumed;
 
 public:
-                psPacketLinear(uint8_t pid);
-                ~psPacketLinear();
+                tsPacketLinear(uint8_t pid);
+                ~tsPacketLinear();
         uint32_t getConsumed(void);
         uint8_t  readi8();
         uint16_t readi16();
@@ -66,7 +66,7 @@
         bool    changePid(uint32_t pid) ;
 };
 /**
-    \class psPacketLinearTracker
+    \class tsPacketLinearTracker
 */
 typedef struct
 {
@@ -79,18 +79,18 @@
     uint64_t startDts;
 }packetStats;
 
-class psPacketLinearTracker : public psPacketLinear
+class tsPacketLinearTracker : public tsPacketLinear
 {
 protected:
       packetStats stats[256];
 
 public:
-                        psPacketLinearTracker(uint8_t pid);
-                        ~psPacketLinearTracker();
+                        tsPacketLinearTracker(uint8_t pid);
+                        ~tsPacketLinearTracker();
          packetStats    *getStat(int intdex);
          bool           resetStats(void);
 virtual  bool           getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
 };
 
 
-#endif
\ No newline at end of file
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt	2009-04-07 05:39:59 UTC (rev 4725)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt	2009-04-07 05:40:01 UTC (rev 4726)
@@ -8,6 +8,7 @@
 dmx_io.cpp
 dmxPacket.cpp
 dmxPSPacket.cpp
+dmxTSPacket.cpp
 )	
 #*************************************************
 ADD_LIBRARY(ADM_coreDemuxerMpeg SHARED ${ADMcoreDemuxerMpeg_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:39:59 UTC (rev 4725)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:40:01 UTC (rev 4726)
@@ -1,7 +1,7 @@
 /**
-    \file dmxPSPacket
-    \brief Packet demuxer for mpeg PS
-    copyright            : (C) 2005-2008 by mean
+    \file dmxtsPacket
+    \brief Packet demuxer for mpeg TS
+    copyright            : (C) 2005-2009 by mean
     email                : fixounet at free.fr
         
  ***************************************************************************/
@@ -16,22 +16,22 @@
  ***************************************************************************/
 #include "ADM_default.h"
 
-#include "dmxPSPacket.h"
+#include "dmxTSPacket.h"
 #include "dmx_mpegstartcode.h"
 
 /**
-    \fn psPacket
+    \fn tsPacket
     \brief ctor
 */
-psPacket::psPacket(void) 
+tsPacket::tsPacket(void) 
 {
 
 }
 /**
-    \fn psPacket
+    \fn tsPacket
     \brief dtor
 */
-psPacket::~psPacket()
+tsPacket::~tsPacket()
 {
     close();
 }
@@ -39,7 +39,7 @@
     \fn open
     \brief dtor
 */
-bool psPacket::open(const char *filenames,FP_TYPE append)
+bool tsPacket::open(const char *filenames,FP_TYPE append)
 {
     _file=new fileParser();
     if(!_file->open(filenames,&append))
@@ -56,7 +56,7 @@
     \fn close
     \brief dtor
 */
-bool psPacket::close(void)
+bool tsPacket::close(void)
 {
     if(_file)
     {
@@ -68,7 +68,7 @@
 /**
     \fn getPos
 */
-uint64_t    psPacket::getPos(void)
+uint64_t    tsPacket::getPos(void)
 {
     return 0;
 }
@@ -76,11 +76,11 @@
     \fn setPos
 */
 
-bool    psPacket::setPos(uint64_t pos)
+bool    tsPacket::setPos(uint64_t pos)
 {
     if(!_file->setpos(pos))
     {
-        printf("[psPacket] Cannot seek to %"LLX"\n", pos);
+        printf("[tsPacket] Cannot seek to %"LLX"\n", pos);
         return false;
     }
 }
@@ -88,7 +88,7 @@
 /**
     \fn getPacket
 */      
-bool        psPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)
+bool        tsPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)
 {
 uint32_t globstream,len;
 uint8_t  stream,substream;
@@ -155,7 +155,7 @@
 
 */
 
-uint8_t psPacket::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
+uint8_t tsPacket::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
 {
 
 //uint32_t un ,deux;
@@ -376,9 +376,9 @@
 
 #define ADM_PACKET_LINEAR 10*1024
 /**
-    \fn psPacket
+    \fn tsPacket
 */
-psPacketLinear::psPacketLinear(uint8_t pid) : psPacket()
+tsPacketLinear::tsPacketLinear(uint8_t pid) : tsPacket()
 {
     oldStartAt=startAt=0xfffffff;
     oldBufferLen=bufferLen=0;
@@ -387,15 +387,15 @@
     eof=false;
 }
 /**
-    \fn ~psPacket
+    \fn ~tsPacket
 */
-psPacketLinear::~psPacketLinear() 
+tsPacketLinear::~tsPacketLinear() 
 {
 }
 /**
     \fn refill
 */
-bool psPacketLinear::refill(void) 
+bool tsPacketLinear::refill(void) 
 {
 // In case a startcode spawns across 2 packets
 // we have to keep track of the old one
@@ -405,7 +405,7 @@
         oldBufferLen=bufferLen;
         if( false== getPacketOfType(myPid,ADM_PACKET_LINEAR, &bufferLen,&bufferPts,&bufferDts,buffer,&startAt)) 
         {
-            printf("[PsPacketLinear] Refill failed for pid :%x\n",myPid);
+            printf("[tsPacketLinear] Refill failed for pid :%x\n",myPid);
             bufferIndex=bufferLen=0;
             return false;
         }
@@ -416,7 +416,7 @@
 /**
     \fn readi8
 */
-uint8_t psPacketLinear::readi8(void)
+uint8_t tsPacketLinear::readi8(void)
 {
     consumed++;
     if(bufferIndex<bufferLen)
@@ -436,7 +436,7 @@
 /**
     \fn readi16
 */
-uint16_t psPacketLinear::readi16(void)
+uint16_t tsPacketLinear::readi16(void)
 {
     if(bufferIndex+1<bufferLen)
     {
@@ -450,7 +450,7 @@
 /**
     \fn readi32
 */
-uint32_t psPacketLinear::readi32(void)
+uint32_t tsPacketLinear::readi32(void)
 {
     if(bufferIndex+3<bufferLen)
     {
@@ -465,7 +465,7 @@
 /**
     \fn forward
 */
-bool psPacketLinear::forward(uint32_t v)
+bool tsPacketLinear::forward(uint32_t v)
 {
 next:
  uint32_t delta=bufferLen-bufferIndex;
@@ -489,7 +489,7 @@
     \fn bool    read(uint32_t len, uint8_t *buffer);
     \brief
 */
-bool    psPacketLinear::read(uint32_t len, uint8_t *out)
+bool    tsPacketLinear::read(uint32_t len, uint8_t *out)
 {
     // Enough already ?
     while(len)
@@ -520,7 +520,7 @@
             It is expected that the caller will do -4 to the index to get the start of the 
             startCode
 */
-bool    psPacketLinear::getInfo(dmxPacketInfo *info)
+bool    tsPacketLinear::getInfo(dmxPacketInfo *info)
 {
     if(bufferIndex<4)
     {
@@ -543,16 +543,16 @@
     \fn seek
     \brief Async jump
 */
-bool    psPacketLinear::seek(uint64_t packetStart, uint32_t offset)
+bool    tsPacketLinear::seek(uint64_t packetStart, uint32_t offset)
 {
     if(!_file->setpos(packetStart))
     {
-        printf("[psPacket] Cannot seek to %"LLX"\n",packetStart);
+        printf("[tsPacket] Cannot seek to %"LLX"\n",packetStart);
         return 0;
     }
     if(!refill())
     {
-        printf("[PsPacketLinear] Seek to %"LLX":%"LX" failed\n",packetStart,offset);
+        printf("[tsPacketLinear] Seek to %"LLX":%"LX" failed\n",packetStart,offset);
         return false;
     }
     ADM_assert(offset<bufferLen);
@@ -564,7 +564,7 @@
     \fn getConsumed
     \brief returns the # of bytes consumed since the last call
 */
-uint32_t psPacketLinear::getConsumed(void)
+uint32_t tsPacketLinear::getConsumed(void)
 {
     uint32_t c=consumed;
     consumed=0;
@@ -574,7 +574,7 @@
     \fn changePid
     \brief change the pid of the stream we read (used when probing all tracks)
 */
-bool    psPacketLinear::changePid(uint32_t pid) 
+bool    tsPacketLinear::changePid(uint32_t pid) 
 {
     myPid=(pid&0xff);
     bufferLen=bufferIndex=0;
@@ -582,16 +582,16 @@
 }
 /* ********************************************************* */
 /**
-    \fn psPacketLinearTracker
+    \fn tsPacketLinearTracker
 */
- psPacketLinearTracker::psPacketLinearTracker(uint8_t pid)  : psPacketLinear(pid)
+ tsPacketLinearTracker::tsPacketLinearTracker(uint8_t pid)  : tsPacketLinear(pid)
 {
    resetStats();
 }
 /**
-    \fn ~psPacketLinearTracker
+    \fn ~tsPacketLinearTracker
 */
-psPacketLinearTracker::~psPacketLinearTracker()
+tsPacketLinearTracker::~tsPacketLinearTracker()
 {
 
     
@@ -599,7 +599,7 @@
 /**
         \fn getStat
 */
-packetStats    *psPacketLinearTracker::getStat(int index)
+packetStats    *tsPacketLinearTracker::getStat(int index)
 {   
     if(index<0 || index>=256) ADM_assert(0);
     return stats+index;
@@ -609,7 +609,7 @@
     \brief Keep track of all the packets we have seen so far.
     Usefull to detect the streams present and to look up the PTS/DTS of audio streams for the audio part of the index
 */
-bool           psPacketLinearTracker::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
+bool           tsPacketLinearTracker::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
 {
  bool xit=false;
     uint8_t tmppid;
@@ -641,7 +641,7 @@
 /**
     \fn resetStats
 */
-bool           psPacketLinearTracker::resetStats(void)
+bool           tsPacketLinearTracker::resetStats(void)
 {
     memset(stats,0,sizeof(stats));
     for(int i=0;i<256;i++)



From mean at mail.berlios.de  Tue Apr  7 07:40:07 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 7 Apr 2009 07:40:07 +0200
Subject: [Avidemux-svn-commit] r4727 - in branches/avidemux_2.6_branch_mean:
	avidemux/ADM_coreDemuxerMpeg/include
	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegTS
Message-ID: <200904070540.n375e7DW009769@sheep.berlios.de>

Author: mean
Date: 2009-04-07 07:40:06 +0200 (Tue, 07 Apr 2009)
New Revision: 4727

Added:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
Log:
[TSdemuxer] Rename PS one to start

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:40:06 UTC (rev 4727)
@@ -1,96 +0,0 @@
-/**
-    dmxtsPacket.cpp
-
-*/
-
-#ifndef DMXtsPacket_H
-#define DMXtsPacket_H
-
-#include "dmxPacket.h"
-#include "ADM_Video.h"
-
-
-
-/**
-    \class tsPacket
-*/
-class tsPacket : public ADMMpegPacket
-{
-protected:
-    uint8_t             getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
-public:
-                        tsPacket(void);
-    virtual            ~tsPacket();
-    virtual bool        open(const char *filenames,FP_TYPE append);
-    virtual bool        close(void);
-    virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
-    virtual uint64_t    getPos(void);
-    virtual bool        setPos(uint64_t pos);
-};
-/**
-    \class tsPacketLinear
-*/
-#define ADM_PACKET_LINEAR 10*1024
-
-class tsPacketLinear : public tsPacket
-{
-protected:
-        uint8_t  myPid;
-        uint64_t startAt;
-        uint32_t bufferLen;
-        uint64_t bufferPts;
-        uint64_t bufferDts;
-        uint32_t bufferIndex;
-        uint8_t  buffer[ADM_PACKET_LINEAR];
-        bool     eof;
-        bool     refill(void);
-        uint64_t oldStartAt;
-        uint32_t oldBufferLen;
-        uint64_t oldBufferPts;
-        uint64_t oldBufferDts;
-        uint32_t consumed;
-
-public:
-                tsPacketLinear(uint8_t pid);
-                ~tsPacketLinear();
-        uint32_t getConsumed(void);
-        uint8_t  readi8();
-        uint16_t readi16();
-        uint32_t readi32();
-        bool     sync(uint8_t *pid);
-        bool    read(uint32_t len, uint8_t *buffer);
-        bool    forward(uint32_t v);
-        bool    stillOk(void) {return !eof;};
-        bool    getInfo(dmxPacketInfo *info);
-        bool    seek(uint64_t packetStart, uint32_t offset);
-        bool    changePid(uint32_t pid) ;
-};
-/**
-    \class tsPacketLinearTracker
-*/
-typedef struct
-{
-    uint32_t count;
-    uint32_t size;
-    
-    uint64_t startAt;
-    uint32_t startCount;
-    uint32_t startSize;
-    uint64_t startDts;
-}packetStats;
-
-class tsPacketLinearTracker : public tsPacketLinear
-{
-protected:
-      packetStats stats[256];
-
-public:
-                        tsPacketLinearTracker(uint8_t pid);
-                        ~tsPacketLinearTracker();
-         packetStats    *getStat(int intdex);
-         bool           resetStats(void);
-virtual  bool           getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
-};
-
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt	2009-04-07 05:40:06 UTC (rev 4727)
@@ -8,7 +8,6 @@
 dmx_io.cpp
 dmxPacket.cpp
 dmxPSPacket.cpp
-dmxTSPacket.cpp
 )	
 #*************************************************
 ADD_LIBRARY(ADM_coreDemuxerMpeg SHARED ${ADMcoreDemuxerMpeg_SRCS})

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -1,653 +0,0 @@
-/**
-    \file dmxtsPacket
-    \brief Packet demuxer for mpeg TS
-    copyright            : (C) 2005-2009 by mean
-    email                : fixounet at free.fr
-        
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "ADM_default.h"
-
-#include "dmxTSPacket.h"
-#include "dmx_mpegstartcode.h"
-
-/**
-    \fn tsPacket
-    \brief ctor
-*/
-tsPacket::tsPacket(void) 
-{
-
-}
-/**
-    \fn tsPacket
-    \brief dtor
-*/
-tsPacket::~tsPacket()
-{
-    close();
-}
-/**
-    \fn open
-    \brief dtor
-*/
-bool tsPacket::open(const char *filenames,FP_TYPE append)
-{
-    _file=new fileParser();
-    if(!_file->open(filenames,&append))
-    {
-        printf("[DmxPS] cannot open %s\n",filenames);
-        delete _file;
-        _file=NULL;
-        return false;
-    }
-    _size=_file->getSize();
-    return true;
-}
-/**
-    \fn close
-    \brief dtor
-*/
-bool tsPacket::close(void)
-{
-    if(_file)
-    {
-        delete _file;
-        _file=NULL;
-    }
-    return true;
-}
-/**
-    \fn getPos
-*/
-uint64_t    tsPacket::getPos(void)
-{
-    return 0;
-}
-/**
-    \fn setPos
-*/
-
-bool    tsPacket::setPos(uint64_t pos)
-{
-    if(!_file->setpos(pos))
-    {
-        printf("[tsPacket] Cannot seek to %"LLX"\n", pos);
-        return false;
-    }
-}
-
-/**
-    \fn getPacket
-*/      
-bool        tsPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)
-{
-uint32_t globstream,len;
-uint8_t  stream,substream;
-uint64_t pts,dts;
-        // Resync on our stream
-_again2:
-        *pid=0;
-        if(!_file->sync(&stream)) 
-        {
-                uint64_t pos;
-                _file->getpos(&pos);
-                printf("[DmxPS] cannot sync  at "LLU"/"LLU"\n",pos,_size);
-                return false;
-        }
-// Position of this packet just before startcode
-        _file->getpos(startAt);
-        *startAt-=4;
-// Handle out of band stuff        
-        if(stream==PACK_START_CODE) 
-        {
-        		_file->forward(8);
-        		goto _again2;
-        }
-        if( stream==PADDING_CODE ||stream==SYSTEM_START_CODE) 
-        {
-                        len=_file->read16i();
-                        //printf("\tForwarding %lu bytes\n",len);
-        		_file->forward(len);
-        		goto _again2;
-        }
-        // Only keep relevant parts
-        // i.e. a/v : C0 C9 E0 E9
-        // subs 20-29
-        // private data 1/2
-#define INSIDE(min,max) (stream>=min && stream<max)
-        if(!(  INSIDE(0xC0,0xC9) || INSIDE(0xE0,0xE9) || INSIDE(0x20,0x29) || stream==PRIVATE_STREAM_1 || stream==PRIVATE_STREAM_2
-        			)) goto _again2;
-        // Ok we got a candidate
-        if(!getPacketInfo(stream,&substream,&len,&pts,&dts))   
-        {
-                goto _again2;
-        }
-        
-        //printf("Main Stream :%x substream :%x\n",stream,substream);
-        if(stream==PRIVATE_STREAM_1) globstream=0xFF00+substream;
-                else                 globstream=stream;
-
-        *pid=globstream;
-        *opts=pts;
-        *odts=dts;
-        *packetSize=len;
-        if(len>     maxSize)
-        {
-                printf("[DmxPS] Packet too big %d vs %d\n",len,maxSize);
-        }
-        if(!_file->read32(len,buffer)) return false;
-        return true;
-       
-}
-/**
-
-    \fn getPacketInfo
-    \brief       Retrieve info about the packet we just met.It is assumed that parser is just after the packet startcode
-
-*/
-
-uint8_t tsPacket::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
-{
-
-//uint32_t un ,deux;
-uint64_t size=0;
-uint8_t c,d;
-uint8_t align=0;
-                        
-                *substream=0xff;
-                *opts=ADM_NO_PTS;
-                *odts=ADM_NO_PTS;
-                
-                                        
-                size=_file->read16i();
-                if((stream==PADDING_CODE) || 
-                	 (stream==PRIVATE_STREAM_2)
-                        ||(stream==SYSTEM_START_CODE) //?
-                        ) // special case, no header
-                        {
-                                *olen=size;      
-                                return 1;
-                        }
-                                
-                        //      remove padding if any                                           
-        
-                while((c=_file->read8i()) == 0xff) 
-                {
-                        size--;
-                }
-//----------------------------------------------------------------------------
-//-------------------------------MPEG-2 PES packet style----------------------
-//----------------------------------------------------------------------------
-                if(((c&0xC0)==0x80))
-                {
-                        uint32_t ptsdts,len;
-                        //printf("\n mpeg2 type \n");
-                        //_muxTypeMpeg2=1;
-                        // c= copyright and stuff       
-                        //printf(" %x align\n",c);      
-                        if(c & 4) align=1;      
-                        c=_file->read8i();     // PTS/DTS
-                        //printf("%x ptsdts\n",c
-                        ptsdts=c>>6;
-                        // header len
-                        len=_file->read8i();
-                        size-=3;  
-
-                        switch(ptsdts)
-                        {
-                                case 2: // PTS=1 DTS=0
-                                        if(len>=5)
-                                        {
-                                                uint64_t pts1,pts2,pts0;
-                                                //      printf("\n PTS10\n");
-                                                        pts0=_file->read8i();  
-                                                        pts1=_file->read16i(); 
-                                                        pts2=_file->read16i();                 
-                                                        len-=5;
-                                                        size-=5;
-                                                        *opts=(pts1>>1)<<15;
-                                                        *opts+=pts2>>1;
-                                                        *opts+=(((pts0&6)>>1)<<30);
-                                        }
-                                        break;
-                                case 3: // PTS=1 DTS=1
-                                                #define PTS11_ADV 10 // nut monkey
-                                                if(len>=PTS11_ADV)
-                                                {
-                                                        uint32_t skip=PTS11_ADV;
-                                                        uint64_t pts1,pts2,dts,pts0;
-                                                                //      printf("\n PTS10\n");
-                                                                pts0=_file->read8i();  
-                                                                pts1=_file->read16i(); 
-                                                                pts2=_file->read16i(); 
-                                                                                        
-                                                                *opts=(pts1>>1)<<15;
-                                                                *opts+=pts2>>1;
-                                                                *opts+=(((pts0&6)>>1)<<30);
-                                                                pts0=_file->read8i();  
-                                                                pts1=_file->read16i(); 
-                                                                pts2=_file->read16i();                 
-                                                                dts=(pts1>>1)<<15;
-                                                                dts+=pts2>>1;
-                                                                dts+=(((pts0&6)>>1)<<30);
-                                                                len-=skip;
-                                                                size-=skip;
-                                                                *odts=dts;
-                                                                        //printf("DTS: %lx\n",dts);                
-                                                   }
-                                                   break;               
-                                case 1:
-                                                return 0;//ADM_assert(0); // forbidden !
-                                                break;
-                                case 0: 
-                                                // printf("\n PTS00\n");
-                                                break; // no pts nor dts
-                                                                                
-                                                            
-                        }  
-// Extension bit        
-// >stealthdave<                                
-
-                        // Skip remaining headers if any
-                        if(len) 
-                        {
-                                _file->forward(len);
-                                size=size-len;
-                        }
-                                
-                if(stream==PRIVATE_STREAM_1)
-                {
-                        if(size>5)
-                        {
-                        // read sub id
-                               *substream=_file->read8i();
-  //                    printf("\n Subid : %x",*subid);
-                                switch(*substream)
-                                {
-                                // DTS
-                                        case 0x88:case 0x89:case 0x8A:case 0x8B:
-                                        
-                                                *substream=*substream-0x48;
-                                                break;
-
-                                //AC3
-                                        case 0x80:case 0x81:case 0x82:case 0x83:
-                                        case 0x84:case 0x85:case 0x86:case 0x87:
-                                                *substream=*substream-0x80;
-                                                break;
-                                // PCM
-                                        case 0xA0:case 0xA1:case 0xa2:case 0xa3:
-                                        case 0xA4:case 0xA5:case 0xa6:case 0xa7:
-                                                // we have an additionnal header
-                                                // of 3 bytes
-                                                _file->forward(3);
-                                                size-=3;
-                                                break;
-                                // Subs
-                                case 0x20:case 0x21:case 0x22:case 0x23:
-                                case 0x24:case 0x25:case 0x26:case 0x27:
-                                                break;
-                             
-                                default:
-                                                doNoComplainAnyMore++;
-                                                if(doNoComplainAnyMore<10)
-                                                    printf("[DmxPS]Unkown substream %x\n",*substream);
-                                                *substream=0xff;
-                                }
-                                // skip audio header (if not sub)
-                                if(*substream>0x26 || *substream<0x20)
-                                {
-                                        _file->forward(3);
-                                        size-=3;
-                                }
-                                size--;
-                        }
-                }
-               //    printf(" pid %x size : %x len %x\n",sid,size,len);
-                *olen=size;
-                return 1;
-        }
-//----------------------------------------------------------------------------------------------                
-//-------------------------------MPEG-1 PES packet style----------------------                                  
-//----------------------------------------------------------------------------------------------                                        
-           if(0) //_muxTypeMpeg2)
-                {
-                        printf("[DmxPS]*** packet type 1 inside type 2 ?????*****\n");
-                        return 0; // mmmm                       
-                }
-          // now look at  STD buffer size if present
-          // 01xxxxxxxxx
-          if ((c>>6) == 1) 
-          {       // 01
-                        size-=2;
-                        _file->read8i();                       // skip one byte
-                        c=_file->read8i();   // then another
-           }                       
-           // PTS/DTS
-           switch(c>>4)
-           {
-                case 2:
-                {
-                        // 0010 xxxx PTS only
-                        uint64_t pts1,pts2,pts0;
-                                        size -= 4;
-                                        pts0=(c>>1) &7;
-                                        pts1=_file->read16i()>>1;
-                                        pts2=_file->read16i()>>1;
-                                        *opts=pts2+(pts1<<15)+(pts0<<30);
-                                        break;
-                  }
-                  case 3:
-                  {               // 0011 xxxx
-                        uint64_t pts1,pts2,pts0;
-                                        size -= 9;
-                                                                        
-                                        pts0=(c>>1) &7;
-                                        pts1=_file->read16i()>>1;
-                                        pts2=_file->read16i()>>1;
-                                        *opts=pts2+(pts1<<15)+(pts0<<30);
-                                        _file->forward(5);
-                   }                                                               
-                   break;
-                   
-                case 1:
-                        // 0001 xxx             
-                        // PTSDTS=01 not allowed                        
-                                return 0;
-                                break; 
-                }
-                                                                
-
-                if(!align)      
-                        size--;         
-        *olen=size;
-        return 1;
-}
-//************************************************************************************
-
-#define ADM_PACKET_LINEAR 10*1024
-/**
-    \fn tsPacket
-*/
-tsPacketLinear::tsPacketLinear(uint8_t pid) : tsPacket()
-{
-    oldStartAt=startAt=0xfffffff;
-    oldBufferLen=bufferLen=0;
-    bufferIndex=0;
-    myPid=pid;
-    eof=false;
-}
-/**
-    \fn ~tsPacket
-*/
-tsPacketLinear::~tsPacketLinear() 
-{
-}
-/**
-    \fn refill
-*/
-bool tsPacketLinear::refill(void) 
-{
-// In case a startcode spawns across 2 packets
-// we have to keep track of the old one
-        oldBufferDts=bufferDts;
-        oldBufferPts=bufferPts;
-        oldStartAt=startAt;
-        oldBufferLen=bufferLen;
-        if( false== getPacketOfType(myPid,ADM_PACKET_LINEAR, &bufferLen,&bufferPts,&bufferDts,buffer,&startAt)) 
-        {
-            printf("[tsPacketLinear] Refill failed for pid :%x\n",myPid);
-            bufferIndex=bufferLen=0;
-            return false;
-        }
-        //printf("Refill : At :%"LLX" size :%"LD"\n",startAt,bufferLen);
-        bufferIndex=0;
-        return true;
-}
-/**
-    \fn readi8
-*/
-uint8_t tsPacketLinear::readi8(void)
-{
-    consumed++;
-    if(bufferIndex<bufferLen)
-    {
-        return buffer[bufferIndex++];
-    }
-    if(false==refill()) 
-    {
-        eof=1;
-        return 0;
-    }
-    ADM_assert(bufferLen);
-    bufferIndex=1;
-    return buffer[0];
-    
-}
-/**
-    \fn readi16
-*/
-uint16_t tsPacketLinear::readi16(void)
-{
-    if(bufferIndex+1<bufferLen)
-    {
-        uint16_t v=(buffer[bufferIndex]<<8)+buffer[bufferIndex+1];;
-        bufferIndex+=2;
-        consumed+=2;
-        return v;
-    }
-    return (readi8()<<8)+readi8();
-}
-/**
-    \fn readi32
-*/
-uint32_t tsPacketLinear::readi32(void)
-{
-    if(bufferIndex+3<bufferLen)
-    {
-        uint8_t *p=buffer+bufferIndex;
-        uint32_t v=(p[0]<<24)+(p[1]<<16)+(p[2]<<8)+p[3];
-        bufferIndex+=4;
-        consumed+=4;
-        return v;
-    }
-    return (readi16()<<16)+readi16();
-}
-/**
-    \fn forward
-*/
-bool tsPacketLinear::forward(uint32_t v)
-{
-next:
- uint32_t delta=bufferLen-bufferIndex;
-    if(v>100*1000)
-    {
-        ADM_assert(0);
-    }
-    if(v<=delta)
-    {
-        bufferIndex+=v;
-        consumed+=v;
-        return true;
-    }
-    // v>delta
-    v-=delta;
-    if(!refill()) return false;
-    goto next;
-}
-
-/**
-    \fn bool    read(uint32_t len, uint8_t *buffer);
-    \brief
-*/
-bool    tsPacketLinear::read(uint32_t len, uint8_t *out)
-{
-    // Enough already ?
-    while(len)
-    {
-        uint32_t avail=bufferLen-bufferIndex;
-        uint32_t chunk=avail;
-        if(chunk>len) chunk=len;
-#if 0
-        printf("len:%ld avail:%ld chunk %ld index:%d size:%d\n",
-                len,avail,chunk,bufferIndex,bufferLen);
-#endif
-        memcpy(out,buffer+bufferIndex,chunk);
-        bufferIndex+=chunk;
-        len-=chunk;
-        out+=chunk;
-        consumed+=chunk;
-        if(bufferIndex==bufferLen)
-        {
-            //printf("Refill\n");
-            if(false==refill()) return false;
-        }
-    }
-    return true;
-}
-/**
-        \fn getInfo
-        \brief Returns info about the current (or previous if it spawns) packet.
-            It is expected that the caller will do -4 to the index to get the start of the 
-            startCode
-*/
-bool    tsPacketLinear::getInfo(dmxPacketInfo *info)
-{
-    if(bufferIndex<4)
-    {
-        info->startAt=this->oldStartAt;
-        info->offset=oldBufferLen+bufferIndex;
-        info->pts=oldBufferPts;
-        info->dts=oldBufferDts;
-
-    }else
-    {
-        info->startAt=this->startAt;
-        info->offset=bufferIndex;
-        info->pts=bufferPts;
-        info->dts=bufferDts;
-    }
-    return true;
-
-};
-/**
-    \fn seek
-    \brief Async jump
-*/
-bool    tsPacketLinear::seek(uint64_t packetStart, uint32_t offset)
-{
-    if(!_file->setpos(packetStart))
-    {
-        printf("[tsPacket] Cannot seek to %"LLX"\n",packetStart);
-        return 0;
-    }
-    if(!refill())
-    {
-        printf("[tsPacketLinear] Seek to %"LLX":%"LX" failed\n",packetStart,offset);
-        return false;
-    }
-    ADM_assert(offset<bufferLen);
-    bufferIndex=offset;
-    
-    return true;
-}
-/**
-    \fn getConsumed
-    \brief returns the # of bytes consumed since the last call
-*/
-uint32_t tsPacketLinear::getConsumed(void)
-{
-    uint32_t c=consumed;
-    consumed=0;
-    return c;
-}
-/**
-    \fn changePid
-    \brief change the pid of the stream we read (used when probing all tracks)
-*/
-bool    tsPacketLinear::changePid(uint32_t pid) 
-{
-    myPid=(pid&0xff);
-    bufferLen=bufferIndex=0;
-    return true;
-}
-/* ********************************************************* */
-/**
-    \fn tsPacketLinearTracker
-*/
- tsPacketLinearTracker::tsPacketLinearTracker(uint8_t pid)  : tsPacketLinear(pid)
-{
-   resetStats();
-}
-/**
-    \fn ~tsPacketLinearTracker
-*/
-tsPacketLinearTracker::~tsPacketLinearTracker()
-{
-
-    
-}
-/**
-        \fn getStat
-*/
-packetStats    *tsPacketLinearTracker::getStat(int index)
-{   
-    if(index<0 || index>=256) ADM_assert(0);
-    return stats+index;
-}
-/**
-    \fn getPacketgetPacketOfType
-    \brief Keep track of all the packets we have seen so far.
-    Usefull to detect the streams present and to look up the PTS/DTS of audio streams for the audio part of the index
-*/
-bool           tsPacketLinearTracker::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
-{
- bool xit=false;
-    uint8_t tmppid;
-    while(1)
-    {
-        if(true!=getPacket(maxSize,&tmppid,packetSize,pts,dts,buffer,startAt))
-                return false;
-        else
-        {
-                // Update 
-                ADM_assert(tmppid<0x100);
-                packetStats *p=stats+tmppid;
-                uint64_t ts=*pts;
-                if(ts==ADM_NO_PTS) ts=*dts;
-                if(ts!=ADM_NO_PTS)
-                {
-                    p->startCount=p->count;
-                    p->startAt=*startAt;
-                    p->startSize=p->size;
-                    p->startDts=ts;
-                }
-                p->count++;
-                p->size+=*packetSize;
-                if(tmppid==pid) return true;
-        }
-    }
-    return false;
-}
-/**
-    \fn resetStats
-*/
-bool           tsPacketLinearTracker::resetStats(void)
-{
-    memset(stats,0,sizeof(stats));
-    for(int i=0;i<256;i++)
-    {
-        packetStats *p=stats+i;
-        p->startDts=ADM_NO_PTS;
-    }
-}
-//EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -18,7 +18,7 @@
 #include "fourcc.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_indexFile.h"
-#include "ADM_ps.h"
+#include "ADM_ts.h"
 
 #include <math.h>
 
@@ -29,7 +29,7 @@
       \brief open the flv file, gather infos and build index(es).
 */
 
-uint8_t psHeader::open(const char *name)
+uint8_t tsHeader::open(const char *name)
 {
     char idxName[strlen(name)+4];
     bool r=false;
@@ -84,16 +84,16 @@
     if(_videostream.dwLength)_isvideopresent=1;
 //***********
     
-    psPacket=new psPacketLinear(0xE0);
-    if(psPacket->open(name,appendType)==false) 
+    tsPacket=new tsPacketLinear(0xE0);
+    if(tsPacket->open(name,appendType)==false) 
     {
-        printf("psDemux] Cannot psPacket open the file\n");
+        printf("psDemux] Cannot tsPacket open the file\n");
         goto abt;
     }
     r=true;
     for(int i=0;i<listOfAudioTracks.size();i++)
     {
-        ADM_psTrackDescriptor *desc=listOfAudioTracks[i];
+        ADM_tsTrackDescriptor *desc=listOfAudioTracks[i];
         ADM_audioStream *audioStream=ADM_audioCreateStream(&desc->header,desc->access);
         if(!audioStream)
         {
@@ -112,7 +112,7 @@
         \fn getVideoDuration
         \brief Returns duration of video in us
 */
-uint64_t psHeader::getVideoDuration(void)
+uint64_t tsHeader::getVideoDuration(void)
 {
     float f;
         f=1000*1000*1000;
@@ -127,7 +127,7 @@
     \fn getAudioInfo
     \brief returns wav header for stream i (=0)
 */
-WAVHeader *psHeader::getAudioInfo(uint32_t i )
+WAVHeader *tsHeader::getAudioInfo(uint32_t i )
 {
         if(!listOfAudioTracks.size()) return NULL;
       ADM_assert(i<listOfAudioTracks.size());
@@ -138,7 +138,7 @@
    \fn getAudioStream
 */
 
-uint8_t   psHeader::getAudioStream(uint32_t i,ADM_audioStream  **audio)
+uint8_t   tsHeader::getAudioStream(uint32_t i,ADM_audioStream  **audio)
 {
     if(!listOfAudioTracks.size())
     {
@@ -153,7 +153,7 @@
     \fn getNbAudioStreams
 
 */
-uint8_t   psHeader::getNbAudioStreams(void)
+uint8_t   tsHeader::getNbAudioStreams(void)
 {
  
   return listOfAudioTracks.size(); 
@@ -162,7 +162,7 @@
     __________________________________________________________
 */
 
-void psHeader::Dump(void)
+void tsHeader::Dump(void)
 {
  
 }
@@ -171,7 +171,7 @@
     \brief cleanup
 */
 
-uint8_t psHeader::close(void)
+uint8_t tsHeader::close(void)
 {
     // Destroy index
     while(ListOfFrames.size())
@@ -179,30 +179,30 @@
         delete ListOfFrames[0];
         ListOfFrames.erase(ListOfFrames.begin());
     }
-    if(psPacket)
+    if(tsPacket)
     {
-        psPacket->close();
-        delete psPacket;
-        psPacket=NULL;
+        tsPacket->close();
+        delete tsPacket;
+        tsPacket=NULL;
     }
 }
 /**
-    \fn psHeader
+    \fn tsHeader
     \brief constructor
 */
 
- psHeader::psHeader( void ) : vidHeader()
+ tsHeader::tsHeader( void ) : vidHeader()
 { 
     interlaced=false;
     lastFrame=0xffffffff;
     
 }
 /**
-    \fn psHeader
+    \fn tsHeader
     \brief destructor
 */
 
- psHeader::~psHeader(  )
+ tsHeader::~tsHeader(  )
 {
   close();
 }
@@ -213,7 +213,7 @@
     \brief Returns timestamp in us of frame "frame" (PTS)
 */
 
-  uint8_t  psHeader::setFlag(uint32_t frame,uint32_t flags)
+  uint8_t  tsHeader::setFlag(uint32_t frame,uint32_t flags)
 {
    
      uint32_t f=2;
@@ -228,7 +228,7 @@
     \brief Returns timestamp in us of frame "frame" (PTS)
 */
 
-uint32_t psHeader::getFlags(uint32_t frame,uint32_t *flags)
+uint32_t tsHeader::getFlags(uint32_t frame,uint32_t *flags)
 {
     if(frame>=ListOfFrames.size()) return 0;
     uint32_t f=ListOfFrames[frame]->type;
@@ -245,7 +245,7 @@
     \fn getTime
     \brief Returns timestamp in us of frame "frame" (PTS)
 */
-uint64_t psHeader::getTime(uint32_t frame)
+uint64_t tsHeader::getTime(uint32_t frame)
 {
    if(frame>=ListOfFrames.size()) return 0;
     uint64_t pts=ListOfFrames[frame]->pts;
@@ -255,7 +255,7 @@
     \fn timeConvert
     \brief FIXME
 */
-uint64_t psHeader::timeConvert(uint64_t x)
+uint64_t tsHeader::timeConvert(uint64_t x)
 {
     if(x==ADM_NO_PTS) return ADM_NO_PTS;
     x=x-ListOfFrames[0]->dts;
@@ -268,14 +268,14 @@
         \fn getFrame
 */
 
-uint8_t  psHeader::getFrame(uint32_t frame,ADMCompressedImage *img)
+uint8_t  tsHeader::getFrame(uint32_t frame,ADMCompressedImage *img)
 {
     if(frame>=ListOfFrames.size()) return 0;
     dmxFrame *pk=ListOfFrames[frame];
     if(frame==(lastFrame+1) && pk->type!=1)
     {
         lastFrame++;
-        bool r=psPacket->read(pk->len,img->data);
+        bool r=tsPacket->read(pk->len,img->data);
              img->dataLength=pk->len;
              img->demuxerFrameNo=frame;
              img->demuxerDts=pk->dts;
@@ -286,8 +286,8 @@
     }
     if(pk->type==1)
     {
-        if(!psPacket->seek(pk->startAt,pk->index)) return false;
-         bool r=psPacket->read(pk->len,img->data);
+        if(!tsPacket->seek(pk->startAt,pk->index)) return false;
+         bool r=tsPacket->read(pk->len,img->data);
              img->dataLength=pk->len;
              img->demuxerFrameNo=frame;
              img->demuxerDts=pk->dts;
@@ -304,7 +304,7 @@
 /**
         \fn getExtraHeaderData
 */
-uint8_t  psHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
+uint8_t  tsHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
 {
                 *len=0; //_tracks[0].extraDataLen;
                 *data=NULL; //_tracks[0].extraData;
@@ -315,7 +315,7 @@
       \fn getFrameSize
       \brief return the size of frame frame
 */
-uint8_t psHeader::getFrameSize (uint32_t frame, uint32_t * size)
+uint8_t tsHeader::getFrameSize (uint32_t frame, uint32_t * size)
 {
     if(frame>=ListOfFrames.size()) return 0;
     *size=ListOfFrames[frame]->len;
@@ -325,7 +325,7 @@
 /**
     \fn getPtsDts
 */
-bool    psHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+bool    tsHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
 {
     if(frame>=ListOfFrames.size()) return false;
     dmxFrame *pk=ListOfFrames[frame];
@@ -337,7 +337,7 @@
 /**
         \fn setPtsDts
 */
-bool    psHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+bool    tsHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
 {
       if(frame>=ListOfFrames.size()) return false;
     dmxFrame *pk=ListOfFrames[frame];

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-07 05:40:06 UTC (rev 4727)
@@ -1,7 +1,7 @@
 /***************************************************************************
-                         ADM_PS
+                         ADM_PT
                              -------------------
-    begin                : Mon Jun 3 2002
+    
     copyright            : (C) 2002 by mean
     email                : fixounet at free.fr
  ***************************************************************************/
@@ -17,14 +17,14 @@
  
 
 
-#ifndef ADM_PS_H
-#define ADM_PS_H
+#ifndef ADM_TS_H
+#define ADM_TS_H
 
 #include "ADM_Video.h"
 #include "ADM_audioStream.h"
 #include "dmx_io.h"
 #include "ADM_indexFile.h"
-#include "dmxPSPacket.h"
+#include "dmxTSPacket.h"
 #include <vector>
 using std::vector;
 /**
@@ -49,24 +49,24 @@
       uint64_t dts;
       uint32_t size;
 
-}ADM_psAudioSeekPoint;
+}ADM_tsAudioSeekPoint;
 
 /**
     \fn ADM_psAccess
 */
-class ADM_psAccess : public ADM_audioAccess
+class ADM_tsAccess : public ADM_audioAccess
 {
 protected:
                 
-                psPacket        demuxer;
+                tsPacket        demuxer;
                 uint8_t         pid;
                 uint64_t        dtsOffset;
                 
 public:
                 bool            setTimeOffset(uint64_t of) {dtsOffset=of;return true;}
-                vector          <ADM_psAudioSeekPoint >seekPoints;
-                                  ADM_psAccess(const char *name,uint8_t pid,bool append); 
-                virtual           ~ADM_psAccess();
+                vector          <ADM_tsAudioSeekPoint >seekPoints;
+                                  ADM_tsAccess(const char *name,uint8_t pid,bool append); 
+                virtual           ~ADM_tsAccess();
                                     /// Hint, the stream is pure CBR (AC3,MP2,MP3)
                 virtual bool      isCBR(void) { return true;}
                                     /// Return true if the demuxer can seek in time
@@ -92,18 +92,18 @@
 /**
     \class ADM_psTrackDescriptor
 */
-class ADM_psTrackDescriptor
+class ADM_tsTrackDescriptor
 {
 public:
         ADM_audioStream *stream;
-        ADM_psAccess    *access;
+        ADM_tsAccess    *access;
         WAVHeader       header;
-        ADM_psTrackDescriptor()
+        ADM_tsTrackDescriptor()
             {
                 stream=NULL;
                 access=NULL;
             }
-        ~ADM_psTrackDescriptor()
+        ~ADM_tsTrackDescriptor()
             {
                 if(stream) delete stream;
                 stream=NULL;
@@ -119,7 +119,7 @@
     \brief mpeg ps demuxer
 
 */
-class psHeader         :public vidHeader
+class tsHeader         :public vidHeader
 {
   protected:
     
@@ -134,18 +134,18 @@
     std::vector <dmxFrame *> ListOfFrames;      
     fileParser      parser;
     uint32_t       lastFrame;
-    psPacketLinear *psPacket;
+    tsPacketLinear *tsPacket;
     uint64_t        timeConvert(uint64_t x);
     bool            updatePtsDts(void);
 protected:
-    vector <ADM_psTrackDescriptor *>listOfAudioTracks;
+    vector <ADM_tsTrackDescriptor *>listOfAudioTracks;
   public:
 
 
     virtual   void          Dump(void);
 
-            psHeader( void ) ;
-   virtual  ~psHeader(  ) ;
+            tsHeader( void ) ;
+   virtual  ~tsHeader(  ) ;
 // AVI io
     virtual uint8_t  open(const char *name);
     virtual uint8_t  close(void) ;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -20,7 +20,7 @@
 #include <string.h>
 #include <math.h>
 
-#include "ADM_ps.h"
+#include "ADM_ts.h"
 
 #if 0
     #define aprintf printf
@@ -29,9 +29,9 @@
 #endif
 
 /**
-    \fn ADM_psAccess
+    \fn ADM_tsAccess
 */
-ADM_psAccess::ADM_psAccess(const char *name,uint8_t pid,bool append)
+ADM_tsAccess::ADM_tsAccess(const char *name,uint8_t pid,bool append)
 {
 FP_TYPE fp=FP_DONT_APPEND;
         if(append) fp=FP_APPEND;
@@ -40,9 +40,9 @@
 }
 
 /**
-    \fn ~ADM_psAccess
+    \fn ~ADM_tsAccess
 */
-ADM_psAccess::~ADM_psAccess()
+ADM_tsAccess::~ADM_tsAccess()
 {
     demuxer.close();
 }
@@ -50,9 +50,9 @@
     \fn push
     \brief add a seek point.
 */
-bool      ADM_psAccess::push(uint64_t at, uint64_t dts,uint32_t size)
+bool      ADM_tsAccess::push(uint64_t at, uint64_t dts,uint32_t size)
 {
-ADM_psAudioSeekPoint s;
+ADM_tsAudioSeekPoint s;
             s.position=at;
             s.dts=dts;
             s.size=size;
@@ -62,7 +62,7 @@
 /**
     \fn getLength
 */
-uint32_t  ADM_psAccess::getLength(void)
+uint32_t  ADM_tsAccess::getLength(void)
 {
   return (seekPoints[seekPoints.size()-1].size);
 
@@ -70,7 +70,7 @@
 /**
     \fn getDurationInUs
 */
-uint64_t  ADM_psAccess::getDurationInUs(void)
+uint64_t  ADM_tsAccess::getDurationInUs(void)
 {
     // Take last seek point; should be accurate enough
     return timeConvert(seekPoints[seekPoints.size()-1].dts);
@@ -79,7 +79,7 @@
     \fn goToTime
     \brief Rememember seekPoint.dts time is already scaled and in us
 */                              
-bool      ADM_psAccess::goToTime(uint64_t timeUs)
+bool      ADM_tsAccess::goToTime(uint64_t timeUs)
 {
     // Convert time in us to scaled 90 kHz tick
     
@@ -107,7 +107,7 @@
     \fn timeConvert
     \brief Convert time in ticks raw from the stream to avidemux time in us starting from the beginning of the file
 */
-uint64_t ADM_psAccess::timeConvert(uint64_t x)
+uint64_t ADM_tsAccess::timeConvert(uint64_t x)
 {
     if(x==ADM_NO_PTS) return ADM_NO_PTS;
     x=x-dtsOffset;
@@ -119,7 +119,7 @@
 /**
     \fn getPacket
 */
-bool      ADM_psAccess::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
+bool      ADM_tsAccess::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
 {
 uint64_t p,d,start;
     if(false==demuxer.getPacketOfType(pid,maxSize,size,&p,&d,buffer,&start)) return false;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -17,8 +17,8 @@
 
 #include "ADM_default.h"
 #include "ADM_audiodef.h"
-#include "dmxPSPacket.h"
-#include "ADM_psAudioProbe.h"
+#include "dmxTSPacket.h"
+#include "ADM_tsAudioProbe.h"
 //
 #include "ADM_a52info.h"
 #include "ADM_mp3info.h"
@@ -35,22 +35,22 @@
 #define LPCM_AUDIO_VALUE 0xA0
 #define DTS_AC3_AUDIO_VALUE 0x00
 
-static bool addAudioTrack(int pid, listOfPsAudioTracks *list, psPacketLinearTracker *p);
-static bool psCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize);
+static bool addAudioTrack(int pid, listOfTsAudioTracks *list, tsPacketLinearTracker *p);
+static bool tsCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize);
 /**
     \fn listOfPsAudioTracks
     \brief returns a list of audio track found, null if none found
 
 */
-listOfPsAudioTracks *psProbeAudio(const char *fileName)
+listOfTsAudioTracks *tsProbeAudio(const char *fileName)
 {
     uint32_t size;
     uint64_t dts,pts,startAt;
     uint8_t buffer[PACKET_PROBE_SIZE];
     uint64_t fileSize;
 
-    listOfPsAudioTracks *tracks=new listOfPsAudioTracks;
-    psPacketLinearTracker *packet=new psPacketLinearTracker(0xE0);
+    listOfTsAudioTracks *tracks=new listOfTsAudioTracks;
+    tsPacketLinearTracker *packet=new tsPacketLinearTracker(0xE0);
 
     printf("[MpegPS] Probing audio for %s\n",fileName);
 
@@ -98,7 +98,7 @@
     \brief gather information about audio & add audio track to the list
 
 */
-bool addAudioTrack(int pid, listOfPsAudioTracks *list, psPacketLinearTracker *p)
+bool addAudioTrack(int pid, listOfTsAudioTracks *list, tsPacketLinearTracker *p)
 {
 #define PROBE_ANALYZE_SIZE 6000 // Should be enough in all cases (need ~ 2 blocks)
 uint8_t audioBuffer[PROBE_ANALYZE_SIZE];
@@ -120,7 +120,7 @@
         int rd=PROBE_ANALYZE_SIZE;
         if(!p->read(PROBE_ANALYZE_SIZE,audioBuffer))
             return false;
-        psAudioTrackInfo *info=new psAudioTrackInfo;
+        tsAudioTrackInfo *info=new tsAudioTrackInfo;
         info->esID=pid;
         uint32_t fq,br,chan,off;
         switch(pid & 0xF0)
@@ -133,7 +133,7 @@
                             break;
             case MP2_AUDIO_VALUE: // MP2
                             {
-                                if(! psCheckMp2Audio(&(info->header),audioBuffer,rd))
+                                if(! tsCheckMp2Audio(&(info->header),audioBuffer,rd))
                                 {
                                     printf("[PsProbeAudio] Failed to get info on track :%x (MP2)\n",pid);
                                     goto er;
@@ -182,7 +182,7 @@
         \fn DestroyListOfPsAudioTracks
         \brief cleanly destroy it
 */
-bool DestroyListOfPsAudioTracks(listOfPsAudioTracks *list)
+bool DestroyListOfTsAudioTracks(listOfTsAudioTracks *list)
 {
     while( list->size())
     {
@@ -196,7 +196,7 @@
     \fn psCheckMp2Audio
     \brief Wait to have 2 audio packets to make sure it is not a false detection (that happens with mp2/mp3 audio)
 */
-bool psCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize)
+bool tsCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize)
 {
     MpegAudioInfo mpeg,first;
     uint32_t off2,off;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-07 05:40:06 UTC (rev 4727)
@@ -14,21 +14,21 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#ifndef ADM_PS_AUDIO_PROBE_H
-#define ADM_PS_AUDIO_PROBE_H
+#ifndef ADM_TS_AUDIO_PROBE_H
+#define ADM_TS_AUDIO_PROBE_H
 #include <vector>
 using std::vector;
 typedef struct
 {
     WAVHeader header;
     uint8_t   esID;
-}psAudioTrackInfo;
+}tsAudioTrackInfo;
 
-typedef vector <psAudioTrackInfo*> listOfPsAudioTracks;
+typedef vector <tsAudioTrackInfo*> listOfTsAudioTracks;
 
 /// Returns a list of audio tracks found in the file.
-listOfPsAudioTracks *psProbeAudio(const char *fileName);
-bool DestroyListOfPsAudioTracks(listOfPsAudioTracks *list);
+listOfTsAudioTracks *tsProbeAudio(const char *fileName);
+bool DestroyListOfTsAudioTracks(listOfTsAudioTracks *list);
 
 
 #endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsComputeTimeStamp.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -8,7 +8,7 @@
 #include "fourcc.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_indexFile.h"
-#include "ADM_ps.h"
+#include "ADM_ts.h"
 
 #include <math.h>
 
@@ -27,7 +27,7 @@
 TODO / FIXME : Handle PTS reordering 
 */
 
-bool psHeader::updatePtsDts(void)
+bool tsHeader::updatePtsDts(void)
 {
         uint64_t lastDts=0,lastPts=0,dtsIncrement=0;
 
@@ -39,7 +39,7 @@
         // at video
         for(int i=0;i<listOfAudioTracks.size();i++)
         {
-            vector          <ADM_psAudioSeekPoint > *seekPoints=&(listOfAudioTracks[i]->access->seekPoints);
+            vector          <ADM_tsAudioSeekPoint > *seekPoints=&(listOfAudioTracks[i]->access->seekPoints);
             uint64_t secondDts=(*seekPoints)[0].dts;
             uint64_t secondSize=(*seekPoints)[0].size;
             if(secondSize && listOfAudioTracks[i]->header.byterate)
@@ -53,7 +53,7 @@
                             else firstDts=secondDts-firstDts;
 
                 // Now add our seek point
-                ADM_psAudioSeekPoint sk;
+                ADM_tsAudioSeekPoint sk;
                 sk.dts=firstDts;
                 sk.size=0;
                 sk.position=ListOfFrames[0]->startAt;
@@ -105,8 +105,8 @@
         // Audio start at 0 too
         for(int i=0;i<listOfAudioTracks.size();i++)
         {
-            ADM_psTrackDescriptor *track=listOfAudioTracks[i];
-            ADM_psAccess    *access=track->access;
+            ADM_tsTrackDescriptor *track=listOfAudioTracks[i];
+            ADM_tsAccess    *access=track->access;
             access->setTimeOffset(startDts);
         }
 
@@ -155,8 +155,8 @@
         // convert to us for Audio tracks (seek points)
         for(int i=0;i<listOfAudioTracks.size();i++)
         {
-            ADM_psTrackDescriptor *track=listOfAudioTracks[i];
-            ADM_psAccess    *access=track->access;
+            ADM_tsTrackDescriptor *track=listOfAudioTracks[i];
+            ADM_tsAccess    *access=track->access;
             
             for(int j=0;j<access->seekPoints.size();j++)
             {

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -19,11 +19,11 @@
 #include "ADM_demuxerInternal.h"
 #include "fourcc.h"
 
-#include "dmxPSPacket.h"
+#include "dmxTSPacket.h"
 
 #include "avidemutils.h"
 #include "ADM_quota.h"
-#include "ADM_psAudioProbe.h"
+#include "ADM_tsAudioProbe.h"
 #include "DIA_working.h"
 
 static const char Type[5]={'X','I','P','B','P'};
@@ -68,7 +68,7 @@
     uint32_t frameType;
     uint32_t nbPics;
     indexerState state;
-    psPacketLinear *pkt;
+    tsPacketLinear *pkt;
     int32_t        nextOffset;
 }indexerData;
 
@@ -80,18 +80,18 @@
 }markType;
 
 /**
-    \class PsIndexer
+    \class TsIndexer
 */
-class PsIndexer
+class TsIndexer
 {
 protected:
         FILE *index;
-        psPacketLinearTracker *pkt;
-        listOfPsAudioTracks *audioTracks;
+        tsPacketLinearTracker *pkt;
+        listOfTsAudioTracks *audioTracks;
         DIA_workingBase  *ui;
 public:
-                PsIndexer(void);
-                ~PsIndexer();
+                TsIndexer(void);
+                ~TsIndexer();
         bool    run(const char *file);
         bool    writeVideo(PSVideo *video);
         bool    writeAudio(void);
@@ -100,22 +100,22 @@
 
 };
 /**
-      \fn psIndexer 
+      \fn TsIndexer 
       \brief main indexing loop for mpeg2 payload
 */
-uint8_t   psIndexer(const char *file)
+uint8_t   tsIndexer(const char *file)
 {
 bool r;
-    PsIndexer *dx=new PsIndexer;
+    TsIndexer *dx=new TsIndexer;
     r=dx->run(file);
     delete dx;
     return r;
 }
 
 /**
-    \fn PsIndexer
+    \fn TsIndexer
 */
-PsIndexer::PsIndexer(void)
+TsIndexer::TsIndexer(void)
 {
     index=NULL;
     pkt=NULL;
@@ -124,20 +124,20 @@
 }
 
 /**
-    \fn ~PsIndexer
+    \fn ~TsIndexer
 */
-PsIndexer::~PsIndexer()
+TsIndexer::~TsIndexer()
 {
     if(index) qfclose(index);
     if(pkt) delete pkt;
-    if( audioTracks) DestroyListOfPsAudioTracks(audioTracks);
+    if( audioTracks) DestroyListOfTsAudioTracks(audioTracks);
     if(ui) delete ui;
     ui=NULL;
 }
 /**
     \fn run
 */  
-bool PsIndexer::run(const char *file)
+bool TsIndexer::run(const char *file)
 {
 uint32_t temporal_ref,val;
 uint64_t fullSize;
@@ -158,9 +158,9 @@
         return false;
     }
     writeSystem(file,true);
-    pkt=new psPacketLinearTracker(0xE0);
+    pkt=new tsPacketLinearTracker(0xE0);
 
-    audioTracks=psProbeAudio(file);
+    audioTracks=tsProbeAudio(file);
     if(audioTracks)
     {
         for(int i=0;i<audioTracks->size();i++)
@@ -246,7 +246,7 @@
                           if(!seq_found)
                           { 
                                   continue;
-                                  printf("[psIndexer]No sequence start yet, skipping..\n");
+                                  printf("[TsIndexer]No sequence start yet, skipping..\n");
                           }
                           
                           val=pkt->readi16();
@@ -280,7 +280,7 @@
         qfprintf(index,"\n[End]\n");
         qfclose(index);
         index=NULL;
-        if(audioTracks) DestroyListOfPsAudioTracks( audioTracks);
+        if(audioTracks) DestroyListOfTsAudioTracks( audioTracks);
         audioTracks=NULL;
         delete pkt;
         pkt=NULL;
@@ -295,7 +295,7 @@
     If the beginning is not a pic, but a gop start for example, we had to add/remove those.
 
 */
-bool  PsIndexer::Mark(indexerData *data,dmxPacketInfo *info,markType update)
+bool  TsIndexer::Mark(indexerData *data,dmxPacketInfo *info,markType update)
 {
     int offset=data->nextOffset;
     data->nextOffset=0;
@@ -353,7 +353,7 @@
     \fn writeVideo
     \brief Write Video section of index file
 */
-bool PsIndexer::writeVideo(PSVideo *video)
+bool TsIndexer::writeVideo(PSVideo *video)
 {
     qfprintf(index,"[Video]\n");
     qfprintf(index,"Width=%d\n",video->w);
@@ -367,7 +367,7 @@
     \fn writeSystem
     \brief Write system part of index file
 */
-bool PsIndexer::writeSystem(const char *filename,bool append)
+bool TsIndexer::writeSystem(const char *filename,bool append)
 {
     qfprintf(index,"PSD1\n");
     qfprintf(index,"[System]\n");
@@ -380,7 +380,7 @@
     \fn     writeAudio
     \brief  Write audio headers
 */
-bool PsIndexer::writeAudio(void)
+bool TsIndexer::writeAudio(void)
 {
     if(!audioTracks) return false;
     qfprintf(index,"[Audio]\n");
@@ -388,7 +388,7 @@
     for(int i=0;i<audioTracks->size();i++)
     {
         char head[30];
-        psAudioTrackInfo *t=(*audioTracks)[i];
+        tsAudioTrackInfo *t=(*audioTracks)[i];
         sprintf(head,"Track%1d",i);
         qfprintf(index,"%s.pid=%x\n",head,t->esID);
         qfprintf(index,"%s.codec=%d\n",head,t->header.encoding);

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -14,19 +14,19 @@
  *                                                                         *
  ***************************************************************************/
 #include "ADM_default.h"
-#include "ADM_ps.h"
+#include "ADM_ts.h"
 #include "ADM_demuxerInternal.h"
 #include "fourcc.h"
 #include "avidemutils.h"
 
-ADM_DEMUXER_BEGIN( psHeader,
+ADM_DEMUXER_BEGIN( tsHeader,
                     1,0,0,
-                    "ps",
-                    "mpeg ps demuxer plugin (c) Mean 2007/2008"
+                    "ts",
+                    "mpeg ps demuxer plugin (c) Mean 2007/2009"
                 );
 
-static bool detectPs(const char *file);
-uint8_t   psIndexer(const char *file);
+static bool detectTs(const char *file);
+uint8_t   tsIndexer(const char *file);
 /**
     \fn Probe
 */
@@ -35,7 +35,7 @@
 {
 char index[strlen(fileName)+4];
 int count=0;
-    if(!detectPs(fileName))
+    if(!detectTs(fileName))
     {
         printf(" [PS Demuxer] Not a ps file\n");
         return false;
@@ -52,14 +52,14 @@
         signature[4]=0;
         fclose(f);
         if(!strcmp(signature,"PSD1")) return 50;
-        printf("[PsDemuxer] Not a valid index\n");
+        printf("[TSDemuxer] Not a valid index\n");
         return false;
     }
     if(count) return false;
-    printf("[PSDemuxer] Creating index..\n");
+    printf("[TSDemuxer] Creating index..\n");
     count++;
-    if(true==psIndexer(fileName)) goto again;
-    printf("[PSDemuxer] Failed..\n");
+    if(true==tsIndexer(fileName)) goto again;
+    printf("[TSDemuxer] Failed..\n");
    return 0;
 }
 #define PROBE_SIZE (1024*1024)
@@ -68,7 +68,7 @@
     \brief returns true if the file seems to be mpeg PS
 
 */
-bool detectPs(const char *file)
+bool detectTs(const char *file)
 {
     uint8_t *buffer=new uint8_t [PROBE_SIZE];
     uint32_t bufferSize;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -18,7 +18,7 @@
 #include "fourcc.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_indexFile.h"
-#include "ADM_ps.h"
+#include "ADM_ts.h"
 
 #include <math.h>
 /**
@@ -26,7 +26,7 @@
         \brief Read the [video] section of the index file
 
 */
-bool    psHeader::readIndex(indexFile *index)
+bool    tsHeader::readIndex(indexFile *index)
 {
 char buffer[2000];
 bool firstAudio=true;
@@ -57,7 +57,7 @@
     \fn processAudioIndex
     \brief process audio seek points from a line from the index file
 */
-bool psHeader::processAudioIndex(char *buffer)
+bool tsHeader::processAudioIndex(char *buffer)
 {
     int64_t startAt,dts;
     uint32_t size;
@@ -73,10 +73,10 @@
             if(4!=sscanf(head,"Pes:%"LX":%"LLX":%"LD":%"LLD" ",&pes,&startAt,&size,&dts))
             {
 // qfprintf(index,"Pes:%x:%08"LLX":%"LD":%LLD ",e,s->startAt,s->startSize,s->startDts);
-                printf("[PsHeader::processAudioIndex] Reading index %s failed\n",buffer);
+                printf("[tsHeader::processAudioIndex] Reading index %s failed\n",buffer);
             }
             head=tail+1;
-            ADM_psAccess *track=listOfAudioTracks[trackNb]->access;
+            ADM_tsAccess *track=listOfAudioTracks[trackNb]->access;
             track->push(startAt,dts,size);
 
             trackNb++;
@@ -91,7 +91,7 @@
     \fn processVideoIndex
     \brief process an mpeg index entry from a line from the index file
 */
-bool psHeader::processVideoIndex(char *buffer)
+bool tsHeader::processVideoIndex(char *buffer)
 {
             char *head=buffer;
             uint64_t pts,dts,startAt;
@@ -165,7 +165,7 @@
         \brief Read the [video] section of the index file
 
 */
-bool    psHeader::readVideo(indexFile *index)
+bool    tsHeader::readVideo(indexFile *index)
 {
     printf("[psDemuxer] Reading Video\n");
     if(!index->readSection("Video")) return false;
@@ -193,7 +193,7 @@
         \brief Read the [Audio] section of the index file
 
 */
-bool    psHeader::readAudio(indexFile *index,const char *name)
+bool    tsHeader::readAudio(indexFile *index,const char *name)
 {
     printf("[psDemuxer] Reading Audio\n");
     if(!index->readSection("Audio")) return false;
@@ -223,8 +223,8 @@
             hdr.byterate=br;
             hdr.channels=chan;
             hdr.encoding=codec;
-        ADM_psAccess *access=new ADM_psAccess(name,pid,true);
-            ADM_psTrackDescriptor *desc=new ADM_psTrackDescriptor;
+        ADM_tsAccess *access=new ADM_tsAccess(name,pid,true);
+            ADM_tsTrackDescriptor *desc=new ADM_tsTrackDescriptor;
             desc->stream=NULL;
             desc->access=access;
             memcpy(&(desc->header),&hdr,sizeof(hdr));

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-07 05:40:06 UTC (rev 4727)
@@ -8,6 +8,7 @@
 	ADM_tsAudioProbe.cpp
 	ADM_tsAudioProbe.h
         ADM_tsComputeTimeStamp.cpp
+        dmxTSPacket.cpp
 )
 
 ADD_LIBRARY(ADM_dm_ts SHARED ${ADM_ts_SRCS})

Copied: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp (from rev 4726, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxTSPacket.cpp	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-07 05:40:06 UTC (rev 4727)
@@ -0,0 +1,653 @@
+/**
+    \file dmxtsPacket
+    \brief Packet demuxer for mpeg TS
+    copyright            : (C) 2005-2009 by mean
+    email                : fixounet at free.fr
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+
+#include "dmxTSPacket.h"
+#include "dmx_mpegstartcode.h"
+
+/**
+    \fn tsPacket
+    \brief ctor
+*/
+tsPacket::tsPacket(void) 
+{
+
+}
+/**
+    \fn tsPacket
+    \brief dtor
+*/
+tsPacket::~tsPacket()
+{
+    close();
+}
+/**
+    \fn open
+    \brief dtor
+*/
+bool tsPacket::open(const char *filenames,FP_TYPE append)
+{
+    _file=new fileParser();
+    if(!_file->open(filenames,&append))
+    {
+        printf("[DmxPS] cannot open %s\n",filenames);
+        delete _file;
+        _file=NULL;
+        return false;
+    }
+    _size=_file->getSize();
+    return true;
+}
+/**
+    \fn close
+    \brief dtor
+*/
+bool tsPacket::close(void)
+{
+    if(_file)
+    {
+        delete _file;
+        _file=NULL;
+    }
+    return true;
+}
+/**
+    \fn getPos
+*/
+uint64_t    tsPacket::getPos(void)
+{
+    return 0;
+}
+/**
+    \fn setPos
+*/
+
+bool    tsPacket::setPos(uint64_t pos)
+{
+    if(!_file->setpos(pos))
+    {
+        printf("[tsPacket] Cannot seek to %"LLX"\n", pos);
+        return false;
+    }
+}
+
+/**
+    \fn getPacket
+*/      
+bool        tsPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)
+{
+uint32_t globstream,len;
+uint8_t  stream,substream;
+uint64_t pts,dts;
+        // Resync on our stream
+_again2:
+        *pid=0;
+        if(!_file->sync(&stream)) 
+        {
+                uint64_t pos;
+                _file->getpos(&pos);
+                printf("[DmxPS] cannot sync  at "LLU"/"LLU"\n",pos,_size);
+                return false;
+        }
+// Position of this packet just before startcode
+        _file->getpos(startAt);
+        *startAt-=4;
+// Handle out of band stuff        
+        if(stream==PACK_START_CODE) 
+        {
+        		_file->forward(8);
+        		goto _again2;
+        }
+        if( stream==PADDING_CODE ||stream==SYSTEM_START_CODE) 
+        {
+                        len=_file->read16i();
+                        //printf("\tForwarding %lu bytes\n",len);
+        		_file->forward(len);
+        		goto _again2;
+        }
+        // Only keep relevant parts
+        // i.e. a/v : C0 C9 E0 E9
+        // subs 20-29
+        // private data 1/2
+#define INSIDE(min,max) (stream>=min && stream<max)
+        if(!(  INSIDE(0xC0,0xC9) || INSIDE(0xE0,0xE9) || INSIDE(0x20,0x29) || stream==PRIVATE_STREAM_1 || stream==PRIVATE_STREAM_2
+        			)) goto _again2;
+        // Ok we got a candidate
+        if(!getPacketInfo(stream,&substream,&len,&pts,&dts))   
+        {
+                goto _again2;
+        }
+        
+        //printf("Main Stream :%x substream :%x\n",stream,substream);
+        if(stream==PRIVATE_STREAM_1) globstream=0xFF00+substream;
+                else                 globstream=stream;
+
+        *pid=globstream;
+        *opts=pts;
+        *odts=dts;
+        *packetSize=len;
+        if(len>     maxSize)
+        {
+                printf("[DmxPS] Packet too big %d vs %d\n",len,maxSize);
+        }
+        if(!_file->read32(len,buffer)) return false;
+        return true;
+       
+}
+/**
+
+    \fn getPacketInfo
+    \brief       Retrieve info about the packet we just met.It is assumed that parser is just after the packet startcode
+
+*/
+
+uint8_t tsPacket::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
+{
+
+//uint32_t un ,deux;
+uint64_t size=0;
+uint8_t c,d;
+uint8_t align=0;
+                        
+                *substream=0xff;
+                *opts=ADM_NO_PTS;
+                *odts=ADM_NO_PTS;
+                
+                                        
+                size=_file->read16i();
+                if((stream==PADDING_CODE) || 
+                	 (stream==PRIVATE_STREAM_2)
+                        ||(stream==SYSTEM_START_CODE) //?
+                        ) // special case, no header
+                        {
+                                *olen=size;      
+                                return 1;
+                        }
+                                
+                        //      remove padding if any                                           
+        
+                while((c=_file->read8i()) == 0xff) 
+                {
+                        size--;
+                }
+//----------------------------------------------------------------------------
+//-------------------------------MPEG-2 PES packet style----------------------
+//----------------------------------------------------------------------------
+                if(((c&0xC0)==0x80))
+                {
+                        uint32_t ptsdts,len;
+                        //printf("\n mpeg2 type \n");
+                        //_muxTypeMpeg2=1;
+                        // c= copyright and stuff       
+                        //printf(" %x align\n",c);      
+                        if(c & 4) align=1;      
+                        c=_file->read8i();     // PTS/DTS
+                        //printf("%x ptsdts\n",c
+                        ptsdts=c>>6;
+                        // header len
+                        len=_file->read8i();
+                        size-=3;  
+
+                        switch(ptsdts)
+                        {
+                                case 2: // PTS=1 DTS=0
+                                        if(len>=5)
+                                        {
+                                                uint64_t pts1,pts2,pts0;
+                                                //      printf("\n PTS10\n");
+                                                        pts0=_file->read8i();  
+                                                        pts1=_file->read16i(); 
+                                                        pts2=_file->read16i();                 
+                                                        len-=5;
+                                                        size-=5;
+                                                        *opts=(pts1>>1)<<15;
+                                                        *opts+=pts2>>1;
+                                                        *opts+=(((pts0&6)>>1)<<30);
+                                        }
+                                        break;
+                                case 3: // PTS=1 DTS=1
+                                                #define PTS11_ADV 10 // nut monkey
+                                                if(len>=PTS11_ADV)
+                                                {
+                                                        uint32_t skip=PTS11_ADV;
+                                                        uint64_t pts1,pts2,dts,pts0;
+                                                                //      printf("\n PTS10\n");
+                                                                pts0=_file->read8i();  
+                                                                pts1=_file->read16i(); 
+                                                                pts2=_file->read16i(); 
+                                                                                        
+                                                                *opts=(pts1>>1)<<15;
+                                                                *opts+=pts2>>1;
+                                                                *opts+=(((pts0&6)>>1)<<30);
+                                                                pts0=_file->read8i();  
+                                                                pts1=_file->read16i(); 
+                                                                pts2=_file->read16i();                 
+                                                                dts=(pts1>>1)<<15;
+                                                                dts+=pts2>>1;
+                                                                dts+=(((pts0&6)>>1)<<30);
+                                                                len-=skip;
+                                                                size-=skip;
+                                                                *odts=dts;
+                                                                        //printf("DTS: %lx\n",dts);                
+                                                   }
+                                                   break;               
+                                case 1:
+                                                return 0;//ADM_assert(0); // forbidden !
+                                                break;
+                                case 0: 
+                                                // printf("\n PTS00\n");
+                                                break; // no pts nor dts
+                                                                                
+                                                            
+                        }  
+// Extension bit        
+// >stealthdave<                                
+
+                        // Skip remaining headers if any
+                        if(len) 
+                        {
+                                _file->forward(len);
+                                size=size-len;
+                        }
+                                
+                if(stream==PRIVATE_STREAM_1)
+                {
+                        if(size>5)
+                        {
+                        // read sub id
+                               *substream=_file->read8i();
+  //                    printf("\n Subid : %x",*subid);
+                                switch(*substream)
+                                {
+                                // DTS
+                                        case 0x88:case 0x89:case 0x8A:case 0x8B:
+                                        
+                                                *substream=*substream-0x48;
+                                                break;
+
+                                //AC3
+                                        case 0x80:case 0x81:case 0x82:case 0x83:
+                                        case 0x84:case 0x85:case 0x86:case 0x87:
+                                                *substream=*substream-0x80;
+                                                break;
+                                // PCM
+                                        case 0xA0:case 0xA1:case 0xa2:case 0xa3:
+                                        case 0xA4:case 0xA5:case 0xa6:case 0xa7:
+                                                // we have an additionnal header
+                                                // of 3 bytes
+                                                _file->forward(3);
+                                                size-=3;
+                                                break;
+                                // Subs
+                                case 0x20:case 0x21:case 0x22:case 0x23:
+                                case 0x24:case 0x25:case 0x26:case 0x27:
+                                                break;
+                             
+                                default:
+                                                doNoComplainAnyMore++;
+                                                if(doNoComplainAnyMore<10)
+                                                    printf("[DmxPS]Unkown substream %x\n",*substream);
+                                                *substream=0xff;
+                                }
+                                // skip audio header (if not sub)
+                                if(*substream>0x26 || *substream<0x20)
+                                {
+                                        _file->forward(3);
+                                        size-=3;
+                                }
+                                size--;
+                        }
+                }
+               //    printf(" pid %x size : %x len %x\n",sid,size,len);
+                *olen=size;
+                return 1;
+        }
+//----------------------------------------------------------------------------------------------                
+//-------------------------------MPEG-1 PES packet style----------------------                                  
+//----------------------------------------------------------------------------------------------                                        
+           if(0) //_muxTypeMpeg2)
+                {
+                        printf("[DmxPS]*** packet type 1 inside type 2 ?????*****\n");
+                        return 0; // mmmm                       
+                }
+          // now look at  STD buffer size if present
+          // 01xxxxxxxxx
+          if ((c>>6) == 1) 
+          {       // 01
+                        size-=2;
+                        _file->read8i();                       // skip one byte
+                        c=_file->read8i();   // then another
+           }                       
+           // PTS/DTS
+           switch(c>>4)
+           {
+                case 2:
+                {
+                        // 0010 xxxx PTS only
+                        uint64_t pts1,pts2,pts0;
+                                        size -= 4;
+                                        pts0=(c>>1) &7;
+                                        pts1=_file->read16i()>>1;
+                                        pts2=_file->read16i()>>1;
+                                        *opts=pts2+(pts1<<15)+(pts0<<30);
+                                        break;
+                  }
+                  case 3:
+                  {               // 0011 xxxx
+                        uint64_t pts1,pts2,pts0;
+                                        size -= 9;
+                                                                        
+                                        pts0=(c>>1) &7;
+                                        pts1=_file->read16i()>>1;
+                                        pts2=_file->read16i()>>1;
+                                        *opts=pts2+(pts1<<15)+(pts0<<30);
+                                        _file->forward(5);
+                   }                                                               
+                   break;
+                   
+                case 1:
+                        // 0001 xxx             
+                        // PTSDTS=01 not allowed                        
+                                return 0;
+                                break; 
+                }
+                                                                
+
+                if(!align)      
+                        size--;         
+        *olen=size;
+        return 1;
+}
+//************************************************************************************
+
+#define ADM_PACKET_LINEAR 10*1024
+/**
+    \fn tsPacket
+*/
+tsPacketLinear::tsPacketLinear(uint8_t pid) : tsPacket()
+{
+    oldStartAt=startAt=0xfffffff;
+    oldBufferLen=bufferLen=0;
+    bufferIndex=0;
+    myPid=pid;
+    eof=false;
+}
+/**
+    \fn ~tsPacket
+*/
+tsPacketLinear::~tsPacketLinear() 
+{
+}
+/**
+    \fn refill
+*/
+bool tsPacketLinear::refill(void) 
+{
+// In case a startcode spawns across 2 packets
+// we have to keep track of the old one
+        oldBufferDts=bufferDts;
+        oldBufferPts=bufferPts;
+        oldStartAt=startAt;
+        oldBufferLen=bufferLen;
+        if( false== getPacketOfType(myPid,ADM_PACKET_LINEAR, &bufferLen,&bufferPts,&bufferDts,buffer,&startAt)) 
+        {
+            printf("[tsPacketLinear] Refill failed for pid :%x\n",myPid);
+            bufferIndex=bufferLen=0;
+            return false;
+        }
+        //printf("Refill : At :%"LLX" size :%"LD"\n",startAt,bufferLen);
+        bufferIndex=0;
+        return true;
+}
+/**
+    \fn readi8
+*/
+uint8_t tsPacketLinear::readi8(void)
+{
+    consumed++;
+    if(bufferIndex<bufferLen)
+    {
+        return buffer[bufferIndex++];
+    }
+    if(false==refill()) 
+    {
+        eof=1;
+        return 0;
+    }
+    ADM_assert(bufferLen);
+    bufferIndex=1;
+    return buffer[0];
+    
+}
+/**
+    \fn readi16
+*/
+uint16_t tsPacketLinear::readi16(void)
+{
+    if(bufferIndex+1<bufferLen)
+    {
+        uint16_t v=(buffer[bufferIndex]<<8)+buffer[bufferIndex+1];;
+        bufferIndex+=2;
+        consumed+=2;
+        return v;
+    }
+    return (readi8()<<8)+readi8();
+}
+/**
+    \fn readi32
+*/
+uint32_t tsPacketLinear::readi32(void)
+{
+    if(bufferIndex+3<bufferLen)
+    {
+        uint8_t *p=buffer+bufferIndex;
+        uint32_t v=(p[0]<<24)+(p[1]<<16)+(p[2]<<8)+p[3];
+        bufferIndex+=4;
+        consumed+=4;
+        return v;
+    }
+    return (readi16()<<16)+readi16();
+}
+/**
+    \fn forward
+*/
+bool tsPacketLinear::forward(uint32_t v)
+{
+next:
+ uint32_t delta=bufferLen-bufferIndex;
+    if(v>100*1000)
+    {
+        ADM_assert(0);
+    }
+    if(v<=delta)
+    {
+        bufferIndex+=v;
+        consumed+=v;
+        return true;
+    }
+    // v>delta
+    v-=delta;
+    if(!refill()) return false;
+    goto next;
+}
+
+/**
+    \fn bool    read(uint32_t len, uint8_t *buffer);
+    \brief
+*/
+bool    tsPacketLinear::read(uint32_t len, uint8_t *out)
+{
+    // Enough already ?
+    while(len)
+    {
+        uint32_t avail=bufferLen-bufferIndex;
+        uint32_t chunk=avail;
+        if(chunk>len) chunk=len;
+#if 0
+        printf("len:%ld avail:%ld chunk %ld index:%d size:%d\n",
+                len,avail,chunk,bufferIndex,bufferLen);
+#endif
+        memcpy(out,buffer+bufferIndex,chunk);
+        bufferIndex+=chunk;
+        len-=chunk;
+        out+=chunk;
+        consumed+=chunk;
+        if(bufferIndex==bufferLen)
+        {
+            //printf("Refill\n");
+            if(false==refill()) return false;
+        }
+    }
+    return true;
+}
+/**
+        \fn getInfo
+        \brief Returns info about the current (or previous if it spawns) packet.
+            It is expected that the caller will do -4 to the index to get the start of the 
+            startCode
+*/
+bool    tsPacketLinear::getInfo(dmxPacketInfo *info)
+{
+    if(bufferIndex<4)
+    {
+        info->startAt=this->oldStartAt;
+        info->offset=oldBufferLen+bufferIndex;
+        info->pts=oldBufferPts;
+        info->dts=oldBufferDts;
+
+    }else
+    {
+        info->startAt=this->startAt;
+        info->offset=bufferIndex;
+        info->pts=bufferPts;
+        info->dts=bufferDts;
+    }
+    return true;
+
+};
+/**
+    \fn seek
+    \brief Async jump
+*/
+bool    tsPacketLinear::seek(uint64_t packetStart, uint32_t offset)
+{
+    if(!_file->setpos(packetStart))
+    {
+        printf("[tsPacket] Cannot seek to %"LLX"\n",packetStart);
+        return 0;
+    }
+    if(!refill())
+    {
+        printf("[tsPacketLinear] Seek to %"LLX":%"LX" failed\n",packetStart,offset);
+        return false;
+    }
+    ADM_assert(offset<bufferLen);
+    bufferIndex=offset;
+    
+    return true;
+}
+/**
+    \fn getConsumed
+    \brief returns the # of bytes consumed since the last call
+*/
+uint32_t tsPacketLinear::getConsumed(void)
+{
+    uint32_t c=consumed;
+    consumed=0;
+    return c;
+}
+/**
+    \fn changePid
+    \brief change the pid of the stream we read (used when probing all tracks)
+*/
+bool    tsPacketLinear::changePid(uint32_t pid) 
+{
+    myPid=(pid&0xff);
+    bufferLen=bufferIndex=0;
+    return true;
+}
+/* ********************************************************* */
+/**
+    \fn tsPacketLinearTracker
+*/
+ tsPacketLinearTracker::tsPacketLinearTracker(uint8_t pid)  : tsPacketLinear(pid)
+{
+   resetStats();
+}
+/**
+    \fn ~tsPacketLinearTracker
+*/
+tsPacketLinearTracker::~tsPacketLinearTracker()
+{
+
+    
+}
+/**
+        \fn getStat
+*/
+packetStats    *tsPacketLinearTracker::getStat(int index)
+{   
+    if(index<0 || index>=256) ADM_assert(0);
+    return stats+index;
+}
+/**
+    \fn getPacketgetPacketOfType
+    \brief Keep track of all the packets we have seen so far.
+    Usefull to detect the streams present and to look up the PTS/DTS of audio streams for the audio part of the index
+*/
+bool           tsPacketLinearTracker::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
+{
+ bool xit=false;
+    uint8_t tmppid;
+    while(1)
+    {
+        if(true!=getPacket(maxSize,&tmppid,packetSize,pts,dts,buffer,startAt))
+                return false;
+        else
+        {
+                // Update 
+                ADM_assert(tmppid<0x100);
+                packetStats *p=stats+tmppid;
+                uint64_t ts=*pts;
+                if(ts==ADM_NO_PTS) ts=*dts;
+                if(ts!=ADM_NO_PTS)
+                {
+                    p->startCount=p->count;
+                    p->startAt=*startAt;
+                    p->startSize=p->size;
+                    p->startDts=ts;
+                }
+                p->count++;
+                p->size+=*packetSize;
+                if(tmppid==pid) return true;
+        }
+    }
+    return false;
+}
+/**
+    \fn resetStats
+*/
+bool           tsPacketLinearTracker::resetStats(void)
+{
+    memset(stats,0,sizeof(stats));
+    for(int i=0;i<256;i++)
+    {
+        packetStats *p=stats+i;
+        p->startDts=ADM_NO_PTS;
+    }
+}
+//EOF

Copied: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h (from rev 4726, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxTSPacket.h	2009-04-07 05:40:01 UTC (rev 4726)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-07 05:40:06 UTC (rev 4727)
@@ -0,0 +1,98 @@
+/**
+   \file dmxtsPacket.h
+    \brief demuxer for TS stream
+    (C) Mean fixounet at free.fr 2003-2009
+
+*/
+
+#ifndef DMXtsPacket_H
+#define DMXtsPacket_H
+
+#include "dmxPacket.h"
+#include "ADM_Video.h"
+
+
+
+/**
+    \class tsPacket
+*/
+class tsPacket : public ADMMpegPacket
+{
+protected:
+    uint8_t             getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
+public:
+                        tsPacket(void);
+    virtual            ~tsPacket();
+    virtual bool        open(const char *filenames,FP_TYPE append);
+    virtual bool        close(void);
+    virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
+    virtual uint64_t    getPos(void);
+    virtual bool        setPos(uint64_t pos);
+};
+/**
+    \class tsPacketLinear
+*/
+#define ADM_PACKET_LINEAR 10*1024
+
+class tsPacketLinear : public tsPacket
+{
+protected:
+        uint8_t  myPid;
+        uint64_t startAt;
+        uint32_t bufferLen;
+        uint64_t bufferPts;
+        uint64_t bufferDts;
+        uint32_t bufferIndex;
+        uint8_t  buffer[ADM_PACKET_LINEAR];
+        bool     eof;
+        bool     refill(void);
+        uint64_t oldStartAt;
+        uint32_t oldBufferLen;
+        uint64_t oldBufferPts;
+        uint64_t oldBufferDts;
+        uint32_t consumed;
+
+public:
+                tsPacketLinear(uint8_t pid);
+                ~tsPacketLinear();
+        uint32_t getConsumed(void);
+        uint8_t  readi8();
+        uint16_t readi16();
+        uint32_t readi32();
+        bool     sync(uint8_t *pid);
+        bool    read(uint32_t len, uint8_t *buffer);
+        bool    forward(uint32_t v);
+        bool    stillOk(void) {return !eof;};
+        bool    getInfo(dmxPacketInfo *info);
+        bool    seek(uint64_t packetStart, uint32_t offset);
+        bool    changePid(uint32_t pid) ;
+};
+/**
+    \class tsPacketLinearTracker
+*/
+typedef struct
+{
+    uint32_t count;
+    uint32_t size;
+    
+    uint64_t startAt;
+    uint32_t startCount;
+    uint32_t startSize;
+    uint64_t startDts;
+}packetStats;
+
+class tsPacketLinearTracker : public tsPacketLinear
+{
+protected:
+      packetStats stats[256];
+
+public:
+                        tsPacketLinearTracker(uint8_t pid);
+                        ~tsPacketLinearTracker();
+         packetStats    *getStat(int intdex);
+         bool           resetStats(void);
+virtual  bool           getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
+};
+
+
+#endif



From mean at mail.berlios.de  Tue Apr  7 07:40:15 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 7 Apr 2009 07:40:15 +0200
Subject: [Avidemux-svn-commit] r4728 - in branches/avidemux_2.6_branch_mean:
	avidemux/ADM_coreDemuxerMpeg/include
	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegTS
Message-ID: <200904070540.n375eFui009817@sheep.berlios.de>

Author: mean
Date: 2009-04-07 07:40:14 +0200 (Tue, 07 Apr 2009)
New Revision: 4728

Added:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsCrc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Log:
[TsDemuxer] More skeleton

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h	2009-04-07 05:40:06 UTC (rev 4727)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h	2009-04-07 05:40:14 UTC (rev 4728)
@@ -59,11 +59,13 @@
                         uint32_t read32(uint32_t l, uint8_t *buffer);
                         uint8_t  end(void) { return _off==_size-1;};
 						void hexDump(uint8_t *buf, int size);
+                        uint8_t  peek8i(void); // Only call it once!!
 #ifdef NO_INLINE_FP
                         uint32_t read32i(void );
                         uint16_t read16i(void );
                         uint8_t  read8i(void );
                         
+                        
 
 #else
 uint32_t read32i(void )

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp	2009-04-07 05:40:06 UTC (rev 4727)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp	2009-04-07 05:40:14 UTC (rev 4728)
@@ -486,6 +486,7 @@
        v= (p[0]<<8)+p[1];
        return v;
 }
+
 uint8_t fileParser::read8i(void )
 {
 uint8_t r;
@@ -501,7 +502,25 @@
         return r;
 }
 #endif
+/**
+    \fn peek8i
+    \brief Return the next bytes in the stream without advancing index
+    * BEWARE: Use with caution!
+*/
+uint8_t  fileParser::peek8i(void)
+{
+uint8_t r;
+    if(_off+1<_tail)
+        r= _buffer[_off-_head];
+    else    
+    {
+        read32(1,&r);
+        _off--;
+    }
+    return r;
 
+}
+
 void fileParser::hexDump(uint8_t *buf, int size)
 {
 	int len, i, j, c;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-07 05:40:06 UTC (rev 4727)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-07 05:40:14 UTC (rev 4728)
@@ -26,6 +26,8 @@
 #include "ADM_indexFile.h"
 #include "dmxTSPacket.h"
 #include <vector>
+
+
 using std::vector;
 /**
     \struct dmxFrame

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsCrc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsCrc.cpp	2009-04-07 05:40:06 UTC (rev 4727)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsCrc.cpp	2009-04-07 05:40:14 UTC (rev 4728)
@@ -0,0 +1,57 @@
+
+static const uint32_t crc_table[256] = {
+	0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
+	0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
+	0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
+	0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
+	0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
+	0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
+	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
+	0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
+	0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
+	0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
+	0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
+	0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
+	0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
+	0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
+	0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
+	0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
+	0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
+	0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
+	0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
+	0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
+	0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
+	0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
+	0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
+	0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
+	0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
+	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
+	0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
+	0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
+	0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
+	0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
+	0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
+	0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
+	0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
+	0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
+	0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
+	0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
+	0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
+	0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
+	0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
+	0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
+	0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
+};
+static uint32_t mpegTsCRC(uint8_t *data, uint32_t len)
+{
+
+    int i;
+    uint32_t crc = 0xffffffff;
+    
+    for (i=0; i<len; i++)
+        crc = (crc << 8) ^ crc_table[((crc >> 24) ^ *data++) & 0xff];
+    
+    return crc;
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-07 05:40:06 UTC (rev 4727)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-07 05:40:14 UTC (rev 4728)
@@ -22,10 +22,11 @@
 ADM_DEMUXER_BEGIN( tsHeader,
                     1,0,0,
                     "ts",
-                    "mpeg ps demuxer plugin (c) Mean 2007/2009"
+                    "mpeg ts demuxer plugin (c) Mean 2007/2009"
                 );
 
 static bool detectTs(const char *file);
+static bool checkMarker(uint8_t *buffer, uint32_t bufferSize,uint32_t block);
 uint8_t   tsIndexer(const char *file);
 /**
     \fn Probe
@@ -35,17 +36,27 @@
 {
 char index[strlen(fileName)+4];
 int count=0;
-    if(!detectTs(fileName))
+    printf("[TS Demuxer] Probing...\n");
+    if(0 && !detectTs(fileName))
     {
-        printf(" [PS Demuxer] Not a ps file\n");
+        printf(" [TS Demuxer] Not a ts file\n");
         return false;
     }
 
+    tsPacket *t=new tsPacket();
+    t->open(fileName,FP_PROBE);
+    uint8_t b[200];
+    uint32_t l,current,max;
+    t->getNextPSI(0,b,&l,&current,&max);
+    delete t;
+    printf("[TS Demuxer] Probed...\n");
+    return 0;
+
     sprintf(index,"%s.idx",fileName);
 again:    
     if(ADM_fileExist(index)) 
     {
-        printf(" [PS Demuxer] There is an index for that file \n");
+        printf(" [TS Demuxer] There is an index for that file \n");
         FILE *f=fopen(index,"rt");
         char signature[10];
         fread(signature,4,1,f);
@@ -64,7 +75,7 @@
 }
 #define PROBE_SIZE (1024*1024)
 /**
-    \fn detectPs
+    \fn detectTs
     \brief returns true if the file seems to be mpeg PS
 
 */
@@ -78,21 +89,52 @@
     if(!f) return false;
     bufferSize=fread(buffer,1,PROBE_SIZE,f);
     fclose(f);
-    nbPacket=bufferSize/2300;
-    uint8_t *head,*tail;
-    head=buffer;
-    tail=buffer+bufferSize;
-    uint8_t code;
-    uint32_t offset;
-    while(ADM_findMpegStartCode(head,tail,&code,&offset))
+    // Do a simple check by checking we have 0x47....0x47 several time in a raw
+    if(true==checkMarker(buffer,bufferSize,188))
     {
-        head+=offset;
-        if(code==0xE0) nbMatch++;
+        printf("[TS Demuxer] 188 bytes packet detected\n");
+        return true;
     }
-    printf(" match :%d / %d (probeSize:%d)\n",nbMatch,nbPacket,bufferSize);
-    if(nbMatch>nbPacket/3)
+    // Do a simple check by checking we have 0x47....0x47 several time in a raw
+    if(true==checkMarker(buffer,bufferSize,192))
+    {
+        printf("[TS Demuxer] 192 bytes packet detected\n");
         return true;
+    }
+    printf("[TS Demuxer] Not a TS file\n");
     return false;
-    
+}
 
-}
\ No newline at end of file
+/**
+        \fn checkMarker
+        \brief return true if the mpeg TS markers are there separated by block bytes
+*/
+bool checkMarker(uint8_t *buffer, uint32_t bufferSize,uint32_t block)
+{
+    uint8_t *end=buffer+bufferSize;
+    int syncOk=0;
+    int syncKo=0;
+    // Search Marker    
+    while(buffer<end)
+    {
+        if(*buffer!=TS_MARKER)
+        {
+            while(*buffer!=TS_MARKER && buffer<end) 
+            {
+                buffer++;
+            }
+            syncKo++;
+        }
+        if(*buffer!=TS_MARKER) break;
+        while(buffer<end && buffer[block]==TS_MARKER)
+        {   
+                syncOk++,
+                buffer+=block;
+        }    
+        buffer++;
+    }
+    printf("[Ts Demuxer] Sync ok :%d Sync ko :%d\n",syncOk,syncKo);
+    if(!syncOk) return false;
+    if(syncOk>5*syncKo) return true;
+}
+//EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-07 05:40:06 UTC (rev 4727)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-07 05:40:14 UTC (rev 4728)
@@ -13,6 +13,8 @@
 
 ADD_LIBRARY(ADM_dm_ts SHARED ${ADM_ts_SRCS})
 TARGET_LINK_LIBRARIES(ADM_dm_ts ADM_coreDemuxerMpeg ADM_audioParser)
+# For ffmpeg includes
+INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_libraries/ADM_ffmpeg") 
 INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreDemuxerMpeg/include")
 
 INIT_DEMUXER(ADM_dm_ts)

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-07 05:40:06 UTC (rev 4727)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-07 05:40:14 UTC (rev 4728)
@@ -19,13 +19,26 @@
 #include "dmxTSPacket.h"
 #include "dmx_mpegstartcode.h"
 
+#define TS_PACKET_LEN 188
+
+#define ADM_NO_CONFIG_H
+extern "C"
+{
+#include "libavutil/common.h"
+#include "libavutil/bswap.h"
+#include "ADM_lavcodec/bitstream.h"
+
+}
+#include "ADM_tsCrc.cpp"
+
+
 /**
     \fn tsPacket
     \brief ctor
 */
 tsPacket::tsPacket(void) 
 {
-
+    extraCrap=0; // =4 for ts2
 }
 /**
     \fn tsPacket
@@ -84,8 +97,128 @@
         return false;
     }
 }
+/**
+    \fn getSinglePacket
+    \brief 
+*/
+bool tsPacket::getSinglePacket(uint8_t *buffer)
+{
+    uint8_t scratch[16];
+again:
+    while(_file->read8i()!=TS_MARKER && _file->end()!=true) ;
+    if(_file->end()==true) 
+    {
+        return false;
+    }
+    _file->read32(TS_PACKET_LEN-1,buffer); // 184-1
+    if(extraCrap)  _file->read32(extraCrap,scratch);
+    if(_file->peek8i()!=TS_MARKER)
+    {
+        printf("[tsPacket] Sync lost\n");
+        goto again;
+    }
+    return true;
+}
 
 /**
+    \fn getNextPsiPacket
+    \brief Take a raw packet of type pid & remove the header
+*/
+bool tsPacket::getNextPacket_NoHeader(uint32_t pid,uint8_t *buffer,uint32_t *olen)
+{
+    uint8_t scratch[188+4];
+nextPack:
+
+    if(false==getSinglePacket(scratch)) return false;
+    uint32_t id=scratch[1]+((scratch[0]&0x1F)<<8);
+    if(id!=pid) goto nextPack;
+    
+
+    int payloadUnitStart=scratch[0]&0x40;
+    int fieldControl=(scratch[2]>>4)&3;
+    int continuity=(scratch[2]&0xf);
+    int len=TS_PACKET_LEN-4; // usefull datas
+    // Adaptation field
+    // 11 Adapt+payload
+    // 10 Adapt only
+    // 01 Payload only
+    // 00 forbidden
+    if(!(fieldControl & 1)) 
+    {
+        // No payload, continue
+        goto nextPack;
+    }
+    uint8_t *start,*end;
+    start=scratch+3;
+    end=scratch+187;
+
+    if(fieldControl & 2) // Adaptation layer
+    {
+        int payloadSize=*start++;
+        start+=payloadSize;
+    }
+    int size=(int)(end-start);
+    if(size<=0)  goto nextPack;
+    memcpy(buffer,start,size);
+    *olen=size;
+    return true;
+}
+
+/**
+    \fn getNextPsiPacket
+    \brief Take a raw packet of type pid & remove the header
+*/
+#define DUMMY(x,n) {dummy=get_bits(&s,n);printf("[TS]: "#x" =0x%x %d\n",dummy,dummy);}
+bool tsPacket::getNextPSI(uint32_t pid,uint8_t *buffer,uint32_t *olen,uint32_t *count, uint32_t *countMax)
+{
+    uint8_t scratch[188+4];
+    uint32_t len;
+nextPack2:
+
+    if(false==getNextPacket_NoHeader(pid,(uint8_t *)scratch,&len)) return false;
+
+    // Verify CRC
+    uint32_t crc1=mpegTsCRC(scratch,len-4);
+
+    uint8_t *c=scratch+len-4;
+    uint32_t crc2=(c[0]<<24)+(c[1]<<16)+(c[2]<<8)+c[3];
+    if(crc1!=crc2)
+    {
+        printf("[MpegTs] getNextPSI bad checksum :%04x vs %04x\n",crc1,crc2);
+        goto nextPack2;
+    }
+
+    GetBitContext s;
+    uint32_t tableId;
+    uint32_t sectionLength=0;
+    uint32_t transportStreamId=0;
+    uint32_t dummy;
+    
+
+    init_get_bits( &s,scratch, (len-4)*8);
+
+    DUMMY(tableId,8);
+    printf("[TS] Pid :%x TableId %02x\n",pid,tableId);
+    skip_bits(&s,1);             // Section syntax indicator
+    if(get_bits(&s,1))             // Marker
+    {
+          printf("[MpegTs] getNextPSI Missing 0 marker\n");
+          goto nextPack2;
+    }
+    sectionLength=get_bits(&s,12);    // Section Length
+    transportStreamId=get_bits(&s,16);// transportStreamId
+    skip_bits(&s,2);                  // ignored
+    DUMMY(VersionNumber,5);         // Version number
+    DUMMY(CurrentNext,1);           // Current Next indicator
+    *count=get_bits(&s,8);           // Section number
+    *countMax=get_bits(&s,8);        // Section last number
+
+    int hdr=(8+16+16+8+8+8)/8;
+    *olen=len-4-hdr;
+    memcpy(buffer,scratch+hdr,*olen);
+    return true;
+}
+/**
     \fn getPacket
 */      
 bool        tsPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-07 05:40:06 UTC (rev 4727)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-07 05:40:14 UTC (rev 4728)
@@ -11,14 +11,15 @@
 #include "dmxPacket.h"
 #include "ADM_Video.h"
 
+#define TS_MARKER 0x47
 
-
 /**
     \class tsPacket
 */
 class tsPacket : public ADMMpegPacket
 {
 protected:
+    uint32_t            extraCrap;
     uint8_t             getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
 public:
                         tsPacket(void);
@@ -28,6 +29,12 @@
     virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
     virtual uint64_t    getPos(void);
     virtual bool        setPos(uint64_t pos);
+protected:
+    bool                getNextPacket_NoHeader(uint32_t pid,uint8_t *buffer,uint32_t *len);
+    bool                getSinglePacket(uint8_t *buffer);
+public:
+    bool                getNextPSI(uint32_t pid,uint8_t *buffer,uint32_t *olen,uint32_t *count, uint32_t *countMax);
+
 };
 /**
     \class tsPacketLinear



From mean at mail.berlios.de  Wed Apr  8 20:01:47 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 8 Apr 2009 20:01:47 +0200
Subject: [Avidemux-svn-commit] r4729 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904081801.n38I1lor031754@sheep.berlios.de>

Author: mean
Date: 2009-04-08 20:01:46 +0200 (Wed, 08 Apr 2009)
New Revision: 4729

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Log:
[MpegTs] Search PAT, skeleton for PMT

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-07 05:40:14 UTC (rev 4728)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-08 18:01:46 UTC (rev 4729)
@@ -27,6 +27,7 @@
 
 static bool detectTs(const char *file);
 static bool checkMarker(uint8_t *buffer, uint32_t bufferSize,uint32_t block);
+static bool scanForPrograms(const char *file);
 uint8_t   tsIndexer(const char *file);
 /**
     \fn Probe
@@ -43,14 +44,7 @@
         return false;
     }
 
-    tsPacket *t=new tsPacket();
-    t->open(fileName,FP_PROBE);
-    uint8_t b[200];
-    uint32_t l,current,max;
-    t->getNextPSI(0,b,&l,&current,&max);
-    delete t;
-    printf("[TS Demuxer] Probed...\n");
-    return 0;
+   
 
     sprintf(index,"%s.idx",fileName);
 again:    
@@ -69,6 +63,7 @@
     if(count) return false;
     printf("[TSDemuxer] Creating index..\n");
     count++;
+    if(scanForPrograms(fileName)==false) return 0;
     if(true==tsIndexer(fileName)) goto again;
     printf("[TSDemuxer] Failed..\n");
    return 0;
@@ -137,4 +132,68 @@
     if(!syncOk) return false;
     if(syncOk>5*syncKo) return true;
 }
+/**
+    \fn scanForPrograms
+*/
+bool scanForPrograms(const char *file)
+{
+    uint8_t buffer[200];
+    uint32_t len,current,max;
+
+    vector <uint32_t>listOfPmt;
+
+    tsPacket *t=new tsPacket();
+    t->open(file,FP_PROBE);
+    // 1 search the pat...
+    if(t->getNextPSI(0,buffer,&len,&current,&max)==true)
+    {
+        uint8_t *r=buffer;
+        while(len>4)
+        {
+            uint32_t prg=((0x1F&r[0])<<8)+r[1];
+            uint32_t pid=((0x1F&r[2])<<8)+r[3];
+            r+=4;
+            len-=4;
+            printf("[TsDemuxer] Pat : Prg:%d Pid: 0x%04x\n",prg,pid);
+            listOfPmt.push_back(pid);
+        }
+        if(listOfPmt.size())
+        {
+            for(int i=0;i<listOfPmt.size();i++)
+            {
+                uint32_t pid=listOfPmt[i];
+                 if(t->getNextPSI(pid,buffer,&len,&current,&max)==true)
+                 {
+                    // We should be protected by CRC here
+                    r=buffer;
+                    printf("[TsDemuxer] PCR 0x%x\n",(r[0]<<8)+r[1]);
+                    r+=2;  
+                    int programInfoLength=(r[0]<<8)+r[1];
+                            programInfoLength&=0xfff;
+                            r+=2;
+                            while(programInfoLength)
+                            {
+                                    printf("[PMT] PMT :%02x StreamType: 0x%x\n",*r++);    
+                                    printf("[PMT] PMT :%02x Pid:        0x%x\n",(r[0]<<8)+r[1]);
+                                    r+=2;
+                                    int esInfoLength=((r[0]<<8)+r[1])&0xfff;
+                                    printf("[PMT] PMT :%02x Es Info Length: %d\n",esInfoLength);
+                                    r+=esInfoLength;
+                                    programInfoLength-=4;
+                                    programInfoLength=esInfoLength;
+
+                            }
+
+
+                 }
+
+            }
+
+        }
+
+    }
+    delete t;
+    printf("[TS Demuxer] Probed...\n");
+    return 0;
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-07 05:40:14 UTC (rev 4728)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-08 18:01:46 UTC (rev 4729)
@@ -4,6 +4,10 @@
     copyright            : (C) 2005-2009 by mean
     email                : fixounet at free.fr
         
+    Warning : For PSI packet (PAT & PMT) we assume they fit into one TS packet
+                Else we fail miserably.
+
+
  ***************************************************************************/
 
 /***************************************************************************
@@ -124,7 +128,7 @@
     \fn getNextPsiPacket
     \brief Take a raw packet of type pid & remove the header
 */
-bool tsPacket::getNextPacket_NoHeader(uint32_t pid,uint8_t *buffer,uint32_t *olen)
+bool tsPacket::getNextPacket_NoHeader(uint32_t pid,uint8_t *buffer,uint32_t *olen,bool psi)
 {
     uint8_t scratch[188+4];
 nextPack:
@@ -152,7 +156,7 @@
     start=scratch+3;
     end=scratch+187;
 
-    if(fieldControl & 2) // Adaptation layer
+    if((fieldControl & 2)|| psi) // Adaptation layer
     {
         int payloadSize=*start++;
         start+=payloadSize;
@@ -166,7 +170,7 @@
 
 /**
     \fn getNextPsiPacket
-    \brief Take a raw packet of type pid & remove the header
+    \brief Take a raw packet of type pid & remove the header (PSI)
 */
 #define DUMMY(x,n) {dummy=get_bits(&s,n);printf("[TS]: "#x" =0x%x %d\n",dummy,dummy);}
 bool tsPacket::getNextPSI(uint32_t pid,uint8_t *buffer,uint32_t *olen,uint32_t *count, uint32_t *countMax)
@@ -175,19 +179,8 @@
     uint32_t len;
 nextPack2:
 
-    if(false==getNextPacket_NoHeader(pid,(uint8_t *)scratch,&len)) return false;
+    if(false==getNextPacket_NoHeader(pid,(uint8_t *)scratch,&len,true)) return false;    
 
-    // Verify CRC
-    uint32_t crc1=mpegTsCRC(scratch,len-4);
-
-    uint8_t *c=scratch+len-4;
-    uint32_t crc2=(c[0]<<24)+(c[1]<<16)+(c[2]<<8)+c[3];
-    if(crc1!=crc2)
-    {
-        printf("[MpegTs] getNextPSI bad checksum :%04x vs %04x\n",crc1,crc2);
-        goto nextPack2;
-    }
-
     GetBitContext s;
     uint32_t tableId;
     uint32_t sectionLength=0;
@@ -198,23 +191,42 @@
     init_get_bits( &s,scratch, (len-4)*8);
 
     DUMMY(tableId,8);
-    printf("[TS] Pid :%x TableId %02x\n",pid,tableId);
     skip_bits(&s,1);             // Section syntax indicator
     if(get_bits(&s,1))             // Marker
     {
           printf("[MpegTs] getNextPSI Missing 0 marker\n");
           goto nextPack2;
     }
+    skip_bits(&s,2);
     sectionLength=get_bits(&s,12);    // Section Length
+    if(sectionLength+3>len) goto nextPack2;
     transportStreamId=get_bits(&s,16);// transportStreamId
+    printf("[MpegTs] Section length    =%d\n",sectionLength);
+    printf("[MpegTs] transportStreamId =%d\n",transportStreamId);
     skip_bits(&s,2);                  // ignored
     DUMMY(VersionNumber,5);         // Version number
     DUMMY(CurrentNext,1);           // Current Next indicator
     *count=get_bits(&s,8);           // Section number
     *countMax=get_bits(&s,8);        // Section last number
 
+    if(*count!=*countMax) return false; // we dont handle split psi at the moment
+
+    uint8_t *c=scratch+sectionLength-4+3;
+
+// Verify CRC
+    uint32_t crc1=mpegTsCRC(scratch,sectionLength-4+3);
+    uint32_t crc2=(c[0]<<24)+(c[1]<<16)+(c[2]<<8)+c[3];
+    if(crc1!=crc2)
+    {
+        printf("[MpegTs] getNextPSI bad checksum :%04x vs %04x\n",crc1,crc2);
+        goto nextPack2;
+    }
+
+
     int hdr=(8+16+16+8+8+8)/8;
-    *olen=len-4-hdr;
+    int payloadsize=sectionLength-4-5; // Remove checksum & header
+    if(payloadsize<4) goto nextPack2;
+    *olen=payloadsize;
     memcpy(buffer,scratch+hdr,*olen);
     return true;
 }

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-07 05:40:14 UTC (rev 4728)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-08 18:01:46 UTC (rev 4729)
@@ -30,7 +30,7 @@
     virtual uint64_t    getPos(void);
     virtual bool        setPos(uint64_t pos);
 protected:
-    bool                getNextPacket_NoHeader(uint32_t pid,uint8_t *buffer,uint32_t *len);
+    bool                getNextPacket_NoHeader(uint32_t pid,uint8_t *buffer,uint32_t *len,bool psi);
     bool                getSinglePacket(uint8_t *buffer);
 public:
     bool                getNextPSI(uint32_t pid,uint8_t *buffer,uint32_t *olen,uint32_t *count, uint32_t *countMax);



From mean at mail.berlios.de  Wed Apr  8 20:02:00 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 8 Apr 2009 20:02:00 +0200
Subject: [Avidemux-svn-commit] r4730 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904081802.n38I20Cl031776@sheep.berlios.de>

Author: mean
Date: 2009-04-08 20:01:59 +0200 (Wed, 08 Apr 2009)
New Revision: 4730

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
Log:
[TsDemuxer] More PMT stuff

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-08 18:01:46 UTC (rev 4729)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-08 18:01:59 UTC (rev 4730)
@@ -28,6 +28,7 @@
 static bool detectTs(const char *file);
 static bool checkMarker(uint8_t *buffer, uint32_t bufferSize,uint32_t block);
 static bool scanForPrograms(const char *file);
+static bool scanPmt(tsPacket *t,uint32_t pid);
 uint8_t   tsIndexer(const char *file);
 /**
     \fn Probe
@@ -148,7 +149,7 @@
     if(t->getNextPSI(0,buffer,&len,&current,&max)==true)
     {
         uint8_t *r=buffer;
-        while(len>4)
+        while(len>=4)
         {
             uint32_t prg=((0x1F&r[0])<<8)+r[1];
             uint32_t pid=((0x1F&r[2])<<8)+r[3];
@@ -159,41 +160,58 @@
         }
         if(listOfPmt.size())
         {
-            for(int i=0;i<listOfPmt.size();i++)
+            for(int i=1;i<listOfPmt.size();i++) // First PMT is PCR lock ?
             {
+                
                 uint32_t pid=listOfPmt[i];
-                 if(t->getNextPSI(pid,buffer,&len,&current,&max)==true)
-                 {
-                    // We should be protected by CRC here
-                    r=buffer;
-                    printf("[TsDemuxer] PCR 0x%x\n",(r[0]<<8)+r[1]);
-                    r+=2;  
-                    int programInfoLength=(r[0]<<8)+r[1];
-                            programInfoLength&=0xfff;
-                            r+=2;
-                            while(programInfoLength)
-                            {
-                                    printf("[PMT] PMT :%02x StreamType: 0x%x\n",*r++);    
-                                    printf("[PMT] PMT :%02x Pid:        0x%x\n",(r[0]<<8)+r[1]);
-                                    r+=2;
-                                    int esInfoLength=((r[0]<<8)+r[1])&0xfff;
-                                    printf("[PMT] PMT :%02x Es Info Length: %d\n",esInfoLength);
-                                    r+=esInfoLength;
-                                    programInfoLength-=4;
-                                    programInfoLength=esInfoLength;
-
-                            }
-
-
-                 }
-
+                scanPmt(t,pid);
             }
 
         }
-
     }
     delete t;
     printf("[TS Demuxer] Probed...\n");
     return 0;
 }
+/**
+    \fn scanPmt
+*/
+bool scanPmt(tsPacket *t,uint32_t pid)
+{
+    uint8_t buffer[200];
+    uint32_t len,current,max;
+    uint8_t *r=buffer;
+    printf("[TsDemuxer] Looking for PMT : %x\n",pid);
+    if(t->getNextPSI(pid,buffer,&len,&current,&max)==true)
+         {
+            // We should be protected by CRC here
+            int packLen=len;
+            printf("[TsDemuxer] PCR 0x%x, len=%d\n",(r[0]<<8)+r[1],packLen);
+            r+=2;  
+                    int programInfoLength=(r[0]<<8)+r[1];
+                    programInfoLength&=0xfff;
+                    r+=2;
+                    printf("[PMT] PMT :%02x Program Info Len: %d\n",programInfoLength);    
+                    packLen-=(2+4);
+                    while(packLen>4)
+                    {
+                            int streamType,streamPid,esInfoLength;
+                            streamType=r[0];
+                            streamPid=(r[1]<<8)+r[2]&0x1fff;
+                            esInfoLength=((r[3]<<8)+r[4])&0xfff;
+                            r+=5;
+                            r+=esInfoLength;
+                            packLen-=5;
+                            packLen-=esInfoLength;
+
+                            printf("[PMT] PMT :%02x StreamType: 0x%x\n",pid,streamType);    
+                            printf("[PMT] PMT :%02x Pid:        0x%x\n",pid,streamPid);
+                            printf("[PMT] PMT :%02x Es Info Length: %d (0x%x)\n",pid,esInfoLength,esInfoLength);
+
+                    }
+
+
+         }
+        return false;
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-08 18:01:46 UTC (rev 4729)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-08 18:01:59 UTC (rev 4730)
@@ -108,7 +108,11 @@
 bool tsPacket::getSinglePacket(uint8_t *buffer)
 {
     uint8_t scratch[16];
+#define MAX_SKIPPED_PACKET 6000
+    int count=MAX_SKIPPED_PACKET;
 again:
+    count--;
+    if(!count) return false;
     while(_file->read8i()!=TS_MARKER && _file->end()!=true) ;
     if(_file->end()==true) 
     {



From mean at mail.berlios.de  Thu Apr  9 07:44:32 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 9 Apr 2009 07:44:32 +0200
Subject: [Avidemux-svn-commit] r4731 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904090544.n395iWqE006271@sheep.berlios.de>

Author: mean
Date: 2009-04-09 07:44:30 +0200 (Thu, 09 Apr 2009)
New Revision: 4731

Added:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h
Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
Log:
[MpegTs] split pmt/pat into its own file

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-08 18:01:59 UTC (rev 4730)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-09 05:44:30 UTC (rev 4731)
@@ -0,0 +1,103 @@
+/** *************************************************************************
+    \file ADM_tsPatPmt.cpp
+    \brief Analyze pat & pmt
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+      
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_ts.h"
+#include "ADM_demuxerInternal.h"
+#include "ADM_tsPatPmt.h"
+/**
+    \fn scanForPrograms
+*/
+bool scanForPrograms(const char *file)
+{
+    uint8_t buffer[200];
+    uint32_t len,current,max;
+
+    vector <uint32_t>listOfPmt;
+
+    tsPacket *t=new tsPacket();
+    t->open(file,FP_PROBE);
+    // 1 search the pat...
+    if(t->getNextPSI(0,buffer,&len,&current,&max)==true)
+    {
+        uint8_t *r=buffer;
+        while(len>=4)
+        {
+            uint32_t prg=((0x1F&r[0])<<8)+r[1];
+            uint32_t pid=((0x1F&r[2])<<8)+r[3];
+            r+=4;
+            len-=4;
+            printf("[TsDemuxer] Pat : Prg:%d Pid: 0x%04x\n",prg,pid);
+            if(prg) // if prg==0, it is network Pid, dont need it
+                listOfPmt.push_back(pid);
+        }
+        if(listOfPmt.size())
+        {
+            for(int i=0;i<listOfPmt.size();i++) // First PMT is PCR lock ?
+            {
+                
+                uint32_t pid=listOfPmt[i];
+                scanPmt(t,pid);
+            }
+
+        }
+    }
+    delete t;
+    printf("[TS Demuxer] Probed...\n");
+    return 0;
+}
+/**
+    \fn scanPmt
+*/
+bool scanPmt(tsPacket *t,uint32_t pid)
+{
+    uint8_t buffer[200];
+    uint32_t len,current,max;
+    uint8_t *r=buffer;
+    printf("[TsDemuxer] Looking for PMT : %x\n",pid);
+    if(t->getNextPSI(pid,buffer,&len,&current,&max)==true)
+         {
+            // We should be protected by CRC here
+            int packLen=len;
+            printf("[TsDemuxer] PCR 0x%x, len=%d\n",(r[0]<<8)+r[1],packLen);
+            r+=2;  
+                    int programInfoLength=(r[0]<<8)+r[1];
+                    programInfoLength&=0xff;
+                    r+=2;
+                    printf("[PMT] PMT :%02x Program Info Len: %d\n",pid,programInfoLength);    
+                    packLen-=(2+4);
+                    while(packLen>4)
+                    {
+                            int streamType,streamPid,esInfoLength;
+                            streamType=r[0];
+                            streamPid=(r[1]<<8)+r[2]&0x1fff;
+                            esInfoLength=((r[3]<<8)+r[4])&0xfff;
+                            r+=5;
+                            r+=esInfoLength;
+                            packLen-=5;
+                            packLen-=esInfoLength;
+
+                            printf("[PMT] PMT :%02x StreamType: 0x%x\n",pid,streamType);    
+                            printf("[PMT] PMT :%02x Pid:        0x%x\n",pid,streamPid);
+                            printf("[PMT] PMT :%02x Es Info Length: %d (0x%x)\n",pid,esInfoLength,esInfoLength);
+
+                    }
+
+
+         }
+        return false;
+}
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h	2009-04-08 18:01:59 UTC (rev 4730)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h	2009-04-09 05:44:30 UTC (rev 4731)
@@ -0,0 +1,31 @@
+/** *************************************************************************
+    \file ADM_tsPatPmt.cpp
+    \brief Analyze pat & pmt
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+      
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_TS_PAT_PMT_H
+#define ADM_TS_PAT_PMT_H
+/**
+    \fn scanForPrograms
+*/
+
+bool scanForPrograms(const char *file);
+
+/**
+    \fn scanPmt
+*/
+bool scanPmt(tsPacket *t,uint32_t pid);
+#endif
+//EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-08 18:01:59 UTC (rev 4730)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-09 05:44:30 UTC (rev 4731)
@@ -18,7 +18,7 @@
 #include "ADM_demuxerInternal.h"
 #include "fourcc.h"
 #include "avidemutils.h"
-
+#include "ADM_tsPatPmt.h"
 ADM_DEMUXER_BEGIN( tsHeader,
                     1,0,0,
                     "ts",
@@ -27,8 +27,6 @@
 
 static bool detectTs(const char *file);
 static bool checkMarker(uint8_t *buffer, uint32_t bufferSize,uint32_t block);
-static bool scanForPrograms(const char *file);
-static bool scanPmt(tsPacket *t,uint32_t pid);
 uint8_t   tsIndexer(const char *file);
 /**
     \fn Probe
@@ -133,85 +131,4 @@
     if(!syncOk) return false;
     if(syncOk>5*syncKo) return true;
 }
-/**
-    \fn scanForPrograms
-*/
-bool scanForPrograms(const char *file)
-{
-    uint8_t buffer[200];
-    uint32_t len,current,max;
-
-    vector <uint32_t>listOfPmt;
-
-    tsPacket *t=new tsPacket();
-    t->open(file,FP_PROBE);
-    // 1 search the pat...
-    if(t->getNextPSI(0,buffer,&len,&current,&max)==true)
-    {
-        uint8_t *r=buffer;
-        while(len>=4)
-        {
-            uint32_t prg=((0x1F&r[0])<<8)+r[1];
-            uint32_t pid=((0x1F&r[2])<<8)+r[3];
-            r+=4;
-            len-=4;
-            printf("[TsDemuxer] Pat : Prg:%d Pid: 0x%04x\n",prg,pid);
-            listOfPmt.push_back(pid);
-        }
-        if(listOfPmt.size())
-        {
-            for(int i=1;i<listOfPmt.size();i++) // First PMT is PCR lock ?
-            {
-                
-                uint32_t pid=listOfPmt[i];
-                scanPmt(t,pid);
-            }
-
-        }
-    }
-    delete t;
-    printf("[TS Demuxer] Probed...\n");
-    return 0;
-}
-/**
-    \fn scanPmt
-*/
-bool scanPmt(tsPacket *t,uint32_t pid)
-{
-    uint8_t buffer[200];
-    uint32_t len,current,max;
-    uint8_t *r=buffer;
-    printf("[TsDemuxer] Looking for PMT : %x\n",pid);
-    if(t->getNextPSI(pid,buffer,&len,&current,&max)==true)
-         {
-            // We should be protected by CRC here
-            int packLen=len;
-            printf("[TsDemuxer] PCR 0x%x, len=%d\n",(r[0]<<8)+r[1],packLen);
-            r+=2;  
-                    int programInfoLength=(r[0]<<8)+r[1];
-                    programInfoLength&=0xfff;
-                    r+=2;
-                    printf("[PMT] PMT :%02x Program Info Len: %d\n",programInfoLength);    
-                    packLen-=(2+4);
-                    while(packLen>4)
-                    {
-                            int streamType,streamPid,esInfoLength;
-                            streamType=r[0];
-                            streamPid=(r[1]<<8)+r[2]&0x1fff;
-                            esInfoLength=((r[3]<<8)+r[4])&0xfff;
-                            r+=5;
-                            r+=esInfoLength;
-                            packLen-=5;
-                            packLen-=esInfoLength;
-
-                            printf("[PMT] PMT :%02x StreamType: 0x%x\n",pid,streamType);    
-                            printf("[PMT] PMT :%02x Pid:        0x%x\n",pid,streamPid);
-                            printf("[PMT] PMT :%02x Es Info Length: %d (0x%x)\n",pid,esInfoLength,esInfoLength);
-
-                    }
-
-
-         }
-        return false;
-}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-08 18:01:59 UTC (rev 4730)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2009-04-09 05:44:30 UTC (rev 4731)
@@ -9,6 +9,7 @@
 	ADM_tsAudioProbe.h
         ADM_tsComputeTimeStamp.cpp
         dmxTSPacket.cpp
+        ADM_tsPatPmt.cpp
 )
 
 ADD_LIBRARY(ADM_dm_ts SHARED ${ADM_ts_SRCS})



From mean at mail.berlios.de  Tue Apr 14 19:43:09 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 14 Apr 2009 19:43:09 +0200
Subject: [Avidemux-svn-commit] r4732 - in
	branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg:
	include src
Message-ID: <200904141743.n3EHh9NB026525@sheep.berlios.de>

Author: mean
Date: 2009-04-14 19:43:09 +0200 (Tue, 14 Apr 2009)
New Revision: 4732

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp
Log:
[dmx_io] Better detect end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h	2009-04-09 05:44:30 UTC (rev 4731)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h	2009-04-14 17:43:09 UTC (rev 4732)
@@ -57,7 +57,7 @@
                         uint8_t  setpos(uint64_t o);                
                         uint64_t getSize( void ) ;
                         uint32_t read32(uint32_t l, uint8_t *buffer);
-                        uint8_t  end(void) { return _off==_size-1;};
+                        uint8_t  end(void) { return _off>=_size-1;};
 						void hexDump(uint8_t *buf, int size);
                         uint8_t  peek8i(void); // Only call it once!!
 #ifdef NO_INLINE_FP

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp	2009-04-09 05:44:30 UTC (rev 4731)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp	2009-04-14 17:43:09 UTC (rev 4732)
@@ -511,7 +511,9 @@
 {
 uint8_t r;
     if(_off+1<_tail)
+    {
         r= _buffer[_off-_head];
+    }
     else    
     {
         read32(1,&r);



From mean at mail.berlios.de  Tue Apr 14 19:43:11 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 14 Apr 2009 19:43:11 +0200
Subject: [Avidemux-svn-commit] r4733 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904141743.n3EHhBYZ026539@sheep.berlios.de>

Author: mean
Date: 2009-04-14 19:43:11 +0200 (Tue, 14 Apr 2009)
New Revision: 4733

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
Log:
[TsDemuxer] debug statements + pmt engancements

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-14 17:43:09 UTC (rev 4732)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-14 17:43:11 UTC (rev 4733)
@@ -45,11 +45,12 @@
             if(prg) // if prg==0, it is network Pid, dont need it
                 listOfPmt.push_back(pid);
         }
-        if(listOfPmt.size())
+        int size=listOfPmt.size();
+        if(size)
         {
-            for(int i=0;i<listOfPmt.size();i++) // First PMT is PCR lock ?
+            for(int i=0;i<size;i++) // First PMT is PCR lock ?
             {
-                
+                printf("<<< PMT : %d/%d>>>\n",i,size);
                 uint32_t pid=listOfPmt[i];
                 scanPmt(t,pid);
             }
@@ -68,36 +69,35 @@
     uint8_t buffer[200];
     uint32_t len,current,max;
     uint8_t *r=buffer;
-    printf("[TsDemuxer] Looking for PMT : %x\n",pid);
+    printf("[TsDemuxer] Looking for PMT : 0x%x\n",pid);
     if(t->getNextPSI(pid,buffer,&len,&current,&max)==true)
-         {
-            // We should be protected by CRC here
-            int packLen=len;
-            printf("[TsDemuxer] PCR 0x%x, len=%d\n",(r[0]<<8)+r[1],packLen);
-            r+=2;  
-                    int programInfoLength=(r[0]<<8)+r[1];
-                    programInfoLength&=0xff;
-                    r+=2;
-                    printf("[PMT] PMT :%02x Program Info Len: %d\n",pid,programInfoLength);    
-                    packLen-=(2+4);
-                    while(packLen>4)
-                    {
-                            int streamType,streamPid,esInfoLength;
-                            streamType=r[0];
-                            streamPid=(r[1]<<8)+r[2]&0x1fff;
-                            esInfoLength=((r[3]<<8)+r[4])&0xfff;
-                            r+=5;
-                            r+=esInfoLength;
-                            packLen-=5;
-                            packLen-=esInfoLength;
+     {
+        // We should be protected by CRC here
+        int packLen=len;
+        printf("[TsDemuxer] PCR 0x%x, len=%d\n",(r[0]<<8)+r[1],packLen);
+        r+=2;  
+        int programInfoLength=(r[0]<<8)+r[1];
+        programInfoLength&=0xff;
+        r+=2;
+        printf("[PMT] PMT :%02x Program Info Len: %d\n",pid,programInfoLength);    
+        packLen-=(2+4);
+        while(packLen>4)
+        {
+                int streamType,streamPid,esInfoLength;
+                streamType=r[0];
+                streamPid=(r[1]<<8)+r[2]&0x1fff;
+                esInfoLength=((r[3]<<8)+r[4])&0xfff;
+                r+=5;
+                r+=esInfoLength;
+                packLen-=5;
+                packLen-=esInfoLength;
 
-                            printf("[PMT] PMT :%02x StreamType: 0x%x\n",pid,streamType);    
-                            printf("[PMT] PMT :%02x Pid:        0x%x\n",pid,streamPid);
-                            printf("[PMT] PMT :%02x Es Info Length: %d (0x%x)\n",pid,esInfoLength,esInfoLength);
+                printf("[PMT] PMT :%02x StreamType: 0x%x\n",pid,streamType);    
+                printf("[PMT] PMT :%02x Pid:        0x%x\n",pid,streamPid);
+                printf("[PMT] PMT :%02x Es Info Length: %d (0x%x)\n",pid,esInfoLength,esInfoLength);
 
-                    }
-
-
-         }
-        return false;
+        }
+        return true;
+     }
+    return false;
 }
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-14 17:43:09 UTC (rev 4732)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-14 17:43:11 UTC (rev 4733)
@@ -42,9 +42,6 @@
         printf(" [TS Demuxer] Not a ts file\n");
         return false;
     }
-
-   
-
     sprintf(index,"%s.idx",fileName);
 again:    
     if(ADM_fileExist(index)) 
@@ -60,7 +57,7 @@
         return false;
     }
     if(count) return false;
-    printf("[TSDemuxer] Creating index..\n");
+    printf("[TSDemuxer] Analyzing file..\n");
     count++;
     if(scanForPrograms(fileName)==false) return 0;
     if(true==tsIndexer(fileName)) goto again;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-14 17:43:09 UTC (rev 4732)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-14 17:43:11 UTC (rev 4733)
@@ -109,20 +109,37 @@
 {
     uint8_t scratch[16];
 #define MAX_SKIPPED_PACKET 6000
-    int count=MAX_SKIPPED_PACKET;
+#define MAX_SEARCH 2048
+    int count=0;
 again:
-    count--;
-    if(!count) return false;
-    while(_file->read8i()!=TS_MARKER && _file->end()!=true) ;
+    while(1)
+    {
+        uint8_t r=_file->read8i();
+        if(r==TS_MARKER || _file->end()) break;
+        count++;
+        if(count>MAX_SEARCH) 
+        {
+            printf("[Mpeg TS] Sync definitevly lost\n");
+            return false;
+        }
+#ifdef TS_DEBUG1
+        uint64_t pos=_file->getpos(&pos);
+        printf("[%02d] count=%d at 0x%x\n",r,count,pos);
+#endif
+    }
     if(_file->end()==true) 
     {
+        printf("[Mpeg Ts] End of file reached\n");
         return false;
     }
     _file->read32(TS_PACKET_LEN-1,buffer); // 184-1
     if(extraCrap)  _file->read32(extraCrap,scratch);
-    if(_file->peek8i()!=TS_MARKER)
+    uint8_t r=_file->peek8i();
+    if(r!=TS_MARKER)
     {
-        printf("[tsPacket] Sync lost\n");
+#ifdef TS_DEBUG1
+        printf("[tsPacket] Sync lost (0x%x)\n",r);
+#endif
         goto again;
     }
     return true;
@@ -135,17 +152,27 @@
 bool tsPacket::getNextPacket_NoHeader(uint32_t pid,uint8_t *buffer,uint32_t *olen,bool psi)
 {
     uint8_t scratch[188+4];
+    int count=0;
 nextPack:
 
     if(false==getSinglePacket(scratch)) return false;
     uint32_t id=scratch[1]+((scratch[0]&0x1F)<<8);
+//#define TS_DEBUG2
+#ifdef TS_DEBUG2
+        printf("[Demuxer] Looking for 0x%x found 0x%x\n",pid,id);
+#endif
+    count++;
+    if(count>MAX_SKIPPED_PACKET) return false;
+
     if(id!=pid) goto nextPack;
+#ifdef TS_DEBUG2
+    printf("[**************> Found matching pid 0x%x\n",pid);
+#endif
     
-
     int payloadUnitStart=scratch[0]&0x40;
     int fieldControl=(scratch[2]>>4)&3;
     int continuity=(scratch[2]&0xf);
-    int len=TS_PACKET_LEN-4; // usefull datas
+    int len=TS_PACKET_LEN-4; // useful datas
     // Adaptation field
     // 11 Adapt+payload
     // 10 Adapt only
@@ -154,11 +181,14 @@
     if(!(fieldControl & 1)) 
     {
         // No payload, continue
+#ifdef TS_DEBUG2
+        printf("[Demuxer] No payload\n");
+#endif        
         goto nextPack;
     }
     uint8_t *start,*end;
     start=scratch+3;
-    end=scratch+187;
+    end=scratch+TS_PACKET_LEN-1;
 
     if((fieldControl & 2)|| psi) // Adaptation layer
     {
@@ -166,7 +196,14 @@
         start+=payloadSize;
     }
     int size=(int)(end-start);
-    if(size<=0)  goto nextPack;
+    if(size<=0)  
+    {
+#ifdef TS_DEBUG2
+        printf("[Demuxer] size=%d\n",size);
+#endif        
+
+        goto nextPack;
+    }
     memcpy(buffer,start,size);
     *olen=size;
     return true;
@@ -192,7 +229,7 @@
     uint32_t dummy;
     
 
-    init_get_bits( &s,scratch, (len-4)*8);
+    init_get_bits( &s,scratch, (len)*8); // dont need checksum
 
     DUMMY(tableId,8);
     skip_bits(&s,1);             // Section syntax indicator
@@ -203,7 +240,13 @@
     }
     skip_bits(&s,2);
     sectionLength=get_bits(&s,12);    // Section Length
-    if(sectionLength+3>len) goto nextPack2;
+#if 0
+    if(sectionLength+3>len) 
+    {
+        printf("[MpegTs] sectionLength=%d, len=%d\n",sectionLength,len);
+        goto nextPack2;
+    }
+#endif
     transportStreamId=get_bits(&s,16);// transportStreamId
     printf("[MpegTs] Section length    =%d\n",sectionLength);
     printf("[MpegTs] transportStreamId =%d\n",transportStreamId);
@@ -212,7 +255,7 @@
     DUMMY(CurrentNext,1);           // Current Next indicator
     *count=get_bits(&s,8);           // Section number
     *countMax=get_bits(&s,8);        // Section last number
-
+    printf("[MpegTs] Count=%d CountMax=%d\n",*count,*countMax);
     if(*count!=*countMax) return false; // we dont handle split psi at the moment
 
     uint8_t *c=scratch+sectionLength-4+3;



From mean at mail.berlios.de  Tue Apr 14 19:43:13 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 14 Apr 2009 19:43:13 +0200
Subject: [Avidemux-svn-commit] r4734 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904141743.n3EHhDnF026572@sheep.berlios.de>

Author: mean
Date: 2009-04-14 19:43:13 +0200 (Tue, 14 Apr 2009)
New Revision: 4734

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Log:
[DemuxerTs] Read PMT completely

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-14 17:43:11 UTC (rev 4733)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-14 17:43:13 UTC (rev 4734)
@@ -20,21 +20,58 @@
 #include "ADM_demuxerInternal.h"
 #include "ADM_tsPatPmt.h"
 /**
+    \class TrackTypeDescriptor
+*/
+class TrackTypeDescriptor
+{
+public:
+    int                 type;
+    ADM_TS_TRACK_TYPE   trackType;
+    const char          *desc;
+    static TrackTypeDescriptor *find(int t);
+};
+TrackTypeDescriptor TrackTypes[]=
+{
+    {0x002,ADM_TS_MPEG2,     "Mpeg2 Video"},
+    {0x003,ADM_TS_MPEG_AUDIO,"Mpeg1 Audio"},
+    {0x004,ADM_TS_MPEG_AUDIO,"Mpeg2 Audio"},
+    {0x01b,ADM_TS_H264,      "H264 Video"},
+    {0x081,ADM_TS_AC3,       "AC3 Audio"},
+    {0x006,ADM_TS_UNKNOWN,   "Private Stream"},
+    {0xfff,ADM_TS_UNKNOWN,   "Unknown"}   // Last one must be "unknown!"
+};
+/**
+    \fn find
+*/
+TrackTypeDescriptor *TrackTypeDescriptor::find(int t)
+{
+    int size=sizeof(TrackTypes)/sizeof(TrackTypeDescriptor);
+    for(int i=0;i<size;i++)
+    {
+        TrackTypeDescriptor *tp=TrackTypes+i;
+        if(tp->type==t) return tp;
+    }
+    return TrackTypes+size-1;
+}
+/**
     \fn scanForPrograms
+    \brief Lookup PAT & PMT to get tracks
 */
-bool scanForPrograms(const char *file)
+bool TS_scanForPrograms(const char *file,uint32_t *nbTracks, ADM_TS_TRACK *tracks)
 {
-    uint8_t buffer[200];
-    uint32_t len,current,max;
+    
+    uint32_t len;
+    TS_PSIpacketInfo psi;
 
     vector <uint32_t>listOfPmt;
 
     tsPacket *t=new tsPacket();
     t->open(file,FP_PROBE);
     // 1 search the pat...
-    if(t->getNextPSI(0,buffer,&len,&current,&max)==true)
+    if(t->getNextPSI(0,&psi)==true)
     {
-        uint8_t *r=buffer;
+        uint8_t *r=psi.payload;
+        len=psi.payloadSize;
         while(len>=4)
         {
             uint32_t prg=((0x1F&r[0])<<8)+r[1];
@@ -52,7 +89,7 @@
             {
                 printf("<<< PMT : %d/%d>>>\n",i,size);
                 uint32_t pid=listOfPmt[i];
-                scanPmt(t,pid);
+                TS_scanPmt(t,pid,NULL,NULL);
             }
 
         }
@@ -62,16 +99,20 @@
     return 0;
 }
 /**
-    \fn scanPmt
+    \fn TS_scanPmt
+    \brief Lookup one PMT and returns content
 */
-bool scanPmt(tsPacket *t,uint32_t pid)
+bool TS_scanPmt(tsPacket *t,uint32_t pid,uint32_t *nbTracks, ADM_TS_TRACK *tracks)
 {
-    uint8_t buffer[200];
-    uint32_t len,current,max;
-    uint8_t *r=buffer;
+
+    uint32_t len;
+    TS_PSIpacketInfo psi;
+    uint8_t *r=psi.payload;
+
     printf("[TsDemuxer] Looking for PMT : 0x%x\n",pid);
-    if(t->getNextPSI(pid,buffer,&len,&current,&max)==true)
+    if(t->getNextPSI(pid,&psi)==true)
      {
+        len=psi.payloadSize;
         // We should be protected by CRC here
         int packLen=len;
         printf("[TsDemuxer] PCR 0x%x, len=%d\n",(r[0]<<8)+r[1],packLen);
@@ -88,16 +129,45 @@
                 streamPid=(r[1]<<8)+r[2]&0x1fff;
                 esInfoLength=((r[3]<<8)+r[4])&0xfff;
                 r+=5;
-                r+=esInfoLength;
                 packLen-=5;
                 packLen-=esInfoLength;
-
-                printf("[PMT] PMT :%02x StreamType: 0x%x\n",pid,streamType);    
-                printf("[PMT] PMT :%02x Pid:        0x%x\n",pid,streamPid);
-                printf("[PMT] PMT :%02x Es Info Length: %d (0x%x)\n",pid,esInfoLength,esInfoLength);
-
+                TrackTypeDescriptor *td=TrackTypeDescriptor::find(streamType);
+                printf("[PMT] PMT :%02x StreamType: 0x%x,<<%s>>\n",pid,streamType,td->desc);    
+                printf("[PMT]           Pid:        0x%x\n",streamPid);
+                printf("[PMT]           Es Info Length: %d (0x%x)\n",esInfoLength,esInfoLength);
+                uint8_t *p=r,*pend=r+esInfoLength;
+                r+=esInfoLength;
+                while(p<pend)
+                {
+                    uint32_t tag,taglen;
+                    tag=p[0];
+                    taglen=p[1];
+                    printf("[PMT]           Tag :%x len:%d =",tag,taglen);
+                    switch(tag) //http://www.coolstf.com/tsreader/descriptors.html
+                    {
+                        
+                        case 0x05: printf("Registration Descriptor :%c%c%c%c",p[2],p[3],p[4],p[5]);break;
+                        case 0x0a: printf("Language descriptor :%c%c%c",p[2],p[3],p[4]);break;
+                        case 0x11: printf("STD\n");break;
+                        case 0x1e: printf("SL descriptor (H264 AAC ????)");break;
+                        case 0x45: printf("VBI data\n");break;
+                        case 0x52: printf("Stream identifier");break;
+                        case 0x56: printf("Teletext");break;
+                        case 0x59: printf("DVB subtitles");break;
+                        case 0x7b: printf("DTS Descriptor");break;
+                        case 0x7a:
+                        case 0x6a: printf("AC3 Descriptor");break;
+                        
+                                                break;
+                        
+                        default : printf("unknown");break;
+                    }
+                    printf("\n");
+                    p+=2+taglen;
+                }
         }
         return true;
      }
     return false;
-}
\ No newline at end of file
+}
+//EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h	2009-04-14 17:43:11 UTC (rev 4733)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h	2009-04-14 17:43:13 UTC (rev 4734)
@@ -17,15 +17,45 @@
  ***************************************************************************/
 #ifndef ADM_TS_PAT_PMT_H
 #define ADM_TS_PAT_PMT_H
+
+#define ADM_TS_MAX_EXTRADATA 256
 /**
-    \fn scanForPrograms
+    \typedef ADM_TS_VIDEO_TYPE
 */
+typedef enum
+{
+    ADM_TS_UNKNOWN=0,
+    ADM_TS_MPEG2,
+    ADM_TS_H264,
+    ADM_TS_MPEG_AUDIO=10,
+    ADM_TS_AC3,
+    ADM_TS_AAC
+}ADM_TS_TRACK_TYPE;
+/**
+    \typedef ADM_TS_TRACK
+*/
+typedef struct
+{
+    uint32_t          trackPid;
+    ADM_TS_TRACK_TYPE trackType;
+    uint32_t          extraDataLen;
+    uint8_t           extraData[ADM_TS_MAX_EXTRADATA];
+}ADM_TS_TRACK;
 
-bool scanForPrograms(const char *file);
 
 /**
+    \fn TS_scanForPrograms
+    \brief Analyze a stream and returns tracks within
+    @param in:file File to open
+    @param out:nbTracks Number of tracks found
+    @param out:tracks, to be freed by delete [] by the caller
+*/
+
+bool TS_scanForPrograms(const char *file,uint32_t *nbTracks, ADM_TS_TRACK *tracks);
+
+/**
     \fn scanPmt
 */
-bool scanPmt(tsPacket *t,uint32_t pid);
+bool TS_scanPmt(tsPacket *t,uint32_t pid,uint32_t *nbTracks, ADM_TS_TRACK *tracks);
 #endif
 //EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-14 17:43:11 UTC (rev 4733)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-14 17:43:13 UTC (rev 4734)
@@ -37,7 +37,7 @@
 char index[strlen(fileName)+4];
 int count=0;
     printf("[TS Demuxer] Probing...\n");
-    if(0 && !detectTs(fileName))
+    if( !detectTs(fileName))
     {
         printf(" [TS Demuxer] Not a ts file\n");
         return false;
@@ -59,7 +59,7 @@
     if(count) return false;
     printf("[TSDemuxer] Analyzing file..\n");
     count++;
-    if(scanForPrograms(fileName)==false) return 0;
+    if(TS_scanForPrograms(fileName,NULL,NULL)==false) return 0;
     if(true==tsIndexer(fileName)) goto again;
     printf("[TSDemuxer] Failed..\n");
    return 0;
@@ -81,13 +81,13 @@
     bufferSize=fread(buffer,1,PROBE_SIZE,f);
     fclose(f);
     // Do a simple check by checking we have 0x47....0x47 several time in a raw
-    if(true==checkMarker(buffer,bufferSize,188))
+    if(true==checkMarker(buffer,bufferSize,TS_PACKET_LEN))
     {
         printf("[TS Demuxer] 188 bytes packet detected\n");
         return true;
     }
     // Do a simple check by checking we have 0x47....0x47 several time in a raw
-    if(true==checkMarker(buffer,bufferSize,192))
+    if(true==checkMarker(buffer,bufferSize,TS_PACKET_LEN+4))
     {
         printf("[TS Demuxer] 192 bytes packet detected\n");
         return true;
@@ -125,7 +125,8 @@
         buffer++;
     }
     printf("[Ts Demuxer] Sync ok :%d Sync ko :%d\n",syncOk,syncKo);
-    if(!syncOk) return false;
+
     if(syncOk>5*syncKo) return true;
+    return false;
 }
 //EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-14 17:43:11 UTC (rev 4733)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-14 17:43:13 UTC (rev 4734)
@@ -23,8 +23,8 @@
 #include "dmxTSPacket.h"
 #include "dmx_mpegstartcode.h"
 
-#define TS_PACKET_LEN 188
 
+
 #define ADM_NO_CONFIG_H
 extern "C"
 {
@@ -149,7 +149,7 @@
     \fn getNextPsiPacket
     \brief Take a raw packet of type pid & remove the header
 */
-bool tsPacket::getNextPacket_NoHeader(uint32_t pid,uint8_t *buffer,uint32_t *olen,bool psi)
+bool tsPacket::getNextPacket_NoHeader(uint32_t pid,TSpacketInfo *pkt,bool psi)
 {
     uint8_t scratch[188+4];
     int count=0;
@@ -165,6 +165,7 @@
     if(count>MAX_SKIPPED_PACKET) return false;
 
     if(id!=pid) goto nextPack;
+    pkt->pid=pid;
 #ifdef TS_DEBUG2
     printf("[**************> Found matching pid 0x%x\n",pid);
 #endif
@@ -173,6 +174,9 @@
     int fieldControl=(scratch[2]>>4)&3;
     int continuity=(scratch[2]&0xf);
     int len=TS_PACKET_LEN-4; // useful datas
+
+    pkt->continuityCounter=continuity;
+    pkt->payloadStart=payloadUnitStart;
     // Adaptation field
     // 11 Adapt+payload
     // 10 Adapt only
@@ -204,8 +208,8 @@
 
         goto nextPack;
     }
-    memcpy(buffer,start,size);
-    *olen=size;
+    memcpy(pkt->payload,start,size);
+    pkt->payloadSize=size;
     return true;
 }
 
@@ -213,14 +217,17 @@
     \fn getNextPsiPacket
     \brief Take a raw packet of type pid & remove the header (PSI)
 */
+#ifdef VERBOSE_PSI
 #define DUMMY(x,n) {dummy=get_bits(&s,n);printf("[TS]: "#x" =0x%x %d\n",dummy,dummy);}
-bool tsPacket::getNextPSI(uint32_t pid,uint8_t *buffer,uint32_t *olen,uint32_t *count, uint32_t *countMax)
+#else
+#define DUMMY(x,n) {dummy=get_bits(&s,n);}
+#endif
+bool tsPacket::getNextPSI(uint32_t pid,TS_PSIpacketInfo *psi)
 {
-    uint8_t scratch[188+4];
-    uint32_t len;
+    TSpacketInfo pkt;
 nextPack2:
 
-    if(false==getNextPacket_NoHeader(pid,(uint8_t *)scratch,&len,true)) return false;    
+    if(false==getNextPacket_NoHeader(pid,&pkt,true)) return false;    
 
     GetBitContext s;
     uint32_t tableId;
@@ -229,7 +236,7 @@
     uint32_t dummy;
     
 
-    init_get_bits( &s,scratch, (len)*8); // dont need checksum
+    init_get_bits( &s,pkt.payload, (pkt.payloadSize)*8); // dont need checksum
 
     DUMMY(tableId,8);
     skip_bits(&s,1);             // Section syntax indicator
@@ -240,28 +247,32 @@
     }
     skip_bits(&s,2);
     sectionLength=get_bits(&s,12);    // Section Length
-#if 0
-    if(sectionLength+3>len) 
+#if 1
+    if(sectionLength+3>pkt.payloadSize) 
     {
-        printf("[MpegTs] sectionLength=%d, len=%d\n",sectionLength,len);
+        printf("[MpegTs] sectionLength=%d, len=%d\n",sectionLength,pkt.payloadSize);
         goto nextPack2;
     }
 #endif
     transportStreamId=get_bits(&s,16);// transportStreamId
+#ifdef VERBOSE_PSI
     printf("[MpegTs] Section length    =%d\n",sectionLength);
     printf("[MpegTs] transportStreamId =%d\n",transportStreamId);
+#endif
     skip_bits(&s,2);                  // ignored
     DUMMY(VersionNumber,5);         // Version number
     DUMMY(CurrentNext,1);           // Current Next indicator
-    *count=get_bits(&s,8);           // Section number
-    *countMax=get_bits(&s,8);        // Section last number
-    printf("[MpegTs] Count=%d CountMax=%d\n",*count,*countMax);
-    if(*count!=*countMax) return false; // we dont handle split psi at the moment
+    psi->count=get_bits(&s,8);           // Section number
+    psi->countMax=get_bits(&s,8);        // Section last number
+#ifdef VERBOSE_PSI
+    printf("[MpegTs] Count=%d CountMax=%d\n",psi->count,psi->countMax);
+#endif
+    if(psi->count!=psi->countMax) return false; // we dont handle split psi at the moment
 
-    uint8_t *c=scratch+sectionLength-4+3;
+    uint8_t *c=pkt.payload+sectionLength-4+3;
 
 // Verify CRC
-    uint32_t crc1=mpegTsCRC(scratch,sectionLength-4+3);
+    uint32_t crc1=mpegTsCRC(pkt.payload,sectionLength-4+3);
     uint32_t crc2=(c[0]<<24)+(c[1]<<16)+(c[2]<<8)+c[3];
     if(crc1!=crc2)
     {
@@ -273,8 +284,8 @@
     int hdr=(8+16+16+8+8+8)/8;
     int payloadsize=sectionLength-4-5; // Remove checksum & header
     if(payloadsize<4) goto nextPack2;
-    *olen=payloadsize;
-    memcpy(buffer,scratch+hdr,*olen);
+    psi->payloadSize=payloadsize;
+    memcpy(psi->payload,pkt.payload+hdr,psi->payloadSize);
     return true;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-14 17:43:11 UTC (rev 4733)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-14 17:43:13 UTC (rev 4734)
@@ -11,9 +11,37 @@
 #include "dmxPacket.h"
 #include "ADM_Video.h"
 
-#define TS_MARKER 0x47
+#define TS_MARKER       0x47
+#define TS_PACKET_LEN   188
+#define TS_PSI_MAX_LEN  1024
+/**
+    \class TSpacketInfo
+*/
+class TSpacketInfo
+{
+public:
+    uint32_t    pid;
+    uint32_t    payloadSize;
+    bool        payloadStart;
+    uint32_t    continuityCounter;
+    uint8_t     payload[TS_PACKET_LEN];
+};
 
+
 /**
+    \class TS_PSIpacketInfo
+*/
+class TS_PSIpacketInfo
+{
+public:
+    uint32_t    pid;
+    uint32_t    payloadSize;
+    uint8_t     payload[TS_PSI_MAX_LEN];
+    uint32_t    count;
+    uint32_t    countMax;
+};
+
+/**
     \class tsPacket
 */
 class tsPacket : public ADMMpegPacket
@@ -30,10 +58,10 @@
     virtual uint64_t    getPos(void);
     virtual bool        setPos(uint64_t pos);
 protected:
-    bool                getNextPacket_NoHeader(uint32_t pid,uint8_t *buffer,uint32_t *len,bool psi);
+    bool                getNextPacket_NoHeader(uint32_t pid,TSpacketInfo *pkt,bool psi);
     bool                getSinglePacket(uint8_t *buffer);
 public:
-    bool                getNextPSI(uint32_t pid,uint8_t *buffer,uint32_t *olen,uint32_t *count, uint32_t *countMax);
+    bool                getNextPSI(uint32_t pid,TS_PSIpacketInfo *psi);
 
 };
 /**



From mean at mail.berlios.de  Tue Apr 14 19:43:15 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 14 Apr 2009 19:43:15 +0200
Subject: [Avidemux-svn-commit] r4735 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904141743.n3EHhFpx026603@sheep.berlios.de>

Author: mean
Date: 2009-04-14 19:43:15 +0200 (Tue, 14 Apr 2009)
New Revision: 4735

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Log:
[Ts Demuxer] Extract PES packet

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-14 17:43:13 UTC (rev 4734)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-14 17:43:15 UTC (rev 4735)
@@ -19,7 +19,16 @@
 #include "ADM_ts.h"
 #include "ADM_demuxerInternal.h"
 #include "ADM_tsPatPmt.h"
+
+typedef vector <ADM_TS_TRACK> listOfTsTracks;
+
 /**
+    \fn scanPmt
+*/
+static bool TS_scanPmt(tsPacket *t,uint32_t pid,listOfTsTracks *list);
+
+
+/**
     \class TrackTypeDescriptor
 */
 class TrackTypeDescriptor
@@ -40,6 +49,9 @@
     {0x006,ADM_TS_UNKNOWN,   "Private Stream"},
     {0xfff,ADM_TS_UNKNOWN,   "Unknown"}   // Last one must be "unknown!"
 };
+
+
+
 /**
     \fn find
 */
@@ -57,13 +69,16 @@
     \fn scanForPrograms
     \brief Lookup PAT & PMT to get tracks
 */
-bool TS_scanForPrograms(const char *file,uint32_t *nbTracks, ADM_TS_TRACK *tracks)
+bool TS_scanForPrograms(const char *file,uint32_t *nbTracks, ADM_TS_TRACK **outTracks)
 {
-    
     uint32_t len;
     TS_PSIpacketInfo psi;
-
+    listOfTsTracks   list;
     vector <uint32_t>listOfPmt;
+    ADM_TS_TRACK *tracks=NULL;
+    *outTracks=NULL;
+    *nbTracks=0;
+    uint32_t nb=0;
 
     tsPacket *t=new tsPacket();
     t->open(file,FP_PROBE);
@@ -89,29 +104,100 @@
             {
                 printf("<<< PMT : %d/%d>>>\n",i,size);
                 uint32_t pid=listOfPmt[i];
-                TS_scanPmt(t,pid,NULL,NULL);
+                t->setPos(0); // Make sure we can have the very first one
+                TS_scanPmt(t,pid,&list);
             }
 
         }
     }
+    // List now contains a list of elementary tracks
+
+    // TODO: Look deeper to see if there is actual content
+    // Some channels advertsise languages that they may have
+    // but dont actually exists in the file
+    // Allocate output files, max size=list.size
+    
+    printf("[TS Demuxer] Found %u interesting tracks\n",(unsigned int)list.size());
+    
+    // Search the video track...
+    bool result=false;
+    int videoIndex=-1;
+    for(int i=0;i<list.size();i++)
+    {
+        ADM_TS_TRACK_TYPE type=list[i].trackType;
+        if(type==ADM_TS_MPEG2 || type==ADM_TS_H264)
+        {
+            videoIndex=i;
+            break;
+        }
+    }
+    if(videoIndex==-1)
+    {
+        printf("[Ts Demuxer] Cannot find a video track\n");
+        goto _failTs;
+    }
+    //
+#if 1 // TO REMOVE
+    TS_PESpacket pes;
+    t->getNextPES(list[videoIndex].trackPid,&pes);
+    t->getNextPES(list[videoIndex].trackPid,&pes);
+    t->getNextPES(list[videoIndex].trackPid,&pes);
+    t->getNextPES(list[videoIndex].trackPid,&pes);
+#endif
+    // After here we cannot fail (normally...)
+    tracks=new ADM_TS_TRACK[list.size()];
+    *outTracks=tracks;
+    // Copy video track
+    tracks[0]=list[videoIndex];
+    // and remove it from the list
+    list.erase(list.begin()+videoIndex);
+    nb++;
+    // Also add audio tracks we know of
+     for(int i=0;i<list.size();i++)
+    {
+        ADM_TS_TRACK_TYPE type=list[i].trackType;
+        if(type==ADM_TS_MPEG_AUDIO || type==ADM_TS_AC3 || type==ADM_TS_AAC)
+        {
+            TSpacketInfo pkt;
+            t->setPos(0);
+            if(true==t->getNextPacket_NoHeader(list[i].trackPid,&pkt,false))
+                tracks[nb++]=list[i];
+            else        
+                printf("[TS Demuxer] Track %i pid 0x%x does not seem to be there\n",i,list[i].trackPid);
+        }
+    }
+    *nbTracks=nb;
+    result=true;
+    
+_failTs:
     delete t;
+    // Delete the list
+    list.erase(list.begin(),list.end()-1);
+    if(result==true)
+    {
+        printf("[T Demuxer] Kept %d tracks\n",*nbTracks);
+    }
     printf("[TS Demuxer] Probed...\n");
-    return 0;
+    
+    return result;
 }
 /**
     \fn TS_scanPmt
     \brief Lookup one PMT and returns content
 */
-bool TS_scanPmt(tsPacket *t,uint32_t pid,uint32_t *nbTracks, ADM_TS_TRACK *tracks)
+bool TS_scanPmt(tsPacket *t,uint32_t pid,listOfTsTracks *list)
 {
-
+    ADM_TS_TRACK trk;
     uint32_t len;
     TS_PSIpacketInfo psi;
     uint8_t *r=psi.payload;
-
+    trk.trackType=ADM_TS_UNKNOWN;
+    trk.trackPid=pid;
     printf("[TsDemuxer] Looking for PMT : 0x%x\n",pid);
     if(t->getNextPSI(pid,&psi)==true)
      {
+        
+        
         len=psi.payloadSize;
         // We should be protected by CRC here
         int packLen=len;
@@ -135,6 +221,9 @@
                 printf("[PMT] PMT :%02x StreamType: 0x%x,<<%s>>\n",pid,streamType,td->desc);    
                 printf("[PMT]           Pid:        0x%x\n",streamPid);
                 printf("[PMT]           Es Info Length: %d (0x%x)\n",esInfoLength,esInfoLength);
+                
+                trk.trackType=td->trackType;
+                trk.trackPid=streamPid;
                 uint8_t *p=r,*pend=r+esInfoLength;
                 r+=esInfoLength;
                 while(p<pend)
@@ -149,7 +238,7 @@
                         case 0x05: printf("Registration Descriptor :%c%c%c%c",p[2],p[3],p[4],p[5]);break;
                         case 0x0a: printf("Language descriptor :%c%c%c",p[2],p[3],p[4]);break;
                         case 0x11: printf("STD\n");break;
-                        case 0x1e: printf("SL descriptor (H264 AAC ????)");break;
+                        case 0x1e: printf("SL descriptor (H264 AAC ?)");break;
                         case 0x45: printf("VBI data\n");break;
                         case 0x52: printf("Stream identifier");break;
                         case 0x56: printf("Teletext");break;
@@ -157,14 +246,13 @@
                         case 0x7b: printf("DTS Descriptor");break;
                         case 0x7a:
                         case 0x6a: printf("AC3 Descriptor");break;
-                        
-                                                break;
-                        
                         default : printf("unknown");break;
                     }
                     printf("\n");
                     p+=2+taglen;
                 }
+                // 
+                if(trk.trackType!=ADM_TS_UNKNOWN) list->push_back(trk);
         }
         return true;
      }

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h	2009-04-14 17:43:13 UTC (rev 4734)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h	2009-04-14 17:43:15 UTC (rev 4735)
@@ -51,11 +51,7 @@
     @param out:tracks, to be freed by delete [] by the caller
 */
 
-bool TS_scanForPrograms(const char *file,uint32_t *nbTracks, ADM_TS_TRACK *tracks);
+bool TS_scanForPrograms(const char *file,uint32_t *nbTracks, ADM_TS_TRACK **tracks);
 
-/**
-    \fn scanPmt
-*/
-bool TS_scanPmt(tsPacket *t,uint32_t pid,uint32_t *nbTracks, ADM_TS_TRACK *tracks);
 #endif
 //EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-14 17:43:13 UTC (rev 4734)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-14 17:43:15 UTC (rev 4735)
@@ -59,8 +59,15 @@
     if(count) return false;
     printf("[TSDemuxer] Analyzing file..\n");
     count++;
-    if(TS_scanForPrograms(fileName,NULL,NULL)==false) return 0;
-    if(true==tsIndexer(fileName)) goto again;
+
+    ADM_TS_TRACK *tracks;
+    uint32_t nbTracks;
+
+    if(TS_scanForPrograms(fileName,&nbTracks,&tracks)==false) return 0;
+    ADM_assert(tracks);
+    ADM_assert(nbTracks);
+    delete [] tracks;
+    //if(true==tsIndexer(fileName)) goto again;
     printf("[TSDemuxer] Failed..\n");
    return 0;
 }

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-14 17:43:13 UTC (rev 4734)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-14 17:43:15 UTC (rev 4735)
@@ -43,6 +43,11 @@
 tsPacket::tsPacket(void) 
 {
     extraCrap=0; // =4 for ts2
+    internalPesBuffer=(uint8_t *)ADM_alloc(2048);
+    internalPesBufferSize=0;
+    internalPesBufferLimit=2048;
+    internalBufferOffset=0;
+
 }
 /**
     \fn tsPacket
@@ -80,9 +85,28 @@
         delete _file;
         _file=NULL;
     }
+    if(internalPesBuffer)
+    {
+        ADM_dealloc(internalPesBuffer);
+        internalPesBuffer=NULL;
+    }
     return true;
 }
 /**
+    \fn PesAddData
+*/
+bool tsPacket::PesAddData(uint32_t len,uint8_t *data)
+{
+    if(internalPesBufferSize+len>internalPesBufferLimit)
+    {
+        internalPesBufferLimit*=2;
+        internalPesBuffer=(uint8_t *)ADM_realloc(internalPesBuffer,internalPesBufferLimit);
+    }
+    memcpy(internalPesBuffer+internalPesBufferSize,data,len);
+    internalPesBufferSize+=len;
+    return true;
+}
+/**
     \fn getPos
 */
 uint64_t    tsPacket::getPos(void)
@@ -289,6 +313,62 @@
     return true;
 }
 /**
+        \fn getNextPES
+        \brief Returns the next PES packet
+        Warning : Does not work with unbound packet!
+*/
+extern void mixDump(uint8_t *ptr, uint32_t len);
+bool        tsPacket::getNextPES(uint32_t pid,TS_PESpacket *pes)
+{
+#define zprintf printf
+    TSpacketInfo pkt;
+nextPack3:
+    // Sync at source
+    if(false==getNextPacket_NoHeader(pid,&pkt,false)) return false;    
+    // If it does not contain a payload strat continue
+    if(!pkt.payloadStart)
+    {
+        printf("[Ts Demuxer] Pes for Pid =0x%d does not contain payload start\n",pid);
+        goto nextPack3;
+    }
+    //____________________
+    //____________________
+    // 1- Start Headers
+    //____________________
+    //____________________
+    uint32_t code=(pkt.payload[0]<<24)+(pkt.payload[1]<<16)+(pkt.payload[2]<<8)+pkt.payload[3];
+    zprintf("[TS Demuxer] Code=0x%x pid=0x%x\n",code,pid);
+    if((code&0xffffff00)!=0x100)
+    {
+        printf("[Ts Demuxer] No PES startcode\n");
+        goto nextPack3;
+    }
+    mixDump(pkt.payload,pkt.payloadSize);
+    uint32_t pesPacketLen=(pkt.payload[4]<<8)+(pkt.payload[5]);
+    zprintf("[TS Demuxer] Pes Packet Len=%d\n",pesPacketLen);
+    
+    internalPesBufferSize=0;
+    PesAddData(pkt.payloadSize,pkt.payload);
+    while(1)
+    {
+        uint64_t pos;
+        _file->getpos(&pos);
+        if(false==getNextPacket_NoHeader(pid,&pkt,false)) return false;    
+        if(!pkt.payloadStart)
+         {
+                PesAddData(pkt.payloadSize,pkt.payload);
+         }else  
+         {
+                _file->setpos(pos);
+                break;
+         }
+    }
+    // Now decode PES header (extra memcpy)
+    printf("[Ts Demuxer] Found PES of len %d\n",internalPesBufferSize);
+    return true;
+}
+
+/**
     \fn getPacket
 */      
 bool        tsPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-14 17:43:13 UTC (rev 4734)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-14 17:43:15 UTC (rev 4735)
@@ -14,6 +14,7 @@
 #define TS_MARKER       0x47
 #define TS_PACKET_LEN   188
 #define TS_PSI_MAX_LEN  1024
+#define TS_PES_MAX_LEN  (10*1024)
 /**
     \class TSpacketInfo
 */
@@ -42,11 +43,31 @@
 };
 
 /**
+    \class TS_PESpacket
+*/
+class TS_PESpacket
+{
+public:
+    uint32_t    pid;
+    uint32_t    payloadSize;
+    uint8_t     payload[TS_PES_MAX_LEN];
+    uint64_t    pts;
+    uint64_t    dts;
+};
+
+/**
     \class tsPacket
 */
 class tsPacket : public ADMMpegPacket
 {
 protected:
+    uint8_t             *internalPesBuffer;
+    uint32_t            internalPesBufferSize;
+    uint32_t            internalPesBufferLimit;
+    uint32_t            internalBufferOffset;
+    bool                PesAddData(uint32_t len,uint8_t *data);
+
+
     uint32_t            extraCrap;
     uint8_t             getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
 public:
@@ -58,10 +79,13 @@
     virtual uint64_t    getPos(void);
     virtual bool        setPos(uint64_t pos);
 protected:
-    bool                getNextPacket_NoHeader(uint32_t pid,TSpacketInfo *pkt,bool psi);
+    
     bool                getSinglePacket(uint8_t *buffer);
 public:
+    bool                getNextPacket_NoHeader(uint32_t pid,TSpacketInfo *pkt,bool psi);
+
     bool                getNextPSI(uint32_t pid,TS_PSIpacketInfo *psi);
+    bool                getNextPES(uint32_t pid,TS_PESpacket *pes);
 
 };
 /**



From mean at mail.berlios.de  Tue Apr 14 19:43:17 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 14 Apr 2009 19:43:17 +0200
Subject: [Avidemux-svn-commit] r4736 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904141743.n3EHhHN6026616@sheep.berlios.de>

Author: mean
Date: 2009-04-14 19:43:17 +0200 (Tue, 14 Apr 2009)
New Revision: 4736

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Log:
[Ts Demuxer] Decode PES header (incomplete)

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-14 17:43:15 UTC (rev 4735)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-14 17:43:17 UTC (rev 4736)
@@ -136,39 +136,42 @@
         printf("[Ts Demuxer] Cannot find a video track\n");
         goto _failTs;
     }
-    //
-#if 1 // TO REMOVE
-    TS_PESpacket pes;
-    t->getNextPES(list[videoIndex].trackPid,&pes);
-    t->getNextPES(list[videoIndex].trackPid,&pes);
-    t->getNextPES(list[videoIndex].trackPid,&pes);
-    t->getNextPES(list[videoIndex].trackPid,&pes);
-#endif
-    // After here we cannot fail (normally...)
-    tracks=new ADM_TS_TRACK[list.size()];
-    *outTracks=tracks;
-    // Copy video track
-    tracks[0]=list[videoIndex];
-    // and remove it from the list
-    list.erase(list.begin()+videoIndex);
-    nb++;
-    // Also add audio tracks we know of
-     for(int i=0;i<list.size();i++)
     {
-        ADM_TS_TRACK_TYPE type=list[i].trackType;
-        if(type==ADM_TS_MPEG_AUDIO || type==ADM_TS_AC3 || type==ADM_TS_AAC)
+        //
+    #if 1 // TO REMOVE
+        TS_PESpacket pes(list[videoIndex].trackPid);
+        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
+        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
+        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
+        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
+        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
+        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
+    #endif
+        // After here we cannot fail (normally...)
+        tracks=new ADM_TS_TRACK[list.size()];
+        *outTracks=tracks;
+        // Copy video track
+        tracks[0]=list[videoIndex];
+        // and remove it from the list
+        list.erase(list.begin()+videoIndex);
+        nb++;
+        // Also add audio tracks we know of
+         for(int i=0;i<list.size();i++)
         {
-            TSpacketInfo pkt;
-            t->setPos(0);
-            if(true==t->getNextPacket_NoHeader(list[i].trackPid,&pkt,false))
-                tracks[nb++]=list[i];
-            else        
-                printf("[TS Demuxer] Track %i pid 0x%x does not seem to be there\n",i,list[i].trackPid);
+            ADM_TS_TRACK_TYPE type=list[i].trackType;
+            if(type==ADM_TS_MPEG_AUDIO || type==ADM_TS_AC3 || type==ADM_TS_AAC)
+            {
+                TSpacketInfo pkt;
+                t->setPos(0);
+                if(true==t->getNextPacket_NoHeader(list[i].trackPid,&pkt,false))
+                    tracks[nb++]=list[i];
+                else        
+                    printf("[TS Demuxer] Track %i pid 0x%x does not seem to be there\n",i,list[i].trackPid);
+            }
         }
+        *nbTracks=nb;
+        result=true;
     }
-    *nbTracks=nb;
-    result=true;
-    
 _failTs:
     delete t;
     // Delete the list

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-14 17:43:15 UTC (rev 4735)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-14 17:43:17 UTC (rev 4736)
@@ -43,11 +43,8 @@
 tsPacket::tsPacket(void) 
 {
     extraCrap=0; // =4 for ts2
-    internalPesBuffer=(uint8_t *)ADM_alloc(2048);
-    internalPesBufferSize=0;
-    internalPesBufferLimit=2048;
-    internalBufferOffset=0;
 
+
 }
 /**
     \fn tsPacket
@@ -85,28 +82,9 @@
         delete _file;
         _file=NULL;
     }
-    if(internalPesBuffer)
-    {
-        ADM_dealloc(internalPesBuffer);
-        internalPesBuffer=NULL;
-    }
     return true;
 }
 /**
-    \fn PesAddData
-*/
-bool tsPacket::PesAddData(uint32_t len,uint8_t *data)
-{
-    if(internalPesBufferSize+len>internalPesBufferLimit)
-    {
-        internalPesBufferLimit*=2;
-        internalPesBuffer=(uint8_t *)ADM_realloc(internalPesBuffer,internalPesBufferLimit);
-    }
-    memcpy(internalPesBuffer+internalPesBufferSize,data,len);
-    internalPesBufferSize+=len;
-    return true;
-}
-/**
     \fn getPos
 */
 uint64_t    tsPacket::getPos(void)
@@ -315,20 +293,20 @@
 /**
         \fn getNextPES
         \brief Returns the next PES packet
-        Warning : Does not work with unbound packet!
+        
 */
 extern void mixDump(uint8_t *ptr, uint32_t len);
-bool        tsPacket::getNextPES(uint32_t pid,TS_PESpacket *pes)
+bool        tsPacket::getNextPES(TS_PESpacket *pes)
 {
 #define zprintf printf
     TSpacketInfo pkt;
 nextPack3:
     // Sync at source
-    if(false==getNextPacket_NoHeader(pid,&pkt,false)) return false;    
+    if(false==getNextPacket_NoHeader(pes->pid,&pkt,false)) return false;    
     // If it does not contain a payload strat continue
     if(!pkt.payloadStart)
     {
-        printf("[Ts Demuxer] Pes for Pid =0x%d does not contain payload start\n",pid);
+        printf("[Ts Demuxer] Pes for Pid =0x%d does not contain payload start\n",pes->pid);
         goto nextPack3;
     }
     //____________________
@@ -337,26 +315,26 @@
     //____________________
     //____________________
     uint32_t code=(pkt.payload[0]<<24)+(pkt.payload[1]<<16)+(pkt.payload[2]<<8)+pkt.payload[3];
-    zprintf("[TS Demuxer] Code=0x%x pid=0x%x\n",code,pid);
+    zprintf("[TS Demuxer] Code=0x%x pid=0x%x\n",code,pes->pid);
     if((code&0xffffff00)!=0x100)
     {
         printf("[Ts Demuxer] No PES startcode\n");
         goto nextPack3;
     }
-    mixDump(pkt.payload,pkt.payloadSize);
+    //mixDump(pkt.payload,pkt.payloadSize);
     uint32_t pesPacketLen=(pkt.payload[4]<<8)+(pkt.payload[5]);
     zprintf("[TS Demuxer] Pes Packet Len=%d\n",pesPacketLen);
     
-    internalPesBufferSize=0;
-    PesAddData(pkt.payloadSize,pkt.payload);
+    pes->payloadSize=0;
+    pes->addData(pkt.payloadSize,pkt.payload);
     while(1)
     {
         uint64_t pos;
         _file->getpos(&pos);
-        if(false==getNextPacket_NoHeader(pid,&pkt,false)) return false;    
+        if(false==getNextPacket_NoHeader(pes->pid,&pkt,false)) return false;    
         if(!pkt.payloadStart)
          {
-                PesAddData(pkt.payloadSize,pkt.payload);
+                pes->addData(pkt.payloadSize,pkt.payload);
          }else  
          {
                 _file->setpos(pos);
@@ -364,10 +342,106 @@
          }
     }
     // Now decode PES header (extra memcpy)
-    printf("[Ts Demuxer] Found PES of len %d\n",internalPesBufferSize);
+    printf("[Ts Demuxer] Full size :%d\n",pes->payloadSize);
+    if(false==decodePesHeader(pes))
+        goto nextPack3;
+
+    //
+    printf("[Ts Demuxer] Found PES of len %d\n",pes->payloadSize);
     return true;
 }
+/**
+    \fn decodePesHeader
+*/
+#define fail(x) {printf("[Ts Demuxer]*********"x"*******\n");return false;}
+bool tsPacket::decodePesHeader(TS_PESpacket *pes)
+{
+    uint8_t  *start=pes->payload+6;
+    uint8_t  *end=pes->payload+pes->payloadSize;
+    uint8_t  stream=pes->payload[3];
+    uint32_t packLen=(pes->payload[4])<<8+(pes->payload[5]);
+    int      align=0,c;
 
+
+    pes->dts=ADM_NO_PTS;
+    pes->pts=ADM_NO_PTS;
+
+    
+    while(*start==0xff && start<end) start++; // Padding
+    if(start>=end) fail("too much padding");
+
+    c=*start++;
+    if((c&0xc0)!=0x80) fail("No Mpeg2 marker");
+    
+        uint32_t ptsdts,len;
+        if(c & 4) align=1;      
+        c=*start++;     // PTS/DTS
+        //printf("%x ptsdts\n",c
+        ptsdts=c>>6;
+        // header len
+        len=*start++;
+
+        switch(ptsdts)
+        {
+                case 2: // PTS=1 DTS=0
+                       
+                        {
+                                uint64_t pts1,pts2,pts0;
+                                //      printf("\n PTS10\n");
+                                        pts0=*start++;  
+                                        pts1=*start++; 
+                                        pts2=*start++;                 
+                                        pes->pts=(pts1>>1)<<15;
+                                        pes->pts+=pts2>>1;
+                                        pes->pts+=(((pts0&6)>>1)<<30);
+                        }
+                        break;
+                case 3: // PTS=1 DTS=1
+                                #define PTS11_ADV 10 // nut monkey
+//                                if(len>=PTS11_ADV)
+                                {
+                                        uint32_t skip=PTS11_ADV;
+                                        uint64_t pts1,pts2,dts,pts0;
+                                                //      printf("\n PTS10\n");
+                                                pts0=*start++;  
+                                                pts1=*start++;; 
+                                                pts2=(start[0]<<8)+start[1]; 
+                                                start+=2;
+                                                                        
+                                                pes->pts=(pts1>>1)<<15;
+                                                pes->pts+=pts2>>1;
+                                                pes->pts+=(((pts0&6)>>1)<<30);
+                                                pts0=*start++;  
+                                                pts1=(start[0]<<8)+start[1]; 
+                                                pts2=(start[2]<<8)+start[3];       
+                                                start+=4;
+                                                pes->dts=(pts1>>1)<<15;
+                                                pes->dts+=pts2>>1;
+                                                pes->dts+=(((pts0&6)>>1)<<30);
+                                   }
+                                   break;               
+                case 1:
+                                fail("unvalid pts/dts");
+                                break;
+                case 0: 
+                                // printf("\n PTS00\n");
+                                break; // no pts nor dts
+                                                                
+        }  
+        int maxLen=(int)(end-start);
+        pes->offset=start-pes->payload;
+        if(packLen)
+        {
+            if(packLen<maxLen) maxLen=packLen;
+            else
+                if(packLen>maxLen)
+                {
+                    fail("Pes too long");
+                }   
+        }
+        pes->payloadSize=maxLen;
+        return true;
+}
 /**
     \fn getPacket
 */      

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-14 17:43:15 UTC (rev 4735)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-14 17:43:17 UTC (rev 4736)
@@ -44,15 +44,42 @@
 
 /**
     \class TS_PESpacket
+    \brief Handle exactly one PES packet
+            It is assumed PES packet starts & ends at TS packet boundaries
 */
 class TS_PESpacket
 {
 public:
     uint32_t    pid;
     uint32_t    payloadSize;
-    uint8_t     payload[TS_PES_MAX_LEN];
+    uint32_t    payloadLimit;
+    uint32_t    offset;
+    uint8_t     *payload;
     uint64_t    pts;
     uint64_t    dts;
+                TS_PESpacket(uint32_t pid)
+                {
+                    payload=(uint8_t *)ADM_alloc(2048);
+                    payloadLimit=2048;
+                    offset=0;
+                    payloadSize=0;
+                    this->pid=pid;
+                }
+                ~TS_PESpacket()
+                {
+                    ADM_dealloc(payload);
+                    payload=NULL;
+                }
+    bool        addData(uint32_t len,uint8_t *data)
+                {
+                    if(len+payloadSize>payloadLimit)
+                    {
+                        payloadLimit*=2;
+                        payload=(uint8_t *)ADM_realloc(payload,payloadLimit);
+                    }
+                    memcpy(payload+payloadSize,data,len);
+                    payloadSize+=len;
+                }
 };
 
 /**
@@ -61,13 +88,7 @@
 class tsPacket : public ADMMpegPacket
 {
 protected:
-    uint8_t             *internalPesBuffer;
-    uint32_t            internalPesBufferSize;
-    uint32_t            internalPesBufferLimit;
-    uint32_t            internalBufferOffset;
-    bool                PesAddData(uint32_t len,uint8_t *data);
 
-
     uint32_t            extraCrap;
     uint8_t             getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
 public:
@@ -81,11 +102,12 @@
 protected:
     
     bool                getSinglePacket(uint8_t *buffer);
+    bool                decodePesHeader(TS_PESpacket *pes);
 public:
     bool                getNextPacket_NoHeader(uint32_t pid,TSpacketInfo *pkt,bool psi);
 
     bool                getNextPSI(uint32_t pid,TS_PSIpacketInfo *psi);
-    bool                getNextPES(uint32_t pid,TS_PESpacket *pes);
+    bool                getNextPES(TS_PESpacket *pes);
 
 };
 /**



From mean at mail.berlios.de  Wed Apr 15 19:54:24 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 15 Apr 2009 19:54:24 +0200
Subject: [Avidemux-svn-commit] r4737 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904151754.n3FHsOJU007499@sheep.berlios.de>

Author: mean
Date: 2009-04-15 19:54:24 +0200 (Wed, 15 Apr 2009)
New Revision: 4737

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Log:
[TS Demuxer] Very basic mpeg2 indexer

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-14 17:43:17 UTC (rev 4736)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-15 17:54:24 UTC (rev 4737)
@@ -35,7 +35,7 @@
 #define LPCM_AUDIO_VALUE 0xA0
 #define DTS_AC3_AUDIO_VALUE 0x00
 
-static bool addAudioTrack(int pid, listOfTsAudioTracks *list, tsPacketLinearTracker *p);
+static bool addAudioTrack(int pid, listOfTsAudioTracks *list, tsPacketLinear *p);
 static bool tsCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize);
 /**
     \fn listOfPsAudioTracks
@@ -50,7 +50,7 @@
     uint64_t fileSize;
 
     listOfTsAudioTracks *tracks=new listOfTsAudioTracks;
-    tsPacketLinearTracker *packet=new tsPacketLinearTracker(0xE0);
+    tsPacketLinear *packet=new tsPacketLinear(0xE0);
 
     printf("[MpegPS] Probing audio for %s\n",fileName);
 
@@ -58,12 +58,14 @@
     fileSize=packet->getSize();
 
     packet->setPos(fileSize/2); // Jump in the middle of the stream
-
+#if 0
     while(packet->getPacketOfType(0xE0,PACKET_PROBE_SIZE,&size,&dts,&pts,buffer,&startAt))
     {
+
         packetStats *stat=packet->getStat(0xE0);
         if(stat->count > PROBE_PACKET_VIDEO_COUNT)
                 break;
+
     }
     // Now synthetize
     for(int i=0x0;i<0xFF;i++)   
@@ -81,7 +83,7 @@
          }
 
     }
-
+#endif
 end:
     printf("[PsDemux] Audio probe done, found %lu tracks\n",tracks->size());
     delete packet;
@@ -98,7 +100,7 @@
     \brief gather information about audio & add audio track to the list
 
 */
-bool addAudioTrack(int pid, listOfTsAudioTracks *list, tsPacketLinearTracker *p)
+bool addAudioTrack(int pid, listOfTsAudioTracks *list, tsPacketLinear *p)
 {
 #define PROBE_ANALYZE_SIZE 6000 // Should be enough in all cases (need ~ 2 blocks)
 uint8_t audioBuffer[PROBE_ANALYZE_SIZE];

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-14 17:43:17 UTC (rev 4736)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-15 17:54:24 UTC (rev 4737)
@@ -21,7 +21,7 @@
 typedef struct
 {
     WAVHeader header;
-    uint8_t   esID;
+    uint32_t  esID;
 }tsAudioTrackInfo;
 
 typedef vector <tsAudioTrackInfo*> listOfTsAudioTracks;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-14 17:43:17 UTC (rev 4736)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-15 17:54:24 UTC (rev 4737)
@@ -25,6 +25,7 @@
 #include "ADM_quota.h"
 #include "ADM_tsAudioProbe.h"
 #include "DIA_working.h"
+#include "ADM_tsPatPmt.h"
 
 static const char Type[5]={'X','I','P','B','P'};
 
@@ -54,6 +55,7 @@
     uint32_t fps;
     uint32_t interlaced;
     uint32_t ar;
+    uint32_t pid;
 }PSVideo;
 
 typedef enum
@@ -86,13 +88,13 @@
 {
 protected:
         FILE *index;
-        tsPacketLinearTracker *pkt;
-        listOfTsAudioTracks *audioTracks;
+        tsPacketLinear       *pkt;
+        listOfTsAudioTracks  *audioTracks;
         DIA_workingBase  *ui;
 public:
                 TsIndexer(void);
                 ~TsIndexer();
-        bool    run(const char *file);
+        bool    run(const char *file,uint32_t nbTracks, ADM_TS_TRACK *Tracks);
         bool    writeVideo(PSVideo *video);
         bool    writeAudio(void);
         bool    writeSystem(const char *filename,bool append);
@@ -106,9 +108,23 @@
 uint8_t   tsIndexer(const char *file)
 {
 bool r;
+
+    ADM_TS_TRACK *tracks;
+    uint32_t nbTracks;
+
+    if(TS_scanForPrograms(file,&nbTracks,&tracks)==false) 
+    {
+        printf("[Ts Indexer] Scan of pmt failed\n");
+        return false;
+    }
+    ADM_assert(tracks);
+    ADM_assert(nbTracks);
+    
+
     TsIndexer *dx=new TsIndexer;
-    r=dx->run(file);
+    r=dx->run(file,nbTracks,tracks);
     delete dx;
+    delete [] tracks;
     return r;
 }
 
@@ -137,7 +153,7 @@
 /**
     \fn run
 */  
-bool TsIndexer::run(const char *file)
+bool TsIndexer::run(const char *file,uint32_t nbTracks, ADM_TS_TRACK *Tracks)
 {
 uint32_t temporal_ref,val;
 uint64_t fullSize;
@@ -148,6 +164,14 @@
 indexerData  data;    
 dmxPacketInfo info;
 
+    if(!nbTracks) return false;
+    if(Tracks[0].trackType!=ADM_TS_MPEG2)
+    {
+        printf("[Ts Indexer] Only Mpeg2 video supported\n");
+        return false;
+    }
+    video.pid=Tracks[0].trackPid;
+
     memset(&data,0,sizeof(data));
     char indexName[strlen(file)+5];
     sprintf(indexName,"%s.idx",file);
@@ -158,24 +182,8 @@
         return false;
     }
     writeSystem(file,true);
-    pkt=new tsPacketLinearTracker(0xE0);
+    pkt=new tsPacketLinear(Tracks[0].trackPid);
 
-    audioTracks=tsProbeAudio(file);
-    if(audioTracks)
-    {
-        for(int i=0;i<audioTracks->size();i++)
-        {
-                printf("[PsProbe] Found audio Track %d, pid=%x\n",i,(*audioTracks)[i]->esID);
-                WAVHeader *hdr=&((*audioTracks)[i]->header);
-                printf("[PsProbe] codec    : 0x%x \n",hdr->encoding);
-                printf("[PsProbe] frequency: %"LU" Hz\n",hdr->frequency);
-                printf("[PsProbe] channel  : %"LU" \n",hdr->channels);
-                printf("[PsProbe] byterate : %"LU" Byte/s\n",hdr->byterate);
-
-        }
-
-    }
-
     FP_TYPE append=FP_APPEND;
     pkt->open(file,append);
     data.pkt=pkt;
@@ -216,8 +224,8 @@
                           video.fps= FPS[val & 0xf];
                           pkt->forward(4);
                           writeVideo(&video);
-                          writeAudio();
-                          pkt->resetStats();
+                          //writeAudio();
+                          //pkt->resetStats();
                           qfprintf(index,"[Data]");
                           break;
                   case 0xb8: // GOP
@@ -317,9 +325,11 @@
     {
         if(data->frameType==1)
         {
+#if 0
             // If audio, also dump audio
             if(audioTracks)
             {
+
                 qfprintf(index,"\nAudio bf:%08"LLX" ",data->startAt);
                 for(int i=0;i<audioTracks->size();i++)
                 {
@@ -330,6 +340,7 @@
                 }
                 
             }
+#endif
             // start a new line
             qfprintf(index,"\nVideo at:%08"LLX":%04"LX" Pts:%08"LLD":%08"LLD" ",data->startAt,data->offset,info->pts,info->dts);
             data->nextOffset=-2;
@@ -361,6 +372,7 @@
     qfprintf(index,"Fps=%d\n",video->fps);
     qfprintf(index,"Interlaced=%d\n",video->interlaced);
     qfprintf(index,"AR=%d\n",video->ar);
+    qfprintf(index,"Pid=%d\n",video->pid);
     return true;
 }
 /**
@@ -371,7 +383,7 @@
 {
     qfprintf(index,"PSD1\n");
     qfprintf(index,"[System]\n");
-    qfprintf(index,"Type=P\n");
+    qfprintf(index,"Type=T\n");
     qfprintf(index,"File=%s\n",filename);
     qfprintf(index,"Append=%d\n",append);
     return true;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-14 17:43:17 UTC (rev 4736)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-15 17:54:24 UTC (rev 4737)
@@ -60,14 +60,8 @@
     printf("[TSDemuxer] Analyzing file..\n");
     count++;
 
-    ADM_TS_TRACK *tracks;
-    uint32_t nbTracks;
-
-    if(TS_scanForPrograms(fileName,&nbTracks,&tracks)==false) return 0;
-    ADM_assert(tracks);
-    ADM_assert(nbTracks);
-    delete [] tracks;
-    //if(true==tsIndexer(fileName)) goto again;
+  
+    if(true==tsIndexer(fileName)) goto again;
     printf("[TSDemuxer] Failed..\n");
    return 0;
 }

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-14 17:43:17 UTC (rev 4736)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-15 17:54:24 UTC (rev 4737)
@@ -23,6 +23,7 @@
 #include "dmxTSPacket.h"
 #include "dmx_mpegstartcode.h"
 
+#define TS_PES_MAX_LIMIT (1024*1024*2)
 
 
 #define ADM_NO_CONFIG_H
@@ -35,7 +36,7 @@
 }
 #include "ADM_tsCrc.cpp"
 
-
+extern void mixDump(uint8_t *ptr, uint32_t len);
 /**
     \fn tsPacket
     \brief ctor
@@ -43,8 +44,6 @@
 tsPacket::tsPacket(void) 
 {
     extraCrap=0; // =4 for ts2
-
-
 }
 /**
     \fn tsPacket
@@ -89,12 +88,13 @@
 */
 uint64_t    tsPacket::getPos(void)
 {
-    return 0;
+    uint64_t pos;
+    _file->getpos(&pos);
+    return pos;
 }
 /**
     \fn setPos
 */
-
 bool    tsPacket::setPos(uint64_t pos)
 {
     if(!_file->setpos(pos))
@@ -295,11 +295,12 @@
         \brief Returns the next PES packet
         
 */
-extern void mixDump(uint8_t *ptr, uint32_t len);
+
 bool        tsPacket::getNextPES(TS_PESpacket *pes)
 {
 #define zprintf printf
     TSpacketInfo pkt;
+    pes->fresh=false;
 nextPack3:
     // Sync at source
     if(false==getNextPacket_NoHeader(pes->pid,&pkt,false)) return false;    
@@ -340,14 +341,22 @@
                 _file->setpos(pos);
                 break;
          }
+        if(pes->payloadLimit>TS_PES_MAX_LIMIT)
+        {
+            printf("[Ts Demuxer] Pes Packet too big\n");
+            goto nextPack3;
+        }
     }
+    //____________________
     // Now decode PES header (extra memcpy)
+    //____________________
     printf("[Ts Demuxer] Full size :%d\n",pes->payloadSize);
     if(false==decodePesHeader(pes))
         goto nextPack3;
 
     //
-    printf("[Ts Demuxer] Found PES of len %d\n",pes->payloadSize);
+    printf("[Ts Demuxer] Found PES of len %d\n",pes->payloadSize);  
+    pes->fresh=true;
     return true;
 }
 /**
@@ -366,6 +375,7 @@
     pes->dts=ADM_NO_PTS;
     pes->pts=ADM_NO_PTS;
 
+    if(pes->payloadSize<(4+2+1+2)) return false;
     
     while(*start==0xff && start<end) start++; // Padding
     if(start>=end) fail("too much padding");
@@ -380,33 +390,36 @@
         ptsdts=c>>6;
         // header len
         len=*start++;
-
+        int available=(int)(end-start);
         switch(ptsdts)
         {
                 case 2: // PTS=1 DTS=0
                        
                         {
+                                if(available<5) return false;
                                 uint64_t pts1,pts2,pts0;
                                 //      printf("\n PTS10\n");
-                                        pts0=*start++;  
-                                        pts1=*start++; 
-                                        pts2=*start++;                 
+                                        pts0=start[0];  
+                                        pts1=(start[1]<<8)+start[2]; 
+                                        pts2=(start[3]<<8)+start[4]; 
+                                        start+=5;
                                         pes->pts=(pts1>>1)<<15;
                                         pes->pts+=pts2>>1;
                                         pes->pts+=(((pts0&6)>>1)<<30);
                         }
                         break;
                 case 3: // PTS=1 DTS=1
+                                if(available<10) return false;
                                 #define PTS11_ADV 10 // nut monkey
-//                                if(len>=PTS11_ADV)
+                                if(len>=PTS11_ADV)
                                 {
                                         uint32_t skip=PTS11_ADV;
                                         uint64_t pts1,pts2,dts,pts0;
                                                 //      printf("\n PTS10\n");
-                                                pts0=*start++;  
-                                                pts1=*start++;; 
-                                                pts2=(start[0]<<8)+start[1]; 
-                                                start+=2;
+                                                pts0=start[0];  
+                                                pts1=(start[1]<<8)+start[2]; 
+                                                pts2=(start[3]<<8)+start[4]; 
+                                                start+=5;
                                                                         
                                                 pes->pts=(pts1>>1)<<15;
                                                 pes->pts+=pts2>>1;
@@ -414,7 +427,7 @@
                                                 pts0=*start++;  
                                                 pts1=(start[0]<<8)+start[1]; 
                                                 pts2=(start[2]<<8)+start[3];       
-                                                start+=4;
+                                                start+=5;
                                                 pes->dts=(pts1>>1)<<15;
                                                 pes->dts+=pts2>>1;
                                                 pes->dts+=(((pts0&6)>>1)<<30);
@@ -447,300 +460,20 @@
 */      
 bool        tsPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)
 {
-uint32_t globstream,len;
-uint8_t  stream,substream;
-uint64_t pts,dts;
-        // Resync on our stream
-_again2:
-        *pid=0;
-        if(!_file->sync(&stream)) 
-        {
-                uint64_t pos;
-                _file->getpos(&pos);
-                printf("[DmxPS] cannot sync  at "LLU"/"LLU"\n",pos,_size);
-                return false;
-        }
-// Position of this packet just before startcode
-        _file->getpos(startAt);
-        *startAt-=4;
-// Handle out of band stuff        
-        if(stream==PACK_START_CODE) 
-        {
-        		_file->forward(8);
-        		goto _again2;
-        }
-        if( stream==PADDING_CODE ||stream==SYSTEM_START_CODE) 
-        {
-                        len=_file->read16i();
-                        //printf("\tForwarding %lu bytes\n",len);
-        		_file->forward(len);
-        		goto _again2;
-        }
-        // Only keep relevant parts
-        // i.e. a/v : C0 C9 E0 E9
-        // subs 20-29
-        // private data 1/2
-#define INSIDE(min,max) (stream>=min && stream<max)
-        if(!(  INSIDE(0xC0,0xC9) || INSIDE(0xE0,0xE9) || INSIDE(0x20,0x29) || stream==PRIVATE_STREAM_1 || stream==PRIVATE_STREAM_2
-        			)) goto _again2;
-        // Ok we got a candidate
-        if(!getPacketInfo(stream,&substream,&len,&pts,&dts))   
-        {
-                goto _again2;
-        }
-        
-        //printf("Main Stream :%x substream :%x\n",stream,substream);
-        if(stream==PRIVATE_STREAM_1) globstream=0xFF00+substream;
-                else                 globstream=stream;
 
-        *pid=globstream;
-        *opts=pts;
-        *odts=dts;
-        *packetSize=len;
-        if(len>     maxSize)
-        {
-                printf("[DmxPS] Packet too big %d vs %d\n",len,maxSize);
-        }
-        if(!_file->read32(len,buffer)) return false;
-        return true;
+        return false;
        
 }
-/**
 
-    \fn getPacketInfo
-    \brief       Retrieve info about the packet we just met.It is assumed that parser is just after the packet startcode
-
-*/
-
-uint8_t tsPacket::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
-{
-
-//uint32_t un ,deux;
-uint64_t size=0;
-uint8_t c,d;
-uint8_t align=0;
-                        
-                *substream=0xff;
-                *opts=ADM_NO_PTS;
-                *odts=ADM_NO_PTS;
-                
-                                        
-                size=_file->read16i();
-                if((stream==PADDING_CODE) || 
-                	 (stream==PRIVATE_STREAM_2)
-                        ||(stream==SYSTEM_START_CODE) //?
-                        ) // special case, no header
-                        {
-                                *olen=size;      
-                                return 1;
-                        }
-                                
-                        //      remove padding if any                                           
-        
-                while((c=_file->read8i()) == 0xff) 
-                {
-                        size--;
-                }
-//----------------------------------------------------------------------------
-//-------------------------------MPEG-2 PES packet style----------------------
-//----------------------------------------------------------------------------
-                if(((c&0xC0)==0x80))
-                {
-                        uint32_t ptsdts,len;
-                        //printf("\n mpeg2 type \n");
-                        //_muxTypeMpeg2=1;
-                        // c= copyright and stuff       
-                        //printf(" %x align\n",c);      
-                        if(c & 4) align=1;      
-                        c=_file->read8i();     // PTS/DTS
-                        //printf("%x ptsdts\n",c
-                        ptsdts=c>>6;
-                        // header len
-                        len=_file->read8i();
-                        size-=3;  
-
-                        switch(ptsdts)
-                        {
-                                case 2: // PTS=1 DTS=0
-                                        if(len>=5)
-                                        {
-                                                uint64_t pts1,pts2,pts0;
-                                                //      printf("\n PTS10\n");
-                                                        pts0=_file->read8i();  
-                                                        pts1=_file->read16i(); 
-                                                        pts2=_file->read16i();                 
-                                                        len-=5;
-                                                        size-=5;
-                                                        *opts=(pts1>>1)<<15;
-                                                        *opts+=pts2>>1;
-                                                        *opts+=(((pts0&6)>>1)<<30);
-                                        }
-                                        break;
-                                case 3: // PTS=1 DTS=1
-                                                #define PTS11_ADV 10 // nut monkey
-                                                if(len>=PTS11_ADV)
-                                                {
-                                                        uint32_t skip=PTS11_ADV;
-                                                        uint64_t pts1,pts2,dts,pts0;
-                                                                //      printf("\n PTS10\n");
-                                                                pts0=_file->read8i();  
-                                                                pts1=_file->read16i(); 
-                                                                pts2=_file->read16i(); 
-                                                                                        
-                                                                *opts=(pts1>>1)<<15;
-                                                                *opts+=pts2>>1;
-                                                                *opts+=(((pts0&6)>>1)<<30);
-                                                                pts0=_file->read8i();  
-                                                                pts1=_file->read16i(); 
-                                                                pts2=_file->read16i();                 
-                                                                dts=(pts1>>1)<<15;
-                                                                dts+=pts2>>1;
-                                                                dts+=(((pts0&6)>>1)<<30);
-                                                                len-=skip;
-                                                                size-=skip;
-                                                                *odts=dts;
-                                                                        //printf("DTS: %lx\n",dts);                
-                                                   }
-                                                   break;               
-                                case 1:
-                                                return 0;//ADM_assert(0); // forbidden !
-                                                break;
-                                case 0: 
-                                                // printf("\n PTS00\n");
-                                                break; // no pts nor dts
-                                                                                
-                                                            
-                        }  
-// Extension bit        
-// >stealthdave<                                
-
-                        // Skip remaining headers if any
-                        if(len) 
-                        {
-                                _file->forward(len);
-                                size=size-len;
-                        }
-                                
-                if(stream==PRIVATE_STREAM_1)
-                {
-                        if(size>5)
-                        {
-                        // read sub id
-                               *substream=_file->read8i();
-  //                    printf("\n Subid : %x",*subid);
-                                switch(*substream)
-                                {
-                                // DTS
-                                        case 0x88:case 0x89:case 0x8A:case 0x8B:
-                                        
-                                                *substream=*substream-0x48;
-                                                break;
-
-                                //AC3
-                                        case 0x80:case 0x81:case 0x82:case 0x83:
-                                        case 0x84:case 0x85:case 0x86:case 0x87:
-                                                *substream=*substream-0x80;
-                                                break;
-                                // PCM
-                                        case 0xA0:case 0xA1:case 0xa2:case 0xa3:
-                                        case 0xA4:case 0xA5:case 0xa6:case 0xa7:
-                                                // we have an additionnal header
-                                                // of 3 bytes
-                                                _file->forward(3);
-                                                size-=3;
-                                                break;
-                                // Subs
-                                case 0x20:case 0x21:case 0x22:case 0x23:
-                                case 0x24:case 0x25:case 0x26:case 0x27:
-                                                break;
-                             
-                                default:
-                                                doNoComplainAnyMore++;
-                                                if(doNoComplainAnyMore<10)
-                                                    printf("[DmxPS]Unkown substream %x\n",*substream);
-                                                *substream=0xff;
-                                }
-                                // skip audio header (if not sub)
-                                if(*substream>0x26 || *substream<0x20)
-                                {
-                                        _file->forward(3);
-                                        size-=3;
-                                }
-                                size--;
-                        }
-                }
-               //    printf(" pid %x size : %x len %x\n",sid,size,len);
-                *olen=size;
-                return 1;
-        }
-//----------------------------------------------------------------------------------------------                
-//-------------------------------MPEG-1 PES packet style----------------------                                  
-//----------------------------------------------------------------------------------------------                                        
-           if(0) //_muxTypeMpeg2)
-                {
-                        printf("[DmxPS]*** packet type 1 inside type 2 ?????*****\n");
-                        return 0; // mmmm                       
-                }
-          // now look at  STD buffer size if present
-          // 01xxxxxxxxx
-          if ((c>>6) == 1) 
-          {       // 01
-                        size-=2;
-                        _file->read8i();                       // skip one byte
-                        c=_file->read8i();   // then another
-           }                       
-           // PTS/DTS
-           switch(c>>4)
-           {
-                case 2:
-                {
-                        // 0010 xxxx PTS only
-                        uint64_t pts1,pts2,pts0;
-                                        size -= 4;
-                                        pts0=(c>>1) &7;
-                                        pts1=_file->read16i()>>1;
-                                        pts2=_file->read16i()>>1;
-                                        *opts=pts2+(pts1<<15)+(pts0<<30);
-                                        break;
-                  }
-                  case 3:
-                  {               // 0011 xxxx
-                        uint64_t pts1,pts2,pts0;
-                                        size -= 9;
-                                                                        
-                                        pts0=(c>>1) &7;
-                                        pts1=_file->read16i()>>1;
-                                        pts2=_file->read16i()>>1;
-                                        *opts=pts2+(pts1<<15)+(pts0<<30);
-                                        _file->forward(5);
-                   }                                                               
-                   break;
-                   
-                case 1:
-                        // 0001 xxx             
-                        // PTSDTS=01 not allowed                        
-                                return 0;
-                                break; 
-                }
-                                                                
-
-                if(!align)      
-                        size--;         
-        *olen=size;
-        return 1;
-}
-//************************************************************************************
-
 #define ADM_PACKET_LINEAR 10*1024
 /**
     \fn tsPacket
 */
-tsPacketLinear::tsPacketLinear(uint8_t pid) : tsPacket()
+tsPacketLinear::tsPacketLinear(uint32_t pid) : tsPacket()
 {
-    oldStartAt=startAt=0xfffffff;
-    oldBufferLen=bufferLen=0;
-    bufferIndex=0;
-    myPid=pid;
+    oldStartAt=0xfffffff;
+    oldBufferLen=0;
+    pesPacket=new TS_PESpacket(pid);
     eof=false;
 }
 /**
@@ -748,6 +481,8 @@
 */
 tsPacketLinear::~tsPacketLinear() 
 {
+    if(pesPacket) delete pesPacket;
+    pesPacket=NULL;
 }
 /**
     \fn refill
@@ -756,18 +491,15 @@
 {
 // In case a startcode spawns across 2 packets
 // we have to keep track of the old one
-        oldBufferDts=bufferDts;
-        oldBufferPts=bufferPts;
-        oldStartAt=startAt;
-        oldBufferLen=bufferLen;
-        if( false== getPacketOfType(myPid,ADM_PACKET_LINEAR, &bufferLen,&bufferPts,&bufferDts,buffer,&startAt)) 
+        oldBufferDts=pesPacket->dts;
+        oldBufferPts=pesPacket->dts;
+        oldStartAt=pesPacket->startAt;
+        oldBufferLen=pesPacket->payloadSize;
+        if(false==getNextPES(pesPacket))
         {
-            printf("[tsPacketLinear] Refill failed for pid :%x\n",myPid);
-            bufferIndex=bufferLen=0;
-            return false;
+                printf("[tsPacketLinear] Refill failed for pid :%x\n",pesPacket->pid);
+                return false;
         }
-        //printf("Refill : At :%"LLX" size :%"LD"\n",startAt,bufferLen);
-        bufferIndex=0;
         return true;
 }
 /**
@@ -776,18 +508,16 @@
 uint8_t tsPacketLinear::readi8(void)
 {
     consumed++;
-    if(bufferIndex<bufferLen)
+    if(pesPacket->offset<pesPacket->payloadSize)
     {
-        return buffer[bufferIndex++];
+        return pesPacket->payload[pesPacket->offset++];
     }
     if(false==refill()) 
     {
         eof=1;
         return 0;
     }
-    ADM_assert(bufferLen);
-    bufferIndex=1;
-    return buffer[0];
+    return pesPacket->payload[pesPacket->offset++];
     
 }
 /**
@@ -795,10 +525,12 @@
 */
 uint16_t tsPacketLinear::readi16(void)
 {
-    if(bufferIndex+1<bufferLen)
+    if(pesPacket->offset+1<pesPacket->payloadSize)
     {
-        uint16_t v=(buffer[bufferIndex]<<8)+buffer[bufferIndex+1];;
-        bufferIndex+=2;
+        uint8_t *r=pesPacket->payload+pesPacket->offset;
+        uint16_t v=(r[0]<<8)+r[1];;
+        
+        pesPacket->offset+=2;
         consumed+=2;
         return v;
     }
@@ -809,11 +541,11 @@
 */
 uint32_t tsPacketLinear::readi32(void)
 {
-    if(bufferIndex+3<bufferLen)
+    if(pesPacket->offset+3<pesPacket->payloadSize)
     {
-        uint8_t *p=buffer+bufferIndex;
-        uint32_t v=(p[0]<<24)+(p[1]<<16)+(p[2]<<8)+p[3];
-        bufferIndex+=4;
+         uint8_t *p=pesPacket->payload+pesPacket->offset;
+         uint32_t v=(p[0]<<24)+(p[1]<<16)+(p[2]<<8)+p[3];
+         pesPacket->offset+=4;
         consumed+=4;
         return v;
     }
@@ -825,14 +557,14 @@
 bool tsPacketLinear::forward(uint32_t v)
 {
 next:
- uint32_t delta=bufferLen-bufferIndex;
+ uint32_t delta=pesPacket->payloadSize-pesPacket->offset;
     if(v>100*1000)
     {
         ADM_assert(0);
     }
     if(v<=delta)
     {
-        bufferIndex+=v;
+        pesPacket->offset+=v;
         consumed+=v;
         return true;
     }
@@ -851,19 +583,19 @@
     // Enough already ?
     while(len)
     {
-        uint32_t avail=bufferLen-bufferIndex;
+        uint32_t avail=pesPacket->payloadSize-pesPacket->offset;
         uint32_t chunk=avail;
         if(chunk>len) chunk=len;
 #if 0
         printf("len:%ld avail:%ld chunk %ld index:%d size:%d\n",
                 len,avail,chunk,bufferIndex,bufferLen);
 #endif
-        memcpy(out,buffer+bufferIndex,chunk);
-        bufferIndex+=chunk;
+        memcpy(out,pesPacket->payload+pesPacket->offset,chunk);
+        pesPacket->offset+=chunk;
         len-=chunk;
         out+=chunk;
         consumed+=chunk;
-        if(bufferIndex==bufferLen)
+        if(pesPacket->payloadSize==pesPacket->offset)
         {
             //printf("Refill\n");
             if(false==refill()) return false;
@@ -879,19 +611,20 @@
 */
 bool    tsPacketLinear::getInfo(dmxPacketInfo *info)
 {
-    if(bufferIndex<4)
+#warning FIXME
+    if(pesPacket->offset<4)
     {
         info->startAt=this->oldStartAt;
-        info->offset=oldBufferLen+bufferIndex;
+        info->offset=oldBufferLen;
         info->pts=oldBufferPts;
         info->dts=oldBufferDts;
 
     }else
     {
-        info->startAt=this->startAt;
-        info->offset=bufferIndex;
-        info->pts=bufferPts;
-        info->dts=bufferDts;
+        info->startAt=pesPacket->startAt;
+        info->offset=pesPacket->offset;
+        info->pts=pesPacket->pts;
+        info->dts=pesPacket->dts;
     }
     return true;
 
@@ -912,9 +645,8 @@
         printf("[tsPacketLinear] Seek to %"LLX":%"LX" failed\n",packetStart,offset);
         return false;
     }
-    ADM_assert(offset<bufferLen);
-    bufferIndex=offset;
-    
+    ADM_assert(offset<pesPacket->payloadSize);
+    pesPacket->offset=offset;
     return true;
 }
 /**
@@ -933,78 +665,10 @@
 */
 bool    tsPacketLinear::changePid(uint32_t pid) 
 {
-    myPid=(pid&0xff);
-    bufferLen=bufferIndex=0;
+    pesPacket->pid=(pid&0xff);
+    pesPacket->offset=pesPacket->payloadSize;
     return true;
 }
 /* ********************************************************* */
-/**
-    \fn tsPacketLinearTracker
-*/
- tsPacketLinearTracker::tsPacketLinearTracker(uint8_t pid)  : tsPacketLinear(pid)
-{
-   resetStats();
-}
-/**
-    \fn ~tsPacketLinearTracker
-*/
-tsPacketLinearTracker::~tsPacketLinearTracker()
-{
 
-    
-}
-/**
-        \fn getStat
-*/
-packetStats    *tsPacketLinearTracker::getStat(int index)
-{   
-    if(index<0 || index>=256) ADM_assert(0);
-    return stats+index;
-}
-/**
-    \fn getPacketgetPacketOfType
-    \brief Keep track of all the packets we have seen so far.
-    Usefull to detect the streams present and to look up the PTS/DTS of audio streams for the audio part of the index
-*/
-bool           tsPacketLinearTracker::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
-{
- bool xit=false;
-    uint8_t tmppid;
-    while(1)
-    {
-        if(true!=getPacket(maxSize,&tmppid,packetSize,pts,dts,buffer,startAt))
-                return false;
-        else
-        {
-                // Update 
-                ADM_assert(tmppid<0x100);
-                packetStats *p=stats+tmppid;
-                uint64_t ts=*pts;
-                if(ts==ADM_NO_PTS) ts=*dts;
-                if(ts!=ADM_NO_PTS)
-                {
-                    p->startCount=p->count;
-                    p->startAt=*startAt;
-                    p->startSize=p->size;
-                    p->startDts=ts;
-                }
-                p->count++;
-                p->size+=*packetSize;
-                if(tmppid==pid) return true;
-        }
-    }
-    return false;
-}
-/**
-    \fn resetStats
-*/
-bool           tsPacketLinearTracker::resetStats(void)
-{
-    memset(stats,0,sizeof(stats));
-    for(int i=0;i<256;i++)
-    {
-        packetStats *p=stats+i;
-        p->startDts=ADM_NO_PTS;
-    }
-}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-14 17:43:17 UTC (rev 4736)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-15 17:54:24 UTC (rev 4737)
@@ -26,6 +26,7 @@
     bool        payloadStart;
     uint32_t    continuityCounter;
     uint8_t     payload[TS_PACKET_LEN];
+    uint64_t    startAt;
 };
 
 
@@ -35,6 +36,7 @@
 class TS_PSIpacketInfo
 {
 public:
+    
     uint32_t    pid;
     uint32_t    payloadSize;
     uint8_t     payload[TS_PSI_MAX_LEN];
@@ -57,6 +59,8 @@
     uint8_t     *payload;
     uint64_t    pts;
     uint64_t    dts;
+    uint64_t    startAt;
+    bool        fresh; // True if we just filled it with a new packet
                 TS_PESpacket(uint32_t pid)
                 {
                     payload=(uint8_t *)ADM_alloc(2048);
@@ -90,7 +94,6 @@
 protected:
 
     uint32_t            extraCrap;
-    uint8_t             getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
 public:
                         tsPacket(void);
     virtual            ~tsPacket();
@@ -118,13 +121,7 @@
 class tsPacketLinear : public tsPacket
 {
 protected:
-        uint8_t  myPid;
-        uint64_t startAt;
-        uint32_t bufferLen;
-        uint64_t bufferPts;
-        uint64_t bufferDts;
-        uint32_t bufferIndex;
-        uint8_t  buffer[ADM_PACKET_LINEAR];
+        TS_PESpacket *pesPacket;
         bool     eof;
         bool     refill(void);
         uint64_t oldStartAt;
@@ -134,7 +131,7 @@
         uint32_t consumed;
 
 public:
-                tsPacketLinear(uint8_t pid);
+                tsPacketLinear(uint32_t pid);
                 ~tsPacketLinear();
         uint32_t getConsumed(void);
         uint8_t  readi8();
@@ -148,6 +145,7 @@
         bool    seek(uint64_t packetStart, uint32_t offset);
         bool    changePid(uint32_t pid) ;
 };
+
 /**
     \class tsPacketLinearTracker
 */
@@ -162,18 +160,5 @@
     uint64_t startDts;
 }packetStats;
 
-class tsPacketLinearTracker : public tsPacketLinear
-{
-protected:
-      packetStats stats[256];
 
-public:
-                        tsPacketLinearTracker(uint8_t pid);
-                        ~tsPacketLinearTracker();
-         packetStats    *getStat(int intdex);
-         bool           resetStats(void);
-virtual  bool           getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
-};
-
-
 #endif



From mean at mail.berlios.de  Thu Apr 16 07:39:52 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 16 Apr 2009 07:39:52 +0200
Subject: [Avidemux-svn-commit] r4738 - in
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers:
	MpegPS MpegTS
Message-ID: <200904160539.n3G5dqDm026153@sheep.berlios.de>

Author: mean
Date: 2009-04-16 07:39:41 +0200 (Thu, 16 Apr 2009)
New Revision: 4738

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psPlugin.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
Log:
[Demuxers] Better identify ps & ts

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psPlugin.cpp	2009-04-15 17:54:24 UTC (rev 4737)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psPlugin.cpp	2009-04-16 05:39:41 UTC (rev 4738)
@@ -51,7 +51,31 @@
         fread(signature,4,1,f);
         signature[4]=0;
         fclose(f);
-        if(!strcmp(signature,"PSD1")) return 50;
+        if(!strcmp(signature,"PSD1")) 
+        {
+              indexFile indexFile;
+             char *type;
+             if(!indexFile.open(index))
+             {
+                printf("[psDemux] Cannot open index file %s\n",index);
+                indexFile.close();
+                return false;
+              }
+             if(!indexFile.readSection("System"))
+            {
+                printf("[psDemux] Cannot read system section\n");
+                indexFile.close();
+                return false;
+            }
+            type=indexFile.getAsString("Type");
+            if(!type || type[0]!='P')
+                {
+                    printf("[psDemux] Incorrect or not found type\n");
+                    indexFile.close();
+                    return false;
+                }
+            return 50;
+        }
         printf("[PsDemuxer] Not a valid index\n");
         return false;
     }
@@ -93,6 +117,5 @@
     if(nbMatch>nbPacket/3)
         return true;
     return false;
-    
-
-}
\ No newline at end of file
+}
+//EOF
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-15 17:54:24 UTC (rev 4737)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-16 05:39:41 UTC (rev 4738)
@@ -51,7 +51,7 @@
         goto abt;
     }
     type=index.getAsString("Type");
-    if(!type || type[0]!='P')
+    if(!type || type[0]!='T')
     {
         printf("[psDemux] Incorrect or not found type\n");
         goto abt;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-15 17:54:24 UTC (rev 4737)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-04-16 05:39:41 UTC (rev 4738)
@@ -52,10 +52,36 @@
         fread(signature,4,1,f);
         signature[4]=0;
         fclose(f);
-        if(!strcmp(signature,"PSD1")) return 50;
+        if(!strcmp(signature,"PSD1"))
+        {
+                // Check if it is a valid index for us...
+                 indexFile indexFile;
+                 char *type;
+                 if(!indexFile.open(index))
+                 {
+                    printf("[tsDemux] Cannot open index file %s\n",index);
+                    indexFile.close();
+                    return false;
+                  }
+                 if(!indexFile.readSection("System"))
+                {
+                    printf("[tsDemux] Cannot read system section\n");
+                    indexFile.close();
+                    return false;
+                }
+                type=indexFile.getAsString("Type");
+                if(!type || type[0]!='T')
+                    {
+                        printf("[TsDemux] Incorrect or not found type\n");
+                        indexFile.close();
+                        return false;
+                    }
+                return 50;
+        }
         printf("[TSDemuxer] Not a valid index\n");
         return false;
-    }
+
+     }
     if(count) return false;
     printf("[TSDemuxer] Analyzing file..\n");
     count++;



From gruntster at mail.berlios.de  Sat Apr 18 20:25:20 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 18 Apr 2009 20:25:20 +0200
Subject: [Avidemux-svn-commit] r4739 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_coreAudio/include ADM_userInterfaces/ADM_commonUI
Message-ID: <200904181825.n3IIPKIj011534@sheep.berlios.de>

Author: gruntster
Date: 2009-04-18 20:25:04 +0200 (Sat, 18 Apr 2009)
New Revision: 4739

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_audioCodecEnum.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_ocr.cpp
Log:
[ocr] use open dialog instead of save dialog (FS#599)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_audioCodecEnum.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_audioCodecEnum.h	2009-04-16 05:39:41 UTC (rev 4738)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_audioCodecEnum.h	2009-04-18 18:25:04 UTC (rev 4739)
@@ -27,4 +27,3 @@
 #define WAV_UNKNOWN     9999
 
 #endif
-//EOF
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_ocr.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_ocr.cpp	2009-04-16 05:39:41 UTC (rev 4738)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_ocr.cpp	2009-04-18 18:25:04 UTC (rev 4739)
@@ -79,7 +79,7 @@
 _again:  
   // Fist build a dialogFactory to get input and output files
   diaElemButton   selectIdx(QT_TR_NOOP("Select idx file:"), cb_idx,&subparam,NULL);
-  diaElemFile     selectGlyph(1,&glyphFileName,QT_TR_NOOP("Use GlyphSet (optional):"), NULL, QT_TR_NOOP("Select GlyphSet file"));
+  diaElemFile     selectGlyph(0,&glyphFileName,QT_TR_NOOP("Use GlyphSet (optional):"), NULL, QT_TR_NOOP("Select GlyphSet file"));
   diaElemFile     selectSrt(1,&srtFileName,QT_TR_NOOP("Output SRT file"), NULL, QT_TR_NOOP("Save SRT file"));
   
   diaElem *elems[]={&selectIdx,&selectSrt,&selectGlyph};
@@ -193,9 +193,9 @@
   }
 _againX:  
   // Fist build a dialogFactory to get input and output files
-  diaElemFile     selectTs(1,&tsFileName,QT_TR_NOOP("Input TS:"), NULL, QT_TR_NOOP("Select TS file"));
+  diaElemFile     selectTs(0,&tsFileName,QT_TR_NOOP("Input TS:"), NULL, QT_TR_NOOP("Select TS file"));
   diaElemUInteger selectPid(&pid,QT_TR_NOOP("Subtitle PID:"),0,255);
-  diaElemFile     selectGlyph(1,&glyphFileName,QT_TR_NOOP("Use glyphset (optional):"), NULL, QT_TR_NOOP("Select GlyphSet file"));  
+  diaElemFile     selectGlyph(0,&glyphFileName,QT_TR_NOOP("Use GlyphSet (optional):"), NULL, QT_TR_NOOP("Select GlyphSet file"));  
   diaElemFile     selectSrt(1,&srtFileName,QT_TR_NOOP("Output SRT file"), NULL, QT_TR_NOOP("Save SRT file"));
   
   diaElem *elems[]={&selectTs,&selectPid,&selectSrt,&selectGlyph};



From gruntster at mail.berlios.de  Mon Apr 20 17:59:03 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 20 Apr 2009 17:59:03 +0200
Subject: [Avidemux-svn-commit] r4740 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: . ADM_script
Message-ID: <200904201559.n3KFx3gM008167@sheep.berlios.de>

Author: gruntster
Date: 2009-04-20 17:58:54 +0200 (Mon, 20 Apr 2009)
New Revision: 4740

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
Log:
[script] add AudioTrackInfo class and sourceTrackInfo/targetTrackInfo properties to Audio class

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.cpp	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.cpp	2009-04-20 15:58:54 UTC (rev 4740)
@@ -0,0 +1,123 @@
+#include "ADM_default.h"
+#include "ADM_JSAudioTrackInfo.h"
+
+extern const char *getStrFromAudioCodec(uint32_t codec);
+
+JSPropertySpec ADM_JSAudioTrackInfo::properties[] = 
+{
+	{ "codec", codecProperty, JSPROP_ENUMERATE },
+	{ "bitrate", bitrateProperty, JSPROP_ENUMERATE },
+	{ "channelCount", channelCountProperty, JSPROP_ENUMERATE },
+	{ "frequency", frequencyProperty, JSPROP_ENUMERATE },
+	{ "sourceIndex", sourceIndexProperty, JSPROP_ENUMERATE },
+	{ "targetIndex", targetIndexProperty, JSPROP_ENUMERATE },
+	{ 0 }
+};
+
+JSClass ADM_JSAudioTrackInfo::m_audioTrackInfo = 
+{
+	"AudioTrackInfo", JSCLASS_HAS_PRIVATE,
+	JS_PropertyStub, JS_PropertyStub,
+	ADM_JSAudioTrackInfo::JSGetProperty, JS_PropertyStub,
+	JS_EnumerateStub, JS_ResolveStub, 
+	JS_ConvertStub, ADM_JSAudioTrackInfo::JSDestructor
+};
+
+ADM_JSAudioTrackInfo::ADM_JSAudioTrackInfo(int sourceIndex, uint32_t encoding, int bitrate, int channelCount, int frequency)
+{
+	this->sourceIndex = sourceIndex;
+	this->targetIndex = -1;
+	this->bitrate = bitrate;
+	this->channelCount = channelCount;
+	this->frequency = frequency;
+	this->encoding = encoding;
+}
+
+ADM_JSAudioTrackInfo::ADM_JSAudioTrackInfo(int sourceIndex, int targetIndex, uint32_t encoding, int bitrate, int channelCount, int frequency)
+{
+	this->sourceIndex = sourceIndex;
+	this->targetIndex = targetIndex;
+	this->bitrate = bitrate;
+	this->channelCount = channelCount;
+	this->frequency = frequency;
+	this->encoding = encoding;
+}
+
+ADM_JSAudioTrackInfo::~ADM_JSAudioTrackInfo(void)
+{
+
+}
+
+JSObject *ADM_JSAudioTrackInfo::JSInit(JSContext *cx, JSObject *obj, JSObject *proto, int sourceIndex, audioInfo* info)
+{
+	JSObject *newObj = JS_InitClass(cx, obj, proto, &m_audioTrackInfo, NULL,
+		0, ADM_JSAudioTrackInfo::properties, NULL, NULL, NULL);
+	ADM_JSAudioTrackInfo *p = new ADM_JSAudioTrackInfo(
+		sourceIndex, info->encoding, info->bitrate, info->channels, info->frequency);
+
+	JS_SetPrivate(cx, newObj, p);
+
+	return newObj;
+}
+
+JSObject *ADM_JSAudioTrackInfo::JSInit(JSContext *cx, JSObject *obj, JSObject *proto, int sourceIndex, int targetIndex, WAVHeader* header)
+{
+	JSObject *newObj = JS_InitClass(
+		cx, obj, proto, &m_audioTrackInfo, NULL, 0, ADM_JSAudioTrackInfo::properties, NULL, NULL, NULL);
+	ADM_JSAudioTrackInfo *p = new ADM_JSAudioTrackInfo(
+		sourceIndex, targetIndex, header->encoding, (header->byterate * 8) / 1000, 
+		header->channels, header->frequency);
+
+	JS_SetPrivate(cx, newObj, p);
+
+	return newObj;
+}
+
+void ADM_JSAudioTrackInfo::JSDestructor(JSContext *cx, JSObject *obj)
+{
+
+}
+
+JSBool ADM_JSAudioTrackInfo::JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+	ADM_JSAudioTrackInfo *p = (ADM_JSAudioTrackInfo *)JS_GetPrivate(cx, obj);
+
+	if (JSVAL_IS_INT(id))
+	{
+		switch(JSVAL_TO_INT(id))
+		{
+			case sourceIndexProperty:
+			{
+				*vp = INT_TO_JSVAL(p->sourceIndex);
+				break;
+			}
+			case targetIndexProperty:
+			{
+				*vp = INT_TO_JSVAL(p->targetIndex);
+				break;
+			}
+			case codecProperty:
+			{
+				*vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, getStrFromAudioCodec(p->encoding)));
+				break;
+			}
+			case bitrateProperty:
+			{
+				*vp = INT_TO_JSVAL(p->bitrate);
+				break;
+			}
+			case channelCountProperty:
+			{
+				*vp = INT_TO_JSVAL(p->channelCount);
+				break;
+			}
+			case frequencyProperty:
+			{
+				*vp = INT_TO_JSVAL(p->frequency);
+				break;
+			}
+		}
+	}
+
+	return JS_TRUE;
+}

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h	2009-04-20 15:58:54 UTC (rev 4740)
@@ -0,0 +1,43 @@
+#ifndef _ADM_JSAUDIOTRACKINFO_H
+#define _ADM_JSAUDIOTRACKINFO_H
+
+#include "ADM_libraries/ADM_smjs/jsapi.h"
+#include "ADM_editor/ADM_Video.h"
+
+class ADM_JSAudioTrackInfo
+{
+public:
+	virtual ~ADM_JSAudioTrackInfo(void);
+	static JSObject *JSInit(JSContext *cx, JSObject *obj, JSObject *proto, int sourceIndex, audioInfo* info);
+	static JSObject *JSInit(JSContext *cx, JSObject *obj, JSObject *proto, int sourceIndex, int targetIndex, WAVHeader* header);
+
+	enum
+	{
+		codecProperty,
+		bitrateProperty,
+		channelCountProperty,
+		frequencyProperty,
+		sourceIndexProperty,
+		targetIndexProperty
+	};
+
+protected:
+	ADM_JSAudioTrackInfo(int sourceIndex, uint32_t encoding, int bitrate, int channelCount, int frequency);
+	ADM_JSAudioTrackInfo(int sourceIndex, int targetIndex, uint32_t encoding, int bitrate, int channelCount, int frequency);
+
+private:
+	int bitrate;
+	int channelCount;
+	int frequency;
+	int sourceIndex, targetIndex;
+	uint32_t encoding;
+
+	static JSBool JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+	static void JSDestructor(JSContext *cx, JSObject *obj);
+
+	static JSPropertySpec properties[];
+	static JSClass m_audioTrackInfo;
+};
+
+#endif
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-04-20 15:58:54 UTC (rev 4740)
@@ -1,503 +1,490 @@
-// C++ Interface: Spider Monkey interface
-//
-// Description: 
-//
-//
-// Author: Anish Mistry
-//      Some modification by mean
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#include "ADM_default.h"
-#include "config.h"
-#include "ADM_JSGlobal.h"
-#include "ADM_JSAvidemuxAudio.h"
-
-#include "../ADM_userInterfaces/ADM_commonUI/GUI_ui.h"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
-#include "avi_vars.h"
-#include "gui_action.hxx"
-#include "ADM_encoder/ADM_vidEncode.hxx"
-
-extern int A_audioSave(char *name);
-extern int A_loadAC3 (char *name);
-extern int A_loadMP3 (char *name);
-extern int A_loadWave (char *name);
-extern void HandleAction(Action act);
-extern uint8_t A_setSecondAudioTrack(const AudioSource nw,char *name);
-
-JSPropertySpec ADM_JSAvidemuxAudio::properties[] = {
-        { "process", audioprocess_prop, JSPROP_ENUMERATE },        // process audio when saving
-        { "resample", resample_prop, JSPROP_ENUMERATE },	// resample
-        { "delay", delay_prop, JSPROP_ENUMERATE },	// set audio delay
-        { "film2Pal", film2pal_prop, JSPROP_ENUMERATE },	// convert film to pal
-        { "pal2Film", pal2film_prop, JSPROP_ENUMERATE },	// convert pal to film
-        { "normalizeMode", normalizemode_prop, JSPROP_ENUMERATE },	//
-        { "drc", drc_prop, JSPROP_ENUMERATE },	//
-        { "normalizeValue", normalizevalue_prop, JSPROP_ENUMERATE },	//
-		{ "mixer", mixerProperty, JSPROP_ENUMERATE },	//
-        { 0 }
-};
-
-JSFunctionSpec ADM_JSAvidemuxAudio::methods[] = {
-        { "scanVbr", ScanVBR, 0, 0, 0 },	// scan variable bit rate audio
-        { "save", Save, 1, 0, 0 },	// save audio stream
-        { "load", Load, 2, 0, 0 },	// load audio stream
-        { "reset", Reset, 0, 0, 0 },	// reset audio stream
-        { "codec", Codec, 4, 0, 0 },	// set output codec
-        { "getTrackCount", getNbTracks, 0, 0, 0 },    // set output codec
-        { "setTrack", setTrack, 1, 0, 0 },    // set output codec
-        { "secondAudioTrack", secondAudioTrack, 2, 0, 0 },    // set audio track
-        { "getChannelCount", getNbChannels, 1, 0, 0 },
-        { "getBitrate", getBitrate, 1, 0, 0 },
-        { 0 }
-};
-
-JSClass ADM_JSAvidemuxAudio::m_classAvidemuxAudio = 
-{
-        "AvidemuxAudio", JSCLASS_HAS_PRIVATE,
-        JS_PropertyStub, JS_PropertyStub,
-        ADM_JSAvidemuxAudio::JSGetProperty, ADM_JSAvidemuxAudio::JSSetProperty,
-        JS_EnumerateStub, JS_ResolveStub, 
-        JS_ConvertStub, ADM_JSAvidemuxAudio::JSDestructor
-};
-
-ADM_JSAvidemuxAudio::~ADM_JSAvidemuxAudio(void)
-{
-        if(m_pObject != NULL)
-                delete m_pObject;
-        m_pObject = NULL;
-}
-
-void ADM_JSAvidemuxAudio::setObject(ADM_AvidemuxAudio *pObject)
-{
-        m_pObject = pObject; 
-}
-        
-ADM_AvidemuxAudio *ADM_JSAvidemuxAudio::getObject()
-{
-        return m_pObject; 
-}
-
-JSObject *ADM_JSAvidemuxAudio::JSInit(JSContext *cx, JSObject *obj, JSObject *proto)
-{
-	JSObject *newObj = JS_InitClass(cx, obj, proto, &m_classAvidemuxAudio, NULL, 0,
-		ADM_JSAvidemuxAudio::properties, ADM_JSAvidemuxAudio::methods, NULL, NULL);
-	ADM_JSAvidemuxAudio *p = new ADM_JSAvidemuxAudio();
-
-	p->setObject(new ADM_AvidemuxAudio());
-	JS_SetPrivate(cx, newObj, p);
-
-	return newObj;
-}
-
-void ADM_JSAvidemuxAudio::JSDestructor(JSContext *cx, JSObject *obj)
-{
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        if(p != NULL)
-                delete p;
-        p = NULL;
-}
-
-JSBool ADM_JSAvidemuxAudio::JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
-{
-        if (JSVAL_IS_INT(id)) 
-        {
-                ADM_JSAvidemuxAudio *priv = (ADM_JSAvidemuxAudio *) JS_GetPrivate(cx, obj);
-                switch(JSVAL_TO_INT(id))
-                {
-                        case audioprocess_prop:
-                                *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_bAudioProcess);
-                                break;
-                        case resample_prop:
-                                *vp = INT_TO_JSVAL(priv->getObject()->m_nResample);
-                                break;
-                        case delay_prop:
-                                *vp = INT_TO_JSVAL(priv->getObject()->m_nDelay);
-                                break;
-                        case film2pal_prop:
-                                *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_bFilm2PAL);
-                                break;
-                        case pal2film_prop:
-                                *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_bPAL2Film);
-                                break;
-                        case normalizemode_prop:
-                              *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_nNormalizeMode);
-                              break;
-                        case normalizevalue_prop:
-                          *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_nNormalizeValue);
-                          break;
-                        case drc_prop:
-                            *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_bDRC);
-                            break;
-						case mixerProperty:
-							*vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, getCurrentMixerString()));
-							break;
-                }
-        }
-        return JS_TRUE;
-}
-
-JSBool ADM_JSAvidemuxAudio::JSSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
-{
-        if (JSVAL_IS_INT(id)) 
-        {
-                
-                ADM_JSAvidemuxAudio *priv = (ADM_JSAvidemuxAudio *) JS_GetPrivate(cx, obj);
-                switch(JSVAL_TO_INT(id))
-                {
-                        case audioprocess_prop:
-                        {
-                                if(JSVAL_IS_BOOLEAN(*vp) == false)
-                                        break;
-                                priv->getObject()->m_bNormalize = JSVAL_TO_BOOLEAN(*vp);
-                                enterLock();
-                                UI_setAProcessToggleStatus(priv->getObject()->m_bAudioProcess);
-                                leaveLock();
-                                break;
-                        }
-                        case drc_prop:
-                        {
-                                if(JSVAL_IS_BOOLEAN(*vp) == false)
-                                        break;
-                                priv->getObject()->m_bDRC = JSVAL_TO_BOOLEAN(*vp);
-                                enterLock();
-                                audioFilterDrc(priv->getObject()->m_bDRC);
-                                leaveLock();
-                                break;
-                        }
-                        case resample_prop:
-                        {
-                                if(JSVAL_IS_INT(*vp) == false)
-                                        break;
-                                priv->getObject()->m_nResample = JSVAL_TO_INT(*vp);
-                                enterLock();
-                                audioFilterResample(priv->getObject()->m_nResample);
-                                leaveLock();
-                                break;
-                        }
-                        case delay_prop:
-                        {
-                                if(JSVAL_IS_INT(*vp) == false)
-                                        break;
-                                priv->getObject()->m_nDelay = JSVAL_TO_INT(*vp);
-                                //audioFilterDelay(priv->getObject()->m_nDelay);
-                                enterLock();
-                                UI_setTimeShift(1, priv->getObject()->m_nDelay); 
-                                leaveLock();
-                                break;
-                        }
-                        case film2pal_prop:
-                        {
-                                if(JSVAL_IS_BOOLEAN(*vp) == false)
-                                        break;
-                                priv->getObject()->m_bFilm2PAL = JSVAL_TO_BOOLEAN(*vp);
-                                enterLock();
-                                audioFilterFilm2Pal(priv->getObject()->m_bFilm2PAL);
-                                leaveLock();
-                                break;
-                        }
-                        case pal2film_prop:
-                        {
-                                if(JSVAL_IS_BOOLEAN(*vp) == false)
-                                        break;
-                                priv->getObject()->m_bPAL2Film = JSVAL_TO_BOOLEAN(*vp);
-                                enterLock();
-                                audioFilterPal2Film(priv->getObject()->m_bPAL2Film);
-                                leaveLock();
-                                break;
-                        }
-                        case normalizemode_prop:
-                        {
-                                  enterLock();
-                                  priv->getObject()->m_nNormalizeMode = JSVAL_TO_INT(*vp);
-                                  audioFilterNormalizeMode(priv->getObject()->m_nNormalizeMode);
-                                  leaveLock();
-                                  break;
-                        }
-                        case normalizevalue_prop:
-                        {
-                                  priv->getObject()->m_nNormalizeValue = JSVAL_TO_INT(*vp);
-                                  enterLock();
-                                  audioFilterNormalizeValue(priv->getObject()->m_nNormalizeValue);
-                                  leaveLock();
-                                  break;
-                        }
-						case mixerProperty:
-						{
-							const char *mixer = JS_GetStringBytes(JSVAL_TO_STRING(*vp));
-
-							setCurrentMixerFromString(mixer);
-							break;
-						}
-                        default : printf("UNKNOWN AUDIO PROP\n");
-                        return JS_FALSE;
-                }
-        }
-        return JS_TRUE;
-}
-
-JSBool ADM_JSAvidemuxAudio::ScanVBR(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{// begin ScanVBR
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 0)
-                return JS_FALSE;
-        printf("Scaning Audio... \n");
-        enterLock();
-        HandleAction(ACT_AudioMap);
-        leaveLock()
-        *rval = BOOLEAN_TO_JSVAL(true);
-        return JS_TRUE;
-}// end ScanVBR
-
-JSBool ADM_JSAvidemuxAudio::Save(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{// begin Save
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 1)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false)
-                return JS_FALSE;
-        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        printf("Saving Audio \"%s\"\n",pTempStr);
-        enterLock();
-        *rval = INT_TO_JSVAL(A_audioSave(pTempStr));
-        leaveLock();
-        return JS_TRUE;
-}// end Save
-
-JSBool ADM_JSAvidemuxAudio::Load(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{// begin Load
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 2)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_STRING(argv[1]) == false)
-                return JS_FALSE;
-        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[1]));
-        char *pArg0 = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        printf("Loading Audio \"%s\"\n",pTempStr);
-
-        // 1st arg is type
-        AudioSource src;
-        int result=0;
-        
-        src=audioSourceFromString(pArg0);
-        if(!src) {printf("[Script]Invalid audiosource type\n");return JS_FALSE;}
-        enterLock();
-        switch(src)
-        {
-                case AudioAvi:
-                        result = A_changeAudioStream (aviaudiostream, AudioAvi,NULL);
-                        break;
-                case AudioMP3:
-                        result = A_loadMP3(pTempStr);
-                        break;
-                case AudioWav:
-                        result = A_loadWave(pTempStr);
-                        break;
-                case AudioAC3:
-                        result = A_loadAC3(pTempStr);
-                        break;
-                case AudioNone:
-                        result = A_changeAudioStream(NULL,AudioNone,NULL);
-                        break;
-                default:
-                        ADM_assert(0);
-                        break;
-        }
-        leaveLock()
-        printf("[script] ");
-        
-        if(!result)
-                printf("failed :");
-        else
-                printf("succeed :");
-        printf(" external source %d (%s) \n", src,pTempStr);
-
-        *rval = INT_TO_JSVAL(result);
-        return JS_TRUE;
-}// end Load
-
-JSBool ADM_JSAvidemuxAudio::Reset(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{// begin Reset
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 0)
-                return JS_FALSE;
-        enterLock();
-        audioReset();
-        leaveLock()
-        *rval = BOOLEAN_TO_JSVAL(true);
-        return JS_TRUE;
-}// end Reset
-// app.audio.codec("lame",128,8,"00 00 00 00 01 00 00 00 ");
-extern uint8_t mk_hex (uint8_t a, uint8_t b);
-JSBool ADM_JSAvidemuxAudio::Codec(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{// begin Codec
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 4)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false || JSVAL_IS_INT(argv[2]) == false  ||  JSVAL_IS_STRING(argv[3]) == false  )
-                return JS_FALSE;
-        char *name = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        ADM_LowerCase(name);
-        enterLock();
-        // First search the codec by its name
-        if(!audioCodecSetByName(name))
-                *rval = BOOLEAN_TO_JSVAL(false);
-        else
-        {// begin set bitrate
-        //audioFilter_SetBitrate(JSVAL_TO_INT(argv[1]));
-          uint32_t bitrate,size;
-          char  *extra;
-          uint8_t *data=NULL;
-                bitrate=JSVAL_TO_INT(argv[1]);
-                size=JSVAL_TO_INT(argv[2]);
-                extra=JS_GetStringBytes(JSVAL_TO_STRING(argv[3])); 
-                if(size)
-                {
-                          data=new uint8_t[size];
-                          for (uint32_t k = 0; k < size; k++)
-                            {
-                              data[k] = mk_hex (*extra, *(extra + 1));
-                              extra += 3;
-                            }
-                        setAudioExtraConf(bitrate,size,data);
-                        delete [] data; 
-                }
-
-                *rval = BOOLEAN_TO_JSVAL(true);
-        }// end set bitrate
-        leaveLock();
-        return JS_TRUE;
-}// end Codec
-JSBool ADM_JSAvidemuxAudio::getNbTracks(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{
-uint32_t nb=0;
-audioInfo *infos=NULL;
-        // default return value
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        if(argc != 0)
-                return JS_FALSE;
-        // default return value
-      
-        enterLock();
-        video_body->getAudioStreamsInfo(0,&nb, &infos);
-        leaveLock();
-        if(infos)
-                delete [] infos;
-        *rval = INT_TO_JSVAL(nb);
-        return JS_TRUE;
-}// end Codec
-JSBool ADM_JSAvidemuxAudio::setTrack(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{
-uint32_t nb=0,nw=0;
-audioInfo *infos=NULL;
-        // default return value
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-
-        // default return value
-      if(argc != 1)
-                return JS_FALSE;
-        if(JSVAL_IS_INT(argv[0]) == false)
-                return JS_FALSE;
-        video_body->getAudioStreamsInfo(0,&nb, &infos);
-        delete [] infos;
-        nw=(JSVAL_TO_INT(argv[0]));
-        if(nw>nb) return JS_FALSE;
-        enterLock();
-        video_body->changeAudioStream(0,nw);
-        leaveLock();
-        return JS_TRUE;
-}// end Codec
-JSBool ADM_JSAvidemuxAudio::secondAudioTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        if(argc != 2)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_STRING(argv[1]) == false)
-                return JS_FALSE;
-        // First arg is MP3 etc...
-        char *name = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        ADM_LowerCase(name);
-        // First search the codec by its name
-        AudioSource source;
-        if(AudioInvalid==(source=audioSourceFromString(name)))
-                return JS_FALSE;
-        // Now get the name
-        name = JS_GetStringBytes(JSVAL_TO_STRING(argv[1]));
-        enterLock();
-        if(A_setSecondAudioTrack(source,name))
-        {
-                leaveLock();
-                return JS_TRUE;
-        }
-        leaveLock();
-      return JS_FALSE;
-}
-
-JSBool ADM_JSAvidemuxAudio::getNbChannels(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{
-uint32_t nb=0, nw=0;
-audioInfo *infos=NULL;
-        // default return value
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        if(argc != 1)
-                return JS_FALSE;
-        // default return value
-      
-        if(JSVAL_IS_INT(argv[0]) == false)
-                return JS_FALSE;
-        enterLock();
-        video_body->getAudioStreamsInfo(0,&nb, &infos);
-        leaveLock()
-        nw=(JSVAL_TO_INT(argv[0]));
-        if(nw>nb)
-                return JS_FALSE;
-        *rval = INT_TO_JSVAL(infos[nw].channels);
-        delete [] infos;
-        return JS_TRUE;
-}// end Codec
-
-JSBool ADM_JSAvidemuxAudio::getBitrate(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{
-uint32_t nb=0, nw=0;
-audioInfo *infos=NULL;
-        // default return value
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
-        if(argc != 1)
-                return JS_FALSE;
-        // default return value
-      
-        if(JSVAL_IS_INT(argv[0]) == false)
-                return JS_FALSE;
-        enterLock();
-        video_body->getAudioStreamsInfo(0,&nb, &infos);
-        leaveLock()
-        nw=(JSVAL_TO_INT(argv[0]));
-        if(nw>nb)
-                return JS_FALSE;
-        *rval = INT_TO_JSVAL(infos[nw].bitrate);
-        delete [] infos;
-        return JS_TRUE;
-}// end Codec
-
+// C++ Interface: Spider Monkey interface
+//
+// Description: 
+//
+//
+// Author: Anish Mistry
+//      Some modification by mean
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include "ADM_default.h"
+#include "config.h"
+#include "ADM_JSGlobal.h"
+#include "ADM_JSAvidemuxAudio.h"
+
+#include "../ADM_userInterfaces/ADM_commonUI/GUI_ui.h"
+#include "gui_action.hxx"
+#include "ADM_encoder/ADM_vidEncode.hxx"
+#include "ADM_JSAudioTrackInfo.h"
+
+extern int A_audioSave(char *name);
+extern int A_loadAC3 (char *name);
+extern int A_loadMP3 (char *name);
+extern int A_loadWave (char *name);
+extern AudioSource currentAudioSource;
+extern AudioSource secondAudioSource;
+extern void HandleAction(Action act);
+extern uint8_t A_setSecondAudioTrack(const AudioSource nw,char *name);
+
+JSPropertySpec ADM_JSAvidemuxAudio::properties[] = {
+        { "process", audioprocess_prop, JSPROP_ENUMERATE },        // process audio when saving
+        { "resample", resample_prop, JSPROP_ENUMERATE },	// resample
+        { "delay", delay_prop, JSPROP_ENUMERATE },	// set audio delay
+        { "film2Pal", film2pal_prop, JSPROP_ENUMERATE },	// convert film to pal
+        { "pal2Film", pal2film_prop, JSPROP_ENUMERATE },	// convert pal to film
+        { "normalizeMode", normalizemode_prop, JSPROP_ENUMERATE },	//
+        { "drc", drc_prop, JSPROP_ENUMERATE },	//
+        { "normalizeValue", normalizevalue_prop, JSPROP_ENUMERATE },	//
+		{ "mixer", mixerProperty, JSPROP_ENUMERATE },	//
+		{ "sourceTrackInfo", sourceTrackInfoProperty, JSPROP_ENUMERATE },
+		{ "targetTrackInfo", targetTrackInfoProperty, JSPROP_ENUMERATE },
+        { 0 }
+};
+
+JSFunctionSpec ADM_JSAvidemuxAudio::methods[] = {
+        { "scanVbr", ScanVBR, 0, 0, 0 },	// scan variable bit rate audio
+        { "save", Save, 1, 0, 0 },	// save audio stream
+        { "load", Load, 2, 0, 0 },	// load audio stream
+        { "reset", Reset, 0, 0, 0 },	// reset audio stream
+        { "codec", Codec, 4, 0, 0 },	// set output codec
+        { "setTrack", setTrack, 1, 0, 0 },    // set output codec
+        { "secondAudioTrack", secondAudioTrack, 2, 0, 0 },    // set audio track
+        { 0 }
+};
+
+JSClass ADM_JSAvidemuxAudio::m_classAvidemuxAudio = 
+{
+        "AvidemuxAudio", JSCLASS_HAS_PRIVATE,
+        JS_PropertyStub, JS_PropertyStub,
+        ADM_JSAvidemuxAudio::JSGetProperty, ADM_JSAvidemuxAudio::JSSetProperty,
+        JS_EnumerateStub, JS_ResolveStub, 
+        JS_ConvertStub, ADM_JSAvidemuxAudio::JSDestructor
+};
+
+ADM_JSAvidemuxAudio::~ADM_JSAvidemuxAudio(void)
+{
+        if(m_pObject != NULL)
+                delete m_pObject;
+        m_pObject = NULL;
+}
+
+void ADM_JSAvidemuxAudio::setObject(ADM_AvidemuxAudio *pObject)
+{
+        m_pObject = pObject; 
+}
+        
+ADM_AvidemuxAudio *ADM_JSAvidemuxAudio::getObject()
+{
+        return m_pObject; 
+}
+
+JSObject *ADM_JSAvidemuxAudio::JSInit(JSContext *cx, JSObject *obj, JSObject *proto)
+{
+	JSObject *newObj = JS_InitClass(cx, obj, proto, &m_classAvidemuxAudio, NULL, 0,
+		ADM_JSAvidemuxAudio::properties, ADM_JSAvidemuxAudio::methods, NULL, NULL);
+	ADM_JSAvidemuxAudio *p = new ADM_JSAvidemuxAudio();
+
+	p->setObject(new ADM_AvidemuxAudio());
+	JS_SetPrivate(cx, newObj, p);
+
+	return newObj;
+}
+
+void ADM_JSAvidemuxAudio::JSDestructor(JSContext *cx, JSObject *obj)
+{
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        if(p != NULL)
+                delete p;
+        p = NULL;
+}
+
+JSBool ADM_JSAvidemuxAudio::JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+        if (JSVAL_IS_INT(id)) 
+        {
+                ADM_JSAvidemuxAudio *priv = (ADM_JSAvidemuxAudio *) JS_GetPrivate(cx, obj);
+                switch(JSVAL_TO_INT(id))
+                {
+                        case audioprocess_prop:
+                                *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_bAudioProcess);
+                                break;
+                        case resample_prop:
+                                *vp = INT_TO_JSVAL(priv->getObject()->m_nResample);
+                                break;
+                        case delay_prop:
+                                *vp = INT_TO_JSVAL(priv->getObject()->m_nDelay);
+                                break;
+                        case film2pal_prop:
+                                *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_bFilm2PAL);
+                                break;
+                        case pal2film_prop:
+                                *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_bPAL2Film);
+                                break;
+                        case normalizemode_prop:
+                              *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_nNormalizeMode);
+                              break;
+                        case normalizevalue_prop:
+                          *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_nNormalizeValue);
+                          break;
+                        case drc_prop:
+                            *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_bDRC);
+                            break;
+						case mixerProperty:
+							*vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, getCurrentMixerString()));
+							break;
+						case sourceTrackInfoProperty:
+						{
+							JSObject *tracks = JS_NewArrayObject(cx, 0, NULL);
+							jsval sourceTrack;
+
+							audioInfo *audioInfos = NULL;
+							uint32_t trackCount = 0;
+
+							*vp = OBJECT_TO_JSVAL(tracks);
+							video_body->getAudioStreamsInfo(0, &trackCount, &audioInfos);
+
+							for (int infoIndex = 0; infoIndex < trackCount; infoIndex++)
+							{
+								sourceTrack = OBJECT_TO_JSVAL(ADM_JSAudioTrackInfo::JSInit(cx, obj, NULL, infoIndex, (&audioInfos)[infoIndex]));
+								JS_SetElement(cx, tracks, infoIndex, &sourceTrack);
+							}
+
+							if(audioInfos)
+								delete [] audioInfos;
+
+							break;
+						}
+						case targetTrackInfoProperty:
+						{
+							JSObject *tracks = JS_NewArrayObject(cx, 0, NULL);
+							jsval targetTrack;
+
+							*vp = OBJECT_TO_JSVAL(tracks);
+
+							AddAudioSourceToJSArray(cx, obj, 0, currentAudioSource, currentaudiostream, tracks);
+							AddAudioSourceToJSArray(cx, obj, 1, secondAudioSource, secondaudiostream, tracks);
+
+							break;
+						}
+				}
+
+				return JS_TRUE;
+		}
+}
+
+void ADM_JSAvidemuxAudio::AddAudioSourceToJSArray(JSContext *cx, JSObject *obj, int trackIndex, AudioSource audioSource, 
+												  AVDMGenericAudioStream *audioStream, JSObject *tracks)
+{
+	if (audioSource != AudioNone)
+	{
+		WAVHeader *trackHeader = audioStream->getInfo();
+
+		jsval targetTrack = OBJECT_TO_JSVAL(ADM_JSAudioTrackInfo::JSInit(
+			cx, obj, NULL, 
+			audioSource == AudioAvi ? video_body->getCurrentAudioStreamNumber(trackIndex) : -1,
+			trackIndex, trackHeader));
+		jsuint length;
+
+		JS_GetArrayLength(cx, tracks, &length);
+		JS_SetElement(cx, tracks, length, &targetTrack);
+	}
+}
+
+JSBool ADM_JSAvidemuxAudio::JSSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+        if (JSVAL_IS_INT(id)) 
+        {
+                
+                ADM_JSAvidemuxAudio *priv = (ADM_JSAvidemuxAudio *) JS_GetPrivate(cx, obj);
+                switch(JSVAL_TO_INT(id))
+                {
+                        case audioprocess_prop:
+                        {
+                                if(JSVAL_IS_BOOLEAN(*vp) == false)
+                                        break;
+                                priv->getObject()->m_bNormalize = JSVAL_TO_BOOLEAN(*vp);
+                                enterLock();
+                                UI_setAProcessToggleStatus(priv->getObject()->m_bAudioProcess);
+                                leaveLock();
+                                break;
+                        }
+                        case drc_prop:
+                        {
+                                if(JSVAL_IS_BOOLEAN(*vp) == false)
+                                        break;
+                                priv->getObject()->m_bDRC = JSVAL_TO_BOOLEAN(*vp);
+                                enterLock();
+                                audioFilterDrc(priv->getObject()->m_bDRC);
+                                leaveLock();
+                                break;
+                        }
+                        case resample_prop:
+                        {
+                                if(JSVAL_IS_INT(*vp) == false)
+                                        break;
+                                priv->getObject()->m_nResample = JSVAL_TO_INT(*vp);
+                                enterLock();
+                                audioFilterResample(priv->getObject()->m_nResample);
+                                leaveLock();
+                                break;
+                        }
+                        case delay_prop:
+                        {
+                                if(JSVAL_IS_INT(*vp) == false)
+                                        break;
+                                priv->getObject()->m_nDelay = JSVAL_TO_INT(*vp);
+                                //audioFilterDelay(priv->getObject()->m_nDelay);
+                                enterLock();
+                                UI_setTimeShift(1, priv->getObject()->m_nDelay); 
+                                leaveLock();
+                                break;
+                        }
+                        case film2pal_prop:
+                        {
+                                if(JSVAL_IS_BOOLEAN(*vp) == false)
+                                        break;
+                                priv->getObject()->m_bFilm2PAL = JSVAL_TO_BOOLEAN(*vp);
+                                enterLock();
+                                audioFilterFilm2Pal(priv->getObject()->m_bFilm2PAL);
+                                leaveLock();
+                                break;
+                        }
+                        case pal2film_prop:
+                        {
+                                if(JSVAL_IS_BOOLEAN(*vp) == false)
+                                        break;
+                                priv->getObject()->m_bPAL2Film = JSVAL_TO_BOOLEAN(*vp);
+                                enterLock();
+                                audioFilterPal2Film(priv->getObject()->m_bPAL2Film);
+                                leaveLock();
+                                break;
+                        }
+                        case normalizemode_prop:
+                        {
+                                  enterLock();
+                                  priv->getObject()->m_nNormalizeMode = JSVAL_TO_INT(*vp);
+                                  audioFilterNormalizeMode(priv->getObject()->m_nNormalizeMode);
+                                  leaveLock();
+                                  break;
+                        }
+                        case normalizevalue_prop:
+                        {
+                                  priv->getObject()->m_nNormalizeValue = JSVAL_TO_INT(*vp);
+                                  enterLock();
+                                  audioFilterNormalizeValue(priv->getObject()->m_nNormalizeValue);
+                                  leaveLock();
+                                  break;
+                        }
+						case mixerProperty:
+						{
+							const char *mixer = JS_GetStringBytes(JSVAL_TO_STRING(*vp));
+
+							setCurrentMixerFromString(mixer);
+							break;
+						}
+                        default : printf("UNKNOWN AUDIO PROP\n");
+                        return JS_FALSE;
+                }
+        }
+        return JS_TRUE;
+}
+
+JSBool ADM_JSAvidemuxAudio::ScanVBR(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{// begin ScanVBR
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 0)
+                return JS_FALSE;
+        printf("Scaning Audio... \n");
+        enterLock();
+        HandleAction(ACT_AudioMap);
+        leaveLock()
+        *rval = BOOLEAN_TO_JSVAL(true);
+        return JS_TRUE;
+}// end ScanVBR
+
+JSBool ADM_JSAvidemuxAudio::Save(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{// begin Save
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 1)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false)
+                return JS_FALSE;
+        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        printf("Saving Audio \"%s\"\n",pTempStr);
+        enterLock();
+        *rval = INT_TO_JSVAL(A_audioSave(pTempStr));
+        leaveLock();
+        return JS_TRUE;
+}// end Save
+
+JSBool ADM_JSAvidemuxAudio::Load(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{// begin Load
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 2)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_STRING(argv[1]) == false)
+                return JS_FALSE;
+        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[1]));
+        char *pArg0 = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        printf("Loading Audio \"%s\"\n",pTempStr);
+
+        // 1st arg is type
+        AudioSource src;
+        int result=0;
+        
+        src=audioSourceFromString(pArg0);
+        if(!src) {printf("[Script]Invalid audiosource type\n");return JS_FALSE;}
+        enterLock();
+        switch(src)
+        {
+                case AudioAvi:
+                        result = A_changeAudioStream (aviaudiostream, AudioAvi,NULL);
+                        break;
+                case AudioMP3:
+                        result = A_loadMP3(pTempStr);
+                        break;
+                case AudioWav:
+                        result = A_loadWave(pTempStr);
+                        break;
+                case AudioAC3:
+                        result = A_loadAC3(pTempStr);
+                        break;
+                case AudioNone:
+                        result = A_changeAudioStream(NULL,AudioNone,NULL);
+                        break;
+                default:
+                        ADM_assert(0);
+                        break;
+        }
+        leaveLock()
+        printf("[script] ");
+        
+        if(!result)
+                printf("failed :");
+        else
+                printf("succeed :");
+        printf(" external source %d (%s) \n", src,pTempStr);
+
+        *rval = INT_TO_JSVAL(result);
+        return JS_TRUE;
+}// end Load
+
+JSBool ADM_JSAvidemuxAudio::Reset(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{// begin Reset
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 0)
+                return JS_FALSE;
+        enterLock();
+        audioReset();
+        leaveLock()
+        *rval = BOOLEAN_TO_JSVAL(true);
+        return JS_TRUE;
+}// end Reset
+// app.audio.codec("lame",128,8,"00 00 00 00 01 00 00 00 ");
+extern uint8_t mk_hex (uint8_t a, uint8_t b);
+JSBool ADM_JSAvidemuxAudio::Codec(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{// begin Codec
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 4)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false || JSVAL_IS_INT(argv[2]) == false  ||  JSVAL_IS_STRING(argv[3]) == false  )
+                return JS_FALSE;
+        char *name = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        ADM_LowerCase(name);
+        enterLock();
+        // First search the codec by its name
+        if(!audioCodecSetByName(name))
+                *rval = BOOLEAN_TO_JSVAL(false);
+        else
+        {// begin set bitrate
+        //audioFilter_SetBitrate(JSVAL_TO_INT(argv[1]));
+          uint32_t bitrate,size;
+          char  *extra;
+          uint8_t *data=NULL;
+                bitrate=JSVAL_TO_INT(argv[1]);
+                size=JSVAL_TO_INT(argv[2]);
+                extra=JS_GetStringBytes(JSVAL_TO_STRING(argv[3])); 
+                if(size)
+                {
+                          data=new uint8_t[size];
+                          for (uint32_t k = 0; k < size; k++)
+                            {
+                              data[k] = mk_hex (*extra, *(extra + 1));
+                              extra += 3;
+                            }
+                        setAudioExtraConf(bitrate,size,data);
+                        delete [] data; 
+                }
+
+                *rval = BOOLEAN_TO_JSVAL(true);
+        }// end set bitrate
+        leaveLock();
+        return JS_TRUE;
+}// end Codec
+
+JSBool ADM_JSAvidemuxAudio::setTrack(JSContext *cx, JSObject *obj, uintN argc, 
+                                      jsval *argv, jsval *rval)
+{
+uint32_t nb=0,nw=0;
+audioInfo *infos=NULL;
+        // default return value
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+
+        // default return value
+      if(argc != 1)
+                return JS_FALSE;
+        if(JSVAL_IS_INT(argv[0]) == false)
+                return JS_FALSE;
+        video_body->getAudioStreamsInfo(0,&nb, &infos);
+        delete [] infos;
+        nw=(JSVAL_TO_INT(argv[0]));
+        if(nw>nb) return JS_FALSE;
+        enterLock();
+        video_body->changeAudioStream(0,nw);
+        leaveLock();
+        return JS_TRUE;
+}// end Codec
+
+JSBool ADM_JSAvidemuxAudio::secondAudioTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
+        if(argc != 2)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_STRING(argv[1]) == false)
+                return JS_FALSE;
+        // First arg is MP3 etc...
+        char *name = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        ADM_LowerCase(name);
+        // First search the codec by its name
+        AudioSource source;
+        if(AudioInvalid==(source=audioSourceFromString(name)))
+                return JS_FALSE;
+        // Now get the name
+        name = JS_GetStringBytes(JSVAL_TO_STRING(argv[1]));
+        enterLock();
+        if(A_setSecondAudioTrack(source,name))
+        {
+                leaveLock();
+                return JS_TRUE;
+        }
+        leaveLock();
+      return JS_FALSE;
+}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h	2009-04-20 15:58:54 UTC (rev 4740)
@@ -8,6 +8,8 @@
 // Spidermonkey
 #include "ADM_libraries/ADM_smjs/jsapi.h"
 #include "ADM_AvidemuxAudio.h"
+#include "avi_vars.h"
+#include "ADM_audiofilter/audioeng_buildfilters.h"
 
 class ADM_JSAvidemuxAudio
 {
@@ -25,7 +27,9 @@
 		normalizemode_prop,
 		normalizevalue_prop,
 		drc_prop,
-		mixerProperty
+		mixerProperty,
+		sourceTrackInfoProperty,
+		targetTrackInfoProperty
 	};
 
 private:
@@ -46,11 +50,9 @@
 	static JSBool Load(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool Reset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool Codec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool getNbTracks(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static void AddAudioSourceToJSArray(JSContext *cx, JSObject *obj, int trackIndex, AudioSource audioSource, AVDMGenericAudioStream *audioStream, JSObject *tracks);
 	static JSBool setTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool secondAudioTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool getNbChannels(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool getBitrate(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 };
 
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt	2009-04-20 15:58:54 UTC (rev 4740)
@@ -1,7 +1,7 @@
 SET(ADM_script_SRCS
 	ADM_AvidemuxAudio.cpp  ADM_AvidemuxVideo.cpp    ADM_JSAvidemux.cpp       ADM_JSDirectorySearch.cpp  ADM_JSGlobal.cpp
 	ADM_Avidemux.cpp       ADM_JSAvidemuxAudio.cpp  ADM_JSAvidemuxVideo.cpp  ADM_JSFunctions.cpp        DirectorySearch.cpp
-	ADM_JSDialogFactory.cpp  ADM_JSDFMenu.cpp  ADM_JSAppliedVideoFilter.cpp)
+	ADM_JSDialogFactory.cpp  ADM_JSDFMenu.cpp  ADM_JSAppliedVideoFilter.cpp  ADM_JSAudioTrackInfo.cpp)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_script ${ADM_script_SRCS})
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2009-04-18 18:25:04 UTC (rev 4739)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2009-04-20 15:58:54 UTC (rev 4740)
@@ -61,10 +61,10 @@
 #include "ADM_libraries/ADM_libmpeg2enc/ADM_mpeg2enc.h"
 #include "ADM_video/ADM_vidMisc.h"
 #include "ADM_preview.h"
-static AudioSource currentAudioSource = AudioAvi;
-static AudioSource secondAudioSource = AudioNone;
-static char *currentAudioName = NULL;
-static char *secondAudioName = NULL;
+AudioSource currentAudioSource = AudioAvi;
+AudioSource secondAudioSource = AudioNone;
+char *currentAudioName = NULL;
+char *secondAudioName = NULL;
 
 void A_handleSecondTrack (int tracktype);
 int A_delete(uint32_t start, uint32_t end);



From gruntster at mail.berlios.de  Mon Apr 20 21:48:14 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 20 Apr 2009 21:48:14 +0200
Subject: [Avidemux-svn-commit] r4741 - in
	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_script
	scripts/auto
Message-ID: <200904201948.n3KJmEVe015456@sheep.berlios.de>

Author: gruntster
Date: 2009-04-20 21:48:09 +0200 (Mon, 20 Apr 2009)
New Revision: 4741

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
   branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js
Log:
[script] change PSP auto wizard to check appropriateness of target audio track

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-04-20 15:58:54 UTC (rev 4740)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-04-20 19:48:09 UTC (rev 4741)
@@ -170,9 +170,9 @@
 							break;
 						}
 				}
+		}
 
-				return JS_TRUE;
-		}
+		return JS_TRUE;
 }
 
 void ADM_JSAvidemuxAudio::AddAudioSourceToJSArray(JSContext *cx, JSObject *obj, int trackIndex, AudioSource audioSource, 

Modified: branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js	2009-04-20 15:58:54 UTC (rev 4740)
+++ branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js	2009-04-20 19:48:09 UTC (rev 4741)
@@ -20,11 +20,20 @@
         resizeAndFillVideo(targetX, targetY, sourceRatio, destinationRatio);
 
         app.video.codecPlugin("32BCB447-21C9-4210-AE9A-4FCE6C8588AE", "x264", "2PASSBITRATE=1000", "<?xml version='1.0'?><x264Config><presetConfiguration><name>Sony PlayStation Portable</name><type>system</type></presetConfiguration><x264Options></x264Options></x264Config>");
-        app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
 
-        if (app.audio.getChannelCount(0) != 2)
-            app.audio.mixer = "STEREO";
+        if (app.audio.targetTrackInfo.length > 0)
+        {
+            if (app.audio.targetTrackInfo[0].codec != "AAC" || app.audio.targetTrackInfo[0].channelCount != 2)
+            {
+                app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
 
+                if (app.audio.targetTrackInfo[0].channelCount == 2)
+                    app.audio.mixer = "NONE";
+                else
+                    app.audio.mixer = "STEREO";
+            }
+        }
+
         app.setContainer("PSP");
     }
 }
\ No newline at end of file



From gruntster at mail.berlios.de  Tue Apr 21 10:59:03 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 21 Apr 2009 10:59:03 +0200
Subject: [Avidemux-svn-commit] r4742 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder:
	ADM_vidEnc_x264/qt4 ADM_vidEnc_xvid/qt4
Message-ID: <200904210859.n3L8x3Zw024254@sheep.berlios.de>

Author: gruntster
Date: 2009-04-21 10:58:57 +0200 (Tue, 21 Apr 2009)
New Revision: 4742

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.cpp
Log:
[x264/xvid] use complete base name of xml config file so full stops are handled in name

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp	2009-04-20 19:48:09 UTC (rev 4741)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp	2009-04-21 08:58:57 UTC (rev 4742)
@@ -173,12 +173,12 @@
 	disableGenericSlots = true;
 
 	for (int item = 0; item < list.size(); item++)
-		configs.insert(QFileInfo(list[item]).baseName(), CONFIG_USER);
+		configs.insert(QFileInfo(list[item]).completeBaseName(), CONFIG_USER);
 
 	list = QDir(getSystemConfigDirectory()).entryList(filter, QDir::Files | QDir::Readable);
 
 	for (int item = 0; item < list.size(); item++)
-		configs.insert(QFileInfo(list[item]).baseName(), CONFIG_SYSTEM);
+		configs.insert(QFileInfo(list[item]).completeBaseName(), CONFIG_SYSTEM);
 
 	ui.configurationComboBox->clear();
 	ui.configurationComboBox->addItem(QT_TR_NOOP("<default>"), CONFIG_DEFAULT);
@@ -340,7 +340,7 @@
 		delete [] xml;
 
 		fillConfigurationComboBox();
-		selectConfiguration(&QFileInfo(configFileName).baseName(), CONFIG_USER);
+		selectConfiguration(&QFileInfo(configFileName).completeBaseName(), CONFIG_USER);
 	}
 
 	delete [] configDirectory;

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.cpp	2009-04-20 19:48:09 UTC (rev 4741)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.cpp	2009-04-21 08:58:57 UTC (rev 4742)
@@ -102,12 +102,12 @@
 	disableGenericSlots = true;
 
 	for (int item = 0; item < list.size(); item++)
-		configs.insert(QFileInfo(list[item]).baseName(), CONFIG_USER);
+		configs.insert(QFileInfo(list[item]).completeBaseName(), CONFIG_USER);
 
 	list = QDir(getSystemConfigDirectory()).entryList(filter, QDir::Files | QDir::Readable);
 
 	for (int item = 0; item < list.size(); item++)
-		configs.insert(QFileInfo(list[item]).baseName(), CONFIG_SYSTEM);
+		configs.insert(QFileInfo(list[item]).completeBaseName(), CONFIG_SYSTEM);
 
 	ui.configurationComboBox->clear();
 	ui.configurationComboBox->addItem(QT_TR_NOOP("<default>"), CONFIG_DEFAULT);
@@ -239,7 +239,7 @@
 		delete [] xml;
 
 		fillConfigurationComboBox();
-		selectConfiguration(&QFileInfo(configFileName).baseName(), CONFIG_USER);
+		selectConfiguration(&QFileInfo(configFileName).completeBaseName(), CONFIG_USER);
 	}
 
 	delete [] configDirectory;



From gruntster at mail.berlios.de  Tue Apr 21 12:38:07 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 21 Apr 2009 12:38:07 +0200
Subject: [Avidemux-svn-commit] r4743 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml
Message-ID: <200904211038.n3LAc78X007835@sheep.berlios.de>

Author: gruntster
Date: 2009-04-21 12:37:59 +0200 (Tue, 21 Apr 2009)
New Revision: 4743

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPhone.xml
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPod 5.5G.xml
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPod.xml
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Microsoft Zune.xml
Log:
[x264] add additional device presets

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPhone.xml
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPhone.xml	2009-04-21 08:58:57 UTC (rev 4742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPhone.xml	2009-04-21 10:37:59 UTC (rev 4743)
@@ -0,0 +1,23 @@
+<?xml version='1.0'?>
+<x264Config>
+  <encodeOptions>
+    <mode>2PASS ABR</mode>
+    <parameter>1000</parameter>
+  </encodeOptions>
+  <x264Options>
+    <idcLevel>3</idcLevel>
+    <cabac>false</cabac>
+    <analyse>
+      <partitionI4x4>true</partitionI4x4>
+      <partitionI8x8>false</partitionI8x8>
+      <partitionP8x8>true</partitionP8x8>
+      <partitionP4x4>false</partitionP4x4>
+      <partitionB8x8>true</partitionB8x8>
+      <trellis>disabled</trellis>
+    </analyse>
+    <rateControl>
+      <vbvMaximumBitrate>10000</vbvMaximumBitrate>
+      <vbvBufferSize>10000</vbvBufferSize>
+    </rateControl>
+  </x264Options>
+</x264Config>
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPod 5.5G.xml
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPod 5.5G.xml	2009-04-21 08:58:57 UTC (rev 4742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPod 5.5G.xml	2009-04-21 10:37:59 UTC (rev 4743)
@@ -0,0 +1,26 @@
+<?xml version='1.0'?>
+<x264Config>
+  <encodeOptions>
+    <mode>2PASS ABR</mode>
+    <parameter>1000</parameter>
+  </encodeOptions>
+  <x264Options>
+    <idcLevel>3</idcLevel>
+    <cabac>false</cabac>
+    <analyse>
+      <partitionI4x4>true</partitionI4x4>
+      <partitionI8x8>false</partitionI8x8>
+      <partitionP8x8>true</partitionP8x8>
+      <partitionP4x4>false</partitionP4x4>
+      <partitionB8x8>true</partitionB8x8>
+      <motionEstimationMethod>multi-hexagonal</motionEstimationMethod>
+      <motionVectorSearchRange>12</motionVectorSearchRange>
+      <trellis>disabled</trellis>
+    </analyse>
+    <rateControl>
+      <quantiserMinimum>16</quantiserMinimum>
+      <vbvMaximumBitrate>1500</vbvMaximumBitrate>
+      <vbvBufferSize>1500</vbvBufferSize>
+    </rateControl>
+  </x264Options>
+</x264Config>
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPod.xml
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPod.xml	2009-04-21 08:58:57 UTC (rev 4742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Apple iPod.xml	2009-04-21 10:37:59 UTC (rev 4743)
@@ -0,0 +1,26 @@
+<?xml version='1.0'?>
+<x264Config>
+  <encodeOptions>
+    <mode>2PASS ABR</mode>
+    <parameter>600</parameter>
+  </encodeOptions>
+  <x264Options>
+    <idcLevel>13</idcLevel>
+    <cabac>false</cabac>
+    <analyse>
+      <partitionI4x4>true</partitionI4x4>
+      <partitionI8x8>false</partitionI8x8>
+      <partitionP8x8>true</partitionP8x8>
+      <partitionP4x4>true</partitionP4x4>
+      <partitionB8x8>true</partitionB8x8>
+      <motionEstimationMethod>multi-hexagonal</motionEstimationMethod>
+      <motionVectorSearchRange>12</motionVectorSearchRange>
+      <trellis>disabled</trellis>
+    </analyse>
+    <rateControl>
+      <quantiserMinimum>16</quantiserMinimum>
+      <vbvMaximumBitrate>768</vbvMaximumBitrate>
+      <vbvBufferSize>768</vbvBufferSize>
+    </rateControl>
+  </x264Options>
+</x264Config>
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Microsoft Zune.xml
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Microsoft Zune.xml	2009-04-21 08:58:57 UTC (rev 4742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Microsoft Zune.xml	2009-04-21 10:37:59 UTC (rev 4743)
@@ -0,0 +1,27 @@
+<?xml version='1.0'?>
+<x264Config>
+  <encodeOptions>
+    <mode>2PASS ABR</mode>
+    <parameter>1000</parameter>
+  </encodeOptions>
+  <x264Options>
+    <idcLevel>3</idcLevel>
+    <loopFilter>false</loopFilter>
+    <cabac>false</cabac>
+    <analyse>
+      <partitionI4x4>true</partitionI4x4>
+      <partitionI8x8>false</partitionI8x8>
+      <partitionP8x8>true</partitionP8x8>
+      <partitionP4x4>false</partitionP4x4>
+      <partitionB8x8>true</partitionB8x8>
+      <motionEstimationMethod>multi-hexagonal</motionEstimationMethod>
+      <motionVectorSearchRange>12</motionVectorSearchRange>
+      <trellis>disabled</trellis>
+    </analyse>
+    <rateControl>
+      <quantiserMinimum>16</quantiserMinimum>
+      <vbvMaximumBitrate>2500</vbvMaximumBitrate>
+      <vbvBufferSize>2500</vbvBufferSize>
+    </rateControl>
+  </x264Options>
+</x264Config>
\ No newline at end of file



From gruntster at mail.berlios.de  Tue Apr 21 16:53:18 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 21 Apr 2009 16:53:18 +0200
Subject: [Avidemux-svn-commit] r4744 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <200904211453.n3LErIeG002539@sheep.berlios.de>

Author: gruntster
Date: 2009-04-21 16:53:13 +0200 (Tue, 21 Apr 2009)
New Revision: 4744

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
Log:
[qt] use complete base name for auto wizards so full stops are handled in name

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-04-21 10:37:59 UTC (rev 4743)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-04-21 14:53:13 UTC (rev 4744)
@@ -618,7 +618,7 @@
 	}
 	else
 	{
-		QAction *action = new QAction(info.baseName(), parentMenu);
+		QAction *action = new QAction(info.completeBaseName(), parentMenu);
 
 		parentMenu->addAction(action);
 		connect(action, SIGNAL(triggered()), this, SLOT(autoMenuHandler()));



From gruntster at mail.berlios.de  Tue Apr 21 16:55:45 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 21 Apr 2009 16:55:45 +0200
Subject: [Avidemux-svn-commit] r4745 - in
	branches/avidemux_2.5_branch_gruntster/scripts/auto: . Apple
Message-ID: <200904211455.n3LEtjT1002702@sheep.berlios.de>

Author: gruntster
Date: 2009-04-21 16:55:38 +0200 (Tue, 21 Apr 2009)
New Revision: 4745

Added:
   branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/
   branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPhone.js
   branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPod 5.5G.js
   branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPod.js
   branches/avidemux_2.5_branch_gruntster/scripts/auto/Microsoft Zune.js
Log:
[auto] add more device auto wizards

Added: branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPhone.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPhone.js	2009-04-21 14:53:13 UTC (rev 4744)
+++ branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPhone.js	2009-04-21 14:55:38 UTC (rev 4745)
@@ -0,0 +1,39 @@
+//AD
+include("video/autoWizard.js");
+include("video/filter.js");
+
+var app = new Avidemux();
+
+if (app.video == null)
+    displayError("A video file must be open to use this Auto Wizard.");
+else
+{
+    var result = videoAutoWizard("Apple iPhone Auto Wizard", [[320, 240], [640, 480]]);
+
+    if (result)
+    {
+        var targetX = result[0][0];
+        var targetY = result[0][1];
+        var sourceRatio = result[1][0] + ":" + result[1][1];
+        var destinationRatio = result[2][0] + ":" + result[2][1];
+
+        resizeAndFillVideo(targetX, targetY, sourceRatio, destinationRatio);
+
+        app.video.codecPlugin("32BCB447-21C9-4210-AE9A-4FCE6C8588AE", "x264", "2PASSBITRATE=1000", "<?xml version='1.0'?><x264Config><presetConfiguration><name>Apple iPhone</name><type>system</type></presetConfiguration><x264Options></x264Options></x264Config>");
+
+        if (app.audio.targetTrackInfo.length > 0)
+        {
+            if (app.audio.targetTrackInfo[0].codec != "AAC" || app.audio.targetTrackInfo[0].channelCount != 2)
+            {
+                app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
+
+                if (app.audio.targetTrackInfo[0].channelCount == 2)
+                    app.audio.mixer = "NONE";
+                else
+                    app.audio.mixer = "STEREO";
+            }
+        }
+
+        app.setContainer("MP4");
+    }
+}
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPod 5.5G.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPod 5.5G.js	2009-04-21 14:53:13 UTC (rev 4744)
+++ branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPod 5.5G.js	2009-04-21 14:55:38 UTC (rev 4745)
@@ -0,0 +1,39 @@
+//AD
+include("video/autoWizard.js");
+include("video/filter.js");
+
+var app = new Avidemux();
+
+if (app.video == null)
+    displayError("A video file must be open to use this Auto Wizard.");
+else
+{
+    var result = videoAutoWizard("Apple iPod 5.5G Auto Wizard", [[320, 240], [640, 480]]);
+
+    if (result)
+    {
+        var targetX = result[0][0];
+        var targetY = result[0][1];
+        var sourceRatio = result[1][0] + ":" + result[1][1];
+        var destinationRatio = result[2][0] + ":" + result[2][1];
+
+        resizeAndFillVideo(targetX, targetY, sourceRatio, destinationRatio);
+
+        app.video.codecPlugin("32BCB447-21C9-4210-AE9A-4FCE6C8588AE", "x264", "2PASSBITRATE=1000", "<?xml version='1.0'?><x264Config><presetConfiguration><name>Apple iPod 5.5G</name><type>system</type></presetConfiguration><x264Options></x264Options></x264Config>");
+
+        if (app.audio.targetTrackInfo.length > 0)
+        {
+            if (app.audio.targetTrackInfo[0].codec != "AAC" || app.audio.targetTrackInfo[0].channelCount != 2)
+            {
+                app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
+
+                if (app.audio.targetTrackInfo[0].channelCount == 2)
+                    app.audio.mixer = "NONE";
+                else
+                    app.audio.mixer = "STEREO";
+            }
+        }
+
+        app.setContainer("MP4");
+    }
+}
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPod.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPod.js	2009-04-21 14:53:13 UTC (rev 4744)
+++ branches/avidemux_2.5_branch_gruntster/scripts/auto/Apple/Apple iPod.js	2009-04-21 14:55:38 UTC (rev 4745)
@@ -0,0 +1,39 @@
+//AD
+include("video/autoWizard.js");
+include("video/filter.js");
+
+var app = new Avidemux();
+
+if (app.video == null)
+    displayError("A video file must be open to use this Auto Wizard.");
+else
+{
+    var result = videoAutoWizard("Apple iPod Auto Wizard", [[320, 240]]);
+
+    if (result)
+    {
+        var targetX = result[0][0];
+        var targetY = result[0][1];
+        var sourceRatio = result[1][0] + ":" + result[1][1];
+        var destinationRatio = result[2][0] + ":" + result[2][1];
+
+        resizeAndFillVideo(targetX, targetY, sourceRatio, destinationRatio);
+
+        app.video.codecPlugin("32BCB447-21C9-4210-AE9A-4FCE6C8588AE", "x264", "2PASSBITRATE=600", "<?xml version='1.0'?><x264Config><presetConfiguration><name>Apple iPod</name><type>system</type></presetConfiguration><x264Options></x264Options></x264Config>");
+
+        if (app.audio.targetTrackInfo.length > 0)
+        {
+            if (app.audio.targetTrackInfo[0].codec != "AAC" || app.audio.targetTrackInfo[0].channelCount != 2)
+            {
+                app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
+
+                if (app.audio.targetTrackInfo[0].channelCount == 2)
+                    app.audio.mixer = "NONE";
+                else
+                    app.audio.mixer = "STEREO";
+            }
+        }
+
+        app.setContainer("MP4");
+    }
+}
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/scripts/auto/Microsoft Zune.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/auto/Microsoft Zune.js	2009-04-21 14:53:13 UTC (rev 4744)
+++ branches/avidemux_2.5_branch_gruntster/scripts/auto/Microsoft Zune.js	2009-04-21 14:55:38 UTC (rev 4745)
@@ -0,0 +1,39 @@
+//AD
+include("video/autoWizard.js");
+include("video/filter.js");
+
+var app = new Avidemux();
+
+if (app.video == null)
+    displayError("A video file must be open to use this Auto Wizard.");
+else
+{
+    var result = videoAutoWizard("Microsoft Zune Auto Wizard", [[320, 240], [640, 480]]);
+
+    if (result)
+    {
+        var targetX = result[0][0];
+        var targetY = result[0][1];
+        var sourceRatio = result[1][0] + ":" + result[1][1];
+        var destinationRatio = result[2][0] + ":" + result[2][1];
+
+        resizeAndFillVideo(targetX, targetY, sourceRatio, destinationRatio);
+
+        app.video.codecPlugin("32BCB447-21C9-4210-AE9A-4FCE6C8588AE", "x264", "2PASSBITRATE=1000", "<?xml version='1.0'?><x264Config><presetConfiguration><name>Microsoft Zune</name><type>system</type></presetConfiguration><x264Options></x264Options></x264Config>");
+
+        if (app.audio.targetTrackInfo.length > 0)
+        {
+            if (app.audio.targetTrackInfo[0].codec != "AAC" || app.audio.targetTrackInfo[0].channelCount != 2)
+            {
+                app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
+
+                if (app.audio.targetTrackInfo[0].channelCount == 2)
+                    app.audio.mixer = "NONE";
+                else
+                    app.audio.mixer = "STEREO";
+            }
+        }
+
+        app.setContainer("MP4");
+    }
+}
\ No newline at end of file



From gruntster at mail.berlios.de  Tue Apr 21 18:15:59 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 21 Apr 2009 18:15:59 +0200
Subject: [Avidemux-svn-commit] r4746 - in
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src:
	. ADM_libsamplerate
Message-ID: <200904211615.n3LGFxjk013637@sheep.berlios.de>

Author: gruntster
Date: 2009-04-21 18:15:51 +0200 (Tue, 21 Apr 2009)
New Revision: 4746

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/config.h
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/common.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/float_cast.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/samplerate.c
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_linear.c
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_sinc.c
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_zoh.c
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
Log:
[src] update Secret Rabbit Code to 0.1.7 for speed improvements

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp	2009-04-21 16:15:51 UTC (rev 4746)
@@ -48,7 +48,7 @@
     fromFrequency=from;
     toFrequency=to;
     nbChannels=channel;
-    context=(void *)src_new (SRC_SINC_FASTEST*0+1*SRC_SINC_MEDIUM_QUALITY, channel, &er) ;
+    context=(void *)src_new (SRC_SINC_MEDIUM_QUALITY, channel, &er) ;
     if(!context) 
     {
         printf("[SRC] Error :%d\n",er);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/common.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/common.h	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/common.h	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,148 +1,157 @@
-/*
-** Copyright (C) 2002-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/*
-** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
-** use license for this code is available, please see:
-**		http://www.mega-nerd.com/SRC/procedure.html
-*/
-
-#ifndef COMMON_H_INCLUDED
-#define COMMON_H_INCLUDED
-
-#ifdef HAVE_STDINT_H
-#include <stdint.h>
-#elif (SIZEOF_INT == 4)
-typedef	int		int32_t ;
-#elif (SIZEOF_LONG == 4)
-typedef	long	int32_t ;
-#endif
-
-#define	SRC_MAX_RATIO			256
-#define	SRC_MIN_RATIO_DIFF		(1e-20)
-
-#define	MAX(a,b)	(((a) > (b)) ? (a) : (b))
-#define	MIN(a,b)	(((a) < (b)) ? (a) : (b))
-
-#define	ARRAY_LEN(x)			((int) (sizeof (x) / sizeof ((x) [0])))
-#define OFFSETOF(type,member)	((int) (&((type*) 0)->member))
-
-#define	MAKE_MAGIC(a,b,c,d,e,f)	((a) + ((b) << 4) + ((c) << 8) + ((d) << 12) + ((e) << 16) + ((f) << 20))
-
-
-#include "samplerate.h"
-
-enum
-{	SRC_FALSE	= 0,
-	SRC_TRUE	= 1,
-
-	SRC_MODE_PROCESS	= 555,
-	SRC_MODE_CALLBACK	= 556
-} ;
-
-enum
-{	SRC_ERR_NO_ERROR = 0,
-
-	SRC_ERR_MALLOC_FAILED,
-	SRC_ERR_BAD_STATE,
-	SRC_ERR_BAD_DATA,
-	SRC_ERR_BAD_DATA_PTR,
-	SRC_ERR_NO_PRIVATE,
-	SRC_ERR_BAD_SRC_RATIO,
-	SRC_ERR_BAD_PROC_PTR,
-	SRC_ERR_SHIFT_BITS,
-	SRC_ERR_FILTER_LEN,
-	SRC_ERR_BAD_CONVERTER,
-	SRC_ERR_BAD_CHANNEL_COUNT,
-	SRC_ERR_SINC_BAD_BUFFER_LEN,
-	SRC_ERR_SIZE_INCOMPATIBILITY,
-	SRC_ERR_BAD_PRIV_PTR,
-	SRC_ERR_BAD_SINC_STATE,
-	SRC_ERR_DATA_OVERLAP,
-	SRC_ERR_BAD_CALLBACK,
-	SRC_ERR_BAD_MODE,
-	SRC_ERR_NULL_CALLBACK,
-	SRC_ERR_NO_VARIABLE_RATIO,
-
-	/* This must be the last error number. */
-	SRC_ERR_MAX_ERROR
-} ;
-
-typedef struct SRC_PRIVATE_tag
-{	double	last_ratio, last_position ;
-
-	int		error ;
-	int		channels ;
-
-	/* SRC_MODE_PROCESS or SRC_MODE_CALLBACK */
-	int		mode ;
-
-	/* Pointer to data to converter specific data. */
-	void	*private_data ;
-
-	/* Varispeed process function. */
-	int		(*vari_process) (struct SRC_PRIVATE_tag *psrc, SRC_DATA *data) ;
-
-	/* Constant speed process function. */
-	int		(*const_process) (struct SRC_PRIVATE_tag *psrc, SRC_DATA *data) ;
-
-	/* State reset. */
-	void	(*reset) (struct SRC_PRIVATE_tag *psrc) ;
-
-	/* Data specific to SRC_MODE_CALLBACK. */
-	src_callback_t	callback_func ;
-	void			*user_callback_data ;
-	long			saved_frames ;
-	float			*saved_data ;
-} SRC_PRIVATE ;
-
-/* In src_sinc.c */
-const char* sinc_get_name (int src_enum) ;
-const char* sinc_get_description (int src_enum) ;
-
-int sinc_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
-
-/* In src_linear.c */
-const char* linear_get_name (int src_enum) ;
-const char* linear_get_description (int src_enum) ;
-
-int linear_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
-
-/* In src_zoh.c */
-const char* zoh_get_name (int src_enum) ;
-const char* zoh_get_description (int src_enum) ;
-
-int zoh_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
-
-/*----------------------------------------------------------
-**	Common static inline functions.
-*/
-
-static inline double
-fmod_one (double x)
-{	double res ;
-
-	res = x - lrint (x) ;
-	if (res < 0.0)
-		return res + 1.0 ;
-
-	return res ;
-} /* fmod_one */
-
-#endif	/* COMMON_H_INCLUDED */
-
+/*
+** Copyright (C) 2002-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/*
+** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
+** use license for this code is available, please see:
+**		http://www.mega-nerd.com/SRC/procedure.html
+*/
+
+#ifndef COMMON_H_INCLUDED
+#define COMMON_H_INCLUDED
+
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#elif (SIZEOF_INT == 4)
+typedef	int		int32_t ;
+#elif (SIZEOF_LONG == 4)
+typedef	long	int32_t ;
+#endif
+
+#define	SRC_MAX_RATIO			256
+#define	SRC_MAX_RATIO_STR		"256"
+
+#define	SRC_MIN_RATIO_DIFF		(1e-20)
+
+#define	MAX(a,b)	(((a) > (b)) ? (a) : (b))
+#define	MIN(a,b)	(((a) < (b)) ? (a) : (b))
+
+#define	ARRAY_LEN(x)			((int) (sizeof (x) / sizeof ((x) [0])))
+#define OFFSETOF(type,member)	((int) (&((type*) 0)->member))
+
+#define	MAKE_MAGIC(a,b,c,d,e,f)	((a) + ((b) << 4) + ((c) << 8) + ((d) << 12) + ((e) << 16) + ((f) << 20))
+
+#ifdef __GNUC__
+#	define WARN_UNUSED	__attribute__ ((warn_unused_result))
+#else
+#	define WARN_UNUSED
+#endif
+
+
+#include "samplerate.h"
+
+enum
+{	SRC_FALSE	= 0,
+	SRC_TRUE	= 1,
+
+	SRC_MODE_PROCESS	= 555,
+	SRC_MODE_CALLBACK	= 556
+} ;
+
+enum
+{	SRC_ERR_NO_ERROR = 0,
+
+	SRC_ERR_MALLOC_FAILED,
+	SRC_ERR_BAD_STATE,
+	SRC_ERR_BAD_DATA,
+	SRC_ERR_BAD_DATA_PTR,
+	SRC_ERR_NO_PRIVATE,
+	SRC_ERR_BAD_SRC_RATIO,
+	SRC_ERR_BAD_PROC_PTR,
+	SRC_ERR_SHIFT_BITS,
+	SRC_ERR_FILTER_LEN,
+	SRC_ERR_BAD_CONVERTER,
+	SRC_ERR_BAD_CHANNEL_COUNT,
+	SRC_ERR_SINC_BAD_BUFFER_LEN,
+	SRC_ERR_SIZE_INCOMPATIBILITY,
+	SRC_ERR_BAD_PRIV_PTR,
+	SRC_ERR_BAD_SINC_STATE,
+	SRC_ERR_DATA_OVERLAP,
+	SRC_ERR_BAD_CALLBACK,
+	SRC_ERR_BAD_MODE,
+	SRC_ERR_NULL_CALLBACK,
+	SRC_ERR_NO_VARIABLE_RATIO,
+	SRC_ERR_SINC_PREPARE_DATA_BAD_LEN,
+
+	/* This must be the last error number. */
+	SRC_ERR_MAX_ERROR
+} ;
+
+typedef struct SRC_PRIVATE_tag
+{	double	last_ratio, last_position ;
+
+	int		error ;
+	int		channels ;
+
+	/* SRC_MODE_PROCESS or SRC_MODE_CALLBACK */
+	int		mode ;
+
+	/* Pointer to data to converter specific data. */
+	void	*private_data ;
+
+	/* Varispeed process function. */
+	int		(*vari_process) (struct SRC_PRIVATE_tag *psrc, SRC_DATA *data) ;
+
+	/* Constant speed process function. */
+	int		(*const_process) (struct SRC_PRIVATE_tag *psrc, SRC_DATA *data) ;
+
+	/* State reset. */
+	void	(*reset) (struct SRC_PRIVATE_tag *psrc) ;
+
+	/* Data specific to SRC_MODE_CALLBACK. */
+	src_callback_t	callback_func ;
+	void			*user_callback_data ;
+	long			saved_frames ;
+	float			*saved_data ;
+} SRC_PRIVATE ;
+
+/* In src_sinc.c */
+const char* sinc_get_name (int src_enum) ;
+const char* sinc_get_description (int src_enum) ;
+
+int sinc_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
+
+/* In src_linear.c */
+const char* linear_get_name (int src_enum) ;
+const char* linear_get_description (int src_enum) ;
+
+int linear_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
+
+/* In src_zoh.c */
+const char* zoh_get_name (int src_enum) ;
+const char* zoh_get_description (int src_enum) ;
+
+int zoh_set_converter (SRC_PRIVATE *psrc, int src_enum) ;
+
+/*----------------------------------------------------------
+**	Common static inline functions.
+*/
+
+static inline double
+fmod_one (double x)
+{	double res ;
+
+	res = x - lrint (x) ;
+	if (res < 0.0)
+		return res + 1.0 ;
+
+	return res ;
+} /* fmod_one */
+
+#endif	/* COMMON_H_INCLUDED */
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/config.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/config.h	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/config.h	2009-04-21 16:15:51 UTC (rev 4746)
@@ -0,0 +1,10 @@
+#include "ADM_default.h"
+
+#define HAVE_LRINT 1
+#define HAVE_LRINTF 1
+
+#define CPU_CLIPS_NEGATIVE 0
+#define CPU_CLIPS_POSITIVE 0
+
+#define PACKAGE "libsamplerate"
+#define VERSION "0.1.7"

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/float_cast.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/float_cast.h	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/float_cast.h	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,255 +1,255 @@
-/*
-** Copyright (C) 2001-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU Lesser General Public License as published by
-** the Free Software Foundation; either version 2.1 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU Lesser General Public License for more details.
-**
-** You should have received a copy of the GNU Lesser General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/* Version 1.4 */
-
-#ifndef FLOAT_CAST_HEADER
-#define FLOAT_CAST_HEADER
-
-/*============================================================================
-**	On Intel Pentium processors (especially PIII and probably P4), converting
-**	from float to int is very slow. To meet the C specs, the code produced by
-**	most C compilers targeting Pentium needs to change the FPU rounding mode
-**	before the float to int conversion is performed.
-**
-**	Changing the FPU rounding mode causes the FPU pipeline to be flushed. It
-**	is this flushing of the pipeline which is so slow.
-**
-**	Fortunately the ISO C99 specifications define the functions lrint, lrintf,
-**	llrint and llrintf which fix this problem as a side effect.
-**
-**	On Unix-like systems, the configure process should have detected the
-**	presence of these functions. If they weren't found we have to replace them
-**	here with a standard C cast.
-*/
-
-/*
-**	The C99 prototypes for lrint and lrintf are as follows:
-**
-**		long int lrintf (float x) ;
-**		long int lrint  (double x) ;
-*/
-
-// MEANX #include "config.h"
-
-/*
-**	The presence of the required functions are detected during the configure
-**	process and the values HAVE_LRINT and HAVE_LRINTF are set accordingly in
-**	the config.h file.
-*/
-
-#define		HAVE_LRINT_REPLACEMENT	0
-
-#if (HAVE_LRINT && HAVE_LRINTF)
-
-	/*
-	**	These defines enable functionality introduced with the 1999 ISO C
-	**	standard. They must be defined before the inclusion of math.h to
-	**	engage them. If optimisation is enabled, these functions will be
-	**	inlined. With optimisation switched off, you have to link in the
-	**	maths library using -lm.
-	*/
-
-	#define	_ISOC9X_SOURCE	1
-	#define _ISOC99_SOURCE	1
-
-	#define	__USE_ISOC9X	1
-	#define	__USE_ISOC99	1
-
-	#include	<math.h>
-
-#elif (defined (__CYGWIN__))
-
-	#include	<math.h>
-
-	#undef		HAVE_LRINT_REPLACEMENT
-	#define		HAVE_LRINT_REPLACEMENT	1
-
-	#undef	lrint
-	#undef	lrintf
-
-	#define	lrint	double2int
-	#define	lrintf	float2int
-
-	/*
-	**	The native CYGWIN lrint and lrintf functions are buggy:
-	**		http://sourceware.org/ml/cygwin/2005-06/msg00153.html
-	**		http://sourceware.org/ml/cygwin/2005-09/msg00047.html
-	**	and slow.
-	**	These functions (pulled from the Public Domain MinGW math.h header)
-	**	replace the native versions.
-	*/
-
-	static inline long double2int (double in)
-	{	long retval ;
-
-		__asm__ __volatile__
-		(	"fistpl %0"
-			: "=m" (retval)
-			: "t" (in)
-			: "st"
-			) ;
-
-		return retval ;
-	} /* double2int */
-
-	static inline long float2int (float in)
-	{	long retval ;
-
-		__asm__ __volatile__
-		(	"fistpl %0"
-			: "=m" (retval)
-			: "t" (in)
-			: "st"
-			) ;
-
-		return retval ;
-	} /* float2int */
-
-#elif (defined (WIN32) || defined (_WIN32))
-
-	#undef		HAVE_LRINT_REPLACEMENT
-	#define		HAVE_LRINT_REPLACEMENT	1
-
-	#include	<math.h>
-
-	/*
-	**	Win32 doesn't seem to have these functions.
-	**	Therefore implement inline versions of these functions here.
-	*/
-
-	__inline long int
-	lrint (double flt)
-	{	int intgr ;
-
-		_asm
-		{	fld flt
-			fistp intgr
-			} ;
-
-		return intgr ;
-	}
-
-	__inline long int
-	lrintf (float flt)
-	{	int intgr ;
-
-		_asm
-		{	fld flt
-			fistp intgr
-			} ;
-
-		return intgr ;
-	}
-
-#elif (defined (__MWERKS__) && defined (macintosh))
-
-	/* This MacOS 9 solution was provided by Stephane Letz */
-
-	#undef		HAVE_LRINT_REPLACEMENT
-	#define		HAVE_LRINT_REPLACEMENT	1
-	#include	<math.h>
-
-	#undef	lrint
-	#undef	lrintf
-
-	#define	lrint	double2int
-	#define	lrintf	float2int
-
-	inline int
-	float2int (register float in)
-	{	long res [2] ;
-
-		asm
-		{	fctiw	in, in
-			stfd	 in, res
-		}
-		return res [1] ;
-	} /* float2int */
-
-	inline int
-	double2int (register double in)
-	{	long res [2] ;
-
-		asm
-		{	fctiw	in, in
-			stfd	 in, res
-		}
-		return res [1] ;
-	} /* double2int */
-
-#elif (defined (__MACH__) && defined (__APPLE__))
-
-	/* For Apple MacOSX. */
-
-	#undef		HAVE_LRINT_REPLACEMENT
-	#define		HAVE_LRINT_REPLACEMENT	1
-	#include	<math.h>
-
-	#undef lrint
-	#undef lrintf
-
-	#define lrint	double2int
-	#define lrintf	float2int
-
-	inline static long
-	float2int (register float in)
-	{	int res [2] ;
-
-		__asm__ __volatile__
-		(	"fctiw	%1, %1\n\t"
-			"stfd	%1, %0"
-			: "=m" (res)	/* Output */
-			: "f" (in)		/* Input */
-			: "memory"
-			) ;
-
-		return res [1] ;
-	} /* lrintf */
-
-	inline static long
-	double2int (register double in)
-	{	int res [2] ;
-
-		__asm__ __volatile__
-		(	"fctiw	%1, %1\n\t"
-			"stfd	%1, %0"
-			: "=m" (res)	/* Output */
-			: "f" (in)		/* Input */
-			: "memory"
-			) ;
-
-		return res [1] ;
-	} /* lrint */
-
-#else
-	#ifndef __sgi
-	#warning "Don't have the functions lrint() and lrintf()."
-	#warning "Replacing these functions with a standard C cast."
-	#endif
-
-	#include	<math.h>
-
-	#define	lrint(dbl)		((long) (dbl))
-	#define	lrintf(flt)		((long) (flt))
-
-#endif
-
-
-#endif /* FLOAT_CAST_HEADER */
-
+/*
+** Copyright (C) 2001-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU Lesser General Public License as published by
+** the Free Software Foundation; either version 2.1 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU Lesser General Public License for more details.
+**
+** You should have received a copy of the GNU Lesser General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/* Version 1.4 */
+
+#ifndef FLOAT_CAST_HEADER
+#define FLOAT_CAST_HEADER
+
+/*============================================================================
+**	On Intel Pentium processors (especially PIII and probably P4), converting
+**	from float to int is very slow. To meet the C specs, the code produced by
+**	most C compilers targeting Pentium needs to change the FPU rounding mode
+**	before the float to int conversion is performed.
+**
+**	Changing the FPU rounding mode causes the FPU pipeline to be flushed. It
+**	is this flushing of the pipeline which is so slow.
+**
+**	Fortunately the ISO C99 specifications define the functions lrint, lrintf,
+**	llrint and llrintf which fix this problem as a side effect.
+**
+**	On Unix-like systems, the configure process should have detected the
+**	presence of these functions. If they weren't found we have to replace them
+**	here with a standard C cast.
+*/
+
+/*
+**	The C99 prototypes for lrint and lrintf are as follows:
+**
+**		long int lrintf (float x) ;
+**		long int lrint  (double x) ;
+*/
+
+#include "config.h"
+
+/*
+**	The presence of the required functions are detected during the configure
+**	process and the values HAVE_LRINT and HAVE_LRINTF are set accordingly in
+**	the config.h file.
+*/
+
+#define		HAVE_LRINT_REPLACEMENT	0
+
+#if (HAVE_LRINT && HAVE_LRINTF)
+
+	/*
+	**	These defines enable functionality introduced with the 1999 ISO C
+	**	standard. They must be defined before the inclusion of math.h to
+	**	engage them. If optimisation is enabled, these functions will be
+	**	inlined. With optimisation switched off, you have to link in the
+	**	maths library using -lm.
+	*/
+
+	#define	_ISOC9X_SOURCE	1
+	#define _ISOC99_SOURCE	1
+
+	#define	__USE_ISOC9X	1
+	#define	__USE_ISOC99	1
+
+	#include	<math.h>
+
+#elif (defined (__CYGWIN__))
+
+	#include	<math.h>
+
+	#undef		HAVE_LRINT_REPLACEMENT
+	#define		HAVE_LRINT_REPLACEMENT	1
+
+	#undef	lrint
+	#undef	lrintf
+
+	#define	lrint	double2int
+	#define	lrintf	float2int
+
+	/*
+	**	The native CYGWIN lrint and lrintf functions are buggy:
+	**		http://sourceware.org/ml/cygwin/2005-06/msg00153.html
+	**		http://sourceware.org/ml/cygwin/2005-09/msg00047.html
+	**	and slow.
+	**	These functions (pulled from the Public Domain MinGW math.h header)
+	**	replace the native versions.
+	*/
+
+	static inline long double2int (double in)
+	{	long retval ;
+
+		__asm__ __volatile__
+		(	"fistpl %0"
+			: "=m" (retval)
+			: "t" (in)
+			: "st"
+			) ;
+
+		return retval ;
+	} /* double2int */
+
+	static inline long float2int (float in)
+	{	long retval ;
+
+		__asm__ __volatile__
+		(	"fistpl %0"
+			: "=m" (retval)
+			: "t" (in)
+			: "st"
+			) ;
+
+		return retval ;
+	} /* float2int */
+
+#elif (defined (WIN32) || defined (_WIN32))
+
+	#undef		HAVE_LRINT_REPLACEMENT
+	#define		HAVE_LRINT_REPLACEMENT	1
+
+	#include	<math.h>
+
+	/*
+	**	Win32 doesn't seem to have these functions.
+	**	Therefore implement inline versions of these functions here.
+	*/
+
+	__inline long int
+	lrint (double flt)
+	{	int intgr ;
+
+		_asm
+		{	fld flt
+			fistp intgr
+			} ;
+
+		return intgr ;
+	}
+
+	__inline long int
+	lrintf (float flt)
+	{	int intgr ;
+
+		_asm
+		{	fld flt
+			fistp intgr
+			} ;
+
+		return intgr ;
+	}
+
+#elif (defined (__MWERKS__) && defined (macintosh))
+
+	/* This MacOS 9 solution was provided by Stephane Letz */
+
+	#undef		HAVE_LRINT_REPLACEMENT
+	#define		HAVE_LRINT_REPLACEMENT	1
+	#include	<math.h>
+
+	#undef	lrint
+	#undef	lrintf
+
+	#define	lrint	double2int
+	#define	lrintf	float2int
+
+	inline int
+	float2int (register float in)
+	{	long res [2] ;
+
+		asm
+		{	fctiw	in, in
+			stfd	 in, res
+		}
+		return res [1] ;
+	} /* float2int */
+
+	inline int
+	double2int (register double in)
+	{	long res [2] ;
+
+		asm
+		{	fctiw	in, in
+			stfd	 in, res
+		}
+		return res [1] ;
+	} /* double2int */
+
+#elif (defined (__MACH__) && defined (__APPLE__))
+
+	/* For Apple MacOSX. */
+
+	#undef		HAVE_LRINT_REPLACEMENT
+	#define		HAVE_LRINT_REPLACEMENT	1
+	#include	<math.h>
+
+	#undef lrint
+	#undef lrintf
+
+	#define lrint	double2int
+	#define lrintf	float2int
+
+	inline static long
+	float2int (register float in)
+	{	int res [2] ;
+
+		__asm__ __volatile__
+		(	"fctiw	%1, %1\n\t"
+			"stfd	%1, %0"
+			: "=m" (res)	/* Output */
+			: "f" (in)		/* Input */
+			: "memory"
+			) ;
+
+		return res [1] ;
+	} /* lrintf */
+
+	inline static long
+	double2int (register double in)
+	{	int res [2] ;
+
+		__asm__ __volatile__
+		(	"fctiw	%1, %1\n\t"
+			"stfd	%1, %0"
+			: "=m" (res)	/* Output */
+			: "f" (in)		/* Input */
+			: "memory"
+			) ;
+
+		return res [1] ;
+	} /* lrint */
+
+#else
+	#ifndef __sgi
+	#warning "Don't have the functions lrint() and lrintf()."
+	#warning "Replacing these functions with a standard C cast."
+	#endif
+
+	#include	<math.h>
+
+	#define	lrint(dbl)		((long) (dbl))
+	#define	lrintf(flt)		((long) (flt))
+
+#endif
+
+
+#endif /* FLOAT_CAST_HEADER */
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/samplerate.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/samplerate.c	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/samplerate.c	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,541 +1,545 @@
-/*
-** Copyright (C) 2002-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/*
-** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
-** use license for this code is available, please see:
-**		http://www.mega-nerd.com/SRC/procedure.html
-*/
-#if 0 // MEANX
-#include	<stdio.h>
-#include	<stdlib.h>
-#include	<string.h>
-
-#include	"config.h"
-#else
-#include "ADM_default.h"
-#endif
-#include	"samplerate.h"
-#include	"float_cast.h"
-#include	"common.h"
-
-static int psrc_set_converter (SRC_PRIVATE	*psrc, int converter_type) ;
-
-
-static inline int
-is_bad_src_ratio (double ratio)
-{	return (ratio < (1.0 / SRC_MAX_RATIO) || ratio > (1.0 * SRC_MAX_RATIO)) ;
-} /* is_bad_src_ratio */
-
-SRC_STATE *
-src_new (int converter_type, int channels, int *error)
-{	SRC_PRIVATE	*psrc ;
-
-	if (error)
-		*error = SRC_ERR_NO_ERROR ;
-
-	if (channels < 1)
-	{	if (error)
-			*error = SRC_ERR_BAD_CHANNEL_COUNT ;
-		return NULL ;
-		} ;
-
-	if ((psrc = calloc (1, sizeof (*psrc))) == NULL)
-	{	if (error)
-			*error = SRC_ERR_MALLOC_FAILED ;
-		return NULL ;
-		} ;
-
-	psrc->channels = channels ;
-	psrc->mode = SRC_MODE_PROCESS ;
-
-	if (psrc_set_converter (psrc, converter_type) != SRC_ERR_NO_ERROR)
-	{	if (error)
-			*error = SRC_ERR_BAD_CONVERTER ;
-		free (psrc) ;
-		psrc = NULL ;
-		} ;
-
-	src_reset ((SRC_STATE*) psrc) ;
-
-	return (SRC_STATE*) psrc ;
-} /* src_new */
-
-SRC_STATE*
-src_callback_new (src_callback_t func, int converter_type, int channels, int *error, void* cb_data)
-{	SRC_STATE	*src_state ;
-
-	if (func == NULL)
-	{	if (error)
-			*error = SRC_ERR_BAD_CALLBACK ;
-		return NULL ;
-		} ;
-
-	if (error != NULL)
-		*error = 0 ;
-
-	src_state = src_new (converter_type, channels, error) ;
-
-	src_reset (src_state) ;
-
-	((SRC_PRIVATE*) src_state)->mode = SRC_MODE_CALLBACK ;
-	((SRC_PRIVATE*) src_state)->callback_func = func ;
-	((SRC_PRIVATE*) src_state)->user_callback_data = cb_data ;
-
-	return src_state ;
-} /* src_callback_new */
-
-SRC_STATE *
-src_delete (SRC_STATE *state)
-{	SRC_PRIVATE *psrc ;
-
-	psrc = (SRC_PRIVATE*) state ;
-	if (psrc)
-	{	if (psrc->private_data)
-			free (psrc->private_data) ;
-		memset (psrc, 0, sizeof (SRC_PRIVATE)) ;
-		free (psrc) ;
-		} ;
-
-	return NULL ;
-} /* src_state */
-
-int
-src_process (SRC_STATE *state, SRC_DATA *data)
-{	SRC_PRIVATE *psrc ;
-	int error ;
-
-	psrc = (SRC_PRIVATE*) state ;
-
-	if (psrc == NULL)
-		return SRC_ERR_BAD_STATE ;
-	if (psrc->vari_process == NULL || psrc->const_process == NULL)
-		return SRC_ERR_BAD_PROC_PTR ;
-
-	if (psrc->mode != SRC_MODE_PROCESS)
-		return SRC_ERR_BAD_MODE ;
-
-	/* Check for valid SRC_DATA first. */
-	if (data == NULL)
-		return SRC_ERR_BAD_DATA ;
-
-	/* Check src_ratio is in range. */
-	if (is_bad_src_ratio (data->src_ratio))
-		return SRC_ERR_BAD_SRC_RATIO ;
-
-	/* And that data_in and data_out are valid. */
-	if (data->data_in == NULL || data->data_out == NULL)
-		return SRC_ERR_BAD_DATA_PTR ;
-
-	if (data->data_in == NULL)
-		data->input_frames = 0 ;
-
-	if (data->input_frames < 0)
-		data->input_frames = 0 ;
-	if (data->output_frames < 0)
-		data->output_frames = 0 ;
-
-	if (data->data_in < data->data_out)
-	{	if (data->data_in + data->input_frames * psrc->channels > data->data_out)
-		{	/*-printf ("\n\ndata_in: %p    data_out: %p\n",
-				(void*) (data->data_in + data->input_frames * psrc->channels), (void*) data->data_out) ;-*/
-			return SRC_ERR_DATA_OVERLAP ;
-			} ;
-		}
-	else if (data->data_out + data->output_frames * psrc->channels > data->data_in)
-	{	/*-printf ("\n\ndata_in : %p   ouput frames: %ld    data_out: %p\n", (void*) data->data_in, data->output_frames, (void*) data->data_out) ;
-
-		printf ("data_out: %p (%p)    data_in: %p\n", (void*) data->data_out,
-			(void*) (data->data_out + data->input_frames * psrc->channels), (void*) data->data_in) ;-*/
-		return SRC_ERR_DATA_OVERLAP ;
-		} ;
-
-	/* Set the input and output counts to zero. */
-	data->input_frames_used = 0 ;
-	data->output_frames_gen = 0 ;
-
-	/* Special case for when last_ratio has not been set. */
-	if (psrc->last_ratio < (1.0 / SRC_MAX_RATIO))
-		psrc->last_ratio = data->src_ratio ;
-
-	/* Now process. */
-	if (fabs (psrc->last_ratio - data->src_ratio) < 1e-15)
-		error = psrc->const_process (psrc, data) ;
-	else
-		error = psrc->vari_process (psrc, data) ;
-
-	return error ;
-} /* src_process */
-
-long
-src_callback_read (SRC_STATE *state, double src_ratio, long frames, float *data)
-{	SRC_PRIVATE	*psrc ;
-	SRC_DATA	src_data ;
-
-	long	output_frames_gen ;
-	int		error = 0 ;
-
-	if (state == NULL)
-		return 0 ;
-
-	if (frames <= 0)
-		return 0 ;
-
-	psrc = (SRC_PRIVATE*) state ;
-
-	if (psrc->mode != SRC_MODE_CALLBACK)
-	{	psrc->error = SRC_ERR_BAD_MODE ;
-		return 0 ;
-		} ;
-
-	if (psrc->callback_func == NULL)
-	{	psrc->error = SRC_ERR_NULL_CALLBACK ;
-		return 0 ;
-		} ;
-
-	memset (&src_data, 0, sizeof (src_data)) ;
-
-	/* Check src_ratio is in range. */
-	if (is_bad_src_ratio (src_ratio))
-	{	psrc->error = SRC_ERR_BAD_SRC_RATIO ;
-		return 0 ;
-		} ;
-
-	/* Switch modes temporarily. */
-	src_data.src_ratio = src_ratio ;
-	src_data.data_out = data ;
-	src_data.output_frames = frames ;
-
-	src_data.data_in = psrc->saved_data ;
-	src_data.input_frames = psrc->saved_frames ;
-
-	output_frames_gen = 0 ;
-	while (output_frames_gen < frames)
-	{
-		if (src_data.input_frames == 0)
-		{	float *ptr ;
-
-			src_data.input_frames = psrc->callback_func (psrc->user_callback_data, &ptr) ;
-			src_data.data_in = ptr ;
-
-			if (src_data.input_frames == 0)
-				src_data.end_of_input = 1 ;
-			} ;
-
-		/*
-		** Now call process function. However, we need to set the mode
-		** to SRC_MODE_PROCESS first and when we return set it back to
-		** SRC_MODE_CALLBACK.
-		*/
-		psrc->mode = SRC_MODE_PROCESS ;
-		error = src_process (state, &src_data) ;
-		psrc->mode = SRC_MODE_CALLBACK ;
-
-		if (error != 0)
-			break ;
-
-		src_data.data_in += src_data.input_frames_used * psrc->channels ;
-		src_data.input_frames -= src_data.input_frames_used ;
-
-		src_data.data_out += src_data.output_frames_gen * psrc->channels ;
-		src_data.output_frames -= src_data.output_frames_gen ;
-
-		output_frames_gen += src_data.output_frames_gen ;
-
-		if (src_data.end_of_input == SRC_TRUE && src_data.output_frames_gen == 0)
-			break ;
-		} ;
-
-	psrc->saved_data = src_data.data_in ;
-	psrc->saved_frames = src_data.input_frames ;
-
-	if (error != 0)
-	{	psrc->error = error ;
-	 	return 0 ;
-		} ;
-
-	return output_frames_gen ;
-} /* src_callback_read */
-
-/*==========================================================================
-*/
-
-int
-src_set_ratio (SRC_STATE *state, double new_ratio)
-{	SRC_PRIVATE *psrc ;
-
-	psrc = (SRC_PRIVATE*) state ;
-
-	if (psrc == NULL)
-		return SRC_ERR_BAD_STATE ;
-	if (psrc->vari_process == NULL || psrc->const_process == NULL)
-		return SRC_ERR_BAD_PROC_PTR ;
-
-	if (is_bad_src_ratio (new_ratio))
-		return SRC_ERR_BAD_SRC_RATIO ;
-
-	psrc->last_ratio = new_ratio ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* src_set_ratio */
-
-int
-src_reset (SRC_STATE *state)
-{	SRC_PRIVATE *psrc ;
-
-	if ((psrc = (SRC_PRIVATE*) state) == NULL)
-		return SRC_ERR_BAD_STATE ;
-
-	if (psrc->reset != NULL)
-		psrc->reset (psrc) ;
-
-	psrc->last_position = 0.0 ;
-	psrc->last_ratio = 0.0 ;
-
-	psrc->saved_data = NULL ;
-	psrc->saved_frames = 0 ;
-
-	psrc->error = SRC_ERR_NO_ERROR ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* src_reset */
-
-/*==============================================================================
-**	Control functions.
-*/
-
-const char *
-src_get_name (int converter_type)
-{	const char *desc ;
-
-	if ((desc = sinc_get_name (converter_type)) != NULL)
-		return desc ;
-
-	if ((desc = zoh_get_name (converter_type)) != NULL)
-		return desc ;
-
-	if ((desc = linear_get_name (converter_type)) != NULL)
-		return desc ;
-
-	return NULL ;
-} /* src_get_name */
-
-const char *
-src_get_description (int converter_type)
-{	const char *desc ;
-
-	if ((desc = sinc_get_description (converter_type)) != NULL)
-		return desc ;
-
-	if ((desc = zoh_get_description (converter_type)) != NULL)
-		return desc ;
-
-	if ((desc = linear_get_description (converter_type)) != NULL)
-		return desc ;
-
-	return NULL ;
-} /* src_get_description */
-
-const char *
-src_get_version (void)
-{	return PACKAGE "-" VERSION " (c) 2002-2008 Erik de Castro Lopo" ;
-} /* src_get_version */
-
-int
-src_is_valid_ratio (double ratio)
-{
-	if (is_bad_src_ratio (ratio))
-		return SRC_FALSE ;
-
-	return SRC_TRUE ;
-} /* src_is_valid_ratio */
-
-/*==============================================================================
-**	Error reporting functions.
-*/
-
-int
-src_error (SRC_STATE *state)
-{	if (state)
-		return ((SRC_PRIVATE*) state)->error ;
-	return SRC_ERR_NO_ERROR ;
-} /* src_error */
-
-const char*
-src_strerror (int error)
-{
-	switch (error)
-	{	case SRC_ERR_NO_ERROR :
-				return "No error." ;
-		case SRC_ERR_MALLOC_FAILED :
-				return "Malloc failed." ;
-		case SRC_ERR_BAD_STATE :
-				return "SRC_STATE pointer is NULL." ;
-		case SRC_ERR_BAD_DATA :
-				return "SRC_DATA pointer is NULL." ;
-		case SRC_ERR_BAD_DATA_PTR :
-				return "SRC_DATA->data_out is NULL." ;
-		case SRC_ERR_NO_PRIVATE :
-				return "Internal error. No private data." ;
-		case SRC_ERR_BAD_SRC_RATIO :
-				return "SRC ratio outside [1/12, 12] range." ;
-		case SRC_ERR_BAD_SINC_STATE :
-				return "src_process() called without reset after end_of_input." ;
-		case SRC_ERR_BAD_PROC_PTR :
-				return "Internal error. No process pointer." ;
-		case SRC_ERR_SHIFT_BITS :
-				return "Internal error. SHIFT_BITS too large." ;
-		case SRC_ERR_FILTER_LEN :
-				return "Internal error. Filter length too large." ;
-		case SRC_ERR_BAD_CONVERTER :
-				return "Bad converter number." ;
-		case SRC_ERR_BAD_CHANNEL_COUNT :
-				return "Channel count must be >= 1." ;
-		case SRC_ERR_SINC_BAD_BUFFER_LEN :
-				return "Internal error. Bad buffer length. Please report this." ;
-		case SRC_ERR_SIZE_INCOMPATIBILITY :
-				return "Internal error. Input data / internal buffer size difference. Please report this." ;
-		case SRC_ERR_BAD_PRIV_PTR :
-				return "Internal error. Private pointer is NULL. Please report this." ;
-		case SRC_ERR_DATA_OVERLAP :
-				return "Input and output data arrays overlap." ;
-		case SRC_ERR_BAD_CALLBACK :
-				return "Supplied callback function pointer is NULL." ;
-		case SRC_ERR_BAD_MODE :
-				return "Calling mode differs from initialisation mode (ie process v callback)." ;
-		case SRC_ERR_NULL_CALLBACK :
-				return "Callback function pointer is NULL in src_callback_read ()." ;
-		case SRC_ERR_NO_VARIABLE_RATIO :
-				return "This converter only allows constant conversion ratios." ;
-
-		case SRC_ERR_MAX_ERROR :
-				return "Placeholder. No error defined for this error number." ;
-
-		default : 						break ;
-		}
-
-	return NULL ;
-} /* src_strerror */
-
-/*==============================================================================
-**	Simple interface for performing a single conversion from input buffer to
-**	output buffer at a fixed conversion ratio.
-*/
-
-int
-src_simple (SRC_DATA *src_data, int converter, int channels)
-{	SRC_STATE	*src_state ;
-	int 		error ;
-
-	if ((src_state = src_new (converter, channels, &error)) == NULL)
-		return error ;
-
-	src_data->end_of_input = 1 ; /* Only one buffer worth of input. */
-
-	error = src_process (src_state, src_data) ;
-
-	src_state = src_delete (src_state) ;
-
-	return error ;
-} /* src_simple */
-
-void
-src_short_to_float_array (const short *in, float *out, int len)
-{
-	while (len)
-	{	len -- ;
-		out [len] = (float) (in [len] / (1.0 * 0x8000)) ;
-		} ;
-
-	return ;
-} /* src_short_to_float_array */
-
-void
-src_float_to_short_array (const float *in, short *out, int len)
-{	double scaled_value ;
-
-	while (len)
-	{	len -- ;
-
-		scaled_value = in [len] * (8.0 * 0x10000000) ;
-		if (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))
-		{	out [len] = 32767 ;
-			continue ;
-			} ;
-		if (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))
-		{	out [len] = -32768 ;
-			continue ;
-			} ;
-
-		out [len] = (short) (lrint (scaled_value) >> 16) ;
-		} ;
-
-} /* src_float_to_short_array */
-
-void
-src_int_to_float_array (const int *in, float *out, int len)
-{
-	while (len)
-	{	len -- ;
-		out [len] = (float) (in [len] / (8.0 * 0x10000000)) ;
-		} ;
-
-	return ;
-} /* src_int_to_float_array */
-
-void
-src_float_to_int_array (const float *in, int *out, int len)
-{	double scaled_value ;
-
-	while (len)
-	{	len -- ;
-
-		scaled_value = in [len] * (8.0 * 0x10000000) ;
-		if (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))
-		{	out [len] = 0x7fffffff ;
-			continue ;
-			} ;
-		if (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))
-		{	out [len] = -1 - 0x7fffffff ;
-			continue ;
-			} ;
-
-		out [len] = lrint (scaled_value) ;
-		} ;
-
-} /* src_float_to_int_array */
-
-/*==============================================================================
-**	Private functions.
-*/
-
-static int
-psrc_set_converter (SRC_PRIVATE	*psrc, int converter_type)
-{
-	if (sinc_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
-		return SRC_ERR_NO_ERROR ;
-
-	if (zoh_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
-		return SRC_ERR_NO_ERROR ;
-
-	if (linear_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
-		return SRC_ERR_NO_ERROR ;
-
-	return SRC_ERR_BAD_CONVERTER ;
-} /* psrc_set_converter */
-
+/*
+** Copyright (C) 2002-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/*
+** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
+** use license for this code is available, please see:
+**		http://www.mega-nerd.com/SRC/procedure.html
+*/
+
+#include	<stdio.h>
+#include	<stdlib.h>
+#include	<string.h>
+
+#include	"config.h"
+
+#include	"samplerate.h"
+#include	"float_cast.h"
+#include	"common.h"
+
+static int psrc_set_converter (SRC_PRIVATE	*psrc, int converter_type) ;
+
+
+static inline int
+is_bad_src_ratio (double ratio)
+{	return (ratio < (1.0 / SRC_MAX_RATIO) || ratio > (1.0 * SRC_MAX_RATIO)) ;
+} /* is_bad_src_ratio */
+
+SRC_STATE *
+src_new (int converter_type, int channels, int *error)
+{	SRC_PRIVATE	*psrc ;
+
+	if (error)
+		*error = SRC_ERR_NO_ERROR ;
+
+	if (channels < 1)
+	{	if (error)
+			*error = SRC_ERR_BAD_CHANNEL_COUNT ;
+		return NULL ;
+		} ;
+
+	if ((psrc = calloc (1, sizeof (*psrc))) == NULL)
+	{	if (error)
+			*error = SRC_ERR_MALLOC_FAILED ;
+		return NULL ;
+		} ;
+
+	psrc->channels = channels ;
+	psrc->mode = SRC_MODE_PROCESS ;
+
+	if (psrc_set_converter (psrc, converter_type) != SRC_ERR_NO_ERROR)
+	{	if (error)
+			*error = SRC_ERR_BAD_CONVERTER ;
+		free (psrc) ;
+		psrc = NULL ;
+		} ;
+
+	src_reset ((SRC_STATE*) psrc) ;
+
+	return (SRC_STATE*) psrc ;
+} /* src_new */
+
+SRC_STATE*
+src_callback_new (src_callback_t func, int converter_type, int channels, int *error, void* cb_data)
+{	SRC_STATE	*src_state ;
+
+	if (func == NULL)
+	{	if (error)
+			*error = SRC_ERR_BAD_CALLBACK ;
+		return NULL ;
+		} ;
+
+	if (error != NULL)
+		*error = 0 ;
+
+	if ((src_state = src_new (converter_type, channels, error)) == NULL)
+		return NULL ;
+
+	src_reset (src_state) ;
+
+	((SRC_PRIVATE*) src_state)->mode = SRC_MODE_CALLBACK ;
+	((SRC_PRIVATE*) src_state)->callback_func = func ;
+	((SRC_PRIVATE*) src_state)->user_callback_data = cb_data ;
+
+	return src_state ;
+} /* src_callback_new */
+
+SRC_STATE *
+src_delete (SRC_STATE *state)
+{	SRC_PRIVATE *psrc ;
+
+	psrc = (SRC_PRIVATE*) state ;
+	if (psrc)
+	{	if (psrc->private_data)
+			free (psrc->private_data) ;
+		memset (psrc, 0, sizeof (SRC_PRIVATE)) ;
+		free (psrc) ;
+		} ;
+
+	return NULL ;
+} /* src_state */
+
+int
+src_process (SRC_STATE *state, SRC_DATA *data)
+{	SRC_PRIVATE *psrc ;
+	int error ;
+
+	psrc = (SRC_PRIVATE*) state ;
+
+	if (psrc == NULL)
+		return SRC_ERR_BAD_STATE ;
+	if (psrc->vari_process == NULL || psrc->const_process == NULL)
+		return SRC_ERR_BAD_PROC_PTR ;
+
+	if (psrc->mode != SRC_MODE_PROCESS)
+		return SRC_ERR_BAD_MODE ;
+
+	/* Check for valid SRC_DATA first. */
+	if (data == NULL)
+		return SRC_ERR_BAD_DATA ;
+
+	/* And that data_in and data_out are valid. */
+	if (data->data_in == NULL || data->data_out == NULL)
+		return SRC_ERR_BAD_DATA_PTR ;
+
+	/* Check src_ratio is in range. */
+	if (is_bad_src_ratio (data->src_ratio))
+		return SRC_ERR_BAD_SRC_RATIO ;
+
+	if (data->input_frames < 0)
+		data->input_frames = 0 ;
+	if (data->output_frames < 0)
+		data->output_frames = 0 ;
+
+	if (data->data_in < data->data_out)
+	{	if (data->data_in + data->input_frames * psrc->channels > data->data_out)
+		{	/*-printf ("\n\ndata_in: %p    data_out: %p\n",
+				(void*) (data->data_in + data->input_frames * psrc->channels), (void*) data->data_out) ;-*/
+			return SRC_ERR_DATA_OVERLAP ;
+			} ;
+		}
+	else if (data->data_out + data->output_frames * psrc->channels > data->data_in)
+	{	/*-printf ("\n\ndata_in : %p   ouput frames: %ld    data_out: %p\n", (void*) data->data_in, data->output_frames, (void*) data->data_out) ;
+
+		printf ("data_out: %p (%p)    data_in: %p\n", (void*) data->data_out,
+			(void*) (data->data_out + data->input_frames * psrc->channels), (void*) data->data_in) ;-*/
+		return SRC_ERR_DATA_OVERLAP ;
+		} ;
+
+	/* Set the input and output counts to zero. */
+	data->input_frames_used = 0 ;
+	data->output_frames_gen = 0 ;
+
+	/* Special case for when last_ratio has not been set. */
+	if (psrc->last_ratio < (1.0 / SRC_MAX_RATIO))
+		psrc->last_ratio = data->src_ratio ;
+
+	/* Now process. */
+	if (fabs (psrc->last_ratio - data->src_ratio) < 1e-15)
+		error = psrc->const_process (psrc, data) ;
+	else
+		error = psrc->vari_process (psrc, data) ;
+
+	return error ;
+} /* src_process */
+
+long
+src_callback_read (SRC_STATE *state, double src_ratio, long frames, float *data)
+{	SRC_PRIVATE	*psrc ;
+	SRC_DATA	src_data ;
+
+	long	output_frames_gen ;
+	int		error = 0 ;
+
+	if (state == NULL)
+		return 0 ;
+
+	if (frames <= 0)
+		return 0 ;
+
+	psrc = (SRC_PRIVATE*) state ;
+
+	if (psrc->mode != SRC_MODE_CALLBACK)
+	{	psrc->error = SRC_ERR_BAD_MODE ;
+		return 0 ;
+		} ;
+
+	if (psrc->callback_func == NULL)
+	{	psrc->error = SRC_ERR_NULL_CALLBACK ;
+		return 0 ;
+		} ;
+
+	memset (&src_data, 0, sizeof (src_data)) ;
+
+	/* Check src_ratio is in range. */
+	if (is_bad_src_ratio (src_ratio))
+	{	psrc->error = SRC_ERR_BAD_SRC_RATIO ;
+		return 0 ;
+		} ;
+
+	/* Switch modes temporarily. */
+	src_data.src_ratio = src_ratio ;
+	src_data.data_out = data ;
+	src_data.output_frames = frames ;
+
+	src_data.data_in = psrc->saved_data ;
+	src_data.input_frames = psrc->saved_frames ;
+
+	output_frames_gen = 0 ;
+	while (output_frames_gen < frames)
+	{	/*	Use a dummy array for the case where the callback function
+		**	returns without setting the ptr.
+		*/
+		float dummy [1] ;
+
+		if (src_data.input_frames == 0)
+		{	float *ptr = dummy ;
+
+			src_data.input_frames = psrc->callback_func (psrc->user_callback_data, &ptr) ;
+			src_data.data_in = ptr ;
+
+			if (src_data.input_frames == 0)
+				src_data.end_of_input = 1 ;
+			} ;
+
+		/*
+		** Now call process function. However, we need to set the mode
+		** to SRC_MODE_PROCESS first and when we return set it back to
+		** SRC_MODE_CALLBACK.
+		*/
+		psrc->mode = SRC_MODE_PROCESS ;
+		error = src_process (state, &src_data) ;
+		psrc->mode = SRC_MODE_CALLBACK ;
+
+		if (error != 0)
+			break ;
+
+		src_data.data_in += src_data.input_frames_used * psrc->channels ;
+		src_data.input_frames -= src_data.input_frames_used ;
+
+		src_data.data_out += src_data.output_frames_gen * psrc->channels ;
+		src_data.output_frames -= src_data.output_frames_gen ;
+
+		output_frames_gen += src_data.output_frames_gen ;
+
+		if (src_data.end_of_input == SRC_TRUE && src_data.output_frames_gen == 0)
+			break ;
+		} ;
+
+	psrc->saved_data = src_data.data_in ;
+	psrc->saved_frames = src_data.input_frames ;
+
+	if (error != 0)
+	{	psrc->error = error ;
+	 	return 0 ;
+		} ;
+
+	return output_frames_gen ;
+} /* src_callback_read */
+
+/*==========================================================================
+*/
+
+int
+src_set_ratio (SRC_STATE *state, double new_ratio)
+{	SRC_PRIVATE *psrc ;
+
+	psrc = (SRC_PRIVATE*) state ;
+
+	if (psrc == NULL)
+		return SRC_ERR_BAD_STATE ;
+	if (psrc->vari_process == NULL || psrc->const_process == NULL)
+		return SRC_ERR_BAD_PROC_PTR ;
+
+	if (is_bad_src_ratio (new_ratio))
+		return SRC_ERR_BAD_SRC_RATIO ;
+
+	psrc->last_ratio = new_ratio ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* src_set_ratio */
+
+int
+src_reset (SRC_STATE *state)
+{	SRC_PRIVATE *psrc ;
+
+	if ((psrc = (SRC_PRIVATE*) state) == NULL)
+		return SRC_ERR_BAD_STATE ;
+
+	if (psrc->reset != NULL)
+		psrc->reset (psrc) ;
+
+	psrc->last_position = 0.0 ;
+	psrc->last_ratio = 0.0 ;
+
+	psrc->saved_data = NULL ;
+	psrc->saved_frames = 0 ;
+
+	psrc->error = SRC_ERR_NO_ERROR ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* src_reset */
+
+/*==============================================================================
+**	Control functions.
+*/
+
+const char *
+src_get_name (int converter_type)
+{	const char *desc ;
+
+	if ((desc = sinc_get_name (converter_type)) != NULL)
+		return desc ;
+
+	if ((desc = zoh_get_name (converter_type)) != NULL)
+		return desc ;
+
+	if ((desc = linear_get_name (converter_type)) != NULL)
+		return desc ;
+
+	return NULL ;
+} /* src_get_name */
+
+const char *
+src_get_description (int converter_type)
+{	const char *desc ;
+
+	if ((desc = sinc_get_description (converter_type)) != NULL)
+		return desc ;
+
+	if ((desc = zoh_get_description (converter_type)) != NULL)
+		return desc ;
+
+	if ((desc = linear_get_description (converter_type)) != NULL)
+		return desc ;
+
+	return NULL ;
+} /* src_get_description */
+
+const char *
+src_get_version (void)
+{	return PACKAGE "-" VERSION " (c) 2002-2008 Erik de Castro Lopo" ;
+} /* src_get_version */
+
+int
+src_is_valid_ratio (double ratio)
+{
+	if (is_bad_src_ratio (ratio))
+		return SRC_FALSE ;
+
+	return SRC_TRUE ;
+} /* src_is_valid_ratio */
+
+/*==============================================================================
+**	Error reporting functions.
+*/
+
+int
+src_error (SRC_STATE *state)
+{	if (state)
+		return ((SRC_PRIVATE*) state)->error ;
+	return SRC_ERR_NO_ERROR ;
+} /* src_error */
+
+const char*
+src_strerror (int error)
+{
+	switch (error)
+	{	case SRC_ERR_NO_ERROR :
+				return "No error." ;
+		case SRC_ERR_MALLOC_FAILED :
+				return "Malloc failed." ;
+		case SRC_ERR_BAD_STATE :
+				return "SRC_STATE pointer is NULL." ;
+		case SRC_ERR_BAD_DATA :
+				return "SRC_DATA pointer is NULL." ;
+		case SRC_ERR_BAD_DATA_PTR :
+				return "SRC_DATA->data_out is NULL." ;
+		case SRC_ERR_NO_PRIVATE :
+				return "Internal error. No private data." ;
+
+		case SRC_ERR_BAD_SRC_RATIO :
+				return "SRC ratio outside [1/" SRC_MAX_RATIO_STR ", " SRC_MAX_RATIO_STR "] range." ;
+
+		case SRC_ERR_BAD_SINC_STATE :
+				return "src_process() called without reset after end_of_input." ;
+		case SRC_ERR_BAD_PROC_PTR :
+				return "Internal error. No process pointer." ;
+		case SRC_ERR_SHIFT_BITS :
+				return "Internal error. SHIFT_BITS too large." ;
+		case SRC_ERR_FILTER_LEN :
+				return "Internal error. Filter length too large." ;
+		case SRC_ERR_BAD_CONVERTER :
+				return "Bad converter number." ;
+		case SRC_ERR_BAD_CHANNEL_COUNT :
+				return "Channel count must be >= 1." ;
+		case SRC_ERR_SINC_BAD_BUFFER_LEN :
+				return "Internal error. Bad buffer length. Please report this." ;
+		case SRC_ERR_SIZE_INCOMPATIBILITY :
+				return "Internal error. Input data / internal buffer size difference. Please report this." ;
+		case SRC_ERR_BAD_PRIV_PTR :
+				return "Internal error. Private pointer is NULL. Please report this." ;
+		case SRC_ERR_DATA_OVERLAP :
+				return "Input and output data arrays overlap." ;
+		case SRC_ERR_BAD_CALLBACK :
+				return "Supplied callback function pointer is NULL." ;
+		case SRC_ERR_BAD_MODE :
+				return "Calling mode differs from initialisation mode (ie process v callback)." ;
+		case SRC_ERR_NULL_CALLBACK :
+				return "Callback function pointer is NULL in src_callback_read ()." ;
+		case SRC_ERR_NO_VARIABLE_RATIO :
+				return "This converter only allows constant conversion ratios." ;
+		case SRC_ERR_SINC_PREPARE_DATA_BAD_LEN :
+				return "Internal error : Bad length in prepare_data ()." ;
+
+		case SRC_ERR_MAX_ERROR :
+				return "Placeholder. No error defined for this error number." ;
+
+		default : 						break ;
+		}
+
+	return NULL ;
+} /* src_strerror */
+
+/*==============================================================================
+**	Simple interface for performing a single conversion from input buffer to
+**	output buffer at a fixed conversion ratio.
+*/
+
+int
+src_simple (SRC_DATA *src_data, int converter, int channels)
+{	SRC_STATE	*src_state ;
+	int 		error ;
+
+	if ((src_state = src_new (converter, channels, &error)) == NULL)
+		return error ;
+
+	src_data->end_of_input = 1 ; /* Only one buffer worth of input. */
+
+	error = src_process (src_state, src_data) ;
+
+	src_state = src_delete (src_state) ;
+
+	return error ;
+} /* src_simple */
+
+void
+src_short_to_float_array (const short *in, float *out, int len)
+{
+	while (len)
+	{	len -- ;
+		out [len] = (float) (in [len] / (1.0 * 0x8000)) ;
+		} ;
+
+	return ;
+} /* src_short_to_float_array */
+
+void
+src_float_to_short_array (const float *in, short *out, int len)
+{	double scaled_value ;
+
+	while (len)
+	{	len -- ;
+
+		scaled_value = in [len] * (8.0 * 0x10000000) ;
+		if (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))
+		{	out [len] = 32767 ;
+			continue ;
+			} ;
+		if (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))
+		{	out [len] = -32768 ;
+			continue ;
+			} ;
+
+		out [len] = (short) (lrint (scaled_value) >> 16) ;
+		} ;
+
+} /* src_float_to_short_array */
+
+void
+src_int_to_float_array (const int *in, float *out, int len)
+{
+	while (len)
+	{	len -- ;
+		out [len] = (float) (in [len] / (8.0 * 0x10000000)) ;
+		} ;
+
+	return ;
+} /* src_int_to_float_array */
+
+void
+src_float_to_int_array (const float *in, int *out, int len)
+{	double scaled_value ;
+
+	while (len)
+	{	len -- ;
+
+		scaled_value = in [len] * (8.0 * 0x10000000) ;
+		if (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))
+		{	out [len] = 0x7fffffff ;
+			continue ;
+			} ;
+		if (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))
+		{	out [len] = -1 - 0x7fffffff ;
+			continue ;
+			} ;
+
+		out [len] = lrint (scaled_value) ;
+		} ;
+
+} /* src_float_to_int_array */
+
+/*==============================================================================
+**	Private functions.
+*/
+
+static int
+psrc_set_converter (SRC_PRIVATE	*psrc, int converter_type)
+{
+	if (sinc_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
+		return SRC_ERR_NO_ERROR ;
+
+	if (zoh_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
+		return SRC_ERR_NO_ERROR ;
+
+	if (linear_set_converter (psrc, converter_type) == SRC_ERR_NO_ERROR)
+		return SRC_ERR_NO_ERROR ;
+
+	return SRC_ERR_BAD_CONVERTER ;
+} /* psrc_set_converter */
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_linear.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_linear.c	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_linear.c	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,222 +1,217 @@
-/*
-** Copyright (C) 2002-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/*
-** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
-** use license for this code is available, please see:
-**		http://www.mega-nerd.com/SRC/procedure.html
-*/
-#if 0 // MEANX
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "config.h"
-#else
-#include "ADM_default.h"
-#endif
-#include "float_cast.h"
-#include "common.h"
-
-static int linear_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
-static void linear_reset (SRC_PRIVATE *psrc) ;
-
-/*========================================================================================
-*/
-
-#define	LINEAR_MAGIC_MARKER	MAKE_MAGIC ('l', 'i', 'n', 'e', 'a', 'r')
-
-#define	SRC_DEBUG	0
-
-typedef struct
-{	int		linear_magic_marker ;
-	int		channels ;
-	int		reset ;
-	long	in_count, in_used ;
-	long	out_count, out_gen ;
-	float	last_value [1] ;
-} LINEAR_DATA ;
-
-/*----------------------------------------------------------------------------------------
-*/
-
-static int
-linear_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
-{	LINEAR_DATA *linear ;
-	double		src_ratio, input_index, rem ;
-	int			ch ;
-
-	if (psrc->private_data == NULL)
-		return SRC_ERR_NO_PRIVATE ;
-
-	linear = (LINEAR_DATA*) psrc->private_data ;
-
-	if (linear->reset)
-	{	/* If we have just been reset, set the last_value data. */
-		for (ch = 0 ; ch < linear->channels ; ch++)
-			linear->last_value [ch] = data->data_in [ch] ;
-		linear->reset = 0 ;
-		} ;
-
-	linear->in_count = data->input_frames * linear->channels ;
-	linear->out_count = data->output_frames * linear->channels ;
-	linear->in_used = linear->out_gen = 0 ;
-
-	src_ratio = psrc->last_ratio ;
-	input_index = psrc->last_position ;
-
-	/* Calculate samples before first sample in input array. */
-	while (input_index < 1.0 && linear->out_gen < linear->out_count)
-	{
-		if (linear->in_used + linear->channels * input_index > linear->in_count)
-			break ;
-
-		if (linear->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > SRC_MIN_RATIO_DIFF)
-			src_ratio = psrc->last_ratio + linear->out_gen * (data->src_ratio - psrc->last_ratio) / linear->out_count ;
-
-		for (ch = 0 ; ch < linear->channels ; ch++)
-		{	data->data_out [linear->out_gen] = (float) (linear->last_value [ch] + input_index *
-										(data->data_in [ch] - linear->last_value [ch])) ;
-			linear->out_gen ++ ;
-			} ;
-
-		/* Figure out the next index. */
-		input_index += 1.0 / src_ratio ;
-		} ;
-
-	rem = fmod_one (input_index) ;
-	linear->in_used += linear->channels * lrint (input_index - rem) ;
-	input_index = rem ;
-
-	/* Main processing loop. */
-	while (linear->out_gen < linear->out_count && linear->in_used + linear->channels * input_index <= linear->in_count)
-	{
-		if (linear->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > SRC_MIN_RATIO_DIFF)
-			src_ratio = psrc->last_ratio + linear->out_gen * (data->src_ratio - psrc->last_ratio) / linear->out_count ;
-
-		if (SRC_DEBUG && linear->in_used < linear->channels && input_index < 1.0)
-		{	printf ("Whoops!!!!   in_used : %ld     channels : %d     input_index : %f\n", linear->in_used, linear->channels, input_index) ;
-			exit (1) ;
-			} ;
-
-		for (ch = 0 ; ch < linear->channels ; ch++)
-		{	data->data_out [linear->out_gen] = (float) (data->data_in [linear->in_used - linear->channels + ch] + input_index *
-						(data->data_in [linear->in_used + ch] - data->data_in [linear->in_used - linear->channels + ch])) ;
-			linear->out_gen ++ ;
-			} ;
-
-		/* Figure out the next index. */
-		input_index += 1.0 / src_ratio ;
-		rem = fmod_one (input_index) ;
-
-		linear->in_used += linear->channels * lrint (input_index - rem) ;
-		input_index = rem ;
-		} ;
-
-	if (linear->in_used > linear->in_count)
-	{	input_index += (linear->in_used - linear->in_count) / linear->channels ;
-		linear->in_used = linear->in_count ;
-		} ;
-
-	psrc->last_position = input_index ;
-
-	if (linear->in_used > 0)
-		for (ch = 0 ; ch < linear->channels ; ch++)
-			linear->last_value [ch] = data->data_in [linear->in_used - linear->channels + ch] ;
-
-	/* Save current ratio rather then target ratio. */
-	psrc->last_ratio = src_ratio ;
-
-	data->input_frames_used = linear->in_used / linear->channels ;
-	data->output_frames_gen = linear->out_gen / linear->channels ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* linear_vari_process */
-
-/*------------------------------------------------------------------------------
-*/
-
-const char*
-linear_get_name (int src_enum)
-{
-	if (src_enum == SRC_LINEAR)
-		return "Linear Interpolator" ;
-
-	return NULL ;
-} /* linear_get_name */
-
-const char*
-linear_get_description (int src_enum)
-{
-	if (src_enum == SRC_LINEAR)
-		return "Linear interpolator, very fast, poor quality." ;
-
-	return NULL ;
-} /* linear_get_descrition */
-
-int
-linear_set_converter (SRC_PRIVATE *psrc, int src_enum)
-{	LINEAR_DATA *linear = NULL ;
-
-	if (src_enum != SRC_LINEAR)
-		return SRC_ERR_BAD_CONVERTER ;
-
-	if (psrc->private_data != NULL)
-	{	linear = (LINEAR_DATA*) psrc->private_data ;
-		if (linear->linear_magic_marker != LINEAR_MAGIC_MARKER)
-		{	free (psrc->private_data) ;
-			psrc->private_data = NULL ;
-			} ;
-		} ;
-
-	if (psrc->private_data == NULL)
-	{	linear = calloc (1, sizeof (*linear) + psrc->channels * sizeof (float)) ;
-		if (linear == NULL)
-			return SRC_ERR_MALLOC_FAILED ;
-		psrc->private_data = linear ;
-		} ;
-
-	linear->linear_magic_marker = LINEAR_MAGIC_MARKER ;
-	linear->channels = psrc->channels ;
-
-	psrc->const_process = linear_vari_process ;
-	psrc->vari_process = linear_vari_process ;
-	psrc->reset = linear_reset ;
-
-	linear_reset (psrc) ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* linear_set_converter */
-
-/*===================================================================================
-*/
-
-static void
-linear_reset (SRC_PRIVATE *psrc)
-{	LINEAR_DATA *linear = NULL ;
-
-	linear = (LINEAR_DATA*) psrc->private_data ;
-	if (linear == NULL)
-		return ;
-
-	linear->channels = psrc->channels ;
-	linear->reset = 1 ;
-
-	memset (linear->last_value, 0, sizeof (linear->last_value [0]) * linear->channels) ;
-} /* linear_reset */
-
+/*
+** Copyright (C) 2002-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/*
+** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
+** use license for this code is available, please see:
+**		http://www.mega-nerd.com/SRC/procedure.html
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "config.h"
+#include "float_cast.h"
+#include "common.h"
+
+static int linear_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static void linear_reset (SRC_PRIVATE *psrc) ;
+
+/*========================================================================================
+*/
+
+#define	LINEAR_MAGIC_MARKER	MAKE_MAGIC ('l', 'i', 'n', 'e', 'a', 'r')
+
+#define	SRC_DEBUG	0
+
+typedef struct
+{	int		linear_magic_marker ;
+	int		channels ;
+	int		reset ;
+	long	in_count, in_used ;
+	long	out_count, out_gen ;
+	float	last_value [1] ;
+} LINEAR_DATA ;
+
+/*----------------------------------------------------------------------------------------
+*/
+
+static int
+linear_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	LINEAR_DATA *priv ;
+	double		src_ratio, input_index, rem ;
+	int			ch ;
+
+	if (psrc->private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	priv = (LINEAR_DATA*) psrc->private_data ;
+
+	if (priv->reset)
+	{	/* If we have just been reset, set the last_value data. */
+		for (ch = 0 ; ch < priv->channels ; ch++)
+			priv->last_value [ch] = data->data_in [ch] ;
+		priv->reset = 0 ;
+		} ;
+
+	priv->in_count = data->input_frames * priv->channels ;
+	priv->out_count = data->output_frames * priv->channels ;
+	priv->in_used = priv->out_gen = 0 ;
+
+	src_ratio = psrc->last_ratio ;
+	input_index = psrc->last_position ;
+
+	/* Calculate samples before first sample in input array. */
+	while (input_index < 1.0 && priv->out_gen < priv->out_count)
+	{
+		if (priv->in_used + priv->channels * (1.0 + input_index) >= priv->in_count)
+			break ;
+
+		if (priv->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > SRC_MIN_RATIO_DIFF)
+			src_ratio = psrc->last_ratio + priv->out_gen * (data->src_ratio - psrc->last_ratio) / priv->out_count ;
+
+		for (ch = 0 ; ch < priv->channels ; ch++)
+		{	data->data_out [priv->out_gen] = (float) (priv->last_value [ch] + input_index *
+										(data->data_in [ch] - priv->last_value [ch])) ;
+			priv->out_gen ++ ;
+			} ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		} ;
+
+	rem = fmod_one (input_index) ;
+	priv->in_used += priv->channels * lrint (input_index - rem) ;
+	input_index = rem ;
+
+	/* Main processing loop. */
+	while (priv->out_gen < priv->out_count && priv->in_used + priv->channels * input_index < priv->in_count)
+	{
+		if (priv->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > SRC_MIN_RATIO_DIFF)
+			src_ratio = psrc->last_ratio + priv->out_gen * (data->src_ratio - psrc->last_ratio) / priv->out_count ;
+
+		if (SRC_DEBUG && priv->in_used < priv->channels && input_index < 1.0)
+		{	printf ("Whoops!!!!   in_used : %ld     channels : %d     input_index : %f\n", priv->in_used, priv->channels, input_index) ;
+			exit (1) ;
+			} ;
+
+		for (ch = 0 ; ch < priv->channels ; ch++)
+		{	data->data_out [priv->out_gen] = (float) (data->data_in [priv->in_used - priv->channels + ch] + input_index *
+						(data->data_in [priv->in_used + ch] - data->data_in [priv->in_used - priv->channels + ch])) ;
+			priv->out_gen ++ ;
+			} ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		priv->in_used += priv->channels * lrint (input_index - rem) ;
+		input_index = rem ;
+		} ;
+
+	if (priv->in_used > priv->in_count)
+	{	input_index += (priv->in_used - priv->in_count) / priv->channels ;
+		priv->in_used = priv->in_count ;
+		} ;
+
+	psrc->last_position = input_index ;
+
+	if (priv->in_used > 0)
+		for (ch = 0 ; ch < priv->channels ; ch++)
+			priv->last_value [ch] = data->data_in [priv->in_used - priv->channels + ch] ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc->last_ratio = src_ratio ;
+
+	data->input_frames_used = priv->in_used / priv->channels ;
+	data->output_frames_gen = priv->out_gen / priv->channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* linear_vari_process */
+
+/*------------------------------------------------------------------------------
+*/
+
+const char*
+linear_get_name (int src_enum)
+{
+	if (src_enum == SRC_LINEAR)
+		return "Linear Interpolator" ;
+
+	return NULL ;
+} /* linear_get_name */
+
+const char*
+linear_get_description (int src_enum)
+{
+	if (src_enum == SRC_LINEAR)
+		return "Linear interpolator, very fast, poor quality." ;
+
+	return NULL ;
+} /* linear_get_descrition */
+
+int
+linear_set_converter (SRC_PRIVATE *psrc, int src_enum)
+{	LINEAR_DATA *priv = NULL ;
+
+	if (src_enum != SRC_LINEAR)
+		return SRC_ERR_BAD_CONVERTER ;
+
+	if (psrc->private_data != NULL)
+	{	free (psrc->private_data) ;
+		psrc->private_data = NULL ;
+		} ;
+
+	if (psrc->private_data == NULL)
+	{	priv = calloc (1, sizeof (*priv) + psrc->channels * sizeof (float)) ;
+		if (priv == NULL)
+			return SRC_ERR_MALLOC_FAILED ;
+		psrc->private_data = priv ;
+		} ;
+
+	priv->linear_magic_marker = LINEAR_MAGIC_MARKER ;
+	priv->channels = psrc->channels ;
+
+	psrc->const_process = linear_vari_process ;
+	psrc->vari_process = linear_vari_process ;
+	psrc->reset = linear_reset ;
+
+	linear_reset (psrc) ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* linear_set_converter */
+
+/*===================================================================================
+*/
+
+static void
+linear_reset (SRC_PRIVATE *psrc)
+{	LINEAR_DATA *priv = NULL ;
+
+	priv = (LINEAR_DATA*) psrc->private_data ;
+	if (priv == NULL)
+		return ;
+
+	priv->channels = psrc->channels ;
+	priv->reset = 1 ;
+	memset (priv->last_value, 0, sizeof (priv->last_value [0]) * priv->channels) ;
+
+	return ;
+} /* linear_reset */
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_sinc.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_sinc.c	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_sinc.c	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,471 +1,1204 @@
-/*
-** Copyright (C) 2002-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/*
-** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
-** use license for this code is available, please see:
-**		http://www.mega-nerd.com/SRC/procedure.html
-*/
-#if 0 // MEANX
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "config.h"
-#else
-#include "ADM_default.h"
-#endif
-#include "float_cast.h"
-#include "common.h"
-
-#define	SINC_MAGIC_MARKER	MAKE_MAGIC (' ', 's', 'i', 'n', 'c', ' ')
-
-/*========================================================================================
-*/
-
-#define MAKE_INCREMENT_T(x) 	((increment_t) (x))
-
-#define	SHIFT_BITS				12
-#define	FP_ONE					((double) (((increment_t) 1) << SHIFT_BITS))
-#define	INV_FP_ONE				(1.0 / FP_ONE)
-
-/*========================================================================================
-*/
-
-typedef int32_t increment_t ;
-typedef float	coeff_t ;
-
-#include "fastest_coeffs.h"
-#include "mid_qual_coeffs.h"
-#include "high_qual_coeffs.h"
-
-typedef struct
-{	int		sinc_magic_marker ;
-
-	int		channels ;
-	long	in_count, in_used ;
-	long	out_count, out_gen ;
-
-	int		coeff_half_len, index_inc ;
-
-	double	src_ratio, input_index ;
-
-	coeff_t const	*coeffs ;
-
-	int		b_current, b_end, b_real_end, b_len ;
-	float	buffer [1] ;
-} SINC_FILTER ;
-
-static int sinc_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
-
-static double calc_output (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, int ch) ;
-
-static void prepare_data (SINC_FILTER *filter, SRC_DATA *data, int half_filter_chan_len) ;
-
-static void sinc_reset (SRC_PRIVATE *psrc) ;
-
-static inline increment_t
-double_to_fp (double x)
-{	if (sizeof (increment_t) == 8)
-		return (llrint ((x) * FP_ONE)) ;
-	return (lrint ((x) * FP_ONE)) ;
-} /* double_to_fp */
-
-static inline increment_t
-int_to_fp (int x)
-{	return (((increment_t) (x)) << SHIFT_BITS) ;
-} /* int_to_fp */
-
-static inline int
-fp_to_int (increment_t x)
-{	return (((x) >> SHIFT_BITS)) ;
-} /* fp_to_int */
-
-static inline increment_t
-fp_fraction_part (increment_t x)
-{	return ((x) & ((((increment_t) 1) << SHIFT_BITS) - 1)) ;
-} /* fp_fraction_part */
-
-static inline double
-fp_to_double (increment_t x)
-{	return fp_fraction_part (x) * INV_FP_ONE ;
-} /* fp_to_double */
-
-
-/*----------------------------------------------------------------------------------------
-*/
-
-const char*
-sinc_get_name (int src_enum)
-{
-	switch (src_enum)
-	{	case SRC_SINC_BEST_QUALITY :
-			return "Best Sinc Interpolator" ;
-
-		case SRC_SINC_MEDIUM_QUALITY :
-			return "Medium Sinc Interpolator" ;
-
-		case SRC_SINC_FASTEST :
-			return "Fastest Sinc Interpolator" ;
-
-		default: break ;
-		} ;
-
-	return NULL ;
-} /* sinc_get_descrition */
-
-const char*
-sinc_get_description (int src_enum)
-{
-	switch (src_enum)
-	{	case SRC_SINC_FASTEST :
-			return "Band limited sinc interpolation, fastest, 97dB SNR, 80% BW." ;
-
-		case SRC_SINC_MEDIUM_QUALITY :
-			return "Band limited sinc interpolation, medium quality, 121dB SNR, 90% BW." ;
-
-		case SRC_SINC_BEST_QUALITY :
-			return "Band limited sinc interpolation, best quality, 145dB SNR, 96% BW." ;
-
-		default :
-			break ;
-		} ;
-
-	return NULL ;
-} /* sinc_get_descrition */
-
-int
-sinc_set_converter (SRC_PRIVATE *psrc, int src_enum)
-{	SINC_FILTER *filter, temp_filter ;
-	increment_t count ;
-	int bits ;
-
-	/* Quick sanity check. */
-	if (SHIFT_BITS >= sizeof (increment_t) * 8 - 1)
-		return SRC_ERR_SHIFT_BITS ;
-
-	if (psrc->private_data != NULL)
-	{	filter = (SINC_FILTER*) psrc->private_data ;
-		if (filter->sinc_magic_marker != SINC_MAGIC_MARKER)
-		{	free (psrc->private_data) ;
-			psrc->private_data = NULL ;
-			} ;
-		} ;
-
-	memset (&temp_filter, 0, sizeof (temp_filter)) ;
-
-	temp_filter.sinc_magic_marker = SINC_MAGIC_MARKER ;
-	temp_filter.channels = psrc->channels ;
-
-	psrc->const_process = sinc_vari_process ;
-	psrc->vari_process = sinc_vari_process ;
-	psrc->reset = sinc_reset ;
-
-	switch (src_enum)
-	{	case SRC_SINC_FASTEST :
-				temp_filter.coeffs = fastest_coeffs.coeffs ;
-				temp_filter.coeff_half_len = ARRAY_LEN (fastest_coeffs.coeffs) - 1 ;
-				temp_filter.index_inc = fastest_coeffs.increment ;
-				break ;
-
-		case SRC_SINC_MEDIUM_QUALITY :
-				temp_filter.coeffs = slow_mid_qual_coeffs.coeffs ;
-				temp_filter.coeff_half_len = ARRAY_LEN (slow_mid_qual_coeffs.coeffs) - 1 ;
-				temp_filter.index_inc = slow_mid_qual_coeffs.increment ;
-				break ;
-
-		case SRC_SINC_BEST_QUALITY :
-				temp_filter.coeffs = slow_high_qual_coeffs.coeffs ;
-				temp_filter.coeff_half_len = ARRAY_LEN (slow_high_qual_coeffs.coeffs) - 1 ;
-				temp_filter.index_inc = slow_high_qual_coeffs.increment ;
-				break ;
-
-		default :
-				return SRC_ERR_BAD_CONVERTER ;
-		} ;
-
-	/*
-	** FIXME : This needs to be looked at more closely to see if there is
-	** a better way. Need to look at prepare_data () at the same time.
-	*/
-
-	temp_filter.b_len = 2 * lrint (1.0 + temp_filter.coeff_half_len / (temp_filter.index_inc * 1.0) * SRC_MAX_RATIO) ;
-	temp_filter.b_len = MAX (temp_filter.b_len, 4096) ;
-	temp_filter.b_len *= temp_filter.channels ;
-
-	if ((filter = calloc (1, sizeof (SINC_FILTER) + sizeof (filter->buffer [0]) * (temp_filter.b_len + temp_filter.channels))) == NULL)
-		return SRC_ERR_MALLOC_FAILED ;
-
-	*filter = temp_filter ;
-	memset (&temp_filter, 0xEE, sizeof (temp_filter)) ;
-
-	psrc->private_data = filter ;
-
-	sinc_reset (psrc) ;
-
-	count = filter->coeff_half_len ;
-	for (bits = 0 ; (MAKE_INCREMENT_T (1) << bits) < count ; bits++)
-		count |= (MAKE_INCREMENT_T (1) << bits) ;
-
-	if (bits + SHIFT_BITS - 1 >= (int) (sizeof (increment_t) * 8))
-		return SRC_ERR_FILTER_LEN ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* sinc_set_converter */
-
-static void
-sinc_reset (SRC_PRIVATE *psrc)
-{	SINC_FILTER *filter ;
-
-	filter = (SINC_FILTER*) psrc->private_data ;
-	if (filter == NULL)
-		return ;
-
-	filter->b_current = filter->b_end = 0 ;
-	filter->b_real_end = -1 ;
-
-	filter->src_ratio = filter->input_index = 0.0 ;
-
-	memset (filter->buffer, 0, filter->b_len * sizeof (filter->buffer [0])) ;
-
-	/* Set this for a sanity check */
-	memset (filter->buffer + filter->b_len, 0xAA, filter->channels * sizeof (filter->buffer [0])) ;
-} /* sinc_reset */
-
-/*========================================================================================
-**	Beware all ye who dare pass this point. There be dragons here.
-*/
-
-static int
-sinc_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
-{	SINC_FILTER *filter ;
-	double		input_index, src_ratio, count, float_increment, terminate, rem ;
-	increment_t	increment, start_filter_index ;
-	int			half_filter_chan_len, samples_in_hand, ch ;
-
-	if (psrc->private_data == NULL)
-		return SRC_ERR_NO_PRIVATE ;
-
-	filter = (SINC_FILTER*) psrc->private_data ;
-
-	/* If there is not a problem, this will be optimised out. */
-	if (sizeof (filter->buffer [0]) != sizeof (data->data_in [0]))
-		return SRC_ERR_SIZE_INCOMPATIBILITY ;
-
-	filter->in_count = data->input_frames * filter->channels ;
-	filter->out_count = data->output_frames * filter->channels ;
-	filter->in_used = filter->out_gen = 0 ;
-
-	src_ratio = psrc->last_ratio ;
-
-	/* Check the sample rate ratio wrt the buffer len. */
-	count = (filter->coeff_half_len + 2.0) / filter->index_inc ;
-	if (MIN (psrc->last_ratio, data->src_ratio) < 1.0)
-		count /= MIN (psrc->last_ratio, data->src_ratio) ;
-
-	/* Maximum coefficientson either side of center point. */
-	half_filter_chan_len = filter->channels * (lrint (count) + 1) ;
-
-	input_index = psrc->last_position ;
-	float_increment = filter->index_inc ;
-
-	rem = fmod_one (input_index) ;
-	filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
-	input_index = rem ;
-
-	terminate = 1.0 / src_ratio + 1e-20 ;
-
-	/* Main processing loop. */
-	while (filter->out_gen < filter->out_count)
-	{
-		/* Need to reload buffer? */
-		samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
-
-		if (samples_in_hand <= half_filter_chan_len)
-		{	prepare_data (filter, data, half_filter_chan_len) ;
-
-			samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
-			if (samples_in_hand <= half_filter_chan_len)
-				break ;
-			} ;
-
-		/* This is the termination condition. */
-		if (filter->b_real_end >= 0)
-		{	if (filter->b_current + input_index + terminate >= filter->b_real_end)
-				break ;
-			} ;
-
-		if (filter->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > 1e-10)
-			src_ratio = psrc->last_ratio + filter->out_gen * (data->src_ratio - psrc->last_ratio) / filter->out_count ;
-
-		float_increment = filter->index_inc * 1.0 ;
-		if (src_ratio < 1.0)
-			float_increment = filter->index_inc * src_ratio ;
-
-		increment = double_to_fp (float_increment) ;
-
-		start_filter_index = double_to_fp (input_index * float_increment) ;
-
-		for (ch = 0 ; ch < filter->channels ; ch++)
-		{	data->data_out [filter->out_gen] = (float) ((float_increment / filter->index_inc) *
-											calc_output (filter, increment, start_filter_index, ch)) ;
-			filter->out_gen ++ ;
-			} ;
-
-		/* Figure out the next index. */
-		input_index += 1.0 / src_ratio ;
-		rem = fmod_one (input_index) ;
-
-		filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
-		input_index = rem ;
-		} ;
-
-	psrc->last_position = input_index ;
-
-	/* Save current ratio rather then target ratio. */
-	psrc->last_ratio = src_ratio ;
-
-	data->input_frames_used = filter->in_used / filter->channels ;
-	data->output_frames_gen = filter->out_gen / filter->channels ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* sinc_vari_process */
-
-/*----------------------------------------------------------------------------------------
-*/
-
-static void
-prepare_data (SINC_FILTER *filter, SRC_DATA *data, int half_filter_chan_len)
-{	int len = 0 ;
-
-	if (filter->b_real_end >= 0)
-		return ;	/* This doesn't make sense, so return. */
-
-	if (filter->b_current == 0)
-	{	/* Initial state. Set up zeros at the start of the buffer and
-		** then load new data after that.
-		*/
-		len = filter->b_len - 2 * half_filter_chan_len ;
-
-		filter->b_current = filter->b_end = half_filter_chan_len ;
-		}
-	else if (filter->b_end + half_filter_chan_len + filter->channels < filter->b_len)
-	{	/*  Load data at current end position. */
-		len = MAX (filter->b_len - filter->b_current - half_filter_chan_len, 0) ;
-		}
-	else
-	{	/* Move data at end of buffer back to the start of the buffer. */
-		len = filter->b_end - filter->b_current ;
-		memmove (filter->buffer, filter->buffer + filter->b_current - half_filter_chan_len,
-						(half_filter_chan_len + len) * sizeof (filter->buffer [0])) ;
-
-		filter->b_current = half_filter_chan_len ;
-		filter->b_end = filter->b_current + len ;
-
-		/* Now load data at current end of buffer. */
-		len = MAX (filter->b_len - filter->b_current - half_filter_chan_len, 0) ;
-		} ;
-
-	len = MIN (filter->in_count - filter->in_used, len) ;
-	len -= (len % filter->channels) ;
-
-	memcpy (filter->buffer + filter->b_end, data->data_in + filter->in_used,
-						len * sizeof (filter->buffer [0])) ;
-
-	filter->b_end += len ;
-	filter->in_used += len ;
-
-	if (filter->in_used == filter->in_count &&
-			filter->b_end - filter->b_current < 2 * half_filter_chan_len && data->end_of_input)
-	{	/* Handle the case where all data in the current buffer has been
-		** consumed and this is the last buffer.
-		*/
-
-		if (filter->b_len - filter->b_end < half_filter_chan_len + 5)
-		{	/* If necessary, move data down to the start of the buffer. */
-			len = filter->b_end - filter->b_current ;
-			memmove (filter->buffer, filter->buffer + filter->b_current - half_filter_chan_len,
-							(half_filter_chan_len + len) * sizeof (filter->buffer [0])) ;
-
-			filter->b_current = half_filter_chan_len ;
-			filter->b_end = filter->b_current + len ;
-			} ;
-
-		filter->b_real_end = filter->b_end ;
-		len = half_filter_chan_len + 5 ;
-
-		memset (filter->buffer + filter->b_end, 0, len * sizeof (filter->buffer [0])) ;
-		filter->b_end += len ;
-		} ;
-
-	return ;
-} /* prepare_data */
-
-
-static double
-calc_output (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, int ch)
-{	double		fraction, left, right, icoeff ;
-	increment_t	filter_index, max_filter_index ;
-	int			data_index, coeff_count, indx ;
-
-	/* Convert input parameters into fixed point. */
-	max_filter_index = int_to_fp (filter->coeff_half_len) ;
-
-	/* First apply the left half of the filter. */
-	filter_index = start_filter_index ;
-	coeff_count = (max_filter_index - filter_index) / increment ;
-	filter_index = filter_index + coeff_count * increment ;
-	data_index = filter->b_current - filter->channels * coeff_count + ch ;
-
-	left = 0.0 ;
-	do
-	{	fraction = fp_to_double (filter_index) ;
-		indx = fp_to_int (filter_index) ;
-
-		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
-
-		left += icoeff * filter->buffer [data_index] ;
-
-		filter_index -= increment ;
-		data_index = data_index + filter->channels ;
-		}
-	while (filter_index >= MAKE_INCREMENT_T (0)) ;
-
-	/* Now apply the right half of the filter. */
-	filter_index = increment - start_filter_index ;
-	coeff_count = (max_filter_index - filter_index) / increment ;
-	filter_index = filter_index + coeff_count * increment ;
-	data_index = filter->b_current + filter->channels * (1 + coeff_count) + ch ;
-
-	right = 0.0 ;
-	do
-	{	fraction = fp_to_double (filter_index) ;
-		indx = fp_to_int (filter_index) ;
-
-		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
-
-		right += icoeff * filter->buffer [data_index] ;
-
-		filter_index -= increment ;
-		data_index = data_index - filter->channels ;
-		}
-	while (filter_index > MAKE_INCREMENT_T (0)) ;
-
-	return (left + right) ;
-} /* calc_output */
-
+/*
+** Copyright (C) 2002-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/*
+** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
+** use license for this code is available, please see:
+**		http://www.mega-nerd.com/SRC/procedure.html
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "config.h"
+#include "float_cast.h"
+#include "common.h"
+
+#define	SINC_MAGIC_MARKER	MAKE_MAGIC (' ', 's', 'i', 'n', 'c', ' ')
+
+/*========================================================================================
+*/
+
+#define MAKE_INCREMENT_T(x) 	((increment_t) (x))
+
+#define	SHIFT_BITS				12
+#define	FP_ONE					((double) (((increment_t) 1) << SHIFT_BITS))
+#define	INV_FP_ONE				(1.0 / FP_ONE)
+
+/*========================================================================================
+*/
+
+typedef int32_t increment_t ;
+typedef float	coeff_t ;
+
+#include "fastest_coeffs.h"
+#include "mid_qual_coeffs.h"
+#include "high_qual_coeffs.h"
+
+typedef struct
+{	int		sinc_magic_marker ;
+
+	int		channels ;
+	long	in_count, in_used ;
+	long	out_count, out_gen ;
+
+	int		coeff_half_len, index_inc ;
+
+	double	src_ratio, input_index ;
+
+	coeff_t const	*coeffs ;
+
+	int		b_current, b_end, b_real_end, b_len ;
+
+	/* Sure hope noone does more than 128 channels at once. */
+	double left_calc [128], right_calc [128] ;
+
+	/* C99 struct flexible array. */
+	float	buffer [] ;
+} SINC_FILTER ;
+
+static int sinc_multichan_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static int sinc_hex_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static int sinc_quad_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static int sinc_stereo_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static int sinc_mono_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+
+static int prepare_data (SINC_FILTER *filter, SRC_DATA *data, int half_filter_chan_len) WARN_UNUSED ;
+
+static void sinc_reset (SRC_PRIVATE *psrc) ;
+
+static inline increment_t
+double_to_fp (double x)
+{	return (lrint ((x) * FP_ONE)) ;
+} /* double_to_fp */
+
+static inline increment_t
+int_to_fp (int x)
+{	return (((increment_t) (x)) << SHIFT_BITS) ;
+} /* int_to_fp */
+
+static inline int
+fp_to_int (increment_t x)
+{	return (((x) >> SHIFT_BITS)) ;
+} /* fp_to_int */
+
+static inline increment_t
+fp_fraction_part (increment_t x)
+{	return ((x) & ((((increment_t) 1) << SHIFT_BITS) - 1)) ;
+} /* fp_fraction_part */
+
+static inline double
+fp_to_double (increment_t x)
+{	return fp_fraction_part (x) * INV_FP_ONE ;
+} /* fp_to_double */
+
+
+/*----------------------------------------------------------------------------------------
+*/
+
+const char*
+sinc_get_name (int src_enum)
+{
+	switch (src_enum)
+	{	case SRC_SINC_BEST_QUALITY :
+			return "Best Sinc Interpolator" ;
+
+		case SRC_SINC_MEDIUM_QUALITY :
+			return "Medium Sinc Interpolator" ;
+
+		case SRC_SINC_FASTEST :
+			return "Fastest Sinc Interpolator" ;
+
+		default: break ;
+		} ;
+
+	return NULL ;
+} /* sinc_get_descrition */
+
+const char*
+sinc_get_description (int src_enum)
+{
+	switch (src_enum)
+	{	case SRC_SINC_FASTEST :
+			return "Band limited sinc interpolation, fastest, 97dB SNR, 80% BW." ;
+
+		case SRC_SINC_MEDIUM_QUALITY :
+			return "Band limited sinc interpolation, medium quality, 121dB SNR, 90% BW." ;
+
+		case SRC_SINC_BEST_QUALITY :
+			return "Band limited sinc interpolation, best quality, 145dB SNR, 96% BW." ;
+
+		default :
+			break ;
+		} ;
+
+	return NULL ;
+} /* sinc_get_descrition */
+
+int
+sinc_set_converter (SRC_PRIVATE *psrc, int src_enum)
+{	SINC_FILTER *filter, temp_filter ;
+	increment_t count ;
+	int bits ;
+
+	/* Quick sanity check. */
+	if (SHIFT_BITS >= sizeof (increment_t) * 8 - 1)
+		return SRC_ERR_SHIFT_BITS ;
+
+	if (psrc->private_data != NULL)
+	{	free (psrc->private_data) ;
+		psrc->private_data = NULL ;
+		} ;
+
+	memset (&temp_filter, 0, sizeof (temp_filter)) ;
+
+	temp_filter.sinc_magic_marker = SINC_MAGIC_MARKER ;
+	temp_filter.channels = psrc->channels ;
+
+	if (psrc->channels > ARRAY_LEN (temp_filter.left_calc))
+		return SRC_ERR_BAD_CHANNEL_COUNT ;
+	else if (psrc->channels == 1)
+	{	psrc->const_process = sinc_mono_vari_process ;
+		psrc->vari_process = sinc_mono_vari_process ;
+		}
+	else
+	if (psrc->channels == 2)
+	{	psrc->const_process = sinc_stereo_vari_process ;
+		psrc->vari_process = sinc_stereo_vari_process ;
+		}
+	else
+	if (psrc->channels == 4)
+	{	psrc->const_process = sinc_quad_vari_process ;
+		psrc->vari_process = sinc_quad_vari_process ;
+		}
+	else
+	if (psrc->channels == 6)
+	{	psrc->const_process = sinc_hex_vari_process ;
+		psrc->vari_process = sinc_hex_vari_process ;
+		}
+	else
+	{	psrc->const_process = sinc_multichan_vari_process ;
+		psrc->vari_process = sinc_multichan_vari_process ;
+		} ;
+	psrc->reset = sinc_reset ;
+
+	switch (src_enum)
+	{	case SRC_SINC_FASTEST :
+				temp_filter.coeffs = fastest_coeffs.coeffs ;
+				temp_filter.coeff_half_len = ARRAY_LEN (fastest_coeffs.coeffs) - 1 ;
+				temp_filter.index_inc = fastest_coeffs.increment ;
+				break ;
+
+		case SRC_SINC_MEDIUM_QUALITY :
+				temp_filter.coeffs = slow_mid_qual_coeffs.coeffs ;
+				temp_filter.coeff_half_len = ARRAY_LEN (slow_mid_qual_coeffs.coeffs) - 1 ;
+				temp_filter.index_inc = slow_mid_qual_coeffs.increment ;
+				break ;
+
+		case SRC_SINC_BEST_QUALITY :
+				temp_filter.coeffs = slow_high_qual_coeffs.coeffs ;
+				temp_filter.coeff_half_len = ARRAY_LEN (slow_high_qual_coeffs.coeffs) - 1 ;
+				temp_filter.index_inc = slow_high_qual_coeffs.increment ;
+				break ;
+
+		default :
+				return SRC_ERR_BAD_CONVERTER ;
+		} ;
+
+	/*
+	** FIXME : This needs to be looked at more closely to see if there is
+	** a better way. Need to look at prepare_data () at the same time.
+	*/
+
+	temp_filter.b_len = lrint (2.5 * temp_filter.coeff_half_len / (temp_filter.index_inc * 1.0) * SRC_MAX_RATIO) ;
+	temp_filter.b_len = MAX (temp_filter.b_len, 4096) ;
+	temp_filter.b_len *= temp_filter.channels ;
+
+	if ((filter = calloc (1, sizeof (SINC_FILTER) + sizeof (filter->buffer [0]) * (temp_filter.b_len + temp_filter.channels))) == NULL)
+		return SRC_ERR_MALLOC_FAILED ;
+
+	*filter = temp_filter ;
+	memset (&temp_filter, 0xEE, sizeof (temp_filter)) ;
+
+	psrc->private_data = filter ;
+
+	sinc_reset (psrc) ;
+
+	count = filter->coeff_half_len ;
+	for (bits = 0 ; (MAKE_INCREMENT_T (1) << bits) < count ; bits++)
+		count |= (MAKE_INCREMENT_T (1) << bits) ;
+
+	if (bits + SHIFT_BITS - 1 >= (int) (sizeof (increment_t) * 8))
+		return SRC_ERR_FILTER_LEN ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_set_converter */
+
+static void
+sinc_reset (SRC_PRIVATE *psrc)
+{	SINC_FILTER *filter ;
+
+	filter = (SINC_FILTER*) psrc->private_data ;
+	if (filter == NULL)
+		return ;
+
+	filter->b_current = filter->b_end = 0 ;
+	filter->b_real_end = -1 ;
+
+	filter->src_ratio = filter->input_index = 0.0 ;
+
+	memset (filter->buffer, 0, filter->b_len * sizeof (filter->buffer [0])) ;
+
+	/* Set this for a sanity check */
+	memset (filter->buffer + filter->b_len, 0xAA, filter->channels * sizeof (filter->buffer [0])) ;
+} /* sinc_reset */
+
+/*========================================================================================
+**	Beware all ye who dare pass this point. There be dragons here.
+*/
+
+static inline double
+calc_output_single (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index)
+{	double		fraction, left, right, icoeff ;
+	increment_t	filter_index, max_filter_index ;
+	int			data_index, coeff_count, indx ;
+
+	/* Convert input parameters into fixed point. */
+	max_filter_index = int_to_fp (filter->coeff_half_len) ;
+
+	/* First apply the left half of the filter. */
+	filter_index = start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current - coeff_count ;
+
+	left = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		left += icoeff * filter->buffer [data_index] ;
+
+		filter_index -= increment ;
+		data_index = data_index + 1 ;
+		}
+	while (filter_index >= MAKE_INCREMENT_T (0)) ;
+
+	/* Now apply the right half of the filter. */
+	filter_index = increment - start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current + 1 + coeff_count ;
+
+	right = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		right += icoeff * filter->buffer [data_index] ;
+
+		filter_index -= increment ;
+		data_index = data_index - 1 ;
+		}
+	while (filter_index > MAKE_INCREMENT_T (0)) ;
+
+	return (left + right) ;
+} /* calc_output_single */
+
+static int
+sinc_mono_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc->private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc->private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter->buffer [0]) != sizeof (data->data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter->in_count = data->input_frames * filter->channels ;
+	filter->out_count = data->output_frames * filter->channels ;
+	filter->in_used = filter->out_gen = 0 ;
+
+	src_ratio = psrc->last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter->coeff_half_len + 2.0) / filter->index_inc ;
+	if (MIN (psrc->last_ratio, data->src_ratio) < 1.0)
+		count /= MIN (psrc->last_ratio, data->src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter->channels * (lrint (count) + 1) ;
+
+	input_index = psrc->last_position ;
+	float_increment = filter->index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter->out_gen < filter->out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+
+		if (samples_in_hand <= half_filter_chan_len)
+		{	if ((psrc->error = prepare_data (filter, data, half_filter_chan_len)) != 0)
+				return psrc->error ;
+
+			samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+			if (samples_in_hand <= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter->b_real_end >= 0)
+		{	if (filter->b_current + input_index + terminate >= filter->b_real_end)
+				break ;
+			} ;
+
+		if (filter->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > 1e-10)
+			src_ratio = psrc->last_ratio + filter->out_gen * (data->src_ratio - psrc->last_ratio) / filter->out_count ;
+
+		float_increment = filter->index_inc * 1.0 ;
+		if (src_ratio < 1.0)
+			float_increment = filter->index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		data->data_out [filter->out_gen] = (float) ((float_increment / filter->index_inc) *
+										calc_output_single (filter, increment, start_filter_index)) ;
+		filter->out_gen ++ ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc->last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc->last_ratio = src_ratio ;
+
+	data->input_frames_used = filter->in_used / filter->channels ;
+	data->output_frames_gen = filter->out_gen / filter->channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_mono_vari_process */
+
+static inline void
+calc_output_stereo (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, double scale, float * output)
+{	double		fraction, left [2], right [2], icoeff ;
+	increment_t	filter_index, max_filter_index ;
+	int			data_index, coeff_count, indx ;
+
+	/* Convert input parameters into fixed point. */
+	max_filter_index = int_to_fp (filter->coeff_half_len) ;
+
+	/* First apply the left half of the filter. */
+	filter_index = start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current - filter->channels * coeff_count ;
+
+	left [0] = left [1] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		left [0] += icoeff * filter->buffer [data_index] ;
+		left [1] += icoeff * filter->buffer [data_index + 1] ;
+
+		filter_index -= increment ;
+		data_index = data_index + 2 ;
+		}
+	while (filter_index >= MAKE_INCREMENT_T (0)) ;
+
+	/* Now apply the right half of the filter. */
+	filter_index = increment - start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current + filter->channels * (1 + coeff_count) ;
+
+	right [0] = right [1] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		right [0] += icoeff * filter->buffer [data_index] ;
+		right [1] += icoeff * filter->buffer [data_index + 1] ;
+
+		filter_index -= increment ;
+		data_index = data_index - 2 ;
+		}
+	while (filter_index > MAKE_INCREMENT_T (0)) ;
+
+	output [0] = scale * (left [0] + right [0]) ;
+	output [1] = scale * (left [1] + right [1]) ;
+} /* calc_output_stereo */
+
+static int
+sinc_stereo_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc->private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc->private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter->buffer [0]) != sizeof (data->data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter->in_count = data->input_frames * filter->channels ;
+	filter->out_count = data->output_frames * filter->channels ;
+	filter->in_used = filter->out_gen = 0 ;
+
+	src_ratio = psrc->last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter->coeff_half_len + 2.0) / filter->index_inc ;
+	if (MIN (psrc->last_ratio, data->src_ratio) < 1.0)
+		count /= MIN (psrc->last_ratio, data->src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter->channels * (lrint (count) + 1) ;
+
+	input_index = psrc->last_position ;
+	float_increment = filter->index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter->out_gen < filter->out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+
+		if (samples_in_hand <= half_filter_chan_len)
+		{	if ((psrc->error = prepare_data (filter, data, half_filter_chan_len)) != 0)
+				return psrc->error ;
+
+			samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+			if (samples_in_hand <= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter->b_real_end >= 0)
+		{	if (filter->b_current + input_index + terminate >= filter->b_real_end)
+				break ;
+			} ;
+
+		if (filter->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > 1e-10)
+			src_ratio = psrc->last_ratio + filter->out_gen * (data->src_ratio - psrc->last_ratio) / filter->out_count ;
+
+		float_increment = filter->index_inc * 1.0 ;
+		if (src_ratio < 1.0)
+			float_increment = filter->index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		calc_output_stereo (filter, increment, start_filter_index, float_increment / filter->index_inc, data->data_out + filter->out_gen) ;
+		filter->out_gen += 2 ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc->last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc->last_ratio = src_ratio ;
+
+	data->input_frames_used = filter->in_used / filter->channels ;
+	data->output_frames_gen = filter->out_gen / filter->channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_stereo_vari_process */
+
+static inline void
+calc_output_quad (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, double scale, float * output)
+{	double		fraction, left [4], right [4], icoeff ;
+	increment_t	filter_index, max_filter_index ;
+	int			data_index, coeff_count, indx ;
+
+	/* Convert input parameters into fixed point. */
+	max_filter_index = int_to_fp (filter->coeff_half_len) ;
+
+	/* First apply the left half of the filter. */
+	filter_index = start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current - filter->channels * coeff_count ;
+
+	left [0] = left [1] = left [2] = left [3] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		left [0] += icoeff * filter->buffer [data_index] ;
+		left [1] += icoeff * filter->buffer [data_index + 1] ;
+		left [2] += icoeff * filter->buffer [data_index + 2] ;
+		left [3] += icoeff * filter->buffer [data_index + 3] ;
+
+		filter_index -= increment ;
+		data_index = data_index + 4 ;
+		}
+	while (filter_index >= MAKE_INCREMENT_T (0)) ;
+
+	/* Now apply the right half of the filter. */
+	filter_index = increment - start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current + filter->channels * (1 + coeff_count) ;
+
+	right [0] = right [1] = right [2] = right [3] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		right [0] += icoeff * filter->buffer [data_index] ;
+		right [1] += icoeff * filter->buffer [data_index + 1] ;
+		right [2] += icoeff * filter->buffer [data_index + 2] ;
+		right [3] += icoeff * filter->buffer [data_index + 3] ;
+
+		filter_index -= increment ;
+		data_index = data_index - 4 ;
+		}
+	while (filter_index > MAKE_INCREMENT_T (0)) ;
+
+	output [0] = scale * (left [0] + right [0]) ;
+	output [1] = scale * (left [1] + right [1]) ;
+	output [2] = scale * (left [2] + right [2]) ;
+	output [3] = scale * (left [3] + right [3]) ;
+} /* calc_output_quad */
+
+static int
+sinc_quad_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc->private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc->private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter->buffer [0]) != sizeof (data->data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter->in_count = data->input_frames * filter->channels ;
+	filter->out_count = data->output_frames * filter->channels ;
+	filter->in_used = filter->out_gen = 0 ;
+
+	src_ratio = psrc->last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter->coeff_half_len + 2.0) / filter->index_inc ;
+	if (MIN (psrc->last_ratio, data->src_ratio) < 1.0)
+		count /= MIN (psrc->last_ratio, data->src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter->channels * (lrint (count) + 1) ;
+
+	input_index = psrc->last_position ;
+	float_increment = filter->index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter->out_gen < filter->out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+
+		if (samples_in_hand <= half_filter_chan_len)
+		{	if ((psrc->error = prepare_data (filter, data, half_filter_chan_len)) != 0)
+				return psrc->error ;
+
+			samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+			if (samples_in_hand <= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter->b_real_end >= 0)
+		{	if (filter->b_current + input_index + terminate >= filter->b_real_end)
+				break ;
+			} ;
+
+		if (filter->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > 1e-10)
+			src_ratio = psrc->last_ratio + filter->out_gen * (data->src_ratio - psrc->last_ratio) / filter->out_count ;
+
+		float_increment = filter->index_inc * 1.0 ;
+		if (src_ratio < 1.0)
+			float_increment = filter->index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		calc_output_quad (filter, increment, start_filter_index, float_increment / filter->index_inc, data->data_out + filter->out_gen) ;
+		filter->out_gen += 4 ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc->last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc->last_ratio = src_ratio ;
+
+	data->input_frames_used = filter->in_used / filter->channels ;
+	data->output_frames_gen = filter->out_gen / filter->channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_quad_vari_process */
+
+static inline void
+calc_output_hex (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, double scale, float * output)
+{	double		fraction, left [6], right [6], icoeff ;
+	increment_t	filter_index, max_filter_index ;
+	int			data_index, coeff_count, indx ;
+
+	/* Convert input parameters into fixed point. */
+	max_filter_index = int_to_fp (filter->coeff_half_len) ;
+
+	/* First apply the left half of the filter. */
+	filter_index = start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current - filter->channels * coeff_count ;
+
+	left [0] = left [1] = left [2] = left [3] = left [4] = left [5] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		left [0] += icoeff * filter->buffer [data_index] ;
+		left [1] += icoeff * filter->buffer [data_index + 1] ;
+		left [2] += icoeff * filter->buffer [data_index + 2] ;
+		left [3] += icoeff * filter->buffer [data_index + 3] ;
+		left [4] += icoeff * filter->buffer [data_index + 4] ;
+		left [5] += icoeff * filter->buffer [data_index + 5] ;
+
+		filter_index -= increment ;
+		data_index = data_index + 6 ;
+		}
+	while (filter_index >= MAKE_INCREMENT_T (0)) ;
+
+	/* Now apply the right half of the filter. */
+	filter_index = increment - start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current + filter->channels * (1 + coeff_count) ;
+
+	right [0] = right [1] = right [2] = right [3] = right [4] = right [5] = 0.0 ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		right [0] += icoeff * filter->buffer [data_index] ;
+		right [1] += icoeff * filter->buffer [data_index + 1] ;
+		right [2] += icoeff * filter->buffer [data_index + 2] ;
+		right [3] += icoeff * filter->buffer [data_index + 3] ;
+		right [4] += icoeff * filter->buffer [data_index + 4] ;
+		right [5] += icoeff * filter->buffer [data_index + 5] ;
+
+		filter_index -= increment ;
+		data_index = data_index - 6 ;
+		}
+	while (filter_index > MAKE_INCREMENT_T (0)) ;
+
+	output [0] = scale * (left [0] + right [0]) ;
+	output [1] = scale * (left [1] + right [1]) ;
+	output [2] = scale * (left [2] + right [2]) ;
+	output [3] = scale * (left [3] + right [3]) ;
+	output [4] = scale * (left [4] + right [4]) ;
+	output [5] = scale * (left [5] + right [5]) ;
+} /* calc_output_hex */
+
+static int
+sinc_hex_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc->private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc->private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter->buffer [0]) != sizeof (data->data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter->in_count = data->input_frames * filter->channels ;
+	filter->out_count = data->output_frames * filter->channels ;
+	filter->in_used = filter->out_gen = 0 ;
+
+	src_ratio = psrc->last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter->coeff_half_len + 2.0) / filter->index_inc ;
+	if (MIN (psrc->last_ratio, data->src_ratio) < 1.0)
+		count /= MIN (psrc->last_ratio, data->src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter->channels * (lrint (count) + 1) ;
+
+	input_index = psrc->last_position ;
+	float_increment = filter->index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter->out_gen < filter->out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+
+		if (samples_in_hand <= half_filter_chan_len)
+		{	if ((psrc->error = prepare_data (filter, data, half_filter_chan_len)) != 0)
+				return psrc->error ;
+
+			samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+			if (samples_in_hand <= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter->b_real_end >= 0)
+		{	if (filter->b_current + input_index + terminate >= filter->b_real_end)
+				break ;
+			} ;
+
+		if (filter->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > 1e-10)
+			src_ratio = psrc->last_ratio + filter->out_gen * (data->src_ratio - psrc->last_ratio) / filter->out_count ;
+
+		float_increment = filter->index_inc * 1.0 ;
+		if (src_ratio < 1.0)
+			float_increment = filter->index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		calc_output_hex (filter, increment, start_filter_index, float_increment / filter->index_inc, data->data_out + filter->out_gen) ;
+		filter->out_gen += 6 ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc->last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc->last_ratio = src_ratio ;
+
+	data->input_frames_used = filter->in_used / filter->channels ;
+	data->output_frames_gen = filter->out_gen / filter->channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_hex_vari_process */
+
+static inline void
+calc_output_multi (SINC_FILTER *filter, increment_t increment, increment_t start_filter_index, int channels, double scale, float * output)
+{	double		fraction, icoeff ;
+	/* The following line is 1999 ISO Standard C. If your compiler complains, get a better compiler. */
+	double		*left, *right ;
+	increment_t	filter_index, max_filter_index ;
+	int			data_index, coeff_count, indx, ch ;
+
+	left = filter->left_calc ;
+	right = filter->right_calc ;
+
+	/* Convert input parameters into fixed point. */
+	max_filter_index = int_to_fp (filter->coeff_half_len) ;
+
+	/* First apply the left half of the filter. */
+	filter_index = start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current - channels * coeff_count ;
+
+	memset (left, 0, sizeof (left [0]) * channels) ;
+
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		/*
+		**	Duff's Device.
+		**	See : http://en.wikipedia.org/wiki/Duff's_device
+		*/
+		ch = channels ;
+		do
+		{
+			switch (ch % 8)
+			{	default :
+					ch -- ;
+					left [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 7 :
+					ch -- ;
+					left [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 6 :
+					ch -- ;
+					left [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 5 :
+					ch -- ;
+					left [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 4 :
+					ch -- ;
+					left [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 3 :
+					ch -- ;
+					left [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 2 :
+					ch -- ;
+					left [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 1 :
+					ch -- ;
+					left [ch] += icoeff * filter->buffer [data_index + ch] ;
+				} ;
+			}
+		while (ch > 0) ;
+
+		filter_index -= increment ;
+		data_index = data_index + channels ;
+		}
+	while (filter_index >= MAKE_INCREMENT_T (0)) ;
+
+	/* Now apply the right half of the filter. */
+	filter_index = increment - start_filter_index ;
+	coeff_count = (max_filter_index - filter_index) / increment ;
+	filter_index = filter_index + coeff_count * increment ;
+	data_index = filter->b_current + channels * (1 + coeff_count) ;
+
+	memset (right, 0, sizeof (right [0]) * channels) ;
+	do
+	{	fraction = fp_to_double (filter_index) ;
+		indx = fp_to_int (filter_index) ;
+
+		icoeff = filter->coeffs [indx] + fraction * (filter->coeffs [indx + 1] - filter->coeffs [indx]) ;
+
+		ch = channels ;
+		do
+		{
+			switch (ch % 8)
+			{	default :
+					ch -- ;
+					right [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 7 :
+					ch -- ;
+					right [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 6 :
+					ch -- ;
+					right [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 5 :
+					ch -- ;
+					right [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 4 :
+					ch -- ;
+					right [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 3 :
+					ch -- ;
+					right [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 2 :
+					ch -- ;
+					right [ch] += icoeff * filter->buffer [data_index + ch] ;
+				case 1 :
+					ch -- ;
+					right [ch] += icoeff * filter->buffer [data_index + ch] ;
+				} ;
+			}
+		while (ch > 0) ;
+
+		filter_index -= increment ;
+		data_index = data_index - channels ;
+		}
+	while (filter_index > MAKE_INCREMENT_T (0)) ;
+
+	ch = channels ;
+	do
+	{
+		switch (ch % 8)
+		{	default :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 7 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 6 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 5 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 4 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 3 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 2 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			case 1 :
+				ch -- ;
+				output [ch] = scale * (left [ch] + right [ch]) ;
+			} ;
+		}
+	while (ch > 0) ;
+
+	return ;
+} /* calc_output_multi */
+
+static int
+sinc_multichan_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	SINC_FILTER *filter ;
+	double		input_index, src_ratio, count, float_increment, terminate, rem ;
+	increment_t	increment, start_filter_index ;
+	int			half_filter_chan_len, samples_in_hand ;
+
+	if (psrc->private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	filter = (SINC_FILTER*) psrc->private_data ;
+
+	/* If there is not a problem, this will be optimised out. */
+	if (sizeof (filter->buffer [0]) != sizeof (data->data_in [0]))
+		return SRC_ERR_SIZE_INCOMPATIBILITY ;
+
+	filter->in_count = data->input_frames * filter->channels ;
+	filter->out_count = data->output_frames * filter->channels ;
+	filter->in_used = filter->out_gen = 0 ;
+
+	src_ratio = psrc->last_ratio ;
+
+	/* Check the sample rate ratio wrt the buffer len. */
+	count = (filter->coeff_half_len + 2.0) / filter->index_inc ;
+	if (MIN (psrc->last_ratio, data->src_ratio) < 1.0)
+		count /= MIN (psrc->last_ratio, data->src_ratio) ;
+
+	/* Maximum coefficientson either side of center point. */
+	half_filter_chan_len = filter->channels * (lrint (count) + 1) ;
+
+	input_index = psrc->last_position ;
+	float_increment = filter->index_inc ;
+
+	rem = fmod_one (input_index) ;
+	filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+	input_index = rem ;
+
+	terminate = 1.0 / src_ratio + 1e-20 ;
+
+	/* Main processing loop. */
+	while (filter->out_gen < filter->out_count)
+	{
+		/* Need to reload buffer? */
+		samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+
+		if (samples_in_hand <= half_filter_chan_len)
+		{	if ((psrc->error = prepare_data (filter, data, half_filter_chan_len)) != 0)
+				return psrc->error ;
+
+			samples_in_hand = (filter->b_end - filter->b_current + filter->b_len) % filter->b_len ;
+			if (samples_in_hand <= half_filter_chan_len)
+				break ;
+			} ;
+
+		/* This is the termination condition. */
+		if (filter->b_real_end >= 0)
+		{	if (filter->b_current + input_index + terminate >= filter->b_real_end)
+				break ;
+			} ;
+
+		if (filter->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > 1e-10)
+			src_ratio = psrc->last_ratio + filter->out_gen * (data->src_ratio - psrc->last_ratio) / filter->out_count ;
+
+		float_increment = filter->index_inc * 1.0 ;
+		if (src_ratio < 1.0)
+			float_increment = filter->index_inc * src_ratio ;
+
+		increment = double_to_fp (float_increment) ;
+
+		start_filter_index = double_to_fp (input_index * float_increment) ;
+
+		calc_output_multi (filter, increment, start_filter_index, filter->channels, float_increment / filter->index_inc, data->data_out + filter->out_gen) ;
+		filter->out_gen += psrc->channels ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		filter->b_current = (filter->b_current + filter->channels * lrint (input_index - rem)) % filter->b_len ;
+		input_index = rem ;
+		} ;
+
+	psrc->last_position = input_index ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc->last_ratio = src_ratio ;
+
+	data->input_frames_used = filter->in_used / filter->channels ;
+	data->output_frames_gen = filter->out_gen / filter->channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* sinc_multichan_vari_process */
+
+/*----------------------------------------------------------------------------------------
+*/
+
+static int
+prepare_data (SINC_FILTER *filter, SRC_DATA *data, int half_filter_chan_len)
+{	int len = 0 ;
+
+	if (filter->b_real_end >= 0)
+		return 0 ;	/* Should be terminating. Just return. */
+
+	if (filter->b_current == 0)
+	{	/* Initial state. Set up zeros at the start of the buffer and
+		** then load new data after that.
+		*/
+		len = filter->b_len - 2 * half_filter_chan_len ;
+
+		filter->b_current = filter->b_end = half_filter_chan_len ;
+		}
+	else if (filter->b_end + half_filter_chan_len + filter->channels < filter->b_len)
+	{	/*  Load data at current end position. */
+		len = MAX (filter->b_len - filter->b_current - half_filter_chan_len, 0) ;
+		}
+	else
+	{	/* Move data at end of buffer back to the start of the buffer. */
+		len = filter->b_end - filter->b_current ;
+		memmove (filter->buffer, filter->buffer + filter->b_current - half_filter_chan_len,
+						(half_filter_chan_len + len) * sizeof (filter->buffer [0])) ;
+
+		filter->b_current = half_filter_chan_len ;
+		filter->b_end = filter->b_current + len ;
+
+		/* Now load data at current end of buffer. */
+		len = MAX (filter->b_len - filter->b_current - half_filter_chan_len, 0) ;
+		} ;
+
+	len = MIN (filter->in_count - filter->in_used, len) ;
+	len -= (len % filter->channels) ;
+
+	if  (len < 0 || filter->b_end + len > filter->b_len)
+		return SRC_ERR_SINC_PREPARE_DATA_BAD_LEN ;
+
+	memcpy (filter->buffer + filter->b_end, data->data_in + filter->in_used,
+						len * sizeof (filter->buffer [0])) ;
+
+	filter->b_end += len ;
+	filter->in_used += len ;
+
+	if (filter->in_used == filter->in_count &&
+			filter->b_end - filter->b_current < 2 * half_filter_chan_len && data->end_of_input)
+	{	/* Handle the case where all data in the current buffer has been
+		** consumed and this is the last buffer.
+		*/
+
+		if (filter->b_len - filter->b_end < half_filter_chan_len + 5)
+		{	/* If necessary, move data down to the start of the buffer. */
+			len = filter->b_end - filter->b_current ;
+			memmove (filter->buffer, filter->buffer + filter->b_current - half_filter_chan_len,
+							(half_filter_chan_len + len) * sizeof (filter->buffer [0])) ;
+
+			filter->b_current = half_filter_chan_len ;
+			filter->b_end = filter->b_current + len ;
+			} ;
+
+		filter->b_real_end = filter->b_end ;
+		len = half_filter_chan_len + 5 ;
+
+		memset (filter->buffer + filter->b_end, 0, len * sizeof (filter->buffer [0])) ;
+		filter->b_end += len ;
+		} ;
+
+	return 0 ;
+} /* prepare_data */
+
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_zoh.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_zoh.c	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_libsamplerate/src_zoh.c	2009-04-21 16:15:51 UTC (rev 4746)
@@ -1,214 +1,208 @@
-/*
-** Copyright (C) 2002-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; if not, write to the Free Software
-** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-/*
-** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
-** use license for this code is available, please see:
-**		http://www.mega-nerd.com/SRC/procedure.html
-*/
-#if 0 // MEANX
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "config.h"
-#else
-#include "ADM_default.h"
-#endif
-#include "float_cast.h"
-#include "common.h"
-
-static int zoh_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
-static void zoh_reset (SRC_PRIVATE *psrc) ;
-
-/*========================================================================================
-*/
-
-#define	ZOH_MAGIC_MARKER	MAKE_MAGIC ('s', 'r', 'c', 'z', 'o', 'h')
-
-typedef struct
-{	int		zoh_magic_marker ;
-	int		channels ;
-	int		reset ;
-	long	in_count, in_used ;
-	long	out_count, out_gen ;
-	float	last_value [1] ;
-} ZOH_DATA ;
-
-/*----------------------------------------------------------------------------------------
-*/
-
-static int
-zoh_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
-{	ZOH_DATA 	*zoh ;
-	double		src_ratio, input_index, rem ;
-	int			ch ;
-
-	if (psrc->private_data == NULL)
-		return SRC_ERR_NO_PRIVATE ;
-
-	zoh = (ZOH_DATA*) psrc->private_data ;
-
-	if (zoh->reset)
-	{	/* If we have just been reset, set the last_value data. */
-		for (ch = 0 ; ch < zoh->channels ; ch++)
-			zoh->last_value [ch] = data->data_in [ch] ;
-		zoh->reset = 0 ;
-		} ;
-
-	zoh->in_count = data->input_frames * zoh->channels ;
-	zoh->out_count = data->output_frames * zoh->channels ;
-	zoh->in_used = zoh->out_gen = 0 ;
-
-	src_ratio = psrc->last_ratio ;
-	input_index = psrc->last_position ;
-
-	/* Calculate samples before first sample in input array. */
-	while (input_index < 1.0 && zoh->out_gen < zoh->out_count)
-	{
-		if (zoh->in_used + zoh->channels * input_index >= zoh->in_count)
-			break ;
-
-		if (zoh->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > SRC_MIN_RATIO_DIFF)
-			src_ratio = psrc->last_ratio + zoh->out_gen * (data->src_ratio - psrc->last_ratio) / zoh->out_count ;
-
-		for (ch = 0 ; ch < zoh->channels ; ch++)
-		{	data->data_out [zoh->out_gen] = zoh->last_value [ch] ;
-			zoh->out_gen ++ ;
-			} ;
-
-		/* Figure out the next index. */
-		input_index += 1.0 / src_ratio ;
-		} ;
-
-	rem = fmod_one (input_index) ;
-	zoh->in_used += zoh->channels * lrint (input_index - rem) ;
-	input_index = rem ;
-
-	/* Main processing loop. */
-	while (zoh->out_gen < zoh->out_count && zoh->in_used + zoh->channels * input_index <= zoh->in_count)
-	{
-		if (zoh->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > SRC_MIN_RATIO_DIFF)
-			src_ratio = psrc->last_ratio + zoh->out_gen * (data->src_ratio - psrc->last_ratio) / zoh->out_count ;
-
-		for (ch = 0 ; ch < zoh->channels ; ch++)
-		{	data->data_out [zoh->out_gen] = data->data_in [zoh->in_used - zoh->channels + ch] ;
-			zoh->out_gen ++ ;
-			} ;
-
-		/* Figure out the next index. */
-		input_index += 1.0 / src_ratio ;
-		rem = fmod_one (input_index) ;
-
-		zoh->in_used += zoh->channels * lrint (input_index - rem) ;
-		input_index = rem ;
-		} ;
-
-	if (zoh->in_used > zoh->in_count)
-	{	input_index += (zoh->in_used - zoh->in_count) / zoh->channels ;
-		zoh->in_used = zoh->in_count ;
-		} ;
-
-	psrc->last_position = input_index ;
-
-	if (zoh->in_used > 0)
-		for (ch = 0 ; ch < zoh->channels ; ch++)
-			zoh->last_value [ch] = data->data_in [zoh->in_used - zoh->channels + ch] ;
-
-	/* Save current ratio rather then target ratio. */
-	psrc->last_ratio = src_ratio ;
-
-	data->input_frames_used = zoh->in_used / zoh->channels ;
-	data->output_frames_gen = zoh->out_gen / zoh->channels ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* zoh_vari_process */
-
-/*------------------------------------------------------------------------------
-*/
-
-const char*
-zoh_get_name (int src_enum)
-{
-	if (src_enum == SRC_ZERO_ORDER_HOLD)
-		return "ZOH Interpolator" ;
-
-	return NULL ;
-} /* zoh_get_name */
-
-const char*
-zoh_get_description (int src_enum)
-{
-	if (src_enum == SRC_ZERO_ORDER_HOLD)
-		return "Zero order hold interpolator, very fast, poor quality." ;
-
-	return NULL ;
-} /* zoh_get_descrition */
-
-int
-zoh_set_converter (SRC_PRIVATE *psrc, int src_enum)
-{	ZOH_DATA *zoh = NULL ;
-
-	if (src_enum != SRC_ZERO_ORDER_HOLD)
-		return SRC_ERR_BAD_CONVERTER ;
-
-	if (psrc->private_data != NULL)
-	{	zoh = (ZOH_DATA*) psrc->private_data ;
-		if (zoh->zoh_magic_marker != ZOH_MAGIC_MARKER)
-		{	free (psrc->private_data) ;
-			psrc->private_data = NULL ;
-			} ;
-		} ;
-
-	if (psrc->private_data == NULL)
-	{	zoh = calloc (1, sizeof (*zoh) + psrc->channels * sizeof (float)) ;
-		if (zoh == NULL)
-			return SRC_ERR_MALLOC_FAILED ;
-		psrc->private_data = zoh ;
-		} ;
-
-	zoh->zoh_magic_marker = ZOH_MAGIC_MARKER ;
-	zoh->channels = psrc->channels ;
-
-	psrc->const_process = zoh_vari_process ;
-	psrc->vari_process = zoh_vari_process ;
-	psrc->reset = zoh_reset ;
-
-	zoh_reset (psrc) ;
-
-	return SRC_ERR_NO_ERROR ;
-} /* zoh_set_converter */
-
-/*===================================================================================
-*/
-
-static void
-zoh_reset (SRC_PRIVATE *psrc)
-{	ZOH_DATA *zoh ;
-
-	zoh = (ZOH_DATA*) psrc->private_data ;
-	if (zoh == NULL)
-		return ;
-
-	zoh->channels = psrc->channels ;
-	zoh->reset = 1 ;
-	memset (zoh->last_value, 0, sizeof (zoh->last_value [0]) * zoh->channels) ;
-
-	return ;
-} /* zoh_reset */
-
+/*
+** Copyright (C) 2002-2008 Erik de Castro Lopo <erikd at mega-nerd.com>
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+/*
+** This code is part of Secret Rabibt Code aka libsamplerate. A commercial
+** use license for this code is available, please see:
+**		http://www.mega-nerd.com/SRC/procedure.html
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "config.h"
+#include "float_cast.h"
+#include "common.h"
+
+static int zoh_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data) ;
+static void zoh_reset (SRC_PRIVATE *psrc) ;
+
+/*========================================================================================
+*/
+
+#define	ZOH_MAGIC_MARKER	MAKE_MAGIC ('s', 'r', 'c', 'z', 'o', 'h')
+
+typedef struct
+{	int		zoh_magic_marker ;
+	int		channels ;
+	int		reset ;
+	long	in_count, in_used ;
+	long	out_count, out_gen ;
+	float	last_value [1] ;
+} ZOH_DATA ;
+
+/*----------------------------------------------------------------------------------------
+*/
+
+static int
+zoh_vari_process (SRC_PRIVATE *psrc, SRC_DATA *data)
+{	ZOH_DATA 	*priv ;
+	double		src_ratio, input_index, rem ;
+	int			ch ;
+
+	if (psrc->private_data == NULL)
+		return SRC_ERR_NO_PRIVATE ;
+
+	priv = (ZOH_DATA*) psrc->private_data ;
+
+	if (priv->reset)
+	{	/* If we have just been reset, set the last_value data. */
+		for (ch = 0 ; ch < priv->channels ; ch++)
+			priv->last_value [ch] = data->data_in [ch] ;
+		priv->reset = 0 ;
+		} ;
+
+	priv->in_count = data->input_frames * priv->channels ;
+	priv->out_count = data->output_frames * priv->channels ;
+	priv->in_used = priv->out_gen = 0 ;
+
+	src_ratio = psrc->last_ratio ;
+	input_index = psrc->last_position ;
+
+	/* Calculate samples before first sample in input array. */
+	while (input_index < 1.0 && priv->out_gen < priv->out_count)
+	{
+		if (priv->in_used + priv->channels * input_index >= priv->in_count)
+			break ;
+
+		if (priv->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > SRC_MIN_RATIO_DIFF)
+			src_ratio = psrc->last_ratio + priv->out_gen * (data->src_ratio - psrc->last_ratio) / priv->out_count ;
+
+		for (ch = 0 ; ch < priv->channels ; ch++)
+		{	data->data_out [priv->out_gen] = priv->last_value [ch] ;
+			priv->out_gen ++ ;
+			} ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		} ;
+
+	rem = fmod_one (input_index) ;
+	priv->in_used += priv->channels * lrint (input_index - rem) ;
+	input_index = rem ;
+
+	/* Main processing loop. */
+	while (priv->out_gen < priv->out_count && priv->in_used + priv->channels * input_index <= priv->in_count)
+	{
+		if (priv->out_count > 0 && fabs (psrc->last_ratio - data->src_ratio) > SRC_MIN_RATIO_DIFF)
+			src_ratio = psrc->last_ratio + priv->out_gen * (data->src_ratio - psrc->last_ratio) / priv->out_count ;
+
+		for (ch = 0 ; ch < priv->channels ; ch++)
+		{	data->data_out [priv->out_gen] = data->data_in [priv->in_used - priv->channels + ch] ;
+			priv->out_gen ++ ;
+			} ;
+
+		/* Figure out the next index. */
+		input_index += 1.0 / src_ratio ;
+		rem = fmod_one (input_index) ;
+
+		priv->in_used += priv->channels * lrint (input_index - rem) ;
+		input_index = rem ;
+		} ;
+
+	if (priv->in_used > priv->in_count)
+	{	input_index += (priv->in_used - priv->in_count) / priv->channels ;
+		priv->in_used = priv->in_count ;
+		} ;
+
+	psrc->last_position = input_index ;
+
+	if (priv->in_used > 0)
+		for (ch = 0 ; ch < priv->channels ; ch++)
+			priv->last_value [ch] = data->data_in [priv->in_used - priv->channels + ch] ;
+
+	/* Save current ratio rather then target ratio. */
+	psrc->last_ratio = src_ratio ;
+
+	data->input_frames_used = priv->in_used / priv->channels ;
+	data->output_frames_gen = priv->out_gen / priv->channels ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* zoh_vari_process */
+
+/*------------------------------------------------------------------------------
+*/
+
+const char*
+zoh_get_name (int src_enum)
+{
+	if (src_enum == SRC_ZERO_ORDER_HOLD)
+		return "ZOH Interpolator" ;
+
+	return NULL ;
+} /* zoh_get_name */
+
+const char*
+zoh_get_description (int src_enum)
+{
+	if (src_enum == SRC_ZERO_ORDER_HOLD)
+		return "Zero order hold interpolator, very fast, poor quality." ;
+
+	return NULL ;
+} /* zoh_get_descrition */
+
+int
+zoh_set_converter (SRC_PRIVATE *psrc, int src_enum)
+{	ZOH_DATA *priv = NULL ;
+
+	if (src_enum != SRC_ZERO_ORDER_HOLD)
+		return SRC_ERR_BAD_CONVERTER ;
+
+	if (psrc->private_data != NULL)
+	{	free (psrc->private_data) ;
+		psrc->private_data = NULL ;
+		} ;
+
+	if (psrc->private_data == NULL)
+	{	priv = calloc (1, sizeof (*priv) + psrc->channels * sizeof (float)) ;
+		if (priv == NULL)
+			return SRC_ERR_MALLOC_FAILED ;
+		psrc->private_data = priv ;
+		} ;
+
+	priv->zoh_magic_marker = ZOH_MAGIC_MARKER ;
+	priv->channels = psrc->channels ;
+
+	psrc->const_process = zoh_vari_process ;
+	psrc->vari_process = zoh_vari_process ;
+	psrc->reset = zoh_reset ;
+
+	zoh_reset (psrc) ;
+
+	return SRC_ERR_NO_ERROR ;
+} /* zoh_set_converter */
+
+/*===================================================================================
+*/
+
+static void
+zoh_reset (SRC_PRIVATE *psrc)
+{	ZOH_DATA *priv ;
+
+	priv = (ZOH_DATA*) psrc->private_data ;
+	if (priv == NULL)
+		return ;
+
+	priv->channels = psrc->channels ;
+	priv->reset = 1 ;
+	memset (priv->last_value, 0, sizeof (priv->last_value [0]) * priv->channels) ;
+
+	return ;
+} /* zoh_reset */
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-04-21 14:55:38 UTC (rev 4745)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-04-21 16:15:51 UTC (rev 4746)
@@ -9,14 +9,10 @@
 ADM_libsamplerate/src_sinc.c
 ADM_libsamplerate/src_zoh.c
 )	
-#*************************************************
+
 ADD_DEFINITIONS(-DADM_LEGACY_PROGGY)
-ADD_DEFINITIONS(-DHAVE_LRINT -DHAVE_LRINTF)
-ADD_DEFINITIONS(-DCPU_CLIPS_POSITIVE=0 -DCPU_CLIPS_NEGATIVE=0)
 ADD_DEFINITIONS(-I${CMAKE_CURRENT_SOURCE_DIR})
-ADD_DEFINITIONS(-DPACKAGE="SRC")
-ADD_DEFINITIONS(-DVERSION="0.1.4")
-#*************************************************
+
 ADD_LIBRARY(ADM_coreAudio SHARED ${ADMaudioCore_SRCS})
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
 TARGET_LINK_LIBRARIES(ADM_coreAudio ADM_core)



From mean at mail.berlios.de  Tue Apr 21 20:04:12 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 21 Apr 2009 20:04:12 +0200
Subject: [Avidemux-svn-commit] r4747 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904211804.n3LI4C0b031282@sheep.berlios.de>

Author: mean
Date: 2009-04-21 20:04:12 +0200 (Tue, 21 Apr 2009)
New Revision: 4747

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
Log:
[TsDemux] Write and Read video part of Ts file (mpeg2 only)

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-21 16:15:51 UTC (rev 4746)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-21 18:04:12 UTC (rev 4747)
@@ -37,57 +37,60 @@
     uint32_t append;
     char *type;
     uint64_t startDts;
+    
 
     sprintf(idxName,"%s.idx",name);
     indexFile index;
     if(!index.open(idxName))
     {
-        printf("[psDemux] Cannot open index file %s\n",idxName);
+        printf("[tsDemux] Cannot open index file %s\n",idxName);
         return false;
     }
     if(!index.readSection("System"))
     {
-        printf("[psDemux] Cannot read system section\n");
+        printf("[tsDemux] Cannot read system section\n");
         goto abt;
     }
     type=index.getAsString("Type");
     if(!type || type[0]!='T')
     {
-        printf("[psDemux] Incorrect or not found type\n");
+        printf("[tsDemux] Incorrect or not found type\n");
         goto abt;
     }
     append=index.getAsUint32("Append");
-    printf("[psDemux] Append=%"LU"\n",append);
+    printf("[tsDemux] Append=%"LU"\n",append);
     if(append) appendType=FP_APPEND;
     if(!parser.open(name,&appendType))
     {
-        printf("[psDemux] Cannot open root file\n",name);
+        printf("[tsDemux] Cannot open root file\n",name);
         goto abt;
     }
     if(!readVideo(&index)) 
     {
-        printf("[psDemux] Cannot read Video section of %s\n",idxName);
+        printf("[tsDemux] Cannot read Video section of %s\n",idxName);
         goto abt;
     }
+#if 0
     if(!readAudio(&index,name)) 
     {
-        printf("[psDemux] Cannot read Audio section of %s => No audio\n",idxName);
+        printf("[tsDemux] Cannot read Audio section of %s => No audio\n",idxName);
     }
+#endif
     if(!readIndex(&index))
     {
-        printf("[psDemux] Cannot read index for file %s\n",idxName);
+        printf("[tsDemux] Cannot read index for file %s\n",idxName);
         goto abt;
     }
     updatePtsDts();
     _videostream.dwLength= _mainaviheader.dwTotalFrames=ListOfFrames.size();
-    printf("[psDemux] Found %d video frames\n",_videostream.dwLength);
+    printf("[tsDemux] Found %d video frames\n",_videostream.dwLength);
     if(_videostream.dwLength)_isvideopresent=1;
 //***********
     
-    tsPacket=new tsPacketLinear(0xE0);
+    tsPacket=new tsPacketLinear(videoPid);
     if(tsPacket->open(name,appendType)==false) 
     {
-        printf("psDemux] Cannot tsPacket open the file\n");
+        printf("tsDemux] Cannot tsPacket open the file\n");
         goto abt;
     }
     r=true;
@@ -105,7 +108,7 @@
     }
 abt:
     index.close();
-    printf("[psDemuxer] Loaded %d\n",r);
+    printf("[tsDemuxer] Loaded %d\n",r);
     return r;
 }
 /**
@@ -195,6 +198,7 @@
 { 
     interlaced=false;
     lastFrame=0xffffffff;
+    videoPid=0;
     
 }
 /**
@@ -298,7 +302,7 @@
              return r;
 
     }
-    printf(" [PsDemux] lastFrame :%d this frame :%d\n",lastFrame,frame);
+    printf(" [tsDemux] lastFrame :%d this frame :%d\n",lastFrame,frame);
     return false;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-21 16:15:51 UTC (rev 4746)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-21 18:04:12 UTC (rev 4747)
@@ -141,6 +141,7 @@
     bool            updatePtsDts(void);
 protected:
     vector <ADM_tsTrackDescriptor *>listOfAudioTracks;
+    uint32_t        videoPid;             
   public:
 
 

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-21 16:15:51 UTC (rev 4746)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-21 18:04:12 UTC (rev 4747)
@@ -174,7 +174,13 @@
     w=index->getAsUint32("Width");
     h=index->getAsUint32("height");
     fps=index->getAsUint32("Fps");
-
+    videoPid=index->getAsUint32("Pid");
+    if(!videoPid)
+    {
+        printf("[tsDemux] Cannot find Pid\n");
+        return false;
+    }
+    printf("[tsDemux] Video pid is 0x%x %d\n",videoPid,videoPid);
     if(!w || !h || !fps) return false;
 
     interlaced=index->getAsUint32("Interlaced");

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 16:15:51 UTC (rev 4746)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:12 UTC (rev 4747)
@@ -212,6 +212,9 @@
     }
     memcpy(pkt->payload,start,size);
     pkt->payloadSize=size;
+    uint64_t pos;
+    _file->getpos(&pos);
+    pkt->startAt=pos-extraCrap-TS_PACKET_LEN;
     return true;
 }
 
@@ -319,7 +322,8 @@
     zprintf("[TS Demuxer] Code=0x%x pid=0x%x\n",code,pes->pid);
     if((code&0xffffff00)!=0x100)
     {
-        printf("[Ts Demuxer] No PES startcode\n");
+        printf("[Ts Demuxer] No PES startcode at 0x%"LLX"\n",pkt.startAt);
+        printf("0x:%02x %02x %02x %02x\n",pkt.payload[4],pkt.payload[5],pkt.payload[6],pkt.payload[7]);
         goto nextPack3;
     }
     //mixDump(pkt.payload,pkt.payloadSize);
@@ -328,6 +332,7 @@
     
     pes->payloadSize=0;
     pes->addData(pkt.payloadSize,pkt.payload);
+    pes->startAt=pkt.startAt;
     while(1)
     {
         uint64_t pos;
@@ -357,6 +362,7 @@
     //
     printf("[Ts Demuxer] Found PES of len %d\n",pes->payloadSize);  
     pes->fresh=true;
+    
     return true;
 }
 /**
@@ -492,7 +498,7 @@
 // In case a startcode spawns across 2 packets
 // we have to keep track of the old one
         oldBufferDts=pesPacket->dts;
-        oldBufferPts=pesPacket->dts;
+        oldBufferPts=pesPacket->pts;
         oldStartAt=pesPacket->startAt;
         oldBufferLen=pesPacket->payloadSize;
         if(false==getNextPES(pesPacket))
@@ -580,6 +586,7 @@
 */
 bool    tsPacketLinear::read(uint32_t len, uint8_t *out)
 {
+    printf("[tsRead] Size 0x%x %d\n",len,len);
     // Enough already ?
     while(len)
     {



From mean at mail.berlios.de  Tue Apr 21 20:04:14 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 21 Apr 2009 20:04:14 +0200
Subject: [Avidemux-svn-commit] r4748 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904211804.n3LI4Epn031293@sheep.berlios.de>

Author: mean
Date: 2009-04-21 20:04:14 +0200 (Tue, 21 Apr 2009)
New Revision: 4748

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
Log:
[TsDemuxer] Cosmetic

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:12 UTC (rev 4747)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:14 UTC (rev 4748)
@@ -301,7 +301,11 @@
 
 bool        tsPacket::getNextPES(TS_PESpacket *pes)
 {
+#if 1
+#define zprintf(...) {}
+#else
 #define zprintf printf
+#endif
     TSpacketInfo pkt;
     pes->fresh=false;
 nextPack3:
@@ -322,8 +326,8 @@
     zprintf("[TS Demuxer] Code=0x%x pid=0x%x\n",code,pes->pid);
     if((code&0xffffff00)!=0x100)
     {
-        printf("[Ts Demuxer] No PES startcode at 0x%"LLX"\n",pkt.startAt);
-        printf("0x:%02x %02x %02x %02x\n",pkt.payload[4],pkt.payload[5],pkt.payload[6],pkt.payload[7]);
+        zprintf("[Ts Demuxer] No PES startcode at 0x%"LLX"\n",pkt.startAt);
+        zprintf("0x:%02x %02x %02x %02x\n",pkt.payload[4],pkt.payload[5],pkt.payload[6],pkt.payload[7]);
         goto nextPack3;
     }
     //mixDump(pkt.payload,pkt.payloadSize);
@@ -355,12 +359,12 @@
     //____________________
     // Now decode PES header (extra memcpy)
     //____________________
-    printf("[Ts Demuxer] Full size :%d\n",pes->payloadSize);
+    zprintf("[Ts Demuxer] Full size :%d\n",pes->payloadSize);
     if(false==decodePesHeader(pes))
         goto nextPack3;
 
     //
-    printf("[Ts Demuxer] Found PES of len %d\n",pes->payloadSize);  
+    zprintf("[Ts Demuxer] Found PES of len %d\n",pes->payloadSize);  
     pes->fresh=true;
     
     return true;
@@ -451,14 +455,17 @@
         pes->offset=start-pes->payload;
         if(packLen)
         {
-            if(packLen<maxLen) maxLen=packLen;
+            //printf("***Zimbla***\n");
+            if(packLen<maxLen) 
+            {
+                maxLen=packLen;
+            }
             else
                 if(packLen>maxLen)
                 {
                     fail("Pes too long");
                 }   
         }
-        pes->payloadSize=maxLen;
         return true;
 }
 /**
@@ -586,7 +593,9 @@
 */
 bool    tsPacketLinear::read(uint32_t len, uint8_t *out)
 {
+#if 0
     printf("[tsRead] Size 0x%x %d\n",len,len);
+#endif
     // Enough already ?
     while(len)
     {



From mean at mail.berlios.de  Tue Apr 21 20:04:16 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 21 Apr 2009 20:04:16 +0200
Subject: [Avidemux-svn-commit] r4749 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904211804.n3LI4GIR031304@sheep.berlios.de>

Author: mean
Date: 2009-04-21 20:04:16 +0200 (Tue, 21 Apr 2009)
New Revision: 4749

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Log:
[TsDemuxer] Skeleton to index audio also

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-21 18:04:14 UTC (rev 4748)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-21 18:04:16 UTC (rev 4749)
@@ -88,8 +88,8 @@
 {
 protected:
         FILE *index;
-        tsPacketLinear       *pkt;
-        listOfTsAudioTracks  *audioTracks;
+        tsPacketLinearTracker  *pkt;
+        listOfTsAudioTracks    *audioTracks;
         DIA_workingBase  *ui;
 public:
                 TsIndexer(void);
@@ -182,7 +182,7 @@
         return false;
     }
     writeSystem(file,true);
-    pkt=new tsPacketLinear(Tracks[0].trackPid);
+    pkt=new tsPacketLinearTracker(nbTracks, Tracks);
 
     FP_TYPE append=FP_APPEND;
     pkt->open(file,append);

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:14 UTC (rev 4748)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:16 UTC (rev 4749)
@@ -686,5 +686,47 @@
     return true;
 }
 /* ********************************************************* */
+/**
+    \fn tsPacketLinearTracker
+*/
+tsPacketLinearTracker::tsPacketLinearTracker(uint32_t nb,ADM_TS_TRACK *tracks) : tsPacketLinear(tracks[0].trackPid)
+{
+    otherPes=new TS_PESpacket(0);
+    ADM_assert(nb);
+    totalTracks=nb;
+    if(!nb)    
+    {
+        this->stats=NULL;
+        return;
+    }
 
+    // Convert ADM_TS_TRACKS to ststa
+    stats=new packetTSStats[nb];    
+    memset(stats,0,sizeof(packetTSStats)*nb);
+    for(int i=0;i<nb;i++)
+    {
+        stats[i].pid=tracks[i].trackPid;
+        stats[i].startDts=ADM_NO_PTS;
+    }
+}
+/**
+    \fn ~tsPacketLinearTracker
+*/
+tsPacketLinearTracker::~tsPacketLinearTracker()
+{
+    if(otherPes) delete otherPes;
+    otherPes=NULL;
+    if(stats) delete [] stats;
+    stats=NULL;
+}
+/**
+    \fn tsPacketLinearTracker
+*/
+bool    tsPacketLinearTracker::getStats(uint32_t *nb,packetTSStats *stats)
+{
+    *nb=totalTracks;
+    stats=this->stats;
+    return true;
+}
+
 //EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-21 18:04:14 UTC (rev 4748)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-21 18:04:16 UTC (rev 4749)
@@ -9,6 +9,7 @@
 #define DMXtsPacket_H
 
 #include "dmxPacket.h"
+#include "ADM_tsPatPmt.h"
 #include "ADM_Video.h"
 
 #define TS_MARKER       0x47
@@ -147,10 +148,11 @@
 };
 
 /**
-    \class tsPacketLinearTracker
+    \class packetTSStats
 */
 typedef struct
 {
+    uint32_t pid;
     uint32_t count;
     uint32_t size;
     
@@ -158,7 +160,22 @@
     uint32_t startCount;
     uint32_t startSize;
     uint64_t startDts;
-}packetStats;
+}packetTSStats;
 
-
+/**
+        \class tsPacketLinearTracker
+        \brieg similar to tsPacketLinear, but also keeps stat of others tracks. Needed to index audio
+*/
+class tsPacketLinearTracker : public tsPacketLinear
+{
+protected:
+        TS_PESpacket *pesPacket;
+        TS_PESpacket *otherPes;
+        packetTSStats *stats;
+        uint32_t      totalTracks;
+public:
+                tsPacketLinearTracker(uint32_t nb,ADM_TS_TRACK *tracks);
+                ~tsPacketLinearTracker();
+        bool    getStats(uint32_t *nb,packetTSStats *stats);
+};
 #endif



From mean at mail.berlios.de  Tue Apr 21 20:04:22 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 21 Apr 2009 20:04:22 +0200
Subject: [Avidemux-svn-commit] r4751 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904211804.n3LI4Msm031329@sheep.berlios.de>

Author: mean
Date: 2009-04-21 20:04:21 +0200 (Tue, 21 Apr 2009)
New Revision: 4751

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
Log:
[TS indexer] Framework to handle audio

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-21 18:04:20 UTC (rev 4750)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-21 18:04:21 UTC (rev 4751)
@@ -51,7 +51,7 @@
         
         
         // dont even try if it is not audio
-        if(trackInfo->trackType!=ADM_TS_MPEG2 &&trackInfo->trackType!=ADM_TS_AC3) return false;
+        if(trackInfo->trackType!=ADM_TS_MPEG_AUDIO &&trackInfo->trackType!=ADM_TS_AC3) return false;
 
         // Go back where we were
         p->changePid(trackInfo->esId); 
@@ -66,7 +66,7 @@
         uint32_t fq,br,chan,off;
         switch(trackInfo->trackType)
         {
-            case ADM_TS_MPEG2: // MP2
+            case ADM_TS_MPEG_AUDIO: // MP2
                             {
                                 if(! tsCheckMp2Audio(&(trackInfo->wav),audioBuffer,rd))
                                 {

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-21 18:04:20 UTC (rev 4750)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-21 18:04:21 UTC (rev 4751)
@@ -111,7 +111,7 @@
 
     ADM_TS_TRACK *tracks;
     uint32_t nbTracks;
-    listOfTsAudioTracks *audioTrack;
+    listOfTsAudioTracks audioTrack;
 
     if(TS_scanForPrograms(file,&nbTracks,&tracks)==false) 
     {
@@ -127,19 +127,23 @@
     for(int i=1;i<nbTracks;i++)
     {
         tsAudioTrackInfo trk;
+        trk.esId=tracks[i].trackPid;
+        trk.trackType=tracks[i].trackType;
         if(true==tsGetAudioInfo(p,&trk))
         {
-                
+              audioTrack.push_back(trk);  
         }
     }
     delete p;
-    printf("[TsIndexer] Audio probed, doing video\n");
+    printf("[TsIndexer] Audio probed, %d found, doing video\n",(int)audioTrack.size());
     //
-    TsIndexer *dx=new TsIndexer(audioTrack);
+    TsIndexer *dx=new TsIndexer(&audioTrack);
     switch(tracks[0].trackType)
     {
-    case ADM_TS_MPEG2: r=dx->runMpeg2(file,&(tracks[0]));break;
-    default:
+            case ADM_TS_MPEG2: 
+                            r=dx->runMpeg2(file,&(tracks[0]));
+                            break;
+            default:
                         r=0;
                         break;
     }

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-21 18:04:20 UTC (rev 4750)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-21 18:04:21 UTC (rev 4751)
@@ -138,15 +138,7 @@
     }
     {
         //
-    #if 0 // TO REMOVE
-        TS_PESpacket pes(list[videoIndex].trackPid);
-        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
-        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
-        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
-        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
-        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
-        t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
-    #endif
+ 
         // After here we cannot fail (normally...)
         tracks=new ADM_TS_TRACK[list.size()];
         *outTracks=tracks;
@@ -156,7 +148,7 @@
         list.erase(list.begin()+videoIndex);
         nb++;
         // Also add audio tracks we know of
-         for(int i=0;i<list.size();i++)
+        for(int i=0;i<list.size();i++)
         {
             ADM_TS_TRACK_TYPE type=list[i].trackType;
             if(type==ADM_TS_MPEG_AUDIO || type==ADM_TS_AC3 || type==ADM_TS_AAC)

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:20 UTC (rev 4750)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:21 UTC (rev 4751)
@@ -463,6 +463,7 @@
             else
                 if(packLen>maxLen)
                 {
+                    printf("[TS Packet] PackLen=%d, avalailble=%d\n",packLen,maxLen);
                     fail("Pes too long");
                 }   
         }



From mean at mail.berlios.de  Tue Apr 21 20:04:20 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 21 Apr 2009 20:04:20 +0200
Subject: [Avidemux-svn-commit] r4750 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904211804.n3LI4KrR031319@sheep.berlios.de>

Author: mean
Date: 2009-04-21 20:04:20 +0200 (Tue, 21 Apr 2009)
New Revision: 4750

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Log:
[TsDemuxer] Probe audio

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-21 18:04:16 UTC (rev 4749)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-04-21 18:04:20 UTC (rev 4750)
@@ -35,166 +35,73 @@
 #define LPCM_AUDIO_VALUE 0xA0
 #define DTS_AC3_AUDIO_VALUE 0x00
 
-static bool addAudioTrack(int pid, listOfTsAudioTracks *list, tsPacketLinear *p);
+bool tsGetAudioInfo(tsPacketLinear *p,tsAudioTrackInfo *trackInfo);
 static bool tsCheckMp2Audio(WAVHeader *hdr, uint8_t *data, uint32_t dataSize);
-/**
-    \fn listOfPsAudioTracks
-    \brief returns a list of audio track found, null if none found
 
-*/
-listOfTsAudioTracks *tsProbeAudio(const char *fileName)
-{
-    uint32_t size;
-    uint64_t dts,pts,startAt;
-    uint8_t buffer[PACKET_PROBE_SIZE];
-    uint64_t fileSize;
-
-    listOfTsAudioTracks *tracks=new listOfTsAudioTracks;
-    tsPacketLinear *packet=new tsPacketLinear(0xE0);
-
-    printf("[MpegPS] Probing audio for %s\n",fileName);
-
-    if(!packet->open(fileName,FP_APPEND)) goto end;
-    fileSize=packet->getSize();
-
-    packet->setPos(fileSize/2); // Jump in the middle of the stream
-#if 0
-    while(packet->getPacketOfType(0xE0,PACKET_PROBE_SIZE,&size,&dts,&pts,buffer,&startAt))
-    {
-
-        packetStats *stat=packet->getStat(0xE0);
-        if(stat->count > PROBE_PACKET_VIDEO_COUNT)
-                break;
-
-    }
-    // Now synthetize
-    for(int i=0x0;i<0xFF;i++)   
-    {
-        packetStats *stat=packet->getStat(i);
-        if(stat->count)
-        {
-            printf("[PsProbeAudo] Pid:%x count:%"LX" size:%"LD"\n",i,stat->count,stat->size);
-        }
-
-         if(stat->count>=PROBE_MIN_PACKET && stat->size>PROBE_MIN_SIZE)
-         {
-                packet->setPos(fileSize/2); 
-                addAudioTrack(i,tracks,packet);
-         }
-
-    }
-#endif
-end:
-    printf("[PsDemux] Audio probe done, found %lu tracks\n",tracks->size());
-    delete packet;
-    
-    if(tracks->size()==0) 
-    {   
-        delete tracks;
-        return NULL;
-    }
-    return tracks;
-}
 /**
     \fn addAudioTrack
     \brief gather information about audio & add audio track to the list
 
 */
-bool addAudioTrack(int pid, listOfTsAudioTracks *list, tsPacketLinear *p)
+bool tsGetAudioInfo(tsPacketLinear *p,tsAudioTrackInfo *trackInfo)
 {
 #define PROBE_ANALYZE_SIZE 6000 // Should be enough in all cases (need ~ 2 blocks)
 uint8_t audioBuffer[PROBE_ANALYZE_SIZE];
-        uint64_t pts,dts,startAt;
-        uint32_t packetSize;
+uint64_t pts,dts,startAt;
+        
+        
+        // dont even try if it is not audio
+        if(trackInfo->trackType!=ADM_TS_MPEG2 &&trackInfo->trackType!=ADM_TS_AC3) return false;
 
-        //
-        int masked=pid&0xF0;
-        if(masked!=MP2_AUDIO_VALUE &&  // MP2
-            masked!=LPCM_AUDIO_VALUE && // PCM
-            masked!=DTS_AC3_AUDIO_VALUE  // AC3 & DTS
-            ) return false;
-
         // Go back where we were
-        p->changePid(pid); 
-        p->getPacketOfType(pid,PROBE_ANALYZE_SIZE, &packetSize,&pts,&dts,audioBuffer,&startAt);
+        p->changePid(trackInfo->esId); 
         //Realign
-        p->seek(startAt,0);
+        p->seek(0,0);
         int rd=PROBE_ANALYZE_SIZE;
         if(!p->read(PROBE_ANALYZE_SIZE,audioBuffer))
+        {
+            printf("[tsAudioProbe] Cannot get info about pid %d 0x%x\n",trackInfo->esId,trackInfo->esId);
             return false;
-        tsAudioTrackInfo *info=new tsAudioTrackInfo;
-        info->esID=pid;
+        }
         uint32_t fq,br,chan,off;
-        switch(pid & 0xF0)
+        switch(trackInfo->trackType)
         {
-            case LPCM_AUDIO_VALUE: // LPCM
-                            info->header.frequency=48000;
-                            info->header.channels=2;
-                            info->header.byterate=48000*4;
-                            info->header.encoding=WAV_LPCM;
-                            break;
-            case MP2_AUDIO_VALUE: // MP2
+            case ADM_TS_MPEG2: // MP2
                             {
-                                if(! tsCheckMp2Audio(&(info->header),audioBuffer,rd))
+                                if(! tsCheckMp2Audio(&(trackInfo->wav),audioBuffer,rd))
                                 {
-                                    printf("[PsProbeAudio] Failed to get info on track :%x (MP2)\n",pid);
+                                    printf("[PsProbeAudio] Failed to get info on track :%x (MP2)\n",trackInfo->esId);
                                     goto er;
                                 }
                             }
                             break;
-            case DTS_AC3_AUDIO_VALUE: // AC3 or DTS
-                            if(pid>=0x8) // DTS
+            case ADM_TS_AC3: // AC3 or DTS
+                            // AC3
                             {
-                                info->header.encoding=WAV_DTS;
-                                uint32_t flags,nbSample;
-                                if(!ADM_DCAGetInfo(audioBuffer, rd, &fq, &br, &chan,&off,&flags,&nbSample))
-                                {
-                                        printf("[PsProbeAudio] Failed to get info on track :%x\n",pid);
-                                        goto er;
-                                }
-                                info->header.frequency=fq;
-                                info->header.channels=chan;
-                                info->header.byterate=(br);
-                                break;
-                            }else // AC3
-                            {
-                                info->header.encoding=WAV_AC3;
+                                trackInfo->wav.encoding=WAV_AC3;
                                 if(!ADM_AC3GetInfo(audioBuffer, rd, &fq, &br, &chan,&off))
                                 {
-                                        printf("[PsProbeAudio] Failed to get info on track :%x\n",pid);
+                                        printf("[PsProbeAudio] Failed to get info on track :%x\n",trackInfo->esId);
                                         goto er;
                                 }
-                                info->header.frequency=fq;
-                                info->header.channels=chan;
-                                info->header.byterate=(br);
+                                trackInfo->wav.frequency=fq;
+                                trackInfo->wav.channels=chan;
+                                trackInfo->wav.byterate=(br);
                                 break;
                             }
                             
             default:
-                        ADM_assert(0);
+                        printf("[tsAudioProbe] Unsupported audio format pid %d 0x%x\n",trackInfo->esId,trackInfo->esId);
+                        return false;
 
         }
-        list->push_back(info);
         return true;
 er:
-        delete info;
         return false;
+
 }
+
 /**
-        \fn DestroyListOfPsAudioTracks
-        \brief cleanly destroy it
-*/
-bool DestroyListOfTsAudioTracks(listOfTsAudioTracks *list)
-{
-    while( list->size())
-    {
-        delete (*list)[0];
-        list->erase(list->begin());
-    }
-    delete list;
-    return true;
-}
-/**
     \fn psCheckMp2Audio
     \brief Wait to have 2 audio packets to make sure it is not a false detection (that happens with mp2/mp3 audio)
 */

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-21 18:04:16 UTC (rev 4749)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.h	2009-04-21 18:04:20 UTC (rev 4750)
@@ -16,19 +16,9 @@
  ***************************************************************************/
 #ifndef ADM_TS_AUDIO_PROBE_H
 #define ADM_TS_AUDIO_PROBE_H
-#include <vector>
-using std::vector;
-typedef struct
-{
-    WAVHeader header;
-    uint32_t  esID;
-}tsAudioTrackInfo;
+#include "ADM_tsPatPmt.h"
 
-typedef vector <tsAudioTrackInfo*> listOfTsAudioTracks;
+// Get infos about one audio track
+bool tsGetAudioInfo(tsPacketLinear *p,tsAudioTrackInfo *trackInfo);
 
-/// Returns a list of audio tracks found in the file.
-listOfTsAudioTracks *tsProbeAudio(const char *fileName);
-bool DestroyListOfTsAudioTracks(listOfTsAudioTracks *list);
-
-
 #endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-21 18:04:16 UTC (rev 4749)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-21 18:04:20 UTC (rev 4750)
@@ -92,9 +92,9 @@
         listOfTsAudioTracks    *audioTracks;
         DIA_workingBase  *ui;
 public:
-                TsIndexer(void);
+                TsIndexer(listOfTsAudioTracks *tr);
                 ~TsIndexer();
-        bool    run(const char *file,uint32_t nbTracks, ADM_TS_TRACK *Tracks);
+        bool    runMpeg2(const char *file,ADM_TS_TRACK *videoTrac);
         bool    writeVideo(PSVideo *video);
         bool    writeAudio(void);
         bool    writeSystem(const char *filename,bool append);
@@ -111,6 +111,7 @@
 
     ADM_TS_TRACK *tracks;
     uint32_t nbTracks;
+    listOfTsAudioTracks *audioTrack;
 
     if(TS_scanForPrograms(file,&nbTracks,&tracks)==false) 
     {
@@ -119,10 +120,29 @@
     }
     ADM_assert(tracks);
     ADM_assert(nbTracks);
-    
-
-    TsIndexer *dx=new TsIndexer;
-    r=dx->run(file,nbTracks,tracks);
+    //
+    // Now extract the datas from audio tracks & verify they are here
+    tsPacketLinear *p=new tsPacketLinear(0);
+    p->open(file,FP_DONT_APPEND);
+    for(int i=1;i<nbTracks;i++)
+    {
+        tsAudioTrackInfo trk;
+        if(true==tsGetAudioInfo(p,&trk))
+        {
+                
+        }
+    }
+    delete p;
+    printf("[TsIndexer] Audio probed, doing video\n");
+    //
+    TsIndexer *dx=new TsIndexer(audioTrack);
+    switch(tracks[0].trackType)
+    {
+    case ADM_TS_MPEG2: r=dx->runMpeg2(file,&(tracks[0]));break;
+    default:
+                        r=0;
+                        break;
+    }
     delete dx;
     delete [] tracks;
     return r;
@@ -131,12 +151,13 @@
 /**
     \fn TsIndexer
 */
-TsIndexer::TsIndexer(void)
+TsIndexer::TsIndexer(listOfTsAudioTracks *trk)
 {
     index=NULL;
     pkt=NULL;
     audioTracks=NULL;
     ui=createWorking ("Indexing");
+    audioTracks=trk;
 }
 
 /**
@@ -146,14 +167,13 @@
 {
     if(index) qfclose(index);
     if(pkt) delete pkt;
-    if( audioTracks) DestroyListOfTsAudioTracks(audioTracks);
     if(ui) delete ui;
     ui=NULL;
 }
 /**
     \fn run
 */  
-bool TsIndexer::run(const char *file,uint32_t nbTracks, ADM_TS_TRACK *Tracks)
+bool TsIndexer::runMpeg2(const char *file,ADM_TS_TRACK *videoTrac)
 {
 uint32_t temporal_ref,val;
 uint64_t fullSize;
@@ -164,13 +184,13 @@
 indexerData  data;    
 dmxPacketInfo info;
 
-    if(!nbTracks) return false;
-    if(Tracks[0].trackType!=ADM_TS_MPEG2)
+    if(!videoTrac) return false;
+    if(videoTrac[0].trackType!=ADM_TS_MPEG2)
     {
         printf("[Ts Indexer] Only Mpeg2 video supported\n");
         return false;
     }
-    video.pid=Tracks[0].trackPid;
+    video.pid=videoTrac[0].trackPid;
 
     memset(&data,0,sizeof(data));
     char indexName[strlen(file)+5];
@@ -182,7 +202,7 @@
         return false;
     }
     writeSystem(file,true);
-    pkt=new tsPacketLinearTracker(nbTracks, Tracks);
+    pkt=new tsPacketLinearTracker(videoTrac->trackPid, audioTracks);
 
     FP_TYPE append=FP_APPEND;
     pkt->open(file,append);
@@ -224,7 +244,7 @@
                           video.fps= FPS[val & 0xf];
                           pkt->forward(4);
                           writeVideo(&video);
-                          //writeAudio();
+                          writeAudio();
                           //pkt->resetStats();
                           qfprintf(index,"[Data]");
                           break;
@@ -288,7 +308,6 @@
         qfprintf(index,"\n[End]\n");
         qfclose(index);
         index=NULL;
-        if(audioTracks) DestroyListOfTsAudioTracks( audioTracks);
         audioTracks=NULL;
         delete pkt;
         pkt=NULL;
@@ -400,13 +419,13 @@
     for(int i=0;i<audioTracks->size();i++)
     {
         char head[30];
-        tsAudioTrackInfo *t=(*audioTracks)[i];
+        tsAudioTrackInfo *t=&(*audioTracks)[i];
         sprintf(head,"Track%1d",i);
-        qfprintf(index,"%s.pid=%x\n",head,t->esID);
-        qfprintf(index,"%s.codec=%d\n",head,t->header.encoding);
-        qfprintf(index,"%s.fq=%d\n",head,t->header.frequency);
-        qfprintf(index,"%s.chan=%d\n",head,t->header.channels);
-        qfprintf(index,"%s.br=%d\n",head,t->header.byterate);
+        qfprintf(index,"%s.pid=%x\n",head,t->esId);
+        qfprintf(index,"%s.codec=%d\n",head,t->wav.encoding);
+        qfprintf(index,"%s.fq=%d\n",head,t->wav.frequency);
+        qfprintf(index,"%s.chan=%d\n",head,t->wav.channels);
+        qfprintf(index,"%s.br=%d\n",head,t->wav.byterate);
     }
     return true;
 }

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-21 18:04:16 UTC (rev 4749)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-21 18:04:20 UTC (rev 4750)
@@ -138,7 +138,7 @@
     }
     {
         //
-    #if 1 // TO REMOVE
+    #if 0 // TO REMOVE
         TS_PESpacket pes(list[videoIndex].trackPid);
         t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);
         t->getNextPES(&pes);printf("pts :%lld dts:%lld\n",pes.pts,pes.dts);

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h	2009-04-21 18:04:16 UTC (rev 4749)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h	2009-04-21 18:04:20 UTC (rev 4750)
@@ -17,7 +17,7 @@
  ***************************************************************************/
 #ifndef ADM_TS_PAT_PMT_H
 #define ADM_TS_PAT_PMT_H
-
+#include "ADM_audiodef.h"
 #define ADM_TS_MAX_EXTRADATA 256
 /**
     \typedef ADM_TS_VIDEO_TYPE
@@ -42,7 +42,21 @@
     uint8_t           extraData[ADM_TS_MAX_EXTRADATA];
 }ADM_TS_TRACK;
 
+/**
+    \struct tsAudioTrackInfo
+*/
+typedef struct
+{
+    WAVHeader         wav;
+    uint32_t          esId;
+    ADM_TS_TRACK_TYPE trackType;
+    uint32_t          extraDataLen;
+    uint8_t           extraData[ADM_TS_MAX_EXTRADATA];
+}tsAudioTrackInfo;
 
+typedef vector <tsAudioTrackInfo > listOfTsAudioTracks;
+
+
 /**
     \fn TS_scanForPrograms
     \brief Analyze a stream and returns tracks within

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:16 UTC (rev 4749)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:20 UTC (rev 4750)
@@ -681,7 +681,7 @@
 */
 bool    tsPacketLinear::changePid(uint32_t pid) 
 {
-    pesPacket->pid=(pid&0xff);
+    pesPacket->pid=pid;
     pesPacket->offset=pesPacket->payloadSize;
     return true;
 }
@@ -689,10 +689,10 @@
 /**
     \fn tsPacketLinearTracker
 */
-tsPacketLinearTracker::tsPacketLinearTracker(uint32_t nb,ADM_TS_TRACK *tracks) : tsPacketLinear(tracks[0].trackPid)
+tsPacketLinearTracker::tsPacketLinearTracker(uint32_t pid,listOfTsAudioTracks *audio) : tsPacketLinear(pid)
 {
+    int nb=audio->size();
     otherPes=new TS_PESpacket(0);
-    ADM_assert(nb);
     totalTracks=nb;
     if(!nb)    
     {
@@ -705,7 +705,8 @@
     memset(stats,0,sizeof(packetTSStats)*nb);
     for(int i=0;i<nb;i++)
     {
-        stats[i].pid=tracks[i].trackPid;
+        
+        stats[i].pid=(*audio)[i].esId;
         stats[i].startDts=ADM_NO_PTS;
     }
 }

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-21 18:04:16 UTC (rev 4749)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-21 18:04:20 UTC (rev 4750)
@@ -7,11 +7,13 @@
 
 #ifndef DMXtsPacket_H
 #define DMXtsPacket_H
-
+#include <vector>
+using std::vector;
 #include "dmxPacket.h"
 #include "ADM_tsPatPmt.h"
 #include "ADM_Video.h"
 
+
 #define TS_MARKER       0x47
 #define TS_PACKET_LEN   188
 #define TS_PSI_MAX_LEN  1024
@@ -174,7 +176,7 @@
         packetTSStats *stats;
         uint32_t      totalTracks;
 public:
-                tsPacketLinearTracker(uint32_t nb,ADM_TS_TRACK *tracks);
+                tsPacketLinearTracker(uint32_t videoPid,listOfTsAudioTracks *audioTracks);
                 ~tsPacketLinearTracker();
         bool    getStats(uint32_t *nb,packetTSStats *stats);
 };



From mean at mail.berlios.de  Tue Apr 21 20:04:23 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 21 Apr 2009 20:04:23 +0200
Subject: [Avidemux-svn-commit] r4752 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904211804.n3LI4NYs031343@sheep.berlios.de>

Author: mean
Date: 2009-04-21 20:04:23 +0200 (Tue, 21 Apr 2009)
New Revision: 4752

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Log:
[Ts Demuxer] skeleton to parse audio

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:21 UTC (rev 4751)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:23 UTC (rev 4752)
@@ -166,7 +166,11 @@
     count++;
     if(count>MAX_SKIPPED_PACKET) return false;
 
-    if(id!=pid) goto nextPack;
+    if(id!=pid) 
+    {
+        updateStats(scratch);
+        goto nextPack;
+    }
     pkt->pid=pid;
 #ifdef TS_DEBUG2
     printf("[**************> Found matching pid 0x%x\n",pid);
@@ -217,8 +221,15 @@
     pkt->startAt=pos-extraCrap-TS_PACKET_LEN;
     return true;
 }
-
 /**
+        \fn updateStats
+        \brief Hook for tracker
+*/
+bool        tsPacket::updateStats(uint8_t *data)
+{
+    return true;
+}
+/**
     \fn getNextPsiPacket
     \brief Take a raw packet of type pid & remove the header (PSI)
 */
@@ -378,7 +389,7 @@
     uint8_t  *start=pes->payload+6;
     uint8_t  *end=pes->payload+pes->payloadSize;
     uint8_t  stream=pes->payload[3];
-    uint32_t packLen=(pes->payload[4])<<8+(pes->payload[5]);
+    uint32_t packLen=(pes->payload[4]<<8)+(pes->payload[5]);
     int      align=0,c;
 
 
@@ -451,19 +462,22 @@
                                 break; // no pts nor dts
                                                                 
         }  
-        int maxLen=(int)(end-start);
+       
+        int sizeCheck=pes->payloadSize-6;
+        int tail=0;
         pes->offset=start-pes->payload;
         if(packLen)
         {
             //printf("***Zimbla***\n");
-            if(packLen<maxLen) 
+            if(packLen<sizeCheck) 
             {
-                maxLen=packLen;
+                tail=sizeCheck-packLen;
+                pes->payloadSize-=tail;
             }
             else
-                if(packLen>maxLen)
+                if(packLen>sizeCheck)
                 {
-                    printf("[TS Packet] PackLen=%d, avalailble=%d\n",packLen,maxLen);
+                    printf("[TS Packet] PackLen=%d, avalailble=%d\n",packLen,sizeCheck);
                     fail("Pes too long");
                 }   
         }
@@ -730,5 +744,51 @@
     stats=this->stats;
     return true;
 }
+bool tsPacketLinearTracker::updateStats(uint8_t *scratch)
+{
+    uint32_t id=scratch[1]+((scratch[0]&0x1F)<<8);
+    int payloadUnitStart=scratch[0]&0x40;
+    int fieldControl=(scratch[2]>>4)&3;
+    int continuity=(scratch[2]&0xf);
+    int len=TS_PACKET_LEN-4; // useful datas
 
-//EOF
+    if(!payloadUnitStart) return false; // no PES start in here...
+    // Adaptation field
+    // 11 Adapt+payload
+    // 10 Adapt only
+    // 01 Payload only
+    // 00 forbidden
+    if(!(fieldControl & 1)) 
+    {
+        // No payload, continue
+#ifdef TS_DEBUG2
+        printf("[Demuxer] No payload\n");
+#endif        
+        return true;
+    }
+    uint8_t *start,*end;
+    start=scratch+3;
+    end=scratch+TS_PACKET_LEN-1;
+
+    if((fieldControl & 2)) // Adaptation layer
+    {
+        int payloadSize=*start++;
+        start+=payloadSize;
+    }
+    int size=(int)(end-start);
+    if(size<=0)  
+    {
+#ifdef TS_DEBUG2
+        printf("[Demuxer] size=%d\n",size);
+#endif        
+
+        return true;
+    }
+    // Look into pes packet starting at "start"
+    otherPes->payloadSize=size;
+    uint64_t pos;
+    _file->getpos(&pos);
+    otherPes->startAt=pos-extraCrap-TS_PACKET_LEN;
+    return true;
+}
+// EOF
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-21 18:04:21 UTC (rev 4751)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-21 18:04:23 UTC (rev 4752)
@@ -109,8 +109,9 @@
     
     bool                getSinglePacket(uint8_t *buffer);
     bool                decodePesHeader(TS_PESpacket *pes);
+    virtual bool        updateStats(uint8_t *data);
 public:
-    bool                getNextPacket_NoHeader(uint32_t pid,TSpacketInfo *pkt,bool psi);
+    virtual bool                getNextPacket_NoHeader(uint32_t pid,TSpacketInfo *pkt,bool psi);
 
     bool                getNextPSI(uint32_t pid,TS_PSIpacketInfo *psi);
     bool                getNextPES(TS_PESpacket *pes);
@@ -179,5 +180,6 @@
                 tsPacketLinearTracker(uint32_t videoPid,listOfTsAudioTracks *audioTracks);
                 ~tsPacketLinearTracker();
         bool    getStats(uint32_t *nb,packetTSStats *stats);
+virtual bool    updateStats(uint8_t *data);
 };
 #endif



From mean at mail.berlios.de  Tue Apr 21 20:04:25 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 21 Apr 2009 20:04:25 +0200
Subject: [Avidemux-svn-commit] r4753 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904211804.n3LI4PJA031353@sheep.berlios.de>

Author: mean
Date: 2009-04-21 20:04:25 +0200 (Tue, 21 Apr 2009)
New Revision: 4753

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Log:
[MpegTs] Correctly index audio. code a bit on the ugly side

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-21 18:04:23 UTC (rev 4752)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-21 18:04:25 UTC (rev 4753)
@@ -348,22 +348,24 @@
     {
         if(data->frameType==1)
         {
-#if 0
+
             // If audio, also dump audio
             if(audioTracks)
             {
 
                 qfprintf(index,"\nAudio bf:%08"LLX" ",data->startAt);
-                for(int i=0;i<audioTracks->size();i++)
-                {
-                    uint8_t e=(*audioTracks)[i]->esID;
-                    packetStats *s=pkt->getStat(e);
-                    
-                    qfprintf(index,"Pes:%x:%08"LLX":%"LD":%"LLD" ",e,s->startAt,s->startSize,s->startDts);
+                packetTSStats *s;
+                uint32_t na;
+                pkt->getStats(&na,&s);      
+                ADM_assert(na==audioTracks->size());
+                for(int i=0;i<na;i++)
+                {   
+                    packetTSStats *current=s+i;
+                    qfprintf(index,"Pes:%x:%08"LLX":%"LD":%"LLD" ",
+                                current->pid,current->startAt,current->startSize,current->startDts);
                 }
                 
             }
-#endif
             // start a new line
             qfprintf(index,"\nVideo at:%08"LLX":%04"LX" Pts:%08"LLD":%08"LLD" ",data->startAt,data->offset,info->pts,info->dts);
             data->nextOffset=-2;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:23 UTC (rev 4752)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-21 18:04:25 UTC (rev 4753)
@@ -738,21 +738,36 @@
 /**
     \fn tsPacketLinearTracker
 */
-bool    tsPacketLinearTracker::getStats(uint32_t *nb,packetTSStats *stats)
+bool    tsPacketLinearTracker::getStats(uint32_t *nb,packetTSStats **stats)
 {
     *nb=totalTracks;
-    stats=this->stats;
+    *stats=this->stats;
     return true;
 }
+/**
+        \fn updateStats
+        \brief Decode a bit of PES header, just enough to get PTS or DTS
+            if only PTS is there we assume PTS=DTS
+*/
 bool tsPacketLinearTracker::updateStats(uint8_t *scratch)
 {
     uint32_t id=scratch[1]+((scratch[0]&0x1F)<<8);
+    int found=-1;
+    // Look if it is a pid we are interested in
+    for(int i=0;i<totalTracks;i++)
+        if(id==stats[i].pid) found=i;
+    if(found==-1) return false;
+
+    
     int payloadUnitStart=scratch[0]&0x40;
     int fieldControl=(scratch[2]>>4)&3;
     int continuity=(scratch[2]&0xf);
-    int len=TS_PACKET_LEN-4; // useful datas
 
+
     if(!payloadUnitStart) return false; // no PES start in here...
+
+
+
     // Adaptation field
     // 11 Adapt+payload
     // 10 Adapt only
@@ -781,14 +796,102 @@
 #ifdef TS_DEBUG2
         printf("[Demuxer] size=%d\n",size);
 #endif        
-
         return true;
     }
     // Look into pes packet starting at "start"
     otherPes->payloadSize=size;
     uint64_t pos;
     _file->getpos(&pos);
+
+    //*************************
+    // ENTER PES
+    //*************************
+
     otherPes->startAt=pos-extraCrap-TS_PACKET_LEN;
+    // PES startcode ?
+    if( start[0] || start[1] || start[2]!=1) return false; 
+    int stream=start[3];
+    // Skip startcode + length
+    start+=6;
+    // Update our stats
+    stats[found].startAt=otherPes->startAt;
+    stats[found].count++;
+    //stats[found].startDts=ADM_NO_PTS;
+    
+    // Get PTS, DTS
+#define LEFT (int)(end-start)
+    int c,available;
+    if(LEFT<(4+2+1+2)) return false;
+    
+    while(*start==0xff && start<end) start++; // Padding
+    if(LEFT<5) fail("Not enough data in OES");
+
+    c=*start++;
+    if((c&0xc0)!=0x80) 
+    {
+        printf("[TS Demuxer] stream=0x%x pid=%d PES header :0x%x no mpeg2 PES marker\n",stream,id,c);
+        return false;
+    }
+    
+        uint32_t ptsdts,len;
+        c=*start++;     // PTS/DTS
+        //printf("%x ptsdts\n",c
+        ptsdts=c>>6;
+        // header len
+        len=*start++;
+        available=LEFT;
+        if(len>available) fail("Not enough data for PES header");
+    
+        switch(ptsdts)
+        {
+                case 2: // PTS=1 DTS=0
+                       
+                        {
+                                if(available<5) return false;
+                                uint64_t pts1,pts2,pts0;
+                                //      printf("\n PTS10\n");
+                                        pts0=start[0];  
+                                        pts1=(start[1]<<8)+start[2]; 
+                                        pts2=(start[3]<<8)+start[4]; 
+                                        start+=5;
+                                        stats[found].startDts=(pts1>>1)<<15;
+                                        stats[found].startDts+=pts2>>1;
+                                        stats[found].startDts+=(((pts0&6)>>1)<<30);
+                        }
+                        break;
+                case 3: // PTS=1 DTS=1
+                                if(available<10) return false;
+                                #define PTS11_ADV 10 // nut monkey
+                                if(len>=PTS11_ADV)
+                                {
+                                        uint32_t skip=PTS11_ADV;
+                                        uint64_t pts1,pts2,dts,pts0;
+                                                //      printf("\n PTS10\n");
+                                                pts0=start[0];  
+                                                pts1=(start[1]<<8)+start[2]; 
+                                                pts2=(start[3]<<8)+start[4]; 
+                                                start+=5;
+                                                                        
+                                                // Assume PTS=DTS
+                                                pts0=*start++;  
+                                                pts1=(start[0]<<8)+start[1]; 
+                                                pts2=(start[2]<<8)+start[3];       
+                                                start+=5;
+                                                stats[found].startDts=(pts1>>1)<<15;
+                                                stats[found].startDts+=pts2>>1;
+                                                stats[found].startDts+=(((pts0&6)>>1)<<30);
+                                   }
+                                   break;               
+                case 1:
+                                fail("unvalid pts/dts");
+                                break;
+                case 0: 
+                                // printf("\n PTS00\n");
+                                break; // no pts nor dts
+                                                                
+        }  
+       
+
     return true;
 }
 // EOF
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-21 18:04:23 UTC (rev 4752)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-21 18:04:25 UTC (rev 4753)
@@ -179,7 +179,7 @@
 public:
                 tsPacketLinearTracker(uint32_t videoPid,listOfTsAudioTracks *audioTracks);
                 ~tsPacketLinearTracker();
-        bool    getStats(uint32_t *nb,packetTSStats *stats);
+        bool    getStats(uint32_t *nb,packetTSStats **stats);
 virtual bool    updateStats(uint8_t *data);
 };
 #endif



From gruntster at mail.berlios.de  Tue Apr 21 21:20:42 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 21 Apr 2009 21:20:42 +0200
Subject: [Avidemux-svn-commit] r4754 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200904211920.n3LJKgYv009662@sheep.berlios.de>

Author: gruntster
Date: 2009-04-21 21:20:33 +0200 (Tue, 21 Apr 2009)
New Revision: 4754

Added:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake
Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
Log:
[cmake] move patching of ffmpeg to separate script

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-04-21 18:04:25 UTC (rev 4753)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-04-21 19:20:33 UTC (rev 4754)
@@ -26,12 +26,6 @@
 
 # Checkout FFmpeg source and patch it
 if (NOT IS_DIRECTORY "${FFMPEG_SOURCE_DIR}/.svn")
-	find_package(Patch)
-
-	if (WIN32)
-		find_package(Unix2Dos)
-	endif (WIN32)
-
 	message(STATUS "Checking out FFmpeg")
 	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} co svn://svn.ffmpeg.org/ffmpeg/trunk -r ${FFMPEG_VERSION} --ignore-externals "${FFMPEG_SOURCE_DIR}"
 					${ffmpegSvnOutput})
@@ -50,12 +44,6 @@
 message(STATUS "FFmpeg revision: ${ffmpeg_WC_REVISION}")
 
 if (NOT ${ffmpeg_WC_REVISION} EQUAL ${FFMPEG_VERSION})
-	find_package(Patch)
-
-	if (WIN32)
-		find_package(Unix2Dos)
-	endif (WIN32)
-
 	MESSAGE(STATUS "Updating to revision ${FFMPEG_VERSION}")
 	set(FFMPEG_PERFORM_BUILD 1)
 	set(FFMPEG_PERFORM_PATCH 1)
@@ -74,12 +62,6 @@
 message(STATUS "libswscale revision: ${swscale_WC_REVISION}")
 
 if (NOT ${swscale_WC_REVISION} EQUAL ${SWSCALE_VERSION})
-	find_package(Patch)
-
-	if (WIN32)
-		find_package(Unix2Dos)
-	endif (WIN32)
-
 	message(STATUS "Updating to revision ${SWSCALE_VERSION}")
 	set(FFMPEG_PERFORM_BUILD 1)
 	set(FFMPEG_PERFORM_PATCH 1)
@@ -93,23 +75,7 @@
 message("")
 
 if (FFMPEG_PERFORM_PATCH)
-	file(GLOB patchFiles "${CMAKE_SOURCE_DIR}/cmake/patches/*.patch")
-
-	foreach(patchFile ${patchFiles})
-		if (WIN32)
-			file(MAKE_DIRECTORY "${FFMPEG_BINARY_DIR}/patches")
-			get_filename_component(fileName "${patchFile}" NAME)
-			execute_process(COMMAND ${UNIX2DOS_EXECUTABLE} -n ${patchFile} ${FFMPEG_BINARY_DIR}/patches/${fileName}
-							${unix2dosOutput})
-
-			set(patchFile "${FFMPEG_BINARY_DIR}/patches/${fileName}")
-		endif (WIN32)
-
-		execute_process(COMMAND ${PATCH_EXECUTABLE} -p0 -i "${patchFile}"
-						WORKING_DIRECTORY "${FFMPEG_SOURCE_DIR}")
-	endforeach(patchFile)
-
-	message("")
+	include(admFFmpegPatch)
 endif (FFMPEG_PERFORM_PATCH)
 
 # Configure FFmpeg, if required

Added: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake	2009-04-21 18:04:25 UTC (rev 4753)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake	2009-04-21 19:20:33 UTC (rev 4754)
@@ -0,0 +1,21 @@
+find_package(Patch)
+
+if (WIN32)
+	find_package(Unix2Dos)
+endif (WIN32)
+
+file(GLOB patchFiles "${CMAKE_SOURCE_DIR}/cmake/patches/*.patch")
+
+foreach(patchFile ${patchFiles})
+	if (WIN32)
+		file(MAKE_DIRECTORY "${FFMPEG_BINARY_DIR}/patches")
+		get_filename_component(fileName "${patchFile}" NAME)
+		execute_process(COMMAND ${UNIX2DOS_EXECUTABLE} -n ${patchFile} ${FFMPEG_BINARY_DIR}/patches/${fileName}
+						${unix2dosOutput})
+
+		set(patchFile "${FFMPEG_BINARY_DIR}/patches/${fileName}")
+	endif (WIN32)
+
+	execute_process(COMMAND ${PATCH_EXECUTABLE} -p0 -i "${patchFile}"
+					WORKING_DIRECTORY "${FFMPEG_SOURCE_DIR}")
+endforeach(patchFile)
\ No newline at end of file



From gruntster at mail.berlios.de  Tue Apr 21 22:11:28 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 21 Apr 2009 22:11:28 +0200
Subject: [Avidemux-svn-commit] r4755 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200904212011.n3LKBSXw017467@sheep.berlios.de>

Author: gruntster
Date: 2009-04-21 22:11:21 +0200 (Tue, 21 Apr 2009)
New Revision: 4755

Added:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareSvn.cmake
Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake
Log:
[cmake] move svn retrieval of ffmpeg to separate script

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-04-21 19:20:33 UTC (rev 4754)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-04-21 20:11:21 UTC (rev 4755)
@@ -1,5 +1,4 @@
 include(admFFmpegUtil)
-find_package(Subversion)
 
 set(FFMPEG_VERSION 18300)
 set(SWSCALE_VERSION 29120)
@@ -17,65 +16,17 @@
 				  --disable-parsers --disable-decoders --disable-encoders --disable-demuxers --disable-muxers --enable-postproc --enable-gpl 
 				  --prefix=${CMAKE_INSTALL_PREFIX})
 
+include(admFFmpegPrepareSvn)
+
 if (NOT VERBOSE)
-	set(ffmpegSvnOutput OUTPUT_VARIABLE FFMPEG_SVN_OUTPUT)
-	set(swscaleSvnOutput OUTPUT_VARIABLE SWSCALE_SVN_OUTPUT)
 	set(ffmpegBuildOutput OUTPUT_VARIABLE FFMPEG_CONFIGURE_OUTPUT)
-	set(unix2dosOutput OUTPUT_VARIABLE UNIX2DOS_OUTPUT)
 endif (NOT VERBOSE)
 
-# Checkout FFmpeg source and patch it
-if (NOT IS_DIRECTORY "${FFMPEG_SOURCE_DIR}/.svn")
-	message(STATUS "Checking out FFmpeg")
-	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} co svn://svn.ffmpeg.org/ffmpeg/trunk -r ${FFMPEG_VERSION} --ignore-externals "${FFMPEG_SOURCE_DIR}"
-					${ffmpegSvnOutput})
-
-	message(STATUS "Checking out libswscale")
-	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} co svn://svn.ffmpeg.org/mplayer/trunk/libswscale -r ${SWSCALE_VERSION} "${FFMPEG_SOURCE_DIR}/libswscale"
-					${swscaleSvnOutput})
-
-	message("")
-
-	set(FFMPEG_PERFORM_PATCH 1)
-endif (NOT IS_DIRECTORY "${FFMPEG_SOURCE_DIR}/.svn")
-
-# Check version
-Subversion_WC_INFO(${FFMPEG_SOURCE_DIR} ffmpeg)
-message(STATUS "FFmpeg revision: ${ffmpeg_WC_REVISION}")
-
-if (NOT ${ffmpeg_WC_REVISION} EQUAL ${FFMPEG_VERSION})
-	MESSAGE(STATUS "Updating to revision ${FFMPEG_VERSION}")
-	set(FFMPEG_PERFORM_BUILD 1)
-	set(FFMPEG_PERFORM_PATCH 1)
-
-	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} revert -R "${FFMPEG_SOURCE_DIR}"
-					${ffmpegSvnOutput})
-	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} up -r ${FFMPEG_VERSION} --ignore-externals "${FFMPEG_SOURCE_DIR}"
-					${ffmpegSvnOutput})	
-
-	message("")
-endif (NOT ${ffmpeg_WC_REVISION} EQUAL ${FFMPEG_VERSION})
-
 message("")
 
-Subversion_WC_INFO(${FFMPEG_SOURCE_DIR}/libswscale swscale)
-message(STATUS "libswscale revision: ${swscale_WC_REVISION}")
-
-if (NOT ${swscale_WC_REVISION} EQUAL ${SWSCALE_VERSION})
-	message(STATUS "Updating to revision ${SWSCALE_VERSION}")
-	set(FFMPEG_PERFORM_BUILD 1)
-	set(FFMPEG_PERFORM_PATCH 1)
-
-	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} revert -R "${FFMPEG_SOURCE_DIR}/libswscale"
-					${swscaleSvnOutput})
-	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} up -r ${SWSCALE_VERSION} "${FFMPEG_SOURCE_DIR}/libswscale"
-					${swscaleSvnOutput})
-endif (NOT ${swscale_WC_REVISION} EQUAL ${SWSCALE_VERSION})
-
-message("")
-
 if (FFMPEG_PERFORM_PATCH)
 	include(admFFmpegPatch)
+	message("")
 endif (FFMPEG_PERFORM_PATCH)
 
 # Configure FFmpeg, if required

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake	2009-04-21 19:20:33 UTC (rev 4754)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake	2009-04-21 20:11:21 UTC (rev 4755)
@@ -2,6 +2,10 @@
 
 if (WIN32)
 	find_package(Unix2Dos)
+	
+	if (NOT VERBOSE)
+		set(unix2dosOutput OUTPUT_VARIABLE UNIX2DOS_OUTPUT)
+	endif (NOT VERBOSE)
 endif (WIN32)
 
 file(GLOB patchFiles "${CMAKE_SOURCE_DIR}/cmake/patches/*.patch")

Added: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareSvn.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareSvn.cmake	2009-04-21 19:20:33 UTC (rev 4754)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareSvn.cmake	2009-04-21 20:11:21 UTC (rev 4755)
@@ -0,0 +1,54 @@
+find_package(Subversion)
+
+if (NOT VERBOSE)
+	set(ffmpegSvnOutput OUTPUT_VARIABLE FFMPEG_SVN_OUTPUT)
+	set(swscaleSvnOutput OUTPUT_VARIABLE SWSCALE_SVN_OUTPUT)
+endif (NOT VERBOSE)
+
+# Checkout FFmpeg source and patch it
+if (NOT IS_DIRECTORY "${FFMPEG_SOURCE_DIR}/.svn")
+	message(STATUS "Checking out FFmpeg")
+	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} co svn://svn.ffmpeg.org/ffmpeg/trunk -r ${FFMPEG_VERSION} --ignore-externals "${FFMPEG_SOURCE_DIR}"
+					${ffmpegSvnOutput})
+
+	message(STATUS "Checking out libswscale")
+	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} co svn://svn.ffmpeg.org/mplayer/trunk/libswscale -r ${SWSCALE_VERSION} "${FFMPEG_SOURCE_DIR}/libswscale"
+					${swscaleSvnOutput})
+
+	message("")
+
+	set(FFMPEG_PERFORM_PATCH 1)
+endif (NOT IS_DIRECTORY "${FFMPEG_SOURCE_DIR}/.svn")
+
+# Check version
+Subversion_WC_INFO(${FFMPEG_SOURCE_DIR} ffmpeg)
+message(STATUS "FFmpeg revision: ${ffmpeg_WC_REVISION}")
+
+if (NOT ${ffmpeg_WC_REVISION} EQUAL ${FFMPEG_VERSION})
+	MESSAGE(STATUS "Updating to revision ${FFMPEG_VERSION}")
+	set(FFMPEG_PERFORM_BUILD 1)
+	set(FFMPEG_PERFORM_PATCH 1)
+
+	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} revert -R "${FFMPEG_SOURCE_DIR}"
+					${ffmpegSvnOutput})
+	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} up -r ${FFMPEG_VERSION} --ignore-externals "${FFMPEG_SOURCE_DIR}"
+					${ffmpegSvnOutput})	
+
+	message("")
+endif (NOT ${ffmpeg_WC_REVISION} EQUAL ${FFMPEG_VERSION})
+
+message("")
+
+Subversion_WC_INFO(${FFMPEG_SOURCE_DIR}/libswscale swscale)
+message(STATUS "libswscale revision: ${swscale_WC_REVISION}")
+
+if (NOT ${swscale_WC_REVISION} EQUAL ${SWSCALE_VERSION})
+	message(STATUS "Updating to revision ${SWSCALE_VERSION}")
+	set(FFMPEG_PERFORM_BUILD 1)
+	set(FFMPEG_PERFORM_PATCH 1)
+
+	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} revert -R "${FFMPEG_SOURCE_DIR}/libswscale"
+					${swscaleSvnOutput})
+	execute_process(COMMAND ${Subversion_SVN_EXECUTABLE} up -r ${SWSCALE_VERSION} "${FFMPEG_SOURCE_DIR}/libswscale"
+					${swscaleSvnOutput})
+endif (NOT ${swscale_WC_REVISION} EQUAL ${SWSCALE_VERSION})
\ No newline at end of file



From gruntster at mail.berlios.de  Wed Apr 22 21:49:15 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 22 Apr 2009 21:49:15 +0200
Subject: [Avidemux-svn-commit] r4756 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200904221949.n3MJnFtY001740@sheep.berlios.de>

Author: gruntster
Date: 2009-04-22 21:49:09 +0200 (Wed, 22 Apr 2009)
New Revision: 4756

Added:
   branches/avidemux_2.5_branch_gruntster/cmake/FindTar.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareTar.cmake
Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
Log:
[cmake] use ffmpeg tarball first if available otherwise svn

Added: branches/avidemux_2.5_branch_gruntster/cmake/FindTar.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/FindTar.cmake	2009-04-21 20:11:21 UTC (rev 4755)
+++ branches/avidemux_2.5_branch_gruntster/cmake/FindTar.cmake	2009-04-22 19:49:09 UTC (rev 4756)
@@ -0,0 +1,19 @@
+if (NOT TAR_EXECUTABLE)
+	message(STATUS "Checking for tar")
+	message(STATUS "****************")
+
+	find_program(TAR_EXECUTABLE tar)
+	set(TAR_EXECUTABLE ${TAR_EXECUTABLE} CACHE STRING "")
+
+	if (TAR_EXECUTABLE)
+		message(STATUS "Found tar")
+
+		if (VERBOSE)
+			message(STATUS "Path: ${TAR_EXECUTABLE}")
+		endif (VERBOSE)
+	else (TAR_EXECUTABLE)
+		message(FATAL_ERROR "tar not found")
+	endif (TAR_EXECUTABLE)
+
+	message("")
+endif (NOT TAR_EXECUTABLE)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-04-21 20:11:21 UTC (rev 4755)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-04-22 19:49:09 UTC (rev 4756)
@@ -1,8 +1,10 @@
 include(admFFmpegUtil)
 
-set(FFMPEG_VERSION 18300)
-set(SWSCALE_VERSION 29120)
-set(FFMPEG_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries/ffmpeg")
+set(FFMPEG_VERSION 18300)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=004034d83aa068cd26b52c17e1b0af6e11410940;sf=tgz
+set(SWSCALE_VERSION 29120)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=e58c77c7cf34896dcbc109730551902a4d5a321b;sf=tgz
+
+set(LIBRARY_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries")
+set(FFMPEG_SOURCE_DIR "${LIBRARY_SOURCE_DIR}/ffmpeg")
 set(FFMPEG_BINARY_DIR "${CMAKE_BINARY_DIR}/avidemux/ADM_libraries/ffmpeg")
 
 set(FFMPEG_DECODERS  adpcm_ima_amv  amv  bmp  cinepak  dnxhd  dvbsub  dvvideo  ffv1  ffvhuff  flv  fourxm  fraps  h263  h264  huffyuv  indeo2  indeo3
@@ -16,8 +18,12 @@
 				  --disable-parsers --disable-decoders --disable-encoders --disable-demuxers --disable-muxers --enable-postproc --enable-gpl 
 				  --prefix=${CMAKE_INSTALL_PREFIX})
 
-include(admFFmpegPrepareSvn)
+include(admFFmpegPrepareTar)
 
+if (NOT FFMPEG_PREPARED)
+	include(admFFmpegPrepareSvn)
+endif (NOT FFMPEG_PREPARED)
+
 if (NOT VERBOSE)
 	set(ffmpegBuildOutput OUTPUT_VARIABLE FFMPEG_CONFIGURE_OUTPUT)
 endif (NOT VERBOSE)

Added: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareTar.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareTar.cmake	2009-04-21 20:11:21 UTC (rev 4755)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareTar.cmake	2009-04-22 19:49:09 UTC (rev 4756)
@@ -0,0 +1,34 @@
+if (NOT VERBOSE)
+	set(ffmpegExtractOutput OUTPUT_VARIABLE FFMPEG_EXTRACT_OUTPUT)
+endif (NOT VERBOSE)
+
+set(FFMPEG_SOURCE_ARCHIVE "ffmpeg_r${FFMPEG_VERSION}.tar.gz")
+set(SWSCALE_SOURCE_ARCHIVE "libswscale_r${SWSCALE_VERSION}.tar.gz")
+
+if (EXISTS "${LIBRARY_SOURCE_DIR}/${FFMPEG_SOURCE_ARCHIVE}" AND EXISTS "${LIBRARY_SOURCE_DIR}/${SWSCALE_SOURCE_ARCHIVE}")
+	if (NOT EXISTS "${FFMPEG_SOURCE_DIR}/ffmpeg.c" OR NOT ${LAST_FFMPEG_VERSION} EQUAL ${FFMPEG_VERSION})
+		find_package(Tar)
+
+		execute_process(COMMAND ${TAR_EXECUTABLE} xvf ${FFMPEG_SOURCE_ARCHIVE}
+					WORKING_DIRECTORY "${LIBRARY_SOURCE_DIR}"
+					${ffmpegExtractOutput})
+
+		set(FFMPEG_PERFORM_PATCH 1)
+		set(FFMPEG_PERFORM_BUILD 1)
+	endif (NOT EXISTS "${FFMPEG_SOURCE_DIR}/ffmpeg.c" OR NOT ${LAST_FFMPEG_VERSION} EQUAL ${FFMPEG_VERSION})
+
+	if (NOT EXISTS "${FFMPEG_SOURCE_DIR}/libswscale/swscale.c" OR NOT ${LAST_SWSCALE_VERSION} EQUAL ${SWSCALE_VERSION})
+		find_package(Tar)
+
+		execute_process(COMMAND ${TAR_EXECUTABLE} xvf ../${SWSCALE_SOURCE_ARCHIVE}
+					WORKING_DIRECTORY "${FFMPEG_SOURCE_DIR}"
+					${ffmpegExtractOutput})
+
+		set(FFMPEG_PERFORM_PATCH 1)
+		set(FFMPEG_PERFORM_BUILD 1)
+	endif (NOT EXISTS "${FFMPEG_SOURCE_DIR}/libswscale/swscale.c" OR NOT ${LAST_SWSCALE_VERSION} EQUAL ${SWSCALE_VERSION})
+
+	set(FFMPEG_PREPARED 1)
+	set(LAST_FFMPEG_VERSION "${FFMPEG_VERSION}" CACHE STRING "" FORCE)
+	set(LAST_SWSCALE_VERSION "${SWSCALE_VERSION}" CACHE STRING "" FORCE)
+endif (EXISTS "${LIBRARY_SOURCE_DIR}/${FFMPEG_SOURCE_ARCHIVE}" AND EXISTS "${LIBRARY_SOURCE_DIR}/${SWSCALE_SOURCE_ARCHIVE}")
\ No newline at end of file



From gruntster at mail.berlios.de  Wed Apr 22 22:01:09 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 22 Apr 2009 22:01:09 +0200
Subject: [Avidemux-svn-commit] r4757 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src
Message-ID: <200904222001.n3MK19Ia003014@sheep.berlios.de>

Author: gruntster
Date: 2009-04-22 22:01:03 +0200 (Wed, 22 Apr 2009)
New Revision: 4757

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_rgb.cpp
Log:
[rgb] use SWS_ACCURATE_RND to temporarily fix broken swscale RGB conversion

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_rgb.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_rgb.cpp	2009-04-22 19:49:09 UTC (rev 4756)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_rgb.cpp	2009-04-22 20:01:03 UTC (rev 4757)
@@ -90,6 +90,13 @@
 	if (_context)
 		sws_freeContext((SwsContext *)_context);
 
+	/* 
+	FIXME: remove when ffmpeg is fixed
+	Without SWS_ACCURATE_RND the quality is bad 
+	for YUV->RGB (caused by libswscale r28700) 
+	*/
+	flags |= SWS_ACCURATE_RND;
+
 	 _context=(void *)sws_getContext(
                       ww,hh,
                       PIX_FMT_YUV420P ,



From gruntster at mail.berlios.de  Wed Apr 22 22:52:25 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 22 Apr 2009 22:52:25 +0200
Subject: [Avidemux-svn-commit] r4758 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264:
	. qt4
Message-ID: <200904222052.n3MKqPoW008766@sheep.berlios.de>

Author: gruntster
Date: 2009-04-22 22:52:19 +0200 (Wed, 22 Apr 2009)
New Revision: 4758

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/options.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/options.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp
Log:
[x264] support core 67

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-04-22 20:01:03 UTC (rev 4757)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-04-22 20:52:19 UTC (rev 4758)
@@ -602,7 +602,9 @@
 	printf("[x264] i_keyint_max = %d\n", x264Param->i_keyint_max);
 	printf("[x264] i_keyint_min = %d\n", x264Param->i_keyint_min);
 	printf("[x264] i_scenecut_threshold = %d\n", x264Param->i_scenecut_threshold);
+#if X264_BUILD < 67
 	printf("[x264] b_pre_scenecut = %d\n", x264Param->b_pre_scenecut);
+#endif
 	printf("[x264] analyse.b_mixed_references = %d\n", x264Param->analyse.b_mixed_references);
 	printf("[x264] analyse.b_chroma_me = %d\n", x264Param->analyse.b_chroma_me);
 #if X264_BUILD < 65

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/options.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/options.cpp	2009-04-22 20:01:03 UTC (rev 4757)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/options.cpp	2009-04-22 20:52:19 UTC (rev 4758)
@@ -315,6 +315,7 @@
 		_param.i_scenecut_threshold = scenecutThreshold;
 }
 
+#if X264_BUILD < 67
 bool x264Options::getPreScenecutDetection(void)
 {
 	return _param.b_pre_scenecut;
@@ -324,6 +325,7 @@
 {
 	_param.b_pre_scenecut = preScenecutDetection;
 }
+#endif
 
 unsigned int x264Options::getBFrames(void)
 {
@@ -1223,7 +1225,9 @@
 	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"gopMaximumSize", number2String(xmlBuffer, bufferSize, getGopMaximumSize()));
 	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"gopMinimumSize", number2String(xmlBuffer, bufferSize, getGopMinimumSize()));
 	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"scenecutThreshold", number2String(xmlBuffer, bufferSize, getScenecutThreshold()));
+#if X264_BUILD < 67
 	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"preScenecutDetection", boolean2String(xmlBuffer, bufferSize, getPreScenecutDetection()));
+#endif
 	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"bFrames", number2String(xmlBuffer, bufferSize, getBFrames()));
 	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"adaptiveBframeDecision", number2String(xmlBuffer, bufferSize, getAdaptiveBFrameDecision()));
 	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"bFrameBias", number2String(xmlBuffer, bufferSize, getBFrameBias()));
@@ -1567,8 +1571,10 @@
 				setGopMinimumSize(atoi(content));
 			else if (strcmp((char*)xmlChild->name, "scenecutThreshold") == 0)
 				setScenecutThreshold(atoi(content));
+#if X264_BUILD < 67
 			else if (strcmp((char*)xmlChild->name, "preScenecutDetection") == 0)
 				setPreScenecutDetection(string2Boolean(content));
+#endif
 			else if (strcmp((char*)xmlChild->name, "bFrames") == 0)
 				setBFrames(atoi(content));
 			else if (strcmp((char*)xmlChild->name, "adaptiveBframeDecision") == 0)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/options.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/options.h	2009-04-22 20:01:03 UTC (rev 4757)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/options.h	2009-04-22 20:52:19 UTC (rev 4758)
@@ -132,8 +132,10 @@
 	unsigned int getScenecutThreshold(void);
 	void setScenecutThreshold(unsigned int scenecutThreshold);
 
+#if X264_BUILD < 67
 	bool getPreScenecutDetection(void);
 	void setPreScenecutDetection(bool preScenecutDetection);
+#endif
 
 	unsigned int getBFrames(void);
 	void setBFrames(unsigned int bFrames);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp	2009-04-22 20:01:03 UTC (rev 4757)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp	2009-04-22 20:52:19 UTC (rev 4758)
@@ -95,6 +95,10 @@
 	ui.predictSizeComboBox->setVisible(false);
 #endif
 
+#if X264_BUILD >= 67
+	ui.scenecutDetectionCheckBox->setVisible(false);
+#endif
+
 	// Frame tab
 	connect(ui.loopFilterCheckBox, SIGNAL(toggled(bool)), this, SLOT(loopFilterCheckBox_toggled(bool)));
 	connect(ui.cabacCheckBox, SIGNAL(toggled(bool)), this, SLOT(cabacCheckBox_toggled(bool)));
@@ -677,7 +681,9 @@
 	ui.maxGopSizeSpinBox->setValue(options->getGopMaximumSize());
 	ui.minGopSizeSpinBox->setValue(options->getGopMinimumSize());
 	ui.IFrameThresholdSpinBox->setValue(options->getScenecutThreshold());
+#if X264_BUILD < 67
 	ui.scenecutDetectionCheckBox->setChecked(options->getPreScenecutDetection());
+#endif
 
 	// Analysis tab
 	ui.mixedRefsCheckBox->setChecked(options->getMixedReferences());
@@ -885,7 +891,9 @@
 	options->setGopMaximumSize(ui.maxGopSizeSpinBox->value());
 	options->setGopMinimumSize(ui.minGopSizeSpinBox->value());
 	options->setScenecutThreshold(ui.IFrameThresholdSpinBox->value());
+#if X264_BUILD < 67
 	options->setPreScenecutDetection(ui.scenecutDetectionCheckBox->isChecked());
+#endif
 
 	// Analysis tab
 	options->setMixedReferences(ui.mixedRefsCheckBox->isChecked());



From gruntster at mail.berlios.de  Thu Apr 23 17:23:47 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 23 Apr 2009 17:23:47 +0200
Subject: [Avidemux-svn-commit] r4759 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script
Message-ID: <200904231523.n3NFNlwa001235@sheep.berlios.de>

Author: gruntster
Date: 2009-04-23 17:23:41 +0200 (Thu, 23 Apr 2009)
New Revision: 4759

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
Log:
[js] remove pointless resolving of path for include scripts

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2009-04-22 20:52:19 UTC (rev 4758)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2009-04-23 15:23:41 UTC (rev 4759)
@@ -439,18 +439,8 @@
 	// dependency loop
 	char *pTempStr = new char[PATH_MAX+1];
 
- #ifdef __MINGW32__
- 	if(_fullpath(pTempStr,pIncludeFile,PATH_MAX) == NULL)
- #else
-	if(realpath(pIncludeFile,pTempStr) == NULL)
-#endif
-	{
-		JS_ReportError(cx, "include() can't resolve the path of \"%s\".", pIncludeFile);
-		delete pTempStr;
+	strcpy(pTempStr, pIncludeFile);
 
-		return JS_FALSE;
-	}
-
 	if(stat(pTempStr, &sbFileInfo) != 0)
 	{
 		char *scriptPath = ADM_getScriptPath();
@@ -461,7 +451,7 @@
 
 		if(stat(pTempStr, &sbFileInfo) != 0)
 		{
-			JS_ReportError(cx, "include() Can't stat \"%s\" errno(%i).", pTempStr, errno);
+			JS_ReportError(cx, "include() Can't stat \"%s\" errno(%i).", pIncludeFile, errno);
 			delete pTempStr;
 
 			return JS_FALSE;



From gruntster at mail.berlios.de  Sat Apr 25 12:42:31 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 25 Apr 2009 12:42:31 +0200
Subject: [Avidemux-svn-commit] r4760 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor
Message-ID: <200904251042.n3PAgVci014018@sheep.berlios.de>

Author: gruntster
Date: 2009-04-25 12:42:22 +0200 (Sat, 25 Apr 2009)
New Revision: 4760

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp
Log:
[script] output new property names in scripts

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp	2009-04-23 15:23:41 UTC (rev 4759)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp	2009-04-25 10:42:22 UTC (rev 4760)
@@ -233,7 +233,7 @@
    qfprintf(fd,"app.audio.normalizeMode=%d;\n",audioGetNormalizeMode());
    qfprintf(fd,"app.audio.normalizeValue=%d;\n",audioGetNormalizeValue());
    qfprintf(fd,"app.audio.delay=%d;\n",audioGetDelay());
-   qfprintf(fd,"app.audio.mixer(\"%s\");\n",getCurrentMixerString());
+   qfprintf(fd,"app.audio.mixer=\"%s\";\n",getCurrentMixerString());
 
     // VBR ?
     if(currentaudiostream)
@@ -268,7 +268,7 @@
 
   // container
         
-  qfprintf(fd,"app.setContainer(\"%s\");\n",getCurrentContainerAsString());
+  qfprintf(fd,"app.container=\"%s\";\n",getCurrentContainerAsString());
   if(outputname)
   {
         char *o=ADM_cleanupPath(outputname);



From gruntster at mail.berlios.de  Sat Apr 25 14:22:23 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 25 Apr 2009 14:22:23 +0200
Subject: [Avidemux-svn-commit] r4761 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor
Message-ID: <200904251222.n3PCMNU3024121@sheep.berlios.de>

Author: gruntster
Date: 2009-04-25 14:22:15 +0200 (Sat, 25 Apr 2009)
New Revision: 4761

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp
Log:
[script] revert part of r4760

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp	2009-04-25 10:42:22 UTC (rev 4760)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp	2009-04-25 12:22:15 UTC (rev 4761)
@@ -268,7 +268,7 @@
 
   // container
         
-  qfprintf(fd,"app.container=\"%s\";\n",getCurrentContainerAsString());
+  qfprintf(fd,"app.setContainer(\"%s\");\n",getCurrentContainerAsString());
   if(outputname)
   {
         char *o=ADM_cleanupPath(outputname);



From gruntster at mail.berlios.de  Sun Apr 26 01:10:06 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 26 Apr 2009 01:10:06 +0200
Subject: [Avidemux-svn-commit] r4762 - in
	branches/avidemux_2.5_branch_gruntster: avidemux
	avidemux/ADM_libraries avidemux/ADM_libraries/ADM_smjs
	avidemux/ADM_script cmake
Message-ID: <200904252310.n3PNA6Q6008852@sheep.berlios.de>

Author: gruntster
Date: 2009-04-26 01:09:35 +0200 (Sun, 26 Apr 2009)
New Revision: 4762

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDFMenu.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDialogFactory.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSGlobal.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckMiscLibs.cmake
Log:
[script] add option to use system version of SpiderMonkey

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt	2009-04-25 23:09:35 UTC (rev 4762)
@@ -14,12 +14,5 @@
 ENDIF (MINGW)
 
 ADD_TARGET_CFLAGS(${ADM_LIB} "-DNDEBUG -DTRIMMED -DEXPORT_JS_API -DJS_USE_SAFE_ARENA -D_IEEE_LIBM")
-ADD_TARGET_CFLAGS(${ADM_LIB} "-Dmalloc=ADM_alloc")
-ADD_TARGET_CFLAGS(${ADM_LIB} "-Drealloc=ADM_realloc")
-ADD_TARGET_CFLAGS(${ADM_LIB} "-Dfree=ADM_dezalloc")
-ADD_TARGET_CFLAGS(${ADM_LIB} "-Dcalloc=ADM_calloc -I/usr/include/nspr")
-ADD_TARGET_CFLAGS(${ADM_LIB} "-Dfopen=ADM_fopen")
 
-TARGET_LINK_LIBRARIES(${ADM_LIB} ADM_core)
-
 INSTALL(TARGETS ${ADM_LIB} RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/CMakeLists.txt	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/CMakeLists.txt	2009-04-25 23:09:35 UTC (rev 4762)
@@ -1,7 +1,11 @@
 add_subdirectory(ADM_libmpeg2enc)
 add_subdirectory(ADM_lvemux)
 add_subdirectory(ADM_mplex)
-add_subdirectory(ADM_smjs)
+
+if (NOT USE_SYSTEM_SPIDERMONKEY)
+	add_subdirectory(ADM_smjs)
+endif (NOT USE_SYSTEM_SPIDERMONKEY)
+
 add_subdirectory(ADM_utilities)
 add_subdirectory(ADM_xvidratectl)
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.h	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.h	2009-04-25 23:09:35 UTC (rev 4762)
@@ -4,7 +4,7 @@
 #pragma once
 
 // Spidermonkey
-#include "ADM_libraries/ADM_smjs/jsapi.h"
+#include "jsapi.h"
 
 class ADM_JSAppliedVideoFilter
 {

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAudioTrackInfo.h	2009-04-25 23:09:35 UTC (rev 4762)
@@ -1,7 +1,7 @@
 #ifndef _ADM_JSAUDIOTRACKINFO_H
 #define _ADM_JSAUDIOTRACKINFO_H
 
-#include "ADM_libraries/ADM_smjs/jsapi.h"
+#include "jsapi.h"
 #include "ADM_editor/ADM_Video.h"
 
 class ADM_JSAudioTrackInfo

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.h	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.h	2009-04-25 23:09:35 UTC (rev 4762)
@@ -5,7 +5,7 @@
 #include "config.h"
 
 // Spidermonkey
-#include "ADM_libraries/ADM_smjs/jsapi.h"
+#include "jsapi.h"
 #include "ADM_Avidemux.h"
 class ADM_JSAvidemux
 {

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h	2009-04-25 23:09:35 UTC (rev 4762)
@@ -6,7 +6,7 @@
 #include "config.h"
 
 // Spidermonkey
-#include "ADM_libraries/ADM_smjs/jsapi.h"
+#include "jsapi.h"
 #include "ADM_AvidemuxAudio.h"
 #include "avi_vars.h"
 #include "ADM_audiofilter/audioeng_buildfilters.h"

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h	2009-04-25 23:09:35 UTC (rev 4762)
@@ -4,7 +4,7 @@
 #pragma once
 
 // Spidermonkey
-#include "ADM_libraries/ADM_smjs/jsapi.h"
+#include "jsapi.h"
 #include "ADM_AvidemuxVideo.h"
 
 class ADM_JSAvidemuxVideo

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDFMenu.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDFMenu.h	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDFMenu.h	2009-04-25 23:09:35 UTC (rev 4762)
@@ -2,7 +2,7 @@
 #define _ADM_JSDFMenu_H
 
 #include "config.h"
-#include "ADM_libraries/ADM_smjs/jsapi.h"
+#include "jsapi.h"
 #include "DIA_factory.h"
 #include <vector>
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDialogFactory.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDialogFactory.h	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDialogFactory.h	2009-04-25 23:09:35 UTC (rev 4762)
@@ -2,7 +2,7 @@
 #define _ADM_JSDialogFactory_H
 
 #include "config.h"
-#include "ADM_libraries/ADM_smjs/jsapi.h"
+#include "jsapi.h"
 #include "DIA_factory.h"
 #include "ADM_JSDFMenu.h"
 #include <vector>

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.h	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.h	2009-04-25 23:09:35 UTC (rev 4762)
@@ -6,7 +6,7 @@
 #include "config.h"
 
 // Spidermonkey
-#include "ADM_libraries/ADM_smjs/jsapi.h"
+#include "jsapi.h"
 #include <string.h>
 #include "DirectorySearch.h"
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSGlobal.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSGlobal.h	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSGlobal.h	2009-04-25 23:09:35 UTC (rev 4762)
@@ -3,7 +3,7 @@
 
 // Spidermonkey
 
-#include "ADM_libraries/ADM_smjs/jsapi.h"
+#include "jsapi.h"
 #include <pthread.h>
 
 // javscript debugging helper

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt	2009-04-25 23:09:35 UTC (rev 4762)
@@ -6,7 +6,13 @@
 ADD_ADM_LIB_ALL_TARGETS(ADM_script ${ADM_script_SRCS})
 
 IF (WIN32)
-	ADD_CFLAGS_ALL_TARGETS(ADM_script "-DJS_THREADSAFE -DXP_WIN")
+	ADD_CFLAGS_ALL_TARGETS(ADM_script "-DXP_WIN")
 ELSE (WIN32)
-	ADD_CFLAGS_ALL_TARGETS(ADM_script "-DJS_THREADSAFE -DXP_UNIX")
-ENDIF (WIN32)
\ No newline at end of file
+	ADD_CFLAGS_ALL_TARGETS(ADM_script "-DXP_UNIX")
+ENDIF (WIN32)
+
+if (USE_SYSTEM_SPIDERMONKEY)
+	include_directories(${SPIDERMONKEY_INCLUDE_DIR})
+else (USE_SYSTEM_SPIDERMONKEY)
+	include_directories(${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries/ADM_smjs)
+endif (USE_SYSTEM_SPIDERMONKEY)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-04-25 23:09:35 UTC (rev 4762)
@@ -263,14 +263,19 @@
 	ADM_utilities
 	ADM_xvidratectl
 )
+
 ADD_LIB_ALL_TARGETS(
-	ADM_smjs
 	ADM_libavutil
 	ADM_libpostproc
 	ADM_libswscale
 	ADM_libavcodec
 	ADM_libavformat)
 
+if (USE_SYSTEM_SPIDERMONKEY)
+	ADD_LIB_ALL_TARGETS(${SPIDERMONKEY_LIBRARY_DIR})
+else (USE_SYSTEM_SPIDERMONKEY)
+	ADD_LIB_ALL_TARGETS(ADM_smjs)
+endif (USE_SYSTEM_SPIDERMONKEY)
 
 IF (ADM_DEBUG AND FIND_LEAKS)
 	ADD_ADMLIB_ALL_TARGETS(ADM_nvwa)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admCheckMiscLibs.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckMiscLibs.cmake	2009-04-25 12:22:15 UTC (rev 4761)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckMiscLibs.cmake	2009-04-25 23:09:35 UTC (rev 4762)
@@ -56,3 +56,20 @@
 ELSE (UNIX AND NOT APPLE)
 	SET(XVIDEO_CAPABLE FALSE)
 ENDIF (UNIX AND NOT APPLE)
+
+########################################
+# SpiderMonkey
+########################################
+OPTION(USE_SYSTEM_SPIDERMONKEY "" OFF)
+
+MESSAGE(STATUS "Checking for SpiderMonkey")
+MESSAGE(STATUS "*************************")
+
+IF (USE_SYSTEM_SPIDERMONKEY)
+	FIND_HEADER_AND_LIB(SPIDERMONKEY jsapi.h js JS_InitStandardClasses)
+	PRINT_LIBRARY_INFO("SpiderMonkey" SPIDERMONKEY_FOUND "${SPIDERMONKEY_INCLUDE_DIR}" "${SPIDERMONKEY_LIBRARY_DIR}" FATAL_ERROR)
+ELSE (USE_SYSTEM_SPIDERMONKEY)
+	MESSAGE("Skipping check and using bundled version.")
+ENDIF (USE_SYSTEM_SPIDERMONKEY)
+
+MESSAGE("")



From gruntster at mail.berlios.de  Sun Apr 26 13:03:18 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 26 Apr 2009 13:03:18 +0200
Subject: [Avidemux-svn-commit] r4763 - in
	branches/avidemux_2.5_branch_gruntster/platforms/windows:
	build_scripts build_scripts/avidemux installer
Message-ID: <200904261103.n3QB3IX7025475@sheep.berlios.de>

Author: gruntster
Date: 2009-04-26 13:03:11 +0200 (Sun, 26 Apr 2009)
New Revision: 4763

Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Set Avidemux Environment Variables.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
Log:
[Win32] update Win32 build scripts and installer to use own SpiderMonkey

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat	2009-04-25 23:09:35 UTC (rev 4762)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat	2009-04-26 11:03:11 UTC (rev 4763)
@@ -69,7 +69,7 @@
 	goto error
 )
 
-set PATH=%cmakeDir%;%mingwDir%\bin;%usrLocalDir%\bin;%msysDir%\bin;%qtDir%\bin;%PATH%
+set PATH=%PATH%;%cmakeDir%;%mingwDir%\bin;%usrLocalDir%\bin;%msysDir%\bin;%qtDir%\bin
 
 goto end
 

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat	2009-04-25 23:09:35 UTC (rev 4762)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat	2009-04-26 11:03:11 UTC (rev 4763)
@@ -4,7 +4,7 @@
 if errorlevel 1 goto error
 
 cd "%sourceDir%\build"
-cmake -G"MSYS Makefiles" -DCMAKE_INSTALL_PREFIX="%buildDir%" -DCMAKE_EXE_LINKER_FLAGS="-shared-libgcc" -DCMAKE_SHARED_LINKER_FLAGS="-shared-libgcc" ..
+cmake -G"MSYS Makefiles" -DCMAKE_INSTALL_PREFIX="%buildDir%" -DCMAKE_EXE_LINKER_FLAGS="-shared-libgcc" -DCMAKE_SHARED_LINKER_FLAGS="-shared-libgcc" -DUSE_SYSTEM_SPIDERMONKEY=ON -DCMAKE_INCLUDE_PATH="%SpiderMonkeySourceDir%" -DCMAKE_LIBRARY_PATH="%SpiderMonkeyLibDir%" ..
 
 if errorlevel 1 goto error
 pause

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml	2009-04-25 23:09:35 UTC (rev 4762)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml	2009-04-26 11:03:11 UTC (rev 4763)
@@ -1,5 +1,19 @@
 <?xml version="1.0"?>
 <log>
+  <buildentry revision="4758" date="2009-04-22">
+    <comment>Updated Avisynth Proxy GUI to version 2.08.</comment>
+    <comment>Updated x264 to r1145.</comment>
+  </buildentry>
+  <buildentry revision="4741" date="2009-04-20">
+    <comment>Updated GLib to version 2.20.1-1.</comment>
+    <comment>Updated GTK+ to version 2.16.1-1.</comment>
+    <comment>Updated Pango to version 1.24.0-1.</comment>
+  </buildentry>
+  <buildentry revision="4685" date="2009-03-14">
+  </buildentry>
+  <buildentry revision="4658" date="2009-03-05">
+    <comment>Updated Qt to version 4.5.0.</comment>
+  </buildentry>
   <buildentry revision="4648" date="2009-03-02">
     <comment>Updated x264 to r1115.</comment>
   </buildentry>

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Set Avidemux Environment Variables.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Set Avidemux Environment Variables.bat	2009-04-25 23:09:35 UTC (rev 4762)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Set Avidemux Environment Variables.bat	2009-04-26 11:03:11 UTC (rev 4763)
@@ -37,6 +37,9 @@
 	goto error
 )
 
+set SpiderMonkeySourceDir=%devDir%\js\src
+set SpiderMonkeyLibDir=%devDir%\js\src\WINNT6.0_OPT.OBJ
+
 goto end
 
 :error

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-04-25 23:09:35 UTC (rev 4762)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-04-26 11:03:11 UTC (rev 4763)
@@ -266,11 +266,12 @@
     ${File} freetype6.dll
     ${File} iconv.dll
     ${File} intl.dll
+    ${File} libjs.dll
+    ${File} nspr4.dll
     ${File} libADM_core.dll
     ${File} libADM_coreAudio.dll
     ${File} libADM_coreImage.dll
     ${File} libADM_coreUI.dll
-    ${File} libADM_smjs.dll
     ${File} libaften.dll
     ${File} libexpat-*.dll
     ${File} libfontconfig-1.dll



From mean at mail.berlios.de  Sun Apr 26 14:30:32 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 26 Apr 2009 14:30:32 +0200
Subject: [Avidemux-svn-commit] r4764 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904261230.n3QCUW7P017322@sheep.berlios.de>

Author: mean
Date: 2009-04-26 14:30:32 +0200 (Sun, 26 Apr 2009)
New Revision: 4764

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
Log:
[TSDemuxer] Also read audio track

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-26 11:03:11 UTC (rev 4763)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-26 12:30:32 UTC (rev 4764)
@@ -70,12 +70,12 @@
         printf("[tsDemux] Cannot read Video section of %s\n",idxName);
         goto abt;
     }
-#if 0
+
     if(!readAudio(&index,name)) 
     {
         printf("[tsDemux] Cannot read Audio section of %s => No audio\n",idxName);
     }
-#endif
+
     if(!readIndex(&index))
     {
         printf("[tsDemux] Cannot read index for file %s\n",idxName);

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-26 11:03:11 UTC (rev 4763)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-26 12:30:32 UTC (rev 4764)
@@ -59,7 +59,7 @@
 class ADM_tsAccess : public ADM_audioAccess
 {
 protected:
-                
+                TS_PESpacket    *packet;
                 tsPacket        demuxer;
                 uint8_t         pid;
                 uint64_t        dtsOffset;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp	2009-04-26 11:03:11 UTC (rev 4763)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsAudio.cpp	2009-04-26 12:30:32 UTC (rev 4764)
@@ -1,5 +1,5 @@
 /***************************************************************************
-    \file ADM_psAudio.cpp
+    \file ADM_tsAudio.cpp
 
     copyright            : (C) 2006/2009 by mean
     email                : fixounet at free.fr
@@ -37,6 +37,7 @@
         if(append) fp=FP_APPEND;
         this->pid=pid;
         if(!demuxer.open(name,fp)) ADM_assert(0);
+        packet=new TS_PESpacket(pid);
 }
 
 /**
@@ -45,6 +46,8 @@
 ADM_tsAccess::~ADM_tsAccess()
 {
     demuxer.close();
+    if(packet) delete packet;
+    packet=NULL;
 }
 /**
     \fn push
@@ -122,15 +125,17 @@
 bool      ADM_tsAccess::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
 {
 uint64_t p,d,start;
-    if(false==demuxer.getPacketOfType(pid,maxSize,size,&p,&d,buffer,&start)) return false;
-    if(d==ADM_NO_PTS) *dts=p;
-            else *dts=d;
-    *dts=timeConvert(*dts);
+    if(false==demuxer.getNextPES(packet)) return false;
+    int avail=packet->payloadSize-packet->offset;
+    if(avail>maxSize) ADM_assert(0);
+    *dts=packet->pts;
+    *size=avail;
+    memcpy(buffer,packet->payload+packet->offset,avail);
+    *dts=timeConvert(packet->pts);
     if(*dts!=ADM_NO_PTS) 
     {
         aprintf("[psAudio] getPacket dts = %"LU" ms\n",(uint32_t)*dts/1000);
     }
-
     return true;
 }
 

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-26 11:03:11 UTC (rev 4763)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-26 12:30:32 UTC (rev 4764)
@@ -30,7 +30,7 @@
 {
 char buffer[2000];
 bool firstAudio=true;
-        printf("[psDemuxer] Reading index\n");
+        printf("[TsDemuxerer] Reading index\n");
         if(!index->goToSection("Data")) return false;
       
         while(1)
@@ -98,7 +98,7 @@
             uint32_t offset;
             if(4!=sscanf(head,"at:%"LLX":%"LX" Pts:%"LLD":%"LLD,&startAt,&offset,&pts,&dts))
             {
-                    printf("[psDemuxer] cannot read fields in  :%s\n",buffer);
+                    printf("[TsDemuxerer] cannot read fields in  :%s\n",buffer);
                     return false;
             }
             
@@ -117,7 +117,7 @@
                 cur++;
                 if(*(cur)!=':')
                 {
-                    printf("[psDemux]  instead of : (%c %x %x):\n",*cur,*(cur-1),*cur);
+                    printf("[TsDemuxer]  instead of : (%c %x %x):\n",*cur,*(cur-1),*cur);
                 }
                 *cur++;
                 next=strstr(start," ");
@@ -167,7 +167,7 @@
 */
 bool    tsHeader::readVideo(indexFile *index)
 {
-    printf("[psDemuxer] Reading Video\n");
+    printf("[TsDemuxerer] Reading Video\n");
     if(!index->readSection("Video")) return false;
     uint32_t w,h,fps,ar;
     
@@ -208,7 +208,7 @@
     nbTracks=index->getAsUint32("Tracks");
     if(!nbTracks)
     {
-        printf("[PsDemux] No audio\n");
+        printf("[TsDemuxer] No audio\n");
         return true;
     }
     for(int i=0;i<nbTracks;i++)
@@ -229,14 +229,13 @@
             hdr.byterate=br;
             hdr.channels=chan;
             hdr.encoding=codec;
+
         ADM_tsAccess *access=new ADM_tsAccess(name,pid,true);
             ADM_tsTrackDescriptor *desc=new ADM_tsTrackDescriptor;
             desc->stream=NULL;
             desc->access=access;
             memcpy(&(desc->header),&hdr,sizeof(hdr));
             listOfAudioTracks.push_back(desc);
-
-
     }
     return true;
 }



From mean at mail.berlios.de  Sun Apr 26 14:30:35 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 26 Apr 2009 14:30:35 +0200
Subject: [Avidemux-svn-commit] r4765 - in branches/avidemux_2.6_branch_mean:
	avidemux/ADM_coreDemuxerMpeg/src
	avidemux/ADM_coreUtils/include plugins/ADM_demuxers/MpegTS
Message-ID: <200904261230.n3QCUZF6017354@sheep.berlios.de>

Author: mean
Date: 2009-04-26 14:30:35 +0200 (Sun, 26 Apr 2009)
New Revision: 4765

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/ADM_indexFile.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_videoInfoExtractor.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
Log:
[tsDemuxer] H264 indexer + refine frame type instead of just IDR/non IDR + fix readAsString

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/ADM_indexFile.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/ADM_indexFile.cpp	2009-04-26 12:30:32 UTC (rev 4764)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/ADM_indexFile.cpp	2009-04-26 12:30:35 UTC (rev 4765)
@@ -170,12 +170,14 @@
         if(!tail) 
         {
             printf("[psIndexer]Weird line :%s\n",buffer);
+            break;
+        }else
+        {
+            *tail=0;
+            tail++;
+            dmxToken *tk=new dmxToken(head,tail);
+            ListOfTokens.push_back(tk);
         }
-        *tail=0;
-        tail++;
-        dmxToken *tk=new dmxToken(head,tail);
-        ListOfTokens.push_back(tk);
-
     }
     return true;
 }
@@ -230,6 +232,19 @@
 {
     if(!fgets((char *)buffer,maxLen,file)) return false;
     buffer[maxLen-1]=0;
+    if(buffer[0])
+        while(1)
+        {
+            int l=strlen((char *)buffer);
+            if(!l) break;
+            char c=buffer[l-1];
+            if(c==0xa || c==0xd)
+            {
+                   buffer[l-1]=0;
+                   continue;
+            }
+            break;
+        }
     return true;
 }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_videoInfoExtractor.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_videoInfoExtractor.h	2009-04-26 12:30:32 UTC (rev 4764)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_videoInfoExtractor.h	2009-04-26 12:30:35 UTC (rev 4765)
@@ -18,7 +18,7 @@
 uint8_t extractMpeg4Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h,uint32_t *time_inc);
 uint8_t extractH263Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h);
 uint8_t extractVopInfo(uint8_t *data, uint32_t len,uint32_t timeincbits,uint32_t *vopType,uint32_t *modulo, uint32_t *time_inc);
-uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight);
+uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000, uint32_t *darNum, uint32_t *darDen);
 uint8_t extractH264FrameType(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags);
 uint8_t extractH264FrameType_startCode(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags);
 

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-26 12:30:32 UTC (rev 4764)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.h	2009-04-26 12:30:35 UTC (rev 4765)
@@ -63,6 +63,7 @@
                 tsPacket        demuxer;
                 uint8_t         pid;
                 uint64_t        dtsOffset;
+                uint32_t        videoCodec;
                 
 public:
                 bool            setTimeOffset(uint64_t of) {dtsOffset=of;return true;}

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-26 12:30:32 UTC (rev 4764)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-26 12:30:35 UTC (rev 4765)
@@ -26,7 +26,20 @@
 #include "ADM_tsAudioProbe.h"
 #include "DIA_working.h"
 #include "ADM_tsPatPmt.h"
+#include "ADM_videoInfoExtractor.h"
+#include "ADM_h264_tag.h"
 
+extern "C"
+{
+#define ADM_NO_CONFIG_H
+#include "libavutil/common.h"
+#include "libavutil/bswap.h"
+#define INT_MAX (0x7FFFFFFF)
+#include "ADM_lavcodec/bitstream.h"
+#include "ADM_lavcodec/golomb.h"
+}
+
+
 static const char Type[5]={'X','I','P','B','P'};
 
 static const uint32_t FPS[16]={
@@ -81,6 +94,12 @@
     markNow
 }markType;
 
+#if 1
+#define aprintf printf
+#else
+#define aprintf(...) {}
+#endif
+
 /**
     \class TsIndexer
 */
@@ -95,10 +114,11 @@
                 TsIndexer(listOfTsAudioTracks *tr);
                 ~TsIndexer();
         bool    runMpeg2(const char *file,ADM_TS_TRACK *videoTrac);
-        bool    writeVideo(PSVideo *video);
+        bool    runH264(const char *file,ADM_TS_TRACK *videoTrac);
+        bool    writeVideo(PSVideo *video,ADM_TS_TRACK_TYPE trkType);
         bool    writeAudio(void);
         bool    writeSystem(const char *filename,bool append);
-        bool    Mark(indexerData *data,dmxPacketInfo *s,markType update);
+        bool    Mark(indexerData *data,dmxPacketInfo *s,markType update,uint32_t formatOffset);
 
 };
 /**
@@ -143,6 +163,9 @@
             case ADM_TS_MPEG2: 
                             r=dx->runMpeg2(file,&(tracks[0]));
                             break;
+            case ADM_TS_H264: 
+                            r=dx->runH264(file,&(tracks[0]));
+                            break;
             default:
                         r=0;
                         break;
@@ -175,8 +198,196 @@
     ui=NULL;
 }
 /**
-    \fn run
+    \fn runH264
+    \brief Index H264 stream
 */  
+bool TsIndexer::runH264(const char *file,ADM_TS_TRACK *videoTrac)
+{
+bool    pic_started=false;
+bool    seq_found=false;
+
+PSVideo video;
+indexerData  data;    
+uint64_t fullSize;
+dmxPacketInfo info;
+
+    printf("Starting H264 indexer\n");
+    if(!videoTrac) return false;
+    if(videoTrac[0].trackType!=ADM_TS_H264)
+    {
+        printf("[Ts Indexer] Only H264 video supported\n");
+        return false;
+    }
+    video.pid=videoTrac[0].trackPid;
+
+    memset(&data,0,sizeof(data));
+    char indexName[strlen(file)+5];
+    sprintf(indexName,"%s.idx",file);
+    index=qfopen(indexName,"wt");
+    if(!index)
+    {
+        printf("[PsIndex] Cannot create %s\n",indexName);
+        return false;
+    }
+
+    writeSystem(file,true);
+    pkt=new tsPacketLinearTracker(videoTrac->trackPid, audioTracks);
+
+    FP_TYPE append=FP_APPEND;
+    pkt->open(file,append);
+    data.pkt=pkt;
+    fullSize=pkt->getSize();
+      while(1)
+      {
+
+        uint32_t code=0xffff+0xffff0000;
+        while((code!=1) && pkt->stillOk())
+        {
+            code=(code<<8)+pkt->readi8();
+        }
+        if(!pkt->stillOk()) break;
+        uint8_t startCode=pkt->readi8();
+
+        pkt->getInfo(&info);
+        info.offset-=5;
+
+//  1:0 2:Nal ref idc 5:Nal Type
+        if(startCode&0x80) continue; // Marker missing
+        
+
+#define T(x) case NAL_##x: aprintf(#x" found\n");break;
+        startCode&=0x1f;
+#ifdef ADM_H264_VERBOSE
+        switch(startCode)
+        {
+            T(NON_IDR);
+            T(IDR);
+            T(SPS);
+            T(PPS);
+            T(SEI);
+            T(AU_DELIMITER);
+            T(FILLER);
+          default :aprintf("0x%02x ?\n",startCode);
+        }
+#endif
+          
+              /* Till we have a SPS no need to continue */
+              if(!seq_found && startCode!=NAL_SPS) continue;
+              if(!seq_found) // It is a SPS
+              {
+                    // Our firt frame is here
+                    // Important to initialize the H264 decoder !
+                      uint8_t buffer[60] ; // should be enough
+                      uint32_t xA,xR;
+                      // Get info
+                      pkt->read(60,buffer);
+                      if (extractSPSInfo(buffer, 60, &video.w,&video.h,&video.fps,&xA,&xR))
+                      {
+						  
+                          printf("[TsIndexer] Found video %"LU"x%"LU", fps=%"LU"\n",video.w,video.h,video.fps);
+                          seq_found=1;
+                          Mark(&data,&info,markStart,4);
+                          data.state=idx_startAtGopOrSeq;
+                          writeVideo(&video,ADM_TS_H264);
+                          writeAudio();
+                          qfprintf(index,"[Data]");
+                          // Rewind
+#warning TODO
+                      }
+                      continue;
+              }
+              
+              // Ignore multiple chunk of the same pic
+              if((startCode==NAL_NON_IDR || startCode==NAL_IDR)&&pic_started) 
+              {
+                aprintf("Still capturing, ignore\n");
+                continue;
+              }
+           
+              
+              switch(startCode)
+                      {
+                      case NAL_AU_DELIMITER:
+							  pic_started = false;
+                              break;
+                      case NAL_SPS:
+                              pic_started = false;
+                              aprintf("Sps \n");
+							  Mark(&data,&info,markStart,4);
+                              data.state=idx_startAtGopOrSeq;
+							  break;
+                      case NAL_IDR:
+                        {
+                          markType update=markNow;
+						  uint32_t frameType = 1 ;
+                          if(data.state==idx_startAtGopOrSeq) 
+                          {
+                                update=markEnd;
+                          }
+						 
+						  data.frameType=frameType;
+                          pkt->readi8();
+                          pkt->readi8();
+                          pkt->readi8();
+                          pkt->readi8();
+                          Mark(&data,&info,update,4);
+                          data.state=idx_startAtImage;
+                          data.nbPics++;
+						  pic_started = true;
+                        }
+					  case NAL_NON_IDR:
+                        {
+                            #define NON_IDR_PRE_READ 8
+                          uint8_t header[NON_IDR_PRE_READ+4];
+                          GetBitContext s;
+
+                          markType update=markNow;
+						  uint32_t frameType = 2;
+                          if(data.state==idx_startAtGopOrSeq) 
+                          {
+                                update=markEnd;
+                          }
+#warning : need un-escaping!!!						 
+						  data.frameType=frameType;
+                          // Let's refine a bit the frame type...
+                          pkt->read(4,header);
+                          init_get_bits(&s, header, NON_IDR_PRE_READ*8);
+                          int first_mb_in_slice,slice_type;
+
+                            first_mb_in_slice= get_ue_golomb(&s);
+                            slice_type= get_ue_golomb_31(&s);
+                            if(slice_type>4) slice_type-=5;
+                            switch(slice_type)
+                            {
+
+                                case 0 : data.frameType=2;break; // P
+                                case 1 : data.frameType=3;break; // B
+                                case 2 : data.frameType=1;break; // I
+                                default : data.frameType=2;break; // SP/SI
+                            }
+                          Mark(&data,&info,update,4);
+                          data.state=idx_startAtImage;
+                          data.nbPics++;
+						  pic_started = true;
+                        }
+						  break;
+					  default:
+						  break;
+			  }
+      }
+        printf("\n");
+        Mark(&data,&info,markStart,0);
+        qfprintf(index,"\n[End]\n");
+        qfclose(index);
+        index=NULL;
+        audioTracks=NULL;
+        delete pkt;
+        pkt=NULL;
+        return true; 
+}
+/**
+    \fn runMpeg2
+*/  
 bool TsIndexer::runMpeg2(const char *file,ADM_TS_TRACK *videoTrac)
 {
 uint32_t temporal_ref,val;
@@ -228,7 +439,7 @@
           switch(startCode)
                   {
                   case 0xB3: // sequence start
-                          Mark(&data,&info,markStart);
+                          Mark(&data,&info,markStart,2);
                           data.state=idx_startAtGopOrSeq;
                           if(seq_found)
                           {
@@ -247,7 +458,7 @@
                           
                           video.fps= FPS[val & 0xf];
                           pkt->forward(4);
-                          writeVideo(&video);
+                          writeVideo(&video,ADM_TS_MPEG2);
                           writeAudio();
                           //pkt->resetStats();
                           qfprintf(index,"[Data]");
@@ -268,7 +479,7 @@
                                   continue;;
                           }
                           
-                          Mark(&data,&info,markStart);
+                          Mark(&data,&info,markStart,2);
                           data.state=idx_startAtGopOrSeq;
                           break;
                   case 0x00 : // picture
@@ -297,7 +508,7 @@
                                 update=markEnd;
                           }
                           data.frameType=type;
-                          Mark(&data,&info,update);
+                          Mark(&data,&info,update,2);
                           data.state=idx_startAtImage;
                           data.nbPics++;
                         }
@@ -308,7 +519,7 @@
       }
     
         printf("\n");
-        Mark(&data,&info,markStart);
+        Mark(&data,&info,markStart,2);
         qfprintf(index,"\n[End]\n");
         qfclose(index);
         index=NULL;
@@ -326,14 +537,16 @@
     If the beginning is not a pic, but a gop start for example, we had to add/remove those.
 
 */
-bool  TsIndexer::Mark(indexerData *data,dmxPacketInfo *info,markType update)
+bool  TsIndexer::Mark(indexerData *data,dmxPacketInfo *info,markType update,uint32_t formatOffset)
 {
     int offset=data->nextOffset;
     data->nextOffset=0;
     
+
+ 
      if( update==markStart)
      {
-                offset=2;
+                offset=formatOffset;
      }
     if(update==markStart || update==markNow)
     {
@@ -368,7 +581,7 @@
             }
             // start a new line
             qfprintf(index,"\nVideo at:%08"LLX":%04"LX" Pts:%08"LLD":%08"LLD" ",data->startAt,data->offset,info->pts,info->dts);
-            data->nextOffset=-2;
+            data->nextOffset=-formatOffset;
         }
     
         qfprintf(index,"%c",Type[data->frameType]);
@@ -389,7 +602,7 @@
     \fn writeVideo
     \brief Write Video section of index file
 */
-bool TsIndexer::writeVideo(PSVideo *video)
+bool TsIndexer::writeVideo(PSVideo *video,ADM_TS_TRACK_TYPE trkType)
 {
     qfprintf(index,"[Video]\n");
     qfprintf(index,"Width=%d\n",video->w);
@@ -398,6 +611,13 @@
     qfprintf(index,"Interlaced=%d\n",video->interlaced);
     qfprintf(index,"AR=%d\n",video->ar);
     qfprintf(index,"Pid=%d\n",video->pid);
+ switch(trkType)
+    {
+        case ADM_TS_MPEG2: qfprintf(index,"VideoCodec=Mpeg2\n");break;;
+        case ADM_TS_H264: qfprintf(index,"VideoCodec=H264\n");break;
+        default: printf("[TsIndexer] Unsupported video codec\n");return false;
+
+    }
     return true;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-26 12:30:32 UTC (rev 4764)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-26 12:30:35 UTC (rev 4765)
@@ -174,6 +174,21 @@
     w=index->getAsUint32("Width");
     h=index->getAsUint32("height");
     fps=index->getAsUint32("Fps");
+    char *type=index->getAsString("VideoCodec");
+    if(type)
+    {
+        printf("[TsIndex] codec :<%s>\n",type);
+        if(!strcmp(type,"H264"))
+        {
+             _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"H264");
+        }else
+        {
+            _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"MPEG");
+        }
+    }else
+    {
+       _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"MPEG");
+    }
     videoPid=index->getAsUint32("Pid");
     if(!videoPid)
     {
@@ -189,9 +204,6 @@
     _video_bih.biHeight=_mainaviheader.dwHeight=h;             
     _videostream.dwScale=1000;
     _videostream.dwRate=fps;
-
-    _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"MPEG");
-
     return true;
 }
 /**



From gruntster at mail.berlios.de  Sun Apr 26 17:41:59 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 26 Apr 2009 17:41:59 +0200
Subject: [Avidemux-svn-commit] r4766 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264
Message-ID: <200904261541.n3QFfx4l002021@sheep.berlios.de>

Author: gruntster
Date: 2009-04-26 17:41:53 +0200 (Sun, 26 Apr 2009)
New Revision: 4766

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h
Log:
[x264] always return flag after creating header

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-04-26 12:30:35 UTC (rev 4765)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-04-26 15:41:53 UTC (rev 4766)
@@ -402,7 +402,7 @@
 	return ADM_VIDENC_ERR_SUCCESS;
 }
 
-int x264Encoder::createHeader(void)
+bool x264Encoder::createHeader(void)
 {
 	x264_nal_t *nal;
 	int nalCount;
@@ -415,12 +415,12 @@
 	int sz;
 
 	if (!_handle)
-		return ADM_VIDENC_ERR_FAILED;
+		return false;
 
 	if (x264_encoder_headers(_handle, &nal, &nalCount))
 	{
 		printf("[x264] Cannot create header\n");
-		return ADM_VIDENC_ERR_FAILED;
+		return false;
 	}
 
 	if (_extraData)
@@ -454,7 +454,7 @@
 		{
 			printf("[x264] Cannot encode nal header %d\n", i);
 
-			return ADM_VIDENC_ERR_FAILED;
+			return false;
 		}
 	}
 
@@ -463,7 +463,7 @@
 	if (!picParamLen || !seqParamLen)
 	{
 		printf("[x264] Seqparam or PicParam not found\n");
-		return ADM_VIDENC_ERR_FAILED;
+		return false;
 	}
 
 	// Fill header
@@ -504,8 +504,7 @@
 	_extraDataSize = offset;
 
 	printf("[x264] generated %d extra bytes for header\n", _extraDataSize);
-
-	//assert(offset < X264_MAX_HEADER_SIZE);
+	return true;
 }
 
 int x264Encoder::finishPass(void)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h	2009-04-26 12:30:35 UTC (rev 4765)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h	2009-04-26 15:41:53 UTC (rev 4766)
@@ -62,7 +62,7 @@
 		void printCqm(const uint8_t cqm[], int size);
 		void updateEncodeParameters(vidEncVideoProperties *properties);
 		unsigned int calculateBitrate(unsigned int fpsNum, unsigned int fpsDen, unsigned int frameCount, unsigned int sizeInMb);
-		int createHeader(void);
+		bool createHeader(void);
 
 	public:
 		x264Encoder(void);



From mean at mail.berlios.de  Tue Apr 28 07:38:08 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 28 Apr 2009 07:38:08 +0200
Subject: [Avidemux-svn-commit] r4768 -
	branches/avidemux_2.6_branch_mean/avidemux
Message-ID: <200904280538.n3S5c8nx012331@sheep.berlios.de>

Author: mean
Date: 2009-04-28 07:38:07 +0200 (Tue, 28 Apr 2009)
New Revision: 4768

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
Log:
[Tools] Fix hexDump

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-04-27 17:17:42 UTC (rev 4767)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-04-28 05:38:07 UTC (rev 4768)
@@ -1689,9 +1689,9 @@
  image.data=buffer;
 
 
- video_body->getFrame (curframe,&image,&seq);
+ video_body->getFrame (video_body->getCurrentFrame(),&image,&seq);
  fullLen=image.dataLength;
- video_body->getFlags (curframe, &flags);
+ video_body->getFlags (video_body->getCurrentFrame(), &flags);
 
  diaElemHex binhex("*****",fullLen,buffer);
 



From mean at mail.berlios.de  Tue Apr 28 07:38:10 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 28 Apr 2009 07:38:10 +0200
Subject: [Avidemux-svn-commit] r4769 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904280538.n3S5cAm8012480@sheep.berlios.de>

Author: mean
Date: 2009-04-28 07:38:10 +0200 (Tue, 28 Apr 2009)
New Revision: 4769

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
Log:
[MpegTs] Mostly correct H264/Ts indexer, still a bug in the offset area

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-28 05:38:07 UTC (rev 4768)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-04-28 05:38:10 UTC (rev 4769)
@@ -276,6 +276,7 @@
 {
     if(frame>=ListOfFrames.size()) return 0;
     dmxFrame *pk=ListOfFrames[frame];
+    // next frame
     if(frame==(lastFrame+1) && pk->type!=1)
     {
         lastFrame++;
@@ -288,6 +289,7 @@
              getFlags(frame,&(img->flags));
              return r;
     }
+    // Intra ?
     if(pk->type==1)
     {
         if(!tsPacket->seek(pk->startAt,pk->index)) return false;
@@ -302,8 +304,41 @@
              return r;
 
     }
-    printf(" [tsDemux] lastFrame :%d this frame :%d\n",lastFrame,frame);
-    return false;
+    
+    // Random frame
+    // Need to rewind, then forward
+    int startPoint=frame;
+    while(startPoint && !ListOfFrames[startPoint]->startAt) startPoint--;
+    printf("[tsDemux] Wanted frame %"LU", going back to frame %"LU", last frame was %"LU",\n",frame,startPoint,lastFrame);
+    pk=ListOfFrames[startPoint];
+    if(!tsPacket->seek(pk->startAt,pk->index)) 
+    {
+            printf("[tsDemux] Failed to rewind to frame %"LU"\n",startPoint);
+            return false;
+    }
+    // Now forward
+    while(startPoint<frame)
+    {
+        pk=ListOfFrames[startPoint];
+        if(!tsPacket->read(pk->len,img->data))
+        {
+            printf("[tsDemux] Read fail for frame %"LU"\n",startPoint);
+            lastFrame=0xffffffff;
+            return false;
+        }
+        startPoint++;
+        lastFrame=startPoint;
+    }
+    pk=ListOfFrames[frame];
+    lastFrame++;
+    bool r=tsPacket->read(pk->len,img->data);
+         img->dataLength=pk->len;
+         img->demuxerFrameNo=frame;
+         img->demuxerDts=pk->dts;
+         img->demuxerPts=pk->pts;
+         //printf("[>>>] %d:%02x %02x %02x %02x\n",frame,img->data[0],img->data[1],img->data[2],img->data[3]);
+         getFlags(frame,&(img->flags));
+         return r;
 }
 /**
         \fn getExtraHeaderData

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-28 05:38:07 UTC (rev 4768)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-04-28 05:38:10 UTC (rev 4769)
@@ -167,7 +167,8 @@
 _failTs:
     delete t;
     // Delete the list
-    list.erase(list.begin(),list.end()-1);
+    if(list.size())
+        list.erase(list.begin(),list.end()-1);
     if(result==true)
     {
         printf("[T Demuxer] Kept %d tracks\n",*nbTracks);

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-28 05:38:07 UTC (rev 4768)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsReadIndex.cpp	2009-04-28 05:38:10 UTC (rev 4769)
@@ -113,7 +113,7 @@
                 char *next;
                 uint32_t len;
                 type=*cur;
-                if(type==0x0a || type==0x0d) break;
+                if(type==0x0a || type==0x0d || !type) break;
                 cur++;
                 if(*(cur)!=':')
                 {



From mean at mail.berlios.de  Thu Apr 30 19:07:04 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 30 Apr 2009 19:07:04 +0200
Subject: [Avidemux-svn-commit] r4770 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS
Message-ID: <200904301707.n3UH74IK011047@sheep.berlios.de>

Author: mean
Date: 2009-04-30 19:07:02 +0200 (Thu, 30 Apr 2009)
New Revision: 4770

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
Log:
[Plugin/Ts] Change way of indexing

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-28 05:38:10 UTC (rev 4769)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-30 17:07:02 UTC (rev 4770)
@@ -78,8 +78,8 @@
 }indexerState;
 typedef struct
 {
-    uint64_t pts,dts,startAt;
-    uint32_t offset;
+    uint64_t pts,dts; //startAt;
+    //uint32_t offset;
     uint32_t frameType;
     uint32_t nbPics;
     indexerState state;
@@ -106,6 +106,10 @@
 class TsIndexer
 {
 protected:
+        uint32_t        currentFrameType;
+        uint32_t        beginConsuming;
+        indexerState    currentIndexState;
+protected:
         FILE *index;
         tsPacketLinearTracker  *pkt;
         listOfTsAudioTracks    *audioTracks;
@@ -118,7 +122,7 @@
         bool    writeVideo(PSVideo *video,ADM_TS_TRACK_TYPE trkType);
         bool    writeAudio(void);
         bool    writeSystem(const char *filename,bool append);
-        bool    Mark(indexerData *data,dmxPacketInfo *s,markType update,uint32_t formatOffset);
+        bool    Mark(indexerData *data,dmxPacketInfo *s,uint32_t overRead);
 
 };
 /**
@@ -210,7 +214,7 @@
 indexerData  data;    
 uint64_t fullSize;
 dmxPacketInfo info;
-
+#if 0
     printf("Starting H264 indexer\n");
     if(!videoTrac) return false;
     if(videoTrac[0].trackType!=ADM_TS_H264)
@@ -280,13 +284,13 @@
                       uint8_t buffer[60] ; // should be enough
                       uint32_t xA,xR;
                       // Get info
-                      pkt->read(60,buffer);
-                      if (extractSPSInfo(buffer, 60, &video.w,&video.h,&video.fps,&xA,&xR))
+                      pkt->read(16,buffer);
+                      if (extractSPSInfo(buffer, 16, &video.w,&video.h,&video.fps,&xA,&xR))
                       {
 						  
                           printf("[TsIndexer] Found video %"LU"x%"LU", fps=%"LU"\n",video.w,video.h,video.fps);
                           seq_found=1;
-                          Mark(&data,&info,markStart,4);
+                          Mark(&data,&info,markStart,4+16);
                           data.state=idx_startAtGopOrSeq;
                           writeVideo(&video,ADM_TS_H264);
                           writeAudio();
@@ -383,8 +387,10 @@
         audioTracks=NULL;
         delete pkt;
         pkt=NULL;
+#endif
         return true; 
 }
+//***********************************************************************
 /**
     \fn runMpeg2
 */  
@@ -408,6 +414,8 @@
     video.pid=videoTrac[0].trackPid;
 
     memset(&data,0,sizeof(data));
+
+
     char indexName[strlen(file)+5];
     sprintf(indexName,"%s.idx",file);
     index=qfopen(indexName,"wt");
@@ -433,16 +441,16 @@
         if(!pkt->stillOk()) break;
         uint8_t startCode=pkt->readi8();
 
-        pkt->getInfo(&info);
-        info.offset-=4;
 
           switch(startCode)
                   {
                   case 0xB3: // sequence start
-                          Mark(&data,&info,markStart,2);
-                          data.state=idx_startAtGopOrSeq;
                           if(seq_found)
                           {
+                                  pkt->getInfo(&info);
+                                  data.frameType=1;
+                                  Mark(&data,&info,4);
+                                  data.state=idx_startAtGopOrSeq;
                                   pkt->forward(8);  // Ignore
                                   continue;
                           }
@@ -454,19 +462,24 @@
                           video.h= (((val>>8) & 0xfff)+15)& ~15;
 
                           video.ar = (val >> 4) & 0xf;
-
-                          
                           video.fps= FPS[val & 0xf];
                           pkt->forward(4);
                           writeVideo(&video,ADM_TS_MPEG2);
                           writeAudio();
-                          //pkt->resetStats();
                           qfprintf(index,"[Data]");
+                          pkt->getInfo(&info);
+                          data.frameType=1;
+                          Mark(&data,&info,4+8);
+                          data.state=idx_startAtGopOrSeq;
+                          continue;
+
                           break;
                   case 0xb8: // GOP
                           // Update ui
                             {
-                                float pos=data.startAt;
+                                uint64_t p;
+                                p=pkt->getPos();
+                                float pos=p;
                                 pos=pos/(float)fullSize;
                                 pos*=100;
                                 ui->update( (uint32_t)pos);
@@ -478,8 +491,8 @@
                           {         
                                   continue;;
                           }
-                          
-                          Mark(&data,&info,markStart,2);
+                          pkt->getInfo(&info);
+                          Mark(&data,&info,4);
                           data.state=idx_startAtGopOrSeq;
                           break;
                   case 0x00 : // picture
@@ -505,12 +518,17 @@
                           
                           if(data.state==idx_startAtGopOrSeq) 
                           {
-                                update=markEnd;
-                          }
-                          data.frameType=type;
-                          Mark(&data,&info,update,2);
-                          data.state=idx_startAtImage;
-                          data.nbPics++;
+                                  currentFrameType=type;
+                          }else
+                            {
+                                  data.frameType=type;
+                                  pkt->getInfo(&info);
+                                  Mark(&data,&info,4+2);
+
+
+                            }
+                            data.state=idx_startAtImage;
+                            data.nbPics++;
                         }
                           break;
                   default:
@@ -519,7 +537,7 @@
       }
     
         printf("\n");
-        Mark(&data,&info,markStart,2);
+        Mark(&data,&info,2);
         qfprintf(index,"\n[End]\n");
         qfclose(index);
         index=NULL;
@@ -537,36 +555,26 @@
     If the beginning is not a pic, but a gop start for example, we had to add/remove those.
 
 */
-bool  TsIndexer::Mark(indexerData *data,dmxPacketInfo *info,markType update,uint32_t formatOffset)
+bool  TsIndexer::Mark(indexerData *data,dmxPacketInfo *info,uint32_t overRead)
 {
-    int offset=data->nextOffset;
-    data->nextOffset=0;
-    
-
- 
-     if( update==markStart)
-     {
-                offset=formatOffset;
-     }
-    if(update==markStart || update==markNow)
-    {
+      
+        uint32_t consumed=pkt->getConsumed()-overRead;
         if(data->nbPics)
         {
-            // Write previous image data (size) : TODO
-            qfprintf(index,":%06"LX" ",data->pkt->getConsumed()+offset); // Size
+            qfprintf(index," %c:%06"LX,Type[currentFrameType],consumed-beginConsuming);
+            beginConsuming=consumed;
+        }else
+        {
+            beginConsuming=overRead;
+            pkt->setConsumed(beginConsuming);
         }
-        else data->pkt->getConsumed();
-    }
-    if(update==markEnd || update==markNow)
-    {
+            
+        // If audio, also dump audio
         if(data->frameType==1)
         {
-
-            // If audio, also dump audio
             if(audioTracks)
             {
-
-                qfprintf(index,"\nAudio bf:%08"LLX" ",data->startAt);
+                qfprintf(index,"\nAudio bf:%08"LLX" ",info->startAt);
                 packetTSStats *s;
                 uint32_t na;
                 pkt->getStats(&na,&s);      
@@ -576,26 +584,14 @@
                     packetTSStats *current=s+i;
                     qfprintf(index,"Pes:%x:%08"LLX":%"LD":%"LLD" ",
                                 current->pid,current->startAt,current->startSize,current->startDts);
-                }
-                
+                }                
             }
             // start a new line
-            qfprintf(index,"\nVideo at:%08"LLX":%04"LX" Pts:%08"LLD":%08"LLD" ",data->startAt,data->offset,info->pts,info->dts);
-            data->nextOffset=-formatOffset;
+            qfprintf(index,"\nVideo at:%08"LLX":%04"LX" Pts:%08"LLD":%08"LLD" ",info->startAt,info->offset-overRead,info->pts,info->dts);
         }
-    
-        qfprintf(index,"%c",Type[data->frameType]);
-    }
-    if(update==markEnd || update==markNow)
-    {
-        data->pts=info->pts;
-        data->dts=info->dts;
-    }
-    if(update==markStart || update==markNow)
-    {
-        data->startAt=info->startAt;
-        data->offset=info->offset;
-    }
+        currentFrameType=data->frameType;
+        
+    return true;
 }
 
 /**

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-28 05:38:10 UTC (rev 4769)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2009-04-30 17:07:02 UTC (rev 4770)
@@ -687,10 +687,19 @@
 uint32_t tsPacketLinear::getConsumed(void)
 {
     uint32_t c=consumed;
-    consumed=0;
     return c;
 }
 /**
+    \fn setConsumed
+    \brief set consumed bytes
+*/
+bool tsPacketLinear::setConsumed(uint32_t v)
+{
+    consumed=v;
+    return true;
+}
+
+/**
     \fn changePid
     \brief change the pid of the stream we read (used when probing all tracks)
 */

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-28 05:38:10 UTC (rev 4769)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/dmxTSPacket.h	2009-04-30 17:07:02 UTC (rev 4770)
@@ -115,7 +115,7 @@
 
     bool                getNextPSI(uint32_t pid,TS_PSIpacketInfo *psi);
     bool                getNextPES(TS_PESpacket *pes);
-
+    
 };
 /**
     \class tsPacketLinear
@@ -148,6 +148,7 @@
         bool    getInfo(dmxPacketInfo *info);
         bool    seek(uint64_t packetStart, uint32_t offset);
         bool    changePid(uint32_t pid) ;
+        bool    setConsumed(uint32_t v);
 };
 
 /**



From mean at mail.berlios.de  Thu Apr 30 19:07:17 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 30 Apr 2009 19:07:17 +0200
Subject: [Avidemux-svn-commit] r4771 - in branches/avidemux_2.6_branch_mean:
	avidemux/ADM_editor plugins/ADM_demuxers/MpegTS
Message-ID: <200904301707.n3UH7Hxe011128@sheep.berlios.de>

Author: mean
Date: 2009-04-30 19:07:07 +0200 (Thu, 30 Apr 2009)
New Revision: 4771

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
Log:
[Ts] Simplified indexer, mostly ok, seek does not work

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edRender.cpp	2009-04-30 17:07:02 UTC (rev 4770)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edRender.cpp	2009-04-30 17:07:07 UTC (rev 4771)
@@ -175,7 +175,8 @@
     }
     if(found==false)
     {
-        printf("[GoToIntra] Could not find decoded frame!\n");
+        printf("[GoToIntra] Could not find decoded frame :%"LU" PTS=%"LLU" ms, %"LLU" us\n",frame,wantedPts/1000,wantedPts);
+        cache->dump();
         return false;
     }
     vid->lastReadPts=wantedPts;
@@ -246,7 +247,7 @@
             return true;
         }else   
         {
-            printf("[getNextPic] Loop:%d, looking for pts :%"LLU"\n",loop,vid->lastReadPts/1000);
+            printf("[getNextPic] Loop:%d, looking for pts :%"LLU" ms %"LLU" us\n",loop,vid->lastReadPts/1000,vid->lastReadPts);
             cache->dump();
         }
     }

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-30 17:07:02 UTC (rev 4770)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-04-30 17:07:07 UTC (rev 4771)
@@ -214,7 +214,7 @@
 indexerData  data;    
 uint64_t fullSize;
 dmxPacketInfo info;
-#if 0
+
     printf("Starting H264 indexer\n");
     if(!videoTrac) return false;
     if(videoTrac[0].trackType!=ADM_TS_H264)
@@ -250,10 +250,9 @@
             code=(code<<8)+pkt->readi8();
         }
         if(!pkt->stillOk()) break;
-        uint8_t startCode=pkt->readi8();
+        uint8_t startCode=pkt->readi8(); // Read 5 bytes so far
 
-        pkt->getInfo(&info);
-        info.offset-=5;
+       
 
 //  1:0 2:Nal ref idc 5:Nal Type
         if(startCode&0x80) continue; // Marker missing
@@ -290,11 +289,13 @@
 						  
                           printf("[TsIndexer] Found video %"LU"x%"LU", fps=%"LU"\n",video.w,video.h,video.fps);
                           seq_found=1;
-                          Mark(&data,&info,markStart,4+16);
                           data.state=idx_startAtGopOrSeq;
                           writeVideo(&video,ADM_TS_H264);
                           writeAudio();
                           qfprintf(index,"[Data]");
+                          data.frameType=1; // Force dump
+                          pkt->getInfo(&info);                          
+                          Mark(&data,&info,5+16);
                           // Rewind
 #warning TODO
                       }
@@ -314,50 +315,27 @@
                       case NAL_AU_DELIMITER:
 							  pic_started = false;
                               break;
+#if 0
                       case NAL_SPS:
                               pic_started = false;
                               aprintf("Sps \n");
-							  Mark(&data,&info,markStart,4);
+                              pkt->getInfo(&info);
+                              data.frameType=1;
+							  Mark(&data,&info,5);
                               data.state=idx_startAtGopOrSeq;
 							  break;
+#endif
                       case NAL_IDR:
+                      case NAL_NON_IDR:
                         {
-                          markType update=markNow;
-						  uint32_t frameType = 1 ;
-                          if(data.state==idx_startAtGopOrSeq) 
-                          {
-                                update=markEnd;
-                          }
-						 
-						  data.frameType=frameType;
-                          pkt->readi8();
-                          pkt->readi8();
-                          pkt->readi8();
-                          pkt->readi8();
-                          Mark(&data,&info,update,4);
-                          data.state=idx_startAtImage;
-                          data.nbPics++;
-						  pic_started = true;
-                        }
-					  case NAL_NON_IDR:
-                        {
-                            #define NON_IDR_PRE_READ 8
+#define NON_IDR_PRE_READ 8
                           uint8_t header[NON_IDR_PRE_READ+4];
                           GetBitContext s;
+                       
+                            pkt->read(4,header);
+                            init_get_bits(&s, header, NON_IDR_PRE_READ*8);
+                            int first_mb_in_slice,slice_type;
 
-                          markType update=markNow;
-						  uint32_t frameType = 2;
-                          if(data.state==idx_startAtGopOrSeq) 
-                          {
-                                update=markEnd;
-                          }
-#warning : need un-escaping!!!						 
-						  data.frameType=frameType;
-                          // Let's refine a bit the frame type...
-                          pkt->read(4,header);
-                          init_get_bits(&s, header, NON_IDR_PRE_READ*8);
-                          int first_mb_in_slice,slice_type;
-
                             first_mb_in_slice= get_ue_golomb(&s);
                             slice_type= get_ue_golomb_31(&s);
                             if(slice_type>4) slice_type-=5;
@@ -369,25 +347,34 @@
                                 case 2 : data.frameType=1;break; // I
                                 default : data.frameType=2;break; // SP/SI
                             }
-                          Mark(&data,&info,update,4);
+
+                          if(data.state==idx_startAtGopOrSeq) 
+                          {
+                                  currentFrameType=data.frameType;;
+                                  
+                          }else
+                          {
+                                pkt->getInfo(&info);
+                                Mark(&data,&info,5+4);
+                           }
                           data.state=idx_startAtImage;
                           data.nbPics++;
 						  pic_started = true;
                         }
-						  break;
+					  
+                        break;
 					  default:
 						  break;
 			  }
       }
         printf("\n");
-        Mark(&data,&info,markStart,0);
+        Mark(&data,&info,0);
         qfprintf(index,"\n[End]\n");
         qfclose(index);
         index=NULL;
         audioTracks=NULL;
         delete pkt;
         pkt=NULL;
-#endif
         return true; 
 }
 //***********************************************************************
@@ -564,7 +551,7 @@
             qfprintf(index," %c:%06"LX,Type[currentFrameType],consumed-beginConsuming);
             beginConsuming=consumed;
         }else
-        {
+        {  // Our first Pic
             beginConsuming=overRead;
             pkt->setConsumed(beginConsuming);
         }



