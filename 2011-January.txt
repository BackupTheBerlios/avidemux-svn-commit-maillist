From mean at mail.berlios.de  Sat Jan  1 09:49:19 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat,  1 Jan 2011 09:49:19 +0100
Subject: [Avidemux-svn-commit] r6907 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_toolkit
Message-ID: <20110101084919.5A84C48079E@sheep.berlios.de>

Author: mean
Date: 2011-01-01 09:49:18 +0100 (Sat, 01 Jan 2011)
New Revision: 6907

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
Log:
[cleanup] Remove unused global variable (wavinfo)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2010-12-31 21:23:09 UTC (rev 6906)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2011-01-01 08:49:18 UTC (rev 6907)
@@ -512,6 +512,7 @@
    printf("   Aspect Ratio: %s (%u:%u)\n", s,war,har);
 
    printf("Audio\n");
+   WAVHeader *wavinfo=video_body->getInfo();
    if( wavinfo )
     {
       printf("   Codec: %s\n",getStrFromAudioCodec(wavinfo->encoding));

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h	2010-12-31 21:23:09 UTC (rev 6906)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h	2011-01-01 08:49:18 UTC (rev 6907)
@@ -54,11 +54,6 @@
 =(aviInfo *)NULL
 #endif
 ;
-EXTERN WAVHeader *wavinfo
-#ifdef __DECLARE__
-=(WAVHeader *)NULL
-#endif
-;
 /**
 	If set to 1, means video is in process mode_preview
 	If set to 0, copy mode

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2010-12-31 21:23:09 UTC (rev 6906)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2011-01-01 08:49:18 UTC (rev 6907)
@@ -588,6 +588,7 @@
 //  getFirstVideoFilter(); // reinit first filter
 
   // now get audio information if exists
+  WAVHeader *wavinfo;
   wavinfo = video_body->getInfo ();	//wavinfo); // will be null if no audio
   if (!wavinfo)
     {
@@ -1185,7 +1186,7 @@
       }
       delete avifileinfo;
       //delete wavinfo;
-      wavinfo = NULL;
+      
       avifileinfo = NULL;
       video_body->cleanup ();
       // Audio streams are cleared by editor

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2010-12-31 21:23:09 UTC (rev 6906)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2011-01-01 08:49:18 UTC (rev 6907)
@@ -355,7 +355,7 @@
 
     channels= playbackAudio->getInfo()->channels;
     frequency=playbackAudio->getInfo()->frequency;
-    preload=  (wavinfo->frequency * channels)/5;	// 200 ms preload
+    preload=  (frequency * channels)/5;	// 200 ms preload
     // 4 sec buffer..
     wavbuf =  (float *)  ADM_alloc((20*sizeof(float)*preload)); // 4 secs buffers
     ADM_assert(wavbuf);
@@ -389,7 +389,7 @@
     AVDM_AudioPlay(wavbuf, fill);
     // Let audio latency sets in...
     ticktock.reset();
-    uint32_t slice=(wavinfo->frequency * channels)/100; // 10 ms
+    uint32_t slice=(frequency * channels)/100; // 10 ms
     // pump data until latency is over
     updateVu();
     #if 0



From mean at mail.berlios.de  Sat Jan  1 09:49:22 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat,  1 Jan 2011 09:49:22 +0100
Subject: [Avidemux-svn-commit] r6908 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <20110101084922.4CDAC48079E@sheep.berlios.de>

Author: mean
Date: 2011-01-01 09:49:22 +0100 (Sat, 01 Jan 2011)
New Revision: 6908

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
Log:
[cleanup] Remove unused global variable (secondaudiostream)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h	2011-01-01 08:49:18 UTC (rev 6907)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h	2011-01-01 08:49:22 UTC (rev 6908)
@@ -42,11 +42,6 @@
 =(ADM_audioStream *)NULL
 #endif
 ;
-EXTERN ADM_audioStream *secondaudiostream
-#ifdef __DECLARE__
-=(ADM_audioStream *)NULL
-#endif
-;
 
 ;
 EXTERN aviInfo   *avifileinfo

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2011-01-01 08:49:18 UTC (rev 6907)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2011-01-01 08:49:22 UTC (rev 6908)
@@ -731,11 +731,6 @@
 		aviaudiostream=NULL;
 	}
 #endif
-	if (secondaudiostream)
-	{
-		delete secondaudiostream;
-		secondaudiostream=NULL;
-	}
 #if 0
 	if (currentAudioName)
 	{
@@ -743,11 +738,6 @@
 		currentAudioName = NULL;
 	}
 
-	if (secondAudioName)
-	{
-		ADM_dealloc(secondAudioName);
-		secondAudioName = NULL;
-	}
 #endif
 
 	if (video_body)
@@ -965,133 +955,7 @@
 */
 void A_externalAudioTrack( void )
 {
-#if 0
-        uint32_t old,nw;
-        uint32_t oldtrack,newtrack;
-        char  *newtrackname=ADM_strdup(secondAudioName);
-
-   diaMenuEntry sourcesStream[]={
-            {AudioNone,QT_TR_NOOP("None"),QT_TR_NOOP("No audio")},
-            {AudioAC3,QT_TR_NOOP("External AC3"),QT_TR_NOOP("Take audio from external AC3 file")},
-            {AudioMP3,QT_TR_NOOP("External MP3"),QT_TR_NOOP("Take audio from external MP3 file")},
-            {AudioWav,QT_TR_NOOP("External WAV"),QT_TR_NOOP("Take audio from external WAV file")}
-        };
-
-        old=nw=secondAudioSource;
-
-        diaElemMenu     sourceMenu(&nw,QT_TR_NOOP("_Audio source:"),4,sourcesStream,NULL);
-        diaElemFile     sourceName(0,&newtrackname,QT_TR_NOOP("_External file:"), NULL, QT_TR_NOOP("Select file"));
-        diaElem *allWidgets[]={&sourceMenu,&sourceName};
-
-  /* Link..*/
-
-         sourceMenu.link(&(sourcesStream[2]),1,&sourceName);
-         sourceMenu.link(&(sourcesStream[3]),1,&sourceName);
-         sourceMenu.link(&(sourcesStream[1]),1,&sourceName);
-
-         if( !diaFactoryRun(QT_TR_NOOP("Second Audio Track"),2,allWidgets)) return;
-         if(!ADM_fileExist(newtrackname))
-         {
-           GUI_Info_HIG(ADM_LOG_INFO,QT_TR_NOOP("Cannot load"),QT_TR_NOOP("The selected audio file does not exist."));
-           return;
-         }
-        if(secondAudioSource!=AudioNone)
-        {
-                 delete secondaudiostream;
-                 secondAudioSource=AudioNone;
-                 secondaudiostream=NULL;
-                 if(secondAudioName) ADM_dealloc(secondAudioName);
-                 secondAudioName=NULL;
-        }
-       secondAudioSource=(AudioSource)nw;
-        A_setSecondAudioTrack(secondAudioSource,newtrackname);
-        if(newtrackname) ADM_dealloc(newtrackname);
-#endif
 }
-#if 0
-uint8_t A_setSecondAudioTrack(const AudioSource nw,char *name)
-{
-
-        switch(nw)
-        {
-                case AudioNone:break;
-                case AudioMP3:
-                        {
-                        AVDMMP3AudioStream *tmp;
-                        if(!name) break;
-                        tmp = new AVDMMP3AudioStream ();
-                        if (!tmp->open (name))
-                        {
-                                delete tmp;
-                                GUI_Error_HIG(QT_TR_NOOP("Error loading the MP3 file"), NULL);
-
-                        }
-                        else
-                        {
-/*                                secondaudiostream = tmp;
-                                secondAudioSource=AudioMP3;
-                                secondAudioName=ADM_strdup(name);
-                                printf ("\n MP3 loaded\n");
-                                GUI_Info_HIG(ADM_LOG_INFO,QT_TR_NOOP("Second track loaded"), NULL);
-*/
-                                return 1;
-                        }
-                        }
-                        break;
-                case AudioAC3:
-                          {
-                        AVDMAC3AudioStream *tmp;
-                        if(!name) break;
-
-                        tmp = new AVDMAC3AudioStream ();
-                        if (!tmp->open (name))
-                        {
-                                delete tmp;
-                                GUI_Error_HIG(QT_TR_NOOP("Error loading the AC3 file"), NULL);
-                        }
-                        else
-                        {
-/*
-                                secondaudiostream = tmp;
-                                secondAudioSource=AudioAC3;
-                                secondAudioName=ADM_strdup(name);
-                                printf ("\n AC3 loaded\n");
-                                GUI_Info_HIG(ADM_LOG_INFO,QT_TR_NOOP("Second track loaded"), NULL);
-*/
-                                return 1;
-                        }
-                        }
-                        break;
-                case AudioWav:
-                         {
-                        AVDMWavAudioStream *tmp;
-                        if(!name) break;
-
-                        tmp = new AVDMWavAudioStream ();
-                        if (!tmp->open (name))
-                        {
-                                delete tmp;
-                                GUI_Error_HIG(QT_TR_NOOP("Error loading the WAV file"), NULL);
-                        }
-                        else
-                        {
-/*
-                                secondaudiostream = tmp;
-                                secondAudioSource=AudioAC3;
-                                secondAudioName=ADM_strdup(name);
-                                printf ("\n AC3 loaded\n");
-                                GUI_Info_HIG(ADM_LOG_INFO,QT_TR_NOOP("Second track loaded"), NULL);
-*/
-                                return 1;
-                        }}
-                        break;
-                default:
-                ADM_assert(0);
-        }
-        return 0;
-
-}
-#endif
 /**
     \fn A_Resync
     \brief 
@@ -1192,7 +1056,7 @@
       // Audio streams are cleared by editor
 
 	  aviaudiostream=NULL;
-	  secondaudiostream=NULL;
+	  
 
 //      filterCleanUp ();
 	  UI_setTitle(NULL);



From mean at mail.berlios.de  Sat Jan  1 09:49:23 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat,  1 Jan 2011 09:49:23 +0100
Subject: [Avidemux-svn-commit] r6909 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_toolkit
Message-ID: <20110101084923.83DFF48079E@sheep.berlios.de>

Author: mean
Date: 2011-01-01 09:49:23 +0100 (Sat, 01 Jan 2011)
New Revision: 6909

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/prototype.h
Log:
[cleanup] Remove more global variable or unused ones

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2011-01-01 08:49:22 UTC (rev 6908)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2011-01-01 08:49:23 UTC (rev 6909)
@@ -445,14 +445,10 @@
 
 void setBegin(char *p)
 {
-    frameStart=atoi(p);
-    printf("\n Start %u\n",frameStart);
+
 }
 void setEnd(char *p)
 {
-    frameEnd=atoi(p);
-    printf("\n End %u\n",frameStart);
-
 }
 void call_help(char *p)
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h	2011-01-01 08:49:22 UTC (rev 6908)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h	2011-01-01 08:49:23 UTC (rev 6909)
@@ -1,3 +1,8 @@
+/**
+    \file avi_vars.h
+    \brief a couple of global variables
+
+*/
 #ifndef __AVI_VARS
 #define __AVI_VARS
 
@@ -21,17 +26,12 @@
 #endif
 ;
 
-
-EXTERN uint32_t  curframe;
-EXTERN uint32_t verbose;
-EXTERN uint32_t originalPriority;
 EXTERN uint8_t 	playing
 #ifdef __DECLARE__
 =0
 #endif
 ;
 
-
 EXTERN ADM_audioStream *aviaudiostream
 #ifdef __DECLARE__
 =(ADM_audioStream *)NULL
@@ -49,20 +49,5 @@
 =(aviInfo *)NULL
 #endif
 ;
-/**
-	If set to 1, means video is in process mode_preview
-	If set to 0, copy mode
-*/
-EXTERN uint32_t audioProcessMode(void);
-/**
-	If set to 1, means video is in process mode_preview
-	If set to 0, copy mode
-*/
-EXTERN uint32_t videoProcessMode(void);
 
-EXTERN uint32_t frameStart,frameEnd;
-
-
-
-
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2011-01-01 08:49:22 UTC (rev 6908)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2011-01-01 08:49:23 UTC (rev 6909)
@@ -356,27 +356,12 @@
       break;
     }
     case ACT_Copy:
-      		if( frameEnd < frameStart ){
-                  GUI_Error_HIG(QT_TR_NOOP("Marker A > B"), QT_TR_NOOP("Cannot copy."));
-      		}else{
+            brokenAct();
 //    		   video_body->copyToClipBoard (frameStart,frameEnd);
-      		}
 		break;
     case ACT_Paste:
-#if 0
-      		video_body->pasteFromClipBoard(curframe);
-		 old=curframe;
-      		ReSync ();
-	  	if (!video_body->updateVideoInfo (avifileinfo))
-		{
-                  GUI_Error_HIG (QT_TR_NOOP("Something bad happened (II))"), NULL);
-		}
-     		 GUI_setAllFrameAndTime ();
-      		UI_setMarkers (frameStart, frameEnd);
- 		curframe=old;
-        	GUI_GoToFrame (curframe);
-#endif
-		break;
+            brokenAct();        		
+            break;
       break;
 
     case ACT_ResetSegments:
@@ -686,8 +671,6 @@
 {
   uint8_t isaviaud;
 
-  frameStart = 0;
-  frameEnd = avifileinfo->nb_frames - 1;
   // update audio stream
   // If we were on avi , mark it...
   if (currentaudiostream == aviaudiostream)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2011-01-01 08:49:22 UTC (rev 6908)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2011-01-01 08:49:23 UTC (rev 6909)
@@ -45,7 +45,7 @@
 
 extern renderZoom currentZoom;
 extern ADM_Composer *video_body;
-
+static uint32_t originalPriority;
 /**
     \class GUIPlayback
     \brief Wrapper for the playback stuff

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp	2011-01-01 08:49:22 UTC (rev 6908)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp	2011-01-01 08:49:23 UTC (rev 6909)
@@ -390,11 +390,10 @@
   DIA_workingBase *working;
   uint8_t success=0;
 
-        if(frameStart>frameEnd)
-                {
-                  GUI_Error_HIG(QT_TR_NOOP("Mark A > B"), QT_TR_NOOP("Set your markers correctly."));
-                        return 0;
-                }
+    ADM_error("Broken\n");
+    return 0;
+#if 0
+
         // Split name into base + extension
         ADM_PathSplit(name,&baseName,&ext);
 
@@ -424,8 +423,8 @@
         delete working	;
         delete src;
         return success;
+#endif
 
-
 }
 /**
       \fn A_saveImg

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/prototype.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/prototype.h	2011-01-01 08:49:22 UTC (rev 6908)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/prototype.h	2011-01-01 08:49:23 UTC (rev 6909)
@@ -22,6 +22,18 @@
 void editorKillPreview( void );
 void editorUpdatePreview(uint32_t framenum)    ;
 
+/**
+	If set to 1, means video is in process mode_preview
+	If set to 0, copy mode
+*/
+EXTERN uint32_t audioProcessMode(void);
+/**
+	If set to 1, means video is in process mode_preview
+	If set to 0, copy mode
+*/
+EXTERN uint32_t videoProcessMode(void);
 
+
+
 // EOF
 



From mean at mail.berlios.de  Sat Jan  1 09:49:24 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat,  1 Jan 2011 09:49:24 +0100
Subject: [Avidemux-svn-commit] r6910 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <20110101084924.AF65C48079E@sheep.berlios.de>

Author: mean
Date: 2011-01-01 09:49:24 +0100 (Sat, 01 Jan 2011)
New Revision: 6910

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
Log:
[cleanup] Remove unused global var aviaudiostream

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h	2011-01-01 08:49:23 UTC (rev 6909)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/avi_vars.h	2011-01-01 08:49:24 UTC (rev 6910)
@@ -32,11 +32,6 @@
 #endif
 ;
 
-EXTERN ADM_audioStream *aviaudiostream
-#ifdef __DECLARE__
-=(ADM_audioStream *)NULL
-#endif
-;
 EXTERN ADM_audioStream *currentaudiostream
 #ifdef __DECLARE__
 =(ADM_audioStream *)NULL

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2011-01-01 08:49:23 UTC (rev 6909)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2011-01-01 08:49:24 UTC (rev 6910)
@@ -96,6 +96,8 @@
 void HandleAction (Action action);
 void HandleAction_Navigate(Action action);
 void HandleAction_Save(Action action);
+
+
 //
 //
 /**
@@ -580,19 +582,6 @@
       printf ("\n *** NO AUDIO ***\n");
       wavinfo = (WAVHeader *) NULL;
     }
-  else
-    {
-	  video_body->getAudioStream (&aviaudiostream);
-//      A_changeAudioStream (aviaudiostream, AudioAvi,NULL);
-#if 0
-      if (aviaudiostream)
-	if (!aviaudiostream->isDecompressable ())
-	  {
-            GUI_Error_HIG (QT_TR_NOOP("No audio decoder found for this file"),
-                           QT_TR_NOOP( "Save (A+V) will generate bad AVI. Save audio will work."));
-	  }
-#endif
-    }
 
   // Init renderer
     admPreview::setMainDimension(avifileinfo->width, avifileinfo->height);
@@ -673,25 +662,8 @@
 
   // update audio stream
   // If we were on avi , mark it...
-  if (currentaudiostream == aviaudiostream)
-    {
-      isaviaud = 1;
-//      A_changeAudioStream ((AVDMGenericAudioStream *) NULL, AudioNone,NULL);
-
-    }
-  else
-    isaviaud = 0;
   GUI_setAllFrameAndTime ();
 
-  // Since we modified avi stream, rebuild audio stream accordingly
-  video_body->getAudioStream (&aviaudiostream);
-  if (isaviaud)
-    {
-//      A_changeAudioStream (aviaudiostream, AudioAvi,NULL);
-    }
-  	//updateVideoFilters ();
-//	getFirstVideoFilter();
-
 }
 
 
@@ -707,22 +679,6 @@
 		delete avifileinfo;
 		avifileinfo=NULL;
 	}
-#if 0
-	if (aviaudiostream)
-	{
-		delete aviaudiostream;
-		aviaudiostream=NULL;
-	}
-#endif
-#if 0
-	if (currentAudioName)
-	{
-		ADM_dealloc(currentAudioName);
-		currentAudioName = NULL;
-	}
-
-#endif
-
 	if (video_body)
 	{
 		delete video_body;
@@ -884,7 +840,6 @@
 int A_setAudioTrack(int track)
 {
         video_body->changeAudioStream(0,track);
-        video_body->getAudioStream(&aviaudiostream);
         return true;
 }
 /**
@@ -1035,12 +990,8 @@
       //delete wavinfo;
       
       avifileinfo = NULL;
-      video_body->cleanup ();
-      // Audio streams are cleared by editor
+      video_body->cleanup ();	  
 
-	  aviaudiostream=NULL;
-	  
-
 //      filterCleanUp ();
 	  UI_setTitle(NULL);
 



From mean at mail.berlios.de  Tue Jan  4 19:48:43 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue,  4 Jan 2011 19:48:43 +0100
Subject: [Avidemux-svn-commit] r6911 -
	branches/avidemux_2.6_branch_mean/cmake
Message-ID: <20110104184844.2C7974804C7@sheep.berlios.de>

Author: mean
Date: 2011-01-04 19:48:43 +0100 (Tue, 04 Jan 2011)
New Revision: 6911

Modified:
   branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake
Log:
[ffmpeg] Fail immediately if ffmpeg configure fails

Modified: branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake	2011-01-01 08:49:24 UTC (rev 6910)
+++ branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake	2011-01-04 18:48:43 UTC (rev 6911)
@@ -44,9 +44,6 @@
 	include(admFFmpegPrepareSvn)
 endif (NOT FFMPEG_PREPARED)
 
-if (NOT VERBOSE)
-	set(ffmpegBuildOutput OUTPUT_VARIABLE FFMPEG_CONFIGURE_OUTPUT)
-endif (NOT VERBOSE)
 
 message("")
 
@@ -160,6 +157,7 @@
 if (NOT EXISTS "${FFMPEG_BINARY_DIR}/Makefile")
 	set(FFMPEG_PERFORM_BUILD 1)
 endif (NOT EXISTS "${FFMPEG_BINARY_DIR}/Makefile")
+	
 
 if (FFMPEG_PERFORM_BUILD)
 	message(STATUS "Configuring FFmpeg")
@@ -169,10 +167,16 @@
 	file(REMOVE "${FFMPEG_BINARY_DIR}/ffmpeg${CMAKE_EXECUTABLE_SUFFIX}")
 	file(REMOVE "${FFMPEG_BINARY_DIR}/ffmpeg_g${CMAKE_EXECUTABLE_SUFFIX}")
 
-	#MESSAGE(STATUS "-> sh ${FFMPEG_SOURCE_DIR}/configure ${FFMPEG_FLAGS}")
 	execute_process(COMMAND sh ${FFMPEG_SOURCE_DIR}/configure ${FFMPEG_FLAGS}
 					WORKING_DIRECTORY "${FFMPEG_BINARY_DIR}"
-					${ffmpegBuildOutput})
+	                                OUTPUT_VARIABLE FFMPEG_CONFIGURE_OUTPUT
+	                                RESULT_VARIABLE FFMPEG_CONFIGURE_RESULT)
+        IF(NOT (FFMPEG_CONFIGURE_RESULT EQUAL 0))
+	        MESSAGE(ERROR "configure returned <${FFMPEG_CONFIGURE_RESULT}>")
+	        MESSAGE(ERROR "configure output is <${FFMPEG_CONFIGURE_OUTPUT}>")
+	        MESSAGE(ERROR "When configuing ffmpeg using < sh ${FFMPEG_SOURCE_DIR}/configure ${FFMPEG_FLAGS}>")
+                MESSAGE(FATAL_ERROR "An error occured ")
+        ENDIF(NOT (FFMPEG_CONFIGURE_RESULT EQUAL 0))
 	MESSAGE(STATUS "Configuring done, processing")
 
 	if (ADM_CPU_X86)



From mean at mail.berlios.de  Thu Jan  6 07:54:14 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  6 Jan 2011 07:54:14 +0100
Subject: [Avidemux-svn-commit] r6912 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_audioFilter/src avidemux/common/ADM_commonUI
	avidemux_core/ADM_coreAudioFilter/include
Message-ID: <20110106065415.35054480402@sheep.berlios.de>

Author: mean
Date: 2011-01-06 07:54:14 +0100 (Thu, 06 Jan 2011)
New Revision: 6912

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_audioFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_conf.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_normalize.h
Log:
[audio] Add back normalize filter (incomplete)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter.cpp	2011-01-04 18:48:43 UTC (rev 6911)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter.cpp	2011-01-06 06:54:14 UTC (rev 6912)
@@ -147,7 +147,11 @@
         ADD_FILTER(src);
     }
     // Normalize
-
+    if(config->gainParam.mode!=ADM_NO_GAIN)
+    {
+        AUDMAudioFilterNormalize *norm=new AUDMAudioFilterNormalize(last,&(config->gainParam));
+        ADD_FILTER(norm);
+    }
     return true;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_audioFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_audioFilter.cpp	2011-01-04 18:48:43 UTC (rev 6911)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_audioFilter.cpp	2011-01-06 06:54:14 UTC (rev 6912)
@@ -24,6 +24,9 @@
 {
   uint32_t vChan=config->mixerConf;
   uint32_t vFilm=config->film2pal;
+  uint32_t vGainMode=(uint32_t)config->gainParam.mode;
+  ELEM_TYPE_FLOAT vGainValue=config->gainParam.gain10;
+
 #define PX(x) (&(config->x))
    diaElemToggleUint eResample(PX(resamplerEnabled),QT_TR_NOOP("R_esampling (Hz):"),PX(resamplerFrequency),QT_TR_NOOP("Resampling frequency (Hz)"),6000,64000);
     
@@ -50,16 +53,28 @@
   {CHANNEL_DOLBY_PROLOGIC,  QT_TR_NOOP("Dolby Pro Logic")},
   {CHANNEL_DOLBY_PROLOGIC2, QT_TR_NOOP("Dolby Pro Logic II")}
     };
-
+  //*************************
+  diaMenuEntry menuGain[]={
+  {ADM_NO_GAIN,       QT_TR_NOOP("None")},
+  {ADM_GAIN_AUTOMATIC,QT_TR_NOOP("Automatic (max -3 dB)")},
+  {ADM_GAIN_MANUAL,   QT_TR_NOOP("Manual")}};
+  
+   diaElemMenu      eGain(&vGainMode,QT_TR_NOOP("_Gain mode:"),3,menuGain);
+   
+    diaElemFloat  eGainValue(&vGainValue,QT_TR_NOOP("G_ain value:"),-10,10);
+     eGain.link(&(menuGain[2]),1,&eGainValue);
+  //****************************
  diaElemMenu      eMixer(&vChan,QT_TR_NOOP("_Mixer:"),11,menuMixer);
  diaElemToggle    tMixer(PX(mixerEnabled),QT_TR_NOOP("Remix:"));
  tMixer.link(1,&eMixer);
  /************************************/
- diaElem *elems[]={&eFPS, &tMixer,&eMixer, &eResample};
-  if( diaFactoryRun(QT_TR_NOOP("Audio Filters"),4,elems))
+ diaElem *elems[]={&eFPS, &tMixer,&eMixer, &eResample,&eGain,&eGainValue};
+  if( diaFactoryRun(QT_TR_NOOP("Audio Filters"),4+2,elems))
     {
         config->mixerConf=(CHANNEL_CONF)vChan;
         config->film2pal=(FILMCONV)vFilm;
+        config->gainParam.mode=(ADM_GAINMode)vGainMode;
+        config->gainParam.gain10=vGainValue;
       return true;
     }
     

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_conf.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_conf.h	2011-01-04 18:48:43 UTC (rev 6911)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_conf.h	2011-01-06 06:54:14 UTC (rev 6912)
@@ -20,6 +20,7 @@
 #include "audiofilter.h"
 #include "audiofilter_mixer.h"
 #include "audiofilter_SRC.h"
+#include "audiofilter_normalize.h"
 
 /**
     \class ADM_AUDIOFILTER_CONFIG
@@ -41,6 +42,8 @@
                         resamplerEnabled=false;
                         resamplerFrequency=44100;
                         film2pal    =FILMCONV_NONE;
+                        gainParam.mode=ADM_NO_GAIN;
+                        gainParam.gain10=10;
                         return true;
                 }
 
@@ -55,7 +58,7 @@
     // film2pal & pal2film
     FILMCONV     film2pal;
     // Gain filter
-    //GAINparam    gainParam;
+    GAINparam    gainParam;
      
 
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_normalize.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_normalize.h	2011-01-04 18:48:43 UTC (rev 6911)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_normalize.h	2011-01-06 06:54:14 UTC (rev 6912)
@@ -2,6 +2,7 @@
 #define AUDIO_F_NORMALIZE_H
 
 #include "ADM_audioFilter.h"
+#include "audiofilter_normalize_param.h"
 class AUDMAudioFilterNormalize : public AUDMAudioFilter
 {
   protected:



From mean at mail.berlios.de  Thu Jan  6 07:54:16 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  6 Jan 2011 07:54:16 +0100
Subject: [Avidemux-svn-commit] r6913 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec
Message-ID: <20110106065416.49901480402@sheep.berlios.de>

Author: mean
Date: 2011-01-06 07:54:16 +0100 (Thu, 06 Jan 2011)
New Revision: 6913

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
Log:
[audioEncoder] Lavcodec :use matching free wrt the one used to allocate context

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2011-01-06 06:54:14 UTC (rev 6912)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2011-01-06 06:54:16 UTC (rev 6913)
@@ -96,7 +96,7 @@
   if(_context)
   {
     avcodec_close(CONTEXT);
-    ADM_dealloc(_context);
+    av_free(_context);
   }
   _context=NULL;
 };



From mean at mail.berlios.de  Thu Jan  6 07:54:18 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  6 Jan 2011 07:54:18 +0100
Subject: [Avidemux-svn-commit] r6914 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_audioFilter/include
	avidemux/common/ADM_audioFilter/src avidemux/common/ADM_editor
	avidemux/common/ADM_script2/binding
	avidemux/common/ADM_script2/include avidemux/common/ADM_script2/py
	avidemux/common/ADM_script2/src
	avidemux_core/ADM_coreAudioFilter/include
Message-ID: <20110106065418.322C6480402@sheep.berlios.de>

Author: mean
Date: 2011-01-06 07:54:18 +0100 (Thu, 06 Jan 2011)
New Revision: 6914

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/include/ADM_audioFilterInterface.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_interface.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_normalize.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPySave.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptCommon.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAudio.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_normalize_param.h
Log:
[audiofilter] Bind normalize, +UI, still incomplete

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/include/ADM_audioFilterInterface.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/include/ADM_audioFilterInterface.h	2011-01-06 06:54:16 UTC (rev 6913)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/include/ADM_audioFilterInterface.h	2011-01-06 06:54:18 UTC (rev 6914)
@@ -19,18 +19,18 @@
 #define ADM_audioFilterInterface_H
 
 #include "ADM_audiodef.h"
-
+#include "audiofilter_normalize_param.h"
 /* Filter part */
 bool            audioFilterReset(void);
 
 bool            audioFilterSetResample(uint32_t newfq);  // Set 0 to disable frequency
 bool            audioFilterSetFrameRate(FILMCONV conf);
 bool            audioFilterSetMixer(CHANNEL_CONF conf); // Invalid to disable
-
+bool            audioFilterSetNormalize( ADM_GAINMode mode,uint32_t gain);
 uint32_t        audioFilterGetResample(void);  // Set 0 to disable frequency
 FILMCONV        audioFilterGetFrameRate(void);
 CHANNEL_CONF    audioFilterGetMixer(void); // Invalid to disable
-
+bool            audioFilterGetNormalize( ADM_GAINMode *mode,uint32_t *gain);
 bool            audioFilterConfigure(void);
 
 /* Encoder part */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_interface.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_interface.cpp	2011-01-06 06:54:16 UTC (rev 6913)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_interface.cpp	2011-01-06 06:54:18 UTC (rev 6914)
@@ -87,8 +87,40 @@
 {
     return audioEncodingConfig.film2pal;
 }
+/**
+    \fn audioFilterSetNormalize
+    \brief 
+*/
+bool            audioFilterSetNormalize( ADM_GAINMode mode,uint32_t gain)
+{
+    if(mode>=ADM_GAIN_MAX)
+    {
+        ADM_error("incorrect mode value for normalize");
+        return false;
+    }
+    if(!gain)
+    {
+        ADM_error("gain cannot be null");
+        return false;
+    }
 
+    audioEncodingConfig.gainParam.mode=mode;
+    audioEncodingConfig.gainParam.gain10=gain;
+    return true;
+}
 /**
+    \fn audioFilterSetNormalize
+    \brief 
+*/
+bool            audioFilterGetNormalize( ADM_GAINMode *mode,uint32_t *gain)
+{
+
+    *mode=audioEncodingConfig.gainParam.mode;
+    *gain=audioEncodingConfig.gainParam.gain10;
+    return true;
+}
+
+/**
     \fn audioFilterSetMixer
     \brief
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_normalize.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_normalize.cpp	2011-01-06 06:54:16 UTC (rev 6913)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_normalize.cpp	2011-01-06 06:54:18 UTC (rev 6914)
@@ -20,19 +20,16 @@
  ***************************************************************************/
 
 
-#include <math.h>
 
 #include "ADM_default.h"
+#include <math.h>
 #include "ADM_audioFilter.h"
 #include "audiofilter_normalize_param.h"
 #include "audiofilter_normalize.h"
 #include "audiofilter_dolby.h"
 
 #include "ADM_coreAudio.h"
-//#include "ADM_dialog/DIA_busy.h" //CANNOT USE IT! We are in another thread!
 
-//extern AVDMGenericAudioStream *currentaudiostream;
-
 #ifdef __WIN32
 #define POW10(x)   pow(10,x)
 #elif defined(ADM_BSD_FAMILY)
@@ -44,8 +41,9 @@
 #define LINEAR_TO_DB(x) (20.*log10(x))
 #define DB_TO_LINEAR(x) (POW10((x/20.)))
 
-// Ctor
-//__________
+/**
+        \fn Ctor
+**/
 
 AUDMAudioFilterNormalize::AUDMAudioFilterNormalize(AUDMAudioFilter * instream,GAINparam *param):AUDMAudioFilter (instream)
 {
@@ -53,26 +51,33 @@
     // nothing special here...
   switch(param->mode)
   {
-    case ADM_NO_GAIN: _ratio=1;_scanned=1;printf("[Gain] Gain of 1.0\n");break; 
-    case ADM_GAIN_AUTOMATIC: _ratio=1;_scanned=0;printf("[Gain] Automatic gain\n");break;
+    case ADM_NO_GAIN: _ratio=1;_scanned=1;ADM_info("[Gain] Gain of 1.0\n");break; 
+    case ADM_GAIN_AUTOMATIC: _ratio=1;_scanned=0;ADM_info("[Gain] Automatic gain\n");break;
     case ADM_GAIN_MANUAL: 
                 _scanned=1;
                 db_out =  param->gain10/10.0; // Dbout is in 10*DB (!)
                 _ratio = DB_TO_LINEAR(db_out);
-                printf("[Gain] %f db (p=%d)\n", (float)(param->gain10)/10.,param->gain10);
-                printf("[Gain] Linear ratio of : %03.3f\n", _ratio);
+                ADM_info("[Gain] %f db (p=%d)\n", (float)(param->gain10)/10.,param->gain10);
+                ADM_info("[Gain] Linear ratio of : %03.3f\n", _ratio);
+                break;
+    default:
+                ADM_error("Unknown normalize mode\n");
+                ADM_assert(0);
+                break;
   }
     _previous->rewind();
 };
-
+/**
+        \fn dtor
+*/
 AUDMAudioFilterNormalize::~AUDMAudioFilterNormalize()
 {
-
+        ADM_info("Destroying normalize audio filter\n");
 }
-//
-// For normalize, we scan the input stream
-// to check for maximum value
-//___________________________________________
+/**
+        \fn preprocess
+        \brief Search for max value to compute gain
+*/
 uint8_t AUDMAudioFilterNormalize::preprocess(void)
 {
 
@@ -86,7 +91,7 @@
     float *max=new float[_wavHeader.channels];
     _previous->rewind();
     DolbySkip(1);
-    printf("\n Seeking for maximum value, that can take a while\n");
+    ADM_info("Seeking for maximum value, that can take a while\n");
 
     llength=_length ;
     
@@ -103,7 +108,7 @@
             }
            else 
             {
-              printf("Unknown cause : %d\n",status);
+              ADM_error("Unknown cause : %d\n",status);
               ADM_assert(0); 
             }
           }
@@ -131,9 +136,9 @@
     for(int chan=0;chan<_wavHeader.channels;chan++)
     {
         if(max[chan]>mx) mx=max[chan];
-        printf("[Normalize] maximum found for channel %d : %f\n", chan,max[chan]);
+        ADM_info("[Normalize] maximum found for channel %d : %f\n", chan,max[chan]);
     }
-    printf("[Normalize] Using : %0.4f as max value \n", mx);
+    ADM_info("[Normalize] Using : %0.4f as max value \n", mx);
     double db_in, db_out=-3;
 
     if (mx>0.001)
@@ -147,9 +152,9 @@
     _ratio=1;
 
     float db_delta=db_out-db_in;
-    printf("[Normalize]Gain %f dB\n",db_delta);
+    ADM_info("[Normalize]Gain %f dB\n",db_delta);
     _ratio = DB_TO_LINEAR(db_delta);
-    printf("\n Using ratio of : %f\n", _ratio);
+    ADM_info("\n Using ratio of : %f\n", _ratio);
 
     _scanned = 1;
     DolbySkip(0);
@@ -157,8 +162,10 @@
     delete [] max;
     return 1;
 }
-//
-//___________________________________________
+/**
+        \fn fill
+        \brief
+*/
 uint32_t AUDMAudioFilterNormalize::fill( uint32_t max, float * buffer,AUD_Status *status)
 {
     uint32_t rd, i, j,rd2;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPySave.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPySave.cpp	2011-01-06 06:54:16 UTC (rev 6913)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPySave.cpp	2011-01-06 06:54:18 UTC (rev 6914)
@@ -24,6 +24,7 @@
 #include "ADM_editor/ADM_edit.hxx"
 
 #include "audioEncoderApi.h"
+#include "audiofilter_normalize_param.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_videoEncoderApi.h"
@@ -203,7 +204,15 @@
                 case FILMCONV_FILM2PAL:  qfprintf(fd,"adm.audioFilm2pal=1\n");break;
                 default:ADM_assert(0);
         }
-   
+   // --------- Normalize ----------------
+        ADM_GAINMode mode;
+        uint32_t gain;
+        audioFilterGetNormalize(&mode,&gain);
+        if(mode && gain)
+        {
+            qfprintf(fd,"adm.audioNormalizeMode=%d\n",(int)mode); 
+            qfprintf(fd,"adm.audioNormalizeGain=%d\n",(int)gain); 
+        }
        
         
   

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass	2011-01-06 06:54:16 UTC (rev 6913)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass	2011-01-06 06:54:18 UTC (rev 6914)
@@ -42,5 +42,7 @@
 /* ATTRIBUTES */ double markerA:scriptSetMarkerA,scriptGetMarkerA
 /* ATTRIBUTES */ double markerB:scriptSetMarkerB,scriptGetMarkerB
 /* ATTRIBUTES */ int    audioResample:scriptSetResample,scriptGetResample
+/* ATTRIBUTES */ int    audioNormalizeMode:scriptSetNormalizeMode,scriptGetNormalizeMode
+/* ATTRIBUTES */ int    audioNormalizeValue:scriptSetNormalizeValue,scriptGetNormalizeValue
 /* ATTRIBUTES */ int    audioPal2film:scriptSetPal2film,scriptGetPal2film
 /* ATTRIBUTES */ int    audioFilm2pal:scriptSetFilm2pal,scriptGetFilm2pal

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptCommon.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptCommon.h	2011-01-06 06:54:16 UTC (rev 6913)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptCommon.h	2011-01-06 06:54:18 UTC (rev 6914)
@@ -24,6 +24,12 @@
 int scriptAddSegment(int ref, double start, double duration);
 int scriptAudioReset(void);
 int scriptAudioMixer(const char *s);
+// Normalize
+int scriptGetNormalizeMode(void);
+int scriptGetNormalizeValue(void);
+void scriptSetNormalizeMode(int v);
+void scriptSetNormalizeValue(int v);
+
 // Fq
 int32_t scriptGetResample(void);
 void    scriptSetResample(int32_t fq);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2011-01-06 06:54:16 UTC (rev 6913)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2011-01-06 06:54:18 UTC (rev 6914)
@@ -251,6 +251,14 @@
   {
      return tp_number(scriptGetResample());
   }
+  if (!strcmp(key, "audioNormalizeValue"))
+  {
+     return tp_number(scriptGetNormalizeValue());
+  }
+  if (!strcmp(key, "audioNormalizeMode"))
+  {
+     return tp_number(scriptGetNormalizeMode());
+  }
   if (!strcmp(key, "markerA"))
   {
      return tp_number(scriptGetMarkerA());
@@ -375,6 +383,18 @@
      scriptSetResample(val);
      return tp_None;
   }
+  if (!strcmp(key, "audioNormalizeValue"))
+  {
+     int val=pm.asInt();
+     scriptSetNormalizeValue(val);
+     return tp_None;
+  }
+  if (!strcmp(key, "audioNormalizeMode"))
+  {
+     int val=pm.asInt();
+     scriptSetNormalizeMode(val);
+     return tp_None;
+  }
   if (!strcmp(key, "markerA"))
   {
      double val=pm.asDouble();

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAudio.cpp	2011-01-06 06:54:16 UTC (rev 6913)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptAudio.cpp	2011-01-06 06:54:18 UTC (rev 6914)
@@ -47,6 +47,50 @@
     return audioFilterSetMixer(c);
 }
 /**
+    \fn scriptGetNormalizeMode
+*/
+int scriptGetNormalizeMode(void)
+{
+    ADM_GAINMode m;
+    uint32_t gain;
+    audioFilterGetNormalize( &m,&gain);
+    return m;
+}
+/**
+    \fn scriptGetNormalizeValue
+*/
+int scriptGetNormalizeValue(void)
+{
+    ADM_GAINMode m;
+    uint32_t gain;
+    audioFilterGetNormalize( &m,&gain);
+    return (int)gain;
+}
+
+/**
+    \fn scriptSetNormalizeMode
+*/
+void scriptSetNormalizeMode(int mode)
+{
+    ADM_GAINMode m;
+    uint32_t gain;
+    audioFilterGetNormalize( &m,&gain);
+    m=(ADM_GAINMode)mode;
+    audioFilterSetNormalize( m,gain);
+}
+/**
+    \fn scriptSetNormalizeValue
+*/
+void scriptSetNormalizeValue(int value)
+{
+    ADM_GAINMode m;
+    uint32_t gain;
+    audioFilterGetNormalize( &m,&gain);
+    gain=(uint32_t)value;
+    audioFilterSetNormalize( m,gain);
+
+}
+/**
     \fn jsGetResample
 */
 int32_t scriptGetResample(void)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_normalize_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_normalize_param.h	2011-01-06 06:54:16 UTC (rev 6913)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/audiofilter_normalize_param.h	2011-01-06 06:54:18 UTC (rev 6914)
@@ -15,7 +15,8 @@
 {
   ADM_NO_GAIN,
   ADM_GAIN_AUTOMATIC,
-  ADM_GAIN_MANUAL
+  ADM_GAIN_MANUAL,
+  ADM_GAIN_MAX // dont use!
   
 }ADM_GAINMode;
 



From mean at mail.berlios.de  Thu Jan  6 20:02:47 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  6 Jan 2011 20:02:47 +0100
Subject: [Avidemux-svn-commit] r6915 - in
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2:
	binding py
Message-ID: <20110106190247.492A9480986@sheep.berlios.de>

Author: mean
Date: 2011-01-06 20:02:46 +0100 (Thu, 06 Jan 2011)
New Revision: 6915

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
Log:
[Normalize] Use Gain instead of value for scripting

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass	2011-01-06 06:54:18 UTC (rev 6914)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass	2011-01-06 19:02:46 UTC (rev 6915)
@@ -43,6 +43,6 @@
 /* ATTRIBUTES */ double markerB:scriptSetMarkerB,scriptGetMarkerB
 /* ATTRIBUTES */ int    audioResample:scriptSetResample,scriptGetResample
 /* ATTRIBUTES */ int    audioNormalizeMode:scriptSetNormalizeMode,scriptGetNormalizeMode
-/* ATTRIBUTES */ int    audioNormalizeValue:scriptSetNormalizeValue,scriptGetNormalizeValue
+/* ATTRIBUTES */ int    audioNormalizeGain:scriptSetNormalizeValue,scriptGetNormalizeValue
 /* ATTRIBUTES */ int    audioPal2film:scriptSetPal2film,scriptGetPal2film
 /* ATTRIBUTES */ int    audioFilm2pal:scriptSetFilm2pal,scriptGetFilm2pal

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2011-01-06 06:54:18 UTC (rev 6914)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2011-01-06 19:02:46 UTC (rev 6915)
@@ -251,10 +251,6 @@
   {
      return tp_number(scriptGetResample());
   }
-  if (!strcmp(key, "audioNormalizeValue"))
-  {
-     return tp_number(scriptGetNormalizeValue());
-  }
   if (!strcmp(key, "audioNormalizeMode"))
   {
      return tp_number(scriptGetNormalizeMode());
@@ -263,6 +259,10 @@
   {
      return tp_number(scriptGetMarkerA());
   }
+  if (!strcmp(key, "audioNormalizeGain"))
+  {
+     return tp_number(scriptGetNormalizeValue());
+  }
   if (!strcmp(key, "markerB"))
   {
      return tp_number(scriptGetMarkerB());
@@ -383,12 +383,6 @@
      scriptSetResample(val);
      return tp_None;
   }
-  if (!strcmp(key, "audioNormalizeValue"))
-  {
-     int val=pm.asInt();
-     scriptSetNormalizeValue(val);
-     return tp_None;
-  }
   if (!strcmp(key, "audioNormalizeMode"))
   {
      int val=pm.asInt();
@@ -401,6 +395,12 @@
      scriptSetMarkerA(val);
      return tp_None;
   }
+  if (!strcmp(key, "audioNormalizeGain"))
+  {
+     int val=pm.asInt();
+     scriptSetNormalizeValue(val);
+     return tp_None;
+  }
   if (!strcmp(key, "markerB"))
   {
      double val=pm.asDouble();



From mean at mail.berlios.de  Thu Jan  6 20:02:48 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  6 Jan 2011 20:02:48 +0100
Subject: [Avidemux-svn-commit] r6916 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI
Message-ID: <20110106190248.566AD480986@sheep.berlios.de>

Author: mean
Date: 2011-01-06 20:02:48 +0100 (Thu, 06 Jan 2011)
New Revision: 6916

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_audioFilter.cpp
Log:
[Normalize/ui] Display gain in db in dialogbox, not in internal format (1/10 db)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_audioFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_audioFilter.cpp	2011-01-06 19:02:46 UTC (rev 6915)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_audioFilter.cpp	2011-01-06 19:02:48 UTC (rev 6916)
@@ -25,7 +25,7 @@
   uint32_t vChan=config->mixerConf;
   uint32_t vFilm=config->film2pal;
   uint32_t vGainMode=(uint32_t)config->gainParam.mode;
-  ELEM_TYPE_FLOAT vGainValue=config->gainParam.gain10;
+  ELEM_TYPE_FLOAT vGainValue=config->gainParam.gain10/10;
 
 #define PX(x) (&(config->x))
    diaElemToggleUint eResample(PX(resamplerEnabled),QT_TR_NOOP("R_esampling (Hz):"),PX(resamplerFrequency),QT_TR_NOOP("Resampling frequency (Hz)"),6000,64000);
@@ -57,11 +57,11 @@
   diaMenuEntry menuGain[]={
   {ADM_NO_GAIN,       QT_TR_NOOP("None")},
   {ADM_GAIN_AUTOMATIC,QT_TR_NOOP("Automatic (max -3 dB)")},
-  {ADM_GAIN_MANUAL,   QT_TR_NOOP("Manual")}};
+  {ADM_GAIN_MANUAL,   QT_TR_NOOP("Manual (dB)")}};
   
    diaElemMenu      eGain(&vGainMode,QT_TR_NOOP("_Gain mode:"),3,menuGain);
    
-    diaElemFloat  eGainValue(&vGainValue,QT_TR_NOOP("G_ain value:"),-10,10);
+    diaElemFloat  eGainValue(&vGainValue,QT_TR_NOOP("G_ain value:"),-10,40);
      eGain.link(&(menuGain[2]),1,&eGainValue);
   //****************************
  diaElemMenu      eMixer(&vChan,QT_TR_NOOP("_Mixer:"),11,menuMixer);
@@ -74,7 +74,7 @@
         config->mixerConf=(CHANNEL_CONF)vChan;
         config->film2pal=(FILMCONV)vFilm;
         config->gainParam.mode=(ADM_GAINMode)vGainMode;
-        config->gainParam.gain10=vGainValue;
+        config->gainParam.gain10=vGainValue*10;
       return true;
     }
     



From mean at mail.berlios.de  Thu Jan  6 20:45:21 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  6 Jan 2011 20:45:21 +0100
Subject: [Avidemux-svn-commit] r6917 -
	branches/avidemux_2.6_branch_mean/cmake
Message-ID: <20110106194521.82B47480986@sheep.berlios.de>

Author: mean
Date: 2011-01-06 20:45:21 +0100 (Thu, 06 Jan 2011)
New Revision: 6917

Modified:
   branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake
Log:
[ffmpeg] enable aac encoder

Modified: branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake	2011-01-06 19:02:48 UTC (rev 6916)
+++ branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake	2011-01-06 19:45:21 UTC (rev 6917)
@@ -14,7 +14,7 @@
 					 mjpegb  mpeg2video  mpeg4  msmpeg4v2  msmpeg4v3  msvideo1  nellymoser  png  qdm2  rawvideo  snow
 					 svq3  theora  tscc 
 					 vc1  vp3  vp6  vp6a  vp6f  wmav2  wmv1  wmv2  wmv3)
-set(FFMPEG_ENCODERS  ac3  dvvideo  ffv1  ffvhuff  flv  h263  huffyuv  mjpeg  mp2  mpeg1video  mpeg2video  mpeg4  snow)
+set(FFMPEG_ENCODERS  ac3  dvvideo  ffv1  ffvhuff  flv  h263  huffyuv  mjpeg  mp2  mpeg1video  mpeg2video  mpeg4  snow aac)
 set(FFMPEG_MUXERS  flv  matroska  mpeg1vcd  mpeg2dvd  mpeg2svcd  mpegts  mov  mp4  psp)
 set(FFMPEG_PARSERS  ac3  h263  h264  mpeg4video)
 set(FFMPEG_PROTOCOLS  file)



From mean at mail.berlios.de  Fri Jan  7 08:30:45 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri,  7 Jan 2011 08:30:45 +0100
Subject: [Avidemux-svn-commit] r6918 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src
Message-ID: <20110107073046.0E63B480A37@sheep.berlios.de>

Author: mean
Date: 2011-01-07 08:30:45 +0100 (Fri, 07 Jan 2011)
New Revision: 6918

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audio_encoderPlugin.cpp
Log:
[audio] Use getAudioBitrate only if the encoder has it, else use a dummy value. It happens for example for PCM where bitrate depends on the incoming data, not on configuration

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audio_encoderPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audio_encoderPlugin.cpp	2011-01-06 19:45:21 UTC (rev 6917)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audio_encoderPlugin.cpp	2011-01-07 07:30:45 UTC (rev 6918)
@@ -371,7 +371,10 @@
     }
      ADM_assert(currentEncoder<ListOfAudioEncoder.size());
      ADM_audioEncoder *encoder= ListOfAudioEncoder[currentEncoder];
-     *bitrate=encoder->getBitrate();
+     if(encoder->getBitrate)
+        *bitrate=encoder->getBitrate();
+     else
+        *bitrate=128; // PCM does not have global conf bitrate
      if(encoder->getConfigurationData)
         return encoder->getConfigurationData(couple);
      else return 1;



From mean at mail.berlios.de  Mon Jan 10 19:52:31 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 10 Jan 2011 19:52:31 +0100
Subject: [Avidemux-svn-commit] r6919 - in branches/avidemux_2.6_branch_mean:
	autononreg/py/avidemux avidemux/common/ADM_script2/binding
	avidemux/common/ADM_script2/include avidemux/common/ADM_script2/py
	avidemux/common/ADM_script2/src
	avidemux/common/ADM_videoEncoder/include
	avidemux/common/ADM_videoEncoder/src
	avidemux_core/ADM_coreUtils/include avidemux_core/ADM_coreUtils/src
	avidemux_core/ADM_coreVideoEncoder/include
Message-ID: <20110110185231.A8217480510@sheep.berlios.de>

Author: mean
Date: 2011-01-10 19:52:31 +0100 (Mon, 10 Jan 2011)
New Revision: 6919

Added:
   branches/avidemux_2.6_branch_mean/autononreg/py/avidemux/pySetCodec.py
   branches/avidemux_2.6_branch_mean/autononreg/py/avidemux/pyVideoCodecChangeParam.py
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptVideo.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptVideo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoEncoder/include/ADM_videoEncoderApi.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoEncoder/src/ADM_dynVideoEncoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_paramList.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderInternal.h
Log:
[videoCodec] Add python binding videoCodecChangeParam() to alter a video codec configuration without submitting everything

Added: branches/avidemux_2.6_branch_mean/autononreg/py/avidemux/pySetCodec.py
===================================================================
--- branches/avidemux_2.6_branch_mean/autononreg/py/avidemux/pySetCodec.py	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/autononreg/py/avidemux/pySetCodec.py	2011-01-10 18:52:31 UTC (rev 6919)
@@ -0,0 +1,14 @@
+#PY  <- Needed to identify#
+#--automatically built--
+#--Project: /home/fx/earl.py
+
+adm=Avidemux()
+#** Video **
+# 01 videos source 
+adm.loadVideo("/work/samples/avi/2mn.avi")
+#** Video Codec conf **
+adm.videoCodec("x264","params=AQ=20","MaxRefFrames=2","MinIdr=10","MaxIdr=150","threads=99","_8x8=True","_8x8P=True","_8x8B=True","_4x4=True","_8x8I=True","_4x4I=True","MaxBFrame=2","profile=30","CABAC=True","Trellis=True")
+
+adm.setContainer("MKV","forceDisplayWidth=False","displayWidth=1280")
+
+#End of script

Added: branches/avidemux_2.6_branch_mean/autononreg/py/avidemux/pyVideoCodecChangeParam.py
===================================================================
--- branches/avidemux_2.6_branch_mean/autononreg/py/avidemux/pyVideoCodecChangeParam.py	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/autononreg/py/avidemux/pyVideoCodecChangeParam.py	2011-01-10 18:52:31 UTC (rev 6919)
@@ -0,0 +1,16 @@
+#PY  <- Needed to identify#
+#--automatically built--
+#--Project: /home/fx/earl.py
+
+gui=Gui()
+adm=Avidemux()
+#** Video **
+# 01 videos source 
+adm.loadVideo("/work/samples/avi/2mn.avi")
+#** Video Codec conf **
+adm.videoCodec("x264","params=AQ=20","MaxRefFrames=5","MinIdr=10","MaxIdr=150","threads=99","_8x8=True","_8x8P=True","_8x8B=True","_4x4=True","_8x8I=True","_4x4I=True","MaxBFrame=5","profile=30","CABAC=True","Trellis=True")
+adm.videoCodecChangeParam("x264","MaxBFrame=3","CABAC=False","Trellis=False")
+
+gui.displayInfo("Hey","Verify CABAC and TRELLIS are both false and MaxBFrame=3 ")
+
+#End of script

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass	2011-01-07 07:30:45 UTC (rev 6918)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/binding/adm.admPyClass	2011-01-10 18:52:31 UTC (rev 6919)
@@ -22,6 +22,7 @@
 #              cname:pyname
 #  Codec, container
 /* METHOD */ int scriptSetVideoCodec:videoCodec(str,couples) 
+/* METHOD */ int scriptSetVideoCodecParam:videoCodecChangeParam(str,couples) 
 /* METHOD */ int scriptSetAudioCodec:audioCodec(str,int,couples) 
 /* METHOD */ int scriptSetContainer:setContainer(str,couples) 
 /* METHOD */ int scriptAddVideoFilter:addVideoFilter(str,couples) 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptVideo.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptVideo.h	2011-01-07 07:30:45 UTC (rev 6918)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_scriptVideo.h	2011-01-10 18:52:31 UTC (rev 6919)
@@ -22,8 +22,10 @@
 
 int     scriptSetPostProc (int a,int b, int c);
 #ifdef __cplusplus
-int     scriptSetVideoCodec(const char *codec,CONFcouple *c);
+int     scriptSetVideoCodec(const char *codec,CONFcouple *c); // Only take the full param list
 int     scriptAddVideoFilter(const char *filter,CONFcouple *c);
+int     scriptSetVideoCodecParam(const char *codec,CONFcouple *c); // same as setVideoCodec, but accepts partial list
+
 #endif
 #ifdef __cplusplus
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2011-01-07 07:30:45 UTC (rev 6918)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2011-01-10 18:52:31 UTC (rev 6919)
@@ -93,6 +93,18 @@
   int r=  A_Save(p0); 
   return tp_number(r);
 }
+// videoCodecChangeParam -> int scriptSetVideoCodecParam (str couples ) 
+static tp_obj zzpy_videoCodecChangeParam(TP)
+ {
+  tp_obj self=tp_getraw( tp);
+  tinyParams pm(tp);
+  void *me=(void *)pm.asThis(&self,ADM_PYID_AVIDEMUX);
+  const char *p0= pm.asString();
+  CONFcouple *p1=NULL;
+  pm.makeCouples(&p1);
+  int r=  scriptSetVideoCodecParam(p0,p1); 
+  return tp_number(r);
+}
 // appendVideo -> int scriptAppendVideo (str  ) 
 static tp_obj zzpy_appendVideo(TP)
  {
@@ -307,6 +319,10 @@
   {
      return tp_method(vm,self,zzpy_save);
   }
+  if (!strcmp(key, "videoCodecChangeParam"))
+  {
+     return tp_method(vm,self,zzpy_videoCodecChangeParam);
+  }
   if (!strcmp(key, "appendVideo"))
   {
      return tp_method(vm,self,zzpy_appendVideo);
@@ -441,6 +457,7 @@
 	jsLog("getHeight(void)\n");
 	jsLog("setPostProc(int ,int , int )\n");
 	jsLog("save(str)\n");
+	jsLog("videoCodecChangeParam(str,couples)\n");
 	jsLog("appendVideo(str )\n");
 	jsLog("audioMixer(str )\n");
 	jsLog("getFps1000(void)\n");

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptVideo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptVideo.cpp	2011-01-07 07:30:45 UTC (rev 6918)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptVideo.cpp	2011-01-10 18:52:31 UTC (rev 6919)
@@ -46,6 +46,30 @@
     return true;
 }
 /**
+    \fn scriptSetVideoCodecParam
+    \brief Same as scriptSetVideoCodec, but accept partial settings
+*/
+int     scriptSetVideoCodecParam(const char *codec,CONFcouple *c)
+{       
+        bool r=true;
+        if(A_setVideoCodec(codec)==false)
+        {
+            jsLog("Could not select codec %s\n",codec);
+            r=false;
+        }else
+        {        
+            if(c)
+            {
+                r=videoEncoder6_SetConfiguration(c,false);
+            }
+        }
+        if(c)
+            delete c;
+        return r;
+}
+
+
+/**
     \fn scriptSetVideoCodec
 */
 int     scriptSetVideoCodec(const char *codec,CONFcouple *c)
@@ -59,7 +83,7 @@
         {        
             if(c)
             {
-                r=videoEncoder6_SetConfiguration(c);
+                r=videoEncoder6_SetConfiguration(c,true);
             }
         }
         if(c)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoEncoder/include/ADM_videoEncoderApi.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoEncoder/include/ADM_videoEncoderApi.h	2011-01-07 07:30:45 UTC (rev 6918)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoEncoder/include/ADM_videoEncoderApi.h	2011-01-10 18:52:31 UTC (rev 6919)
@@ -32,7 +32,7 @@
 
 const char            *videoEncoder6_GetCurrentEncoderName(void);
 
-bool                  videoEncoder6_SetConfiguration(CONFcouple *c);
+bool                  videoEncoder6_SetConfiguration(CONFcouple *ci,bool full=true);
 bool                  videoEncoder6_GetConfiguration(CONFcouple **c);
 
 ADM_coreVideoEncoder *createVideoEncoderFromIndex(ADM_coreVideoFilter *chain,int index,bool globalHeader);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoEncoder/src/ADM_dynVideoEncoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoEncoder/src/ADM_dynVideoEncoder.cpp	2011-01-07 07:30:45 UTC (rev 6918)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoEncoder/src/ADM_dynVideoEncoder.cpp	2011-01-10 18:52:31 UTC (rev 6919)
@@ -243,16 +243,16 @@
     return e->desc->encoderName;
 }
 /**
-    \fn videoEncoder6_GetCurrentEncoderName
+    \fn videoEncoder6_SetPartialConfiguration
 */
-
-bool                  videoEncoder6_SetConfiguration(CONFcouple *c)
+bool                  videoEncoder6_SetConfiguration(CONFcouple *c,bool full)
 {
     if(!c) return true;
     ADM_assert(currentVideoCodec<ListOfEncoders.size());
     ADM_videoEncoder6 *e=ListOfEncoders[currentVideoCodec];
-    return e->desc->setConfigurationData(c);
+    return e->desc->setConfigurationData(c,full);
 }
+
 /**
     \fn videoEncoder6_GetConfiguration
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_paramList.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_paramList.h	2011-01-07 07:30:45 UTC (rev 6918)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_paramList.h	2011-01-10 18:52:31 UTC (rev 6919)
@@ -49,6 +49,8 @@
 
 /// Couple -> structure
 bool ADM_paramLoad(CONFcouple *couples, const ADM_paramList *params,void *s);
+bool ADM_paramLoadPartial(CONFcouple *couples, const ADM_paramList *params,void *s);
+
 /// Structure -> couples
 bool ADM_paramSave(CONFcouple **couples, const ADM_paramList *params,void *s);
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp	2011-01-07 07:30:45 UTC (rev 6918)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp	2011-01-10 18:52:31 UTC (rev 6919)
@@ -188,13 +188,10 @@
     return true;
 }
 /**
-    \fn ADM_paramValidate
-    \brief Check the confcouples match the param list
+    \fn getParamSize
 */
-bool ADM_paramValidate(CONFcouple *couples, const    ADM_paramList *params)
+static int XgetParamSize( const ADM_paramList *params)
 {
-    int n=couples->getSize();
-    int found=0;
     int p=0;
     const ADM_paramList *l=params;
     while(l->paramName)
@@ -202,6 +199,17 @@
         p++;
         l++;
     };
+    return p;
+}
+/**
+    \fn ADM_paramValidate
+    \brief Check the confcouples match the param list
+*/
+bool ADM_paramValidate(CONFcouple *couples, const    ADM_paramList *params)
+{
+    int n=couples->getSize();
+    int found=0;
+    int p=XgetParamSize(params);
     if(n!=p)
     {
         ADM_warning("Number of parameter mistmatch :%d vs %d\n",n,p);
@@ -220,24 +228,60 @@
     return true;
 }
 /**
-    \fn ADM_paramLoad
+    \fn ADM_paramValidatePartialList
+    \brief In that case couples is a sublist of params
+*/
+bool ADM_paramValidatePartialList(CONFcouple *couples, const    ADM_paramList *params)
+{
+    int n=couples->getSize();
+    int p=XgetParamSize(params);
+    if(n>p)
+    {
+        ADM_warning("Too many parameters in partial list");
+        return false;
+    }
+    int found=0;
+    for(int i=0;i<p;i++)
+    {
+        const char *name=params[i].paramName;
+        if(true==couples->exist(name))
+        {
+            found++;
+        }
+    }
+    if(found==n) return true;
+    ADM_warning("Some parameters are not in the parameter list, typo ?\n");
+    return false;;
+}
+
+/**
+    \fn ADM_paramLoadInternal
     \brief Load a structure from a list of confCouple
 */
-bool ADM_paramLoad(CONFcouple *couples, const ADM_paramList *params,void *s)
+static bool ADM_paramLoadInternal(bool partial,CONFcouple *couples, const ADM_paramList *params,void *s)
 {
     uint8_t *address=(uint8_t *)s;
-    if(false==ADM_paramValidate(couples,params)) return false;
+    
     int n=couples->getSize();
-    for(int i=0;i<n;i++)
+    int p=XgetParamSize(params);
+    for(int i=0;i<p;i++)
     {
         const char *name=params[i].paramName;
         int index=couples->lookupName(name);
-        ADM_assert(index!=-1);
+        if(index==-1) // not found ?
+            if(false==partial)
+            {
+                ADM_assert(index!=-1); // Should be replaced later by a return false
+            }else       
+            {
+               // ADM_info("%s not found\n",name);
+                continue; // this parameter is not in the param list and we are doing a partial update
+            }
         switch(params[i].type)
         {
 #define SWAL(entry,type,var,access) case  entry: {type   var;\
                         couples->readAs##access(name,&var); \
-                        *(type *)(address+params[i].offset)=var;}break;
+                        *(type *)(address+params[i].offset)=var;};break;
            SWAL(ADM_param_uint32_t,uint32_t,u32,Uint32)
            SWAL(ADM_param_int32_t, int32_t, i32,Int32)
            SWAL(ADM_param_float,   float ,  f,Float)
@@ -284,12 +328,35 @@
                         *(char  **)(address+params[i].offset)=var;
                     }
                     break;
+            default:
+                    ADM_error("Type no handled %d\n",params[i].type);
+                    break;
         }
     }
     return true;
 }
 /**
     \fn ADM_paramLoad
+    \brief Load a structure from a list of confCouple, validate that all fields are there
+*/
+bool ADM_paramLoad(CONFcouple *couples, const ADM_paramList *params,void *s)
+{
+    if(false==ADM_paramValidate(couples,params)) return false;
+    return ADM_paramLoadInternal(false,couples,params,s);
+
+}
+/**
+    \fn ADM_paramLoad
+    \brief Load a structure from a list of confCouple, accept partial fields
+*/
+
+bool ADM_paramLoadPartial(CONFcouple *couples, const ADM_paramList *params,void *s)
+{
+   if(false==ADM_paramValidatePartialList(couples,params)) return false;
+   return ADM_paramLoadInternal(true,couples,params,s);
+}
+/**
+    \fn ADM_paramLoad
     \brief Save a structure to a list of confCouple
 */
 bool ADM_paramSave(CONFcouple **couples, const ADM_paramList *params,void *s)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderInternal.h	2011-01-07 07:30:45 UTC (rev 6918)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderInternal.h	2011-01-10 18:52:31 UTC (rev 6919)
@@ -15,7 +15,7 @@
 #ifndef VIDEOENCODERINTERNAL_H
 #define VIDEOENCODERINTERNAL_H
 
-#define ADM_VIDEO_ENCODER_API_VERSION 4
+#define ADM_VIDEO_ENCODER_API_VERSION 5
 #include "ADM_coreVideoEncoder.h"
 #include "DIA_uiTypes.h"
 #include "ADM_paramList.h"
@@ -38,7 +38,7 @@
     void         (*destroy)(ADM_coreVideoEncoder *codec);
     bool         (*configure)(void);                                // Call UI to set it up
     bool         (*getConfigurationData)(CONFcouple **c); // Get the encoder private conf
-    bool         (*setConfigurationData)(CONFcouple *c);   // Set the encoder private conf
+    bool         (*setConfigurationData)(CONFcouple *c,bool full);   // Set the encoder private conf
 
     ADM_UI_TYPE  UIType;                // Type of UI
     uint32_t     major,minor,patch;     // Version of the plugin
@@ -50,7 +50,7 @@
 /**************************************************************************/
 #define ADM_DECLARE_VIDEO_ENCODER_PREAMBLE(Class) \
 static bool getConfigurationData (CONFcouple **c); \
-static bool setConfigurationData (CONFcouple *c);\
+static bool setConfigurationData (CONFcouple *c,bool full=true);\
 \
 static ADM_coreVideoEncoder * create (ADM_coreVideoFilter * head,bool globalHeader) \
 { \
@@ -83,9 +83,10 @@
          if(confTemplate==NULL) {*c=NULL;return true;} \
          return ADM_paramSave(c,confTemplate,confVar); \
 }\
-bool setConfigurationData (CONFcouple *c)\
+bool setConfigurationData (CONFcouple *c,bool full)\
 {\
-        return ADM_paramLoad(c,confTemplate,confVar); \
+	if(full) return ADM_paramLoad(c,confTemplate,confVar); \
+	return ADM_paramLoadPartial(c,confTemplate,confVar); \
 } \
 extern "C" ADM_videoEncoderDesc *getInfo (void) \
 { \



From mean at mail.berlios.de  Mon Jan 10 19:52:47 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 10 Jan 2011 19:52:47 +0100
Subject: [Avidemux-svn-commit] r6921 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2:
	. doc doc/man doc/man/man1
Message-ID: <20110110185247.E38EF480510@sheep.berlios.de>

Author: mean
Date: 2011-01-10 19:52:47 +0100 (Mon, 10 Jan 2011)
New Revision: 6921

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/COPYING
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/README
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/Authors.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/BuildRepository.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/BuildSource.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/Documentation.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/GNUmakefile.mk
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/ReleaseNotes.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/ToolGuide.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4art.1
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4file.1
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4subtitle.1
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4track.1
Log:
[libmp4v2] Add license & doc

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/COPYING
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/COPYING	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/COPYING	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,481 @@
+		  GNU LIBRARY GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1991 Free Software Foundation, Inc.
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the library GPL.  It is
+ numbered 2 because it goes with version 2 of the ordinary GPL.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Library General Public License, applies to some
+specially designated Free Software Foundation software, and to any
+other libraries whose authors decide to use it.  You can use it for
+your libraries, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if
+you distribute copies of the library, or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link a program with the library, you must provide
+complete object files to the recipients so that they can relink them
+with the library, after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  Our method of protecting your rights has two steps: (1) copyright
+the library, and (2) offer you this license which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  Also, for each distributor's protection, we want to make certain
+that everyone understands that there is no warranty for this free
+library.  If the library is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original
+version, so that any problems introduced by others will not reflect on
+the original authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that companies distributing free
+software will individually obtain patent licenses, thus in effect
+transforming the program into proprietary software.  To prevent this,
+we have made it clear that any patent must be licensed for everyone's
+free use or not licensed at all.
+
+  Most GNU software, including some libraries, is covered by the ordinary
+GNU General Public License, which was designed for utility programs.  This
+license, the GNU Library General Public License, applies to certain
+designated libraries.  This license is quite different from the ordinary
+one; be sure to read it in full, and don't assume that anything in it is
+the same as in the ordinary license.
+
+  The reason we have a separate public license for some libraries is that
+they blur the distinction we usually make between modifying or adding to a
+program and simply using it.  Linking a program with a library, without
+changing the library, is in some sense simply using the library, and is
+analogous to running a utility program or application program.  However, in
+a textual and legal sense, the linked executable is a combined work, a
+derivative of the original library, and the ordinary General Public License
+treats it as such.
+
+  Because of this blurred distinction, using the ordinary General
+Public License for libraries did not effectively promote software
+sharing, because most developers did not use the libraries.  We
+concluded that weaker conditions might promote sharing better.
+
+  However, unrestricted linking of non-free programs would deprive the
+users of those programs of all benefit from the free status of the
+libraries themselves.  This Library General Public License is intended to
+permit developers of non-free programs to use free libraries, while
+preserving your freedom as a user of such programs to change the free
+libraries that are incorporated in them.  (We have not seen how to achieve
+this as regards changes in header files, but we have achieved it as regards
+changes in the actual functions of the Library.)  The hope is that this
+will lead to faster development of free libraries.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, while the latter only
+works together with the library.
+
+  Note that it is possible for a library to be covered by the ordinary
+General Public License rather than by this special one.
+
+		  GNU LIBRARY GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library which
+contains a notice placed by the copyright holder or other authorized
+party saying it may be distributed under the terms of this Library
+General Public License (also called "this License").  Each licensee is
+addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also compile or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    c) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    d) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the source code distributed need not include anything that is normally
+distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Library General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/README
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/README	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/README	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,5 @@
+All docs are located in doc/ subdirectory. Useful starting points:
+
+Release Notes           -- doc/ReleaseNotes.txt
+Building the Source     -- doc/BuildSource.txt
+Building the Repository -- doc/BuildRepository.txt

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/Authors.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/Authors.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/Authors.txt	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,22 @@
+MP4v2 1.9.1 Authors
+*******************
+
+This document lists significant contributors to MP4v2. If any
+contributors are missing please contact one of the project members.
+More extensive contributor information may be found in sources, docs,
+and other files where appropriate.
+
+     Edward Groenendaal          egroenen at cisco.com
+     Jonathon Rubin              jb.rubin at gmail.com
+     Kona Blend                  kona8lend at gmail.com
+     Rouven Wessling             mp4v2 at rouvenwessling.de
+
+Authors from original MPEG4IP/libmp4v2
+======================================
+
+     Dave Mackie                 dmackie at cisco.com
+     Alix Marchandise-Franquet   alix at cisco.com
+     Bill May                    wmay at cisco.com
+     Ximpo Group Ltd.            mp4v2 at ximpo.com
+     Danijel Kopcinovic          danijel.kopcinovic at adnecto.net
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/BuildRepository.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/BuildRepository.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/BuildRepository.txt	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,720 @@
+MP4v2 1.9.1 Building the Repository
+***********************************
+
+Table of Contents
+*****************
+
+1 Overview
+2 Introduction
+3 Quickstart
+4 Build Process
+  4.1 Checkout Sources
+  4.2 Boostrap (Autotools)
+  4.3 Configure
+  4.4 Build
+  4.5 Install
+  4.6 Create Distribution
+  4.7 Build Documentation
+  4.8 Post Site and API Documentation to project website.
+5 Platform Notes
+  5.1 Mac OS X
+    5.1.1 Default Binaries
+    5.1.2 Release Binaries
+    5.1.3 Developer Binaries
+    5.1.4 Universal Binaries - all architectures
+    5.1.5 Universal Binaries - selected architectures
+  5.2 Linux
+    5.2.1 Default Binaries
+    5.2.2 Release Binaries
+    5.2.3 Developer Binaries
+    5.2.4 Bi-arch compilation
+  5.3 FreeBSD
+    5.3.1 Default Binaries
+    5.3.2 Release Binaries
+    5.3.3 Developer Binaries
+    5.3.4 Bi-arch compilation
+  5.4 Solaris
+    5.4.1 Default Binaries
+    5.4.2 Release Binaries
+    5.4.3 Developer Binaries
+    5.4.4 Bi-arch compilation
+  5.5 Cygwin
+    5.5.1 Default Binaries
+    5.5.2 Release Binaries
+    5.5.3 Developer Binaries
+  5.6 Windows
+
+
+1 Overview
+**********
+
+The documented and supported method to build MP4v2 uses the GNU build
+system (also known as the Autotools). You must first obtain the sources
+by either downloading and extracting the source-distribution bundle or
+working directly MP4v2's Subversion repository. We have build documents
+for both methods, but unless you are a member of the MP4v2 project, you
+are strongly encouraged to use the source-distribution method.
+
+On other supported platforms which lack Autotools we provide an
+alternative method for building the software. Please see the
+appropriate platform section.
+
+2 Introduction
+**************
+
+This document describes the recommended process to build MP4v2 from the
+repository. This process is a superset of the process to build from a
+source-distribution bundle.  If you are interested in building from a
+source-distribution bundle then this document is not for you.
+
+3 Quickstart
+************
+
+This chapter is for the impatient or those just looking for a quick
+summary of all the commands used in a typical build. You may skip this
+summary and jump to *note Build Process::.
+
+     svn checkout https://mp4v2.googlecode.com/svn/releases/1.9.1 mp4v2
+     cd mp4v2
+     autoreconf -fiv
+     rm -fr build/
+     mkdir build/
+     cd build/
+     ../configure
+     make
+     make install
+     make install-man
+     make dist
+
+4 Build Process
+***************
+
+4.1 Checkout Sources
+====================
+
+Checkout sources from the project's Subversion repository.
+
+Sources are checked out from either the trunk, release or a branch.
+This document was generated from one of those, and for example
+purposes, we will use exactly the same URL which used to create the
+distribution which contains this document.
+
+If you are a project member, then you may add the appropriate
+login/password information as needed.
+
+     svn checkout https://mp4v2.googlecode.com/svn/releases/1.9.1 mp4v2
+     cd mp4v2
+
+It is recommended to use Subversion 1.5.0 or higher.  Lower versions
+might work.
+
+4.2 Boostrap (Autotools)
+========================
+
+The following command causes forces Autotools to regenerate all files
+and install helper scripts needed at configure-time and to regenerate
+all files.
+
+     autoreconf -fiv
+
+If you are a project member and preparing for a release, it is
+important to note that the versions of Autotools available in your path
+will directly effect files added to the bundle. At the time of writing,
+the following versions of Autotools are recommended; in some cases a
+minimum is hard-coded and warnings will be issued if in violation:
+
+   * GNU autoconf 2.61 or higher (lower versions might work)
+
+   * GNU automake 1.10 or higher (lower versions might work)
+
+   * GNU libtool 1.5.26 or higher (lower versions might work)
+
+4.3 Configure
+=============
+
+The following command configures the project for a build.  It is highly
+recommended that you invoke configure from an empty directory.
+
+     rm -fr build/
+     mkdir build/
+     cd build/
+     ../configure
+
+Please see `INSTALL' for details on configure usage, and standard
+options. Additionally, the following custom options have been added to
+`configure':
+
+`--disable-debug'
+     Do not generate debug information.  Do not direct compiler to
+     generate debugging information. By default the compiler will
+     generate debug information if the platform supports it.
+
+`--disable-optimize'
+     Do not optimize. Do not direct compiler to optimize code. By
+     default compiler optimization is enabled if the platform supports
+     it.
+
+`--disable-fvisibility'
+     Do not set default ELF symbol visibility. By default configure
+     attempts to detect if the compiler supports this feature. However
+     on some platforms detecting incompatibilty of this feature might
+     not be accurate in which case this option should be given.
+
+`--disable-gch'
+     By default certain platforms are marked to use GCC precompiled
+     headers. Generally this greatly decrease build times but may
+     require more diligence for iterative development; that is to say
+     dependencies may not properly be tracked and more frequent `make
+     clean' may be required when headers are changed. Use this option
+     to disable GCC precompiled headers.
+
+`--disable-largefile'
+     On some 32-bit platforms or configurations it might be desirable
+     to build without largefile (LFS) support. By default configure
+     attempts to detect formal LFS support and enables it if found.
+
+`--disable-util'
+     Do not build/install utilities. This is convenience option for
+     users who desire to skip building the utilities (eg. command-line
+     executables) which are enabled by default.
+
+`--enable-bi=ARCH'
+     On bi-arch capable platforms it is possible to generate 32 or 64
+     bit code. This is supported by adding arguments `-m32' or `-m64',
+     respectively, when compiling or linking. Use this option to
+     override the platform-specific default.
+
+`--enable-ub[=ARCHS]'
+     On OSX systems it is possible to generate universal binaries. This
+     is supported by adding one or more argument patterns `-arch ARCH'
+     when compiling or linking. Use this option to either target an
+     architecture different from the platform default, or to produce
+     universal binaries.
+
+`--enable-dependency-tracking'
+     Enable automatic dependency tracking for include-files. By default
+     this feature is disabled.
+
+
+4.4 Build
+=========
+
+The following command will build MP4v2.
+
+     make
+
+On some platforms `make' refers to a BSD-flavor of make which is not
+compatible with this project. Check if `gmake' is installed, and if it
+is, substitute `gmake' wherever you may see `make' in this document.
+Otherwise you will need to install GNU make package version 3.81 or
+higher. Lower versions might work.
+
+4.5 Install
+===========
+
+The following command will install MP4v2.
+
+     make install
+     make install-man
+
+4.6 Create Distribution
+=======================
+
+The following command will create a MP4v2 source distribution. It is
+during this step that shipped documentation is generated.
+
+     make dist
+
+This step in the build process introduces additional requirements to
+the host system. While most of the following utilities are generally
+available, `help2man' is used to generate man-pages; however if this
+command is not available the man-pages will be empty. This is
+acceptable for non-release builds but for full quality builds this
+command is required.
+
+   * GNU help2man 1.36 or higher (lower versions should work)
+
+   * GNU tar 1.15.1 or higher (lower versions should work)
+
+   * GNU gzip 1.3.10 or higher (lower versions should work)
+
+   * bzip2 1.0.4 or higher (lower versions should work)
+
+   * Info-ZIP zip 2.32 or higher (lower versions should work)
+
+4.7 Build Documentation
+=======================
+
+This step in the build process introduces some significant requirements
+to the host system:
+
+   * GNU texinfo 4.8 or higher (lower versions should work)
+
+   * Doxygen 1.5.7 or higher (lower versions should work)
+
+Documentation that is shipped with source-distribution is generated as
+part of the *note Build Process:: step. This section documents builds
+all of the supported methods to build documentation. There are three
+kinds of documentation in this project; man-pages, articles and API.
+Documentation must be build from the repository.
+
+Man-pages are automatically generated for command-line utilities by
+using `html2man' which invokes standard options `--help' and
+`--version' and gleans the information, generating a man-page in nroff
+script. Note that the utilities will first be built as they are
+depdendencies of man-page generation.
+
+Artcles are usually hand-written and authored in Texinfo format which
+permits macro-expansions, simple formatting and conversion to several
+popular formats using the GNU `makeinfo'. A Texinfo manual
+(http://www.gnu.org/software/texinfo) is available.
+
+API is documented inline to C and C++ source files, usually headers
+using Doxygen comment-formatting. Doxygen is then used to post-process
+these files and generate documentation in various formats. A Doxygen
+manual is available at it's main site (http://www.doxygen.org) .
+
+The project's goal is to document as thoroughly as possible the public
+API in MP4v2. Since we never have enough time to document everything,
+we try to set some priorities in this regard. Generally the public API
+is the highest priority to document. Next most important is probably
+underlying utility code which is shared by many developers; for example
+libplatform.
+
+If you need examples of how to document C-compatible source see
+`include/mp4v2/mp4v2.h' and for C++-only source see
+`libplatform/io/File.h' .
+
+The following table describes the various make targets available for
+building docs. Note you must first have completed the *note Configure::
+step.
+
+`make man'
+     Generate man-pages for command-line utilities.
+
+`make html'
+     Generate articles in HTML format from `texi' files.
+
+`make txt'
+     Generate articles in plaintext format from `texi' files.
+
+`make wiki'
+     Generate articles in Google Code Wiki format from `texi' files.
+
+`make xml'
+     Generate articles in (Texinfo) XML format from `texi' files.
+
+`make api'
+     Generate API in HTML format from header files.
+
+`make articles'
+     Convenience; the equivalent of `make html txt wiki xml' .
+
+`make doc'
+     Convenience; the equivalent of `make man articles api' .
+
+
+And finally all of the document targets have a corresponding clean
+target which cleans up generated files. Simply prefix as follows:
+
+     make manclean
+     make htmlclean
+     make txtclean
+     make wikiclean
+     make xmlclean
+     make apiclean
+     make articlesclean
+     make docclean
+
+4.8 Post Site and API Documentation to project website.
+=======================================================
+
+This step is for project maintainers and can be used to update Site and
+API documentation. The following components are updated:
+
+   * Featured Wiki article: BuildRepository
+
+   * Featured Wiki article: BuildSource
+
+   * MP4v2 (trunk) docs (includes Release Notes and other articles, and
+     API docs).
+
+This procedure may only be run from a *nix platform and has only been
+tested on Mac OS X.
+
+`make google.clean'
+     Clean any local working copy of google changeset.
+
+`make google.post'
+     Generate required docs, sparse-checkout google tree, remove files
+     which are no longer generated, add new files which are generated,
+     and update existing files.
+
+`svn ci -m "-refreshed GoogleCode site+api docs." google/.'
+     Check-in changes. This might take several minutes, especially if
+     your upstream bandwidth is limited.
+
+
+5 Platform Notes
+****************
+
+MP4v2 builds on many unix-style platforms, also commonly referred to as
+posix-style systems. Building on Mac OS X, Linux, FreeBSD, Solaris,
+Cygwin, Windows are known to work.
+
+Similar platforms should also work. Please see the following platform
+specific notes for instructions on commonly used options for various
+platforms.
+
+5.1 Mac OS X
+============
+
+Building on Mac OS X is well supported as it is used by maintainers of
+this project. The following are the recommended specifications for this
+platform; but is not necessarily the only configuration that is
+possible:
+
+   * Mac Intel hardware
+
+   * Mac OS X 10.5.7
+
+   * Xcode-3.1.2
+
+   * gcc 4.0.1 (Apple Inc. build 5493)
+
+   * gcc 4.2.1 (Apple Inc. build 5570)
+
+     Note: It is recommended to use the platform distribution's bundled
+     compiler for maximum C++ compatibility. If you build with a custom
+     compiler it will likely introduce non-standard runtime
+     requirements for your users. There are of course many valid
+     reasons to build with unbundled compilers, but be aware that is
+     generally unsupported and left as an exercise to the reader.
+
+5.1.1 Default Binaries
+----------------------
+
+The preferred method to produce default binaries is to run configure
+without any options which will compile with debug+optimize and produce
+static+shared libraries and dynamic executables.
+
+     ../configure
+
+5.1.2 Release Binaries
+----------------------
+
+The preferred method to produce binaries suitable for releases, (ie.
+which does not contain debug information) is to pass the following to
+configure:
+
+     ../configure --disable-debug
+
+5.1.3 Developer Binaries
+------------------------
+
+The preferred method to produce binaries suitable for development is to
+pass the following to configure.  Default Binaries will work, however
+for the best debugging experience we recommend no optimize and no
+static libraries.
+
+     ../configure --disable-optimize --disable-static
+
+5.1.4 Universal Binaries - all architectures
+--------------------------------------------
+
+The preferred method to produce universal binaries for all supported
+architectures is to pass the following option to configure. As of this
+writing, architectures { i386, x86_64, ppc, ppc64 } are built.
+
+     ../configure --enable-ub
+
+5.1.5 Universal Binaries - selected architectures
+-------------------------------------------------
+
+The preferred method to produce universal binaries for selected
+architectures is to specify a comma-delimited list specifying the
+desired architecture identifiers. Passing the following option will
+produce universal binaries for architectures { i386, x86_64 }.
+
+     ../configure --enable-ub=i386,x86_64
+
+5.2 Linux
+=========
+
+Building on Linux is well supported as it is used by maintainers of
+this project. The following are the recommended specifications for this
+platform; but is not necessarily the only configuration that is
+possible:
+
+   * Intel 32-bit or 64-bit hardware
+
+   * Fedora 10, gcc 4.3.2
+
+   * gcc 3.4.0 or higher is reported to work
+
+     Note: It is recommended to use the platform distribution's bundled
+     compiler for maximum C++ compatibility. If you build with a custom
+     compiler it will likely introduce non-standard runtime
+     requirements for your users. There are of course many valid
+     reasons to build with unbundled compilers, but be aware that is
+     generally unsupported and left as an exercise to the reader.
+
+5.2.1 Default Binaries
+----------------------
+
+The preferred method to produce default binaries is to run configure
+without any options which will compile with debug+optimize and produce
+static+shared libraries and dynamic executables.
+
+     ../configure
+
+5.2.2 Release Binaries
+----------------------
+
+The preferred method to produce binaries suitable for releases, (ie.
+which does not contain debug information) is to pass the following to
+configure:
+
+     ../configure --disable-debug
+
+5.2.3 Developer Binaries
+------------------------
+
+The preferred method to produce binaries suitable for development is to
+pass the following to configure.  Default Binaries will work, however
+for the best debugging experience we recommend no optimize and no
+static libraries.
+
+     ../configure --disable-optimize --disable-static
+
+5.2.4 Bi-arch compilation
+-------------------------
+
+The preferred method to produce a bi-arch binary is to specify the
+target (eg. 32-bit) with the following option to configure. This
+example will produce a 32-bit binary if compiling on a platform which
+defaults to producing 64-bit binaries. The inverse is also possible.
+
+     ../configure --enable-bi=32
+
+     Warning: Currently bi-arch cross-compilation is not supported due
+     to a bug with libtool which fails miserably during linking.
+
+5.3 FreeBSD
+===========
+
+Building on FreeBSD is supported. The following are the recommended
+specifications for this platform; but is not necessarily the only
+configuration that is possible:
+
+   * Intel 32-bit or 64-bit hardware
+
+   * FreeBSD 7.0 Release, gcc 4.2.1
+
+   * gcc 3.4.0 or higher is reported to work
+
+     Note: It is recommended to use the platform distribution's bundled
+     compiler for maximum C++ compatibility. If you build with a custom
+     compiler it will likely introduce non-standard runtime
+     requirements for your users. There are of course many valid
+     reasons to build with unbundled compilers, but be aware that is
+     generally unsupported and left as an exercise to the reader.
+
+5.3.1 Default Binaries
+----------------------
+
+The preferred method to produce default binaries is to run configure
+without any options which will compile with debug+optimize and produce
+static+shared libraries and dynamic executables.
+
+     ../configure
+
+5.3.2 Release Binaries
+----------------------
+
+The preferred method to produce binaries suitable for releases, (ie.
+which does not contain debug information) is to pass the following to
+configure:
+
+     ../configure --disable-debug
+
+5.3.3 Developer Binaries
+------------------------
+
+The preferred method to produce binaries suitable for development is to
+pass the following to configure.  Default Binaries will work, however
+for the best debugging experience we recommend no optimize and no
+static libraries.
+
+     ../configure --disable-optimize --disable-static
+
+5.3.4 Bi-arch compilation
+-------------------------
+
+The preferred method to produce a bi-arch binary is to specify the
+target (eg. 32-bit) with the following option to configure. This
+example will produce a 32-bit binary if compiling on a platform which
+defaults to producing 64-bit binaries. The inverse is also possible.
+
+     ../configure --enable-bi=32
+
+     Warning: Currently bi-arch cross-compilation is not supported due
+     to a bug with libtool which fails miserably during linking.
+
+5.4 Solaris
+===========
+
+Building on Solaris is supported. The following are the recommended
+specifications for this platform; but is not necessarily the only
+configuration that is possible:
+
+   * Intel 32-bit or 64-bit hardware
+
+   * Solaris 10u6, gcc 3.4.3
+
+   * gcc 3.4.0 or higher is reported to work
+
+     Note: It is recommended to use the platform distribution's bundled
+     compiler for maximum C++ compatibility. If you build with a custom
+     compiler it will likely introduce non-standard runtime
+     requirements for your users. There are of course many valid
+     reasons to build with unbundled compilers, but be aware that is
+     generally unsupported and left as an exercise to the reader.
+
+     Note: Solaris does not (yet) really bundle a compiler. The
+     recommendation is to use the companion-disk compiler for maximum
+     C++ runtime compatibility. It is usually found in `/usr/sfw/bin'.
+
+5.4.1 Default Binaries
+----------------------
+
+The preferred method to produce default binaries is to run configure
+without any options which will compile with debug+optimize and produce
+static+shared libraries and dynamic executables.
+
+     ../configure
+
+5.4.2 Release Binaries
+----------------------
+
+The preferred method to produce binaries suitable for releases, (ie.
+which does not contain debug information) is to pass the following to
+configure:
+
+     ../configure --disable-debug
+
+5.4.3 Developer Binaries
+------------------------
+
+The preferred method to produce binaries suitable for development is to
+pass the following to configure.  Default Binaries will work, however
+for the best debugging experience we recommend no optimize and no
+static libraries.
+
+     ../configure --disable-optimize --disable-static
+
+5.4.4 Bi-arch compilation
+-------------------------
+
+The preferred method to produce a bi-arch binary is to specify the
+target (eg. 32-bit) with the following option to configure. This
+example will produce a 32-bit binary if compiling on a platform which
+defaults to producing 64-bit binaries. The inverse is also possible.
+
+     ../configure --enable-bi=32
+
+     Warning: Currently bi-arch cross-compilation is not supported due
+     to a bug with libtool which fails miserably during linking.
+
+5.5 Cygwin
+==========
+
+Building on Cygwin is supported. The following are the recommended
+specifications for this platform; but is not necessarily the only
+configuration that is possible:
+
+   * Intel 32-bit or 64-bit hardware
+
+   * Cygwin, gcc 4.3.2
+
+   * gcc 3.4.0 or higher is reported to work
+
+     Note: As of this writing, Cygwin has available to it several
+     versions of gcc; only one of which may be found and used in the
+     path as `gcc' and `g++'. Configure will thus find what is probably
+     the older more stable version of gcc in a typical Cygwin
+     environment. If you desire to build with the newer gcc, it is
+     found in the path as `gcc-4' and `g++-4' respectively and you must
+     indicate to configure the desired versions. Defining the following
+     variables beforing running configure should do the trick:
+
+     setenv CC gcc-4
+     setenv CXX gcc-4
+     ../configure
+
+5.5.1 Default Binaries
+----------------------
+
+The preferred method to produce default binaries is to run configure
+without any options which will compile with debug+optimize and produce
+static+shared libraries and dynamic executables.
+
+     ../configure
+
+5.5.2 Release Binaries
+----------------------
+
+The preferred method to produce binaries suitable for releases, (ie.
+which does not contain debug information) is to pass the following to
+configure:
+
+     ../configure --disable-debug
+
+5.5.3 Developer Binaries
+------------------------
+
+The preferred method to produce binaries suitable for development is to
+pass the following to configure.  Default Binaries will work, however
+for the best debugging experience we recommend no optimize and no
+static libraries.
+
+     ../configure --disable-optimize --disable-static
+
+5.6 Windows
+===========
+
+Native builds on Windows is supported via Microsoft's Visual Studio
+package. Both the commercial version and free version (express) are
+known to work. The following are the recommended specifications for
+this platform; but is not necessarily the only configuration that is
+possible:
+
+   * Intel 32-bit or 64-bit hardware
+
+   * Windows 2000 or higher, Visual Studio 9.0 (aka. Visual Studio 2008)
+
+   * Visual Studio 9.0 Express is reported to work
+
+Only 32-bit binaries are targeted, and win32-API is set to Windows 2000
+or higher. Older versions of Windows, or win32-API are not supported.
+
+MP4v2 has directory `vstudio9.0/' which contains the necessary
+solution+project files to produce a basic build of libmp4v2's DLL and
+several command-line executables. Enabling things such as debugging,
+optimization, etc, are all left as an exercise to the user.
+
+     Warning: Project meta-data is stored in header `project.h'. A
+     proper source distribution is built using autotools and generates
+     `TOP/include/mp4v2/project.h' correctly, which is then bundled
+     with our source distribution. This is adequate for building on the
+     Windows platform.
+
+     However, if you are building from the repository, be warned that
+     there is no method to automatically generate `project.h' on
+     Windows. Instead, we periodically checkin a copy of this file
+     (generated using autotools) as
+     `vstudio9.0/include/mp4v2/project.h' which may from time to time
+     get out of date. If it is significantly out of date, you should
+     find the latest source distribution and copy the `project.h' from
+     there.
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/BuildSource.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/BuildSource.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/BuildSource.txt	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,561 @@
+MP4v2 1.9.1 Building the Source
+*******************************
+
+Table of Contents
+*****************
+
+1 Overview
+2 Introduction
+3 Quickstart
+4 Build Process
+  4.1 Extract
+  4.2 Configure
+  4.3 Build
+  4.4 Install
+5 Platform Notes
+  5.1 Mac OS X
+    5.1.1 Default Binaries
+    5.1.2 Release Binaries
+    5.1.3 Developer Binaries
+    5.1.4 Universal Binaries - all architectures
+    5.1.5 Universal Binaries - selected architectures
+  5.2 Linux
+    5.2.1 Default Binaries
+    5.2.2 Release Binaries
+    5.2.3 Developer Binaries
+    5.2.4 Bi-arch compilation
+  5.3 FreeBSD
+    5.3.1 Default Binaries
+    5.3.2 Release Binaries
+    5.3.3 Developer Binaries
+    5.3.4 Bi-arch compilation
+  5.4 Solaris
+    5.4.1 Default Binaries
+    5.4.2 Release Binaries
+    5.4.3 Developer Binaries
+    5.4.4 Bi-arch compilation
+  5.5 Cygwin
+    5.5.1 Default Binaries
+    5.5.2 Release Binaries
+    5.5.3 Developer Binaries
+  5.6 Windows
+
+
+1 Overview
+**********
+
+The documented and supported method to build MP4v2 uses the GNU build
+system (also known as the Autotools). You must first obtain the sources
+by either downloading and extracting the source-distribution bundle or
+working directly MP4v2's Subversion repository. We have build documents
+for both methods, but unless you are a member of the MP4v2 project, you
+are strongly encouraged to use the source-distribution method.
+
+On other supported platforms which lack Autotools we provide an
+alternative method for building the software. Please see the
+appropriate platform section.
+
+2 Introduction
+**************
+
+This document describes the recommended process to build MP4v2 from a
+source-distribution bundle. This process is a subset of the process to
+build directly from the project's repository. If you are interested in
+building from the repository then this document is not for you.
+
+3 Quickstart
+************
+
+This chapter is for the impatient or those just looking for a quick
+summary of all the commands used in a typical build. You may skip this
+summary and jump to *note Build Process::.
+
+     tar xf mp4v2-1.9.1.tar.bz2
+     cd mp4v2-1.9.1/
+     rm -fr build/
+     mkdir build/
+     cd build/
+     ../configure
+     make
+     make install
+     make install-man
+
+4 Build Process
+***************
+
+4.1 Extract
+===========
+
+Extract sources from a source-distribution bundle. Releases are
+available from `http://code.google.com/p/mp4v2' in the downloads
+(http://code.google.com/p/mp4v2/downloads/list) section.
+
+     tar xf mp4v2-1.9.1.tar.bz2
+     cd mp4v2-1.9.1/
+
+Older versions of `tar' may not automatically uncompress the bundle, so
+you might have to either enter additional flags manually, or first
+decompress the bundle before extracting. Some possible command
+variations for uncompressing a `bz2' file:
+
+     tar xjf mp4v2-1.9.1.tar.bz2
+     bunzip2 -c mp4v2-1.9.1.tar.bz2 | tar xf -
+     bzcat mp4v2-1.9.1.tar.bz2 | tar xf -
+
+And for a `gz' file:
+
+     tar xzf mp4v2-1.9.1.tar.gz
+     gunzip -c mp4v2-1.9.1.tar.gz | tar xf -
+     gzcat mp4v2-1.9.1.tar.gz | tar xf -
+
+4.2 Configure
+=============
+
+The following command configures the project for a build.  It is highly
+recommended that you invoke configure from an empty directory.
+
+     rm -fr build/
+     mkdir build/
+     cd build/
+     ../configure
+
+Please see `INSTALL' for details on configure usage, and standard
+options. Additionally, the following custom options have been added to
+`configure':
+
+`--disable-debug'
+     Do not generate debug information.  Do not direct compiler to
+     generate debugging information. By default the compiler will
+     generate debug information if the platform supports it.
+
+`--disable-optimize'
+     Do not optimize. Do not direct compiler to optimize code. By
+     default compiler optimization is enabled if the platform supports
+     it.
+
+`--disable-fvisibility'
+     Do not set default ELF symbol visibility. By default configure
+     attempts to detect if the compiler supports this feature. However
+     on some platforms detecting incompatibilty of this feature might
+     not be accurate in which case this option should be given.
+
+`--disable-gch'
+     By default certain platforms are marked to use GCC precompiled
+     headers. Generally this greatly decrease build times but may
+     require more diligence for iterative development; that is to say
+     dependencies may not properly be tracked and more frequent `make
+     clean' may be required when headers are changed. Use this option
+     to disable GCC precompiled headers.
+
+`--disable-largefile'
+     On some 32-bit platforms or configurations it might be desirable
+     to build without largefile (LFS) support. By default configure
+     attempts to detect formal LFS support and enables it if found.
+
+`--disable-util'
+     Do not build/install utilities. This is convenience option for
+     users who desire to skip building the utilities (eg. command-line
+     executables) which are enabled by default.
+
+`--enable-bi=ARCH'
+     On bi-arch capable platforms it is possible to generate 32 or 64
+     bit code. This is supported by adding arguments `-m32' or `-m64',
+     respectively, when compiling or linking. Use this option to
+     override the platform-specific default.
+
+`--enable-ub[=ARCHS]'
+     On OSX systems it is possible to generate universal binaries. This
+     is supported by adding one or more argument patterns `-arch ARCH'
+     when compiling or linking. Use this option to either target an
+     architecture different from the platform default, or to produce
+     universal binaries.
+
+`--enable-dependency-tracking'
+     Enable automatic dependency tracking for include-files. By default
+     this feature is disabled.
+
+
+4.3 Build
+=========
+
+The following command will build MP4v2.
+
+     make
+
+On some platforms `make' refers to a BSD-flavor of make which is not
+compatible with this project. Check if `gmake' is installed, and if it
+is, substitute `gmake' wherever you may see `make' in this document.
+Otherwise you will need to install GNU make package version 3.81 or
+higher. Lower versions might work.
+
+4.4 Install
+===========
+
+The following command will install MP4v2.
+
+     make install
+     make install-man
+
+5 Platform Notes
+****************
+
+MP4v2 builds on many unix-style platforms, also commonly referred to as
+posix-style systems. Building on Mac OS X, Linux, FreeBSD, Solaris,
+Cygwin, Windows are known to work.
+
+Similar platforms should also work. Please see the following platform
+specific notes for instructions on commonly used options for various
+platforms.
+
+5.1 Mac OS X
+============
+
+Building on Mac OS X is well supported as it is used by maintainers of
+this project. The following are the recommended specifications for this
+platform; but is not necessarily the only configuration that is
+possible:
+
+   * Mac Intel hardware
+
+   * Mac OS X 10.5.7
+
+   * Xcode-3.1.2
+
+   * gcc 4.0.1 (Apple Inc. build 5493)
+
+   * gcc 4.2.1 (Apple Inc. build 5570)
+
+     Note: It is recommended to use the platform distribution's bundled
+     compiler for maximum C++ compatibility. If you build with a custom
+     compiler it will likely introduce non-standard runtime
+     requirements for your users. There are of course many valid
+     reasons to build with unbundled compilers, but be aware that is
+     generally unsupported and left as an exercise to the reader.
+
+5.1.1 Default Binaries
+----------------------
+
+The preferred method to produce default binaries is to run configure
+without any options which will compile with debug+optimize and produce
+static+shared libraries and dynamic executables.
+
+     ../configure
+
+5.1.2 Release Binaries
+----------------------
+
+The preferred method to produce binaries suitable for releases, (ie.
+which does not contain debug information) is to pass the following to
+configure:
+
+     ../configure --disable-debug
+
+5.1.3 Developer Binaries
+------------------------
+
+The preferred method to produce binaries suitable for development is to
+pass the following to configure.  Default Binaries will work, however
+for the best debugging experience we recommend no optimize and no
+static libraries.
+
+     ../configure --disable-optimize --disable-static
+
+5.1.4 Universal Binaries - all architectures
+--------------------------------------------
+
+The preferred method to produce universal binaries for all supported
+architectures is to pass the following option to configure. As of this
+writing, architectures { i386, x86_64, ppc, ppc64 } are built.
+
+     ../configure --enable-ub
+
+5.1.5 Universal Binaries - selected architectures
+-------------------------------------------------
+
+The preferred method to produce universal binaries for selected
+architectures is to specify a comma-delimited list specifying the
+desired architecture identifiers. Passing the following option will
+produce universal binaries for architectures { i386, x86_64 }.
+
+     ../configure --enable-ub=i386,x86_64
+
+5.2 Linux
+=========
+
+Building on Linux is well supported as it is used by maintainers of
+this project. The following are the recommended specifications for this
+platform; but is not necessarily the only configuration that is
+possible:
+
+   * Intel 32-bit or 64-bit hardware
+
+   * Fedora 10, gcc 4.3.2
+
+   * gcc 3.4.0 or higher is reported to work
+
+     Note: It is recommended to use the platform distribution's bundled
+     compiler for maximum C++ compatibility. If you build with a custom
+     compiler it will likely introduce non-standard runtime
+     requirements for your users. There are of course many valid
+     reasons to build with unbundled compilers, but be aware that is
+     generally unsupported and left as an exercise to the reader.
+
+5.2.1 Default Binaries
+----------------------
+
+The preferred method to produce default binaries is to run configure
+without any options which will compile with debug+optimize and produce
+static+shared libraries and dynamic executables.
+
+     ../configure
+
+5.2.2 Release Binaries
+----------------------
+
+The preferred method to produce binaries suitable for releases, (ie.
+which does not contain debug information) is to pass the following to
+configure:
+
+     ../configure --disable-debug
+
+5.2.3 Developer Binaries
+------------------------
+
+The preferred method to produce binaries suitable for development is to
+pass the following to configure.  Default Binaries will work, however
+for the best debugging experience we recommend no optimize and no
+static libraries.
+
+     ../configure --disable-optimize --disable-static
+
+5.2.4 Bi-arch compilation
+-------------------------
+
+The preferred method to produce a bi-arch binary is to specify the
+target (eg. 32-bit) with the following option to configure. This
+example will produce a 32-bit binary if compiling on a platform which
+defaults to producing 64-bit binaries. The inverse is also possible.
+
+     ../configure --enable-bi=32
+
+     Warning: Currently bi-arch cross-compilation is not supported due
+     to a bug with libtool which fails miserably during linking.
+
+5.3 FreeBSD
+===========
+
+Building on FreeBSD is supported. The following are the recommended
+specifications for this platform; but is not necessarily the only
+configuration that is possible:
+
+   * Intel 32-bit or 64-bit hardware
+
+   * FreeBSD 7.0 Release, gcc 4.2.1
+
+   * gcc 3.4.0 or higher is reported to work
+
+     Note: It is recommended to use the platform distribution's bundled
+     compiler for maximum C++ compatibility. If you build with a custom
+     compiler it will likely introduce non-standard runtime
+     requirements for your users. There are of course many valid
+     reasons to build with unbundled compilers, but be aware that is
+     generally unsupported and left as an exercise to the reader.
+
+5.3.1 Default Binaries
+----------------------
+
+The preferred method to produce default binaries is to run configure
+without any options which will compile with debug+optimize and produce
+static+shared libraries and dynamic executables.
+
+     ../configure
+
+5.3.2 Release Binaries
+----------------------
+
+The preferred method to produce binaries suitable for releases, (ie.
+which does not contain debug information) is to pass the following to
+configure:
+
+     ../configure --disable-debug
+
+5.3.3 Developer Binaries
+------------------------
+
+The preferred method to produce binaries suitable for development is to
+pass the following to configure.  Default Binaries will work, however
+for the best debugging experience we recommend no optimize and no
+static libraries.
+
+     ../configure --disable-optimize --disable-static
+
+5.3.4 Bi-arch compilation
+-------------------------
+
+The preferred method to produce a bi-arch binary is to specify the
+target (eg. 32-bit) with the following option to configure. This
+example will produce a 32-bit binary if compiling on a platform which
+defaults to producing 64-bit binaries. The inverse is also possible.
+
+     ../configure --enable-bi=32
+
+     Warning: Currently bi-arch cross-compilation is not supported due
+     to a bug with libtool which fails miserably during linking.
+
+5.4 Solaris
+===========
+
+Building on Solaris is supported. The following are the recommended
+specifications for this platform; but is not necessarily the only
+configuration that is possible:
+
+   * Intel 32-bit or 64-bit hardware
+
+   * Solaris 10u6, gcc 3.4.3
+
+   * gcc 3.4.0 or higher is reported to work
+
+     Note: It is recommended to use the platform distribution's bundled
+     compiler for maximum C++ compatibility. If you build with a custom
+     compiler it will likely introduce non-standard runtime
+     requirements for your users. There are of course many valid
+     reasons to build with unbundled compilers, but be aware that is
+     generally unsupported and left as an exercise to the reader.
+
+     Note: Solaris does not (yet) really bundle a compiler. The
+     recommendation is to use the companion-disk compiler for maximum
+     C++ runtime compatibility. It is usually found in `/usr/sfw/bin'.
+
+5.4.1 Default Binaries
+----------------------
+
+The preferred method to produce default binaries is to run configure
+without any options which will compile with debug+optimize and produce
+static+shared libraries and dynamic executables.
+
+     ../configure
+
+5.4.2 Release Binaries
+----------------------
+
+The preferred method to produce binaries suitable for releases, (ie.
+which does not contain debug information) is to pass the following to
+configure:
+
+     ../configure --disable-debug
+
+5.4.3 Developer Binaries
+------------------------
+
+The preferred method to produce binaries suitable for development is to
+pass the following to configure.  Default Binaries will work, however
+for the best debugging experience we recommend no optimize and no
+static libraries.
+
+     ../configure --disable-optimize --disable-static
+
+5.4.4 Bi-arch compilation
+-------------------------
+
+The preferred method to produce a bi-arch binary is to specify the
+target (eg. 32-bit) with the following option to configure. This
+example will produce a 32-bit binary if compiling on a platform which
+defaults to producing 64-bit binaries. The inverse is also possible.
+
+     ../configure --enable-bi=32
+
+     Warning: Currently bi-arch cross-compilation is not supported due
+     to a bug with libtool which fails miserably during linking.
+
+5.5 Cygwin
+==========
+
+Building on Cygwin is supported. The following are the recommended
+specifications for this platform; but is not necessarily the only
+configuration that is possible:
+
+   * Intel 32-bit or 64-bit hardware
+
+   * Cygwin, gcc 4.3.2
+
+   * gcc 3.4.0 or higher is reported to work
+
+     Note: As of this writing, Cygwin has available to it several
+     versions of gcc; only one of which may be found and used in the
+     path as `gcc' and `g++'. Configure will thus find what is probably
+     the older more stable version of gcc in a typical Cygwin
+     environment. If you desire to build with the newer gcc, it is
+     found in the path as `gcc-4' and `g++-4' respectively and you must
+     indicate to configure the desired versions. Defining the following
+     variables beforing running configure should do the trick:
+
+     setenv CC gcc-4
+     setenv CXX gcc-4
+     ../configure
+
+5.5.1 Default Binaries
+----------------------
+
+The preferred method to produce default binaries is to run configure
+without any options which will compile with debug+optimize and produce
+static+shared libraries and dynamic executables.
+
+     ../configure
+
+5.5.2 Release Binaries
+----------------------
+
+The preferred method to produce binaries suitable for releases, (ie.
+which does not contain debug information) is to pass the following to
+configure:
+
+     ../configure --disable-debug
+
+5.5.3 Developer Binaries
+------------------------
+
+The preferred method to produce binaries suitable for development is to
+pass the following to configure.  Default Binaries will work, however
+for the best debugging experience we recommend no optimize and no
+static libraries.
+
+     ../configure --disable-optimize --disable-static
+
+5.6 Windows
+===========
+
+Native builds on Windows is supported via Microsoft's Visual Studio
+package. Both the commercial version and free version (express) are
+known to work. The following are the recommended specifications for
+this platform; but is not necessarily the only configuration that is
+possible:
+
+   * Intel 32-bit or 64-bit hardware
+
+   * Windows 2000 or higher, Visual Studio 9.0 (aka. Visual Studio 2008)
+
+   * Visual Studio 9.0 Express is reported to work
+
+Only 32-bit binaries are targeted, and win32-API is set to Windows 2000
+or higher. Older versions of Windows, or win32-API are not supported.
+
+MP4v2 has directory `vstudio9.0/' which contains the necessary
+solution+project files to produce a basic build of libmp4v2's DLL and
+several command-line executables. Enabling things such as debugging,
+optimization, etc, are all left as an exercise to the user.
+
+     Warning: Project meta-data is stored in header `project.h'. A
+     proper source distribution is built using autotools and generates
+     `TOP/include/mp4v2/project.h' correctly, which is then bundled
+     with our source distribution. This is adequate for building on the
+     Windows platform.
+
+     However, if you are building from the repository, be warned that
+     there is no method to automatically generate `project.h' on
+     Windows. Instead, we periodically checkin a copy of this file
+     (generated using autotools) as
+     `vstudio9.0/include/mp4v2/project.h' which may from time to time
+     get out of date. If it is significantly out of date, you should
+     find the latest source distribution and copy the `project.h' from
+     there.
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/Documentation.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/Documentation.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/Documentation.txt	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,33 @@
+MP4v2 1.9.1 Documentation
+*************************
+
+Introduction
+============
+
+Project MP4v2 consists of a C-library and various command-line
+utilities which permit creation and modification of MP4 files as
+defined by as defined by `ISO base media file format', document number
+`ISO/IEC 14496-12:2005(E)'.
+
+Official website
+================
+
+The official website (http://code.google.com/p/mp4v2) makes various
+downloads (http://code.google.com/p/mp4v2/downloads/list) available and
+archives online browesable documentation for releases, including API
+Reference. Questions, bug-reports and general feedback may be submitted
+to the discussion (http://groups.google.com/group/mp4v2) group.
+
+Articles
+********
+
+See Release Notes (`doc/ReleaseNotes.txt')
+See Building the Source (`doc/BuildSource.txt')
+See Building the Repository (`doc/BuildRepository.txt')
+See Authors (`doc/Authors.txt')
+
+Guides
+******
+
+See Command-line Tools Guide (`doc/ToolGuide.txt')
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/GNUmakefile.mk
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/GNUmakefile.mk	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/GNUmakefile.mk	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,387 @@
+###############################################################################
+##
+##  makefile for documentation creation
+##
+##  INTPUT FILES (SOURCE/doc)
+##      doc/
+##          dox/            <-- generated API docs support files
+##          doxygen/        <-- generated API docs support files
+##          texi/           <-- hand-written project articles
+##
+##  OUTPUT FILES (BUILD/doc)
+##      doc/
+##      doc/
+##          api/
+##              html/   <-- API in html format
+##              xml/    <-- API in xml format
+##          articles/
+##              html/   <-- articles in html format
+##              txt/    <-- articles in txt format
+##              wiki/   <-- articles in Google Code Wiki format
+##              xml/    <-- articles in xml-texinfo format
+##          man/
+##              man1/   <-- man-pages for utilities
+##
+###############################################################################
+
+# Conventional VPATH directive breaks too many things so we use vpath and its
+# pattern-spec feature. If new files or extensions are introduced they may need
+# to be added here.
+
+VPATH =
+
+vpath COPYING       $(top_srcdir)
+vpath INSTALL       $(top_srcdir)
+vpath README        $(top_srcdir)
+vpath autoaux/%     $(top_srcdir)
+vpath %.1           $(top_srcdir)
+vpath %.cpp         $(top_srcdir)
+vpath %.h           $(top_srcdir)
+vpath %.m4          $(top_srcdir)
+vpath %.tcc         $(top_srcdir)
+
+###############################################################################
+
+SOURCE/ = $(top_srcdir)/
+BUILD/  = $(top_builddir)/
+
+DOC.in/  = $(SOURCE/)doc/
+DOC.out/ = $(BUILD/)doc/
+
+DOC.out.api/      = $(DOC.out/)api/
+DOC.out.articles/ = $(DOC.out/)articles/
+DOC.out.site/     = $(DOC.out/)site/
+
+###############################################################################
+
+M4       = m4
+M4.flags = -I$(BUILD/)project
+M4.cmd   = $(M4) $(M4.flags) $(1) > $(2)
+M4.deps  = $(BUILD/)project/project.m4
+
+ifeq ($(FOUND_HELP2MAN),yes)
+HELP2MAN       = help2man
+HELP2MAN.flags = -m "$(PROJECT_name) Utilities" -N
+HELP2MAN.cmd   = $(HELP2MAN) $(HELP2MAN.flags) ./$(1) -o $(2)
+else
+HELP2MAN.cmd = touch $(2)
+endif
+
+MAKEINFO.flags      = -I$(DOC.in/)texi -I$(DOC.out/)texi
+MAKEINFO.flags.html = --html --no-headers --no-split
+MAKEINFO.flags.txt  = --plaintext --no-headers
+MAKEINFO.flags.xml  = --xml --output-indent=4
+MAKEINFO.cmd        = makeinfo $(MAKEINFO.flags) $(MAKEINFO.flags.$(1)) $(2) -o $(3)
+
+HTMLCOMBINE = $(SOURCE/)project/htmlcombine.py
+HTMLCOMBINE.cmd   = $(HTMLCOMBINE) --header $(1) --footer $(2) --body $(3) > $(4)
+HTMLCOMBINE.deps  = $(HTMLCOMBINE)
+
+XML2WIKI       = $(SOURCE/)project/xml2wiki.py
+XML2WIKI.flags = --date --toc
+XML2WIKI.cmd   = $(XML2WIKI) $(XML2WIKI.flags) $(1) > $(2)
+XML2WIKI.deps  = $(XML2WIKI)
+
+DOXYGEN     = doxygen
+DOXYGEN.cmd = $(DOXYGEN) $(1)
+
+###############################################################################
+
+DOC.m4.out = \
+    doc/texi/base/project.texi \
+    doc/doxygen/Doxyfile       \
+    doc/doxygen/header.html    \
+    doc/doxygen/footer.html    \
+    doc/html/header.html       \
+    doc/html/footer.html
+
+DOC.man.utils = mp4art mp4file mp4subtitle mp4track
+DOC.man.out   = $(DOC.man.utils:%=$(DOC.out/)man/man1/%.1)
+
+DOC.texi.articles = $(wildcard $(DOC.in/)texi/*.texi $(DOC.out/)texi/*.texi)
+
+DOC.texi.includes = \
+    doc/texi/base/project.texi \
+    $(wildcard $(DOC.in/)texi/*/*.texi $(DOC.out/)texi/*/*.texi)
+
+DOC.texi2html.out = $(DOC.texi.articles:$(DOC.in/)texi/%.texi=$(DOC.out.articles/)html/%.html)
+DOC.texi2txt.out  = $(DOC.texi.articles:$(DOC.in/)texi/%.texi=$(DOC.out.articles/)txt/%.txt)
+DOC.texi2xml.out  = $(DOC.texi.articles:$(DOC.in/)texi/%.texi=$(DOC.out.articles/)xml/%.xml)
+
+DOC.xml2wiki.out  = $(DOC.texi2xml.out:$(DOC.out.articles/)xml/%.xml=$(DOC.out.articles/)wiki/%.wiki)
+
+DOC.api.out = $(DOC.out.api/).stamp
+
+DOC.site.out       = $(DOC.out.site/).stamp
+DOC.site.out.copy  = $(patsubst $(DOC.in/)html/%,$(DOC.out.site/)%, \
+    $(filter-out %.in,$(wildcard $(DOC.in/)html/*)))
+DOC.site.out.index = $(DOC.out.site/)index.html
+DOC.site.out.html  = $(patsubst $(DOC.out.articles/)html/%,$(DOC.out.site/)%, \
+    $(filter-out %/Documentation.html,$(DOC.texi2html.out)))
+
+###############################################################################
+
+MKDIRS += $(dir $(DOC.m4.out))
+MKDIRS += $(DOC.out/)man/man1/
+MKDIRS += $(foreach n,html man texi txt wiki xml,$(DOC.out.articles/)$n)
+MKDIRS += $(DOC.out.api/)
+MKDIRS += $(DOC.out.site/)
+
+###############################################################################
+
+EXTRA_DIST += \
+    $(SOURCE/)vstudio9.0/include/mp4v2/project.h \
+    $(SOURCE/)vstudio9.0/mp4v2.sln \
+    $(wildcard $(SOURCE/)vstudio9.0/*/*.vcproj)
+
+###############################################################################
+
+dist-hook: $(DOC.texi2txt.out) $(DOC.man.out)
+	rm -fr $(distdir)/doc
+	$(mkdir_p) $(distdir)/doc
+	$(INSTALL_DATA) $(DOC.in/)GNUmakefile.mk $(distdir)/doc/.
+ifneq (,$(DOC.texi2txt.out))
+	$(INSTALL_DATA) $(DOC.texi2txt.out) $(distdir)/doc/.
+endif
+ifneq (,$(DOC.man.out))
+	$(mkdir_p) $(distdir)/doc/man/man1
+	$(INSTALL_DATA) $(DOC.man.out) $(distdir)/doc/man/man1
+endif
+
+distclean-local: docclean
+
+###############################################################################
+
+$(DOC.m4.out): %: %.m4 $(M4.deps) | $(dir $(DOC.m4.out))
+	$(call M4.cmd,$<,$@)
+
+###############################################################################
+
+.PHONY: articles doc
+articles: html txt xml wiki
+doc: man articles api site
+
+.PHONY: articlesclean apiclean docclean
+articlesclean: htmlclean txtclean xmlclean wikiclean
+docclean: manclean articlesclean apiclean siteclean
+
+.PHONY: man html txt xml wiki api
+man: $(DOC.man.out)
+html: $(DOC.texi2html.out)
+txt: $(DOC.texi2txt.out)
+xml: $(DOC.texi2xml.out)
+wiki: $(DOC.xml2wiki.out)
+api: $(DOC.api.out)
+site: $(DOC.site.out)
+
+.PHONY: manclean htmlclean txtclean xmlclean wikiclean apiclean
+manclean:
+	rm -f $(DOC.man.out)
+
+htmlclean:
+	rm -f $(DOC.texi2html.out)
+
+txtclean:
+	rm -f $(DOC.texi2txt.out)
+
+xmlclean:
+	rm -f $(DOC.texi2xml.out)
+
+wikiclean:
+	rm -f $(DOC.xml2wiki.out)
+
+apiclean:
+	rm -f $(DOC.api.out)
+	rm -fr $(DOC.out.api/)html/ $(DOC.out.api/)xml/
+
+siteclean:
+	rm -fr $(DOC.out.site/)
+
+###############################################################################
+
+$(DOC.man.out): | $(dir $(DOC.man.out))
+$(DOC.man.out): $(DOC.out/)man/man1/%.1: $(BUILD/)%
+	$(call HELP2MAN.cmd,$<,$@)
+
+$(DOC.texi2html.out): $(DOC.texi.includes) | $(dir $(DOC.texi2html.out))
+$(DOC.texi2html.out): $(DOC.out.articles/)html/%.html: $(DOC.in/)texi/%.texi
+	$(call MAKEINFO.cmd,html,$<,$@)
+
+$(DOC.texi2txt.out): $(DOC.texi.includes) | $(dir $(DOC.texi2txt.out))
+$(DOC.texi2txt.out): $(DOC.out.articles/)txt/%.txt: $(DOC.in/)texi/%.texi
+	$(call MAKEINFO.cmd,txt,$<,$@)
+
+$(DOC.texi2xml.out): $(DOC.texi.includes) | $(dir $(DOC.texi2xml.out))
+$(DOC.texi2xml.out): $(DOC.out.articles/)xml/%.xml: $(DOC.in/)texi/%.texi
+	$(call MAKEINFO.cmd,xml,$<,$@)
+
+$(DOC.xml2wiki.out): $(XML2WIKI.deps) | $(dir $(DOC.xml2wiki.out))
+$(DOC.xml2wiki.out): $(DOC.out.articles/)wiki/%.wiki: $(DOC.out.articles/)xml/%.xml
+	$(call XML2WIKI.cmd,$<,$@)
+
+$(DOC.api.out): | $(dir $(DOC.api.out))
+$(DOC.api.out): $(DOC.in/)doxygen/banner.png
+$(DOC.api.out): $(DOC.in/)doxygen/project.css
+$(DOC.api.out): $(DOC.out/)doxygen/header.html
+$(DOC.api.out): $(DOC.out/)doxygen/footer.html
+$(DOC.api.out): $(DOC.out/)doxygen/Doxyfile
+	$(call DOXYGEN.cmd,$<)
+	$(INSTALL_DATA) $(DOC.in/)doxygen/banner.png $(DOC.out.api/)html/
+	touch $@
+
+###############################################################################
+
+$(DOC.site.out): | $(DOC.out.site/)articles
+$(DOC.site.out): | $(DOC.out.site/)api
+$(DOC.site.out): $(DOC.site.out.copy)
+$(DOC.site.out): $(DOC.site.out.index)
+$(DOC.site.out): $(DOC.site.out.html)
+
+$(DOC.out.site/)articles: | html $(DOC.out.site/)
+	rm -f $@
+	ln -s ../articles/html $@
+
+$(DOC.out.site/)api: | api $(DOC.out.site/)
+	rm -f $@
+	ln -s ../api/html $@
+
+$(DOC.site.out.copy): $(DOC.out.site/)%: $(DOC.in/)html/%
+	$(INSTALL_DATA) $^ $(@D)/.
+
+$(DOC.site.out.index): $(DOC.out/)html/header.html $(DOC.out/)html/footer.html
+$(DOC.site.out.index): $(HTMLCOMBINE.deps)
+$(DOC.site.out.index): $(DOC.out.articles/)html/Documentation.html
+	$(call HTMLCOMBINE.cmd,$(word 2,$^),$(word 3,$^),$<,$@)
+
+$(DOC.site.out.html): $(DOC.out/)html/header.html $(DOC.out/)html/footer.html
+$(DOC.site.out.html): $(HTMLCOMBINE.deps)
+$(DOC.site.out.html): $(DOC.out.site/)%: $(DOC.out.articles/)html/%
+	$(call HTMLCOMBINE.cmd,$(word 2,$^),$(word 3,$^),$<,$@)
+
+###############################################################################
+
+GOOGLE.out/      = $(top_builddir)/google/
+GOOGLE.repo.doc  = $(if $(filter stable,$(PROJECT_repo_type)),$(PROJECT_version),trunk)
+
+google.clean:
+	rm -fr $(GOOGLE.out/)
+
+google.post: site wiki
+google.post: | $(GOOGLE.out/)
+google.post: google.rsync google.rm google.add google.propset
+
+$(GOOGLE.out/):
+	svn co --depth immediates $(PROJECT_repo_root) $(GOOGLE.out/)
+	svn update --set-depth immediates google/wiki
+	svn update --set-depth infinity google/doc/$(GOOGLE.repo.doc)
+
+google.rsync:
+	rsync -vrptPL --delete \
+	    --exclude=".svn/*" --exclude=".svn" \
+	    --exclude="*/.svn/*" --exclude="*/.svn" \
+	    --exclude=".stamp" --exclude="*/.stamp" \
+	    --exclude="*.m4" --exclude="*/*.m4" \
+	    $(DOC.out.site/). $(GOOGLE.out/)doc/$(GOOGLE.repo.doc)/.
+	$(INSTALL_DATA) $(DOC.out.articles/)wiki/BuildRepository.wiki $(GOOGLE.out/)wiki/.
+	$(INSTALL_DATA) $(DOC.out.articles/)wiki/BuildSource.wiki $(GOOGLE.out/)wiki/.
+
+google.rm:
+	@files=`svn status $(GOOGLE.out/) | grep '^!' | awk '{ print $$2 }'`; \
+	if [ -n "$$files" ]; then \
+	    svn rm $$files; \
+	fi
+
+google.add:
+	@files=`svn status $(GOOGLE.out/) | grep '^?' | awk '{ print $$2 }'`; \
+	if [ -n "$$files" ]; then \
+	    svn add $$files; \
+	fi
+
+google.propset:
+	find $(GOOGLE.out/)doc/$(GOOGLE.repo.doc) -type f -a \( -name "*.html" -o -name "*.css" \) -print0 \
+	    | xargs -0 svn propset svn:eol-style native
+	find $(GOOGLE.out/)doc/$(GOOGLE.repo.doc) -type f -a -name "*.html" -print0 \
+	    | xargs -0 svn propset svn:mime-type "text/html"
+
+###############################################################################
+
+dist-hb: distdir=lib$(PACKAGE)
+dist-hb: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >lib$(PACKAGE)-$(VERSION).tar.gz
+	$(am__remove_distdir)
+
+###############################################################################
+
+## Precompiled header support is tricky given libtool's complexity and its
+## historical aversion to supporting it.
+##
+## What we do is add rules to precompile. Unfortunately, we cannot
+## automatically determine what flags libtool adds for compilation variants;
+## ie: PIC or non-PIC compilation. So instead we will hardcode the flags
+## to match. The reason for this is the precompiled-header will not be used if
+## (relevent) compilation flags differ.
+
+CXX.gch.static.flags = $(X_GCH_STATIC_FLAGS)
+CXX.gch.static.in    = libplatform/impl.h src/impl.h libutil/impl.h
+CXX.gch.static.out   = $(CXX.gch.static.in:%=$(BUILD/)%.gch/static)
+
+CXX.gch.shared.flags = $(X_GCH_SHARED_FLAGS)
+CXX.gch.shared.in    = libplatform/impl.h src/impl.h libutil/impl.h
+CXX.gch.shared.out   = $(CXX.gch.shared.in:%=$(BUILD/)%.gch/shared)
+
+CXX.gch.exe.flags = $(X_GCH_FLAGS)
+CXX.gch.exe.in    = util/impl.h
+CXX.gch.exe.out   = $(CXX.gch.exe.in:%=$(BUILD/)%.gch/exe)
+
+CXX.gch.static.dependents = $(libmp4v2_la_OBJECTS)
+CXX.gch.shared.dependents = $(libmp4v2_la_OBJECTS)
+
+CXX.gch.exe.dependents = \
+    $(mp4art_OBJECTS)        \
+    $(mp4chaps_OBJECTS)      \
+    $(mp4extract_OBJECTS)    \
+    $(mp4file_OBJECTS)       \
+    $(mp4info_OBJECTS)       \
+    $(mp4subtitle_OBJECTS)   \
+    $(mp4syncfiles_OBJECTS)  \
+    $(mp4tags_OBJECTS)       \
+    $(mp4track_OBJECTS)      \
+    $(mp4trackdump_OBJECTS)
+
+ifeq ($(X_GCH_STATIC),1)
+$(CXX.gch.static.dependents): $(CXX.gch.static.out)
+endif
+
+ifeq ($(X_GCH_SHARED),1)
+$(CXX.gch.shared.dependents): $(CXX.gch.shared.out)
+endif
+
+ifeq ($(X_GCH),1)
+$(CXX.gch.exe.dependents): $(CXX.gch.exe.out)
+endif
+
+$(CXX.gch.static.out): | $(sort $(dir $(CXX.gch.static.out)))
+$(CXX.gch.static.out): $(BUILD/)%.gch/static: %
+	$(CXXCOMPILE) $(CXX.gch.static.flags) -c $< -o $@
+
+$(CXX.gch.shared.out): | $(sort $(dir $(CXX.gch.shared.out)))
+$(CXX.gch.shared.out): $(BUILD/)%.gch/shared: %
+	$(CXXCOMPILE) $(CXX.gch.shared.flags) -c $< -o $@
+
+$(CXX.gch.exe.out): | $(sort $(dir $(CXX.gch.exe.out)))
+$(CXX.gch.exe.out): $(BUILD/)%.gch/exe: %
+	$(CXXCOMPILE) $(CXX.gch.exe.flags) -c $< -o $@
+
+MKDIRS += $(dir $(CXX.gch.static.out))
+MKDIRS += $(dir $(CXX.gch.shared.out))
+MKDIRS += $(dir $(CXX.gch.exe.out))
+
+clean-local:
+	rm -f $(CXX.gch.static.out)
+	rm -f $(CXX.gch.shared.out)
+	rm -f $(CXX.gch.exe.out)
+
+###############################################################################
+
+$(sort $(MKDIRS)):
+	$(mkdir_p) $@

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/ReleaseNotes.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/ReleaseNotes.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/ReleaseNotes.txt	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,128 @@
+MP4v2 1.9.1 Release Notes
+*************************
+
+Table of Contents
+*****************
+
+1 What's New?
+2 Breaking Changes
+  2.1 Top-level header file
+  2.2 Command-line utilities
+Appendix A Changelog
+  A.1 Version 1.9
+  A.2 Version 1.6
+Appendix B SCM repository details
+
+
+1 What's New?
+*************
+
+Welcome! This is the inaugural release of MP4v2.
+
+This project's goal is to continue development of a C-library named
+`libmp4v2' which was once a part of the (now defunct) MPEG4IP project.
+That library, and some related command-line utilities were branched
+from MPEG4IP version 1.6.1 to seed this project, MP4v2.
+
+2 Breaking Changes
+******************
+
+2.1 Top-level header file
+=========================
+
+This release is nearly 100% API compatible with MPEG4IP, however there
+are some differences. Dependents of this library must now include the
+top-level public header file as follows. This is the only supported
+mechanism to include the library. We do not support attempts to include
+any sub-level header files; such files are private implementation
+details and their naming must not be relied upon.
+
+     #include <mp4v2/mp4v2.h>
+
+2.2 Command-line utilities
+==========================
+
+The command-line utilities have been totally rewritten and enhanced.
+Help usage has been made more consistent and enhanced, please invoke
+the appropriate utility in this fashion for more details:
+
+     command --help
+
+Appendix A Changelog
+********************
+
+A.1 Version 1.9
+===============
+
+  1. Renamed public API top-level header to `<mp4v2/mp4v2.h>' and added
+     namespaces for implementation (private) symbols. Only public API
+     symbols are exported for dynamic (shared) or DLL libraries. All
+     other symbols are now private, notwithstanding static-library
+     usage.
+
+  2. Added initial AC3 support.
+
+  3. Added native Windows port. The port targets `WINVER 0x0500' which
+     is Windows 2000 or higher.
+
+  4. Added QuickTime and Nero chapter support. See `mp4chaps'
+     command-line utility.
+     Contributed by Ullrich Poll?hne <u.pollaehne at gmail.com>.
+
+  5. Enhanced `mp4art' to support multiple cover-art atoms.
+
+  6. Dropped `mp4dump' and replaced with `mp4file' which supports
+     general file operations.
+
+  7. Added `mp4track' with colr-box and pasp-box support.
+
+  8. Fixed corruption of udta.name atom during read-in.
+
+  9. Enhanced `mp4file --dump' to show hexdump-style canonical
+     hex+ASCII data.
+
+ 10. Enhanced `mp4file --dump' to show human-readble value for tag
+     typeCode values.
+
+ 11. Enhanced `mp4file --dump' to show human-readble value for
+     ISO-639-2/T language codes.
+
+ 12. Added new public-API: MP4GetTrackLanguage().
+
+ 13. Added new public-API: MP4SetTrackLanguage().
+
+ 14. Added support for GCC precompiled-headers on various *nix
+     platforms to speed up builds as we are using quite a few C++
+     headers.
+
+ 15. Enhanced `mp4track' to facilitate modification of { enabled,
+     inmovie, inpreview, altgroup, volume, width, height, language,
+     hdlrname, udtaname } properties.
+
+ 16. Added new public-API: MP4GetTrackDurationPerChunk().
+
+ 17. Added new public-API: MP4SetTrackDurationPerChunk() to override
+     default per-track chunk duration.
+
+ 18. Added new public-API: MP4WriteSampleDependency().
+
+ 19. Replaced (undocumented) public-API: MP4CreateEx() with
+     MP4CreateProvider().
+
+ 20. Added new public-API for iTMF Generic functionality.
+
+A.2 Version 1.6
+===============
+
+  1. Branched libmp4v2 module from mpeg4ip project version 1.6.1.
+
+Appendix B SCM repository details
+*********************************
+
+     url:  https://mp4v2.googlecode.com/svn/releases/1.9.1
+     root: https://mp4v2.googlecode.com/svn
+     uuid: 6e6572fa-98a6-11dd-ad9f-f77439c74b79
+     rev:  368
+     date: 2009-07-14 11:25:03 +1200 (Tue, 14 Jul 2009)
+     type: stable
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/ToolGuide.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/ToolGuide.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/ToolGuide.txt	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,415 @@
+MP4v2 1.9.1 Command-line Tools Guide
+************************************
+
+Table of Contents
+*****************
+
+1 Overview
+2 Introduction
+3 Common Options
+4 mp4file
+5 mp4track
+6 mp4art
+
+
+1 Overview
+**********
+
+MP4v2 bundles several command-line tools which, in general, allow some
+basic manipulation of mp4 files which have been created by other means.
+They are not meant to be a complete solution to management of mp4 file
+structure.
+
+The following is a brief summary of the tools available and the
+functionality offered. Other tools may be packaged with the
+distribution but are not yet stable enough to even document. User
+beware.
+
+`mp4file'
+     Operates on the entire file with actions such as list (summary
+     information), optimization and ASCII dumps.
+
+`mp4track'
+     Operates on individual tracks with actions such as colr-box and
+     pasp-box manipulation.
+
+`mp4art'
+     Operates on iTunes Metadata Cover-art Boxes with actions such as
+     list, add, replace, remove and extraction of Cover-art images.
+
+2 Introduction
+**************
+
+The tools are invoked by their command-name, followed by one or more
+options, actions, parameters for actions, and finally one or more files
+on which the tool will operate. Options are specified in one of two
+ways; in short or long syntax. A short-syntax option is prefixed with
+exactly one dash while a long-syntax option is prefixed with exactly
+two dashes. Depending on the option, it may or may not expect an
+argument. Specifying an option which expects an argument usually
+follows either of the following patterns:
+
+     toolname --something value ...
+     toolname --something=value ...
+
+The rest of this guide will use the equals sign method.
+
+3 Common Options
+****************
+
+Many of the tools share a common set of options which. These common
+options usually have identically behaving short or long syntax. In some
+cases short-syntax differs from long-syntax in that it may not require
+an argument. This style is used sparingly and only when truly
+convenient. Even though it is common practice in many unix-style tools
+to permit optional arguments, the tools used in this project will tend
+to avoid that because it can create a great deal of confusion.
+
+The following is a list of common options available:
+
+`-y, --dryrun'
+     do not actually create or modify any files.  In situations where
+     the command will create new or modify existing files, specifying
+     this option will cause the tool to do as much as possible stopping
+     short of performing any actual writes. This is useful to guard
+     against user mistakes or unexpected behavior.
+
+`-k, --keepgoing'
+     continue batch processing even after errors.  When actions involve
+     multiple files or operations, the default behavior is to stop and
+     exit on the first error encountered. Specify this option if it is
+     desirable to record the error but continue processing.
+
+`-o, --overwrite'
+     overwrite existing files when creating.  In situations where a new
+     file will be created, the default behavior is to not overwrite a
+     file if it already exists. Use this option to allow overwriting.
+
+`-f, --force'
+     force overwrite even if file is read-only.  If overwriting is
+     enabled, file permissions may prevent writes. Specify this option
+     to try and overwrite the file anyways. This usually involves
+     deleting the file, then creating a new one.
+
+`-q, --quiet'
+     equivalent to -verbose 0.  Default behavior is to print a low
+     amount of informative information, usually one line of text per
+     action/file. Specify this option to omit normal messages. Errors
+     will still be reported.
+
+`-d, --debug NUM'
+     increase debug or long-option to set NUM.  File I/O with mp4 file
+     structures have special debug options available to users
+     interested in all the fine details. Default is level 1 . The
+     short-syntax is accumulative and takes no argument, while
+     long-syntax takes an argument. For exmaple, the following are
+     equivalent and would set level 3: `-dd' or `-d -d' or `--debug=3'.
+     The following levels are available:
+       0. supressed
+
+       1. add warnings and errors (default)
+
+       2. add table details
+
+       3. add implicits
+
+       4. everything
+
+`-v, --verbose NUM'
+     increase verbosity or long-option to set NUM.  Tool activity by
+     default will generally print one informative message per
+     action/file. Specify this option to change the default behavior.
+     The short-syntax is accumulative and takes no argument, while
+     long-syntax takes an argument.
+       0. warnings and errors
+
+       1. normal informative messages (default)
+
+       2. more informative messages
+
+       3. everything
+
+`-h, --help'
+     print brief help or long-option for extended help.  The
+     short-syntax will produce brief help. Specify the long-option for
+     more extensive help.
+
+`--version'
+     print version information and exit.  Extended version information
+     used for SCM purposes is not listed in help, but is available by
+     specifying `--verionx'.
+
+4 mp4file
+*********
+
+`--list'
+     list (summary information).  This will produce brief report when
+     summarizing each mp4 file.  BRAND shows the file's main brand
+     identifier.  COMPAT shows additional brands for which the file
+     purports to be comaptible with.  SIZING displays if the file has
+     64-bit extensions of any kind, otherwise 32-bit.  Example output:
+          BRAND  COMPAT              SIZING  FILE
+          ----------------------------------------------------------------------
+          M4A    M4A,isom,mp42       32-bit  Song.m4a
+          mp42   isom,mp42           32-bit  Movie1.m4v
+          mp42   isom,mp42           32-bit  Movie2.m4v
+
+`--optimize'
+     optimize mp4 structure.  This will rewrite the entire mp4 file
+     which, if needed, will clean up any unused (free) sections, and
+     re-order the atoms in a manner somewhat consistent with the
+     best-practices described in the ISO base media file specification.
+
+`--dump'
+     dump mp4 structure in human-readable format.  An ASCII dump of mp4
+     atoms is printed to stdout. This action is heavily influenced by
+     `--debug' option.
+
+     Example, list some files:
+          mp4file --list *.mp4 *.m4a *.m4v
+
+     Example, dump a file with more than usual debugging information:
+          mp4file -dd --dump movie.m4v
+
+5 mp4track
+**********
+
+This tool is used to manage various aspects of individual tracks in an
+mp4 file. Some of the actions are mp4 (generic) while others may
+support standards based on mp4 files such as `.m4a' or `.m4v' files.
+Each action has an appropriate scope upon which it acts. See individual
+actions for details. The following parameters are used to set scopes
+for actions:
+
+`--track-any'
+     act on any/all tracks.
+
+`--track-index IDX'
+     act on a single track specified by index value.  A track index is
+     0-based and counts upwards for each track available.
+
+`--track-id ID'
+     act on a single track specified by id value.  A track id is a
+     unique value assigned to each track and never changes.
+
+The list action will produce a brief report of each track for each mp4
+file.  Many (but not all) of the values shown may be modified by
+actions documented later in this article.  This will produce a brief
+report of each track for each mp4 file.
+
+`--list'
+     list all tracks in mp4.  Example output:
+          track[0] id=1
+            type           = video
+            enabled        = true
+            inMovie        = false
+            inPreview      = false
+            layer          = 0
+            alternateGroup = 0
+            volume         = 0.0000
+            width          = 850.96295166
+            height         = 360.00000000
+            language       = UNDEFINED(0)
+            handlerName    =
+            userDataName   = <absent>
+
+The following group of actions are used to modify the values shown by
+-list action. The modification of these values should be done with
+great care on any files, and as always you are cautioned to backup your
+media files before modification.
+
+`--enabled BOOL'
+     set trak.tkhd.flags (enabled bit).  When true indicates the track
+     is enabled.
+
+`--inmovie BOOL'
+     set trak.tkhd.flags (inMovie bit).  When true indicates the track
+     is used in the movie.
+
+`--inpreview BOOL'
+     set trak.tkhd.flags (inPreview bit).  When true indicates the
+     track is used in the movie's preview.
+
+`--layer NUM'
+     set trak.tkhd.layer.  Specifies the front-to-back ordering of
+     video tracks; tracks with lower numbers are closer to the viewer.
+     0 is the normal value, and -1 would be in front of track 0, and so
+     on.
+
+`--altgroup NUM'
+     set trak.tkhd.alternate_group.  An integer that specifies a group
+     or collection of tracks. If this field is 0 there is no
+     information on possible relations to other tracks. If this field
+     is not 0, it should be the same for tracks that contain alternate
+     data for one another and different for tracks belonging to
+     different such groups. Only one track within an alternate group
+     should be played or streamed at any one time, and must be
+     distinguishable from other tracks in the group via attributes such
+     as bitrate, codec, language, packet size etc. A group may have
+     only one member.
+
+`--volume FLOAT'
+     set trak.tkhd.volume.  Specifies the track's relative audio
+     volume. Full volume is 1.0 and is the normal value.
+
+`--width FLOAT'
+     set trak.tkhd.width.  Specifies the track's visual presentation
+     width. By default this is the same as the pixel width of the
+     images. All images in the sequence are scaled to this size before
+     any overall transformation by the matrix.
+
+`--height FLOAT'
+     set trak.tkhd.height.  Specifies the track's visual presentation
+     height. By default this is the same as the pixel width of the
+     images. All images in the sequence are scaled to this size before
+     any overall transformation by the matrix.
+
+`--language CODE'
+     set trak.mdia.mdhd.language.  Specifies the ISO-639-2/T langauge
+     code of the track. For example, `eng' for English, `fra' for
+     French.
+
+`--hdlrname STR'
+     set trak.mdia.hdlr.name.  Specifies a human-readable track type
+     (for debugging and inspection purposes).
+
+`--udtaname STR'
+     set trak.udta.name.value.  Specifies an arbitrary track-name. This
+     value is optional (may be absent).
+
+`--udtaname-remove'
+     remove trak.udta.name atom.  This action will remove the optional
+     atom.
+
+
+The colr related actions manage Color Parameter boxes which are used by
+QuickTime to map numerical values of pixels in a file to a common
+representation of color for video tracks. They may or may not be
+suitable for other Apple media players. Community feedback on
+compatibility is welcome.
+
+`--colr-list'
+     list all colr-boxes in mp4.
+
+`--colr-add'
+     add colr-box to a video track.  An individual track must be
+     specified.
+
+`--colr-set'
+     set colr-box parms.  An individual track must be specified.
+
+`--colr-remove'
+     remove colr-box from track.  By default all colr-boxes will be
+     removed unless an individual track is specified.
+
+`--colr-parms CSV'
+     where CSV is IDX1,IDX2,IDX3 .  Specify the exact parameters of an
+     NCLC Color Parameter box as specified in the QuickTime
+     specification.  IDX1 correlates to the 16-bit primaries index.
+     IDX2 correlates to the 16-bit transferFunction index.  IDX3
+     correlates to the 16-bit matrixIndex index.  Effects actions
+     -colr-add, -colr-set.
+
+`--colr-parm-hd'
+     equivalent to -colr-parms=1,1,1 .  This is a convenience setting
+     generally suitable for HD content.  Effects actions -colr-add,
+     -colr-set.
+
+`--colr-parm-sd'
+     equivalent to -colr-parms=6,1,6 .  This is a convenience setting
+     generally suitable for SD content.  Effects actions -colr-add,
+     -colr-set.
+
+     Example, add a colr-box tuned for HD content:
+          mp4track --track-id=1 --colr-add --colr-parm-hd mymovie.m4v
+
+     Example, add a colr-box with arbitrary index parameters:
+          mp4track --track-id=1 --colr-add --colr-parms=2,3,4 mymovie.m4v
+
+
+The pasp related actions manage Picture Aspect Ratio boxes which are
+used by QuickTime to specify height-to-width ratio of pixels for video
+tracks. They may or may not be suitable for other Apple media players.
+Community feedback on compatibility is welcome.
+
+`--pasp-list'
+     list all pasp-boxes in mp4.
+
+`--pasp-add'
+     add pasp-box to a video track.  An individual track must be
+     specified.
+
+`--pasp-set'
+     set pasp-box parms.  An individual track must be specified.
+
+`--pasp-remove'
+     remove pasp-box from track By default all pasp-boxes will be
+     removed unless an individual track is specified.
+
+`--pasp-parms CSV'
+     where CSV is hSPACING,vSPACING.  Specify the exact parameters of
+     Picture Aspect Ratio box as specified in the QuickTime
+     specification.  Effects actions -pasp-add, -pasp-set.
+
+     Example, add a pasp-box with default (1,1) parameters for square
+     pixels:
+          mp4track --track-id=1 --pasp-add --pasp-parms=1,1 mymovie.m4v
+
+     Example, add a pasp-box for 16:9 digital 525 (NTSC):
+          mp4track --track-id=1 --pasp-add --pasp-parms=40,33 mymovie.m4v
+
+     Example, add a pasp-box for 16:9 digital 625 (PAL):
+          mp4track --track-id=1 --pasp-add --pasp-parms=118,81 mymovie.m4v
+
+
+6 mp4art
+********
+
+This tool is used to manage iTunes Metadata Cover-art which is
+typically used to embed an image to a song file. For example, the songs
+in an album collection might all contain an image of the album cover
+art. This data is usually found in `.m4a', `.m4v' and `.mov' files.
+
+`--art-any'
+     act on all covr-boxes (default).  Specifies the scope of the
+     action to operate on all, if applicable, covr-boxes.
+
+`--art-index IDX'
+     act on covr-box index IDX.  Specifies the scope of the action to
+     operate on single covr-box INDEX.
+
+`--list'
+     list all covr-boxes.
+          IDX     BYTES  CRC32     TYPE       FILE
+          ----------------------------------------------------------------------
+            0    173613  710a3ec9  JPEG       01 Life In Technicolor.m4a
+            0    173613  710a3ec9  JPEG       02 Cemeteries Of London.m4a
+            0    173613  710a3ec9  JPEG       03 Lost!.m4a
+            0    173613  710a3ec9  JPEG       04 42.m4a
+            0    173613  710a3ec9  JPEG       05 Lovers In Japan _ Reign Of Love.m4a
+            0    173613  710a3ec9  JPEG       06 Yes.m4a
+            0    173613  710a3ec9  JPEG       07 Viva La Vida.m4a
+            0    173613  710a3ec9  JPEG       08 Violet Hill.m4a
+            0    173613  710a3ec9  JPEG       09 Strawberry Swing.m4a
+            0    173613  710a3ec9  JPEG       10 Death And All His Friends.m4a
+
+`--add IMG'
+     add covr-box from IMG file.
+
+`--replace IMG'
+     replace covr-box with IMG file.
+
+`--remove'
+     remove covr-box.
+
+`--extract'
+     extract covr-box.  This will extract all covr-box data to image
+     files in the format of `BASENAME.art[INDEX].TYPE' .
+
+     Example, add PNG image file:
+          mp4art --add ACDC.png mysong.m4a
+
+     Example, extract image files from file:
+          mp4art --extract mysong.m4a
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4art.1
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4art.1	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4art.1	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,98 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.29.
+.TH MP4ART "1" "July 2009" "mp4art - MP4v2 1.9.1" "MP4v2 Utilities"
+.SH NAME
+mp4art \- manual page for mp4art - MP4v2 1.9.1
+.SH SYNOPSIS
+.B mp4art
+[\fIOPTION\fR]... \fIACTION file\fR...
+.SH DESCRIPTION
+For each mp4 (m4a) file specified, perform the specified ACTION. An action
+must be specified. Some options are not applicable for some actions.
+.PP
+ACTIONS
+.TP
+\fB\-\-list\fR
+list all covr-boxes
+.TP
+\fB\-\-add\fR IMG
+add covr-box from IMG file
+.TP
+\fB\-\-replace\fR IMG
+replace covr-box with IMG file
+.TP
+\fB\-\-remove\fR
+remove covr-box
+.TP
+\fB\-\-extract\fR
+extract covr-box
+.PP
+ACTION PARAMETERS
+.TP
+\fB\-\-art\-any\fR
+act on all covr-boxes (default)
+.TP
+\fB\-\-art\-index\fR IDX
+act on covr-box index IDX
+.PP
+OPTIONS
+.TP
+\fB\-z\fR, \fB\-\-optimize\fR
+optimize mp4 file after modification
+.TP
+\fB\-y\fR, \fB\-\-dryrun\fR
+do not actually create or modify any files
+.TP
+\fB\-k\fR, \fB\-\-keepgoing\fR
+continue batch processing even after errors
+.TP
+\fB\-o\fR, \fB\-\-overwrite\fR
+overwrite existing files when creating
+.TP
+\fB\-f\fR, \fB\-\-force\fR
+force overwrite even if file is read-only
+.TP
+\fB\-q\fR, \fB\-\-quiet\fR
+equivalent to \fB\-\-verbose\fR 0
+.TP
+\fB\-d\fR, \fB\-\-debug\fR NUM
+increase debug or long-option to set NUM
+.TP
+\fB\-v\fR, \fB\-\-verbose\fR NUM
+increase verbosity or long-option to set NUM
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+print brief help or long-option for extended help
+.TP
+\fB\-\-version\fR
+print version information and exit
+.PP
+DEBUG LEVELS (for raw mp4 file I/O)
+.TP
+0
+supressed
+.TP
+1
+add warnings and errors (default)
+.TP
+2
+add table details
+.TP
+3
+add implicits
+.TP
+4
+everything
+.PP
+VERBOSE LEVELS
+.TP
+0
+warnings and errors
+.TP
+1
+normal informative messages (default)
+.TP
+2
+more informative messages
+.TP
+3
+everything

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4file.1
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4file.1	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4file.1	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,75 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.29.
+.TH MP4FILE "1" "July 2009" "mp4file - MP4v2 1.9.1" "MP4v2 Utilities"
+.SH NAME
+mp4file \- manual page for mp4file - MP4v2 1.9.1
+.SH SYNOPSIS
+.B mp4file
+[\fIOPTION\fR]... \fIACTION file\fR...
+.SH DESCRIPTION
+For each mp4 file specified, perform the specified ACTION. An action must be
+specified. Some options are not applicable to some actions.
+.PP
+ACTIONS
+.TP
+\fB\-\-list\fR
+list (summary information)
+.TP
+\fB\-\-optimize\fR
+optimize mp4 structure
+.TP
+\fB\-\-dump\fR
+dump mp4 structure in human-readable format
+.PP
+OPTIONS
+.TP
+\fB\-y\fR, \fB\-\-dryrun\fR
+do not actually create or modify any files
+.TP
+\fB\-k\fR, \fB\-\-keepgoing\fR
+continue batch processing even after errors
+.TP
+\fB\-q\fR, \fB\-\-quiet\fR
+equivalent to \fB\-\-verbose\fR 0
+.TP
+\fB\-d\fR, \fB\-\-debug\fR NUM
+increase debug or long-option to set NUM
+.TP
+\fB\-v\fR, \fB\-\-verbose\fR NUM
+increase verbosity or long-option to set NUM
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+print brief help or long-option for extended help
+.TP
+\fB\-\-version\fR
+print version information and exit
+.PP
+DEBUG LEVELS (for raw mp4 file I/O)
+.TP
+0
+supressed
+.TP
+1
+add warnings and errors (default)
+.TP
+2
+add table details
+.TP
+3
+add implicits
+.TP
+4
+everything
+.PP
+VERBOSE LEVELS
+.TP
+0
+warnings and errors
+.TP
+1
+normal informative messages (default)
+.TP
+2
+more informative messages
+.TP
+3
+everything

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4subtitle.1
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4subtitle.1	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4subtitle.1	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,87 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.29.
+.TH MP4SUBTITLE "1" "July 2009" "mp4subtitle - MP4v2 1.9.1" "MP4v2 Utilities"
+.SH NAME
+mp4subtitle \- manual page for mp4subtitle - MP4v2 1.9.1
+.SH SYNOPSIS
+.B mp4subtitle
+[\fIOPTION\fR]... \fIACTION file\fR...
+.SH DESCRIPTION
+For each mp4 file specified, perform the specified ACTION. An action must be
+specified. Some options are not applicable to some actions.
+.PP
+ACTIONS
+.TP
+\fB\-\-list\fR
+list available subtitles
+.TP
+\fB\-\-export\fR TXT
+export subtitles to TXT
+.TP
+\fB\-\-import\fR TXT
+import subtitles from TXT
+.TP
+\fB\-\-remove\fR
+remove all subtitles
+.PP
+OPTIONS
+.TP
+\fB\-z\fR, \fB\-\-optimize\fR
+optimize mp4 file after modification
+.TP
+\fB\-y\fR, \fB\-\-dryrun\fR
+do not actually create or modify any files
+.TP
+\fB\-k\fR, \fB\-\-keepgoing\fR
+continue batch processing even after errors
+.TP
+\fB\-o\fR, \fB\-\-overwrite\fR
+overwrite existing files when creating
+.TP
+\fB\-f\fR, \fB\-\-force\fR
+force overwrite even if file is read-only
+.TP
+\fB\-q\fR, \fB\-\-quiet\fR
+equivalent to \fB\-\-verbose\fR 0
+.TP
+\fB\-d\fR, \fB\-\-debug\fR NUM
+increase debug or long-option to set NUM
+.TP
+\fB\-v\fR, \fB\-\-verbose\fR NUM
+increase verbosity or long-option to set NUM
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+print brief help or long-option for extended help
+.TP
+\fB\-\-version\fR
+print version information and exit
+.PP
+DEBUG LEVELS (for raw mp4 file I/O)
+.TP
+0
+supressed
+.TP
+1
+add warnings and errors (default)
+.TP
+2
+add table details
+.TP
+3
+add implicits
+.TP
+4
+everything
+.PP
+VERBOSE LEVELS
+.TP
+0
+warnings and errors
+.TP
+1
+normal informative messages (default)
+.TP
+2
+more informative messages
+.TP
+3
+everything

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4track.1
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4track.1	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/doc/man/man1/mp4track.1	2011-01-10 18:52:47 UTC (rev 6921)
@@ -0,0 +1,161 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.29.
+.TH MP4TRACK "1" "July 2009" "mp4track - MP4v2 1.9.1" "MP4v2 Utilities"
+.SH NAME
+mp4track \- manual page for mp4track - MP4v2 1.9.1
+.SH SYNOPSIS
+.B mp4track
+[\fIOPTION\fR]... [\fIPARAMETERS\fR]... \fIACTION file\fR...
+.SH DESCRIPTION
+For each mp4 file specified, perform the specified ACTION. An action must be
+specified. Some options are not applicable to some actions.
+.PP
+ACTIONS
+.TP
+\fB\-\-list\fR
+list all tracks in mp4
+.TP
+\fB\-\-enabled\fR BOOL
+set trak.tkhd.flags (enabled bit)
+.TP
+\fB\-\-inmovie\fR BOOL
+set trak.tkhd.flags (inMovie bit)
+.TP
+\fB\-\-inpreview\fR BOOL
+set trak.tkhd.flags (inPreview bit)
+.TP
+\fB\-\-layer\fR NUM
+set trak.tkhd.layer
+.TP
+\fB\-\-altgroup\fR NUM
+set trak.tkhd.alternate_group
+.TP
+\fB\-\-volume\fR FLOAT
+set trak.tkhd.volume
+.TP
+\fB\-\-width\fR FLOAT
+set trak.tkhd.width
+.TP
+\fB\-\-height\fR FLOAT
+set trak.tkhd.height
+.TP
+\fB\-\-language\fR CODE
+set trak.mdia.mdhd.language
+.TP
+\fB\-\-hdlrname\fR STR
+set trak.mdia.hdlr.name
+.TP
+\fB\-\-udtaname\fR STR
+set trak.udta.name.value
+.TP
+\fB\-\-udtaname\-remove\fR
+remove trak.udta.name atom
+.TP
+\fB\-\-colr\-list\fR
+list all colr-boxes in mp4
+.TP
+\fB\-\-colr\-add\fR
+add colr-box to a video track
+.TP
+\fB\-\-colr\-set\fR
+set colr-box parms
+.TP
+\fB\-\-colr\-remove\fR
+remove colr-box from track
+.TP
+\fB\-\-pasp\-list\fR
+list all pasp-boxes in mp4
+.TP
+\fB\-\-pasp\-add\fR
+add pasp-box to a video track
+.TP
+\fB\-\-pasp\-set\fR
+set pasp-box parms
+.TP
+\fB\-\-pasp\-remove\fR
+remove pasp-box from track
+.PP
+PARAMETERS
+.TP
+\fB\-\-track\-any\fR
+act on any/all tracks
+.TP
+\fB\-\-track\-index\fR IDX
+act on track index IDX
+.TP
+\fB\-\-track\-id\fR ID
+act on track id ID
+.TP
+\fB\-\-colr\-parms\fR CSV
+where CSV is IDX1,IDX2,IDX3
+.TP
+\fB\-\-colr\-parm\-hd\fR
+equivalent to \fB\-\-colr\-parms\fR=\fI1\fR,1,1
+.TP
+\fB\-\-colr\-parm\-sd\fR
+equivalent to \fB\-\-colr\-parms\fR=\fI6\fR,1,6
+.TP
+\fB\-\-pasp\-parms\fR CSV
+where CSV is hSPACING,vSPACING
+.PP
+OPTIONS
+.TP
+\fB\-z\fR, \fB\-\-optimize\fR
+optimize mp4 file after modification
+.TP
+\fB\-y\fR, \fB\-\-dryrun\fR
+do not actually create or modify any files
+.TP
+\fB\-k\fR, \fB\-\-keepgoing\fR
+continue batch processing even after errors
+.TP
+\fB\-o\fR, \fB\-\-overwrite\fR
+overwrite existing files when creating
+.TP
+\fB\-f\fR, \fB\-\-force\fR
+force overwrite even if file is read-only
+.TP
+\fB\-q\fR, \fB\-\-quiet\fR
+equivalent to \fB\-\-verbose\fR 0
+.TP
+\fB\-d\fR, \fB\-\-debug\fR NUM
+increase debug or long-option to set NUM
+.TP
+\fB\-v\fR, \fB\-\-verbose\fR NUM
+increase verbosity or long-option to set NUM
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+print brief help or long-option for extended help
+.TP
+\fB\-\-version\fR
+print version information and exit
+.PP
+DEBUG LEVELS (for raw mp4 file I/O)
+.TP
+0
+supressed
+.TP
+1
+add warnings and errors (default)
+.TP
+2
+add table details
+.TP
+3
+add implicits
+.TP
+4
+everything
+.PP
+VERBOSE LEVELS
+.TP
+0
+warnings and errors
+.TP
+1
+normal informative messages (default)
+.TP
+2
+more informative messages
+.TP
+3
+everything



From mean at mail.berlios.de  Mon Jan 10 19:52:49 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 10 Jan 2011 19:52:49 +0100
Subject: [Avidemux-svn-commit] r6922 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec
Message-ID: <20110110185249.945BE480510@sheep.berlios.de>

Author: mean
Date: 2011-01-10 19:52:49 +0100 (Mon, 10 Jan 2011)
New Revision: 6922

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt
Log:
[audioEncoder] link also to libavutil (win32)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt	2011-01-10 18:52:47 UTC (rev 6921)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt	2011-01-10 18:52:49 UTC (rev 6922)
@@ -5,7 +5,7 @@
 
 	ADD_LIBRARY(ADM_ae_lav_mp2 SHARED ${ADM_ae_lav_mp2_SRCS})
 	ADD_TARGET_CFLAGS(ADM_ae_lav_mp2 "-DADM_AE_SET='\"ADM_lav_mp2.h\"'")
-	TARGET_LINK_LIBRARIES(ADM_ae_lav_mp2  ADM_libavcodec)
+	TARGET_LINK_LIBRARIES(ADM_ae_lav_mp2  ADM_libavcodec ADM_libavutil)
 
 	INIT_AUDIO_ENCODER(ADM_ae_lav_mp2)
 	INSTALL_AUDIOENCODER(ADM_ae_lav_mp2)
@@ -14,7 +14,7 @@
 
 	ADD_LIBRARY(ADM_ae_lav_ac3 SHARED ${ADM_ae_lav_ac3_SRCS})
 	ADD_TARGET_CFLAGS(ADM_ae_lav_ac3 "-DADM_AE_SET='\"ADM_lav_ac3.h\"'")
-	TARGET_LINK_LIBRARIES(ADM_ae_lav_ac3  ADM_libavcodec)
+	TARGET_LINK_LIBRARIES(ADM_ae_lav_ac3  ADM_libavcodec ADM_libavutil)
 
 	INIT_AUDIO_ENCODER(ADM_ae_lav_ac3)
 	INSTALL_AUDIOENCODER(ADM_ae_lav_ac3)
@@ -23,8 +23,8 @@
 
 	ADD_LIBRARY(ADM_ae_lav_aac SHARED ${ADM_ae_lav_aac_SRCS})
 	ADD_TARGET_CFLAGS(ADM_ae_lav_aac "-DADM_AE_SET='\"ADM_lav_aac.h\"'")
-	TARGET_LINK_LIBRARIES(ADM_ae_lav_aac  ADM_libavcodec)
+	TARGET_LINK_LIBRARIES(ADM_ae_lav_aac  ADM_libavcodec ADM_libavutil)
 
 	INIT_AUDIO_ENCODER(ADM_ae_lav_aac)
 	INSTALL_AUDIOENCODER(ADM_ae_lav_aac)
-#====
\ No newline at end of file
+#====



From mean at mail.berlios.de  Mon Jan 10 19:52:50 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 10 Jan 2011 19:52:50 +0100
Subject: [Avidemux-svn-commit] r6923 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110110185250.B56D5480510@sheep.berlios.de>

Author: mean
Date: 2011-01-10 19:52:50 +0100 (Mon, 10 Jan 2011)
New Revision: 6923

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Plugin.cpp
Log:
[mp4v2] Skeleton

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt	2011-01-10 18:52:49 UTC (rev 6922)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt	2011-01-10 18:52:50 UTC (rev 6923)
@@ -1,6 +1,7 @@
 include(mx_plugin)
 SET(ADM_mp4v2_SRCS
-	./muxerMp4v2Plugin.cpp
+	muxerMp4v2Plugin.cpp
+	muxerMp4v2.cpp
 )
 SUBDIRS(libmp4v2)
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Plugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Plugin.cpp	2011-01-10 18:52:49 UTC (rev 6922)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Plugin.cpp	2011-01-10 18:52:50 UTC (rev 6923)
@@ -16,16 +16,20 @@
 #include "ADM_default.h"
 #include "ADM_muxerInternal.h"
 #include "fourcc.h"
-#if 0
-class muxermp4v2;
-ADM_MUXER_BEGIN( muxermp4v2,
+#include "muxerMp4v2.h"
+
+bool mp4v2Configure(void)
+{
+    return true;
+}
+ADM_MUXER_BEGIN( muxerMp4v2,
                     1,0,0,
                     "MP4V2",    // Internal name
                     "MP4V2 muxer plugin (c) Mean 2011",
                     "MP4 Muxer", // DIsplay name
-                    NULL,
+                    mp4v2Configure,
                     NULL, //template
                     NULL
                 );
-#endif
 
+



From mean at mail.berlios.de  Mon Jan 10 19:52:51 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 10 Jan 2011 19:52:51 +0100
Subject: [Avidemux-svn-commit] r6924 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers
Message-ID: <20110110185251.E3EA9480510@sheep.berlios.de>

Author: mean
Date: 2011-01-10 19:52:51 +0100 (Mon, 10 Jan 2011)
New Revision: 6924

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
Log:
[mp4v2] disable for now

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2011-01-10 18:52:50 UTC (rev 6923)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2011-01-10 18:52:51 UTC (rev 6924)
@@ -6,5 +6,5 @@
 ADD_SUBDIRECTORY(muxerMkv)
 ADD_SUBDIRECTORY(muxerffPS)
 ADD_SUBDIRECTORY(muxerffTS)
-ADD_SUBDIRECTORY(muxerMp4v2)
+#ADD_SUBDIRECTORY(muxerMp4v2)
 #ADD_SUBDIRECTORY(muxerMplex)



From mean at mail.berlios.de  Sun Jan 16 09:20:37 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 16 Jan 2011 09:20:37 +0100
Subject: [Avidemux-svn-commit] r6925 -
	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog
Message-ID: <20110116082037.48401481254@sheep.berlios.de>

Author: mean
Date: 2011-01-16 09:20:36 +0100 (Sun, 16 Jan 2011)
New Revision: 6925

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_calculator.cpp
Log:
[gtk] Fix build

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_calculator.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_calculator.cpp	2011-01-10 18:52:51 UTC (rev 6924)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_calculator.cpp	2011-01-16 08:20:36 UTC (rev 6925)
@@ -26,6 +26,7 @@
 
 #include "ADM_vidMisc.h"
 #include "avi_vars.h"
+#include "prototype.h"
 
 void DIA_Calculator(uint32_t *sizeInMeg, uint32_t *avgBitrate );
 static GtkWidget	*create_Calculator (void);



From mean at mail.berlios.de  Sun Jan 16 09:20:38 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 16 Jan 2011 09:20:38 +0100
Subject: [Avidemux-svn-commit] r6926 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:
	. muxerMp4v2 muxerMp4v2/libmp4v2
Message-ID: <20110116082038.5EAA2481254@sheep.berlios.de>

Author: mean
Date: 2011-01-16 09:20:38 +0100 (Sun, 16 Jan 2011)
New Revision: 6926

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/CMakeLists.txt
Log:
[mp4v2] Add platform specific files

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2011-01-16 08:20:36 UTC (rev 6925)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2011-01-16 08:20:38 UTC (rev 6926)
@@ -6,5 +6,5 @@
 ADD_SUBDIRECTORY(muxerMkv)
 ADD_SUBDIRECTORY(muxerffPS)
 ADD_SUBDIRECTORY(muxerffTS)
-#ADD_SUBDIRECTORY(muxerMp4v2)
+ADD_SUBDIRECTORY(muxerMp4v2)
 #ADD_SUBDIRECTORY(muxerMplex)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt	2011-01-16 08:20:36 UTC (rev 6925)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt	2011-01-16 08:20:38 UTC (rev 6926)
@@ -8,5 +8,6 @@
 ADD_LIBRARY(ADM_mx_mp4v2 SHARED ${ADM_mp4v2_SRCS})
 TARGET_LINK_LIBRARIES(ADM_mx_mp4v2 ADM_libmp4v2)
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR})
+INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/libmp4v2/include/)
 INIT_MUXER(ADM_mx_mp4v2)
 INSTALL_MUXER(ADM_mx_mp4v2)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/CMakeLists.txt	2011-01-16 08:20:36 UTC (rev 6925)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/CMakeLists.txt	2011-01-16 08:20:38 UTC (rev 6926)
@@ -86,8 +86,37 @@
 	./src/qtff/PictureAspectRatioBox.cpp
 	./src/rtphint.cpp
 	./src/text.cpp	)
+# Platform files
+if(WIN32)
+	SET(PLATFORM
+		libplatform/io/File_win32.cpp
+		libplatform/io/FileSystem_win32.cpp
+		libplatform/number/random_win32.cpp
+		libplatform/process/process_win32.cpp
+		libplatform/time/time_win32.cpp
+	
+ 	)
+else(WIN32)
+		SET(PLATFORM
+			libplatform/io/File_posix.cpp
+			libplatform/io/FileSystem_posix.cpp
+			libplatform/number/random_posix.cpp
+			libplatform/process/process_posix.cpp
+			libplatform/time/time_posix.cpp
+	
+ 		)
+endif(WIN32)
 
-ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+SET(PLATFORM ${PLATFORM}
+	libplatform/io/File.cpp
+	libplatform/io/FileSystem.cpp
+	libplatform/prog/option.cpp
+	libplatform/sys/error.cpp
+	libplatform/time/time.cpp
+)
+
+
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS} ${PLATFORM})
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR})
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/include)
 



From mean at mail.berlios.de  Sun Jan 16 09:20:39 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 16 Jan 2011 09:20:39 +0100
Subject: [Avidemux-svn-commit] r6927 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110116082039.7CCEC481254@sheep.berlios.de>

Author: mean
Date: 2011-01-16 09:20:39 +0100 (Sun, 16 Jan 2011)
New Revision: 6927

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
Log:
[mp4v2] Add plugin skeleton

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-16 08:20:39 UTC (rev 6927)
@@ -0,0 +1,124 @@
+/**********************************************************************
+            \file            muxerMp4v2
+            \brief           libmp4v2 muxer
+                             -------------------
+    
+    copyright            : (C) 2011 by mean
+    email                : fixounet at free.fr
+    Strongly inspired by handbrake code
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "muxerMp4v2.h"
+#include "ADM_codecType.h"
+#if 1
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+
+
+
+/**
+    \fn     muxerMp4v2
+    \brief  Constructor
+*/
+muxerMp4v2::muxerMp4v2()
+{
+        handle=NULL;
+};
+/**
+    \fn     muxerMp4v2
+    \brief  Destructor
+*/
+
+muxerMp4v2::~muxerMp4v2()
+{
+    printf("[Mp4v2Muxer] Destructing\n");
+    if(handle)
+        ADM_error("MP4V2: File still opened\n");
+}
+
+/**
+    \fn open
+    \brief Check that the streams are ok, initialize context...
+*/
+
+bool muxerMp4v2::open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a)
+{
+
+//        audioDelay=s->getVideoDelay();
+        vStream=s;
+        nbAStreams=nbAudioTrack;
+        aStreams=a;
+// Verify everything is ok : Accept Mp4 & H264 for video, AAC for audio
+        uint32_t fcc=vStream->getFCC();
+        if(!isH264Compatible(fcc) && !isMpeg4Compatible(fcc))
+        {
+            ADM_error("[mp4v2] Only h264 and mp4 video track!\n");
+            return false;
+        }
+        for(int i=0;i<nbAStreams;i++)
+        {
+            if(aStreams[i]->getInfo()->encoding!=WAV_AAC)
+            {
+                ADM_error("[mp4v2] Only AAC audio!\n");
+                return false;
+            }
+        }
+        // Create file
+        handle=MP4Create( file, MP4_DETAILS_ERROR, 0 ); // FIXME MP4_CREATE_64BIT_DATA
+        if(MP4_INVALID_FILE_HANDLE==handle)
+        {
+            ADM_error("[mp4v2]Cannot create output file %s\n",file);
+            return false;
+        }
+        if (!(MP4SetTimeScale( handle, 1000*1000 ))) // Us, optimize
+        {
+            ADM_error("[mp4v2]Cannot set timescale to us\n");
+            return false;
+        }
+        
+        return true;
+}
+
+/**
+    \fn save
+*/
+bool muxerMp4v2::save(void)
+{
+    bool result=true;
+    printf("[Mp4v2Muxer] Saving\n");
+    
+    return result;
+}
+/**
+    \fn close
+    \brief Cleanup is done in the dtor
+*/
+bool muxerMp4v2::close(void)
+{
+    if(handle)
+    {
+            MP4Close(handle);
+#warning run MP4Optimize
+    }
+    handle=NULL;
+    ADM_info("[Mp4v2Muxer] Closing\n");
+    return true;
+}
+//EOF
+
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-16 08:20:39 UTC (rev 6927)
@@ -0,0 +1,37 @@
+/***************************************************************************
+    \file muxerMp4v2.h
+    \brief muxer using libmp4v2
+    \author mean fixounet at free.fr 
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_MUXER_MP4V2
+#define ADM_MUXER_MP4V2
+
+#include "ADM_muxer.h"
+#include "ADM_audioClock.h"
+#include "mp4v2/mp4v2.h"
+/**
+    \class muxerMp4v2
+*/
+class muxerMp4v2 : public ADM_muxer
+{
+protected:
+        MP4FileHandle   handle;
+public:
+                muxerMp4v2();
+        virtual ~muxerMp4v2();
+        virtual bool open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a);
+        virtual bool save(void) ;
+        virtual bool close(void) ;
+
+};
+
+#endif



From mean at mail.berlios.de  Sun Jan 16 09:20:40 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 16 Jan 2011 09:20:40 +0100
Subject: [Avidemux-svn-commit] r6928 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110116082040.9982E481254@sheep.berlios.de>

Author: mean
Date: 2011-01-16 09:20:40 +0100 (Sun, 16 Jan 2011)
New Revision: 6928

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
Log:
[mp4v2] Partial handling of audio

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt	2011-01-16 08:20:39 UTC (rev 6927)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt	2011-01-16 08:20:40 UTC (rev 6928)
@@ -2,6 +2,8 @@
 SET(ADM_mp4v2_SRCS
 	muxerMp4v2Plugin.cpp
 	muxerMp4v2.cpp
+	muxerMp4v2Audio.cpp
+	muxerMp4v2Video.cpp
 )
 SUBDIRS(libmp4v2)
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-16 08:20:39 UTC (rev 6927)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-16 08:20:40 UTC (rev 6928)
@@ -22,21 +22,34 @@
 #include "fourcc.h"
 #include "muxerMp4v2.h"
 #include "ADM_codecType.h"
+#include "ADM_imageFlags.h"
 #if 1
 #define aprintf(...) {}
 #else
 #define aprintf printf
 #endif
 
+/**
+    \fn timeScale
+    \brief convert our unit (us) to mp4v2 unit (90khz tick)
+*/
+uint64_t muxerMp4v2::timeScale(uint64_t timeUs)
+{
+    return (uint64_t)(timeUs/90000LL);
 
-
+}
 /**
     \fn     muxerMp4v2
     \brief  Constructor
 */
 muxerMp4v2::muxerMp4v2()
 {
+        ADM_info("[Mp4v2Muxer] Creating\n");
         handle=NULL;
+        audioTrackIds=NULL;
+        videoBuffer[0]=NULL;
+        videoBuffer[1]=NULL;
+        nextWrite=0;
 };
 /**
     \fn     muxerMp4v2
@@ -45,11 +58,11 @@
 
 muxerMp4v2::~muxerMp4v2()
 {
-    printf("[Mp4v2Muxer] Destructing\n");
+    ADM_info("[Mp4v2Muxer] Destroying\n");
+    close();
     if(handle)
         ADM_error("MP4V2: File still opened\n");
 }
-
 /**
     \fn open
     \brief Check that the streams are ok, initialize context...
@@ -62,7 +75,15 @@
         vStream=s;
         nbAStreams=nbAudioTrack;
         aStreams=a;
-// Verify everything is ok : Accept Mp4 & H264 for video, AAC for audio
+        videoBufferSize=vStream->getWidth()*vStream->getHeight()*3;
+        videoBuffer[0]=new uint8_t[videoBufferSize];
+        videoBuffer[1]=new uint8_t[videoBufferSize];
+        in[0].bufferSize=videoBufferSize;
+        in[0].data=videoBuffer[0];
+        in[1].bufferSize=videoBufferSize;
+        in[1].data=videoBuffer[1];
+        audioTrackIds=new MP4TrackId[nbAStreams];
+//------Verify everything is ok : Accept Mp4 & H264 for video, AAC for audio ----
         uint32_t fcc=vStream->getFCC();
         if(!isH264Compatible(fcc) && !isMpeg4Compatible(fcc))
         {
@@ -71,12 +92,15 @@
         }
         for(int i=0;i<nbAStreams;i++)
         {
-            if(aStreams[i]->getInfo()->encoding!=WAV_AAC)
+            if(0) //if(aStreams[i]->getInfo()->encoding!=WAV_AAC)
             {
                 ADM_error("[mp4v2] Only AAC audio!\n");
                 return false;
             }
+            
         }
+//------Verify everything is ok : Accept Mp4 & H264 for video, AAC for audio ----
+        
         // Create file
         handle=MP4Create( file, MP4_DETAILS_ERROR, 0 ); // FIXME MP4_CREATE_64BIT_DATA
         if(MP4_INVALID_FILE_HANDLE==handle)
@@ -84,13 +108,25 @@
             ADM_error("[mp4v2]Cannot create output file %s\n",file);
             return false;
         }
-        if (!(MP4SetTimeScale( handle, 1000*1000 ))) // Us, optimize
+        if (!(MP4SetTimeScale( handle, 90*1000 ))) // 90 kHz tick
         {
             ADM_error("[mp4v2]Cannot set timescale to us\n");
             return false;
         }
-        
+        if(false==initAudio())
+        {
+            ADM_error("Cannot init audio\n");
+            return false;
+        }
+        if(false==initVideo())
+        {
+            ADM_error("Cannot init video\n");
+            return false;
+        }
+
         return true;
+er:
+        return false;
 }
 
 /**
@@ -100,7 +136,48 @@
 {
     bool result=true;
     printf("[Mp4v2Muxer] Saving\n");
+   
+
+    initUI("Saving MP4V2");
+    encoding->setContainer("MP4");
+    uint32_t nbFrame=0;
     
+    while(vStream->getPacket(&(in[nextWrite]))) 
+    {
+        bool kf=false;
+        int other=!nextWrite;
+        if(in[other].flags & AVI_KEY_FRAME) kf=true;
+        uint64_t newDts=in[nextWrite].dts-in[other].dts;
+        uint64_t duration=timeScale(newDts);
+        uint64_t delta=in[other].pts-in[other].dts;
+            delta=timeScale(delta);
+   
+        if(false==MP4WriteSample(handle,videoTrackId,in[other].data,in[other].len,
+                        duration, // duration
+                        delta, // pts/dts offset
+                        kf // Sync Sample
+                        ))
+        {
+            ADM_error("Cannot write video sample\n");
+            result=false;
+            goto theEnd;
+        }
+        
+        //
+        uint64_t nextDts=in[nextWrite].dts;
+        fillAudio(nextDts);
+        // toggle
+        nextWrite=other;
+    }
+    // Write last frame
+    nextWrite=!nextWrite;
+    MP4WriteSample(handle,videoTrackId,in[nextWrite].data,in[nextWrite].len,
+                        90000/100, // duration=10ms
+                        0, // pts/dts offset
+                        0 // Sync Sample
+                        );
+theEnd:
+    close();
     return result;
 }
 /**
@@ -115,6 +192,13 @@
 #warning run MP4Optimize
     }
     handle=NULL;
+    if(audioTrackIds) delete [] audioTrackIds;
+    audioTrackIds=NULL;
+    for(int i=0;i<2;i++)
+    {
+        if(videoBuffer[i]) delete [] videoBuffer[i];
+        videoBuffer[i]=NULL;
+    }
     ADM_info("[Mp4v2Muxer] Closing\n");
     return true;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-16 08:20:39 UTC (rev 6927)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-16 08:20:40 UTC (rev 6928)
@@ -25,6 +25,19 @@
 {
 protected:
         MP4FileHandle   handle;
+        MP4TrackId      videoTrackId;
+        MP4TrackId      *audioTrackIds;
+        uint32_t        videoBufferSize;
+        uint8_t         *videoBuffer[2];
+        ADMBitstream    in[2];
+        int             nextWrite;
+protected:
+        bool            setMpeg4Esds(void);
+        bool            initVideo(void);
+        bool            initAudio(void);
+        bool            fillAudio(uint64_t targetDts);
+static  uint64_t        timeScale(uint64_t timeUs);
+
 public:
                 muxerMp4v2();
         virtual ~muxerMp4v2();

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-16 08:20:40 UTC (rev 6928)
@@ -0,0 +1,111 @@
+/**********************************************************************
+            \file            muxerMp4v2
+            \brief           libmp4v2 muxer
+                             -------------------
+    
+    copyright            : (C) 2011 by mean
+    email                : fixounet at free.fr
+    Strongly inspired by handbrake code
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "muxerMp4v2.h"
+#include "ADM_codecType.h"
+#include "ADM_imageFlags.h"
+#if 1
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+
+
+/**
+    \fn initAudio
+*/
+bool muxerMp4v2::initAudio(void)
+{
+    for(int i=0;i<nbAStreams;i++)
+    {
+        WAVHeader *header=aStreams[i]->getInfo();
+        switch(header->encoding)
+        {
+            case WAV_MP2:
+            case WAV_MP3:
+                    #warning fixme : Not always 1152 sample per packet
+                    audioTrackIds[i]=MP4AddAudioTrack(handle,header->frequency,1152,MP4_MPEG2_AUDIO_TYPE);
+                    if(MP4_INVALID_TRACK_ID==audioTrackIds[i])
+                    {
+                        ADM_error("Error adding audio track %i of type 0x%x\n",i,header->encoding);
+                        return false;
+                    }
+                    MP4SetAudioProfileLevel(handle,0x0f);
+                    MP4SetTrackIntegerProperty(handle,audioTrackIds[i],"mdia.minf.stbl.stsd.mp4a.channels",
+                                header->channels);
+                    break;
+            default:
+                    ADM_error("Cannot create audio track of type 0x%x\n",header->encoding);
+                    return false;
+        }
+    }
+    if(nbAStreams)
+         MP4SetTrackIntegerProperty(handle, audioTrackIds[0], "tkhd.flags", 3);
+    return true;
+}
+/**
+    \fn fillAudio
+    \brief push audio packets until nextDts is reached
+*/  
+bool muxerMp4v2::fillAudio(uint64_t targetDts)
+{
+    uint8_t buffer[4*1024];
+    uint32_t packetLen;
+    uint32_t nbSample;
+    uint64_t dts;
+    for(int audioIndex=0;audioIndex<nbAStreams;audioIndex++)
+    {
+                ADM_audioStream*a=aStreams[audioIndex];
+                uint32_t fq=a->getInfo()->frequency;
+                int nb=0;
+                while(1)
+                {
+                        if(!a->getPacket(buffer,
+                                         &(packetLen),
+                                         4096,
+                                         &(nbSample),
+                                         &(dts)))
+                        {
+                                ADM_warning("Cannot get audio packet for stream %d\n",audioIndex);
+                                break;
+                        }
+                        float duration=nbSample;
+                        duration/=fq;
+                        duration*=90000;
+                        if(!MP4WriteSample(handle,audioTrackIds[audioIndex],buffer,packetLen,
+                                                            timeScale((uint64_t )duration),
+                                                            0,1))
+                        {
+                            ADM_error("Cannot write audio sample for track %d\n",audioIndex);
+                            return false;
+                        }
+                    // We now have a packet stored
+                    if(dts!=ADM_NO_PTS)
+                        if(dts>targetDts) break; // this one is in the future
+                }
+    }
+    return true;
+}
+//EOF
+
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-16 08:20:40 UTC (rev 6928)
@@ -0,0 +1,121 @@
+/**********************************************************************
+            \file            muxerMp4v2
+            \brief           libmp4v2 muxer
+                             -------------------
+    
+    copyright            : (C) 2011 by mean
+    email                : fixounet at free.fr
+    Strongly inspired by handbrake code
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "muxerMp4v2.h"
+#include "ADM_codecType.h"
+#include "ADM_imageFlags.h"
+#if 1
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+
+/**
+    \fn setEsdsAtom
+    \brief extract esds atom from extradata or for first frame. In all cases read the first frame
+*/
+bool muxerMp4v2::setMpeg4Esds(void)
+{
+    ADM_info("Setting mpeg4 (a)SP ESDS...\n");
+    if(0) //false==vStream->getPacket(&in) )
+     {
+        ADM_error("Cannot read first frame\n");
+        return false;
+     }
+     uint8_t *esdsData=NULL;
+     uint32_t esdsLen=0;
+        if(false==vStream->getExtraData(&esdsLen,&esdsData))
+        {
+            ADM_info("No extradata, geting ESDS from first frame...");
+        }else
+        {
+            ADM_info("Got esds from extradata\n");
+        }
+        if(!esdsLen)
+        {
+            ADM_error("ESDS not found, aborting\n");
+            return false;
+        }
+        ADM_info("Esds:\n"); mixDump(esdsData,esdsLen);ADM_info("\n");            
+        if(false==MP4SetTrackESConfiguration(handle,videoTrackId,esdsData,esdsLen))
+        {
+            ADM_error("SetTracEsConfiguration failed\n");
+            return false;
+        }
+        ADM_info("ESDS atom set\n");
+        return true;
+}
+/**
+    \fn initVideo
+*/
+bool muxerMp4v2::initVideo(void)
+{
+        uint32_t fcc=vStream->getFCC();
+
+        if(false==vStream->getPacket(&(in[0])))
+        {
+            ADM_error("Cannot read 1st video frame\n");
+            return false;
+        }
+        nextWrite=1;
+        ADM_info("Setting video..\n");
+        if(isMpeg4Compatible(fcc))
+        {
+            videoTrackId=MP4AddVideoTrack(handle,90000,MP4_INVALID_DURATION,
+                    vStream->getWidth(),vStream->getHeight(),MP4_MPEG4_VIDEO_TYPE);
+            if(MP4_INVALID_TRACK_ID==videoTrackId)
+            {
+                ADM_error("Cannot add mpeg4 video Track \n");
+                return false;
+            }
+            if(false==setMpeg4Esds())
+            {
+                ADM_error("Cannot set ESDS atom\n");
+                return false;
+            }
+        }
+        if(isH264Compatible(fcc))
+        {
+#if 0
+            // Extract sps & pps
+            uint8_t *sps,*pps;
+            //
+            videoTrackId=MP4AddH264VideoTrack(handle,90000,MP4_INVALID_DURATION,
+                    vStream->getWidth(),vStream->getHeight(),sps[0],sps[1],sps[2],3);
+            if(MP4_INVALID_TRACK_ID==videoTrackId)
+            {
+                ADM_error("Cannot add h264 video Track \n");
+                goto er;
+            }
+            if(false==MP4SetTrackESConfiguration(handle,videoTrackId,esdsData,esdsLen))
+            {
+                ADM_error("SetTracEsConfiguration failed\n");
+                return false;
+            }
+#endif
+        }
+        return true;
+}
+//EOF
+
+
+



From mean at mail.berlios.de  Sun Jan 16 09:20:41 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 16 Jan 2011 09:20:41 +0100
Subject: [Avidemux-svn-commit] r6929 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110116082041.C0748481254@sheep.berlios.de>

Author: mean
Date: 2011-01-16 09:20:41 +0100 (Sun, 16 Jan 2011)
New Revision: 6929

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
Log:
[mp4v2] Write audio, incomplete, only supports mp3

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-16 08:20:40 UTC (rev 6928)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-16 08:20:41 UTC (rev 6929)
@@ -23,10 +23,13 @@
 #include "muxerMp4v2.h"
 #include "ADM_codecType.h"
 #include "ADM_imageFlags.h"
-#if 1
+
+#if 0
 #define aprintf(...) {}
+#define MP4_DEBUG 0
 #else
 #define aprintf printf
+#define MP4_DEBUG MP4_DETAILS_ALL
 #endif
 
 /**
@@ -35,7 +38,7 @@
 */
 uint64_t muxerMp4v2::timeScale(uint64_t timeUs)
 {
-    return (uint64_t)(timeUs/90000LL);
+    return (uint64_t)((timeUs*90LL)/1000LL);
 
 }
 /**
@@ -83,6 +86,7 @@
         in[1].bufferSize=videoBufferSize;
         in[1].data=videoBuffer[1];
         audioTrackIds=new MP4TrackId[nbAStreams];
+        audioPackets=new mp4v2AudioPacket[nbAStreams];
 //------Verify everything is ok : Accept Mp4 & H264 for video, AAC for audio ----
         uint32_t fcc=vStream->getFCC();
         if(!isH264Compatible(fcc) && !isMpeg4Compatible(fcc))
@@ -108,6 +112,7 @@
             ADM_error("[mp4v2]Cannot create output file %s\n",file);
             return false;
         }
+        MP4SetVerbosity(handle,MP4_DEBUG);
         if (!(MP4SetTimeScale( handle, 90*1000 ))) // 90 kHz tick
         {
             ADM_error("[mp4v2]Cannot set timescale to us\n");
@@ -194,6 +199,8 @@
     handle=NULL;
     if(audioTrackIds) delete [] audioTrackIds;
     audioTrackIds=NULL;
+    if(audioPackets) delete [] audioPackets;
+    audioPackets=NULL;
     for(int i=0;i<2;i++)
     {
         if(videoBuffer[i]) delete [] videoBuffer[i];

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-16 08:20:40 UTC (rev 6928)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-16 08:20:41 UTC (rev 6929)
@@ -19,6 +19,32 @@
 #include "ADM_audioClock.h"
 #include "mp4v2/mp4v2.h"
 /**
+    \class mp4v2AudioPacket
+*/
+#define AUDIO_BUFFER_SIZE 16*1024*2
+class mp4v2AudioPacket
+{
+    public:
+         class mp4v2AudioBlock
+         {
+            public:
+                    uint8_t     *buffer;
+                    uint64_t    dts;
+                    uint32_t    nbSamples;
+                    uint32_t    sizeInBytes;
+                    bool        present;
+            public:
+                  mp4v2AudioBlock() {buffer=new uint8_t[AUDIO_BUFFER_SIZE];present=false;}
+                  ~mp4v2AudioBlock() {delete [] buffer;buffer=NULL;}
+         };
+            bool                eos;
+            mp4v2AudioBlock     blocks[2];
+            int                 nextWrite;
+            mp4v2AudioPacket() {eos=false;nextWrite=0;}
+            ~mp4v2AudioPacket() {}
+
+};
+/**
     \class muxerMp4v2
 */
 class muxerMp4v2 : public ADM_muxer
@@ -27,6 +53,7 @@
         MP4FileHandle   handle;
         MP4TrackId      videoTrackId;
         MP4TrackId      *audioTrackIds;
+        mp4v2AudioPacket *audioPackets;
         uint32_t        videoBufferSize;
         uint8_t         *videoBuffer[2];
         ADMBitstream    in[2];
@@ -37,6 +64,8 @@
         bool            initAudio(void);
         bool            fillAudio(uint64_t targetDts);
 static  uint64_t        timeScale(uint64_t timeUs);
+        bool            loadAndToggleAudioSlot(int index);
+        bool            writeAudioBlock(int index,mp4v2AudioPacket::mp4v2AudioBlock *block,uint64_t duration90);
 
 public:
                 muxerMp4v2();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-16 08:20:40 UTC (rev 6928)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-16 08:20:41 UTC (rev 6929)
@@ -23,10 +23,12 @@
 #include "muxerMp4v2.h"
 #include "ADM_codecType.h"
 #include "ADM_imageFlags.h"
-#if 1
+#if 0
 #define aprintf(...) {}
+#define MP4_DEBUG 0
 #else
-#define aprintf printf
+#define aprintf ADM_info
+#define MP4_DEBUG MP4_DETAILS_ALL
 #endif
 
 
@@ -35,20 +37,27 @@
 */
 bool muxerMp4v2::initAudio(void)
 {
+    
     for(int i=0;i<nbAStreams;i++)
     {
         WAVHeader *header=aStreams[i]->getInfo();
+        ADM_audioStream*a=aStreams[i];
         switch(header->encoding)
         {
             case WAV_MP2:
             case WAV_MP3:
                     #warning fixme : Not always 1152 sample per packet
-                    audioTrackIds[i]=MP4AddAudioTrack(handle,header->frequency,1152,MP4_MPEG2_AUDIO_TYPE);
+                    
+                    audioTrackIds[i]=MP4AddAudioTrack(handle,
+                                                      header->frequency,
+                                                      1152,
+                                                      MP4_MPEG2_AUDIO_TYPE);
                     if(MP4_INVALID_TRACK_ID==audioTrackIds[i])
                     {
                         ADM_error("Error adding audio track %i of type 0x%x\n",i,header->encoding);
                         return false;
                     }
+                    aprintf("Add Track %d fq %d\n",audioTrackIds[i],header->frequency);
                     MP4SetAudioProfileLevel(handle,0x0f);
                     MP4SetTrackIntegerProperty(handle,audioTrackIds[i],"mdia.minf.stbl.stsd.mp4a.channels",
                                 header->channels);
@@ -57,50 +66,86 @@
                     ADM_error("Cannot create audio track of type 0x%x\n",header->encoding);
                     return false;
         }
+        // Preload this track...
+        loadAndToggleAudioSlot(i); 
     }
     if(nbAStreams)
          MP4SetTrackIntegerProperty(handle, audioTrackIds[0], "tkhd.flags", 3);
     return true;
 }
 /**
+    \fn loadAndToggleAudioSlot
+*/
+bool muxerMp4v2::loadAndToggleAudioSlot(int index)
+{
+        ADM_audioStream                     *a=aStreams[index];
+        mp4v2AudioPacket                    *pkt=&(audioPackets[index]);
+        mp4v2AudioPacket::mp4v2AudioBlock   *blk=&(pkt->blocks[pkt->nextWrite]);
+        if(!a->getPacket(blk->buffer,
+                         &(blk->sizeInBytes),
+                         AUDIO_BUFFER_SIZE,
+                         &(blk->nbSamples),
+                         &(blk->dts)))
+        {
+                ADM_warning("Cannot get audio packet for stream %d\n",index);
+                pkt->eos=true;
+                return false;
+        }
+        blk->present=true;
+        pkt->nextWrite=!pkt->nextWrite;
+        return true;
+}
+/**
+    \fn writeAudioBlock
+*/
+bool muxerMp4v2::writeAudioBlock(int index,mp4v2AudioPacket::mp4v2AudioBlock *block,uint64_t nbSamples)
+{
+    ADM_info("Writting audio block : size=%d, samples=%d nbSamples=%d \n",block->sizeInBytes,block->nbSamples,(int)nbSamples);
+    bool r=MP4WriteSample(handle,audioTrackIds[index],
+                            block->buffer,
+                            block->sizeInBytes,
+                            nbSamples,
+                            0,1);
+    if(false==r)
+                        {
+                            ADM_error("Cannot write audio sample for track %d\n",index);
+                            //return false;
+                        }
+    return true;
+}
+/**
     \fn fillAudio
     \brief push audio packets until nextDts is reached
 */  
 bool muxerMp4v2::fillAudio(uint64_t targetDts)
 {
-    uint8_t buffer[4*1024];
-    uint32_t packetLen;
-    uint32_t nbSample;
-    uint64_t dts;
     for(int audioIndex=0;audioIndex<nbAStreams;audioIndex++)
     {
-                ADM_audioStream*a=aStreams[audioIndex];
-                uint32_t fq=a->getInfo()->frequency;
-                int nb=0;
+                ADM_audioStream         *a=aStreams[audioIndex];
+                uint32_t                fq=a->getInfo()->frequency;
+                mp4v2AudioPacket       *pkt=&(audioPackets[audioIndex]);
+                if(pkt->eos)            continue;
+                
                 while(1)
                 {
-                        if(!a->getPacket(buffer,
-                                         &(packetLen),
-                                         4096,
-                                         &(nbSample),
-                                         &(dts)))
+                        int current=!pkt->nextWrite;
+                        int other=pkt->nextWrite;
+                        mp4v2AudioPacket::mp4v2AudioBlock        *currentBlock=&(pkt->blocks[current]);
+                        mp4v2AudioPacket::mp4v2AudioBlock        *otherBlock=&(pkt->blocks[other]);
+                        if(currentBlock->dts>targetDts) // In the future
+                            break;
+                        if(false==writeAudioBlock(audioIndex,currentBlock,currentBlock->nbSamples))
                         {
-                                ADM_warning("Cannot get audio packet for stream %d\n",audioIndex);
-                                break;
-                        }
-                        float duration=nbSample;
-                        duration/=fq;
-                        duration*=90000;
-                        if(!MP4WriteSample(handle,audioTrackIds[audioIndex],buffer,packetLen,
-                                                            timeScale((uint64_t )duration),
-                                                            0,1))
-                        {
                             ADM_error("Cannot write audio sample for track %d\n",audioIndex);
+                            pkt->eos=true;
                             return false;
                         }
-                    // We now have a packet stored
-                    if(dts!=ADM_NO_PTS)
-                        if(dts>targetDts) break; // this one is in the future
+                        // load next
+                        if(false==loadAndToggleAudioSlot(audioIndex))
+                        {
+                            #warning Purge other slot
+                            pkt->eos=true;
+                        }
                 }
     }
     return true;



From mean at mail.berlios.de  Sun Jan 16 09:20:42 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 16 Jan 2011 09:20:42 +0100
Subject: [Avidemux-svn-commit] r6930 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src
Message-ID: <20110116082042.E4A5F481254@sheep.berlios.de>

Author: mean
Date: 2011-01-16 09:20:42 +0100 (Sun, 16 Jan 2011)
New Revision: 6930

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
Log:
[videoEncoder] Use av_free for lavcodec ones, not ADM_desalloc

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2011-01-16 08:20:41 UTC (rev 6929)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2011-01-16 08:20:42 UTC (rev 6930)
@@ -93,7 +93,7 @@
         }
         if(_context->codec)
         avcodec_close (_context);
-        ADM_dealloc (_context);
+        av_free (_context);
         _context = NULL;
     }
     if(colorSpace)



From mean at mail.berlios.de  Sun Jan 16 09:20:43 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 16 Jan 2011 09:20:43 +0100
Subject: [Avidemux-svn-commit] r6931 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110116082044.0001D481254@sheep.berlios.de>

Author: mean
Date: 2011-01-16 09:20:43 +0100 (Sun, 16 Jan 2011)
New Revision: 6931

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
Log:
[mp4v2] Partial block handling

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-16 08:20:42 UTC (rev 6930)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-16 08:20:43 UTC (rev 6931)
@@ -24,7 +24,7 @@
 #include "ADM_codecType.h"
 #include "ADM_imageFlags.h"
 
-#if 0
+#if 1
 #define aprintf(...) {}
 #define MP4_DEBUG 0
 #else
@@ -74,7 +74,7 @@
 bool muxerMp4v2::open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a)
 {
 
-//        audioDelay=s->getVideoDelay();
+        audioDelay=s->getVideoDelay();
         vStream=s;
         nbAStreams=nbAudioTrack;
         aStreams=a;
@@ -85,8 +85,6 @@
         in[0].data=videoBuffer[0];
         in[1].bufferSize=videoBufferSize;
         in[1].data=videoBuffer[1];
-        audioTrackIds=new MP4TrackId[nbAStreams];
-        audioPackets=new mp4v2AudioPacket[nbAStreams];
 //------Verify everything is ok : Accept Mp4 & H264 for video, AAC for audio ----
         uint32_t fcc=vStream->getFCC();
         if(!isH264Compatible(fcc) && !isMpeg4Compatible(fcc))

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-16 08:20:42 UTC (rev 6930)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-16 08:20:43 UTC (rev 6931)
@@ -22,6 +22,7 @@
     \class mp4v2AudioPacket
 */
 #define AUDIO_BUFFER_SIZE 16*1024*2
+#define MP4V2_MAX_JITTER (40*1000) // 40 ms
 class mp4v2AudioPacket
 {
     public:
@@ -40,8 +41,9 @@
             bool                eos;
             mp4v2AudioBlock     blocks[2];
             int                 nextWrite;
-            mp4v2AudioPacket() {eos=false;nextWrite=0;}
-            ~mp4v2AudioPacket() {}
+            audioClock          *clock;
+            mp4v2AudioPacket() {eos=false;nextWrite=0;clock=NULL;}
+            ~mp4v2AudioPacket() {if(clock) delete clock;clock=NULL;}
 
 };
 /**
@@ -58,6 +60,7 @@
         uint8_t         *videoBuffer[2];
         ADMBitstream    in[2];
         int             nextWrite;
+        uint64_t        audioDelay; // In fact videoDelay, but must be added to all audioTrack
 protected:
         bool            setMpeg4Esds(void);
         bool            initVideo(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-16 08:20:42 UTC (rev 6930)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-16 08:20:43 UTC (rev 6931)
@@ -23,7 +23,7 @@
 #include "muxerMp4v2.h"
 #include "ADM_codecType.h"
 #include "ADM_imageFlags.h"
-#if 0
+#if 1
 #define aprintf(...) {}
 #define MP4_DEBUG 0
 #else
@@ -31,26 +31,36 @@
 #define MP4_DEBUG MP4_DETAILS_ALL
 #endif
 
+#warning add audioDelay
+#warning fix audio not starting at 0
 
 /**
     \fn initAudio
 */
 bool muxerMp4v2::initAudio(void)
 {
+    audioTrackIds=new MP4TrackId[nbAStreams];
+    audioPackets=new mp4v2AudioPacket[nbAStreams];
     
     for(int i=0;i<nbAStreams;i++)
     {
         WAVHeader *header=aStreams[i]->getInfo();
         ADM_audioStream*a=aStreams[i];
+        audioPackets[i].clock=new audioClock(header->frequency);
+        // Preload this track...
+        if(false==loadAndToggleAudioSlot(i))
+        {
+            audioPackets[i].eos=true;
+            continue;
+        }
+        
         switch(header->encoding)
         {
             case WAV_MP2:
             case WAV_MP3:
-                    #warning fixme : Not always 1152 sample per packet
-                    
                     audioTrackIds[i]=MP4AddAudioTrack(handle,
                                                       header->frequency,
-                                                      1152,
+                                                      audioPackets[i].blocks[0].nbSamples,
                                                       MP4_MPEG2_AUDIO_TYPE);
                     if(MP4_INVALID_TRACK_ID==audioTrackIds[i])
                     {
@@ -66,8 +76,7 @@
                     ADM_error("Cannot create audio track of type 0x%x\n",header->encoding);
                     return false;
         }
-        // Preload this track...
-        loadAndToggleAudioSlot(i); 
+       
     }
     if(nbAStreams)
          MP4SetTrackIntegerProperty(handle, audioTrackIds[0], "tkhd.flags", 3);
@@ -91,6 +100,8 @@
                 pkt->eos=true;
                 return false;
         }
+        if(blk->dts!=ADM_NO_PTS)
+            blk->dts+=audioDelay;
         blk->present=true;
         pkt->nextWrite=!pkt->nextWrite;
         return true;
@@ -100,7 +111,7 @@
 */
 bool muxerMp4v2::writeAudioBlock(int index,mp4v2AudioPacket::mp4v2AudioBlock *block,uint64_t nbSamples)
 {
-    ADM_info("Writting audio block : size=%d, samples=%d nbSamples=%d \n",block->sizeInBytes,block->nbSamples,(int)nbSamples);
+    aprintf("Writting audio block : size=%d, samples=%d nbSamples=%d \n",block->sizeInBytes,block->nbSamples,(int)nbSamples);
     bool r=MP4WriteSample(handle,audioTrackIds[index],
                             block->buffer,
                             block->sizeInBytes,
@@ -109,7 +120,7 @@
     if(false==r)
                         {
                             ADM_error("Cannot write audio sample for track %d\n",index);
-                            //return false;
+                            return false;
                         }
     return true;
 }
@@ -124,23 +135,52 @@
                 ADM_audioStream         *a=aStreams[audioIndex];
                 uint32_t                fq=a->getInfo()->frequency;
                 mp4v2AudioPacket       *pkt=&(audioPackets[audioIndex]);
+                audioClock             *clock=pkt->clock;
                 if(pkt->eos)            continue;
-                
+                uint64_t                extraSamples=0;
                 while(1)
                 {
                         int current=!pkt->nextWrite;
                         int other=pkt->nextWrite;
                         mp4v2AudioPacket::mp4v2AudioBlock        *currentBlock=&(pkt->blocks[current]);
                         mp4v2AudioPacket::mp4v2AudioBlock        *otherBlock=&(pkt->blocks[other]);
-                        if(currentBlock->dts>targetDts) // In the future
+                        // Get our currentDts
+                        uint64_t currentDts=clock->getTimeUs();                        
+                        uint64_t blockDts=currentBlock->dts;
+                        extraSamples=0;
+                        // Take either block Dts or our own if no DTS is provided
+                        if(currentBlock->dts!=ADM_NO_PTS)
+                        {
+                            if( abs(currentBlock->dts-currentDts)>MP4V2_MAX_JITTER)
+                            {
+                                if(currentBlock->dts<currentDts)
+                                    {
+                                            ADM_warning("Audio going back in time audio track %d\n",audioIndex);
+                                            ADM_warning("expected %d ms, got %d ms",currentDts/1000,currentBlock->dts/1000);
+                                            ADM_warning("Dropping packet\n");
+                                            goto nextOne;
+                                    }
+                                // We have a hole, increase duration of current packet
+                                double holeDurationUs=currentBlock->dts-currentDts;
+                                ADM_warning("Hole detected in audio of %d ms, track %d\n",(int)(holeDurationUs/1000),audioIndex);
+                                holeDurationUs*=fq;
+                                holeDurationUs/=1000*1000;
+                                ADM_warning("Increasing hole duration by %d samples\n",(int)holeDurationUs);
+                                extraSamples=(uint64_t)holeDurationUs;
+                            }
+                        }else       
+                            blockDts=currentDts;
+                        if(blockDts>targetDts) // In the future
                             break;
-                        if(false==writeAudioBlock(audioIndex,currentBlock,currentBlock->nbSamples))
+                        if(false==writeAudioBlock(audioIndex,currentBlock,currentBlock->nbSamples+extraSamples))
                         {
                             ADM_error("Cannot write audio sample for track %d\n",audioIndex);
                             pkt->eos=true;
                             return false;
                         }
                         // load next
+nextOne:
+                        clock->advanceBySample(currentBlock->nbSamples+extraSamples);
                         if(false==loadAndToggleAudioSlot(audioIndex))
                         {
                             #warning Purge other slot



From mean at mail.berlios.de  Sun Jan 16 15:48:19 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 16 Jan 2011 15:48:19 +0100
Subject: [Avidemux-svn-commit] r6932 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/include/mp4v2
Message-ID: <20110116144819.45B76481254@sheep.berlios.de>

Author: mean
Date: 2011-01-16 15:48:19 +0100 (Sun, 16 Jan 2011)
New Revision: 6932

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/include/mp4v2/platform.h
Log:
[libmp4v2] apply P00-mingw-dllimport.patch

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/include/mp4v2/platform.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/include/mp4v2/platform.h	2011-01-16 08:20:43 UTC (rev 6931)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/libmp4v2/include/mp4v2/platform.h	2011-01-16 14:48:19 UTC (rev 6932)
@@ -24,7 +24,7 @@
 #if defined( _WIN32 ) || defined( __MINGW32__ )
 #   if defined( _WINDLL ) || defined( DLL_EXPORT )
 #       define MP4V2_EXPORT __declspec(dllexport)
-#   elif defined( _DLL ) || defined( DLL_IMPORT ) 
+#   elif defined( DLL_IMPORT ) 
 #       define MP4V2_EXPORT __declspec(dllimport)
 #   else
 #       define MP4V2_EXPORT



From mean at mail.berlios.de  Sun Jan 16 15:48:20 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 16 Jan 2011 15:48:20 +0100
Subject: [Avidemux-svn-commit] r6933 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110116144820.61230481254@sheep.berlios.de>

Author: mean
Date: 2011-01-16 15:48:20 +0100 (Sun, 16 Jan 2011)
New Revision: 6933

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
Log:
[mp4v2Muxer] Add AC3 (incomplete)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-16 14:48:19 UTC (rev 6932)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-16 14:48:20 UTC (rev 6933)
@@ -56,6 +56,68 @@
         
         switch(header->encoding)
         {
+            case WAV_AC3:
+                {
+                    int fscod=0;
+                    switch(header->frequency)
+                    {
+                            case 48000: fscod=0;break;
+                            case 44100: fscod=1;break;
+                            case 32000: fscod=2;break;
+                            default: 
+                                {
+                                GUI_Error_HIG("", "invalid frequency for AC3. Only 32, 44.1 & 48 kHz");
+                                return false;
+                                }
+                    }
+                    int bitrate;
+                    static const uint16_t ac3_bitrate_tab[19] = { // From handbrake
+                                 32, 40, 48, 56, 64, 80, 96, 112, 128,
+                                 160, 192, 224, 256, 320, 384, 448, 512, 576, 640
+                             };
+                    int Ceil=sizeof(ac3_bitrate_tab)/sizeof(const uint16_t);
+                    bitrate=-1;
+                    for(int ix=0;ix<Ceil;ix++)
+                            if(header->byterate==(ac3_bitrate_tab[ix]*1000)/8)
+                            {
+                                bitrate=ix;
+                                break;
+                            }
+                    if(-1==bitrate) 
+                    {
+                        GUI_Error_HIG("","Invalid bitrate for AC3");
+                        return false;
+                    }
+                    int acmod,lfe=0;
+                    switch(header->channels)
+                    {
+                            case 1: acmod=1;break;
+                            case 2: acmod=2;break;
+                            case 5: acmod=7;lfe=0;break; 
+#warning Check!
+                            case 6: acmod=7;lfe=1;break;
+                            default: 
+                                    {
+                                              GUI_Error_HIG("","Invalid number of channel for AC3");
+                                              return false;
+                                    }
+                    }
+                    audioTrackIds[i]=MP4AddAC3AudioTrack(handle,
+                                                          header->frequency,// samplingRate,
+                                                           fscod,           // fscod
+                                                           8,               // bsid,
+                                                           0,               // bsmod,
+                                                           acmod,           // acmod
+                                                           lfe,             // lfeon
+                                                           bitrate);        // bit_rate_code 
+                    if(MP4_INVALID_TRACK_ID==audioTrackIds[i])
+                    {
+                        ADM_error("Error adding audio track %i of type 0x%x\n",i,header->encoding);
+                        return false;
+                    }
+                    aprintf("Add Track %d fq %d (AC3)\n",audioTrackIds[i],header->frequency);
+                    }
+                    break;
             case WAV_MP2:
             case WAV_MP3:
                     audioTrackIds[i]=MP4AddAudioTrack(handle,



From mean at mail.berlios.de  Mon Jan 17 08:43:18 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 17 Jan 2011 08:43:18 +0100
Subject: [Avidemux-svn-commit] r6934 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110117074318.8FB9C48128D@sheep.berlios.de>

Author: mean
Date: 2011-01-17 08:43:18 +0100 (Mon, 17 Jan 2011)
New Revision: 6934

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
Log:
[mp4v2] Add AAC

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-16 14:48:20 UTC (rev 6933)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-17 07:43:18 UTC (rev 6934)
@@ -69,7 +69,8 @@
 static  uint64_t        timeScale(uint64_t timeUs);
         bool            loadAndToggleAudioSlot(int index);
         bool            writeAudioBlock(int index,mp4v2AudioPacket::mp4v2AudioBlock *block,uint64_t duration90);
-
+protected:
+        bool            addAc3(int index, WAVHeader *header);
 public:
                 muxerMp4v2();
         virtual ~muxerMp4v2();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-16 14:48:20 UTC (rev 6933)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-17 07:43:18 UTC (rev 6934)
@@ -33,8 +33,73 @@
 
 #warning add audioDelay
 #warning fix audio not starting at 0
-
 /**
+    \fn addAC3
+    \brief Setup AC3 audio track
+*/
+bool muxerMp4v2::addAc3(int index, WAVHeader *header)
+{
+        int fscod=0;
+        switch(header->frequency)
+        {
+                case 48000: fscod=0;break;
+                case 44100: fscod=1;break;
+                case 32000: fscod=2;break;
+                default: 
+                    {
+                    GUI_Error_HIG("", "invalid frequency for AC3. Only 32, 44.1 & 48 kHz");
+                    return false;
+                    }
+        }
+        int bitrate;
+        static const uint16_t ac3_bitrate_tab[19] = { // From handbrake
+                     32, 40, 48, 56, 64, 80, 96, 112, 128,
+                     160, 192, 224, 256, 320, 384, 448, 512, 576, 640
+                 };
+        int Ceil=sizeof(ac3_bitrate_tab)/sizeof(const uint16_t);
+        bitrate=-1;
+        for(int ix=0;ix<Ceil;ix++)
+                if(header->byterate==(ac3_bitrate_tab[ix]*1000)/8)
+                {
+                    bitrate=ix;
+                    break;
+                }
+        if(-1==bitrate) 
+        {
+            GUI_Error_HIG("","Invalid bitrate for AC3");
+            return false;
+        }
+        int acmod,lfe=0;
+        switch(header->channels)
+        {
+                case 1: acmod=1;break;
+                case 2: acmod=2;break;
+                case 5: acmod=7;lfe=0;break; 
+#warning Check!
+                case 6: acmod=7;lfe=1;break;
+                default: 
+                        {
+                                  GUI_Error_HIG("","Invalid number of channel for AC3");
+                                  return false;
+                        }
+        }
+        audioTrackIds[index]=MP4AddAC3AudioTrack(handle,
+                                              header->frequency,// samplingRate,
+                                               fscod,           // fscod
+                                               8,               // bsid,
+                                               0,               // bsmod,
+                                               acmod,           // acmod
+                                               lfe,             // lfeon
+                                               bitrate);        // bit_rate_code 
+        if(MP4_INVALID_TRACK_ID==audioTrackIds[index])
+        {
+            ADM_error("Error adding audio track %i of type 0x%x\n",index,header->encoding);
+            return false;
+        }
+        aprintf("Add Track %d fq %d (AC3)\n",audioTrackIds[i],header->frequency);
+        return true;
+}
+/**
     \fn initAudio
 */
 bool muxerMp4v2::initAudio(void)
@@ -56,67 +121,36 @@
         
         switch(header->encoding)
         {
-            case WAV_AC3:
-                {
-                    int fscod=0;
-                    switch(header->frequency)
+            case WAV_AAC:
                     {
-                            case 48000: fscod=0;break;
-                            case 44100: fscod=1;break;
-                            case 32000: fscod=2;break;
-                            default: 
-                                {
-                                GUI_Error_HIG("", "invalid frequency for AC3. Only 32, 44.1 & 48 kHz");
-                                return false;
-                                }
-                    }
-                    int bitrate;
-                    static const uint16_t ac3_bitrate_tab[19] = { // From handbrake
-                                 32, 40, 48, 56, 64, 80, 96, 112, 128,
-                                 160, 192, 224, 256, 320, 384, 448, 512, 576, 640
-                             };
-                    int Ceil=sizeof(ac3_bitrate_tab)/sizeof(const uint16_t);
-                    bitrate=-1;
-                    for(int ix=0;ix<Ceil;ix++)
-                            if(header->byterate==(ac3_bitrate_tab[ix]*1000)/8)
+                        uint8_t *extraData=NULL;
+                        uint32_t extraDataLen=0;
+                        if(!a->getExtraData(&extraDataLen,&extraData))
                             {
-                                bitrate=ix;
-                                break;
+                                 GUI_Error_HIG("AAC","Cannot get AAC Extra data\n");
+                                 return false;
                             }
-                    if(-1==bitrate) 
-                    {
-                        GUI_Error_HIG("","Invalid bitrate for AC3");
-                        return false;
+                        audioTrackIds[i]=MP4AddAudioTrack(handle,
+                                                      header->frequency,
+                                                      1024,
+                                                      MP4_MPEG4_AUDIO_TYPE);
+                        if(MP4_INVALID_TRACK_ID==audioTrackIds[i])
+                        {
+                            ADM_error("Error adding audio track %i of type 0x%x\n",i,header->encoding);
+                            return false;
+                        }
+                        aprintf("Add Track %d fq %d\n",audioTrackIds[i],header->frequency);
+                        MP4SetAudioProfileLevel(handle,0x0f);
+                        MP4SetTrackIntegerProperty(handle,audioTrackIds[i],"mdia.minf.stbl.stsd.mp4a.channels",
+                                    header->channels);
+                        MP4SetTrackESConfiguration(handle,audioTrackIds[i],extraData,extraDataLen);
+                    break;
                     }
-                    int acmod,lfe=0;
-                    switch(header->channels)
+            case WAV_AC3:
+                    if(false==addAc3(i, header))
                     {
-                            case 1: acmod=1;break;
-                            case 2: acmod=2;break;
-                            case 5: acmod=7;lfe=0;break; 
-#warning Check!
-                            case 6: acmod=7;lfe=1;break;
-                            default: 
-                                    {
-                                              GUI_Error_HIG("","Invalid number of channel for AC3");
-                                              return false;
-                                    }
+                            return false;
                     }
-                    audioTrackIds[i]=MP4AddAC3AudioTrack(handle,
-                                                          header->frequency,// samplingRate,
-                                                           fscod,           // fscod
-                                                           8,               // bsid,
-                                                           0,               // bsmod,
-                                                           acmod,           // acmod
-                                                           lfe,             // lfeon
-                                                           bitrate);        // bit_rate_code 
-                    if(MP4_INVALID_TRACK_ID==audioTrackIds[i])
-                    {
-                        ADM_error("Error adding audio track %i of type 0x%x\n",i,header->encoding);
-                        return false;
-                    }
-                    aprintf("Add Track %d fq %d (AC3)\n",audioTrackIds[i],header->frequency);
-                    }
                     break;
             case WAV_MP2:
             case WAV_MP3:



From mean at mail.berlios.de  Mon Jan 17 08:43:19 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 17 Jan 2011 08:43:19 +0100
Subject: [Avidemux-svn-commit] r6935 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src
Message-ID: <20110117074319.C4DCB48128D@sheep.berlios.de>

Author: mean
Date: 2011-01-17 08:43:19 +0100 (Mon, 17 Jan 2011)
New Revision: 6935

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_a52info.cpp
Log:
[a52parser] Cosmetic

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_a52info.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_a52info.cpp	2011-01-17 07:43:18 UTC (rev 6934)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_a52info.cpp	2011-01-17 07:43:19 UTC (rev 6935)
@@ -37,11 +37,12 @@
 			 128, 160, 192, 224, 256, 320, 384, 448,
 			 512, 576, 640};
 static uint8_t lfeon[8] = {0x10, 0x10, 0x04, 0x04, 0x04, 0x01, 0x04, 0x01};
-
-// Borrowed from a52dec
-// Return packed size on success, 0 on failure
-// Need at least 6 bytes incoming
-
+/**
+    \fn ADM_a52_syncinfo
+    \brief  Return packed size on success, 0 on failure
+            Need at least 6 bytes incoming
+            Borrowed from a52dec
+*/
 int ADM_a52_syncinfo (uint8_t * buf, int * flags, int * sample_rate, int * bit_rate)
 {
     int frmsizecod;
@@ -53,7 +54,7 @@
 	return 0;
 
     if (buf[5] >= 0x60)		/* bsid >= 12 */
-	return 0;
+            return 0;
     half = halfrate[buf[5] >> 3];
 
     /* acmod, dsurmod and lfeon */
@@ -81,9 +82,10 @@
 	return 0;
     }
 }
-//
-//	Exctract infos from AC3 stream (used when muxing with external AC3)
-//
+/**
+        \fn     ADM_AC3GetInfo
+        \brief Extract infos from AC3 stream (used when muxing with external AC3)
+*/
 uint8_t ADM_AC3GetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *br, uint32_t *chan,uint32_t *syncoff)
 {
 uint32_t l;



From mean at mail.berlios.de  Mon Jan 17 08:43:21 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 17 Jan 2011 08:43:21 +0100
Subject: [Avidemux-svn-commit] r6936 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils:
	include src
Message-ID: <20110117074321.3237148128D@sheep.berlios.de>

Author: mean
Date: 2011-01-17 08:43:21 +0100 (Mon, 17 Jan 2011)
New Revision: 6936

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp
Log:
[infoExtractor] Use a more generic way to exctract vol/vop etc.....

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h	2011-01-17 07:43:19 UTC (rev 6935)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h	2011-01-17 07:43:21 UTC (rev 6936)
@@ -18,7 +18,7 @@
 uint8_t extractMpeg4Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h,uint32_t *time_inc);
 uint8_t extractH263Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h);
 uint8_t extractVopInfo(uint8_t *data, uint32_t len,uint32_t timeincbits,uint32_t *vopType,uint32_t *modulo, uint32_t *time_inc);
-
+bool    extractVolHeader(uint8_t *data,uint32_t dataSize,uint8_t **volStart, uint32_t *volLen);
 /**
     \struct ADM_SPSinfo
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp	2011-01-17 07:43:19 UTC (rev 6935)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp	2011-01-17 07:43:21 UTC (rev 6936)
@@ -21,6 +21,13 @@
 
 #define aprintf(...) {}
 
+#define MP4_VOL         0x20
+#define MP4_VO_SEQ      0xB0
+#define MP4_USER_DATA   0xB2
+#define MP4_GOP         0xB3
+#define MP4_VISUAL_OBJ  0xB5
+#define MP4_VOP         0xB6         
+
 bool ADM_findMpegStartCode (uint8_t * start, uint8_t * end,
 			    uint8_t * outstartcode, uint32_t * offset);
 
@@ -69,7 +76,7 @@
       if (dataSize > 2)
 	{
 	  //printf("Startcodec:%x\n",data[idx]);
-	  if ((data[idx] & 0xF0) == 0x20)	//VOL start
+	  if ((data[idx] & 0xF0) == MP4_VOL)	//VOL start
 	    {
 	      dataSize--;
 	      idx++;
@@ -276,8 +283,9 @@
     }
   return 1;
 }
-/*
-        Extract H263 width & height from header
+/**
+    \fn extractH263Info
+    \brief  Extract H263 width & height from header
 
 */
 uint8_t
@@ -354,7 +362,7 @@
     {
       if (ADM_findMpegStartCode (begin, end, &code, &off))
 	{
-	  if (code == 0xb6)
+	  if (code == MP4_VOP)
 	    {
 	      // Analyse a bit the vop header
 	      uint8_t coding_type = begin[off];
@@ -422,5 +430,108 @@
   return 1;
 }
 
+typedef struct
+{
+        uint32_t code;
+        uint8_t  *data;
+        uint32_t len;
+}mpeg4unit;
+#define MKVOL(x) {x,#x}
+typedef struct
+{
+    int unitId;
+    const char *unitName;
+}unitDesc;
+static const unitDesc descriptor[]={
+MKVOL(MP4_VOL         ),
+MKVOL(MP4_VO_SEQ      ),
+MKVOL(MP4_USER_DATA   ),
+MKVOL(MP4_GOP         ),
+MKVOL(MP4_VISUAL_OBJ  ),
+MKVOL(MP4_VOP         )};
 
+const char *findUnit(int c)
+{
+    int m=sizeof(descriptor)/sizeof(unitDesc);
+    for(int i=0;i<m;i++)
+        if(descriptor [i].unitId==c)
+            return descriptor[i].unitName;
+    return "unknown";
+}
+/**
+    \fn splitMpeg4
+    \brief split a bytestream block into mpeg4 sp/asp units
+*/
+int splitMpeg4(uint8_t *frame,uint32_t dataSize,mpeg4unit *unit,int maxUnits)
+{
+    uint8_t *start=frame;
+    uint8_t *end=start+dataSize;
+    int nbUnit=0;
+    while(start+3<end)
+    {
+        uint8_t c;
+        uint32_t offset;
+        if(false==ADM_findMpegStartCode(start,end,&c,&offset)) break;
+        ADM_assert(nbUnit<maxUnits);
+#if 0
+        printf("Unit : %x offset=%d absOffset=%d val=%x\n",c,offset,(int)(offset,start+offset-frame),
+                                                            *(start+offset));
+#endif
+        ADM_assert(offset>=4);
+        unit[nbUnit].code=c;
+        unit[nbUnit].data=start+offset-4;
+        unit[nbUnit].len=0;
+        start=start+offset;
+        nbUnit++;
+    }
+    //ADM_info("found %d units\n",nbUnit);
+    if(!nbUnit) return 0;
+    for(int j=0;j<nbUnit-1;j++)
+    {
+        unit[j].len=(uint32_t)(unit[j+1].data-unit[j].data);
+    }
+    unit[nbUnit-1].len=(uint32_t)(end-unit[nbUnit-1].data);
+    for(int j=0;j<nbUnit;j++)
+    {
+        mpeg4unit *u=unit+j;
+        //ADM_info("%x : %s, offset=%d size=%d\n",u->code,findUnit(u->code),(int)(u->data-frame),u->len);
+    }
+    return nbUnit;
+}
+/**
+    \fn extractVolHeader
+    \brief extract VOL header from a frame, it will be used later as esds atom for example
+*/
+bool extractVolHeader(uint8_t *data,uint32_t dataSize,uint8_t **volStart, uint32_t *volLen)
+{
+    // Search startcode
+    uint8_t b;
+    uint32_t idx=0;
+    uint32_t mw,mh;
+    uint32_t time_inc;
+    
+    mpeg4unit unit[10];
+    int nbUnit=splitMpeg4(data,dataSize,unit,10);
+    if(!nbUnit)
+    {
+        ADM_error("Cannot find VOL header(1)\n");
+        return false;
+    }
+    for(int i=0;i<nbUnit;i++)
+    {
+          mpeg4unit *u=unit+i;
+          if(u->code==MP4_VOL)
+          {
+                ADM_info("Vol Header found : %x : %s, offset=%d size=%d\n",u->code,findUnit(u->code),
+                                                        (int)(u->data-data),u->len);
+                *volStart=u->data;
+                *volLen=u->len;
+                return true;
+          }
+    }
+    ADM_error("Cannot find VOL header in the units\n");
+    return false;
+}    
+
+
 //EOF



From mean at mail.berlios.de  Mon Jan 17 08:43:22 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 17 Jan 2011 08:43:22 +0100
Subject: [Avidemux-svn-commit] r6937 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110117074322.478D948128D@sheep.berlios.de>

Author: mean
Date: 2011-01-17 08:43:22 +0100 (Mon, 17 Jan 2011)
New Revision: 6937

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
Log:
[mp4v2] Exctract VOL from first frame if not extraData

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-17 07:43:21 UTC (rev 6936)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-17 07:43:22 UTC (rev 6937)
@@ -77,6 +77,7 @@
         virtual bool open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a);
         virtual bool save(void) ;
         virtual bool close(void) ;
+        virtual bool useGlobalHeader(void) {return true;}
 
 };
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-17 07:43:21 UTC (rev 6936)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-17 07:43:22 UTC (rev 6937)
@@ -23,6 +23,7 @@
 #include "muxerMp4v2.h"
 #include "ADM_codecType.h"
 #include "ADM_imageFlags.h"
+#include "ADM_videoInfoExtractor.h"
 #if 1
 #define aprintf(...) {}
 #else
@@ -45,16 +46,39 @@
      uint32_t esdsLen=0;
         if(false==vStream->getExtraData(&esdsLen,&esdsData))
         {
-            ADM_info("No extradata, geting ESDS from first frame...");
+            ADM_info("No extradata, geting ESDS from first frame...\n");
         }else
         {
             ADM_info("Got esds from extradata\n");
         }
+        if(!esdsLen) // We dont have extraData, look into the 1st frame
+        {
+            ADM_info("Trying to get VOL header from first frame...\n");
+            if(!extractVolHeader(in[0].data,in[0].len,&esdsData,&esdsLen))
+            {
+                ADM_error("Cannot get ESDS, aborting\n");
+                return false;
+            }
+           
+        }
+        //
         if(!esdsLen)
         {
             ADM_error("ESDS not found, aborting\n");
             return false;
         }
+        if(!esdsData[0] && !esdsData[1] && esdsData[2]==1)
+        {
+            // Remove startcode
+            if(esdsLen<4)
+            {
+                ADM_error("ESDS too short\n");
+                return false;
+            }
+            esdsData+=4;
+            esdsLen-=4;
+        }
+
         ADM_info("Esds:\n"); mixDump(esdsData,esdsLen);ADM_info("\n");            
         if(false==MP4SetTrackESConfiguration(handle,videoTrackId,esdsData,esdsLen))
         {



From mean at mail.berlios.de  Mon Jan 17 19:49:24 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 17 Jan 2011 19:49:24 +0100
Subject: [Avidemux-svn-commit] r6938 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110117184924.EA60B48129C@sheep.berlios.de>

Author: mean
Date: 2011-01-17 19:49:24 +0100 (Mon, 17 Jan 2011)
New Revision: 6938

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
Log:
[mp4v2] Remove VOL if we got it from 1st frame

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-17 07:43:22 UTC (rev 6937)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-17 18:49:24 UTC (rev 6938)
@@ -36,6 +36,7 @@
 */
 bool muxerMp4v2::setMpeg4Esds(void)
 {
+    bool removeVol=false;
     ADM_info("Setting mpeg4 (a)SP ESDS...\n");
     if(0) //false==vStream->getPacket(&in) )
      {
@@ -59,7 +60,8 @@
                 ADM_error("Cannot get ESDS, aborting\n");
                 return false;
             }
-           
+            // Remove VOL Header from Fist frame...
+            removeVol=true;
         }
         //
         if(!esdsLen)
@@ -86,6 +88,12 @@
             return false;
         }
         ADM_info("ESDS atom set\n");
+        if(removeVol)
+        {
+            uint32_t size=(uint32_t)((in[0].data+in[0].len)-(esdsData+esdsLen));
+            memmove(in[0].data,esdsData+esdsLen,size);
+            in[0].len=size;
+        }
         return true;
 }
 /**



From mean at mail.berlios.de  Mon Jan 17 19:49:25 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 17 Jan 2011 19:49:25 +0100
Subject: [Avidemux-svn-commit] r6939 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src
Message-ID: <20110117184926.01F0148129C@sheep.berlios.de>

Author: mean
Date: 2011-01-17 19:49:25 +0100 (Mon, 17 Jan 2011)
New Revision: 6939

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
Log:
[coreFFmpeg] Video encoder, dont use pts/dts remapper when b_frames are disabled

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2011-01-17 18:49:24 UTC (rev 6938)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2011-01-17 18:49:25 UTC (rev 6939)
@@ -361,6 +361,12 @@
         out->flags=AVI_B_FRAME;
     
     // Update PTS/Dts
+    if(!_context->max_b_frames)
+    {
+            out->dts=out->pts=queueOfDts[0];
+            mapper.erase(mapper.begin());
+            queueOfDts.erase(queueOfDts.begin());
+    } else
     getRealPtsFromInternal(_context->coded_frame->pts,&(out->dts),&(out->pts));
     
     



From mean at mail.berlios.de  Mon Jan 17 19:49:27 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 17 Jan 2011 19:49:27 +0100
Subject: [Avidemux-svn-commit] r6940 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110117184927.2474F48129C@sheep.berlios.de>

Author: mean
Date: 2011-01-17 19:49:26 +0100 (Mon, 17 Jan 2011)
New Revision: 6940

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
Log:
[mp4v2] Add progress bar + fix video not starting at dts=0

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-17 18:49:25 UTC (rev 6939)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-17 18:49:26 UTC (rev 6940)
@@ -138,13 +138,14 @@
 bool muxerMp4v2::save(void)
 {
     bool result=true;
+    int nbFrame=0;
     printf("[Mp4v2Muxer] Saving\n");
    
 
     initUI("Saving MP4V2");
     encoding->setContainer("MP4");
-    uint32_t nbFrame=0;
     
+    
     while(vStream->getPacket(&(in[nextWrite]))) 
     {
         bool kf=false;
@@ -153,8 +154,16 @@
         uint64_t newDts=in[nextWrite].dts-in[other].dts;
         uint64_t duration=timeScale(newDts);
         uint64_t delta=in[other].pts-in[other].dts;
-            delta=timeScale(delta);
-   
+
+        encoding->pushVideoFrame(in[other].len,in[other].out_quantizer,in[other].dts);
+        // Special case : First frame
+        if(!nbFrame)
+        {
+            delta+=in[other].dts;
+            ADM_info("Video does not start at 0, adding %d ms\n",(int)in[other].dts/1000);
+        }
+        delta=timeScale(delta);
+        nbFrame++;
         if(false==MP4WriteSample(handle,videoTrackId,in[other].data,in[other].len,
                         duration, // duration
                         delta, // pts/dts offset
@@ -171,6 +180,11 @@
         fillAudio(nextDts);
         // toggle
         nextWrite=other;
+        if(updateUI()==false)
+            {  
+                result=false;
+                break;
+            }
     }
     // Write last frame
     nextWrite=!nextWrite;
@@ -180,6 +194,7 @@
                         0 // Sync Sample
                         );
 theEnd:
+    closeUI();
     close();
     return result;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-17 18:49:25 UTC (rev 6939)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-17 18:49:26 UTC (rev 6940)
@@ -172,7 +172,9 @@
                     ADM_error("Cannot create audio track of type 0x%x\n",header->encoding);
                     return false;
         }
-       
+         MP4SetTrackBytesProperty(handle,audioTrackIds[i],"udta.name.value",
+                    (const uint8_t*)"Stereo", strlen("Stereo"));
+
     }
     if(nbAStreams)
          MP4SetTrackIntegerProperty(handle, audioTrackIds[0], "tkhd.flags", 3);
@@ -213,6 +215,7 @@
                             block->sizeInBytes,
                             nbSamples,
                             0,1);
+    encoding->pushAudioFrame(block->sizeInBytes);
     if(false==r)
                         {
                             ADM_error("Cannot write audio sample for track %d\n",index);



From mean at mail.berlios.de  Wed Jan 19 07:29:24 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 19 Jan 2011 07:29:24 +0100
Subject: [Avidemux-svn-commit] r6941 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_faad
Message-ID: <20110119062925.1BA0B4812A3@sheep.berlios.de>

Author: mean
Date: 2011-01-19 07:29:24 +0100 (Wed, 19 Jan 2011)
New Revision: 6941

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp
Log:
[Faad] Disable SBR

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp	2011-01-17 18:49:26 UTC (rev 6940)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp	2011-01-19 06:29:24 UTC (rev 6941)
@@ -74,6 +74,9 @@
 		conf->outputFormat=FAAD_FMT_FLOAT;
 		conf->defSampleRate=info->frequency;
   	    conf->defObjectType =LC;
+        // Disable SBR...
+        conf->dontUpSampleImplicitSBR=1;
+        //
 		faacDecSetConfiguration(_instance, conf);
                 printf("[FAAD] using %u bytes of extradata\n",l);
 		// if we have some extra data, it means we can init it from it



From mean at mail.berlios.de  Wed Jan 19 07:29:26 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 19 Jan 2011 07:29:26 +0100
Subject: [Avidemux-svn-commit] r6942 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec
Message-ID: <20110119062926.41ABF4812A3@sheep.berlios.de>

Author: mean
Date: 2011-01-19 07:29:26 +0100 (Wed, 19 Jan 2011)
New Revision: 6942

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h
Log:
[Lav/AACenc] Get extradata, needed to build the esds atom

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2011-01-19 06:29:24 UTC (rev 6941)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2011-01-19 06:29:26 UTC (rev 6942)
@@ -82,11 +82,28 @@
     _globalHeader=false;
 
   wavheader.encoding=makeName(WAV);
-  
-  
 };
-
 /**
+    \fn extraData
+*/
+uint8_t AUDMEncoder_Lavcodec::extraData(uint32_t *l,uint8_t **d)
+{
+    ADM_assert(_context);
+    int size=0;
+    size=CONTEXT->extradata_size;
+    if(size)
+    {
+        *d=CONTEXT->extradata;
+        *l=(uint32_t)size;
+    }
+    else    
+    {
+        *d=NULL;
+        *l=0;
+    }
+    return true;
+}
+/**
     \fn ~AUDMEncoder_Lavcodec
 */
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h	2011-01-19 06:29:24 UTC (rev 6941)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h	2011-01-19 06:29:26 UTC (rev 6942)
@@ -29,6 +29,7 @@
    virtual             ~AUDMEncoder_Lavcodec();
                         AUDMEncoder_Lavcodec(AUDMAudioFilter *instream,bool globalHeader);
    virtual bool  	    encode(uint8_t *dest, uint32_t *len, uint32_t *samples);
+   uint8_t              extraData(uint32_t *l,uint8_t **d);
 };
 
 #endif



From mean at mail.berlios.de  Fri Jan 21 08:24:49 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 21 Jan 2011 08:24:49 +0100
Subject: [Avidemux-svn-commit] r6943 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_muxerGate/src
	avidemux_core/ADM_coreUtils/include avidemux_core/ADM_coreUtils/src
Message-ID: <20110121072449.C889F481237@sheep.berlios.de>

Author: mean
Date: 2011-01-21 08:24:49 +0100 (Fri, 21 Jan 2011)
New Revision: 6943

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp
Log:
[core] Move splitNalu/findNalu to core

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp	2011-01-19 06:29:26 UTC (rev 6942)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp	2011-01-21 07:24:49 UTC (rev 6943)
@@ -20,6 +20,7 @@
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_coreUtils.h"
 #include "ADM_h264_tag.h"
+#include "ADM_videoInfoExtractor.h"
 
 
 
@@ -29,16 +30,8 @@
 extern bool ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
 extern void mixDump(uint8_t *ptr, uint32_t len);
 
-#define SHORT_START_CODE
+#warning fixme : double definition
 
-#ifdef SHORT_START_CODE
-    #define SearchStartCode ADM_findMpegStartCode
-    #define START_CODE_LEN 4
-#else
-    #define SearchStartCode ADM_findH264StartCode
-    #define START_CODE_LEN 5
-#endif
-
 //#define ANNEX_B_DEBUG
 
 #if defined(ANNEX_B_DEBUG)
@@ -51,12 +44,6 @@
 
 #define MAX_NALU_PER_CHUNK 20
 
-typedef struct
-{
-    uint8_t  *start;
-    uint32_t size;   // size of payload excluding nalu type
-    uint8_t  nalu;
-}NALU_descriptor;
 
 static uint32_t readBE32(uint8_t *p)
 {
@@ -91,55 +78,8 @@
     if(nal<=12) ADM_info("Nal : %s",nalType[nal]);
     return true;
 }
-/**
-    \fn splitNalu
-    \brief split a nalu annexb size into a list of nalu descriptor
-*/
-static int splitNalu(uint8_t *start, uint8_t *end, uint32_t maxNalu,NALU_descriptor *desc)
-{
-bool first=true;
-uint8_t *head=start;
-uint32_t offset;
-uint8_t startCode,oldStartCode=0xff;
-int index=0;
-      while(true==SearchStartCode(head,end,&startCode,&offset))
-      {
-            if(true==first)
-            {
-                head+=offset;
-                first=false;
-                oldStartCode=startCode;
-                continue;
-            }
-        ADM_assert(index<maxNalu);
-        desc[index].start=head;
-        desc[index].size=offset-START_CODE_LEN;
-        desc[index].nalu=oldStartCode;
-        index++;
-        head+=offset;
-        oldStartCode=startCode;
-      }
-    // leftover
-    desc[index].start=head;
-    desc[index].size=(uint32_t)(end-head);
-    desc[index].nalu=oldStartCode;
-    index++;
-    return index;
-}
-/**
-    \fn findNalu
-    \brief lookup for a specific NALU in the given buffer
-*/
-static int findNalu(uint32_t nalu,uint32_t maxNalu,NALU_descriptor *desc)
-{
-    for(int i=0;i<maxNalu;i++)
-    {
-            if((desc[i].nalu&0x1f) == (nalu&0x1f))
-                return i;
-    }
-    return -1;
-}
 
+
 /**
     \fn ctor
 */
@@ -165,19 +105,19 @@
     {
         myBitstream->len=img.dataLength;
         NALU_descriptor desc[MAX_NALU_PER_CHUNK];
-        int nbNalu=splitNalu(myBitstream->data,myBitstream->data+myBitstream->len,
+        int nbNalu=ADM_splitNalu(myBitstream->data,myBitstream->data+myBitstream->len,
                                 MAX_NALU_PER_CHUNK,desc);
         // search sps
         uint8_t *spsStart,*ppsStart;
         uint32_t spsLen=0, ppsLen=0;
         int indexSps,indexPps;
 
-        indexSps=findNalu(NAL_SPS,nbNalu,desc);
+        indexSps=ADM_findNalu(NAL_SPS,nbNalu,desc);
         if(-1==indexSps)
         {
             ADM_error("Cannot find SPS");
         }
-        indexPps=findNalu(NAL_PPS,nbNalu,desc);
+        indexPps=ADM_findNalu(NAL_PPS,nbNalu,desc);
         if(-1==indexPps)
         {
             ADM_error("Cannot find SPS");
@@ -243,7 +183,7 @@
 {
     uint8_t *tgt=outData;
     NALU_descriptor desc[MAX_NALU_PER_CHUNK];
-    int nbNalu=splitNalu(myBitstream->data,myBitstream->data+myBitstream->len,
+    int nbNalu=ADM_splitNalu(myBitstream->data,myBitstream->data+myBitstream->len,
                         MAX_NALU_PER_CHUNK,desc);
     int nalHeaderSize=4;
     int outputSize=0;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h	2011-01-19 06:29:26 UTC (rev 6942)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h	2011-01-21 07:24:49 UTC (rev 6943)
@@ -36,7 +36,28 @@
 uint8_t extractSPSInfo(uint8_t *data, uint32_t len,ADM_SPSInfo *info);
 uint8_t extractH264FrameType(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags);
 uint8_t extractH264FrameType_startCode(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags);
+bool    ADM_getH264SpsPpsFromExtraData(uint32_t extraLen,uint8_t *extra,
+                                    uint32_t *spsLen,uint8_t **spsData,
+                                    uint32_t *ppsLen,uint8_t **ppsData); // return a copy of pps/sps extracted
 
+typedef struct
+{
+    uint8_t  *start;
+    uint32_t size;   // size of payload excluding nalu type
+    uint8_t  nalu;
+}NALU_descriptor;
+int ADM_splitNalu(uint8_t *start, uint8_t *end, uint32_t maxNalu,NALU_descriptor *desc);
+int ADM_findNalu(uint32_t nalu,uint32_t maxNalu,NALU_descriptor *desc);
+
+#define SHORT_START_CODE
+
+#ifdef SHORT_START_CODE
+    #define SearchStartCode ADM_findMpegStartCode
+    #define START_CODE_LEN 4
+#else
+    #define SearchStartCode ADM_findH264StartCode
+    #define START_CODE_LEN 5
+#endif
 /**
     \struct ADM_vopS
     \brief describe a vop inside a bitstream (mpeg4 SP/ASP)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp	2011-01-19 06:29:26 UTC (rev 6942)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp	2011-01-21 07:24:49 UTC (rev 6943)
@@ -32,6 +32,19 @@
 #include "ADM_videoInfoExtractor.h"
 #include "ADM_h264_tag.h"
 
+
+//#define ANNEX_B_DEBUG
+
+#if defined(ANNEX_B_DEBUG)
+#define aprintf ADM_info
+#define check isNalValid
+#else
+#define aprintf(...) {}
+#define check(...) {}
+#endif
+
+#define MAX_NALU_PER_CHUNK 20
+
 bool ADM_findMpegStartCode (uint8_t * start, uint8_t * end,
 			    uint8_t * outstartcode, uint32_t * offset);
 /**
@@ -649,4 +662,107 @@
         return i;
 #endif
 }
+/**
+    \fn ADM_getH264SpsPpsFromExtraData
+    \brief Returns a copy of PPS/SPS extracted from extrdata
+*/
+bool ADM_getH264SpsPpsFromExtraData(uint32_t extraLen,uint8_t *extra,
+                                    uint32_t *spsLen,uint8_t **spsData,
+                                    uint32_t *ppsLen,uint8_t **ppsData)
+{
+  
+            if(extraLen<7) // not mov/mp4 formatted...
+            {
+                ADM_error("Wrong extra data for h264\n");
+                return false;
+            }
+            //
+            if(extra[1]==1) // MP4-type extradata
+            {
+                ADM_info("MP4 style PPS/SPS\n");
+                return false;
+
+                int nbSps=extra[5]&0x1f;
+                if(nbSps!=1)    
+                {
+                    ADM_error("More or less than 1 sps\n");
+                    return false;
+                    
+                }
+                uint8_t *c=extra+6;
+                *spsLen= (c[0]<<8)+(c[1]);
+                *spsData=c+2;
+                c+=2+*spsLen;
+                int nbPps=c[0]&0x1f;
+                if(nbPps!=1)
+                {
+                    ADM_error("More or less than 1 pps\n");
+                    return false;        
+                }
+                c++;
+                *ppsLen= (c[0]<<8)+(c[1]);
+                *ppsData=c+2;
+            }else
+            if(!extra[0] && !extra[1] && extra[2]==1) // 00 00 01 type extradata
+            {
+                ADM_info("Startcoded PPS/SPS\n");
+                return false;
+            }
+            // Duplicate
+            uint8_t *y=new uint8_t [*spsLen];
+            memcpy(y,*spsData,*spsLen);
+            *spsData=y;
+            y=new uint8_t [*ppsLen];
+            memcpy(y,*ppsData,*ppsLen);
+            *ppsData=y;
+            return true;
+}
+/**
+    \fn ADM_splitNalu
+    \brief split a nalu annexb size into a list of nalu descriptor
+*/
+int ADM_splitNalu(uint8_t *start, uint8_t *end, uint32_t maxNalu,NALU_descriptor *desc)
+{
+bool first=true;
+uint8_t *head=start;
+uint32_t offset;
+uint8_t startCode,oldStartCode=0xff;
+int index=0;
+      while(true==SearchStartCode(head,end,&startCode,&offset))
+      {
+            if(true==first)
+            {
+                head+=offset;
+                first=false;
+                oldStartCode=startCode;
+                continue;
+            }
+        ADM_assert(index<maxNalu);
+        desc[index].start=head;
+        desc[index].size=offset-START_CODE_LEN;
+        desc[index].nalu=oldStartCode;
+        index++;
+        head+=offset;
+        oldStartCode=startCode;
+      }
+    // leftover
+    desc[index].start=head;
+    desc[index].size=(uint32_t)(end-head);
+    desc[index].nalu=oldStartCode;
+    index++;
+    return index;
+}
+/**
+    \fn ADM_findNalu
+    \brief lookup for a specific NALU in the given buffer
+*/
+int ADM_findNalu(uint32_t nalu,uint32_t maxNalu,NALU_descriptor *desc)
+{
+    for(int i=0;i<maxNalu;i++)
+    {
+            if((desc[i].nalu&0x1f) == (nalu&0x1f))
+                return i;
+    }
+    return -1;
+}
 //EOF



From mean at mail.berlios.de  Fri Jan 21 08:24:50 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 21 Jan 2011 08:24:50 +0100
Subject: [Avidemux-svn-commit] r6944 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110121072450.EAE1F481237@sheep.berlios.de>

Author: mean
Date: 2011-01-21 08:24:50 +0100 (Fri, 21 Jan 2011)
New Revision: 6944

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
Log:
[mp4v2] Support for h264 video (incomplete)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-21 07:24:49 UTC (rev 6943)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-21 07:24:50 UTC (rev 6944)
@@ -143,7 +143,7 @@
    
 
     initUI("Saving MP4V2");
-    encoding->setContainer("MP4");
+    encoding->setContainer("MP4 (libmp4v2)");
     
     
     while(vStream->getPacket(&(in[nextWrite]))) 
@@ -151,18 +151,27 @@
         bool kf=false;
         int other=!nextWrite;
         if(in[other].flags & AVI_KEY_FRAME) kf=true;
-        uint64_t newDts=in[nextWrite].dts-in[other].dts;
-        uint64_t duration=timeScale(newDts);
-        uint64_t delta=in[other].pts-in[other].dts;
 
+        ADM_assert(in[nextWrite].dts!=ADM_NO_PTS)
+        ADM_assert(in[other].pts!=ADM_NO_PTS)
+        ADM_assert(in[nextWrite].dts!=ADM_NO_PTS)
+        ADM_assert(in[other].pts!=ADM_NO_PTS)
+
+        uint64_t newDts=in[nextWrite].dts-in[other].dts;   // Delta between dts=duration of the frame (sort of)     
+        uint64_t delta=in[other].pts-in[other].dts; // composition time...
+        uint64_t duration=(newDts);
+
         encoding->pushVideoFrame(in[other].len,in[other].out_quantizer,in[other].dts);
         // Special case : First frame
         if(!nbFrame)
         {
-            delta+=in[other].dts;
-            ADM_info("Video does not start at 0, adding %d ms\n",(int)in[other].dts/1000);
+            uint64_t tzero=in[other].dts;
+            delta+=tzero; // Still in us
+            duration+=tzero;
+            ADM_info("Video does not start at 0, adding %d ms\n",(int)tzero/1000);
         }
         delta=timeScale(delta);
+        duration=timeScale(duration);
         nbFrame++;
         if(false==MP4WriteSample(handle,videoTrackId,in[other].data,in[other].len,
                         duration, // duration

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-21 07:24:49 UTC (rev 6943)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-21 07:24:50 UTC (rev 6944)
@@ -62,7 +62,8 @@
         int             nextWrite;
         uint64_t        audioDelay; // In fact videoDelay, but must be added to all audioTrack
 protected:
-        bool            setMpeg4Esds(void);
+        bool            initMpeg4(void);
+        bool            initH264(void);
         bool            initVideo(void);
         bool            initAudio(void);
         bool            fillAudio(uint64_t targetDts);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-21 07:24:49 UTC (rev 6943)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-01-21 07:24:50 UTC (rev 6944)
@@ -25,9 +25,11 @@
 #include "ADM_imageFlags.h"
 #if 1
 #define aprintf(...) {}
+#define bprintf(...) {} // ADM_info
 #define MP4_DEBUG 0
 #else
 #define aprintf ADM_info
+#define bprintf ADM_info
 #define MP4_DEBUG MP4_DETAILS_ALL
 #endif
 
@@ -246,10 +248,14 @@
                         // Get our currentDts
                         uint64_t currentDts=clock->getTimeUs();                        
                         uint64_t blockDts=currentBlock->dts;
+                        if(pkt->eos)            break;
                         extraSamples=0;
                         // Take either block Dts or our own if no DTS is provided
                         if(currentBlock->dts!=ADM_NO_PTS)
                         {
+                            bprintf("Current audio Dts=%"LLD"\n",currentDts);
+                            bprintf("Incoming block, dts=%"LLD"\n",currentBlock->dts);
+                            bprintf("Delta =%d ms\n",(int)(currentDts-currentBlock->dts));
                             if( abs(currentBlock->dts-currentDts)>MP4V2_MAX_JITTER)
                             {
                                 if(currentBlock->dts<currentDts)
@@ -278,10 +284,12 @@
                             return false;
                         }
                         // load next
+
+                        clock->advanceBySample(currentBlock->nbSamples+extraSamples);
 nextOne:
-                        clock->advanceBySample(currentBlock->nbSamples+extraSamples);
                         if(false==loadAndToggleAudioSlot(audioIndex))
                         {
+                            ADM_warning("End of audio stream %d\n",audioIndex);
                             #warning Purge other slot
                             pkt->eos=true;
                         }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-21 07:24:49 UTC (rev 6943)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-21 07:24:50 UTC (rev 6944)
@@ -34,9 +34,16 @@
     \fn setEsdsAtom
     \brief extract esds atom from extradata or for first frame. In all cases read the first frame
 */
-bool muxerMp4v2::setMpeg4Esds(void)
+bool muxerMp4v2::initMpeg4(void)
 {
     bool removeVol=false;
+    videoTrackId=MP4AddVideoTrack(handle,90000,MP4_INVALID_DURATION,
+    vStream->getWidth(),vStream->getHeight(),MP4_MPEG4_VIDEO_TYPE);
+    if(MP4_INVALID_TRACK_ID==videoTrackId)
+        {
+            ADM_error("Cannot add mpeg4 video Track \n");
+            return false;
+        }
     ADM_info("Setting mpeg4 (a)SP ESDS...\n");
     if(0) //false==vStream->getPacket(&in) )
      {
@@ -97,6 +104,59 @@
         return true;
 }
 /**
+       \fn initH264
+       \brief format header for H264
+*/
+bool muxerMp4v2::initH264(void)
+{
+//
+            bool result=false;
+            uint32_t spsLen;
+            uint8_t  *spsData=NULL;
+            uint32_t ppsLen;
+            uint8_t  *ppsData=NULL;
+            // Extract sps & pps            
+            uint8_t *extra=NULL;
+            uint32_t extraLen=0;
+            if(false==vStream->getExtraData(&extraLen,&extra))
+            {
+                ADM_error("Cannot get extradata\n");
+                return false;
+            }
+            if(extraLen)
+                mixDump(extra,extraLen);
+            ADM_info("\n");
+            if(false==ADM_getH264SpsPpsFromExtraData(extraLen,extra,&spsLen,&spsData,&ppsLen,&ppsData))
+            {
+                ADM_error("Wrong extra data for h264\n");
+                return false;
+            }
+          
+            videoTrackId=MP4AddH264VideoTrack(handle,90000,MP4_INVALID_DURATION,
+                    vStream->getWidth(),vStream->getHeight(),spsData[1],spsData[2],spsData[3],3);
+            if(MP4_INVALID_TRACK_ID==videoTrackId)
+            {
+                ADM_error("Cannot add h264 video Track \n");
+                return false;
+            }
+            ADM_info("SPS (%d) :",spsLen);
+            mixDump(spsData,spsLen);
+            ADM_info("PPS (%d) :",ppsLen);
+            mixDump(ppsData,ppsLen);
+            ADM_info("\n");
+
+            MP4AddH264SequenceParameterSet(handle,videoTrackId, spsData,spsLen );
+            MP4AddH264PictureParameterSet( handle,videoTrackId, ppsData,ppsLen);
+            // MP4AddIPodUUID
+            result=true;
+clnup:
+            if(spsData) delete [] spsData;
+            if(ppsData) delete [] ppsData;
+            spsData=NULL;
+            ppsData=NULL;
+            return result;
+}
+/**
     \fn initVideo
 */
 bool muxerMp4v2::initVideo(void)
@@ -112,39 +172,22 @@
         ADM_info("Setting video..\n");
         if(isMpeg4Compatible(fcc))
         {
-            videoTrackId=MP4AddVideoTrack(handle,90000,MP4_INVALID_DURATION,
-                    vStream->getWidth(),vStream->getHeight(),MP4_MPEG4_VIDEO_TYPE);
-            if(MP4_INVALID_TRACK_ID==videoTrackId)
+           
+            if(false==initMpeg4())
             {
-                ADM_error("Cannot add mpeg4 video Track \n");
-                return false;
-            }
-            if(false==setMpeg4Esds())
-            {
                 ADM_error("Cannot set ESDS atom\n");
                 return false;
             }
         }
         if(isH264Compatible(fcc))
         {
-#if 0
-            // Extract sps & pps
-            uint8_t *sps,*pps;
-            //
-            videoTrackId=MP4AddH264VideoTrack(handle,90000,MP4_INVALID_DURATION,
-                    vStream->getWidth(),vStream->getHeight(),sps[0],sps[1],sps[2],3);
-            if(MP4_INVALID_TRACK_ID==videoTrackId)
+            if(false==initH264())
             {
-                ADM_error("Cannot add h264 video Track \n");
-                goto er;
-            }
-            if(false==MP4SetTrackESConfiguration(handle,videoTrackId,esdsData,esdsLen))
-            {
-                ADM_error("SetTracEsConfiguration failed\n");
+                ADM_error("Cannot add h264 track\n");
                 return false;
             }
-#endif
         }
+        ADM_info("[MP4V2] Video correctly initalized\n");
         return true;
 }
 //EOF



From mean at mail.berlios.de  Fri Jan 21 08:24:52 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 21 Jan 2011 08:24:52 +0100
Subject: [Avidemux-svn-commit] r6945 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src
Message-ID: <20110121072452.2DCE2481237@sheep.berlios.de>

Author: mean
Date: 2011-01-21 08:24:52 +0100 (Fri, 21 Jan 2011)
New Revision: 6945

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp
Log:
[util] Search mpeg style nalu in extradata

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp	2011-01-21 07:24:50 UTC (rev 6944)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp	2011-01-21 07:24:52 UTC (rev 6945)
@@ -706,6 +706,23 @@
             if(!extra[0] && !extra[1] && extra[2]==1) // 00 00 01 type extradata
             {
                 ADM_info("Startcoded PPS/SPS\n");
+                #define NALU_COUNT 10
+                NALU_descriptor nalus[NALU_COUNT];      
+                int nbNalus=ADM_splitNalu(extra, extraLen+extra, NALU_COUNT,nalus);
+                //int ADM_findNalu(uint32_t nalu,uint32_t maxNalu,NALU_descriptor *desc);
+                if(nbNalus<2)
+                {
+                    ADM_error("Not enough nalus in extradata (%s)\n",nbNalus);
+                    return false;
+                }
+                int spsIndex=ADM_findNalu(NAL_SPS,nbNalus,nalus);
+                int ppsIndex=ADM_findNalu(NAL_PPS,nbNalus,nalus);
+                if(-1==spsIndex || -1 == ppsIndex)
+                {
+                    ADM_error("Cant find sps/pps in nalus\n");
+                    return false;
+                }
+
                 return false;
             }
             // Duplicate



From mean at mail.berlios.de  Sat Jan 22 09:29:07 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 22 Jan 2011 09:29:07 +0100
Subject: [Avidemux-svn-commit] r6946 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_muxerGate/src
	avidemux_core/ADM_coreUtils/include avidemux_core/ADM_coreUtils/src
Message-ID: <20110122082907.C46344809B2@sheep.berlios.de>

Author: mean
Date: 2011-01-22 09:29:07 +0100 (Sat, 22 Jan 2011)
New Revision: 6946

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp
Log:
[h264] move annexB conversion into core

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp	2011-01-21 07:24:52 UTC (rev 6945)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp	2011-01-22 08:29:07 UTC (rev 6946)
@@ -53,13 +53,6 @@
 }
 
 
-static void writeBE32(uint8_t *p, uint32_t size)
-{
-    p[0]=size>>24;
-    p[1]=(size>>16)&0xff;
-    p[2]=(size>>8)&0xff;
-    p[3]=(size>>0)&0xff;
-}
 static const char *nalType[13]=
 {
     "invalid","nonIdr","invalid","invalid","invalid",
@@ -174,41 +167,7 @@
     delete myBitstream;
     myBitstream=NULL;
 }
-/**
-    \fn convertFromAnnexB   
-    \brief convert annexB startcode (00 00 00 0 xx) to NALU
-*/
-int ADM_videoStreamCopyFromAnnexB::convertFromAnnexB(uint8_t *inData,uint32_t inSize,
-                                                      uint8_t *outData,uint32_t outMaxSize)
-{
-    uint8_t *tgt=outData;
-    NALU_descriptor desc[MAX_NALU_PER_CHUNK];
-    int nbNalu=ADM_splitNalu(myBitstream->data,myBitstream->data+myBitstream->len,
-                        MAX_NALU_PER_CHUNK,desc);
-    int nalHeaderSize=4;
-    int outputSize=0;
 
-
-    for(int i=0;i<nbNalu;i++)
-    {
-        NALU_descriptor *d=desc+i;
-        aprintf("%d/%d : Nalu :0x%x size=%d\n",i,nbNalu,d->nalu,d->size);
-        switch(d->nalu&0x1f)
-        {
-            case NAL_FILLER: break;
-            case NAL_AU_DELIMITER: break; 
-            default:
-                  writeBE32(tgt,1+d->size);
-                  tgt[nalHeaderSize]=d->nalu;
-                  memcpy(tgt+1+nalHeaderSize,d->start,d->size);
-                  tgt+=d->size+1+nalHeaderSize;
-                  break;
-        }
-        outputSize=tgt-outData;
-        ADM_assert(outputSize<outMaxSize);
-    }
-    return outputSize;
-}
 static void parseNalu(uint8_t *head, uint8_t *tail)
 {
     printf("**** Parsing NALU : %d****",(int)(tail-head));
@@ -228,7 +187,7 @@
     aprintf("-------%d--------\n",(int)currentFrame);
     if(false==ADM_videoStreamCopy::getPacket(myBitstream)) return false;
     
-    int size=convertFromAnnexB(myBitstream->data,myBitstream->len,out->data,out->bufferSize);
+    int size=ADM_convertFromAnnexBToMP4(myBitstream->data,myBitstream->len,out->data,out->bufferSize);
     out->len=size;
     out->dts=myBitstream->dts;
     out->pts=myBitstream->pts;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h	2011-01-21 07:24:52 UTC (rev 6945)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h	2011-01-22 08:29:07 UTC (rev 6946)
@@ -48,6 +48,7 @@
 }NALU_descriptor;
 int ADM_splitNalu(uint8_t *start, uint8_t *end, uint32_t maxNalu,NALU_descriptor *desc);
 int ADM_findNalu(uint32_t nalu,uint32_t maxNalu,NALU_descriptor *desc);
+int ADM_convertFromAnnexBToMP4(uint8_t *inData,uint32_t inSize, uint8_t *outData,uint32_t outMaxSize);
 
 #define SHORT_START_CODE
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp	2011-01-21 07:24:52 UTC (rev 6945)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractorH264.cpp	2011-01-22 08:29:07 UTC (rev 6946)
@@ -663,6 +663,19 @@
 #endif
 }
 /**
+    \fn    packNalu
+    \brief convert mpeg type NALU into mp4 header type nalu
+*/
+static void packNalu(int idx,NALU_descriptor *nalus,uint32_t *len,uint8_t **data)
+{
+    NALU_descriptor *n=nalus+idx;
+    uint32_t size=n->size;
+    uint8_t *p=new uint8_t[size+1];
+    *data=p;
+    p[0]=n->nalu;
+    *len=1+ADM_unescapeH264(n->size, n->start,p+1);
+}
+/**
     \fn ADM_getH264SpsPpsFromExtraData
     \brief Returns a copy of PPS/SPS extracted from extrdata
 */
@@ -677,10 +690,9 @@
                 return false;
             }
             //
-            if(extra[1]==1) // MP4-type extradata
+            if(extra[0]==1) // MP4-type extradata
             {
                 ADM_info("MP4 style PPS/SPS\n");
-                return false;
 
                 int nbSps=extra[5]&0x1f;
                 if(nbSps!=1)    
@@ -702,8 +714,19 @@
                 c++;
                 *ppsLen= (c[0]<<8)+(c[1]);
                 *ppsData=c+2;
+                // Duplicate
+                uint8_t *y=new uint8_t [*spsLen];
+                memcpy(y,*spsData,*spsLen);
+                *spsData=y;
+                y=new uint8_t [*ppsLen];
+                memcpy(y,*ppsData,*ppsLen);
+                *ppsData=y;
+                ADM_info("Got extradata, ppslen=%d, spslen=%d\n",(int)(*ppsLen),(int)*spsLen);
+                return true;
+
             }else
-            if(!extra[0] && !extra[1] && extra[2]==1) // 00 00 01 type extradata
+            if(!extra[0] && !extra[1])
+                if(extra[2]==1 || (!extra[2] && extra[3]==1)) // 00 00 01 type extradata
             {
                 ADM_info("Startcoded PPS/SPS\n");
                 #define NALU_COUNT 10
@@ -722,17 +745,11 @@
                     ADM_error("Cant find sps/pps in nalus\n");
                     return false;
                 }
-
-                return false;
+                packNalu(spsIndex,nalus,spsLen,spsData);
+                packNalu(ppsIndex,nalus,ppsLen,ppsData);
+                return true;
             }
-            // Duplicate
-            uint8_t *y=new uint8_t [*spsLen];
-            memcpy(y,*spsData,*spsLen);
-            *spsData=y;
-            y=new uint8_t [*ppsLen];
-            memcpy(y,*ppsData,*ppsLen);
-            *ppsData=y;
-            return true;
+    return false;
 }
 /**
     \fn ADM_splitNalu
@@ -782,4 +799,47 @@
     }
     return -1;
 }
+
+static void writeBE32(uint8_t *p, uint32_t size)
+{
+    p[0]=size>>24;
+    p[1]=(size>>16)&0xff;
+    p[2]=(size>>8)&0xff;
+    p[3]=(size>>0)&0xff;
+}
+/**
+    \fn ADM_convertFromAnnexBToMP4   
+    \brief convert annexB startcode (00 00 00 0 xx) to NALU
+*/
+int ADM_convertFromAnnexBToMP4(uint8_t *inData,uint32_t inSize,
+                                                      uint8_t *outData,uint32_t outMaxSize)
+{
+    uint8_t *tgt=outData;
+    NALU_descriptor desc[MAX_NALU_PER_CHUNK];
+    int nbNalu=ADM_splitNalu(inData,inData+inSize,
+                        MAX_NALU_PER_CHUNK,desc);
+    int nalHeaderSize=4;
+    int outputSize=0;
+
+
+    for(int i=0;i<nbNalu;i++)
+    {
+        NALU_descriptor *d=desc+i;
+        aprintf("%d/%d : Nalu :0x%x size=%d\n",i,nbNalu,d->nalu,d->size);
+        switch(d->nalu&0x1f)
+        {
+            case NAL_FILLER: break;
+            case NAL_AU_DELIMITER: break; 
+            default:
+                  writeBE32(tgt,1+d->size);
+                  tgt[nalHeaderSize]=d->nalu;
+                  memcpy(tgt+1+nalHeaderSize,d->start,d->size);
+                  tgt+=d->size+1+nalHeaderSize;
+                  break;
+        }
+        outputSize=tgt-outData;
+        ADM_assert(outputSize<outMaxSize);
+    }
+    return outputSize;
+}
 //EOF



From mean at mail.berlios.de  Sat Jan 22 09:29:09 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 22 Jan 2011 09:29:09 +0100
Subject: [Avidemux-svn-commit] r6947 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110122082909.19A864809B2@sheep.berlios.de>

Author: mean
Date: 2011-01-22 09:29:08 +0100 (Sat, 22 Jan 2011)
New Revision: 6947

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
Log:
[mp4v2] Better handling of h264 , handling of annexB case

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-22 08:29:07 UTC (rev 6946)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-22 08:29:08 UTC (rev 6947)
@@ -52,7 +52,9 @@
         audioTrackIds=NULL;
         videoBuffer[0]=NULL;
         videoBuffer[1]=NULL;
+        scratchBuffer=NULL;
         nextWrite=0;
+        needToConvertFromAnnexB=false;
 };
 /**
     \fn     muxerMp4v2
@@ -81,6 +83,7 @@
         videoBufferSize=vStream->getWidth()*vStream->getHeight()*3;
         videoBuffer[0]=new uint8_t[videoBufferSize];
         videoBuffer[1]=new uint8_t[videoBufferSize];
+        scratchBuffer=new uint8_t[videoBufferSize];
         in[0].bufferSize=videoBufferSize;
         in[0].data=videoBuffer[0];
         in[1].bufferSize=videoBufferSize;
@@ -131,7 +134,6 @@
 er:
         return false;
 }
-
 /**
     \fn save
 */
@@ -146,7 +148,7 @@
     encoding->setContainer("MP4 (libmp4v2)");
     
     
-    while(vStream->getPacket(&(in[nextWrite]))) 
+    while(loadNextVideoFrame((&(in[nextWrite])))) 
     {
         bool kf=false;
         int other=!nextWrite;
@@ -157,6 +159,8 @@
         ADM_assert(in[nextWrite].dts!=ADM_NO_PTS)
         ADM_assert(in[other].pts!=ADM_NO_PTS)
 
+        
+
         uint64_t newDts=in[nextWrite].dts-in[other].dts;   // Delta between dts=duration of the frame (sort of)     
         uint64_t delta=in[other].pts-in[other].dts; // composition time...
         uint64_t duration=(newDts);
@@ -228,6 +232,11 @@
         if(videoBuffer[i]) delete [] videoBuffer[i];
         videoBuffer[i]=NULL;
     }
+    if(scratchBuffer)
+        {
+            delete [] scratchBuffer;
+            scratchBuffer=NULL;
+        }
     ADM_info("[Mp4v2Muxer] Closing\n");
     return true;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-22 08:29:07 UTC (rev 6946)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-22 08:29:08 UTC (rev 6947)
@@ -61,10 +61,14 @@
         ADMBitstream    in[2];
         int             nextWrite;
         uint64_t        audioDelay; // In fact videoDelay, but must be added to all audioTrack
-protected:
+        bool            needToConvertFromAnnexB;
+        uint8_t         *scratchBuffer;
+protected: // video
         bool            initMpeg4(void);
         bool            initH264(void);
         bool            initVideo(void);
+        bool            loadNextVideoFrame(ADMBitstream *bs);
+protected: // audio
         bool            initAudio(void);
         bool            fillAudio(uint64_t targetDts);
 static  uint64_t        timeScale(uint64_t timeUs);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-22 08:29:07 UTC (rev 6946)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-22 08:29:08 UTC (rev 6947)
@@ -31,12 +31,47 @@
 #endif
 
 /**
+    \fn loadNextVideoFrame
+    \brief Load buffer, convert to annexB if needed
+*/
+bool muxerMp4v2::loadNextVideoFrame(ADMBitstream *bs)
+{
+    if(true==needToConvertFromAnnexB)
+        {
+            ADMBitstream tmp;
+            tmp.data=scratchBuffer;
+            tmp.bufferSize=videoBufferSize;
+            if(false==vStream->getPacket(&tmp))
+                return false;
+            bs->dts=tmp.dts;
+            bs->pts=tmp.pts;
+            bs->flags=tmp.flags;
+            bs->len=ADM_convertFromAnnexBToMP4(scratchBuffer,tmp.len, bs->data,videoBufferSize);
+            return true;
+        }
+    if(false==vStream->getPacket(bs))
+        {
+            return false;
+        }
+
+    
+    return true;
+}
+/**
     \fn setEsdsAtom
     \brief extract esds atom from extradata or for first frame. In all cases read the first frame
 */
 bool muxerMp4v2::initMpeg4(void)
 {
     bool removeVol=false;
+    // Preload first image
+    if(false==loadNextVideoFrame(&(in[0])))
+        {
+            ADM_error("Cannot read 1st video frame\n");
+            return false;
+        }
+        nextWrite=1;
+
     videoTrackId=MP4AddVideoTrack(handle,90000,MP4_INVALID_DURATION,
     vStream->getWidth(),vStream->getHeight(),MP4_MPEG4_VIDEO_TYPE);
     if(MP4_INVALID_TRACK_ID==videoTrackId)
@@ -131,7 +166,16 @@
                 ADM_error("Wrong extra data for h264\n");
                 return false;
             }
-          
+            needToConvertFromAnnexB=true;
+            if(extraLen)
+                if(extra[0]==1) needToConvertFromAnnexB=false;
+            if(false==loadNextVideoFrame(&(in[0])))
+            {
+                ADM_error("Cannot read 1st video frame\n");
+                return false;
+            }
+            nextWrite=1;
+            //
             videoTrackId=MP4AddH264VideoTrack(handle,90000,MP4_INVALID_DURATION,
                     vStream->getWidth(),vStream->getHeight(),spsData[1],spsData[2],spsData[3],3);
             if(MP4_INVALID_TRACK_ID==videoTrackId)
@@ -162,13 +206,7 @@
 bool muxerMp4v2::initVideo(void)
 {
         uint32_t fcc=vStream->getFCC();
-
-        if(false==vStream->getPacket(&(in[0])))
-        {
-            ADM_error("Cannot read 1st video frame\n");
-            return false;
-        }
-        nextWrite=1;
+       
         ADM_info("Setting video..\n");
         if(isMpeg4Compatible(fcc))
         {



From mean at mail.berlios.de  Sat Jan 22 18:20:58 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 22 Jan 2011 18:20:58 +0100
Subject: [Avidemux-svn-commit] r6948 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <20110122172058.EF0AE481232@sheep.berlios.de>

Author: mean
Date: 2011-01-22 18:20:58 +0100 (Sat, 22 Jan 2011)
New Revision: 6948

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
Log:
[seek] update lastReadPts so that the cache is not filled

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2011-01-22 08:29:08 UTC (rev 6947)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2011-01-22 17:20:58 UTC (rev 6948)
@@ -83,6 +83,7 @@
             ADM_warning("No PTS out of decoder\n");
             continue;
         }
+        vid->lastReadPts=pts;
         if(pts==timeToSeek)
         {
             ADM_info("Image found, pts=%"LLU" ms\n",pts/1000);



From mean at mail.berlios.de  Sun Jan 23 19:34:18 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 23 Jan 2011 19:34:18 +0100
Subject: [Avidemux-svn-commit] r6949 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src
Message-ID: <20110123183418.C0FF1481275@sheep.berlios.de>

Author: mean
Date: 2011-01-23 19:34:18 +0100 (Sun, 23 Jan 2011)
New Revision: 6949

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp
Log:
[core] use mkdir instead of system(mkdir xxx)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp	2011-01-22 17:20:58 UTC (rev 6948)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp	2011-01-23 18:34:18 UTC (rev 6949)
@@ -420,14 +420,9 @@
 		return 0;
 	}
 #else
-	char *sys = new char[strlen(dirname2) + strlen("mkdir ") + 2];
+	printf("Creating dir :%s\n", dirname2);
+	mkdir(dirname2,0755);
 
-	strcpy(sys, "mkdir ");
-	strcat(sys, dirname2);
-	printf("Creating dir :%s\n", sys);
-	system(sys);
-
-	delete [] sys;
 #endif
 
 	if ((dir = opendir(dirname2)) == NULL)



From mean at mail.berlios.de  Sun Jan 23 20:22:47 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 23 Jan 2011 20:22:47 +0100
Subject: [Avidemux-svn-commit] r6950 -
	branches/avidemux_2.6_branch_mean/avidemux
Message-ID: <20110123192248.182D1481275@sheep.berlios.de>

Author: mean
Date: 2011-01-23 20:22:47 +0100 (Sun, 23 Jan 2011)
New Revision: 6950

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
Log:
[avidemux] Explictely link to libavcodec and friends, else it will not build when vdpau is set on fedora 14

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2011-01-23 18:34:18 UTC (rev 6949)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2011-01-23 19:22:47 UTC (rev 6950)
@@ -17,6 +17,9 @@
 # Add include dirs
 ########################################
 include(admCoreIncludes)
+# Add ffmpeg to resolve ADM_libavcodec to the actual name
+include(admFFmpegUtil)
+registerFFmpeg("${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6" "${AVIDEMUX_LIB_DIR}" 1)
 # Verify ADM_coreConfig is there
 if(NOT EXISTS "${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/ADM_coreConfig.h")
         MESSAGE(FATAL_ERROR "CMAKE_INSTALL_PREFIX does not contain include/avidemux/2.6/ADM_coreConfig.h (${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/ADM_coreConfig.h)")
@@ -104,6 +107,7 @@
 
 if (USE_VDPAU)
 	SET(commonLibs1 ${commonLibs1} ADM_coreVDPAU6)
+	SET(commonLibs1 ${commonLibs1} ADM_libavcodec ADM_libavutil)
 endif (USE_VDPAU)
 
 SET(commonLibs2



From mean at mail.berlios.de  Sun Jan 23 20:54:25 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 23 Jan 2011 20:54:25 +0100
Subject: [Avidemux-svn-commit] r6951 -
	branches/avidemux_2.6_branch_mean/avidemux
Message-ID: <20110123195426.23755481275@sheep.berlios.de>

Author: mean
Date: 2011-01-23 20:54:25 +0100 (Sun, 23 Jan 2011)
New Revision: 6951

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
Log:
[avidemux] Do not apply previous patch on win32

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2011-01-23 19:22:47 UTC (rev 6950)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2011-01-23 19:54:25 UTC (rev 6951)
@@ -17,9 +17,11 @@
 # Add include dirs
 ########################################
 include(admCoreIncludes)
-# Add ffmpeg to resolve ADM_libavcodec to the actual name
+# Add ffmpeg to resolve ADM_libavcodec to the actual name, needed for vdpau
+if (NOT WIN32)
 include(admFFmpegUtil)
 registerFFmpeg("${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6" "${AVIDEMUX_LIB_DIR}" 1)
+endif (NOT WIN32)
 # Verify ADM_coreConfig is there
 if(NOT EXISTS "${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/ADM_coreConfig.h")
         MESSAGE(FATAL_ERROR "CMAKE_INSTALL_PREFIX does not contain include/avidemux/2.6/ADM_coreConfig.h (${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/ADM_coreConfig.h)")



From mean at mail.berlios.de  Sun Jan 23 20:57:36 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 23 Jan 2011 20:57:36 +0100
Subject: [Avidemux-svn-commit] r6952 - in branches/avidemux_2.6_branch_mean:
	avidemux avidemux_plugins
Message-ID: <20110123195736.C64B3481275@sheep.berlios.de>

Author: mean
Date: 2011-01-23 20:57:36 +0100 (Sun, 23 Jan 2011)
New Revision: 6952

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt
Log:
[avidemux/plugin] re-enable explicit linking, fix plugins

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2011-01-23 19:54:25 UTC (rev 6951)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2011-01-23 19:57:36 UTC (rev 6952)
@@ -18,10 +18,8 @@
 ########################################
 include(admCoreIncludes)
 # Add ffmpeg to resolve ADM_libavcodec to the actual name, needed for vdpau
-if (NOT WIN32)
 include(admFFmpegUtil)
 registerFFmpeg("${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6" "${AVIDEMUX_LIB_DIR}" 1)
-endif (NOT WIN32)
 # Verify ADM_coreConfig is there
 if(NOT EXISTS "${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/ADM_coreConfig.h")
         MESSAGE(FATAL_ERROR "CMAKE_INSTALL_PREFIX does not contain include/avidemux/2.6/ADM_coreConfig.h (${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/ADM_coreConfig.h)")

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt	2011-01-23 19:54:25 UTC (rev 6951)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt	2011-01-23 19:57:36 UTC (rev 6952)
@@ -37,8 +37,6 @@
 LINK_DIRECTORIES("${AVIDEMUX_LIB_DIR}")
 INCLUDE_DIRECTORIES("${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6")
 
-include(admFFmpegUtil)
-registerFFmpeg("${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6" "${AVIDEMUX_LIB_DIR}" 1)
 
 IF (FRESH_BUILD)
 	MESSAGE("")
@@ -183,4 +181,4 @@
 # Packaging
 #
 include(admPackager)
-admPackager(pluginsPackage)
\ No newline at end of file
+admPackager(pluginsPackage)



From mean at mail.berlios.de  Mon Jan 24 19:56:30 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 24 Jan 2011 19:56:30 +0100
Subject: [Avidemux-svn-commit] r6953 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4
Message-ID: <20110124185630.B9BA3481290@sheep.berlios.de>

Author: mean
Date: 2011-01-24 19:56:30 +0100 (Mon, 24 Jan 2011)
New Revision: 6953

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
Log:
[mov] Partial support for hdv5 (incomplete), ref #118

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2011-01-23 19:57:36 UTC (rev 6952)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2011-01-24 18:56:30 UTC (rev 6953)
@@ -585,6 +585,14 @@
                                 //
                                 switch(entryName)
                                 {
+		 		  case MKFCCR('h','d','v','5'): // hdv5
+                                  {
+                                        commonPart(MPEG);
+                                        adm_atom hdv5(&son);
+                                        printf("Reading hdv5, got %s\n",fourCC::tostringBE(hdv5.getFCC()));
+                                        left=0;
+                                  }
+                                    break;
                                   case MKFCCR('m','j','p','b'):  //mjpegb
                                   {
                                         commonPart(MJPB);



From mean at mail.berlios.de  Mon Jan 24 19:57:44 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 24 Jan 2011 19:57:44 +0100
Subject: [Avidemux-svn-commit] r6954 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_videoCodec/src
	avidemux_core/ADM_coreVideoCodec/include
	avidemux_core/ADM_coreVideoCodec/src
Message-ID: <20110124185744.529F2481290@sheep.berlios.de>

Author: mean
Date: 2011-01-24 19:57:44 +0100 (Mon, 24 Jan 2011)
New Revision: 6954

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp
Log:
[core/app] Verify that core has been compiled with vdpau if the application has

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2011-01-24 18:56:30 UTC (rev 6953)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2011-01-24 18:57:44 UTC (rev 6954)
@@ -75,6 +75,13 @@
     void *draw;
     draw=UI_getDrawWidget();
     UI_getWindowInfo(draw,&xinfo );
+#ifdef USE_VDPAU
+    if( admCoreCodecSupports(ADM_CORE_CODEC_FEATURE_VDPAU)==false)
+    {
+        GUI_Error_HIG("Error","Core has been compiled without vdpau support, but the application has been compiled with it.\nInstallation mismatch");
+        vdpauWorking=false;
+    }
+#endif
     if(false==admVdpau::init(&xinfo)) return false;
     vdpauWorking=true;
     return true;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2011-01-24 18:56:30 UTC (rev 6953)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2011-01-24 18:57:44 UTC (rev 6954)
@@ -91,6 +91,15 @@
 decoders *ADM_getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp=0);
 /* This function is implemented in coreVideoCodec, it will return a codec if it can find a suitable one, NULL if not */
 decoders *ADM_coreCodecGetDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp=0);
+/**
 
+*/
+typedef enum 
+{
+    ADM_CORE_CODEC_FEATURE_VDPAU=1
+}ADM_CORE_CODEC_FEATURE;
 
+bool admCoreCodecSupports(ADM_CORE_CODEC_FEATURE feat);
+
+
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp	2011-01-24 18:56:30 UTC (rev 6953)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp	2011-01-24 18:57:44 UTC (rev 6954)
@@ -18,6 +18,7 @@
 #include "DIA_coreToolkit.h"
 #include "ADM_coreCodecMapping.h"
 
+
 /**
     \fn decoderFFSimple
 */
@@ -65,6 +66,19 @@
     if(id==CODEC_ID_NONE) return NULL;
     return new decoderFFSimple(w,h,fcc,extraDataLen,extraData,bpp);
 }
-
+/**
+    \fn admCoreCodecSupports
+    \brief returns true if core has been compiled with feature
+*/
+bool admCoreCodecSupports(ADM_CORE_CODEC_FEATURE feat)
+{
+#ifdef USE_VDPAU
+    if(feat==ADM_CORE_CODEC_FEATURE_VDPAU)
+    {
+        return true;
+    }
+#endif
+    return false;
+}
 // EOF
 



From mean at mail.berlios.de  Mon Jan 24 19:57:45 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 24 Jan 2011 19:57:45 +0100
Subject: [Avidemux-svn-commit] r6955 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src
Message-ID: <20110124185745.AB5DA481290@sheep.berlios.de>

Author: mean
Date: 2011-01-24 19:57:45 +0100 (Mon, 24 Jan 2011)
New Revision: 6955

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
Log:
[AnnexB] oops, return true as it always succeeds...

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp	2011-01-24 18:57:44 UTC (rev 6954)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp	2011-01-24 18:57:45 UTC (rev 6955)
@@ -199,12 +199,12 @@
     return true;
 }
 /**
-
+    \fn getExtraData
 */
 bool    ADM_videoStreamCopyFromAnnexB::getExtraData(uint32_t *extraLen, uint8_t **extraData) 
 {
     *extraData=myExtra;
     *extraLen=myExtraLen;
-    return 0;
+    return true;
 }
 // EOF



From mean at mail.berlios.de  Mon Jan 24 19:57:46 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 24 Jan 2011 19:57:46 +0100
Subject: [Avidemux-svn-commit] r6956 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4
Message-ID: <20110124185746.EB696481290@sheep.berlios.de>

Author: mean
Date: 2011-01-24 19:57:46 +0100 (Mon, 24 Jan 2011)
New Revision: 6956

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
Log:
[codec] support for hdv4 in mov, ref #118

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2011-01-24 18:57:45 UTC (rev 6955)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2011-01-24 18:57:46 UTC (rev 6956)
@@ -644,11 +644,21 @@
                                 //
                                 switch(entryName)
                                 {
+                                  case MKFCCR('h','d','v','5'): // hdv5
+                                  {
+                                        commonPart(MPEG);
+                                        adm_atom hdv5(&son);
+                                        printf("Reading hdv5, got %s\n",fourCC::tostringBE(hdv5.getFCC()));
+                                          
+                                        left=0;
+                                  }
+                                    break;
                                   case MKFCCR('m','j','p','b'):  //mjpegb
                                   {
                                         commonPart(MJPB);
                                         left=0;
                                   }
+                                  break;
                                   case MKFCCR('S','V','Q','1'):  //mjpegb
                                  {
                                        commonPart(SVQ1);



From mean at mail.berlios.de  Tue Jan 25 08:25:10 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 25 Jan 2011 08:25:10 +0100
Subject: [Avidemux-svn-commit] r6957 - in branches/avidemux_2.6_branch_mean:
	avidemux/common avidemux/common/ADM_audioFilter/src
	avidemux/qt4/ADM_userInterfaces/ADM_dialog
	avidemux/qt4/ADM_userInterfaces/ADM_gui
	avidemux_core/ADM_core/src avidemux_core/ADM_coreUI/src
	avidemux_plugins/ADM_demuxers/OpenDml cmake_compile_check
Message-ID: <20110125072510.59F5B4812E5@sheep.berlios.de>

Author: mean
Date: 2011-01-25 08:25:10 +0100 (Tue, 25 Jan 2011)
New Revision: 6957

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_normalize.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_cpuCap.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_memsupport.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp
   branches/avidemux_2.6_branch_mean/cmake_compile_check/os_bsd_check.cpp
Log:
[haiku] First set of haiku patches by diger

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_normalize.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_normalize.cpp	2011-01-24 18:57:46 UTC (rev 6956)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_normalize.cpp	2011-01-25 07:25:10 UTC (rev 6957)
@@ -30,7 +30,7 @@
 
 #include "ADM_coreAudio.h"
 
-#ifdef __WIN32
+#if defined (__WIN32) || defined (__HAIKU__)
 #define POW10(x)   pow(10,x)
 #elif defined(ADM_BSD_FAMILY)
 #define POW10(x) powf(10.0,x)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2011-01-24 18:57:46 UTC (rev 6956)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2011-01-25 07:25:10 UTC (rev 6957)
@@ -122,9 +122,11 @@
     oldTimeFrame=admPreview::getCurrentPts();
 	uint32_t priorityLevel;
 
+	#ifndef __HAIKU__
 	originalPriority = getpriority(PRIO_PROCESS, 0);
 	prefs->get(PRIORITY_PLAYBACK,&priorityLevel);
 	setpriority(PRIO_PROCESS, 0, ADM_getNiceValue(priorityLevel));
+	#endif
 
     stop_req = 0;
     playing = 1;
@@ -186,7 +188,9 @@
         }
         videoFilter=NULL; // it has been destroyed by the chain
        // done.
+	   #ifndef __HAIKU__
 	   setpriority(PRIO_PROCESS, 0, originalPriority);
+	   #endif
        return true;
 }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2011-01-24 18:57:46 UTC (rev 6956)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2011-01-25 07:25:10 UTC (rev 6957)
@@ -45,7 +45,11 @@
 
 #ifdef USE_SDL
 extern "C" {
+	#ifdef __HAIKU__
+	#include "SDL/SDL.h"
+	#else
 	#include "SDL.h"
+	#endif
 }
 
 #include "ADM_render/GUI_sdlRender.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2011-01-24 18:57:46 UTC (rev 6956)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_encoding.cpp	2011-01-25 07:25:10 UTC (rev 6957)
@@ -79,7 +79,9 @@
 	}
 #endif
 
+	#ifndef __HAIKU__
 	setpriority(PRIO_PROCESS, 0, ADM_getNiceValue(priorityLevel));
+	#endif
 }
 
 void encodingWindow::shutdownChanged(int state)

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui	2011-01-24 18:57:46 UTC (rev 6956)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui	2011-01-25 07:25:10 UTC (rev 6957)
@@ -7,10 +7,16 @@
    <rect>
     <x>0</x>
     <y>0</y>
-    <width>659</width>
-    <height>642</height>
+    <width>640</width>
+    <height>640</height>
    </rect>
   </property>
+  <property name="minimumSize">
+   <size>
+    <width>640</width>
+    <height>640</height>
+   </size>
+  </property>
   <property name="windowTitle">
    <string>Avidemux</string>
   </property>
@@ -99,8 +105,8 @@
     <rect>
      <x>0</x>
      <y>0</y>
-     <width>659</width>
-     <height>22</height>
+     <width>640</width>
+     <height>19</height>
     </rect>
    </property>
    <widget class="QMenu" name="menuHelp">
@@ -1266,8 +1272,8 @@
    </property>
    <property name="minimumSize">
     <size>
-     <width>120</width>
-     <height>0</height>
+     <width>136</width>
+     <height>137</height>
     </size>
    </property>
    <property name="features">

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_cpuCap.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_cpuCap.cpp	2011-01-24 18:57:46 UTC (rev 6956)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_cpuCap.cpp	2011-01-25 07:25:10 UTC (rev 6957)
@@ -14,7 +14,7 @@
 
 #if defined(__MINGW32__)
 #include <pthread.h>
-#elif defined(__APPLE__) || defined(ADM_BSD_FAMILY)
+#elif defined(__APPLE__) || defined(ADM_BSD_FAMILY) && !defined(__HAIKU__)
 #include <sys/types.h>
 #include <sys/sysctl.h>
 #else
@@ -148,7 +148,7 @@
 {
 #if defined(__MINGW32__)
     return pthread_num_processors_np();
-#elif defined(__APPLE__) || defined(ADM_BSD_FAMILY)
+#elif defined(__APPLE__) || defined(ADM_BSD_FAMILY) && !defined(__HAIKU__)
     int np;
 
     size_t length = sizeof(np);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_memsupport.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_memsupport.cpp	2011-01-24 18:57:46 UTC (rev 6956)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_memsupport.cpp	2011-01-25 07:25:10 UTC (rev 6957)
@@ -90,7 +90,7 @@
 
 void *ADM_alloc(size_t size)
 {
-#if defined(__APPLE__) || defined(__WIN64)
+#if defined(__APPLE__) || defined(__WIN64) || defined(__HAIKU__)
 	return malloc(size);
 #else
 	char *c;
@@ -127,7 +127,7 @@
 
 void ADM_dezalloc(void *ptr)
 {
-#if defined(__APPLE__) || defined(__WIN64)
+#if defined(__APPLE__) || defined(__WIN64) || defined(__HAIKU__)
 	if (!ptr)
 		return;
 
@@ -238,7 +238,7 @@
  */
 void *ADM_realloc(void *ptr, size_t newsize)
 {
-#if defined(__APPLE__) || defined(__WIN64)
+#if defined(__APPLE__) || defined(__WIN64) || defined(__HAIKU__)
 	if(!ptr)
 		return ADM_alloc(newsize);
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2011-01-24 18:57:46 UTC (rev 6956)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/src/DIA_encoding.cpp	2011-01-25 07:25:10 UTC (rev 6957)
@@ -28,7 +28,9 @@
 */
 DIA_encodingBase::DIA_encodingBase( uint64_t duration )
 {
+        #ifndef __HAIKU__
         _originalPriority=getpriority(PRIO_PROCESS, 0);
+        #endif
         _totalDurationUs=duration;
 #ifdef __WIN32
         _originalPriority=getpriority(PRIO_PROCESS, 0);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp	2011-01-24 18:57:46 UTC (rev 6956)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp	2011-01-25 07:25:10 UTC (rev 6957)
@@ -84,7 +84,9 @@
 							// Assume MAX_VOP Bframes maximum
 	ADM_assert(newIndex);
 
+	#ifndef __HAIKU__
 	uint32_t originalPriority = getpriority(PRIO_PROCESS, 0);
+	#endif
 	uint32_t priorityLevel;
 #if 0
 	prefs->get(PRIORITY_INDEXING,&priorityLevel);
@@ -222,7 +224,9 @@
 	printf("[Avi] Initial # of images : %"LU", now we have %"LU" \n",nbFrame,targetIndex);
 	nbFrame=targetIndex;
 
+	#ifndef __HAIKU__
 	setpriority(PRIO_PROCESS, 0, originalPriority);
+	#endif
 
 	return ret;
 }

Modified: branches/avidemux_2.6_branch_mean/cmake_compile_check/os_bsd_check.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake_compile_check/os_bsd_check.cpp	2011-01-24 18:57:46 UTC (rev 6956)
+++ branches/avidemux_2.6_branch_mean/cmake_compile_check/os_bsd_check.cpp	2011-01-25 07:25:10 UTC (rev 6957)
@@ -1,6 +1,6 @@
 int main(int a, char **b)
 {
-#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__NetBSD__) || defined(__OpenBSD__)
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__HAIKU__)
 	return 0;
 #else
 #error Unable to detect GCC for BSD family



From mean at mail.berlios.de  Tue Jan 25 20:07:21 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 25 Jan 2011 20:07:21 +0100
Subject: [Avidemux-svn-commit] r6958 -
	branches/avidemux_2.6_branch_mean/cmake
Message-ID: <20110125190721.1474D480BFC@sheep.berlios.de>

Author: mean
Date: 2011-01-25 20:07:20 +0100 (Tue, 25 Jan 2011)
New Revision: 6958

Modified:
   branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake
Log:
[ffmpeg] Re-enable aac decoder

Modified: branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake	2011-01-25 07:25:10 UTC (rev 6957)
+++ branches/avidemux_2.6_branch_mean/cmake/admFFmpegBuild.cmake	2011-01-25 19:07:20 UTC (rev 6958)
@@ -10,7 +10,7 @@
 set(FFMPEG_SOURCE_DIR "${FFMPEG_BASE_DIR}/source")
 set(FFMPEG_BINARY_DIR "${FFMPEG_BASE_DIR}/build")
 
-set(FFMPEG_DECODERS  ac3 eac3 adpcm_ima_amv  amv  bmp  cinepak  cyuv  dca  dvbsub  dvvideo  ffv1  ffvhuff  flv  fraps  h263  h264  huffyuv  mjpeg
+set(FFMPEG_DECODERS  aac ac3 eac3 adpcm_ima_amv  amv  bmp  cinepak  cyuv  dca  dvbsub  dvvideo  ffv1  ffvhuff  flv  fraps  h263  h264  huffyuv  mjpeg
 					 mjpegb  mpeg2video  mpeg4  msmpeg4v2  msmpeg4v3  msvideo1  nellymoser  png  qdm2  rawvideo  snow
 					 svq3  theora  tscc 
 					 vc1  vp3  vp6  vp6a  vp6f  wmav2  wmv1  wmv2  wmv3)



From mean at mail.berlios.de  Wed Jan 26 07:49:29 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 26 Jan 2011 07:49:29 +0100
Subject: [Avidemux-svn-commit] r6959 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110126064929.CBD38480C22@sheep.berlios.de>

Author: mean
Date: 2011-01-26 07:49:29 +0100 (Wed, 26 Jan 2011)
New Revision: 6959

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer_desc.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Config.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Plugin.cpp
Log:
[mp4v2] Add config and configure ui

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt	2011-01-25 19:07:20 UTC (rev 6958)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/CMakeLists.txt	2011-01-26 06:49:29 UTC (rev 6959)
@@ -4,6 +4,7 @@
 	muxerMp4v2.cpp
 	muxerMp4v2Audio.cpp
 	muxerMp4v2Video.cpp
+	muxerMp4v2Config.cpp
 )
 SUBDIRS(libmp4v2)
 

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer.conf	2011-01-26 06:49:29 UTC (rev 6959)
@@ -0,0 +1,2 @@
+uint32_t:optimize
+uint32_t:add_itunes_metadata

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer.h	2011-01-26 06:49:29 UTC (rev 6959)
@@ -0,0 +1,9 @@
+// Automatically generated, do not edit!
+#ifndef ADM_mp4v2_muxer_CONF_H
+#define ADM_mp4v2_muxer_CONF_H
+typedef struct {
+   uint32_t optimize;
+   uint32_t add_itunes_metadata;
+}mp4v2_muxer;
+#endif //mp4v2_muxer
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/mp4v2_muxer_desc.cpp	2011-01-26 06:49:29 UTC (rev 6959)
@@ -0,0 +1,6 @@
+// Automatically generated, do not edit!
+const ADM_paramList mp4v2_muxer_param[]={
+ {"optimize",offsetof( mp4v2_muxer,optimize),"uint32_t",ADM_param_uint32_t},
+ {"add_itunes_metadata",offsetof( mp4v2_muxer,add_itunes_metadata),"uint32_t",ADM_param_uint32_t},
+{NULL,0,NULL}
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-25 19:07:20 UTC (rev 6958)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-26 06:49:29 UTC (rev 6959)
@@ -32,6 +32,12 @@
 #define MP4_DEBUG MP4_DETAILS_ALL
 #endif
 
+mp4v2_muxer muxerConfig=
+{
+   1, // uint32_t optimize;
+   0  //uint32_t add_itunes_metadata;
+};
+
 /**
     \fn timeScale
     \brief convert our unit (us) to mp4v2 unit (90khz tick)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-25 19:07:20 UTC (rev 6958)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-26 06:49:29 UTC (rev 6959)
@@ -18,6 +18,8 @@
 #include "ADM_muxer.h"
 #include "ADM_audioClock.h"
 #include "mp4v2/mp4v2.h"
+#include "ADM_paramList.h"
+#include "mp4v2_muxer.h"
 /**
     \class mp4v2AudioPacket
 */

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Config.cpp (from rev 6958, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Plugin.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Config.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Config.cpp	2011-01-26 06:49:29 UTC (rev 6959)
@@ -0,0 +1,43 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+      
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_muxerInternal.h"
+#include "fourcc.h"
+#include "muxerMp4v2.h"
+#include "mp4v2_muxer.h"
+#include "DIA_factory.h"
+extern mp4v2_muxer muxerConfig;
+/**
+    \fn mp4v2Configure
+*/
+bool mp4v2Configure(void)
+{
+        uint32_t optimize=(uint32_t)muxerConfig.optimize;
+        uint32_t addItuneMetaData=(uint32_t)muxerConfig.add_itunes_metadata;
+
+        diaElemToggle   wOptimize(&optimize,"Optimize for streaming");
+        diaElemToggle   wItunes(&addItuneMetaData,"Add ipod metadata");
+
+        diaElem *tabs[]={&wOptimize,&wItunes};
+        if( diaFactoryRun(("MP4V2 Settings"),2,tabs))
+        {
+            muxerConfig.optimize=optimize;
+            muxerConfig.add_itunes_metadata=addItuneMetaData;
+            return true;
+        }
+        return false;
+}
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Plugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Plugin.cpp	2011-01-25 19:07:20 UTC (rev 6958)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Plugin.cpp	2011-01-26 06:49:29 UTC (rev 6959)
@@ -17,19 +17,17 @@
 #include "ADM_muxerInternal.h"
 #include "fourcc.h"
 #include "muxerMp4v2.h"
-
-bool mp4v2Configure(void)
-{
-    return true;
-}
+#include "mp4v2_muxer_desc.cpp"
+extern bool mp4v2Configure(void);
+extern mp4v2_muxer muxerConfig;
 ADM_MUXER_BEGIN( muxerMp4v2,
                     1,0,0,
                     "MP4V2",    // Internal name
                     "MP4V2 muxer plugin (c) Mean 2011",
                     "MP4 Muxer", // DIsplay name
                     mp4v2Configure,
-                    NULL, //template
-                    NULL
+                    mp4v2_muxer_param, //template
+                    &muxerConfig
                 );
 
 



From mean at mail.berlios.de  Wed Jan 26 07:49:30 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 26 Jan 2011 07:49:30 +0100
Subject: [Avidemux-svn-commit] r6960 - branches/avidemux_2.6_branch_mean
Message-ID: <20110126064930.EABEC480C22@sheep.berlios.de>

Author: mean
Date: 2011-01-26 07:49:30 +0100 (Wed, 26 Jan 2011)
New Revision: 6960

Added:
   branches/avidemux_2.6_branch_mean/bootStrapHaikuOS.bash
Log:
[haiku] Add boopstrap (thanks diger)

Added: branches/avidemux_2.6_branch_mean/bootStrapHaikuOS.bash
===================================================================
--- branches/avidemux_2.6_branch_mean/bootStrapHaikuOS.bash	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/bootStrapHaikuOS.bash	2011-01-26 06:49:30 UTC (rev 6960)
@@ -0,0 +1,212 @@
+#!/bin/bash
+# Bootstrapper to semi-automatically build avidemux from source on OSX
+# (c) Mean 2009
+
+# Specify the the directory where you want to install avidemux (a.k.a. the cmake_install_prefix)
+# like export BASE_INSTALL_DIR="<full_path_to_installation>". This can be /usr/local or /opt/local (macports) or /sw (Fink)
+export BASE_INSTALL_DIR="/boot/apps/Avidemux";
+
+packages_ext=""
+do_core=1
+do_cli=0
+do_gtk=0   # Note that gtk is no fully longer supported on OSX. You are on your own here
+do_qt4=1
+do_plugins=1
+debug=0
+fail()
+{
+        echo "** Failed at $1**"
+        exit 1
+}
+
+
+Process()
+{
+        export BUILDDIR=$1
+        export SOURCEDIR=$2
+        export EXTRA=$3
+        export DEBUG=""
+        BUILDER="Unix Makefiles"
+        if [ "x$debug" = "x1" ] ; then 
+                DEBUG="-DVERBOSE=1 -DCMAKE_BUILD_TYPE=Debug  "
+                BUILDDIR="${BUILDDIR}_debug"
+                BUILDER="CodeBlocks - Unix Makefiles"
+        fi
+        
+        echo "Building $BUILDDIR from $SOURCEDIR with EXTRA=<$EXTRA>, DEBUG=<$DEBUG>"
+        rm -Rf ./$BUILDDIR
+        mkdir $BUILDDIR || fail mkdir
+        cd $BUILDDIR 
+        cmake $PKG -DCMAKE_EDIT_COMMAND=mcedit -DCMAKE_CXX_FLAGS="-D__STDC_CONSTANT_MACROS" -DPTHREAD_INCLUDE_DIR=/boot/develop/headers/posix -DAVIDEMUX_SOURCE_DIR=$TOP -DCMAKE_INSTALL_PREFIX="$BASE_INSTALL_DIR" $EXTRA $DEBUG -G "$BUILDER" $SOURCEDIR || fail cmakeZ
+        make -j 2 > /tmp/log$BUILDDIR || fail make
+}
+printModule()
+{
+        value=$1
+        name=$2
+        if [ "x$value" = "x1" ]; then echo "    $name will be built"
+        else echo "     $name will be skipped"
+        fi
+        
+
+}
+config()
+{
+        echo "Build configuration :"
+        echo "******************* :"
+        echo "Build type :"
+        if [ "x$debug" = "x1" ] ; then echo   "Debug build"
+        else echo   "Release build"
+        fi
+        printModule $do_core Core
+        printModule $do_gtk Gtk
+        printModule $do_qt4 Qt4
+        printModule $do_cli Cli
+        printModule $do_plugins Plugins
+}
+usage()
+{
+        echo "Bootstrap avidemux 2.6:"
+        echo "***********************"
+        echo "  --help            : Print usage"
+        echo "  --tgz             : Build tgz packages"
+        echo "  --debug           : Switch debugging on"
+        echo "  --with-core       : Build core"
+        echo "  --without-core    : Dont build core"
+        echo "  --with-cli        : Build cli"
+        echo "  --without-cli     : Dont build cli"
+        echo "  --with-gtk        : Build gtk"
+        echo "  --without-gtk     : Dont build gtk"
+        echo "  --with-core       : Build core"
+        echo "  --without-qt4     : Dont build qt4"
+        echo "  --with-plugins    : Build plugins"
+        echo "  --without-plugins : Dont build plugins"
+        config 
+
+}
+# Could probably do it with getopts...
+while [ $# != 0 ] ;do
+        case "$1" in
+         -h|--help)
+             usage
+             exit 1
+             ;;
+         --debug)
+                debug=1
+                ;;
+         --pause)
+                pause_script=true
+                ;;
+         --tgz)
+                packages_ext=tar.gz
+                PKG="$PKG -DAVIDEMUX_PACKAGER=tgz"
+                ;;
+         --without-qt4)
+                do_qt4=0
+             ;;
+         --without-cli)
+                do_cli=0
+             ;;
+         --without-gtk)
+                do_gtk=0
+             ;;
+         --without-plugins)
+                do_plugins=0
+             ;;
+         --without-core)
+                do_core=0
+             ;;
+         --with-qt4)
+                do_qt4=1
+             ;;
+         --with-cli)
+                do_cli=1
+             ;;
+         --with-gtk)
+                do_gtk=1
+             ;;
+         --with-plugins)
+                do_plugins=1
+             ;;
+         --with-core)
+                do_core=1
+             ;;
+        *)
+                echo "unknown parameter $1"
+                usage
+                exit 1
+                ;;
+     esac
+     shift
+done
+config
+echo "**BootStrapping avidemux **"
+export TOP=$PWD
+export POSTFIX=""
+echo "Top dir : $TOP"
+if [ "x$debug" = "x1" ] ; then echo   
+POSTFIX="_debug"
+fi
+
+if [ "x$do_core" = "x1" ] ; then 
+        echo "** CORE **"
+        cd $TOP
+        Process buildCore ../avidemux_core
+        echo " Core needs to be installed, installing through  make install ...."
+        cd $TOP/buildCore${POSTFIX} &&  make install
+fi
+if [ "x$do_qt4" = "x1" ] ; then 
+        echo "** QT4 **"
+        cd $TOP
+        Process buildQt4 ../avidemux/qt4
+        echo " Qt4 needs to be installed, installing through  make install ...."
+        cd $TOP/buildQt4${POSTFIX} &&  make install
+fi
+if [ "x$do_cli" = "x1" ] ; then 
+        echo "** CLI **"
+        cd $TOP
+        Process buildCli ../avidemux/cli
+        echo " Cli needs to be installed, installing through  make install ...."
+        cd $TOP/buildCli${POSTFIX} &&  make install
+fi
+if [ "x$do_gtk" = "x1" ] ; then 
+        echo "** GTK **"
+        cd $TOP
+        Process buildGtk ../avidemux/gtk
+        echo " Gtk needs to be installed, installing through  make install ...."
+        cd $TOP/buildGtk${POSTFIX} &&  make install
+fi
+if [ "x$do_plugins" = "x1" ] ; then 
+        echo "** Plugins **"
+        cd $TOP
+        Process buildPluginsCommon ../avidemux_plugins -DPLUGIN_UI=COMMON
+fi
+if [ "x$do_plugins" = "x1" -a "x$do_qt4" = "x1" ] ; then 
+        echo "** Plugins Qt4 **"
+        cd $TOP
+        Process buildPluginsQt4 ../avidemux_plugins -DPLUGIN_UI=QT4
+fi
+if [ "x$do_plugins" = "x1" -a "x$do_gtk" = "x1" ] ; then 
+        echo "** Plugins Gtk **"
+        cd $TOP
+        Process buildPluginsGtk ../avidemux_plugins -DPLUGIN_UI=GTK
+fi
+if [ "x$do_plugins" = "x1" -a "x$do_cli" = "x1" ] ; then 
+        echo "** Plugins CLI **"
+        cd $TOP
+        Process buildPluginsCLI ../avidemux_plugins -DPLUGIN_UI=CLI
+fi
+
+echo "** Preparing debs **"
+cd $TOP
+if [ "x$packages_ext" = "x" ]; then 
+        echo "No packaging"
+else
+        echo "Preparing packages"
+        rm -Rf debs
+        mkdir debs
+        find . -name "*.$packages_ext" | grep -vi cpa | xargs cp -t debs
+        echo "** debs directory ready **"
+        ls -l debs
+fi
+echo "** ALL DONE **"



From mean at mail.berlios.de  Wed Jan 26 07:49:32 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 26 Jan 2011 07:49:32 +0100
Subject: [Avidemux-svn-commit] r6961 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110126064932.239B0480C22@sheep.berlios.de>

Author: mean
Date: 2011-01-26 07:49:31 +0100 (Wed, 26 Jan 2011)
New Revision: 6961

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
Log:
[mp4v2] Add optimize

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-26 06:49:30 UTC (rev 6960)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-26 06:49:31 UTC (rev 6961)
@@ -19,6 +19,7 @@
  ***************************************************************************/
 
 #include "ADM_default.h"
+#include "ADM_cpp.h"
 #include "fourcc.h"
 #include "muxerMp4v2.h"
 #include "ADM_codecType.h"
@@ -94,6 +95,7 @@
         in[0].data=videoBuffer[0];
         in[1].bufferSize=videoBufferSize;
         in[1].data=videoBuffer[1];
+        targetFileName=string(file);
 //------Verify everything is ok : Accept Mp4 & H264 for video, AAC for audio ----
         uint32_t fcc=vStream->getFCC();
         if(!isH264Compatible(fcc) && !isMpeg4Compatible(fcc))
@@ -215,6 +217,20 @@
 theEnd:
     closeUI();
     close();
+    if(muxerConfig.optimize && result==true)
+    {
+        string tmpTargetFileName=targetFileName+string(".tmp");
+        if(rename(targetFileName.c_str(),tmpTargetFileName.c_str()))
+        {
+            GUI_Error_HIG("","Cannot rename file (optimize)");
+            return false;
+        }
+        // Optimize
+        ADM_info("Optimizing...\n");
+        MP4Optimize( tmpTargetFileName.c_str(), targetFileName.c_str(), MP4_DETAILS_ERROR );
+        // delete
+        unlink(tmpTargetFileName.c_str());
+    }
     return result;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-26 06:49:30 UTC (rev 6960)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-26 06:49:31 UTC (rev 6961)
@@ -14,12 +14,13 @@
  ***************************************************************************/
 #ifndef ADM_MUXER_MP4V2
 #define ADM_MUXER_MP4V2
-
+#include "ADM_cpp.h"
 #include "ADM_muxer.h"
 #include "ADM_audioClock.h"
 #include "mp4v2/mp4v2.h"
 #include "ADM_paramList.h"
 #include "mp4v2_muxer.h"
+
 /**
     \class mp4v2AudioPacket
 */
@@ -46,6 +47,7 @@
             audioClock          *clock;
             mp4v2AudioPacket() {eos=false;nextWrite=0;clock=NULL;}
             ~mp4v2AudioPacket() {if(clock) delete clock;clock=NULL;}
+            
 
 };
 /**
@@ -65,6 +67,7 @@
         uint64_t        audioDelay; // In fact videoDelay, but must be added to all audioTrack
         bool            needToConvertFromAnnexB;
         uint8_t         *scratchBuffer;
+        string          targetFileName;
 protected: // video
         bool            initMpeg4(void);
         bool            initH264(void);



From mean at mail.berlios.de  Thu Jan 27 08:18:48 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 27 Jan 2011 08:18:48 +0100
Subject: [Avidemux-svn-commit] r6962 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_render avidemux/qt4/ADM_userInterfaces/ADM_gui
	avidemux_core/ADM_core/src
Message-ID: <20110127071849.34AE74812FF@sheep.berlios.de>

Author: mean
Date: 2011-01-27 08:18:48 +0100 (Thu, 27 Jan 2011)
New Revision: 6962

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_crashdump.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp
Log:
[os] 2nd part of haiku patches by diger

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp	2011-01-26 06:49:31 UTC (rev 6961)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp	2011-01-27 07:18:48 UTC (rev 6962)
@@ -25,8 +25,12 @@
 #undef HAVE_MALLOC_H
 #undef HAVE_STDINT_H
 #undef HAVE_SYS_TYPES_H
+#ifdef __HAIKU__
+#include "SDL/SDL.h"
+#else
 #include "SDL.h"
 #include "SDL_syswm.h"
+#endif
 }
 #include "ADM_default.h"
 #include "ADM_colorspace.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp	2011-01-26 06:49:31 UTC (rev 6961)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp	2011-01-27 07:18:48 UTC (rev 6962)
@@ -67,6 +67,9 @@
     rgbDataBuffer=NULL;
     return true;
 }
+#ifdef __HAIKU__
+ADM_Qvideo::ADM_Qvideo(QWidget *z) : QWidget(z)  {}
+#else
 ADM_Qvideo::ADM_Qvideo(QWidget *z) : QWidget(z) 
 {    
 setAttribute( Qt::WA_PaintOnScreen, true );
@@ -79,6 +82,7 @@
 setPalette( p );
 
 } //{setAutoFillBackground(false);}
+#endif // Haiku
 ADM_Qvideo::~ADM_Qvideo() {}
 
 void ADM_Qvideo::paintEvent(QPaintEvent *ev)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_crashdump.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_crashdump.cpp	2011-01-26 06:49:31 UTC (rev 6961)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_crashdump.cpp	2011-01-27 07:18:48 UTC (rev 6962)
@@ -281,7 +281,7 @@
 #else
 #include <signal.h>
 
-#ifndef __CYGWIN__
+#if !defined( __CYGWIN__) && !defined(__HAIKU__)
 #include <execinfo.h>
 #endif
 
@@ -324,7 +324,7 @@
 	if(mysaveFunction)
 		mysaveFunction();
 
-#ifndef __CYGWIN__
+#if !defined( __CYGWIN__) && !defined(__HAIKU__)
 	printf("\n*********** BACKTRACK **************\n");
 
 	count = backtrace(stack, 20);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp	2011-01-26 06:49:31 UTC (rev 6961)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp	2011-01-27 07:18:48 UTC (rev 6962)
@@ -37,6 +37,10 @@
 #ifdef __WIN32
 static const char *separator="\\";
 const char *ADM_DIR_NAME="\\avidemux6";
+#elif defined __HAIKU__
+static const char *separator="/";
+const char *ADM_DIR_NAME="/config/settings/avidemux6";
+
 #else
 static const char *separator="/";
 const char *ADM_DIR_NAME="/.avidemux6";



From mean at mail.berlios.de  Thu Jan 27 08:18:50 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 27 Jan 2011 08:18:50 +0100
Subject: [Avidemux-svn-commit] r6963 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_render avidemux_core/ADM_core/src
Message-ID: <20110127071850.8E0154812FF@sheep.berlios.de>

Author: mean
Date: 2011-01-27 08:18:50 +0100 (Thu, 27 Jan 2011)
New Revision: 6963

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp
Log:
[cosmetic] Remove dos end of line

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp	2011-01-27 07:18:48 UTC (rev 6962)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp	2011-01-27 07:18:50 UTC (rev 6963)
@@ -1,296 +1,296 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
-***************************************************************************/
-
-/***************************************************************************
-*                                                                         *
-*   This program is free software; you can redistribute it and/or modify  *
-*   it under the terms of the GNU General Public License as published by  *
-*   the Free Software Foundation; either version 2 of the License, or     *
-*   (at your option) any later version.                                   *
-*                                                                         *
-***************************************************************************///
-#include "config.h"
-
-#if defined(USE_SDL)
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-extern "C" {
-// get rid of warnings due to different definitions
-#undef HAVE_INTTYPES_H
-#undef HAVE_MALLOC_H
-#undef HAVE_STDINT_H
-#undef HAVE_SYS_TYPES_H
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+***************************************************************************/
+
+/***************************************************************************
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+***************************************************************************///
+#include "config.h"
+
+#if defined(USE_SDL)
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+extern "C" {
+// get rid of warnings due to different definitions
+#undef HAVE_INTTYPES_H
+#undef HAVE_MALLOC_H
+#undef HAVE_STDINT_H
+#undef HAVE_SYS_TYPES_H
 #ifdef __HAIKU__
-#include "SDL/SDL.h"
+#include "SDL/SDL.h"
 #else
-#include "SDL.h"
-#include "SDL_syswm.h"
+#include "SDL.h"
+#include "SDL_syswm.h"
 #endif
-}
-#include "ADM_default.h"
-#include "ADM_colorspace.h"
-#include "GUI_render.h"
-#include "GUI_accelRender.h"
-#include "GUI_sdlRender.h"
-
-
-#ifdef __APPLE__
-extern "C"
-{
-	void initSdlCocoaView(void* parent, int x, int y, int width, int height, bool carbonParent);
-	void destroyCocoaView(void);
-}
-#endif
-
-//******************************************
-static uint8_t sdl_running=0;
-static SDL_Overlay *sdl_overlay=NULL;
-static SDL_Surface *sdl_display=NULL;
-static SDL_Rect disp;
-#ifdef __WIN32
-HWND sdlWin32;
-#endif
+}
+#include "ADM_default.h"
+#include "ADM_colorspace.h"
+#include "GUI_render.h"
+#include "GUI_accelRender.h"
+#include "GUI_sdlRender.h"
+
+
+#ifdef __APPLE__
+extern "C"
+{
+	void initSdlCocoaView(void* parent, int x, int y, int width, int height, bool carbonParent);
+	void destroyCocoaView(void);
+}
+#endif
+
+//******************************************
+static uint8_t sdl_running=0;
+static SDL_Overlay *sdl_overlay=NULL;
+static SDL_Surface *sdl_display=NULL;
+static SDL_Rect disp;
+#ifdef __WIN32
+HWND sdlWin32;
+#endif
 /**
     \fn sdlRender
-*/
-sdlRender::sdlRender( void)
-{
+*/
+sdlRender::sdlRender( void)
+{
         useYV12=true;
-        ADM_info("[SDL] Init rendered\n");
+        ADM_info("[SDL] Init rendered\n");
 }
 /**
     \fn stop
-*/
-bool sdlRender::stop( void)
-{
-        if(sdl_overlay)
-        {
-                SDL_FreeYUVOverlay(sdl_overlay);
-        }
-        if(sdl_display)
-        {
-        		SDL_UnlockSurface(sdl_display);
-                SDL_FreeSurface(sdl_display);
-        }
-        if(sdl_running)
-        {
-                SDL_QuitSubSystem(SDL_INIT_VIDEO);
-
-#ifdef __APPLE__
-				destroyCocoaView();
-#endif
-        }
-        sdl_running=0;
-        sdl_overlay=NULL;
-        sdl_display=NULL;
+*/
+bool sdlRender::stop( void)
+{
+        if(sdl_overlay)
+        {
+                SDL_FreeYUVOverlay(sdl_overlay);
+        }
+        if(sdl_display)
+        {
+        		SDL_UnlockSurface(sdl_display);
+                SDL_FreeSurface(sdl_display);
+        }
+        if(sdl_running)
+        {
+                SDL_QuitSubSystem(SDL_INIT_VIDEO);
+
+#ifdef __APPLE__
+				destroyCocoaView();
+#endif
+        }
+        sdl_running=0;
+        sdl_overlay=NULL;
+        sdl_display=NULL;
         ADM_info("[SDL] Video subsystem closed and destroyed\n");
-        return true;
+        return true;
 }
 /**
     \fn init
-*/
-bool sdlRender::init( GUI_WindowInfo * window, uint32_t w, uint32_t h,renderZoom zoom)
-{
-	ADM_info("[SDL] Initialising video subsystem\n");
-
-#ifdef __APPLE__
-	if (window->width > w && window->height > h)
-	{
-		ADM_info("[SDL] Disabling acceleration.  Zoom increase not supported on Mac\n");
-		return 0;
-	}
-#endif
-
-	int bpp;
-	int flags;
-    baseInit(w,h,zoom);
-    // Ask for the position of the drawing window at start
-    disp.w=w;
-    disp.h=h;
-    disp.x=0;
-    disp.y=0;
-
-
-    // Hack to get SDL to use GTK window, ugly but works
-#if !defined(__WIN32) && !defined(__APPLE__)
-	char SDL_windowhack[32];
-    int winId=(int)window->window;
-
-    sprintf(SDL_windowhack,"SDL_WINDOWID=%d",winId);
-    putenv(SDL_windowhack);
-#endif
-
-    if (SDL_InitSubSystem(SDL_INIT_VIDEO) < 0)
-    {
-		ADM_warning("[SDL] FAILED initialising video subsystem\n");
-		ADM_warning("[SDL] ERROR: %s\n", SDL_GetError());
-
-        return 0;
-    }
-    ADM_info("SDL subsystem init ok\n");
-    // Do it twice as the 1st time does not work
-    // Hack to get SDL to use GTK window, ugly but works
-#if !defined(__WIN32) && !defined(__APPLE__)
-    putenv(SDL_windowhack);
-    SDL_QuitSubSystem(SDL_INIT_VIDEO);
-    if (SDL_InitSubSystem(SDL_INIT_VIDEO) < 0)
-    {
-                ADM_warning("[SDL] FAILED initialising video subsystem\n");
-                ADM_warning("[SDL] ERROR: %s\n", SDL_GetError());
-                return 0;
-    }
-#endif
-
-    sdl_running=1;
-    flags = SDL_ANYFORMAT | SDL_HWPALETTE | SDL_HWSURFACE | SDL_NOFRAME;
-    bpp= SDL_VideoModeOK( w, h,  32, flags );
-
-#ifdef __WIN32
-	// SDL window is created and displayed before we get a chance to set the parent.
-	// Therefore, align the SDL overlay with the client area before it is displayed.
-	POINT screenPoint = {};
-	char origin[43];
-
-	ClientToScreen((HWND)window->display, &screenPoint);
-	snprintf(origin, 43, "SDL_VIDEO_WINDOW_POS=%i,%i", screenPoint.x, screenPoint.y);
-	putenv(origin);
-#endif
-
-#ifdef __APPLE__
-	void* parent;
-
-	if (window->display)
-		// Carbon parent (Qt4)
-		parent = window->display;
-	else
-		// Cocoa parent (GTK)
-		parent = (void*)window->window;
-
-	if (parent)
-		// Create Cocoa view and attach to Carbon window using custom Objective-C function.
-		// It's a retarded way of doing things but that's what Apple has imposed...
-		initSdlCocoaView(parent, window->x, window->y, window->width, window->height, (window->display != NULL));
-#endif
-
-	// SDL will resize our window to width and height passed to SetVideoMode.
+*/
+bool sdlRender::init( GUI_WindowInfo * window, uint32_t w, uint32_t h,renderZoom zoom)
+{
+	ADM_info("[SDL] Initialising video subsystem\n");
+
+#ifdef __APPLE__
+	if (window->width > w && window->height > h)
+	{
+		ADM_info("[SDL] Disabling acceleration.  Zoom increase not supported on Mac\n");
+		return 0;
+	}
+#endif
+
+	int bpp;
+	int flags;
+    baseInit(w,h,zoom);
+    // Ask for the position of the drawing window at start
+    disp.w=w;
+    disp.h=h;
+    disp.x=0;
+    disp.y=0;
+
+
+    // Hack to get SDL to use GTK window, ugly but works
+#if !defined(__WIN32) && !defined(__APPLE__)
+	char SDL_windowhack[32];
+    int winId=(int)window->window;
+
+    sprintf(SDL_windowhack,"SDL_WINDOWID=%d",winId);
+    putenv(SDL_windowhack);
+#endif
+
+    if (SDL_InitSubSystem(SDL_INIT_VIDEO) < 0)
+    {
+		ADM_warning("[SDL] FAILED initialising video subsystem\n");
+		ADM_warning("[SDL] ERROR: %s\n", SDL_GetError());
+
+        return 0;
+    }
+    ADM_info("SDL subsystem init ok\n");
+    // Do it twice as the 1st time does not work
+    // Hack to get SDL to use GTK window, ugly but works
+#if !defined(__WIN32) && !defined(__APPLE__)
+    putenv(SDL_windowhack);
+    SDL_QuitSubSystem(SDL_INIT_VIDEO);
+    if (SDL_InitSubSystem(SDL_INIT_VIDEO) < 0)
+    {
+                ADM_warning("[SDL] FAILED initialising video subsystem\n");
+                ADM_warning("[SDL] ERROR: %s\n", SDL_GetError());
+                return 0;
+    }
+#endif
+
+    sdl_running=1;
+    flags = SDL_ANYFORMAT | SDL_HWPALETTE | SDL_HWSURFACE | SDL_NOFRAME;
+    bpp= SDL_VideoModeOK( w, h,  32, flags );
+
+#ifdef __WIN32
+	// SDL window is created and displayed before we get a chance to set the parent.
+	// Therefore, align the SDL overlay with the client area before it is displayed.
+	POINT screenPoint = {};
+	char origin[43];
+
+	ClientToScreen((HWND)window->display, &screenPoint);
+	snprintf(origin, 43, "SDL_VIDEO_WINDOW_POS=%i,%i", screenPoint.x, screenPoint.y);
+	putenv(origin);
+#endif
+
+#ifdef __APPLE__
+	void* parent;
+
+	if (window->display)
+		// Carbon parent (Qt4)
+		parent = window->display;
+	else
+		// Cocoa parent (GTK)
+		parent = (void*)window->window;
+
+	if (parent)
+		// Create Cocoa view and attach to Carbon window using custom Objective-C function.
+		// It's a retarded way of doing things but that's what Apple has imposed...
+		initSdlCocoaView(parent, window->x, window->y, window->width, window->height, (window->display != NULL));
+#endif
+
+	// SDL will resize our window to width and height passed to SetVideoMode.
 	// This is fine until we use zoomed views so pass window dimensions instead.
-    ADM_info("SDL setting video mode %d,%d\n",(int)window->width,(int)window->height);
-	sdl_display= SDL_SetVideoMode(window->width,window->height, bpp, flags);
-
-    if (!sdl_display)
-    {
-        stop();
-        ADM_warning("[SDL] Cannot create surface\n");
-		ADM_warning("[SDL] ERROR: %s\n", SDL_GetError());
-        return 0;
-    }
-
-    SDL_LockSurface(sdl_display);
-
-#ifdef __WIN32
-	struct SDL_SysWMinfo wmInfo;
-	SDL_VERSION(&wmInfo.version);
-
-	if (-1 != SDL_GetWMInfo(&wmInfo))
-	{
-		sdlWin32 = wmInfo.window;
-
-		// Make SDL window a child to prevent it from gaining focus
-		int windowFlags = GetWindowLongPtr(sdlWin32, GWL_STYLE);
-
-		SetWindowLongPtr(sdlWin32, GWL_STYLE, (windowFlags & ~WS_POPUP) | WS_CHILD);
-
-		// Set the SDL window's parent to the main window and reposition
-		SetParent(sdlWin32, (HWND)window->display);
-		SetWindowPos(sdlWin32, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
-
-		// The SDL window stole focus before it was made a child, so set focus back to the main window
-		SetFocus((HWND)window->display);
-	}
-	else
-	{
-		printf("[SDL] Reparenting failed\n");
-	}
-#endif
-
-        int cspace;
-
-        if(useYV12) cspace=SDL_YV12_OVERLAY;
-            else    cspace=SDL_YUY2_OVERLAY;
+    ADM_info("SDL setting video mode %d,%d\n",(int)window->width,(int)window->height);
+	sdl_display= SDL_SetVideoMode(window->width,window->height, bpp, flags);
+
+    if (!sdl_display)
+    {
+        stop();
+        ADM_warning("[SDL] Cannot create surface\n");
+		ADM_warning("[SDL] ERROR: %s\n", SDL_GetError());
+        return 0;
+    }
+
+    SDL_LockSurface(sdl_display);
+
+#ifdef __WIN32
+	struct SDL_SysWMinfo wmInfo;
+	SDL_VERSION(&wmInfo.version);
+
+	if (-1 != SDL_GetWMInfo(&wmInfo))
+	{
+		sdlWin32 = wmInfo.window;
+
+		// Make SDL window a child to prevent it from gaining focus
+		int windowFlags = GetWindowLongPtr(sdlWin32, GWL_STYLE);
+
+		SetWindowLongPtr(sdlWin32, GWL_STYLE, (windowFlags & ~WS_POPUP) | WS_CHILD);
+
+		// Set the SDL window's parent to the main window and reposition
+		SetParent(sdlWin32, (HWND)window->display);
+		SetWindowPos(sdlWin32, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
+
+		// The SDL window stole focus before it was made a child, so set focus back to the main window
+		SetFocus((HWND)window->display);
+	}
+	else
+	{
+		printf("[SDL] Reparenting failed\n");
+	}
+#endif
+
+        int cspace;
+
+        if(useYV12) cspace=SDL_YV12_OVERLAY;
+            else    cspace=SDL_YUY2_OVERLAY;
         //_______________________________________________________
-        ADM_info("Creating overlay\n");
-        sdl_overlay=SDL_CreateYUVOverlay((w),(h), cspace, sdl_display);
-
-		// DirectX may fail but overlay still created.
-		// Not a showstopper but log failure.
-		if (strlen(SDL_GetError()))
-		{
-			ADM_warning("[SDL] ERROR: %s\n", SDL_GetError());
-		}
-
-        if(!sdl_overlay)
-        {
-			stop();
-			ADM_warning("[SDL] Cannot create SDL overlay\n");
-			ADM_warning("[SDL] ERROR: %s\n", SDL_GetError());
-
-			return 0;
-        }
-
-        printf("[SDL] Overlay created; type: %d, planes: %d, pitch: %d\n", sdl_overlay->hw_overlay, sdl_overlay->planes, sdl_overlay->pitches[0]);
-
-        if(!sdl_overlay->hw_overlay)
-            printf("[SDL] Hardware acceleration disabled\n");
-
+        ADM_info("Creating overlay\n");
+        sdl_overlay=SDL_CreateYUVOverlay((w),(h), cspace, sdl_display);
+
+		// DirectX may fail but overlay still created.
+		// Not a showstopper but log failure.
+		if (strlen(SDL_GetError()))
+		{
+			ADM_warning("[SDL] ERROR: %s\n", SDL_GetError());
+		}
+
+        if(!sdl_overlay)
+        {
+			stop();
+			ADM_warning("[SDL] Cannot create SDL overlay\n");
+			ADM_warning("[SDL] ERROR: %s\n", SDL_GetError());
+
+			return 0;
+        }
+
+        printf("[SDL] Overlay created; type: %d, planes: %d, pitch: %d\n", sdl_overlay->hw_overlay, sdl_overlay->planes, sdl_overlay->pitches[0]);
+
+        if(!sdl_overlay->hw_overlay)
+            printf("[SDL] Hardware acceleration disabled\n");
+
         if(!useYV12)
         {
-          // Create YV12->YUY2 here!
-        }
-		ADM_info("[SDL] Video subsystem initalised successfully\n");
-
-        return 1;
-}
+          // Create YV12->YUY2 here!
+        }
+		ADM_info("[SDL] Video subsystem initalised successfully\n");
 
+        return 1;
+}
+
 /**
     \fn displayImage
-*/
-bool sdlRender::displayImage(ADMImage *pic)
-{
-#ifdef __WIN32
-	// DirectX playback doesn't refresh correctly if the parent window is moved.
-	// Detect when the parent window has moved and force a coordinate update.
-	if (strcmp(getenv("SDL_VIDEODRIVER"), "directx") == 0)
-	{
-		static RECT lastPos;
-
-		RECT currentPos;
-		GetWindowRect(sdlWin32, &currentPos);
-
-		if (currentPos.left != lastPos.left || currentPos.top != lastPos.top)
-		{
-			// By default SetWindowPos doesn't work if the new coordinates are the same as the
-			// current so use SWP_FRAMECHANGED to force an update.
-			SetWindowPos(sdlWin32, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
-			lastPos = currentPos;
-		}
-	}
-#endif
-#warning FIXME
+*/
+bool sdlRender::displayImage(ADMImage *pic)
+{
+#ifdef __WIN32
+	// DirectX playback doesn't refresh correctly if the parent window is moved.
+	// Detect when the parent window has moved and force a coordinate update.
+	if (strcmp(getenv("SDL_VIDEODRIVER"), "directx") == 0)
+	{
+		static RECT lastPos;
+
+		RECT currentPos;
+		GetWindowRect(sdlWin32, &currentPos);
+
+		if (currentPos.left != lastPos.left || currentPos.top != lastPos.top)
+		{
+			// By default SetWindowPos doesn't work if the new coordinates are the same as the
+			// current so use SWP_FRAMECHANGED to force an update.
+			SetWindowPos(sdlWin32, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
+			lastPos = currentPos;
+		}
+	}
+#endif
+#warning FIXME
 int pitch;
 int w=imageWidth;
-int h=imageHeight;
+int h=imageHeight;
 int page=w*h;
-
-        ADM_assert(sdl_overlay);
-        SDL_LockYUVOverlay(sdl_overlay);
-        pitch=sdl_overlay->pitches[0];
-//	printf("SDL: new pitch :%d\n",pitch);
-        if(useYV12)
+
+        ADM_assert(sdl_overlay);
+        SDL_LockYUVOverlay(sdl_overlay);
+        pitch=sdl_overlay->pitches[0];
+//	printf("SDL: new pitch :%d\n",pitch);
+        if(useYV12)
         {
             uint32_t imagePitch[3];
             uint8_t  *imagePtr[3];
@@ -299,37 +299,37 @@
             //
             BitBlit(sdl_overlay->pixels[0],sdl_overlay->pitches[0],imagePtr[0],imagePitch[0],w, h);
             BitBlit(sdl_overlay->pixels[1],sdl_overlay->pitches[1],imagePtr[1],imagePitch[1],w/2, h/2);
-            BitBlit(sdl_overlay->pixels[2],sdl_overlay->pitches[2],imagePtr[2],imagePitch[2],w/2, h/2);
-
+            BitBlit(sdl_overlay->pixels[2],sdl_overlay->pitches[2],imagePtr[2],imagePitch[2],w/2, h/2);
+
         }else
-
+
         { // YUYV
-#if 0
-	        scaler->changeWidthHeight(w,h);
-	        if(pitch==2*w)
-	        {
-	            scaler->convert(pic,sdl_overlay->pixels[0]);
-	        }
-	        else
-	        {
+#if 0
+	        scaler->changeWidthHeight(w,h);
+	        if(pitch==2*w)
+	        {
+	            scaler->convert(pic,sdl_overlay->pixels[0]);
+	        }
+	        else
+	        {
 	            scaler->convert(pic,decoded);
-                BitBlit(sdl_overlay->pixels[0],sdl_overlay->pitches[0],decoded,2*w,h);
+                BitBlit(sdl_overlay->pixels[0],sdl_overlay->pitches[0],decoded,2*w,h);
 	        }
 #else
             ADM_warning("[SDL] YUYV disabled\n");
             return false;
-#endif
-        }
-       
-        disp.w=displayWidth;
-        disp.h=displayHeight;
-        disp.x=0;
-        disp.y=0;
-
-        SDL_UnlockYUVOverlay(sdl_overlay);
-        SDL_DisplayYUVOverlay(sdl_overlay,&disp);
-
-        return 1;
+#endif
+        }
+       
+        disp.w=displayWidth;
+        disp.h=displayHeight;
+        disp.x=0;
+        disp.y=0;
+
+        SDL_UnlockYUVOverlay(sdl_overlay);
+        SDL_DisplayYUVOverlay(sdl_overlay,&disp);
+
+        return 1;
 }
 
 /**
@@ -341,69 +341,69 @@
         calcDisplayFromZoom(newZoom);
         currentZoom=newZoom;
         return true;
-}
+}
 /**
     \fn initSdl
-*/
-void initSdl(int videoDevice)
-{
-	printf("\n");
-	quitSdl();
-
-    int sdl_version = (SDL_Linked_Version()->major*1000)+(SDL_Linked_Version()->minor*100) + (SDL_Linked_Version()->patch);
-
-    printf("[SDL] Version: %u.%u.%u\n",SDL_Linked_Version()->major, SDL_Linked_Version()->minor, SDL_Linked_Version()->patch);
-
-#ifdef __WIN32
-	if(videoDevice == RENDER_DIRECTX)
-	{
-		printf("[SDL] Setting video driver to Microsoft DirectX\n");
-		putenv("SDL_VIDEODRIVER=directx");
-	}
-	else
-	{
-		printf("[SDL] Setting video driver to Microsoft Windows GDI\n");
-		putenv("SDL_VIDEODRIVER=windib");
-	}
-#endif
-
-	uint32_t sdlInitFlags;
-
-	if (sdl_version > 1209)
-		sdlInitFlags = SDL_INIT_EVERYTHING;
-	else
-		sdlInitFlags = 0;
-
-	printf("[SDL] Initialisation ");
-
-	if (SDL_Init(sdlInitFlags) == 0)
-	{
-		printf("succeeded\n");
-
-		char driverName[100];
-
-		if (SDL_VideoDriverName(driverName, 100) != NULL)
-		{
-			printf("[SDL] Video Driver: %s\n", driverName);
-		}
-	}
-	else
-	{
-		printf("FAILED\n");
-		printf("[SDL] ERROR: %s\n", SDL_GetError());
-	}
-
-	printf("\n");
-}
+*/
+void initSdl(int videoDevice)
+{
+	printf("\n");
+	quitSdl();
+
+    int sdl_version = (SDL_Linked_Version()->major*1000)+(SDL_Linked_Version()->minor*100) + (SDL_Linked_Version()->patch);
+
+    printf("[SDL] Version: %u.%u.%u\n",SDL_Linked_Version()->major, SDL_Linked_Version()->minor, SDL_Linked_Version()->patch);
+
+#ifdef __WIN32
+	if(videoDevice == RENDER_DIRECTX)
+	{
+		printf("[SDL] Setting video driver to Microsoft DirectX\n");
+		putenv("SDL_VIDEODRIVER=directx");
+	}
+	else
+	{
+		printf("[SDL] Setting video driver to Microsoft Windows GDI\n");
+		putenv("SDL_VIDEODRIVER=windib");
+	}
+#endif
+
+	uint32_t sdlInitFlags;
+
+	if (sdl_version > 1209)
+		sdlInitFlags = SDL_INIT_EVERYTHING;
+	else
+		sdlInitFlags = 0;
+
+	printf("[SDL] Initialisation ");
+
+	if (SDL_Init(sdlInitFlags) == 0)
+	{
+		printf("succeeded\n");
+
+		char driverName[100];
+
+		if (SDL_VideoDriverName(driverName, 100) != NULL)
+		{
+			printf("[SDL] Video Driver: %s\n", driverName);
+		}
+	}
+	else
+	{
+		printf("FAILED\n");
+		printf("[SDL] ERROR: %s\n", SDL_GetError());
+	}
+
+	printf("\n");
+}
 /**
     \fn quitSdl
-*/
-void quitSdl(void)
-{
-	if (SDL_WasInit(SDL_INIT_EVERYTHING))
-	{
-		printf("[SDL] Quitting...\n");
-		SDL_Quit();
-	}
-}
-#endif
+*/
+void quitSdl(void)
+{
+	if (SDL_WasInit(SDL_INIT_EVERYTHING))
+	{
+		printf("[SDL] Quitting...\n");
+		SDL_Quit();
+	}
+}
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp	2011-01-27 07:18:48 UTC (rev 6962)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp	2011-01-27 07:18:50 UTC (rev 6963)
@@ -1,24 +1,24 @@
-/***************************************************************************
-                    
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <dirent.h>
-#include <errno.h>
-#include <sys/stat.h>
+/***************************************************************************
+                    
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dirent.h>
+#include <errno.h>
+#include <sys/stat.h>
 #include <unistd.h>
 
 #if defined(__APPLE__)
@@ -30,660 +30,660 @@
   #include <shlobj.h>
  #endif
 #endif
-
-#include "ADM_default.h"
-
-
-#ifdef __WIN32
-static const char *separator="\\";
-const char *ADM_DIR_NAME="\\avidemux6";
+
+#include "ADM_default.h"
+
+
+#ifdef __WIN32
+static const char *separator="\\";
+const char *ADM_DIR_NAME="\\avidemux6";
 #elif defined __HAIKU__
 static const char *separator="/";
 const char *ADM_DIR_NAME="/config/settings/avidemux6";
 
-#else
-static const char *separator="/";
-const char *ADM_DIR_NAME="/.avidemux6";
-#endif
-
-static char ADM_basedir[1024] = {0};
-static char *ADM_jobdir = NULL;
-static char *ADM_customdir = NULL;
-static int baseDirDone = 0;
-
-#undef fread
-#undef fwrite
-#undef fopen
-#undef fclose
-
-#ifdef __WIN32
-extern int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString);
-extern int wideCharStringToUtf8(const wchar_t *wideCharString, int wideCharStringLength, char *utf8String);
-#endif
-
-size_t ADM_fread (void *ptr, size_t size, size_t n, FILE *sstream)
-{
-	return fread(ptr,size,n,sstream);
-}
-
-size_t ADM_fwrite(const void *ptr, size_t size, size_t n, FILE *sstream)
-{
-	return fwrite(ptr,size,n,sstream);
-}
-
-FILE *ADM_fopen(const char *file, const char *mode)
-{
-#ifdef __MINGW32__
-	// Override fopen to handle Unicode filenames and to ensure exclusive access when initially writing to a file.
-	int fileNameLength = utf8StringToWideChar(file, -1, NULL);
-	wchar_t wcFile[fileNameLength];
-	int creation = 0, access = 0;
-	HANDLE hFile;
-
-	utf8StringToWideChar(file, -1, wcFile);
-
-	if (strchr(mode, 'w'))
-	{
-		creation = CREATE_ALWAYS;
-		access = GENERIC_WRITE;
-
-		if (strchr(mode, '+'))
-			access |= GENERIC_READ;
-	}
-	else if (strchr(mode, 'r'))
-	{
-		creation = OPEN_EXISTING;
-		access = GENERIC_READ;
-
-		if (strchr(mode, '+'))
-			access = GENERIC_WRITE;
-	}
-	else if (strchr(mode, 'a'))
-	{
-		creation = OPEN_ALWAYS;
-		access = GENERIC_WRITE;
-
-		if (strchr(mode, '+'))
-			access |= GENERIC_READ;
-	}
-
-	if (creation & GENERIC_WRITE)
-	{
-		hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
-
-		if (hFile == INVALID_HANDLE_VALUE)
-			return NULL;
-		else
-			CloseHandle(hFile);
-	}
-
-	hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
-
-	if (hFile == INVALID_HANDLE_VALUE)
-		return NULL;
-	else
-		return _fdopen(_open_osfhandle((intptr_t)hFile, 0), mode);
-#else
-	return fopen(file, mode);
-#endif
-}
-
-#if __WIN32
-extern "C"
-{
-	// libavformat uses open (in the file_open function) so we need to override that too.
-	// Following the same rules as ADM_fopen.
-	int ADM_open(const char *path, int oflag, ...)
-	{
-		int fileNameLength = utf8StringToWideChar(path, -1, NULL);
-		wchar_t wcFile[fileNameLength];
-		int creation = 0, access = 0;
-		HANDLE hFile;
-
-		utf8StringToWideChar(path, -1, wcFile);
-
-		if (oflag & O_WRONLY || oflag & O_RDWR)
-		{
-			access = GENERIC_WRITE;
-
-			if (oflag & O_RDWR)
-				access |= GENERIC_READ;
-
-			if (oflag & O_CREAT)
-			{
-				if (oflag & O_EXCL)
-					creation = CREATE_NEW;
-				else if (oflag & O_TRUNC)
-					creation = CREATE_ALWAYS;
-				else
-					creation = OPEN_ALWAYS;
-			}
-			else if (oflag & O_TRUNC)
-				creation = TRUNCATE_EXISTING;
-		}
-		else if (oflag & O_RDONLY)
-			creation = OPEN_EXISTING;
-
-		if (creation & GENERIC_WRITE)
-		{
-			hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
-
-			if (hFile == INVALID_HANDLE_VALUE)
-				return -1;
-			else
-				CloseHandle(hFile);
-		}
-
-		hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
-
-		if (hFile == INVALID_HANDLE_VALUE)
-			return -1;
-		else
-			return _open_osfhandle((intptr_t)hFile, oflag);
-	}
-}
-#endif
-
-int ADM_fclose(FILE *file)
-{
-	return fclose(file); 
-}
-
-/*
-      Get the  directory where jobs are stored
-******************************************************/
-char *ADM_getCustomDir(void)
-{
-	if (ADM_customdir)
-		return ADM_customdir;
-
-	ADM_customdir = ADM_getHomeRelativePath("custom");
-
-	if (!ADM_mkdir(ADM_customdir))
-	{
-		printf("can't create custom directory (%s).\n", ADM_customdir);
-		return NULL;
-	}
-
-	return ADM_customdir;
-}
-
-/*
-      Get the  directory where jobs are stored
-******************************************************/
-char *ADM_getJobDir(void)
-{
-	if (ADM_jobdir)
-		return ADM_jobdir;
-
-	ADM_jobdir = ADM_getHomeRelativePath("jobs");
-
-	if (!ADM_mkdir(ADM_jobdir))
-	{
-		printf("can't create custom directory (%s).\n", ADM_jobdir);
-		return NULL;
-	}
-
-	return ADM_jobdir;
-}
-
-/**
- * 	\fn ADM_getRelativePath
- */
-static char *ADM_getRelativePath(const char *base0,const char *base1, const char *base2,const char *base3)
-{
-	char *result;
-	int length = strlen(base1);
-
-	if (base2)
-		length += strlen(base2);
-
-	if (base3)
-		length += strlen(base3);
-
-	length += strlen(base0);
-	length += 5; // Slashes + end 0
-	result = (char *)new char [length];
-	strcpy(result, base0);
-	strcat(result, separator);
-
-	strcat(result, base1);
-	strcat(result, separator);
-
-	if (base2)
-	{
-		strcat(result, base2);
-		strcat(result, separator);
-
-		if (base3)
-		{
-			strcat(result, base3);
-			strcat(result, separator);
-		}
-	}
-
-	return result;
-}
-
-/**
- * 	\fn char *ADM_getHomeRelativePath(const char *base1, const char *base2=NULL,const char *base3=NULL);
- *  \brief Returns home directory +base 1 + base 2... The return value is a copy, and must be deleted []
- */
-char *ADM_getHomeRelativePath(const char *base1, const char *base2,const char *base3)
-{
-	return ADM_getRelativePath(ADM_getBaseDir(), base1, base2, base3);
-}
-
-char *ADM_getInstallRelativePath(const char *base1, const char *base2,const char *base3)
-{
-#ifdef __WIN32
-       	wchar_t wcModuleName[MAX_PATH];
-
-	GetModuleFileNameW(0, wcModuleName, sizeof(wcModuleName) / sizeof(wchar_t));
-
-	int len = wideCharStringToUtf8(wcModuleName, -1, NULL);
-	char moduleName[len];
-
-	wideCharStringToUtf8(wcModuleName, -1, moduleName);
-
-
-	char *slash = strrchr(moduleName, '\\');
-		
-	if (slash)
-		*slash = '\0';
-
-	return ADM_getRelativePath(moduleName, base1, base2, base3);
-#elif defined(__APPLE__)
-#define MAX_PATH_SIZE 1024
-
-	char buffer[MAX_PATH_SIZE];
-
-	CFURLRef url(CFBundleCopyExecutableURL(CFBundleGetMainBundle()));
-	buffer[0] = '\0';
-
-	if (url)
-	{
-		CFURLGetFileSystemRepresentation(url, true, (UInt8*)buffer, MAX_PATH_SIZE);
-		CFRelease(url);
-
-		char *slash = strrchr(buffer, '/');
-		
-		if (slash)
-			*slash = '\0';
-	}
-
-	return ADM_getRelativePath(buffer, base1, base2, base3);
-#else
-	return ADM_getRelativePath(ADM_INSTALL_DIR, base1, base2, base3);
-#endif
-}
-
-char *ADM_getPluginPath(void)
-{
-	return ADM_getInstallRelativePath("lib", "ADM_plugins", "videoEncoder");
-}
-/*
-      Get the root directory for .avidemux stuff
-******************************************************/
-char *ADM_getBaseDir(void)
-{
-	char *home;
-
-	if (baseDirDone)
-		return ADM_basedir;
-
-	// Get the base directory
-#ifdef __WIN32
-	wchar_t wcHome[MAX_PATH];
-
-	if (SHGetFolderPathW(NULL, CSIDL_APPDATA, NULL, 0, wcHome) == S_OK)
-	{
-		int len = wideCharStringToUtf8(wcHome, -1, NULL);
-		home = new char[len];
-
-		wideCharStringToUtf8(wcHome, -1, home);
-	}
-	else
-	{
-		printf("Oops: can't determine the Application Data folder.");
-		home = ADM_strdup("c:\\");
-	}
-#else
-	const char* homeEnv = getenv("HOME");
-
-	if (homeEnv)
-	{
-		home = new char[strlen(homeEnv) + 1];
-		strcpy(home, homeEnv);
-	}
-	else
-	{
-		printf("Oops: can't determine $HOME.");
-
-		return NULL;
-	}
-#endif
-
-	// Try to open the .avidemux directory
-
-	strcpy(ADM_basedir, home);
+#else
+static const char *separator="/";
+const char *ADM_DIR_NAME="/.avidemux6";
+#endif
+
+static char ADM_basedir[1024] = {0};
+static char *ADM_jobdir = NULL;
+static char *ADM_customdir = NULL;
+static int baseDirDone = 0;
+
+#undef fread
+#undef fwrite
+#undef fopen
+#undef fclose
+
+#ifdef __WIN32
+extern int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString);
+extern int wideCharStringToUtf8(const wchar_t *wideCharString, int wideCharStringLength, char *utf8String);
+#endif
+
+size_t ADM_fread (void *ptr, size_t size, size_t n, FILE *sstream)
+{
+	return fread(ptr,size,n,sstream);
+}
+
+size_t ADM_fwrite(const void *ptr, size_t size, size_t n, FILE *sstream)
+{
+	return fwrite(ptr,size,n,sstream);
+}
+
+FILE *ADM_fopen(const char *file, const char *mode)
+{
+#ifdef __MINGW32__
+	// Override fopen to handle Unicode filenames and to ensure exclusive access when initially writing to a file.
+	int fileNameLength = utf8StringToWideChar(file, -1, NULL);
+	wchar_t wcFile[fileNameLength];
+	int creation = 0, access = 0;
+	HANDLE hFile;
+
+	utf8StringToWideChar(file, -1, wcFile);
+
+	if (strchr(mode, 'w'))
+	{
+		creation = CREATE_ALWAYS;
+		access = GENERIC_WRITE;
+
+		if (strchr(mode, '+'))
+			access |= GENERIC_READ;
+	}
+	else if (strchr(mode, 'r'))
+	{
+		creation = OPEN_EXISTING;
+		access = GENERIC_READ;
+
+		if (strchr(mode, '+'))
+			access = GENERIC_WRITE;
+	}
+	else if (strchr(mode, 'a'))
+	{
+		creation = OPEN_ALWAYS;
+		access = GENERIC_WRITE;
+
+		if (strchr(mode, '+'))
+			access |= GENERIC_READ;
+	}
+
+	if (creation & GENERIC_WRITE)
+	{
+		hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
+
+		if (hFile == INVALID_HANDLE_VALUE)
+			return NULL;
+		else
+			CloseHandle(hFile);
+	}
+
+	hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
+
+	if (hFile == INVALID_HANDLE_VALUE)
+		return NULL;
+	else
+		return _fdopen(_open_osfhandle((intptr_t)hFile, 0), mode);
+#else
+	return fopen(file, mode);
+#endif
+}
+
+#if __WIN32
+extern "C"
+{
+	// libavformat uses open (in the file_open function) so we need to override that too.
+	// Following the same rules as ADM_fopen.
+	int ADM_open(const char *path, int oflag, ...)
+	{
+		int fileNameLength = utf8StringToWideChar(path, -1, NULL);
+		wchar_t wcFile[fileNameLength];
+		int creation = 0, access = 0;
+		HANDLE hFile;
+
+		utf8StringToWideChar(path, -1, wcFile);
+
+		if (oflag & O_WRONLY || oflag & O_RDWR)
+		{
+			access = GENERIC_WRITE;
+
+			if (oflag & O_RDWR)
+				access |= GENERIC_READ;
+
+			if (oflag & O_CREAT)
+			{
+				if (oflag & O_EXCL)
+					creation = CREATE_NEW;
+				else if (oflag & O_TRUNC)
+					creation = CREATE_ALWAYS;
+				else
+					creation = OPEN_ALWAYS;
+			}
+			else if (oflag & O_TRUNC)
+				creation = TRUNCATE_EXISTING;
+		}
+		else if (oflag & O_RDONLY)
+			creation = OPEN_EXISTING;
+
+		if (creation & GENERIC_WRITE)
+		{
+			hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
+
+			if (hFile == INVALID_HANDLE_VALUE)
+				return -1;
+			else
+				CloseHandle(hFile);
+		}
+
+		hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
+
+		if (hFile == INVALID_HANDLE_VALUE)
+			return -1;
+		else
+			return _open_osfhandle((intptr_t)hFile, oflag);
+	}
+}
+#endif
+
+int ADM_fclose(FILE *file)
+{
+	return fclose(file); 
+}
+
+/*
+      Get the  directory where jobs are stored
+******************************************************/
+char *ADM_getCustomDir(void)
+{
+	if (ADM_customdir)
+		return ADM_customdir;
+
+	ADM_customdir = ADM_getHomeRelativePath("custom");
+
+	if (!ADM_mkdir(ADM_customdir))
+	{
+		printf("can't create custom directory (%s).\n", ADM_customdir);
+		return NULL;
+	}
+
+	return ADM_customdir;
+}
+
+/*
+      Get the  directory where jobs are stored
+******************************************************/
+char *ADM_getJobDir(void)
+{
+	if (ADM_jobdir)
+		return ADM_jobdir;
+
+	ADM_jobdir = ADM_getHomeRelativePath("jobs");
+
+	if (!ADM_mkdir(ADM_jobdir))
+	{
+		printf("can't create custom directory (%s).\n", ADM_jobdir);
+		return NULL;
+	}
+
+	return ADM_jobdir;
+}
+
+/**
+ * 	\fn ADM_getRelativePath
+ */
+static char *ADM_getRelativePath(const char *base0,const char *base1, const char *base2,const char *base3)
+{
+	char *result;
+	int length = strlen(base1);
+
+	if (base2)
+		length += strlen(base2);
+
+	if (base3)
+		length += strlen(base3);
+
+	length += strlen(base0);
+	length += 5; // Slashes + end 0
+	result = (char *)new char [length];
+	strcpy(result, base0);
+	strcat(result, separator);
+
+	strcat(result, base1);
+	strcat(result, separator);
+
+	if (base2)
+	{
+		strcat(result, base2);
+		strcat(result, separator);
+
+		if (base3)
+		{
+			strcat(result, base3);
+			strcat(result, separator);
+		}
+	}
+
+	return result;
+}
+
+/**
+ * 	\fn char *ADM_getHomeRelativePath(const char *base1, const char *base2=NULL,const char *base3=NULL);
+ *  \brief Returns home directory +base 1 + base 2... The return value is a copy, and must be deleted []
+ */
+char *ADM_getHomeRelativePath(const char *base1, const char *base2,const char *base3)
+{
+	return ADM_getRelativePath(ADM_getBaseDir(), base1, base2, base3);
+}
+
+char *ADM_getInstallRelativePath(const char *base1, const char *base2,const char *base3)
+{
+#ifdef __WIN32
+       	wchar_t wcModuleName[MAX_PATH];
+
+	GetModuleFileNameW(0, wcModuleName, sizeof(wcModuleName) / sizeof(wchar_t));
+
+	int len = wideCharStringToUtf8(wcModuleName, -1, NULL);
+	char moduleName[len];
+
+	wideCharStringToUtf8(wcModuleName, -1, moduleName);
+
+
+	char *slash = strrchr(moduleName, '\\');
+		
+	if (slash)
+		*slash = '\0';
+
+	return ADM_getRelativePath(moduleName, base1, base2, base3);
+#elif defined(__APPLE__)
+#define MAX_PATH_SIZE 1024
+
+	char buffer[MAX_PATH_SIZE];
+
+	CFURLRef url(CFBundleCopyExecutableURL(CFBundleGetMainBundle()));
+	buffer[0] = '\0';
+
+	if (url)
+	{
+		CFURLGetFileSystemRepresentation(url, true, (UInt8*)buffer, MAX_PATH_SIZE);
+		CFRelease(url);
+
+		char *slash = strrchr(buffer, '/');
+		
+		if (slash)
+			*slash = '\0';
+	}
+
+	return ADM_getRelativePath(buffer, base1, base2, base3);
+#else
+	return ADM_getRelativePath(ADM_INSTALL_DIR, base1, base2, base3);
+#endif
+}
+
+char *ADM_getPluginPath(void)
+{
+	return ADM_getInstallRelativePath("lib", "ADM_plugins", "videoEncoder");
+}
+/*
+      Get the root directory for .avidemux stuff
+******************************************************/
+char *ADM_getBaseDir(void)
+{
+	char *home;
+
+	if (baseDirDone)
+		return ADM_basedir;
+
+	// Get the base directory
+#ifdef __WIN32
+	wchar_t wcHome[MAX_PATH];
+
+	if (SHGetFolderPathW(NULL, CSIDL_APPDATA, NULL, 0, wcHome) == S_OK)
+	{
+		int len = wideCharStringToUtf8(wcHome, -1, NULL);
+		home = new char[len];
+
+		wideCharStringToUtf8(wcHome, -1, home);
+	}
+	else
+	{
+		printf("Oops: can't determine the Application Data folder.");
+		home = ADM_strdup("c:\\");
+	}
+#else
+	const char* homeEnv = getenv("HOME");
+
+	if (homeEnv)
+	{
+		home = new char[strlen(homeEnv) + 1];
+		strcpy(home, homeEnv);
+	}
+	else
+	{
+		printf("Oops: can't determine $HOME.");
+
+		return NULL;
+	}
+#endif
+
+	// Try to open the .avidemux directory
+
+	strcpy(ADM_basedir, home);
 	strcat(ADM_basedir, ADM_DIR_NAME);
     delete [] home;
-    home=NULL;
-
-	if (!ADM_mkdir(ADM_basedir))
-	{
-		printf("Oops: cannot create the .avidemux directory", NULL);
-		return NULL;
-	}
-
+    home=NULL;
+
+	if (!ADM_mkdir(ADM_basedir))
+	{
+		printf("Oops: cannot create the .avidemux directory", NULL);
+		return NULL;
+	}
+
 	// Now built the filename
-	baseDirDone = 1;
-	printf("Using %s as base directory for prefs/jobs/...\n", ADM_basedir);
-	return ADM_basedir;
-}
-
-#ifdef __WIN32
-#define DIR _WDIR
-#define dirent _wdirent
-#define opendir _wopendir
-#define readdir _wreaddir
-#define closedir _wclosedir
-#endif
-
-/*----------------------------------------
-      Create a directory
-      If it already exists, do nothing
-------------------------------------------*/
-uint8_t ADM_mkdir(const char *dirname)
-{
-	DIR *dir = NULL;
-
-#ifdef __WIN32
-	int dirNameLength = utf8StringToWideChar(dirname, -1, NULL);
-	wchar_t dirname2[dirNameLength];
-
-	utf8StringToWideChar(dirname, -1, dirname2);
-#else
-	const char* dirname2 = dirname;
-#endif
-
-	// Check it already exists ?
-	dir = opendir(dirname2);
-
-	if (dir)
-	{ 
-		printf("Directory %s exists.Good.\n", dirname);
-		closedir(dir);
-		return 1;
-	}
-#ifdef __WIN32
-	if (_wmkdir(dirname2))
-	{
-		printf("Oops: mkdir failed on %s\n", dirname);
-		return 0;
-	}
-#else
-	printf("Creating dir :%s\n", dirname2);
-	mkdir(dirname2,0755);
-
-#endif
-
-	if ((dir = opendir(dirname2)) == NULL)
-		return 0;
-
-	closedir(dir);
-
-	return 1;
-}
-/**
- *  \fn buildDirectoryContent
- * 	\brief Returns the content of a dir with the extension ext. The receiving array must be allocated by caller
- * (just the array, not the names themselves)
- */
-uint8_t buildDirectoryContent(uint32_t *outnb, const char *base, char *jobName[], int maxElems, const char *ext)
-{
-	DIR *dir;
-	struct dirent *direntry;
-	int dirmax = 0, len;
-	int extlen = strlen(ext);
-
-	ADM_assert(extlen);
-
-#ifdef __WIN32
-	int dirNameLength = utf8StringToWideChar(base, -1, NULL);
-	wchar_t base2[dirNameLength];
-
-	utf8StringToWideChar(base, -1, base2);
-#else
-	const char *base2 = base;
-#endif
-
-	dir = opendir(base2);
-	if (!dir)
-		return 0;
-
-	while (direntry = readdir(dir))
-	{
-#ifdef __WIN32
-		int dirLength = wideCharStringToUtf8(direntry->d_name, -1, NULL);
-		char d_name[dirLength];
-
-		wideCharStringToUtf8(direntry->d_name, -1, d_name);
-#else
-		const char *d_name = direntry->d_name;
-#endif
-
-		len = strlen(d_name);
-
-		if (len < (extlen + 1))
-			continue;
-
-		int xbase = len - extlen;
-
-		if (memcmp(d_name + xbase, ext, extlen))
-			//if (direntry->d_name[len-1]!='s' || direntry->d_name[len-2]!='j' || direntry->d_name[len-3]!='.')
-		{
-			printf("ignored: %s\n", d_name);
-			continue;
-		}
-
-		jobName[dirmax] = (char *)ADM_alloc(strlen(base) + strlen(d_name) + 2);
-		strcpy(jobName[dirmax], base);
-		strcat(jobName[dirmax], "/");
-		strcat(jobName[dirmax], d_name);
-		dirmax++;
-
-		if (dirmax >= maxElems)
-		{
-			printf("[jobs]: Max # of jobs exceeded\n");
-			break;
-		}
-	}
-
-	closedir(dir);
-	*outnb = dirmax;
-
-	return 1;
-}
-//------------------------------------------------------------------
-
-/*
-
-** note: it modifies it's first argument
-*/
-void simplify_path(char **buf)
-{
-	unsigned int last1slash = 0;
-	unsigned int last2slash = 0;
-
-	while (!strncmp(*buf, "/../", 4))
-		memmove(*buf, *buf + 3, strlen(*buf + 3) + 1);
-
-	for (unsigned int i = 0; i < strlen(*buf) - 2; i++)
-		while (!strncmp(*buf + i, "/./", 3))
-			memmove(*buf + i, *buf + i + 2, strlen(*buf + i + 2) + 1);
-
-	for (unsigned int i = 0; i < strlen(*buf) - 3; i++)
-	{
-		if (*(*buf + i) == '/')
-		{
-			last2slash = last1slash;
-			last1slash = i;
-		}
-
-		if (!strncmp(*buf + i, "/../", 4))
-		{
-			memmove(*buf + last2slash, *buf + i + 3, strlen(*buf + i + 3) + 1);
-
-			return simplify_path(buf);
-		}
-	}
-}
-
-/**
-        \fn ADM_PathCanonize
-        \brief Canonize the path, returns a copy of the absolute path given as parameter
-*/
-char *ADM_PathCanonize(const char *tmpname)
-{
-	char path[300];
-	char *out;
-
-	if (!getcwd(path, 300))
-	{
-		fprintf(stderr, "\ngetcwd() failed with: %s (%u)\n", strerror(errno), errno);
-		path[0] = '\0';
-	}
-
-	if (!tmpname || tmpname[0] == 0)
-	{
-		out = new char[strlen(path) + 2];
-		strcpy(out, path);
-#ifndef __WIN32
-		strcat(out, "/");
-#else
-		strcat(out, "\\");
-#endif
-		printf("\n Canonizing null string ??? (%s)\n", out);
-	}
-	else if (tmpname[0] == '/'
-#if defined(__WIN32)
-		|| tmpname[1] == ':'
-#endif
-		)
-	{
-		out = new char[strlen(tmpname) + 1];
-		strcpy(out, tmpname);
-
-		return out;
-	}
-	else
-	{
-		out = new char[strlen(path) + strlen(tmpname) + 6];
-		strcpy(out, path);
-#ifndef __WIN32
-		strcat(out, "/");
-#else
-		strcat(out, "\\");
-#endif
-		strcat(out, tmpname);
-	}
-
-	simplify_path(&out);
-
-	return out;
-}
-
-/**
-        \fn ADM_PathStripName
-	\brief Returns path only /foo/bar.avi -> /foo INPLACE, no copy done
-
-*/
-void ADM_PathStripName(char *str)
-{
-	int len = strlen(str);
-
-	if (len <= 1)
-		return;
-
-	len--;
-
-#ifndef __WIN32
-	while (*(str + len) != '/' && len)
-#else
-	while (*(str + len) != '\\' && len)
-#endif
-	{
-		*(str + len) = 0;
-		len--;
-	}
-}
-
-/**
-    \fn ADM_GetFileName
-    \brief Get the filename without path. /foo/bar.avi -> bar.avi INPLACE, NO COPY
-
-*/
-const char *ADM_GetFileName(const char *str)
-{
-	const char *filename;
-	const char *filename2;
-
-#ifndef __WIN32
-	filename = strrchr(str, '/');
-#else
-	filename = strrchr(str, '\\');
-	filename2 = strrchr(str, '/');
-
-	if (filename2 && filename)
-		if (filename2 > filename)
-			filename = filename2;
-#endif
-
-	if (filename)
-		return filename + 1;
-	else
-		return str;
-}
-
-/**
-    \fn ADM_PathSplit
-    \brief Split path into absolute path+name and extention i.e. /foo/bar/zee.avi -> /foo/bar/zee,avi.             Copy are returned
-
-*/
-void ADM_PathSplit(const char *str, char **root, char **ext)
-{
-	char *full;
-	uint32_t l;
-
-	full = ADM_PathCanonize(str);
-	// Search the last
-	l = strlen(full);
-	l--;
-	ADM_assert(l > 0);
-
-	while (*(full + l) != '.' && l)
-		l--;
-
-	if (!l || l == (strlen(full) - 1))
-	{
-		if (l == (strlen(full) - 1))
-			*(full + l) = 0;  // remove trailing
-
-		*ext = new char[2];
-		*root = full;
-		strcpy(*ext, "");
-
-		return;
-	}
-	// else we do get an extension
-	// starting at l+1
-	uint32_t suff;
-
-	suff = strlen(full) - l - 1;
-	*ext = new char[suff + 1];
-	strcpy(*ext, full + l + 1);
-	*(full + l) = 0;
-	*root = full;
-}
+	baseDirDone = 1;
+	printf("Using %s as base directory for prefs/jobs/...\n", ADM_basedir);
+	return ADM_basedir;
+}
+
+#ifdef __WIN32
+#define DIR _WDIR
+#define dirent _wdirent
+#define opendir _wopendir
+#define readdir _wreaddir
+#define closedir _wclosedir
+#endif
+
+/*----------------------------------------
+      Create a directory
+      If it already exists, do nothing
+------------------------------------------*/
+uint8_t ADM_mkdir(const char *dirname)
+{
+	DIR *dir = NULL;
+
+#ifdef __WIN32
+	int dirNameLength = utf8StringToWideChar(dirname, -1, NULL);
+	wchar_t dirname2[dirNameLength];
+
+	utf8StringToWideChar(dirname, -1, dirname2);
+#else
+	const char* dirname2 = dirname;
+#endif
+
+	// Check it already exists ?
+	dir = opendir(dirname2);
+
+	if (dir)
+	{ 
+		printf("Directory %s exists.Good.\n", dirname);
+		closedir(dir);
+		return 1;
+	}
+#ifdef __WIN32
+	if (_wmkdir(dirname2))
+	{
+		printf("Oops: mkdir failed on %s\n", dirname);
+		return 0;
+	}
+#else
+	printf("Creating dir :%s\n", dirname2);
+	mkdir(dirname2,0755);
+
+#endif
+
+	if ((dir = opendir(dirname2)) == NULL)
+		return 0;
+
+	closedir(dir);
+
+	return 1;
+}
+/**
+ *  \fn buildDirectoryContent
+ * 	\brief Returns the content of a dir with the extension ext. The receiving array must be allocated by caller
+ * (just the array, not the names themselves)
+ */
+uint8_t buildDirectoryContent(uint32_t *outnb, const char *base, char *jobName[], int maxElems, const char *ext)
+{
+	DIR *dir;
+	struct dirent *direntry;
+	int dirmax = 0, len;
+	int extlen = strlen(ext);
+
+	ADM_assert(extlen);
+
+#ifdef __WIN32
+	int dirNameLength = utf8StringToWideChar(base, -1, NULL);
+	wchar_t base2[dirNameLength];
+
+	utf8StringToWideChar(base, -1, base2);
+#else
+	const char *base2 = base;
+#endif
+
+	dir = opendir(base2);
+	if (!dir)
+		return 0;
+
+	while (direntry = readdir(dir))
+	{
+#ifdef __WIN32
+		int dirLength = wideCharStringToUtf8(direntry->d_name, -1, NULL);
+		char d_name[dirLength];
+
+		wideCharStringToUtf8(direntry->d_name, -1, d_name);
+#else
+		const char *d_name = direntry->d_name;
+#endif
+
+		len = strlen(d_name);
+
+		if (len < (extlen + 1))
+			continue;
+
+		int xbase = len - extlen;
+
+		if (memcmp(d_name + xbase, ext, extlen))
+			//if (direntry->d_name[len-1]!='s' || direntry->d_name[len-2]!='j' || direntry->d_name[len-3]!='.')
+		{
+			printf("ignored: %s\n", d_name);
+			continue;
+		}
+
+		jobName[dirmax] = (char *)ADM_alloc(strlen(base) + strlen(d_name) + 2);
+		strcpy(jobName[dirmax], base);
+		strcat(jobName[dirmax], "/");
+		strcat(jobName[dirmax], d_name);
+		dirmax++;
+
+		if (dirmax >= maxElems)
+		{
+			printf("[jobs]: Max # of jobs exceeded\n");
+			break;
+		}
+	}
+
+	closedir(dir);
+	*outnb = dirmax;
+
+	return 1;
+}
+//------------------------------------------------------------------
+
+/*
+
+** note: it modifies it's first argument
+*/
+void simplify_path(char **buf)
+{
+	unsigned int last1slash = 0;
+	unsigned int last2slash = 0;
+
+	while (!strncmp(*buf, "/../", 4))
+		memmove(*buf, *buf + 3, strlen(*buf + 3) + 1);
+
+	for (unsigned int i = 0; i < strlen(*buf) - 2; i++)
+		while (!strncmp(*buf + i, "/./", 3))
+			memmove(*buf + i, *buf + i + 2, strlen(*buf + i + 2) + 1);
+
+	for (unsigned int i = 0; i < strlen(*buf) - 3; i++)
+	{
+		if (*(*buf + i) == '/')
+		{
+			last2slash = last1slash;
+			last1slash = i;
+		}
+
+		if (!strncmp(*buf + i, "/../", 4))
+		{
+			memmove(*buf + last2slash, *buf + i + 3, strlen(*buf + i + 3) + 1);
+
+			return simplify_path(buf);
+		}
+	}
+}
+
+/**
+        \fn ADM_PathCanonize
+        \brief Canonize the path, returns a copy of the absolute path given as parameter
+*/
+char *ADM_PathCanonize(const char *tmpname)
+{
+	char path[300];
+	char *out;
+
+	if (!getcwd(path, 300))
+	{
+		fprintf(stderr, "\ngetcwd() failed with: %s (%u)\n", strerror(errno), errno);
+		path[0] = '\0';
+	}
+
+	if (!tmpname || tmpname[0] == 0)
+	{
+		out = new char[strlen(path) + 2];
+		strcpy(out, path);
+#ifndef __WIN32
+		strcat(out, "/");
+#else
+		strcat(out, "\\");
+#endif
+		printf("\n Canonizing null string ??? (%s)\n", out);
+	}
+	else if (tmpname[0] == '/'
+#if defined(__WIN32)
+		|| tmpname[1] == ':'
+#endif
+		)
+	{
+		out = new char[strlen(tmpname) + 1];
+		strcpy(out, tmpname);
+
+		return out;
+	}
+	else
+	{
+		out = new char[strlen(path) + strlen(tmpname) + 6];
+		strcpy(out, path);
+#ifndef __WIN32
+		strcat(out, "/");
+#else
+		strcat(out, "\\");
+#endif
+		strcat(out, tmpname);
+	}
+
+	simplify_path(&out);
+
+	return out;
+}
+
+/**
+        \fn ADM_PathStripName
+	\brief Returns path only /foo/bar.avi -> /foo INPLACE, no copy done
+
+*/
+void ADM_PathStripName(char *str)
+{
+	int len = strlen(str);
+
+	if (len <= 1)
+		return;
+
+	len--;
+
+#ifndef __WIN32
+	while (*(str + len) != '/' && len)
+#else
+	while (*(str + len) != '\\' && len)
+#endif
+	{
+		*(str + len) = 0;
+		len--;
+	}
+}
+
+/**
+    \fn ADM_GetFileName
+    \brief Get the filename without path. /foo/bar.avi -> bar.avi INPLACE, NO COPY
+
+*/
+const char *ADM_GetFileName(const char *str)
+{
+	const char *filename;
+	const char *filename2;
+
+#ifndef __WIN32
+	filename = strrchr(str, '/');
+#else
+	filename = strrchr(str, '\\');
+	filename2 = strrchr(str, '/');
+
+	if (filename2 && filename)
+		if (filename2 > filename)
+			filename = filename2;
+#endif
+
+	if (filename)
+		return filename + 1;
+	else
+		return str;
+}
+
+/**
+    \fn ADM_PathSplit
+    \brief Split path into absolute path+name and extention i.e. /foo/bar/zee.avi -> /foo/bar/zee,avi.             Copy are returned
+
+*/
+void ADM_PathSplit(const char *str, char **root, char **ext)
+{
+	char *full;
+	uint32_t l;
+
+	full = ADM_PathCanonize(str);
+	// Search the last
+	l = strlen(full);
+	l--;
+	ADM_assert(l > 0);
+
+	while (*(full + l) != '.' && l)
+		l--;
+
+	if (!l || l == (strlen(full) - 1))
+	{
+		if (l == (strlen(full) - 1))
+			*(full + l) = 0;  // remove trailing
+
+		*ext = new char[2];
+		*root = full;
+		strcpy(*ext, "");
+
+		return;
+	}
+	// else we do get an extension
+	// starting at l+1
+	uint32_t suff;
+
+	suff = strlen(full) - l - 1;
+	*ext = new char[suff + 1];
+	strcpy(*ext, full + l + 1);
+	*(full + l) = 0;
+	*root = full;
+}



From mean at mail.berlios.de  Thu Jan 27 08:18:51 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 27 Jan 2011 08:18:51 +0100
Subject: [Avidemux-svn-commit] r6964 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110127071851.CF8264812FF@sheep.berlios.de>

Author: mean
Date: 2011-01-27 08:18:51 +0100 (Thu, 27 Jan 2011)
New Revision: 6964

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
Log:
[mp4v2] Add tune chunk duration

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-27 07:18:50 UTC (rev 6963)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-27 07:18:51 UTC (rev 6964)
@@ -38,8 +38,24 @@
    1, // uint32_t optimize;
    0  //uint32_t add_itunes_metadata;
 };
-
 /**
+    \fn setMaxDurationPerChunk
+    \brief Max chunk duration is 1 sec par default; set it to ~ 4 frames
+*/
+bool muxerMp4v2::setMaxDurationPerChunk(MP4TrackId track, uint32_t samples)
+{
+    uint32_t trackScale=MP4GetTrackTimeScale(handle,track);
+    uint32_t   mx;
+    mx=4*samples;
+    ADM_info("Setting max chunk duration =%d; scale=%d for track %d\n",(int)mx,(int)trackScale,(int)track);
+    if(!MP4SetTrackDurationPerChunk(handle,track,mx))
+    {
+        ADM_error("Cannot set TrackDurationPerChunk\n");
+        return false;
+    }
+    return true;
+}
+/**
     \fn timeScale
     \brief convert our unit (us) to mp4v2 unit (90khz tick)
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-27 07:18:50 UTC (rev 6963)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-27 07:18:51 UTC (rev 6964)
@@ -73,6 +73,7 @@
         bool            initH264(void);
         bool            initVideo(void);
         bool            loadNextVideoFrame(ADMBitstream *bs);
+        bool            setMaxDurationPerChunk(MP4TrackId track, uint32_t samples);
 protected: // audio
         bool            initAudio(void);
         bool            fillAudio(uint64_t targetDts);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-27 07:18:50 UTC (rev 6963)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-27 07:18:51 UTC (rev 6964)
@@ -166,6 +166,8 @@
                 ADM_error("Wrong extra data for h264\n");
                 return false;
             }
+            
+            // if we dont have extraData, it is annexB 100 % sire
             needToConvertFromAnnexB=true;
             if(extraLen)
                 if(extra[0]==1) needToConvertFromAnnexB=false;
@@ -225,6 +227,13 @@
                 return false;
             }
         }
+        double inc=vStream->getAvgFps1000();
+        inc=inc/1000;
+        if(inc>0.005) inc=1/inc;
+                else inc=0.005;
+        ADM_info("Frame increment =%d ms\n",(int)(inc*1000));
+        inc*=90000;
+        setMaxDurationPerChunk(videoTrackId, inc);
         ADM_info("[MP4V2] Video correctly initalized\n");
         return true;
 }



From mean at mail.berlios.de  Thu Jan 27 20:05:43 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 27 Jan 2011 20:05:43 +0100
Subject: [Avidemux-svn-commit] r6965 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4
Message-ID: <20110127190543.B644E480CC2@sheep.berlios.de>

Author: mean
Date: 2011-01-27 20:05:43 +0100 (Thu, 27 Jan 2011)
New Revision: 6965

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
Log:
[mp4/demux] Partial support of ac3 in mp4 (incomplete, need bitrate)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2011-01-27 07:18:51 UTC (rev 6964)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2011-01-27 19:05:43 UTC (rev 6965)
@@ -875,6 +875,11 @@
 #define audioCodec(x) ADIO.encoding=WAV_##x;
                                 switch(entryName)
                                 {
+                                    case MKFCCR('a','c','-','3'):
+                                    case MKFCCR('s','a','c','3'):
+                                            audioCodec(AC3);
+                                            ADIO.byterate=128000>>3;
+                                            break;
 
                                     case MKFCCR('t','w','o','s'):
                                             audioCodec(LPCM);



From mean at mail.berlios.de  Sat Jan 29 10:57:29 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 29 Jan 2011 10:57:29 +0100
Subject: [Avidemux-svn-commit] r6966 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <20110129095730.34B84480F6B@sheep.berlios.de>

Author: mean
Date: 2011-01-29 10:57:29 +0100 (Sat, 29 Jan 2011)
New Revision: 6966

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp
Log:
[save/audio] Handle copy and process

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp	2011-01-27 19:05:43 UTC (rev 6965)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp	2011-01-29 09:57:29 UTC (rev 6966)
@@ -38,6 +38,7 @@
 #include "A_functions.h"
 int      A_Save(const char *name);
 uint8_t  GUI_getFrameContent(ADMImage *image, uint32_t frame);
+extern   ADM_audioStream  *audioCreateEncodingStream(bool globalHeader,uint64_t startTime,int32_t shift);
 
 /**
     \fn HandleAction_Navigate
@@ -120,7 +121,7 @@
     ADM_audioStream *stream;
     if(false==video_body->getAudioStream( &stream)) 
     {
-        printf("[A_audioSave] No stream\n");
+        ADM_error("[A_audioSave] No stream\n");
         return 0;
     }
 	if (audioProcessMode())
@@ -137,140 +138,10 @@
 }
 
 /**
-    \fn A_saveAudioProcessed
-    \brief Save current stream (generally avi...)
-     in decoded mode (assuming MP3)
+        \fn A_saveAudioCommon
+        \brief Save giveb stream 
 */
-int A_saveAudioProcessed (const char *name)
-{
-#if 0
-// debug audio seek
-  uint32_t len, gauge = 0;
-  uint32_t written = 0;
-  FILE *out;
-  AVDMGenericAudioStream *saveFilter;
-
-  uint64_t sampleTarget,sampleCurrent;
-
-#undef BITT
-#define BITT 4*1152
-#define OUTCHUNK 1024*1024
-  uint8_t *outbuffer;
-
-  if (!currentaudiostream)
-    return;
-
-
-  if (!(out = ADM_fopen (name, "wb")))
-    {
-      GUI_Error_HIG (QT_TR_NOOP("File error"), QT_TR_NOOP("Cannot open \"%s\" for writing."), name);
-      return false;
-    }
-
-  outbuffer = (uint8_t *) ADM_alloc (2 * OUTCHUNK);	// 1Meg cache;
-  if (!outbuffer)
-    {
-      GUI_Error_HIG (QT_TR_NOOP("Memory Error"), NULL);
-      return false;
-    }
-
-
-
-// re-ignite first filter...
-
-
-
-
-  // Write Wav header
-
-  /* Sat Nov 09 06:11:52 CET 2002 Fixes from Maik Broemme <mbroemme at plusserver.de> */
-  /* If you set negative delay and save the audio stream, the saved stream was shorter than the video stream. */
-
-  /* Example: video stream is 10 minutes long, audio stream perhaps 20 minutes, you need the audio stream from */
-  /*          minute 1 until 11, so you setup an audio delay from -60 seconds, but this 60 seconds were removed */
-  /*          from begin and end of the audio stream. That was not good :) Now it runs correctly also if you use */
-  /*          audio stream with same length then video, therefore is premature ending :) */
-
-
-
-//        saveFilter =  buildAudioFilter (currentaudiostream,video_body->getTime (frameStart));
-
-		if (saveFilter == NULL)
-		{
-			fclose(out);
-			ADM_dealloc(outbuffer);
-			return false;
-		}
-
-    	DIA_working *work=new DIA_working(QT_TR_NOOP("Saving audio"));
-
-
-//
-//  Create First filter that is null filter
-//
-  saveFilter->writeHeader (out);
-  uint32_t tstart,tend,samples;
-  double duration;
-  tstart=video_body->getTime(frameStart);
-  tend=video_body->getTime(frameEnd+1);
-  duration=(tend-tstart);
-  duration*=saveFilter->getInfo()->frequency;
-  duration/=1000.;
-
-  sampleTarget=(uint64_t)floor(duration);
-  sampleCurrent=0;
-  gauge=0;
-
-  if( frameStart == frameEnd ){
-     /* JSC: we will write some bytes, but nobody should expect useful data */
-    GUI_Error_HIG(QT_TR_NOOP("No frames to encode"),QT_TR_NOOP("Please check markers. Is \"A>\" == \">B\"?"));
-  }
-
-  while ((sampleCurrent<sampleTarget))
-    {
-      if(!saveFilter->getPacket(outbuffer + gauge,&len,&samples))
-      {
-        printf("Audio save:Read error\n");
-      	break;
-      }
-      
-      gauge += len;
-      sampleCurrent+=samples;
-      // update GUI
-	// JSC: if "A>" == ">B" we will get >100% here => assert in work->update()
-	if (work->update ((sampleCurrent>>10 > sampleTarget>>10 ? sampleTarget>>10 : sampleCurrent>>10), sampleTarget>>10))	// abort request ?
-	    break;;
-      if (gauge > OUTCHUNK)	// either out buffer is full
-	{
-	  fwrite (outbuffer, 1, gauge, out);
-	  written += gauge;
-	  gauge = 0;
-	}
-    };
-// Clean up
-	if(gauge)
-	{
-		fwrite (outbuffer,  gauge,1, out);
-		written += gauge;
-		gauge = 0;
-	}
-  saveFilter->endWrite (out, written);
-  fclose (out);
-  ADM_dealloc (outbuffer);
-  delete work;
-//  deleteAudioFilter (saveFilter);
-//  currentaudiostream->endDecompress ();
-  printf ("AudioSave: actually written %u\n", written);
-  printf ("Audiosave: target sample:%llu, got :%llu\n",sampleTarget,sampleCurrent);
-#else
-  return 0;
-#endif
-}
-/**
-        \fn A_saveAudioCopy
-        \brief Save current stream (generally avi...)     in raw mode
-*/
-int A_saveAudioCopy (const char *name)
+static bool A_saveAudioCommon (const char *name,ADM_audioStream *stream,double duration)
 { 
   uint32_t written, max;
   uint64_t dts;
@@ -279,43 +150,24 @@
 
 #define ONE_STRIKE (64*1024)
   uint8_t *buffer=NULL;
-  ADM_audioStream *stream;
-  if(false==video_body->getAudioStream( &stream)) 
-    {
-        printf("[A_audioSave] No stream\n");
-        return false;
-    }
 
 
   out = ADM_fopen (name, "wb");
-  if (!out) return false;
+  if (!out) 
+  {
+    ADM_error("Cannot open file for writing\n");
+    return false;
+  }
 
   work=createWorking(QT_TR_NOOP("Saving audio"));
 
   uint64_t timeEnd,timeStart;
   uint32_t hold,len,sample;
   uint64_t tgt_sample,cur_sample;
-  double   duration;
 
-  // compute start position and duration in samples
-
-   timeStart=video_body->getMarkerAPts ();
-   timeEnd=video_body->getMarkerBPts ();
-   
-   duration=timeEnd-timeStart;
-   if(duration<0) 
-    {
-            stream->goToTime (timeEnd);
-            duration=-duration;
-    }else
-    {
-            stream->goToTime (timeStart);
-    }
    duration*=stream->getInfo()->frequency;
    duration/=1000000; // in seconds to have samples
    tgt_sample=(uint64_t)floor(duration);
-   printf("[saveAudio] Start time :%"LLU" ms\n",timeStart/1000);
-   printf("[saveAudio] End time :%"LLU" ms\n",timeEnd/1000);
    printf("[saveAudio]Duration:%f ms\n",duration/1000);
    printf("[saveAudio]Samples:%"LLU" ms\n",tgt_sample);
 
@@ -323,6 +175,7 @@
    written = 0;
    hold=0;
    buffer=new uint8_t[ONE_STRIKE*2];
+
    while (1)
     {
     	if(!stream->getPacket(buffer+hold,&len,ONE_STRIKE,&sample,&dts)) break;
@@ -352,8 +205,89 @@
   return true;
 }
 
+/**
+        \fn A_saveAudioCopy
+        \brief Save current stream (generally avi...)     in raw mode
+*/
+int A_saveAudioCopy (const char *name)
+{ 
+  uint32_t written, max;
+  uint64_t dts;
 
+#define ONE_STRIKE (64*1024)
+  ADM_audioStream *stream;
+  if(false==video_body->getAudioStream( &stream)) 
+    {
+        ADM_error("[A_audioSave] No stream\n");
+        return false;
+    }
+
+  uint64_t timeEnd,timeStart;
+  double   duration;
+
+  // compute start position and duration in samples
+
+   timeStart=video_body->getMarkerAPts ();
+   timeEnd=video_body->getMarkerBPts ();
+   
+   duration=timeEnd-timeStart;
+   if(duration<0) 
+    {
+            stream->goToTime (timeEnd);
+            duration=-duration;
+    }else
+    {
+            stream->goToTime (timeStart);
+    }
+   ADM_info("Saving from %s \n",ADM_us2plain(timeStart));
+   ADM_info("Saving to %s \n",ADM_us2plain(timeEnd));
+   ADM_info("duration %s \n",ADM_us2plain((uint64_t)duration));
+   return A_saveAudioCommon (name,stream,duration);
+   
+}
+
+
 /**
+    \fn A_saveAudioProcessed
+    \brief Save current stream (generally avi...)
+     in decoded mode (assuming MP3)
+*/
+int A_saveAudioProcessed (const char *name)
+{
+#if 0
+    GUI_Error_HIG("Audio","Function not implemented\n");
+    return false;
+#else
+
+  uint64_t timeEnd,timeStart;
+  uint32_t hold,len,sample;
+  uint64_t tgt_sample,cur_sample;
+  double   duration;
+   timeStart=video_body->getMarkerAPts ();
+   timeEnd=video_body->getMarkerBPts ();
+   uint64_t start=timeStart;
+   duration=timeEnd-timeStart;
+   if(duration<0) 
+    {
+            start=timeEnd;
+            duration=-duration;
+    }
+  ADM_audioStream *access=audioCreateEncodingStream(false,start,0);
+  if(!access)
+    {
+        GUI_Error_HIG("Audio","Cannot create stream");
+        return false;
+    }
+  #warning Fixme,duration can change! e.g. pal2film /film2pal
+  bool r=A_saveAudioCommon (name,access,duration);
+  delete access;
+  if(false==r)
+        GUI_Error_HIG("Audio","Saving failed");
+  return r;
+#endif   
+}
+
+/**
         \fn A_saveJpg
         \brief Save a Jpg image from current display buffer
 */



From mean at mail.berlios.de  Sat Jan 29 10:57:31 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 29 Jan 2011 10:57:31 +0100
Subject: [Avidemux-svn-commit] r6967 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec
Message-ID: <20110129095731.3DA1F480F6B@sheep.berlios.de>

Author: mean
Date: 2011-01-29 10:57:31 +0100 (Sat, 29 Jan 2011)
New Revision: 6967

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
Log:
[audio encoder/lav] Cosmetic

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2011-01-29 09:57:29 UTC (rev 6966)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2011-01-29 09:57:31 UTC (rev 6967)
@@ -129,13 +129,13 @@
 
   if( _incoming->getInfo()->channels>ADM_LAV_MAX_CHANNEL)
   {
-    printf("[Lavcodec]Too many channels\n");
+    ADM_error("[Lavcodec]Too many channels\n");
     return 0; 
   }
   wavheader.byterate=(lavBitrate*1000)>>3;         
       
   _chunk = ADM_LAV_SAMPLE_PER_P*wavheader.channels; // AC3
-  printf("[Lavcodec]Incoming : fq : %"LU", channel : %"LU" bitrate: %"LU" \n",
+  ADM_info("[Lavcodec]Incoming : fq : %"LU", channel : %"LU" bitrate: %"LU" \n",
   wavheader.frequency,wavheader.channels,lavBitrate);
   
   
@@ -160,12 +160,12 @@
   ret = avcodec_open(CONTEXT, codec);
   if (0> ret) 
   {
-    printf("[Lavcodec] init failed err : %d!\n",ret);
+    ADM_error("[Lavcodec] init failed err : %d!\n",ret);
     return 0;
   }
 
 
-  printf("[Lavcodec]Lavcodec successfully initialized,wavTag : 0x%x\n",makeName(WAV));
+  ADM_info("[Lavcodec]Lavcodec successfully initialized,wavTag : 0x%x\n",makeName(WAV));
   return 1;       
 }
 /**
@@ -232,7 +232,7 @@
 cnt:
   if (nbout < 0) 
   {
-    printf("[Lavcodec] Error !!! : %"LD"\n", nbout);
+    ADM_error("[Lavcodec] Error !!! : %"LD"\n", nbout);
     return 0;
   }
   *len=nbout;
@@ -266,7 +266,7 @@
 
     diaElem *elems[]={&bitrate};
     
-    return ( diaFactoryRun(QT_TR_NOOP("Aften Configuration"),1,elems));
+    return ( diaFactoryRun(QT_TR_NOOP(ADM_LAV_MENU" (lav) Configuration"),1,elems));
     
 }	
 



From mean at mail.berlios.de  Sat Jan 29 10:57:32 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 29 Jan 2011 10:57:32 +0100
Subject: [Avidemux-svn-commit] r6968 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_audioFilter/src
	avidemux_core/ADM_coreAudio/include avidemux_core/ADM_coreAudio/src
Message-ID: <20110129095732.C570F480F6B@sheep.berlios.de>

Author: mean
Date: 2011-01-29 10:57:32 +0100 (Sat, 29 Jan 2011)
New Revision: 6968

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_encoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStream.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamMP3.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamMP3.cpp
Log:
[audio] Dont create timeMap on encoded audio stream, we dont need it and it causes problem

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_encoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_encoder.cpp	2011-01-29 09:57:31 UTC (rev 6967)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_encoder.cpp	2011-01-29 09:57:32 UTC (rev 6968)
@@ -141,7 +141,7 @@
     // 3b create threaded version
     ADM_audioAccess *threaded=ADM_threadifyAudioAccess(access);
     // 4- Create Stream 
-    ADM_audioStream *stream=ADM_audioCreateStream(encoder->getInfo(), threaded);
+    ADM_audioStream *stream=ADM_audioCreateStream(encoder->getInfo(), threaded,false); // No map, it is not seekable
     if(!stream)
     {
         printf("[Access] Cannot create stream\n");

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStream.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStream.h	2011-01-29 09:57:31 UTC (rev 6967)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStream.h	2011-01-29 09:57:32 UTC (rev 6968)
@@ -105,7 +105,7 @@
    \fn ADM_audioCreateStream
     \brief Create the appropriate audio stream. It will be a derivated class of audioStream if possible (MP3/AC3)
 */
-ADM_audioStream  *ADM_audioCreateStream(WAVHeader *wavheader, ADM_audioAccess *access);
+ADM_audioStream  *ADM_audioCreateStream(WAVHeader *wavheader, ADM_audioAccess *access,bool createTimeMap=true);
 #endif
 // EOF
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamMP3.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamMP3.h	2011-01-29 09:57:31 UTC (rev 6967)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamMP3.h	2011-01-29 09:57:32 UTC (rev 6968)
@@ -38,7 +38,7 @@
         bool            buildTimeMap(void);
         public:
 /// Default constructor
-                       ADM_audioStreamMP3(WAVHeader *header,ADM_audioAccess *access);  
+                       ADM_audioStreamMP3(WAVHeader *header,ADM_audioAccess *access, bool createMap=true);  
 /// Destructor
 virtual                 ~ADM_audioStreamMP3();
 ///  Get a packet

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp	2011-01-29 09:57:31 UTC (rev 6967)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp	2011-01-29 09:57:32 UTC (rev 6968)
@@ -132,7 +132,7 @@
 /**
                 Create the appropriate audio stream
 */
-ADM_audioStream  *ADM_audioCreateStream(WAVHeader *wavheader, ADM_audioAccess *access)
+ADM_audioStream  *ADM_audioCreateStream(WAVHeader *wavheader, ADM_audioAccess *access,bool makeTimeMap)
 {
 uint8_t *data;
 uint32_t size;
@@ -144,7 +144,7 @@
             return new ADM_audioStreamAC3(wavheader,access);
         case WAV_MP2:
         case WAV_MP3:
-            return new ADM_audioStreamMP3(wavheader,access);
+            return new ADM_audioStreamMP3(wavheader,access,makeTimeMap);
         case WAV_PCM:
         case WAV_LPCM:
             return new ADM_audioStreamPCM(wavheader,access);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamMP3.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamMP3.cpp	2011-01-29 09:57:31 UTC (rev 6967)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamMP3.cpp	2011-01-29 09:57:32 UTC (rev 6968)
@@ -13,7 +13,7 @@
     \fn ADM_audioStreamMP3
     \brief constructor
 */
-ADM_audioStreamMP3::ADM_audioStreamMP3(WAVHeader *header,ADM_audioAccess *access) : ADM_audioStreamBuffered(header,access)
+ADM_audioStreamMP3::ADM_audioStreamMP3(WAVHeader *header,ADM_audioAccess *access,bool createMap) : ADM_audioStreamBuffered(header,access)
 {
     // If hinted..., compute the duration ourselves
     if(access->isCBR()==true && access->canSeekOffset()==true)
@@ -32,8 +32,11 @@
     if( access->canSeekTime()==false)
     {
         ADM_assert(access->canSeekOffset()==true);
-        buildTimeMap();
-        return;
+        if(true==createMap)
+        {
+            buildTimeMap();
+            return;
+        }
     }
     // Time based
     durationInUs=access->getDurationInUs();
@@ -75,7 +78,11 @@
     if(access->isCBR()==true)
         return ADM_audioStream::goToTime(nbUs);
     // if VBR use our time map
-    ADM_assert(seekPoints.size());
+    if(!seekPoints.size())
+    {
+        ADM_error("VBR MP2/MP3 stream with no time map, cannot seek");
+        return false;
+    }
     // Search the switching point..
     for(int i=0;i<seekPoints.size()-1;i++)
     {



From mean at mail.berlios.de  Mon Jan 31 07:56:34 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 31 Jan 2011 07:56:34 +0100
Subject: [Avidemux-svn-commit] r6969 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_muxerGate/src
	avidemux_core/ADM_coreMuxer/include
Message-ID: <20110131065634.D3B3A481356@sheep.berlios.de>

Author: mean
Date: 2011-01-31 07:56:34 +0100 (Mon, 31 Jan 2011)
New Revision: 6969

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h
Log:
[muxer] Add frameIncrement info to videoStream , fps1000 only is not convenient

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2011-01-29 09:57:32 UTC (rev 6968)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2011-01-31 06:56:34 UTC (rev 6969)
@@ -42,6 +42,7 @@
     height=info.height;
     fourCC=info.fcc;
     averageFps1000=info.fps1000;
+    frameIncrement=video_body->getFrameIncrement();
     isCFR=false;
     // Estimate start frame
     if(false==video_body->getPKFramePTS(&ptsStart))

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp	2011-01-29 09:57:32 UTC (rev 6968)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp	2011-01-31 06:56:34 UTC (rev 6969)
@@ -30,6 +30,7 @@
     fcc=encoder->getFourcc();
     printf("[StreamProcess] Stream %"LU"x%"LU", codec : %s\n",width,height,fcc);
     fourCC=fourCC::get((uint8_t *)fcc);
+    frameIncrement=encoder->getFrameIncrement();
     float f=encoder->getFrameIncrement();
     if(f) f=1000000000./f;
         else f=25000;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h	2011-01-29 09:57:32 UTC (rev 6968)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h	2011-01-31 06:56:34 UTC (rev 6969)
@@ -24,8 +24,8 @@
             uint32_t fourCC;
             bool     isCFR;
             uint64_t videoDelay;
+            uint64_t frameIncrement;
 
-
             
 public:
                       ADM_videoStream() {videoDelay=0;} ;
@@ -36,7 +36,7 @@
             bool     getIsCfr(void) {return isCFR;}
             uint32_t getAvgFps1000(void) {return averageFps1000;}
             uint64_t getVideoDelay(void) {return videoDelay;}
-
+            uint64_t getFrameIncrement(void) {return frameIncrement;}
 virtual     bool     getPacket(ADMBitstream *out)=0;
 virtual     bool     getExtraData(uint32_t *extraLen, uint8_t **extraData) {*extraLen=0;*extraData=NULL;return true;};
 virtual     bool     providePts(void) {return false;}



From mean at mail.berlios.de  Mon Jan 31 07:56:36 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 31 Jan 2011 07:56:36 +0100
Subject: [Avidemux-svn-commit] r6970 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110131065636.12043481356@sheep.berlios.de>

Author: mean
Date: 2011-01-31 07:56:35 +0100 (Mon, 31 Jan 2011)
New Revision: 6970

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
Log:
[mp4v2] Guess missing dts, fail if pts is missing (copy from AVI)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-31 06:56:34 UTC (rev 6969)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.cpp	2011-01-31 06:56:35 UTC (rev 6970)
@@ -78,6 +78,7 @@
         scratchBuffer=NULL;
         nextWrite=0;
         needToConvertFromAnnexB=false;
+        lastVideoDts=0;
 };
 /**
     \fn     muxerMp4v2
@@ -121,12 +122,15 @@
         }
         for(int i=0;i<nbAStreams;i++)
         {
-            if(0) //if(aStreams[i]->getInfo()->encoding!=WAV_AAC)
+            int encoding=aStreams[i]->getInfo()->encoding;
+            switch(encoding)
             {
-                ADM_error("[mp4v2] Only AAC audio!\n");
-                return false;
-            }
-            
+                case WAV_MP2:case WAV_MP3:case WAV_AAC:case WAV_AC3:
+                            continue;
+                default:
+                    GUI_Error_HIG("Audio","Audio format not supported, only AAC/MP3/AC3");
+                    return false;
+            }            
         }
 //------Verify everything is ok : Accept Mp4 & H264 for video, AAC for audio ----
         
@@ -179,9 +183,12 @@
         if(in[other].flags & AVI_KEY_FRAME) kf=true;
 
         ADM_assert(in[nextWrite].dts!=ADM_NO_PTS)
-        ADM_assert(in[other].pts!=ADM_NO_PTS)
         ADM_assert(in[nextWrite].dts!=ADM_NO_PTS)
-        ADM_assert(in[other].pts!=ADM_NO_PTS)
+        if(in[other].pts==ADM_NO_PTS || in[other].pts==ADM_NO_PTS)
+        {
+            GUI_Error_HIG("Video","Video does not have enough timing information. Are you copying from AVI ?");
+            goto theEnd;
+        }
 
         
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-31 06:56:34 UTC (rev 6969)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2.h	2011-01-31 06:56:35 UTC (rev 6970)
@@ -68,6 +68,7 @@
         bool            needToConvertFromAnnexB;
         uint8_t         *scratchBuffer;
         string          targetFileName;
+        uint64_t        lastVideoDts;
 protected: // video
         bool            initMpeg4(void);
         bool            initH264(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-31 06:56:34 UTC (rev 6969)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-01-31 06:56:35 UTC (rev 6970)
@@ -47,14 +47,18 @@
             bs->pts=tmp.pts;
             bs->flags=tmp.flags;
             bs->len=ADM_convertFromAnnexBToMP4(scratchBuffer,tmp.len, bs->data,videoBufferSize);
-            return true;
+            goto goOn;
         }
     if(false==vStream->getPacket(bs))
         {
             return false;
         }
-
-    
+goOn:
+    if(bs->dts==ADM_NO_PTS)
+    {
+        bs->dts=lastVideoDts+vStream->getFrameIncrement();
+    }
+    lastVideoDts=bs->dts;
     return true;
 }
 /**



