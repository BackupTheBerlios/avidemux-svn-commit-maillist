<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5835 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common/ADM_commonUI	avidemux/common/ADM_editor avidemux/common/ADM_script	avidemux/qt4/ADM_userInterfaces/ADM_dialog	avidemux/qt4/ADM_userInterfaces/ADM_gui	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src cmake
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-January/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5835%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux%20avidemux/common/ADM_commonUI%0A%09avidemux/common/ADM_editor%20avidemux/common/ADM_script%0A%09avidemux/qt4/ADM_userInterfaces/ADM_dialog%0A%09avidemux/qt4/ADM_userInterfaces/ADM_gui%0A%09avidemux_core/ADM_coreVideoCodec/include%0A%09avidemux_core/ADM_coreVideoCodec/src%20cmake&In-Reply-To=%3C201001101808.o0AI8xJ3013417%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003040.html">
   <LINK REL="Next"  HREF="003042.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5835 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common/ADM_commonUI	avidemux/common/ADM_editor avidemux/common/ADM_script	avidemux/qt4/ADM_userInterfaces/ADM_dialog	avidemux/qt4/ADM_userInterfaces/ADM_gui	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src cmake</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5835%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux%20avidemux/common/ADM_commonUI%0A%09avidemux/common/ADM_editor%20avidemux/common/ADM_script%0A%09avidemux/qt4/ADM_userInterfaces/ADM_dialog%0A%09avidemux/qt4/ADM_userInterfaces/ADM_gui%0A%09avidemux_core/ADM_coreVideoCodec/include%0A%09avidemux_core/ADM_coreVideoCodec/src%20cmake&In-Reply-To=%3C201001101808.o0AI8xJ3013417%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5835 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common/ADM_commonUI	avidemux/common/ADM_editor avidemux/common/ADM_script	avidemux/qt4/ADM_userInterfaces/ADM_dialog	avidemux/qt4/ADM_userInterfaces/ADM_gui	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src cmake">mean at mail.berlios.de
       </A><BR>
    <I>Sun Jan 10 19:08:59 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003040.html">[Avidemux-svn-commit] r5834 - in branches/avidemux_2.6_branch_mean:	avidemux/common avidemux/common/ADM_codecs avidemux_core	avidemux_core/ADM_coreVideoCodec	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src
</A></li>
        <LI>Next message: <A HREF="003042.html">[Avidemux-svn-commit] r5836 - in	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces:	ADM_dialog ADM_gui2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3041">[ date ]</a>
              <a href="thread.html#3041">[ thread ]</a>
              <a href="subject.html#3041">[ subject ]</a>
              <a href="author.html#3041">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-01-10 19:08:56 +0100 (Sun, 10 Jan 2010)
New Revision: 5835

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecEmpty.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake
Log:
[Codec] Move codec to core as a shared library before making them plugins

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt	2010-01-10 18:08:56 UTC (rev 5835)
@@ -13,7 +13,7 @@
 DIA_lavDecoder.cpp  
 DIA_requant.cpp   
 #DIA_ocr.cpp             
-DIA_tsSub.cpp        
+#DIA_tsSub.cpp        
 DIA_jobs_save.cpp
 DIA_flv1.cpp            
 DIA_plugins.cpp

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -37,9 +37,9 @@
 {
 	if(_segments.getNbSegments())
     {
-        _VIDEOS *vid=_segments.getRefVideo(0);
-		if(vid-&gt;decoder)
-	 		return vid-&gt;decoder-&gt;getSpecificMpeg4Info();
+ //       _VIDEOS *vid=_segments.getRefVideo(0);
+//		if(vid-&gt;decoder)
+//	 		return vid-&gt;decoder-&gt;getSpecificMpeg4Info();
     }
 	return 0;
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-10 18:08:56 UTC (rev 5835)
@@ -27,7 +27,7 @@
  #ifndef __ADM_composer__
  #define __ADM_composer__
  #include &quot;ADM_Video.h&quot;
- #include &quot;../ADM_codecs/ADM_codec.h&quot;
+ #include &quot;ADM_codec.h&quot;
  #include &quot;ADM_image.h&quot;
  #include &quot;../ADM_editor/ADM_edCache.h&quot;
  #include &quot;ADM_pp.h&quot;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -16,7 +16,7 @@
  ***************************************************************************/
 #include &quot;ADM_default.h&quot;
 #include &quot;ADM_segment.h&quot;
-#include &quot;../ADM_codecs/ADM_codec.h&quot;
+#include &quot;ADM_codec.h&quot;
 #include &quot;ADM_image.h&quot;
 #include &quot;../ADM_editor/ADM_edCache.h&quot;
 #include &quot;ADM_pp.h&quot;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -472,7 +472,7 @@
          
         // default return value
         *rval=JS_FALSE;
-        if(info &amp; ADM_VOP_ON) *rval=JS_TRUE;
+        //if(info &amp; ADM_VOP_ON) *rval=JS_TRUE;
         return JS_TRUE;
 }// end PostProcess
 /**
@@ -492,7 +492,7 @@
         
         // default return value
         *rval=JS_FALSE;
-        if(info &amp; ADM_GMC_ON) *rval=JS_TRUE;
+        //if(info &amp; ADM_GMC_ON) *rval=JS_TRUE;
         return JS_TRUE;
 }// end PostProcess
 /**
@@ -511,7 +511,7 @@
         leaveLock(); 
         
         *rval=JS_FALSE;
-        if(info &amp; ADM_QPEL_ON) *rval=JS_TRUE;
+        //if(info &amp; ADM_QPEL_ON) *rval=JS_TRUE;
         return JS_TRUE;
 }// end PostProcess
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-10 18:08:56 UTC (rev 5835)
@@ -88,7 +88,7 @@
 ADM_audioFilter6
 ADM_editor6
 ADM_audiocodec6 
-ADM_codecs6 
+ADM_coreVideoCodec6 
 ADM_commonUI6
 )
 SET(commonLibs2

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -35,13 +35,13 @@
     text[0] = 0;
     if (!avifileinfo)
         return;
-  
+#if 0  
         // Fetch info
         info=video_body-&gt;getSpecificMpeg4Info();
         vop=!!(info &amp; ADM_VOP_ON);
         qpel=!!(info &amp; ADM_QPEL_ON);
         gmc=!!(info &amp; ADM_GMC_ON);
-
+#endif
 #define FILLTEXT(a,b,c) {snprintf(text,79,b,c);ui.a-&gt;setText(text);}
 #define FILLTEXT4(a,b,c,d) {snprintf(text,79,b,c,d);ui.a-&gt;setText(text);}
 #define FILLTEXT5(a,b,c,d,e) {snprintf(text,79,b,c,d,e);ui.a-&gt;setText(text);}

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -21,7 +21,7 @@
 #include &quot;Q_gui2.h&quot;
 #include &quot;ADM_default.h&quot;
 
-#include &quot;ADM_codecs/ADM_codec.h&quot;
+//#include &quot;ADM_codecs/ADM_codec.h&quot;
 #include &quot;gui_action.hxx&quot;
 #include &quot;ADM_editor/ADM_outputfmt.h&quot;
 #include &quot;DIA_fileSel.h&quot;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,9 +1,8 @@
 /***************************************************************************
-                          ADM_codec.h  -  description
-                             -------------------
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+         \fn ADM_codec.h
+         \brief Base class for all decoders
+         \author mean, <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> (C) 2002-2010
+    
  ***************************************************************************/
 
 /***************************************************************************
@@ -14,16 +13,13 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#ifndef __CODECS__
-#define __CODECS__
+#ifndef __ADM_CODECS__
+#define __ADM_CODECS__
 
 #include &quot;ADM_image.h&quot;
 #include &quot;ADM_frameType.h&quot;
 #include &quot;ADM_codecType.h&quot;
 
-#define ADM_QPEL_ON	1
-#define ADM_GMC_ON	2
-#define ADM_VOP_ON	4
 
 /*
         Bitrate in configuration will always be in **kBITS**
@@ -43,7 +39,7 @@
   uint32_t _h;
   uint8_t _lastQ;
 public:
-    decoders (uint32_t w, uint32_t h)
+    decoders (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
   {
     _w = w;
     _h = h;
@@ -60,63 +56,46 @@
   {
     return 1;
   };
-  virtual void setParam (void)
+  virtual bool setParam (void)
   {
+        return false;
   };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)=0;
+  virtual bool uncompress (ADMCompressedImage * in, ADMImage * out)=0;
 
   // does this codec *possibly* can have b-frame ?
-  virtual uint8_t dontcopy (void)
+  virtual bool dontcopy (void)
   {
-    return 0;
+    return false;
   }				// if 1 means the decoder will return reference
   // no need to copy the datas to ADMimage
-  virtual uint8_t bFramePossible (void)
+  virtual bool bFramePossible (void)
   {
-    return 0;
+    return false;
   }
-  virtual uint8_t decodeHeaderOnly (void)
+  virtual bool decodeHeaderOnly (void)
   {
-    return 0;
+    return false;
   };
-  virtual uint8_t decodeFull (void)
+  virtual bool decodeFull (void)
   {
-    return 0;
+    return false;
   }
-  virtual uint8_t isDivxPacked (void)
-  {
-    return 0;
-  };
-  virtual uint32_t getSpecificMpeg4Info (void)
-  {
-    return 0;
-  };
-  virtual uint8_t isIndexable (void)
-  {
-    return 1;
-  };
   virtual bool flush(void)
     {
         return true;
     }
 };
-/* Dummy decoder in case we don't have the desired one */
-class decoderEmpty : public decoders
-{
-protected:
-public:
-    decoderEmpty (uint32_t w, uint32_t h) : decoders(w,h) {};
-    uint8_t uncompress (ADMCompressedImage * in, ADMImage * out) {return 1;}
 
-};
-
 decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
 		      uint8_t * extraData,uint32_t bpp=0);
+#if 0
 decoders *getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h,
 			       uint32_t extraLen, uint8_t * extraData);
 decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
 		     uint8_t * extraData);
 
+//***************************************
+
 class coders
 {
 protected:
@@ -154,7 +133,7 @@
   }
 };
 
+#endif
 
 
-
 #endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecEmpty.h (from rev 5834, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecEmpty.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -0,0 +1,31 @@
+/***************************************************************************
+         \fn ADM_codecEmpty.h
+         \brief Empty decoder
+         \author mean, <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> (C) 2002-2010
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_codecEmpty_H
+#define ADM_codecEmpty_H
+/* Dummy decoder in case we don't have the desired one */
+class decoderEmpty : public decoders
+{
+protected:
+public:
+    decoderEmpty (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+        :decoders (  w,   h,  fcc,   extraDataLen,  extraData,  bpp)
+    {
+
+    }
+    bool uncompress (ADMCompressedImage * in, ADMImage * out) {return true;}
+
+};
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -19,13 +19,14 @@
 protected:
 
 public:
-  decoderNull (uint32_t w, uint32_t h):decoders (w, h)
+  decoderNull (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+        :decoders (  w,   h,  fcc,   extraDataLen,  extraData,  bpp)
   {
   }
   virtual ~ decoderNull ()
   {
   };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)
+  virtual bool uncompress (ADMCompressedImage * in, ADMImage * out)
   {
     memcpy (out-&gt;data, in-&gt;data, in-&gt;dataLength);
     return 1;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -19,6 +19,7 @@
  ***************************************************************************/
 
 #include &quot;ADM_lavcodec.h&quot;
+#if 0
 class decoderFFSubs
 {
   protected:
@@ -31,8 +32,11 @@
     virtual ~ decoderFFSubs ();
     virtual uint8_t uncompress (ADMCompressedImage * in, AVSubtitle * out); 
 };
-
-/****************************/
+#endif
+/**
+    \class decoderFF
+    \brief Base class for lavcodec based decoder
+*/
 class decoderFF:public decoders
 {
 protected:
@@ -52,22 +56,21 @@
   uint32_t _usingMT;
 public:
 
-    decoderFF (uint32_t w, uint32_t h);
+    decoderFF (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
     virtual ~ decoderFF ();
-  virtual uint8_t dontcopy (void)
+  virtual bool dontcopy (void)
   {
-    return 1;
+    return true;
   }
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-  virtual void setParam (void);
-  virtual uint8_t bFramePossible (void)
+  virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
+  virtual bool setParam (void);
+  virtual bool bFramePossible (void)
   {
-    return 0;
+    return false;
   }
-  virtual uint8_t decodeHeaderOnly (void);
-  virtual uint8_t decodeFull (void);
-  virtual uint8_t isDivxPacked (void);
-  virtual uint32_t getSpecificMpeg4Info (void);
+  virtual bool decodeHeaderOnly (void);
+  virtual bool decodeFull (void);
+//  virtual uint32_t getSpecificMpeg4Info (void);
   virtual uint8_t getPARWidth (void);
   virtual uint8_t getPARHeight (void);
   virtual bool    flush(void);
@@ -80,9 +83,10 @@
 
 public:
 
-  decoderFFDiv3 (uint32_t w, uint32_t h);
+  decoderFFDiv3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
+#if 0
 class decoderFFMpeg4VopPacked:public decoderFF
 {
 protected:
@@ -102,16 +106,17 @@
     return 0;
   };
 };
+#endif
 class decoderFFMpeg4:public decoderFF
 {
 protected:
 
 
 public:
-  decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d);
-  uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+        decoderFFMpeg4 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
+  bool uncompress (ADMCompressedImage * in, ADMImage * out);
   // mpeg4 can have B-frame
-  virtual uint8_t bFramePossible (void)
+  virtual bool bFramePossible (void)
   {
     return 1;
   }
@@ -123,9 +128,9 @@
 
 
 public:
-  decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFMpeg12 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
   // mpeg1/2 can have B-frame
-  virtual uint8_t bFramePossible (void)
+  virtual bool bFramePossible (void)
   {
     return 1;
   }
@@ -137,8 +142,8 @@
 
 
 public:
-  decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-  virtual uint8_t bFramePossible (void)
+  decoderFFSVQ3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
+  virtual bool bFramePossible (void)
   {
     return 0;
   }
@@ -151,7 +156,7 @@
 
 
 public:
-  decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFDV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFMP42:public decoderFF
@@ -160,7 +165,7 @@
 
 
 public:
-  decoderFFMP42 (uint32_t w, uint32_t h);
+  decoderFFMP42 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFH263:public decoderFF
@@ -169,7 +174,7 @@
 
 
 public:
-  decoderFFH263 (uint32_t w, uint32_t h);
+  decoderFFH263 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFH264:public decoderFF
@@ -178,12 +183,12 @@
   uint32_t _lowDelay;
 
 public:
-  decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t lowdelay);
-  virtual uint8_t bFramePossible (void)
+  decoderFFH264 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
+  virtual bool bFramePossible (void)
   {
       return _lowDelay;
   }
-  uint8_t   uncompress (ADMCompressedImage * in, ADMImage * out);
+  bool   uncompress (ADMCompressedImage * in, ADMImage * out);
 
 };
 class decoderFFhuff:public decoderFF
@@ -192,7 +197,7 @@
 
 
 public:
-  decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
+  decoderFFhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFF_ffhuff:public decoderFF
@@ -201,7 +206,7 @@
 
 
 public:
-  decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
+  decoderFF_ffhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFWMV2:public decoderFF
@@ -210,7 +215,7 @@
 
 
 public:
-  decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFWMV2 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFWMV1:public decoderFF
@@ -219,7 +224,7 @@
 
 
   public:
-    decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+    decoderFFWMV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 
@@ -229,7 +234,7 @@
 
 
 public:
-  decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFWMV3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 
@@ -239,7 +244,7 @@
 
 
 public:
-  decoderFFVC1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFVC1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 
@@ -249,7 +254,7 @@
 
 
 public:
-  decoderFFV1 (uint32_t w, uint32_t h);
+  decoderFFV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFMJPEG:public decoderFF
@@ -258,7 +263,7 @@
 
 
 public:
-  decoderFFMJPEG (uint32_t w, uint32_t h);
+  decoderFFMJPEG (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderSnow:public decoderFF
@@ -267,7 +272,7 @@
 
 
 public:
-  decoderSnow (uint32_t w, uint32_t h);
+  decoderSnow (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFcyuv:public decoderFF
@@ -276,7 +281,7 @@
 
 
 public:
-  decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFcyuv (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderCamtasia:public decoderFF
@@ -285,7 +290,7 @@
 
 
 public:
-  decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp);
+  decoderCamtasia (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFTheora:public decoderFF
@@ -294,7 +299,7 @@
 
 
 public:
-  decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFTheora (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 
@@ -304,7 +309,7 @@
 
 
 public:
-  decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFCinepak (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFCRAM:public decoderFF
@@ -313,50 +318,50 @@
 
 
 public:
-  decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFCRAM (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFVP6F:public decoderFF
 {
 protected:
 public:
-  decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFVP6F (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFVP6A:public decoderFF
 {
 protected:
 public:
-  decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFVP6A (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFFLV1:public decoderFF
 {
 protected:
 public:
-  decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFFLV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFDVBSub:public decoderFF
 {
 protected:
 public:
-  decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFDVBSub (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFAMV:public decoderFF
 {
 protected:
 public:
-  decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFAMV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFMjpegB:public decoderFF
 {
 protected:
 public:
-  decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFMjpegB (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFSVQ1:public decoderFF
 {
 protected:
 public:
-  decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFSVQ1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 
 #ifdef USE_VDPAU
@@ -380,12 +385,12 @@
             // public API
                     decoderFFVDPAU (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
                     ~decoderFFVDPAU();
-    virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-    virtual uint8_t dontcopy (void)
+    virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
+    virtual bool dontcopy (void)
                       {
                         return 0;
                       }
-     virtual uint8_t bFramePossible (void)
+    virtual bool bFramePossible (void)
       {
         return 1;
       }

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,29 +0,0 @@
-/***************************************************************************
-                          ADM_mjpeg.h  -  description
-                             -------------------
-    begin                : Sat Apr 13 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-class decoderMjpeg:decoders
-{
-protected:
-  uint8_t _swap;
-
-public:
-  decoderMjpeg (uint32_t w, uint32_t h);
-  virtual ~ decoderMjpeg ();
-  virtual void setParam (void);
-  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			      uint32_t * flag = NULL);
-};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -16,63 +16,49 @@
  ***************************************************************************/ 
 #ifndef PNG_H_A
 #define PNG_H_A
-#ifdef USE_PNG
 
+/**
+    \struct memAccess   
+    \brief png io wrapper
+*/
 typedef struct memAccess 
 {
   
-int size;
-   
+int size;   
 int cur;
-   
 uint8_t * data;
-
-
 } memAccess;
 
-
+/**
+    \class decoderPng
+*/
 class decoderPng:public decoders 
 {
 
 protected:
-memAccess io;
-  
-ADM_colorspace colorspace;
-  
-void *png_ptr;
-  
-void *info_ptr;
-  
-void *end_info;
-  
+    memAccess io;      
+    ADM_colorspace colorspace;
+    void *png_ptr;
+    void *info_ptr;
+    void *end_info;
+    uint8_t ** rows;      
+    uint8_t * decoded;
+    void Init (void);
+    void Cleanup (void);
+    void recalc (void);
 
-uint8_t ** rows;
-  
-uint8_t * decoded;
-  
-void Init (void);
-  
-void Cleanup (void);
-  
-void recalc (void);
-
 public:
-decoderPng (uint32_t w, uint32_t h);
+            decoderPng (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
   
-virtual ~ decoderPng ();
+    virtual ~ decoderPng ();
   
-virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
+    virtual bool uncompress(ADMCompressedImage * in, ADMImage * out);
   
-uint8_t dontcopy (void)
-  {
-    return 1;
-  }
-
-
-
+    bool dontcopy (void)
+            {
+                return true;
+            }
 };
 
-#endif /* 
- */
-#endif /* 
- */
+#endif 
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -16,7 +16,7 @@
  ***************************************************************************/
 #ifndef ADM_RGB16_H
 #define ADM_RGB16_H
-
+#include &quot;ADM_codec.h&quot;
 #include &quot;ADM_colorspace.h&quot;
 
 class decoderRGB16 : decoders
@@ -24,15 +24,15 @@
 	protected:
 		uint8_t* planar;
 		ColRgbToYV12* color;
-		uint32_t isRgb; // Else BGR
+		bool     isRgb; // Else BGR
 		uint32_t _bpp;
 		uint8_t* decoded;
 
 	public:
-		uint8_t dontcopy (void) { return 1; }
-		decoderRGB16 (uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp);
+		bool dontcopy (void) { return 1; }
+		decoderRGB16 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 		virtual ~decoderRGB16();
-		virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
+		virtual bool uncompress(ADMCompressedImage * in, ADMImage * out);
 };
 
 #endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,46 +0,0 @@
-/***************************************************************************
-                          ADM_theora_dec.h  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef USE_THEORA
-#ifndef __theora__
-#define __theora__
-
-extern &quot;C&quot;
-{
-#include &quot;theora/theora.h&quot;
-}
-class decoderTheora:public decoders
-{
-protected:
-
-
-  theora_info _tinfo;
-  theora_state _tstate;
-
-
-
-public:
-    decoderTheora (uint32_t w, uint32_t h);
-    virtual ~ decoderTheora ();
-  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			      uint32_t * flag = NULL);
-  virtual void setParam (void);
-
-
-};
-
-#endif
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,16 +0,0 @@
-/***************************************************************************
-                          ADM_theora_enc.h  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -9,29 +9,35 @@
 // Copyright: See COPYING file that comes with this distribution
 //
 //
+#ifndef ADM_YUYV_H
+#define ADM_YUYV_H
+#include &quot;ADM_codec.h&quot;
 class decoderUYVY:decoders
 {
 protected:
 
 public:
-  decoderUYVY (uint32_t w, uint32_t h):decoders (w, h)
+  decoderUYVY (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+                :decoders (  w,   h,  fcc,   extraDataLen,  extraData,  bpp)
   {
   };
   virtual ~ decoderUYVY ()
   {
   };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+  virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
 };
 class decoderYUY2:decoders
 {
 protected:
 
 public:
-  decoderYUY2 (uint32_t w, uint32_t h):decoders (w, h)
+  decoderYUY2 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+                :decoders (  w,   h,  fcc,   extraDataLen,  extraData,  bpp)
   {
   };
   virtual ~ decoderYUY2 ()
   {
   };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+  virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
 };
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp (from rev 5834, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -0,0 +1,247 @@
+/***************************************************************************
+                          ADM_codecs.cpp  -  description
+                             -------------------
+    begin                : Fri Apr 12 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    see here : <A HREF="http://www.webartz.com/fourcc/">http://www.webartz.com/fourcc/</A>
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+extern &quot;C&quot;
+{
+#include &quot;ADM_lavcodec.h&quot;
+};
+#include &quot;ADM_default.h&quot;
+
+#ifdef BIG_ENDIAN
+#undef BIG_ENDIAN
+#endif
+
+#include &quot;ADM_codec.h&quot;
+#include &quot;ADM_codecNull.h&quot;
+#include &quot;ADM_rgb16.h&quot;
+#include &quot;ADM_uyvy.h&quot;
+#include &quot;ADM_png.h&quot;
+#include &quot;ADM_codecEmpty.h&quot;
+#include &quot;ADM_ffmp43.h&quot;
+
+#include &quot;avidemutils.h&quot;
+#include &quot;fourcc.h&quot;
+
+extern uint8_t GUI_Question (char *);
+extern uint8_t use_fast_ffmpeg;
+extern bool vdpauUsable(void);
+
+/**
+    \fn getDecoder
+    \brief returns the correct decoder for a stream w,h,fcc,extraLen,extraData,bpp
+*/
+decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp)
+{
+  ADM_info(&quot;Searching decoder (%d x %d, extradataSize:%d)...\n&quot;,w,h,extraLen);
+  if (isMSMpeg4Compatible (fcc) == 1)
+    {
+      // For div3, no problem we take ffmpeg
+
+      return (decoders *) (new decoderFFDiv3 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (isDVCompatible(fcc))//&quot;CDVC&quot;))
+    {
+
+      return (decoders *) (new decoderFFDV (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;MP42&quot;))
+    {
+
+      return (decoders *) (new decoderFFMP42 (w,h,fcc,extraLen,extraData,bpp));
+    }
+    if (fourCC::check (fcc, (uint8_t *) &quot;FLV1&quot;))
+    {
+      return (decoders *) (new decoderFFFLV1 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;H263&quot;))
+    {
+
+      return (decoders *) (new decoderFFH263 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;HFYU&quot;))
+    {
+
+      return (decoders *) (new decoderFFhuff (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;PNG &quot;))
+    {
+
+      return (decoders *) (new decoderPng (w,h,fcc,extraLen,extraData,bpp));
+    }
+ if (fourCC::check (fcc, (uint8_t *) &quot;cvid&quot;))
+    {
+
+      return (decoders *) (new decoderFFCinepak (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;FFVH&quot;))
+    {
+
+      return (decoders *) (new decoderFF_ffhuff (w,h,fcc,extraLen,extraData,bpp));
+    }
+if (fourCC::check (fcc, (uint8_t *) &quot;SVQ1&quot;))
+    {
+
+      return (decoders *) (new decoderFFSVQ1 (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) &quot;SVQ3&quot;))
+    {
+
+      return (decoders *) (new decoderFFSVQ3 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;tscc&quot;))
+    {
+
+      return (decoders *) (new decoderCamtasia (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+     if (fourCC::check (fcc, (uint8_t *) &quot;CRAM&quot;))
+    {
+
+      return (decoders *) (new decoderFFCRAM (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;WMV2&quot;))
+    {
+
+      return (decoders *) (new decoderFFWMV2 (w,h,fcc,extraLen,extraData,bpp));
+    }
+    if (fourCC::check (fcc, (uint8_t *) &quot;WMV1&quot;))
+    {
+
+      return (decoders *) (new decoderFFWMV1 (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) &quot;WMV3&quot;) )
+    {
+
+      return (decoders *) (new decoderFFWMV3 (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+    if (fourCC::check (fcc, (uint8_t *) &quot;WVC1&quot;)|| fourCC::check (fcc, (uint8_t *) &quot;WMVA&quot;))
+    {
+
+      return (decoders *) (new decoderFFVC1 (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+if (fourCC::check (fcc, (uint8_t *) &quot;FFV1&quot;))
+    {
+
+      return (decoders *) (new decoderFFV1 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;SNOW&quot;))
+    {
+
+      return (decoders *) (new decoderSnow (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (isH264Compatible (fcc))
+    {
+#if defined(USE_VDPAU) &amp;&amp; 0
+        if(vdpauUsable()==true)
+            return (decoders *) (new decoderFFVDPAU (w,h,fcc,extraLen,extraData,bpp));
+        else
+#endif
+            return (decoders *) (new decoderFFH264 (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+
+/*
+	Could be either divx5 packed crap or xvid or ffmpeg
+	For now we return FFmpeg and later will switch to divx5 if available
+		(ugly hack for ugly hack....)
+*/
+
+  if (isMpeg4Compatible (fcc) == 1)
+    {
+      return (decoders *) (new decoderFFMpeg4 (w,h,fcc,extraLen,extraData,bpp));
+      //    return(decoders *)( new decoderXvid(w,h));
+      //    return(decoders *)( new decoderDIVX(w,h));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) &quot;MJPB&quot;))
+    {
+      printf (&quot;\n using FF mjpeg codec\n&quot;);
+      return (decoders *) (new decoderFFMjpegB (w,h,fcc,extraLen,extraData,bpp));
+    }
+if (fourCC::check (fcc, (uint8_t *) &quot;MJPG&quot;)
+      || fourCC::check (fcc, (uint8_t *) &quot;mjpa&quot;))
+    {
+      printf (&quot;\n using FF mjpeg codec\n&quot;);
+      return (decoders *) (new decoderFFMJPEG (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;YV12&quot;)
+      || fourCC::check (fcc, (uint8_t *) &quot;yv12&quot;)
+      || fourCC::check (fcc, (uint8_t *) &quot;I420&quot;))
+    {
+      printf (&quot;\n using null codec\n&quot;);
+      return (decoders *) (new decoderNull (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;UYVY&quot;))
+    {
+      printf (&quot;\n using uyvy codec\n&quot;);
+      return (decoders *) (new decoderUYVY (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;YUY2&quot;))
+    {
+      printf (&quot;\n using YUY2 codec\n&quot;);
+      return (decoders *) (new decoderYUY2 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;AMV &quot;))
+    {
+      printf (&quot;\n using AMV codec\n&quot;);
+      return (decoders *) (new decoderFFAMV (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+ if (fourCC::check (fcc, (uint8_t *) &quot;VP6A&quot;))
+    {
+      printf (&quot;\n using YUY2 codec\n&quot;);
+      return (decoders *) (new decoderFFVP6A (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (isVP6Compatible(fcc))
+    {
+      printf (&quot;\n using VP6F codec\n&quot;);
+      return (decoders *) (new decoderFFVP6F (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+
+  if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) &quot;RGB &quot;))
+    {
+      // RGB 16 Codecs
+      printf (&quot;\n using RGB codec\n&quot;);
+      return (decoders *) (new decoderRGB16 (w,h,fcc,extraLen,extraData,bpp)); //1
+
+    }
+ if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) &quot;DIB &quot;))
+    {
+      // RGB 16 Codecs
+      printf (&quot;\n using DIB codec\n&quot;);
+      return (decoders *) (new decoderRGB16 (w,h,fcc,extraLen,extraData,bpp));  //0
+
+    }
+  if (isMpeg12Compatible (fcc))
+	  return (decoders *) (new decoderFFMpeg12 (w,h,fcc,extraLen,extraData,bpp));
+
+  // default : null decoder
+  printf (&quot;\n using invalid codec for \n&quot;);
+  fourCC::print (fcc);
+
+  return (decoders *) (new decoderEmpty(w,h,fcc,extraLen,extraData,bpp));
+}
+//EOF
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -17,296 +17,19 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include &quot;config.h&quot;
-
-
-#ifdef USE_FFMPEG
-extern &quot;C&quot;
-{
-#include &quot;ADM_lavcodec.h&quot;
-};
-#endif
 #include &quot;ADM_default.h&quot;
-#ifdef BIG_ENDIAN
-#undef BIG_ENDIAN
-#endif
-
-//#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#ifdef USE_XX_XVID
-#include &quot;xvid.h&quot;
-#endif
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_mjpeg.h&quot;
-#include &quot;ADM_codecs/ADM_codecNull.h&quot;
-#include &quot;ADM_codecs/ADM_rgb16.h&quot;
-#include &quot;ADM_codecs/ADM_uyvy.h&quot;
-#include &quot;avidemutils.h&quot;
-#include &quot;fourcc.h&quot;
-
-
-#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
-
-
-#ifdef USE_THEORA
-#include &quot;ADM_codecs/ADM_theora_dec.h&quot;
-#endif
-
-#include &quot;ADM_codecs/ADM_png.h&quot;
-
-#include &quot;ADM_assert.h&quot;
-#include &quot;prefs.h&quot;
-
-extern uint8_t GUI_Question (char *);
-extern uint8_t use_fast_ffmpeg;
-extern bool vdpauUsable(void);
-
-uint8_t
-  decoders::uncompress (ADMCompressedImage * in, ADMImage * out)
+#include &quot;ADM_codec.h&quot;
+/**
+    \fn uncompress
+*/
+bool  decoders::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
   UNUSED_ARG (in);
   UNUSED_ARG (out);
-  return 0;
+  return false;
 }
-decoders *
-getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData)
-{
-  UNUSED_ARG (fcc);
-  UNUSED_ARG (extraLen);
-  UNUSED_ARG (extraData);
-  return (decoders *) (new decoderFFMpeg4VopPacked (w, h));
 
-}
-decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData)
-{
-  UNUSED_ARG (fcc);
-  UNUSED_ARG (extraLen);
-  UNUSED_ARG (extraData);
-  return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,0));
-
-}
-/**
-    \fn getDecoder
-    \brief returns the correct decoder for a stream
-*/
-decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-	    uint8_t * extraData,uint32_t bpp)
-{
-  printf(&quot;\nSearching decoder (%d x %d, extradataSize:%d)...\n&quot;,w,h,extraLen);
-  if (isMSMpeg4Compatible (fcc) == 1)
-    {
-      // For div3, no problem we take ffmpeg
-
-      return (decoders *) (new decoderFFDiv3 (w, h));
-    }
-
-#ifdef USE_FFMPEG
-  if (isDVCompatible(fcc))//&quot;CDVC&quot;))
-    {
-
-      return (decoders *) (new decoderFFDV (w, h, extraLen, extraData));
-    }
-#endif
-#ifdef USE_FFMPEG
-  if (fourCC::check (fcc, (uint8_t *) &quot;MP42&quot;))
-    {
-
-      return (decoders *) (new decoderFFMP42 (w, h));
-    }
-#endif
-    if (fourCC::check (fcc, (uint8_t *) &quot;FLV1&quot;))
-    {
-      return (decoders *) (new decoderFFFLV1 (w, h,extraLen, extraData));
-    }
-
-
-#ifdef USE_FFMPEG
-  if (fourCC::check (fcc, (uint8_t *) &quot;H263&quot;))
-    {
-
-      return (decoders *) (new decoderFFH263 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;HFYU&quot;))
-    {
-
-      return (decoders *) (new decoderFFhuff (w, h, extraLen, extraData,bpp));
-    }
-#ifdef USE_PNG
-  if (fourCC::check (fcc, (uint8_t *) &quot;PNG &quot;))
-    {
-
-      return (decoders *) (new decoderPng (w, h));
-    }
-#endif
- if (fourCC::check (fcc, (uint8_t *) &quot;cvid&quot;))
-    {
-
-      return (decoders *) (new decoderFFCinepak (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;FFVH&quot;))
-    {
-
-      return (decoders *) (new decoderFF_ffhuff (w, h, extraLen, extraData,bpp));
-    }
-if (fourCC::check (fcc, (uint8_t *) &quot;SVQ1&quot;))
-    {
-
-      return (decoders *) (new decoderFFSVQ1 (w, h, extraLen, extraData));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) &quot;SVQ3&quot;))
-    {
-
-      return (decoders *) (new decoderFFSVQ3 (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;tscc&quot;))
-    {
-
-      return (decoders *) (new decoderCamtasia (w, h, bpp));
-    }
-
-     if (fourCC::check (fcc, (uint8_t *) &quot;CRAM&quot;))
-    {
-
-      return (decoders *) (new decoderFFCRAM (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;WMV2&quot;))
-    {
-
-      return (decoders *) (new decoderFFWMV2 (w, h, extraLen, extraData));
-    }
-    if (fourCC::check (fcc, (uint8_t *) &quot;WMV1&quot;))
-    {
-
-      return (decoders *) (new decoderFFWMV1 (w, h, extraLen, extraData));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) &quot;WMV3&quot;) )
-    {
-
-      return (decoders *) (new decoderFFWMV3 (w, h, extraLen, extraData));
-    }
-
-    if (fourCC::check (fcc, (uint8_t *) &quot;WVC1&quot;)|| fourCC::check (fcc, (uint8_t *) &quot;WMVA&quot;))
-    {
-
-      return (decoders *) (new decoderFFVC1 (w, h, extraLen, extraData));
-    }
-
-if (fourCC::check (fcc, (uint8_t *) &quot;FFV1&quot;))
-    {
-
-      return (decoders *) (new decoderFFV1 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;SNOW&quot;))
-    {
-
-      return (decoders *) (new decoderSnow (w, h));
-    }
-  if (isH264Compatible (fcc))
-    {
-#ifdef USE_VDPAU
-        if(vdpauUsable()==true)
-            return (decoders *) (new decoderFFVDPAU (w, h, extraLen, extraData));
-        else
-#endif
-            return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,1));
-    }
-#endif
-
-/*
-	Could be either divx5 packed crap or xvid or ffmpeg
-	For now we return FFmpeg and later will switch to divx5 if available
-		(ugly hack for ugly hack....)
-*/
-
-  if (isMpeg4Compatible (fcc) == 1)
-    {
-      return (decoders *) (new decoderFFMpeg4 (w, h, fcc,extraLen, extraData));
-      //    return(decoders *)( new decoderXvid(w,h));
-      //    return(decoders *)( new decoderDIVX(w,h));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) &quot;MJPB&quot;))
-    {
-      printf (&quot;\n using FF mjpeg codec\n&quot;);
-      return (decoders *) (new decoderFFMjpegB (w, h,extraLen,extraData));
-    }
-if (fourCC::check (fcc, (uint8_t *) &quot;MJPG&quot;)
-      || fourCC::check (fcc, (uint8_t *) &quot;mjpa&quot;))
-    {
-#if  0
-      //#ifdef USE_MJPEG
-      printf (&quot;\n using mjpeg codec\n&quot;);
-      return (decoders *) (new decoderMjpeg (w, h));
-#else
-      printf (&quot;\n using FF mjpeg codec\n&quot;);
-      return (decoders *) (new decoderFFMJPEG (w, h));
-#endif
-
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;YV12&quot;)
-      || fourCC::check (fcc, (uint8_t *) &quot;yv12&quot;)
-      || fourCC::check (fcc, (uint8_t *) &quot;I420&quot;))
-    {
-      printf (&quot;\n using null codec\n&quot;);
-      return (decoders *) (new decoderNull (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;UYVY&quot;))
-    {
-      printf (&quot;\n using uyvy codec\n&quot;);
-      return (decoders *) (new decoderUYVY (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;YUY2&quot;))
-    {
-      printf (&quot;\n using YUY2 codec\n&quot;);
-      return (decoders *) (new decoderYUY2 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;AMV &quot;))
-    {
-      printf (&quot;\n using AMV codec\n&quot;);
-      return (decoders *) (new decoderFFAMV (w, h,extraLen,extraData));
-    }
-
- if (fourCC::check (fcc, (uint8_t *) &quot;VP6A&quot;))
-    {
-      printf (&quot;\n using YUY2 codec\n&quot;);
-      return (decoders *) (new decoderFFVP6A (w, h,extraLen,extraData));
-    }
-  if (isVP6Compatible(fcc))
-    {
-      printf (&quot;\n using VP6F codec\n&quot;);
-      return (decoders *) (new decoderFFVP6F (w, h,extraLen,extraData));
-    }
-
-
-  if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) &quot;RGB &quot;))
-    {
-      // RGB 16 Codecs
-      printf (&quot;\n using RGB codec\n&quot;);
-      return (decoders *) (new decoderRGB16 (w, h, 1, bpp));
-
-    }
- if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) &quot;DIB &quot;))
-    {
-      // RGB 16 Codecs
-      printf (&quot;\n using DIB codec\n&quot;);
-      return (decoders *) (new decoderRGB16 (w, h, 0, bpp));
-
-    }
-  if (isMpeg12Compatible (fcc))
-	  return (decoders *) (new decoderFFMpeg12 (w, h, extraLen, extraData));
-
-  // default : null decoder
-  printf (&quot;\n using invalid codec for \n&quot;);
-  fourCC::print (fcc);
-
-  return (decoders *) (new decoderEmpty (w, h));
-}
-
+#if 0
 uint8_t coders::compress (ADMImage * in, ADMBitstream * out)
 {
   UNUSED_ARG (in);
@@ -314,3 +37,5 @@
 
   return 0;
 }
+#endif
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,12 +1,7 @@
 /***************************************************************************
-                          ADM_ffmp43.cpp  -  description
-                             -------------------
-                             
-	Decoder for Divx3/4/..., using ffmpeg
-                             
-    begin                : Wed Sep 25 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+    \file ADM_ffmp43
+    \brief Decoders using lavcodec
+    \author mean &amp; all (c) 2002-2010
  ***************************************************************************/
 
 /***************************************************************************
@@ -17,25 +12,17 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include &quot;config.h&quot;
 
-
-#include &quot;ADM_assert.h&quot;
-#include &quot;prefs.h&quot;
 extern &quot;C&quot; {
 #include &quot;ADM_lavcodec.h&quot;
 }
 #include &quot;ADM_default.h&quot;
 
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
+#include &quot;ADM_codec.h&quot;
+#include &quot;ADM_ffmp43.h&quot;
 #include &quot;DIA_coreToolkit.h&quot;
+//#include &quot;ADM_videoInfoExtractor.h&quot;
 
-#include &quot;ADM_debugID.h&quot;
-#define MODULE_NAME  MODULE_CODEC
-#include &quot;ADM_debug.h&quot;
-#include &quot;ADM_videoInfoExtractor.h&quot;
-
 extern int ADM_cpu_num_processors(void);
 extern &quot;C&quot;
 {
@@ -43,8 +30,8 @@
     static int  ADM_getBuffer(AVCodecContext *avctx, AVFrame *pic);
 }
 
+#define aprintf(...) {}
 
-
 #define WRAP_Open_Template(funcz,argz,display,codecid) \
 {\
 AVCodec *codec=funcz(argz);\
@@ -131,10 +118,10 @@
 {
   uint32_t threads = 0;
 
-  prefs-&gt;get(FEATURE_THREADING_LAVC, &amp;threads);
+//  prefs-&gt;get(FEATURE_THREADING_LAVC, &amp;threads);
 
-  if (threads == 0)
-	  threads = ADM_cpu_num_processors();
+//  if (threads == 0)
+//	  threads = ADM_cpu_num_processors();
 
   if (threads == 1)
 	  threads = 0;
@@ -161,7 +148,7 @@
 
 }
 
-  
+#if 0  
 uint8_t decoderFF::isDivxPacked (void)
 {
   int
@@ -194,17 +181,17 @@
 
   return out;
 }
-
+#endif
 //________________________________________________
-void
-decoderFF::setParam (void)
+bool  decoderFF::setParam (void)
 {
   DIA_lavDecoder (&amp;_swapUV, &amp;_showMv);
-  return;			// no param for ffmpeg
+  return true;			// no param for ffmpeg
 }
 
 //-------------------------------
-decoderFF::decoderFF (uint32_t w, uint32_t h):decoders (w, h)
+decoderFF::decoderFF (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+            :decoders (w, h,fcc,extraDataLen,extraData,bpp)
 {
   codecId = 0;
 //                              memset(&amp;_context,0,sizeof(_context));
@@ -308,7 +295,7 @@
     }
   return flag;
 }
-uint8_t decoderFF::decodeHeaderOnly (void)
+bool decoderFF::decodeHeaderOnly (void)
 {
   if (codecId == CODEC_ID_H264)
     _context-&gt;hurry_up = 4;
@@ -317,7 +304,7 @@
   printf (&quot;\n[lavc] Hurry up\n&quot;);
   return 1;
 }
-uint8_t decoderFF::decodeFull (void)
+bool decoderFF::decodeFull (void)
 {
   _context-&gt;hurry_up = 0;
   printf (&quot;\n[lavc] full decoding\n&quot;);
@@ -338,7 +325,7 @@
     \fn uncompress
     \brief Actually decode an image
 */
-uint8_t   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
+bool   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
   int got_picture = 0;
   uint8_t *oBuff[3];
@@ -490,12 +477,14 @@
 #define LOWDELAY() {} //_context-&gt;flags |= CODEC_FLAG_LOW_DELAY
 
 
-decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _refCopy = 1;			// YUV420 only
   WRAP_Open (CODEC_ID_MSMPEG4V3);
 }
 //**************************************************
+#if 0
 decoderFFMpeg4VopPacked::decoderFFMpeg4VopPacked (uint32_t w, uint32_t h):decoderFF (w,
 	   h)
 {
@@ -517,24 +506,24 @@
     return decoderFF::uncompress(in,out);
 
 }
-
-decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+#endif
+decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
 // force low delay as avidemux don't handle B-frames
   LOWDELAY();
-  printf (&quot;[lavc] Using %d bytes of extradata for MPEG4 decoder\n&quot;, l);
+  ADM_info (&quot;[lavc] Using %d bytes of extradata for MPEG4 decoder\n&quot;, (int)extraDataLen);
   
   _refCopy = 1;			// YUV420 only
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
+  _context-&gt;extradata = (uint8_t *) extraDataLen;
+  _context-&gt;extradata_size = (int) extraDataLen;
   _context-&gt;codec_tag=fcc;
   _context-&gt;stream_codec_tag=fcc;
   decoderMultiThread ();
   //  _context-&gt;flags|=FF_DEBUG_VIS_MV;
   WRAP_Open (CODEC_ID_MPEG4);
 }
-uint8_t decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
+bool decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
     // For pseudo startcode
     if(in-&gt;dataLength)
@@ -546,22 +535,23 @@
 
 }
 //************************************
-decoderFFDV::decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFDV::decoderFFDV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
   WRAP_Open (CODEC_ID_DVVIDEO);
 
 }
-decoderFFMP42::decoderFFMP42 (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderFFMP42::decoderFFMP42 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+                decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _refCopy = 1;			// YUV420 only
   WRAP_Open (CODEC_ID_MSMPEG4V2);
 
 }
-decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
-	   h)
+decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+                decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   int
     got_picture = 0;
@@ -570,64 +560,62 @@
   decoderMultiThread ();
   WRAP_Open (CODEC_ID_MPEG2VIDEO);
 }
-decoderFFSVQ3::decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
-	   h)
+decoderFFSVQ3::decoderFFSVQ3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+        :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   int
     got_picture = 0;
 
   LOWDELAY();
   _context-&gt;extradata = (uint8_t *) extraData;
-  _context-&gt;extradata_size = (int) extraLen;
+  _context-&gt;extradata_size = (int) extraDataLen;
   WRAP_Open (CODEC_ID_SVQ3);
 }
 
-decoderFFH263::decoderFFH263 (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderFFH263::decoderFFH263 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+            :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _refCopy = 1;			// YUV420 only
   WRAP_Open (CODEC_ID_H263);
 
 }
-decoderFFV1::decoderFFV1 (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderFFV1::decoderFFV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+            :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _refCopy = 1;			// YUV420 only
   WRAP_Open (CODEC_ID_FFV1);
 }
-decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
-	   h)
+decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
   _context-&gt;bits_per_coded_sample=bpp;
-  printf (&quot;[lavc] FFhuff: We have %d bytes of extra data\n&quot;, l);
+  ADM_info (&quot;[lavc] FFhuff: We have %d bytes of extra data\n&quot;, (int)extraDataLen);
   WRAP_Open (CODEC_ID_FFVHUFF);
 
 }
-decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d, uint32_t lowdelay):decoderFF (w,
-	   h)
+decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+        :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _lowDelay=lowdelay;
+
   _refCopy = 1;			// YUV420 only
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
   decoderMultiThread ();
-  if(lowdelay)
-    LOWDELAY();
-  printf (&quot;[lavc] Initializing H264 decoder with %d extradata\n&quot;, l);
-
-       {
-        WRAP_Open(CODEC_ID_H264);
-    }
-
-
+  ADM_info (&quot;[lavc] Initializing H264 decoder with %d extradata\n&quot;, (int)extraDataLen);
+  WRAP_Open(CODEC_ID_H264);
 }
 //*********************
 extern &quot;C&quot; {int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc);}
-
-uint8_t   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
+/**
+    \fn uncompress
+*/
+bool   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
   if(!_context-&gt;hurry_up) return decoderFF::uncompress (in, out);
-  
+    ADM_assert(0);
+#if 0  
   uint32_t nalSize, isAvc;
   av_getAVCStreamInfo(_context,&amp;nalSize,&amp;isAvc);
   if(isAvc)
@@ -637,125 +625,140 @@
   {
     return extractH264FrameType_startCode(nalSize, in-&gt;data,in-&gt;dataLength,&amp;(out-&gt;flags));
   }
+#endif
 }
 //*********************
-decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
-	   h)
+decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
   _context-&gt;bits_per_coded_sample = bpp;
   WRAP_Open (CODEC_ID_HUFFYUV);
 }
-decoderFFWMV2::decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFWMV2::decoderFFWMV2 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
 
   WRAP_Open (CODEC_ID_WMV2);
 
 }
-decoderFFWMV1::decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFWMV1::decoderFFWMV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
 
   WRAP_Open (CODEC_ID_WMV1);
 
 }
 
-decoderFFWMV3::decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFWMV3::decoderFFWMV3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
 
   WRAP_Open (CODEC_ID_WMV3);
 
 }
 
-decoderFFVC1::decoderFFVC1(uint32_t w, uint32_t h, uint32_t l, uint8_t * d) : decoderFF(w, h)
+decoderFFVC1::decoderFFVC1(uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp) : 
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
 
   WRAP_Open (CODEC_ID_VC1);
 }
 
-decoderFFcyuv::decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFcyuv::decoderFFcyuv (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+
 {
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
 
   WRAP_Open (CODEC_ID_CYUV);
 }
-decoderFFMJPEG::decoderFFMJPEG (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderFFMJPEG::decoderFFMJPEG (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_MJPEG);
 }
-decoderFFTheora::decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFTheora::decoderFFTheora (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraDataLen;
   WRAP_Open (CODEC_ID_THEORA);
 }
-decoderSnow::decoderSnow (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderSnow::decoderSnow (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_SNOW);
 }
 //*************
-decoderCamtasia::decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp):decoderFF (w,  h)
+decoderCamtasia::decoderCamtasia (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _context-&gt;bits_per_coded_sample = bpp;
   WRAP_Open (CODEC_ID_TSCC);
 }
 //*************
-decoderFFCinepak::decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFCinepak::decoderFFCinepak (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_CINEPAK);
 }
 //*************
-decoderFFCRAM::decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFCRAM::decoderFFCRAM (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_MSVIDEO1);
 }
 //*************
-decoderFFVP6F::decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFVP6F::decoderFFVP6F (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_VP6F);
 }
 //*************
-decoderFFVP6A::decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFVP6A::decoderFFVP6A (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_VP6A);
 }
 
 //*************
-decoderFFSVQ1::decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFSVQ1::decoderFFSVQ1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_SVQ1);
 }
 
 //************
-decoderFFFLV1::decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFFLV1::decoderFFFLV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_FLV1);
 }
-decoderFFAMV::decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
+decoderFFAMV::decoderFFAMV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_AMV);
   //_context-&gt;codec_id=CODEC_ID_AMV;
 }
-decoderFFMjpegB::decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
+decoderFFMjpegB::decoderFFMjpegB (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_MJPEGB);
   //_context-&gt;codec_id=CODEC_ID_AMV;
 }
-decoderFFDVBSub::decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+#if 0
+decoderFFDVBSub::decoderFFDVBSub (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):decoderFF (w,	   h)
 {
   _context-&gt;sub_id=1;
   WRAP_Open (CODEC_ID_DVB_SUBTITLE);
@@ -797,7 +800,7 @@
      return 1;
 }
 
-
+#endif
 //***************
 extern uint8_t  lavformat_init(void);
 extern void     avcodec_init(void );

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -20,6 +20,7 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
+#if 0
 extern &quot;C&quot; {
 #include &quot;ADM_lavcodec.h&quot;
 }
@@ -31,13 +32,13 @@
 
 #include &quot;vdpau/vdpau_x11.h&quot;
 #include &quot;vdpau/vdpau.h&quot;
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
+#include &quot;ADM_codec.h&quot;
+#include &quot;ADM_ffmp43.h&quot;
 #include &quot;DIA_coreToolkit.h&quot;
 #include &quot;ADM_dynamicLoading.h&quot;
 #include &quot;ADM_render/GUI_render.h&quot;
 #include &quot;ADM_ffmpeg_vdpau_internal.h&quot;
-#include &quot;prefs.h&quot;
+//#include &quot;prefs.h&quot;
 
 static VdpFunctions funcs;
 
@@ -340,4 +341,5 @@
 }
 
 #endif
+#endif
 // EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,115 +0,0 @@
-#if 0
-/***************************************************************************
-                          ADM_mjpeg.cpp  -  description
-                             -------------------
-          I think i could use plain jpeg instead but....
-
-
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &quot;ADM_assert.h&quot;
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-#include &quot;ADM_default.h&quot;
-#include &quot;config.h&quot;
-#ifdef USE_MJPEG
-#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_mjpeg.h&quot;
-extern &quot;C&quot;
-{
-#include &quot;mjpegtools/jpegutils.h&quot;
-}
-#include &quot;ADM_gui/GUI_decodersettings.h&quot;
- /*
-  * jpeg_data:       buffer with input / output jpeg
-  * len:             Length of jpeg buffer
-  * itype:           LAV_INTER_NONE: Not interlaced
-  *                  LAV_INTER_TOP_FIRST: Interlaced, top-field-first
-  *                  LAV_INTER_BOTTOM_FIRST: Interlaced, bottom-field-first
-  * ctype            Chroma format for decompression.
-  *                  Currently always 420 and hence ignored.
-  * raw0             buffer with input / output raw Y channel
-  * raw1             buffer with input / output raw U/Cb channel
-  * raw2             buffer with input / output raw V/Cr channel
-  * width            width of Y channel (width of U/V is width/2)
-  * height           height of Y channel (height of U/V is height/2)
-
-
-  int decode_jpeg_raw (unsigned char *jpeg_data, int len,
-  int itype, int ctype, int width, int height,
-  unsigned char *raw0, unsigned char *raw1,
-  unsigned char *raw2);
-
-  */
-void
-decoderMjpeg::setParam (void)
-{
-  int param;
-
-  param = _swap;
-  if (1 == getMjpegParams (&amp;param))
-    {
-      _swap = param;
-    }
-
-}
-//________________________________________________
-
-uint8_t
-  decoderMjpeg::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			    uint32_t * flagz)
-{
-  //
-  uint32_t delta;
-  uint8_t *outu, *outv;
-  //
-  UNUSED_ARG (flagz);
-
-
-  delta = _w * _h;
-
-  outu = out + delta;
-  outv = outu + (delta &gt;&gt; 2);
-  if (!_swap)
-
-    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outu, outv);
-
-  else
-    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outv, outu);
-
-  return 1;
-
-
-}
-
-//_____________________________________________________
-
-decoderMjpeg::~decoderMjpeg ()
-{
-
-
-}
-// constructor for mjpeg, init encoder and stuff
-decoderMjpeg::decoderMjpeg (uint32_t w, uint32_t h):decoders (w, h)
-{
-  // some mjpeg are encoded with u &amp; v inverted
-  _swap = 0;
-
-}
-#endif
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -14,25 +14,15 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include &quot;config.h&quot;
-#ifdef USE_PNG
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
 
-#include &lt;string.h&gt;
+#include &quot;ADM_default.h&quot;
 #include &lt;math.h&gt;
-
-#include &quot;ADM_default.h&quot;
-
-//#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_png.h&quot;
+#include &quot;ADM_codec.h&quot;
+#include &quot;ADM_png.h&quot;
 extern &quot;C&quot;
 {
 #include &quot;png.h&quot;
 }
-#include &quot;ADM_assert.h&quot;
 
 #define PNG_PTR ((png_structp)png_ptr)
 #define INFO_PTR ((png_infop)info_ptr)
@@ -41,7 +31,9 @@
    	Initialize codec
 */
 static void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length);
-
+/**
+    \fn Recalc
+*/
 void decoderPng::recalc (void)
 {
   int mul;
@@ -54,8 +46,11 @@
     rows[i] = decoded + mul * _w * i;
 }
 
-
-decoderPng::decoderPng (uint32_t w, uint32_t h):decoders (w, h)
+/**
+    \fn decoderPng
+*/
+decoderPng::decoderPng (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+                    decoders (w, h,fcc,extraDataLen,extraData,bpp)
 {
   rows = NULL;
   decoded = NULL;
@@ -69,10 +64,12 @@
   rows = new uint8_t *[h];
   recalc ();
 }
+/**
+    \fn Init
+*/
  void decoderPng::Init (void)
 {
-  png_ptr =
-    (void *) png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+  png_ptr =    (void *) png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
   ADM_assert (png_ptr);
   info_ptr = (void *) png_create_info_struct (PNG_PTR);
   ADM_assert (info_ptr);
@@ -82,20 +79,27 @@
   png_set_read_fn (PNG_PTR, &amp;io, user_read_data);
   png_set_rows (PNG_PTR, INFO_PTR, (png_byte **) rows);
 }
+/**
+    \fn Cleanup
+*/
 void decoderPng::Cleanup (void)
 {
   png_destroy_read_struct ((png_structpp) &amp; png_ptr, (png_infopp) &amp; info_ptr,
 			   (png_infopp) &amp; end_info);
 }
+/**
+    \fn dtor
+*/
 decoderPng::~decoderPng ()
 {
   delete[]rows;
   delete[]decoded;
 }
-/*
-   	Uncompress frame, set flags if needed
+/**
+    \fn uncompress
+   	\brief Uncompress frame, set flags if needed
 */
-uint8_t decoderPng::uncompress(ADMCompressedImage * in, ADMImage * out)
+bool decoderPng::uncompress(ADMCompressedImage * in, ADMImage * out)
 {
   int bpp;
   int colortype;
@@ -104,8 +108,8 @@
   if (!!png_sig_cmp (in-&gt;data, 0, 8))
 
     {
-      printf (&quot;[PNG] wrong sig\n&quot;);
-      return 0;
+      ADM_warning (&quot;[PNG] wrong sig\n&quot;);
+      return false;
     }
 
   //
@@ -154,7 +158,7 @@
   out-&gt;_planeStride[2] = 0;
   out-&gt;_colorspace = colorspace;
   Cleanup ();
-  return 1;
+  return true;
 }
 
 // ******************************************************
@@ -177,4 +181,3 @@
 {
 }
 //EOF
-#endif /*  */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -15,19 +15,14 @@
  *                                                                         *
  ***************************************************************************/
 
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
 #include &quot;ADM_default.h&quot;
-//#include &quot;ADM_colorspace/colorspace.h&quot;
+#include &quot;ADM_codec.h&quot;
+#include &quot;ADM_rgb16.h&quot;
 
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_rgb16.h&quot;
-
-decoderRGB16::decoderRGB16(uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp) : decoders (w, h)
+decoderRGB16::decoderRGB16(uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+    : decoders (  w,   h,  fcc,   extraDataLen,   extraData,  bpp)
 {
-	isRgb = rgb;
+	isRgb = true;
 	_bpp = bpp;
 
 	decoded = new uint8_t[_bpp * w * h];
@@ -38,7 +33,7 @@
 	delete[] decoded;
 }
 
-uint8_t decoderRGB16::uncompress(ADMCompressedImage * in, ADMImage * out)
+bool decoderRGB16::uncompress(ADMCompressedImage * in, ADMImage * out)
 {
 	int xx = _w * _h;
 	int lineSize = (_w * (_bpp / 8) + 3) &amp; ~3;

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,116 +0,0 @@
-/***************************************************************************
-                          ADM_theora_dec.cpp  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-#ifdef USE_THEORA
-#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-
-#include &quot;ADM_codecs/ADM_theora_dec.h&quot;
-//________________________________________________
-void
-decoderTheora::setParam (void)
-{
-  return;			// no param for ffmpeg
-}
-//-------------------------------
-decoderTheora::decoderTheora (uint32_t w, uint32_t h):decoders (w, h)
-{
-  memset (&amp;_tinfo, 0, sizeof (_tinfo));
-  memset (&amp;_tstate, 0, sizeof (_tstate));
-
-  _tinfo.width = _w;
-  _tinfo.height = _h;
-  _tinfo.fps_numerator = 25;
-  _tinfo.fps_denominator = 1;
-  _tinfo.aspect_numerator = 4;
-  _tinfo.aspect_denominator = 3;
-  _tinfo.quality = 9;
-
-  _tinfo.version_major = 3;
-  _tinfo.version_minor = 1;
-
-
-  theora_decode_init (&amp;_tstate, &amp;_tinfo);
-  printf (&quot;\n Theora initialized\n&quot;);
-}
-
-
-//-------------------------------
-
-uint8_t
-  decoderTheora::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			     uint32_t * flagz)
-{
-  int got_picture = 0;
-
-  if (len == 0)			// Null frame, silently skip
-    {
-      if (flagz)
-	*flagz = 0;
-      return 1;
-    }
-  ogg_packet ogg;
-
-  memset (&amp;ogg, 0, sizeof (ogg));
-  ogg.packet = in;
-  ogg.bytes = len;
-  /*
-     typedef struct {
-     unsigned char *packet;
-     long  bytes;
-     long  b_o_s;
-     long  e_o_s;
-
-     ogg_int64_t  granulepos;
-
-     ogg_int64_t  packetno;      sequence number for decode; the framing
-     knows where there's a hole in the data,
-     but we need coupling so that the codec
-     (which is in a seperate abstraction
-     layer) also knows about the gap 
-     } ogg_packet; */
-  if (theora_decode_packetin (&amp;_tstate, &amp;ogg))
-    {
-      printf (&quot;\n error decoding theora ..\n&quot;);
-      return 0;
-    }
-  yuv_buffer yuv;
-  theora_decode_YUVout (&amp;_tstate, &amp;yuv);
-  memcpy (out, yuv.y, _w * _h);
-  memset (out + _w * _h, 128, (_w * _h) &gt;&gt; 1);
-
-
-
-
-
-  return 1;
-}
-
-//_____________________________________________________
-
-decoderTheora::~decoderTheora ()
-{
-
-  printf (&quot;Theora destroyed\n&quot;);
-  theora_clear (&amp;_tstate);
-}
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,34 +1,24 @@
-//
-// C++ Implementation: ADM_uyvy
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
+/**
 
-#ifdef HAVE_SYS_PARAM_H
-#include &lt;sys/param.h&gt;
-#endif
-#if  defined( __FreeBSD__ ) || defined(__APPLE__)
-#include &lt;sys/types.h&gt;
-#endif
+    \file ADM_uyvy
+    \author mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>, 2004-1010
+*/
 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
 #include &quot;ADM_default.h&quot;
 #include &quot;avifmt.h&quot;
 #include &quot;avifmt2.h&quot;
 #include &quot;fourcc.h&quot;
+#include &quot;ADM_uyvy.h&quot;
 
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_uyvy.h&quot;
-
-uint8_t
-  decoderUYVY::uncompress (ADMCompressedImage * in, ADMImage * out)
+bool   decoderUYVY::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
 
   if (in-&gt;dataLength &lt; _w * _h * 2)
@@ -68,8 +58,7 @@
   return 1;
 
 }
-uint8_t
-  decoderYUY2::uncompress  (ADMCompressedImage * in, ADMImage * out)
+bool   decoderYUY2::uncompress  (ADMCompressedImage * in, ADMImage * out)
 {
 
   if (in-&gt;dataLength &lt; _w * _h * 2)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,18 +1,16 @@
 SET(ADM_codecs_SRCS 
 ADM_codecs.cpp
 ADM_png.cpp
-ADM_theora_dec.cpp
 ADM_ffmp43.cpp
-ADM_mjpeg.cpp
 ADM_rgb16.cpp
 ADM_uyvy.cpp
 ADM_ffmpeg_vdpau.cpp
+ADM_png.cpp
+ADM_codecSearch.cpp
 )
 
-ADD_LIBRARY(ADM_codecs6 STATIC ${ADM_codecs_SRCS})
+ADD_LIBRARY(ADM_coreVideoCodec6 SHARED ${ADM_codecs_SRCS})
+ADD_SOURCE_CFLAGS(ADM_png.cpp ${PNG_CFLAGS})
+ADM_INSTALL_LIB(ADM_coreVideoCodec6)
 
-IF (USE_PNG)
-	 ADD_SOURCE_CFLAGS(ADM_png.cpp ${PNG_CFLAGS})
-ENDIF (USE_PNG)
-
 REMOVE_DEFINITIONS(-DHAVE_CONFIG_H)

Modified: branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake	2010-01-10 18:08:56 UTC (rev 5835)
@@ -14,6 +14,7 @@
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreUtils/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoEncoder/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoFilter/include)
+INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoCodec/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_ffmpeg)
 INCLUDE_DIRECTORIES(${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/)
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003040.html">[Avidemux-svn-commit] r5834 - in branches/avidemux_2.6_branch_mean:	avidemux/common avidemux/common/ADM_codecs avidemux_core	avidemux_core/ADM_coreVideoCodec	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src
</A></li>
	<LI>Next message: <A HREF="003042.html">[Avidemux-svn-commit] r5836 - in	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces:	ADM_dialog ADM_gui2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3041">[ date ]</a>
              <a href="thread.html#3041">[ thread ]</a>
              <a href="subject.html#3041">[ subject ]</a>
              <a href="author.html#3041">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
