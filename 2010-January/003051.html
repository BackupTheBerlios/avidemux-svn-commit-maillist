<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5845 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common avidemux_core	avidemux_core/ADM_coreImage/include	avidemux_core/ADM_coreImageLoader	avidemux_core/ADM_coreImageLoader/include	avidemux_core/ADM_coreImageLoader/src cmake
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-January/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5845%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux%20avidemux/common%20avidemux_core%0A%09avidemux_core/ADM_coreImage/include%0A%09avidemux_core/ADM_coreImageLoader%0A%09avidemux_core/ADM_coreImageLoader/include%0A%09avidemux_core/ADM_coreImageLoader/src%20cmake&In-Reply-To=%3C201001131951.o0DJpsjM030040%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003050.html">
   <LINK REL="Next"  HREF="003052.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5845 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common avidemux_core	avidemux_core/ADM_coreImage/include	avidemux_core/ADM_coreImageLoader	avidemux_core/ADM_coreImageLoader/include	avidemux_core/ADM_coreImageLoader/src cmake</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5845%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux%20avidemux/common%20avidemux_core%0A%09avidemux_core/ADM_coreImage/include%0A%09avidemux_core/ADM_coreImageLoader%0A%09avidemux_core/ADM_coreImageLoader/include%0A%09avidemux_core/ADM_coreImageLoader/src%20cmake&In-Reply-To=%3C201001131951.o0DJpsjM030040%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5845 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common avidemux_core	avidemux_core/ADM_coreImage/include	avidemux_core/ADM_coreImageLoader	avidemux_core/ADM_coreImageLoader/include	avidemux_core/ADM_coreImageLoader/src cmake">mean at mail.berlios.de
       </A><BR>
    <I>Wed Jan 13 20:51:54 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003050.html">[Avidemux-svn-commit] r5844 -	branches/avidemux_2.6_branch_mean/avidemux
</A></li>
        <LI>Next message: <A HREF="003052.html">[Avidemux-svn-commit] r5846 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3051">[ date ]</a>
              <a href="thread.html#3051">[ thread ]</a>
              <a href="subject.html#3051">[ subject ]</a>
              <a href="author.html#3051">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-01-13 20:51:53 +0100 (Wed, 13 Jan 2010)
New Revision: 5845

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/include/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/include/ADM_imageLoader.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/CMakeLists.txt
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
   branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake
Log:
[imageLoader] Make imageLoader a core library so that it can be used by plugins

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp	2010-01-13 19:51:53 UTC (rev 5845)
@@ -1,454 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2007 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-
-
-#include &quot;ADM_image.h&quot;
-#if 0
-#include &quot;ADM_lavcodec.h&quot;
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
-#include &quot;ADM_codecs/ADM_png.h&quot;
-#endif
-
-#include &quot;ADM_bitmap.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-//**********************************
-//static ADMImage *createImageFromFile_jpeg(const char *filename);
-static ADMImage *createImageFromFile_Bmp(const char *filename);
-static ADMImage *createImageFromFile_Bmp2(const char *filename);
-//static ADMImage *createImageFromFile_png(const char *filename);
-//***********************************
-static uint8_t read8(FILE *fd)
-{
-	return fgetc(fd);
-}
-static uint32_t read16(FILE *fd)
-{
-	uint32_t a,b;
-	
-	a=fgetc(fd);
-	b=fgetc(fd);
-	return (a&lt;&lt;8)+b;
-		
-}
-static uint32_t read32(FILE *fd)
-{
-	uint32_t a,b,c,d;
-	
-	a=fgetc(fd);
-	b=fgetc(fd);
-	c=fgetc(fd);
-	d=fgetc(fd);
-	return (a&lt;&lt;24)+(b&lt;&lt;16)+(c&lt;&lt;8)+d;
-		
-}
-
-/**
-		\fn 	createImageFromFile
-		\brief 	Create and returns an ADMImage from a file, only YV12 jpg supported ATM
-
-*/
-ADMImage *createImageFromFile(const char *filename)
-{
-	uint32_t w,h;
-	switch(ADM_identidyImageFile(filename,&amp;w,&amp;h))
-	{
-		case  ADM_IMAGE_UNKNOWN: 
-					printf(&quot;[imageLoader] Trouble identifying /loading %s\n&quot;,filename);
-					return NULL;
-#if 0
-		case ADM_IMAGE_JPG:
-					return createImageFromFile_jpeg(filename);
-					break;
-		case ADM_IMAGE_PNG:
-					return createImageFromFile_png(filename);
-					break;
-#endif
-		case ADM_IMAGE_BMP2:
-					return createImageFromFile_Bmp2(filename);
-					break;
-		default:
-				ADM_assert(0);
-	
-	}
-	ADM_assert(0);
-}
-#if 0
-/**
- * 	\fn createImageFromFile_jpeg
- *  \brief Create image from jpeg file
- */
-ADMImage *createImageFromFile_jpeg(const char *filename)
-{
-	
-	FILE *fd;
-	uint32_t _imgSize;
-	uint32_t w = 0, h = 0;
-	   
-
-		fd = ADM_fopen(filename, &quot;rb&quot;);
-		fseek(fd, 0, SEEK_END);
-		_imgSize = ftell(fd);
-		fseek(fd, 0, SEEK_SET);
-
-		//Retrieve width &amp; height
-		//_______________________
-		    uint16_t tag = 0, count = 0, off;
-
-		    
-		    fseek(fd, 0, SEEK_SET);
-		    read16(fd);	// skip jpeg ffd8
-		    while (count &lt; 10 &amp;&amp; tag != 0xFFC0) 
-		    {
-
-		    	tag = read16(fd);
-		    	if ((tag &gt;&gt; 8) != 0xff) 
-		    	{
-		    		printf(&quot;[imageLoader]invalid jpeg tag found (%x)\n&quot;, tag);
-		    	}
-		    	if (tag == 0xFFC0) 
-		    	{
-		    		read16(fd);	// size
-		    		read8(fd);	// precision
-		    		h = read16(fd);
-		    		w = read16(fd);
-	                if(w&amp;1) w++;
-	                if(h&amp;1) h++;
-		    	} 
-		    	else 
-		    	{
-		    		off = read16(fd);
-		    		if (off &lt; 2) 
-		    		{
-		    			printf(&quot;[imageLoader]Offset too short!\n&quot;);
-		    		    fclose(fd);
-		    		    return NULL;
-		    		}
-		    		fseek(fd, off - 2, SEEK_CUR);
-		    	}
-			count++;
-		    }
-		    if (tag != 0xffc0) 
-		    {
-		    	printf(&quot;[imageLoader]Cannot fint start of frame\n&quot;);
-				fclose(fd);
-				return NULL;
-		    }
-		    printf(&quot;[imageLoader] %lu x %lu.., total Size : %u, offset %u\n&quot;, w, h,_imgSize,off);
-		    
-		// Load the binary coded image
-		    uint8_t *data=new uint8_t[_imgSize];
-		    fseek(fd, 0, SEEK_SET);
-		    fread(data,_imgSize,1,fd);
-		    fclose(fd);
-		  //
-		    
-		    ADMImage tmpImage(w,h,1); // It is a reference image
-		    // Now unpack it ...
-		    decoderFFMJPEG *decoder=new decoderFFMJPEG(w,h);
-		    ADMCompressedImage bin;
-		    bin.data=data;
-		    bin.dataLength=_imgSize; // This is more than actually, but who cares...
-		    
-		    decoder-&gt;uncompress (&amp;bin, &amp;tmpImage);
-		    //
-		    ADMImage *image=NULL;
-		    switch(tmpImage._colorspace)
-		    {
-		    case ADM_COLOR_YV12:
-		    {
-		    	printf(&quot;[imageLoader] YV12\n&quot;);
-	    		image=new ADMImage(w,h);
-	    		image-&gt;duplicate(&amp;tmpImage);
-	    		break;
-		    }
-		    case ADM_COLOR_YUV422:
-		    {
-		    	printf(&quot;[imageLoader] YUY2\n&quot;);
-		    	image=new ADMImage(w,h);
-		    	COL_422_YV12(tmpImage._planes, tmpImage._planeStride,  image-&gt;data,w,h);
-		    	break;
-		    }
-		    default:
-		    	GUI_Error_HIG(QT_TR_NOOP(&quot;Wrong Colorspace&quot;),QT_TR_NOOP(&quot;Only YV12/I420 or YUY2/I422 JPegs are supported&quot;));
-		    }
-		    // Cannot destroy decoder earlier as tmpImage has pointers to its internals
-		    delete decoder;
-		    decoder=NULL;
-		    delete [] data;
-		    return image;		
-}
-#endif
-/**
- * 	\fn createImageFromFile_jpeg
- *  \brief Create image from Bmp
- */
-ADMImage *createImageFromFile_Bmp(const char *filename)
-{
-	
-	FILE *fd;
-	uint32_t _imgSize;
-	uint32_t w = 0, h = 0;
-    uint16_t  s16;
-    uint32_t s32;
-
-		fd = ADM_fopen(filename, &quot;rb&quot;);
-		fseek(fd, 0, SEEK_END);
-		_imgSize = ftell(fd);
-		fseek(fd, 0, SEEK_SET);
-
-		//Retrieve width &amp; height
-		//_______________________
-		   		ADM_BITMAPINFOHEADER bmph;
-
-			    fread(&amp;s16, 2, 1, fd);
-			    if (s16 != 0x4D42) 
-			    {
-			    	printf(&quot;[imageLoader] incorrect bmp sig.\n&quot;);
-			    	fclose(fd);
-			    	return NULL;
-			    }
-			    fread(&amp;s32, 4, 1, fd);
-			    fread(&amp;s32, 4, 1, fd);
-			    fread(&amp;s32, 4, 1, fd);
-			    fread(&amp;bmph, sizeof(bmph), 1, fd);
-			    if (bmph.biCompression != 0) 
-			    {
-			    	printf(&quot;[imageLoader]cannot handle compressed bmp\n&quot;);
-			    	fclose(fd);
-			    	return NULL;
-			    }
-			    
-			    w = bmph.biWidth;
-			    h = bmph.biHeight;
-			    
-			    
-			    printf(&quot;[ImageLoader] BMP %u * %u\n&quot;,w,h);
-
-		// Load the binary coded image
-		    uint8_t *data=new uint8_t[w*h*3];
-		    fread(data,w*h*3,1,fd);
-		    fclose(fd);
-		    
-		  // Colorconversion
-		    
-		    	ADMImage *image=new ADMImage(w,h);
-		    	COL_RGB24_to_YV12( w, h,data,image-&gt;data);
-		    
-		    delete [] data;
-		    return image;		
-}
-/**
- * 	\fn createImageFromFile_bmp2
- *  \brief Create image from Bmp2 (BM6)
- */
-ADMImage *createImageFromFile_Bmp2(const char *filename)
-{
-    
-	ADM_BITMAPINFOHEADER bmph;
-    uint8_t fcc_tab[4];
-    uint32_t offset;
-    FILE *fd=NULL;
-    uint32_t w,h;
-
-		fd = ADM_fopen(filename, &quot;rb&quot;);
- 	    fseek(fd, 10, SEEK_SET);
-
- #define MK32() (fcc_tab[0]+(fcc_tab[1]&lt;&lt;8)+(fcc_tab[2]&lt;&lt;16)+ \
- 						(fcc_tab[3]&lt;&lt;24))
-
- 	    fread(fcc_tab, 4, 1, fd);
- 	    offset = MK32();
- 	    // size, width height follow as int32 
- 	    fread(&amp;bmph, sizeof(bmph), 1, fd);
- #ifdef ADM_BIG_ENDIAN
- 	    Endian_BitMapInfo(&amp;bmph);
- #endif
- 	    if (bmph.biCompression != 0) 
- 	    {
- 	    	printf(&quot;[imageLoader] BMP2:Cannot handle compressed bmp\n&quot;);
- 	    	fclose(fd);
- 	    	return NULL;
- 	    }
- 	    w = bmph.biWidth;
- 	    h = bmph.biHeight;
- 	    printf(&quot;[imageLoader] BMP2 W: %d H: %d offset : %d\n&quot;, w, h, offset);
-// Load the binary coded image
- 	fseek(fd,offset,SEEK_SET);
-    uint8_t *data=new uint8_t[w*h*3];
-    fread(data,w*h*3,1,fd);
-    fclose(fd);
-    
-  // Colorconversion
-    
-    	ADMImage *image=new ADMImage(w,h);
-    	COL_RGB24_to_YV12_revert( w, h,data,image-&gt;data);
-    
-    	delete [] data;
-    	return image;		
-}
-#if 0
-/**
- * 	\fn createImageFromFile_png
- *  \brief Create image from PNG
- */
-ADMImage *createImageFromFile_png(const char *filename)
-{
-    
-	ADM_BITMAPINFOHEADER bmph;
-    uint8_t fcc_tab[4];
-    uint32_t offset,size;
-    FILE *fd=NULL;
-    uint32_t w,h;
-
-		fd = ADM_fopen(filename, &quot;rb&quot;);
- 	    fseek(fd, 0, SEEK_END);
- 	    size=ftell(fd);
- 	   fseek(fd, 0, SEEK_SET);
- 	   read32(fd);
- 	   read32(fd);
- 	   read32(fd);
- 	   read32(fd);
- 	   w=read32(fd);
- 	   h=read32(fd);
- 	   fseek(fd,0,SEEK_SET);
- 	   uint8_t *data=new uint8_t[size];
- 	   fread(data,size,1,fd);
- 	   fclose(fd);
-    
-  
-    
- 	   ADMImage tmpImage(w,h,1);
-    	// Decode PNG
-    	decoderPng decoder(w,h);
-    	ADMCompressedImage bin;
-    	bin.data=data;
-    	bin.dataLength=size; // This is more than actually, but who cares...
-    			    
-    	decoder.uncompress (&amp;bin, &amp;tmpImage);
-    	
-    	ADMImage *image=new ADMImage(w,h);
-    	COL_RGB24_to_YV12( w, h,tmpImage._planes[0],image-&gt;data);
-    
-    	delete [] data;
-    	return image;		
-}
-#endif
-/**
- * 		\fn ADM_identidyImageFile
- * 		\brief Identidy image type, returns type and width/height
- */
-ADM_IMAGE_TYPE ADM_identidyImageFile(const char *filename,uint32_t *w,uint32_t *h)
-{
-			uint32_t *fcc;
-		    uint8_t fcc_tab[4];
-		    FILE *fd;
-		    uint32_t off,tag=0,count,size;
-
-		    // 1- identity the file type
-		    //
-		    fcc = (uint32_t *) fcc_tab;
-		    fd = ADM_fopen(filename, &quot;rb&quot;);
-		    if (!fd) 
-		    {
-		    	printf(&quot;[imageIdentify] Cannot open that file!\n&quot;);
-		    	return ADM_IMAGE_UNKNOWN;
-		    }
-		    fread(fcc_tab, 4, 1, fd);
-		    fcc = (uint32_t *) fcc_tab;
-		    // 2- JPEG ?
-		    if (fcc_tab[0] == 0xff &amp;&amp; fcc_tab[1] == 0xd8) 
-		    {
-		    			// JPEG
-		    	  			fseek(fd, 0, SEEK_SET);
-		    			    read16(fd);	// skip jpeg ffd8
-		    			    count=0;
-		    			    while (count &lt; 10 &amp;&amp; tag != 0xFFC0) 
-		    			    {
-
-		    			    	tag = read16(fd);
-		    			    	if ((tag &gt;&gt; 8) != 0xff) 
-		    			    	{
-		    			    		printf(&quot;[imageIdentify]invalid jpeg tag found (%x)\n&quot;, tag);
-		    			    	}
-		    			    	if (tag == 0xFFC0) 
-		    			    	{
-		    			    		read16(fd);	// size
-		    			    		read8(fd);	// precision
-		    			    		*h = read16(fd);
-		    			    		*w = read16(fd);
-		    		                if(*w&amp;1) *w++;
-		    		                if(*h&amp;1) *h++;
-		    			    	} 
-		    			    	else 
-		    			    	{
-		    			    		off = read16(fd);
-		    			    		if (off &lt; 2) 
-		    			    		{
-		    			    			printf(&quot;[imageIdentify]Offset too short!\n&quot;);
-		    			    		    fclose(fd);
-		    			    		    return ADM_IMAGE_UNKNOWN;
-		    			    		}
-		    			    		fseek(fd, off - 2, SEEK_CUR);
-		    			    	}
-		    				count++;
-		    			    }
-		    			    fclose(fd);
-		    			    if(count&gt;=10) return ADM_IMAGE_UNKNOWN;
-		    			    return ADM_IMAGE_JPG;
-		    }
-		    // PNG ?
-		    if (fcc_tab[1] == 'P' &amp;&amp; fcc_tab[2] == 'N' &amp;&amp; fcc_tab[3] == 'G') 
-			    {
-		     	    fseek(fd, 0, SEEK_SET);
-		     	    read32(fd);
-		     	    read32(fd);
-		     	    read32(fd);
-		     	    read32(fd);
-		     	    *w=read32(fd);
-		     	    *h=read32(fd);	
-		     	    fclose(fd);
-		     	    return ADM_IMAGE_PNG;
-			    }
-		    // BMP2?
-		    if (fcc_tab[0] == 'B' &amp;&amp; fcc_tab[1] == 'M') 
-		    {
-		    	    ADM_BITMAPINFOHEADER bmph;
-
-		     	    fseek(fd, 10, SEEK_SET);
-		     	    fread(fcc_tab, 4, 1, fd);
-		     	    // size, width height follow as int32 
-		     	    fread(&amp;bmph, sizeof(bmph), 1, fd);
-		     #ifdef ADM_BIG_ENDIAN
-		     	    Endian_BitMapInfo(&amp;bmph);
-		     #endif
-		     	    if (bmph.biCompression != 0) 
-		     	    {
-		     	    	printf(&quot;[imageIdentify] BMP2:Cannot handle compressed bmp\n&quot;);
-		     	    	fclose(fd);
-		     	    	return ADM_IMAGE_UNKNOWN;
-		     	    }
-		     	    *w = bmph.biWidth;
-		     	    *h = bmph.biHeight;
-	     	    	fclose(fd);
-	     	    	return ADM_IMAGE_BMP2;
-		    }
-		    // Unknown filetype...
-		    fclose(fd);
-		    return ADM_IMAGE_UNKNOWN;
-}
-//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-13 19:51:53 UTC (rev 5845)
@@ -50,7 +50,6 @@
 ../common/gui_action.cpp
 ../common/gui_audio.cpp
 ../common/gui_blackframes.cpp
-../common/ADM_imageLoader.cpp  
 ../common/ADM_gettext.cpp
 )
 
@@ -72,6 +71,7 @@
 ADM_coreUtils6
 ADM_coreVideoEncoder6
 ADM_coreVideoFilter6
+ADM_coreImageLoader6
 ADM_libavcodec6
 ADM_libavformat6
 ADM_libavutil6

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2010-01-13 19:51:53 UTC (rev 5845)
@@ -46,15 +46,6 @@
         PLANAR_V=3
         
 } ADM_PLANE;
-typedef enum 
-{
-		ADM_IMAGE_UNKNOWN=0,
-        ADM_IMAGE_JPG=1,
-        ADM_IMAGE_PNG=2,
-        ADM_IMAGE_BMP=3,
-        ADM_IMAGE_BMP2=4
-        
-} ADM_IMAGE_TYPE;
 /**
     \class ADMImage
     \brief Stores image
@@ -191,6 +182,4 @@
 uint8_t BitBlit(uint8_t *dst, uint32_t pitchDest,uint8_t *src,uint32_t pitchSrc,uint32_t width, uint32_t height);
 uint8_t BitBlitAlpha(uint8_t *dst, uint32_t pitchDst,uint8_t *src,uint32_t pitchSrc,uint32_t width, uint32_t height,uint32_t alpha);
 
-ADMImage *createImageFromFile(const char *filename);
-ADM_IMAGE_TYPE ADM_identidyImageFile(const char *filename,uint32_t *w,uint32_t *h);
 #endif

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/CMakeLists.txt	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/CMakeLists.txt	2010-01-13 19:51:53 UTC (rev 5845)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(src)

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/include/ADM_imageLoader.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/include/ADM_imageLoader.h	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/include/ADM_imageLoader.h	2010-01-13 19:51:53 UTC (rev 5845)
@@ -0,0 +1,21 @@
+/**
+    \file ADM_imageLoader
+*/
+//
+#ifndef ADM_IMAGE_LOADER
+#define ADM_IMAGE_LOADER
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_image.h&quot;
+typedef enum 
+{
+		ADM_IMAGE_UNKNOWN=0,
+        ADM_IMAGE_JPG=1,
+        ADM_IMAGE_PNG=2,
+        ADM_IMAGE_BMP=3,
+        ADM_IMAGE_BMP2=4
+        
+} ADM_IMAGE_TYPE;
+
+ADMImage *createImageFromFile(const char *filename);
+ADM_IMAGE_TYPE ADM_identidyImageFile(const char *filename,uint32_t *w,uint32_t *h);
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp (from rev 5844, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp	2010-01-13 19:51:53 UTC (rev 5845)
@@ -0,0 +1,448 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+
+
+#include &quot;ADM_image.h&quot;
+#include &quot;ADM_bitmap.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_imageLoader.h&quot;
+#include &quot;ADM_colorspace.h&quot;
+//**********************************
+//static ADMImage *createImageFromFile_jpeg(const char *filename);
+static ADMImage *createImageFromFile_Bmp(const char *filename);
+static ADMImage *createImageFromFile_Bmp2(const char *filename);
+//static ADMImage *createImageFromFile_png(const char *filename);
+//***********************************
+static uint8_t read8(FILE *fd)
+{
+	return fgetc(fd);
+}
+static uint32_t read16(FILE *fd)
+{
+	uint32_t a,b;
+	
+	a=fgetc(fd);
+	b=fgetc(fd);
+	return (a&lt;&lt;8)+b;
+		
+}
+static uint32_t read32(FILE *fd)
+{
+	uint32_t a,b,c,d;
+	
+	a=fgetc(fd);
+	b=fgetc(fd);
+	c=fgetc(fd);
+	d=fgetc(fd);
+	return (a&lt;&lt;24)+(b&lt;&lt;16)+(c&lt;&lt;8)+d;
+		
+}
+
+/**
+		\fn 	createImageFromFile
+		\brief 	Create and returns an ADMImage from a file, only YV12 jpg supported ATM
+
+*/
+ADMImage *createImageFromFile(const char *filename)
+{
+	uint32_t w,h;
+	switch(ADM_identidyImageFile(filename,&amp;w,&amp;h))
+	{
+		case  ADM_IMAGE_UNKNOWN: 
+					printf(&quot;[imageLoader] Trouble identifying /loading %s\n&quot;,filename);
+					return NULL;
+#if 0
+		case ADM_IMAGE_JPG:
+					return createImageFromFile_jpeg(filename);
+					break;
+		case ADM_IMAGE_PNG:
+					return createImageFromFile_png(filename);
+					break;
+#endif
+		case ADM_IMAGE_BMP2:
+					return createImageFromFile_Bmp2(filename);
+					break;
+		default:
+				ADM_assert(0);
+	
+	}
+	ADM_assert(0);
+}
+#if 0
+/**
+ * 	\fn createImageFromFile_jpeg
+ *  \brief Create image from jpeg file
+ */
+ADMImage *createImageFromFile_jpeg(const char *filename)
+{
+	
+	FILE *fd;
+	uint32_t _imgSize;
+	uint32_t w = 0, h = 0;
+	   
+
+		fd = ADM_fopen(filename, &quot;rb&quot;);
+		fseek(fd, 0, SEEK_END);
+		_imgSize = ftell(fd);
+		fseek(fd, 0, SEEK_SET);
+
+		//Retrieve width &amp; height
+		//_______________________
+		    uint16_t tag = 0, count = 0, off;
+
+		    
+		    fseek(fd, 0, SEEK_SET);
+		    read16(fd);	// skip jpeg ffd8
+		    while (count &lt; 10 &amp;&amp; tag != 0xFFC0) 
+		    {
+
+		    	tag = read16(fd);
+		    	if ((tag &gt;&gt; 8) != 0xff) 
+		    	{
+		    		printf(&quot;[imageLoader]invalid jpeg tag found (%x)\n&quot;, tag);
+		    	}
+		    	if (tag == 0xFFC0) 
+		    	{
+		    		read16(fd);	// size
+		    		read8(fd);	// precision
+		    		h = read16(fd);
+		    		w = read16(fd);
+	                if(w&amp;1) w++;
+	                if(h&amp;1) h++;
+		    	} 
+		    	else 
+		    	{
+		    		off = read16(fd);
+		    		if (off &lt; 2) 
+		    		{
+		    			printf(&quot;[imageLoader]Offset too short!\n&quot;);
+		    		    fclose(fd);
+		    		    return NULL;
+		    		}
+		    		fseek(fd, off - 2, SEEK_CUR);
+		    	}
+			count++;
+		    }
+		    if (tag != 0xffc0) 
+		    {
+		    	printf(&quot;[imageLoader]Cannot fint start of frame\n&quot;);
+				fclose(fd);
+				return NULL;
+		    }
+		    printf(&quot;[imageLoader] %lu x %lu.., total Size : %u, offset %u\n&quot;, w, h,_imgSize,off);
+		    
+		// Load the binary coded image
+		    uint8_t *data=new uint8_t[_imgSize];
+		    fseek(fd, 0, SEEK_SET);
+		    fread(data,_imgSize,1,fd);
+		    fclose(fd);
+		  //
+		    
+		    ADMImage tmpImage(w,h,1); // It is a reference image
+		    // Now unpack it ...
+		    decoderFFMJPEG *decoder=new decoderFFMJPEG(w,h);
+		    ADMCompressedImage bin;
+		    bin.data=data;
+		    bin.dataLength=_imgSize; // This is more than actually, but who cares...
+		    
+		    decoder-&gt;uncompress (&amp;bin, &amp;tmpImage);
+		    //
+		    ADMImage *image=NULL;
+		    switch(tmpImage._colorspace)
+		    {
+		    case ADM_COLOR_YV12:
+		    {
+		    	printf(&quot;[imageLoader] YV12\n&quot;);
+	    		image=new ADMImage(w,h);
+	    		image-&gt;duplicate(&amp;tmpImage);
+	    		break;
+		    }
+		    case ADM_COLOR_YUV422:
+		    {
+		    	printf(&quot;[imageLoader] YUY2\n&quot;);
+		    	image=new ADMImage(w,h);
+		    	COL_422_YV12(tmpImage._planes, tmpImage._planeStride,  image-&gt;data,w,h);
+		    	break;
+		    }
+		    default:
+		    	GUI_Error_HIG(QT_TR_NOOP(&quot;Wrong Colorspace&quot;),QT_TR_NOOP(&quot;Only YV12/I420 or YUY2/I422 JPegs are supported&quot;));
+		    }
+		    // Cannot destroy decoder earlier as tmpImage has pointers to its internals
+		    delete decoder;
+		    decoder=NULL;
+		    delete [] data;
+		    return image;		
+}
+#endif
+/**
+ * 	\fn createImageFromFile_jpeg
+ *  \brief Create image from Bmp
+ */
+ADMImage *createImageFromFile_Bmp(const char *filename)
+{
+	
+	FILE *fd;
+	uint32_t _imgSize;
+	uint32_t w = 0, h = 0;
+    uint16_t  s16;
+    uint32_t s32;
+
+		fd = ADM_fopen(filename, &quot;rb&quot;);
+		fseek(fd, 0, SEEK_END);
+		_imgSize = ftell(fd);
+		fseek(fd, 0, SEEK_SET);
+
+		//Retrieve width &amp; height
+		//_______________________
+		   		ADM_BITMAPINFOHEADER bmph;
+
+			    fread(&amp;s16, 2, 1, fd);
+			    if (s16 != 0x4D42) 
+			    {
+			    	printf(&quot;[imageLoader] incorrect bmp sig.\n&quot;);
+			    	fclose(fd);
+			    	return NULL;
+			    }
+			    fread(&amp;s32, 4, 1, fd);
+			    fread(&amp;s32, 4, 1, fd);
+			    fread(&amp;s32, 4, 1, fd);
+			    fread(&amp;bmph, sizeof(bmph), 1, fd);
+			    if (bmph.biCompression != 0) 
+			    {
+			    	printf(&quot;[imageLoader]cannot handle compressed bmp\n&quot;);
+			    	fclose(fd);
+			    	return NULL;
+			    }
+			    
+			    w = bmph.biWidth;
+			    h = bmph.biHeight;
+			    
+			    
+			    printf(&quot;[ImageLoader] BMP %u * %u\n&quot;,w,h);
+
+		// Load the binary coded image
+		    uint8_t *data=new uint8_t[w*h*3];
+		    fread(data,w*h*3,1,fd);
+		    fclose(fd);
+		    
+		  // Colorconversion
+		    
+		    	ADMImage *image=new ADMImage(w,h);
+		    	COL_RGB24_to_YV12( w, h,data,image-&gt;data);
+		    
+		    delete [] data;
+		    return image;		
+}
+/**
+ * 	\fn createImageFromFile_bmp2
+ *  \brief Create image from Bmp2 (BM6)
+ */
+ADMImage *createImageFromFile_Bmp2(const char *filename)
+{
+    
+	ADM_BITMAPINFOHEADER bmph;
+    uint8_t fcc_tab[4];
+    uint32_t offset;
+    FILE *fd=NULL;
+    uint32_t w,h;
+
+		fd = ADM_fopen(filename, &quot;rb&quot;);
+ 	    fseek(fd, 10, SEEK_SET);
+
+ #define MK32() (fcc_tab[0]+(fcc_tab[1]&lt;&lt;8)+(fcc_tab[2]&lt;&lt;16)+ \
+ 						(fcc_tab[3]&lt;&lt;24))
+
+ 	    fread(fcc_tab, 4, 1, fd);
+ 	    offset = MK32();
+ 	    // size, width height follow as int32 
+ 	    fread(&amp;bmph, sizeof(bmph), 1, fd);
+ #ifdef ADM_BIG_ENDIAN
+ 	    Endian_BitMapInfo(&amp;bmph);
+ #endif
+ 	    if (bmph.biCompression != 0) 
+ 	    {
+ 	    	printf(&quot;[imageLoader] BMP2:Cannot handle compressed bmp\n&quot;);
+ 	    	fclose(fd);
+ 	    	return NULL;
+ 	    }
+ 	    w = bmph.biWidth;
+ 	    h = bmph.biHeight;
+ 	    printf(&quot;[imageLoader] BMP2 W: %d H: %d offset : %d\n&quot;, w, h, offset);
+// Load the binary coded image
+ 	fseek(fd,offset,SEEK_SET);
+    uint8_t *data=new uint8_t[w*h*3];
+    fread(data,w*h*3,1,fd);
+    fclose(fd);
+    
+  // Colorconversion
+    
+    	ADMImage *image=new ADMImage(w,h);
+    	COL_RGB24_to_YV12_revert( w, h,data,image-&gt;data);
+    
+    	delete [] data;
+    	return image;		
+}
+#if 0
+/**
+ * 	\fn createImageFromFile_png
+ *  \brief Create image from PNG
+ */
+ADMImage *createImageFromFile_png(const char *filename)
+{
+    
+	ADM_BITMAPINFOHEADER bmph;
+    uint8_t fcc_tab[4];
+    uint32_t offset,size;
+    FILE *fd=NULL;
+    uint32_t w,h;
+
+		fd = ADM_fopen(filename, &quot;rb&quot;);
+ 	    fseek(fd, 0, SEEK_END);
+ 	    size=ftell(fd);
+ 	   fseek(fd, 0, SEEK_SET);
+ 	   read32(fd);
+ 	   read32(fd);
+ 	   read32(fd);
+ 	   read32(fd);
+ 	   w=read32(fd);
+ 	   h=read32(fd);
+ 	   fseek(fd,0,SEEK_SET);
+ 	   uint8_t *data=new uint8_t[size];
+ 	   fread(data,size,1,fd);
+ 	   fclose(fd);
+    
+  
+    
+ 	   ADMImage tmpImage(w,h,1);
+    	// Decode PNG
+    	decoderPng decoder(w,h);
+    	ADMCompressedImage bin;
+    	bin.data=data;
+    	bin.dataLength=size; // This is more than actually, but who cares...
+    			    
+    	decoder.uncompress (&amp;bin, &amp;tmpImage);
+    	
+    	ADMImage *image=new ADMImage(w,h);
+    	COL_RGB24_to_YV12( w, h,tmpImage._planes[0],image-&gt;data);
+    
+    	delete [] data;
+    	return image;		
+}
+#endif
+/**
+ * 		\fn ADM_identidyImageFile
+ * 		\brief Identidy image type, returns type and width/height
+ */
+ADM_IMAGE_TYPE ADM_identidyImageFile(const char *filename,uint32_t *w,uint32_t *h)
+{
+			uint32_t *fcc;
+		    uint8_t fcc_tab[4];
+		    FILE *fd;
+		    uint32_t off,tag=0,count,size;
+
+		    // 1- identity the file type
+		    //
+		    fcc = (uint32_t *) fcc_tab;
+		    fd = ADM_fopen(filename, &quot;rb&quot;);
+		    if (!fd) 
+		    {
+		    	printf(&quot;[imageIdentify] Cannot open that file!\n&quot;);
+		    	return ADM_IMAGE_UNKNOWN;
+		    }
+		    fread(fcc_tab, 4, 1, fd);
+		    fcc = (uint32_t *) fcc_tab;
+		    // 2- JPEG ?
+		    if (fcc_tab[0] == 0xff &amp;&amp; fcc_tab[1] == 0xd8) 
+		    {
+		    			// JPEG
+		    	  			fseek(fd, 0, SEEK_SET);
+		    			    read16(fd);	// skip jpeg ffd8
+		    			    count=0;
+		    			    while (count &lt; 10 &amp;&amp; tag != 0xFFC0) 
+		    			    {
+
+		    			    	tag = read16(fd);
+		    			    	if ((tag &gt;&gt; 8) != 0xff) 
+		    			    	{
+		    			    		printf(&quot;[imageIdentify]invalid jpeg tag found (%x)\n&quot;, tag);
+		    			    	}
+		    			    	if (tag == 0xFFC0) 
+		    			    	{
+		    			    		read16(fd);	// size
+		    			    		read8(fd);	// precision
+		    			    		*h = read16(fd);
+		    			    		*w = read16(fd);
+		    		                if(*w&amp;1) *w++;
+		    		                if(*h&amp;1) *h++;
+		    			    	} 
+		    			    	else 
+		    			    	{
+		    			    		off = read16(fd);
+		    			    		if (off &lt; 2) 
+		    			    		{
+		    			    			printf(&quot;[imageIdentify]Offset too short!\n&quot;);
+		    			    		    fclose(fd);
+		    			    		    return ADM_IMAGE_UNKNOWN;
+		    			    		}
+		    			    		fseek(fd, off - 2, SEEK_CUR);
+		    			    	}
+		    				count++;
+		    			    }
+		    			    fclose(fd);
+		    			    if(count&gt;=10) return ADM_IMAGE_UNKNOWN;
+		    			    return ADM_IMAGE_JPG;
+		    }
+		    // PNG ?
+		    if (fcc_tab[1] == 'P' &amp;&amp; fcc_tab[2] == 'N' &amp;&amp; fcc_tab[3] == 'G') 
+			    {
+		     	    fseek(fd, 0, SEEK_SET);
+		     	    read32(fd);
+		     	    read32(fd);
+		     	    read32(fd);
+		     	    read32(fd);
+		     	    *w=read32(fd);
+		     	    *h=read32(fd);	
+		     	    fclose(fd);
+		     	    return ADM_IMAGE_PNG;
+			    }
+		    // BMP2?
+		    if (fcc_tab[0] == 'B' &amp;&amp; fcc_tab[1] == 'M') 
+		    {
+		    	    ADM_BITMAPINFOHEADER bmph;
+
+		     	    fseek(fd, 10, SEEK_SET);
+		     	    fread(fcc_tab, 4, 1, fd);
+		     	    // size, width height follow as int32 
+		     	    fread(&amp;bmph, sizeof(bmph), 1, fd);
+		     #ifdef ADM_BIG_ENDIAN
+		     	    Endian_BitMapInfo(&amp;bmph);
+		     #endif
+		     	    if (bmph.biCompression != 0) 
+		     	    {
+		     	    	printf(&quot;[imageIdentify] BMP2:Cannot handle compressed bmp\n&quot;);
+		     	    	fclose(fd);
+		     	    	return ADM_IMAGE_UNKNOWN;
+		     	    }
+		     	    *w = bmph.biWidth;
+		     	    *h = bmph.biHeight;
+	     	    	fclose(fd);
+	     	    	return ADM_IMAGE_BMP2;
+		    }
+		    // Unknown filetype...
+		    fclose(fd);
+		    return ADM_IMAGE_UNKNOWN;
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/CMakeLists.txt	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/CMakeLists.txt	2010-01-13 19:51:53 UTC (rev 5845)
@@ -0,0 +1,13 @@
+SET(ADM_imageLoader_SRCS 
+ADM_imageLoader.cpp
+)
+
+ADD_LIBRARY(ADM_coreImageLoader6 SHARED ${ADM_imageLoader_SRCS})
+TARGET_LINK_LIBRARIES(ADM_coreImageLoader6 
+                                          ADM_core6
+                                          ADM_coreImage6 
+                                          ADM_coreUI6
+                                          ADM_coreUtils6
+                                          ADM_coreVideoCodec6)
+include_directories(../include)
+ADM_INSTALL_LIB(ADM_coreImageLoader6)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2010-01-13 19:51:53 UTC (rev 5845)
@@ -63,7 +63,7 @@
 ADD_SUBDIRECTORY(ADM_coreVideoFilter)
 ADD_SUBDIRECTORY(ADM_ffmpeg)
 ADD_SUBDIRECTORY(ADM_smjs)
-
+ADD_SUBDIRECTORY(ADM_coreImageLoader)
 ########################################
 # Config Summary
 ########################################

Modified: branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake	2010-01-13 19:51:53 UTC (rev 5845)
@@ -15,6 +15,7 @@
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoEncoder/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoFilter/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoCodec/include)
+INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreImageLoader/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_ffmpeg)
 INCLUDE_DIRECTORIES(${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/)
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003050.html">[Avidemux-svn-commit] r5844 -	branches/avidemux_2.6_branch_mean/avidemux
</A></li>
	<LI>Next message: <A HREF="003052.html">[Avidemux-svn-commit] r5846 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3051">[ date ]</a>
              <a href="thread.html#3051">[ thread ]</a>
              <a href="subject.html#3051">[ subject ]</a>
              <a href="author.html#3051">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
