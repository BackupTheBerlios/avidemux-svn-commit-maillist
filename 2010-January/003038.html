<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5832 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass:	. ADM_libAss
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-January/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5832%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass%3A%0A%09.%20ADM_libAss&In-Reply-To=%3C201001091103.o09B3K0f017202%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003037.html">
   <LINK REL="Next"  HREF="003039.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5832 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass:	. ADM_libAss</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5832%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass%3A%0A%09.%20ADM_libAss&In-Reply-To=%3C201001091103.o09B3K0f017202%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5832 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass:	. ADM_libAss">mean at mail.berlios.de
       </A><BR>
    <I>Sat Jan  9 12:03:20 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003037.html">[Avidemux-svn-commit] r5831 -	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video
</A></li>
        <LI>Next message: <A HREF="003039.html">[Avidemux-svn-commit] r5833 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3038">[ date ]</a>
              <a href="thread.html#3038">[ thread ]</a>
              <a href="subject.html#3038">[ subject ]</a>
              <a href="author.html#3038">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-01-09 12:03:17 +0100 (Sat, 09 Jan 2010)
New Revision: 5832

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_strtod.c
Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt
Log:
[Ass] Update libass to git version + tweak a bit CMakelist.txt to enable fontconfig/freetype if they are there

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt	2010-01-09 11:03:17 UTC (rev 5832)
@@ -10,6 +10,7 @@
 
         SET(${ADM_LIB}_SRCS 
         ass_bitmap.c  ass.c  ass_cache.c  ass_drawing.c  ass_font.c    ass_library.c  ass_render.c  ass_utils.c
+        ass_parse.c ass_strtod.c
         )
     IF (FONTCONFIG_FOUND)
         ADD_DEFINITIONS(${FONTCONFIG_CFLAGS} &quot;-DHAVE_FONTCONFIG=1&quot; &quot;-DCONFIG_FONTCONFIG=1&quot;)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -38,11 +38,16 @@
 #include &quot;ass_utils.h&quot;
 #include &quot;ass_library.h&quot;
 
-typedef enum { PST_UNKNOWN =
-        0, PST_INFO, PST_STYLES, PST_EVENTS, PST_FONTS } parser_state_t;
+typedef enum {
+    PST_UNKNOWN = 0,
+    PST_INFO,
+    PST_STYLES,
+    PST_EVENTS,
+    PST_FONTS
+} ParserState;
 
 struct parser_priv {
-    parser_state_t state;
+    ParserState state;
     char *fontname;
     char *fontdata;
     int fontdata_size;
@@ -52,7 +57,7 @@
 #define ASS_STYLES_ALLOC 20
 #define ASS_EVENTS_ALLOC 200
 
-void ass_free_track(ass_track_t *track)
+void ass_free_track(ASS_Track *track)
 {
     int i;
 
@@ -84,7 +89,7 @@
 /// \brief Allocate a new style struct
 /// \param track track
 /// \return style id
-int ass_alloc_style(ass_track_t *track)
+int ass_alloc_style(ASS_Track *track)
 {
     int sid;
 
@@ -93,20 +98,20 @@
     if (track-&gt;n_styles == track-&gt;max_styles) {
         track-&gt;max_styles += ASS_STYLES_ALLOC;
         track-&gt;styles =
-            (ass_style_t *) realloc(track-&gt;styles,
-                                    sizeof(ass_style_t) *
-                                    track-&gt;max_styles);
+            (ASS_Style *) realloc(track-&gt;styles,
+                                  sizeof(ASS_Style) *
+                                  track-&gt;max_styles);
     }
 
     sid = track-&gt;n_styles++;
-    memset(track-&gt;styles + sid, 0, sizeof(ass_style_t));
+    memset(track-&gt;styles + sid, 0, sizeof(ASS_Style));
     return sid;
 }
 
 /// \brief Allocate a new event struct
 /// \param track track
 /// \return event id
-int ass_alloc_event(ass_track_t *track)
+int ass_alloc_event(ASS_Track *track)
 {
     int eid;
 
@@ -115,19 +120,19 @@
     if (track-&gt;n_events == track-&gt;max_events) {
         track-&gt;max_events += ASS_EVENTS_ALLOC;
         track-&gt;events =
-            (ass_event_t *) realloc(track-&gt;events,
-                                    sizeof(ass_event_t) *
-                                    track-&gt;max_events);
+            (ASS_Event *) realloc(track-&gt;events,
+                                  sizeof(ASS_Event) *
+                                  track-&gt;max_events);
     }
 
     eid = track-&gt;n_events++;
-    memset(track-&gt;events + eid, 0, sizeof(ass_event_t));
+    memset(track-&gt;events + eid, 0, sizeof(ASS_Event));
     return eid;
 }
 
-void ass_free_event(ass_track_t *track, int eid)
+void ass_free_event(ASS_Track *track, int eid)
 {
-    ass_event_t *event = track-&gt;events + eid;
+    ASS_Event *event = track-&gt;events + eid;
     if (event-&gt;Name)
         free(event-&gt;Name);
     if (event-&gt;Effect)
@@ -138,9 +143,9 @@
         free(event-&gt;render_priv);
 }
 
-void ass_free_style(ass_track_t *track, int sid)
+void ass_free_style(ASS_Track *track, int sid)
 {
-    ass_style_t *style = track-&gt;styles + sid;
+    ASS_Style *style = track-&gt;styles + sid;
     if (style-&gt;Name)
         free(style-&gt;Name);
     if (style-&gt;FontName)
@@ -173,7 +178,7 @@
  * Returnes 0 if no styles found =&gt; expects at least 1 style.
  * Parsing code always adds &quot;Default&quot; style in the end.
  */
-static int lookup_style(ass_track_t *track, char *name)
+static int lookup_style(ASS_Track *track, char *name)
 {
     int i;
     if (*name == '*')
@@ -190,14 +195,14 @@
     return i;                   // use the first style
 }
 
-static uint32_t string2color(ass_library_t *library, char *p)
+static uint32_t string2color(ASS_Library *library, char *p)
 {
     uint32_t tmp;
-    (void) strtocolor(library, &amp;p, &amp;tmp);
+    (void) strtocolor(library, &amp;p, &amp;tmp, 0);
     return tmp;
 }
 
-static long long string2timecode(ass_library_t *library, char *p)
+static long long string2timecode(ASS_Library *library, char *p)
 {
     unsigned h, m, s, ms;
     long long tm;
@@ -294,14 +299,14 @@
  * \param str string to parse, zero-terminated
  * \param n_ignored number of format options to skip at the beginning
 */
-static int process_event_tail(ass_track_t *track, ass_event_t *event,
+static int process_event_tail(ASS_Track *track, ASS_Event *event,
                               char *str, int n_ignored)
 {
     char *token;
     char *tname;
     char *p = str;
     int i;
-    ass_event_t *target = event;
+    ASS_Event *target = event;
 
     char *format = strdup(track-&gt;event_format);
     char *q = format;           // format scanning pointer
@@ -357,10 +362,10 @@
  * \param track track to apply overrides to
  * The format for overrides is [StyleName.]Field=Value
  */
-void ass_process_force_style(ass_track_t *track)
+void ass_process_force_style(ASS_Track *track)
 {
     char **fs, *eq, *dt, *style, *tname, *token;
-    ass_style_t *target;
+    ASS_Style *target;
     int sid;
     char **list = track-&gt;library-&gt;style_overrides;
 
@@ -384,6 +389,8 @@
             track-&gt;WrapStyle = atoi(token);
         else if (!strcasecmp(*fs, &quot;ScaledBorderAndShadow&quot;))
             track-&gt;ScaledBorderAndShadow = parse_bool(token);
+        else if (!strcasecmp(*fs, &quot;Kerning&quot;))
+            track-&gt;Kerning = parse_bool(token);
 
         dt = strrchr(*fs, '.');
         if (dt) {
@@ -436,7 +443,7 @@
  * \param str string to parse, zero-terminated
  * Allocates a new style struct.
 */
-static int process_style(ass_track_t *track, char *str)
+static int process_style(ASS_Track *track, char *str)
 {
 
     char *token;
@@ -445,8 +452,8 @@
     char *format;
     char *q;                    // format scanning pointer
     int sid;
-    ass_style_t *style;
-    ass_style_t *target;
+    ASS_Style *style;
+    ASS_Style *target;
 
     if (!track-&gt;style_format) {
         // no style format header
@@ -474,7 +481,8 @@
 
     style = track-&gt;styles + sid;
     target = style;
-// fill style with some default values
+
+    // fill style with some default values
     style-&gt;ScaleX = 100.;
     style-&gt;ScaleY = 100.;
 
@@ -482,8 +490,6 @@
         NEXT(q, tname);
         NEXT(p, token);
 
-//              ALIAS(TertiaryColour,OutlineColour) // ignore TertiaryColour; it appears only in SSA, and is overridden by BackColour
-
         if (0) {                // cool ;)
             STRVAL(Name)
             if ((strcmp(target-&gt;Name, &quot;Default&quot;) == 0)
@@ -539,7 +545,7 @@
 
 }
 
-static int process_styles_line(ass_track_t *track, char *str)
+static int process_styles_line(ASS_Track *track, char *str)
 {
     if (!strncmp(str, &quot;Format:&quot;, 7)) {
         char *p = str + 7;
@@ -555,7 +561,7 @@
     return 0;
 }
 
-static int process_info_line(ass_track_t *track, char *str)
+static int process_info_line(ASS_Track *track, char *str)
 {
     if (!strncmp(str, &quot;PlayResX:&quot;, 9)) {
         track-&gt;PlayResX = atoi(str + 9);
@@ -567,11 +573,13 @@
         track-&gt;WrapStyle = atoi(str + 10);
     } else if (!strncmp(str, &quot;ScaledBorderAndShadow:&quot;, 22)) {
         track-&gt;ScaledBorderAndShadow = parse_bool(str + 22);
+    } else if (!strncmp(str, &quot;Kerning:&quot;, 8)) {
+        track-&gt;Kerning = parse_bool(str + 8);
     }
     return 0;
 }
 
-static void event_format_fallback(ass_track_t *track)
+static void event_format_fallback(ASS_Track *track)
 {
     track-&gt;parser_priv-&gt;state = PST_EVENTS;
     if (track-&gt;track_type == TRACK_TYPE_SSA)
@@ -584,7 +592,7 @@
             &quot;No event format found, using fallback&quot;);
 }
 
-static int process_events_line(ass_track_t *track, char *str)
+static int process_events_line(ASS_Track *track, char *str)
 {
     if (!strncmp(str, &quot;Format:&quot;, 7)) {
         char *p = str + 7;
@@ -596,7 +604,7 @@
         // They have slightly different format and are parsed in ass_process_chunk,
         // called directly from demuxer
         int eid;
-        ass_event_t *event;
+        ASS_Event *event;
 
         str += 9;
         skip_spaces(&amp;str);
@@ -636,7 +644,7 @@
     return dst;
 }
 
-static int decode_font(ass_track_t *track)
+static int decode_font(ASS_Track *track)
 {
     unsigned char *p;
     unsigned char *q;
@@ -684,7 +692,7 @@
     return 0;
 }
 
-static int process_fonts_line(ass_track_t *track, char *str)
+static int process_fonts_line(ASS_Track *track, char *str)
 {
     int len;
 
@@ -730,7 +738,7 @@
  * \param track track
  * \param str string to parse, zero-terminated
 */
-static int process_line(ass_track_t *track, char *str)
+static int process_line(ASS_Track *track, char *str)
 {
     if (!strncasecmp(str, &quot;[Script Info]&quot;, 13)) {
         track-&gt;parser_priv-&gt;state = PST_INFO;
@@ -771,7 +779,7 @@
     return 0;
 }
 
-static int process_text(ass_track_t *track, char *str)
+static int process_text(ASS_Track *track, char *str)
 {
     char *p = str;
     while (1) {
@@ -804,7 +812,7 @@
  * \param data string to parse
  * \param size length of data
 */
-void ass_process_data(ass_track_t *track, char *data, int size)
+void ass_process_data(ASS_Track *track, char *data, int size)
 {
     char *str = malloc(size + 1);
 
@@ -823,7 +831,7 @@
  * \param size length of data
  CodecPrivate section contains [Stream Info] and [V4+ Styles] ([V4 Styles] for SSA) sections
 */
-void ass_process_codec_private(ass_track_t *track, char *data, int size)
+void ass_process_codec_private(ASS_Track *track, char *data, int size)
 {
     ass_process_data(track, data, size);
 
@@ -835,7 +843,7 @@
     ass_process_force_style(track);
 }
 
-static int check_duplicate_event(ass_track_t *track, int ReadOrder)
+static int check_duplicate_event(ASS_Track *track, int ReadOrder)
 {
     int i;
     for (i = 0; i &lt; track-&gt;n_events - 1; ++i)   // ignoring last event, it is the one we are comparing with
@@ -852,14 +860,14 @@
  * \param timecode starting time of the event (milliseconds)
  * \param duration duration of the event (milliseconds)
 */
-void ass_process_chunk(ass_track_t *track, char *data, int size,
+void ass_process_chunk(ASS_Track *track, char *data, int size,
                        long long timecode, long long duration)
 {
     char *str;
     int eid;
     char *p;
     char *token;
-    ass_event_t *event;
+    ASS_Event *event;
 
     if (!track-&gt;event_format) {
         ass_msg(track-&gt;library, MSGL_WARN, &quot;Event format header missing&quot;);
@@ -908,7 +916,7 @@
  * \param size buffer size
  * \return a pointer to recoded buffer, caller is responsible for freeing it
 **/
-static char *sub_recode(ass_library_t *library, char *data, size_t size,
+static char *sub_recode(ASS_Library *library, char *data, size_t size,
                         char *codepage)
 {
     iconv_t icdsc;
@@ -987,7 +995,7 @@
  * \param bufsize out: file size
  * \return pointer to file contents. Caller is responsible for its deallocation.
  */
-static char *read_file(ass_library_t *library, char *fname, size_t *bufsize)
+static char *read_file(ASS_Library *library, char *fname, size_t *bufsize)
 {
     int res;
     long sz;
@@ -1046,9 +1054,9 @@
 /*
  * \param buf pointer to subtitle text in utf-8
  */
-static ass_track_t *parse_memory(ass_library_t *library, char *buf)
+static ASS_Track *parse_memory(ASS_Library *library, char *buf)
 {
-    ass_track_t *track;
+    ASS_Track *track;
     int i;
 
     track = ass_new_track(library);
@@ -1082,22 +1090,23 @@
  * \param codepage recode buffer contents from given codepage
  * \return newly allocated track
 */
-ass_track_t *ass_read_memory(ass_library_t *library, char *buf,
-                             size_t bufsize, char *codepage)
+ASS_Track *ass_read_memory(ASS_Library *library, char *buf,
+                           size_t bufsize, char *codepage)
 {
-    ass_track_t *track;
+    ASS_Track *track;
     int need_free = 0;
 
     if (!buf)
         return 0;
 
 #ifdef CONFIG_ICONV
-    if (codepage)
+    if (codepage) {
         buf = sub_recode(library, buf, bufsize, codepage);
-    if (!buf)
-        return 0;
-    else
-        need_free = 1;
+        if (!buf)
+            return 0;
+        else
+            need_free = 1;
+    }
 #endif
     track = parse_memory(library, buf);
     if (need_free)
@@ -1111,7 +1120,7 @@
     return track;
 }
 
-static char *read_file_recode(ass_library_t *library, char *fname,
+static char *read_file_recode(ASS_Library *library, char *fname,
                               char *codepage, size_t *size)
 {
     char *buf;
@@ -1140,11 +1149,11 @@
  * \param codepage recode buffer contents from given codepage
  * \return newly allocated track
 */
-ass_track_t *ass_read_file(ass_library_t *library, char *fname,
-                           char *codepage)
+ASS_Track *ass_read_file(ASS_Library *library, char *fname,
+                         char *codepage)
 {
     char *buf;
-    ass_track_t *track;
+    ASS_Track *track;
     size_t bufsize;
 
     buf = read_file_recode(library, fname, codepage, &amp;bufsize);
@@ -1167,10 +1176,10 @@
 /**
  * \brief read styles from file into already initialized track
  */
-int ass_read_styles(ass_track_t *track, char *fname, char *codepage)
+int ass_read_styles(ASS_Track *track, char *fname, char *codepage)
 {
     char *buf;
-    parser_state_t old_state;
+    ParserState old_state;
     size_t sz;
 
     buf = read_file(track-&gt;library, fname, &amp;sz);
@@ -1195,7 +1204,7 @@
     return 0;
 }
 
-long long ass_step_sub(ass_track_t *track, long long now, int movement)
+long long ass_step_sub(ASS_Track *track, long long now, int movement)
 {
     int i;
 
@@ -1227,11 +1236,11 @@
     return ((long long) track-&gt;events[i].Start) - now;
 }
 
-ass_track_t *ass_new_track(ass_library_t *library)
+ASS_Track *ass_new_track(ASS_Library *library)
 {
-    ass_track_t *track = calloc(1, sizeof(ass_track_t));
+    ASS_Track *track = calloc(1, sizeof(ASS_Track));
     track-&gt;library = library;
     track-&gt;ScaledBorderAndShadow = 1;
-    track-&gt;parser_priv = calloc(1, sizeof(parser_priv_t));
+    track-&gt;parser_priv = calloc(1, sizeof(ASS_ParserPriv));
     return track;
 }

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -25,7 +25,7 @@
 #include &lt;stdarg.h&gt;
 #include &quot;ass_types.h&quot;
 
-#define LIBASS_VERSION 0x00907000
+#define LIBASS_VERSION 0x00908000
 
 /*
  * A linked list of images produced by an ass renderer.
@@ -46,10 +46,10 @@
     int dst_x, dst_y;           // Bitmap placement inside the video frame
 
     struct ass_image *next;   // Next image, or NULL
-} ass_image_t;
+} ASS_Image;
 
 /*
- * Hintint type. (see ass_set_hinting below)
+ * Hinting type. (see ass_set_hinting below)
  *
  * FreeType's native hinter is still buggy sometimes and it is recommended
  * to use the light autohinter, ASS_HINTING_LIGHT, instead.  For best
@@ -60,19 +60,19 @@
     ASS_HINTING_LIGHT,
     ASS_HINTING_NORMAL,
     ASS_HINTING_NATIVE
-} ass_hinting_t;
+} ASS_Hinting;
 
 /**
  * \brief Initialize the library.
  * \return library handle or NULL if failed
  */
-ass_library_t *ass_library_init(void);
+ASS_Library *ass_library_init(void);
 
 /**
  * \brief Finalize the library
  * \param priv library handle
  */
-void ass_library_done(ass_library_t *);
+void ass_library_done(ASS_Library *priv);
 
 /**
  * \brief Set private font directory.
@@ -81,14 +81,14 @@
  * \param priv library handle
  * \param fonts_dir private directory for font extraction
  */
-void ass_set_fonts_dir(ass_library_t *priv, const char *fonts_dir);
+void ass_set_fonts_dir(ASS_Library *priv, const char *fonts_dir);
 
 /**
  * \brief Whether fonts should be extracted from track data.
  * \param priv library handle
  * \param extract whether to extract fonts
  */
-void ass_set_extract_fonts(ass_library_t *priv, int extract);
+void ass_set_extract_fonts(ASS_Library *priv, int extract);
 
 /**
  * \brief Register style overrides with a library instance.
@@ -99,13 +99,13 @@
  * \param priv library handle
  * \param list NULL-terminated list of strings
  */
-void ass_set_style_overrides(ass_library_t *priv, char **list);
+void ass_set_style_overrides(ASS_Library *priv, char **list);
 
 /**
  * \brief Explicitly process style overrides for a track.
  * \param track track handle
  */
-void ass_process_force_style(ass_track_t *track);
+void ass_process_force_style(ASS_Track *track);
 
 /**
  * \brief Register a callback for debug/info messages.
@@ -121,7 +121,7 @@
  * \param msg_cb pointer to callback function
  * \param data additional data, will be passed to callback
  */
-void ass_set_message_cb(ass_library_t *priv, void (*msg_cb)
+void ass_set_message_cb(ASS_Library *priv, void (*msg_cb)
                         (int level, const char *fmt, va_list args, void *data),
                         void *data);
 
@@ -130,13 +130,13 @@
  * \param priv library handle
  * \return renderer handle or NULL if failed
  */
-ass_renderer_t *ass_renderer_init(ass_library_t *);
+ASS_Renderer *ass_renderer_init(ASS_Library *);
 
 /**
  * \brief Finalize the renderer.
  * \param priv renderer handle
  */
-void ass_renderer_done(ass_renderer_t *priv);
+void ass_renderer_done(ASS_Renderer *priv);
 
 /**
  * \brief Set the frame size in pixels, including margins.
@@ -144,7 +144,7 @@
  * \param w width
  * \param h height
  */
-void ass_set_frame_size(ass_renderer_t *priv, int w, int h);
+void ass_set_frame_size(ASS_Renderer *priv, int w, int h);
 
 /**
  * \brief Set frame margins.  These values may be negative if pan-and-scan
@@ -155,53 +155,56 @@
  * \param l left margin
  * \param r right margin
  */
-void ass_set_margins(ass_renderer_t *priv, int t, int b, int l, int r);
+void ass_set_margins(ASS_Renderer *priv, int t, int b, int l, int r);
 
 /**
  * \brief Whether margins should be used for placing regular events.
  * \param priv renderer handle
  * \param use whether to use the margins
  */
-void ass_set_use_margins(ass_renderer_t *priv, int use);
+void ass_set_use_margins(ASS_Renderer *priv, int use);
 
 /**
  * \brief Set aspect ratio parameters.
  * \param priv renderer handle
- * \param ar physical aspect ratio
- * \param par pixel ratio, e.g. width / height of the video
+ * \param dar display aspect ratio (DAR), prescaled for output PAR
+ * \param sar storage aspect ratio (SAR)
  */
-void ass_set_aspect_ratio(ass_renderer_t *priv, double ar, double par);
+void ass_set_aspect_ratio(ASS_Renderer *priv, double dar, double sar);
 
 /**
  * \brief Set a fixed font scaling factor.
  * \param priv renderer handle
  * \param font_scale scaling factor, default is 1.0
  */
-void ass_set_font_scale(ass_renderer_t *priv, double font_scale);
+void ass_set_font_scale(ASS_Renderer *priv, double font_scale);
 
 /**
  * \brief Set font hinting method.
  * \param priv renderer handle
  * \param ht hinting method
  */
-void ass_set_hinting(ass_renderer_t *priv, ass_hinting_t ht);
+void ass_set_hinting(ASS_Renderer *priv, ASS_Hinting ht);
 
 /**
  * \brief Set line spacing. Will not be scaled with frame size.
  * \param priv renderer handle
  * \param line_spacing line spacing in pixels
  */
-void ass_set_line_spacing(ass_renderer_t *priv, double line_spacing);
+void ass_set_line_spacing(ASS_Renderer *priv, double line_spacing);
 
 /**
  * \brief Set font lookup defaults.
+ * \param default_font path to default font to use. Must be supplied if
+ * fontconfig is disabled or unavailable.
+ * \param default_family fallback font family for fontconfig, or NULL
  * \param fc whether to use fontconfig
  * \param config path to fontconfig configuration file, or NULL.  Only relevant
  * if fontconfig is used.
  * \param update whether fontconfig cache should be built/updated now.  Only
  * relevant if fontconfig is used.
  */
-void ass_set_fonts(ass_renderer_t *priv, const char *default_font,
+void ass_set_fonts(ASS_Renderer *priv, const char *default_font,
                    const char *default_family, int fc, const char *config,
                    int update);
 
@@ -212,7 +215,7 @@
  * \param priv renderer handle
  * \return success
  */
-int ass_fonts_update(ass_renderer_t *priv);
+int ass_fonts_update(ASS_Renderer *priv);
 
 /**
  * \brief Set hard cache limits.  Do not set, or set to zero, for reasonable
@@ -222,19 +225,19 @@
  * \param glyph_max maximum number of cached glyphs
  * \param bitmap_max_size maximum bitmap cache size (in MB)
  */
-void ass_set_cache_limits(ass_renderer_t *priv, int glyph_max,
+void ass_set_cache_limits(ASS_Renderer *priv, int glyph_max,
                           int bitmap_max_size);
 
 /**
- * \brief Render a frame, producing a list of ass_image_t.
+ * \brief Render a frame, producing a list of ASS_Image.
  * \param priv renderer handle
  * \param track subtitle track
  * \param now video timestamp in milliseconds
  * \param detect_change will be set to 1 if a change occured compared
  * to the last invocation
  */
-ass_image_t *ass_render_frame(ass_renderer_t *priv, ass_track_t *track,
-                              long long now, int *detect_change);
+ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
+                            long long now, int *detect_change);
 
 
 /*
@@ -247,27 +250,27 @@
  * \param library handle
  * \return pointer to empty track
  */
-ass_track_t *ass_new_track(ass_library_t *);
+ASS_Track *ass_new_track(ASS_Library *);
 
 /**
  * \brief Deallocate track and all its child objects (styles and events).
  * \param track track to deallocate
  */
-void ass_free_track(ass_track_t *track);
+void ass_free_track(ASS_Track *track);
 
 /**
  * \brief Allocate new style.
  * \param track track
  * \return newly allocated style id
  */
-int ass_alloc_style(ass_track_t *track);
+int ass_alloc_style(ASS_Track *track);
 
 /**
  * \brief Allocate new event.
  * \param track track
  * \return newly allocated event id
  */
-int ass_alloc_event(ass_track_t *track);
+int ass_alloc_event(ASS_Track *track);
 
 /**
  * \brief Delete a style.
@@ -275,7 +278,7 @@
  * \param sid style id
  * Deallocates style data. Does not modify track-&gt;n_styles.
  */
-void ass_free_style(ass_track_t *track, int sid);
+void ass_free_style(ASS_Track *track, int sid);
 
 /**
  * \brief Delete an event.
@@ -283,7 +286,7 @@
  * \param eid event id
  * Deallocates event data. Does not modify track-&gt;n_events.
  */
-void ass_free_event(ass_track_t *track, int eid);
+void ass_free_event(ASS_Track *track, int eid);
 
 /**
  * \brief Parse a chunk of subtitle stream data.
@@ -291,7 +294,7 @@
  * \param data string to parse
  * \param size length of data
  */
-void ass_process_data(ass_track_t *track, char *data, int size);
+void ass_process_data(ASS_Track *track, char *data, int size);
 
 /**
  * \brief Parse Codec Private section of subtitle stream.
@@ -299,7 +302,7 @@
  * \param data string to parse
  * \param size length of data
  */
-void ass_process_codec_private(ass_track_t *track, char *data, int size);
+void ass_process_codec_private(ASS_Track *track, char *data, int size);
 
 /**
  * \brief Parse a chunk of subtitle stream data. In Matroska,
@@ -310,7 +313,7 @@
  * \param timecode starting time of the event (milliseconds)
  * \param duration duration of the event (milliseconds)
  */
-void ass_process_chunk(ass_track_t *track, char *data, int size,
+void ass_process_chunk(ASS_Track *track, char *data, int size,
                        long long timecode, long long duration);
 
 /**
@@ -320,8 +323,8 @@
  * \param codepage encoding (iconv format)
  * \return newly allocated track
 */
-ass_track_t *ass_read_file(ass_library_t *library, char *fname,
-                           char *codepage);
+ASS_Track *ass_read_file(ASS_Library *library, char *fname,
+                         char *codepage);
 
 /**
  * \brief Read subtitles from memory.
@@ -331,15 +334,15 @@
  * \param codepage encoding (iconv format)
  * \return newly allocated track
 */
-ass_track_t *ass_read_memory(ass_library_t *library, char *buf,
-                             size_t bufsize, char *codepage);
+ASS_Track *ass_read_memory(ASS_Library *library, char *buf,
+                           size_t bufsize, char *codepage);
 /**
  * \brief Read styles from file into already initialized track.
  * \param fname file name
  * \param codepage encoding (iconv format)
  * \return 0 on success
  */
-int ass_read_styles(ass_track_t *track, char *fname, char *codepage);
+int ass_read_styles(ASS_Track *track, char *fname, char *codepage);
 
 /**
  * \brief Add a memory font.
@@ -348,14 +351,14 @@
  * \param data binary font data
  * \param data_size data size
 */
-void ass_add_font(ass_library_t *library, char *name, char *data,
+void ass_add_font(ASS_Library *library, char *name, char *data,
                   int data_size);
 
 /**
  * \brief Remove all fonts stored in an ass_library object.
  * \param library library handle
  */
-void ass_clear_fonts(ass_library_t *library);
+void ass_clear_fonts(ASS_Library *library);
 
 /**
  * \brief Calculates timeshift from now to the start of some other subtitle
@@ -366,6 +369,6 @@
  * +2 means &quot;the one after the next&quot;, -1 means &quot;previous&quot;
  * \return timeshift in milliseconds
  */
-long long ass_step_sub(ass_track_t *track, long long now, int movement);
+long long ass_step_sub(ASS_Track *track, long long now, int movement);
 
 #endif /* LIBASS_ASS_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -44,7 +44,7 @@
 static const unsigned int maxcolor = 255;
 static const unsigned base = 256;
 
-static int generate_tables(ass_synth_priv_t *priv, double radius)
+static int generate_tables(ASS_SynthPriv *priv, double radius)
 {
     double A = log(1.0 / base) / (radius * radius * 2);
     int mx, i;
@@ -101,7 +101,7 @@
     return 0;
 }
 
-static void resize_tmp(ass_synth_priv_t *priv, int w, int h)
+static void resize_tmp(ASS_SynthPriv *priv, int w, int h)
 {
     if (priv-&gt;tmp_w &gt;= w &amp;&amp; priv-&gt;tmp_h &gt;= h)
         return;
@@ -118,14 +118,14 @@
     priv-&gt;tmp = malloc((priv-&gt;tmp_w + 1) * priv-&gt;tmp_h * sizeof(short));
 }
 
-ass_synth_priv_t *ass_synth_init(double radius)
+ASS_SynthPriv *ass_synth_init(double radius)
 {
-    ass_synth_priv_t *priv = calloc(1, sizeof(ass_synth_priv_t));
+    ASS_SynthPriv *priv = calloc(1, sizeof(ASS_SynthPriv));
     generate_tables(priv, radius);
     return priv;
 }
 
-void ass_synth_done(ass_synth_priv_t *priv)
+void ass_synth_done(ASS_SynthPriv *priv)
 {
     if (priv-&gt;tmp)
         free(priv-&gt;tmp);
@@ -136,10 +136,10 @@
     free(priv);
 }
 
-static bitmap_t *alloc_bitmap(int w, int h)
+static Bitmap *alloc_bitmap(int w, int h)
 {
-    bitmap_t *bm;
-    bm = calloc(1, sizeof(bitmap_t));
+    Bitmap *bm;
+    bm = calloc(1, sizeof(Bitmap));
     bm-&gt;buffer = malloc(w * h);
     bm-&gt;w = w;
     bm-&gt;h = h;
@@ -147,7 +147,7 @@
     return bm;
 }
 
-void ass_free_bitmap(bitmap_t *bm)
+void ass_free_bitmap(Bitmap *bm)
 {
     if (bm) {
         if (bm-&gt;buffer)
@@ -156,16 +156,16 @@
     }
 }
 
-static bitmap_t *copy_bitmap(const bitmap_t *src)
+static Bitmap *copy_bitmap(const Bitmap *src)
 {
-    bitmap_t *dst = alloc_bitmap(src-&gt;w, src-&gt;h);
+    Bitmap *dst = alloc_bitmap(src-&gt;w, src-&gt;h);
     dst-&gt;left = src-&gt;left;
     dst-&gt;top = src-&gt;top;
     memcpy(dst-&gt;buffer, src-&gt;buffer, src-&gt;w * src-&gt;h);
     return dst;
 }
 
-static int check_glyph_area(ass_library_t *library, FT_Glyph glyph)
+static int check_glyph_area(ASS_Library *library, FT_Glyph glyph)
 {
     FT_BBox bbox;
     long long dx, dy;
@@ -180,12 +180,12 @@
         return 0;
 }
 
-static bitmap_t *glyph_to_bitmap_internal(ass_library_t *library,
+static Bitmap *glyph_to_bitmap_internal(ASS_Library *library,
                                           FT_Glyph glyph, int bord)
 {
     FT_BitmapGlyph bg;
     FT_Bitmap *bit;
-    bitmap_t *bm;
+    Bitmap *bm;
     int w, h;
     unsigned char *src;
     unsigned char *dst;
@@ -230,12 +230,12 @@
 }
 
 /**
- * \brief fix outline bitmap and generate shadow bitmap
- * Two things are done here:
- * 1. Glyph bitmap is subtracted from outline bitmap. This way looks much better in some cases.
- * 2. Shadow bitmap is created as a sum of glyph and outline bitmaps.
+ * \brief fix outline bitmap
+ *
+ * The glyph bitmap is subtracted from outline bitmap. This way looks much
+ * better in some cases.
  */
-static bitmap_t *fix_outline_and_shadow(bitmap_t *bm_g, bitmap_t *bm_o)
+static void fix_outline(Bitmap *bm_g, Bitmap *bm_o)
 {
     int x, y;
     const int l = bm_o-&gt;left &gt; bm_g-&gt;left ? bm_o-&gt;left : bm_g-&gt;left;
@@ -247,30 +247,21 @@
         bm_o-&gt;top + bm_o-&gt;h &lt;
         bm_g-&gt;top + bm_g-&gt;h ? bm_o-&gt;top + bm_o-&gt;h : bm_g-&gt;top + bm_g-&gt;h;
 
-    bitmap_t *bm_s = copy_bitmap(bm_o);
-
     unsigned char *g =
         bm_g-&gt;buffer + (t - bm_g-&gt;top) * bm_g-&gt;w + (l - bm_g-&gt;left);
     unsigned char *o =
         bm_o-&gt;buffer + (t - bm_o-&gt;top) * bm_o-&gt;w + (l - bm_o-&gt;left);
-    unsigned char *s =
-        bm_s-&gt;buffer + (t - bm_s-&gt;top) * bm_s-&gt;w + (l - bm_s-&gt;left);
 
     for (y = 0; y &lt; b - t; ++y) {
         for (x = 0; x &lt; r - l; ++x) {
             unsigned char c_g, c_o;
             c_g = g[x];
             c_o = o[x];
-            o[x] = (c_o &gt; (3 * c_g) / 5) ? c_o - (3 * c_g) / 5 : 0;
-            s[x] = (c_o &lt; 0xFF - c_g) ? c_o + c_g : 0xFF;
+            o[x] = (c_o &gt; c_g) ? c_o - (c_g / 2) : 0;
         }
         g += bm_g-&gt;w;
         o += bm_o-&gt;w;
-        s += bm_s-&gt;w;
     }
-
-    assert(bm_s);
-    return bm_s;
 }
 
 /**
@@ -472,10 +463,11 @@
     }
 }
 
-int glyph_to_bitmap(ass_library_t *library, ass_synth_priv_t *priv_blur,
+int glyph_to_bitmap(ASS_Library *library, ASS_SynthPriv *priv_blur,
                     FT_Glyph glyph, FT_Glyph outline_glyph,
-                    bitmap_t **bm_g, bitmap_t **bm_o, bitmap_t **bm_s,
-                    int be, double blur_radius, FT_Vector shadow_offset)
+                    Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset,
+                    int border_style)
 {
     blur_radius *= 2;
     int bbord = be &gt; 0 ? sqrt(2 * be) : 0;
@@ -527,14 +519,19 @@
                            priv_blur-&gt;g_w);
     }
 
-    if (*bm_o)
-        *bm_s = fix_outline_and_shadow(*bm_g, *bm_o);
-    else
+    // Create shadow and fix outline as needed
+    if (*bm_o &amp;&amp; border_style != 3) {
+        *bm_s = copy_bitmap(*bm_o);
+        fix_outline(*bm_g, *bm_o);
+    } else if (*bm_o) {
+        *bm_s = copy_bitmap(*bm_o);
+    } else
         *bm_s = copy_bitmap(*bm_g);
 
+    assert(bm_s);
+
     shift_bitmap((*bm_s)-&gt;buffer, (*bm_s)-&gt;w,(*bm_s)-&gt;h,
                  shadow_offset.x, shadow_offset.y);
 
-    assert(bm_s);
     return 0;
 }

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -26,16 +26,16 @@
 
 #include &quot;ass.h&quot;
 
-typedef struct ass_synth_priv ass_synth_priv_t;
+typedef struct ass_synth_priv ASS_SynthPriv;
 
-ass_synth_priv_t *ass_synth_init(double);
-void ass_synth_done(ass_synth_priv_t *priv);
+ASS_SynthPriv *ass_synth_init(double);
+void ass_synth_done(ASS_SynthPriv *priv);
 
 typedef struct {
     int left, top;
     int w, h;                   // width, height
     unsigned char *buffer;      // w x h buffer
-} bitmap_t;
+} Bitmap;
 
 /**
  * \brief perform glyph rendering
@@ -46,11 +46,12 @@
  * \param bm_g out: pointer to the bitmap of glyph shadow is returned here
  * \param be 1 = produces blurred bitmaps, 0 = normal bitmaps
  */
-int glyph_to_bitmap(ass_library_t *library, ass_synth_priv_t *priv_blur,
+int glyph_to_bitmap(ASS_Library *library, ASS_SynthPriv *priv_blur,
                     FT_Glyph glyph, FT_Glyph outline_glyph,
-                    bitmap_t **bm_g, bitmap_t **bm_o, bitmap_t **bm_s,
-                    int be, double blur_radius, FT_Vector shadow_offset);
+                    Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset,
+                    int border_style);
 
-void ass_free_bitmap(bitmap_t *bm);
+void ass_free_bitmap(Bitmap *bm);
 
 #endif                          /* LIBASS_BITMAP_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -51,13 +51,13 @@
     free(value);
 }
 
-hashmap_t *hashmap_init(ass_library_t *library, size_t key_size,
-                        size_t value_size, int nbuckets,
-                        hashmap_item_dtor_t item_dtor,
-                        hashmap_key_compare_t key_compare,
-                        hashmap_hash_t hash)
+Hashmap *hashmap_init(ASS_Library *library, size_t key_size,
+                      size_t value_size, int nbuckets,
+                      HashmapItemDtor item_dtor,
+                      HashmapKeyCompare key_compare,
+                      HashmapHash hash)
 {
-    hashmap_t *map = calloc(1, sizeof(hashmap_t));
+    Hashmap *map = calloc(1, sizeof(Hashmap));
     map-&gt;library = library;
     map-&gt;nbuckets = nbuckets;
     map-&gt;key_size = key_size;
@@ -69,7 +69,7 @@
     return map;
 }
 
-void hashmap_done(hashmap_t *map)
+void hashmap_done(Hashmap *map)
 {
     int i;
     // print stats
@@ -81,9 +81,9 @@
                map-&gt;miss_count, map-&gt;count);
 
     for (i = 0; i &lt; map-&gt;nbuckets; ++i) {
-        hashmap_item_t *item = map-&gt;root[i];
+        HashmapItem *item = map-&gt;root[i];
         while (item) {
-            hashmap_item_t *next = item-&gt;next;
+            HashmapItem *next = item-&gt;next;
             map-&gt;item_dtor(item-&gt;key, map-&gt;key_size, item-&gt;value,
                            map-&gt;value_size);
             free(item);
@@ -95,17 +95,17 @@
 }
 
 // does nothing if key already exists
-void *hashmap_insert(hashmap_t *map, void *key, void *value)
+void *hashmap_insert(Hashmap *map, void *key, void *value)
 {
     unsigned hash = map-&gt;hash(key, map-&gt;key_size);
-    hashmap_item_t **next = map-&gt;root + (hash % map-&gt;nbuckets);
+    HashmapItem **next = map-&gt;root + (hash % map-&gt;nbuckets);
     while (*next) {
         if (map-&gt;key_compare(key, (*next)-&gt;key, map-&gt;key_size))
             return (*next)-&gt;value;
         next = &amp;((*next)-&gt;next);
         assert(next);
     }
-    (*next) = malloc(sizeof(hashmap_item_t));
+    (*next) = malloc(sizeof(HashmapItem));
     (*next)-&gt;key = malloc(map-&gt;key_size);
     (*next)-&gt;value = malloc(map-&gt;value_size);
     memcpy((*next)-&gt;key, key, map-&gt;key_size);
@@ -116,10 +116,10 @@
     return (*next)-&gt;value;
 }
 
-void *hashmap_find(hashmap_t *map, void *key)
+void *hashmap_find(Hashmap *map, void *key)
 {
     unsigned hash = map-&gt;hash(key, map-&gt;key_size);
-    hashmap_item_t *item = map-&gt;root[hash % map-&gt;nbuckets];
+    HashmapItem *item = map-&gt;root[hash % map-&gt;nbuckets];
     while (item) {
         if (map-&gt;key_compare(key, item-&gt;key, map-&gt;key_size)) {
             map-&gt;hit_count++;
@@ -136,7 +136,7 @@
 
 static unsigned font_desc_hash(void *buf, size_t len)
 {
-    ass_font_desc_t *desc = buf;
+    ASS_FontDesc *desc = buf;
     unsigned hval;
     hval = fnv_32a_str(desc-&gt;family, FNV1_32A_INIT);
     hval = fnv_32a_buf(&amp;desc-&gt;bold, sizeof(desc-&gt;bold), hval);
@@ -146,8 +146,8 @@
 
 static int font_compare(void *key1, void *key2, size_t key_size)
 {
-    ass_font_desc_t *a = key1;
-    ass_font_desc_t *b = key2;
+    ASS_FontDesc *a = key1;
+    ASS_FontDesc *b = key2;
     if (strcmp(a-&gt;family, b-&gt;family) != 0)
         return 0;
     if (a-&gt;bold != b-&gt;bold)
@@ -166,8 +166,8 @@
     free(key);
 }
 
-ass_font_t *ass_font_cache_find(hashmap_t *font_cache,
-                                ass_font_desc_t *desc)
+ASS_Font *ass_font_cache_find(Hashmap *font_cache,
+                              ASS_FontDesc *desc)
 {
     return hashmap_find(font_cache, desc);
 }
@@ -176,22 +176,22 @@
  * \brief Add a face struct to cache.
  * \param font font struct
 */
-void *ass_font_cache_add(hashmap_t *font_cache, ass_font_t *font)
+void *ass_font_cache_add(Hashmap *font_cache, ASS_Font *font)
 {
     return hashmap_insert(font_cache, &amp;(font-&gt;desc), font);
 }
 
-hashmap_t *ass_font_cache_init(ass_library_t *library)
+Hashmap *ass_font_cache_init(ASS_Library *library)
 {
-    hashmap_t *font_cache;
-    font_cache = hashmap_init(library, sizeof(ass_font_desc_t),
-                              sizeof(ass_font_t),
+    Hashmap *font_cache;
+    font_cache = hashmap_init(library, sizeof(ASS_FontDesc),
+                              sizeof(ASS_Font),
                               1000,
                               font_hash_dtor, font_compare, font_desc_hash);
     return font_cache;
 }
 
-void ass_font_cache_done(hashmap_t *font_cache)
+void ass_font_cache_done(Hashmap *font_cache)
 {
     hashmap_done(font_cache);
 }
@@ -209,7 +209,7 @@
 static void bitmap_hash_dtor(void *key, size_t key_size, void *value,
                              size_t value_size)
 {
-    bitmap_hash_val_t *v = value;
+    BitmapHashValue *v = value;
     if (v-&gt;bm)
         ass_free_bitmap(v-&gt;bm);
     if (v-&gt;bm_o)
@@ -220,13 +220,13 @@
     free(value);
 }
 
-void *cache_add_bitmap(hashmap_t *bitmap_cache, bitmap_hash_key_t *key,
-                       bitmap_hash_val_t *val)
+void *cache_add_bitmap(Hashmap *bitmap_cache, BitmapHashKey *key,
+                       BitmapHashValue *val)
 {
     // Note: this is only an approximation
     if (val-&gt;bm_o)
         bitmap_cache-&gt;cache_size += val-&gt;bm_o-&gt;w * val-&gt;bm_o-&gt;h * 3;
-    else
+    else if (val-&gt;bm)
         bitmap_cache-&gt;cache_size += val-&gt;bm-&gt;w * val-&gt;bm-&gt;h * 3;
 
     return hashmap_insert(bitmap_cache, key, val);
@@ -237,32 +237,32 @@
  * \param key hash key
  * \return requested hash val or 0 if not found
 */
-bitmap_hash_val_t *cache_find_bitmap(hashmap_t *bitmap_cache,
-                                     bitmap_hash_key_t *key)
+BitmapHashValue *cache_find_bitmap(Hashmap *bitmap_cache,
+                                   BitmapHashKey *key)
 {
     return hashmap_find(bitmap_cache, key);
 }
 
-hashmap_t *ass_bitmap_cache_init(ass_library_t *library)
+Hashmap *ass_bitmap_cache_init(ASS_Library *library)
 {
-    hashmap_t *bitmap_cache;
+    Hashmap *bitmap_cache;
     bitmap_cache = hashmap_init(library,
-                                sizeof(bitmap_hash_key_t),
-                                sizeof(bitmap_hash_val_t),
+                                sizeof(BitmapHashKey),
+                                sizeof(BitmapHashValue),
                                 0xFFFF + 13,
                                 bitmap_hash_dtor, bitmap_compare,
                                 bitmap_hash);
     return bitmap_cache;
 }
 
-void ass_bitmap_cache_done(hashmap_t *bitmap_cache)
+void ass_bitmap_cache_done(Hashmap *bitmap_cache)
 {
     hashmap_done(bitmap_cache);
 }
 
-hashmap_t *ass_bitmap_cache_reset(hashmap_t *bitmap_cache)
+Hashmap *ass_bitmap_cache_reset(Hashmap *bitmap_cache)
 {
-    ass_library_t *lib = bitmap_cache-&gt;library;
+    ASS_Library *lib = bitmap_cache-&gt;library;
 
     ass_bitmap_cache_done(bitmap_cache);
     return ass_bitmap_cache_init(lib);
@@ -274,7 +274,7 @@
 static void glyph_hash_dtor(void *key, size_t key_size, void *value,
                             size_t value_size)
 {
-    glyph_hash_val_t *v = value;
+    GlyphHashValue *v = value;
     if (v-&gt;glyph)
         FT_Done_Glyph(v-&gt;glyph);
     if (v-&gt;outline_glyph)
@@ -283,8 +283,8 @@
     free(value);
 }
 
-void *cache_add_glyph(hashmap_t *glyph_cache, glyph_hash_key_t *key,
-                      glyph_hash_val_t *val)
+void *cache_add_glyph(Hashmap *glyph_cache, GlyphHashKey *key,
+                      GlyphHashValue *val)
 {
     return hashmap_insert(glyph_cache, key, val);
 }
@@ -294,30 +294,30 @@
  * \param key hash key
  * \return requested hash val or 0 if not found
 */
-glyph_hash_val_t *cache_find_glyph(hashmap_t *glyph_cache,
-                                   glyph_hash_key_t *key)
+GlyphHashValue *cache_find_glyph(Hashmap *glyph_cache,
+                                 GlyphHashKey *key)
 {
     return hashmap_find(glyph_cache, key);
 }
 
-hashmap_t *ass_glyph_cache_init(ass_library_t *library)
+Hashmap *ass_glyph_cache_init(ASS_Library *library)
 {
-    hashmap_t *glyph_cache;
-    glyph_cache = hashmap_init(library, sizeof(glyph_hash_key_t),
-                               sizeof(glyph_hash_val_t),
+    Hashmap *glyph_cache;
+    glyph_cache = hashmap_init(library, sizeof(GlyphHashKey),
+                               sizeof(GlyphHashValue),
                                0xFFFF + 13,
                                glyph_hash_dtor, glyph_compare, glyph_hash);
     return glyph_cache;
 }
 
-void ass_glyph_cache_done(hashmap_t *glyph_cache)
+void ass_glyph_cache_done(Hashmap *glyph_cache)
 {
     hashmap_done(glyph_cache);
 }
 
-hashmap_t *ass_glyph_cache_reset(hashmap_t *glyph_cache)
+Hashmap *ass_glyph_cache_reset(Hashmap *glyph_cache)
 {
-    ass_library_t *lib = glyph_cache-&gt;library;
+    ASS_Library *lib = glyph_cache-&gt;library;
 
     ass_glyph_cache_done(glyph_cache);
     return ass_glyph_cache_init(lib);
@@ -330,16 +330,16 @@
 static void composite_hash_dtor(void *key, size_t key_size, void *value,
                                 size_t value_size)
 {
-    composite_hash_val_t *v = value;
+    CompositeHashValue *v = value;
     free(v-&gt;a);
     free(v-&gt;b);
     free(key);
     free(value);
 }
 
-void *cache_add_composite(hashmap_t *composite_cache,
-                          composite_hash_key_t *key,
-                          composite_hash_val_t *val)
+void *cache_add_composite(Hashmap *composite_cache,
+                          CompositeHashKey *key,
+                          CompositeHashValue *val)
 {
     return hashmap_insert(composite_cache, key, val);
 }
@@ -349,31 +349,31 @@
  * \param key hash key
  * \return requested hash val or 0 if not found
 */
-composite_hash_val_t *cache_find_composite(hashmap_t *composite_cache,
-                                           composite_hash_key_t *key)
+CompositeHashValue *cache_find_composite(Hashmap *composite_cache,
+                                         CompositeHashKey *key)
 {
     return hashmap_find(composite_cache, key);
 }
 
-hashmap_t *ass_composite_cache_init(ass_library_t *library)
+Hashmap *ass_composite_cache_init(ASS_Library *library)
 {
-    hashmap_t *composite_cache;
-    composite_cache = hashmap_init(library, sizeof(composite_hash_key_t),
-                                   sizeof(composite_hash_val_t),
+    Hashmap *composite_cache;
+    composite_cache = hashmap_init(library, sizeof(CompositeHashKey),
+                                   sizeof(CompositeHashValue),
                                    0xFFFF + 13,
                                    composite_hash_dtor, composite_compare,
                                    composite_hash);
     return composite_cache;
 }
 
-void ass_composite_cache_done(hashmap_t *composite_cache)
+void ass_composite_cache_done(Hashmap *composite_cache)
 {
     hashmap_done(composite_cache);
 }
 
-hashmap_t *ass_composite_cache_reset(hashmap_t *composite_cache)
+Hashmap *ass_composite_cache_reset(Hashmap *composite_cache)
 {
-    ass_library_t *lib = composite_cache-&gt;library;
+    ASS_Library *lib = composite_cache-&gt;library;
 
     ass_composite_cache_done(composite_cache);
     return ass_composite_cache_init(lib);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -25,79 +25,79 @@
 #include &quot;ass_font.h&quot;
 #include &quot;ass_bitmap.h&quot;
 
-typedef void (*hashmap_item_dtor_t) (void *key, size_t key_size,
-                                     void *value, size_t value_size);
-typedef int (*hashmap_key_compare_t) (void *key1, void *key2,
-                                      size_t key_size);
-typedef unsigned (*hashmap_hash_t) (void *key, size_t key_size);
+typedef void (*HashmapItemDtor) (void *key, size_t key_size,
+                                 void *value, size_t value_size);
+typedef int (*HashmapKeyCompare) (void *key1, void *key2,
+                                  size_t key_size);
+typedef unsigned (*HashmapHash) (void *key, size_t key_size);
 
 typedef struct hashmap_item {
     void *key;
     void *value;
     struct hashmap_item *next;
-} hashmap_item_t;
-typedef hashmap_item_t *hashmap_item_p;
+} HashmapItem;
+typedef HashmapItem *hashmap_item_p;
 
 typedef struct {
     int nbuckets;
     size_t key_size, value_size;
     hashmap_item_p *root;
-    hashmap_item_dtor_t item_dtor;      // a destructor for hashmap key/value pairs
-    hashmap_key_compare_t key_compare;
-    hashmap_hash_t hash;
+    HashmapItemDtor item_dtor;      // a destructor for hashmap key/value pairs
+    HashmapKeyCompare key_compare;
+    HashmapHash hash;
     size_t cache_size;
     // stats
     int hit_count;
     int miss_count;
     int count;
-    ass_library_t *library;
-} hashmap_t;
+    ASS_Library *library;
+} Hashmap;
 
-hashmap_t *hashmap_init(ass_library_t *library, size_t key_size,
-                        size_t value_size, int nbuckets,
-                        hashmap_item_dtor_t item_dtor,
-                        hashmap_key_compare_t key_compare,
-                        hashmap_hash_t hash);
-void hashmap_done(hashmap_t *map);
-void *hashmap_insert(hashmap_t *map, void *key, void *value);
-void *hashmap_find(hashmap_t *map, void *key);
+Hashmap *hashmap_init(ASS_Library *library, size_t key_size,
+                      size_t value_size, int nbuckets,
+                      HashmapItemDtor item_dtor,
+                      HashmapKeyCompare key_compare,
+                      HashmapHash hash);
+void hashmap_done(Hashmap *map);
+void *hashmap_insert(Hashmap *map, void *key, void *value);
+void *hashmap_find(Hashmap *map, void *key);
 
-hashmap_t *ass_font_cache_init(ass_library_t *library);
-ass_font_t *ass_font_cache_find(hashmap_t *, ass_font_desc_t *desc);
-void *ass_font_cache_add(hashmap_t *, ass_font_t *font);
-void ass_font_cache_done(hashmap_t *);
+Hashmap *ass_font_cache_init(ASS_Library *library);
+ASS_Font *ass_font_cache_find(Hashmap *, ASS_FontDesc *desc);
+void *ass_font_cache_add(Hashmap *, ASS_Font *font);
+void ass_font_cache_done(Hashmap *);
 
 // Create definitions for bitmap_hash_key and glyph_hash_key
 #define CREATE_STRUCT_DEFINITIONS
 #include &quot;ass_cache_template.h&quot;
 
 typedef struct {
-    bitmap_t *bm;               // the actual bitmaps
-    bitmap_t *bm_o;
-    bitmap_t *bm_s;
-} bitmap_hash_val_t;
+    Bitmap *bm;               // the actual bitmaps
+    Bitmap *bm_o;
+    Bitmap *bm_s;
+} BitmapHashValue;
 
-hashmap_t *ass_bitmap_cache_init(ass_library_t *library);
-void *cache_add_bitmap(hashmap_t *, bitmap_hash_key_t *key,
-                       bitmap_hash_val_t *val);
-bitmap_hash_val_t *cache_find_bitmap(hashmap_t *bitmap_cache,
-                                     bitmap_hash_key_t *key);
-hashmap_t *ass_bitmap_cache_reset(hashmap_t *bitmap_cache);
-void ass_bitmap_cache_done(hashmap_t *bitmap_cache);
+Hashmap *ass_bitmap_cache_init(ASS_Library *library);
+void *cache_add_bitmap(Hashmap *, BitmapHashKey *key,
+                       BitmapHashValue *val);
+BitmapHashValue *cache_find_bitmap(Hashmap *bitmap_cache,
+                                   BitmapHashKey *key);
+Hashmap *ass_bitmap_cache_reset(Hashmap *bitmap_cache);
+void ass_bitmap_cache_done(Hashmap *bitmap_cache);
 
 
 typedef struct {
     unsigned char *a;
     unsigned char *b;
-} composite_hash_val_t;
+} CompositeHashValue;
 
-hashmap_t *ass_composite_cache_init(ass_library_t *library);
-void *cache_add_composite(hashmap_t *, composite_hash_key_t *key,
-                          composite_hash_val_t *val);
-composite_hash_val_t *cache_find_composite(hashmap_t *composite_cache,
-                                           composite_hash_key_t *key);
-hashmap_t *ass_composite_cache_reset(hashmap_t *composite_cache);
-void ass_composite_cache_done(hashmap_t *composite_cache);
+Hashmap *ass_composite_cache_init(ASS_Library *library);
+void *cache_add_composite(Hashmap *, CompositeHashKey *key,
+                          CompositeHashValue *val);
+CompositeHashValue *cache_find_composite(Hashmap *composite_cache,
+                                         CompositeHashKey *key);
+Hashmap *ass_composite_cache_reset(Hashmap *composite_cache);
+void ass_composite_cache_done(Hashmap *composite_cache);
 
 
 typedef struct {
@@ -106,14 +106,14 @@
     FT_BBox bbox_scaled;        // bbox after scaling, but before rotation
     FT_Vector advance;          // 26.6, advance distance to the next bitmap in line
     int asc, desc;              // ascender/descender of a drawing
-} glyph_hash_val_t;
+} GlyphHashValue;
 
-hashmap_t *ass_glyph_cache_init(ass_library_t *library);
-void *cache_add_glyph(hashmap_t *, glyph_hash_key_t *key,
-                      glyph_hash_val_t *val);
-glyph_hash_val_t *cache_find_glyph(hashmap_t *glyph_cache,
-                                   glyph_hash_key_t *key);
-hashmap_t *ass_glyph_cache_reset(hashmap_t *glyph_cache);
-void ass_glyph_cache_done(hashmap_t *glyph_cache);
+Hashmap *ass_glyph_cache_init(ASS_Library *library);
+void *cache_add_glyph(Hashmap *, GlyphHashKey *key,
+                      GlyphHashValue *val);
+GlyphHashValue *cache_find_glyph(Hashmap *glyph_cache,
+                                 GlyphHashKey *key);
+Hashmap *ass_glyph_cache_reset(Hashmap *glyph_cache);
+void ass_glyph_cache_done(Hashmap *glyph_cache);
 
 #endif                          /* LIBASS_CACHE_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -7,7 +7,7 @@
 #define FTVECTOR(member) \
         FT_Vector member;
 #define BITMAPHASHKEY(member) \
-        bitmap_hash_key_t member;
+        BitmapHashKey member;
 #define END(typedefnamename) \
     } typedefnamename;
 
@@ -54,9 +54,9 @@
 
 
 // describes a bitmap; bitmaps with equivalents structs are considered identical
-START(bitmap, bipmap_hash_key)
+START(bitmap, bitmap_hash_key)
     GENERIC(char, bitmap) // bool : true = bitmap, false = outline
-    GENERIC(ass_font_t *, font)
+    GENERIC(ASS_Font *, font)
     GENERIC(double, size) // font size
     GENERIC(uint32_t, ch) // character code
     FTVECTOR(outline) // border width, 16.16 fixed point value
@@ -79,11 +79,13 @@
     FTVECTOR(advance) // subpixel shift vector
     FTVECTOR(shadow_offset) // shadow subpixel shift
     GENERIC(unsigned, drawing_hash) // hashcode of a drawing
-END(bitmap_hash_key_t)
+    GENERIC(unsigned, flags)    // glyph decoration
+    GENERIC(unsigned, border_style)
+END(BitmapHashKey)
 
 // describes an outline glyph
 START(glyph, glyph_hash_key)
-    GENERIC(ass_font_t *, font)
+    GENERIC(ASS_Font *, font)
     GENERIC(double, size) // font size
     GENERIC(uint32_t, ch) // character code
     GENERIC(int, bold)
@@ -93,7 +95,8 @@
     FTVECTOR(outline) // border width, 16.16
     GENERIC(unsigned, drawing_hash) // hashcode of a drawing
     GENERIC(unsigned, flags)    // glyph decoration flags
-END(glyph_hash_key_t)
+    GENERIC(unsigned, border_style)
+END(GlyphHashKey)
 
 // Cache for composited bitmaps
 START(composite, composite_hash_key)
@@ -105,9 +108,11 @@
     GENERIC(int, ay)
     GENERIC(int, bx)
     GENERIC(int, by)
-    BITMAPHASHKEY(a)
-    BITMAPHASHKEY(b)
-END(composite_hash_key_t)
+    GENERIC(int, as)
+    GENERIC(int, bs)
+    GENERIC(unsigned char *, a)
+    GENERIC(unsigned char *, b)
+END(CompositeHashKey)
 
 
 #undef START

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -33,29 +33,30 @@
 /*
  * \brief Get and prepare a FreeType glyph
  */
-static void drawing_make_glyph(ass_drawing_t *drawing, void *fontconfig_priv,
-                               ass_font_t *font, ass_hinting_t hint)
+static void drawing_make_glyph(ASS_Drawing *drawing, void *fontconfig_priv,
+                               ASS_Font *font, ASS_Hinting hint)
 {
     FT_OutlineGlyph glyph;
 
     // This is hacky...
     glyph = (FT_OutlineGlyph) ass_font_get_glyph(fontconfig_priv, font,
                                                  (uint32_t) ' ', hint, 0);
+    if (glyph) {
+        FT_Outline_Done(drawing-&gt;ftlibrary, &amp;glyph-&gt;outline);
+        FT_Outline_New(drawing-&gt;ftlibrary, GLYPH_INITIAL_POINTS,
+                       GLYPH_INITIAL_CONTOURS, &amp;glyph-&gt;outline);
 
-    FT_Outline_Done(drawing-&gt;ftlibrary, &amp;glyph-&gt;outline);
-    FT_Outline_New(drawing-&gt;ftlibrary, GLYPH_INITIAL_POINTS,
-                   GLYPH_INITIAL_CONTOURS, &amp;glyph-&gt;outline);
-
-    glyph-&gt;outline.n_contours = 0;
-    glyph-&gt;outline.n_points = 0;
-    glyph-&gt;root.advance.x = glyph-&gt;root.advance.y = 0;
+        glyph-&gt;outline.n_contours = 0;
+        glyph-&gt;outline.n_points = 0;
+        glyph-&gt;root.advance.x = glyph-&gt;root.advance.y = 0;
+    }
     drawing-&gt;glyph = glyph;
 }
 
 /*
  * \brief Add a single point to a contour.
  */
-static inline void drawing_add_point(ass_drawing_t *drawing,
+static inline void drawing_add_point(ASS_Drawing *drawing,
                                      FT_Vector *point)
 {
     FT_Outline *ol = &amp;drawing-&gt;glyph-&gt;outline;
@@ -76,7 +77,7 @@
 /*
  * \brief Close a contour and check glyph size overflow.
  */
-static inline void drawing_close_shape(ass_drawing_t *drawing)
+static inline void drawing_close_shape(ASS_Drawing *drawing)
 {
     FT_Outline *ol = &amp;drawing-&gt;glyph-&gt;outline;
 
@@ -86,14 +87,16 @@
                                drawing-&gt;max_contours);
     }
 
-    ol-&gt;contours[ol-&gt;n_contours] = ol-&gt;n_points - 1;
-    ol-&gt;n_contours++;
+    if (ol-&gt;n_points) {
+        ol-&gt;contours[ol-&gt;n_contours] = ol-&gt;n_points - 1;
+        ol-&gt;n_contours++;
+    }
 }
 
 /*
  * \brief Prepare drawing for parsing.  This just sets a few parameters.
  */
-static void drawing_prepare(ass_drawing_t *drawing)
+static void drawing_prepare(ASS_Drawing *drawing)
 {
     // Scaling parameters
     drawing-&gt;point_scale_x = drawing-&gt;scale_x *
@@ -106,7 +109,7 @@
  * \brief Finish a drawing.  This only sets the horizontal advance according
  * to the glyph's bbox at the moment.
  */
-static void drawing_finish(ass_drawing_t *drawing, int raw_mode)
+static void drawing_finish(ASS_Drawing *drawing, int raw_mode)
 {
     int i, offset;
     FT_BBox bbox;
@@ -150,7 +153,7 @@
 /*
  * \brief Check whether a number of items on the list is available
  */
-static int token_check_values(ass_drawing_token_t *token, int i, int type)
+static int token_check_values(ASS_DrawingToken *token, int i, int type)
 {
     int j;
     for (j = 0; j &lt; i; j++) {
@@ -162,16 +165,16 @@
 }
 
 /*
- * \brief Tokenize a drawing string into a list of ass_drawing_token_t
+ * \brief Tokenize a drawing string into a list of ASS_DrawingToken
  * This also expands points for closing b-splines
  */
-static ass_drawing_token_t *drawing_tokenize(char *str)
+static ASS_DrawingToken *drawing_tokenize(char *str)
 {
     char *p = str;
     int i, val, type = -1, is_set = 0;
     FT_Vector point = {0, 0};
 
-    ass_drawing_token_t *root = NULL, *tail = NULL, *spline_start = NULL;
+    ASS_DrawingToken *root = NULL, *tail = NULL, *spline_start = NULL;
 
     while (*p) {
         if (*p == 'c' &amp;&amp; spline_start) {
@@ -179,7 +182,7 @@
             // back to the end
             if (token_check_values(spline_start-&gt;next, 2, TOKEN_B_SPLINE)) {
                 for (i = 0; i &lt; 3; i++) {
-                    tail-&gt;next = calloc(1, sizeof(ass_drawing_token_t));
+                    tail-&gt;next = calloc(1, sizeof(ASS_DrawingToken));
                     tail-&gt;next-&gt;prev = tail;
                     tail = tail-&gt;next;
                     tail-&gt;type = TOKEN_B_SPLINE;
@@ -214,11 +217,11 @@
 
         if (type != -1 &amp;&amp; is_set == 2) {
             if (root) {
-                tail-&gt;next = calloc(1, sizeof(ass_drawing_token_t));
+                tail-&gt;next = calloc(1, sizeof(ASS_DrawingToken));
                 tail-&gt;next-&gt;prev = tail;
                 tail = tail-&gt;next;
             } else
-                root = tail = calloc(1, sizeof(ass_drawing_token_t));
+                root = tail = calloc(1, sizeof(ASS_DrawingToken));
             tail-&gt;type = type;
             tail-&gt;point = point;
             is_set = 0;
@@ -230,7 +233,7 @@
 
 #if 0
     // Check tokens
-    ass_drawing_token_t *t = root;
+    ASS_DrawingToken *t = root;
     while(t) {
         printf(&quot;token %d point (%d, %d)\n&quot;, t-&gt;type, t-&gt;point.x, t-&gt;point.y);
         t = t-&gt;next;
@@ -243,10 +246,10 @@
 /*
  * \brief Free a list of tokens
  */
-static void drawing_free_tokens(ass_drawing_token_t *token)
+static void drawing_free_tokens(ASS_DrawingToken *token)
 {
     while (token) {
-        ass_drawing_token_t *at = token;
+        ASS_DrawingToken *at = token;
         token = token-&gt;next;
         free(at);
     }
@@ -256,7 +259,7 @@
  * \brief Translate and scale a point coordinate according to baseline
  * offset and scale.
  */
-static inline void translate_point(ass_drawing_t *drawing, FT_Vector *point)
+static inline void translate_point(ASS_Drawing *drawing, FT_Vector *point)
 {
     point-&gt;x = drawing-&gt;point_scale_x * point-&gt;x;
     point-&gt;y = drawing-&gt;point_scale_y * -point-&gt;y;
@@ -267,8 +270,8 @@
  * This curve evaluator is also used in VSFilter (RTS.cpp); it's a simple
  * implementation of the De Casteljau algorithm.
  */
-static void drawing_evaluate_curve(ass_drawing_t *drawing,
-                                   ass_drawing_token_t *token, char spline,
+static void drawing_evaluate_curve(ASS_Drawing *drawing,
+                                   ASS_DrawingToken *token, char spline,
                                    int started)
 {
     double cx3, cx2, cx1, cx0, cy3, cy2, cy1, cy0;
@@ -358,18 +361,20 @@
 /*
  * \brief Create and initialize a new drawing and return it
  */
-ass_drawing_t *ass_drawing_new(void *fontconfig_priv, ass_font_t *font,
-                               ass_hinting_t hint, FT_Library lib)
+ASS_Drawing *ass_drawing_new(void *fontconfig_priv, ASS_Font *font,
+                             ASS_Hinting hint, FT_Library lib)
 {
-    ass_drawing_t* drawing;
+    ASS_Drawing *drawing;
 
     drawing = calloc(1, sizeof(*drawing));
     drawing-&gt;text = calloc(1, DRAWING_INITIAL_SIZE);
     drawing-&gt;size = DRAWING_INITIAL_SIZE;
 
     drawing-&gt;ftlibrary = lib;
-    drawing-&gt;library = font-&gt;library;
-    drawing_make_glyph(drawing, fontconfig_priv, font, hint);
+    if (font) {
+        drawing-&gt;library = font-&gt;library;
+        drawing_make_glyph(drawing, fontconfig_priv, font, hint);
+    }
 
     drawing-&gt;scale_x = 1.;
     drawing-&gt;scale_y = 1.;
@@ -382,17 +387,20 @@
 /*
  * \brief Free a drawing
  */
-void ass_drawing_free(ass_drawing_t* drawing)
+void ass_drawing_free(ASS_Drawing* drawing)
 {
-    FT_Done_Glyph((FT_Glyph) drawing-&gt;glyph);
-    free(drawing-&gt;text);
+    if (drawing) {
+        if (drawing-&gt;glyph)
+            FT_Done_Glyph((FT_Glyph) drawing-&gt;glyph);
+        free(drawing-&gt;text);
+    }
     free(drawing);
 }
 
 /*
  * \brief Add one ASCII character to the drawing text buffer
  */
-void ass_drawing_add_char(ass_drawing_t* drawing, char symbol)
+void ass_drawing_add_char(ASS_Drawing* drawing, char symbol)
 {
     drawing-&gt;text[drawing-&gt;i++] = symbol;
     drawing-&gt;text[drawing-&gt;i] = 0;
@@ -407,7 +415,7 @@
  * \brief Create a hashcode for the drawing
  * XXX: To avoid collisions a better hash algorithm might be useful.
  */
-void ass_drawing_hash(ass_drawing_t* drawing)
+void ass_drawing_hash(ASS_Drawing* drawing)
 {
     drawing-&gt;hash = fnv_32a_str(drawing-&gt;text, FNV1_32A_INIT);
 }
@@ -415,12 +423,15 @@
 /*
  * \brief Convert token list to outline.  Calls the line and curve evaluators.
  */
-FT_OutlineGlyph *ass_drawing_parse(ass_drawing_t *drawing, int raw_mode)
+FT_OutlineGlyph *ass_drawing_parse(ASS_Drawing *drawing, int raw_mode)
 {
     int started = 0;
-    ass_drawing_token_t *token;
+    ASS_DrawingToken *token;
     FT_Vector pen = {0, 0};
 
+    if (!drawing-&gt;glyph)
+        return NULL;
+
     drawing-&gt;tokens = drawing_tokenize(drawing-&gt;text);
     drawing_prepare(drawing);
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -35,14 +35,14 @@
     TOKEN_B_SPLINE,
     TOKEN_EXTEND_SPLINE,
     TOKEN_CLOSE
-} ass_token_type_t;
+} ASS_TokenType;
 
 typedef struct ass_drawing_token {
-    ass_token_type_t type;
+    ASS_TokenType type;
     FT_Vector point;
     struct ass_drawing_token *next;
     struct ass_drawing_token *prev;
-} ass_drawing_token_t;
+} ASS_DrawingToken;
 
 typedef struct {
     char *text; // drawing string
@@ -58,20 +58,20 @@
 
     // private
     FT_Library ftlibrary;   // FT library instance, needed for font ops
-    ass_library_t *library;
+    ASS_Library *library;
     int size;           // current buffer size
-    ass_drawing_token_t *tokens;    // tokenized drawing
+    ASS_DrawingToken *tokens;    // tokenized drawing
     int max_points;     // current maximum size
     int max_contours;
     double point_scale_x;
     double point_scale_y;
-} ass_drawing_t;
+} ASS_Drawing;
 
-ass_drawing_t *ass_drawing_new(void *fontconfig_priv, ass_font_t *font,
-                               ass_hinting_t hint, FT_Library lib);
-void ass_drawing_free(ass_drawing_t* drawing);
-void ass_drawing_add_char(ass_drawing_t* drawing, char symbol);
-void ass_drawing_hash(ass_drawing_t* drawing);
-FT_OutlineGlyph *ass_drawing_parse(ass_drawing_t *drawing, int raw_mode);
+ASS_Drawing *ass_drawing_new(void *fontconfig_priv, ASS_Font *font,
+                             ASS_Hinting hint, FT_Library lib);
+void ass_drawing_free(ASS_Drawing* drawing);
+void ass_drawing_add_char(ASS_Drawing* drawing, char symbol);
+void ass_drawing_hash(ASS_Drawing* drawing);
+FT_OutlineGlyph *ass_drawing_parse(ASS_Drawing *drawing, int raw_mode);
 
 #endif /* LIBASS_DRAWING_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -26,6 +26,7 @@
 #include FT_SYNTHESIS_H
 #include FT_GLYPH_H
 #include FT_TRUETYPE_TABLES_H
+#include FT_OUTLINE_H
 
 #include &quot;ass.h&quot;
 #include &quot;ass_library.h&quot;
@@ -39,7 +40,7 @@
  * Select Microfost Unicode CharMap, if the font has one.
  * Otherwise, let FreeType decide.
  */
-static void charmap_magic(ass_library_t *library, FT_Face face)
+static void charmap_magic(ASS_Library *library, FT_Face face)
 {
     int i;
     for (i = 0; i &lt; face-&gt;num_charmaps; ++i) {
@@ -66,7 +67,7 @@
     }
 }
 
-static void update_transform(ass_font_t *font)
+static void update_transform(ASS_Font *font)
 {
     int i;
     FT_Matrix m;
@@ -80,7 +81,7 @@
 /**
  * \brief find a memory font by name
  */
-static int find_font(ass_library_t *library, char *name)
+static int find_font(ASS_Library *library, char *name)
 {
     int i;
     for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
@@ -111,10 +112,10 @@
 }
 
 /**
- * \brief Select a face with the given charcode and add it to ass_font_t
+ * \brief Select a face with the given charcode and add it to ASS_Font
  * \return index of the new face in font-&gt;faces, -1 if failed
  */
-static int add_face(void *fc_priv, ass_font_t *font, uint32_t ch)
+static int add_face(void *fc_priv, ASS_Font *font, uint32_t ch)
 {
     char *path;
     int index;
@@ -166,17 +167,17 @@
 }
 
 /**
- * \brief Create a new ass_font_t according to &quot;desc&quot; argument
+ * \brief Create a new ASS_Font according to &quot;desc&quot; argument
  */
-ass_font_t *ass_font_new(void *font_cache, ass_library_t *library,
-                         FT_Library ftlibrary, void *fc_priv,
-                         ass_font_desc_t *desc)
+ASS_Font *ass_font_new(void *font_cache, ASS_Library *library,
+                       FT_Library ftlibrary, void *fc_priv,
+                       ASS_FontDesc *desc)
 {
     int error;
-    ass_font_t *fontp;
-    ass_font_t font;
+    ASS_Font *fontp;
+    ASS_Font font;
 
-    fontp = ass_font_cache_find((hashmap_t *) font_cache, desc);
+    fontp = ass_font_cache_find((Hashmap *) font_cache, desc);
     if (fontp)
         return fontp;
 
@@ -197,13 +198,13 @@
         free(font.desc.family);
         return 0;
     } else
-        return ass_font_cache_add((hashmap_t *) font_cache, &amp;font);
+        return ass_font_cache_add((Hashmap *) font_cache, &amp;font);
 }
 
 /**
  * \brief Set font transformation matrix and shift vector
  **/
-void ass_font_set_transform(ass_font_t *font, double scale_x,
+void ass_font_set_transform(ASS_Font *font, double scale_x,
                             double scale_y, FT_Vector *v)
 {
     font-&gt;scale_x = scale_x;
@@ -217,7 +218,6 @@
 
 static void face_set_size(FT_Face face, double size)
 {
-#if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
     TT_HoriHeader *hori = FT_Get_Sfnt_Table(face, ft_sfnt_hhea);
     TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
     double mscale = 1.;
@@ -240,15 +240,12 @@
     m-&gt;ascender /= mscale;
     m-&gt;descender /= mscale;
     m-&gt;height /= mscale;
-#else
-    FT_Set_Char_Size(face, 0, double_to_d6(size), 0, 0);
-#endif
 }
 
 /**
  * \brief Set font size
  **/
-void ass_font_set_size(ass_font_t *font, double size)
+void ass_font_set_size(ASS_Font *font, double size)
 {
     int i;
     if (font-&gt;size != size) {
@@ -263,7 +260,7 @@
  * \param ch character code
  * The values are extracted from the font face that provides glyphs for the given character
  **/
-void ass_font_get_asc_desc(ass_font_t *font, uint32_t ch, int *asc,
+void ass_font_get_asc_desc(ASS_Font *font, uint32_t ch, int *asc,
                            int *desc)
 {
     int i;
@@ -293,14 +290,17 @@
  * being accurate.
  *
  */
-static int ass_strike_outline_glyph(FT_Face face, ass_font_t *font,
+static int ass_strike_outline_glyph(FT_Face face, ASS_Font *font,
                                     FT_Glyph glyph, int under, int through)
 {
     TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
     TT_Postscript *ps = FT_Get_Sfnt_Table(face, ft_sfnt_post);
     FT_Outline *ol = &amp;((FT_OutlineGlyph) glyph)-&gt;outline;
-    int bear, advance, y_scale, i;
+    int bear, advance, y_scale, i, dir;
 
+    if (!under &amp;&amp; !through)
+        return 0;
+
     // Grow outline
     i = (under ? 4 : 0) + (through ? 4 : 0);
     ol-&gt;points = realloc(ol-&gt;points, sizeof(FT_Vector) *
@@ -317,6 +317,9 @@
     advance = d16_to_d6(glyph-&gt;advance.x) + 32;
     y_scale = face-&gt;size-&gt;metrics.y_scale;
 
+    // Reverse drawing direction for non-truetype fonts
+    dir = FT_Outline_Get_Orientation(ol);
+
     // Add points to the outline
     if (under &amp;&amp; ps) {
         int pos, size;
@@ -325,7 +328,7 @@
                          y_scale * font-&gt;scale_y / 2);
 
         if (pos &gt; 0 || size &lt;= 0)
-            return 0;
+            return 1;
 
         FT_Vector points[4] = {
             {.x = bear,      .y = pos + size},
@@ -334,10 +337,18 @@
             {.x = bear,      .y = pos - size},
         };
 
-        for (i = 0; i &lt; 4; i++) {
-            ol-&gt;points[ol-&gt;n_points] = points[i];
-            ol-&gt;tags[ol-&gt;n_points++] = 1;
+        if (dir == FT_ORIENTATION_TRUETYPE) {
+            for (i = 0; i &lt; 4; i++) {
+                ol-&gt;points[ol-&gt;n_points] = points[i];
+                ol-&gt;tags[ol-&gt;n_points++] = 1;
+            }
+        } else {
+            for (i = 3; i &gt;= 0; i--) {
+                ol-&gt;points[ol-&gt;n_points] = points[i];
+                ol-&gt;tags[ol-&gt;n_points++] = 1;
+            }
         }
+
         ol-&gt;contours[ol-&gt;n_contours++] = ol-&gt;n_points - 1;
     }
 
@@ -347,7 +358,7 @@
         size = FT_MulFix(os2-&gt;yStrikeoutSize, y_scale * font-&gt;scale_y / 2);
 
         if (pos &lt; 0 || size &lt;= 0)
-            return 0;
+            return 1;
 
         FT_Vector points[4] = {
             {.x = bear,      .y = pos + size},
@@ -356,23 +367,46 @@
             {.x = bear,      .y = pos - size},
         };
 
-        for (i = 0; i &lt; 4; i++) {
-            ol-&gt;points[ol-&gt;n_points] = points[i];
-            ol-&gt;tags[ol-&gt;n_points++] = 1;
+        if (dir == FT_ORIENTATION_TRUETYPE) {
+            for (i = 0; i &lt; 4; i++) {
+                ol-&gt;points[ol-&gt;n_points] = points[i];
+                ol-&gt;tags[ol-&gt;n_points++] = 1;
+            }
+        } else {
+            for (i = 3; i &gt;= 0; i--) {
+                ol-&gt;points[ol-&gt;n_points] = points[i];
+                ol-&gt;tags[ol-&gt;n_points++] = 1;
+            }
         }
 
         ol-&gt;contours[ol-&gt;n_contours++] = ol-&gt;n_points - 1;
     }
 
-    return 1;
+    return 0;
 }
 
 /**
+ * Slightly embold a glyph without touching its metrics
+ */
+static void ass_glyph_embolden(FT_GlyphSlot slot)
+{
+    int str;
+
+    if (slot-&gt;format != FT_GLYPH_FORMAT_OUTLINE)
+        return;
+
+    str = FT_MulFix(slot-&gt;face-&gt;units_per_EM,
+                    slot-&gt;face-&gt;size-&gt;metrics.y_scale) / 64;
+
+    FT_Outline_Embolden(&amp;slot-&gt;outline, str);
+}
+
+/**
  * \brief Get a glyph
  * \param ch character code
  **/
-FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ass_font_t *font,
-                            uint32_t ch, ass_hinting_t hinting, int deco)
+FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ASS_Font *font,
+                            uint32_t ch, ASS_Hinting hinting, int deco)
 {
     int error;
     int index = 0;
@@ -383,6 +417,9 @@
 
     if (ch &lt; 0x20)
         return 0;
+    // Handle NBSP like a regular space when rendering the glyph
+    if (ch == 0xa0)
+        ch = ' ';
     if (font-&gt;n_faces == 0)
         return 0;
 
@@ -435,15 +472,15 @@
                 index);
         return 0;
     }
-#if (FREETYPE_MAJOR &gt; 2) || \
-    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt;= 2)) || \
-    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR == 1) &amp;&amp; (FREETYPE_PATCH &gt;= 10))
-// FreeType &gt;= 2.1.10 required
     if (!(face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC) &amp;&amp;
         (font-&gt;desc.italic &gt; 55)) {
         FT_GlyphSlot_Oblique(face-&gt;glyph);
     }
-#endif
+
+    if (!(face-&gt;style_flags &amp; FT_STYLE_FLAG_BOLD) &amp;&amp;
+        (font-&gt;desc.bold &gt; 80)) {
+        ass_glyph_embolden(face-&gt;glyph);
+    }
     error = FT_Get_Glyph(face-&gt;glyph, &amp;glyph);
     if (error) {
         ass_msg(font-&gt;library, MSGL_WARN, &quot;Error loading glyph, index %d&quot;,
@@ -460,7 +497,7 @@
 /**
  * \brief Get kerning for the pair of glyphs.
  **/
-FT_Vector ass_font_get_kerning(ass_font_t *font, uint32_t c1, uint32_t c2)
+FT_Vector ass_font_get_kerning(ASS_Font *font, uint32_t c1, uint32_t c2)
 {
     FT_Vector v = { 0, 0 };
     int i;
@@ -481,9 +518,9 @@
 }
 
 /**
- * \brief Deallocate ass_font_t
+ * \brief Deallocate ASS_Font
  **/
-void ass_font_free(ass_font_t *font)
+void ass_font_free(ASS_Font *font)
 {
     int i;
     for (i = 0; i &lt; font-&gt;n_faces; ++i)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -36,31 +36,31 @@
     unsigned bold;
     unsigned italic;
     int treat_family_as_pattern;
-} ass_font_desc_t;
+} ASS_FontDesc;
 
 typedef struct {
-    ass_font_desc_t desc;
-    ass_library_t *library;
+    ASS_FontDesc desc;
+    ASS_Library *library;
     FT_Library ftlibrary;
     FT_Face faces[ASS_FONT_MAX_FACES];
     int n_faces;
     double scale_x, scale_y;    // current transform
     FT_Vector v;                // current shift
     double size;
-} ass_font_t;
+} ASS_Font;
 
 // FIXME: passing the hashmap via a void pointer is very ugly.
-ass_font_t *ass_font_new(void *font_cache, ass_library_t *library,
-                         FT_Library ftlibrary, void *fc_priv,
-                         ass_font_desc_t *desc);
-void ass_font_set_transform(ass_font_t *font, double scale_x,
+ASS_Font *ass_font_new(void *font_cache, ASS_Library *library,
+                       FT_Library ftlibrary, void *fc_priv,
+                       ASS_FontDesc *desc);
+void ass_font_set_transform(ASS_Font *font, double scale_x,
                             double scale_y, FT_Vector *v);
-void ass_font_set_size(ass_font_t *font, double size);
-void ass_font_get_asc_desc(ass_font_t *font, uint32_t ch, int *asc,
+void ass_font_set_size(ASS_Font *font, double size);
+void ass_font_get_asc_desc(ASS_Font *font, uint32_t ch, int *asc,
                            int *desc);
-FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ass_font_t *font,
-                            uint32_t ch, ass_hinting_t hinting, int flags);
-FT_Vector ass_font_get_kerning(ass_font_t *font, uint32_t c1, uint32_t c2);
-void ass_font_free(ass_font_t *font);
+FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ASS_Font *font,
+                            uint32_t ch, ASS_Hinting hinting, int flags);
+FT_Vector ass_font_get_kerning(ASS_Font *font, uint32_t c1, uint32_t c2);
+void ass_font_free(ASS_Font *font);
 
 #endif                          /* LIBASS_FONT_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -51,15 +51,6 @@
 
 #ifdef CONFIG_FONTCONFIG
 
-// 4yo fontconfig does not have these.
-// They are only needed for debug output, anyway.
-#ifndef FC_FULLNAME
-#define FC_FULLNAME &quot;fullname&quot;
-#endif
-#ifndef FC_EMBOLDEN
-#define FC_EMBOLDEN &quot;embolden&quot;
-#endif
-
 /**
  * \brief Low-level font selection.
  * \param priv private data
@@ -71,7 +62,7 @@
  * \param code: the character that should be present in the font, can be 0
  * \return font file path
 */
-static char *_select_font(ass_library_t *library, fc_instance_t *priv,
+static char *_select_font(ASS_Library *library, FCInstance *priv,
                           const char *family, int treat_family_as_pattern,
                           unsigned bold, unsigned italic, int *index,
                           uint32_t code)
@@ -159,7 +150,6 @@
     if (curf &gt;= fset-&gt;nfont)
         goto error;
 
-#if (FC_VERSION &gt;= 20297)
     if (!treat_family_as_pattern) {
         // Remove all extra family names from original pattern.
         // After this, FcFontRenderPrepare will select the most relevant family
@@ -167,7 +157,6 @@
         for (; family_cnt &gt; 1; --family_cnt)
             FcPatternRemove(pat, FC_FAMILY, family_cnt - 1);
     }
-#endif
 
     rpat = FcFontRenderPrepare(priv-&gt;config, pat, fset-&gt;fonts[curf]);
     if (!rpat)
@@ -242,7 +231,7 @@
  * \param code: the character that should be present in the font, can be 0
  * \return font file path
 */
-char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+char *fontconfig_select(ASS_Library *library, FCInstance *priv,
                         const char *family, int treat_family_as_pattern,
                         unsigned bold, unsigned italic, int *index,
                         uint32_t code)
@@ -250,7 +239,8 @@
     char *res = 0;
     if (!priv-&gt;config) {
         *index = priv-&gt;index_default;
-        return priv-&gt;path_default;
+        res = priv-&gt;path_default ? strdup(priv-&gt;path_default) : 0;
+        return res;
     }
     if (family &amp;&amp; *family)
         res =
@@ -266,7 +256,7 @@
                     family, bold, italic, res, *index);
     }
     if (!res &amp;&amp; priv-&gt;path_default) {
-        res = priv-&gt;path_default;
+        res = strdup(priv-&gt;path_default);
         *index = priv-&gt;index_default;
         ass_msg(library, MSGL_WARN, &quot;fontconfig_select: Using default font: &quot;
                 &quot;(%s, %d, %d) -&gt; %s, %d&quot;, family, bold, italic,
@@ -287,41 +277,6 @@
     return res;
 }
 
-#if (FC_VERSION &lt; 20402)
-static char *validate_fname(char *name)
-{
-    char *fname;
-    char *p;
-    char *q;
-    unsigned code;
-    int sz = strlen(name);
-
-    q = fname = malloc(sz + 1);
-    p = name;
-    while (*p) {
-        code = ass_utf8_get_char(&amp;p);
-        if (code == 0)
-            break;
-        if ((code &gt; 0x7F) ||
-            (code == '\\') ||
-            (code == '/') ||
-            (code == ':') ||
-            (code == '*') ||
-            (code == '?') ||
-            (code == '&lt;') ||
-            (code == '&gt;') || (code == '|') || (code == 0)) {
-            *q++ = '_';
-        } else {
-            *q++ = code;
-        }
-        if (p - name &gt; sz)
-            break;
-    }
-    *q = 0;
-    return fname;
-}
-#endif
-
 /**
  * \brief Process memory font.
  * \param priv private data
@@ -331,7 +286,7 @@
  * With FontConfig &gt;= 2.4.2, builds a font pattern in memory via FT_New_Memory_Face/FcFreeTypeQueryFace.
  * With older FontConfig versions, save the font to ~/.mplayer/fonts.
 */
-static void process_fontdata(fc_instance_t *priv, ass_library_t *library,
+static void process_fontdata(FCInstance *priv, ASS_Library *library,
                              FT_Library ftlibrary, int idx)
 {
     int rc;
@@ -339,44 +294,6 @@
     const char *data = library-&gt;fontdata[idx].data;
     int data_size = library-&gt;fontdata[idx].size;
 
-#if (FC_VERSION &lt; 20402)
-    struct stat st;
-    char *fname;
-    const char *fonts_dir = library-&gt;fonts_dir;
-    char buf[1000];
-    FILE *fp = NULL;
-
-    if (!fonts_dir)
-        return;
-    rc = stat(fonts_dir, &amp;st);
-    if (rc) {
-        int res;
-#ifndef __MINGW32__
-        res = mkdir(fonts_dir, 0700);
-#else
-        res = mkdir(fonts_dir);
-#endif
-        if (res) {
-            ass_msg(library, MSGL_WARN, &quot;Failed to create directory '%s'&quot;,
-                    fonts_dir);
-        }
-    } else if (!S_ISDIR(st.st_mode)) {
-        ass_msg(library, MSGL_WARN, &quot;Not a directory: '%s'&quot;, fonts_dir);
-    }
-
-    fname = validate_fname((char *) name);
-
-    snprintf(buf, 1000, &quot;%s/%s&quot;, fonts_dir, fname);
-    free(fname);
-
-    fp = fopen(buf, &quot;wb&quot;);
-    if (!fp)
-        return;
-
-    fwrite(data, data_size, 1, fp);
-    fclose(fp);
-
-#else                           // (FC_VERSION &gt;= 20402)
     FT_Face face;
     FcPattern *pattern;
     FcFontSet *fset;
@@ -418,7 +335,6 @@
 
         FT_Done_Face(face);
     }
-#endif
 }
 
 /**
@@ -432,13 +348,13 @@
  * \param update whether the fontconfig cache should be built/updated
  * \return pointer to fontconfig private data
 */
-fc_instance_t *fontconfig_init(ass_library_t *library,
-                               FT_Library ftlibrary, const char *family,
-                               const char *path, int fc, const char *config,
-                               int update)
+FCInstance *fontconfig_init(ASS_Library *library,
+                            FT_Library ftlibrary, const char *family,
+                            const char *path, int fc, const char *config,
+                            int update)
 {
     int rc;
-    fc_instance_t *priv = calloc(1, sizeof(fc_instance_t));
+    FCInstance *priv = calloc(1, sizeof(FCInstance));
     const char *dir = library-&gt;fonts_dir;
     int i;
 
@@ -472,41 +388,8 @@
         process_fontdata(priv, library, ftlibrary, i);
 
     if (dir) {
-        if (FcDirCacheValid((const FcChar8 *) dir) == FcFalse) {
-            ass_msg(library, MSGL_INFO, &quot;Updating font cache&quot;);
-            if (FcGetVersion() &gt;= 20390 &amp;&amp; FcGetVersion() &lt; 20400)
-                ass_msg(library, MSGL_WARN, &quot;Beta versions of fontconfig&quot;
-                        &quot;are not supported. Update before reporting any bugs&quot;);
-            // FontConfig &gt;= 2.4.0 updates cache automatically in FcConfigAppFontAddDir()
-            if (FcGetVersion() &lt; 20390) {
-                FcFontSet *fcs;
-                FcStrSet *fss;
-                fcs = FcFontSetCreate();
-                fss = FcStrSetCreate();
-                rc = FcStrSetAdd(fss, (const FcChar8 *) dir);
-                if (!rc) {
-                    ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcStrSetAdd&quot;);
-                    goto ErrorFontCache;
-                }
+        ass_msg(library, MSGL_INFO, &quot;Updating font cache&quot;);
 
-                rc = FcDirScan(fcs, fss, NULL,
-                               FcConfigGetBlanks(priv-&gt;config),
-                               (const FcChar8 *) dir, FcFalse);
-                if (!rc) {
-                    ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcDirScan&quot;);
-                    goto ErrorFontCache;
-                }
-
-                rc = FcDirSave(fcs, fss, (const FcChar8 *) dir);
-                if (!rc) {
-                    ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcDirSave&quot;);
-                    goto ErrorFontCache;
-                }
-              ErrorFontCache:
-                ;
-            }
-        }
-
         rc = FcConfigAppFontAddDir(priv-&gt;config, (const FcChar8 *) dir);
         if (!rc) {
             ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcConfigAppFontAddDir&quot;);
@@ -521,40 +404,41 @@
     return priv;
 }
 
-int fontconfig_update(fc_instance_t *priv)
+int fontconfig_update(FCInstance *priv)
 {
         return FcConfigBuildFonts(priv-&gt;config);
 }
 
 #else                           /* CONFIG_FONTCONFIG */
 
-char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+char *fontconfig_select(ASS_Library *library, FCInstance *priv,
                         const char *family, int treat_family_as_pattern,
                         unsigned bold, unsigned italic, int *index,
                         uint32_t code)
 {
     *index = priv-&gt;index_default;
-    return priv-&gt;path_default;
+    char* res = priv-&gt;path_default ? strdup(priv-&gt;path_default) : 0;
+    return res;
 }
 
-fc_instance_t *fontconfig_init(ass_library_t *library,
-                               FT_Library ftlibrary, const char *family,
-                               const char *path, int fc, const char *config,
-                               int update)
+FCInstance *fontconfig_init(ASS_Library *library,
+                            FT_Library ftlibrary, const char *family,
+                            const char *path, int fc, const char *config,
+                            int update)
 {
-    fc_instance_t *priv;
+    FCInstance *priv;
 
     ass_msg(library, MSGL_WARN,
         &quot;Fontconfig disabled, only default font will be used.&quot;);
 
-    priv = calloc(1, sizeof(fc_instance_t));
+    priv = calloc(1, sizeof(FCInstance));
 
-    priv-&gt;path_default = strdup(path);
+    priv-&gt;path_default = path ? strdup(path) : 0;
     priv-&gt;index_default = 0;
     return priv;
 }
 
-int fontconfig_update(fc_instance_t *priv)
+int fontconfig_update(FCInstance *priv)
 {
     // Do nothing
     return 1;
@@ -562,10 +446,12 @@
 
 #endif
 
-void fontconfig_done(fc_instance_t *priv)
+void fontconfig_done(FCInstance *priv)
 {
+#ifdef CONFIG_FONTCONFIG
     if (priv &amp;&amp; priv-&gt;config)
         FcConfigDestroy(priv-&gt;config);
+#endif
     if (priv &amp;&amp; priv-&gt;path_default)
         free(priv-&gt;path_default);
     if (priv &amp;&amp; priv-&gt;family_default)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -31,17 +31,17 @@
 #include &lt;fontconfig/fontconfig.h&gt;
 #endif
 
-typedef struct fc_instance fc_instance_t;
+typedef struct fc_instance FCInstance;
 
-fc_instance_t *fontconfig_init(ass_library_t *library,
-                               FT_Library ftlibrary, const char *family,
-                               const char *path, int fc, const char *config,
-                               int update);
-char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+FCInstance *fontconfig_init(ASS_Library *library,
+                            FT_Library ftlibrary, const char *family,
+                            const char *path, int fc, const char *config,
+                            int update);
+char *fontconfig_select(ASS_Library *library, FCInstance *priv,
                         const char *family, int treat_family_as_pattern,
                         unsigned bold, unsigned italic, int *index,
                         uint32_t code);
-void fontconfig_done(fc_instance_t *priv);
-int fontconfig_update(fc_instance_t *priv);
+void fontconfig_done(FCInstance *priv);
+int fontconfig_update(FCInstance *priv);
 
 #endif                          /* LIBASS_FONTCONFIG_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -37,15 +37,15 @@
     fprintf(stderr, &quot;\n&quot;);
 }
 
-ass_library_t *ass_library_init(void)
+ASS_Library *ass_library_init(void)
 {
-    ass_library_t* lib = calloc(1, sizeof(ass_library_t));
+    ASS_Library* lib = calloc(1, sizeof(*lib));
     lib-&gt;msg_callback = ass_msg_handler;
 
     return lib;
 }
 
-void ass_library_done(ass_library_t *priv)
+void ass_library_done(ASS_Library *priv)
 {
     if (priv) {
         ass_set_fonts_dir(priv, NULL);
@@ -55,7 +55,7 @@
     }
 }
 
-void ass_set_fonts_dir(ass_library_t *priv, const char *fonts_dir)
+void ass_set_fonts_dir(ASS_Library *priv, const char *fonts_dir)
 {
     if (priv-&gt;fonts_dir)
         free(priv-&gt;fonts_dir);
@@ -63,12 +63,12 @@
     priv-&gt;fonts_dir = fonts_dir ? strdup(fonts_dir) : 0;
 }
 
-void ass_set_extract_fonts(ass_library_t *priv, int extract)
+void ass_set_extract_fonts(ASS_Library *priv, int extract)
 {
     priv-&gt;extract_fonts = !!extract;
 }
 
-void ass_set_style_overrides(ass_library_t *priv, char **list)
+void ass_set_style_overrides(ASS_Library *priv, char **list)
 {
     char **p;
     char **q;
@@ -98,7 +98,7 @@
         *array = realloc(*array, (nelem + 32) * elsize);
 }
 
-void ass_add_font(ass_library_t *priv, char *name, char *data, int size)
+void ass_add_font(ASS_Library *priv, char *name, char *data, int size)
 {
     int idx = priv-&gt;num_fontdata;
     if (!name || !data || !size)
@@ -116,7 +116,7 @@
     priv-&gt;num_fontdata++;
 }
 
-void ass_clear_fonts(ass_library_t *priv)
+void ass_clear_fonts(ASS_Library *priv)
 {
     int i;
     for (i = 0; i &lt; priv-&gt;num_fontdata; ++i) {
@@ -136,7 +136,7 @@
  * \param msg_cb the callback function
  * \param data additional data that will be passed to the callback
  */
-void ass_set_message_cb(ass_library_t *priv,
+void ass_set_message_cb(ASS_Library *priv,
                         void (*msg_cb)(int, const char *, va_list, void *),
                         void *data)
 {

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -27,14 +27,14 @@
     char *name;
     char *data;
     int size;
-} ass_fontdata_t;
+} ASS_Fontdata;
 
 struct ass_library {
     char *fonts_dir;
     int extract_fonts;
     char **style_overrides;
 
-    ass_fontdata_t *fontdata;
+    ASS_Fontdata *fontdata;
     int num_fontdata;
     void (*msg_callback)(int, const char *, va_list, void *);
     void *msg_callback_data;

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -0,0 +1,926 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at geekmind.org</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;ass_render.h&quot;
+#include &quot;ass_parse.h&quot;
+
+#define MAX_BE 127
+#define NBSP 0xa0   // unicode non-breaking space character
+
+#define skip_to(x) while ((*p != (x)) &amp;&amp; (*p != '}') &amp;&amp; (*p != 0)) { ++p;}
+#define skip(x) if (*p == (x)) ++p; else { return p; }
+#define skipopt(x) if (*p == (x)) { ++p; }
+
+/**
+ * \brief Check if starting part of (*p) matches sample.
+ * If true, shift p to the first symbol after the matching part.
+ */
+static inline int mystrcmp(char **p, const char *sample)
+{
+    int len = strlen(sample);
+    if (strncmp(*p, sample, len) == 0) {
+        (*p) += len;
+        return 1;
+    } else
+        return 0;
+}
+
+static void change_font_size(ASS_Renderer *render_priv, double sz)
+{
+    double size = sz * render_priv-&gt;font_scale;
+
+    if (size &lt; 1)
+        size = 1;
+    else if (size &gt; render_priv-&gt;height * 2)
+        size = render_priv-&gt;height * 2;
+
+    ass_font_set_size(render_priv-&gt;state.font, size);
+
+    render_priv-&gt;state.font_size = sz;
+}
+
+/**
+ * \brief Change current font, using setting from render_priv-&gt;state.
+ */
+void update_font(ASS_Renderer *render_priv)
+{
+    unsigned val;
+    ASS_FontDesc desc;
+    desc.family = strdup(render_priv-&gt;state.family);
+    desc.treat_family_as_pattern =
+        render_priv-&gt;state.treat_family_as_pattern;
+
+    val = render_priv-&gt;state.bold;
+    // 0 = normal, 1 = bold, &gt;1 = exact weight
+    if (val == 1 || val == -1)
+        val = 200;              // bold
+    else if (val &lt;= 0)
+        val = 80;               // normal
+    desc.bold = val;
+
+    val = render_priv-&gt;state.italic;
+    if (val == 1 || val == -1)
+        val = 110;              // italic
+    else if (val &lt;= 0)
+        val = 0;                // normal
+    desc.italic = val;
+
+    render_priv-&gt;state.font =
+        ass_font_new(render_priv-&gt;cache.font_cache, render_priv-&gt;library,
+                     render_priv-&gt;ftlibrary, render_priv-&gt;fontconfig_priv,
+                     &amp;desc);
+    free(desc.family);
+
+    if (render_priv-&gt;state.font)
+        change_font_size(render_priv, render_priv-&gt;state.font_size);
+}
+
+/**
+ * \brief Change border width
+ * negative value resets border to style value
+ */
+void change_border(ASS_Renderer *render_priv, double border_x,
+                   double border_y)
+{
+    int bord;
+    if (!render_priv-&gt;state.font)
+        return;
+
+    if (border_x &lt; 0 &amp;&amp; border_y &lt; 0) {
+        if (render_priv-&gt;state.style-&gt;BorderStyle == 1 ||
+            render_priv-&gt;state.style-&gt;BorderStyle == 3)
+            border_x = border_y = render_priv-&gt;state.style-&gt;Outline;
+        else
+            border_x = border_y = 1.;
+    }
+
+    render_priv-&gt;state.border_x = border_x;
+    render_priv-&gt;state.border_y = border_y;
+
+    bord = 64 * border_x * render_priv-&gt;border_scale;
+    if (bord &gt; 0 &amp;&amp; border_x == border_y) {
+        if (!render_priv-&gt;state.stroker) {
+            int error;
+            error =
+                FT_Stroker_New(render_priv-&gt;ftlibrary,
+                               &amp;render_priv-&gt;state.stroker);
+            if (error) {
+                ass_msg(render_priv-&gt;library, MSGL_V,
+                        &quot;failed to get stroker&quot;);
+                render_priv-&gt;state.stroker = 0;
+            }
+        }
+        if (render_priv-&gt;state.stroker)
+            FT_Stroker_Set(render_priv-&gt;state.stroker, bord,
+                           FT_STROKER_LINECAP_ROUND,
+                           FT_STROKER_LINEJOIN_ROUND, 0);
+    } else {
+        FT_Stroker_Done(render_priv-&gt;state.stroker);
+        render_priv-&gt;state.stroker = 0;
+    }
+}
+
+/**
+ * \brief Calculate a weighted average of two colors
+ * calculates c1*(1-a) + c2*a, but separately for each component except alpha
+ */
+static void change_color(uint32_t *var, uint32_t new, double pwr)
+{
+    (*var) = ((uint32_t) (_r(*var) * (1 - pwr) + _r(new) * pwr) &lt;&lt; 24) +
+        ((uint32_t) (_g(*var) * (1 - pwr) + _g(new) * pwr) &lt;&lt; 16) +
+        ((uint32_t) (_b(*var) * (1 - pwr) + _b(new) * pwr) &lt;&lt; 8) + _a(*var);
+}
+
+// like change_color, but for alpha component only
+inline void change_alpha(uint32_t *var, uint32_t new, double pwr)
+{
+    *var =
+        (_r(*var) &lt;&lt; 24) + (_g(*var) &lt;&lt; 16) + (_b(*var) &lt;&lt; 8) +
+        (uint32_t) (_a(*var) * (1 - pwr) + _a(new) * pwr);
+}
+
+/**
+ * \brief Multiply two alpha values
+ * \param a first value
+ * \param b second value
+ * \return result of multiplication
+ * Parameters and result are limited by 0xFF.
+ */
+inline uint32_t mult_alpha(uint32_t a, uint32_t b)
+{
+    return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;
+}
+
+/**
+ * \brief Calculate alpha value by piecewise linear function
+ * Used for \fad, \fade implementation.
+ */
+static unsigned
+interpolate_alpha(long long now, long long t1, long long t2, long long t3,
+                  long long t4, unsigned a1, unsigned a2, unsigned a3)
+{
+    unsigned a;
+    double cf;
+    if (now &lt;= t1) {
+        a = a1;
+    } else if (now &gt;= t4) {
+        a = a3;
+    } else if (now &lt; t2) {      // and &gt; t1
+        cf = ((double) (now - t1)) / (t2 - t1);
+        a = a1 * (1 - cf) + a2 * cf;
+    } else if (now &gt; t3) {
+        cf = ((double) (now - t3)) / (t4 - t3);
+        a = a2 * (1 - cf) + a3 * cf;
+    } else {                    // t2 &lt;= now &lt;= t3
+        a = a2;
+    }
+
+    return a;
+}
+
+/**
+ * Parse a vector clip into an outline, using the proper scaling
+ * parameters.  Translate it to correct for screen borders, if needed.
+ */
+static char *parse_vector_clip(ASS_Renderer *render_priv, char *p)
+{
+    int scale = 1;
+    int res = 0;
+    ASS_Drawing *drawing;
+
+    render_priv-&gt;state.clip_drawing = ass_drawing_new(
+        render_priv-&gt;fontconfig_priv,
+        render_priv-&gt;state.font,
+        render_priv-&gt;settings.hinting,
+        render_priv-&gt;ftlibrary);
+    drawing = render_priv-&gt;state.clip_drawing;
+    skipopt('(');
+    res = mystrtoi(&amp;p, &amp;scale);
+    skipopt(',')
+    if (!res)
+        scale = 1;
+    drawing-&gt;scale = scale;
+    drawing-&gt;scale_x = render_priv-&gt;font_scale_x * render_priv-&gt;font_scale;
+    drawing-&gt;scale_y = render_priv-&gt;font_scale;
+    while (*p != ')' &amp;&amp; *p != '}' &amp;&amp; p != 0)
+        ass_drawing_add_char(drawing, *p++);
+    skipopt(')');
+    if (ass_drawing_parse(drawing, 1)) {
+        // We need to translate the clip according to screen borders
+        if (render_priv-&gt;settings.left_margin != 0 ||
+            render_priv-&gt;settings.top_margin != 0) {
+            FT_Vector trans = {
+                .x = int_to_d6(render_priv-&gt;settings.left_margin),
+                .y = -int_to_d6(render_priv-&gt;settings.top_margin),
+            };
+            FT_Outline_Translate(&amp;drawing-&gt;glyph-&gt;outline, trans.x, trans.y);
+        }
+        ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                &quot;Parsed vector clip: scale %d, scales (%f, %f) string [%s]\n&quot;,
+                scale, drawing-&gt;scale_x, drawing-&gt;scale_y, drawing-&gt;text);
+    }
+
+    return p;
+}
+
+/**
+ * \brief Parse style override tag.
+ * \param p string to parse
+ * \param pwr multiplier for some tag effects (comes from \t tags)
+ */
+static char *parse_tag(ASS_Renderer *render_priv, char *p, double pwr)
+{
+    skip_to('\\');
+    skip('\\');
+    if ((*p == '}') || (*p == 0))
+        return p;
+
+    // New tags introduced in vsfilter 2.39
+    if (mystrcmp(&amp;p, &quot;xbord&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.border_x * (1 - pwr) + val * pwr;
+        else
+            val = -1.;
+        change_border(render_priv, val, render_priv-&gt;state.border_y);
+    } else if (mystrcmp(&amp;p, &quot;ybord&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.border_y * (1 - pwr) + val * pwr;
+        else
+            val = -1.;
+        change_border(render_priv, render_priv-&gt;state.border_x, val);
+    } else if (mystrcmp(&amp;p, &quot;xshad&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.shadow_x * (1 - pwr) + val * pwr;
+        else
+            val = 0.;
+        render_priv-&gt;state.shadow_x = val;
+    } else if (mystrcmp(&amp;p, &quot;yshad&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.shadow_y * (1 - pwr) + val * pwr;
+        else
+            val = 0.;
+        render_priv-&gt;state.shadow_y = val;
+    } else if (mystrcmp(&amp;p, &quot;fax&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.fax =
+                val * pwr + render_priv-&gt;state.fax * (1 - pwr);
+        else
+            render_priv-&gt;state.fax = 0.;
+    } else if (mystrcmp(&amp;p, &quot;fay&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.fay =
+                val * pwr + render_priv-&gt;state.fay * (1 - pwr);
+        else
+            render_priv-&gt;state.fay = 0.;
+    } else if (mystrcmp(&amp;p, &quot;iclip&quot;)) {
+        int x0, y0, x1, y1;
+        int res = 1;
+        char *start = p;
+        skipopt('(');
+        res &amp;= mystrtoi(&amp;p, &amp;x0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;x1);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y1);
+        skipopt(')');
+        if (res) {
+            render_priv-&gt;state.clip_x0 =
+                render_priv-&gt;state.clip_x0 * (1 - pwr) + x0 * pwr;
+            render_priv-&gt;state.clip_x1 =
+                render_priv-&gt;state.clip_x1 * (1 - pwr) + x1 * pwr;
+            render_priv-&gt;state.clip_y0 =
+                render_priv-&gt;state.clip_y0 * (1 - pwr) + y0 * pwr;
+            render_priv-&gt;state.clip_y1 =
+                render_priv-&gt;state.clip_y1 * (1 - pwr) + y1 * pwr;
+            render_priv-&gt;state.clip_mode = 1;
+        } else if (!render_priv-&gt;state.clip_drawing) {
+            p = parse_vector_clip(render_priv, start);
+            render_priv-&gt;state.clip_drawing_mode = 1;
+        } else
+            render_priv-&gt;state.clip_mode = 0;
+    } else if (mystrcmp(&amp;p, &quot;blur&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val = render_priv-&gt;state.blur * (1 - pwr) + val * pwr;
+            val = (val &lt; 0) ? 0 : val;
+            val = (val &gt; BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;
+            render_priv-&gt;state.blur = val;
+        } else
+            render_priv-&gt;state.blur = 0.0;
+        // ASS standard tags
+    } else if (mystrcmp(&amp;p, &quot;fsc&quot;)) {
+        char tp = *p++;
+        double val;
+        if (tp == 'x') {
+            if (mystrtod(&amp;p, &amp;val)) {
+                val /= 100;
+                render_priv-&gt;state.scale_x =
+                    render_priv-&gt;state.scale_x * (1 - pwr) + val * pwr;
+            } else
+                render_priv-&gt;state.scale_x =
+                    render_priv-&gt;state.style-&gt;ScaleX;
+        } else if (tp == 'y') {
+            if (mystrtod(&amp;p, &amp;val)) {
+                val /= 100;
+                render_priv-&gt;state.scale_y =
+                    render_priv-&gt;state.scale_y * (1 - pwr) + val * pwr;
+            } else
+                render_priv-&gt;state.scale_y =
+                    render_priv-&gt;state.style-&gt;ScaleY;
+        }
+    } else if (mystrcmp(&amp;p, &quot;fsp&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.hspacing =
+                render_priv-&gt;state.hspacing * (1 - pwr) + val * pwr;
+        else
+            render_priv-&gt;state.hspacing = render_priv-&gt;state.style-&gt;Spacing;
+    } else if (mystrcmp(&amp;p, &quot;fs&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.font_size * (1 - pwr) + val * pwr;
+        else
+            val = render_priv-&gt;state.style-&gt;FontSize;
+        if (render_priv-&gt;state.font)
+            change_font_size(render_priv, val);
+    } else if (mystrcmp(&amp;p, &quot;bord&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            if (render_priv-&gt;state.border_x == render_priv-&gt;state.border_y)
+                val = render_priv-&gt;state.border_x * (1 - pwr) + val * pwr;
+        } else
+            val = -1.;          // reset to default
+        change_border(render_priv, val, val);
+    } else if (mystrcmp(&amp;p, &quot;move&quot;)) {
+        double x1, x2, y1, y2;
+        long long t1, t2, delta_t, t;
+        double x, y;
+        double k;
+        skip('(');
+        mystrtod(&amp;p, &amp;x1);
+        skip(',');
+        mystrtod(&amp;p, &amp;y1);
+        skip(',');
+        mystrtod(&amp;p, &amp;x2);
+        skip(',');
+        mystrtod(&amp;p, &amp;y2);
+        if (*p == ',') {
+            skip(',');
+            mystrtoll(&amp;p, &amp;t1);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t2);
+            ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                   &quot;movement6: (%f, %f) -&gt; (%f, %f), (%&quot; PRId64 &quot; .. %&quot;
+                   PRId64 &quot;)\n&quot;, x1, y1, x2, y2, (int64_t) t1,
+                   (int64_t) t2);
+        } else {
+            t1 = 0;
+            t2 = render_priv-&gt;state.event-&gt;Duration;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                   &quot;movement: (%f, %f) -&gt; (%f, %f)&quot;, x1, y1, x2, y2);
+        }
+        skip(')');
+        delta_t = t2 - t1;
+        t = render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start;
+        if (t &lt; t1)
+            k = 0.;
+        else if (t &gt; t2)
+            k = 1.;
+        else
+            k = ((double) (t - t1)) / delta_t;
+        x = k * (x2 - x1) + x1;
+        y = k * (y2 - y1) + y1;
+        if (render_priv-&gt;state.evt_type != EVENT_POSITIONED) {
+            render_priv-&gt;state.pos_x = x;
+            render_priv-&gt;state.pos_y = y;
+            render_priv-&gt;state.detect_collisions = 0;
+            render_priv-&gt;state.evt_type = EVENT_POSITIONED;
+        }
+    } else if (mystrcmp(&amp;p, &quot;frx&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val *= M_PI / 180;
+            render_priv-&gt;state.frx =
+                val * pwr + render_priv-&gt;state.frx * (1 - pwr);
+        } else
+            render_priv-&gt;state.frx = 0.;
+    } else if (mystrcmp(&amp;p, &quot;fry&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val *= M_PI / 180;
+            render_priv-&gt;state.fry =
+                val * pwr + render_priv-&gt;state.fry * (1 - pwr);
+        } else
+            render_priv-&gt;state.fry = 0.;
+    } else if (mystrcmp(&amp;p, &quot;frz&quot;) || mystrcmp(&amp;p, &quot;fr&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val *= M_PI / 180;
+            render_priv-&gt;state.frz =
+                val * pwr + render_priv-&gt;state.frz * (1 - pwr);
+        } else
+            render_priv-&gt;state.frz =
+                M_PI * render_priv-&gt;state.style-&gt;Angle / 180.;
+    } else if (mystrcmp(&amp;p, &quot;fn&quot;)) {
+        char *start = p;
+        char *family;
+        skip_to('\\');
+        if (p &gt; start) {
+            family = malloc(p - start + 1);
+            strncpy(family, start, p - start);
+            family[p - start] = '\0';
+        } else
+            family = strdup(render_priv-&gt;state.style-&gt;FontName);
+        if (render_priv-&gt;state.family)
+            free(render_priv-&gt;state.family);
+        render_priv-&gt;state.family = family;
+        update_font(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;alpha&quot;)) {
+        uint32_t val;
+        int i;
+        int hex = render_priv-&gt;track-&gt;track_type == TRACK_TYPE_ASS;
+        if (strtocolor(render_priv-&gt;library, &amp;p, &amp;val, hex)) {
+            unsigned char a = val &gt;&gt; 24;
+            for (i = 0; i &lt; 4; ++i)
+                change_alpha(&amp;render_priv-&gt;state.c[i], a, pwr);
+        } else {
+            change_alpha(&amp;render_priv-&gt;state.c[0],
+                         render_priv-&gt;state.style-&gt;PrimaryColour, pwr);
+            change_alpha(&amp;render_priv-&gt;state.c[1],
+                         render_priv-&gt;state.style-&gt;SecondaryColour, pwr);
+            change_alpha(&amp;render_priv-&gt;state.c[2],
+                         render_priv-&gt;state.style-&gt;OutlineColour, pwr);
+            change_alpha(&amp;render_priv-&gt;state.c[3],
+                         render_priv-&gt;state.style-&gt;BackColour, pwr);
+        }
+        // FIXME: simplify
+    } else if (mystrcmp(&amp;p, &quot;an&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val) {
+            int v = (val - 1) / 3;      // 0, 1 or 2 for vertical alignment
+            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;an %d&quot;, val);
+            if (v != 0)
+                v = 3 - v;
+            val = ((val - 1) % 3) + 1;  // horizontal alignment
+            val += v * 4;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;align %d&quot;, val);
+            render_priv-&gt;state.alignment = val;
+        } else
+            render_priv-&gt;state.alignment =
+                render_priv-&gt;state.style-&gt;Alignment;
+    } else if (mystrcmp(&amp;p, &quot;a&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
+            // take care of a vsfilter quirk: handle illegal \a8 like \a5
+            render_priv-&gt;state.alignment = (val == 8) ? 5 : val;
+        else
+            render_priv-&gt;state.alignment =
+                render_priv-&gt;state.style-&gt;Alignment;
+    } else if (mystrcmp(&amp;p, &quot;pos&quot;)) {
+        double v1, v2;
+        skip('(');
+        mystrtod(&amp;p, &amp;v1);
+        skip(',');
+        mystrtod(&amp;p, &amp;v2);
+        skip(')');
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;pos(%f, %f)&quot;, v1, v2);
+        if (render_priv-&gt;state.evt_type == EVENT_POSITIONED) {
+            ass_msg(render_priv-&gt;library, MSGL_V, &quot;Subtitle has a new \\pos &quot;
+                   &quot;after \\move or \\pos, ignoring&quot;);
+        } else {
+            render_priv-&gt;state.evt_type = EVENT_POSITIONED;
+            render_priv-&gt;state.detect_collisions = 0;
+            render_priv-&gt;state.pos_x = v1;
+            render_priv-&gt;state.pos_y = v2;
+        }
+    } else if (mystrcmp(&amp;p, &quot;fad&quot;)) {
+        int a1, a2, a3;
+        long long t1, t2, t3, t4;
+        if (*p == 'e')
+            ++p;                // either \fad or \fade
+        skip('(');
+        mystrtoi(&amp;p, &amp;a1);
+        skip(',');
+        mystrtoi(&amp;p, &amp;a2);
+        if (*p == ')') {
+            // 2-argument version (\fad, according to specs)
+            // a1 and a2 are fade-in and fade-out durations
+            t1 = 0;
+            t4 = render_priv-&gt;state.event-&gt;Duration;
+            t2 = a1;
+            t3 = t4 - a2;
+            a1 = 0xFF;
+            a2 = 0;
+            a3 = 0xFF;
+        } else {
+            // 6-argument version (\fade)
+            // a1 and a2 (and a3) are opacity values
+            skip(',');
+            mystrtoi(&amp;p, &amp;a3);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t1);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t2);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t3);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t4);
+        }
+        skip(')');
+        render_priv-&gt;state.fade =
+            interpolate_alpha(render_priv-&gt;time -
+                              render_priv-&gt;state.event-&gt;Start, t1, t2,
+                              t3, t4, a1, a2, a3);
+    } else if (mystrcmp(&amp;p, &quot;org&quot;)) {
+        int v1, v2;
+        skip('(');
+        mystrtoi(&amp;p, &amp;v1);
+        skip(',');
+        mystrtoi(&amp;p, &amp;v2);
+        skip(')');
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;org(%d, %d)&quot;, v1, v2);
+        if (!render_priv-&gt;state.have_origin) {
+            render_priv-&gt;state.org_x = v1;
+            render_priv-&gt;state.org_y = v2;
+            render_priv-&gt;state.have_origin = 1;
+            render_priv-&gt;state.detect_collisions = 0;
+        }
+    } else if (mystrcmp(&amp;p, &quot;t&quot;)) {
+        double v[3];
+        int v1, v2;
+        double v3;
+        int cnt;
+        long long t1, t2, t, delta_t;
+        double k;
+        skip('(');
+        for (cnt = 0; cnt &lt; 3; ++cnt) {
+            if (*p == '\\')
+                break;
+            v[cnt] = strtod(p, &amp;p);
+            skip(',');
+        }
+        if (cnt == 3) {
+            v1 = v[0];
+            v2 = (v[1] &lt; v1) ? render_priv-&gt;state.event-&gt;Duration : v[1];
+            v3 = v[2];
+        } else if (cnt == 2) {
+            v1 = v[0];
+            v2 = (v[1] &lt; v1) ? render_priv-&gt;state.event-&gt;Duration : v[1];
+            v3 = 1.;
+        } else if (cnt == 1) {
+            v1 = 0;
+            v2 = render_priv-&gt;state.event-&gt;Duration;
+            v3 = v[0];
+        } else {                // cnt == 0
+            v1 = 0;
+            v2 = render_priv-&gt;state.event-&gt;Duration;
+            v3 = 1.;
+        }
+        render_priv-&gt;state.detect_collisions = 0;
+        t1 = v1;
+        t2 = v2;
+        delta_t = v2 - v1;
+        if (v3 &lt; 0.)
+            v3 = 0.;
+        t = render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start;        // FIXME: move to render_context
+        if (t &lt;= t1)
+            k = 0.;
+        else if (t &gt;= t2)
+            k = 1.;
+        else {
+            assert(delta_t != 0.);
+            k = pow(((double) (t - t1)) / delta_t, v3);
+        }
+        while (*p == '\\')
+            p = parse_tag(render_priv, p, k);   // maybe k*pwr ? no, specs forbid nested \t's
+        skip_to(')');           // in case there is some unknown tag or a comment
+        skip(')');
+    } else if (mystrcmp(&amp;p, &quot;clip&quot;)) {
+        char *start = p;
+        int x0, y0, x1, y1;
+        int res = 1;
+        skipopt('(');
+        res &amp;= mystrtoi(&amp;p, &amp;x0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;x1);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y1);
+        skipopt(')');
+        if (res) {
+            render_priv-&gt;state.clip_x0 =
+                render_priv-&gt;state.clip_x0 * (1 - pwr) + x0 * pwr;
+            render_priv-&gt;state.clip_x1 =
+                render_priv-&gt;state.clip_x1 * (1 - pwr) + x1 * pwr;
+            render_priv-&gt;state.clip_y0 =
+                render_priv-&gt;state.clip_y0 * (1 - pwr) + y0 * pwr;
+            render_priv-&gt;state.clip_y1 =
+                render_priv-&gt;state.clip_y1 * (1 - pwr) + y1 * pwr;
+        // Might be a vector clip
+        } else if (!render_priv-&gt;state.clip_drawing) {
+            p = parse_vector_clip(render_priv, start);
+            render_priv-&gt;state.clip_drawing_mode = 0;
+        } else {
+            render_priv-&gt;state.clip_x0 = 0;
+            render_priv-&gt;state.clip_y0 = 0;
+            render_priv-&gt;state.clip_x1 = render_priv-&gt;track-&gt;PlayResX;
+            render_priv-&gt;state.clip_y1 = render_priv-&gt;track-&gt;PlayResY;
+        }
+    } else if (mystrcmp(&amp;p, &quot;c&quot;)) {
+        uint32_t val;
+        int hex = render_priv-&gt;track-&gt;track_type == TRACK_TYPE_ASS;
+        if (!strtocolor(render_priv-&gt;library, &amp;p, &amp;val, hex))
+            val = render_priv-&gt;state.style-&gt;PrimaryColour;
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;color: %X&quot;, val);
+        change_color(&amp;render_priv-&gt;state.c[0], val, pwr);
+    } else if ((*p &gt;= '1') &amp;&amp; (*p &lt;= '4') &amp;&amp; (++p)
+               &amp;&amp; (mystrcmp(&amp;p, &quot;c&quot;) || mystrcmp(&amp;p, &quot;a&quot;))) {
+        char n = *(p - 2);
+        int cidx = n - '1';
+        char cmd = *(p - 1);
+        uint32_t val;
+        int hex = render_priv-&gt;track-&gt;track_type == TRACK_TYPE_ASS;
+        assert((n &gt;= '1') &amp;&amp; (n &lt;= '4'));
+        if (!strtocolor(render_priv-&gt;library, &amp;p, &amp;val, hex))
+            switch (n) {
+            case '1':
+                val = render_priv-&gt;state.style-&gt;PrimaryColour;
+                break;
+            case '2':
+                val = render_priv-&gt;state.style-&gt;SecondaryColour;
+                break;
+            case '3':
+                val = render_priv-&gt;state.style-&gt;OutlineColour;
+                break;
+            case '4':
+                val = render_priv-&gt;state.style-&gt;BackColour;
+                break;
+            default:
+                val = 0;
+                break;          // impossible due to assert; avoid compilation warning
+            }
+        switch (cmd) {
+        case 'c':
+            change_color(render_priv-&gt;state.c + cidx, val, pwr);
+            break;
+        case 'a':
+            change_alpha(render_priv-&gt;state.c + cidx, val &gt;&gt; 24, pwr);
+            break;
+        default:
+            ass_msg(render_priv-&gt;library, MSGL_WARN, &quot;Bad command: %c%c&quot;,
+                    n, cmd);
+            break;
+        }
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;single c/a at %f: %c%c = %X&quot;,
+               pwr, n, cmd, render_priv-&gt;state.c[cidx]);
+    } else if (mystrcmp(&amp;p, &quot;r&quot;)) {
+        reset_render_context(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;be&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val)) {
+            // Clamp to a safe upper limit, since high values need excessive CPU
+            val = (val &lt; 0) ? 0 : val;
+            val = (val &gt; MAX_BE) ? MAX_BE : val;
+            render_priv-&gt;state.be = val;
+        } else
+            render_priv-&gt;state.be = 0;
+    } else if (mystrcmp(&amp;p, &quot;b&quot;)) {
+        int b;
+        if (mystrtoi(&amp;p, &amp;b)) {
+            if (pwr &gt;= .5)
+                render_priv-&gt;state.bold = b;
+        } else
+            render_priv-&gt;state.bold = render_priv-&gt;state.style-&gt;Bold;
+        update_font(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;i&quot;)) {
+        int i;
+        if (mystrtoi(&amp;p, &amp;i)) {
+            if (pwr &gt;= .5)
+                render_priv-&gt;state.italic = i;
+        } else
+            render_priv-&gt;state.italic = render_priv-&gt;state.style-&gt;Italic;
+        update_font(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;kf&quot;) || mystrcmp(&amp;p, &quot;K&quot;)) {
+        int val = 0;
+        mystrtoi(&amp;p, &amp;val);
+        render_priv-&gt;state.effect_type = EF_KARAOKE_KF;
+        if (render_priv-&gt;state.effect_timing)
+            render_priv-&gt;state.effect_skip_timing +=
+                render_priv-&gt;state.effect_timing;
+        render_priv-&gt;state.effect_timing = val * 10;
+    } else if (mystrcmp(&amp;p, &quot;ko&quot;)) {
+        int val = 0;
+        mystrtoi(&amp;p, &amp;val);
+        render_priv-&gt;state.effect_type = EF_KARAOKE_KO;
+        if (render_priv-&gt;state.effect_timing)
+            render_priv-&gt;state.effect_skip_timing +=
+                render_priv-&gt;state.effect_timing;
+        render_priv-&gt;state.effect_timing = val * 10;
+    } else if (mystrcmp(&amp;p, &quot;k&quot;)) {
+        int val = 0;
+        mystrtoi(&amp;p, &amp;val);
+        render_priv-&gt;state.effect_type = EF_KARAOKE;
+        if (render_priv-&gt;state.effect_timing)
+            render_priv-&gt;state.effect_skip_timing +=
+                render_priv-&gt;state.effect_timing;
+        render_priv-&gt;state.effect_timing = val * 10;
+    } else if (mystrcmp(&amp;p, &quot;shad&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            if (render_priv-&gt;state.shadow_x == render_priv-&gt;state.shadow_y)
+                val = render_priv-&gt;state.shadow_x * (1 - pwr) + val * pwr;
+        } else
+            val = 0.;
+        render_priv-&gt;state.shadow_x = render_priv-&gt;state.shadow_y = val;
+    } else if (mystrcmp(&amp;p, &quot;s&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
+            render_priv-&gt;state.flags |= DECO_STRIKETHROUGH;
+        else
+            render_priv-&gt;state.flags &amp;= ~DECO_STRIKETHROUGH;
+    } else if (mystrcmp(&amp;p, &quot;u&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
+            render_priv-&gt;state.flags |= DECO_UNDERLINE;
+        else
+            render_priv-&gt;state.flags &amp;= ~DECO_UNDERLINE;
+    } else if (mystrcmp(&amp;p, &quot;pbo&quot;)) {
+        double val = 0;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.drawing-&gt;pbo = val;
+    } else if (mystrcmp(&amp;p, &quot;p&quot;)) {
+        int val;
+        if (!mystrtoi(&amp;p, &amp;val))
+            val = 0;
+        if (val)
+            render_priv-&gt;state.drawing-&gt;scale = val;
+        render_priv-&gt;state.drawing_mode = !!val;
+    } else if (mystrcmp(&amp;p, &quot;q&quot;)) {
+        int val;
+        if (!mystrtoi(&amp;p, &amp;val))
+            val = render_priv-&gt;track-&gt;WrapStyle;
+        render_priv-&gt;state.wrap_style = val;
+    }
+
+    return p;
+}
+
+void apply_transition_effects(ASS_Renderer *render_priv, ASS_Event *event)
+{
+    int v[4];
+    int cnt;
+    char *p = event-&gt;Effect;
+
+    if (!p || !*p)
+        return;
+
+    cnt = 0;
+    while (cnt &lt; 4 &amp;&amp; (p = strchr(p, ';'))) {
+        v[cnt++] = atoi(++p);
+    }
+
+    if (strncmp(event-&gt;Effect, &quot;Banner;&quot;, 7) == 0) {
+        int delay;
+        if (cnt &lt; 1) {
+            ass_msg(render_priv-&gt;library, MSGL_V,
+                    &quot;Error parsing effect: '%s'&quot;, event-&gt;Effect);
+            return;
+        }
+        if (cnt &gt;= 2 &amp;&amp; v[1] == 0)      // right-to-left
+            render_priv-&gt;state.scroll_direction = SCROLL_RL;
+        else                    // left-to-right
+            render_priv-&gt;state.scroll_direction = SCROLL_LR;
+
+        delay = v[0];
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv-&gt;state.scroll_shift =
+            (render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start) / delay;
+        render_priv-&gt;state.evt_type = EVENT_HSCROLL;
+        return;
+    }
+
+    if (strncmp(event-&gt;Effect, &quot;Scroll up;&quot;, 10) == 0) {
+        render_priv-&gt;state.scroll_direction = SCROLL_BT;
+    } else if (strncmp(event-&gt;Effect, &quot;Scroll down;&quot;, 12) == 0) {
+        render_priv-&gt;state.scroll_direction = SCROLL_TB;
+    } else {
+        ass_msg(render_priv-&gt;library, MSGL_V,
+                &quot;Unknown transition effect: '%s'&quot;, event-&gt;Effect);
+        return;
+    }
+    // parse scroll up/down parameters
+    {
+        int delay;
+        int y0, y1;
+        if (cnt &lt; 3) {
+            ass_msg(render_priv-&gt;library, MSGL_V,
+                    &quot;Error parsing effect: '%s'&quot;, event-&gt;Effect);
+            return;
+        }
+        delay = v[2];
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv-&gt;state.scroll_shift =
+            (render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start) / delay;
+        if (v[0] &lt; v[1]) {
+            y0 = v[0];
+            y1 = v[1];
+        } else {
+            y0 = v[1];
+            y1 = v[0];
+        }
+        if (y1 == 0)
+            y1 = render_priv-&gt;track-&gt;PlayResY;  // y0=y1=0 means fullscreen scrolling
+        render_priv-&gt;state.clip_y0 = y0;
+        render_priv-&gt;state.clip_y1 = y1;
+        render_priv-&gt;state.evt_type = EVENT_VSCROLL;
+        render_priv-&gt;state.detect_collisions = 0;
+    }
+
+}
+
+/**
+ * \brief Get next ucs4 char from string, parsing and executing style overrides
+ * \param str string pointer
+ * \return ucs4 code of the next char
+ * On return str points to the unparsed part of the string
+ */
+unsigned get_next_char(ASS_Renderer *render_priv, char **str)
+{
+    char *p = *str;
+    unsigned chr;
+    if (*p == '{') {            // '\0' goes here
+        p++;
+        while (1) {
+            p = parse_tag(render_priv, p, 1.);
+            if (*p == '}') {    // end of tag
+                p++;
+                if (*p == '{') {
+                    p++;
+                    continue;
+                } else
+                    break;
+            } else if (*p != '\\')
+                ass_msg(render_priv-&gt;library, MSGL_V,
+                        &quot;Unable to parse: '%s'&quot;, p);
+            if (*p == 0)
+                break;
+        }
+    }
+    if (*p == '\t') {
+        ++p;
+        *str = p;
+        return ' ';
+    }
+    if (*p == '\\') {
+        if ((p[1] == 'N') || ((p[1] == 'n') &amp;&amp;
+                              (render_priv-&gt;state.wrap_style == 2))) {
+            p += 2;
+            *str = p;
+            return '\n';
+        } else if (p[1] == 'n') {
+            p += 2;
+            *str = p;
+            return ' ';
+        } else if (p[1] == 'h') {
+            p += 2;
+            *str = p;
+            return NBSP;
+        }
+    }
+    chr = ass_utf8_get_char((char **) &amp;p);
+    *str = p;
+    return chr;
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at geekmind.org</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef LIBASS_PARSE_H
+#define LIBASS_PARSE_H
+
+#define BLUR_MAX_RADIUS 100.0
+
+#define _r(c)   ((c) &gt;&gt; 24)
+#define _g(c)   (((c) &gt;&gt; 16) &amp; 0xFF)
+#define _b(c)   (((c) &gt;&gt; 8) &amp; 0xFF)
+#define _a(c)   ((c) &amp; 0xFF)
+
+void update_font(ASS_Renderer *render_priv);
+void change_border(ASS_Renderer *render_priv, double border_x,
+                   double border_y);
+void apply_transition_effects(ASS_Renderer *render_priv, ASS_Event *event);
+unsigned get_next_char(ASS_Renderer *render_priv, char **str);
+extern void change_alpha(uint32_t *var, uint32_t new, double pwr);
+extern uint32_t mult_alpha(uint32_t a, uint32_t b);
+
+
+#endif /* LIBASS_PARSE_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -37,221 +37,19 @@
 #include &quot;ass_fontconfig.h&quot;
 #include &quot;ass_library.h&quot;
 #include &quot;ass_drawing.h&quot;
+#include &quot;ass_render.h&quot;
+#include &quot;ass_parse.h&quot;
 
 #define MAX_GLYPHS_INITIAL 1024
 #define MAX_LINES_INITIAL 64
-#define BLUR_MAX_RADIUS 100.0
-#define MAX_BE 127
 #define SUBPIXEL_MASK 63
 #define SUBPIXEL_ACCURACY 7    // d6 mask for subpixel accuracy adjustment
 #define GLYPH_CACHE_MAX 1000
-#define BITMAP_CACHE_MAX_SIZE 50 * 1048576;
+#define BITMAP_CACHE_MAX_SIZE 50 * 1048576
 
-typedef struct {
-    double xMin;
-    double xMax;
-    double yMin;
-    double yMax;
-} double_bbox_t;
-
-typedef struct {
-    double x;
-    double y;
-} double_vector_t;
-
-typedef struct free_list {
-    void *object;
-    struct free_list *next;
-} free_list_t;
-
-typedef struct {
-    int frame_width;
-    int frame_height;
-    double font_size_coeff;     // font size multiplier
-    double line_spacing;        // additional line spacing (in frame pixels)
-    int top_margin;             // height of top margin. Everything except toptitles is shifted down by top_margin.
-    int bottom_margin;          // height of bottom margin. (frame_height - top_margin - bottom_margin) is original video height.
-    int left_margin;
-    int right_margin;
-    int use_margins;            // 0 - place all subtitles inside original frame
-    // 1 - use margins for placing toptitles and subtitles
-    double aspect;              // frame aspect ratio, d_width / d_height.
-    double pixel_ratio;         // pixel ratio of the source image
-    ass_hinting_t hinting;
-
-    char *default_font;
-    char *default_family;
-} ass_settings_t;
-
-// a rendered event
-typedef struct {
-    ass_image_t *imgs;
-    int top, height;
-    int detect_collisions;
-    int shift_direction;
-    ass_event_t *event;
-} event_images_t;
-
-typedef enum { EF_NONE = 0, EF_KARAOKE, EF_KARAOKE_KF, EF_KARAOKE_KO
-} effect_t;
-
-// describes a glyph
-// glyph_info_t and text_info_t are used for text centering and word-wrapping operations
-typedef struct {
-    unsigned symbol;
-    FT_Glyph glyph;
-    FT_Glyph outline_glyph;
-    bitmap_t *bm;               // glyph bitmap
-    bitmap_t *bm_o;             // outline bitmap
-    bitmap_t *bm_s;             // shadow bitmap
-    FT_BBox bbox;
-    FT_Vector pos;
-    char linebreak;             // the first (leading) glyph of some line ?
-    uint32_t c[4];              // colors
-    FT_Vector advance;          // 26.6
-    effect_t effect_type;
-    int effect_timing;          // time duration of current karaoke word
-    // after process_karaoke_effects: distance in pixels from the glyph origin.
-    // part of the glyph to the left of it is displayed in a different color.
-    int effect_skip_timing;     // delay after the end of last karaoke word
-    int asc, desc;              // font max ascender and descender
-//      int height;
-    int be;                     // blur edges
-    double blur;                // gaussian blur
-    double shadow_x;
-    double shadow_y;
-    double frx, fry, frz;       // rotation
-    double fax, fay;            // text shearing
-
-    bitmap_hash_key_t hash_key;
-} glyph_info_t;
-
-typedef struct {
-    double asc, desc;
-} line_info_t;
-
-typedef struct {
-    glyph_info_t *glyphs;
-    int length;
-    line_info_t *lines;
-    int n_lines;
-    double height;
-    int max_glyphs;
-    int max_lines;
-} text_info_t;
-
-
-// Renderer state.
-// Values like current font face, color, screen position, clipping and so on are stored here.
-typedef struct {
-    ass_event_t *event;
-    ass_style_t *style;
-
-    ass_font_t *font;
-    char *font_path;
-    double font_size;
-    int flags;                  // decoration flags (underline/strike-through)
-
-    FT_Stroker stroker;
-    int alignment;              // alignment overrides go here; if zero, style value will be used
-    double frx, fry, frz;
-    double fax, fay;            // text shearing
-    enum { EVENT_NORMAL,        // &quot;normal&quot; top-, sub- or mid- title
-        EVENT_POSITIONED,       // happens after pos(,), margins are ignored
-        EVENT_HSCROLL,          // &quot;Banner&quot; transition effect, text_width is unlimited
-        EVENT_VSCROLL           // &quot;Scroll up&quot;, &quot;Scroll down&quot; transition effects
-    } evt_type;
-    double pos_x, pos_y;        // position
-    double org_x, org_y;        // origin
-    char have_origin;           // origin is explicitly defined; if 0, get_base_point() is used
-    double scale_x, scale_y;
-    double hspacing;            // distance between letters, in pixels
-    double border_x;              // outline width
-    double border_y;
-    uint32_t c[4];              // colors(Primary, Secondary, so on) in RGBA
-    int clip_x0, clip_y0, clip_x1, clip_y1;
-    char clip_mode;             // 1 = iclip
-    char detect_collisions;
-    uint32_t fade;              // alpha from \fad
-    char be;                    // blur edges
-    double blur;                // gaussian blur
-    double shadow_x;
-    double shadow_y;
-    int drawing_mode;           // not implemented; when != 0 text is discarded, except for style override tags
-    ass_drawing_t *drawing;     // current drawing
-    ass_drawing_t *clip_drawing;// clip vector
-    int clip_drawing_mode;      // 0 = regular clip, 1 = inverse clip
-
-    effect_t effect_type;
-    int effect_timing;
-    int effect_skip_timing;
-
-    enum { SCROLL_LR,           // left-to-right
-        SCROLL_RL,
-        SCROLL_TB,              // top-to-bottom
-        SCROLL_BT
-    } scroll_direction;         // for EVENT_HSCROLL, EVENT_VSCROLL
-    int scroll_shift;
-
-    // face properties
-    char *family;
-    unsigned bold;
-    unsigned italic;
-    int treat_family_as_pattern;
-
-} render_context_t;
-
-typedef struct {
-    hashmap_t *font_cache;
-    hashmap_t *glyph_cache;
-    hashmap_t *bitmap_cache;
-    hashmap_t *composite_cache;
-    size_t glyph_max;
-    size_t bitmap_max_size;
-} cache_store_t;
-
-struct ass_renderer {
-    ass_library_t *library;
-    FT_Library ftlibrary;
-    fc_instance_t *fontconfig_priv;
-    ass_settings_t settings;
-    int render_id;
-    ass_synth_priv_t *synth_priv;
-
-    ass_image_t *images_root;   // rendering result is stored here
-    ass_image_t *prev_images_root;
-
-    event_images_t *eimg;       // temporary buffer for sorting rendered events
-    int eimg_size;              // allocated buffer size
-
-    // frame-global data
-    int width, height;          // screen dimensions
-    int orig_height;            // frame height ( = screen height - margins )
-    int orig_width;             // frame width ( = screen width - margins )
-    int orig_height_nocrop;     // frame height ( = screen height - margins + cropheight)
-    int orig_width_nocrop;      // frame width ( = screen width - margins + cropwidth)
-    ass_track_t *track;
-    long long time;             // frame's timestamp, ms
-    double font_scale;
-    double font_scale_x;        // x scale applied to all glyphs to preserve text aspect ratio
-    double border_scale;
-
-    render_context_t state;
-    text_info_t text_info;
-    cache_store_t cache;
-
-    free_list_t *free_head;
-    free_list_t *free_tail;
-};
-
-struct render_priv {
-    int top, height;
-    int render_id;
-};
-
-static void ass_lazy_track_init(ass_renderer_t *render_priv)
+static void ass_lazy_track_init(ASS_Renderer *render_priv)
 {
-    ass_track_t *track = render_priv-&gt;track;
+    ASS_Track *track = render_priv-&gt;track;
 
     if (track-&gt;PlayResX &amp;&amp; track-&gt;PlayResY)
         return;
@@ -281,11 +79,11 @@
     }
 }
 
-ass_renderer_t *ass_renderer_init(ass_library_t *library)
+ASS_Renderer *ass_renderer_init(ASS_Library *library)
 {
     int error;
     FT_Library ft;
-    ass_renderer_t *priv = 0;
+    ASS_Renderer *priv = 0;
     int vmajor, vminor, vpatch;
 
     error = FT_Init_FreeType(&amp;ft);
@@ -300,7 +98,7 @@
     ass_msg(library, MSGL_V, &quot;FreeType headers version: %d.%d.%d&quot;,
            FREETYPE_MAJOR, FREETYPE_MINOR, FREETYPE_PATCH);
 
-    priv = calloc(1, sizeof(ass_renderer_t));
+    priv = calloc(1, sizeof(ASS_Renderer));
     if (!priv) {
         FT_Done_FreeType(ft);
         goto ass_init_exit;
@@ -322,8 +120,8 @@
     priv-&gt;text_info.max_glyphs = MAX_GLYPHS_INITIAL;
     priv-&gt;text_info.max_lines = MAX_LINES_INITIAL;
     priv-&gt;text_info.glyphs =
-        calloc(MAX_GLYPHS_INITIAL, sizeof(glyph_info_t));
-    priv-&gt;text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(line_info_t));
+        calloc(MAX_GLYPHS_INITIAL, sizeof(GlyphInfo));
+    priv-&gt;text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(LineInfo));
 
   ass_init_exit:
     if (priv)
@@ -334,7 +132,7 @@
     return priv;
 }
 
-void ass_set_cache_limits(ass_renderer_t *render_priv, int glyph_max,
+void ass_set_cache_limits(ASS_Renderer *render_priv, int glyph_max,
                           int bitmap_max)
 {
     render_priv-&gt;cache.glyph_max = glyph_max ? glyph_max : GLYPH_CACHE_MAX;
@@ -342,12 +140,12 @@
                                          BITMAP_CACHE_MAX_SIZE;
 }
 
-static void free_list_clear(ass_renderer_t *render_priv)
+static void free_list_clear(ASS_Renderer *render_priv)
 {
     if (render_priv-&gt;free_head) {
-        free_list_t *item = render_priv-&gt;free_head;
+        FreeList *item = render_priv-&gt;free_head;
         while(item) {
-            free_list_t *oi = item;
+            FreeList *oi = item;
             free(item-&gt;object);
             item = item-&gt;next;
             free(oi);
@@ -356,9 +154,9 @@
     }
 }
 
-static void ass_free_images(ass_image_t *img);
+static void ass_free_images(ASS_Image *img);
 
-void ass_renderer_done(ass_renderer_t *render_priv)
+void ass_renderer_done(ASS_Renderer *render_priv)
 {
     ass_font_cache_done(render_priv-&gt;cache.font_cache);
     ass_bitmap_cache_done(render_priv-&gt;cache.bitmap_cache);
@@ -391,14 +189,14 @@
 }
 
 /**
- * \brief Create a new ass_image_t
- * Parameters are the same as ass_image_t fields.
+ * \brief Create a new ASS_Image
+ * Parameters are the same as ASS_Image fields.
  */
-static ass_image_t *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,
-                                   int bitmap_h, int stride, int dst_x,
-                                   int dst_y, uint32_t color)
+static ASS_Image *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,
+                                 int bitmap_h, int stride, int dst_x,
+                                 int dst_y, uint32_t color)
 {
-    ass_image_t *img = calloc(1, sizeof(ass_image_t));
+    ASS_Image *img = calloc(1, sizeof(ASS_Image));
 
     img-&gt;w = bitmap_w;
     img-&gt;h = bitmap_h;
@@ -411,18 +209,11 @@
     return img;
 }
 
-static double x2scr_pos(ass_renderer_t *render_priv, double x);
-static double y2scr_pos(ass_renderer_t *render_priv, double y);
+static double x2scr_pos(ASS_Renderer *render_priv, double x);
+static double y2scr_pos(ASS_Renderer *render_priv, double y);
 
-typedef struct {
-    int x0;
-    int y0;
-    int x1;
-    int y1;
-} rect_t;
-
 /*
- * \brief Convert bitmap glyphs into ass_image_t list with inverse clipping
+ * \brief Convert bitmap glyphs into ASS_Image list with inverse clipping
  *
  * Inverse clipping with the following strategy:
  * - find rectangle from (x0, y0) to (cx0, y1)
@@ -434,14 +225,14 @@
  * In an additional pass, the rectangles need to be split up left/right for
  * karaoke effects.  This can result in a lot of bitmaps (6 to be exact).
  */
-static ass_image_t **render_glyph_i(ass_renderer_t *render_priv,
-                                    bitmap_t *bm, int dst_x, int dst_y,
-                                    uint32_t color, uint32_t color2, int brk,
-                                    ass_image_t **tail)
+static ASS_Image **render_glyph_i(ASS_Renderer *render_priv,
+                                  Bitmap *bm, int dst_x, int dst_y,
+                                  uint32_t color, uint32_t color2, int brk,
+                                  ASS_Image **tail)
 {
     int i, j, x0, y0, x1, y1, cx0, cy0, cx1, cy1, sx, sy, zx, zy;
-    rect_t r[4];
-    ass_image_t *img;
+    Rect r[4];
+    ASS_Image *img;
 
     dst_x += bm-&gt;left;
     dst_y += bm-&gt;top;
@@ -521,7 +312,7 @@
 }
 
 /**
- * \brief convert bitmap glyph into ass_image_t struct(s)
+ * \brief convert bitmap glyph into ASS_Image struct(s)
  * \param bit freetype bitmap glyph, FT_PIXEL_MODE_GRAY
  * \param dst_x bitmap x coordinate in video frame
  * \param dst_y bitmap y coordinate in video frame
@@ -532,10 +323,9 @@
  * \return pointer to the new list tail
  * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.
  */
-static ass_image_t **render_glyph(ass_renderer_t *render_priv,
-                                  bitmap_t *bm, int dst_x, int dst_y,
-                                  uint32_t color, uint32_t color2, int brk,
-                                  ass_image_t **tail)
+static ASS_Image **
+render_glyph(ASS_Renderer *render_priv, Bitmap *bm, int dst_x, int dst_y,
+             uint32_t color, uint32_t color2, int brk, ASS_Image **tail)
 {
     // Inverse clipping in use?
     if (render_priv-&gt;state.clip_mode)
@@ -548,7 +338,7 @@
     int b_x0, b_y0, b_x1, b_y1; // visible part of the bitmap
     int clip_x0, clip_y0, clip_x1, clip_y1;
     int tmp;
-    ass_image_t *img;
+    ASS_Image *img;
 
     dst_x += bm-&gt;left;
     dst_y += bm-&gt;top;
@@ -610,11 +400,11 @@
 }
 
 /**
- * \brief Replace the bitmap buffer in ass_image_t with a copy
- * \param img ass_image_t to operate on
+ * \brief Replace the bitmap buffer in ASS_Image with a copy
+ * \param img ASS_Image to operate on
  * \return pointer to old bitmap buffer
  */
-static unsigned char *clone_bitmap_buffer(ass_image_t *img)
+static unsigned char *clone_bitmap_buffer(ASS_Image *img)
 {
     unsigned char *old_bitmap = img-&gt;bitmap;
     int size = img-&gt;stride * (img-&gt;h - 1) + img-&gt;w;
@@ -625,22 +415,21 @@
 
 /**
  * \brief Calculate overlapping area of two consecutive bitmaps and in case they
- * overlap, composite them together
+ * overlap, blend them together
  * Mainly useful for translucent glyphs and especially borders, to avoid the
  * luminance adding up where they overlap (which looks ugly)
  */
 static void
-render_overlap(ass_renderer_t *render_priv, ass_image_t **last_tail,
-               ass_image_t **tail, bitmap_hash_key_t *last_hash,
-               bitmap_hash_key_t *hash)
+render_overlap(ASS_Renderer *render_priv, ASS_Image **last_tail,
+               ASS_Image **tail)
 {
     int left, top, bottom, right;
     int old_left, old_top, w, h, cur_left, cur_top;
     int x, y, opos, cpos;
     char m;
-    composite_hash_key_t hk;
-    composite_hash_val_t *hv;
-    composite_hash_val_t chv;
+    CompositeHashKey hk;
+    CompositeHashValue *hv;
+    CompositeHashValue chv;
     int ax = (*last_tail)-&gt;dst_x;
     int ay = (*last_tail)-&gt;dst_y;
     int aw = (*last_tail)-&gt;w;
@@ -676,8 +465,8 @@
 
     // Query cache
     memset(&amp;hk, 0, sizeof(hk));
-    memcpy(&amp;hk.a, last_hash, sizeof(*last_hash));
-    memcpy(&amp;hk.b, hash, sizeof(*hash));
+    hk.a = (*last_tail)-&gt;bitmap;
+    hk.b = (*tail)-&gt;bitmap;
     hk.aw = aw;
     hk.ah = ah;
     hk.bw = bw;
@@ -686,6 +475,8 @@
     hk.ay = ay;
     hk.bx = bx;
     hk.by = by;
+    hk.as = as;
+    hk.bs = bs;
     hv = cache_find_composite(render_priv-&gt;cache.composite_cache, &amp;hk);
     if (hv) {
         (*last_tail)-&gt;bitmap = hv-&gt;a;
@@ -696,12 +487,12 @@
     a = clone_bitmap_buffer(*last_tail);
     b = clone_bitmap_buffer(*tail);
 
-    // Composite overlapping area
+    // Blend overlapping area
     for (y = 0; y &lt; h; y++)
         for (x = 0; x &lt; w; x++) {
             opos = (old_top + y) * (as) + (old_left + x);
             cpos = (cur_top + y) * (bs) + (cur_left + x);
-            m = (a[opos] &gt; b[cpos]) ? a[opos] : b[cpos];
+            m = FFMIN(a[opos] + b[cpos], 0xff);
             (*last_tail)-&gt;bitmap[opos] = 0;
             (*tail)-&gt;bitmap[cpos] = m;
         }
@@ -712,14 +503,14 @@
     cache_add_composite(render_priv-&gt;cache.composite_cache, &amp;hk, &amp;chv);
 }
 
-static void free_list_add(ass_renderer_t *render_priv, void *object)
+static void free_list_add(ASS_Renderer *render_priv, void *object)
 {
     if (!render_priv-&gt;free_head) {
-        render_priv-&gt;free_head = calloc(1, sizeof(free_list_t));
+        render_priv-&gt;free_head = calloc(1, sizeof(FreeList));
         render_priv-&gt;free_head-&gt;object = object;
         render_priv-&gt;free_tail = render_priv-&gt;free_head;
     } else {
-        free_list_t *l = calloc(1, sizeof(free_list_t));
+        FreeList *l = calloc(1, sizeof(FreeList));
         l-&gt;object = object;
         render_priv-&gt;free_tail-&gt;next = l;
         render_priv-&gt;free_tail = render_priv-&gt;free_tail-&gt;next;
@@ -731,13 +522,13 @@
  * applicable. The blended bitmaps are added to a free list which is freed
  * at the start of a new frame.
  */
-static void blend_vector_clip(ass_renderer_t *render_priv,
-                              ass_image_t *head)
+static void blend_vector_clip(ASS_Renderer *render_priv,
+                              ASS_Image *head)
 {
     FT_Glyph glyph;
     FT_BitmapGlyph clip_bm;
-    ass_image_t *cur;
-    ass_drawing_t *drawing = render_priv-&gt;state.clip_drawing;
+    ASS_Image *cur;
+    ASS_Drawing *drawing = render_priv-&gt;state.clip_drawing;
     int error;
 
     if (!drawing)
@@ -801,7 +592,7 @@
             free_list_add(render_priv, nbuffer);
 
             // Blend together
-            memcpy(nbuffer, abuffer, as * ah);
+            memcpy(nbuffer, abuffer, as * (ah - 1) + aw);
             for (y = 0; y &lt; h; y++)
                 for (x = 0; x &lt; w; x++) {
                     apos = (atop + y) * as + aleft + x;
@@ -839,26 +630,25 @@
 }
 
 /**
- * \brief Convert text_info_t struct to ass_image_t list
+ * \brief Convert TextInfo struct to ASS_Image list
  * Splits glyphs in halves when needed (for \kf karaoke).
  */
-static ass_image_t *render_text(ass_renderer_t *render_priv, int dst_x,
+static ASS_Image *render_text(ASS_Renderer *render_priv, int dst_x,
                                 int dst_y)
 {
     int pen_x, pen_y;
     int i;
-    bitmap_t *bm;
-    ass_image_t *head;
-    ass_image_t **tail = &head;
-    ass_image_t **last_tail = 0;
-    ass_image_t **here_tail = 0;
-    bitmap_hash_key_t *last_hash = 0;
-    text_info_t *text_info = &amp;render_priv-&gt;text_info;
+    Bitmap *bm;
+    ASS_Image *head;
+    ASS_Image **tail = &head;
+    ASS_Image **last_tail = 0;
+    ASS_Image **here_tail = 0;
+    TextInfo *text_info = &amp;render_priv-&gt;text_info;
 
     for (i = 0; i &lt; text_info-&gt;length; ++i) {
-        glyph_info_t *info = text_info-&gt;glyphs + i;
+        GlyphInfo *info = text_info-&gt;glyphs + i;
         if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_s
-            || (info-&gt;shadow_x == 0 &amp;&amp; info-&gt;shadow_y == 0))
+            || (info-&gt;shadow_x == 0 &amp;&amp; info-&gt;shadow_y == 0) || info-&gt;skip)
             continue;
 
         pen_x =
@@ -874,16 +664,16 @@
             render_glyph(render_priv, bm, pen_x, pen_y, info-&gt;c[3], 0,
                          1000000, tail);
         if (last_tail &amp;&amp; tail != here_tail &amp;&amp; ((info-&gt;c[3] &amp; 0xff) &gt; 0))
-            render_overlap(render_priv, last_tail, here_tail, last_hash,
-                           &amp;info-&gt;hash_key);
+            render_overlap(render_priv, last_tail, here_tail);
+
         last_tail = here_tail;
-        last_hash = &amp;info-&gt;hash_key;
     }
 
     last_tail = 0;
     for (i = 0; i &lt; text_info-&gt;length; ++i) {
-        glyph_info_t *info = text_info-&gt;glyphs + i;
-        if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_o)
+        GlyphInfo *info = text_info-&gt;glyphs + i;
+        if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_o
+            || info-&gt;skip)
             continue;
 
         pen_x = dst_x + (info-&gt;pos.x &gt;&gt; 6);
@@ -899,15 +689,16 @@
                 render_glyph(render_priv, bm, pen_x, pen_y, info-&gt;c[2],
                              0, 1000000, tail);
             if (last_tail &amp;&amp; tail != here_tail &amp;&amp; ((info-&gt;c[2] &amp; 0xff) &gt; 0))
-                render_overlap(render_priv, last_tail, here_tail,
-                               last_hash, &amp;info-&gt;hash_key);
+                render_overlap(render_priv, last_tail, here_tail);
+
             last_tail = here_tail;
-            last_hash = &amp;info-&gt;hash_key;
         }
     }
+
     for (i = 0; i &lt; text_info-&gt;length; ++i) {
-        glyph_info_t *info = text_info-&gt;glyphs + i;
-        if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm)
+        GlyphInfo *info = text_info-&gt;glyphs + i;
+        if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm
+            || info-&gt;skip)
             continue;
 
         pen_x = dst_x + (info-&gt;pos.x &gt;&gt; 6);
@@ -943,13 +734,13 @@
 /**
  * \brief Mapping between script and screen coordinates
  */
-static double x2scr(ass_renderer_t *render_priv, double x)
+static double x2scr(ASS_Renderer *render_priv, double x)
 {
     return x * render_priv-&gt;orig_width_nocrop /
         render_priv-&gt;track-&gt;PlayResX +
         FFMAX(render_priv-&gt;settings.left_margin, 0);
 }
-static double x2scr_pos(ass_renderer_t *render_priv, double x)
+static double x2scr_pos(ASS_Renderer *render_priv, double x)
 {
     return x * render_priv-&gt;orig_width / render_priv-&gt;track-&gt;PlayResX +
         render_priv-&gt;settings.left_margin;
@@ -958,20 +749,20 @@
 /**
  * \brief Mapping between script and screen coordinates
  */
-static double y2scr(ass_renderer_t *render_priv, double y)
+static double y2scr(ASS_Renderer *render_priv, double y)
 {
     return y * render_priv-&gt;orig_height_nocrop /
         render_priv-&gt;track-&gt;PlayResY +
         FFMAX(render_priv-&gt;settings.top_margin, 0);
 }
-static double y2scr_pos(ass_renderer_t *render_priv, double y)
+static double y2scr_pos(ASS_Renderer *render_priv, double y)
 {
     return y * render_priv-&gt;orig_height / render_priv-&gt;track-&gt;PlayResY +
         render_priv-&gt;settings.top_margin;
 }
 
 // the same for toptitles
-static double y2scr_top(ass_renderer_t *render_priv, double y)
+static double y2scr_top(ASS_Renderer *render_priv, double y)
 {
     if (render_priv-&gt;settings.use_margins)
         return y * render_priv-&gt;orig_height_nocrop /
@@ -983,7 +774,7 @@
 }
 
 // the same for subtitles
-static double y2scr_sub(ass_renderer_t *render_priv, double y)
+static double y2scr_sub(ASS_Renderer *render_priv, double y)
 {
     if (render_priv-&gt;settings.use_margins)
         return y * render_priv-&gt;orig_height_nocrop /
@@ -996,7 +787,7 @@
             FFMAX(render_priv-&gt;settings.top_margin, 0);
 }
 
-static void compute_string_bbox(text_info_t *info, double_bbox_t *bbox)
+static void compute_string_bbox(TextInfo *info, DBBox *bbox)
 {
     int i;
 
@@ -1008,6 +799,7 @@
                      d6_to_double(info-&gt;glyphs[0].pos.y);
 
         for (i = 0; i &lt; info-&gt;length; ++i) {
+            if (info-&gt;glyphs[i].skip) continue;
             double s = d6_to_double(info-&gt;glyphs[i].pos.x);
             double e = s + d6_to_double(info-&gt;glyphs[i].advance.x);
             bbox-&gt;xMin = FFMIN(bbox-&gt;xMin, s);
@@ -1017,911 +809,11 @@
         bbox-&gt;xMin = bbox-&gt;xMax = bbox-&gt;yMin = bbox-&gt;yMax = 0.;
 }
 
-
 /**
- * \brief Check if starting part of (*p) matches sample. If true, shift p to the first symbol after the matching part.
- */
-static inline int mystrcmp(char **p, const char *sample)
-{
-    int len = strlen(sample);
-    if (strncmp(*p, sample, len) == 0) {
-        (*p) += len;
-        return 1;
-    } else
-        return 0;
-}
-
-static void change_font_size(ass_renderer_t *render_priv, double sz)
-{
-    double size = sz * render_priv-&gt;font_scale;
-
-    if (size &lt; 1)
-        size = 1;
-    else if (size &gt; render_priv-&gt;height * 2)
-        size = render_priv-&gt;height * 2;
-
-    ass_font_set_size(render_priv-&gt;state.font, size);
-
-    render_priv-&gt;state.font_size = sz;
-}
-
-/**
- * \brief Change current font, using setting from render_priv-&gt;state.
- */
-static void update_font(ass_renderer_t *render_priv)
-{
-    unsigned val;
-    ass_font_desc_t desc;
-    desc.family = strdup(render_priv-&gt;state.family);
-    desc.treat_family_as_pattern =
-        render_priv-&gt;state.treat_family_as_pattern;
-
-    val = render_priv-&gt;state.bold;
-    // 0 = normal, 1 = bold, &gt;1 = exact weight
-    if (val == 1 || val == -1)
-        val = 200;              // bold
-    else if (val &lt;= 0)
-        val = 80;               // normal
-    desc.bold = val;
-
-    val = render_priv-&gt;state.italic;
-    if (val == 1 || val == -1)
-        val = 110;              // italic
-    else if (val &lt;= 0)
-        val = 0;                // normal
-    desc.italic = val;
-
-    render_priv-&gt;state.font =
-        ass_font_new(render_priv-&gt;cache.font_cache, render_priv-&gt;library,
-                     render_priv-&gt;ftlibrary, render_priv-&gt;fontconfig_priv,
-                     &amp;desc);
-    free(desc.family);
-
-    if (render_priv-&gt;state.font)
-        change_font_size(render_priv, render_priv-&gt;state.font_size);
-}
-
-/**
- * \brief Change border width
- * negative value resets border to style value
- */
-static void change_border(ass_renderer_t *render_priv, double border_x,
-                          double border_y)
-{
-    int bord;
-    if (!render_priv-&gt;state.font)
-        return;
-
-    if (border_x &lt; 0 &amp;&amp; border_y &lt; 0) {
-        if (render_priv-&gt;state.style-&gt;BorderStyle == 1)
-            border_x = border_y = render_priv-&gt;state.style-&gt;Outline;
-        else
-            border_x = border_y = 1.;
-    }
-
-    render_priv-&gt;state.border_x = border_x;
-    render_priv-&gt;state.border_y = border_y;
-
-    bord = 64 * border_x * render_priv-&gt;border_scale;
-    if (bord &gt; 0 &amp;&amp; border_x == border_y) {
-        if (!render_priv-&gt;state.stroker) {
-            int error;
-#if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
-            error =
-                FT_Stroker_New(render_priv-&gt;ftlibrary,
-                               &amp;render_priv-&gt;state.stroker);
-#else                           // &lt; 2.2
-            error =
-                FT_Stroker_New(render_priv-&gt;state.font-&gt;faces[0]-&gt;
-                               memory, &amp;render_priv-&gt;state.stroker);
-#endif
-            if (error) {
-                ass_msg(render_priv-&gt;library, MSGL_V,
-                        &quot;failed to get stroker&quot;);
-                render_priv-&gt;state.stroker = 0;
-            }
-        }
-        if (render_priv-&gt;state.stroker)
-            FT_Stroker_Set(render_priv-&gt;state.stroker, bord,
-                           FT_STROKER_LINECAP_ROUND,
-                           FT_STROKER_LINEJOIN_ROUND, 0);
-    } else {
-        FT_Stroker_Done(render_priv-&gt;state.stroker);
-        render_priv-&gt;state.stroker = 0;
-    }
-}
-
-#define _r(c)  ((c)&gt;&gt;24)
-#define _g(c)  (((c)&gt;&gt;16)&amp;0xFF)
-#define _b(c)  (((c)&gt;&gt;8)&amp;0xFF)
-#define _a(c)  ((c)&amp;0xFF)
-
-/**
- * \brief Calculate a weighted average of two colors
- * calculates c1*(1-a) + c2*a, but separately for each component except alpha
- */
-static void change_color(uint32_t *var, uint32_t new, double pwr)
-{
-    (*var) = ((uint32_t) (_r(*var) * (1 - pwr) + _r(new) * pwr) &lt;&lt; 24) +
-        ((uint32_t) (_g(*var) * (1 - pwr) + _g(new) * pwr) &lt;&lt; 16) +
-        ((uint32_t) (_b(*var) * (1 - pwr) + _b(new) * pwr) &lt;&lt; 8) + _a(*var);
-}
-
-// like change_color, but for alpha component only
-static void change_alpha(uint32_t *var, uint32_t new, double pwr)
-{
-    *var =
-        (_r(*var) &lt;&lt; 24) + (_g(*var) &lt;&lt; 16) + (_b(*var) &lt;&lt; 8) +
-        (_a(*var) * (1 - pwr) + _a(new) * pwr);
-}
-
-/**
- * \brief Multiply two alpha values
- * \param a first value
- * \param b second value
- * \return result of multiplication
- * Parameters and result are limited by 0xFF.
- */
-static uint32_t mult_alpha(uint32_t a, uint32_t b)
-{
-    return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;
-}
-
-/**
- * \brief Calculate alpha value by piecewise linear function
- * Used for \fad, \fade implementation.
- */
-static unsigned
-interpolate_alpha(long long now,
-                  long long t1, long long t2, long long t3, long long t4,
-                  unsigned a1, unsigned a2, unsigned a3)
-{
-    unsigned a;
-    double cf;
-    if (now &lt;= t1) {
-        a = a1;
-    } else if (now &gt;= t4) {
-        a = a3;
-    } else if (now &lt; t2) {      // and &gt; t1
-        cf = ((double) (now - t1)) / (t2 - t1);
-        a = a1 * (1 - cf) + a2 * cf;
-    } else if (now &gt; t3) {
-        cf = ((double) (now - t3)) / (t4 - t3);
-        a = a2 * (1 - cf) + a3 * cf;
-    } else {                    // t2 &lt;= now &lt;= t3
-        a = a2;
-    }
-
-    return a;
-}
-
-#define skip_to(x) while ((*p != (x)) &amp;&amp; (*p != '}') &amp;&amp; (*p != 0)) { ++p;}
-#define skip(x) if (*p == (x)) ++p; else { return p; }
-#define skipopt(x) if (*p == (x)) { ++p; }
-
-/**
- * Parse a vector clip into an outline, using the proper scaling
- * parameters.  Translate it to correct for screen borders, if needed.
- */
-static char *parse_vector_clip(ass_renderer_t *render_priv, char *p)
-{
-    int scale = 1;
-    int res = 0;
-    ass_drawing_t *drawing;
-    render_priv-&gt;state.clip_drawing = ass_drawing_new(
-        render_priv-&gt;fontconfig_priv,
-        render_priv-&gt;state.font,
-        render_priv-&gt;settings.hinting,
-        render_priv-&gt;ftlibrary);
-    drawing = render_priv-&gt;state.clip_drawing;
-    skipopt('(');
-    res = mystrtoi(&amp;p, &amp;scale);
-    skipopt(',')
-    if (!res)
-        scale = 1;
-    drawing-&gt;scale = scale;
-    drawing-&gt;scale_x = render_priv-&gt;font_scale_x * render_priv-&gt;font_scale;
-    drawing-&gt;scale_y = render_priv-&gt;font_scale;
-    while (*p != ')' &amp;&amp; *p != '}' &amp;&amp; p != 0)
-        ass_drawing_add_char(drawing, *p++);
-    skipopt(')');
-    ass_drawing_parse(drawing, 1);
-    // We need to translate the clip according to screen borders
-    if (render_priv-&gt;settings.left_margin != 0 ||
-        render_priv-&gt;settings.top_margin != 0) {
-        FT_Vector trans = {
-            .x = int_to_d6(render_priv-&gt;settings.left_margin),
-            .y = -int_to_d6(render_priv-&gt;settings.top_margin),
-        };
-        FT_Outline_Translate(&amp;drawing-&gt;glyph-&gt;outline, trans.x, trans.y);
-    }
-    ass_msg(render_priv-&gt;library, MSGL_DBG2,
-            &quot;Parsed vector clip: scale %d, scales (%f, %f) string [%s]\n&quot;,
-            scale, drawing-&gt;scale_x, drawing-&gt;scale_y, drawing-&gt;text);
-
-    return p;
-}
-
-static void reset_render_context(ass_renderer_t *);
-
-/**
- * \brief Parse style override tag.
- * \param p string to parse
- * \param pwr multiplier for some tag effects (comes from \t tags)
- */
-static char *parse_tag(ass_renderer_t *render_priv, char *p, double pwr)
-{
-    skip_to('\\');
-    skip('\\');
-    if ((*p == '}') || (*p == 0))
-        return p;
-
-    // New tags introduced in vsfilter 2.39
-    if (mystrcmp(&amp;p, &quot;xbord&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val))
-            val = render_priv-&gt;state.border_x * (1 - pwr) + val * pwr;
-        else
-            val = -1.;
-        change_border(render_priv, val, render_priv-&gt;state.border_y);
-    } else if (mystrcmp(&amp;p, &quot;ybord&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val))
-            val = render_priv-&gt;state.border_y * (1 - pwr) + val * pwr;
-        else
-            val = -1.;
-        change_border(render_priv, render_priv-&gt;state.border_x, val);
-    } else if (mystrcmp(&amp;p, &quot;xshad&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val))
-            val = render_priv-&gt;state.shadow_x * (1 - pwr) + val * pwr;
-        else
-            val = 0.;
-        render_priv-&gt;state.shadow_x = val;
-    } else if (mystrcmp(&amp;p, &quot;yshad&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val))
-            val = render_priv-&gt;state.shadow_y * (1 - pwr) + val * pwr;
-        else
-            val = 0.;
-        render_priv-&gt;state.shadow_y = val;
-    } else if (mystrcmp(&amp;p, &quot;fax&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val))
-            render_priv-&gt;state.fax =
-                val * pwr + render_priv-&gt;state.fax * (1 - pwr);
-        else
-            render_priv-&gt;state.fax = 0.;
-    } else if (mystrcmp(&amp;p, &quot;fay&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val))
-            render_priv-&gt;state.fay =
-                val * pwr + render_priv-&gt;state.fay * (1 - pwr);
-        else
-            render_priv-&gt;state.fay = 0.;
-    } else if (mystrcmp(&amp;p, &quot;iclip&quot;)) {
-        int x0, y0, x1, y1;
-        int res = 1;
-        char *start = p;
-        skipopt('(');
-        res &amp;= mystrtoi(&amp;p, &amp;x0);
-        skipopt(',');
-        res &amp;= mystrtoi(&amp;p, &amp;y0);
-        skipopt(',');
-        res &amp;= mystrtoi(&amp;p, &amp;x1);
-        skipopt(',');
-        res &amp;= mystrtoi(&amp;p, &amp;y1);
-        skipopt(')');
-        if (res) {
-            render_priv-&gt;state.clip_x0 =
-                render_priv-&gt;state.clip_x0 * (1 - pwr) + x0 * pwr;
-            render_priv-&gt;state.clip_x1 =
-                render_priv-&gt;state.clip_x1 * (1 - pwr) + x1 * pwr;
-            render_priv-&gt;state.clip_y0 =
-                render_priv-&gt;state.clip_y0 * (1 - pwr) + y0 * pwr;
-            render_priv-&gt;state.clip_y1 =
-                render_priv-&gt;state.clip_y1 * (1 - pwr) + y1 * pwr;
-            render_priv-&gt;state.clip_mode = 1;
-        } else if (!render_priv-&gt;state.clip_drawing) {
-            p = parse_vector_clip(render_priv, start);
-            render_priv-&gt;state.clip_drawing_mode = 1;
-        } else
-            render_priv-&gt;state.clip_mode = 0;
-    } else if (mystrcmp(&amp;p, &quot;blur&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val)) {
-            val = render_priv-&gt;state.blur * (1 - pwr) + val * pwr;
-            val = (val &lt; 0) ? 0 : val;
-            val = (val &gt; BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;
-            render_priv-&gt;state.blur = val;
-        } else
-            render_priv-&gt;state.blur = 0.0;
-        // ASS standard tags
-    } else if (mystrcmp(&amp;p, &quot;fsc&quot;)) {
-        char tp = *p++;
-        double val;
-        if (tp == 'x') {
-            if (mystrtod(&amp;p, &amp;val)) {
-                val /= 100;
-                render_priv-&gt;state.scale_x =
-                    render_priv-&gt;state.scale_x * (1 - pwr) + val * pwr;
-            } else
-                render_priv-&gt;state.scale_x =
-                    render_priv-&gt;state.style-&gt;ScaleX;
-        } else if (tp == 'y') {
-            if (mystrtod(&amp;p, &amp;val)) {
-                val /= 100;
-                render_priv-&gt;state.scale_y =
-                    render_priv-&gt;state.scale_y * (1 - pwr) + val * pwr;
-            } else
-                render_priv-&gt;state.scale_y =
-                    render_priv-&gt;state.style-&gt;ScaleY;
-        }
-    } else if (mystrcmp(&amp;p, &quot;fsp&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val))
-            render_priv-&gt;state.hspacing =
-                render_priv-&gt;state.hspacing * (1 - pwr) + val * pwr;
-        else
-            render_priv-&gt;state.hspacing = render_priv-&gt;state.style-&gt;Spacing;
-    } else if (mystrcmp(&amp;p, &quot;fs&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val))
-            val = render_priv-&gt;state.font_size * (1 - pwr) + val * pwr;
-        else
-            val = render_priv-&gt;state.style-&gt;FontSize;
-        if (render_priv-&gt;state.font)
-            change_font_size(render_priv, val);
-    } else if (mystrcmp(&amp;p, &quot;bord&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val)) {
-            if (render_priv-&gt;state.border_x == render_priv-&gt;state.border_y)
-                val = render_priv-&gt;state.border_x * (1 - pwr) + val * pwr;
-        } else
-            val = -1.;          // reset to default
-        change_border(render_priv, val, val);
-    } else if (mystrcmp(&amp;p, &quot;move&quot;)) {
-        double x1, x2, y1, y2;
-        long long t1, t2, delta_t, t;
-        double x, y;
-        double k;
-        skip('(');
-        mystrtod(&amp;p, &amp;x1);
-        skip(',');
-        mystrtod(&amp;p, &amp;y1);
-        skip(',');
-        mystrtod(&amp;p, &amp;x2);
-        skip(',');
-        mystrtod(&amp;p, &amp;y2);
-        if (*p == ',') {
-            skip(',');
-            mystrtoll(&amp;p, &amp;t1);
-            skip(',');
-            mystrtoll(&amp;p, &amp;t2);
-            ass_msg(render_priv-&gt;library, MSGL_DBG2,
-                   &quot;movement6: (%f, %f) -&gt; (%f, %f), (%&quot; PRId64 &quot; .. %&quot;
-                   PRId64 &quot;)\n&quot;, x1, y1, x2, y2, (int64_t) t1,
-                   (int64_t) t2);
-        } else {
-            t1 = 0;
-            t2 = render_priv-&gt;state.event-&gt;Duration;
-            ass_msg(render_priv-&gt;library, MSGL_DBG2,
-                   &quot;movement: (%f, %f) -&gt; (%f, %f)&quot;, x1, y1, x2, y2);
-        }
-        skip(')');
-        delta_t = t2 - t1;
-        t = render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start;
-        if (t &lt; t1)
-            k = 0.;
-        else if (t &gt; t2)
-            k = 1.;
-        else
-            k = ((double) (t - t1)) / delta_t;
-        x = k * (x2 - x1) + x1;
-        y = k * (y2 - y1) + y1;
-        if (render_priv-&gt;state.evt_type != EVENT_POSITIONED) {
-            render_priv-&gt;state.pos_x = x;
-            render_priv-&gt;state.pos_y = y;
-            render_priv-&gt;state.detect_collisions = 0;
-            render_priv-&gt;state.evt_type = EVENT_POSITIONED;
-        }
-    } else if (mystrcmp(&amp;p, &quot;frx&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val)) {
-            val *= M_PI / 180;
-            render_priv-&gt;state.frx =
-                val * pwr + render_priv-&gt;state.frx * (1 - pwr);
-        } else
-            render_priv-&gt;state.frx = 0.;
-    } else if (mystrcmp(&amp;p, &quot;fry&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val)) {
-            val *= M_PI / 180;
-            render_priv-&gt;state.fry =
-                val * pwr + render_priv-&gt;state.fry * (1 - pwr);
-        } else
-            render_priv-&gt;state.fry = 0.;
-    } else if (mystrcmp(&amp;p, &quot;frz&quot;) || mystrcmp(&amp;p, &quot;fr&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val)) {
-            val *= M_PI / 180;
-            render_priv-&gt;state.frz =
-                val * pwr + render_priv-&gt;state.frz * (1 - pwr);
-        } else
-            render_priv-&gt;state.frz =
-                M_PI * render_priv-&gt;state.style-&gt;Angle / 180.;
-    } else if (mystrcmp(&amp;p, &quot;fn&quot;)) {
-        char *start = p;
-        char *family;
-        skip_to('\\');
-        if (p &gt; start) {
-            family = malloc(p - start + 1);
-            strncpy(family, start, p - start);
-            family[p - start] = '\0';
-        } else
-            family = strdup(render_priv-&gt;state.style-&gt;FontName);
-        if (render_priv-&gt;state.family)
-            free(render_priv-&gt;state.family);
-        render_priv-&gt;state.family = family;
-        update_font(render_priv);
-    } else if (mystrcmp(&amp;p, &quot;alpha&quot;)) {
-        uint32_t val;
-        int i;
-        if (strtocolor(render_priv-&gt;library, &amp;p, &amp;val)) {
-            unsigned char a = val &gt;&gt; 24;
-            for (i = 0; i &lt; 4; ++i)
-                change_alpha(&amp;render_priv-&gt;state.c[i], a, pwr);
-        } else {
-            change_alpha(&amp;render_priv-&gt;state.c[0],
-                         render_priv-&gt;state.style-&gt;PrimaryColour, pwr);
-            change_alpha(&amp;render_priv-&gt;state.c[1],
-                         render_priv-&gt;state.style-&gt;SecondaryColour, pwr);
-            change_alpha(&amp;render_priv-&gt;state.c[2],
-                         render_priv-&gt;state.style-&gt;OutlineColour, pwr);
-            change_alpha(&amp;render_priv-&gt;state.c[3],
-                         render_priv-&gt;state.style-&gt;BackColour, pwr);
-        }
-        // FIXME: simplify
-    } else if (mystrcmp(&amp;p, &quot;an&quot;)) {
-        int val;
-        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val) {
-            int v = (val - 1) / 3;      // 0, 1 or 2 for vertical alignment
-            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;an %d&quot;, val);
-            if (v != 0)
-                v = 3 - v;
-            val = ((val - 1) % 3) + 1;  // horizontal alignment
-            val += v * 4;
-            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;align %d&quot;, val);
-            render_priv-&gt;state.alignment = val;
-        } else
-            render_priv-&gt;state.alignment =
-                render_priv-&gt;state.style-&gt;Alignment;
-    } else if (mystrcmp(&amp;p, &quot;a&quot;)) {
-        int val;
-        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
-            render_priv-&gt;state.alignment = val;
-        else
-            render_priv-&gt;state.alignment =
-                render_priv-&gt;state.style-&gt;Alignment;
-    } else if (mystrcmp(&amp;p, &quot;pos&quot;)) {
-        double v1, v2;
-        skip('(');
-        mystrtod(&amp;p, &amp;v1);
-        skip(',');
-        mystrtod(&amp;p, &amp;v2);
-        skip(')');
-        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;pos(%f, %f)&quot;, v1, v2);
-        if (render_priv-&gt;state.evt_type == EVENT_POSITIONED) {
-            ass_msg(render_priv-&gt;library, MSGL_V, &quot;Subtitle has a new \\pos &quot;
-                   &quot;after \\move or \\pos, ignoring&quot;);
-        } else {
-            render_priv-&gt;state.evt_type = EVENT_POSITIONED;
-            render_priv-&gt;state.detect_collisions = 0;
-            render_priv-&gt;state.pos_x = v1;
-            render_priv-&gt;state.pos_y = v2;
-        }
-    } else if (mystrcmp(&amp;p, &quot;fad&quot;)) {
-        int a1, a2, a3;
-        long long t1, t2, t3, t4;
-        if (*p == 'e')
-            ++p;                // either \fad or \fade
-        skip('(');
-        mystrtoi(&amp;p, &amp;a1);
-        skip(',');
-        mystrtoi(&amp;p, &amp;a2);
-        if (*p == ')') {
-            // 2-argument version (\fad, according to specs)
-            // a1 and a2 are fade-in and fade-out durations
-            t1 = 0;
-            t4 = render_priv-&gt;state.event-&gt;Duration;
-            t2 = a1;
-            t3 = t4 - a2;
-            a1 = 0xFF;
-            a2 = 0;
-            a3 = 0xFF;
-        } else {
-            // 6-argument version (\fade)
-            // a1 and a2 (and a3) are opacity values
-            skip(',');
-            mystrtoi(&amp;p, &amp;a3);
-            skip(',');
-            mystrtoll(&amp;p, &amp;t1);
-            skip(',');
-            mystrtoll(&amp;p, &amp;t2);
-            skip(',');
-            mystrtoll(&amp;p, &amp;t3);
-            skip(',');
-            mystrtoll(&amp;p, &amp;t4);
-        }
-        skip(')');
-        render_priv-&gt;state.fade =
-            interpolate_alpha(render_priv-&gt;time -
-                              render_priv-&gt;state.event-&gt;Start, t1, t2,
-                              t3, t4, a1, a2, a3);
-    } else if (mystrcmp(&amp;p, &quot;org&quot;)) {
-        int v1, v2;
-        skip('(');
-        mystrtoi(&amp;p, &amp;v1);
-        skip(',');
-        mystrtoi(&amp;p, &amp;v2);
-        skip(')');
-        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;org(%d, %d)&quot;, v1, v2);
-        if (!render_priv-&gt;state.have_origin) {
-            render_priv-&gt;state.org_x = v1;
-            render_priv-&gt;state.org_y = v2;
-            render_priv-&gt;state.have_origin = 1;
-            render_priv-&gt;state.detect_collisions = 0;
-        }
-    } else if (mystrcmp(&amp;p, &quot;t&quot;)) {
-        double v[3];
-        int v1, v2;
-        double v3;
-        int cnt;
-        long long t1, t2, t, delta_t;
-        double k;
-        skip('(');
-        for (cnt = 0; cnt &lt; 3; ++cnt) {
-            if (*p == '\\')
-                break;
-            v[cnt] = strtod(p, &amp;p);
-            skip(',');
-        }
-        if (cnt == 3) {
-            v1 = v[0];
-            v2 = (v[1] &lt; v1) ? render_priv-&gt;state.event-&gt;Duration : v[1];
-            v3 = v[2];
-        } else if (cnt == 2) {
-            v1 = v[0];
-            v2 = (v[1] &lt; v1) ? render_priv-&gt;state.event-&gt;Duration : v[1];
-            v3 = 1.;
-        } else if (cnt == 1) {
-            v1 = 0;
-            v2 = render_priv-&gt;state.event-&gt;Duration;
-            v3 = v[0];
-        } else {                // cnt == 0
-            v1 = 0;
-            v2 = render_priv-&gt;state.event-&gt;Duration;
-            v3 = 1.;
-        }
-        render_priv-&gt;state.detect_collisions = 0;
-        t1 = v1;
-        t2 = v2;
-        delta_t = v2 - v1;
-        if (v3 &lt; 0.)
-            v3 = 0.;
-        t = render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start;        // FIXME: move to render_context
-        if (t &lt;= t1)
-            k = 0.;
-        else if (t &gt;= t2)
-            k = 1.;
-        else {
-            assert(delta_t != 0.);
-            k = pow(((double) (t - t1)) / delta_t, v3);
-        }
-        while (*p == '\\')
-            p = parse_tag(render_priv, p, k);   // maybe k*pwr ? no, specs forbid nested \t's
-        skip_to(')');           // in case there is some unknown tag or a comment
-        skip(')');
-    } else if (mystrcmp(&amp;p, &quot;clip&quot;)) {
-        char *start = p;
-        int x0, y0, x1, y1;
-        int res = 1;
-        skipopt('(');
-        res &amp;= mystrtoi(&amp;p, &amp;x0);
-        skipopt(',');
-        res &amp;= mystrtoi(&amp;p, &amp;y0);
-        skipopt(',');
-        res &amp;= mystrtoi(&amp;p, &amp;x1);
-        skipopt(',');
-        res &amp;= mystrtoi(&amp;p, &amp;y1);
-        skipopt(')');
-        if (res) {
-            render_priv-&gt;state.clip_x0 =
-                render_priv-&gt;state.clip_x0 * (1 - pwr) + x0 * pwr;
-            render_priv-&gt;state.clip_x1 =
-                render_priv-&gt;state.clip_x1 * (1 - pwr) + x1 * pwr;
-            render_priv-&gt;state.clip_y0 =
-                render_priv-&gt;state.clip_y0 * (1 - pwr) + y0 * pwr;
-            render_priv-&gt;state.clip_y1 =
-                render_priv-&gt;state.clip_y1 * (1 - pwr) + y1 * pwr;
-        // Might be a vector clip
-        } else if (!render_priv-&gt;state.clip_drawing) {
-            p = parse_vector_clip(render_priv, start);
-            render_priv-&gt;state.clip_drawing_mode = 0;
-        } else {
-            render_priv-&gt;state.clip_x0 = 0;
-            render_priv-&gt;state.clip_y0 = 0;
-            render_priv-&gt;state.clip_x1 = render_priv-&gt;track-&gt;PlayResX;
-            render_priv-&gt;state.clip_y1 = render_priv-&gt;track-&gt;PlayResY;
-        }
-    } else if (mystrcmp(&amp;p, &quot;c&quot;)) {
-        uint32_t val;
-        if (!strtocolor(render_priv-&gt;library, &amp;p, &amp;val))
-            val = render_priv-&gt;state.style-&gt;PrimaryColour;
-        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;color: %X&quot;, val);
-        change_color(&amp;render_priv-&gt;state.c[0], val, pwr);
-    } else if ((*p &gt;= '1') &amp;&amp; (*p &lt;= '4') &amp;&amp; (++p)
-               &amp;&amp; (mystrcmp(&amp;p, &quot;c&quot;) || mystrcmp(&amp;p, &quot;a&quot;))) {
-        char n = *(p - 2);
-        int cidx = n - '1';
-        char cmd = *(p - 1);
-        uint32_t val;
-        assert((n &gt;= '1') &amp;&amp; (n &lt;= '4'));
-        if (!strtocolor(render_priv-&gt;library, &amp;p, &amp;val))
-            switch (n) {
-            case '1':
-                val = render_priv-&gt;state.style-&gt;PrimaryColour;
-                break;
-            case '2':
-                val = render_priv-&gt;state.style-&gt;SecondaryColour;
-                break;
-            case '3':
-                val = render_priv-&gt;state.style-&gt;OutlineColour;
-                break;
-            case '4':
-                val = render_priv-&gt;state.style-&gt;BackColour;
-                break;
-            default:
-                val = 0;
-                break;          // impossible due to assert; avoid compilation warning
-            }
-        switch (cmd) {
-        case 'c':
-            change_color(render_priv-&gt;state.c + cidx, val, pwr);
-            break;
-        case 'a':
-            change_alpha(render_priv-&gt;state.c + cidx, val &gt;&gt; 24, pwr);
-            break;
-        default:
-            ass_msg(render_priv-&gt;library, MSGL_WARN, &quot;Bad command: %c%c&quot;,
-                    n, cmd);
-            break;
-        }
-        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;single c/a at %f: %c%c = %X&quot;,
-               pwr, n, cmd, render_priv-&gt;state.c[cidx]);
-    } else if (mystrcmp(&amp;p, &quot;r&quot;)) {
-        reset_render_context(render_priv);
-    } else if (mystrcmp(&amp;p, &quot;be&quot;)) {
-        int val;
-        if (mystrtoi(&amp;p, &amp;val)) {
-            // Clamp to a safe upper limit, since high values need excessive CPU
-            val = (val &lt; 0) ? 0 : val;
-            val = (val &gt; MAX_BE) ? MAX_BE : val;
-            render_priv-&gt;state.be = val;
-        } else
-            render_priv-&gt;state.be = 0;
-    } else if (mystrcmp(&amp;p, &quot;b&quot;)) {
-        int b;
-        if (mystrtoi(&amp;p, &amp;b)) {
-            if (pwr &gt;= .5)
-                render_priv-&gt;state.bold = b;
-        } else
-            render_priv-&gt;state.bold = render_priv-&gt;state.style-&gt;Bold;
-        update_font(render_priv);
-    } else if (mystrcmp(&amp;p, &quot;i&quot;)) {
-        int i;
-        if (mystrtoi(&amp;p, &amp;i)) {
-            if (pwr &gt;= .5)
-                render_priv-&gt;state.italic = i;
-        } else
-            render_priv-&gt;state.italic = render_priv-&gt;state.style-&gt;Italic;
-        update_font(render_priv);
-    } else if (mystrcmp(&amp;p, &quot;kf&quot;) || mystrcmp(&amp;p, &quot;K&quot;)) {
-        int val = 0;
-        mystrtoi(&amp;p, &amp;val);
-        render_priv-&gt;state.effect_type = EF_KARAOKE_KF;
-        if (render_priv-&gt;state.effect_timing)
-            render_priv-&gt;state.effect_skip_timing +=
-                render_priv-&gt;state.effect_timing;
-        render_priv-&gt;state.effect_timing = val * 10;
-    } else if (mystrcmp(&amp;p, &quot;ko&quot;)) {
-        int val = 0;
-        mystrtoi(&amp;p, &amp;val);
-        render_priv-&gt;state.effect_type = EF_KARAOKE_KO;
-        if (render_priv-&gt;state.effect_timing)
-            render_priv-&gt;state.effect_skip_timing +=
-                render_priv-&gt;state.effect_timing;
-        render_priv-&gt;state.effect_timing = val * 10;
-    } else if (mystrcmp(&amp;p, &quot;k&quot;)) {
-        int val = 0;
-        mystrtoi(&amp;p, &amp;val);
-        render_priv-&gt;state.effect_type = EF_KARAOKE;
-        if (render_priv-&gt;state.effect_timing)
-            render_priv-&gt;state.effect_skip_timing +=
-                render_priv-&gt;state.effect_timing;
-        render_priv-&gt;state.effect_timing = val * 10;
-    } else if (mystrcmp(&amp;p, &quot;shad&quot;)) {
-        double val;
-        if (mystrtod(&amp;p, &amp;val)) {
-            if (render_priv-&gt;state.shadow_x == render_priv-&gt;state.shadow_y)
-                val = render_priv-&gt;state.shadow_x * (1 - pwr) + val * pwr;
-        } else
-            val = 0.;
-        render_priv-&gt;state.shadow_x = render_priv-&gt;state.shadow_y = val;
-    } else if (mystrcmp(&amp;p, &quot;s&quot;)) {
-        int val;
-        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
-            render_priv-&gt;state.flags |= DECO_STRIKETHROUGH;
-        else
-            render_priv-&gt;state.flags &amp;= ~DECO_STRIKETHROUGH;
-    } else if (mystrcmp(&amp;p, &quot;u&quot;)) {
-        int val;
-        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
-            render_priv-&gt;state.flags |= DECO_UNDERLINE;
-        else
-            render_priv-&gt;state.flags &amp;= ~DECO_UNDERLINE;
-    } else if (mystrcmp(&amp;p, &quot;pbo&quot;)) {
-        double val = 0;
-        if (mystrtod(&amp;p, &amp;val))
-            render_priv-&gt;state.drawing-&gt;pbo = val;
-    } else if (mystrcmp(&amp;p, &quot;p&quot;)) {
-        int val;
-        if (!mystrtoi(&amp;p, &amp;val))
-            val = 0;
-        if (val)
-            render_priv-&gt;state.drawing-&gt;scale = val;
-        render_priv-&gt;state.drawing_mode = !!val;
-    }
-
-    return p;
-
-#undef skip
-#undef skipopt
-#undef skip_to
-}
-
-/**
- * \brief Get next ucs4 char from string, parsing and executing style overrides
- * \param str string pointer
- * \return ucs4 code of the next char
- * On return str points to the unparsed part of the string
- */
-static unsigned get_next_char(ass_renderer_t *render_priv, char **str)
-{
-    char *p = *str;
-    unsigned chr;
-    if (*p == '{') {            // '\0' goes here
-        p++;
-        while (1) {
-            p = parse_tag(render_priv, p, 1.);
-            if (*p == '}') {    // end of tag
-                p++;
-                if (*p == '{') {
-                    p++;
-                    continue;
-                } else
-                    break;
-            } else if (*p != '\\')
-                ass_msg(render_priv-&gt;library, MSGL_V,
-                        &quot;Unable to parse: '%s'&quot;, p);
-            if (*p == 0)
-                break;
-        }
-    }
-    if (*p == '\t') {
-        ++p;
-        *str = p;
-        return ' ';
-    }
-    if (*p == '\\') {
-        if ((*(p + 1) == 'N')
-            || ((*(p + 1) == 'n')
-                &amp;&amp; (render_priv-&gt;track-&gt;WrapStyle == 2))) {
-            p += 2;
-            *str = p;
-            return '\n';
-        } else if ((*(p + 1) == 'n') || (*(p + 1) == 'h')) {
-            p += 2;
-            *str = p;
-            return ' ';
-        }
-    }
-    chr = ass_utf8_get_char((char **) &amp;p);
-    *str = p;
-    return chr;
-}
-
-static void
-apply_transition_effects(ass_renderer_t *render_priv, ass_event_t *event)
-{
-    int v[4];
-    int cnt;
-    char *p = event-&gt;Effect;
-
-    if (!p || !*p)
-        return;
-
-    cnt = 0;
-    while (cnt &lt; 4 &amp;&amp; (p = strchr(p, ';'))) {
-        v[cnt++] = atoi(++p);
-    }
-
-    if (strncmp(event-&gt;Effect, &quot;Banner;&quot;, 7) == 0) {
-        int delay;
-        if (cnt &lt; 1) {
-            ass_msg(render_priv-&gt;library, MSGL_V,
-                    &quot;Error parsing effect: '%s'&quot;, event-&gt;Effect);
-            return;
-        }
-        if (cnt &gt;= 2 &amp;&amp; v[1] == 0)      // right-to-left
-            render_priv-&gt;state.scroll_direction = SCROLL_RL;
-        else                    // left-to-right
-            render_priv-&gt;state.scroll_direction = SCROLL_LR;
-
-        delay = v[0];
-        if (delay == 0)
-            delay = 1;          // ?
-        render_priv-&gt;state.scroll_shift =
-            (render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start) / delay;
-        render_priv-&gt;state.evt_type = EVENT_HSCROLL;
-        return;
-    }
-
-    if (strncmp(event-&gt;Effect, &quot;Scroll up;&quot;, 10) == 0) {
-        render_priv-&gt;state.scroll_direction = SCROLL_BT;
-    } else if (strncmp(event-&gt;Effect, &quot;Scroll down;&quot;, 12) == 0) {
-        render_priv-&gt;state.scroll_direction = SCROLL_TB;
-    } else {
-        ass_msg(render_priv-&gt;library, MSGL_V,
-                &quot;Unknown transition effect: '%s'&quot;, event-&gt;Effect);
-        return;
-    }
-    // parse scroll up/down parameters
-    {
-        int delay;
-        int y0, y1;
-        if (cnt &lt; 3) {
-            ass_msg(render_priv-&gt;library, MSGL_V,
-                    &quot;Error parsing effect: '%s'&quot;, event-&gt;Effect);
-            return;
-        }
-        delay = v[2];
-        if (delay == 0)
-            delay = 1;          // ?
-        render_priv-&gt;state.scroll_shift =
-            (render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start) / delay;
-        if (v[0] &lt; v[1]) {
-            y0 = v[0];
-            y1 = v[1];
-        } else {
-            y0 = v[1];
-            y1 = v[0];
-        }
-        if (y1 == 0)
-            y1 = render_priv-&gt;track-&gt;PlayResY;  // y0=y1=0 means fullscreen scrolling
-        render_priv-&gt;state.clip_y0 = y0;
-        render_priv-&gt;state.clip_y1 = y1;
-        render_priv-&gt;state.evt_type = EVENT_VSCROLL;
-        render_priv-&gt;state.detect_collisions = 0;
-    }
-
-}
-
-/**
  * \brief partially reset render_context to style values
  * Works like {\r}: resets some style overrides
  */
-static void reset_render_context(ass_renderer_t *render_priv)
+void reset_render_context(ASS_Renderer *render_priv)
 {
     render_priv-&gt;state.c[0] = render_priv-&gt;state.style-&gt;PrimaryColour;
     render_priv-&gt;state.c[1] = render_priv-&gt;state.style-&gt;SecondaryColour;
@@ -1952,6 +844,7 @@
     render_priv-&gt;state.frx = render_priv-&gt;state.fry = 0.;
     render_priv-&gt;state.frz = M_PI * render_priv-&gt;state.style-&gt;Angle / 180.;
     render_priv-&gt;state.fax = render_priv-&gt;state.fay = 0.;
+    render_priv-&gt;state.wrap_style = render_priv-&gt;track-&gt;WrapStyle;
 
     // FIXME: does not reset unsupported attributes.
 }
@@ -1960,7 +853,7 @@
  * \brief Start new event. Reset render_priv-&gt;state.
  */
 static void
-init_render_context(ass_renderer_t *render_priv, ass_event_t *event)
+init_render_context(ASS_Renderer *render_priv, ASS_Event *event)
 {
     render_priv-&gt;state.event = event;
     render_priv-&gt;state.style = render_priv-&gt;track-&gt;styles + event-&gt;Style;
@@ -1978,6 +871,7 @@
     render_priv-&gt;state.clip_y0 = 0;
     render_priv-&gt;state.clip_x1 = render_priv-&gt;track-&gt;PlayResX;
     render_priv-&gt;state.clip_y1 = render_priv-&gt;track-&gt;PlayResY;
+    render_priv-&gt;state.clip_mode = 0;
     render_priv-&gt;state.detect_collisions = 1;
     render_priv-&gt;state.fade = 0;
     render_priv-&gt;state.drawing_mode = 0;
@@ -1993,7 +887,7 @@
     apply_transition_effects(render_priv, event);
 }
 
-static void free_render_context(ass_renderer_t *render_priv)
+static void free_render_context(ASS_Renderer *render_priv)
 {
     free(render_priv-&gt;state.family);
     ass_drawing_free(render_priv-&gt;state.drawing);
@@ -2085,10 +979,68 @@
 }
 
 /*
+ * Replace the outline of a glyph by a contour which makes up a simple
+ * opaque rectangle.
+ */
+static void draw_opaque_box(ASS_Renderer *render_priv, uint32_t ch,
+                            FT_Glyph glyph, int sx, int sy)
+{
+    int asc = 0, desc = 0;
+    int i;
+    int adv = d16_to_d6(glyph-&gt;advance.x);
+    double scale_y = render_priv-&gt;state.scale_y;
+    double scale_x = render_priv-&gt;state.scale_x
+                     * render_priv-&gt;font_scale_x;
+    FT_OutlineGlyph og = (FT_OutlineGlyph) glyph;
+    FT_Outline *ol;
+
+    // to avoid gaps
+    sx = FFMAX(64, sx);
+    sy = FFMAX(64, sy);
+
+    if (ch == -1) {
+        asc = render_priv-&gt;state.drawing-&gt;asc;
+        desc = render_priv-&gt;state.drawing-&gt;desc;
+    } else {
+        ass_font_get_asc_desc(render_priv-&gt;state.font, ch, &amp;asc, &amp;desc);
+        asc  *= scale_y;
+        desc *= scale_y;
+    }
+
+    // Emulate the WTFish behavior of VSFilter, i.e. double-scale
+    // the sizes of the opaque box.
+    adv += double_to_d6(render_priv-&gt;state.hspacing * render_priv-&gt;font_scale
+                        * scale_x);
+    adv *= scale_x;
+    sx *= scale_x;
+    sy *= scale_y;
+    desc *= scale_y;
+    desc += asc * (scale_y - 1.0);
+
+    FT_Vector points[4] = {
+        { .x = -sx,         .y = asc + sy },
+        { .x = adv + sx,    .y = asc + sy },
+        { .x = adv + sx,    .y = -desc - sy },
+        { .x = -sx,         .y = -desc - sy },
+    };
+
+    FT_Outline_Done(render_priv-&gt;ftlibrary, &amp;og-&gt;outline);
+    FT_Outline_New(render_priv-&gt;ftlibrary, 4, 1, &amp;og-&gt;outline);
+
+    ol = &amp;og-&gt;outline;
+    ol-&gt;n_points = ol-&gt;n_contours = 0;
+    for (i = 0; i &lt; 4; i++) {
+        ol-&gt;points[ol-&gt;n_points] = points[i];
+        ol-&gt;tags[ol-&gt;n_points++] = 1;
+    }
+    ol-&gt;contours[ol-&gt;n_contours++] = ol-&gt;n_points - 1;
+}
+
+/*
  * Stroke an outline glyph in x/y direction.  Applies various fixups to get
  * around limitations of the FreeType stroker.
  */
-static void stroke_outline_glyph(ass_renderer_t *render_priv,
+static void stroke_outline_glyph(ASS_Renderer *render_priv,
                                  FT_OutlineGlyph *glyph, int sx, int sy)
 {
     if (sx &lt;= 0 &amp;&amp; sy &lt;= 0)
@@ -2137,11 +1089,11 @@
  * The glyphs are returned in info-&gt;glyph and info-&gt;outline_glyph
  */
 static void
-get_outline_glyph(ass_renderer_t *render_priv, int symbol,
-                  glyph_info_t *info, ass_drawing_t *drawing)
+get_outline_glyph(ASS_Renderer *render_priv, int symbol, GlyphInfo *info,
+                  ASS_Drawing *drawing)
 {
-    glyph_hash_val_t *val;
-    glyph_hash_key_t key;
+    GlyphHashValue *val;
+    GlyphHashKey key;
     memset(&amp;key, 0, sizeof(key));
 
     if (drawing-&gt;hash) {
@@ -2149,6 +1101,7 @@
         key.scale_y = double_to_d16(render_priv-&gt;state.scale_y);
         key.outline.x = render_priv-&gt;state.border_x * 0xFFFF;
         key.outline.y = render_priv-&gt;state.border_y * 0xFFFF;
+        key.border_style = render_priv-&gt;state.style-&gt;BorderStyle;
         key.drawing_hash = drawing-&gt;hash;
     } else {
         key.font = render_priv-&gt;state.font;
@@ -2161,8 +1114,9 @@
         key.outline.x = render_priv-&gt;state.border_x * 0xFFFF;
         key.outline.y = render_priv-&gt;state.border_y * 0xFFFF;
         key.flags = render_priv-&gt;state.flags;
+        key.border_style = render_priv-&gt;state.style-&gt;BorderStyle;
     }
-    memset(info, 0, sizeof(glyph_info_t));
+    memset(info, 0, sizeof(GlyphInfo));
 
     val = cache_find_glyph(render_priv-&gt;cache.glyph_cache, &amp;key);
     if (val) {
@@ -2177,9 +1131,10 @@
             drawing-&gt;desc = val-&gt;desc;
         }
     } else {
-        glyph_hash_val_t v;
+        GlyphHashValue v;
         if (drawing-&gt;hash) {
-            ass_drawing_parse(drawing, 0);
+            if(!ass_drawing_parse(drawing, 0))
+                return;
             FT_Glyph_Copy((FT_Glyph) drawing-&gt;glyph, &amp;info-&gt;glyph);
         } else {
             info-&gt;glyph =
@@ -2194,8 +1149,17 @@
         info-&gt;advance.y = d16_to_d6(info-&gt;glyph-&gt;advance.y);
         FT_Glyph_Get_CBox(info-&gt;glyph, FT_GLYPH_BBOX_SUBPIXELS, &amp;info-&gt;bbox);
 
-        if (render_priv-&gt;state.border_x &gt; 0 ||
-            render_priv-&gt;state.border_y &gt; 0) {
+        if (render_priv-&gt;state.style-&gt;BorderStyle == 3 &amp;&amp;
+            (render_priv-&gt;state.border_x &gt; 0||
+             render_priv-&gt;state.border_y &gt; 0)) {
+            FT_Glyph_Copy(info-&gt;glyph, &amp;info-&gt;outline_glyph);
+            draw_opaque_box(render_priv, symbol, info-&gt;outline_glyph,
+                            double_to_d6(render_priv-&gt;state.border_x *
+                                         render_priv-&gt;border_scale),
+                            double_to_d6(render_priv-&gt;state.border_y *
+                                         render_priv-&gt;border_scale));
+        } else if (render_priv-&gt;state.border_x &gt; 0 ||
+                   render_priv-&gt;state.border_y &gt; 0) {
 
             FT_Glyph_Copy(info-&gt;glyph, &amp;info-&gt;outline_glyph);
             stroke_outline_glyph(render_priv,
@@ -2222,7 +1186,8 @@
 
 static void transform_3d(FT_Vector shift, FT_Glyph *glyph,
                          FT_Glyph *glyph2, double frx, double fry,
-                         double frz, double fax, double fay, double scale);
+                         double frz, double fax, double fay, double scale,
+                         int yshift);
 
 /**
  * \brief Get bitmaps for a glyph
@@ -2233,10 +1198,10 @@
  * They are returned in info-&gt;bm (glyph), info-&gt;bm_o (outline) and info-&gt;bm_s (shadow).
  */
 static void
-get_bitmap_glyph(ass_renderer_t *render_priv, glyph_info_t *info)
+get_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info)
 {
-    bitmap_hash_val_t *val;
-    bitmap_hash_key_t *key = &amp;info-&gt;hash_key;
+    BitmapHashValue *val;
+    BitmapHashKey *key = &amp;info-&gt;hash_key;
 
     val = cache_find_bitmap(render_priv-&gt;cache.bitmap_cache, key);
 
@@ -2246,17 +1211,22 @@
         info-&gt;bm_s = val-&gt;bm_s;
     } else {
         FT_Vector shift;
-        bitmap_hash_val_t hash_val;
+        BitmapHashValue hash_val;
         int error;
+        double fax_scaled, fay_scaled;
         info-&gt;bm = info-&gt;bm_o = info-&gt;bm_s = 0;
-        if (info-&gt;glyph &amp;&amp; info-&gt;symbol != '\n' &amp;&amp; info-&gt;symbol != 0) {
+        if (info-&gt;glyph &amp;&amp; info-&gt;symbol != '\n' &amp;&amp; info-&gt;symbol != 0
+            &amp;&amp; !info-&gt;skip) {
             // calculating rotation shift vector (from rotation origin to the glyph basepoint)
             shift.x = info-&gt;hash_key.shift_x;
             shift.y = info-&gt;hash_key.shift_y;
+            fax_scaled = info-&gt;fax * render_priv-&gt;font_scale_x *
+                         render_priv-&gt;state.scale_x;
+            fay_scaled = info-&gt;fay * render_priv-&gt;state.scale_y;
             // apply rotation
             transform_3d(shift, &amp;info-&gt;glyph, &amp;info-&gt;outline_glyph,
-                         info-&gt;frx, info-&gt;fry, info-&gt;frz, info-&gt;fax,
-                         info-&gt;fay, render_priv-&gt;font_scale);
+                         info-&gt;frx, info-&gt;fry, info-&gt;frz, fax_scaled,
+                         fay_scaled, render_priv-&gt;font_scale, info-&gt;asc);
 
             // subpixel shift
             if (info-&gt;glyph)
@@ -2277,7 +1247,8 @@
                                     &amp;info-&gt;bm, &amp;info-&gt;bm_o,
                                     &amp;info-&gt;bm_s, info-&gt;be,
                                     info-&gt;blur * render_priv-&gt;border_scale,
-                                    info-&gt;hash_key.shadow_offset);
+                                    info-&gt;hash_key.shadow_offset,
+                                    info-&gt;hash_key.border_style);
             if (error)
                 info-&gt;symbol = 0;
 
@@ -2304,12 +1275,12 @@
  *   lines[].asc
  *   lines[].desc
  */
-static void measure_text(ass_renderer_t *render_priv)
+static void measure_text(ASS_Renderer *render_priv)
 {
-    text_info_t *text_info = &amp;render_priv-&gt;text_info;
+    TextInfo *text_info = &amp;render_priv-&gt;text_info;
     int cur_line = 0;
     double max_asc = 0., max_desc = 0.;
-    glyph_info_t *last = NULL;
+    GlyphInfo *last = NULL;
     int i;
     int empty_line = 1;
     text_info-&gt;height = 0.;
@@ -2328,7 +1299,7 @@
         } else
             empty_line = 0;
         if (i &lt; text_info-&gt;length) {
-            glyph_info_t *cur = text_info-&gt;glyphs + i;
+            GlyphInfo *cur = text_info-&gt;glyphs + i;
             if (d6_to_double(cur-&gt;asc) &gt; max_asc)
                 max_asc = d6_to_double(cur-&gt;asc);
             if (d6_to_double(cur-&gt;desc) &gt; max_desc)
@@ -2343,6 +1314,61 @@
 }
 
 /**
+ * Mark extra whitespace for later removal.
+ */
+#define IS_WHITESPACE(x) ((x-&gt;symbol == ' ' || x-&gt;symbol == '\n') \
+                          &amp;&amp; !x-&gt;linebreak)
+static void trim_whitespace(ASS_Renderer *render_priv)
+{
+    int i, j;
+    GlyphInfo *cur;
+    TextInfo *ti = &amp;render_priv-&gt;text_info;
+
+    // Mark trailing spaces
+    i = ti-&gt;length - 1;
+    cur = ti-&gt;glyphs + i;
+    while (i &amp;&amp; IS_WHITESPACE(cur)) {
+        cur-&gt;skip++;
+        cur = ti-&gt;glyphs + --i;
+    }
+
+    // Mark leading whitespace
+    i = 0;
+    cur = ti-&gt;glyphs;
+    while (i &lt; ti-&gt;length &amp;&amp; IS_WHITESPACE(cur)) {
+        cur-&gt;skip++;
+        cur = ti-&gt;glyphs + ++i;
+    }
+
+    // Mark all extraneous whitespace inbetween
+    for (i = 0; i &lt; ti-&gt;length; ++i) {
+        cur = ti-&gt;glyphs + i;
+        if (cur-&gt;linebreak) {
+            // Mark whitespace before
+            j = i - 1;
+            cur = ti-&gt;glyphs + j;
+            while (j &amp;&amp; IS_WHITESPACE(cur)) {
+                cur-&gt;skip++;
+                cur = ti-&gt;glyphs + --j;
+            }
+            // A break itself can contain a whitespace, too
+            cur = ti-&gt;glyphs + i;
+            if (cur-&gt;symbol == ' ')
+                cur-&gt;skip++;
+            // Mark whitespace after
+            j = i + 1;
+            cur = ti-&gt;glyphs + j;
+            while (j &lt; ti-&gt;length &amp;&amp; IS_WHITESPACE(cur)) {
+                cur-&gt;skip++;
+                cur = ti-&gt;glyphs + ++j;
+            }
+            i = j - 1;
+        }
+    }
+}
+#undef IS_WHITESPACE
+
+/**
  * \brief rearrange text between lines
  * \param max_text_width maximal text line width in pixels
  * The algo is similar to the one in libvo/sub.c:
@@ -2350,19 +1376,21 @@
  * 2. Try moving words from the end of a line to the beginning of the next one while it reduces
  * the difference in lengths between this two lines.
  * The result may not be optimal, but usually is good enough.
+ *
+ * FIXME: implement style 0 and 3 correctly, add support for style 1
  */
 static void
-wrap_lines_smart(ass_renderer_t *render_priv, double max_text_width)
+wrap_lines_smart(ASS_Renderer *render_priv, double max_text_width)
 {
     int i;
-    glyph_info_t *cur, *s1, *e1, *s2, *s3, *w;
+    GlyphInfo *cur, *s1, *e1, *s2, *s3, *w;
     int last_space;
     int break_type;
     int exit;
     double pen_shift_x;
     double pen_shift_y;
     int cur_line;
-    text_info_t *text_info = &amp;render_priv-&gt;text_info;
+    TextInfo *text_info = &amp;render_priv-&gt;text_info;
 
     last_space = -1;
     text_info-&gt;n_lines = 1;
@@ -2384,7 +1412,7 @@
         }
 
         if ((len &gt;= max_text_width)
-            &amp;&amp; (render_priv-&gt;track-&gt;WrapStyle != 2)) {
+            &amp;&amp; (render_priv-&gt;state.wrap_style != 2)) {
             break_type = 1;
             break_at = last_space;
             if (break_at == -1)
@@ -2404,7 +1432,7 @@
                 // Raise maximum number of lines
                 text_info-&gt;max_lines *= 2;
                 text_info-&gt;lines = realloc(text_info-&gt;lines,
-                                           sizeof(line_info_t) *
+                                           sizeof(LineInfo) *
                                            text_info-&gt;max_lines);
             }
             if (lead &lt; text_info-&gt;length)
@@ -2425,7 +1453,7 @@
     }
 #define DIFF(x,y) (((x) &lt; (y)) ? (y - x) : (x - y))
     exit = 0;
-    while (!exit) {
+    while (!exit &amp;&amp; render_priv-&gt;state.wrap_style != 1) {
         exit = 1;
         w = s3 = text_info-&gt;glyphs;
         s1 = s2 = 0;
@@ -2479,13 +1507,23 @@
 #undef DIFF
 
     measure_text(render_priv);
+    trim_whitespace(render_priv);
 
     pen_shift_x = 0.;
     pen_shift_y = 0.;
     cur_line = 1;
+
+    i = 0;
+    cur = text_info-&gt;glyphs + i;
+    while (i &lt; text_info-&gt;length &amp;&amp; cur-&gt;skip)
+        cur = text_info-&gt;glyphs + ++i;
+    pen_shift_x = d6_to_double(-cur-&gt;pos.x);
+
     for (i = 0; i &lt; text_info-&gt;length; ++i) {
         cur = text_info-&gt;glyphs + i;
         if (cur-&gt;linebreak) {
+            while (i &lt; text_info-&gt;length &amp;&amp; cur-&gt;skip &amp;&amp; cur-&gt;symbol != '\n')
+                cur = text_info-&gt;glyphs + ++i;
             double height =
                 text_info-&gt;lines[cur_line - 1].desc +
                 text_info-&gt;lines[cur_line].asc;
@@ -2512,11 +1550,11 @@
  * 2. sets effect_timing for all glyphs to x coordinate of the border line between the left and right karaoke parts
  * (left part is filled with PrimaryColour, right one - with SecondaryColour).
  */
-static void process_karaoke_effects(ass_renderer_t *render_priv)
+static void process_karaoke_effects(ASS_Renderer *render_priv)
 {
-    glyph_info_t *cur, *cur2;
-    glyph_info_t *s1, *e1;      // start and end of the current word
-    glyph_info_t *s2;           // start of the next word
+    GlyphInfo *cur, *cur2;
+    GlyphInfo *s1, *e1;      // start and end of the current word
+    GlyphInfo *s2;           // start of the next word
     int i;
     int timing;                 // current timing
     int tm_start, tm_end;       // timings at start and end of the current word
@@ -2577,7 +1615,7 @@
  * \param alignment alignment
  * \param bx, by out: base point coordinates
  */
-static void get_base_point(double_bbox_t *bbox, int alignment, double *bx, double *by)
+static void get_base_point(DBBox *bbox, int alignment, double *bx, double *by)
 {
     const int halign = alignment &amp; 3;
     const int valign = alignment &amp; 12;
@@ -2613,9 +1651,9 @@
  * onto the screen plane.
  */
 static void
-transform_3d_points(FT_Vector shift, FT_Glyph glyph, double frx,
-                    double fry, double frz, double fax, double fay,
-                    double scale)
+transform_3d_points(FT_Vector shift, FT_Glyph glyph, double frx, double fry,
+                    double frz, double fax, double fay, double scale,
+                    int yshift)
 {
     double sx = sin(frx);
     double sy = sin(fry);
@@ -2630,7 +1668,7 @@
 
     dist = 20000 * scale;
     for (i = 0; i &lt; outline-&gt;n_points; i++) {
-        x = (double) p[i].x + shift.x + (-fax * p[i].y);
+        x = (double) p[i].x + shift.x + (fax * (yshift - p[i].y));
         y = (double) p[i].y + shift.y + (-fay * p[i].x);
         z = 0.;
 
@@ -2668,18 +1706,18 @@
 static void
 transform_3d(FT_Vector shift, FT_Glyph *glyph, FT_Glyph *glyph2,
              double frx, double fry, double frz, double fax, double fay,
-             double scale)
+             double scale, int yshift)
 {
     frx = -frx;
     frz = -frz;
     if (frx != 0. || fry != 0. || frz != 0. || fax != 0. || fay != 0.) {
         if (glyph &amp;&amp; *glyph)
             transform_3d_points(shift, *glyph, frx, fry, frz,
-                                fax, fay, scale);
+                                fax, fay, scale, yshift);
 
         if (glyph2 &amp;&amp; *glyph2)
             transform_3d_points(shift, *glyph2, frx, fry, frz,
-                                fax, fay, scale);
+                                fax, fay, scale, yshift);
     }
 }
 
@@ -2688,26 +1726,27 @@
  * \brief Main ass rendering function, glues everything together
  * \param event event to render
  * \param event_images struct containing resulting images, will also be initialized
- * Process event, appending resulting ass_image_t's to images_root.
+ * Process event, appending resulting ASS_Image's to images_root.
  */
 static int
-ass_render_event(ass_renderer_t *render_priv, ass_event_t *event,
-                 event_images_t *event_images)
+ass_render_event(ASS_Renderer *render_priv, ASS_Event *event,
+                 EventImages *event_images)
 {
     char *p;
     FT_UInt previous;
     FT_UInt num_glyphs;
     FT_Vector pen;
     unsigned code;
-    double_bbox_t bbox;
+    DBBox bbox;
     int i, j;
     int MarginL, MarginR, MarginV;
     int last_break;
     int alignment, halign, valign;
+    int kern = render_priv-&gt;track-&gt;Kerning;
     double device_x = 0;
     double device_y = 0;
-    text_info_t *text_info = &amp;render_priv-&gt;text_info;
-    ass_drawing_t *drawing;
+    TextInfo *text_info = &amp;render_priv-&gt;text_info;
+    ASS_Drawing *drawing;
 
     if (event-&gt;Style &gt;= render_priv-&gt;track-&gt;n_styles) {
         ass_msg(render_priv-&gt;library, MSGL_WARN, &quot;No style found&quot;);
@@ -2763,17 +1802,19 @@
             text_info-&gt;max_glyphs *= 2;
             text_info-&gt;glyphs =
                 realloc(text_info-&gt;glyphs,
-                        sizeof(glyph_info_t) * text_info-&gt;max_glyphs);
+                        sizeof(GlyphInfo) * text_info-&gt;max_glyphs);
         }
 
         // Add kerning to pen
-        if (previous &amp;&amp; code &amp;&amp; !drawing-&gt;hash) {
+        if (kern &amp;&amp; previous &amp;&amp; code &amp;&amp; !drawing-&gt;hash) {
             FT_Vector delta;
             delta =
                 ass_font_get_kerning(render_priv-&gt;state.font, previous,
                                      code);
-            pen.x += delta.x * render_priv-&gt;state.scale_x;
-            pen.y += delta.y * render_priv-&gt;state.scale_y;
+            pen.x += delta.x * render_priv-&gt;state.scale_x
+                     * render_priv-&gt;font_scale_x;
+            pen.y += delta.y * render_priv-&gt;state.scale_y
+                     * render_priv-&gt;font_scale_x;
         }
 
         ass_font_set_transform(render_priv-&gt;state.font,
@@ -2784,14 +1825,30 @@
         get_outline_glyph(render_priv, code,
                           text_info-&gt;glyphs + text_info-&gt;length, drawing);
 
+        // Add additional space after italic to non-italic style changes
+        if (text_info-&gt;length &amp;&amp;
+            text_info-&gt;glyphs[text_info-&gt;length - 1].hash_key.italic &amp;&amp;
+            !render_priv-&gt;state.italic) {
+            int back = text_info-&gt;length - 1;
+            GlyphInfo *og = &amp;text_info-&gt;glyphs[back];
+            while (back &amp;&amp; og-&gt;bbox.xMax - og-&gt;bbox.xMin == 0
+                   &amp;&amp; og-&gt;hash_key.italic)
+                og = &amp;text_info-&gt;glyphs[--back];
+            if (og-&gt;bbox.xMax &gt; og-&gt;advance.x) {
+                // The FreeType oblique slants by 6/16
+                pen.x += og-&gt;bbox.yMax * 0.375;
+            }
+        }
+
         text_info-&gt;glyphs[text_info-&gt;length].pos.x = pen.x;
         text_info-&gt;glyphs[text_info-&gt;length].pos.y = pen.y;
 
         pen.x += text_info-&gt;glyphs[text_info-&gt;length].advance.x;
         pen.x += double_to_d6(render_priv-&gt;state.hspacing *
-                              render_priv-&gt;font_scale);
+                              render_priv-&gt;font_scale
+                              * render_priv-&gt;state.scale_x);
         pen.y += text_info-&gt;glyphs[text_info-&gt;length].advance.y;
-        pen.y += render_priv-&gt;state.fay *
+        pen.y += (render_priv-&gt;state.fay * render_priv-&gt;state.scale_y) *
                  text_info-&gt;glyphs[text_info-&gt;length].advance.x;
 
         previous = code;
@@ -2850,29 +1907,31 @@
                 drawing-&gt;hash;
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.ch = code;
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.outline.x =
-            render_priv-&gt;state.border_x * 0xFFFF;
+            double_to_d16(render_priv-&gt;state.border_x);
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.outline.y =
-            render_priv-&gt;state.border_y * 0xFFFF;
+            double_to_d16(render_priv-&gt;state.border_y);
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.scale_x =
-            render_priv-&gt;state.scale_x * 0xFFFF;
+            double_to_d16(render_priv-&gt;state.scale_x);
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.scale_y =
-            render_priv-&gt;state.scale_y * 0xFFFF;
+            double_to_d16(render_priv-&gt;state.scale_y);
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.frx =
-            render_priv-&gt;state.frx * 0xFFFF;
+            rot_key(render_priv-&gt;state.frx);
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.fry =
-            render_priv-&gt;state.fry * 0xFFFF;
+            rot_key(render_priv-&gt;state.fry);
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.frz =
-            render_priv-&gt;state.frz * 0xFFFF;
+            rot_key(render_priv-&gt;state.frz);
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.fax =
-            render_priv-&gt;state.fax * 0xFFFF;
+            double_to_d16(render_priv-&gt;state.fax);
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.fay =
-            render_priv-&gt;state.fay * 0xFFFF;
+            double_to_d16(render_priv-&gt;state.fay);
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.advance.x = pen.x;
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.advance.y = pen.y;
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.be =
             render_priv-&gt;state.be;
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.blur =
             render_priv-&gt;state.blur;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.border_style =
+            render_priv-&gt;state.style-&gt;BorderStyle;
         text_info-&gt;glyphs[text_info-&gt;length].hash_key.shadow_offset.x =
             double_to_d6(
                 render_priv-&gt;state.shadow_x * render_priv-&gt;border_scale -
@@ -2883,6 +1942,8 @@
                 render_priv-&gt;state.shadow_y * render_priv-&gt;border_scale -
                 (int) (render_priv-&gt;state.shadow_y *
                 render_priv-&gt;border_scale));
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.flags =
+            render_priv-&gt;state.flags;
 
         text_info-&gt;length++;
 
@@ -2942,13 +2003,17 @@
             if ((i == text_info-&gt;length)
                 || text_info-&gt;glyphs[i].linebreak) {
                 double width, shift = 0;
-                glyph_info_t *first_glyph =
+                GlyphInfo *first_glyph =
                     text_info-&gt;glyphs + last_break + 1;
-                glyph_info_t *last_glyph = text_info-&gt;glyphs + i - 1;
+                GlyphInfo *last_glyph = text_info-&gt;glyphs + i - 1;
 
+                while (first_glyph &lt; last_glyph &amp;&amp; first_glyph-&gt;skip)
+                    first_glyph++;
+
                 while ((last_glyph &gt; first_glyph)
                        &amp;&amp; ((last_glyph-&gt;symbol == '\n')
-                           || (last_glyph-&gt;symbol == 0)))
+                           || (last_glyph-&gt;symbol == 0)
+                           || (last_glyph-&gt;skip)))
                     last_glyph--;
 
                 width = d6_to_double(
@@ -3076,7 +2141,7 @@
     }
     // calculate rotation parameters
     {
-        double_vector_t center;
+        DVector center;
 
         if (render_priv-&gt;state.have_origin) {
             center.x = x2scr(render_priv, render_priv-&gt;state.org_x);
@@ -3089,7 +2154,7 @@
         }
 
         for (i = 0; i &lt; text_info-&gt;length; ++i) {
-            glyph_info_t *info = text_info-&gt;glyphs + i;
+            GlyphInfo *info = text_info-&gt;glyphs + i;
 
             if (info-&gt;hash_key.frx || info-&gt;hash_key.fry
                 || info-&gt;hash_key.frz || info-&gt;hash_key.fax
@@ -3106,7 +2171,7 @@
 
     // convert glyphs to bitmaps
     for (i = 0; i &lt; text_info-&gt;length; ++i) {
-        glyph_info_t *g = text_info-&gt;glyphs + i;
+        GlyphInfo *g = text_info-&gt;glyphs + i;
         g-&gt;hash_key.advance.x =
             double_to_d6(device_x - (int) device_x +
             d6_to_double(g-&gt;pos.x &amp; SUBPIXEL_MASK)) &amp; ~SUBPIXEL_ACCURACY;
@@ -3119,6 +2184,8 @@
     memset(event_images, 0, sizeof(*event_images));
     event_images-&gt;top = device_y - text_info-&gt;lines[0].asc;
     event_images-&gt;height = text_info-&gt;height;
+    event_images-&gt;left = device_x + bbox.xMin + 0.5;
+    event_images-&gt;width = bbox.xMax - bbox.xMin + 0.5;
     event_images-&gt;detect_collisions = render_priv-&gt;state.detect_collisions;
     event_images-&gt;shift_direction = (valign == VALIGN_TOP) ? 1 : -1;
     event_images-&gt;event = event;
@@ -3133,16 +2200,16 @@
  * \brief deallocate image list
  * \param img list pointer
  */
-static void ass_free_images(ass_image_t *img)
+static void ass_free_images(ASS_Image *img)
 {
     while (img) {
-        ass_image_t *next = img-&gt;next;
+        ASS_Image *next = img-&gt;next;
         free(img);
         img = next;
     }
 }
 
-static void ass_reconfigure(ass_renderer_t *priv)
+static void ass_reconfigure(ASS_Renderer *priv)
 {
     priv-&gt;render_id++;
     priv-&gt;cache.glyph_cache =
@@ -3155,20 +2222,20 @@
     priv-&gt;prev_images_root = 0;
 }
 
-void ass_set_frame_size(ass_renderer_t *priv, int w, int h)
+void ass_set_frame_size(ASS_Renderer *priv, int w, int h)
 {
     if (priv-&gt;settings.frame_width != w || priv-&gt;settings.frame_height != h) {
         priv-&gt;settings.frame_width = w;
         priv-&gt;settings.frame_height = h;
         if (priv-&gt;settings.aspect == 0.) {
             priv-&gt;settings.aspect = ((double) w) / h;
-            priv-&gt;settings.pixel_ratio = ((double) w) / h;
+            priv-&gt;settings.storage_aspect = ((double) w) / h;
         }
         ass_reconfigure(priv);
     }
 }
 
-void ass_set_margins(ass_renderer_t *priv, int t, int b, int l, int r)
+void ass_set_margins(ASS_Renderer *priv, int t, int b, int l, int r)
 {
     if (priv-&gt;settings.left_margin != l ||
         priv-&gt;settings.right_margin != r ||
@@ -3182,21 +2249,21 @@
     }
 }
 
-void ass_set_use_margins(ass_renderer_t *priv, int use)
+void ass_set_use_margins(ASS_Renderer *priv, int use)
 {
     priv-&gt;settings.use_margins = use;
 }
 
-void ass_set_aspect_ratio(ass_renderer_t *priv, double ar, double par)
+void ass_set_aspect_ratio(ASS_Renderer *priv, double dar, double sar)
 {
-    if (priv-&gt;settings.aspect != ar || priv-&gt;settings.pixel_ratio != par) {
-        priv-&gt;settings.aspect = ar;
-        priv-&gt;settings.pixel_ratio = par;
+    if (priv-&gt;settings.aspect != dar || priv-&gt;settings.storage_aspect != sar) {
+        priv-&gt;settings.aspect = dar;
+        priv-&gt;settings.storage_aspect = sar;
         ass_reconfigure(priv);
     }
 }
 
-void ass_set_font_scale(ass_renderer_t *priv, double font_scale)
+void ass_set_font_scale(ASS_Renderer *priv, double font_scale)
 {
     if (priv-&gt;settings.font_size_coeff != font_scale) {
         priv-&gt;settings.font_size_coeff = font_scale;
@@ -3204,7 +2271,7 @@
     }
 }
 
-void ass_set_hinting(ass_renderer_t *priv, ass_hinting_t ht)
+void ass_set_hinting(ASS_Renderer *priv, ASS_Hinting ht)
 {
     if (priv-&gt;settings.hinting != ht) {
         priv-&gt;settings.hinting = ht;
@@ -3212,12 +2279,12 @@
     }
 }
 
-void ass_set_line_spacing(ass_renderer_t *priv, double line_spacing)
+void ass_set_line_spacing(ASS_Renderer *priv, double line_spacing)
 {
     priv-&gt;settings.line_spacing = line_spacing;
 }
 
-void ass_set_fonts(ass_renderer_t *priv, const char *default_font,
+void ass_set_fonts(ASS_Renderer *priv, const char *default_font,
                    const char *default_family, int fc, const char *config,
                    int update)
 {
@@ -3234,7 +2301,7 @@
                         default_font, fc, config, update);
 }
 
-int ass_fonts_update(ass_renderer_t *render_priv)
+int ass_fonts_update(ASS_Renderer *render_priv)
 {
     return fontconfig_update(render_priv-&gt;fontconfig_priv);
 }
@@ -3243,11 +2310,11 @@
  * \brief Start a new frame
  */
 static int
-ass_start_frame(ass_renderer_t *render_priv, ass_track_t *track,
+ass_start_frame(ASS_Renderer *render_priv, ASS_Track *track,
                 long long now)
 {
-    ass_settings_t *settings_priv = &amp;render_priv-&gt;settings;
-    cache_store_t *cache = &amp;render_priv-&gt;cache;
+    ASS_Settings *settings_priv = &amp;render_priv-&gt;settings;
+    CacheStore *cache = &amp;render_priv-&gt;cache;
 
     if (!render_priv-&gt;settings.frame_width
         &amp;&amp; !render_priv-&gt;settings.frame_height)
@@ -3293,7 +2360,7 @@
 
     // PAR correction
     render_priv-&gt;font_scale_x = render_priv-&gt;settings.aspect /
-                                render_priv-&gt;settings.pixel_ratio;
+                                render_priv-&gt;settings.storage_aspect;
 
     render_priv-&gt;prev_images_root = render_priv-&gt;images_root;
     render_priv-&gt;images_root = 0;
@@ -3321,8 +2388,8 @@
 
 static int cmp_event_layer(const void *p1, const void *p2)
 {
-    ass_event_t *e1 = ((event_images_t *) p1)-&gt;event;
-    ass_event_t *e2 = ((event_images_t *) p2)-&gt;event;
+    ASS_Event *e1 = ((EventImages *) p1)-&gt;event;
+    ASS_Event *e2 = ((EventImages *) p2)-&gt;event;
     if (e1-&gt;Layer &lt; e2-&gt;Layer)
         return -1;
     if (e1-&gt;Layer &gt; e2-&gt;Layer)
@@ -3334,41 +2401,36 @@
     return 0;
 }
 
-#define MAX_EVENTS 100
-
-static render_priv_t *get_render_priv(ass_renderer_t *render_priv,
-                                      ass_event_t *event)
+static ASS_RenderPriv *get_render_priv(ASS_Renderer *render_priv,
+                                       ASS_Event *event)
 {
     if (!event-&gt;render_priv)
-        event-&gt;render_priv = calloc(1, sizeof(render_priv_t));
-    // FIXME: check render_id
+        event-&gt;render_priv = calloc(1, sizeof(ASS_RenderPriv));
     if (render_priv-&gt;render_id != event-&gt;render_priv-&gt;render_id) {
-        memset(event-&gt;render_priv, 0, sizeof(render_priv_t));
+        memset(event-&gt;render_priv, 0, sizeof(ASS_RenderPriv));
         event-&gt;render_priv-&gt;render_id = render_priv-&gt;render_id;
     }
+
     return event-&gt;render_priv;
 }
 
-typedef struct {
-    int a, b;                   // top and height
-} segment_t;
-
-static int overlap(segment_t *s1, segment_t *s2)
+static int overlap(Segment *s1, Segment *s2)
 {
-    if (s1-&gt;a &gt;= s2-&gt;b || s2-&gt;a &gt;= s1-&gt;b)
+    if (s1-&gt;a &gt;= s2-&gt;b || s2-&gt;a &gt;= s1-&gt;b ||
+        s1-&gt;ha &gt;= s2-&gt;hb || s2-&gt;ha &gt;= s1-&gt;hb)
         return 0;
     return 1;
 }
 
 static int cmp_segment(const void *p1, const void *p2)
 {
-    return ((segment_t *) p1)-&gt;a - ((segment_t *) p2)-&gt;a;
+    return ((Segment *) p1)-&gt;a - ((Segment *) p2)-&gt;a;
 }
 
 static void
-shift_event(ass_renderer_t *render_priv, event_images_t *ei, int shift)
+shift_event(ASS_Renderer *render_priv, EventImages *ei, int shift)
 {
-    ass_image_t *cur = ei-&gt;imgs;
+    ASS_Image *cur = ei-&gt;imgs;
     while (cur) {
         cur-&gt;dst_y += shift;
         // clip top and bottom
@@ -3393,90 +2455,107 @@
 
 // dir: 1 - move down
 //      -1 - move up
-static int fit_segment(segment_t *s, segment_t *fixed, int *cnt, int dir)
+static int fit_segment(Segment *s, Segment *fixed, int *cnt, int dir)
 {
     int i;
     int shift = 0;
 
     if (dir == 1)               // move down
         for (i = 0; i &lt; *cnt; ++i) {
-            if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
+            if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b ||
+                s-&gt;hb &lt;= fixed[i].ha || s-&gt;ha &gt;= fixed[i].hb)
                 continue;
             shift = fixed[i].b - s-&gt;a;
     } else                      // dir == -1, move up
         for (i = *cnt - 1; i &gt;= 0; --i) {
-            if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
+            if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b ||
+                s-&gt;hb &lt;= fixed[i].ha || s-&gt;ha &gt;= fixed[i].hb)
                 continue;
             shift = fixed[i].a - s-&gt;b;
         }
 
     fixed[*cnt].a = s-&gt;a + shift;
     fixed[*cnt].b = s-&gt;b + shift;
+    fixed[*cnt].ha = s-&gt;ha;
+    fixed[*cnt].hb = s-&gt;hb;
     (*cnt)++;
-    qsort(fixed, *cnt, sizeof(segment_t), cmp_segment);
+    qsort(fixed, *cnt, sizeof(Segment), cmp_segment);
 
     return shift;
 }
 
 static void
-fix_collisions(ass_renderer_t *render_priv, event_images_t *imgs, int cnt)
+fix_collisions(ASS_Renderer *render_priv, EventImages *imgs, int cnt)
 {
-    segment_t used[MAX_EVENTS];
+    Segment *used = malloc(cnt * sizeof(*used));
     int cnt_used = 0;
     int i, j;
 
     // fill used[] with fixed events
     for (i = 0; i &lt; cnt; ++i) {
-        render_priv_t *priv;
+        ASS_RenderPriv *priv;
         if (!imgs[i].detect_collisions)
             continue;
         priv = get_render_priv(render_priv, imgs[i].event);
         if (priv-&gt;height &gt; 0) { // it's a fixed event
-            segment_t s;
+            Segment s;
             s.a = priv-&gt;top;
             s.b = priv-&gt;top + priv-&gt;height;
+            s.ha = priv-&gt;left;
+            s.hb = priv-&gt;left + priv-&gt;width;
             if (priv-&gt;height != imgs[i].height) {       // no, it's not
                 ass_msg(render_priv-&gt;library, MSGL_WARN,
                         &quot;Warning! Event height has changed&quot;);
                 priv-&gt;top = 0;
                 priv-&gt;height = 0;
+                priv-&gt;left = 0;
+                priv-&gt;width = 0;
             }
             for (j = 0; j &lt; cnt_used; ++j)
                 if (overlap(&amp;s, used + j)) {    // no, it's not
                     priv-&gt;top = 0;
                     priv-&gt;height = 0;
+                    priv-&gt;left = 0;
+                    priv-&gt;width = 0;
                 }
             if (priv-&gt;height &gt; 0) {     // still a fixed event
                 used[cnt_used].a = priv-&gt;top;
                 used[cnt_used].b = priv-&gt;top + priv-&gt;height;
+                used[cnt_used].ha = priv-&gt;left;
+                used[cnt_used].hb = priv-&gt;left + priv-&gt;width;
                 cnt_used++;
                 shift_event(render_priv, imgs + i, priv-&gt;top - imgs[i].top);
             }
         }
     }
-    qsort(used, cnt_used, sizeof(segment_t), cmp_segment);
+    qsort(used, cnt_used, sizeof(Segment), cmp_segment);
 
     // try to fit other events in free spaces
     for (i = 0; i &lt; cnt; ++i) {
-        render_priv_t *priv;
+        ASS_RenderPriv *priv;
         if (!imgs[i].detect_collisions)
             continue;
         priv = get_render_priv(render_priv, imgs[i].event);
         if (priv-&gt;height == 0) {        // not a fixed event
             int shift;
-            segment_t s;
+            Segment s;
             s.a = imgs[i].top;
             s.b = imgs[i].top + imgs[i].height;
-            shift =
-                fit_segment(&amp;s, used, &amp;cnt_used, imgs[i].shift_direction);
+            s.ha = imgs[i].left;
+            s.hb = imgs[i].left + imgs[i].width;
+            shift = fit_segment(&amp;s, used, &amp;cnt_used, imgs[i].shift_direction);
             if (shift)
                 shift_event(render_priv, imgs + i, shift);
             // make it fixed
             priv-&gt;top = imgs[i].top;
             priv-&gt;height = imgs[i].height;
+            priv-&gt;left = imgs[i].left;
+            priv-&gt;width = imgs[i].width;
         }
 
     }
+
+    free(used);
 }
 
 /**
@@ -3485,7 +2564,7 @@
  * \param i2 second image
  * \return 0 if identical, 1 if different positions, 2 if different content
  */
-static int ass_image_compare(ass_image_t *i1, ass_image_t *i2)
+static int ass_image_compare(ASS_Image *i1, ASS_Image *i2)
 {
     if (i1-&gt;w != i2-&gt;w)
         return 2;
@@ -3509,16 +2588,16 @@
  * \param priv library handle
  * \return 0 if identical, 1 if different positions, 2 if different content
  */
-static int ass_detect_change(ass_renderer_t *priv)
+static int ass_detect_change(ASS_Renderer *priv)
 {
-    ass_image_t *img, *img2;
+    ASS_Image *img, *img2;
     int diff;
 
     img = priv-&gt;prev_images_root;
     img2 = priv-&gt;images_root;
     diff = 0;
     while (img &amp;&amp; diff &lt; 2) {
-        ass_image_t *next, *next2;
+        ASS_Image *next, *next2;
         next = img-&gt;next;
         if (img2) {
             int d = ass_image_compare(img, img2);
@@ -3550,12 +2629,12 @@
  *        0 if identical, 1 if different positions, 2 if different content.
  *        Can be NULL, in that case no detection is performed.
  */
-ass_image_t *ass_render_frame(ass_renderer_t *priv, ass_track_t *track,
-                              long long now, int *detect_change)
+ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
+                            long long now, int *detect_change)
 {
     int i, cnt, rc;
-    event_images_t *last;
-    ass_image_t **tail;
+    EventImages *last;
+    ASS_Image **tail;
 
     // init frame
     rc = ass_start_frame(priv, track, now);
@@ -3565,14 +2644,14 @@
     // render events separately
     cnt = 0;
     for (i = 0; i &lt; track-&gt;n_events; ++i) {
-        ass_event_t *event = track-&gt;events + i;
+        ASS_Event *event = track-&gt;events + i;
         if ((event-&gt;Start &lt;= now)
             &amp;&amp; (now &lt; (event-&gt;Start + event-&gt;Duration))) {
             if (cnt &gt;= priv-&gt;eimg_size) {
                 priv-&gt;eimg_size += 100;
                 priv-&gt;eimg =
                     realloc(priv-&gt;eimg,
-                            priv-&gt;eimg_size * sizeof(event_images_t));
+                            priv-&gt;eimg_size * sizeof(EventImages));
             }
             rc = ass_render_event(priv, event, priv-&gt;eimg + cnt);
             if (!rc)
@@ -3581,7 +2660,7 @@
     }
 
     // sort by layer
-    qsort(priv-&gt;eimg, cnt, sizeof(event_images_t), cmp_event_layer);
+    qsort(priv-&gt;eimg, cnt, sizeof(EventImages), cmp_event_layer);
 
     // call fix_collisions for each group of events with the same layer
     last = priv-&gt;eimg;
@@ -3596,7 +2675,7 @@
     // concat lists
     tail = &amp;priv-&gt;images_root;
     for (i = 0; i &lt; cnt; ++i) {
-        ass_image_t *cur = priv-&gt;eimg[i].imgs;
+        ASS_Image *cur = priv-&gt;eimg[i].imgs;
         while (cur) {
             *tail = cur;
             tail = &amp;cur-&gt;next;

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ * Copyright (C) 2009 Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at geekmind.org</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_RENDER_H
+#define LIBASS_RENDER_H
+
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+#include FT_STROKER_H
+#include FT_GLYPH_H
+#include FT_SYNTHESIS_H
+
+#include &quot;ass.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_bitmap.h&quot;
+#include &quot;ass_cache.h&quot;
+#include &quot;ass_utils.h&quot;
+#include &quot;ass_fontconfig.h&quot;
+#include &quot;ass_library.h&quot;
+#include &quot;ass_drawing.h&quot;
+
+typedef struct {
+    double xMin;
+    double xMax;
+    double yMin;
+    double yMax;
+} DBBox;
+
+typedef struct {
+    double x;
+    double y;
+} DVector;
+
+typedef struct free_list {
+    void *object;
+    struct free_list *next;
+} FreeList;
+
+typedef struct {
+    int frame_width;
+    int frame_height;
+    double font_size_coeff;     // font size multiplier
+    double line_spacing;        // additional line spacing (in frame pixels)
+    int top_margin;             // height of top margin. Everything except toptitles is shifted down by top_margin.
+    int bottom_margin;          // height of bottom margin. (frame_height - top_margin - bottom_margin) is original video height.
+    int left_margin;
+    int right_margin;
+    int use_margins;            // 0 - place all subtitles inside original frame
+    // 1 - use margins for placing toptitles and subtitles
+    double aspect;              // frame aspect ratio, d_width / d_height.
+    double storage_aspect;      // pixel ratio of the source image
+    ASS_Hinting hinting;
+
+    char *default_font;
+    char *default_family;
+} ASS_Settings;
+
+// a rendered event
+typedef struct {
+    ASS_Image *imgs;
+    int top, height, left, width;
+    int detect_collisions;
+    int shift_direction;
+    ASS_Event *event;
+} EventImages;
+
+typedef enum {
+    EF_NONE = 0,
+    EF_KARAOKE,
+    EF_KARAOKE_KF,
+    EF_KARAOKE_KO
+} Effect;
+
+// describes a glyph
+// GlyphInfo and TextInfo are used for text centering and word-wrapping operations
+typedef struct {
+    unsigned symbol;
+    unsigned skip;              // skip glyph when layouting text
+    FT_Glyph glyph;
+    FT_Glyph outline_glyph;
+    Bitmap *bm;                 // glyph bitmap
+    Bitmap *bm_o;               // outline bitmap
+    Bitmap *bm_s;               // shadow bitmap
+    FT_BBox bbox;
+    FT_Vector pos;
+    char linebreak;             // the first (leading) glyph of some line ?
+    uint32_t c[4];              // colors
+    FT_Vector advance;          // 26.6
+    Effect effect_type;
+    int effect_timing;          // time duration of current karaoke word
+    // after process_karaoke_effects: distance in pixels from the glyph origin.
+    // part of the glyph to the left of it is displayed in a different color.
+    int effect_skip_timing;     // delay after the end of last karaoke word
+    int asc, desc;              // font max ascender and descender
+    int be;                     // blur edges
+    double blur;                // gaussian blur
+    double shadow_x;
+    double shadow_y;
+    double frx, fry, frz;       // rotation
+    double fax, fay;            // text shearing
+
+    BitmapHashKey hash_key;
+} GlyphInfo;
+
+typedef struct {
+    double asc, desc;
+} LineInfo;
+
+typedef struct {
+    GlyphInfo *glyphs;
+    int length;
+    LineInfo *lines;
+    int n_lines;
+    double height;
+    int max_glyphs;
+    int max_lines;
+} TextInfo;
+
+// Renderer state.
+// Values like current font face, color, screen position, clipping and so on are stored here.
+typedef struct {
+    ASS_Event *event;
+    ASS_Style *style;
+
+    ASS_Font *font;
+    char *font_path;
+    double font_size;
+    int flags;                  // decoration flags (underline/strike-through)
+
+    FT_Stroker stroker;
+    int alignment;              // alignment overrides go here; if zero, style value will be used
+    double frx, fry, frz;
+    double fax, fay;            // text shearing
+    enum {
+        EVENT_NORMAL,           // &quot;normal&quot; top-, sub- or mid- title
+        EVENT_POSITIONED,       // happens after pos(,), margins are ignored
+        EVENT_HSCROLL,          // &quot;Banner&quot; transition effect, text_width is unlimited
+        EVENT_VSCROLL           // &quot;Scroll up&quot;, &quot;Scroll down&quot; transition effects
+    } evt_type;
+    double pos_x, pos_y;        // position
+    double org_x, org_y;        // origin
+    char have_origin;           // origin is explicitly defined; if 0, get_base_point() is used
+    double scale_x, scale_y;
+    double hspacing;            // distance between letters, in pixels
+    double border_x;            // outline width
+    double border_y;
+    uint32_t c[4];              // colors(Primary, Secondary, so on) in RGBA
+    int clip_x0, clip_y0, clip_x1, clip_y1;
+    char clip_mode;             // 1 = iclip
+    char detect_collisions;
+    uint32_t fade;              // alpha from \fad
+    char be;                    // blur edges
+    double blur;                // gaussian blur
+    double shadow_x;
+    double shadow_y;
+    int drawing_mode;           // not implemented; when != 0 text is discarded, except for style override tags
+    ASS_Drawing *drawing;       // current drawing
+    ASS_Drawing *clip_drawing;  // clip vector
+    int clip_drawing_mode;      // 0 = regular clip, 1 = inverse clip
+
+    Effect effect_type;
+    int effect_timing;
+    int effect_skip_timing;
+
+    enum {
+        SCROLL_LR,              // left-to-right
+        SCROLL_RL,
+        SCROLL_TB,              // top-to-bottom
+        SCROLL_BT
+    } scroll_direction;         // for EVENT_HSCROLL, EVENT_VSCROLL
+    int scroll_shift;
+
+    // face properties
+    char *family;
+    unsigned bold;
+    unsigned italic;
+    int treat_family_as_pattern;
+    int wrap_style;
+} RenderContext;
+
+typedef struct {
+    Hashmap *font_cache;
+    Hashmap *glyph_cache;
+    Hashmap *bitmap_cache;
+    Hashmap *composite_cache;
+    size_t glyph_max;
+    size_t bitmap_max_size;
+} CacheStore;
+
+struct ass_renderer {
+    ASS_Library *library;
+    FT_Library ftlibrary;
+    FCInstance *fontconfig_priv;
+    ASS_Settings settings;
+    int render_id;
+    ASS_SynthPriv *synth_priv;
+
+    ASS_Image *images_root;     // rendering result is stored here
+    ASS_Image *prev_images_root;
+
+    EventImages *eimg;          // temporary buffer for sorting rendered events
+    int eimg_size;              // allocated buffer size
+
+    // frame-global data
+    int width, height;          // screen dimensions
+    int orig_height;            // frame height ( = screen height - margins )
+    int orig_width;             // frame width ( = screen width - margins )
+    int orig_height_nocrop;     // frame height ( = screen height - margins + cropheight)
+    int orig_width_nocrop;      // frame width ( = screen width - margins + cropwidth)
+    ASS_Track *track;
+    long long time;             // frame's timestamp, ms
+    double font_scale;
+    double font_scale_x;        // x scale applied to all glyphs to preserve text aspect ratio
+    double border_scale;
+
+    RenderContext state;
+    TextInfo text_info;
+    CacheStore cache;
+
+    FreeList *free_head;
+    FreeList *free_tail;
+};
+
+typedef struct render_priv {
+    int top, height, left, width;
+    int render_id;
+} RenderPriv;
+
+typedef struct {
+    int x0;
+    int y0;
+    int x1;
+    int y1;
+} Rect;
+
+typedef struct {
+    int a, b;                   // top and height
+    int ha, hb;                 // left and width
+} Segment;
+
+void reset_render_context(ASS_Renderer *render_priv);
+
+#endif /* LIBASS_RENDER_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_strtod.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_strtod.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_strtod.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -0,0 +1,247 @@
+/*
+ * Copyright (c) 1988-1993 The Regents of the University of California.
+ * Copyright (c) 1994 Sun Microsystems, Inc.
+ *
+ * Permission to use, copy, modify, and distribute this
+ * software and its documentation for any purpose and without
+ * fee is hereby granted, provided that the above copyright
+ * notice appear in all copies.  The University of California
+ * makes no representations about the suitability of this
+ * software for any purpose.  It is provided &quot;as is&quot; without
+ * express or implied warranty.
+ *
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;errno.h&gt;
+
+static int maxExponent = 511;   /* Largest possible base 10 exponent.  Any
+                                 * exponent larger than this will already
+                                 * produce underflow or overflow, so there's
+                                 * no need to worry about additional digits.
+                                 */
+
+static double powersOf10[] = {  /* Table giving binary powers of 10.  Entry */
+    10.,                        /* is 10^2^i.  Used to convert decimal */
+    100.,                       /* exponents into floating-point numbers. */
+    1.0e4,
+    1.0e8,
+    1.0e16,
+    1.0e32,
+    1.0e64,
+    1.0e128,
+    1.0e256
+};
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * strtod --
+ *
+ * This procedure converts a floating-point number from an ASCII
+ * decimal representation to internal double-precision format.
+ *
+ * Results:
+ * The return value is the double-precision floating-point
+ * representation of the characters in string.  If endPtr isn't
+ * NULL, then *endPtr is filled in with the address of the
+ * next character after the last one that was part of the
+ * floating-point number.
+ *
+ * Side effects:
+ * None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+double
+ass_strtod(string, endPtr)
+    const char *string;     /* A decimal ASCII floating-point number,
+                             * optionally preceded by white space.
+                             * Must have form &quot;-I.FE-X&quot;, where I is the
+                             * integer part of the mantissa, F is the
+                             * fractional part of the mantissa, and X
+                             * is the exponent.  Either of the signs
+                             * may be &quot;+&quot;, &quot;-&quot;, or omitted.  Either I
+                             * or F may be omitted, or both.  The decimal
+                             * point isn't necessary unless F is present.
+                             * The &quot;E&quot; may actually be an &quot;e&quot;.  E and X
+                             * may both be omitted (but not just one).
+                             */
+    char **endPtr;          /* If non-NULL, store terminating character's
+                             * address here. */
+{
+    int sign, expSign = 0;
+    double fraction, dblExp, *d;
+    register const char *p;
+    register int c;
+    int exp = 0;            /* Exponent read from &quot;EX&quot; field. */
+    int fracExp = 0;        /* Exponent that derives from the fractional
+                             * part.  Under normal circumstatnces, it is
+                             * the negative of the number of digits in F.
+                             * However, if I is very long, the last digits
+                             * of I get dropped (otherwise a long I with a
+                             * large negative exponent could cause an
+                             * unnecessary overflow on I alone).  In this
+                             * case, fracExp is incremented one for each
+                             * dropped digit. */
+    int mantSize;       /* Number of digits in mantissa. */
+    int decPt;          /* Number of mantissa digits BEFORE decimal
+                         * point. */
+    const char *pExp;       /* Temporarily holds location of exponent
+                             * in string. */
+
+    /*
+     * Strip off leading blanks and check for a sign.
+     */
+
+    p = string;
+    while (isspace(*p)) {
+        p += 1;
+    }
+    if (*p == '-') {
+        sign = 1;
+        p += 1;
+    } else {
+        if (*p == '+') {
+            p += 1;
+        }
+        sign = 0;
+    }
+
+    /*
+     * Count the number of digits in the mantissa (including the decimal
+     * point), and also locate the decimal point.
+     */
+
+    decPt = -1;
+    for (mantSize = 0; ; mantSize += 1)
+    {
+        c = *p;
+        if (!isdigit(c)) {
+            if ((c != '.') || (decPt &gt;= 0)) {
+                break;
+            }
+            decPt = mantSize;
+        }
+        p += 1;
+    }
+
+    /*
+     * Now suck up the digits in the mantissa.  Use two integers to
+     * collect 9 digits each (this is faster than using floating-point).
+     * If the mantissa has more than 18 digits, ignore the extras, since
+     * they can't affect the value anyway.
+     */
+
+    pExp  = p;
+    p -= mantSize;
+    if (decPt &lt; 0) {
+        decPt = mantSize;
+    } else {
+        mantSize -= 1;      /* One of the digits was the point. */
+    }
+    if (mantSize &gt; 18) {
+        fracExp = decPt - 18;
+        mantSize = 18;
+    } else {
+        fracExp = decPt - mantSize;
+    }
+    if (mantSize == 0) {
+        fraction = 0.0;
+        p = string;
+        goto done;
+    } else {
+        int frac1, frac2;
+        frac1 = 0;
+        for ( ; mantSize &gt; 9; mantSize -= 1)
+        {
+            c = *p;
+            p += 1;
+            if (c == '.') {
+                c = *p;
+                p += 1;
+            }
+            frac1 = 10*frac1 + (c - '0');
+        }
+        frac2 = 0;
+        for (; mantSize &gt; 0; mantSize -= 1)
+        {
+            c = *p;
+            p += 1;
+            if (c == '.') {
+                c = *p;
+                p += 1;
+            }
+            frac2 = 10*frac2 + (c - '0');
+        }
+        fraction = (1.0e9 * frac1) + frac2;
+    }
+
+    /*
+     * Skim off the exponent.
+     */
+
+    p = pExp;
+    if ((*p == 'E') || (*p == 'e')) {
+        p += 1;
+        if (*p == '-') {
+            expSign = 1;
+            p += 1;
+        } else {
+            if (*p == '+') {
+                p += 1;
+            }
+            expSign = 0;
+        }
+        while (isdigit(*p)) {
+            exp = exp * 10 + (*p - '0');
+            p += 1;
+        }
+    }
+    if (expSign) {
+        exp = fracExp - exp;
+    } else {
+        exp = fracExp + exp;
+    }
+
+    /*
+     * Generate a floating-point number that represents the exponent.
+     * Do this by processing the exponent one bit at a time to combine
+     * many powers of 2 of 10. Then combine the exponent with the
+     * fraction.
+     */
+
+    if (exp &lt; 0) {
+        expSign = 1;
+        exp = -exp;
+    } else {
+        expSign = 0;
+    }
+    if (exp &gt; maxExponent) {
+        exp = maxExponent;
+        errno = ERANGE;
+    }
+    dblExp = 1.0;
+    for (d = powersOf10; exp != 0; exp &gt;&gt;= 1, d += 1) {
+        if (exp &amp; 01) {
+            dblExp *= *d;
+        }
+    }
+    if (expSign) {
+        fraction /= dblExp;
+    } else {
+        fraction *= dblExp;
+    }
+
+done:
+    if (endPtr != NULL) {
+        *endPtr = (char *) p;
+    }
+
+    if (sign) {
+        return -fraction;
+    }
+    return fraction;
+}

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -31,10 +31,10 @@
 #define HALIGN_RIGHT 3
 
 /* Opaque objects internally used by libass.  Contents are private. */
-typedef struct ass_renderer ass_renderer_t;
-typedef struct render_priv render_priv_t;
-typedef struct parser_priv parser_priv_t;
-typedef struct ass_library ass_library_t;
+typedef struct ass_renderer ASS_Renderer;
+typedef struct render_priv ASS_RenderPriv;
+typedef struct parser_priv ASS_ParserPriv;
+typedef struct ass_library ASS_Library;
 
 /* ASS Style: line */
 typedef struct ass_style {
@@ -62,10 +62,10 @@
     int MarginV;
     int Encoding;
     int treat_fontname_as_pattern;
-} ass_style_t;
+} ASS_Style;
 
 /*
- * ass_event_t corresponds to a single Dialogue line;
+ * ASS_Event corresponds to a single Dialogue line;
  * text is stored as-is, style overrides will be parsed later.
  */
 typedef struct ass_event {
@@ -82,8 +82,8 @@
     char *Effect;
     char *Text;
 
-    render_priv_t *render_priv;
-} ass_event_t;
+    ASS_RenderPriv *render_priv;
+} ASS_Event;
 
 /*
  * ass track represent either an external script or a matroska subtitle stream
@@ -95,8 +95,8 @@
     int max_styles;         // amount allocated
     int n_events;
     int max_events;
-    ass_style_t *styles;    // array of styles, max_styles length, n_styles used
-    ass_event_t *events;    // the same as styles
+    ASS_Style *styles;    // array of styles, max_styles length, n_styles used
+    ASS_Event *events;    // the same as styles
 
     char *style_format;     // style format line (everything after &quot;Format: &quot;)
     char *event_format;     // event format line
@@ -112,14 +112,14 @@
     int PlayResY;
     double Timer;
     int WrapStyle;
-    char ScaledBorderAndShadow;
+    int ScaledBorderAndShadow;
+    int Kerning;
 
-
     int default_style;      // index of default style
     char *name;             // file name in case of external subs, 0 for streams
 
-    ass_library_t *library;
-    parser_priv_t *parser_priv;
-} ass_track_t;
+    ASS_Library *library;
+    ASS_ParserPriv *parser_priv;
+} ASS_Track;
 
 #endif /* LIBASS_TYPES_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -34,7 +34,7 @@
 {
     double temp_res;
     char *start = *p;
-    temp_res = strtod(*p, p);
+    temp_res = ass_strtod(*p, p);
     *res = (int) (temp_res + (temp_res &gt; 0 ? 0.5 : -0.5));
     if (*p != start)
         return 1;
@@ -46,7 +46,7 @@
 {
     double temp_res;
     char *start = *p;
-    temp_res = strtod(*p, p);
+    temp_res = ass_strtod(*p, p);
     *res = (int) (temp_res + (temp_res &gt; 0 ? 0.5 : -0.5));
     if (*p != start)
         return 1;
@@ -67,18 +67,19 @@
 int mystrtod(char **p, double *res)
 {
     char *start = *p;
-    *res = strtod(*p, p);
+    *res = ass_strtod(*p, p);
     if (*p != start)
         return 1;
     else
         return 0;
 }
 
-int strtocolor(ass_library_t *library, char **q, uint32_t *res)
+int strtocolor(ASS_Library *library, char **q, uint32_t *res, int hex)
 {
     uint32_t color = 0;
     int result;
     char *p = *q;
+    int base = hex ? 16 : 10;
 
     if (*p == '&amp;')
         ++p;
@@ -89,7 +90,7 @@
         ++p;
         result = mystrtou32(&amp;p, 16, &amp;color);
     } else {
-        result = mystrtou32(&amp;p, 0, &amp;color);
+        result = mystrtou32(&amp;p, base, &amp;color);
     }
 
     {
@@ -122,7 +123,7 @@
     return 0;
 }
 
-void ass_msg(ass_library_t *priv, int lvl, char *fmt, ...)
+void ass_msg(ASS_Library *priv, int lvl, char *fmt, ...)
 {
     va_list va;
     va_start(va, fmt);
@@ -161,7 +162,7 @@
 }
 
 #ifdef CONFIG_ENCA
-void *ass_guess_buffer_cp(ass_library_t *library, unsigned char *buffer,
+void *ass_guess_buffer_cp(ASS_Library *library, unsigned char *buffer,
                           int buflen, char *preferred_language,
                           char *fallback)
 {

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -49,16 +49,19 @@
 int mystrtoll(char **p, long long *res);
 int mystrtou32(char **p, int base, uint32_t *res);
 int mystrtod(char **p, double *res);
-int strtocolor(ass_library_t *library, char **q, uint32_t *res);
+int strtocolor(ASS_Library *library, char **q, uint32_t *res, int hex);
 char parse_bool(char *str);
 unsigned ass_utf8_get_char(char **str);
-void ass_msg(ass_library_t *priv, int lvl, char *fmt, ...);
+void ass_msg(ASS_Library *priv, int lvl, char *fmt, ...);
 #ifdef CONFIG_ENCA
-void *ass_guess_buffer_cp(ass_library_t *library, unsigned char *buffer,
+void *ass_guess_buffer_cp(ASS_Library *library, unsigned char *buffer,
                           int buflen, char *preferred_language,
                           char *fallback);
 #endif
 
+/* defined in ass_strtod.c */
+double ass_strtod(const char *string, char **endPtr);
+
 static inline int d6_to_int(int x)
 {
     return (x + 32) &gt;&gt; 6;
@@ -99,7 +102,22 @@
 {
     return (int) (x * 0x10000);
 }
+static inline double d22_to_double(int x)
+{
+    return ((double) x) / 0x400000;
+}
+static inline int double_to_d22(double x)
+{
+    return (int) (x * 0x400000);
+}
 
+// Calculate cache key for a rotational angle in degrees
+static inline int rot_key(double a)
+{
+    const int m = double_to_d22(360.0);
+    return double_to_d22(a) % m;
+}
+
 #define FNV1_32A_INIT (unsigned)0x811c9dc5
 
 static inline unsigned fnv_32a_buf(void *buf, size_t len, unsigned hval)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme	2010-01-09 11:03:17 UTC (rev 5832)
@@ -1,2 +1,12 @@
 checkout <A HREF="http://repo.or.cz/w/libass.git">http://repo.or.cz/w/libass.git</A>
-done august first 8h36 AM, paris time, last commit      Do not round karaoke timing coordinates  
+Done 9 Jan 2010 at 1104
+Last commit
+commit 8db4a5b1b5ab6598b96092e08586f2bed8ab8f39
+Author: Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at blackbox</A>&gt;
+Date:   Fri Jan 8 18:23:34 2010 +0100
+
+    Remove support for freetype &lt; 2.2.1
+
+    Get rid of compatibility #ifdefs and some code to support very old
+    versions of freetype. libass now requires at least version 2.2.1.
+

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp	2010-01-09 11:03:17 UTC (rev 5832)
@@ -287,7 +287,7 @@
           return 1; 
         }
         int changed=0;
-        ass_image_t *img = ass_render_frame(_ass_rend, _ass_track, where,&amp;changed);
+        ASS_Image *img = ass_render_frame(_ass_rend, _ass_track, where,&amp;changed);
         
 
         while(img) {

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -22,9 +22,9 @@
 protected:
         virtual char* printConf(void);
         ASSParams* _params;
-        ass_library_t *_ass_lib;
-        ass_renderer_t *_ass_rend;
-        ass_track_t *_ass_track;
+        ASS_Library *_ass_lib;
+        ASS_Renderer *_ass_rend;
+        ASS_Track *_ass_track;
         uint8_t init(void);
 public:
         ADMVideoSubASS(AVDMGenericVideoStream *in, CONFcouple *conf);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt	2010-01-09 11:03:17 UTC (rev 5832)
@@ -9,10 +9,12 @@
 
 	ADD_LIBRARY(ADM_vf_ssa SHARED ${ADM_vf_ssa_SRCS})
 	TARGET_LINK_LIBRARIES(ADM_vf_ssa ADM_libass)
+	ADD_TARGET_CFLAGS(ADM_vf_ssa &quot;-DCONFIG_FREETYPE=1&quot;)
 	ADD_TARGET_LDFLAGS(ADM_vf_ssa &quot;${FREETYPE2_LDFLAGS}&quot;)
 
 	IF (FONTCONFIG_FOUND)
 		ADD_TARGET_LDFLAGS(ADM_vf_ssa &quot;${FONTCONFIG_LDFLAGS}&quot;)
+	        ADD_TARGET_CFLAGS(ADM_vf_ssa &quot;-DCONFIG_FONTCONFIG=1&quot;)
 	ENDIF (FONTCONFIG_FOUND)
 
 	INIT_VIDEOFILTER_PLUGIN(ADM_vf_ssa)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003037.html">[Avidemux-svn-commit] r5831 -	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video
</A></li>
	<LI>Next message: <A HREF="003039.html">[Avidemux-svn-commit] r5833 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3038">[ date ]</a>
              <a href="thread.html#3038">[ thread ]</a>
              <a href="subject.html#3038">[ subject ]</a>
              <a href="author.html#3038">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
