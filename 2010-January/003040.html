<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5834 - in branches/avidemux_2.6_branch_mean:	avidemux/common avidemux/common/ADM_codecs avidemux_core	avidemux_core/ADM_coreVideoCodec	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-January/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5834%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/common%20avidemux/common/ADM_codecs%20avidemux_core%0A%09avidemux_core/ADM_coreVideoCodec%0A%09avidemux_core/ADM_coreVideoCodec/include%0A%09avidemux_core/ADM_coreVideoCodec/src&In-Reply-To=%3C201001101808.o0AI8gHv013232%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003039.html">
   <LINK REL="Next"  HREF="003041.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5834 - in branches/avidemux_2.6_branch_mean:	avidemux/common avidemux/common/ADM_codecs avidemux_core	avidemux_core/ADM_coreVideoCodec	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5834%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/common%20avidemux/common/ADM_codecs%20avidemux_core%0A%09avidemux_core/ADM_coreVideoCodec%0A%09avidemux_core/ADM_coreVideoCodec/include%0A%09avidemux_core/ADM_coreVideoCodec/src&In-Reply-To=%3C201001101808.o0AI8gHv013232%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5834 - in branches/avidemux_2.6_branch_mean:	avidemux/common avidemux/common/ADM_codecs avidemux_core	avidemux_core/ADM_coreVideoCodec	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src">mean at mail.berlios.de
       </A><BR>
    <I>Sun Jan 10 19:08:42 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003039.html">[Avidemux-svn-commit] r5833 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml
</A></li>
        <LI>Next message: <A HREF="003041.html">[Avidemux-svn-commit] r5835 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common/ADM_commonUI	avidemux/common/ADM_editor avidemux/common/ADM_script	avidemux/qt4/ADM_userInterfaces/ADM_dialog	avidemux/qt4/ADM_userInterfaces/ADM_gui	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src cmake
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3040">[ date ]</a>
              <a href="thread.html#3040">[ thread ]</a>
              <a href="subject.html#3040">[ subject ]</a>
              <a href="author.html#3040">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-01-10 19:08:39 +0100 (Sun, 10 Jan 2010)
New Revision: 5834

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
Log:
[VideoCodec] Move them to  core

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,160 +0,0 @@
-/***************************************************************************
-                          ADM_codec.h  -  description
-                             -------------------
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef __CODECS__
-#define __CODECS__
-
-#include &quot;ADM_image.h&quot;
-#include &quot;ADM_frameType.h&quot;
-#include &quot;ADM_codecType.h&quot;
-
-#define ADM_QPEL_ON	1
-#define ADM_GMC_ON	2
-#define ADM_VOP_ON	4
-
-/*
-        Bitrate in configuration will always be in **kBITS**
-
-*/
-
-#include &quot;ADM_bitstream.h&quot;
-#include &quot;ADM_compressedImage.h&quot;
-/**
-    \class decoders
-    \brief base class for video decoders
-*/
-class decoders
-{
-protected:
-  uint32_t _w;
-  uint32_t _h;
-  uint8_t _lastQ;
-public:
-    decoders (uint32_t w, uint32_t h)
-  {
-    _w = w;
-    _h = h;
-    _lastQ = 0;
-  }
-  virtual ~ decoders ()
-  {
-  };
-  virtual uint8_t getPARWidth (void)
-  {
-    return 1;
-  };
-  virtual uint8_t getPARHeight (void)
-  {
-    return 1;
-  };
-  virtual void setParam (void)
-  {
-  };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)=0;
-
-  // does this codec *possibly* can have b-frame ?
-  virtual uint8_t dontcopy (void)
-  {
-    return 0;
-  }				// if 1 means the decoder will return reference
-  // no need to copy the datas to ADMimage
-  virtual uint8_t bFramePossible (void)
-  {
-    return 0;
-  }
-  virtual uint8_t decodeHeaderOnly (void)
-  {
-    return 0;
-  };
-  virtual uint8_t decodeFull (void)
-  {
-    return 0;
-  }
-  virtual uint8_t isDivxPacked (void)
-  {
-    return 0;
-  };
-  virtual uint32_t getSpecificMpeg4Info (void)
-  {
-    return 0;
-  };
-  virtual uint8_t isIndexable (void)
-  {
-    return 1;
-  };
-  virtual bool flush(void)
-    {
-        return true;
-    }
-};
-/* Dummy decoder in case we don't have the desired one */
-class decoderEmpty : public decoders
-{
-protected:
-public:
-    decoderEmpty (uint32_t w, uint32_t h) : decoders(w,h) {};
-    uint8_t uncompress (ADMCompressedImage * in, ADMImage * out) {return 1;}
-
-};
-
-decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		      uint8_t * extraData,uint32_t bpp=0);
-decoders *getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h,
-			       uint32_t extraLen, uint8_t * extraData);
-decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData);
-
-class coders
-{
-protected:
-  uint32_t _w;
-  uint32_t _h;
-public:
-    coders (uint32_t w, uint32_t h)
-  {
-    _w = w;
-    _h = h;
-  }
-  virtual ~ coders ()
-  {
-  };
-  virtual uint8_t compress (ADMImage * in, ADMBitstream * out);
-};
-decoders *getCoder (uint32_t fcc, uint32_t w, uint32_t h);
-/*----------------------------------------------------------*/
-class encoder
-{
-protected:uint32_t _w, _h;
-public:encoder (uint32_t width, uint32_t height)
-  {
-    _w = width;
-    _h = height;
-  };
-  virtual uint8_t stopEncoder (void) = 0;
-  virtual uint8_t init (uint32_t val, uint32_t fps1000) = 0;
-  virtual uint8_t encode (ADMImage * in, ADMBitstream *out) = 0;
-  virtual uint8_t getExtraData (uint32_t * l, uint8_t ** d)
-  {
-    *l = 0;
-    *d = NULL;
-    return 0;
-  }
-};
-
-
-
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,33 +0,0 @@
-/***************************************************************************
-                          ADM_codecNull.h  -  description
-                             -------------------
-    begin                : Fri Apr 19 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-class decoderNull:public decoders
-{
-protected:
-
-public:
-  decoderNull (uint32_t w, uint32_t h):decoders (w, h)
-  {
-  }
-  virtual ~ decoderNull ()
-  {
-  };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)
-  {
-    memcpy (out-&gt;data, in-&gt;data, in-&gt;dataLength);
-    return 1;
-  }
-};

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,316 +0,0 @@
-/***************************************************************************
-                          ADM_codecs.cpp  -  description
-                             -------------------
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-    see here : <A HREF="http://www.webartz.com/fourcc/">http://www.webartz.com/fourcc/</A>
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-
-#ifdef USE_FFMPEG
-extern &quot;C&quot;
-{
-#include &quot;ADM_lavcodec.h&quot;
-};
-#endif
-#include &quot;ADM_default.h&quot;
-#ifdef BIG_ENDIAN
-#undef BIG_ENDIAN
-#endif
-
-//#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#ifdef USE_XX_XVID
-#include &quot;xvid.h&quot;
-#endif
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_mjpeg.h&quot;
-#include &quot;ADM_codecs/ADM_codecNull.h&quot;
-#include &quot;ADM_codecs/ADM_rgb16.h&quot;
-#include &quot;ADM_codecs/ADM_uyvy.h&quot;
-#include &quot;avidemutils.h&quot;
-#include &quot;fourcc.h&quot;
-
-
-#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
-
-
-#ifdef USE_THEORA
-#include &quot;ADM_codecs/ADM_theora_dec.h&quot;
-#endif
-
-#include &quot;ADM_codecs/ADM_png.h&quot;
-
-#include &quot;ADM_assert.h&quot;
-#include &quot;prefs.h&quot;
-
-extern uint8_t GUI_Question (char *);
-extern uint8_t use_fast_ffmpeg;
-extern bool vdpauUsable(void);
-
-uint8_t
-  decoders::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-  UNUSED_ARG (in);
-  UNUSED_ARG (out);
-  return 0;
-}
-decoders *
-getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData)
-{
-  UNUSED_ARG (fcc);
-  UNUSED_ARG (extraLen);
-  UNUSED_ARG (extraData);
-  return (decoders *) (new decoderFFMpeg4VopPacked (w, h));
-
-}
-decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData)
-{
-  UNUSED_ARG (fcc);
-  UNUSED_ARG (extraLen);
-  UNUSED_ARG (extraData);
-  return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,0));
-
-}
-/**
-    \fn getDecoder
-    \brief returns the correct decoder for a stream
-*/
-decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-	    uint8_t * extraData,uint32_t bpp)
-{
-  printf(&quot;\nSearching decoder (%d x %d, extradataSize:%d)...\n&quot;,w,h,extraLen);
-  if (isMSMpeg4Compatible (fcc) == 1)
-    {
-      // For div3, no problem we take ffmpeg
-
-      return (decoders *) (new decoderFFDiv3 (w, h));
-    }
-
-#ifdef USE_FFMPEG
-  if (isDVCompatible(fcc))//&quot;CDVC&quot;))
-    {
-
-      return (decoders *) (new decoderFFDV (w, h, extraLen, extraData));
-    }
-#endif
-#ifdef USE_FFMPEG
-  if (fourCC::check (fcc, (uint8_t *) &quot;MP42&quot;))
-    {
-
-      return (decoders *) (new decoderFFMP42 (w, h));
-    }
-#endif
-    if (fourCC::check (fcc, (uint8_t *) &quot;FLV1&quot;))
-    {
-      return (decoders *) (new decoderFFFLV1 (w, h,extraLen, extraData));
-    }
-
-
-#ifdef USE_FFMPEG
-  if (fourCC::check (fcc, (uint8_t *) &quot;H263&quot;))
-    {
-
-      return (decoders *) (new decoderFFH263 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;HFYU&quot;))
-    {
-
-      return (decoders *) (new decoderFFhuff (w, h, extraLen, extraData,bpp));
-    }
-#ifdef USE_PNG
-  if (fourCC::check (fcc, (uint8_t *) &quot;PNG &quot;))
-    {
-
-      return (decoders *) (new decoderPng (w, h));
-    }
-#endif
- if (fourCC::check (fcc, (uint8_t *) &quot;cvid&quot;))
-    {
-
-      return (decoders *) (new decoderFFCinepak (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;FFVH&quot;))
-    {
-
-      return (decoders *) (new decoderFF_ffhuff (w, h, extraLen, extraData,bpp));
-    }
-if (fourCC::check (fcc, (uint8_t *) &quot;SVQ1&quot;))
-    {
-
-      return (decoders *) (new decoderFFSVQ1 (w, h, extraLen, extraData));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) &quot;SVQ3&quot;))
-    {
-
-      return (decoders *) (new decoderFFSVQ3 (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;tscc&quot;))
-    {
-
-      return (decoders *) (new decoderCamtasia (w, h, bpp));
-    }
-
-     if (fourCC::check (fcc, (uint8_t *) &quot;CRAM&quot;))
-    {
-
-      return (decoders *) (new decoderFFCRAM (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;WMV2&quot;))
-    {
-
-      return (decoders *) (new decoderFFWMV2 (w, h, extraLen, extraData));
-    }
-    if (fourCC::check (fcc, (uint8_t *) &quot;WMV1&quot;))
-    {
-
-      return (decoders *) (new decoderFFWMV1 (w, h, extraLen, extraData));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) &quot;WMV3&quot;) )
-    {
-
-      return (decoders *) (new decoderFFWMV3 (w, h, extraLen, extraData));
-    }
-
-    if (fourCC::check (fcc, (uint8_t *) &quot;WVC1&quot;)|| fourCC::check (fcc, (uint8_t *) &quot;WMVA&quot;))
-    {
-
-      return (decoders *) (new decoderFFVC1 (w, h, extraLen, extraData));
-    }
-
-if (fourCC::check (fcc, (uint8_t *) &quot;FFV1&quot;))
-    {
-
-      return (decoders *) (new decoderFFV1 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;SNOW&quot;))
-    {
-
-      return (decoders *) (new decoderSnow (w, h));
-    }
-  if (isH264Compatible (fcc))
-    {
-#ifdef USE_VDPAU
-        if(vdpauUsable()==true)
-            return (decoders *) (new decoderFFVDPAU (w, h, extraLen, extraData));
-        else
-#endif
-            return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,1));
-    }
-#endif
-
-/*
-	Could be either divx5 packed crap or xvid or ffmpeg
-	For now we return FFmpeg and later will switch to divx5 if available
-		(ugly hack for ugly hack....)
-*/
-
-  if (isMpeg4Compatible (fcc) == 1)
-    {
-      return (decoders *) (new decoderFFMpeg4 (w, h, fcc,extraLen, extraData));
-      //    return(decoders *)( new decoderXvid(w,h));
-      //    return(decoders *)( new decoderDIVX(w,h));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) &quot;MJPB&quot;))
-    {
-      printf (&quot;\n using FF mjpeg codec\n&quot;);
-      return (decoders *) (new decoderFFMjpegB (w, h,extraLen,extraData));
-    }
-if (fourCC::check (fcc, (uint8_t *) &quot;MJPG&quot;)
-      || fourCC::check (fcc, (uint8_t *) &quot;mjpa&quot;))
-    {
-#if  0
-      //#ifdef USE_MJPEG
-      printf (&quot;\n using mjpeg codec\n&quot;);
-      return (decoders *) (new decoderMjpeg (w, h));
-#else
-      printf (&quot;\n using FF mjpeg codec\n&quot;);
-      return (decoders *) (new decoderFFMJPEG (w, h));
-#endif
-
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;YV12&quot;)
-      || fourCC::check (fcc, (uint8_t *) &quot;yv12&quot;)
-      || fourCC::check (fcc, (uint8_t *) &quot;I420&quot;))
-    {
-      printf (&quot;\n using null codec\n&quot;);
-      return (decoders *) (new decoderNull (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;UYVY&quot;))
-    {
-      printf (&quot;\n using uyvy codec\n&quot;);
-      return (decoders *) (new decoderUYVY (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;YUY2&quot;))
-    {
-      printf (&quot;\n using YUY2 codec\n&quot;);
-      return (decoders *) (new decoderYUY2 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) &quot;AMV &quot;))
-    {
-      printf (&quot;\n using AMV codec\n&quot;);
-      return (decoders *) (new decoderFFAMV (w, h,extraLen,extraData));
-    }
-
- if (fourCC::check (fcc, (uint8_t *) &quot;VP6A&quot;))
-    {
-      printf (&quot;\n using YUY2 codec\n&quot;);
-      return (decoders *) (new decoderFFVP6A (w, h,extraLen,extraData));
-    }
-  if (isVP6Compatible(fcc))
-    {
-      printf (&quot;\n using VP6F codec\n&quot;);
-      return (decoders *) (new decoderFFVP6F (w, h,extraLen,extraData));
-    }
-
-
-  if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) &quot;RGB &quot;))
-    {
-      // RGB 16 Codecs
-      printf (&quot;\n using RGB codec\n&quot;);
-      return (decoders *) (new decoderRGB16 (w, h, 1, bpp));
-
-    }
- if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) &quot;DIB &quot;))
-    {
-      // RGB 16 Codecs
-      printf (&quot;\n using DIB codec\n&quot;);
-      return (decoders *) (new decoderRGB16 (w, h, 0, bpp));
-
-    }
-  if (isMpeg12Compatible (fcc))
-	  return (decoders *) (new decoderFFMpeg12 (w, h, extraLen, extraData));
-
-  // default : null decoder
-  printf (&quot;\n using invalid codec for \n&quot;);
-  fourCC::print (fcc);
-
-  return (decoders *) (new decoderEmpty (w, h));
-}
-
-uint8_t coders::compress (ADMImage * in, ADMBitstream * out)
-{
-  UNUSED_ARG (in);
-  UNUSED_ARG (out);
-
-  return 0;
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,838 +0,0 @@
-/***************************************************************************
-                          ADM_ffmp43.cpp  -  description
-                             -------------------
-                             
-	Decoder for Divx3/4/..., using ffmpeg
-                             
-    begin                : Wed Sep 25 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-
-#include &quot;ADM_assert.h&quot;
-#include &quot;prefs.h&quot;
-extern &quot;C&quot; {
-#include &quot;ADM_lavcodec.h&quot;
-}
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-
-#include &quot;ADM_debugID.h&quot;
-#define MODULE_NAME  MODULE_CODEC
-#include &quot;ADM_debug.h&quot;
-#include &quot;ADM_videoInfoExtractor.h&quot;
-
-extern int ADM_cpu_num_processors(void);
-extern &quot;C&quot;
-{
-    static void ADM_releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-    static int  ADM_getBuffer(AVCodecContext *avctx, AVFrame *pic);
-}
-
-
-
-#define WRAP_Open_Template(funcz,argz,display,codecid) \
-{\
-AVCodec *codec=funcz(argz);\
-if(!codec) {GUI_Error_HIG(&quot;Codec&quot;,QT_TR_NOOP(&quot;Internal error finding codec&quot;display));ADM_assert(0);} \
-  codecId=codecid; \
-  _context-&gt;workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
-  _context-&gt;error_concealment=3; \
-  if (avcodec_open(_context, codec) &lt; 0)  \
-                      { \
-                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder failed!\n&quot;); \
-                                        GUI_Error_HIG(&quot;Codec&quot;,&quot;Internal error opening &quot;display); \
-                                        ADM_assert(0); \
-                                } \
-                                else \
-                                { \
-                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder initialized! (%s)\n&quot;,codec-&gt;long_name); \
-                                } \
-}
-
-#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
-#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
-
-
-//****************************
-extern uint8_t DIA_lavDecoder (uint32_t * swapUv, uint32_t * showU);
-extern &quot;C&quot;
-{
-  int av_is_voppacked (AVCodecContext * avctx, int *vop_packed, int *gmc,
-		       int *qpel);
-};
-/**
-    \fn clonePic
-    \brief Convert AvFrame to ADMImage
-*/
-uint8_t decoderFF::clonePic (AVFrame * src, ADMImage * out)
-{
-  uint32_t    u,v;
-  ADM_assert(out-&gt;_isRef);
-  out-&gt;_planes[0] = (uint8_t *) src-&gt;data[0];
-  out-&gt;_planeStride[0] = src-&gt;linesize[0];
-  if (_swapUV)
-    {
-      u = 1;
-      v = 2;
-    }
-  else
-    {
-      u = 2;
-      v = 1;
-    }
-  out-&gt;_planes[1] = (uint8_t *) src-&gt;data[u];
-  out-&gt;_planeStride[1] = src-&gt;linesize[u];
-
-  out-&gt;_planes[2] = (uint8_t *) src-&gt;data[v];
-  out-&gt;_planeStride[2] = src-&gt;linesize[v];
-
-  _lastQ = 0;			//_context-&gt;quality;
-  out-&gt;_Qp = (src-&gt;quality * 32) / FF_LAMBDA_MAX;
-  out-&gt;flags = frameType ();
-
-  // Quant ?
-  if (src-&gt;qstride &amp;&amp; src-&gt;qscale_table &amp;&amp; codecId != CODEC_ID_H264)
-    {
-      out-&gt;quant = (uint8_t *) src-&gt;qscale_table;
-      out-&gt;_qStride = src-&gt;qstride;
-      out-&gt;_qSize = (_w + 15) &gt;&gt; 4;
-      out-&gt;_qSize *= (_h + 15) &gt;&gt; 4;	// FixME?
-    }
-  else
-    {
-      out-&gt;_qSize = out-&gt;_qStride = 0;
-      out-&gt;quant = NULL;
-    }
-    //printf(&quot;[LAVC] Old pts :%&quot;LLD&quot; new pts :%&quot;LLD&quot;\n&quot;,out-&gt;Pts, (uint64_t)(src-&gt;reordered_opaque));
-    //printf(&quot;[LAVC] pts: %&quot;LLU&quot;\n&quot;,src-&gt;pts);
-    out-&gt;Pts= (uint64_t)(src-&gt;reordered_opaque);
-    return 1;
-}
-/**
-        \fn decoderMultiThread
-        \brief Enabled multitheaded decoder if possible
-*/
-void decoderFF::decoderMultiThread (void)
-{
-  uint32_t threads = 0;
-
-  prefs-&gt;get(FEATURE_THREADING_LAVC, &amp;threads);
-
-  if (threads == 0)
-	  threads = ADM_cpu_num_processors();
-
-  if (threads == 1)
-	  threads = 0;
-
-  if (threads)
-  {
-      printf (&quot;[lavc] Enabling MT decoder with %u threads\n&quot;, threads);
-
-      if (avcodec_thread_init (_context, threads) == -1)
-	      printf (&quot;[lavc] Failed!!\n&quot;);
-	  else
-          _usingMT = 1;
-  }
-}
-uint8_t decoderFF::getPARWidth (void)
-{
-  if(!_context-&gt;sample_aspect_ratio.num) return 1;
-  return _context-&gt;sample_aspect_ratio.num;
-}
-uint8_t decoderFF::getPARHeight (void)
-{
-  if(!_context-&gt;sample_aspect_ratio.den) return 1;
-  return _context-&gt;sample_aspect_ratio.den;
-
-}
-
-  
-uint8_t decoderFF::isDivxPacked (void)
-{
-  int
-    vop,
-    gmc,
-    qpel;
-  av_is_voppacked (_context, &amp;vop, &amp;gmc, &amp;qpel);
-  return vop;
-}
-// Fill the bitfields for some mpeg4 specific info
-// It is a bit of a hack as we make it a general
-// stuff (i.e. shared with all codecs) whereas it is mpeg4 specific
-// and should stay within mpeg4 scope FIXME
-uint32_t decoderFF::getSpecificMpeg4Info (void)
-{
-  int
-    vop,
-    gmc,
-    qpel;
-  uint32_t
-    out = 0;
-  av_is_voppacked (_context, &amp;vop, &amp;gmc, &amp;qpel);
-
-  if (qpel)
-    out += ADM_QPEL_ON;
-  if (_gmc)
-    out += ADM_GMC_ON;
-  if (vop)
-    out += ADM_VOP_ON;
-
-  return out;
-}
-
-//________________________________________________
-void
-decoderFF::setParam (void)
-{
-  DIA_lavDecoder (&amp;_swapUV, &amp;_showMv);
-  return;			// no param for ffmpeg
-}
-
-//-------------------------------
-decoderFF::decoderFF (uint32_t w, uint32_t h):decoders (w, h)
-{
-  codecId = 0;
-//                              memset(&amp;_context,0,sizeof(_context));
-  _allowNull = 0;
-  _gmc = 0;
-  _context = NULL;
-  _refCopy = 0;
-  _usingMT = 0;
-#if LIBAVCODEC_BUILD &gt;= 4624
-  _context = avcodec_alloc_context ();
-#else
-  _context = new AVCodecContext;
-  memset (_context, 0, sizeof (AVCodecContext));
-#endif
-  ADM_assert (_context);
-  memset (&amp;_frame, 0, sizeof (_frame));
-
-  _context-&gt;max_b_frames = 0;
-
-  _context-&gt;width = _w;
-  _context-&gt;height = _h;
-  _context-&gt;pix_fmt = PIX_FMT_YUV420P;	//PIX_FMT_RGBA32
-  //_context-&gt;debug=1;
-
-  _internalBuffer = new uint8_t[w * h * 3];
-
-  _swapUV = 0;
-  //_context-&gt;strict_std_compliance=-1;
-
-  _showMv = 0;
-#define FF_SHOW		(FF_DEBUG_VIS_MV_P_FOR+	FF_DEBUG_VIS_MV_B_FOR+FF_DEBUG_VIS_MV_B_BACK)
-//#define FF_SHOW               (FF_DEBUG_VIS_MV_P_FOR)
-  printf (&quot;[lavc] Build: %d\n&quot;, LIBAVCODEC_BUILD);
-  _context-&gt;debug_mv |= FF_SHOW;
-  _context-&gt;debug |= FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP;
-  
-}
-
-//_____________________________________________________
-
-decoderFF::~decoderFF ()
-{
-  if (_usingMT)
-    {
-      printf (&quot;[lavc] Killing decoding threads\n&quot;);
-      avcodec_thread_free (_context);
-      _usingMT = 0;
-    }
-
-  avcodec_close (_context);
-  ADM_dealloc (_context);
-  delete[]_internalBuffer;
-  printf (&quot;[lavc] Destroyed\n&quot;);
-}
-
-/**
-    \fn frameType
-    \return frametype of the last decoded frame
-*/
-uint32_t decoderFF::frameType (void)
-{
-  uint32_t
-    flag = 0;
-
-  AVFrame *
-    target;
-#define SET(x) {flag=x;aprintf(&quot;Frame is %s\n&quot;,#x);}
-
-
-  target = &amp;_frame;
-  switch (target-&gt;pict_type)
-    {
-    case FF_B_TYPE:
-      SET (AVI_B_FRAME);
-      if (target-&gt;key_frame)
-	aprintf (&quot;\n But keyframe is set\n&quot;);
-      break;
-
-    case FF_I_TYPE:
-      SET (AVI_KEY_FRAME);
-      if (!target-&gt;key_frame)
-	{
-	  if (codecId == CODEC_ID_H264)
-	    {
-	      SET (AVI_P_FRAME);
-	    }
-	  else
-	    printf (&quot;\n But keyframe is not set\n&quot;);
-	}
-      break;
-    case FF_S_TYPE:
-      _gmc = 1;			// No break, just inform that gmc is there
-    case FF_P_TYPE:
-      SET (AVI_P_FRAME);
-      if (target-&gt;key_frame)
-	aprintf (&quot;\n But keyframe is set\n&quot;);
-      break;
-    default:
-//                              printf(&quot;\n OOops XXX frame ?\n&quot;);
-      break;
-    }
-  return flag;
-}
-uint8_t decoderFF::decodeHeaderOnly (void)
-{
-  if (codecId == CODEC_ID_H264)
-    _context-&gt;hurry_up = 4;
-  else
-    _context-&gt;hurry_up = 5;
-  printf (&quot;\n[lavc] Hurry up\n&quot;);
-  return 1;
-}
-uint8_t decoderFF::decodeFull (void)
-{
-  _context-&gt;hurry_up = 0;
-  printf (&quot;\n[lavc] full decoding\n&quot;);
-  return 1;
-}
-
-/**
-    \fn flush
-    \brief empty internal buffer
-*/
-bool    decoderFF::flush(void)
-{
-    if(_context)
-        avcodec_flush_buffers(_context);
-    return true;
-}
-/**
-    \fn uncompress
-    \brief Actually decode an image
-*/
-uint8_t   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-  int got_picture = 0;
-  uint8_t *oBuff[3];
-  int strideTab[3];
-  int strideTab2[3];
-  int ret = 0;
-  out-&gt;_noPicture = 0;
-  if (_showMv)
-    {
-      _context-&gt;debug_mv |= FF_SHOW;
-      _context-&gt;debug |= 0;	//FF_DEBUG_VIS_MB_TYPE;
-    }
-  else
-    {
-      _context-&gt;debug_mv &amp;= ~FF_SHOW;
-      _context-&gt;debug &amp;= ~(FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP);
-    }
-
-   
-    
-  if (in-&gt;dataLength == 0 &amp;&amp; !_allowNull)	// Null frame, silently skipped
-    {
-      
-      printf (&quot;[Codec] null frame\n&quot;);
-        // search the last image
-        if (_context-&gt;coded_frame &amp;&amp; 
-            _context-&gt;coded_frame-&gt;data &amp;&amp;
-            _context-&gt;coded_frame-&gt;data[0]
-            )
-          {
-            printf(&quot;[Codec] Cloning older pic\n&quot;);
-            clonePic (_context-&gt;coded_frame, out);
-            out-&gt;Pts=ADM_COMPRESSED_NO_PTS;
-          }
-        else
-            {
-                out-&gt;_noPicture = 1;
-                out-&gt;Pts=ADM_COMPRESSED_NO_PTS;
-                printf(&quot;[Codec] No Picture\n&quot;);
-            }
-          return 1;
-    }
-   // Put a safe value....
-   out-&gt;Pts=in-&gt;demuxerPts;
-    _context-&gt;reordered_opaque=in-&gt;demuxerPts;
-  //_frame.opaque=(void *)out-&gt;Pts;
-  //printf(&quot;Incoming Pts :%&quot;LLD&quot;\n&quot;,out-&gt;Pts);
-  ret = avcodec_decode_video (_context, &amp;_frame, &amp;got_picture, in-&gt;data, in-&gt;dataLength);
-  if(!bFramePossible())
-  {
-    // No delay, the value is sure, no need to hide it in opaque
-    _context-&gt;reordered_opaque=(int64_t)in-&gt;demuxerPts;
-  }
-  out-&gt;_qStride = 0;		//Default = no quant
-  if (0 &gt; ret &amp;&amp; !_context-&gt;hurry_up)
-    {
-      printf (&quot;\n[lavc] error in lavcodec decoder!\n&quot;);
-      printf (&quot;[lavc] Err: %d, size :%d\n&quot;, ret, in-&gt;dataLength);
-      return 0;
-    }
-  if (!got_picture &amp;&amp; !_context-&gt;hurry_up)
-    {
-      // Some encoder code a vop header with the 
-      // vop flag set to 0
-      // it is meant to mean frame skipped but very dubious
-      if (in-&gt;dataLength &lt;= 8 &amp;&amp; codecId == CODEC_ID_MPEG4)
-	{
-	  printf (&quot;[lavc] Probably pseudo black frame...\n&quot;);
-	  out-&gt;_Qp = 2;
-	  out-&gt;flags = 0;	// assume P ?
-
-	  clonePic (_context-&gt;coded_frame, out);
-	  return 1;
-	}
-      // allow null means we allow null frame in and so potentially
-      // have no frame out for a time
-      // in that case silently fill with black and returns it as KF
-      if (_allowNull)
-	{
-	  out-&gt;flags = AVI_KEY_FRAME;
-	  if (!_refCopy)
-	    {
-	      memset (out-&gt;data, 0, _w * _h);
-	      memset (out-&gt;data + _w * _h, 128, (_w * _h) &gt;&gt; 1);
-	    }
-	  else
-	    {
-	      out-&gt;_noPicture = 1;
-	    }
-	  printf (&quot;\n[lavc] ignoring got pict ==0\n&quot;);
-	  return 1;
-
-	}
-      printf (&quot;[lavc] Err: %d, size: %d\n&quot;, ret, in-&gt;dataLength);
-      printf (&quot;\n[lavc] error in FFMP43/mpeg4!: got picture\n&quot;);
-      //GUI_Alert(&quot;Please retry with misc-&gt;Turbo off&quot;);
-      //return 1;
-      return 0;
-    }
-  if (_context-&gt;hurry_up)
-    {
-      out-&gt;flags = frameType ();
-      return 1;
-    }
-  // We have an image....
-  switch (_context-&gt;pix_fmt)
-    {
-    case PIX_FMT_YUV411P:
-      out-&gt;_colorspace = ADM_COLOR_YUV411;
-      break;
-
-    case PIX_FMT_YUV422P:
-    case PIX_FMT_YUVJ422P:
-      out-&gt;_colorspace = ADM_COLOR_YUV422;
-      break;
-
-    case PIX_FMT_YUV444P:
-    case PIX_FMT_YUVJ444P:
-      out-&gt;_colorspace = ADM_COLOR_YUV444;
-      break;
-    case PIX_FMT_YUV420P:
-    case PIX_FMT_YUVJ420P:
-    case PIX_FMT_YUVA420P:
-      // Default is YV12 or I420
-      // In that case depending on swap u/v
-      // we do it or not
-      out-&gt;_colorspace = ADM_COLOR_YV12;
-      break;
-
-    case PIX_FMT_RGBA: // ???PIX_FMT_RGBA32:
-      out-&gt;_colorspace = ADM_COLOR_RGB32A;
-      break;
-    case PIX_FMT_RGB555:
-      out-&gt;_colorspace = ADM_COLOR_RGB555;
-      break;
-    case PIX_FMT_VDPAU_H264:
-        out-&gt;_colorspace=ADM_COLOR_VDPAU;
-        break;
-    default:
-      printf (&quot;[lavc] Unhandled colorspace: %d\n&quot;, _context-&gt;pix_fmt);
-      return 0;
-    }
-    clonePic (&amp;_frame, out);
-    //printf(&quot;[AvCodec] Pts : %llu Out Pts:%llu \n&quot;,_frame.pts,out-&gt;Pts);
-
-  return 1;
-}
-
-#define LOWDELAY() {} //_context-&gt;flags |= CODEC_FLAG_LOW_DELAY
-
-
-decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_MSMPEG4V3);
-}
-//**************************************************
-decoderFFMpeg4VopPacked::decoderFFMpeg4VopPacked (uint32_t w, uint32_t h):decoderFF (w,
-	   h)
-{
-/* In that case, we cannot use lowdelay...*/
-  _refCopy = 1;			// YUV420 only
-  _allowNull = 1;
-  decoderMultiThread ();
-  WRAP_Open (CODEC_ID_MPEG4);
-  printf(&quot;[lavc] Non low delay mpeg4 decoder initialized\n&quot;);
-}
-uint8_t decoderFFMpeg4VopPacked::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-    // For pseudo startcode
-    if(in-&gt;dataLength)
-    {
-        in-&gt;data[in-&gt;dataLength]=0;
-        in-&gt;data[in-&gt;dataLength+1]=0;
-    }
-    return decoderFF::uncompress(in,out);
-
-}
-
-decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-// force low delay as avidemux don't handle B-frames
-  LOWDELAY();
-  printf (&quot;[lavc] Using %d bytes of extradata for MPEG4 decoder\n&quot;, l);
-  
-  _refCopy = 1;			// YUV420 only
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
-  _context-&gt;codec_tag=fcc;
-  _context-&gt;stream_codec_tag=fcc;
-  decoderMultiThread ();
-  //  _context-&gt;flags|=FF_DEBUG_VIS_MV;
-  WRAP_Open (CODEC_ID_MPEG4);
-}
-uint8_t decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-    // For pseudo startcode
-    if(in-&gt;dataLength)
-    {
-        in-&gt;data[in-&gt;dataLength]=0;
-        in-&gt;data[in-&gt;dataLength+1]=0;
-    }
-    return decoderFF::uncompress(in,out);
-
-}
-//************************************
-decoderFFDV::decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
-  WRAP_Open (CODEC_ID_DVVIDEO);
-
-}
-decoderFFMP42::decoderFFMP42 (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_MSMPEG4V2);
-
-}
-decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
-	   h)
-{
-  int
-    got_picture = 0;
-  LOWDELAY();
-  _refCopy = 1;			// YUV420 only
-  decoderMultiThread ();
-  WRAP_Open (CODEC_ID_MPEG2VIDEO);
-}
-decoderFFSVQ3::decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
-	   h)
-{
-  int
-    got_picture = 0;
-
-  LOWDELAY();
-  _context-&gt;extradata = (uint8_t *) extraData;
-  _context-&gt;extradata_size = (int) extraLen;
-  WRAP_Open (CODEC_ID_SVQ3);
-}
-
-decoderFFH263::decoderFFH263 (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_H263);
-
-}
-decoderFFV1::decoderFFV1 (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_FFV1);
-}
-decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
-	   h)
-{
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
-  _context-&gt;bits_per_coded_sample=bpp;
-  printf (&quot;[lavc] FFhuff: We have %d bytes of extra data\n&quot;, l);
-  WRAP_Open (CODEC_ID_FFVHUFF);
-
-}
-decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d, uint32_t lowdelay):decoderFF (w,
-	   h)
-{
-  _lowDelay=lowdelay;
-  _refCopy = 1;			// YUV420 only
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
-  decoderMultiThread ();
-  if(lowdelay)
-    LOWDELAY();
-  printf (&quot;[lavc] Initializing H264 decoder with %d extradata\n&quot;, l);
-
-       {
-        WRAP_Open(CODEC_ID_H264);
-    }
-
-
-}
-//*********************
-extern &quot;C&quot; {int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc);}
-
-uint8_t   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-  if(!_context-&gt;hurry_up) return decoderFF::uncompress (in, out);
-  
-  uint32_t nalSize, isAvc;
-  av_getAVCStreamInfo(_context,&amp;nalSize,&amp;isAvc);
-  if(isAvc)
-  {
-      return extractH264FrameType(nalSize, in-&gt;data,in-&gt;dataLength,&amp;(out-&gt;flags));
-  }else
-  {
-    return extractH264FrameType_startCode(nalSize, in-&gt;data,in-&gt;dataLength,&amp;(out-&gt;flags));
-  }
-}
-//*********************
-decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
-	   h)
-{
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
-  _context-&gt;bits_per_coded_sample = bpp;
-  WRAP_Open (CODEC_ID_HUFFYUV);
-}
-decoderFFWMV2::decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
-
-  WRAP_Open (CODEC_ID_WMV2);
-
-}
-decoderFFWMV1::decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
-
-  WRAP_Open (CODEC_ID_WMV1);
-
-}
-
-decoderFFWMV3::decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
-
-  WRAP_Open (CODEC_ID_WMV3);
-
-}
-
-decoderFFVC1::decoderFFVC1(uint32_t w, uint32_t h, uint32_t l, uint8_t * d) : decoderFF(w, h)
-{
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
-
-  WRAP_Open (CODEC_ID_VC1);
-}
-
-decoderFFcyuv::decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
-
-  WRAP_Open (CODEC_ID_CYUV);
-}
-decoderFFMJPEG::decoderFFMJPEG (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  WRAP_Open (CODEC_ID_MJPEG);
-}
-decoderFFTheora::decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context-&gt;extradata = (uint8_t *) d;
-  _context-&gt;extradata_size = (int) l;
-  WRAP_Open (CODEC_ID_THEORA);
-}
-decoderSnow::decoderSnow (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  WRAP_Open (CODEC_ID_SNOW);
-}
-//*************
-decoderCamtasia::decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp):decoderFF (w,  h)
-{
-  _context-&gt;bits_per_coded_sample = bpp;
-  WRAP_Open (CODEC_ID_TSCC);
-}
-//*************
-decoderFFCinepak::decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_CINEPAK);
-}
-//*************
-decoderFFCRAM::decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_MSVIDEO1);
-}
-//*************
-decoderFFVP6F::decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_VP6F);
-}
-//*************
-decoderFFVP6A::decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_VP6A);
-}
-
-//*************
-decoderFFSVQ1::decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_SVQ1);
-}
-
-//************
-decoderFFFLV1::decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_FLV1);
-}
-decoderFFAMV::decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
-{
-  WRAP_Open (CODEC_ID_AMV);
-  //_context-&gt;codec_id=CODEC_ID_AMV;
-}
-decoderFFMjpegB::decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
-{
-  WRAP_Open (CODEC_ID_MJPEGB);
-  //_context-&gt;codec_id=CODEC_ID_AMV;
-}
-decoderFFDVBSub::decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  _context-&gt;sub_id=1;
-  WRAP_Open (CODEC_ID_DVB_SUBTITLE);
-}
-//*********************
-/**
-    \fn decoderFFSubs
-    \brief Constructor for DVB subtitles...
-*/
-
-decoderFFSubs::decoderFFSubs (uint32_t subid)
-{
-  _context = avcodec_alloc_context ();
-  codecId= CODEC_ID_DVB_SUBTITLE;
-  subId=subid;
-  _context-&gt;sub_id=subId;
-  WRAP_Open (CODEC_ID_DVB_SUBTITLE);
-}
-decoderFFSubs:: ~ decoderFFSubs ()
-{
-  avcodec_close (_context);
-  ADM_dealloc (_context);
-  _context=NULL;
-  
-}
-
-uint8_t decoderFFSubs::uncompress (ADMCompressedImage * in, AVSubtitle * out)
-{
-  int ret=0;
-  int got_picture=0;
-  ret=avcodec_decode_subtitle(_context, out,
-                            &amp;got_picture,
-                            in-&gt;data, in-&gt;dataLength); 
-     if(ret&lt;0) 
-     {
-        printf(&quot;[lavc] FFSUB Error %d\n&quot;,ret);
-        return 0; 
-     }
-     return 1;
-}
-
-
-//***************
-extern uint8_t  lavformat_init(void);
-extern void     avcodec_init(void );
-extern  void    avcodec_register_all(void );
-extern &quot;C&quot;
-{
-  void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list);
-}
-/**
-    \fn ADM_lavInit
-    \brief Init both lavcodec and lavformat
-*/
-void ADM_lavInit(void)
-{
-    avcodec_init();
-    avcodec_register_all();
-//BAZOOKA    lavformat_init();
-    av_log_set_callback(adm_lavLogCallback);
-#ifdef ADM_DEBUG
-  //  av_log_set_level(AV_LOG_DEBUG);
-#endif
-
-}
-void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list)
-{
-   // if(level&gt;1) return;
-    char buf[256];
-  
-    vsnprintf(buf, sizeof(buf), fmt, list);
-    printf(&quot;[lavc] %s&quot;,buf);
-}
-
-void ADM_lavDestroy(void)
-{
-	//av_free_static();
-}
-
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,397 +0,0 @@
-/***************************************************************************
-                          ADM_ffmp43.h  -  description
-                             -------------------
-                             
-	Mpeg4 ****decoder******** using ffmpeg
-	                              
-    begin                : Wed Sep 25 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_lavcodec.h&quot;
-class decoderFFSubs
-{
-  protected:
-     int      codecId;
-     uint32_t subId;
-     AVCodecContext *_context;
-  public:
-
-    decoderFFSubs (uint32_t subId);
-    virtual ~ decoderFFSubs ();
-    virtual uint8_t uncompress (ADMCompressedImage * in, AVSubtitle * out); 
-};
-
-/****************************/
-class decoderFF:public decoders
-{
-protected:
-
-  int codecId;
-  uint8_t _refCopy;
-  AVCodecContext *_context;
-  AVFrame _frame;
-  uint8_t *_internalBuffer;
-  uint8_t _allowNull;
-  uint32_t _swapUV;
-  uint32_t frameType (void);
-  uint8_t clonePic (AVFrame * src, ADMImage * out);
-  void decoderMultiThread ();
-  uint32_t _showMv;
-  uint32_t _gmc;
-  uint32_t _usingMT;
-public:
-
-    decoderFF (uint32_t w, uint32_t h);
-    virtual ~ decoderFF ();
-  virtual uint8_t dontcopy (void)
-  {
-    return 1;
-  }
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-  virtual void setParam (void);
-  virtual uint8_t bFramePossible (void)
-  {
-    return 0;
-  }
-  virtual uint8_t decodeHeaderOnly (void);
-  virtual uint8_t decodeFull (void);
-  virtual uint8_t isDivxPacked (void);
-  virtual uint32_t getSpecificMpeg4Info (void);
-  virtual uint8_t getPARWidth (void);
-  virtual uint8_t getPARHeight (void);
-  virtual bool    flush(void);
-};
-
-class decoderFFDiv3:public decoderFF
-{
-protected:
-
-
-public:
-
-  decoderFFDiv3 (uint32_t w, uint32_t h);
-
-};
-class decoderFFMpeg4VopPacked:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFMpeg4VopPacked (uint32_t w, uint32_t h);
-  uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-  // mpeg4 can have B-frame
-  virtual uint8_t bFramePossible (void)
-  {
-    return 0;
-  }
-  // Vop packed are not indexable
-  virtual uint8_t isIndexable (void)
-  {
-    return 0;
-  };
-};
-class decoderFFMpeg4:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d);
-  uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-  // mpeg4 can have B-frame
-  virtual uint8_t bFramePossible (void)
-  {
-    return 1;
-  }
-
-};
-class decoderFFMpeg12:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-  // mpeg1/2 can have B-frame
-  virtual uint8_t bFramePossible (void)
-  {
-    return 1;
-  }
-
-};
-class decoderFFSVQ3:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-  virtual uint8_t bFramePossible (void)
-  {
-    return 0;
-  }
-
-};
-
-class decoderFFDV:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-class decoderFFMP42:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFMP42 (uint32_t w, uint32_t h);
-
-};
-class decoderFFH263:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFH263 (uint32_t w, uint32_t h);
-
-};
-class decoderFFH264:public decoderFF
-{
-protected:
-  uint32_t _lowDelay;
-
-public:
-  decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t lowdelay);
-  virtual uint8_t bFramePossible (void)
-  {
-      return _lowDelay;
-  }
-  uint8_t   uncompress (ADMCompressedImage * in, ADMImage * out);
-
-};
-class decoderFFhuff:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
-
-};
-class decoderFF_ffhuff:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
-
-};
-class decoderFFWMV2:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-class decoderFFWMV1:public decoderFF
-{
-  protected:
-
-
-  public:
-    decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-
-class decoderFFWMV3:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-
-class decoderFFVC1:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFVC1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-
-class decoderFFV1:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFV1 (uint32_t w, uint32_t h);
-
-};
-class decoderFFMJPEG:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFMJPEG (uint32_t w, uint32_t h);
-
-};
-class decoderSnow:public decoderFF
-{
-protected:
-
-
-public:
-  decoderSnow (uint32_t w, uint32_t h);
-
-};
-class decoderFFcyuv:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-class decoderCamtasia:public decoderFF
-{
-protected:
-
-
-public:
-  decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp);
-
-};
-class decoderFFTheora:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-
-class decoderFFCinepak:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-class decoderFFCRAM:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-class decoderFFVP6F:public decoderFF
-{
-protected:
-public:
-  decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFVP6A:public decoderFF
-{
-protected:
-public:
-  decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFFLV1:public decoderFF
-{
-protected:
-public:
-  decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFDVBSub:public decoderFF
-{
-protected:
-public:
-  decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFAMV:public decoderFF
-{
-protected:
-public:
-  decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFMjpegB:public decoderFF
-{
-protected:
-public:
-  decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFSVQ1:public decoderFF
-{
-protected:
-public:
-  decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-
-#ifdef USE_VDPAU
-class decoderFFVDPAU:public decoderFF
-{
-protected:
-                    int b_age;
-                    int ip_age[2];
-
-                    void     *vdpau;
-                    ADMImage *scratch;
-                    ADMImage *vdpau_copy;
-                    uint64_t vdpau_pts;
-                    bool     decode_status;
-                    bool     destroying;
-public:     // Callbacks
-                    int     getBuffer(AVCodecContext *avctx, AVFrame *pic);
-                    void    releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-                    void    goOn( const AVFrame *d,int type);            
-public:
-            // public API
-                    decoderFFVDPAU (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-                    ~decoderFFVDPAU();
-    virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-    virtual uint8_t dontcopy (void)
-                      {
-                        return 0;
-                      }
-     virtual uint8_t bFramePossible (void)
-      {
-        return 1;
-      }
-
-};
-
-#endif
-// EOF
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,343 +0,0 @@
-/***************************************************************************
-            \file              ADM_ffmpeg_vdpau.cpp  
-            \brief Decoder using half ffmpeg/half VDPAU
-
-    The ffmpeg part is to preformat inputs for VDPAU
-    VDPAU is loaded dynamically to be able to make a binary
-        and have something working even if the target machine
-        does not have vdpau
-    Some part, especially get/buffer and ip_age borrowed from xbmc
-        as the api from ffmpeg is far from clear....
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-extern &quot;C&quot; {
-#include &quot;ADM_lavcodec.h&quot;
-}
-#include &quot;ADM_default.h&quot;
-#ifdef USE_VDPAU
-extern &quot;C&quot; {
- #include &quot;ADM_ffmpeg/libavcodec/vdpau.h&quot;
-}
-
-#include &quot;vdpau/vdpau_x11.h&quot;
-#include &quot;vdpau/vdpau.h&quot;
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;ADM_dynamicLoading.h&quot;
-#include &quot;ADM_render/GUI_render.h&quot;
-#include &quot;ADM_ffmpeg_vdpau_internal.h&quot;
-#include &quot;prefs.h&quot;
-
-static VdpFunctions funcs;
-
-static bool vdpauWorking=false;
-
-static ADM_LibWrapper        vdpauDynaLoader;
-static VdpDeviceCreateX11    *ADM_createVdpX11;
-static VdpDevice             vdpDevice;
-static VdpGetProcAddress     *vdpProcAddress;
-
-#define aprintf(...) {}
-
-/**
-    \fn vdpauUsable
-    \brief Return true if  vdpau can be used...
-*/
-bool vdpauUsable(void)
-{
-    uint32_t v=false;
-    if(!vdpauWorking) return false;
-    if(!prefs-&gt;get(FEATURE_VDPAU,&amp;v)) v=false;
-    return v;
-}
-/**
-    \fn getFunc
-    \brief vdpau function pointers from ID
-*/
-static void *getFunc(uint32_t id)
-{
-    void *f;
-    if(VDP_STATUS_OK!=vdpProcAddress(vdpDevice,id,&amp;f)) return NULL;
-    return (void *)f;
-}
-/**
-    \fn vdpauProbe
-    \brief Try loading vdpau...
-*/
-bool vdpauProbe(void)
-{
-    memset(&amp;funcs,0,sizeof(funcs));
-    if(false==vdpauDynaLoader.loadLibrary(&quot;/usr/lib/libvdpau.so&quot;))
-    {
-        return false;
-    }
-    ADM_createVdpX11=(VdpDeviceCreateX11*)vdpauDynaLoader.getSymbol(&quot;vdp_device_create_x11&quot;);
-    if(!ADM_createVdpX11) return false;
-
-    //
-    GUI_WindowInfo xinfo;
-    void *draw;
-    draw=UI_getDrawWidget();
-    UI_getWindowInfo(draw,&amp;xinfo );
-    
-    // try to create....
-    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)xinfo.display,0,&amp;vdpDevice,&amp;vdpProcAddress))
-    {
-        return false;
-    }
-    // Now that we have the vdpProcAddress, time to get the functions....
-#define GetMe(fun,id)         funcs.fun= (typeof(funcs.fun))getFunc(id);ADM_assert(funcs.fun); 
-        
-    GetMe(getErrorString,VDP_FUNC_ID_GET_ERROR_STRING);
-    GetMe(getApiVersion,VDP_FUNC_ID_GET_API_VERSION);
-    GetMe(getInformationString,VDP_FUNC_ID_GET_INFORMATION_STRING);
-
-    GetMe(createSurface,VDP_FUNC_ID_VIDEO_SURFACE_CREATE);
-    GetMe(destroySurface,VDP_FUNC_ID_VIDEO_SURFACE_DESTROY);
-    GetMe(getDataSurface,VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR);
-
-    GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
-    GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
-    GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
-
-
-
-    const char *versionString=NULL;
-    uint32_t version=0xff;
-        funcs.getInformationString(&amp;versionString);
-        funcs.getApiVersion(&amp;version);
-        printf(&quot;[VDPAU] API : 0x%x, info : %s\n&quot;,version,versionString);
-
-    vdpauWorking=true;
-    return true;
-}
-/**
-    \fn ADM_VDPAUgetBuffer
-    \brief trampoline to get a VDPAU surface
-*/
-int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx-&gt;opaque;
-    return dec-&gt;getBuffer(avctx,pic);
-}
-/**
-    \fn getBuffer
-    \brief returns a VDPAU render masquerading as a AVFrame
-*/
-int decoderFFVDPAU::getBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-    vdpau_render_state * render;
-    if(VDPAU-&gt;freeQueue.size()==0)
-    {
-        printf(&quot;[VDPAU] No more available surface\n&quot;);
-        return -1;
-    }
-    // Get an image   
-    render=VDPAU-&gt;freeQueue.back();
-    VDPAU-&gt;freeQueue.pop_back();
-    render-&gt;state=0;
-    pic-&gt;data[0]=(uint8_t *)render;
-    pic-&gt;data[1]=(uint8_t *)render;
-    pic-&gt;data[2]=(uint8_t *)render;
-    pic-&gt;linesize[0]=0;
-    pic-&gt;linesize[1]=0;
-    pic-&gt;linesize[2]=0;
-    pic-&gt;type=FF_BUFFER_TYPE_USER;
-    render-&gt;state |= FF_VDPAU_STATE_USED_FOR_REFERENCE;
-    pic-&gt;reordered_opaque= avctx-&gt;reordered_opaque;
-    if(pic-&gt;reference)
-    {
-        pic-&gt;age=ip_age[0];
-        ip_age[0]=ip_age[1]+1;
-        ip_age[1]=1;
-        b_age++;
-    }else
-    {
-        pic-&gt;age=b_age;
-        ip_age[0]++;
-        ip_age[1]++;
-        b_age=1;
-    }
-    return 0;
-}
-/**
-    \fn releaseBuffer
-*/
-void decoderFFVDPAU::releaseBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-  vdpau_render_state * render;
-  int i;
-  if(destroying==true) return; // They are already freed...
-  render=(vdpau_render_state*)pic-&gt;data[0];
-  ADM_assert(render);
-
-  render-&gt;state &amp;= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
-  for(i=0; i&lt;4; i++){
-    pic-&gt;data[i]= NULL;
-  }
-  VDPAU-&gt;freeQueue.push_back(render);
-}
-/**
-    \fn ADM_VDPAUreleaseBuffer
-*/
- void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx-&gt;opaque;
-    dec-&gt;releaseBuffer(avctx,pic);
-}
-/**
-    \fn decoderFFVDPAU
-*/
-decoderFFVDPAU::decoderFFVDPAU(uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-        destroying=false;
-        _context-&gt;opaque          = this;
-        _context-&gt;get_buffer      = ADM_VDPAUgetBuffer;
-        _context-&gt;release_buffer  = ADM_VDPAUreleaseBuffer;
-        _context-&gt;draw_horiz_band = draw;
-        _context-&gt;slice_flags     = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
-        _context-&gt;extradata = (uint8_t *) d;
-        _context-&gt;extradata_size = (int) l;
-
-        vdpau=(void *)new vdpauContext;
-        VDPAU-&gt;vdpDecoder=VDP_INVALID_HANDLE;
-        WRAP_OpenByName(h264_vdpau,CODEC_ID_H264);
-        
-        // Now instantiate our VDPAU surface &amp; decoder
-        ADM_assert(VDP_STATUS_OK==funcs.decoderCreate(vdpDevice,VDP_DECODER_PROFILE_H264_HIGH,w,h,15,&amp;(VDPAU-&gt;vdpDecoder)));
-        // Create our surfaces...
-        for(int i=0;i&lt;NB_SURFACE;i++)
-        {
-            VDPAU-&gt;renders[i]=new vdpau_render_state;
-            memset(VDPAU-&gt;renders[i],0,sizeof( vdpau_render_state));
-            ADM_assert(VDP_STATUS_OK==funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,w,h,&amp;(VDPAU-&gt;renders[i]-&gt;surface)));
-            VDPAU-&gt;freeQueue.push_back(VDPAU-&gt;renders[i]);
-        }
-        scratch=new ADMImage(w,h,1);
-        b_age = ip_age[0] = ip_age[1] = 256*256*256*64;
-
-}
-/**
-    \fn ~            void    goOn( const AVFrame *d);
-*/
-decoderFFVDPAU::~decoderFFVDPAU()
-{
-        printf(&quot;[VDPAU] Cleaning up\n&quot;);
-        destroying=true;
-        for(int i=0;i&lt;NB_SURFACE;i++)
-        {
-            ADM_assert(VDP_STATUS_OK==funcs.destroySurface((VDPAU-&gt;renders[i]-&gt;surface)));
-            delete VDPAU-&gt;renders[i];
-        }
-         ADM_assert(VDP_STATUS_OK==funcs.decoderDestroy(VDPAU-&gt;vdpDecoder));
-         delete VDPAU;
-         vdpau=NULL;
-}
-/**
-    \fn uncompress
-*/
-uint8_t decoderFFVDPAU::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-VdpStatus status;
-    
-    // First let ffmpeg prepare datas...
-    vdpau_copy=out;
-    decode_status=false;
-    if(!decoderFF::uncompress (in, scratch))
-    {
-        printf(&quot;[VDPAU] No data from libavcodec\n&quot;);
-        return 0;
-    }
-    if(decode_status!=true)
-    {
-        printf(&quot;[VDPAU] error in renderDecode\n&quot;);
-        return 0;
-    }
-    // other part will be done in goOn
-  struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch-&gt;_planes[0];
-   VdpVideoSurface  surface;
-
-    surface=rndr-&gt;surface;
- void *planes[3];
-            planes[0]=vdpau_copy-&gt;GetWritePtr(PLANAR_Y);
-            planes[1]=vdpau_copy-&gt;GetWritePtr(PLANAR_U);
-            planes[2]=vdpau_copy-&gt;GetWritePtr(PLANAR_V);
-    uint32_t stride[3];
-            stride[0]=vdpau_copy-&gt;GetPitch(PLANAR_Y);
-            stride[1]=vdpau_copy-&gt;GetPitch(PLANAR_U);
-            stride[2]=vdpau_copy-&gt;GetPitch(PLANAR_V);
-
-    
-   // Copy back the decoded image to our output ADM_image
-   aprintf(&quot;[VDPAU] Getting datas from surface %d\n&quot;,surface);
-    status=funcs.getDataSurface(
-                surface,
-                VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
-                planes, //void * const *   destination_data,
-                stride //destination_pitches
-                );
-    if(VDP_STATUS_OK!=status)
-    {
-        
-        printf(&quot;[VDPAU] Cannot get data from surface &lt;%s&gt;\n&quot;,funcs.getErrorString(status));
-        decode_status=false;
-        return 0 ;
-    }
-    
-
-    //
-    out-&gt;Pts=scratch-&gt;Pts;
-    out-&gt;flags=scratch-&gt;flags;
-    return (uint8_t)decode_status;
-}
-/**
-    \fn goOn
-    \brief Callback from ffmpeg when a pic is ready to be decoded
-*/
-void decoderFFVDPAU::goOn( const AVFrame *d,int type)
-{
-   VdpStatus status;
-   struct vdpau_render_state *rndr = (struct vdpau_render_state *)d-&gt;data[0];
-   VdpVideoSurface  surface;
-
-    surface=rndr-&gt;surface;
-    vdpau_pts=d-&gt;reordered_opaque; // Retrieve our PTS
-
-     aprintf(&quot;[VDPAU] Decoding Using surface %d\n&quot;, surface);
-    status=funcs.decoderRender(VDPAU-&gt;vdpDecoder, surface,
-                            (void * const *)&amp;rndr-&gt;info, rndr-&gt;bitstream_buffers_used, rndr-&gt;bitstream_buffers);
-    if(VDP_STATUS_OK!=status)
-    {
-        printf(&quot;[VDPAU] No data after decoderRender &lt;%s&gt;\n&quot;,funcs.getErrorString(status));
-        decode_status=false;
-        return ;
-    }
-    aprintf(&quot;[VDPAU] DecodeRender Ok***\n&quot;);
-    decode_status=true;
-    return;
-}
-
-
-/**
-    \fn draw
-    \brief callback invoked by lavcodec when a pic is ready to be decoded
-*/
-void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)s-&gt;opaque;
-    dec-&gt;goOn(src,type);
-}
-
-#endif
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,82 +0,0 @@
-/***************************************************************************
-            \file              ADM_ffmpeg_vdpau.cpp  
-            \brief Decoder using half ffmpeg/half VDPAU
-
-    The ffmpeg part is to preformat inputs for VDPAU
-    VDPAU is loaded dynamically to be able to make a binary
-        and have something working even if the target machine
-        does not have vdpau
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_ffmpeg_vdpa_internal_H
-#define ADM_ffmpeg_vdpa_internal_H
-#include &lt;vector&gt;
-extern &quot;C&quot; {
-static void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height);
-static int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic);
-static void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-}
-
-
-#define NB_SURFACE 50
-typedef struct 
-{
-        VdpDecoder            vdpDecoder;
-        vdpau_render_state *renders[NB_SURFACE];
-        std::vector &lt;vdpau_render_state *&gt;freeQueue;
-
-}vdpauContext;
-
-#define VDPAU ((vdpauContext *)vdpau)
-
-// VDPAU internal linker
-
-typedef struct 
-{
-    VdpGetErrorString       *getErrorString;
-    VdpGetApiVersion        *getApiVersion;
-    VdpGetInformationString *getInformationString;
-
-    VdpVideoSurfaceCreate   *createSurface;
-    VdpVideoSurfaceDestroy  *destroySurface;
-    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
-
-    VdpDecoderCreate        *decoderCreate;
-    VdpDecoderDestroy       *decoderDestroy;
-    VdpDecoderRender        *decoderRender;
-
-}VdpFunctions;
-
-#define WRAP_Open_Template(funcz,argz,display,codecid) \
-{\
-AVCodec *codec=funcz(argz);\
-if(!codec) {GUI_Error_HIG(&quot;Codec&quot;,QT_TR_NOOP(&quot;Internal error finding codec&quot;display));ADM_assert(0);} \
-  codecId=codecid; \
-  _context-&gt;workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
-  _context-&gt;error_concealment=3; \
-  if (avcodec_open(_context, codec) &lt; 0)  \
-                      { \
-                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder failed!\n&quot;); \
-                                        GUI_Error_HIG(&quot;Codec&quot;,&quot;Internal error opening &quot;display); \
-                                        ADM_assert(0); \
-                                } \
-                                else \
-                                { \
-                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder initialized! (%s)\n&quot;,codec-&gt;long_name); \
-                                } \
-}
-
-#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
-#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
-
-#endif
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,115 +0,0 @@
-#if 0
-/***************************************************************************
-                          ADM_mjpeg.cpp  -  description
-                             -------------------
-          I think i could use plain jpeg instead but....
-
-
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &quot;ADM_assert.h&quot;
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-#include &quot;ADM_default.h&quot;
-#include &quot;config.h&quot;
-#ifdef USE_MJPEG
-#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_mjpeg.h&quot;
-extern &quot;C&quot;
-{
-#include &quot;mjpegtools/jpegutils.h&quot;
-}
-#include &quot;ADM_gui/GUI_decodersettings.h&quot;
- /*
-  * jpeg_data:       buffer with input / output jpeg
-  * len:             Length of jpeg buffer
-  * itype:           LAV_INTER_NONE: Not interlaced
-  *                  LAV_INTER_TOP_FIRST: Interlaced, top-field-first
-  *                  LAV_INTER_BOTTOM_FIRST: Interlaced, bottom-field-first
-  * ctype            Chroma format for decompression.
-  *                  Currently always 420 and hence ignored.
-  * raw0             buffer with input / output raw Y channel
-  * raw1             buffer with input / output raw U/Cb channel
-  * raw2             buffer with input / output raw V/Cr channel
-  * width            width of Y channel (width of U/V is width/2)
-  * height           height of Y channel (height of U/V is height/2)
-
-
-  int decode_jpeg_raw (unsigned char *jpeg_data, int len,
-  int itype, int ctype, int width, int height,
-  unsigned char *raw0, unsigned char *raw1,
-  unsigned char *raw2);
-
-  */
-void
-decoderMjpeg::setParam (void)
-{
-  int param;
-
-  param = _swap;
-  if (1 == getMjpegParams (&amp;param))
-    {
-      _swap = param;
-    }
-
-}
-//________________________________________________
-
-uint8_t
-  decoderMjpeg::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			    uint32_t * flagz)
-{
-  //
-  uint32_t delta;
-  uint8_t *outu, *outv;
-  //
-  UNUSED_ARG (flagz);
-
-
-  delta = _w * _h;
-
-  outu = out + delta;
-  outv = outu + (delta &gt;&gt; 2);
-  if (!_swap)
-
-    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outu, outv);
-
-  else
-    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outv, outu);
-
-  return 1;
-
-
-}
-
-//_____________________________________________________
-
-decoderMjpeg::~decoderMjpeg ()
-{
-
-
-}
-// constructor for mjpeg, init encoder and stuff
-decoderMjpeg::decoderMjpeg (uint32_t w, uint32_t h):decoders (w, h)
-{
-  // some mjpeg are encoded with u &amp; v inverted
-  _swap = 0;
-
-}
-#endif
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,29 +0,0 @@
-/***************************************************************************
-                          ADM_mjpeg.h  -  description
-                             -------------------
-    begin                : Sat Apr 13 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-class decoderMjpeg:decoders
-{
-protected:
-  uint8_t _swap;
-
-public:
-  decoderMjpeg (uint32_t w, uint32_t h);
-  virtual ~ decoderMjpeg ();
-  virtual void setParam (void);
-  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			      uint32_t * flag = NULL);
-};

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,180 +0,0 @@
-/***************************************************************************
-                          ADM_png.cpp  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#ifdef USE_PNG
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-
-#include &quot;ADM_default.h&quot;
-
-//#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_png.h&quot;
-extern &quot;C&quot;
-{
-#include &quot;png.h&quot;
-}
-#include &quot;ADM_assert.h&quot;
-
-#define PNG_PTR ((png_structp)png_ptr)
-#define INFO_PTR ((png_infop)info_ptr)
-#define INFO_END ((png_infop)end_info)
-/*
-   	Initialize codec
-*/
-static void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length);
-
-void decoderPng::recalc (void)
-{
-  int mul;
-  if (colorspace == ADM_COLOR_RGB24)
-    mul = 3;
-
-  else
-    mul = 4;
-  for (int i = 0; i &lt; _h; i++)
-    rows[i] = decoded + mul * _w * i;
-}
-
-
-decoderPng::decoderPng (uint32_t w, uint32_t h):decoders (w, h)
-{
-  rows = NULL;
-  decoded = NULL;
-  colorspace = ADM_COLOR_RGB24;
-
-  //****************************
-  // Prepare the decoded buffer*
-  //****************************
-  decoded = new uint8_t[4 * w * h];	// We take a bit more to be able to decode 32 bits png
-  // without causing a segfault
-  rows = new uint8_t *[h];
-  recalc ();
-}
- void decoderPng::Init (void)
-{
-  png_ptr =
-    (void *) png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-  ADM_assert (png_ptr);
-  info_ptr = (void *) png_create_info_struct (PNG_PTR);
-  ADM_assert (info_ptr);
-  end_info = (void *) png_create_info_struct (PNG_PTR);
-  ADM_assert (end_info);
-  memset (&amp;io, 0, sizeof (io));
-  png_set_read_fn (PNG_PTR, &amp;io, user_read_data);
-  png_set_rows (PNG_PTR, INFO_PTR, (png_byte **) rows);
-}
-void decoderPng::Cleanup (void)
-{
-  png_destroy_read_struct ((png_structpp) &amp; png_ptr, (png_infopp) &amp; info_ptr,
-			   (png_infopp) &amp; end_info);
-}
-decoderPng::~decoderPng ()
-{
-  delete[]rows;
-  delete[]decoded;
-}
-/*
-   	Uncompress frame, set flags if needed
-*/
-uint8_t decoderPng::uncompress(ADMCompressedImage * in, ADMImage * out)
-{
-  int bpp;
-  int colortype;
-
-  // Check if it is png, and fill it
-  if (!!png_sig_cmp (in-&gt;data, 0, 8))
-
-    {
-      printf (&quot;[PNG] wrong sig\n&quot;);
-      return 0;
-    }
-
-  //
-  //
-gain2:
-  Init ();
-  io.data = in-&gt;data;
-  io.size = in-&gt;dataLength;
-  io.cur = 0;
-  png_read_png (PNG_PTR, INFO_PTR, PNG_TRANSFORM_IDENTITY, NULL);
-
-  // Check if it is 24 or 32 bits RGB 
-  bpp = png_get_bit_depth (PNG_PTR, INFO_PTR);
-//   printf(&quot;Bpp:%u\n&quot;,bpp);
-  // if needed we change colorspace 
-  colortype = png_get_color_type (PNG_PTR, INFO_PTR);
-  // 
-  if (colorspace == ADM_COLOR_RGB24 &amp;&amp; colortype == PNG_COLOR_TYPE_RGB_ALPHA)	// RGB32
-    {
-
-      // Switch to 32 bits
-      colorspace = ADM_COLOR_RGB32A;
-      recalc ();
-      goto gain2;
-    }
-
-  else if (colorspace == ADM_COLOR_RGB32A &amp;&amp; colortype == PNG_COLOR_TYPE_RGB)
-
-    {
-
-      // Switch to 24 bits
-      colorspace = ADM_COLOR_RGB24;
-      recalc ();
-      goto gain2;
-    }
-  ADM_assert (out-&gt;_isRef);
-  out-&gt;_planes[0] = decoded;
-  out-&gt;_planes[1] = NULL;
-  out-&gt;_planes[2] = NULL;
-  if (colorspace == ADM_COLOR_RGB32A)
-    out-&gt;_planeStride[0] = _w * 4;
-
-  else
-    out-&gt;_planeStride[0] = _w * 3;
-  out-&gt;_planeStride[1] = 0;
-  out-&gt;_planeStride[2] = 0;
-  out-&gt;_colorspace = colorspace;
-  Cleanup ();
-  return 1;
-}
-
-// ******************************************************
-//    Memory based IO
-// ******************************************************
-void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length)
-{
-  memAccess *ac;
-  ac = (memAccess *) png_get_io_ptr (png_ptr);
-  ADM_assert (length + ac-&gt;cur &lt;= ac-&gt;size);	// or &lt; ?
-  memcpy (data, ac-&gt;data + ac-&gt;cur, length);
-  ac-&gt;cur += length;
-} 
-
-void user_write_data (png_structp png_ptr, png_bytep data, png_size_t length)
-{
-} 
-
-void user_flush_data (png_structp png_ptr)
-{
-}
-//EOF
-#endif /*  */

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,78 +0,0 @@
-/***************************************************************************
-                          ADM_png  -  description
-                             -------------------
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
- 
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/ 
-#ifndef PNG_H_A
-#define PNG_H_A
-#ifdef USE_PNG
-
-typedef struct memAccess 
-{
-  
-int size;
-   
-int cur;
-   
-uint8_t * data;
-
-
-} memAccess;
-
-
-class decoderPng:public decoders 
-{
-
-protected:
-memAccess io;
-  
-ADM_colorspace colorspace;
-  
-void *png_ptr;
-  
-void *info_ptr;
-  
-void *end_info;
-  
-
-uint8_t ** rows;
-  
-uint8_t * decoded;
-  
-void Init (void);
-  
-void Cleanup (void);
-  
-void recalc (void);
-
-public:
-decoderPng (uint32_t w, uint32_t h);
-  
-virtual ~ decoderPng ();
-  
-virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
-  
-uint8_t dontcopy (void)
-  {
-    return 1;
-  }
-
-
-
-};
-
-#endif /* 
- */
-#endif /* 
- */

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,125 +0,0 @@
-/***************************************************************************
-                          ADM_rgb16.cpp  -  description
-                             -------------------
-    begin                : Mon May 27 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &quot;ADM_default.h&quot;
-//#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_rgb16.h&quot;
-
-decoderRGB16::decoderRGB16(uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp) : decoders (w, h)
-{
-	isRgb = rgb;
-	_bpp = bpp;
-
-	decoded = new uint8_t[_bpp * w * h];
-}
-
-decoderRGB16::~decoderRGB16()
-{
-	delete[] decoded;
-}
-
-uint8_t decoderRGB16::uncompress(ADMCompressedImage * in, ADMImage * out)
-{
-	int xx = _w * _h;
-	int lineSize = (_w * (_bpp / 8) + 3) &amp; ~3;
-	ADM_colorspace colorspace;
-	int i, j;
-	uint8_t *src = in-&gt;data;
-	uint8_t *dst = decoded;
-
-	switch (_bpp)
-	{
-		case 16:
-			// FIXME - 16-bit could use a BGR555 or BGR565 colour mask
-			colorspace = ADM_COLOR_BGR555;
-			break;
-		case 24:
-		case 32:
-			if(isRgb)
-				colorspace = ADM_COLOR_RGB24;
-			else
-				colorspace = ADM_COLOR_BGR24;
-
-			break;
-		default:
-			printf(&quot;bpp %d not supported\n&quot;, _bpp);
-			return 0;
-	}
-
-	if (_bpp == 32)
-	{
-		for(i = 0; i &lt; _h; i++)
-		{
-			uint8_t *buf = src;
-			uint8_t *ptr = dst;
-
-			for(j = 0; j &lt; _w; j++)
-			{
-				ptr[0] = buf[0];
-				ptr[1] = buf[1];
-				ptr[2] = buf[2];
-				ptr += 3;
-				buf += 4;
-			}
-
-			src += lineSize;
-			dst += _w * 3;
-		}
-	}
-	else
-	{
-		memcpy(decoded, in-&gt;data, lineSize * _h);
-
-		if (lineSize == _w * _bpp)
-		{
-			// no extra junk in scanlines so copy as is
-			memcpy(decoded, in-&gt;data, lineSize * _h);
-		}
-		else
-		{
-			// strip extra junk from scanlines (due to 4 byte alignment)
-			for(i = 0; i &lt; _h; i++)
-			{
-				memcpy(dst, src, _w * (_bpp / 8));
-				src += lineSize;
-				dst += _w * (_bpp / 8);
-			}
-		}
-	}
-
-	ADM_assert(out-&gt;_isRef);
-
-	out-&gt;flags = AVI_KEY_FRAME;
-	out-&gt;_colorspace = (ADM_colorspace)(colorspace | ADM_COLOR_BACKWARD);
-
-	out-&gt;_planes[0] = decoded;
-	out-&gt;_planes[1] = NULL;
-	out-&gt;_planes[2] = NULL;
-
-	out-&gt;_planeStride[0] = (_bpp / 8) * _w;
-	out-&gt;_planeStride[1] = 0;
-	out-&gt;_planeStride[2] = 0;
-
-	return 1;
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,38 +0,0 @@
-/***************************************************************************
-                          ADM_rgb16.h  -  description
-                             -------------------
-    begin                : Mon May 27 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_RGB16_H
-#define ADM_RGB16_H
-
-#include &quot;ADM_colorspace.h&quot;
-
-class decoderRGB16 : decoders
-{
-	protected:
-		uint8_t* planar;
-		ColRgbToYV12* color;
-		uint32_t isRgb; // Else BGR
-		uint32_t _bpp;
-		uint8_t* decoded;
-
-	public:
-		uint8_t dontcopy (void) { return 1; }
-		decoderRGB16 (uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp);
-		virtual ~decoderRGB16();
-		virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
-};
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,116 +0,0 @@
-/***************************************************************************
-                          ADM_theora_dec.cpp  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
-#ifdef USE_THEORA
-#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-
-#include &quot;ADM_codecs/ADM_theora_dec.h&quot;
-//________________________________________________
-void
-decoderTheora::setParam (void)
-{
-  return;			// no param for ffmpeg
-}
-//-------------------------------
-decoderTheora::decoderTheora (uint32_t w, uint32_t h):decoders (w, h)
-{
-  memset (&amp;_tinfo, 0, sizeof (_tinfo));
-  memset (&amp;_tstate, 0, sizeof (_tstate));
-
-  _tinfo.width = _w;
-  _tinfo.height = _h;
-  _tinfo.fps_numerator = 25;
-  _tinfo.fps_denominator = 1;
-  _tinfo.aspect_numerator = 4;
-  _tinfo.aspect_denominator = 3;
-  _tinfo.quality = 9;
-
-  _tinfo.version_major = 3;
-  _tinfo.version_minor = 1;
-
-
-  theora_decode_init (&amp;_tstate, &amp;_tinfo);
-  printf (&quot;\n Theora initialized\n&quot;);
-}
-
-
-//-------------------------------
-
-uint8_t
-  decoderTheora::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			     uint32_t * flagz)
-{
-  int got_picture = 0;
-
-  if (len == 0)			// Null frame, silently skip
-    {
-      if (flagz)
-	*flagz = 0;
-      return 1;
-    }
-  ogg_packet ogg;
-
-  memset (&amp;ogg, 0, sizeof (ogg));
-  ogg.packet = in;
-  ogg.bytes = len;
-  /*
-     typedef struct {
-     unsigned char *packet;
-     long  bytes;
-     long  b_o_s;
-     long  e_o_s;
-
-     ogg_int64_t  granulepos;
-
-     ogg_int64_t  packetno;      sequence number for decode; the framing
-     knows where there's a hole in the data,
-     but we need coupling so that the codec
-     (which is in a seperate abstraction
-     layer) also knows about the gap 
-     } ogg_packet; */
-  if (theora_decode_packetin (&amp;_tstate, &amp;ogg))
-    {
-      printf (&quot;\n error decoding theora ..\n&quot;);
-      return 0;
-    }
-  yuv_buffer yuv;
-  theora_decode_YUVout (&amp;_tstate, &amp;yuv);
-  memcpy (out, yuv.y, _w * _h);
-  memset (out + _w * _h, 128, (_w * _h) &gt;&gt; 1);
-
-
-
-
-
-  return 1;
-}
-
-//_____________________________________________________
-
-decoderTheora::~decoderTheora ()
-{
-
-  printf (&quot;Theora destroyed\n&quot;);
-  theora_clear (&amp;_tstate);
-}
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,46 +0,0 @@
-/***************************************************************************
-                          ADM_theora_dec.h  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef USE_THEORA
-#ifndef __theora__
-#define __theora__
-
-extern &quot;C&quot;
-{
-#include &quot;theora/theora.h&quot;
-}
-class decoderTheora:public decoders
-{
-protected:
-
-
-  theora_info _tinfo;
-  theora_state _tstate;
-
-
-
-public:
-    decoderTheora (uint32_t w, uint32_t h);
-    virtual ~ decoderTheora ();
-  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			      uint32_t * flag = NULL);
-  virtual void setParam (void);
-
-
-};
-
-#endif
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,16 +0,0 @@
-/***************************************************************************
-                          ADM_theora_enc.h  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,113 +0,0 @@
-//
-// C++ Implementation: ADM_uyvy
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
-
-#ifdef HAVE_SYS_PARAM_H
-#include &lt;sys/param.h&gt;
-#endif
-#if  defined( __FreeBSD__ ) || defined(__APPLE__)
-#include &lt;sys/types.h&gt;
-#endif
-
-#include &quot;ADM_default.h&quot;
-#include &quot;avifmt.h&quot;
-#include &quot;avifmt2.h&quot;
-#include &quot;fourcc.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_codecs/ADM_uyvy.h&quot;
-
-uint8_t
-  decoderUYVY::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-
-  if (in-&gt;dataLength &lt; _w * _h * 2)
-    {
-      printf (&quot;in:%d expected%d\n&quot;, in-&gt;dataLength, _w * _h * 2);
-      return 1;
-    }
-  uint8_t *ptrY, *ptrU, *ptrV, *ptr;
-
-  ptr = in-&gt;data;
-  ptrY = out-&gt;data;
-  ptrU = out-&gt;data + _w * _h;
-  ptrV = ptrU + ((_w * _h) &gt;&gt; 2);
-
-  for (uint32_t y = 0; y &lt; _h; y++)
-    for (uint32_t x = 0; x &lt; (_w &gt;&gt; 2); x++)
-      {
-	if (!(y &amp; 1))
-	  {
-	    *ptrU++ = (*(ptr) + *(ptr + _w)) &gt;&gt; 1;
-	    ptr++;
-	    *ptrY++ = *ptr++;
-	    *ptrV++ = (*(ptr) + *(ptr + _w)) &gt;&gt; 1;
-	    ptr++;
-	    *ptrY++ = *ptr++;
-	  }
-	else
-	  {
-	    *ptrY++ = *(++ptr);
-	    *ptrY++ = *(ptr + 2);
-	    ptr++;
-	  }
-      }
-
-  
-  out-&gt;flags = AVI_KEY_FRAME;
-  return 1;
-
-}
-uint8_t
-  decoderYUY2::uncompress  (ADMCompressedImage * in, ADMImage * out)
-{
-
-  if (in-&gt;dataLength &lt; _w * _h * 2)
-    {
-      printf (&quot;in:%d expected%d\n&quot;, in-&gt;dataLength, _w * _h * 2);
-      return 1;
-    }
-  uint8_t *ptrY, *ptrU, *ptrV, *ptr;
-
-  ptr = in-&gt;data;
-  ptrY = out-&gt;data;
-  ptrV = out-&gt;data + _w * _h;
-  ptrU = out-&gt;data + ((_w * _h * 5) &gt;&gt; 2);
-
-
-  for (uint32_t y = 0; y &lt; _h; y++)
-    for (uint32_t x = 0; x &lt; (_w &gt;&gt; 1); x++)
-      {
-	if (!(y &amp; 1))
-	  {
-	    *ptrY++ = *ptr++;
-	    *ptrU++ = (*(ptr) + *(ptr + _w * 2)) &gt;&gt; 1;
-	    ptr++;
-	    *ptrY++ = *ptr++;
-	    *ptrV++ = (*(ptr) + *(ptr + _w * 2)) &gt;&gt; 1;
-	    ptr++;
-
-	  }
-	else
-	  {
-	    *ptrY++ = *(ptr);
-	    *ptrY++ = *(ptr + 2);
-	    ptr += 4;
-	  }
-      }
-
-
-  out-&gt;flags = AVI_KEY_FRAME;
-  return 1;
-
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,37 +0,0 @@
-//
-// C++ Interface: ADM_uyvy
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-class decoderUYVY:decoders
-{
-protected:
-
-public:
-  decoderUYVY (uint32_t w, uint32_t h):decoders (w, h)
-  {
-  };
-  virtual ~ decoderUYVY ()
-  {
-  };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-};
-class decoderYUY2:decoders
-{
-protected:
-
-public:
-  decoderYUY2 (uint32_t w, uint32_t h):decoders (w, h)
-  {
-  };
-  virtual ~ decoderYUY2 ()
-  {
-  };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-};

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,18 +0,0 @@
-SET(ADM_codecs_SRCS 
-ADM_codecs.cpp
-ADM_png.cpp
-ADM_theora_dec.cpp
-ADM_ffmp43.cpp
-ADM_mjpeg.cpp
-ADM_rgb16.cpp
-ADM_uyvy.cpp
-ADM_ffmpeg_vdpau.cpp
-)
-
-ADD_LIBRARY(ADM_codecs6 STATIC ${ADM_codecs_SRCS})
-
-IF (USE_PNG)
-	 ADD_SOURCE_CFLAGS(ADM_png.cpp ${PNG_CFLAGS})
-ENDIF (USE_PNG)
-
-REMOVE_DEFINITIONS(-DHAVE_CONFIG_H)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,7 +1,7 @@
 ADD_SUBDIRECTORY(ADM_audiocodec)
 ADD_SUBDIRECTORY(ADM_audioFilter)
 #ADD_SUBDIRECTORY(ADM_audioFilter_old)
-ADD_SUBDIRECTORY(ADM_codecs)
+#ADD_SUBDIRECTORY(ADM_codecs)
 ADD_SUBDIRECTORY(ADM_commonUI)
 ADD_SUBDIRECTORY(ADM_editor)
 #ADD_SUBDIRECTORY(ADM_filter)

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/CMakeLists.txt	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(src)

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,160 @@
+/***************************************************************************
+                          ADM_codec.h  -  description
+                             -------------------
+    begin                : Fri Apr 12 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef __CODECS__
+#define __CODECS__
+
+#include &quot;ADM_image.h&quot;
+#include &quot;ADM_frameType.h&quot;
+#include &quot;ADM_codecType.h&quot;
+
+#define ADM_QPEL_ON	1
+#define ADM_GMC_ON	2
+#define ADM_VOP_ON	4
+
+/*
+        Bitrate in configuration will always be in **kBITS**
+
+*/
+
+#include &quot;ADM_bitstream.h&quot;
+#include &quot;ADM_compressedImage.h&quot;
+/**
+    \class decoders
+    \brief base class for video decoders
+*/
+class decoders
+{
+protected:
+  uint32_t _w;
+  uint32_t _h;
+  uint8_t _lastQ;
+public:
+    decoders (uint32_t w, uint32_t h)
+  {
+    _w = w;
+    _h = h;
+    _lastQ = 0;
+  }
+  virtual ~ decoders ()
+  {
+  };
+  virtual uint8_t getPARWidth (void)
+  {
+    return 1;
+  };
+  virtual uint8_t getPARHeight (void)
+  {
+    return 1;
+  };
+  virtual void setParam (void)
+  {
+  };
+  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)=0;
+
+  // does this codec *possibly* can have b-frame ?
+  virtual uint8_t dontcopy (void)
+  {
+    return 0;
+  }				// if 1 means the decoder will return reference
+  // no need to copy the datas to ADMimage
+  virtual uint8_t bFramePossible (void)
+  {
+    return 0;
+  }
+  virtual uint8_t decodeHeaderOnly (void)
+  {
+    return 0;
+  };
+  virtual uint8_t decodeFull (void)
+  {
+    return 0;
+  }
+  virtual uint8_t isDivxPacked (void)
+  {
+    return 0;
+  };
+  virtual uint32_t getSpecificMpeg4Info (void)
+  {
+    return 0;
+  };
+  virtual uint8_t isIndexable (void)
+  {
+    return 1;
+  };
+  virtual bool flush(void)
+    {
+        return true;
+    }
+};
+/* Dummy decoder in case we don't have the desired one */
+class decoderEmpty : public decoders
+{
+protected:
+public:
+    decoderEmpty (uint32_t w, uint32_t h) : decoders(w,h) {};
+    uint8_t uncompress (ADMCompressedImage * in, ADMImage * out) {return 1;}
+
+};
+
+decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+		      uint8_t * extraData,uint32_t bpp=0);
+decoders *getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h,
+			       uint32_t extraLen, uint8_t * extraData);
+decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+		     uint8_t * extraData);
+
+class coders
+{
+protected:
+  uint32_t _w;
+  uint32_t _h;
+public:
+    coders (uint32_t w, uint32_t h)
+  {
+    _w = w;
+    _h = h;
+  }
+  virtual ~ coders ()
+  {
+  };
+  virtual uint8_t compress (ADMImage * in, ADMBitstream * out);
+};
+decoders *getCoder (uint32_t fcc, uint32_t w, uint32_t h);
+/*----------------------------------------------------------*/
+class encoder
+{
+protected:uint32_t _w, _h;
+public:encoder (uint32_t width, uint32_t height)
+  {
+    _w = width;
+    _h = height;
+  };
+  virtual uint8_t stopEncoder (void) = 0;
+  virtual uint8_t init (uint32_t val, uint32_t fps1000) = 0;
+  virtual uint8_t encode (ADMImage * in, ADMBitstream *out) = 0;
+  virtual uint8_t getExtraData (uint32_t * l, uint8_t ** d)
+  {
+    *l = 0;
+    *d = NULL;
+    return 0;
+  }
+};
+
+
+
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,33 @@
+/***************************************************************************
+                          ADM_codecNull.h  -  description
+                             -------------------
+    begin                : Fri Apr 19 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+class decoderNull:public decoders
+{
+protected:
+
+public:
+  decoderNull (uint32_t w, uint32_t h):decoders (w, h)
+  {
+  }
+  virtual ~ decoderNull ()
+  {
+  };
+  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)
+  {
+    memcpy (out-&gt;data, in-&gt;data, in-&gt;dataLength);
+    return 1;
+  }
+};

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,397 @@
+/***************************************************************************
+                          ADM_ffmp43.h  -  description
+                             -------------------
+                             
+	Mpeg4 ****decoder******** using ffmpeg
+	                              
+    begin                : Wed Sep 25 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_lavcodec.h&quot;
+class decoderFFSubs
+{
+  protected:
+     int      codecId;
+     uint32_t subId;
+     AVCodecContext *_context;
+  public:
+
+    decoderFFSubs (uint32_t subId);
+    virtual ~ decoderFFSubs ();
+    virtual uint8_t uncompress (ADMCompressedImage * in, AVSubtitle * out); 
+};
+
+/****************************/
+class decoderFF:public decoders
+{
+protected:
+
+  int codecId;
+  uint8_t _refCopy;
+  AVCodecContext *_context;
+  AVFrame _frame;
+  uint8_t *_internalBuffer;
+  uint8_t _allowNull;
+  uint32_t _swapUV;
+  uint32_t frameType (void);
+  uint8_t clonePic (AVFrame * src, ADMImage * out);
+  void decoderMultiThread ();
+  uint32_t _showMv;
+  uint32_t _gmc;
+  uint32_t _usingMT;
+public:
+
+    decoderFF (uint32_t w, uint32_t h);
+    virtual ~ decoderFF ();
+  virtual uint8_t dontcopy (void)
+  {
+    return 1;
+  }
+  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+  virtual void setParam (void);
+  virtual uint8_t bFramePossible (void)
+  {
+    return 0;
+  }
+  virtual uint8_t decodeHeaderOnly (void);
+  virtual uint8_t decodeFull (void);
+  virtual uint8_t isDivxPacked (void);
+  virtual uint32_t getSpecificMpeg4Info (void);
+  virtual uint8_t getPARWidth (void);
+  virtual uint8_t getPARHeight (void);
+  virtual bool    flush(void);
+};
+
+class decoderFFDiv3:public decoderFF
+{
+protected:
+
+
+public:
+
+  decoderFFDiv3 (uint32_t w, uint32_t h);
+
+};
+class decoderFFMpeg4VopPacked:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFMpeg4VopPacked (uint32_t w, uint32_t h);
+  uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+  // mpeg4 can have B-frame
+  virtual uint8_t bFramePossible (void)
+  {
+    return 0;
+  }
+  // Vop packed are not indexable
+  virtual uint8_t isIndexable (void)
+  {
+    return 0;
+  };
+};
+class decoderFFMpeg4:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d);
+  uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+  // mpeg4 can have B-frame
+  virtual uint8_t bFramePossible (void)
+  {
+    return 1;
+  }
+
+};
+class decoderFFMpeg12:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  // mpeg1/2 can have B-frame
+  virtual uint8_t bFramePossible (void)
+  {
+    return 1;
+  }
+
+};
+class decoderFFSVQ3:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  virtual uint8_t bFramePossible (void)
+  {
+    return 0;
+  }
+
+};
+
+class decoderFFDV:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+class decoderFFMP42:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFMP42 (uint32_t w, uint32_t h);
+
+};
+class decoderFFH263:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFH263 (uint32_t w, uint32_t h);
+
+};
+class decoderFFH264:public decoderFF
+{
+protected:
+  uint32_t _lowDelay;
+
+public:
+  decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t lowdelay);
+  virtual uint8_t bFramePossible (void)
+  {
+      return _lowDelay;
+  }
+  uint8_t   uncompress (ADMCompressedImage * in, ADMImage * out);
+
+};
+class decoderFFhuff:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
+
+};
+class decoderFF_ffhuff:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
+
+};
+class decoderFFWMV2:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+class decoderFFWMV1:public decoderFF
+{
+  protected:
+
+
+  public:
+    decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+
+class decoderFFWMV3:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+
+class decoderFFVC1:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFVC1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+
+class decoderFFV1:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFV1 (uint32_t w, uint32_t h);
+
+};
+class decoderFFMJPEG:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFMJPEG (uint32_t w, uint32_t h);
+
+};
+class decoderSnow:public decoderFF
+{
+protected:
+
+
+public:
+  decoderSnow (uint32_t w, uint32_t h);
+
+};
+class decoderFFcyuv:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+class decoderCamtasia:public decoderFF
+{
+protected:
+
+
+public:
+  decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp);
+
+};
+class decoderFFTheora:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+
+class decoderFFCinepak:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+class decoderFFCRAM:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+class decoderFFVP6F:public decoderFF
+{
+protected:
+public:
+  decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFVP6A:public decoderFF
+{
+protected:
+public:
+  decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFFLV1:public decoderFF
+{
+protected:
+public:
+  decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFDVBSub:public decoderFF
+{
+protected:
+public:
+  decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFAMV:public decoderFF
+{
+protected:
+public:
+  decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFMjpegB:public decoderFF
+{
+protected:
+public:
+  decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFSVQ1:public decoderFF
+{
+protected:
+public:
+  decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+
+#ifdef USE_VDPAU
+class decoderFFVDPAU:public decoderFF
+{
+protected:
+                    int b_age;
+                    int ip_age[2];
+
+                    void     *vdpau;
+                    ADMImage *scratch;
+                    ADMImage *vdpau_copy;
+                    uint64_t vdpau_pts;
+                    bool     decode_status;
+                    bool     destroying;
+public:     // Callbacks
+                    int     getBuffer(AVCodecContext *avctx, AVFrame *pic);
+                    void    releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+                    void    goOn( const AVFrame *d,int type);            
+public:
+            // public API
+                    decoderFFVDPAU (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+                    ~decoderFFVDPAU();
+    virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+    virtual uint8_t dontcopy (void)
+                      {
+                        return 0;
+                      }
+     virtual uint8_t bFramePossible (void)
+      {
+        return 1;
+      }
+
+};
+
+#endif
+// EOF
+

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,82 @@
+/***************************************************************************
+            \file              ADM_ffmpeg_vdpau.cpp  
+            \brief Decoder using half ffmpeg/half VDPAU
+
+    The ffmpeg part is to preformat inputs for VDPAU
+    VDPAU is loaded dynamically to be able to make a binary
+        and have something working even if the target machine
+        does not have vdpau
+
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_ffmpeg_vdpa_internal_H
+#define ADM_ffmpeg_vdpa_internal_H
+#include &lt;vector&gt;
+extern &quot;C&quot; {
+static void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height);
+static int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic);
+static void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+}
+
+
+#define NB_SURFACE 50
+typedef struct 
+{
+        VdpDecoder            vdpDecoder;
+        vdpau_render_state *renders[NB_SURFACE];
+        std::vector &lt;vdpau_render_state *&gt;freeQueue;
+
+}vdpauContext;
+
+#define VDPAU ((vdpauContext *)vdpau)
+
+// VDPAU internal linker
+
+typedef struct 
+{
+    VdpGetErrorString       *getErrorString;
+    VdpGetApiVersion        *getApiVersion;
+    VdpGetInformationString *getInformationString;
+
+    VdpVideoSurfaceCreate   *createSurface;
+    VdpVideoSurfaceDestroy  *destroySurface;
+    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
+
+    VdpDecoderCreate        *decoderCreate;
+    VdpDecoderDestroy       *decoderDestroy;
+    VdpDecoderRender        *decoderRender;
+
+}VdpFunctions;
+
+#define WRAP_Open_Template(funcz,argz,display,codecid) \
+{\
+AVCodec *codec=funcz(argz);\
+if(!codec) {GUI_Error_HIG(&quot;Codec&quot;,QT_TR_NOOP(&quot;Internal error finding codec&quot;display));ADM_assert(0);} \
+  codecId=codecid; \
+  _context-&gt;workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
+  _context-&gt;error_concealment=3; \
+  if (avcodec_open(_context, codec) &lt; 0)  \
+                      { \
+                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder failed!\n&quot;); \
+                                        GUI_Error_HIG(&quot;Codec&quot;,&quot;Internal error opening &quot;display); \
+                                        ADM_assert(0); \
+                                } \
+                                else \
+                                { \
+                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder initialized! (%s)\n&quot;,codec-&gt;long_name); \
+                                } \
+}
+
+#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
+#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
+
+#endif
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,29 @@
+/***************************************************************************
+                          ADM_mjpeg.h  -  description
+                             -------------------
+    begin                : Sat Apr 13 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+class decoderMjpeg:decoders
+{
+protected:
+  uint8_t _swap;
+
+public:
+  decoderMjpeg (uint32_t w, uint32_t h);
+  virtual ~ decoderMjpeg ();
+  virtual void setParam (void);
+  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
+			      uint32_t * flag = NULL);
+};

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,78 @@
+/***************************************************************************
+                          ADM_png  -  description
+                             -------------------
+    copyright            : (C) 2005 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+ 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/ 
+#ifndef PNG_H_A
+#define PNG_H_A
+#ifdef USE_PNG
+
+typedef struct memAccess 
+{
+  
+int size;
+   
+int cur;
+   
+uint8_t * data;
+
+
+} memAccess;
+
+
+class decoderPng:public decoders 
+{
+
+protected:
+memAccess io;
+  
+ADM_colorspace colorspace;
+  
+void *png_ptr;
+  
+void *info_ptr;
+  
+void *end_info;
+  
+
+uint8_t ** rows;
+  
+uint8_t * decoded;
+  
+void Init (void);
+  
+void Cleanup (void);
+  
+void recalc (void);
+
+public:
+decoderPng (uint32_t w, uint32_t h);
+  
+virtual ~ decoderPng ();
+  
+virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
+  
+uint8_t dontcopy (void)
+  {
+    return 1;
+  }
+
+
+
+};
+
+#endif /* 
+ */
+#endif /* 
+ */

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,38 @@
+/***************************************************************************
+                          ADM_rgb16.h  -  description
+                             -------------------
+    begin                : Mon May 27 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_RGB16_H
+#define ADM_RGB16_H
+
+#include &quot;ADM_colorspace.h&quot;
+
+class decoderRGB16 : decoders
+{
+	protected:
+		uint8_t* planar;
+		ColRgbToYV12* color;
+		uint32_t isRgb; // Else BGR
+		uint32_t _bpp;
+		uint8_t* decoded;
+
+	public:
+		uint8_t dontcopy (void) { return 1; }
+		decoderRGB16 (uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp);
+		virtual ~decoderRGB16();
+		virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
+};
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,46 @@
+/***************************************************************************
+                          ADM_theora_dec.h  -  description
+                             -------------------
+    begin                : Thu Sep 26 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifdef USE_THEORA
+#ifndef __theora__
+#define __theora__
+
+extern &quot;C&quot;
+{
+#include &quot;theora/theora.h&quot;
+}
+class decoderTheora:public decoders
+{
+protected:
+
+
+  theora_info _tinfo;
+  theora_state _tstate;
+
+
+
+public:
+    decoderTheora (uint32_t w, uint32_t h);
+    virtual ~ decoderTheora ();
+  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
+			      uint32_t * flag = NULL);
+  virtual void setParam (void);
+
+
+};
+
+#endif
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,16 @@
+/***************************************************************************
+                          ADM_theora_enc.h  -  description
+                             -------------------
+    begin                : Thu Sep 26 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,37 @@
+//
+// C++ Interface: ADM_uyvy
+//
+// Description: 
+//
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+class decoderUYVY:decoders
+{
+protected:
+
+public:
+  decoderUYVY (uint32_t w, uint32_t h):decoders (w, h)
+  {
+  };
+  virtual ~ decoderUYVY ()
+  {
+  };
+  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+};
+class decoderYUY2:decoders
+{
+protected:
+
+public:
+  decoderYUY2 (uint32_t w, uint32_t h):decoders (w, h)
+  {
+  };
+  virtual ~ decoderYUY2 ()
+  {
+  };
+  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+};

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,316 @@
+/***************************************************************************
+                          ADM_codecs.cpp  -  description
+                             -------------------
+    begin                : Fri Apr 12 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    see here : <A HREF="http://www.webartz.com/fourcc/">http://www.webartz.com/fourcc/</A>
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+
+#ifdef USE_FFMPEG
+extern &quot;C&quot;
+{
+#include &quot;ADM_lavcodec.h&quot;
+};
+#endif
+#include &quot;ADM_default.h&quot;
+#ifdef BIG_ENDIAN
+#undef BIG_ENDIAN
+#endif
+
+//#include &quot;ADM_colorspace/colorspace.h&quot;
+
+#ifdef USE_XX_XVID
+#include &quot;xvid.h&quot;
+#endif
+
+#include &quot;ADM_codecs/ADM_codec.h&quot;
+#include &quot;ADM_codecs/ADM_mjpeg.h&quot;
+#include &quot;ADM_codecs/ADM_codecNull.h&quot;
+#include &quot;ADM_codecs/ADM_rgb16.h&quot;
+#include &quot;ADM_codecs/ADM_uyvy.h&quot;
+#include &quot;avidemutils.h&quot;
+#include &quot;fourcc.h&quot;
+
+
+#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
+
+
+#ifdef USE_THEORA
+#include &quot;ADM_codecs/ADM_theora_dec.h&quot;
+#endif
+
+#include &quot;ADM_codecs/ADM_png.h&quot;
+
+#include &quot;ADM_assert.h&quot;
+#include &quot;prefs.h&quot;
+
+extern uint8_t GUI_Question (char *);
+extern uint8_t use_fast_ffmpeg;
+extern bool vdpauUsable(void);
+
+uint8_t
+  decoders::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+  UNUSED_ARG (in);
+  UNUSED_ARG (out);
+  return 0;
+}
+decoders *
+getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+		     uint8_t * extraData)
+{
+  UNUSED_ARG (fcc);
+  UNUSED_ARG (extraLen);
+  UNUSED_ARG (extraData);
+  return (decoders *) (new decoderFFMpeg4VopPacked (w, h));
+
+}
+decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+		     uint8_t * extraData)
+{
+  UNUSED_ARG (fcc);
+  UNUSED_ARG (extraLen);
+  UNUSED_ARG (extraData);
+  return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,0));
+
+}
+/**
+    \fn getDecoder
+    \brief returns the correct decoder for a stream
+*/
+decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+	    uint8_t * extraData,uint32_t bpp)
+{
+  printf(&quot;\nSearching decoder (%d x %d, extradataSize:%d)...\n&quot;,w,h,extraLen);
+  if (isMSMpeg4Compatible (fcc) == 1)
+    {
+      // For div3, no problem we take ffmpeg
+
+      return (decoders *) (new decoderFFDiv3 (w, h));
+    }
+
+#ifdef USE_FFMPEG
+  if (isDVCompatible(fcc))//&quot;CDVC&quot;))
+    {
+
+      return (decoders *) (new decoderFFDV (w, h, extraLen, extraData));
+    }
+#endif
+#ifdef USE_FFMPEG
+  if (fourCC::check (fcc, (uint8_t *) &quot;MP42&quot;))
+    {
+
+      return (decoders *) (new decoderFFMP42 (w, h));
+    }
+#endif
+    if (fourCC::check (fcc, (uint8_t *) &quot;FLV1&quot;))
+    {
+      return (decoders *) (new decoderFFFLV1 (w, h,extraLen, extraData));
+    }
+
+
+#ifdef USE_FFMPEG
+  if (fourCC::check (fcc, (uint8_t *) &quot;H263&quot;))
+    {
+
+      return (decoders *) (new decoderFFH263 (w, h));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;HFYU&quot;))
+    {
+
+      return (decoders *) (new decoderFFhuff (w, h, extraLen, extraData,bpp));
+    }
+#ifdef USE_PNG
+  if (fourCC::check (fcc, (uint8_t *) &quot;PNG &quot;))
+    {
+
+      return (decoders *) (new decoderPng (w, h));
+    }
+#endif
+ if (fourCC::check (fcc, (uint8_t *) &quot;cvid&quot;))
+    {
+
+      return (decoders *) (new decoderFFCinepak (w, h, extraLen, extraData));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;FFVH&quot;))
+    {
+
+      return (decoders *) (new decoderFF_ffhuff (w, h, extraLen, extraData,bpp));
+    }
+if (fourCC::check (fcc, (uint8_t *) &quot;SVQ1&quot;))
+    {
+
+      return (decoders *) (new decoderFFSVQ1 (w, h, extraLen, extraData));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) &quot;SVQ3&quot;))
+    {
+
+      return (decoders *) (new decoderFFSVQ3 (w, h, extraLen, extraData));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;tscc&quot;))
+    {
+
+      return (decoders *) (new decoderCamtasia (w, h, bpp));
+    }
+
+     if (fourCC::check (fcc, (uint8_t *) &quot;CRAM&quot;))
+    {
+
+      return (decoders *) (new decoderFFCRAM (w, h, extraLen, extraData));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;WMV2&quot;))
+    {
+
+      return (decoders *) (new decoderFFWMV2 (w, h, extraLen, extraData));
+    }
+    if (fourCC::check (fcc, (uint8_t *) &quot;WMV1&quot;))
+    {
+
+      return (decoders *) (new decoderFFWMV1 (w, h, extraLen, extraData));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) &quot;WMV3&quot;) )
+    {
+
+      return (decoders *) (new decoderFFWMV3 (w, h, extraLen, extraData));
+    }
+
+    if (fourCC::check (fcc, (uint8_t *) &quot;WVC1&quot;)|| fourCC::check (fcc, (uint8_t *) &quot;WMVA&quot;))
+    {
+
+      return (decoders *) (new decoderFFVC1 (w, h, extraLen, extraData));
+    }
+
+if (fourCC::check (fcc, (uint8_t *) &quot;FFV1&quot;))
+    {
+
+      return (decoders *) (new decoderFFV1 (w, h));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;SNOW&quot;))
+    {
+
+      return (decoders *) (new decoderSnow (w, h));
+    }
+  if (isH264Compatible (fcc))
+    {
+#ifdef USE_VDPAU
+        if(vdpauUsable()==true)
+            return (decoders *) (new decoderFFVDPAU (w, h, extraLen, extraData));
+        else
+#endif
+            return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,1));
+    }
+#endif
+
+/*
+	Could be either divx5 packed crap or xvid or ffmpeg
+	For now we return FFmpeg and later will switch to divx5 if available
+		(ugly hack for ugly hack....)
+*/
+
+  if (isMpeg4Compatible (fcc) == 1)
+    {
+      return (decoders *) (new decoderFFMpeg4 (w, h, fcc,extraLen, extraData));
+      //    return(decoders *)( new decoderXvid(w,h));
+      //    return(decoders *)( new decoderDIVX(w,h));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) &quot;MJPB&quot;))
+    {
+      printf (&quot;\n using FF mjpeg codec\n&quot;);
+      return (decoders *) (new decoderFFMjpegB (w, h,extraLen,extraData));
+    }
+if (fourCC::check (fcc, (uint8_t *) &quot;MJPG&quot;)
+      || fourCC::check (fcc, (uint8_t *) &quot;mjpa&quot;))
+    {
+#if  0
+      //#ifdef USE_MJPEG
+      printf (&quot;\n using mjpeg codec\n&quot;);
+      return (decoders *) (new decoderMjpeg (w, h));
+#else
+      printf (&quot;\n using FF mjpeg codec\n&quot;);
+      return (decoders *) (new decoderFFMJPEG (w, h));
+#endif
+
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;YV12&quot;)
+      || fourCC::check (fcc, (uint8_t *) &quot;yv12&quot;)
+      || fourCC::check (fcc, (uint8_t *) &quot;I420&quot;))
+    {
+      printf (&quot;\n using null codec\n&quot;);
+      return (decoders *) (new decoderNull (w, h));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;UYVY&quot;))
+    {
+      printf (&quot;\n using uyvy codec\n&quot;);
+      return (decoders *) (new decoderUYVY (w, h));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;YUY2&quot;))
+    {
+      printf (&quot;\n using YUY2 codec\n&quot;);
+      return (decoders *) (new decoderYUY2 (w, h));
+    }
+  if (fourCC::check (fcc, (uint8_t *) &quot;AMV &quot;))
+    {
+      printf (&quot;\n using AMV codec\n&quot;);
+      return (decoders *) (new decoderFFAMV (w, h,extraLen,extraData));
+    }
+
+ if (fourCC::check (fcc, (uint8_t *) &quot;VP6A&quot;))
+    {
+      printf (&quot;\n using YUY2 codec\n&quot;);
+      return (decoders *) (new decoderFFVP6A (w, h,extraLen,extraData));
+    }
+  if (isVP6Compatible(fcc))
+    {
+      printf (&quot;\n using VP6F codec\n&quot;);
+      return (decoders *) (new decoderFFVP6F (w, h,extraLen,extraData));
+    }
+
+
+  if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) &quot;RGB &quot;))
+    {
+      // RGB 16 Codecs
+      printf (&quot;\n using RGB codec\n&quot;);
+      return (decoders *) (new decoderRGB16 (w, h, 1, bpp));
+
+    }
+ if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) &quot;DIB &quot;))
+    {
+      // RGB 16 Codecs
+      printf (&quot;\n using DIB codec\n&quot;);
+      return (decoders *) (new decoderRGB16 (w, h, 0, bpp));
+
+    }
+  if (isMpeg12Compatible (fcc))
+	  return (decoders *) (new decoderFFMpeg12 (w, h, extraLen, extraData));
+
+  // default : null decoder
+  printf (&quot;\n using invalid codec for \n&quot;);
+  fourCC::print (fcc);
+
+  return (decoders *) (new decoderEmpty (w, h));
+}
+
+uint8_t coders::compress (ADMImage * in, ADMBitstream * out)
+{
+  UNUSED_ARG (in);
+  UNUSED_ARG (out);
+
+  return 0;
+}

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,838 @@
+/***************************************************************************
+                          ADM_ffmp43.cpp  -  description
+                             -------------------
+                             
+	Decoder for Divx3/4/..., using ffmpeg
+                             
+    begin                : Wed Sep 25 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+
+#include &quot;ADM_assert.h&quot;
+#include &quot;prefs.h&quot;
+extern &quot;C&quot; {
+#include &quot;ADM_lavcodec.h&quot;
+}
+#include &quot;ADM_default.h&quot;
+
+#include &quot;ADM_codecs/ADM_codec.h&quot;
+#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+
+#include &quot;ADM_debugID.h&quot;
+#define MODULE_NAME  MODULE_CODEC
+#include &quot;ADM_debug.h&quot;
+#include &quot;ADM_videoInfoExtractor.h&quot;
+
+extern int ADM_cpu_num_processors(void);
+extern &quot;C&quot;
+{
+    static void ADM_releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+    static int  ADM_getBuffer(AVCodecContext *avctx, AVFrame *pic);
+}
+
+
+
+#define WRAP_Open_Template(funcz,argz,display,codecid) \
+{\
+AVCodec *codec=funcz(argz);\
+if(!codec) {GUI_Error_HIG(&quot;Codec&quot;,QT_TR_NOOP(&quot;Internal error finding codec&quot;display));ADM_assert(0);} \
+  codecId=codecid; \
+  _context-&gt;workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
+  _context-&gt;error_concealment=3; \
+  if (avcodec_open(_context, codec) &lt; 0)  \
+                      { \
+                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder failed!\n&quot;); \
+                                        GUI_Error_HIG(&quot;Codec&quot;,&quot;Internal error opening &quot;display); \
+                                        ADM_assert(0); \
+                                } \
+                                else \
+                                { \
+                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder initialized! (%s)\n&quot;,codec-&gt;long_name); \
+                                } \
+}
+
+#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
+#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
+
+
+//****************************
+extern uint8_t DIA_lavDecoder (uint32_t * swapUv, uint32_t * showU);
+extern &quot;C&quot;
+{
+  int av_is_voppacked (AVCodecContext * avctx, int *vop_packed, int *gmc,
+		       int *qpel);
+};
+/**
+    \fn clonePic
+    \brief Convert AvFrame to ADMImage
+*/
+uint8_t decoderFF::clonePic (AVFrame * src, ADMImage * out)
+{
+  uint32_t    u,v;
+  ADM_assert(out-&gt;_isRef);
+  out-&gt;_planes[0] = (uint8_t *) src-&gt;data[0];
+  out-&gt;_planeStride[0] = src-&gt;linesize[0];
+  if (_swapUV)
+    {
+      u = 1;
+      v = 2;
+    }
+  else
+    {
+      u = 2;
+      v = 1;
+    }
+  out-&gt;_planes[1] = (uint8_t *) src-&gt;data[u];
+  out-&gt;_planeStride[1] = src-&gt;linesize[u];
+
+  out-&gt;_planes[2] = (uint8_t *) src-&gt;data[v];
+  out-&gt;_planeStride[2] = src-&gt;linesize[v];
+
+  _lastQ = 0;			//_context-&gt;quality;
+  out-&gt;_Qp = (src-&gt;quality * 32) / FF_LAMBDA_MAX;
+  out-&gt;flags = frameType ();
+
+  // Quant ?
+  if (src-&gt;qstride &amp;&amp; src-&gt;qscale_table &amp;&amp; codecId != CODEC_ID_H264)
+    {
+      out-&gt;quant = (uint8_t *) src-&gt;qscale_table;
+      out-&gt;_qStride = src-&gt;qstride;
+      out-&gt;_qSize = (_w + 15) &gt;&gt; 4;
+      out-&gt;_qSize *= (_h + 15) &gt;&gt; 4;	// FixME?
+    }
+  else
+    {
+      out-&gt;_qSize = out-&gt;_qStride = 0;
+      out-&gt;quant = NULL;
+    }
+    //printf(&quot;[LAVC] Old pts :%&quot;LLD&quot; new pts :%&quot;LLD&quot;\n&quot;,out-&gt;Pts, (uint64_t)(src-&gt;reordered_opaque));
+    //printf(&quot;[LAVC] pts: %&quot;LLU&quot;\n&quot;,src-&gt;pts);
+    out-&gt;Pts= (uint64_t)(src-&gt;reordered_opaque);
+    return 1;
+}
+/**
+        \fn decoderMultiThread
+        \brief Enabled multitheaded decoder if possible
+*/
+void decoderFF::decoderMultiThread (void)
+{
+  uint32_t threads = 0;
+
+  prefs-&gt;get(FEATURE_THREADING_LAVC, &amp;threads);
+
+  if (threads == 0)
+	  threads = ADM_cpu_num_processors();
+
+  if (threads == 1)
+	  threads = 0;
+
+  if (threads)
+  {
+      printf (&quot;[lavc] Enabling MT decoder with %u threads\n&quot;, threads);
+
+      if (avcodec_thread_init (_context, threads) == -1)
+	      printf (&quot;[lavc] Failed!!\n&quot;);
+	  else
+          _usingMT = 1;
+  }
+}
+uint8_t decoderFF::getPARWidth (void)
+{
+  if(!_context-&gt;sample_aspect_ratio.num) return 1;
+  return _context-&gt;sample_aspect_ratio.num;
+}
+uint8_t decoderFF::getPARHeight (void)
+{
+  if(!_context-&gt;sample_aspect_ratio.den) return 1;
+  return _context-&gt;sample_aspect_ratio.den;
+
+}
+
+  
+uint8_t decoderFF::isDivxPacked (void)
+{
+  int
+    vop,
+    gmc,
+    qpel;
+  av_is_voppacked (_context, &amp;vop, &amp;gmc, &amp;qpel);
+  return vop;
+}
+// Fill the bitfields for some mpeg4 specific info
+// It is a bit of a hack as we make it a general
+// stuff (i.e. shared with all codecs) whereas it is mpeg4 specific
+// and should stay within mpeg4 scope FIXME
+uint32_t decoderFF::getSpecificMpeg4Info (void)
+{
+  int
+    vop,
+    gmc,
+    qpel;
+  uint32_t
+    out = 0;
+  av_is_voppacked (_context, &amp;vop, &amp;gmc, &amp;qpel);
+
+  if (qpel)
+    out += ADM_QPEL_ON;
+  if (_gmc)
+    out += ADM_GMC_ON;
+  if (vop)
+    out += ADM_VOP_ON;
+
+  return out;
+}
+
+//________________________________________________
+void
+decoderFF::setParam (void)
+{
+  DIA_lavDecoder (&amp;_swapUV, &amp;_showMv);
+  return;			// no param for ffmpeg
+}
+
+//-------------------------------
+decoderFF::decoderFF (uint32_t w, uint32_t h):decoders (w, h)
+{
+  codecId = 0;
+//                              memset(&amp;_context,0,sizeof(_context));
+  _allowNull = 0;
+  _gmc = 0;
+  _context = NULL;
+  _refCopy = 0;
+  _usingMT = 0;
+#if LIBAVCODEC_BUILD &gt;= 4624
+  _context = avcodec_alloc_context ();
+#else
+  _context = new AVCodecContext;
+  memset (_context, 0, sizeof (AVCodecContext));
+#endif
+  ADM_assert (_context);
+  memset (&amp;_frame, 0, sizeof (_frame));
+
+  _context-&gt;max_b_frames = 0;
+
+  _context-&gt;width = _w;
+  _context-&gt;height = _h;
+  _context-&gt;pix_fmt = PIX_FMT_YUV420P;	//PIX_FMT_RGBA32
+  //_context-&gt;debug=1;
+
+  _internalBuffer = new uint8_t[w * h * 3];
+
+  _swapUV = 0;
+  //_context-&gt;strict_std_compliance=-1;
+
+  _showMv = 0;
+#define FF_SHOW		(FF_DEBUG_VIS_MV_P_FOR+	FF_DEBUG_VIS_MV_B_FOR+FF_DEBUG_VIS_MV_B_BACK)
+//#define FF_SHOW               (FF_DEBUG_VIS_MV_P_FOR)
+  printf (&quot;[lavc] Build: %d\n&quot;, LIBAVCODEC_BUILD);
+  _context-&gt;debug_mv |= FF_SHOW;
+  _context-&gt;debug |= FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP;
+  
+}
+
+//_____________________________________________________
+
+decoderFF::~decoderFF ()
+{
+  if (_usingMT)
+    {
+      printf (&quot;[lavc] Killing decoding threads\n&quot;);
+      avcodec_thread_free (_context);
+      _usingMT = 0;
+    }
+
+  avcodec_close (_context);
+  ADM_dealloc (_context);
+  delete[]_internalBuffer;
+  printf (&quot;[lavc] Destroyed\n&quot;);
+}
+
+/**
+    \fn frameType
+    \return frametype of the last decoded frame
+*/
+uint32_t decoderFF::frameType (void)
+{
+  uint32_t
+    flag = 0;
+
+  AVFrame *
+    target;
+#define SET(x) {flag=x;aprintf(&quot;Frame is %s\n&quot;,#x);}
+
+
+  target = &amp;_frame;
+  switch (target-&gt;pict_type)
+    {
+    case FF_B_TYPE:
+      SET (AVI_B_FRAME);
+      if (target-&gt;key_frame)
+	aprintf (&quot;\n But keyframe is set\n&quot;);
+      break;
+
+    case FF_I_TYPE:
+      SET (AVI_KEY_FRAME);
+      if (!target-&gt;key_frame)
+	{
+	  if (codecId == CODEC_ID_H264)
+	    {
+	      SET (AVI_P_FRAME);
+	    }
+	  else
+	    printf (&quot;\n But keyframe is not set\n&quot;);
+	}
+      break;
+    case FF_S_TYPE:
+      _gmc = 1;			// No break, just inform that gmc is there
+    case FF_P_TYPE:
+      SET (AVI_P_FRAME);
+      if (target-&gt;key_frame)
+	aprintf (&quot;\n But keyframe is set\n&quot;);
+      break;
+    default:
+//                              printf(&quot;\n OOops XXX frame ?\n&quot;);
+      break;
+    }
+  return flag;
+}
+uint8_t decoderFF::decodeHeaderOnly (void)
+{
+  if (codecId == CODEC_ID_H264)
+    _context-&gt;hurry_up = 4;
+  else
+    _context-&gt;hurry_up = 5;
+  printf (&quot;\n[lavc] Hurry up\n&quot;);
+  return 1;
+}
+uint8_t decoderFF::decodeFull (void)
+{
+  _context-&gt;hurry_up = 0;
+  printf (&quot;\n[lavc] full decoding\n&quot;);
+  return 1;
+}
+
+/**
+    \fn flush
+    \brief empty internal buffer
+*/
+bool    decoderFF::flush(void)
+{
+    if(_context)
+        avcodec_flush_buffers(_context);
+    return true;
+}
+/**
+    \fn uncompress
+    \brief Actually decode an image
+*/
+uint8_t   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+  int got_picture = 0;
+  uint8_t *oBuff[3];
+  int strideTab[3];
+  int strideTab2[3];
+  int ret = 0;
+  out-&gt;_noPicture = 0;
+  if (_showMv)
+    {
+      _context-&gt;debug_mv |= FF_SHOW;
+      _context-&gt;debug |= 0;	//FF_DEBUG_VIS_MB_TYPE;
+    }
+  else
+    {
+      _context-&gt;debug_mv &amp;= ~FF_SHOW;
+      _context-&gt;debug &amp;= ~(FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP);
+    }
+
+   
+    
+  if (in-&gt;dataLength == 0 &amp;&amp; !_allowNull)	// Null frame, silently skipped
+    {
+      
+      printf (&quot;[Codec] null frame\n&quot;);
+        // search the last image
+        if (_context-&gt;coded_frame &amp;&amp; 
+            _context-&gt;coded_frame-&gt;data &amp;&amp;
+            _context-&gt;coded_frame-&gt;data[0]
+            )
+          {
+            printf(&quot;[Codec] Cloning older pic\n&quot;);
+            clonePic (_context-&gt;coded_frame, out);
+            out-&gt;Pts=ADM_COMPRESSED_NO_PTS;
+          }
+        else
+            {
+                out-&gt;_noPicture = 1;
+                out-&gt;Pts=ADM_COMPRESSED_NO_PTS;
+                printf(&quot;[Codec] No Picture\n&quot;);
+            }
+          return 1;
+    }
+   // Put a safe value....
+   out-&gt;Pts=in-&gt;demuxerPts;
+    _context-&gt;reordered_opaque=in-&gt;demuxerPts;
+  //_frame.opaque=(void *)out-&gt;Pts;
+  //printf(&quot;Incoming Pts :%&quot;LLD&quot;\n&quot;,out-&gt;Pts);
+  ret = avcodec_decode_video (_context, &amp;_frame, &amp;got_picture, in-&gt;data, in-&gt;dataLength);
+  if(!bFramePossible())
+  {
+    // No delay, the value is sure, no need to hide it in opaque
+    _context-&gt;reordered_opaque=(int64_t)in-&gt;demuxerPts;
+  }
+  out-&gt;_qStride = 0;		//Default = no quant
+  if (0 &gt; ret &amp;&amp; !_context-&gt;hurry_up)
+    {
+      printf (&quot;\n[lavc] error in lavcodec decoder!\n&quot;);
+      printf (&quot;[lavc] Err: %d, size :%d\n&quot;, ret, in-&gt;dataLength);
+      return 0;
+    }
+  if (!got_picture &amp;&amp; !_context-&gt;hurry_up)
+    {
+      // Some encoder code a vop header with the 
+      // vop flag set to 0
+      // it is meant to mean frame skipped but very dubious
+      if (in-&gt;dataLength &lt;= 8 &amp;&amp; codecId == CODEC_ID_MPEG4)
+	{
+	  printf (&quot;[lavc] Probably pseudo black frame...\n&quot;);
+	  out-&gt;_Qp = 2;
+	  out-&gt;flags = 0;	// assume P ?
+
+	  clonePic (_context-&gt;coded_frame, out);
+	  return 1;
+	}
+      // allow null means we allow null frame in and so potentially
+      // have no frame out for a time
+      // in that case silently fill with black and returns it as KF
+      if (_allowNull)
+	{
+	  out-&gt;flags = AVI_KEY_FRAME;
+	  if (!_refCopy)
+	    {
+	      memset (out-&gt;data, 0, _w * _h);
+	      memset (out-&gt;data + _w * _h, 128, (_w * _h) &gt;&gt; 1);
+	    }
+	  else
+	    {
+	      out-&gt;_noPicture = 1;
+	    }
+	  printf (&quot;\n[lavc] ignoring got pict ==0\n&quot;);
+	  return 1;
+
+	}
+      printf (&quot;[lavc] Err: %d, size: %d\n&quot;, ret, in-&gt;dataLength);
+      printf (&quot;\n[lavc] error in FFMP43/mpeg4!: got picture\n&quot;);
+      //GUI_Alert(&quot;Please retry with misc-&gt;Turbo off&quot;);
+      //return 1;
+      return 0;
+    }
+  if (_context-&gt;hurry_up)
+    {
+      out-&gt;flags = frameType ();
+      return 1;
+    }
+  // We have an image....
+  switch (_context-&gt;pix_fmt)
+    {
+    case PIX_FMT_YUV411P:
+      out-&gt;_colorspace = ADM_COLOR_YUV411;
+      break;
+
+    case PIX_FMT_YUV422P:
+    case PIX_FMT_YUVJ422P:
+      out-&gt;_colorspace = ADM_COLOR_YUV422;
+      break;
+
+    case PIX_FMT_YUV444P:
+    case PIX_FMT_YUVJ444P:
+      out-&gt;_colorspace = ADM_COLOR_YUV444;
+      break;
+    case PIX_FMT_YUV420P:
+    case PIX_FMT_YUVJ420P:
+    case PIX_FMT_YUVA420P:
+      // Default is YV12 or I420
+      // In that case depending on swap u/v
+      // we do it or not
+      out-&gt;_colorspace = ADM_COLOR_YV12;
+      break;
+
+    case PIX_FMT_RGBA: // ???PIX_FMT_RGBA32:
+      out-&gt;_colorspace = ADM_COLOR_RGB32A;
+      break;
+    case PIX_FMT_RGB555:
+      out-&gt;_colorspace = ADM_COLOR_RGB555;
+      break;
+    case PIX_FMT_VDPAU_H264:
+        out-&gt;_colorspace=ADM_COLOR_VDPAU;
+        break;
+    default:
+      printf (&quot;[lavc] Unhandled colorspace: %d\n&quot;, _context-&gt;pix_fmt);
+      return 0;
+    }
+    clonePic (&amp;_frame, out);
+    //printf(&quot;[AvCodec] Pts : %llu Out Pts:%llu \n&quot;,_frame.pts,out-&gt;Pts);
+
+  return 1;
+}
+
+#define LOWDELAY() {} //_context-&gt;flags |= CODEC_FLAG_LOW_DELAY
+
+
+decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  _refCopy = 1;			// YUV420 only
+  WRAP_Open (CODEC_ID_MSMPEG4V3);
+}
+//**************************************************
+decoderFFMpeg4VopPacked::decoderFFMpeg4VopPacked (uint32_t w, uint32_t h):decoderFF (w,
+	   h)
+{
+/* In that case, we cannot use lowdelay...*/
+  _refCopy = 1;			// YUV420 only
+  _allowNull = 1;
+  decoderMultiThread ();
+  WRAP_Open (CODEC_ID_MPEG4);
+  printf(&quot;[lavc] Non low delay mpeg4 decoder initialized\n&quot;);
+}
+uint8_t decoderFFMpeg4VopPacked::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+    // For pseudo startcode
+    if(in-&gt;dataLength)
+    {
+        in-&gt;data[in-&gt;dataLength]=0;
+        in-&gt;data[in-&gt;dataLength+1]=0;
+    }
+    return decoderFF::uncompress(in,out);
+
+}
+
+decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+// force low delay as avidemux don't handle B-frames
+  LOWDELAY();
+  printf (&quot;[lavc] Using %d bytes of extradata for MPEG4 decoder\n&quot;, l);
+  
+  _refCopy = 1;			// YUV420 only
+  _context-&gt;extradata = (uint8_t *) d;
+  _context-&gt;extradata_size = (int) l;
+  _context-&gt;codec_tag=fcc;
+  _context-&gt;stream_codec_tag=fcc;
+  decoderMultiThread ();
+  //  _context-&gt;flags|=FF_DEBUG_VIS_MV;
+  WRAP_Open (CODEC_ID_MPEG4);
+}
+uint8_t decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+    // For pseudo startcode
+    if(in-&gt;dataLength)
+    {
+        in-&gt;data[in-&gt;dataLength]=0;
+        in-&gt;data[in-&gt;dataLength+1]=0;
+    }
+    return decoderFF::uncompress(in,out);
+
+}
+//************************************
+decoderFFDV::decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context-&gt;extradata = (uint8_t *) d;
+  _context-&gt;extradata_size = (int) l;
+  WRAP_Open (CODEC_ID_DVVIDEO);
+
+}
+decoderFFMP42::decoderFFMP42 (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  _refCopy = 1;			// YUV420 only
+  WRAP_Open (CODEC_ID_MSMPEG4V2);
+
+}
+decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
+	   h)
+{
+  int
+    got_picture = 0;
+  LOWDELAY();
+  _refCopy = 1;			// YUV420 only
+  decoderMultiThread ();
+  WRAP_Open (CODEC_ID_MPEG2VIDEO);
+}
+decoderFFSVQ3::decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
+	   h)
+{
+  int
+    got_picture = 0;
+
+  LOWDELAY();
+  _context-&gt;extradata = (uint8_t *) extraData;
+  _context-&gt;extradata_size = (int) extraLen;
+  WRAP_Open (CODEC_ID_SVQ3);
+}
+
+decoderFFH263::decoderFFH263 (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  _refCopy = 1;			// YUV420 only
+  WRAP_Open (CODEC_ID_H263);
+
+}
+decoderFFV1::decoderFFV1 (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  _refCopy = 1;			// YUV420 only
+  WRAP_Open (CODEC_ID_FFV1);
+}
+decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
+	   h)
+{
+  _context-&gt;extradata = (uint8_t *) d;
+  _context-&gt;extradata_size = (int) l;
+  _context-&gt;bits_per_coded_sample=bpp;
+  printf (&quot;[lavc] FFhuff: We have %d bytes of extra data\n&quot;, l);
+  WRAP_Open (CODEC_ID_FFVHUFF);
+
+}
+decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d, uint32_t lowdelay):decoderFF (w,
+	   h)
+{
+  _lowDelay=lowdelay;
+  _refCopy = 1;			// YUV420 only
+  _context-&gt;extradata = (uint8_t *) d;
+  _context-&gt;extradata_size = (int) l;
+  decoderMultiThread ();
+  if(lowdelay)
+    LOWDELAY();
+  printf (&quot;[lavc] Initializing H264 decoder with %d extradata\n&quot;, l);
+
+       {
+        WRAP_Open(CODEC_ID_H264);
+    }
+
+
+}
+//*********************
+extern &quot;C&quot; {int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc);}
+
+uint8_t   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+  if(!_context-&gt;hurry_up) return decoderFF::uncompress (in, out);
+  
+  uint32_t nalSize, isAvc;
+  av_getAVCStreamInfo(_context,&amp;nalSize,&amp;isAvc);
+  if(isAvc)
+  {
+      return extractH264FrameType(nalSize, in-&gt;data,in-&gt;dataLength,&amp;(out-&gt;flags));
+  }else
+  {
+    return extractH264FrameType_startCode(nalSize, in-&gt;data,in-&gt;dataLength,&amp;(out-&gt;flags));
+  }
+}
+//*********************
+decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
+	   h)
+{
+  _context-&gt;extradata = (uint8_t *) d;
+  _context-&gt;extradata_size = (int) l;
+  _context-&gt;bits_per_coded_sample = bpp;
+  WRAP_Open (CODEC_ID_HUFFYUV);
+}
+decoderFFWMV2::decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context-&gt;extradata = (uint8_t *) d;
+  _context-&gt;extradata_size = (int) l;
+
+  WRAP_Open (CODEC_ID_WMV2);
+
+}
+decoderFFWMV1::decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context-&gt;extradata = (uint8_t *) d;
+  _context-&gt;extradata_size = (int) l;
+
+  WRAP_Open (CODEC_ID_WMV1);
+
+}
+
+decoderFFWMV3::decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context-&gt;extradata = (uint8_t *) d;
+  _context-&gt;extradata_size = (int) l;
+
+  WRAP_Open (CODEC_ID_WMV3);
+
+}
+
+decoderFFVC1::decoderFFVC1(uint32_t w, uint32_t h, uint32_t l, uint8_t * d) : decoderFF(w, h)
+{
+  _context-&gt;extradata = (uint8_t *) d;
+  _context-&gt;extradata_size = (int) l;
+
+  WRAP_Open (CODEC_ID_VC1);
+}
+
+decoderFFcyuv::decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context-&gt;extradata = (uint8_t *) d;
+  _context-&gt;extradata_size = (int) l;
+
+  WRAP_Open (CODEC_ID_CYUV);
+}
+decoderFFMJPEG::decoderFFMJPEG (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  WRAP_Open (CODEC_ID_MJPEG);
+}
+decoderFFTheora::decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context-&gt;extradata = (uint8_t *) d;
+  _context-&gt;extradata_size = (int) l;
+  WRAP_Open (CODEC_ID_THEORA);
+}
+decoderSnow::decoderSnow (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  WRAP_Open (CODEC_ID_SNOW);
+}
+//*************
+decoderCamtasia::decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp):decoderFF (w,  h)
+{
+  _context-&gt;bits_per_coded_sample = bpp;
+  WRAP_Open (CODEC_ID_TSCC);
+}
+//*************
+decoderFFCinepak::decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_CINEPAK);
+}
+//*************
+decoderFFCRAM::decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_MSVIDEO1);
+}
+//*************
+decoderFFVP6F::decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_VP6F);
+}
+//*************
+decoderFFVP6A::decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_VP6A);
+}
+
+//*************
+decoderFFSVQ1::decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_SVQ1);
+}
+
+//************
+decoderFFFLV1::decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_FLV1);
+}
+decoderFFAMV::decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
+{
+  WRAP_Open (CODEC_ID_AMV);
+  //_context-&gt;codec_id=CODEC_ID_AMV;
+}
+decoderFFMjpegB::decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
+{
+  WRAP_Open (CODEC_ID_MJPEGB);
+  //_context-&gt;codec_id=CODEC_ID_AMV;
+}
+decoderFFDVBSub::decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  _context-&gt;sub_id=1;
+  WRAP_Open (CODEC_ID_DVB_SUBTITLE);
+}
+//*********************
+/**
+    \fn decoderFFSubs
+    \brief Constructor for DVB subtitles...
+*/
+
+decoderFFSubs::decoderFFSubs (uint32_t subid)
+{
+  _context = avcodec_alloc_context ();
+  codecId= CODEC_ID_DVB_SUBTITLE;
+  subId=subid;
+  _context-&gt;sub_id=subId;
+  WRAP_Open (CODEC_ID_DVB_SUBTITLE);
+}
+decoderFFSubs:: ~ decoderFFSubs ()
+{
+  avcodec_close (_context);
+  ADM_dealloc (_context);
+  _context=NULL;
+  
+}
+
+uint8_t decoderFFSubs::uncompress (ADMCompressedImage * in, AVSubtitle * out)
+{
+  int ret=0;
+  int got_picture=0;
+  ret=avcodec_decode_subtitle(_context, out,
+                            &amp;got_picture,
+                            in-&gt;data, in-&gt;dataLength); 
+     if(ret&lt;0) 
+     {
+        printf(&quot;[lavc] FFSUB Error %d\n&quot;,ret);
+        return 0; 
+     }
+     return 1;
+}
+
+
+//***************
+extern uint8_t  lavformat_init(void);
+extern void     avcodec_init(void );
+extern  void    avcodec_register_all(void );
+extern &quot;C&quot;
+{
+  void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list);
+}
+/**
+    \fn ADM_lavInit
+    \brief Init both lavcodec and lavformat
+*/
+void ADM_lavInit(void)
+{
+    avcodec_init();
+    avcodec_register_all();
+//BAZOOKA    lavformat_init();
+    av_log_set_callback(adm_lavLogCallback);
+#ifdef ADM_DEBUG
+  //  av_log_set_level(AV_LOG_DEBUG);
+#endif
+
+}
+void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list)
+{
+   // if(level&gt;1) return;
+    char buf[256];
+  
+    vsnprintf(buf, sizeof(buf), fmt, list);
+    printf(&quot;[lavc] %s&quot;,buf);
+}
+
+void ADM_lavDestroy(void)
+{
+	//av_free_static();
+}
+
+// EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,343 @@
+/***************************************************************************
+            \file              ADM_ffmpeg_vdpau.cpp  
+            \brief Decoder using half ffmpeg/half VDPAU
+
+    The ffmpeg part is to preformat inputs for VDPAU
+    VDPAU is loaded dynamically to be able to make a binary
+        and have something working even if the target machine
+        does not have vdpau
+    Some part, especially get/buffer and ip_age borrowed from xbmc
+        as the api from ffmpeg is far from clear....
+
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+extern &quot;C&quot; {
+#include &quot;ADM_lavcodec.h&quot;
+}
+#include &quot;ADM_default.h&quot;
+#ifdef USE_VDPAU
+extern &quot;C&quot; {
+ #include &quot;ADM_ffmpeg/libavcodec/vdpau.h&quot;
+}
+
+#include &quot;vdpau/vdpau_x11.h&quot;
+#include &quot;vdpau/vdpau.h&quot;
+#include &quot;ADM_codecs/ADM_codec.h&quot;
+#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_dynamicLoading.h&quot;
+#include &quot;ADM_render/GUI_render.h&quot;
+#include &quot;ADM_ffmpeg_vdpau_internal.h&quot;
+#include &quot;prefs.h&quot;
+
+static VdpFunctions funcs;
+
+static bool vdpauWorking=false;
+
+static ADM_LibWrapper        vdpauDynaLoader;
+static VdpDeviceCreateX11    *ADM_createVdpX11;
+static VdpDevice             vdpDevice;
+static VdpGetProcAddress     *vdpProcAddress;
+
+#define aprintf(...) {}
+
+/**
+    \fn vdpauUsable
+    \brief Return true if  vdpau can be used...
+*/
+bool vdpauUsable(void)
+{
+    uint32_t v=false;
+    if(!vdpauWorking) return false;
+    if(!prefs-&gt;get(FEATURE_VDPAU,&amp;v)) v=false;
+    return v;
+}
+/**
+    \fn getFunc
+    \brief vdpau function pointers from ID
+*/
+static void *getFunc(uint32_t id)
+{
+    void *f;
+    if(VDP_STATUS_OK!=vdpProcAddress(vdpDevice,id,&amp;f)) return NULL;
+    return (void *)f;
+}
+/**
+    \fn vdpauProbe
+    \brief Try loading vdpau...
+*/
+bool vdpauProbe(void)
+{
+    memset(&amp;funcs,0,sizeof(funcs));
+    if(false==vdpauDynaLoader.loadLibrary(&quot;/usr/lib/libvdpau.so&quot;))
+    {
+        return false;
+    }
+    ADM_createVdpX11=(VdpDeviceCreateX11*)vdpauDynaLoader.getSymbol(&quot;vdp_device_create_x11&quot;);
+    if(!ADM_createVdpX11) return false;
+
+    //
+    GUI_WindowInfo xinfo;
+    void *draw;
+    draw=UI_getDrawWidget();
+    UI_getWindowInfo(draw,&amp;xinfo );
+    
+    // try to create....
+    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)xinfo.display,0,&amp;vdpDevice,&amp;vdpProcAddress))
+    {
+        return false;
+    }
+    // Now that we have the vdpProcAddress, time to get the functions....
+#define GetMe(fun,id)         funcs.fun= (typeof(funcs.fun))getFunc(id);ADM_assert(funcs.fun); 
+        
+    GetMe(getErrorString,VDP_FUNC_ID_GET_ERROR_STRING);
+    GetMe(getApiVersion,VDP_FUNC_ID_GET_API_VERSION);
+    GetMe(getInformationString,VDP_FUNC_ID_GET_INFORMATION_STRING);
+
+    GetMe(createSurface,VDP_FUNC_ID_VIDEO_SURFACE_CREATE);
+    GetMe(destroySurface,VDP_FUNC_ID_VIDEO_SURFACE_DESTROY);
+    GetMe(getDataSurface,VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR);
+
+    GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
+    GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
+    GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
+
+
+
+    const char *versionString=NULL;
+    uint32_t version=0xff;
+        funcs.getInformationString(&amp;versionString);
+        funcs.getApiVersion(&amp;version);
+        printf(&quot;[VDPAU] API : 0x%x, info : %s\n&quot;,version,versionString);
+
+    vdpauWorking=true;
+    return true;
+}
+/**
+    \fn ADM_VDPAUgetBuffer
+    \brief trampoline to get a VDPAU surface
+*/
+int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx-&gt;opaque;
+    return dec-&gt;getBuffer(avctx,pic);
+}
+/**
+    \fn getBuffer
+    \brief returns a VDPAU render masquerading as a AVFrame
+*/
+int decoderFFVDPAU::getBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+    vdpau_render_state * render;
+    if(VDPAU-&gt;freeQueue.size()==0)
+    {
+        printf(&quot;[VDPAU] No more available surface\n&quot;);
+        return -1;
+    }
+    // Get an image   
+    render=VDPAU-&gt;freeQueue.back();
+    VDPAU-&gt;freeQueue.pop_back();
+    render-&gt;state=0;
+    pic-&gt;data[0]=(uint8_t *)render;
+    pic-&gt;data[1]=(uint8_t *)render;
+    pic-&gt;data[2]=(uint8_t *)render;
+    pic-&gt;linesize[0]=0;
+    pic-&gt;linesize[1]=0;
+    pic-&gt;linesize[2]=0;
+    pic-&gt;type=FF_BUFFER_TYPE_USER;
+    render-&gt;state |= FF_VDPAU_STATE_USED_FOR_REFERENCE;
+    pic-&gt;reordered_opaque= avctx-&gt;reordered_opaque;
+    if(pic-&gt;reference)
+    {
+        pic-&gt;age=ip_age[0];
+        ip_age[0]=ip_age[1]+1;
+        ip_age[1]=1;
+        b_age++;
+    }else
+    {
+        pic-&gt;age=b_age;
+        ip_age[0]++;
+        ip_age[1]++;
+        b_age=1;
+    }
+    return 0;
+}
+/**
+    \fn releaseBuffer
+*/
+void decoderFFVDPAU::releaseBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+  vdpau_render_state * render;
+  int i;
+  if(destroying==true) return; // They are already freed...
+  render=(vdpau_render_state*)pic-&gt;data[0];
+  ADM_assert(render);
+
+  render-&gt;state &amp;= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
+  for(i=0; i&lt;4; i++){
+    pic-&gt;data[i]= NULL;
+  }
+  VDPAU-&gt;freeQueue.push_back(render);
+}
+/**
+    \fn ADM_VDPAUreleaseBuffer
+*/
+ void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx-&gt;opaque;
+    dec-&gt;releaseBuffer(avctx,pic);
+}
+/**
+    \fn decoderFFVDPAU
+*/
+decoderFFVDPAU::decoderFFVDPAU(uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+        destroying=false;
+        _context-&gt;opaque          = this;
+        _context-&gt;get_buffer      = ADM_VDPAUgetBuffer;
+        _context-&gt;release_buffer  = ADM_VDPAUreleaseBuffer;
+        _context-&gt;draw_horiz_band = draw;
+        _context-&gt;slice_flags     = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
+        _context-&gt;extradata = (uint8_t *) d;
+        _context-&gt;extradata_size = (int) l;
+
+        vdpau=(void *)new vdpauContext;
+        VDPAU-&gt;vdpDecoder=VDP_INVALID_HANDLE;
+        WRAP_OpenByName(h264_vdpau,CODEC_ID_H264);
+        
+        // Now instantiate our VDPAU surface &amp; decoder
+        ADM_assert(VDP_STATUS_OK==funcs.decoderCreate(vdpDevice,VDP_DECODER_PROFILE_H264_HIGH,w,h,15,&amp;(VDPAU-&gt;vdpDecoder)));
+        // Create our surfaces...
+        for(int i=0;i&lt;NB_SURFACE;i++)
+        {
+            VDPAU-&gt;renders[i]=new vdpau_render_state;
+            memset(VDPAU-&gt;renders[i],0,sizeof( vdpau_render_state));
+            ADM_assert(VDP_STATUS_OK==funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,w,h,&amp;(VDPAU-&gt;renders[i]-&gt;surface)));
+            VDPAU-&gt;freeQueue.push_back(VDPAU-&gt;renders[i]);
+        }
+        scratch=new ADMImage(w,h,1);
+        b_age = ip_age[0] = ip_age[1] = 256*256*256*64;
+
+}
+/**
+    \fn ~            void    goOn( const AVFrame *d);
+*/
+decoderFFVDPAU::~decoderFFVDPAU()
+{
+        printf(&quot;[VDPAU] Cleaning up\n&quot;);
+        destroying=true;
+        for(int i=0;i&lt;NB_SURFACE;i++)
+        {
+            ADM_assert(VDP_STATUS_OK==funcs.destroySurface((VDPAU-&gt;renders[i]-&gt;surface)));
+            delete VDPAU-&gt;renders[i];
+        }
+         ADM_assert(VDP_STATUS_OK==funcs.decoderDestroy(VDPAU-&gt;vdpDecoder));
+         delete VDPAU;
+         vdpau=NULL;
+}
+/**
+    \fn uncompress
+*/
+uint8_t decoderFFVDPAU::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+VdpStatus status;
+    
+    // First let ffmpeg prepare datas...
+    vdpau_copy=out;
+    decode_status=false;
+    if(!decoderFF::uncompress (in, scratch))
+    {
+        printf(&quot;[VDPAU] No data from libavcodec\n&quot;);
+        return 0;
+    }
+    if(decode_status!=true)
+    {
+        printf(&quot;[VDPAU] error in renderDecode\n&quot;);
+        return 0;
+    }
+    // other part will be done in goOn
+  struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch-&gt;_planes[0];
+   VdpVideoSurface  surface;
+
+    surface=rndr-&gt;surface;
+ void *planes[3];
+            planes[0]=vdpau_copy-&gt;GetWritePtr(PLANAR_Y);
+            planes[1]=vdpau_copy-&gt;GetWritePtr(PLANAR_U);
+            planes[2]=vdpau_copy-&gt;GetWritePtr(PLANAR_V);
+    uint32_t stride[3];
+            stride[0]=vdpau_copy-&gt;GetPitch(PLANAR_Y);
+            stride[1]=vdpau_copy-&gt;GetPitch(PLANAR_U);
+            stride[2]=vdpau_copy-&gt;GetPitch(PLANAR_V);
+
+    
+   // Copy back the decoded image to our output ADM_image
+   aprintf(&quot;[VDPAU] Getting datas from surface %d\n&quot;,surface);
+    status=funcs.getDataSurface(
+                surface,
+                VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
+                planes, //void * const *   destination_data,
+                stride //destination_pitches
+                );
+    if(VDP_STATUS_OK!=status)
+    {
+        
+        printf(&quot;[VDPAU] Cannot get data from surface &lt;%s&gt;\n&quot;,funcs.getErrorString(status));
+        decode_status=false;
+        return 0 ;
+    }
+    
+
+    //
+    out-&gt;Pts=scratch-&gt;Pts;
+    out-&gt;flags=scratch-&gt;flags;
+    return (uint8_t)decode_status;
+}
+/**
+    \fn goOn
+    \brief Callback from ffmpeg when a pic is ready to be decoded
+*/
+void decoderFFVDPAU::goOn( const AVFrame *d,int type)
+{
+   VdpStatus status;
+   struct vdpau_render_state *rndr = (struct vdpau_render_state *)d-&gt;data[0];
+   VdpVideoSurface  surface;
+
+    surface=rndr-&gt;surface;
+    vdpau_pts=d-&gt;reordered_opaque; // Retrieve our PTS
+
+     aprintf(&quot;[VDPAU] Decoding Using surface %d\n&quot;, surface);
+    status=funcs.decoderRender(VDPAU-&gt;vdpDecoder, surface,
+                            (void * const *)&amp;rndr-&gt;info, rndr-&gt;bitstream_buffers_used, rndr-&gt;bitstream_buffers);
+    if(VDP_STATUS_OK!=status)
+    {
+        printf(&quot;[VDPAU] No data after decoderRender &lt;%s&gt;\n&quot;,funcs.getErrorString(status));
+        decode_status=false;
+        return ;
+    }
+    aprintf(&quot;[VDPAU] DecodeRender Ok***\n&quot;);
+    decode_status=true;
+    return;
+}
+
+
+/**
+    \fn draw
+    \brief callback invoked by lavcodec when a pic is ready to be decoded
+*/
+void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)s-&gt;opaque;
+    dec-&gt;goOn(src,type);
+}
+
+#endif
+// EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,115 @@
+#if 0
+/***************************************************************************
+                          ADM_mjpeg.cpp  -  description
+                             -------------------
+          I think i could use plain jpeg instead but....
+
+
+    begin                : Fri Apr 12 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;ADM_assert.h&quot;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+#include &quot;ADM_default.h&quot;
+#include &quot;config.h&quot;
+#ifdef USE_MJPEG
+#include &quot;ADM_colorspace/colorspace.h&quot;
+
+#include &quot;ADM_codecs/ADM_codec.h&quot;
+#include &quot;ADM_codecs/ADM_mjpeg.h&quot;
+extern &quot;C&quot;
+{
+#include &quot;mjpegtools/jpegutils.h&quot;
+}
+#include &quot;ADM_gui/GUI_decodersettings.h&quot;
+ /*
+  * jpeg_data:       buffer with input / output jpeg
+  * len:             Length of jpeg buffer
+  * itype:           LAV_INTER_NONE: Not interlaced
+  *                  LAV_INTER_TOP_FIRST: Interlaced, top-field-first
+  *                  LAV_INTER_BOTTOM_FIRST: Interlaced, bottom-field-first
+  * ctype            Chroma format for decompression.
+  *                  Currently always 420 and hence ignored.
+  * raw0             buffer with input / output raw Y channel
+  * raw1             buffer with input / output raw U/Cb channel
+  * raw2             buffer with input / output raw V/Cr channel
+  * width            width of Y channel (width of U/V is width/2)
+  * height           height of Y channel (height of U/V is height/2)
+
+
+  int decode_jpeg_raw (unsigned char *jpeg_data, int len,
+  int itype, int ctype, int width, int height,
+  unsigned char *raw0, unsigned char *raw1,
+  unsigned char *raw2);
+
+  */
+void
+decoderMjpeg::setParam (void)
+{
+  int param;
+
+  param = _swap;
+  if (1 == getMjpegParams (&amp;param))
+    {
+      _swap = param;
+    }
+
+}
+//________________________________________________
+
+uint8_t
+  decoderMjpeg::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
+			    uint32_t * flagz)
+{
+  //
+  uint32_t delta;
+  uint8_t *outu, *outv;
+  //
+  UNUSED_ARG (flagz);
+
+
+  delta = _w * _h;
+
+  outu = out + delta;
+  outv = outu + (delta &gt;&gt; 2);
+  if (!_swap)
+
+    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outu, outv);
+
+  else
+    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outv, outu);
+
+  return 1;
+
+
+}
+
+//_____________________________________________________
+
+decoderMjpeg::~decoderMjpeg ()
+{
+
+
+}
+// constructor for mjpeg, init encoder and stuff
+decoderMjpeg::decoderMjpeg (uint32_t w, uint32_t h):decoders (w, h)
+{
+  // some mjpeg are encoded with u &amp; v inverted
+  _swap = 0;
+
+}
+#endif
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,180 @@
+/***************************************************************************
+                          ADM_png.cpp  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+#ifdef USE_PNG
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+
+//#include &quot;ADM_colorspace/colorspace.h&quot;
+
+#include &quot;ADM_codecs/ADM_codec.h&quot;
+#include &quot;ADM_codecs/ADM_png.h&quot;
+extern &quot;C&quot;
+{
+#include &quot;png.h&quot;
+}
+#include &quot;ADM_assert.h&quot;
+
+#define PNG_PTR ((png_structp)png_ptr)
+#define INFO_PTR ((png_infop)info_ptr)
+#define INFO_END ((png_infop)end_info)
+/*
+   	Initialize codec
+*/
+static void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length);
+
+void decoderPng::recalc (void)
+{
+  int mul;
+  if (colorspace == ADM_COLOR_RGB24)
+    mul = 3;
+
+  else
+    mul = 4;
+  for (int i = 0; i &lt; _h; i++)
+    rows[i] = decoded + mul * _w * i;
+}
+
+
+decoderPng::decoderPng (uint32_t w, uint32_t h):decoders (w, h)
+{
+  rows = NULL;
+  decoded = NULL;
+  colorspace = ADM_COLOR_RGB24;
+
+  //****************************
+  // Prepare the decoded buffer*
+  //****************************
+  decoded = new uint8_t[4 * w * h];	// We take a bit more to be able to decode 32 bits png
+  // without causing a segfault
+  rows = new uint8_t *[h];
+  recalc ();
+}
+ void decoderPng::Init (void)
+{
+  png_ptr =
+    (void *) png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+  ADM_assert (png_ptr);
+  info_ptr = (void *) png_create_info_struct (PNG_PTR);
+  ADM_assert (info_ptr);
+  end_info = (void *) png_create_info_struct (PNG_PTR);
+  ADM_assert (end_info);
+  memset (&amp;io, 0, sizeof (io));
+  png_set_read_fn (PNG_PTR, &amp;io, user_read_data);
+  png_set_rows (PNG_PTR, INFO_PTR, (png_byte **) rows);
+}
+void decoderPng::Cleanup (void)
+{
+  png_destroy_read_struct ((png_structpp) &amp; png_ptr, (png_infopp) &amp; info_ptr,
+			   (png_infopp) &amp; end_info);
+}
+decoderPng::~decoderPng ()
+{
+  delete[]rows;
+  delete[]decoded;
+}
+/*
+   	Uncompress frame, set flags if needed
+*/
+uint8_t decoderPng::uncompress(ADMCompressedImage * in, ADMImage * out)
+{
+  int bpp;
+  int colortype;
+
+  // Check if it is png, and fill it
+  if (!!png_sig_cmp (in-&gt;data, 0, 8))
+
+    {
+      printf (&quot;[PNG] wrong sig\n&quot;);
+      return 0;
+    }
+
+  //
+  //
+gain2:
+  Init ();
+  io.data = in-&gt;data;
+  io.size = in-&gt;dataLength;
+  io.cur = 0;
+  png_read_png (PNG_PTR, INFO_PTR, PNG_TRANSFORM_IDENTITY, NULL);
+
+  // Check if it is 24 or 32 bits RGB 
+  bpp = png_get_bit_depth (PNG_PTR, INFO_PTR);
+//   printf(&quot;Bpp:%u\n&quot;,bpp);
+  // if needed we change colorspace 
+  colortype = png_get_color_type (PNG_PTR, INFO_PTR);
+  // 
+  if (colorspace == ADM_COLOR_RGB24 &amp;&amp; colortype == PNG_COLOR_TYPE_RGB_ALPHA)	// RGB32
+    {
+
+      // Switch to 32 bits
+      colorspace = ADM_COLOR_RGB32A;
+      recalc ();
+      goto gain2;
+    }
+
+  else if (colorspace == ADM_COLOR_RGB32A &amp;&amp; colortype == PNG_COLOR_TYPE_RGB)
+
+    {
+
+      // Switch to 24 bits
+      colorspace = ADM_COLOR_RGB24;
+      recalc ();
+      goto gain2;
+    }
+  ADM_assert (out-&gt;_isRef);
+  out-&gt;_planes[0] = decoded;
+  out-&gt;_planes[1] = NULL;
+  out-&gt;_planes[2] = NULL;
+  if (colorspace == ADM_COLOR_RGB32A)
+    out-&gt;_planeStride[0] = _w * 4;
+
+  else
+    out-&gt;_planeStride[0] = _w * 3;
+  out-&gt;_planeStride[1] = 0;
+  out-&gt;_planeStride[2] = 0;
+  out-&gt;_colorspace = colorspace;
+  Cleanup ();
+  return 1;
+}
+
+// ******************************************************
+//    Memory based IO
+// ******************************************************
+void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length)
+{
+  memAccess *ac;
+  ac = (memAccess *) png_get_io_ptr (png_ptr);
+  ADM_assert (length + ac-&gt;cur &lt;= ac-&gt;size);	// or &lt; ?
+  memcpy (data, ac-&gt;data + ac-&gt;cur, length);
+  ac-&gt;cur += length;
+} 
+
+void user_write_data (png_structp png_ptr, png_bytep data, png_size_t length)
+{
+} 
+
+void user_flush_data (png_structp png_ptr)
+{
+}
+//EOF
+#endif /*  */

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,125 @@
+/***************************************************************************
+                          ADM_rgb16.cpp  -  description
+                             -------------------
+    begin                : Mon May 27 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;ADM_default.h&quot;
+//#include &quot;ADM_colorspace/colorspace.h&quot;
+
+#include &quot;ADM_codecs/ADM_codec.h&quot;
+#include &quot;ADM_codecs/ADM_rgb16.h&quot;
+
+decoderRGB16::decoderRGB16(uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp) : decoders (w, h)
+{
+	isRgb = rgb;
+	_bpp = bpp;
+
+	decoded = new uint8_t[_bpp * w * h];
+}
+
+decoderRGB16::~decoderRGB16()
+{
+	delete[] decoded;
+}
+
+uint8_t decoderRGB16::uncompress(ADMCompressedImage * in, ADMImage * out)
+{
+	int xx = _w * _h;
+	int lineSize = (_w * (_bpp / 8) + 3) &amp; ~3;
+	ADM_colorspace colorspace;
+	int i, j;
+	uint8_t *src = in-&gt;data;
+	uint8_t *dst = decoded;
+
+	switch (_bpp)
+	{
+		case 16:
+			// FIXME - 16-bit could use a BGR555 or BGR565 colour mask
+			colorspace = ADM_COLOR_BGR555;
+			break;
+		case 24:
+		case 32:
+			if(isRgb)
+				colorspace = ADM_COLOR_RGB24;
+			else
+				colorspace = ADM_COLOR_BGR24;
+
+			break;
+		default:
+			printf(&quot;bpp %d not supported\n&quot;, _bpp);
+			return 0;
+	}
+
+	if (_bpp == 32)
+	{
+		for(i = 0; i &lt; _h; i++)
+		{
+			uint8_t *buf = src;
+			uint8_t *ptr = dst;
+
+			for(j = 0; j &lt; _w; j++)
+			{
+				ptr[0] = buf[0];
+				ptr[1] = buf[1];
+				ptr[2] = buf[2];
+				ptr += 3;
+				buf += 4;
+			}
+
+			src += lineSize;
+			dst += _w * 3;
+		}
+	}
+	else
+	{
+		memcpy(decoded, in-&gt;data, lineSize * _h);
+
+		if (lineSize == _w * _bpp)
+		{
+			// no extra junk in scanlines so copy as is
+			memcpy(decoded, in-&gt;data, lineSize * _h);
+		}
+		else
+		{
+			// strip extra junk from scanlines (due to 4 byte alignment)
+			for(i = 0; i &lt; _h; i++)
+			{
+				memcpy(dst, src, _w * (_bpp / 8));
+				src += lineSize;
+				dst += _w * (_bpp / 8);
+			}
+		}
+	}
+
+	ADM_assert(out-&gt;_isRef);
+
+	out-&gt;flags = AVI_KEY_FRAME;
+	out-&gt;_colorspace = (ADM_colorspace)(colorspace | ADM_COLOR_BACKWARD);
+
+	out-&gt;_planes[0] = decoded;
+	out-&gt;_planes[1] = NULL;
+	out-&gt;_planes[2] = NULL;
+
+	out-&gt;_planeStride[0] = (_bpp / 8) * _w;
+	out-&gt;_planeStride[1] = 0;
+	out-&gt;_planeStride[2] = 0;
+
+	return 1;
+}
+//EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,116 @@
+/***************************************************************************
+                          ADM_theora_dec.cpp  -  description
+                             -------------------
+    begin                : Thu Sep 26 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;config.h&quot;
+#include &quot;ADM_default.h&quot;
+
+#ifdef USE_THEORA
+#include &quot;ADM_colorspace/colorspace.h&quot;
+
+#include &quot;ADM_codecs/ADM_codec.h&quot;
+
+#include &quot;ADM_codecs/ADM_theora_dec.h&quot;
+//________________________________________________
+void
+decoderTheora::setParam (void)
+{
+  return;			// no param for ffmpeg
+}
+//-------------------------------
+decoderTheora::decoderTheora (uint32_t w, uint32_t h):decoders (w, h)
+{
+  memset (&amp;_tinfo, 0, sizeof (_tinfo));
+  memset (&amp;_tstate, 0, sizeof (_tstate));
+
+  _tinfo.width = _w;
+  _tinfo.height = _h;
+  _tinfo.fps_numerator = 25;
+  _tinfo.fps_denominator = 1;
+  _tinfo.aspect_numerator = 4;
+  _tinfo.aspect_denominator = 3;
+  _tinfo.quality = 9;
+
+  _tinfo.version_major = 3;
+  _tinfo.version_minor = 1;
+
+
+  theora_decode_init (&amp;_tstate, &amp;_tinfo);
+  printf (&quot;\n Theora initialized\n&quot;);
+}
+
+
+//-------------------------------
+
+uint8_t
+  decoderTheora::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
+			     uint32_t * flagz)
+{
+  int got_picture = 0;
+
+  if (len == 0)			// Null frame, silently skip
+    {
+      if (flagz)
+	*flagz = 0;
+      return 1;
+    }
+  ogg_packet ogg;
+
+  memset (&amp;ogg, 0, sizeof (ogg));
+  ogg.packet = in;
+  ogg.bytes = len;
+  /*
+     typedef struct {
+     unsigned char *packet;
+     long  bytes;
+     long  b_o_s;
+     long  e_o_s;
+
+     ogg_int64_t  granulepos;
+
+     ogg_int64_t  packetno;      sequence number for decode; the framing
+     knows where there's a hole in the data,
+     but we need coupling so that the codec
+     (which is in a seperate abstraction
+     layer) also knows about the gap 
+     } ogg_packet; */
+  if (theora_decode_packetin (&amp;_tstate, &amp;ogg))
+    {
+      printf (&quot;\n error decoding theora ..\n&quot;);
+      return 0;
+    }
+  yuv_buffer yuv;
+  theora_decode_YUVout (&amp;_tstate, &amp;yuv);
+  memcpy (out, yuv.y, _w * _h);
+  memset (out + _w * _h, 128, (_w * _h) &gt;&gt; 1);
+
+
+
+
+
+  return 1;
+}
+
+//_____________________________________________________
+
+decoderTheora::~decoderTheora ()
+{
+
+  printf (&quot;Theora destroyed\n&quot;);
+  theora_clear (&amp;_tstate);
+}
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,113 @@
+//
+// C++ Implementation: ADM_uyvy
+//
+// Description: 
+//
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#include &quot;config.h&quot;
+#include &lt;stdio.h&gt;
+
+#ifdef HAVE_SYS_PARAM_H
+#include &lt;sys/param.h&gt;
+#endif
+#if  defined( __FreeBSD__ ) || defined(__APPLE__)
+#include &lt;sys/types.h&gt;
+#endif
+
+#include &quot;ADM_default.h&quot;
+#include &quot;avifmt.h&quot;
+#include &quot;avifmt2.h&quot;
+#include &quot;fourcc.h&quot;
+
+#include &quot;ADM_codecs/ADM_codec.h&quot;
+#include &quot;ADM_codecs/ADM_uyvy.h&quot;
+
+uint8_t
+  decoderUYVY::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+
+  if (in-&gt;dataLength &lt; _w * _h * 2)
+    {
+      printf (&quot;in:%d expected%d\n&quot;, in-&gt;dataLength, _w * _h * 2);
+      return 1;
+    }
+  uint8_t *ptrY, *ptrU, *ptrV, *ptr;
+
+  ptr = in-&gt;data;
+  ptrY = out-&gt;data;
+  ptrU = out-&gt;data + _w * _h;
+  ptrV = ptrU + ((_w * _h) &gt;&gt; 2);
+
+  for (uint32_t y = 0; y &lt; _h; y++)
+    for (uint32_t x = 0; x &lt; (_w &gt;&gt; 2); x++)
+      {
+	if (!(y &amp; 1))
+	  {
+	    *ptrU++ = (*(ptr) + *(ptr + _w)) &gt;&gt; 1;
+	    ptr++;
+	    *ptrY++ = *ptr++;
+	    *ptrV++ = (*(ptr) + *(ptr + _w)) &gt;&gt; 1;
+	    ptr++;
+	    *ptrY++ = *ptr++;
+	  }
+	else
+	  {
+	    *ptrY++ = *(++ptr);
+	    *ptrY++ = *(ptr + 2);
+	    ptr++;
+	  }
+      }
+
+  
+  out-&gt;flags = AVI_KEY_FRAME;
+  return 1;
+
+}
+uint8_t
+  decoderYUY2::uncompress  (ADMCompressedImage * in, ADMImage * out)
+{
+
+  if (in-&gt;dataLength &lt; _w * _h * 2)
+    {
+      printf (&quot;in:%d expected%d\n&quot;, in-&gt;dataLength, _w * _h * 2);
+      return 1;
+    }
+  uint8_t *ptrY, *ptrU, *ptrV, *ptr;
+
+  ptr = in-&gt;data;
+  ptrY = out-&gt;data;
+  ptrV = out-&gt;data + _w * _h;
+  ptrU = out-&gt;data + ((_w * _h * 5) &gt;&gt; 2);
+
+
+  for (uint32_t y = 0; y &lt; _h; y++)
+    for (uint32_t x = 0; x &lt; (_w &gt;&gt; 1); x++)
+      {
+	if (!(y &amp; 1))
+	  {
+	    *ptrY++ = *ptr++;
+	    *ptrU++ = (*(ptr) + *(ptr + _w * 2)) &gt;&gt; 1;
+	    ptr++;
+	    *ptrY++ = *ptr++;
+	    *ptrV++ = (*(ptr) + *(ptr + _w * 2)) &gt;&gt; 1;
+	    ptr++;
+
+	  }
+	else
+	  {
+	    *ptrY++ = *(ptr);
+	    *ptrY++ = *(ptr + 2);
+	    ptr += 4;
+	  }
+      }
+
+
+  out-&gt;flags = AVI_KEY_FRAME;
+  return 1;
+
+}

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,18 @@
+SET(ADM_codecs_SRCS 
+ADM_codecs.cpp
+ADM_png.cpp
+ADM_theora_dec.cpp
+ADM_ffmp43.cpp
+ADM_mjpeg.cpp
+ADM_rgb16.cpp
+ADM_uyvy.cpp
+ADM_ffmpeg_vdpau.cpp
+)
+
+ADD_LIBRARY(ADM_codecs6 STATIC ${ADM_codecs_SRCS})
+
+IF (USE_PNG)
+	 ADD_SOURCE_CFLAGS(ADM_png.cpp ${PNG_CFLAGS})
+ENDIF (USE_PNG)
+
+REMOVE_DEFINITIONS(-DHAVE_CONFIG_H)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
@@ -54,6 +54,7 @@
 ADD_SUBDIRECTORY(ADM_coreAudioEncoder)
 ADD_SUBDIRECTORY(ADM_coreDemuxer)
 ADD_SUBDIRECTORY(ADM_coreDemuxerMpeg)
+ADD_SUBDIRECTORY(ADM_coreVideoCodec)
 ADD_SUBDIRECTORY(ADM_coreImage)
 ADD_SUBDIRECTORY(ADM_coreMuxer)
 ADD_SUBDIRECTORY(ADM_coreUI)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003039.html">[Avidemux-svn-commit] r5833 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml
</A></li>
	<LI>Next message: <A HREF="003041.html">[Avidemux-svn-commit] r5835 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common/ADM_commonUI	avidemux/common/ADM_editor avidemux/common/ADM_script	avidemux/qt4/ADM_userInterfaces/ADM_dialog	avidemux/qt4/ADM_userInterfaces/ADM_gui	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src cmake
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3040">[ date ]</a>
              <a href="thread.html#3040">[ thread ]</a>
              <a href="subject.html#3040">[ subject ]</a>
              <a href="author.html#3040">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
