<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5842 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common avidemux/common/ADM_editor	avidemux/common/ADM_videoCodec	avidemux/common/ADM_videoCodec/include	avidemux/common/ADM_videoCodec/src	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-January/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5842%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux%20avidemux/common%20avidemux/common/ADM_editor%0A%09avidemux/common/ADM_videoCodec%0A%09avidemux/common/ADM_videoCodec/include%0A%09avidemux/common/ADM_videoCodec/src%0A%09avidemux_core/ADM_coreVideoCodec/include%0A%09avidemux_core/ADM_coreVideoCodec/src&In-Reply-To=%3C201001111909.o0BJ9YJa009345%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003047.html">
   <LINK REL="Next"  HREF="003049.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5842 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common avidemux/common/ADM_editor	avidemux/common/ADM_videoCodec	avidemux/common/ADM_videoCodec/include	avidemux/common/ADM_videoCodec/src	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5842%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux%20avidemux/common%20avidemux/common/ADM_editor%0A%09avidemux/common/ADM_videoCodec%0A%09avidemux/common/ADM_videoCodec/include%0A%09avidemux/common/ADM_videoCodec/src%0A%09avidemux_core/ADM_coreVideoCodec/include%0A%09avidemux_core/ADM_coreVideoCodec/src&In-Reply-To=%3C201001111909.o0BJ9YJa009345%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5842 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common avidemux/common/ADM_editor	avidemux/common/ADM_videoCodec	avidemux/common/ADM_videoCodec/include	avidemux/common/ADM_videoCodec/src	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src">mean at mail.berlios.de
       </A><BR>
    <I>Mon Jan 11 20:09:34 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003047.html">[Avidemux-svn-commit] r5841 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_commonUI avidemux_core/ADM_coreVideoCodec/src
</A></li>
        <LI>Next message: <A HREF="003049.html">[Avidemux-svn-commit] r5843 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_videoCodec/src	avidemux_core/ADM_coreVideoCodec/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3048">[ date ]</a>
              <a href="thread.html#3048">[ thread ]</a>
              <a href="subject.html#3048">[ subject ]</a>
              <a href="author.html#3048">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-01-11 20:09:33 +0100 (Mon, 11 Jan 2010)
New Revision: 5842

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_codecVdpau.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_ffmpeg_vdpau_internal.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/CMakeLists.txt
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
Log:
[Codec] Allow codec override by application so that we can put back vdpau. Vdpau needs a X11 device so it cannot goes to coreVideoCodec. Plus it needs preference

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-11 19:09:33 UTC (rev 5842)
@@ -24,6 +24,7 @@
 #include &quot;ADM_vidMisc.h&quot;
 #include &quot;ADM_audiocodec/ADM_audiocodec.h&quot;
 #include &quot;ADM_script/ADM_JSif.h&quot;
+#include &quot;ADM_codec.h&quot;
 
 ADM_EditorSegment::ADM_EditorSegment(void)
 {
@@ -48,7 +49,7 @@
 
   ref-&gt;_aviheader-&gt;getVideoInfo (&amp;info);
   ref-&gt;_aviheader-&gt;getExtraHeaderData (&amp;l, &amp;d);
-  ref-&gt;decoder = getDecoder (info.fcc,  info.width, info.height, l, d,info.bpp);
+  ref-&gt;decoder = ADM_getDecoder (info.fcc,  info.width, info.height, l, d,info.bpp);
   ref-&gt;_videoCache   =   new EditorCache(32,info.width,info.height) ;
 
   float frameD=info.fps1000;

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/CMakeLists.txt	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/CMakeLists.txt	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1 @@
+subdirs (src)

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_codecVdpau.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_codecVdpau.h	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_codecVdpau.h	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1,32 @@
+#ifdef USE_VDPAU
+class decoderFFVDPAU:public decoderFF
+{
+protected:
+                    int b_age;
+                    int ip_age[2];
+
+                    void     *vdpau;
+                    ADMImage *scratch;
+                    ADMImage *vdpau_copy;
+                    uint64_t vdpau_pts;
+                    bool     decode_status;
+                    bool     destroying;
+public:     // Callbacks
+                    int     getBuffer(AVCodecContext *avctx, AVFrame *pic);
+                    void    releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+                    void    goOn( const AVFrame *d,int type);            
+public:
+            // public API
+                    decoderFFVDPAU (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
+                    ~decoderFFVDPAU();
+    virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
+    virtual bool dontcopy (void)
+                      {
+                        return 0;
+                      }
+    virtual bool bFramePossible (void)
+      {
+        return 1;
+      }
+};
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_ffmpeg_vdpau_internal.h (from rev 5841, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1,82 @@
+/***************************************************************************
+            \file              ADM_ffmpeg_vdpau.cpp  
+            \brief Decoder using half ffmpeg/half VDPAU
+
+    The ffmpeg part is to preformat inputs for VDPAU
+    VDPAU is loaded dynamically to be able to make a binary
+        and have something working even if the target machine
+        does not have vdpau
+
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_ffmpeg_vdpa_internal_H
+#define ADM_ffmpeg_vdpa_internal_H
+#include &lt;vector&gt;
+extern &quot;C&quot; {
+static void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height);
+static int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic);
+static void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+}
+
+
+#define NB_SURFACE 50
+typedef struct 
+{
+        VdpDecoder            vdpDecoder;
+        vdpau_render_state *renders[NB_SURFACE];
+        std::vector &lt;vdpau_render_state *&gt;freeQueue;
+
+}vdpauContext;
+
+#define VDPAU ((vdpauContext *)vdpau)
+
+// VDPAU internal linker
+
+typedef struct 
+{
+    VdpGetErrorString       *getErrorString;
+    VdpGetApiVersion        *getApiVersion;
+    VdpGetInformationString *getInformationString;
+
+    VdpVideoSurfaceCreate   *createSurface;
+    VdpVideoSurfaceDestroy  *destroySurface;
+    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
+
+    VdpDecoderCreate        *decoderCreate;
+    VdpDecoderDestroy       *decoderDestroy;
+    VdpDecoderRender        *decoderRender;
+
+}VdpFunctions;
+
+#define WRAP_Open_Template(funcz,argz,display,codecid) \
+{\
+AVCodec *codec=funcz(argz);\
+if(!codec) {GUI_Error_HIG(&quot;Codec&quot;,QT_TR_NOOP(&quot;Internal error finding codec&quot;display));ADM_assert(0);} \
+  codecId=codecid; \
+  _context-&gt;workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
+  _context-&gt;error_concealment=3; \
+  if (avcodec_open(_context, codec) &lt; 0)  \
+                      { \
+                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder failed!\n&quot;); \
+                                        GUI_Error_HIG(&quot;Codec&quot;,&quot;Internal error opening &quot;display); \
+                                        ADM_assert(0); \
+                                } \
+                                else \
+                                { \
+                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder initialized! (%s)\n&quot;,codec-&gt;long_name); \
+                                } \
+}
+
+#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
+#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
+
+#endif
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp (from rev 5841, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1,347 @@
+/***************************************************************************
+            \file              ADM_ffmpeg_vdpau.cpp  
+            \brief Decoder using half ffmpeg/half VDPAU
+
+    The ffmpeg part is to preformat inputs for VDPAU
+    VDPAU is loaded dynamically to be able to make a binary
+        and have something working even if the target machine
+        does not have vdpau
+    Some part, especially get/buffer and ip_age borrowed from xbmc
+        as the api from ffmpeg is far from clear....
+
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+extern &quot;C&quot; {
+#include &quot;ADM_lavcodec.h&quot;
+}
+#include &quot;ADM_default.h&quot;
+#ifdef USE_VDPAU
+extern &quot;C&quot; {
+ #include &quot;ADM_ffmpeg/libavcodec/vdpau.h&quot;
+}
+
+#include &quot;vdpau/vdpau_x11.h&quot;
+#include &quot;vdpau/vdpau.h&quot;
+#include &quot;ADM_codec.h&quot;
+#include &quot;ADM_ffmp43.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_dynamicLoading.h&quot;
+#include &quot;ADM_render/GUI_render.h&quot;
+#include &quot;ADM_ffmpeg_vdpau_internal.h&quot;
+#include &quot;prefs.h&quot;
+#include &quot;ADM_codecVdpau.h&quot;
+
+static VdpFunctions funcs;
+
+static bool vdpauWorking=false;
+
+static ADM_LibWrapper        vdpauDynaLoader;
+static VdpDeviceCreateX11    *ADM_createVdpX11;
+static VdpDevice             vdpDevice;
+static VdpGetProcAddress     *vdpProcAddress;
+
+#define aprintf(...) {}
+
+/**
+    \fn vdpauUsable
+    \brief Return true if  vdpau can be used...
+*/
+bool vdpauUsable(void)
+{
+    uint32_t v=false;
+    if(!vdpauWorking) return false;
+    if(!prefs-&gt;get(FEATURE_VDPAU,&amp;v)) v=false;
+    return v;
+}
+/**
+    \fn getFunc
+    \brief vdpau function pointers from ID
+*/
+static void *getFunc(uint32_t id)
+{
+    void *f;
+    if(VDP_STATUS_OK!=vdpProcAddress(vdpDevice,id,&amp;f)) return NULL;
+    return (void *)f;
+}
+/**
+    \fn vdpauProbe
+    \brief Try loading vdpau...
+*/
+bool vdpauProbe(void)
+{
+    memset(&amp;funcs,0,sizeof(funcs));
+    if(false==vdpauDynaLoader.loadLibrary(&quot;/usr/lib/libvdpau.so&quot;))
+    {
+        return false;
+    }
+    ADM_createVdpX11=(VdpDeviceCreateX11*)vdpauDynaLoader.getSymbol(&quot;vdp_device_create_x11&quot;);
+    if(!ADM_createVdpX11) return false;
+
+    //
+    GUI_WindowInfo xinfo;
+    void *draw;
+    draw=UI_getDrawWidget();
+    UI_getWindowInfo(draw,&amp;xinfo );
+    
+    // try to create....
+    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)xinfo.display,0,&amp;vdpDevice,&amp;vdpProcAddress))
+    {
+        return false;
+    }
+    // Now that we have the vdpProcAddress, time to get the functions....
+#define GetMe(fun,id)         funcs.fun= (typeof(funcs.fun))getFunc(id);ADM_assert(funcs.fun); 
+        
+    GetMe(getErrorString,VDP_FUNC_ID_GET_ERROR_STRING);
+    GetMe(getApiVersion,VDP_FUNC_ID_GET_API_VERSION);
+    GetMe(getInformationString,VDP_FUNC_ID_GET_INFORMATION_STRING);
+
+    GetMe(createSurface,VDP_FUNC_ID_VIDEO_SURFACE_CREATE);
+    GetMe(destroySurface,VDP_FUNC_ID_VIDEO_SURFACE_DESTROY);
+    GetMe(getDataSurface,VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR);
+
+    GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
+    GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
+    GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
+
+
+
+    const char *versionString=NULL;
+    uint32_t version=0xff;
+        funcs.getInformationString(&amp;versionString);
+        funcs.getApiVersion(&amp;version);
+        printf(&quot;[VDPAU] API : 0x%x, info : %s\n&quot;,version,versionString);
+
+    vdpauWorking=true;
+    return true;
+}
+/**
+    \fn ADM_VDPAUgetBuffer
+    \brief trampoline to get a VDPAU surface
+*/
+int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx-&gt;opaque;
+    return dec-&gt;getBuffer(avctx,pic);
+}
+/**
+    \fn getBuffer
+    \brief returns a VDPAU render masquerading as a AVFrame
+*/
+int decoderFFVDPAU::getBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+    vdpau_render_state * render;
+    if(VDPAU-&gt;freeQueue.size()==0)
+    {
+        printf(&quot;[VDPAU] No more available surface\n&quot;);
+        return -1;
+    }
+    // Get an image   
+    render=VDPAU-&gt;freeQueue.back();
+    VDPAU-&gt;freeQueue.pop_back();
+    render-&gt;state=0;
+    pic-&gt;data[0]=(uint8_t *)render;
+    pic-&gt;data[1]=(uint8_t *)render;
+    pic-&gt;data[2]=(uint8_t *)render;
+    pic-&gt;linesize[0]=0;
+    pic-&gt;linesize[1]=0;
+    pic-&gt;linesize[2]=0;
+    pic-&gt;type=FF_BUFFER_TYPE_USER;
+    render-&gt;state |= FF_VDPAU_STATE_USED_FOR_REFERENCE;
+    pic-&gt;reordered_opaque= avctx-&gt;reordered_opaque;
+    if(pic-&gt;reference)
+    {
+        pic-&gt;age=ip_age[0];
+        ip_age[0]=ip_age[1]+1;
+        ip_age[1]=1;
+        b_age++;
+    }else
+    {
+        pic-&gt;age=b_age;
+        ip_age[0]++;
+        ip_age[1]++;
+        b_age=1;
+    }
+    return 0;
+}
+/**
+    \fn releaseBuffer
+*/
+void decoderFFVDPAU::releaseBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+  vdpau_render_state * render;
+  int i;
+  if(destroying==true) return; // They are already freed...
+  render=(vdpau_render_state*)pic-&gt;data[0];
+  ADM_assert(render);
+
+  render-&gt;state &amp;= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
+  for(i=0; i&lt;4; i++){
+    pic-&gt;data[i]= NULL;
+  }
+  VDPAU-&gt;freeQueue.push_back(render);
+}
+/**
+    \fn ADM_VDPAUreleaseBuffer
+*/
+ void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx-&gt;opaque;
+    dec-&gt;releaseBuffer(avctx,pic);
+}
+/**
+    \fn decoderFFVDPAU
+*/
+decoderFFVDPAU::decoderFFVDPAU(uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, 
+        uint8_t *extraData,uint32_t bpp)
+:decoderFF (w,h,fcc,extraDataLen,extraData,bpp)
+{
+        destroying=false;
+        _context-&gt;opaque          = this;
+        _context-&gt;get_buffer      = ADM_VDPAUgetBuffer;
+        _context-&gt;release_buffer  = ADM_VDPAUreleaseBuffer;
+        _context-&gt;draw_horiz_band = draw;
+        _context-&gt;slice_flags     = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
+        _context-&gt;extradata = (uint8_t *) extraData;
+        _context-&gt;extradata_size = (int) extraDataLen;
+
+        vdpau=(void *)new vdpauContext;
+        VDPAU-&gt;vdpDecoder=VDP_INVALID_HANDLE;
+        WRAP_OpenByName(h264_vdpau,CODEC_ID_H264);
+        
+        // Now instantiate our VDPAU surface &amp; decoder
+        ADM_assert(VDP_STATUS_OK==funcs.decoderCreate(vdpDevice,VDP_DECODER_PROFILE_H264_HIGH,w,h,15,&amp;(VDPAU-&gt;vdpDecoder)));
+        // Create our surfaces...
+        for(int i=0;i&lt;NB_SURFACE;i++)
+        {
+            VDPAU-&gt;renders[i]=new vdpau_render_state;
+            memset(VDPAU-&gt;renders[i],0,sizeof( vdpau_render_state));
+            ADM_assert(VDP_STATUS_OK==funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,w,h,&amp;(VDPAU-&gt;renders[i]-&gt;surface)));
+            VDPAU-&gt;freeQueue.push_back(VDPAU-&gt;renders[i]);
+        }
+        scratch=new ADMImage(w,h,1);
+        b_age = ip_age[0] = ip_age[1] = 256*256*256*64;
+
+}
+/**
+    \fn ~            void    goOn( const AVFrame *d);
+*/
+decoderFFVDPAU::~decoderFFVDPAU()
+{
+        printf(&quot;[VDPAU] Cleaning up\n&quot;);
+        destroying=true;
+        for(int i=0;i&lt;NB_SURFACE;i++)
+        {
+            ADM_assert(VDP_STATUS_OK==funcs.destroySurface((VDPAU-&gt;renders[i]-&gt;surface)));
+            delete VDPAU-&gt;renders[i];
+        }
+         ADM_assert(VDP_STATUS_OK==funcs.decoderDestroy(VDPAU-&gt;vdpDecoder));
+         delete VDPAU;
+         vdpau=NULL;
+}
+/**
+    \fn uncompress
+*/
+bool decoderFFVDPAU::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+VdpStatus status;
+    
+    // First let ffmpeg prepare datas...
+    vdpau_copy=out;
+    decode_status=false;
+    if(!decoderFF::uncompress (in, scratch))
+    {
+        printf(&quot;[VDPAU] No data from libavcodec\n&quot;);
+        return 0;
+    }
+    if(decode_status!=true)
+    {
+        printf(&quot;[VDPAU] error in renderDecode\n&quot;);
+        return 0;
+    }
+    // other part will be done in goOn
+  struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch-&gt;_planes[0];
+   VdpVideoSurface  surface;
+
+    surface=rndr-&gt;surface;
+ void *planes[3];
+            planes[0]=vdpau_copy-&gt;GetWritePtr(PLANAR_Y);
+            planes[1]=vdpau_copy-&gt;GetWritePtr(PLANAR_U);
+            planes[2]=vdpau_copy-&gt;GetWritePtr(PLANAR_V);
+    uint32_t stride[3];
+            stride[0]=vdpau_copy-&gt;GetPitch(PLANAR_Y);
+            stride[1]=vdpau_copy-&gt;GetPitch(PLANAR_U);
+            stride[2]=vdpau_copy-&gt;GetPitch(PLANAR_V);
+
+    
+   // Copy back the decoded image to our output ADM_image
+   aprintf(&quot;[VDPAU] Getting datas from surface %d\n&quot;,surface);
+    status=funcs.getDataSurface(
+                surface,
+                VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
+                planes, //void * const *   destination_data,
+                stride //destination_pitches
+                );
+    if(VDP_STATUS_OK!=status)
+    {
+        
+        printf(&quot;[VDPAU] Cannot get data from surface &lt;%s&gt;\n&quot;,funcs.getErrorString(status));
+        decode_status=false;
+        return 0 ;
+    }
+    
+
+    //
+    out-&gt;Pts=scratch-&gt;Pts;
+    out-&gt;flags=scratch-&gt;flags;
+    return (uint8_t)decode_status;
+}
+/**
+    \fn goOn
+    \brief Callback from ffmpeg when a pic is ready to be decoded
+*/
+void decoderFFVDPAU::goOn( const AVFrame *d,int type)
+{
+   VdpStatus status;
+   struct vdpau_render_state *rndr = (struct vdpau_render_state *)d-&gt;data[0];
+   VdpVideoSurface  surface;
+
+    surface=rndr-&gt;surface;
+    vdpau_pts=d-&gt;reordered_opaque; // Retrieve our PTS
+
+     aprintf(&quot;[VDPAU] Decoding Using surface %d\n&quot;, surface);
+    status=funcs.decoderRender(VDPAU-&gt;vdpDecoder, surface,
+                            (void * const *)&amp;rndr-&gt;info, rndr-&gt;bitstream_buffers_used, rndr-&gt;bitstream_buffers);
+    if(VDP_STATUS_OK!=status)
+    {
+        printf(&quot;[VDPAU] No data after decoderRender &lt;%s&gt;\n&quot;,funcs.getErrorString(status));
+        decode_status=false;
+        return ;
+    }
+    aprintf(&quot;[VDPAU] DecodeRender Ok***\n&quot;);
+    decode_status=true;
+    return;
+}
+
+
+/**
+    \fn draw
+    \brief callback invoked by lavcodec when a pic is ready to be decoded
+*/
+void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)s-&gt;opaque;
+    dec-&gt;goOn(src,type);
+}
+
+#endif
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1,51 @@
+/***************************************************************************
+        \file ADM_videoCodec
+        \brief Search and instantiate video coder
+        \author mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> (C) 2010
+
+    see here : <A HREF="http://www.webartz.com/fourcc/">http://www.webartz.com/fourcc/</A>
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+extern &quot;C&quot;
+{
+#include &quot;ADM_lavcodec.h&quot;
+};
+#include &quot;ADM_default.h&quot;
+
+#include &quot;ADM_codec.h&quot;
+#include &quot;ADM_ffmp43.h&quot;
+#include &quot;avidemutils.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;ADM_codecVdpau.h&quot;
+
+extern bool vdpauUsable(void);
+
+/**
+    \fn getDecoder
+    \brief returns the correct decoder for a stream w,h,fcc,extraLen,extraData,bpp
+*/
+decoders *ADM_getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp)
+{
+  ADM_info(&quot;Searching decoder in coreVideoCodec(%d x %d, extradataSize:%d)...\n&quot;,w,h,extraLen);
+  if (isH264Compatible (fcc))
+    {
+#if defined(USE_VDPAU) 
+        if(vdpauUsable()==true)
+            return (decoders *) (new decoderFFVDPAU (w,h,fcc,extraLen,extraData,bpp));
+        
+#endif
+    }
+    return ADM_coreCodecGetDecoder(fcc,w,h,extraLen,extraData,bpp);
+}
+//EOF
+

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/CMakeLists.txt	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/CMakeLists.txt	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1,7 @@
+SET(ADM_videoCodec_SRCS
+        ADM_ffmpeg_vdpau.cpp
+        ADM_videoCodec.cpp
+)
+
+ADD_LIBRARY(ADM_videocodec6 STATIC ${ADM_videoCodec_SRCS})
+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../include)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2010-01-11 19:09:33 UTC (rev 5842)
@@ -21,3 +21,4 @@
 #ADD_SUBDIRECTORY(ADM_videoFilter)
 ADD_SUBDIRECTORY(ADM_videoEncoder)
 ADD_SUBDIRECTORY(ADM_videoFilter2)
+ADD_SUBDIRECTORY(ADM_videoCodec)

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-11 19:09:33 UTC (rev 5842)
@@ -89,6 +89,7 @@
 ADM_editor6
 ADM_audiocodec6 
 ADM_coreVideoCodec6 
+ADM_videocodec6 
 ADM_commonUI6
 )
 SET(commonLibs2

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2010-01-11 19:09:33 UTC (rev 5842)
@@ -85,55 +85,10 @@
         return true;
     }
 };
+/* This function is to be implemented by the application, it is just here for reference */
+decoders *ADM_getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp=0);
+/* This function is implemented in coreVideoCodec, it will return a codec if it can find a suitable one, NULL if not */
+decoders *ADM_coreCodecGetDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp=0);
 
-decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		      uint8_t * extraData,uint32_t bpp=0);
-#if 0
-decoders *getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h,
-			       uint32_t extraLen, uint8_t * extraData);
-decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData);
 
-//***************************************
-
-class coders
-{
-protected:
-  uint32_t _w;
-  uint32_t _h;
-public:
-    coders (uint32_t w, uint32_t h)
-  {
-    _w = w;
-    _h = h;
-  }
-  virtual ~ coders ()
-  {
-  };
-  virtual uint8_t compress (ADMImage * in, ADMBitstream * out);
-};
-decoders *getCoder (uint32_t fcc, uint32_t w, uint32_t h);
-/*----------------------------------------------------------*/
-class encoder
-{
-protected:uint32_t _w, _h;
-public:encoder (uint32_t width, uint32_t height)
-  {
-    _w = width;
-    _h = height;
-  };
-  virtual uint8_t stopEncoder (void) = 0;
-  virtual uint8_t init (uint32_t val, uint32_t fps1000) = 0;
-  virtual uint8_t encode (ADMImage * in, ADMBitstream *out) = 0;
-  virtual uint8_t getExtraData (uint32_t * l, uint8_t ** d)
-  {
-    *l = 0;
-    *d = NULL;
-    return 0;
-  }
-};
-
 #endif
-
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-11 19:09:33 UTC (rev 5842)
@@ -132,39 +132,8 @@
 };
 
 
-#ifdef USE_VDPAU
-class decoderFFVDPAU:public decoderFF
-{
-protected:
-                    int b_age;
-                    int ip_age[2];
 
-                    void     *vdpau;
-                    ADMImage *scratch;
-                    ADMImage *vdpau_copy;
-                    uint64_t vdpau_pts;
-                    bool     decode_status;
-                    bool     destroying;
-public:     // Callbacks
-                    int     getBuffer(AVCodecContext *avctx, AVFrame *pic);
-                    void    releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-                    void    goOn( const AVFrame *d,int type);            
-public:
-            // public API
-                    decoderFFVDPAU (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-                    ~decoderFFVDPAU();
-    virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
-    virtual bool dontcopy (void)
-                      {
-                        return 0;
-                      }
-    virtual bool bFramePossible (void)
-      {
-        return 1;
-      }
-};
-
 #endif
-#endif
+
 // EOF
 

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-01-11 19:09:33 UTC (rev 5842)
@@ -1,82 +0,0 @@
-/***************************************************************************
-            \file              ADM_ffmpeg_vdpau.cpp  
-            \brief Decoder using half ffmpeg/half VDPAU
-
-    The ffmpeg part is to preformat inputs for VDPAU
-    VDPAU is loaded dynamically to be able to make a binary
-        and have something working even if the target machine
-        does not have vdpau
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_ffmpeg_vdpa_internal_H
-#define ADM_ffmpeg_vdpa_internal_H
-#include &lt;vector&gt;
-extern &quot;C&quot; {
-static void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height);
-static int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic);
-static void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-}
-
-
-#define NB_SURFACE 50
-typedef struct 
-{
-        VdpDecoder            vdpDecoder;
-        vdpau_render_state *renders[NB_SURFACE];
-        std::vector &lt;vdpau_render_state *&gt;freeQueue;
-
-}vdpauContext;
-
-#define VDPAU ((vdpauContext *)vdpau)
-
-// VDPAU internal linker
-
-typedef struct 
-{
-    VdpGetErrorString       *getErrorString;
-    VdpGetApiVersion        *getApiVersion;
-    VdpGetInformationString *getInformationString;
-
-    VdpVideoSurfaceCreate   *createSurface;
-    VdpVideoSurfaceDestroy  *destroySurface;
-    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
-
-    VdpDecoderCreate        *decoderCreate;
-    VdpDecoderDestroy       *decoderDestroy;
-    VdpDecoderRender        *decoderRender;
-
-}VdpFunctions;
-
-#define WRAP_Open_Template(funcz,argz,display,codecid) \
-{\
-AVCodec *codec=funcz(argz);\
-if(!codec) {GUI_Error_HIG(&quot;Codec&quot;,QT_TR_NOOP(&quot;Internal error finding codec&quot;display));ADM_assert(0);} \
-  codecId=codecid; \
-  _context-&gt;workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
-  _context-&gt;error_concealment=3; \
-  if (avcodec_open(_context, codec) &lt; 0)  \
-                      { \
-                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder failed!\n&quot;); \
-                                        GUI_Error_HIG(&quot;Codec&quot;,&quot;Internal error opening &quot;display); \
-                                        ADM_assert(0); \
-                                } \
-                                else \
-                                { \
-                                        printf(&quot;[lavc] Decoder init: &quot;display&quot; video decoder initialized! (%s)\n&quot;,codec-&gt;long_name); \
-                                } \
-}
-
-#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
-#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
-
-#endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp	2010-01-11 19:09:33 UTC (rev 5842)
@@ -39,17 +39,14 @@
 #include &quot;avidemutils.h&quot;
 #include &quot;fourcc.h&quot;
 
-extern uint8_t GUI_Question (char *);
-extern uint8_t use_fast_ffmpeg;
-extern bool vdpauUsable(void);
 
 /**
     \fn getDecoder
     \brief returns the correct decoder for a stream w,h,fcc,extraLen,extraData,bpp
 */
-decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp)
+decoders *ADM_coreCodecGetDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp)
 {
-  ADM_info(&quot;Searching decoder (%d x %d, extradataSize:%d)...\n&quot;,w,h,extraLen);
+  ADM_info(&quot;Searching decoder in coreVideoCodec(%d x %d, extradataSize:%d)...\n&quot;,w,h,extraLen);
   if (isMSMpeg4Compatible (fcc) == 1)
     {
       return (decoders *) (new decoderFFDiv3 (w,h,fcc,extraLen,extraData,bpp));

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-11 19:09:33 UTC (rev 5842)
@@ -1,345 +0,0 @@
-/***************************************************************************
-            \file              ADM_ffmpeg_vdpau.cpp  
-            \brief Decoder using half ffmpeg/half VDPAU
-
-    The ffmpeg part is to preformat inputs for VDPAU
-    VDPAU is loaded dynamically to be able to make a binary
-        and have something working even if the target machine
-        does not have vdpau
-    Some part, especially get/buffer and ip_age borrowed from xbmc
-        as the api from ffmpeg is far from clear....
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#if 0
-extern &quot;C&quot; {
-#include &quot;ADM_lavcodec.h&quot;
-}
-#include &quot;ADM_default.h&quot;
-#ifdef USE_VDPAU
-extern &quot;C&quot; {
- #include &quot;ADM_ffmpeg/libavcodec/vdpau.h&quot;
-}
-
-#include &quot;vdpau/vdpau_x11.h&quot;
-#include &quot;vdpau/vdpau.h&quot;
-#include &quot;ADM_codec.h&quot;
-#include &quot;ADM_ffmp43.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;ADM_dynamicLoading.h&quot;
-#include &quot;ADM_render/GUI_render.h&quot;
-#include &quot;ADM_ffmpeg_vdpau_internal.h&quot;
-//#include &quot;prefs.h&quot;
-
-static VdpFunctions funcs;
-
-static bool vdpauWorking=false;
-
-static ADM_LibWrapper        vdpauDynaLoader;
-static VdpDeviceCreateX11    *ADM_createVdpX11;
-static VdpDevice             vdpDevice;
-static VdpGetProcAddress     *vdpProcAddress;
-
-#define aprintf(...) {}
-
-/**
-    \fn vdpauUsable
-    \brief Return true if  vdpau can be used...
-*/
-bool vdpauUsable(void)
-{
-    uint32_t v=false;
-    if(!vdpauWorking) return false;
-    if(!prefs-&gt;get(FEATURE_VDPAU,&amp;v)) v=false;
-    return v;
-}
-/**
-    \fn getFunc
-    \brief vdpau function pointers from ID
-*/
-static void *getFunc(uint32_t id)
-{
-    void *f;
-    if(VDP_STATUS_OK!=vdpProcAddress(vdpDevice,id,&amp;f)) return NULL;
-    return (void *)f;
-}
-/**
-    \fn vdpauProbe
-    \brief Try loading vdpau...
-*/
-bool vdpauProbe(void)
-{
-    memset(&amp;funcs,0,sizeof(funcs));
-    if(false==vdpauDynaLoader.loadLibrary(&quot;/usr/lib/libvdpau.so&quot;))
-    {
-        return false;
-    }
-    ADM_createVdpX11=(VdpDeviceCreateX11*)vdpauDynaLoader.getSymbol(&quot;vdp_device_create_x11&quot;);
-    if(!ADM_createVdpX11) return false;
-
-    //
-    GUI_WindowInfo xinfo;
-    void *draw;
-    draw=UI_getDrawWidget();
-    UI_getWindowInfo(draw,&amp;xinfo );
-    
-    // try to create....
-    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)xinfo.display,0,&amp;vdpDevice,&amp;vdpProcAddress))
-    {
-        return false;
-    }
-    // Now that we have the vdpProcAddress, time to get the functions....
-#define GetMe(fun,id)         funcs.fun= (typeof(funcs.fun))getFunc(id);ADM_assert(funcs.fun); 
-        
-    GetMe(getErrorString,VDP_FUNC_ID_GET_ERROR_STRING);
-    GetMe(getApiVersion,VDP_FUNC_ID_GET_API_VERSION);
-    GetMe(getInformationString,VDP_FUNC_ID_GET_INFORMATION_STRING);
-
-    GetMe(createSurface,VDP_FUNC_ID_VIDEO_SURFACE_CREATE);
-    GetMe(destroySurface,VDP_FUNC_ID_VIDEO_SURFACE_DESTROY);
-    GetMe(getDataSurface,VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR);
-
-    GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
-    GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
-    GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
-
-
-
-    const char *versionString=NULL;
-    uint32_t version=0xff;
-        funcs.getInformationString(&amp;versionString);
-        funcs.getApiVersion(&amp;version);
-        printf(&quot;[VDPAU] API : 0x%x, info : %s\n&quot;,version,versionString);
-
-    vdpauWorking=true;
-    return true;
-}
-/**
-    \fn ADM_VDPAUgetBuffer
-    \brief trampoline to get a VDPAU surface
-*/
-int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx-&gt;opaque;
-    return dec-&gt;getBuffer(avctx,pic);
-}
-/**
-    \fn getBuffer
-    \brief returns a VDPAU render masquerading as a AVFrame
-*/
-int decoderFFVDPAU::getBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-    vdpau_render_state * render;
-    if(VDPAU-&gt;freeQueue.size()==0)
-    {
-        printf(&quot;[VDPAU] No more available surface\n&quot;);
-        return -1;
-    }
-    // Get an image   
-    render=VDPAU-&gt;freeQueue.back();
-    VDPAU-&gt;freeQueue.pop_back();
-    render-&gt;state=0;
-    pic-&gt;data[0]=(uint8_t *)render;
-    pic-&gt;data[1]=(uint8_t *)render;
-    pic-&gt;data[2]=(uint8_t *)render;
-    pic-&gt;linesize[0]=0;
-    pic-&gt;linesize[1]=0;
-    pic-&gt;linesize[2]=0;
-    pic-&gt;type=FF_BUFFER_TYPE_USER;
-    render-&gt;state |= FF_VDPAU_STATE_USED_FOR_REFERENCE;
-    pic-&gt;reordered_opaque= avctx-&gt;reordered_opaque;
-    if(pic-&gt;reference)
-    {
-        pic-&gt;age=ip_age[0];
-        ip_age[0]=ip_age[1]+1;
-        ip_age[1]=1;
-        b_age++;
-    }else
-    {
-        pic-&gt;age=b_age;
-        ip_age[0]++;
-        ip_age[1]++;
-        b_age=1;
-    }
-    return 0;
-}
-/**
-    \fn releaseBuffer
-*/
-void decoderFFVDPAU::releaseBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-  vdpau_render_state * render;
-  int i;
-  if(destroying==true) return; // They are already freed...
-  render=(vdpau_render_state*)pic-&gt;data[0];
-  ADM_assert(render);
-
-  render-&gt;state &amp;= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
-  for(i=0; i&lt;4; i++){
-    pic-&gt;data[i]= NULL;
-  }
-  VDPAU-&gt;freeQueue.push_back(render);
-}
-/**
-    \fn ADM_VDPAUreleaseBuffer
-*/
- void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx-&gt;opaque;
-    dec-&gt;releaseBuffer(avctx,pic);
-}
-/**
-    \fn decoderFFVDPAU
-*/
-decoderFFVDPAU::decoderFFVDPAU(uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-        destroying=false;
-        _context-&gt;opaque          = this;
-        _context-&gt;get_buffer      = ADM_VDPAUgetBuffer;
-        _context-&gt;release_buffer  = ADM_VDPAUreleaseBuffer;
-        _context-&gt;draw_horiz_band = draw;
-        _context-&gt;slice_flags     = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
-        _context-&gt;extradata = (uint8_t *) d;
-        _context-&gt;extradata_size = (int) l;
-
-        vdpau=(void *)new vdpauContext;
-        VDPAU-&gt;vdpDecoder=VDP_INVALID_HANDLE;
-        WRAP_OpenByName(h264_vdpau,CODEC_ID_H264);
-        
-        // Now instantiate our VDPAU surface &amp; decoder
-        ADM_assert(VDP_STATUS_OK==funcs.decoderCreate(vdpDevice,VDP_DECODER_PROFILE_H264_HIGH,w,h,15,&amp;(VDPAU-&gt;vdpDecoder)));
-        // Create our surfaces...
-        for(int i=0;i&lt;NB_SURFACE;i++)
-        {
-            VDPAU-&gt;renders[i]=new vdpau_render_state;
-            memset(VDPAU-&gt;renders[i],0,sizeof( vdpau_render_state));
-            ADM_assert(VDP_STATUS_OK==funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,w,h,&amp;(VDPAU-&gt;renders[i]-&gt;surface)));
-            VDPAU-&gt;freeQueue.push_back(VDPAU-&gt;renders[i]);
-        }
-        scratch=new ADMImage(w,h,1);
-        b_age = ip_age[0] = ip_age[1] = 256*256*256*64;
-
-}
-/**
-    \fn ~            void    goOn( const AVFrame *d);
-*/
-decoderFFVDPAU::~decoderFFVDPAU()
-{
-        printf(&quot;[VDPAU] Cleaning up\n&quot;);
-        destroying=true;
-        for(int i=0;i&lt;NB_SURFACE;i++)
-        {
-            ADM_assert(VDP_STATUS_OK==funcs.destroySurface((VDPAU-&gt;renders[i]-&gt;surface)));
-            delete VDPAU-&gt;renders[i];
-        }
-         ADM_assert(VDP_STATUS_OK==funcs.decoderDestroy(VDPAU-&gt;vdpDecoder));
-         delete VDPAU;
-         vdpau=NULL;
-}
-/**
-    \fn uncompress
-*/
-uint8_t decoderFFVDPAU::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-VdpStatus status;
-    
-    // First let ffmpeg prepare datas...
-    vdpau_copy=out;
-    decode_status=false;
-    if(!decoderFF::uncompress (in, scratch))
-    {
-        printf(&quot;[VDPAU] No data from libavcodec\n&quot;);
-        return 0;
-    }
-    if(decode_status!=true)
-    {
-        printf(&quot;[VDPAU] error in renderDecode\n&quot;);
-        return 0;
-    }
-    // other part will be done in goOn
-  struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch-&gt;_planes[0];
-   VdpVideoSurface  surface;
-
-    surface=rndr-&gt;surface;
- void *planes[3];
-            planes[0]=vdpau_copy-&gt;GetWritePtr(PLANAR_Y);
-            planes[1]=vdpau_copy-&gt;GetWritePtr(PLANAR_U);
-            planes[2]=vdpau_copy-&gt;GetWritePtr(PLANAR_V);
-    uint32_t stride[3];
-            stride[0]=vdpau_copy-&gt;GetPitch(PLANAR_Y);
-            stride[1]=vdpau_copy-&gt;GetPitch(PLANAR_U);
-            stride[2]=vdpau_copy-&gt;GetPitch(PLANAR_V);
-
-    
-   // Copy back the decoded image to our output ADM_image
-   aprintf(&quot;[VDPAU] Getting datas from surface %d\n&quot;,surface);
-    status=funcs.getDataSurface(
-                surface,
-                VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
-                planes, //void * const *   destination_data,
-                stride //destination_pitches
-                );
-    if(VDP_STATUS_OK!=status)
-    {
-        
-        printf(&quot;[VDPAU] Cannot get data from surface &lt;%s&gt;\n&quot;,funcs.getErrorString(status));
-        decode_status=false;
-        return 0 ;
-    }
-    
-
-    //
-    out-&gt;Pts=scratch-&gt;Pts;
-    out-&gt;flags=scratch-&gt;flags;
-    return (uint8_t)decode_status;
-}
-/**
-    \fn goOn
-    \brief Callback from ffmpeg when a pic is ready to be decoded
-*/
-void decoderFFVDPAU::goOn( const AVFrame *d,int type)
-{
-   VdpStatus status;
-   struct vdpau_render_state *rndr = (struct vdpau_render_state *)d-&gt;data[0];
-   VdpVideoSurface  surface;
-
-    surface=rndr-&gt;surface;
-    vdpau_pts=d-&gt;reordered_opaque; // Retrieve our PTS
-
-     aprintf(&quot;[VDPAU] Decoding Using surface %d\n&quot;, surface);
-    status=funcs.decoderRender(VDPAU-&gt;vdpDecoder, surface,
-                            (void * const *)&amp;rndr-&gt;info, rndr-&gt;bitstream_buffers_used, rndr-&gt;bitstream_buffers);
-    if(VDP_STATUS_OK!=status)
-    {
-        printf(&quot;[VDPAU] No data after decoderRender &lt;%s&gt;\n&quot;,funcs.getErrorString(status));
-        decode_status=false;
-        return ;
-    }
-    aprintf(&quot;[VDPAU] DecodeRender Ok***\n&quot;);
-    decode_status=true;
-    return;
-}
-
-
-/**
-    \fn draw
-    \brief callback invoked by lavcodec when a pic is ready to be decoded
-*/
-void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)s-&gt;opaque;
-    dec-&gt;goOn(src,type);
-}
-
-#endif
-#endif
-// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-11 19:09:33 UTC (rev 5842)
@@ -5,7 +5,6 @@
 ADM_codecFFsimple.cpp
 ADM_rgb16.cpp
 ADM_uyvy.cpp
-ADM_ffmpeg_vdpau.cpp
 ADM_png.cpp
 ADM_codecSearch.cpp
 DIA_lavDecoder.cpp


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003047.html">[Avidemux-svn-commit] r5841 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_commonUI avidemux_core/ADM_coreVideoCodec/src
</A></li>
	<LI>Next message: <A HREF="003049.html">[Avidemux-svn-commit] r5843 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_videoCodec/src	avidemux_core/ADM_coreVideoCodec/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3048">[ date ]</a>
              <a href="thread.html#3048">[ thread ]</a>
              <a href="subject.html#3048">[ subject ]</a>
              <a href="author.html#3048">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
