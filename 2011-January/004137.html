<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6963 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_render avidemux_core/ADM_core/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2011-January/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6963%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/common/ADM_render%20avidemux_core/ADM_core/src&In-Reply-To=%3C20110127071850.8E0154812FF%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004136.html">
   <LINK REL="Next"  HREF="004138.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6963 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_render avidemux_core/ADM_core/src</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6963%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/common/ADM_render%20avidemux_core/ADM_core/src&In-Reply-To=%3C20110127071850.8E0154812FF%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6963 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_render avidemux_core/ADM_core/src">mean at mail.berlios.de
       </A><BR>
    <I>Thu Jan 27 08:18:50 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="004136.html">[Avidemux-svn-commit] r6962 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_render avidemux/qt4/ADM_userInterfaces/ADM_gui	avidemux_core/ADM_core/src
</A></li>
        <LI>Next message: <A HREF="004138.html">[Avidemux-svn-commit] r6964 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4137">[ date ]</a>
              <a href="thread.html#4137">[ thread ]</a>
              <a href="subject.html#4137">[ subject ]</a>
              <a href="author.html#4137">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2011-01-27 08:18:50 +0100 (Thu, 27 Jan 2011)
New Revision: 6963

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp
Log:
[cosmetic] Remove dos end of line

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp	2011-01-27 07:18:48 UTC (rev 6962)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp	2011-01-27 07:18:50 UTC (rev 6963)
@@ -1,296 +1,296 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-***************************************************************************/
-
-/***************************************************************************
-*                                                                         *
-*   This program is free software; you can redistribute it and/or modify  *
-*   it under the terms of the GNU General Public License as published by  *
-*   the Free Software Foundation; either version 2 of the License, or     *
-*   (at your option) any later version.                                   *
-*                                                                         *
-***************************************************************************///
-#include &quot;config.h&quot;
-
-#if defined(USE_SDL)
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-extern &quot;C&quot; {
-// get rid of warnings due to different definitions
-#undef HAVE_INTTYPES_H
-#undef HAVE_MALLOC_H
-#undef HAVE_STDINT_H
-#undef HAVE_SYS_TYPES_H
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+***************************************************************************/
+
+/***************************************************************************
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+***************************************************************************///
+#include &quot;config.h&quot;
+
+#if defined(USE_SDL)
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+extern &quot;C&quot; {
+// get rid of warnings due to different definitions
+#undef HAVE_INTTYPES_H
+#undef HAVE_MALLOC_H
+#undef HAVE_STDINT_H
+#undef HAVE_SYS_TYPES_H
 #ifdef __HAIKU__
-#include &quot;SDL/SDL.h&quot;
+#include &quot;SDL/SDL.h&quot;
 #else
-#include &quot;SDL.h&quot;
-#include &quot;SDL_syswm.h&quot;
+#include &quot;SDL.h&quot;
+#include &quot;SDL_syswm.h&quot;
 #endif
-}
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_colorspace.h&quot;
-#include &quot;GUI_render.h&quot;
-#include &quot;GUI_accelRender.h&quot;
-#include &quot;GUI_sdlRender.h&quot;
-
-
-#ifdef __APPLE__
-extern &quot;C&quot;
-{
-	void initSdlCocoaView(void* parent, int x, int y, int width, int height, bool carbonParent);
-	void destroyCocoaView(void);
-}
-#endif
-
-//******************************************
-static uint8_t sdl_running=0;
-static SDL_Overlay *sdl_overlay=NULL;
-static SDL_Surface *sdl_display=NULL;
-static SDL_Rect disp;
-#ifdef __WIN32
-HWND sdlWin32;
-#endif
+}
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_colorspace.h&quot;
+#include &quot;GUI_render.h&quot;
+#include &quot;GUI_accelRender.h&quot;
+#include &quot;GUI_sdlRender.h&quot;
+
+
+#ifdef __APPLE__
+extern &quot;C&quot;
+{
+	void initSdlCocoaView(void* parent, int x, int y, int width, int height, bool carbonParent);
+	void destroyCocoaView(void);
+}
+#endif
+
+//******************************************
+static uint8_t sdl_running=0;
+static SDL_Overlay *sdl_overlay=NULL;
+static SDL_Surface *sdl_display=NULL;
+static SDL_Rect disp;
+#ifdef __WIN32
+HWND sdlWin32;
+#endif
 /**
     \fn sdlRender
-*/
-sdlRender::sdlRender( void)
-{
+*/
+sdlRender::sdlRender( void)
+{
         useYV12=true;
-        ADM_info(&quot;[SDL] Init rendered\n&quot;);
+        ADM_info(&quot;[SDL] Init rendered\n&quot;);
 }
 /**
     \fn stop
-*/
-bool sdlRender::stop( void)
-{
-        if(sdl_overlay)
-        {
-                SDL_FreeYUVOverlay(sdl_overlay);
-        }
-        if(sdl_display)
-        {
-        		SDL_UnlockSurface(sdl_display);
-                SDL_FreeSurface(sdl_display);
-        }
-        if(sdl_running)
-        {
-                SDL_QuitSubSystem(SDL_INIT_VIDEO);
-
-#ifdef __APPLE__
-				destroyCocoaView();
-#endif
-        }
-        sdl_running=0;
-        sdl_overlay=NULL;
-        sdl_display=NULL;
+*/
+bool sdlRender::stop( void)
+{
+        if(sdl_overlay)
+        {
+                SDL_FreeYUVOverlay(sdl_overlay);
+        }
+        if(sdl_display)
+        {
+        		SDL_UnlockSurface(sdl_display);
+                SDL_FreeSurface(sdl_display);
+        }
+        if(sdl_running)
+        {
+                SDL_QuitSubSystem(SDL_INIT_VIDEO);
+
+#ifdef __APPLE__
+				destroyCocoaView();
+#endif
+        }
+        sdl_running=0;
+        sdl_overlay=NULL;
+        sdl_display=NULL;
         ADM_info(&quot;[SDL] Video subsystem closed and destroyed\n&quot;);
-        return true;
+        return true;
 }
 /**
     \fn init
-*/
-bool sdlRender::init( GUI_WindowInfo * window, uint32_t w, uint32_t h,renderZoom zoom)
-{
-	ADM_info(&quot;[SDL] Initialising video subsystem\n&quot;);
-
-#ifdef __APPLE__
-	if (window-&gt;width &gt; w &amp;&amp; window-&gt;height &gt; h)
-	{
-		ADM_info(&quot;[SDL] Disabling acceleration.  Zoom increase not supported on Mac\n&quot;);
-		return 0;
-	}
-#endif
-
-	int bpp;
-	int flags;
-    baseInit(w,h,zoom);
-    // Ask for the position of the drawing window at start
-    disp.w=w;
-    disp.h=h;
-    disp.x=0;
-    disp.y=0;
-
-
-    // Hack to get SDL to use GTK window, ugly but works
-#if !defined(__WIN32) &amp;&amp; !defined(__APPLE__)
-	char SDL_windowhack[32];
-    int winId=(int)window-&gt;window;
-
-    sprintf(SDL_windowhack,&quot;SDL_WINDOWID=%d&quot;,winId);
-    putenv(SDL_windowhack);
-#endif
-
-    if (SDL_InitSubSystem(SDL_INIT_VIDEO) &lt; 0)
-    {
-		ADM_warning(&quot;[SDL] FAILED initialising video subsystem\n&quot;);
-		ADM_warning(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
-
-        return 0;
-    }
-    ADM_info(&quot;SDL subsystem init ok\n&quot;);
-    // Do it twice as the 1st time does not work
-    // Hack to get SDL to use GTK window, ugly but works
-#if !defined(__WIN32) &amp;&amp; !defined(__APPLE__)
-    putenv(SDL_windowhack);
-    SDL_QuitSubSystem(SDL_INIT_VIDEO);
-    if (SDL_InitSubSystem(SDL_INIT_VIDEO) &lt; 0)
-    {
-                ADM_warning(&quot;[SDL] FAILED initialising video subsystem\n&quot;);
-                ADM_warning(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
-                return 0;
-    }
-#endif
-
-    sdl_running=1;
-    flags = SDL_ANYFORMAT | SDL_HWPALETTE | SDL_HWSURFACE | SDL_NOFRAME;
-    bpp= SDL_VideoModeOK( w, h,  32, flags );
-
-#ifdef __WIN32
-	// SDL window is created and displayed before we get a chance to set the parent.
-	// Therefore, align the SDL overlay with the client area before it is displayed.
-	POINT screenPoint = {};
-	char origin[43];
-
-	ClientToScreen((HWND)window-&gt;display, &amp;screenPoint);
-	snprintf(origin, 43, &quot;SDL_VIDEO_WINDOW_POS=%i,%i&quot;, screenPoint.x, screenPoint.y);
-	putenv(origin);
-#endif
-
-#ifdef __APPLE__
-	void* parent;
-
-	if (window-&gt;display)
-		// Carbon parent (Qt4)
-		parent = window-&gt;display;
-	else
-		// Cocoa parent (GTK)
-		parent = (void*)window-&gt;window;
-
-	if (parent)
-		// Create Cocoa view and attach to Carbon window using custom Objective-C function.
-		// It's a retarded way of doing things but that's what Apple has imposed...
-		initSdlCocoaView(parent, window-&gt;x, window-&gt;y, window-&gt;width, window-&gt;height, (window-&gt;display != NULL));
-#endif
-
-	// SDL will resize our window to width and height passed to SetVideoMode.
+*/
+bool sdlRender::init( GUI_WindowInfo * window, uint32_t w, uint32_t h,renderZoom zoom)
+{
+	ADM_info(&quot;[SDL] Initialising video subsystem\n&quot;);
+
+#ifdef __APPLE__
+	if (window-&gt;width &gt; w &amp;&amp; window-&gt;height &gt; h)
+	{
+		ADM_info(&quot;[SDL] Disabling acceleration.  Zoom increase not supported on Mac\n&quot;);
+		return 0;
+	}
+#endif
+
+	int bpp;
+	int flags;
+    baseInit(w,h,zoom);
+    // Ask for the position of the drawing window at start
+    disp.w=w;
+    disp.h=h;
+    disp.x=0;
+    disp.y=0;
+
+
+    // Hack to get SDL to use GTK window, ugly but works
+#if !defined(__WIN32) &amp;&amp; !defined(__APPLE__)
+	char SDL_windowhack[32];
+    int winId=(int)window-&gt;window;
+
+    sprintf(SDL_windowhack,&quot;SDL_WINDOWID=%d&quot;,winId);
+    putenv(SDL_windowhack);
+#endif
+
+    if (SDL_InitSubSystem(SDL_INIT_VIDEO) &lt; 0)
+    {
+		ADM_warning(&quot;[SDL] FAILED initialising video subsystem\n&quot;);
+		ADM_warning(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
+
+        return 0;
+    }
+    ADM_info(&quot;SDL subsystem init ok\n&quot;);
+    // Do it twice as the 1st time does not work
+    // Hack to get SDL to use GTK window, ugly but works
+#if !defined(__WIN32) &amp;&amp; !defined(__APPLE__)
+    putenv(SDL_windowhack);
+    SDL_QuitSubSystem(SDL_INIT_VIDEO);
+    if (SDL_InitSubSystem(SDL_INIT_VIDEO) &lt; 0)
+    {
+                ADM_warning(&quot;[SDL] FAILED initialising video subsystem\n&quot;);
+                ADM_warning(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
+                return 0;
+    }
+#endif
+
+    sdl_running=1;
+    flags = SDL_ANYFORMAT | SDL_HWPALETTE | SDL_HWSURFACE | SDL_NOFRAME;
+    bpp= SDL_VideoModeOK( w, h,  32, flags );
+
+#ifdef __WIN32
+	// SDL window is created and displayed before we get a chance to set the parent.
+	// Therefore, align the SDL overlay with the client area before it is displayed.
+	POINT screenPoint = {};
+	char origin[43];
+
+	ClientToScreen((HWND)window-&gt;display, &amp;screenPoint);
+	snprintf(origin, 43, &quot;SDL_VIDEO_WINDOW_POS=%i,%i&quot;, screenPoint.x, screenPoint.y);
+	putenv(origin);
+#endif
+
+#ifdef __APPLE__
+	void* parent;
+
+	if (window-&gt;display)
+		// Carbon parent (Qt4)
+		parent = window-&gt;display;
+	else
+		// Cocoa parent (GTK)
+		parent = (void*)window-&gt;window;
+
+	if (parent)
+		// Create Cocoa view and attach to Carbon window using custom Objective-C function.
+		// It's a retarded way of doing things but that's what Apple has imposed...
+		initSdlCocoaView(parent, window-&gt;x, window-&gt;y, window-&gt;width, window-&gt;height, (window-&gt;display != NULL));
+#endif
+
+	// SDL will resize our window to width and height passed to SetVideoMode.
 	// This is fine until we use zoomed views so pass window dimensions instead.
-    ADM_info(&quot;SDL setting video mode %d,%d\n&quot;,(int)window-&gt;width,(int)window-&gt;height);
-	sdl_display= SDL_SetVideoMode(window-&gt;width,window-&gt;height, bpp, flags);
-
-    if (!sdl_display)
-    {
-        stop();
-        ADM_warning(&quot;[SDL] Cannot create surface\n&quot;);
-		ADM_warning(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
-        return 0;
-    }
-
-    SDL_LockSurface(sdl_display);
-
-#ifdef __WIN32
-	struct SDL_SysWMinfo wmInfo;
-	SDL_VERSION(&amp;wmInfo.version);
-
-	if (-1 != SDL_GetWMInfo(&amp;wmInfo))
-	{
-		sdlWin32 = wmInfo.window;
-
-		// Make SDL window a child to prevent it from gaining focus
-		int windowFlags = GetWindowLongPtr(sdlWin32, GWL_STYLE);
-
-		SetWindowLongPtr(sdlWin32, GWL_STYLE, (windowFlags &amp; ~WS_POPUP) | WS_CHILD);
-
-		// Set the SDL window's parent to the main window and reposition
-		SetParent(sdlWin32, (HWND)window-&gt;display);
-		SetWindowPos(sdlWin32, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
-
-		// The SDL window stole focus before it was made a child, so set focus back to the main window
-		SetFocus((HWND)window-&gt;display);
-	}
-	else
-	{
-		printf(&quot;[SDL] Reparenting failed\n&quot;);
-	}
-#endif
-
-        int cspace;
-
-        if(useYV12) cspace=SDL_YV12_OVERLAY;
-            else    cspace=SDL_YUY2_OVERLAY;
+    ADM_info(&quot;SDL setting video mode %d,%d\n&quot;,(int)window-&gt;width,(int)window-&gt;height);
+	sdl_display= SDL_SetVideoMode(window-&gt;width,window-&gt;height, bpp, flags);
+
+    if (!sdl_display)
+    {
+        stop();
+        ADM_warning(&quot;[SDL] Cannot create surface\n&quot;);
+		ADM_warning(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
+        return 0;
+    }
+
+    SDL_LockSurface(sdl_display);
+
+#ifdef __WIN32
+	struct SDL_SysWMinfo wmInfo;
+	SDL_VERSION(&amp;wmInfo.version);
+
+	if (-1 != SDL_GetWMInfo(&amp;wmInfo))
+	{
+		sdlWin32 = wmInfo.window;
+
+		// Make SDL window a child to prevent it from gaining focus
+		int windowFlags = GetWindowLongPtr(sdlWin32, GWL_STYLE);
+
+		SetWindowLongPtr(sdlWin32, GWL_STYLE, (windowFlags &amp; ~WS_POPUP) | WS_CHILD);
+
+		// Set the SDL window's parent to the main window and reposition
+		SetParent(sdlWin32, (HWND)window-&gt;display);
+		SetWindowPos(sdlWin32, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
+
+		// The SDL window stole focus before it was made a child, so set focus back to the main window
+		SetFocus((HWND)window-&gt;display);
+	}
+	else
+	{
+		printf(&quot;[SDL] Reparenting failed\n&quot;);
+	}
+#endif
+
+        int cspace;
+
+        if(useYV12) cspace=SDL_YV12_OVERLAY;
+            else    cspace=SDL_YUY2_OVERLAY;
         //_______________________________________________________
-        ADM_info(&quot;Creating overlay\n&quot;);
-        sdl_overlay=SDL_CreateYUVOverlay((w),(h), cspace, sdl_display);
-
-		// DirectX may fail but overlay still created.
-		// Not a showstopper but log failure.
-		if (strlen(SDL_GetError()))
-		{
-			ADM_warning(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
-		}
-
-        if(!sdl_overlay)
-        {
-			stop();
-			ADM_warning(&quot;[SDL] Cannot create SDL overlay\n&quot;);
-			ADM_warning(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
-
-			return 0;
-        }
-
-        printf(&quot;[SDL] Overlay created; type: %d, planes: %d, pitch: %d\n&quot;, sdl_overlay-&gt;hw_overlay, sdl_overlay-&gt;planes, sdl_overlay-&gt;pitches[0]);
-
-        if(!sdl_overlay-&gt;hw_overlay)
-            printf(&quot;[SDL] Hardware acceleration disabled\n&quot;);
-
+        ADM_info(&quot;Creating overlay\n&quot;);
+        sdl_overlay=SDL_CreateYUVOverlay((w),(h), cspace, sdl_display);
+
+		// DirectX may fail but overlay still created.
+		// Not a showstopper but log failure.
+		if (strlen(SDL_GetError()))
+		{
+			ADM_warning(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
+		}
+
+        if(!sdl_overlay)
+        {
+			stop();
+			ADM_warning(&quot;[SDL] Cannot create SDL overlay\n&quot;);
+			ADM_warning(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
+
+			return 0;
+        }
+
+        printf(&quot;[SDL] Overlay created; type: %d, planes: %d, pitch: %d\n&quot;, sdl_overlay-&gt;hw_overlay, sdl_overlay-&gt;planes, sdl_overlay-&gt;pitches[0]);
+
+        if(!sdl_overlay-&gt;hw_overlay)
+            printf(&quot;[SDL] Hardware acceleration disabled\n&quot;);
+
         if(!useYV12)
         {
-          // Create YV12-&gt;YUY2 here!
-        }
-		ADM_info(&quot;[SDL] Video subsystem initalised successfully\n&quot;);
-
-        return 1;
-}
+          // Create YV12-&gt;YUY2 here!
+        }
+		ADM_info(&quot;[SDL] Video subsystem initalised successfully\n&quot;);
 
+        return 1;
+}
+
 /**
     \fn displayImage
-*/
-bool sdlRender::displayImage(ADMImage *pic)
-{
-#ifdef __WIN32
-	// DirectX playback doesn't refresh correctly if the parent window is moved.
-	// Detect when the parent window has moved and force a coordinate update.
-	if (strcmp(getenv(&quot;SDL_VIDEODRIVER&quot;), &quot;directx&quot;) == 0)
-	{
-		static RECT lastPos;
-
-		RECT currentPos;
-		GetWindowRect(sdlWin32, &amp;currentPos);
-
-		if (currentPos.left != lastPos.left || currentPos.top != lastPos.top)
-		{
-			// By default SetWindowPos doesn't work if the new coordinates are the same as the
-			// current so use SWP_FRAMECHANGED to force an update.
-			SetWindowPos(sdlWin32, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
-			lastPos = currentPos;
-		}
-	}
-#endif
-#warning FIXME
+*/
+bool sdlRender::displayImage(ADMImage *pic)
+{
+#ifdef __WIN32
+	// DirectX playback doesn't refresh correctly if the parent window is moved.
+	// Detect when the parent window has moved and force a coordinate update.
+	if (strcmp(getenv(&quot;SDL_VIDEODRIVER&quot;), &quot;directx&quot;) == 0)
+	{
+		static RECT lastPos;
+
+		RECT currentPos;
+		GetWindowRect(sdlWin32, &amp;currentPos);
+
+		if (currentPos.left != lastPos.left || currentPos.top != lastPos.top)
+		{
+			// By default SetWindowPos doesn't work if the new coordinates are the same as the
+			// current so use SWP_FRAMECHANGED to force an update.
+			SetWindowPos(sdlWin32, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
+			lastPos = currentPos;
+		}
+	}
+#endif
+#warning FIXME
 int pitch;
 int w=imageWidth;
-int h=imageHeight;
+int h=imageHeight;
 int page=w*h;
-
-        ADM_assert(sdl_overlay);
-        SDL_LockYUVOverlay(sdl_overlay);
-        pitch=sdl_overlay-&gt;pitches[0];
-//	printf(&quot;SDL: new pitch :%d\n&quot;,pitch);
-        if(useYV12)
+
+        ADM_assert(sdl_overlay);
+        SDL_LockYUVOverlay(sdl_overlay);
+        pitch=sdl_overlay-&gt;pitches[0];
+//	printf(&quot;SDL: new pitch :%d\n&quot;,pitch);
+        if(useYV12)
         {
             uint32_t imagePitch[3];
             uint8_t  *imagePtr[3];
@@ -299,37 +299,37 @@
             //
             BitBlit(sdl_overlay-&gt;pixels[0],sdl_overlay-&gt;pitches[0],imagePtr[0],imagePitch[0],w, h);
             BitBlit(sdl_overlay-&gt;pixels[1],sdl_overlay-&gt;pitches[1],imagePtr[1],imagePitch[1],w/2, h/2);
-            BitBlit(sdl_overlay-&gt;pixels[2],sdl_overlay-&gt;pitches[2],imagePtr[2],imagePitch[2],w/2, h/2);
-
+            BitBlit(sdl_overlay-&gt;pixels[2],sdl_overlay-&gt;pitches[2],imagePtr[2],imagePitch[2],w/2, h/2);
+
         }else
-
+
         { // YUYV
-#if 0
-	        scaler-&gt;changeWidthHeight(w,h);
-	        if(pitch==2*w)
-	        {
-	            scaler-&gt;convert(pic,sdl_overlay-&gt;pixels[0]);
-	        }
-	        else
-	        {
+#if 0
+	        scaler-&gt;changeWidthHeight(w,h);
+	        if(pitch==2*w)
+	        {
+	            scaler-&gt;convert(pic,sdl_overlay-&gt;pixels[0]);
+	        }
+	        else
+	        {
 	            scaler-&gt;convert(pic,decoded);
-                BitBlit(sdl_overlay-&gt;pixels[0],sdl_overlay-&gt;pitches[0],decoded,2*w,h);
+                BitBlit(sdl_overlay-&gt;pixels[0],sdl_overlay-&gt;pitches[0],decoded,2*w,h);
 	        }
 #else
             ADM_warning(&quot;[SDL] YUYV disabled\n&quot;);
             return false;
-#endif
-        }
-       
-        disp.w=displayWidth;
-        disp.h=displayHeight;
-        disp.x=0;
-        disp.y=0;
-
-        SDL_UnlockYUVOverlay(sdl_overlay);
-        SDL_DisplayYUVOverlay(sdl_overlay,&amp;disp);
-
-        return 1;
+#endif
+        }
+       
+        disp.w=displayWidth;
+        disp.h=displayHeight;
+        disp.x=0;
+        disp.y=0;
+
+        SDL_UnlockYUVOverlay(sdl_overlay);
+        SDL_DisplayYUVOverlay(sdl_overlay,&amp;disp);
+
+        return 1;
 }
 
 /**
@@ -341,69 +341,69 @@
         calcDisplayFromZoom(newZoom);
         currentZoom=newZoom;
         return true;
-}
+}
 /**
     \fn initSdl
-*/
-void initSdl(int videoDevice)
-{
-	printf(&quot;\n&quot;);
-	quitSdl();
-
-    int sdl_version = (SDL_Linked_Version()-&gt;major*1000)+(SDL_Linked_Version()-&gt;minor*100) + (SDL_Linked_Version()-&gt;patch);
-
-    printf(&quot;[SDL] Version: %u.%u.%u\n&quot;,SDL_Linked_Version()-&gt;major, SDL_Linked_Version()-&gt;minor, SDL_Linked_Version()-&gt;patch);
-
-#ifdef __WIN32
-	if(videoDevice == RENDER_DIRECTX)
-	{
-		printf(&quot;[SDL] Setting video driver to Microsoft DirectX\n&quot;);
-		putenv(&quot;SDL_VIDEODRIVER=directx&quot;);
-	}
-	else
-	{
-		printf(&quot;[SDL] Setting video driver to Microsoft Windows GDI\n&quot;);
-		putenv(&quot;SDL_VIDEODRIVER=windib&quot;);
-	}
-#endif
-
-	uint32_t sdlInitFlags;
-
-	if (sdl_version &gt; 1209)
-		sdlInitFlags = SDL_INIT_EVERYTHING;
-	else
-		sdlInitFlags = 0;
-
-	printf(&quot;[SDL] Initialisation &quot;);
-
-	if (SDL_Init(sdlInitFlags) == 0)
-	{
-		printf(&quot;succeeded\n&quot;);
-
-		char driverName[100];
-
-		if (SDL_VideoDriverName(driverName, 100) != NULL)
-		{
-			printf(&quot;[SDL] Video Driver: %s\n&quot;, driverName);
-		}
-	}
-	else
-	{
-		printf(&quot;FAILED\n&quot;);
-		printf(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
-	}
-
-	printf(&quot;\n&quot;);
-}
+*/
+void initSdl(int videoDevice)
+{
+	printf(&quot;\n&quot;);
+	quitSdl();
+
+    int sdl_version = (SDL_Linked_Version()-&gt;major*1000)+(SDL_Linked_Version()-&gt;minor*100) + (SDL_Linked_Version()-&gt;patch);
+
+    printf(&quot;[SDL] Version: %u.%u.%u\n&quot;,SDL_Linked_Version()-&gt;major, SDL_Linked_Version()-&gt;minor, SDL_Linked_Version()-&gt;patch);
+
+#ifdef __WIN32
+	if(videoDevice == RENDER_DIRECTX)
+	{
+		printf(&quot;[SDL] Setting video driver to Microsoft DirectX\n&quot;);
+		putenv(&quot;SDL_VIDEODRIVER=directx&quot;);
+	}
+	else
+	{
+		printf(&quot;[SDL] Setting video driver to Microsoft Windows GDI\n&quot;);
+		putenv(&quot;SDL_VIDEODRIVER=windib&quot;);
+	}
+#endif
+
+	uint32_t sdlInitFlags;
+
+	if (sdl_version &gt; 1209)
+		sdlInitFlags = SDL_INIT_EVERYTHING;
+	else
+		sdlInitFlags = 0;
+
+	printf(&quot;[SDL] Initialisation &quot;);
+
+	if (SDL_Init(sdlInitFlags) == 0)
+	{
+		printf(&quot;succeeded\n&quot;);
+
+		char driverName[100];
+
+		if (SDL_VideoDriverName(driverName, 100) != NULL)
+		{
+			printf(&quot;[SDL] Video Driver: %s\n&quot;, driverName);
+		}
+	}
+	else
+	{
+		printf(&quot;FAILED\n&quot;);
+		printf(&quot;[SDL] ERROR: %s\n&quot;, SDL_GetError());
+	}
+
+	printf(&quot;\n&quot;);
+}
 /**
     \fn quitSdl
-*/
-void quitSdl(void)
-{
-	if (SDL_WasInit(SDL_INIT_EVERYTHING))
-	{
-		printf(&quot;[SDL] Quitting...\n&quot;);
-		SDL_Quit();
-	}
-}
-#endif
+*/
+void quitSdl(void)
+{
+	if (SDL_WasInit(SDL_INIT_EVERYTHING))
+	{
+		printf(&quot;[SDL] Quitting...\n&quot;);
+		SDL_Quit();
+	}
+}
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp	2011-01-27 07:18:48 UTC (rev 6962)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp	2011-01-27 07:18:50 UTC (rev 6963)
@@ -1,24 +1,24 @@
-/***************************************************************************
-                    
-    copyright            : (C) 2006 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;dirent.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;sys/stat.h&gt;
+/***************************************************************************
+                    
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;dirent.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;sys/stat.h&gt;
 #include &lt;unistd.h&gt;
 
 #if defined(__APPLE__)
@@ -30,660 +30,660 @@
   #include &lt;shlobj.h&gt;
  #endif
 #endif
-
-#include &quot;ADM_default.h&quot;
-
-
-#ifdef __WIN32
-static const char *separator=&quot;\\&quot;;
-const char *ADM_DIR_NAME=&quot;\\avidemux6&quot;;
+
+#include &quot;ADM_default.h&quot;
+
+
+#ifdef __WIN32
+static const char *separator=&quot;\\&quot;;
+const char *ADM_DIR_NAME=&quot;\\avidemux6&quot;;
 #elif defined __HAIKU__
 static const char *separator=&quot;/&quot;;
 const char *ADM_DIR_NAME=&quot;/config/settings/avidemux6&quot;;
 
-#else
-static const char *separator=&quot;/&quot;;
-const char *ADM_DIR_NAME=&quot;/.avidemux6&quot;;
-#endif
-
-static char ADM_basedir[1024] = {0};
-static char *ADM_jobdir = NULL;
-static char *ADM_customdir = NULL;
-static int baseDirDone = 0;
-
-#undef fread
-#undef fwrite
-#undef fopen
-#undef fclose
-
-#ifdef __WIN32
-extern int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString);
-extern int wideCharStringToUtf8(const wchar_t *wideCharString, int wideCharStringLength, char *utf8String);
-#endif
-
-size_t ADM_fread (void *ptr, size_t size, size_t n, FILE *sstream)
-{
-	return fread(ptr,size,n,sstream);
-}
-
-size_t ADM_fwrite(const void *ptr, size_t size, size_t n, FILE *sstream)
-{
-	return fwrite(ptr,size,n,sstream);
-}
-
-FILE *ADM_fopen(const char *file, const char *mode)
-{
-#ifdef __MINGW32__
-	// Override fopen to handle Unicode filenames and to ensure exclusive access when initially writing to a file.
-	int fileNameLength = utf8StringToWideChar(file, -1, NULL);
-	wchar_t wcFile[fileNameLength];
-	int creation = 0, access = 0;
-	HANDLE hFile;
-
-	utf8StringToWideChar(file, -1, wcFile);
-
-	if (strchr(mode, 'w'))
-	{
-		creation = CREATE_ALWAYS;
-		access = GENERIC_WRITE;
-
-		if (strchr(mode, '+'))
-			access |= GENERIC_READ;
-	}
-	else if (strchr(mode, 'r'))
-	{
-		creation = OPEN_EXISTING;
-		access = GENERIC_READ;
-
-		if (strchr(mode, '+'))
-			access = GENERIC_WRITE;
-	}
-	else if (strchr(mode, 'a'))
-	{
-		creation = OPEN_ALWAYS;
-		access = GENERIC_WRITE;
-
-		if (strchr(mode, '+'))
-			access |= GENERIC_READ;
-	}
-
-	if (creation &amp; GENERIC_WRITE)
-	{
-		hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
-
-		if (hFile == INVALID_HANDLE_VALUE)
-			return NULL;
-		else
-			CloseHandle(hFile);
-	}
-
-	hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
-
-	if (hFile == INVALID_HANDLE_VALUE)
-		return NULL;
-	else
-		return _fdopen(_open_osfhandle((intptr_t)hFile, 0), mode);
-#else
-	return fopen(file, mode);
-#endif
-}
-
-#if __WIN32
-extern &quot;C&quot;
-{
-	// libavformat uses open (in the file_open function) so we need to override that too.
-	// Following the same rules as ADM_fopen.
-	int ADM_open(const char *path, int oflag, ...)
-	{
-		int fileNameLength = utf8StringToWideChar(path, -1, NULL);
-		wchar_t wcFile[fileNameLength];
-		int creation = 0, access = 0;
-		HANDLE hFile;
-
-		utf8StringToWideChar(path, -1, wcFile);
-
-		if (oflag &amp; O_WRONLY || oflag &amp; O_RDWR)
-		{
-			access = GENERIC_WRITE;
-
-			if (oflag &amp; O_RDWR)
-				access |= GENERIC_READ;
-
-			if (oflag &amp; O_CREAT)
-			{
-				if (oflag &amp; O_EXCL)
-					creation = CREATE_NEW;
-				else if (oflag &amp; O_TRUNC)
-					creation = CREATE_ALWAYS;
-				else
-					creation = OPEN_ALWAYS;
-			}
-			else if (oflag &amp; O_TRUNC)
-				creation = TRUNCATE_EXISTING;
-		}
-		else if (oflag &amp; O_RDONLY)
-			creation = OPEN_EXISTING;
-
-		if (creation &amp; GENERIC_WRITE)
-		{
-			hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
-
-			if (hFile == INVALID_HANDLE_VALUE)
-				return -1;
-			else
-				CloseHandle(hFile);
-		}
-
-		hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
-
-		if (hFile == INVALID_HANDLE_VALUE)
-			return -1;
-		else
-			return _open_osfhandle((intptr_t)hFile, oflag);
-	}
-}
-#endif
-
-int ADM_fclose(FILE *file)
-{
-	return fclose(file); 
-}
-
-/*
-      Get the  directory where jobs are stored
-******************************************************/
-char *ADM_getCustomDir(void)
-{
-	if (ADM_customdir)
-		return ADM_customdir;
-
-	ADM_customdir = ADM_getHomeRelativePath(&quot;custom&quot;);
-
-	if (!ADM_mkdir(ADM_customdir))
-	{
-		printf(&quot;can't create custom directory (%s).\n&quot;, ADM_customdir);
-		return NULL;
-	}
-
-	return ADM_customdir;
-}
-
-/*
-      Get the  directory where jobs are stored
-******************************************************/
-char *ADM_getJobDir(void)
-{
-	if (ADM_jobdir)
-		return ADM_jobdir;
-
-	ADM_jobdir = ADM_getHomeRelativePath(&quot;jobs&quot;);
-
-	if (!ADM_mkdir(ADM_jobdir))
-	{
-		printf(&quot;can't create custom directory (%s).\n&quot;, ADM_jobdir);
-		return NULL;
-	}
-
-	return ADM_jobdir;
-}
-
-/**
- * 	\fn ADM_getRelativePath
- */
-static char *ADM_getRelativePath(const char *base0,const char *base1, const char *base2,const char *base3)
-{
-	char *result;
-	int length = strlen(base1);
-
-	if (base2)
-		length += strlen(base2);
-
-	if (base3)
-		length += strlen(base3);
-
-	length += strlen(base0);
-	length += 5; // Slashes + end 0
-	result = (char *)new char [length];
-	strcpy(result, base0);
-	strcat(result, separator);
-
-	strcat(result, base1);
-	strcat(result, separator);
-
-	if (base2)
-	{
-		strcat(result, base2);
-		strcat(result, separator);
-
-		if (base3)
-		{
-			strcat(result, base3);
-			strcat(result, separator);
-		}
-	}
-
-	return result;
-}
-
-/**
- * 	\fn char *ADM_getHomeRelativePath(const char *base1, const char *base2=NULL,const char *base3=NULL);
- *  \brief Returns home directory +base 1 + base 2... The return value is a copy, and must be deleted []
- */
-char *ADM_getHomeRelativePath(const char *base1, const char *base2,const char *base3)
-{
-	return ADM_getRelativePath(ADM_getBaseDir(), base1, base2, base3);
-}
-
-char *ADM_getInstallRelativePath(const char *base1, const char *base2,const char *base3)
-{
-#ifdef __WIN32
-       	wchar_t wcModuleName[MAX_PATH];
-
-	GetModuleFileNameW(0, wcModuleName, sizeof(wcModuleName) / sizeof(wchar_t));
-
-	int len = wideCharStringToUtf8(wcModuleName, -1, NULL);
-	char moduleName[len];
-
-	wideCharStringToUtf8(wcModuleName, -1, moduleName);
-
-
-	char *slash = strrchr(moduleName, '\\');
-		
-	if (slash)
-		*slash = '\0';
-
-	return ADM_getRelativePath(moduleName, base1, base2, base3);
-#elif defined(__APPLE__)
-#define MAX_PATH_SIZE 1024
-
-	char buffer[MAX_PATH_SIZE];
-
-	CFURLRef url(CFBundleCopyExecutableURL(CFBundleGetMainBundle()));
-	buffer[0] = '\0';
-
-	if (url)
-	{
-		CFURLGetFileSystemRepresentation(url, true, (UInt8*)buffer, MAX_PATH_SIZE);
-		CFRelease(url);
-
-		char *slash = strrchr(buffer, '/');
-		
-		if (slash)
-			*slash = '\0';
-	}
-
-	return ADM_getRelativePath(buffer, base1, base2, base3);
-#else
-	return ADM_getRelativePath(ADM_INSTALL_DIR, base1, base2, base3);
-#endif
-}
-
-char *ADM_getPluginPath(void)
-{
-	return ADM_getInstallRelativePath(&quot;lib&quot;, &quot;ADM_plugins&quot;, &quot;videoEncoder&quot;);
-}
-/*
-      Get the root directory for .avidemux stuff
-******************************************************/
-char *ADM_getBaseDir(void)
-{
-	char *home;
-
-	if (baseDirDone)
-		return ADM_basedir;
-
-	// Get the base directory
-#ifdef __WIN32
-	wchar_t wcHome[MAX_PATH];
-
-	if (SHGetFolderPathW(NULL, CSIDL_APPDATA, NULL, 0, wcHome) == S_OK)
-	{
-		int len = wideCharStringToUtf8(wcHome, -1, NULL);
-		home = new char[len];
-
-		wideCharStringToUtf8(wcHome, -1, home);
-	}
-	else
-	{
-		printf(&quot;Oops: can't determine the Application Data folder.&quot;);
-		home = ADM_strdup(&quot;c:\\&quot;);
-	}
-#else
-	const char* homeEnv = getenv(&quot;HOME&quot;);
-
-	if (homeEnv)
-	{
-		home = new char[strlen(homeEnv) + 1];
-		strcpy(home, homeEnv);
-	}
-	else
-	{
-		printf(&quot;Oops: can't determine $HOME.&quot;);
-
-		return NULL;
-	}
-#endif
-
-	// Try to open the .avidemux directory
-
-	strcpy(ADM_basedir, home);
+#else
+static const char *separator=&quot;/&quot;;
+const char *ADM_DIR_NAME=&quot;/.avidemux6&quot;;
+#endif
+
+static char ADM_basedir[1024] = {0};
+static char *ADM_jobdir = NULL;
+static char *ADM_customdir = NULL;
+static int baseDirDone = 0;
+
+#undef fread
+#undef fwrite
+#undef fopen
+#undef fclose
+
+#ifdef __WIN32
+extern int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString);
+extern int wideCharStringToUtf8(const wchar_t *wideCharString, int wideCharStringLength, char *utf8String);
+#endif
+
+size_t ADM_fread (void *ptr, size_t size, size_t n, FILE *sstream)
+{
+	return fread(ptr,size,n,sstream);
+}
+
+size_t ADM_fwrite(const void *ptr, size_t size, size_t n, FILE *sstream)
+{
+	return fwrite(ptr,size,n,sstream);
+}
+
+FILE *ADM_fopen(const char *file, const char *mode)
+{
+#ifdef __MINGW32__
+	// Override fopen to handle Unicode filenames and to ensure exclusive access when initially writing to a file.
+	int fileNameLength = utf8StringToWideChar(file, -1, NULL);
+	wchar_t wcFile[fileNameLength];
+	int creation = 0, access = 0;
+	HANDLE hFile;
+
+	utf8StringToWideChar(file, -1, wcFile);
+
+	if (strchr(mode, 'w'))
+	{
+		creation = CREATE_ALWAYS;
+		access = GENERIC_WRITE;
+
+		if (strchr(mode, '+'))
+			access |= GENERIC_READ;
+	}
+	else if (strchr(mode, 'r'))
+	{
+		creation = OPEN_EXISTING;
+		access = GENERIC_READ;
+
+		if (strchr(mode, '+'))
+			access = GENERIC_WRITE;
+	}
+	else if (strchr(mode, 'a'))
+	{
+		creation = OPEN_ALWAYS;
+		access = GENERIC_WRITE;
+
+		if (strchr(mode, '+'))
+			access |= GENERIC_READ;
+	}
+
+	if (creation &amp; GENERIC_WRITE)
+	{
+		hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
+
+		if (hFile == INVALID_HANDLE_VALUE)
+			return NULL;
+		else
+			CloseHandle(hFile);
+	}
+
+	hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
+
+	if (hFile == INVALID_HANDLE_VALUE)
+		return NULL;
+	else
+		return _fdopen(_open_osfhandle((intptr_t)hFile, 0), mode);
+#else
+	return fopen(file, mode);
+#endif
+}
+
+#if __WIN32
+extern &quot;C&quot;
+{
+	// libavformat uses open (in the file_open function) so we need to override that too.
+	// Following the same rules as ADM_fopen.
+	int ADM_open(const char *path, int oflag, ...)
+	{
+		int fileNameLength = utf8StringToWideChar(path, -1, NULL);
+		wchar_t wcFile[fileNameLength];
+		int creation = 0, access = 0;
+		HANDLE hFile;
+
+		utf8StringToWideChar(path, -1, wcFile);
+
+		if (oflag &amp; O_WRONLY || oflag &amp; O_RDWR)
+		{
+			access = GENERIC_WRITE;
+
+			if (oflag &amp; O_RDWR)
+				access |= GENERIC_READ;
+
+			if (oflag &amp; O_CREAT)
+			{
+				if (oflag &amp; O_EXCL)
+					creation = CREATE_NEW;
+				else if (oflag &amp; O_TRUNC)
+					creation = CREATE_ALWAYS;
+				else
+					creation = OPEN_ALWAYS;
+			}
+			else if (oflag &amp; O_TRUNC)
+				creation = TRUNCATE_EXISTING;
+		}
+		else if (oflag &amp; O_RDONLY)
+			creation = OPEN_EXISTING;
+
+		if (creation &amp; GENERIC_WRITE)
+		{
+			hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
+
+			if (hFile == INVALID_HANDLE_VALUE)
+				return -1;
+			else
+				CloseHandle(hFile);
+		}
+
+		hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
+
+		if (hFile == INVALID_HANDLE_VALUE)
+			return -1;
+		else
+			return _open_osfhandle((intptr_t)hFile, oflag);
+	}
+}
+#endif
+
+int ADM_fclose(FILE *file)
+{
+	return fclose(file); 
+}
+
+/*
+      Get the  directory where jobs are stored
+******************************************************/
+char *ADM_getCustomDir(void)
+{
+	if (ADM_customdir)
+		return ADM_customdir;
+
+	ADM_customdir = ADM_getHomeRelativePath(&quot;custom&quot;);
+
+	if (!ADM_mkdir(ADM_customdir))
+	{
+		printf(&quot;can't create custom directory (%s).\n&quot;, ADM_customdir);
+		return NULL;
+	}
+
+	return ADM_customdir;
+}
+
+/*
+      Get the  directory where jobs are stored
+******************************************************/
+char *ADM_getJobDir(void)
+{
+	if (ADM_jobdir)
+		return ADM_jobdir;
+
+	ADM_jobdir = ADM_getHomeRelativePath(&quot;jobs&quot;);
+
+	if (!ADM_mkdir(ADM_jobdir))
+	{
+		printf(&quot;can't create custom directory (%s).\n&quot;, ADM_jobdir);
+		return NULL;
+	}
+
+	return ADM_jobdir;
+}
+
+/**
+ * 	\fn ADM_getRelativePath
+ */
+static char *ADM_getRelativePath(const char *base0,const char *base1, const char *base2,const char *base3)
+{
+	char *result;
+	int length = strlen(base1);
+
+	if (base2)
+		length += strlen(base2);
+
+	if (base3)
+		length += strlen(base3);
+
+	length += strlen(base0);
+	length += 5; // Slashes + end 0
+	result = (char *)new char [length];
+	strcpy(result, base0);
+	strcat(result, separator);
+
+	strcat(result, base1);
+	strcat(result, separator);
+
+	if (base2)
+	{
+		strcat(result, base2);
+		strcat(result, separator);
+
+		if (base3)
+		{
+			strcat(result, base3);
+			strcat(result, separator);
+		}
+	}
+
+	return result;
+}
+
+/**
+ * 	\fn char *ADM_getHomeRelativePath(const char *base1, const char *base2=NULL,const char *base3=NULL);
+ *  \brief Returns home directory +base 1 + base 2... The return value is a copy, and must be deleted []
+ */
+char *ADM_getHomeRelativePath(const char *base1, const char *base2,const char *base3)
+{
+	return ADM_getRelativePath(ADM_getBaseDir(), base1, base2, base3);
+}
+
+char *ADM_getInstallRelativePath(const char *base1, const char *base2,const char *base3)
+{
+#ifdef __WIN32
+       	wchar_t wcModuleName[MAX_PATH];
+
+	GetModuleFileNameW(0, wcModuleName, sizeof(wcModuleName) / sizeof(wchar_t));
+
+	int len = wideCharStringToUtf8(wcModuleName, -1, NULL);
+	char moduleName[len];
+
+	wideCharStringToUtf8(wcModuleName, -1, moduleName);
+
+
+	char *slash = strrchr(moduleName, '\\');
+		
+	if (slash)
+		*slash = '\0';
+
+	return ADM_getRelativePath(moduleName, base1, base2, base3);
+#elif defined(__APPLE__)
+#define MAX_PATH_SIZE 1024
+
+	char buffer[MAX_PATH_SIZE];
+
+	CFURLRef url(CFBundleCopyExecutableURL(CFBundleGetMainBundle()));
+	buffer[0] = '\0';
+
+	if (url)
+	{
+		CFURLGetFileSystemRepresentation(url, true, (UInt8*)buffer, MAX_PATH_SIZE);
+		CFRelease(url);
+
+		char *slash = strrchr(buffer, '/');
+		
+		if (slash)
+			*slash = '\0';
+	}
+
+	return ADM_getRelativePath(buffer, base1, base2, base3);
+#else
+	return ADM_getRelativePath(ADM_INSTALL_DIR, base1, base2, base3);
+#endif
+}
+
+char *ADM_getPluginPath(void)
+{
+	return ADM_getInstallRelativePath(&quot;lib&quot;, &quot;ADM_plugins&quot;, &quot;videoEncoder&quot;);
+}
+/*
+      Get the root directory for .avidemux stuff
+******************************************************/
+char *ADM_getBaseDir(void)
+{
+	char *home;
+
+	if (baseDirDone)
+		return ADM_basedir;
+
+	// Get the base directory
+#ifdef __WIN32
+	wchar_t wcHome[MAX_PATH];
+
+	if (SHGetFolderPathW(NULL, CSIDL_APPDATA, NULL, 0, wcHome) == S_OK)
+	{
+		int len = wideCharStringToUtf8(wcHome, -1, NULL);
+		home = new char[len];
+
+		wideCharStringToUtf8(wcHome, -1, home);
+	}
+	else
+	{
+		printf(&quot;Oops: can't determine the Application Data folder.&quot;);
+		home = ADM_strdup(&quot;c:\\&quot;);
+	}
+#else
+	const char* homeEnv = getenv(&quot;HOME&quot;);
+
+	if (homeEnv)
+	{
+		home = new char[strlen(homeEnv) + 1];
+		strcpy(home, homeEnv);
+	}
+	else
+	{
+		printf(&quot;Oops: can't determine $HOME.&quot;);
+
+		return NULL;
+	}
+#endif
+
+	// Try to open the .avidemux directory
+
+	strcpy(ADM_basedir, home);
 	strcat(ADM_basedir, ADM_DIR_NAME);
     delete [] home;
-    home=NULL;
-
-	if (!ADM_mkdir(ADM_basedir))
-	{
-		printf(&quot;Oops: cannot create the .avidemux directory&quot;, NULL);
-		return NULL;
-	}
-
+    home=NULL;
+
+	if (!ADM_mkdir(ADM_basedir))
+	{
+		printf(&quot;Oops: cannot create the .avidemux directory&quot;, NULL);
+		return NULL;
+	}
+
 	// Now built the filename
-	baseDirDone = 1;
-	printf(&quot;Using %s as base directory for prefs/jobs/...\n&quot;, ADM_basedir);
-	return ADM_basedir;
-}
-
-#ifdef __WIN32
-#define DIR _WDIR
-#define dirent _wdirent
-#define opendir _wopendir
-#define readdir _wreaddir
-#define closedir _wclosedir
-#endif
-
-/*----------------------------------------
-      Create a directory
-      If it already exists, do nothing
-------------------------------------------*/
-uint8_t ADM_mkdir(const char *dirname)
-{
-	DIR *dir = NULL;
-
-#ifdef __WIN32
-	int dirNameLength = utf8StringToWideChar(dirname, -1, NULL);
-	wchar_t dirname2[dirNameLength];
-
-	utf8StringToWideChar(dirname, -1, dirname2);
-#else
-	const char* dirname2 = dirname;
-#endif
-
-	// Check it already exists ?
-	dir = opendir(dirname2);
-
-	if (dir)
-	{ 
-		printf(&quot;Directory %s exists.Good.\n&quot;, dirname);
-		closedir(dir);
-		return 1;
-	}
-#ifdef __WIN32
-	if (_wmkdir(dirname2))
-	{
-		printf(&quot;Oops: mkdir failed on %s\n&quot;, dirname);
-		return 0;
-	}
-#else
-	printf(&quot;Creating dir :%s\n&quot;, dirname2);
-	mkdir(dirname2,0755);
-
-#endif
-
-	if ((dir = opendir(dirname2)) == NULL)
-		return 0;
-
-	closedir(dir);
-
-	return 1;
-}
-/**
- *  \fn buildDirectoryContent
- * 	\brief Returns the content of a dir with the extension ext. The receiving array must be allocated by caller
- * (just the array, not the names themselves)
- */
-uint8_t buildDirectoryContent(uint32_t *outnb, const char *base, char *jobName[], int maxElems, const char *ext)
-{
-	DIR *dir;
-	struct dirent *direntry;
-	int dirmax = 0, len;
-	int extlen = strlen(ext);
-
-	ADM_assert(extlen);
-
-#ifdef __WIN32
-	int dirNameLength = utf8StringToWideChar(base, -1, NULL);
-	wchar_t base2[dirNameLength];
-
-	utf8StringToWideChar(base, -1, base2);
-#else
-	const char *base2 = base;
-#endif
-
-	dir = opendir(base2);
-	if (!dir)
-		return 0;
-
-	while (direntry = readdir(dir))
-	{
-#ifdef __WIN32
-		int dirLength = wideCharStringToUtf8(direntry-&gt;d_name, -1, NULL);
-		char d_name[dirLength];
-
-		wideCharStringToUtf8(direntry-&gt;d_name, -1, d_name);
-#else
-		const char *d_name = direntry-&gt;d_name;
-#endif
-
-		len = strlen(d_name);
-
-		if (len &lt; (extlen + 1))
-			continue;
-
-		int xbase = len - extlen;
-
-		if (memcmp(d_name + xbase, ext, extlen))
-			//if (direntry-&gt;d_name[len-1]!='s' || direntry-&gt;d_name[len-2]!='j' || direntry-&gt;d_name[len-3]!='.')
-		{
-			printf(&quot;ignored: %s\n&quot;, d_name);
-			continue;
-		}
-
-		jobName[dirmax] = (char *)ADM_alloc(strlen(base) + strlen(d_name) + 2);
-		strcpy(jobName[dirmax], base);
-		strcat(jobName[dirmax], &quot;/&quot;);
-		strcat(jobName[dirmax], d_name);
-		dirmax++;
-
-		if (dirmax &gt;= maxElems)
-		{
-			printf(&quot;[jobs]: Max # of jobs exceeded\n&quot;);
-			break;
-		}
-	}
-
-	closedir(dir);
-	*outnb = dirmax;
-
-	return 1;
-}
-//------------------------------------------------------------------
-
-/*
-
-** note: it modifies it's first argument
-*/
-void simplify_path(char **buf)
-{
-	unsigned int last1slash = 0;
-	unsigned int last2slash = 0;
-
-	while (!strncmp(*buf, &quot;/../&quot;, 4))
-		memmove(*buf, *buf + 3, strlen(*buf + 3) + 1);
-
-	for (unsigned int i = 0; i &lt; strlen(*buf) - 2; i++)
-		while (!strncmp(*buf + i, &quot;/./&quot;, 3))
-			memmove(*buf + i, *buf + i + 2, strlen(*buf + i + 2) + 1);
-
-	for (unsigned int i = 0; i &lt; strlen(*buf) - 3; i++)
-	{
-		if (*(*buf + i) == '/')
-		{
-			last2slash = last1slash;
-			last1slash = i;
-		}
-
-		if (!strncmp(*buf + i, &quot;/../&quot;, 4))
-		{
-			memmove(*buf + last2slash, *buf + i + 3, strlen(*buf + i + 3) + 1);
-
-			return simplify_path(buf);
-		}
-	}
-}
-
-/**
-        \fn ADM_PathCanonize
-        \brief Canonize the path, returns a copy of the absolute path given as parameter
-*/
-char *ADM_PathCanonize(const char *tmpname)
-{
-	char path[300];
-	char *out;
-
-	if (!getcwd(path, 300))
-	{
-		fprintf(stderr, &quot;\ngetcwd() failed with: %s (%u)\n&quot;, strerror(errno), errno);
-		path[0] = '\0';
-	}
-
-	if (!tmpname || tmpname[0] == 0)
-	{
-		out = new char[strlen(path) + 2];
-		strcpy(out, path);
-#ifndef __WIN32
-		strcat(out, &quot;/&quot;);
-#else
-		strcat(out, &quot;\\&quot;);
-#endif
-		printf(&quot;\n Canonizing null string ??? (%s)\n&quot;, out);
-	}
-	else if (tmpname[0] == '/'
-#if defined(__WIN32)
-		|| tmpname[1] == ':'
-#endif
-		)
-	{
-		out = new char[strlen(tmpname) + 1];
-		strcpy(out, tmpname);
-
-		return out;
-	}
-	else
-	{
-		out = new char[strlen(path) + strlen(tmpname) + 6];
-		strcpy(out, path);
-#ifndef __WIN32
-		strcat(out, &quot;/&quot;);
-#else
-		strcat(out, &quot;\\&quot;);
-#endif
-		strcat(out, tmpname);
-	}
-
-	simplify_path(&amp;out);
-
-	return out;
-}
-
-/**
-        \fn ADM_PathStripName
-	\brief Returns path only /foo/bar.avi -&gt; /foo INPLACE, no copy done
-
-*/
-void ADM_PathStripName(char *str)
-{
-	int len = strlen(str);
-
-	if (len &lt;= 1)
-		return;
-
-	len--;
-
-#ifndef __WIN32
-	while (*(str + len) != '/' &amp;&amp; len)
-#else
-	while (*(str + len) != '\\' &amp;&amp; len)
-#endif
-	{
-		*(str + len) = 0;
-		len--;
-	}
-}
-
-/**
-    \fn ADM_GetFileName
-    \brief Get the filename without path. /foo/bar.avi -&gt; bar.avi INPLACE, NO COPY
-
-*/
-const char *ADM_GetFileName(const char *str)
-{
-	const char *filename;
-	const char *filename2;
-
-#ifndef __WIN32
-	filename = strrchr(str, '/');
-#else
-	filename = strrchr(str, '\\');
-	filename2 = strrchr(str, '/');
-
-	if (filename2 &amp;&amp; filename)
-		if (filename2 &gt; filename)
-			filename = filename2;
-#endif
-
-	if (filename)
-		return filename + 1;
-	else
-		return str;
-}
-
-/**
-    \fn ADM_PathSplit
-    \brief Split path into absolute path+name and extention i.e. /foo/bar/zee.avi -&gt; /foo/bar/zee,avi.             Copy are returned
-
-*/
-void ADM_PathSplit(const char *str, char **root, char **ext)
-{
-	char *full;
-	uint32_t l;
-
-	full = ADM_PathCanonize(str);
-	// Search the last
-	l = strlen(full);
-	l--;
-	ADM_assert(l &gt; 0);
-
-	while (*(full + l) != '.' &amp;&amp; l)
-		l--;
-
-	if (!l || l == (strlen(full) - 1))
-	{
-		if (l == (strlen(full) - 1))
-			*(full + l) = 0;  // remove trailing
-
-		*ext = new char[2];
-		*root = full;
-		strcpy(*ext, &quot;&quot;);
-
-		return;
-	}
-	// else we do get an extension
-	// starting at l+1
-	uint32_t suff;
-
-	suff = strlen(full) - l - 1;
-	*ext = new char[suff + 1];
-	strcpy(*ext, full + l + 1);
-	*(full + l) = 0;
-	*root = full;
-}
+	baseDirDone = 1;
+	printf(&quot;Using %s as base directory for prefs/jobs/...\n&quot;, ADM_basedir);
+	return ADM_basedir;
+}
+
+#ifdef __WIN32
+#define DIR _WDIR
+#define dirent _wdirent
+#define opendir _wopendir
+#define readdir _wreaddir
+#define closedir _wclosedir
+#endif
+
+/*----------------------------------------
+      Create a directory
+      If it already exists, do nothing
+------------------------------------------*/
+uint8_t ADM_mkdir(const char *dirname)
+{
+	DIR *dir = NULL;
+
+#ifdef __WIN32
+	int dirNameLength = utf8StringToWideChar(dirname, -1, NULL);
+	wchar_t dirname2[dirNameLength];
+
+	utf8StringToWideChar(dirname, -1, dirname2);
+#else
+	const char* dirname2 = dirname;
+#endif
+
+	// Check it already exists ?
+	dir = opendir(dirname2);
+
+	if (dir)
+	{ 
+		printf(&quot;Directory %s exists.Good.\n&quot;, dirname);
+		closedir(dir);
+		return 1;
+	}
+#ifdef __WIN32
+	if (_wmkdir(dirname2))
+	{
+		printf(&quot;Oops: mkdir failed on %s\n&quot;, dirname);
+		return 0;
+	}
+#else
+	printf(&quot;Creating dir :%s\n&quot;, dirname2);
+	mkdir(dirname2,0755);
+
+#endif
+
+	if ((dir = opendir(dirname2)) == NULL)
+		return 0;
+
+	closedir(dir);
+
+	return 1;
+}
+/**
+ *  \fn buildDirectoryContent
+ * 	\brief Returns the content of a dir with the extension ext. The receiving array must be allocated by caller
+ * (just the array, not the names themselves)
+ */
+uint8_t buildDirectoryContent(uint32_t *outnb, const char *base, char *jobName[], int maxElems, const char *ext)
+{
+	DIR *dir;
+	struct dirent *direntry;
+	int dirmax = 0, len;
+	int extlen = strlen(ext);
+
+	ADM_assert(extlen);
+
+#ifdef __WIN32
+	int dirNameLength = utf8StringToWideChar(base, -1, NULL);
+	wchar_t base2[dirNameLength];
+
+	utf8StringToWideChar(base, -1, base2);
+#else
+	const char *base2 = base;
+#endif
+
+	dir = opendir(base2);
+	if (!dir)
+		return 0;
+
+	while (direntry = readdir(dir))
+	{
+#ifdef __WIN32
+		int dirLength = wideCharStringToUtf8(direntry-&gt;d_name, -1, NULL);
+		char d_name[dirLength];
+
+		wideCharStringToUtf8(direntry-&gt;d_name, -1, d_name);
+#else
+		const char *d_name = direntry-&gt;d_name;
+#endif
+
+		len = strlen(d_name);
+
+		if (len &lt; (extlen + 1))
+			continue;
+
+		int xbase = len - extlen;
+
+		if (memcmp(d_name + xbase, ext, extlen))
+			//if (direntry-&gt;d_name[len-1]!='s' || direntry-&gt;d_name[len-2]!='j' || direntry-&gt;d_name[len-3]!='.')
+		{
+			printf(&quot;ignored: %s\n&quot;, d_name);
+			continue;
+		}
+
+		jobName[dirmax] = (char *)ADM_alloc(strlen(base) + strlen(d_name) + 2);
+		strcpy(jobName[dirmax], base);
+		strcat(jobName[dirmax], &quot;/&quot;);
+		strcat(jobName[dirmax], d_name);
+		dirmax++;
+
+		if (dirmax &gt;= maxElems)
+		{
+			printf(&quot;[jobs]: Max # of jobs exceeded\n&quot;);
+			break;
+		}
+	}
+
+	closedir(dir);
+	*outnb = dirmax;
+
+	return 1;
+}
+//------------------------------------------------------------------
+
+/*
+
+** note: it modifies it's first argument
+*/
+void simplify_path(char **buf)
+{
+	unsigned int last1slash = 0;
+	unsigned int last2slash = 0;
+
+	while (!strncmp(*buf, &quot;/../&quot;, 4))
+		memmove(*buf, *buf + 3, strlen(*buf + 3) + 1);
+
+	for (unsigned int i = 0; i &lt; strlen(*buf) - 2; i++)
+		while (!strncmp(*buf + i, &quot;/./&quot;, 3))
+			memmove(*buf + i, *buf + i + 2, strlen(*buf + i + 2) + 1);
+
+	for (unsigned int i = 0; i &lt; strlen(*buf) - 3; i++)
+	{
+		if (*(*buf + i) == '/')
+		{
+			last2slash = last1slash;
+			last1slash = i;
+		}
+
+		if (!strncmp(*buf + i, &quot;/../&quot;, 4))
+		{
+			memmove(*buf + last2slash, *buf + i + 3, strlen(*buf + i + 3) + 1);
+
+			return simplify_path(buf);
+		}
+	}
+}
+
+/**
+        \fn ADM_PathCanonize
+        \brief Canonize the path, returns a copy of the absolute path given as parameter
+*/
+char *ADM_PathCanonize(const char *tmpname)
+{
+	char path[300];
+	char *out;
+
+	if (!getcwd(path, 300))
+	{
+		fprintf(stderr, &quot;\ngetcwd() failed with: %s (%u)\n&quot;, strerror(errno), errno);
+		path[0] = '\0';
+	}
+
+	if (!tmpname || tmpname[0] == 0)
+	{
+		out = new char[strlen(path) + 2];
+		strcpy(out, path);
+#ifndef __WIN32
+		strcat(out, &quot;/&quot;);
+#else
+		strcat(out, &quot;\\&quot;);
+#endif
+		printf(&quot;\n Canonizing null string ??? (%s)\n&quot;, out);
+	}
+	else if (tmpname[0] == '/'
+#if defined(__WIN32)
+		|| tmpname[1] == ':'
+#endif
+		)
+	{
+		out = new char[strlen(tmpname) + 1];
+		strcpy(out, tmpname);
+
+		return out;
+	}
+	else
+	{
+		out = new char[strlen(path) + strlen(tmpname) + 6];
+		strcpy(out, path);
+#ifndef __WIN32
+		strcat(out, &quot;/&quot;);
+#else
+		strcat(out, &quot;\\&quot;);
+#endif
+		strcat(out, tmpname);
+	}
+
+	simplify_path(&amp;out);
+
+	return out;
+}
+
+/**
+        \fn ADM_PathStripName
+	\brief Returns path only /foo/bar.avi -&gt; /foo INPLACE, no copy done
+
+*/
+void ADM_PathStripName(char *str)
+{
+	int len = strlen(str);
+
+	if (len &lt;= 1)
+		return;
+
+	len--;
+
+#ifndef __WIN32
+	while (*(str + len) != '/' &amp;&amp; len)
+#else
+	while (*(str + len) != '\\' &amp;&amp; len)
+#endif
+	{
+		*(str + len) = 0;
+		len--;
+	}
+}
+
+/**
+    \fn ADM_GetFileName
+    \brief Get the filename without path. /foo/bar.avi -&gt; bar.avi INPLACE, NO COPY
+
+*/
+const char *ADM_GetFileName(const char *str)
+{
+	const char *filename;
+	const char *filename2;
+
+#ifndef __WIN32
+	filename = strrchr(str, '/');
+#else
+	filename = strrchr(str, '\\');
+	filename2 = strrchr(str, '/');
+
+	if (filename2 &amp;&amp; filename)
+		if (filename2 &gt; filename)
+			filename = filename2;
+#endif
+
+	if (filename)
+		return filename + 1;
+	else
+		return str;
+}
+
+/**
+    \fn ADM_PathSplit
+    \brief Split path into absolute path+name and extention i.e. /foo/bar/zee.avi -&gt; /foo/bar/zee,avi.             Copy are returned
+
+*/
+void ADM_PathSplit(const char *str, char **root, char **ext)
+{
+	char *full;
+	uint32_t l;
+
+	full = ADM_PathCanonize(str);
+	// Search the last
+	l = strlen(full);
+	l--;
+	ADM_assert(l &gt; 0);
+
+	while (*(full + l) != '.' &amp;&amp; l)
+		l--;
+
+	if (!l || l == (strlen(full) - 1))
+	{
+		if (l == (strlen(full) - 1))
+			*(full + l) = 0;  // remove trailing
+
+		*ext = new char[2];
+		*root = full;
+		strcpy(*ext, &quot;&quot;);
+
+		return;
+	}
+	// else we do get an extension
+	// starting at l+1
+	uint32_t suff;
+
+	suff = strlen(full) - l - 1;
+	*ext = new char[suff + 1];
+	strcpy(*ext, full + l + 1);
+	*(full + l) = 0;
+	*root = full;
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004136.html">[Avidemux-svn-commit] r6962 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_render avidemux/qt4/ADM_userInterfaces/ADM_gui	avidemux_core/ADM_core/src
</A></li>
	<LI>Next message: <A HREF="004138.html">[Avidemux-svn-commit] r6964 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4137">[ date ]</a>
              <a href="thread.html#4137">[ thread ]</a>
              <a href="subject.html#4137">[ subject ]</a>
              <a href="author.html#4137">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
