From mean at mail.berlios.de  Wed Jul  6 07:19:53 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed,  6 Jul 2011 07:19:53 +0200
Subject: [Avidemux-svn-commit] r7306 - in
	branches/avidemux_2.6_branch_mean/avidemux: . common
Message-ID: <20110706051954.04112483387@sheep.berlios.de>

Author: mean
Date: 2011-07-06 07:19:53 +0200 (Wed, 06 Jul 2011)
New Revision: 7306

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_main.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
Log:
[cosmetic] Rename gtk_gui.cpp to gui_main.cpp

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2011-06-26 17:14:30 UTC (rev 7305)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2011-07-06 05:19:53 UTC (rev 7306)
@@ -1,1187 +0,0 @@
-/***************************************************************************
-                          \file gtk_gui.cpp  
-                          \brief Main UI even loop
-                             
-    copyright            : (C) 2001-2009 by mean, fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "ADM_cpp.h"
-#include "ADM_default.h"
-#include <math.h>
-#include <errno.h>
-
-#include "fourcc.h"
-
-#include "DIA_fileSel.h"
-#include "DIA_coreToolkit.h"
-
-#include "gui_action.hxx"
-#include "gtkgui.h"
-
-#include "prefs.h"
-#include "ADM_render/GUI_render.h"
-#include "ADM_commonUI/GUI_ui.h"
-
-#include "DIA_working.h"
-#include "DIA_factory.h"
-
-#include "ADM_vidMisc.h"
-#include "ADM_preview.h"
-#include "ADM_coreVideoEncoder.h"
-#include "ADM_videoEncoderApi.h"
-#include "ADM_audioFilter/include/ADM_audioFilterInterface.h"
-
-#include "avi_vars.h"
-#include "prototype.h" // FIXME
-#include "ADM_script2/include/ADM_scriptIf.h"
-renderZoom currentZoom=ZOOM_1_1;
-//***********************************
-//******** A Function ***************
-//***********************************
-#include "A_functions.h"
-//***********************************
-//******** GUI Function**************
-//***********************************
-
-extern uint8_t UI_getPhysicalScreenSize(void* window, uint32_t *w,uint32_t *h);
-extern uint8_t GUI_jobs(void);
-extern const char * GUI_getCustomJsScript(uint32_t nb);
-extern const char * GUI_getCustomPyScript(uint32_t nb);
-extern const char * GUI_getAutoPyScript(uint32_t nb);
-
-extern uint8_t GUI_getFrameContent(ADMImage *image, uint32_t frame);
-extern int     GUI_handleVFilter (void);
-extern void    GUI_setMarks (uint32_t a, uint32_t b);
-extern void    GUI_displayBitrate( void );
-// Debug functions
-       void    GUI_showCurrentFrameHex(void);
-       void    GUI_showSize(void);
-
-       void    GUI_avsProxy(void);
-       uint8_t GUI_close(void);
-extern int     GUI_GoToFrame(uint32_t frame);;
-extern bool    GUI_GoToTime(uint64_t time);
-//***********************************
-//******** DIA Function**************
-//***********************************
-extern uint8_t DIA_about( void );
-extern void    DIA_properties( void);
-extern uint8_t DIA_Preferences(void);
-extern uint8_t DIA_gotoTime(uint16_t *hh, uint32_t *mm, uint32_t *ss);
-extern uint8_t DIA_builtin(void);
-extern void    DIA_Calculator(uint32_t *sizeInMeg, uint32_t *avgBitrate );
-extern uint8_t DIA_pluginsInfo(void);
-
-extern void filterCleanUp (void);
-static void ReSync (void);
-static void cleanUp (void);
-void        updateLoaded (void);
-extern void encoderSetLogFile (char *name);
-extern void videoCodecConfigureUI(int codecIndex = -1);
-extern void audioCodecChanged(int newcodec);
-extern void videoCodecChanged(int newcodec);
-extern bool ADM_mux_configure(int index);
-void brokenAct(void);
-//
-//  Sub gui files...
-//
-void HandleAction (Action action);
-void HandleAction_Navigate(Action action);
-void HandleAction_Save(Action action);
-
-
-//
-//
-/**
-    \fn HandleAction
-    \brief  serialization of user event through gui
-
-*/
-typedef  const char * (*getName)(uint32_t nb);
-bool getScriptName(int action, int base,getName name,const char *ext,string &out )
-{
-    if(action<base) return false;
-    action=action-base;
-    const char *p=name(action);
-    if(!p) return false;
-    out=string(p)+string(".")+string(ext);
-    return true;
-}
-void HandleAction (Action action)
-{
-  uint32_t nf = 0;
-  uint32_t old;
-
-  ADM_warning("************ %s **************\n",getActionName(action));
-
-  // handle out of band actions
-  // independant load not loaded
-//------------------------------------------------
-int nw;
-  if(action>=ACT_CUSTOM_BASE_JS && action <ACT_CUSTOM_END_JS)
-  {
-      string script;
-      if(true==getScriptName( action, ACT_CUSTOM_BASE_JS,GUI_getCustomJsScript,"js",script))
-      {
-            A_parseECMAScript(script.c_str());
-      }
-      return ;
-  }
-  if(action>=ACT_CUSTOM_BASE_PY && action <ACT_CUSTOM_END_PY)
-  {
-      string script;
-      if(true==getScriptName( action, ACT_CUSTOM_BASE_PY,GUI_getCustomPyScript,"py",script))
-      {
-            A_parseTinyPyScript(script.c_str());      
-      }
-      return ;
-  }
-  if(action>=ACT_AUTO_BASE_PY && action <ACT_AUTO_END_PY)
-  {
-      string script;
-      if(true==getScriptName( action, ACT_AUTO_BASE_PY,GUI_getAutoPyScript,"py",script))
-      {
-            A_parseTinyPyScript(script.c_str());
-      }
-      return ;
-  }
-  switch (action)
-    {
-        case ACT_TimeShift:
-        case ACT_Goto:
-                                brokenAct();
-                                return;
-        case ACT_PY_SHELL:
-                                interactiveTinyPy();
-                                return;
-        case ACT_JS_SHELL:
-                                interactiveECMAScript("dummy");
-                                return;
-        case ACT_AVS_PROXY:
-                                GUI_avsProxy();
-                                return;
-        case ACT_BUILT_IN:
-                                DIA_builtin();
-                                return;
-        case ACT_RECENT0:
-        case ACT_RECENT1:
-        case ACT_RECENT2:
-        case ACT_RECENT3:
-                const char **name;
-                int rank;
-
-                name=prefs->get_lastfiles();
-                rank=(int)action-ACT_RECENT0;
-                ADM_assert(name[rank]);
-                A_openAvi (name[rank]);
-                return;
-		return;
-	case ACT_VIDEO_CODEC_CONFIGURE:
-    		videoEncoder6Configure();
-            return;
-    case ACT_ContainerConfigure:    
-            {
-            int index=UI_GetCurrentFormat();
-            ADM_mux_configure(index);
-            return;
-            }
-    case ACT_VIDEO_CODEC_CHANGED:
-    		nw=UI_getCurrentVCodec();
-    		videoEncoder6_SetCurrentEncoder(nw);
-            return;
-   case ACT_AUDIO_CODEC_CHANGED:
-            nw=UI_getCurrentACodec();
-            audioCodecSetByIndex(nw);
-            return;
-    case ACT_PLUGIN_INFO:
-            DIA_pluginsInfo();
-            return;
-    case ACT_RUN_PY_PROJECT:
-            GUI_FileSelRead (QT_TR_NOOP("Select python script to Run"),(SELFILE_CB *) A_parseTinyPyScript);
-    		return;
-    case ACT_RUN_JS_PROJECT:
-            GUI_FileSelRead (QT_TR_NOOP("Select ECMAScript to Run"),(SELFILE_CB *) A_parseECMAScript);
-    		return;
-
-    case ACT_ABOUT :
-    		 DIA_about( );
-		 return;
-    case ACT_AUDIO_CODEC_CONFIGURE:
-      audioCodecConfigure();
-      return;
-    case ACT_AUDIO_FILTERS:
-      audioFilterConfigure();
-      return;
-    case ACT_PREFERENCES:
-        if(playing) return;
-    	if(DIA_Preferences())
-        {
-            prefs->save ();
-        }
-        return;
-    case ACT_SavePref:
-        prefs->save ();
-        return;
-    case ACT_EXIT:
-      { bool saveprefsonexit;
-         prefs->get(FEATURES_SAVEPREFSONEXIT,&saveprefsonexit);
-         if( saveprefsonexit )
-            prefs->save ();
-      }
-      cleanUp ();
-      exit (0);
-      break;
-    default:
-      break;
-
-    }
-
-  if (playing)			// only allow some action
-    {
-      switch (action)
-        {
-        case ACT_PlayAvi:
-        case ACT_StopAvi:
-          break;
-        default:
-          return;
-        }
-    }
-  // not playing,
-  // restict disabled uncoded actions
-  if ((int) action >= ACT_DUMMY)
-    {
-      GUI_Error_HIG (QT_TR_NOOP("Not coded in this version"), NULL);
-      return;
-    }
-  // allow only if avi loaded
-  if (!avifileinfo)
-    {
-      switch (action)
-        {
-          case ACT_JOG:
-                break;
-          case ACT_OPEN_VIDEO:
-                GUI_FileSelRead (QT_TR_NOOP("Select AVI File..."), (SELFILE_CB *)A_openAvi);
-                break;
-          default:
-            break;
-        }
-        return;
-    }
-
-  // Dispatch actions, we have a file loaded
-  if(action>ACT_NAVIGATE_BEGIN && action < ACT_NAVIGATE_END)
-  {
-    return HandleAction_Navigate(action);
-  }
-  if(action>ACT_SAVE_BEGIN && action < ACT_SAVE_END)
-  {
-    return HandleAction_Save(action);
-  }
-
-  switch (action)
-    {
-       case ACT_JOG:
-                A_jog();
-                break;
-
-       case ACT_CLOSE:
-              GUI_close();
-              break;
-
-        case ACT_ZOOM_1_4:
-        case ACT_ZOOM_1_2:
-        case ACT_ZOOM_1_1:
-        case ACT_ZOOM_2_1:
-        case ACT_ZOOM_4_1:
-                currentZoom=(renderZoom)((action-ACT_ZOOM_1_4)+ZOOM_1_4);
-                changePreviewZoom(currentZoom);
-                admPreview::samePicture();
-                break;
-        case ACT_AUDIO_SELECT_TRACK:
-                A_audioTrack();
-                break;
-
-    case ACT_OPEN_VIDEO:
-        GUI_FileSelRead (QT_TR_NOOP("Select AVI File..."),(SELFILE_CB *) A_openAvi);
-        break;
-    case ACT_APPEND_VIDEO:
-        GUI_FileSelRead (QT_TR_NOOP("Select AVI File to Append..."),(SELFILE_CB *) A_appendAvi);
-        break;
-    case ACT_VIDEO_PROPERTIES:
-        DIA_properties ();
-        break;
-    case ACT_PlayAvi:
-      GUI_PlayAvi ();
-      break;
-  
-#define TOGGLE_PREVIEW ADM_PREVIEW_OUTPUT
-    case ACT_PreviewChanged:
-    {
-        ADM_PREVIEW_MODE oldpreview=getPreviewMode(),newpreview=(ADM_PREVIEW_MODE)UI_getCurrentPreview();
-          printf("Old preview %d, New preview mode : %d\n",oldpreview,newpreview);
-
-          if(oldpreview==newpreview)
-          {
-            return;
-          }
-            admPreview::stop();
-            setPreviewMode(newpreview);
-            admPreview::start();
-//            admPreview::update(curframe);
-      }
-      break;
-    case ACT_StopAvi:
-      if (playing)
-	GUI_PlayAvi ();
-      break;
-    case ACT_SetPostProcessing:
-      A_setPostproc();
-      break;
-    case ACT_MarkA:
-    case ACT_MarkB:
-    {
-      bool swapit=0;
-      uint64_t markA,markB;
-      uint64_t pts=admPreview::getCurrentPts();
-      if( prefs->get(FEATURES_SWAP_IF_A_GREATER_THAN_B, &swapit) != RC_OK )     swapit = 1;
-
-      markA=video_body->getMarkerAPts();
-      markB=video_body->getMarkerBPts();
-      if (action == ACT_MarkA)
-            markA=pts;
-      else
-            markB=pts;
-      if (markA>markB && swapit )	// auto swap
-        {
-          uint64_t y;
-          y = markA;
-          markA=markB;
-          markB=y;
-        }
-        video_body->setMarkerAPts(markA);
-        video_body->setMarkerBPts(markB);
-        UI_setMarkers (markA, markB);
-      break;
-    }
-    case ACT_Copy:
-            brokenAct();
-//    		   video_body->copyToClipBoard (frameStart,frameEnd);
-		break;
-    case ACT_Paste:
-            brokenAct();        		
-            break;
-      break;
-
-    case ACT_ResetSegments:
-       if(avifileinfo)
-         if(GUI_Question(QT_TR_NOOP("Are you sure?")))
-        {
-            video_body->resetSeg();
-            video_body->getVideoInfo (avifileinfo);
-		
-      		GUI_setAllFrameAndTime ();
-            A_ResetMarkers();
-      		ReSync ();
-
-            // forget last project file
-            video_body->setProjectName("");
-        }
-	break;
-
-    case ACT_Delete:
-    case ACT_Cut:
-        {
-            uint64_t a=video_body->getMarkerAPts();
-            uint64_t b=video_body->getMarkerBPts();
-            if(false==video_body->remove(a,b))
-            {
-                GUI_Error_HIG("Cutting","Error while cutting out.");
-            }
-            else    
-            {
-              A_ResetMarkers();              
-              A_Resync(); // total duration & stuff
-              // Rewind to first frame...
-              //A_Rewind();
-              GUI_GoToTime(a);
-                
-            }
-        }
-        
-      break;
-      // set decoder option (post processing ...)
-    case ACT_DecoderOption:
-      video_body->setDecodeParam ( admPreview::getCurrentPts());
-
-      break;
-    case ACT_VIDEO_FILTERS:
-        GUI_handleVFilter();
-        break;
-
-   case ACT_HEX_DUMP:
-      GUI_showCurrentFrameHex();
-      break;
-   case ACT_SIZE_DUMP:
-      GUI_showSize();
-      break;
-    default:
-      printf ("\n unhandled action %d\n", action);
-      ADM_assert (0);
-      return;
-
-    }
-}
-
-//_____________________________________________________________
-//
-// Open AVI File
-//    mode 0: normal
-//    mode 1: Suspicious
-//_____________________________________________________________
-
-extern void GUI_PreviewEnd (void);
-/**
-        \fn A_openAvi
-        \brief Open (replace mode) a video
-*/
-int A_openAvi (const char *name)
-{
-  uint8_t res;
-  char *longname;
-  uint32_t magic[4];
-  uint32_t id = 0;
-
-  if (playing)
-    return 0;
-  /// check if name exists
-  FILE *fd;
-  fd = ADM_fopen (name, "rb");
-  if (!fd){
-    if( errno == EACCES ){
-      GUI_Error_HIG(QT_TR_NOOP("Permission error"), QT_TR_NOOP("Cannot open \"%s\"."), name);
-    }
-    if( errno == ENOENT ){
-      GUI_Error_HIG(QT_TR_NOOP("File error"), QT_TR_NOOP("\"%s\" does not exist."), name);
-    }
-    return 0;
-  }
-  if( 4 == fread(magic,4,4,fd) )
-     id=R32(magic[0]);
-  fclose (fd);
-
-
-  GUI_close(); // Cleanup
-
-//  DIA_StartBusy ();
-  /*
-  ** we may get a relative path by cmdline
-  */
-  longname = ADM_PathCanonize(name);
-  res = video_body->addFile (longname);
-//  DIA_StopBusy ();
-
-  // forget last project file
-    video_body->setProjectName("");
-
-  if (res!=ADM_OK)			// an error occured
-    {
-		delete[] longname;
-    	if(ADM_IGN==res)
-	{
-		return 0;
-	}
-
-	if( fourCC::check(id,(uint8_t *)"//AD") ){
-          GUI_Error_HIG(QT_TR_NOOP("Cannot open project using the video loader."),
-                        QT_TR_NOOP(  "Try 'File' -> 'Load/Run Project...'"));
-	}else{
-          GUI_Error_HIG (QT_TR_NOOP("Could not open the file"), NULL);
-	}
-	return 0;
-    }
-
-    { int i;
-      FILE *fd=NULL;
-      char magic[4];
-
-	/* check myself it is a project file (transparent detected and read
-        ** by video_body->addFile (name);
-	*/
-#warning FIXME
-#if 0
-	if( (fd = ADM_fopen(longname,"rb"))  ){
-		if( fread(magic,4,1,fd) == 4 ){
-			/* remember a workbench file */
-			if( !strncmp(magic,"ADMW",4) ){
-				actual_workbench_file = ADM_strdup(longname);
-			}
-		}
-		fclose(fd);
-	}
-#endif
-	/* remember any video or workbench file to "recent" */
-        prefs->set_lastfile(longname);
-        UI_updateRecentMenu();
-        updateLoaded ();
-        if(currentaudiostream)
-        {
-            uint32_t nbAudio;
-            audioInfo *infos=NULL;
-            if(video_body->getAudioStreamsInfo(admPreview::getCurrentPts()+1,&nbAudio,&infos))
-            {
-                if(nbAudio>1)
-                {   // Multiple track warn user
-                  GUI_Info_HIG(ADM_LOG_INFO,QT_TR_NOOP("Multiple Audio Tracks"),QT_TR_NOOP("The file you just loaded contains several audio tracks.\n"
-                      "Go to Audio->MainTrack to select the active one."));
-                }
-            }
-            if(infos) delete [] infos;
-            // Revert mixer to copy
-            //setCurrentMixerFromString("NONE");
-            audioFilterSetMixer(CHANNEL_INVALID);
-        }
-	for(i=strlen(longname);i>=0;i--)
-    {
-#ifdef __WIN32
-		if( longname[i] == '\\' || longname[i] == '/' )
-#else
-		if( longname[i] == '/' )
-#endif
-        {
-
-			i++;
-			break;
-		}
-    }
-	UI_setTitle(longname+i);
-    }
-
-	delete[] longname;
-	return 1;
-}
-/**
-    \fn updateLoaded
-    \brief update the UI after loading a file
-
-*/
-void  updateLoaded ()
-{
-  avifileinfo = new aviInfo;
-  if (!video_body->getVideoInfo (avifileinfo))
-    {
-//      err1:
-      printf ("\n get info failed...cancelling load...\n");
-      delete avifileinfo;
-      avifileinfo = NULL;
-
-      return;
-    }
-
-
-//  getFirstVideoFilter(); // reinit first filter
-
-  // now get audio information if exists
-  WAVHeader *wavinfo;
-  wavinfo = video_body->getInfo ();	//wavinfo); // will be null if no audio
-  if (!wavinfo)
-    {
-      printf ("\n *** NO AUDIO ***\n");
-      wavinfo = (WAVHeader *) NULL;
-    }
-
-  // Init renderer
-    admPreview::setMainDimension(avifileinfo->width, avifileinfo->height);
-
-
-  // Draw first frame
-  GUI_setAllFrameAndTime();
-  A_ResetMarkers();
-//  getFirstVideoFilter(); // Rebuild filter if needed
-
-  /* Zoom out if needed */
-  uint32_t phyW,phyH;
-  UI_getPhysicalScreenSize(NULL, &phyW,&phyH);
-  if(3*phyW<4*avifileinfo->width || 3*phyH<4*avifileinfo->height)
-  {
-      if(phyW<avifileinfo->width/2 || phyH<avifileinfo->height/2)
-      {
-                currentZoom=ZOOM_1_4;
-      }else
-      {
-                currentZoom=ZOOM_1_2;
-      }
-     changePreviewZoom(currentZoom);
-  }
-  else
-  {
-      currentZoom=ZOOM_1_1;
-      changePreviewZoom(currentZoom);
-  }
-
-
-   A_Rewind();
-   ADM_info(" conf updated \n");
-   UI_setDecoderName(video_body->getVideoDecoderName());
-
-}
-
-//___________________________________________
-//  Append an AVI to the existing one
-//___________________________________________
-int
-A_appendAvi (const char *name)
-{
-
-
-  if (playing)
-    return 0;
-//  DIA_StartBusy ();
-  if (!video_body->addFile (name))
-    {
-//      DIA_StopBusy ();
-      GUI_Error_HIG (QT_TR_NOOP("Something failed when appending"), NULL);
-      return 0;
-    }
-//  DIA_StopBusy ();
-
-
-//  video_body->dumpSeg ();
-  if (!video_body->updateVideoInfo (avifileinfo))
-    {
-      GUI_Error_HIG (QT_TR_NOOP("Something bad happened (II)"), NULL);
-      return 0;
-    }
-
-  ReSync ();
-  A_ResetMarkers();
-  
-  return 1;
-}
-
-//
-//      Whenever a changed happened in the the stream, resync
-//  related infos including audio & video filters
-
-void ReSync (void)
-{
-  uint8_t isaviaud;
-
-  // update audio stream
-  // If we were on avi , mark it...
-  GUI_setAllFrameAndTime ();
-
-}
-
-
-
-
-//      Clean up
-//      free all pending stuff, make leakchecker happy
-//
-void cleanUp (void)
-{
-	if (avifileinfo)
-	{
-		delete avifileinfo;
-		avifileinfo=NULL;
-	}
-	if (video_body)
-	{
-		delete video_body;
-		video_body=NULL;
-	}
-
-	currentaudiostream=NULL;
-//	filterCleanUp();
-	admPreview::cleanUp();
-}
-
-#warning fixme
-
-
-
-/**
-    \fn A_parseTinyPyScript
-*/
-bool A_parseTinyPyScript(const char *name){
-  bool ret;
-  ADM_info("Executing tinyPy script :%s\n",name);
-  char *longname = ADM_PathCanonize(name);
-   if (playing)
-   {
-        return false;
-   }
-   ret = parseTinyPyScript(longname);
-   A_Resync(); // total duration & stuff
-   if( ret == true )
-   {
-      video_body->setProjectName(longname);
-   }
-   ADM_dealloc(longname);
-   return ret;
-}
-/**
-    \fn A_parseECMAScript
-*/
-bool A_parseECMAScript(const char *name){
-  bool ret;
-  char *longname = ADM_PathCanonize(name);
-   if (playing)
-    {
-      return false;
-   }
-   ret = parseECMAScript(longname);
-   A_Resync(); // total duration & stuff
-   if( ret == true )
-   {
-      video_body->setProjectName(longname);
-   }
-   ADM_dealloc(longname);
-   return ret;
-}
-
-/*
-	Unpack all frames without displaying them to check for error
-
-*/
-void A_videoCheck( void)
-{
-#if 0
-uint32_t nb=0;
-//uint32_t buf[720*576*2];
-uint32_t error=0;
-ADMImage *aImage;
-DIA_workingBase *work;
-
-	nb = avifileinfo->nb_frames;
-	work=createWorking(QT_TR_NOOP("Checking video"));
-	aImage=new ADMImage(avifileinfo->width,avifileinfo->height);
-  for(uint32_t i=0;i<nb;i++)
-  {
-	work->update(i, nb);
-      	if(!work->isAlive()) break;
-	if(!GUI_getFrameContent (aImage,i))
-	{
-		error ++;
-		printf("Frame %u has error\n",i);
-	}
-
-    };
-  delete work;
-  delete aImage;
-  if(error==0)
-    GUI_Info_HIG(ADM_LOG_IMPORTANT,QT_TR_NOOP("No error found"), NULL);
-else
-	{
-		char str[400];
-                sprintf(str,QT_TR_NOOP("Errors found in %u frames"),error);
-		GUI_Info_HIG(ADM_LOG_IMPORTANT,str, NULL);
-
-	}
-	GUI_GoToFrame(0);
-#endif
-}
-int A_delete(uint32_t start, uint32_t end)
-{
-uint32_t count;
-
-      aviInfo info;
-      ADM_assert (video_body->getVideoInfo (&info));
-      count = end - start;
-
-      if( end < start ){
-        GUI_Error_HIG(QT_TR_NOOP("Marker A > B"), QT_TR_NOOP("Cannot delete the selection."));
-         return 0;
-      }
-      if (count >= info.nb_frames - 1)
-	{
-          GUI_Error_HIG (QT_TR_NOOP("You can't remove all frames"), NULL);
-	  return 0;
-	}
-
-//      video_body->dumpSeg ();
-//      if (!video_body->removeFrames (start, end))
-    if(0)
-	{
-          GUI_Error_HIG (QT_TR_NOOP("Something bad happened"), NULL);
-	  return 0;
-	}
-//      video_body->dumpSeg ();
-      //resync GUI and video
-      if (!video_body->updateVideoInfo (avifileinfo))
-	{
-          GUI_Error_HIG (QT_TR_NOOP("Something bad happened (II)"), NULL);
-	}
-
-
-      A_ResetMarkers();
-      GUI_setAllFrameAndTime ();
-      ReSync ();
-     return 1;
-
-
-
-}
-extern int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,bool *swap);
-//
-
-//
-void	A_setPostproc( void )
-{
-uint32_t type,strength;
-bool swap;
-	if(!avifileinfo) return;
-
-	video_body->getPostProc(&type,&strength,&swap);
-
- 	if(DIA_getMPParams( &type, &strength,&swap))
- 	{
-		video_body->setPostProc(type,strength,swap);
- 	}
-
-}
-extern const char *getStrFromAudioCodec( uint32_t codec);
-/**
-
-*/
-int A_setAudioTrack(int track)
-{
-        video_body->changeAudioStream(0,track);
-        return true;
-}
-/**
-      \fn A_audioTrack
-      \brief Allow to select audio track
-*/
-void A_audioTrack( void )
-{        
-        audioInfo *infos=NULL;
-        uint32_t nbAudioTracks,currentAudioTrack;
-        uint32_t newTrack;
-
-        if(!video_body->getAudioStreamsInfo(0,&nbAudioTracks,&infos)) return;
-        currentAudioTrack=video_body->getCurrentAudioStreamNumber(0);
-        newTrack=currentAudioTrack;
-        // Now build the list of embedded track
-#define MAX_AUDIO_TRACK 10
-#define MAX_AUDIO_TRACK_NAME 100
-        diaMenuEntryDynamic *sourceavitracks[MAX_AUDIO_TRACK];
-        char string[MAX_AUDIO_TRACK_NAME];
-        for(int i=0;i<nbAudioTracks;i++)
-        {
-          sprintf(string,"Audio track %d (%s, %d channels, %d kbit/s)",i,
-                        getStrFromAudioCodec(infos[i].encoding),
-                        infos[i].channels,infos[i].bitrate);
-           sourceavitracks[i]=new diaMenuEntryDynamic(i,string,NULL);
-        }
-         if(infos) delete [] infos;
-
-         diaElemMenuDynamic   sourceFromVideo(&newTrack,QT_TR_NOOP("_Track from video:"),nbAudioTracks,sourceavitracks);
-         diaElem *allWidgets[]={&sourceFromVideo};
-
-         if( diaFactoryRun(QT_TR_NOOP("Main Audio Track"),1,allWidgets))
-         {
-            if(newTrack!=currentAudioTrack)
-            {
-                    A_setAudioTrack(newTrack);
-            }
-        }
-      
-roger_and_out:
-         /* Clean up */
-         for(int i=0;i<nbAudioTracks;i++)
-            delete sourceavitracks[i];
-        return;
-
-}
-/**
-        \fn A_externalAudioTrack
-        \brief Select external audio track (for 2nd track)
-*/
-void A_externalAudioTrack( void )
-{
-}
-/**
-    \fn A_Resync
-    \brief 
-*/
-void A_Resync(void)
-{
-        if(!avifileinfo) return;
-        GUI_setAllFrameAndTime();
-        UI_setMarkers (video_body->getMarkerAPts(),video_body->getMarkerBPts());
-}
-uint8_t  DIA_job_select(char **jobname, char **filename);
-void A_addJob(void)
-{
-        char *name=NULL,*fullname,*base,*final=NULL;
-
-        if(!DIA_job_select(&name,&final)) return;
-        if(!name || !final) return;
-        if(!*name || !*final) return;
-
-        base=ADM_getJobDir();
-        fullname=new char[strlen(name)+strlen(base)+2+4];
-
-        strcpy(fullname,base);
-        strcat(fullname,"/");
-        strcat(fullname,name);
-        strcat(fullname,".js");
-
-        if(!video_body->saveAsScript(fullname,final))
-        {
-          GUI_Error_HIG(QT_TR_NOOP("Saving failed"),QT_TR_NOOP("Saving the job failed. Maybe you have permission issue with ~/.avidemux"));
-        }
-
-        delete [] fullname;
-        delete [] base;
-        ADM_dealloc(name);
-        ADM_dealloc(final);
-}
-/**
-    \fn GUI_GetScale
-    \brief Return the % of the scale, between 0 and ADM_SCALE_SIZE
-
-*/
-uint32_t GUI_GetScale(void)
-{
-
-    double  percent;
-    float tg;
-
-    percent = UI_readScale();
-    tg= ADM_SCALE_SIZE * percent / 100.;
-
-    return (uint32_t)floor(tg);;
-}
-/**
-    \fn GUI_SetScale
-    \brief Set the scale, input is between 0 and ADM_SCALE_SIZE (max)
-*/
-void     GUI_SetScale( uint32_t scale )
-{
-    double percent;
-    percent=scale;
-    percent/=ADM_SCALE_SIZE;
-    percent*=100;
-    UI_setScale(percent);
-}
-
-
-/**
-      \fn GUI_getFrameContent
-      \brief fill image with content of frame frame
-*/
-uint8_t GUI_getFrameContent(ADMImage *image, uint32_t frame)
-{
-//  uint32_t flags;
-//  if(!video_body->getUncompressedFrame(frame,image,&flags)) return 0;
-  return 1;
-}
-/**
-    \fn GUI_close
-    \brief Close opened file and cleanup filters etc..
-*/
-uint8_t GUI_close(void)
-{
-  if (avifileinfo)		// already opened ?
-    {				// delete everything
-      // if preview is on
-      admPreview::setMainDimension(0, 0);
-      if(getPreviewMode()!=ADM_PREVIEW_NONE)
-      {
-        admPreview::stop();
-        setPreviewMode(ADM_PREVIEW_NONE);
-      }
-      delete avifileinfo;
-      //delete wavinfo;
-      
-      avifileinfo = NULL;
-      video_body->cleanup ();	  
-
-//      filterCleanUp ();
-	  UI_setTitle(NULL);
-
-      return 1;
-    }
-    return 0;
-}
-/**
-      \fn GUI_avsProxy
-      \brief Shortcut to connect to avsProxy
-*/
-
-void GUI_avsProxy(void)
-{
-  uint8_t res;
-
-
-  GUI_close();
-  res = video_body->addFile (AVS_PROXY_DUMMY_FILE);
-  // forget last project file
-  video_body->setProjectName(NULL);
-  if (res!=ADM_OK)			// an error occured
-    {
-        currentaudiostream = NULL;
-        avifileinfo = NULL;
-        GUI_Error_HIG (QT_TR_NOOP("AvsProxy"), QT_TR_NOOP("Failed to connect to avsproxy.\nIs it running ?"));
-        return ;
-    }
-
-       updateLoaded ();
-       UI_setTitle(QT_TR_NOOP("avsproxy"));
-       return ;
-}
-/**
-      \fn GUI_showCurrentFrameHex
-      \brief Display the first 32 bytes of the current frame in hex
-*/
-
-void GUI_showCurrentFrameHex(void)
-{
- uint8_t *buffer;
- uint32_t fullLen,flags;
- char sType[5];
- char sSize[15];
- ADMCompressedImage image;
- uint8_t seq;
-#if 0
- if (!avifileinfo) return;
-
- buffer=new uint8_t [avifileinfo->width*avifileinfo->height*3];
- image.data=buffer;
-
-
- video_body->getFrame (video_body->getCurrentFrame(),&image,&seq);
- fullLen=image.dataLength;
- video_body->getFlags (video_body->getCurrentFrame(), &flags);
-
- diaElemHex binhex("*****",fullLen,buffer);
-
- if(flags&AVI_KEY_FRAME) sprintf(sType,"I");
-  else if(flags&AVI_B_FRAME) sprintf(sType,"B");
-    else sprintf(sType,"P");
- sprintf(sSize,"%d bytes",fullLen);
-
- diaElemReadOnlyText Type(sType,QT_TR_NOOP("Frame type:"));
- diaElemReadOnlyText Size(sSize,QT_TR_NOOP("Frame size:"));
- diaElem *elems[]={&Type,&Size,&binhex   };
- if(diaFactoryRun(QT_TR_NOOP("Frame Hex Dump"),3,elems))
-
- delete [] buffer;
-#endif
-}
-/**
-    \fn GUI_showSize
-    \brief Show frame size
-
-*/
-#define DUMP_SIZE 30
-void GUI_showSize(void)
-{
-uint8_t *buffer;
- uint32_t fullLen,flags;
- ADMCompressedImage image;
- uint8_t seq;
- char                text[DUMP_SIZE][100];
- 
- if (!avifileinfo) return;
-#if 0
- buffer=new uint8_t [avifileinfo->width*avifileinfo->height*3];
- image.data=buffer;
-    for(int i=0;i<DUMP_SIZE;i++)
-    {
-        int target=video_body->getCurrentFrame()+i;
-        video_body->getFlags ( target,&flags);
-        video_body->getFrame ( target,&image,&seq);
-        fullLen=image.dataLength;
-        sprintf(text[i],"Frame %d:%d",target,fullLen);
-        printf("%s\n",text[i]);
-    }
- 
-
-
- 
- delete [] buffer;
- #endif
-}
-
-/**
- *      \fn UI_getPreferredRender
- *      \brief Returns to render lib the user preferred rendering method
- *
- */
-ADM_RENDER_TYPE UI_getPreferredRender(void)
-{
-  char *displ;
-  unsigned int renderI;
-  ADM_RENDER_TYPE render;
-
-#if !defined __WIN32 && !defined(__APPLE__)
-        // First check if local
-        // We do it in a very wrong way : If DISPLAY!=:0.0 we assume remote display
-        // in that case we do not even try to use accel
-
-        // Win32 and Mac/Qt4 don't have DISPLAY
-        displ=getenv("DISPLAY");
-        if(!displ)
-        {
-                return RENDER_GTK;
-        }
-        if(strcmp(displ,":0") && strcmp(displ,":0.0"))
-        {
-                printf("Looks like remote display, no Xv :%s\n",displ);
-                return RENDER_GTK;
-        }
-#endif
-
-        if(prefs->get(VIDEODEVICE,&renderI)!=RC_OK)
-        {
-                render=RENDER_GTK;
-        }else
-        {
-                render=(ADM_RENDER_TYPE)renderI;
-        }
-
-        return render;
-}
-
-/**
-    \fn A_ResetMarkers
-*/
-void A_ResetMarkers(void)
-{
-uint64_t duration=video_body->getVideoDuration();
-        ADM_info("Video Total duration : %s ms\n",ADM_us2plain(duration));
-        video_body->setMarkerAPts(0);
-        video_body->setMarkerBPts(duration);
-        UI_setMarkers(0,duration);
-        
-}
-/**
-    \fn A_Rewind
-    \brief Go back to the first frame
-*/
-void A_Rewind(void)
-{
-               video_body->rewind();
-               admPreview::samePicture();
-               GUI_setCurrentFrameAndTime();
-}
-void brokenAct(void)
-{
-    GUI_Error_HIG("Oops","This function is disabled or no longer valid");
-}
-
-//
-// EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/gui_main.cpp (from rev 7305, branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_main.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_main.cpp	2011-07-06 05:19:53 UTC (rev 7306)
@@ -0,0 +1,1187 @@
+/***************************************************************************
+                          \file gtk_gui.cpp  
+                          \brief Main UI even loop
+                             
+    copyright            : (C) 2001-2009 by mean, fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_cpp.h"
+#include "ADM_default.h"
+#include <math.h>
+#include <errno.h>
+
+#include "fourcc.h"
+
+#include "DIA_fileSel.h"
+#include "DIA_coreToolkit.h"
+
+#include "gui_action.hxx"
+#include "gtkgui.h"
+
+#include "prefs.h"
+#include "ADM_render/GUI_render.h"
+#include "ADM_commonUI/GUI_ui.h"
+
+#include "DIA_working.h"
+#include "DIA_factory.h"
+
+#include "ADM_vidMisc.h"
+#include "ADM_preview.h"
+#include "ADM_coreVideoEncoder.h"
+#include "ADM_videoEncoderApi.h"
+#include "ADM_audioFilter/include/ADM_audioFilterInterface.h"
+
+#include "avi_vars.h"
+#include "prototype.h" // FIXME
+#include "ADM_script2/include/ADM_scriptIf.h"
+renderZoom currentZoom=ZOOM_1_1;
+//***********************************
+//******** A Function ***************
+//***********************************
+#include "A_functions.h"
+//***********************************
+//******** GUI Function**************
+//***********************************
+
+extern uint8_t UI_getPhysicalScreenSize(void* window, uint32_t *w,uint32_t *h);
+extern uint8_t GUI_jobs(void);
+extern const char * GUI_getCustomJsScript(uint32_t nb);
+extern const char * GUI_getCustomPyScript(uint32_t nb);
+extern const char * GUI_getAutoPyScript(uint32_t nb);
+
+extern uint8_t GUI_getFrameContent(ADMImage *image, uint32_t frame);
+extern int     GUI_handleVFilter (void);
+extern void    GUI_setMarks (uint32_t a, uint32_t b);
+extern void    GUI_displayBitrate( void );
+// Debug functions
+       void    GUI_showCurrentFrameHex(void);
+       void    GUI_showSize(void);
+
+       void    GUI_avsProxy(void);
+       uint8_t GUI_close(void);
+extern int     GUI_GoToFrame(uint32_t frame);;
+extern bool    GUI_GoToTime(uint64_t time);
+//***********************************
+//******** DIA Function**************
+//***********************************
+extern uint8_t DIA_about( void );
+extern void    DIA_properties( void);
+extern uint8_t DIA_Preferences(void);
+extern uint8_t DIA_gotoTime(uint16_t *hh, uint32_t *mm, uint32_t *ss);
+extern uint8_t DIA_builtin(void);
+extern void    DIA_Calculator(uint32_t *sizeInMeg, uint32_t *avgBitrate );
+extern uint8_t DIA_pluginsInfo(void);
+
+extern void filterCleanUp (void);
+static void ReSync (void);
+static void cleanUp (void);
+void        updateLoaded (void);
+extern void encoderSetLogFile (char *name);
+extern void videoCodecConfigureUI(int codecIndex = -1);
+extern void audioCodecChanged(int newcodec);
+extern void videoCodecChanged(int newcodec);
+extern bool ADM_mux_configure(int index);
+void brokenAct(void);
+//
+//  Sub gui files...
+//
+void HandleAction (Action action);
+void HandleAction_Navigate(Action action);
+void HandleAction_Save(Action action);
+
+
+//
+//
+/**
+    \fn HandleAction
+    \brief  serialization of user event through gui
+
+*/
+typedef  const char * (*getName)(uint32_t nb);
+bool getScriptName(int action, int base,getName name,const char *ext,string &out )
+{
+    if(action<base) return false;
+    action=action-base;
+    const char *p=name(action);
+    if(!p) return false;
+    out=string(p)+string(".")+string(ext);
+    return true;
+}
+void HandleAction (Action action)
+{
+  uint32_t nf = 0;
+  uint32_t old;
+
+  ADM_warning("************ %s **************\n",getActionName(action));
+
+  // handle out of band actions
+  // independant load not loaded
+//------------------------------------------------
+int nw;
+  if(action>=ACT_CUSTOM_BASE_JS && action <ACT_CUSTOM_END_JS)
+  {
+      string script;
+      if(true==getScriptName( action, ACT_CUSTOM_BASE_JS,GUI_getCustomJsScript,"js",script))
+      {
+            A_parseECMAScript(script.c_str());
+      }
+      return ;
+  }
+  if(action>=ACT_CUSTOM_BASE_PY && action <ACT_CUSTOM_END_PY)
+  {
+      string script;
+      if(true==getScriptName( action, ACT_CUSTOM_BASE_PY,GUI_getCustomPyScript,"py",script))
+      {
+            A_parseTinyPyScript(script.c_str());      
+      }
+      return ;
+  }
+  if(action>=ACT_AUTO_BASE_PY && action <ACT_AUTO_END_PY)
+  {
+      string script;
+      if(true==getScriptName( action, ACT_AUTO_BASE_PY,GUI_getAutoPyScript,"py",script))
+      {
+            A_parseTinyPyScript(script.c_str());
+      }
+      return ;
+  }
+  switch (action)
+    {
+        case ACT_TimeShift:
+        case ACT_Goto:
+                                brokenAct();
+                                return;
+        case ACT_PY_SHELL:
+                                interactiveTinyPy();
+                                return;
+        case ACT_JS_SHELL:
+                                interactiveECMAScript("dummy");
+                                return;
+        case ACT_AVS_PROXY:
+                                GUI_avsProxy();
+                                return;
+        case ACT_BUILT_IN:
+                                DIA_builtin();
+                                return;
+        case ACT_RECENT0:
+        case ACT_RECENT1:
+        case ACT_RECENT2:
+        case ACT_RECENT3:
+                const char **name;
+                int rank;
+
+                name=prefs->get_lastfiles();
+                rank=(int)action-ACT_RECENT0;
+                ADM_assert(name[rank]);
+                A_openAvi (name[rank]);
+                return;
+		return;
+	case ACT_VIDEO_CODEC_CONFIGURE:
+    		videoEncoder6Configure();
+            return;
+    case ACT_ContainerConfigure:    
+            {
+            int index=UI_GetCurrentFormat();
+            ADM_mux_configure(index);
+            return;
+            }
+    case ACT_VIDEO_CODEC_CHANGED:
+    		nw=UI_getCurrentVCodec();
+    		videoEncoder6_SetCurrentEncoder(nw);
+            return;
+   case ACT_AUDIO_CODEC_CHANGED:
+            nw=UI_getCurrentACodec();
+            audioCodecSetByIndex(nw);
+            return;
+    case ACT_PLUGIN_INFO:
+            DIA_pluginsInfo();
+            return;
+    case ACT_RUN_PY_PROJECT:
+            GUI_FileSelRead (QT_TR_NOOP("Select python script to Run"),(SELFILE_CB *) A_parseTinyPyScript);
+    		return;
+    case ACT_RUN_JS_PROJECT:
+            GUI_FileSelRead (QT_TR_NOOP("Select ECMAScript to Run"),(SELFILE_CB *) A_parseECMAScript);
+    		return;
+
+    case ACT_ABOUT :
+    		 DIA_about( );
+		 return;
+    case ACT_AUDIO_CODEC_CONFIGURE:
+      audioCodecConfigure();
+      return;
+    case ACT_AUDIO_FILTERS:
+      audioFilterConfigure();
+      return;
+    case ACT_PREFERENCES:
+        if(playing) return;
+    	if(DIA_Preferences())
+        {
+            prefs->save ();
+        }
+        return;
+    case ACT_SavePref:
+        prefs->save ();
+        return;
+    case ACT_EXIT:
+      { bool saveprefsonexit;
+         prefs->get(FEATURES_SAVEPREFSONEXIT,&saveprefsonexit);
+         if( saveprefsonexit )
+            prefs->save ();
+      }
+      cleanUp ();
+      exit (0);
+      break;
+    default:
+      break;
+
+    }
+
+  if (playing)			// only allow some action
+    {
+      switch (action)
+        {
+        case ACT_PlayAvi:
+        case ACT_StopAvi:
+          break;
+        default:
+          return;
+        }
+    }
+  // not playing,
+  // restict disabled uncoded actions
+  if ((int) action >= ACT_DUMMY)
+    {
+      GUI_Error_HIG (QT_TR_NOOP("Not coded in this version"), NULL);
+      return;
+    }
+  // allow only if avi loaded
+  if (!avifileinfo)
+    {
+      switch (action)
+        {
+          case ACT_JOG:
+                break;
+          case ACT_OPEN_VIDEO:
+                GUI_FileSelRead (QT_TR_NOOP("Select AVI File..."), (SELFILE_CB *)A_openAvi);
+                break;
+          default:
+            break;
+        }
+        return;
+    }
+
+  // Dispatch actions, we have a file loaded
+  if(action>ACT_NAVIGATE_BEGIN && action < ACT_NAVIGATE_END)
+  {
+    return HandleAction_Navigate(action);
+  }
+  if(action>ACT_SAVE_BEGIN && action < ACT_SAVE_END)
+  {
+    return HandleAction_Save(action);
+  }
+
+  switch (action)
+    {
+       case ACT_JOG:
+                A_jog();
+                break;
+
+       case ACT_CLOSE:
+              GUI_close();
+              break;
+
+        case ACT_ZOOM_1_4:
+        case ACT_ZOOM_1_2:
+        case ACT_ZOOM_1_1:
+        case ACT_ZOOM_2_1:
+        case ACT_ZOOM_4_1:
+                currentZoom=(renderZoom)((action-ACT_ZOOM_1_4)+ZOOM_1_4);
+                changePreviewZoom(currentZoom);
+                admPreview::samePicture();
+                break;
+        case ACT_AUDIO_SELECT_TRACK:
+                A_audioTrack();
+                break;
+
+    case ACT_OPEN_VIDEO:
+        GUI_FileSelRead (QT_TR_NOOP("Select AVI File..."),(SELFILE_CB *) A_openAvi);
+        break;
+    case ACT_APPEND_VIDEO:
+        GUI_FileSelRead (QT_TR_NOOP("Select AVI File to Append..."),(SELFILE_CB *) A_appendAvi);
+        break;
+    case ACT_VIDEO_PROPERTIES:
+        DIA_properties ();
+        break;
+    case ACT_PlayAvi:
+      GUI_PlayAvi ();
+      break;
+  
+#define TOGGLE_PREVIEW ADM_PREVIEW_OUTPUT
+    case ACT_PreviewChanged:
+    {
+        ADM_PREVIEW_MODE oldpreview=getPreviewMode(),newpreview=(ADM_PREVIEW_MODE)UI_getCurrentPreview();
+          printf("Old preview %d, New preview mode : %d\n",oldpreview,newpreview);
+
+          if(oldpreview==newpreview)
+          {
+            return;
+          }
+            admPreview::stop();
+            setPreviewMode(newpreview);
+            admPreview::start();
+//            admPreview::update(curframe);
+      }
+      break;
+    case ACT_StopAvi:
+      if (playing)
+	GUI_PlayAvi ();
+      break;
+    case ACT_SetPostProcessing:
+      A_setPostproc();
+      break;
+    case ACT_MarkA:
+    case ACT_MarkB:
+    {
+      bool swapit=0;
+      uint64_t markA,markB;
+      uint64_t pts=admPreview::getCurrentPts();
+      if( prefs->get(FEATURES_SWAP_IF_A_GREATER_THAN_B, &swapit) != RC_OK )     swapit = 1;
+
+      markA=video_body->getMarkerAPts();
+      markB=video_body->getMarkerBPts();
+      if (action == ACT_MarkA)
+            markA=pts;
+      else
+            markB=pts;
+      if (markA>markB && swapit )	// auto swap
+        {
+          uint64_t y;
+          y = markA;
+          markA=markB;
+          markB=y;
+        }
+        video_body->setMarkerAPts(markA);
+        video_body->setMarkerBPts(markB);
+        UI_setMarkers (markA, markB);
+      break;
+    }
+    case ACT_Copy:
+            brokenAct();
+//    		   video_body->copyToClipBoard (frameStart,frameEnd);
+		break;
+    case ACT_Paste:
+            brokenAct();        		
+            break;
+      break;
+
+    case ACT_ResetSegments:
+       if(avifileinfo)
+         if(GUI_Question(QT_TR_NOOP("Are you sure?")))
+        {
+            video_body->resetSeg();
+            video_body->getVideoInfo (avifileinfo);
+		
+      		GUI_setAllFrameAndTime ();
+            A_ResetMarkers();
+      		ReSync ();
+
+            // forget last project file
+            video_body->setProjectName("");
+        }
+	break;
+
+    case ACT_Delete:
+    case ACT_Cut:
+        {
+            uint64_t a=video_body->getMarkerAPts();
+            uint64_t b=video_body->getMarkerBPts();
+            if(false==video_body->remove(a,b))
+            {
+                GUI_Error_HIG("Cutting","Error while cutting out.");
+            }
+            else    
+            {
+              A_ResetMarkers();              
+              A_Resync(); // total duration & stuff
+              // Rewind to first frame...
+              //A_Rewind();
+              GUI_GoToTime(a);
+                
+            }
+        }
+        
+      break;
+      // set decoder option (post processing ...)
+    case ACT_DecoderOption:
+      video_body->setDecodeParam ( admPreview::getCurrentPts());
+
+      break;
+    case ACT_VIDEO_FILTERS:
+        GUI_handleVFilter();
+        break;
+
+   case ACT_HEX_DUMP:
+      GUI_showCurrentFrameHex();
+      break;
+   case ACT_SIZE_DUMP:
+      GUI_showSize();
+      break;
+    default:
+      printf ("\n unhandled action %d\n", action);
+      ADM_assert (0);
+      return;
+
+    }
+}
+
+//_____________________________________________________________
+//
+// Open AVI File
+//    mode 0: normal
+//    mode 1: Suspicious
+//_____________________________________________________________
+
+extern void GUI_PreviewEnd (void);
+/**
+        \fn A_openAvi
+        \brief Open (replace mode) a video
+*/
+int A_openAvi (const char *name)
+{
+  uint8_t res;
+  char *longname;
+  uint32_t magic[4];
+  uint32_t id = 0;
+
+  if (playing)
+    return 0;
+  /// check if name exists
+  FILE *fd;
+  fd = ADM_fopen (name, "rb");
+  if (!fd){
+    if( errno == EACCES ){
+      GUI_Error_HIG(QT_TR_NOOP("Permission error"), QT_TR_NOOP("Cannot open \"%s\"."), name);
+    }
+    if( errno == ENOENT ){
+      GUI_Error_HIG(QT_TR_NOOP("File error"), QT_TR_NOOP("\"%s\" does not exist."), name);
+    }
+    return 0;
+  }
+  if( 4 == fread(magic,4,4,fd) )
+     id=R32(magic[0]);
+  fclose (fd);
+
+
+  GUI_close(); // Cleanup
+
+//  DIA_StartBusy ();
+  /*
+  ** we may get a relative path by cmdline
+  */
+  longname = ADM_PathCanonize(name);
+  res = video_body->addFile (longname);
+//  DIA_StopBusy ();
+
+  // forget last project file
+    video_body->setProjectName("");
+
+  if (res!=ADM_OK)			// an error occured
+    {
+		delete[] longname;
+    	if(ADM_IGN==res)
+	{
+		return 0;
+	}
+
+	if( fourCC::check(id,(uint8_t *)"//AD") ){
+          GUI_Error_HIG(QT_TR_NOOP("Cannot open project using the video loader."),
+                        QT_TR_NOOP(  "Try 'File' -> 'Load/Run Project...'"));
+	}else{
+          GUI_Error_HIG (QT_TR_NOOP("Could not open the file"), NULL);
+	}
+	return 0;
+    }
+
+    { int i;
+      FILE *fd=NULL;
+      char magic[4];
+
+	/* check myself it is a project file (transparent detected and read
+        ** by video_body->addFile (name);
+	*/
+#warning FIXME
+#if 0
+	if( (fd = ADM_fopen(longname,"rb"))  ){
+		if( fread(magic,4,1,fd) == 4 ){
+			/* remember a workbench file */
+			if( !strncmp(magic,"ADMW",4) ){
+				actual_workbench_file = ADM_strdup(longname);
+			}
+		}
+		fclose(fd);
+	}
+#endif
+	/* remember any video or workbench file to "recent" */
+        prefs->set_lastfile(longname);
+        UI_updateRecentMenu();
+        updateLoaded ();
+        if(currentaudiostream)
+        {
+            uint32_t nbAudio;
+            audioInfo *infos=NULL;
+            if(video_body->getAudioStreamsInfo(admPreview::getCurrentPts()+1,&nbAudio,&infos))
+            {
+                if(nbAudio>1)
+                {   // Multiple track warn user
+                  GUI_Info_HIG(ADM_LOG_INFO,QT_TR_NOOP("Multiple Audio Tracks"),QT_TR_NOOP("The file you just loaded contains several audio tracks.\n"
+                      "Go to Audio->MainTrack to select the active one."));
+                }
+            }
+            if(infos) delete [] infos;
+            // Revert mixer to copy
+            //setCurrentMixerFromString("NONE");
+            audioFilterSetMixer(CHANNEL_INVALID);
+        }
+	for(i=strlen(longname);i>=0;i--)
+    {
+#ifdef __WIN32
+		if( longname[i] == '\\' || longname[i] == '/' )
+#else
+		if( longname[i] == '/' )
+#endif
+        {
+
+			i++;
+			break;
+		}
+    }
+	UI_setTitle(longname+i);
+    }
+
+	delete[] longname;
+	return 1;
+}
+/**
+    \fn updateLoaded
+    \brief update the UI after loading a file
+
+*/
+void  updateLoaded ()
+{
+  avifileinfo = new aviInfo;
+  if (!video_body->getVideoInfo (avifileinfo))
+    {
+//      err1:
+      printf ("\n get info failed...cancelling load...\n");
+      delete avifileinfo;
+      avifileinfo = NULL;
+
+      return;
+    }
+
+
+//  getFirstVideoFilter(); // reinit first filter
+
+  // now get audio information if exists
+  WAVHeader *wavinfo;
+  wavinfo = video_body->getInfo ();	//wavinfo); // will be null if no audio
+  if (!wavinfo)
+    {
+      printf ("\n *** NO AUDIO ***\n");
+      wavinfo = (WAVHeader *) NULL;
+    }
+
+  // Init renderer
+    admPreview::setMainDimension(avifileinfo->width, avifileinfo->height);
+
+
+  // Draw first frame
+  GUI_setAllFrameAndTime();
+  A_ResetMarkers();
+//  getFirstVideoFilter(); // Rebuild filter if needed
+
+  /* Zoom out if needed */
+  uint32_t phyW,phyH;
+  UI_getPhysicalScreenSize(NULL, &phyW,&phyH);
+  if(3*phyW<4*avifileinfo->width || 3*phyH<4*avifileinfo->height)
+  {
+      if(phyW<avifileinfo->width/2 || phyH<avifileinfo->height/2)
+      {
+                currentZoom=ZOOM_1_4;
+      }else
+      {
+                currentZoom=ZOOM_1_2;
+      }
+     changePreviewZoom(currentZoom);
+  }
+  else
+  {
+      currentZoom=ZOOM_1_1;
+      changePreviewZoom(currentZoom);
+  }
+
+
+   A_Rewind();
+   ADM_info(" conf updated \n");
+   UI_setDecoderName(video_body->getVideoDecoderName());
+
+}
+
+//___________________________________________
+//  Append an AVI to the existing one
+//___________________________________________
+int
+A_appendAvi (const char *name)
+{
+
+
+  if (playing)
+    return 0;
+//  DIA_StartBusy ();
+  if (!video_body->addFile (name))
+    {
+//      DIA_StopBusy ();
+      GUI_Error_HIG (QT_TR_NOOP("Something failed when appending"), NULL);
+      return 0;
+    }
+//  DIA_StopBusy ();
+
+
+//  video_body->dumpSeg ();
+  if (!video_body->updateVideoInfo (avifileinfo))
+    {
+      GUI_Error_HIG (QT_TR_NOOP("Something bad happened (II)"), NULL);
+      return 0;
+    }
+
+  ReSync ();
+  A_ResetMarkers();
+  
+  return 1;
+}
+
+//
+//      Whenever a changed happened in the the stream, resync
+//  related infos including audio & video filters
+
+void ReSync (void)
+{
+  uint8_t isaviaud;
+
+  // update audio stream
+  // If we were on avi , mark it...
+  GUI_setAllFrameAndTime ();
+
+}
+
+
+
+
+//      Clean up
+//      free all pending stuff, make leakchecker happy
+//
+void cleanUp (void)
+{
+	if (avifileinfo)
+	{
+		delete avifileinfo;
+		avifileinfo=NULL;
+	}
+	if (video_body)
+	{
+		delete video_body;
+		video_body=NULL;
+	}
+
+	currentaudiostream=NULL;
+//	filterCleanUp();
+	admPreview::cleanUp();
+}
+
+#warning fixme
+
+
+
+/**
+    \fn A_parseTinyPyScript
+*/
+bool A_parseTinyPyScript(const char *name){
+  bool ret;
+  ADM_info("Executing tinyPy script :%s\n",name);
+  char *longname = ADM_PathCanonize(name);
+   if (playing)
+   {
+        return false;
+   }
+   ret = parseTinyPyScript(longname);
+   A_Resync(); // total duration & stuff
+   if( ret == true )
+   {
+      video_body->setProjectName(longname);
+   }
+   ADM_dealloc(longname);
+   return ret;
+}
+/**
+    \fn A_parseECMAScript
+*/
+bool A_parseECMAScript(const char *name){
+  bool ret;
+  char *longname = ADM_PathCanonize(name);
+   if (playing)
+    {
+      return false;
+   }
+   ret = parseECMAScript(longname);
+   A_Resync(); // total duration & stuff
+   if( ret == true )
+   {
+      video_body->setProjectName(longname);
+   }
+   ADM_dealloc(longname);
+   return ret;
+}
+
+/*
+	Unpack all frames without displaying them to check for error
+
+*/
+void A_videoCheck( void)
+{
+#if 0
+uint32_t nb=0;
+//uint32_t buf[720*576*2];
+uint32_t error=0;
+ADMImage *aImage;
+DIA_workingBase *work;
+
+	nb = avifileinfo->nb_frames;
+	work=createWorking(QT_TR_NOOP("Checking video"));
+	aImage=new ADMImage(avifileinfo->width,avifileinfo->height);
+  for(uint32_t i=0;i<nb;i++)
+  {
+	work->update(i, nb);
+      	if(!work->isAlive()) break;
+	if(!GUI_getFrameContent (aImage,i))
+	{
+		error ++;
+		printf("Frame %u has error\n",i);
+	}
+
+    };
+  delete work;
+  delete aImage;
+  if(error==0)
+    GUI_Info_HIG(ADM_LOG_IMPORTANT,QT_TR_NOOP("No error found"), NULL);
+else
+	{
+		char str[400];
+                sprintf(str,QT_TR_NOOP("Errors found in %u frames"),error);
+		GUI_Info_HIG(ADM_LOG_IMPORTANT,str, NULL);
+
+	}
+	GUI_GoToFrame(0);
+#endif
+}
+int A_delete(uint32_t start, uint32_t end)
+{
+uint32_t count;
+
+      aviInfo info;
+      ADM_assert (video_body->getVideoInfo (&info));
+      count = end - start;
+
+      if( end < start ){
+        GUI_Error_HIG(QT_TR_NOOP("Marker A > B"), QT_TR_NOOP("Cannot delete the selection."));
+         return 0;
+      }
+      if (count >= info.nb_frames - 1)
+	{
+          GUI_Error_HIG (QT_TR_NOOP("You can't remove all frames"), NULL);
+	  return 0;
+	}
+
+//      video_body->dumpSeg ();
+//      if (!video_body->removeFrames (start, end))
+    if(0)
+	{
+          GUI_Error_HIG (QT_TR_NOOP("Something bad happened"), NULL);
+	  return 0;
+	}
+//      video_body->dumpSeg ();
+      //resync GUI and video
+      if (!video_body->updateVideoInfo (avifileinfo))
+	{
+          GUI_Error_HIG (QT_TR_NOOP("Something bad happened (II)"), NULL);
+	}
+
+
+      A_ResetMarkers();
+      GUI_setAllFrameAndTime ();
+      ReSync ();
+     return 1;
+
+
+
+}
+extern int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,bool *swap);
+//
+
+//
+void	A_setPostproc( void )
+{
+uint32_t type,strength;
+bool swap;
+	if(!avifileinfo) return;
+
+	video_body->getPostProc(&type,&strength,&swap);
+
+ 	if(DIA_getMPParams( &type, &strength,&swap))
+ 	{
+		video_body->setPostProc(type,strength,swap);
+ 	}
+
+}
+extern const char *getStrFromAudioCodec( uint32_t codec);
+/**
+
+*/
+int A_setAudioTrack(int track)
+{
+        video_body->changeAudioStream(0,track);
+        return true;
+}
+/**
+      \fn A_audioTrack
+      \brief Allow to select audio track
+*/
+void A_audioTrack( void )
+{        
+        audioInfo *infos=NULL;
+        uint32_t nbAudioTracks,currentAudioTrack;
+        uint32_t newTrack;
+
+        if(!video_body->getAudioStreamsInfo(0,&nbAudioTracks,&infos)) return;
+        currentAudioTrack=video_body->getCurrentAudioStreamNumber(0);
+        newTrack=currentAudioTrack;
+        // Now build the list of embedded track
+#define MAX_AUDIO_TRACK 10
+#define MAX_AUDIO_TRACK_NAME 100
+        diaMenuEntryDynamic *sourceavitracks[MAX_AUDIO_TRACK];
+        char string[MAX_AUDIO_TRACK_NAME];
+        for(int i=0;i<nbAudioTracks;i++)
+        {
+          sprintf(string,"Audio track %d (%s, %d channels, %d kbit/s)",i,
+                        getStrFromAudioCodec(infos[i].encoding),
+                        infos[i].channels,infos[i].bitrate);
+           sourceavitracks[i]=new diaMenuEntryDynamic(i,string,NULL);
+        }
+         if(infos) delete [] infos;
+
+         diaElemMenuDynamic   sourceFromVideo(&newTrack,QT_TR_NOOP("_Track from video:"),nbAudioTracks,sourceavitracks);
+         diaElem *allWidgets[]={&sourceFromVideo};
+
+         if( diaFactoryRun(QT_TR_NOOP("Main Audio Track"),1,allWidgets))
+         {
+            if(newTrack!=currentAudioTrack)
+            {
+                    A_setAudioTrack(newTrack);
+            }
+        }
+      
+roger_and_out:
+         /* Clean up */
+         for(int i=0;i<nbAudioTracks;i++)
+            delete sourceavitracks[i];
+        return;
+
+}
+/**
+        \fn A_externalAudioTrack
+        \brief Select external audio track (for 2nd track)
+*/
+void A_externalAudioTrack( void )
+{
+}
+/**
+    \fn A_Resync
+    \brief 
+*/
+void A_Resync(void)
+{
+        if(!avifileinfo) return;
+        GUI_setAllFrameAndTime();
+        UI_setMarkers (video_body->getMarkerAPts(),video_body->getMarkerBPts());
+}
+uint8_t  DIA_job_select(char **jobname, char **filename);
+void A_addJob(void)
+{
+        char *name=NULL,*fullname,*base,*final=NULL;
+
+        if(!DIA_job_select(&name,&final)) return;
+        if(!name || !final) return;
+        if(!*name || !*final) return;
+
+        base=ADM_getJobDir();
+        fullname=new char[strlen(name)+strlen(base)+2+4];
+
+        strcpy(fullname,base);
+        strcat(fullname,"/");
+        strcat(fullname,name);
+        strcat(fullname,".js");
+
+        if(!video_body->saveAsScript(fullname,final))
+        {
+          GUI_Error_HIG(QT_TR_NOOP("Saving failed"),QT_TR_NOOP("Saving the job failed. Maybe you have permission issue with ~/.avidemux"));
+        }
+
+        delete [] fullname;
+        delete [] base;
+        ADM_dealloc(name);
+        ADM_dealloc(final);
+}
+/**
+    \fn GUI_GetScale
+    \brief Return the % of the scale, between 0 and ADM_SCALE_SIZE
+
+*/
+uint32_t GUI_GetScale(void)
+{
+
+    double  percent;
+    float tg;
+
+    percent = UI_readScale();
+    tg= ADM_SCALE_SIZE * percent / 100.;
+
+    return (uint32_t)floor(tg);;
+}
+/**
+    \fn GUI_SetScale
+    \brief Set the scale, input is between 0 and ADM_SCALE_SIZE (max)
+*/
+void     GUI_SetScale( uint32_t scale )
+{
+    double percent;
+    percent=scale;
+    percent/=ADM_SCALE_SIZE;
+    percent*=100;
+    UI_setScale(percent);
+}
+
+
+/**
+      \fn GUI_getFrameContent
+      \brief fill image with content of frame frame
+*/
+uint8_t GUI_getFrameContent(ADMImage *image, uint32_t frame)
+{
+//  uint32_t flags;
+//  if(!video_body->getUncompressedFrame(frame,image,&flags)) return 0;
+  return 1;
+}
+/**
+    \fn GUI_close
+    \brief Close opened file and cleanup filters etc..
+*/
+uint8_t GUI_close(void)
+{
+  if (avifileinfo)		// already opened ?
+    {				// delete everything
+      // if preview is on
+      admPreview::setMainDimension(0, 0);
+      if(getPreviewMode()!=ADM_PREVIEW_NONE)
+      {
+        admPreview::stop();
+        setPreviewMode(ADM_PREVIEW_NONE);
+      }
+      delete avifileinfo;
+      //delete wavinfo;
+      
+      avifileinfo = NULL;
+      video_body->cleanup ();	  
+
+//      filterCleanUp ();
+	  UI_setTitle(NULL);
+
+      return 1;
+    }
+    return 0;
+}
+/**
+      \fn GUI_avsProxy
+      \brief Shortcut to connect to avsProxy
+*/
+
+void GUI_avsProxy(void)
+{
+  uint8_t res;
+
+
+  GUI_close();
+  res = video_body->addFile (AVS_PROXY_DUMMY_FILE);
+  // forget last project file
+  video_body->setProjectName(NULL);
+  if (res!=ADM_OK)			// an error occured
+    {
+        currentaudiostream = NULL;
+        avifileinfo = NULL;
+        GUI_Error_HIG (QT_TR_NOOP("AvsProxy"), QT_TR_NOOP("Failed to connect to avsproxy.\nIs it running ?"));
+        return ;
+    }
+
+       updateLoaded ();
+       UI_setTitle(QT_TR_NOOP("avsproxy"));
+       return ;
+}
+/**
+      \fn GUI_showCurrentFrameHex
+      \brief Display the first 32 bytes of the current frame in hex
+*/
+
+void GUI_showCurrentFrameHex(void)
+{
+ uint8_t *buffer;
+ uint32_t fullLen,flags;
+ char sType[5];
+ char sSize[15];
+ ADMCompressedImage image;
+ uint8_t seq;
+#if 0
+ if (!avifileinfo) return;
+
+ buffer=new uint8_t [avifileinfo->width*avifileinfo->height*3];
+ image.data=buffer;
+
+
+ video_body->getFrame (video_body->getCurrentFrame(),&image,&seq);
+ fullLen=image.dataLength;
+ video_body->getFlags (video_body->getCurrentFrame(), &flags);
+
+ diaElemHex binhex("*****",fullLen,buffer);
+
+ if(flags&AVI_KEY_FRAME) sprintf(sType,"I");
+  else if(flags&AVI_B_FRAME) sprintf(sType,"B");
+    else sprintf(sType,"P");
+ sprintf(sSize,"%d bytes",fullLen);
+
+ diaElemReadOnlyText Type(sType,QT_TR_NOOP("Frame type:"));
+ diaElemReadOnlyText Size(sSize,QT_TR_NOOP("Frame size:"));
+ diaElem *elems[]={&Type,&Size,&binhex   };
+ if(diaFactoryRun(QT_TR_NOOP("Frame Hex Dump"),3,elems))
+
+ delete [] buffer;
+#endif
+}
+/**
+    \fn GUI_showSize
+    \brief Show frame size
+
+*/
+#define DUMP_SIZE 30
+void GUI_showSize(void)
+{
+uint8_t *buffer;
+ uint32_t fullLen,flags;
+ ADMCompressedImage image;
+ uint8_t seq;
+ char                text[DUMP_SIZE][100];
+ 
+ if (!avifileinfo) return;
+#if 0
+ buffer=new uint8_t [avifileinfo->width*avifileinfo->height*3];
+ image.data=buffer;
+    for(int i=0;i<DUMP_SIZE;i++)
+    {
+        int target=video_body->getCurrentFrame()+i;
+        video_body->getFlags ( target,&flags);
+        video_body->getFrame ( target,&image,&seq);
+        fullLen=image.dataLength;
+        sprintf(text[i],"Frame %d:%d",target,fullLen);
+        printf("%s\n",text[i]);
+    }
+ 
+
+
+ 
+ delete [] buffer;
+ #endif
+}
+
+/**
+ *      \fn UI_getPreferredRender
+ *      \brief Returns to render lib the user preferred rendering method
+ *
+ */
+ADM_RENDER_TYPE UI_getPreferredRender(void)
+{
+  char *displ;
+  unsigned int renderI;
+  ADM_RENDER_TYPE render;
+
+#if !defined __WIN32 && !defined(__APPLE__)
+        // First check if local
+        // We do it in a very wrong way : If DISPLAY!=:0.0 we assume remote display
+        // in that case we do not even try to use accel
+
+        // Win32 and Mac/Qt4 don't have DISPLAY
+        displ=getenv("DISPLAY");
+        if(!displ)
+        {
+                return RENDER_GTK;
+        }
+        if(strcmp(displ,":0") && strcmp(displ,":0.0"))
+        {
+                printf("Looks like remote display, no Xv :%s\n",displ);
+                return RENDER_GTK;
+        }
+#endif
+
+        if(prefs->get(VIDEODEVICE,&renderI)!=RC_OK)
+        {
+                render=RENDER_GTK;
+        }else
+        {
+                render=(ADM_RENDER_TYPE)renderI;
+        }
+
+        return render;
+}
+
+/**
+    \fn A_ResetMarkers
+*/
+void A_ResetMarkers(void)
+{
+uint64_t duration=video_body->getVideoDuration();
+        ADM_info("Video Total duration : %s ms\n",ADM_us2plain(duration));
+        video_body->setMarkerAPts(0);
+        video_body->setMarkerBPts(duration);
+        UI_setMarkers(0,duration);
+        
+}
+/**
+    \fn A_Rewind
+    \brief Go back to the first frame
+*/
+void A_Rewind(void)
+{
+               video_body->rewind();
+               admPreview::samePicture();
+               GUI_setCurrentFrameAndTime();
+}
+void brokenAct(void)
+{
+    GUI_Error_HIG("Oops","This function is disabled or no longer valid");
+}
+
+//
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2011-06-26 17:14:30 UTC (rev 7305)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2011-07-06 05:19:53 UTC (rev 7306)
@@ -44,7 +44,7 @@
 SET(ADM_EXE_SRCS 
 ../common/ADM_preview.cpp  
 ../common/ADM_previewNavigate.cpp  
-../common/gtk_gui.cpp  
+../common/gui_main.cpp  
 ../common/gui_autodrive.cpp  
 ../common/GUI_jobs.cpp  
 ../common/gui_navigate.cpp  



From mean at mail.berlios.de  Wed Jul  6 07:19:54 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed,  6 Jul 2011 07:19:54 +0200
Subject: [Avidemux-svn-commit] r7307 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_amrnb
Message-ID: <20110706051954.EF340483387@sheep.berlios.de>

Author: mean
Date: 2011-07-06 07:19:54 +0200 (Wed, 06 Jul 2011)
New Revision: 7307

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_amrnb/ADM_ad_amrnb.cpp
Log:
[amr/decoder] Blind fix to make the ctor match with base class (issue reported by Jan), untested

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_amrnb/ADM_ad_amrnb.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_amrnb/ADM_ad_amrnb.cpp	2011-07-06 05:19:53 UTC (rev 7306)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_amrnb/ADM_ad_amrnb.cpp	2011-07-06 05:19:54 UTC (rev 7307)
@@ -66,7 +66,7 @@
    */
    
 ADM_AudiocodecAmrNb::ADM_AudiocodecAmrNb( uint32_t fourcc, WAVHeader *info,uint32_t extraLength,uint8_t *extraData)
-		:   ADM_Audiocodec(fourcc)
+		:   ADM_Audiocodec(fourcc,*info)
 {
       state=Decoder_Interface_init();
       _wavHeader = info;



From mean at mail.berlios.de  Wed Jul  6 07:19:56 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed,  6 Jul 2011 07:19:56 +0200
Subject: [Avidemux-svn-commit] r7308 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS
Message-ID: <20110706051956.1C37A483387@sheep.berlios.de>

Author: mean
Date: 2011-07-06 07:19:55 +0200 (Wed, 06 Jul 2011)
New Revision: 7308

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
Log:
[tsPacket] Cosmetic, change printf to ADM_warning

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2011-07-06 05:19:54 UTC (rev 7307)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/dmxTSPacket.cpp	2011-07-06 05:19:55 UTC (rev 7308)
@@ -314,7 +314,7 @@
 #if 1
     if(sectionLength+3>pkt.payloadSize) 
     {
-        printf("[MpegTs] sectionLength=%d, len=%d\n",sectionLength,pkt.payloadSize);
+        ADM_warning("[MpegTs] Multi Packet PSI ? sectionLength=%d, len=%d\n",sectionLength,pkt.payloadSize);
         goto nextPack2;
     }
 #endif



From gruntster at mail.berlios.de  Sat Jul  9 23:35:27 2011
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat,  9 Jul 2011 23:35:27 +0200
Subject: [Avidemux-svn-commit] r7309 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <20110709213527.581ED480BE2@sheep.berlios.de>

Author: gruntster
Date: 2011-07-09 23:35:26 +0200 (Sat, 09 Jul 2011)
New Revision: 7309

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.h
Log:
[qt] don't block source application after drag and drop

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2011-07-06 05:19:55 UTC (rev 7308)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2011-07-09 21:35:26 UTC (rev 7309)
@@ -14,7 +14,6 @@
 #include "config.h"
 #undef QT_TR_NOOP
 
-#include <QtCore/QUrl>
 #include <QtCore/QDir>
 #include <QtGui/QKeyEvent>
 #include <QtGui/QGraphicsView>
@@ -106,11 +105,18 @@
 void UI_updateFrameCount(uint32_t curFrame);
 void UI_updateTimeCount(uint32_t curFrame,uint32_t fps);
 extern void UI_purge(void);
-/*
-    Declare the class that will be our main window
 
-*/
+class FileDropEvent : public QEvent
+{
+public:
+	QList<QUrl> files;
 
+	FileDropEvent(QList<QUrl> files) : QEvent(QEvent::User)
+	{
+		this->files = files;
+	}
+};
+
 void MainWindow::comboChanged(int z)
 {
 	if (sender() == ui.comboBoxVideo)
@@ -480,6 +486,9 @@
 			}
 
 			break;
+		case QEvent::User:
+			this->openFiles(((FileDropEvent*)event)->files);
+			break;
 	}
 
 	return QObject::eventFilter(watched, event);
@@ -498,30 +507,31 @@
 
 void MainWindow::dropEvent(QDropEvent *event)
 {
-	QList<QUrl> urlList;
-	QString fileName;
+	if (event->mimeData()->hasUrls())
+	{
+		QCoreApplication::postEvent(this, new FileDropEvent(event->mimeData()->urls()));
+
+		event->acceptProposedAction();
+	}
+}
+
+void MainWindow::openFiles(QList<QUrl> urlList)
+{
 	QFileInfo info;
 
-	if (event->mimeData()->hasUrls())
+	for (int fileIndex = 0; fileIndex < urlList.size(); fileIndex++)
 	{
-		urlList = event->mimeData()->urls();
+		QString fileName = urlList[fileIndex].toLocalFile();
+		QFileInfo info(fileName);
 
-		for (int fileIndex = 0; fileIndex < urlList.size(); fileIndex++)
+		if (info.isFile())
 		{
-			fileName = urlList[fileIndex].toLocalFile();
-			info.setFile(fileName);
-
-			if (info.isFile())
-			{
-				if (avifileinfo)
-					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_appendAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
-				else
-					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_openAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
-			}
+			if (avifileinfo)
+				FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_appendAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
+			else
+				FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_openAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
 		}
 	}
-
-	event->acceptProposedAction();
 }
 
 void MainWindow::previousIntraFrame(void)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.h	2011-07-06 05:19:55 UTC (rev 7308)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.h	2011-07-09 21:35:26 UTC (rev 7309)
@@ -2,6 +2,7 @@
 #define Q_gui2_h
 
 #include <QtCore/QFileInfo>
+#include <QtCore/QUrl>
 #include <QtGui/QSlider>
 #include <QtGui/QWidget>
 #include <QtGui/QMenu>
@@ -53,5 +54,6 @@
 	void dropEvent(QDropEvent *event);
 	void closeEvent(QCloseEvent *event);
 	void addDirEntryToMenu(QMenu *parentMenu, QString path);
+	void openFiles(QList<QUrl>);
 };
 #endif	// Q_gui2_h



From mean at mail.berlios.de  Sun Jul 10 16:31:22 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 10 Jul 2011 16:31:22 +0200
Subject: [Avidemux-svn-commit] r7310 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	. telecide
Message-ID: <20110710143122.F3A6A4813BB@sheep.berlios.de>

Author: mean
Date: 2011-07-10 16:31:22 +0200 (Sun, 10 Jul 2011)
New Revision: 7310

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
Log:
[Telecide] port from 2.5

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/CMakeLists.txt	2011-07-10 14:31:22 UTC (rev 7310)
@@ -0,0 +1,12 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_telecide_SRCS Telecide.cpp   
+                         Telecide_utils.cpp
+                         Telecide_getFrame.cpp
+                        )
+
+ADD_VIDEO_FILTER(ADM_vf_telecide ${ADM_vf_telecide_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_telecide)
+INSTALL_VIDEO_FILTER(ADM_vf_telecide)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	2011-07-10 14:31:22 UTC (rev 7310)
@@ -0,0 +1,184 @@
+
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : fixounet at free.fr
+
+    Port of Donal Graft Telecide which is (c) Donald Graft
+    http://www.neuron2.net
+    http://puschpull.org/avisynth/decomb_reference_manual.html
+
+ ***************************************************************************/
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include "ADM_default.h"
+#include "Telecide.h"
+#include "DIA_factory.h"
+#include "telec_desc.cpp"
+#if 1
+    #define aprintf printf
+#else
+    #define aprintf(...) {}
+#endif
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   Telecide,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_INTERLACING,            // Category
+                        "telecide",            // internal name (must be uniq!)
+                        "Decomb telecide",            // Display name
+                        "Donald Graft Telecide. Replace ivtc pattern by progressive frames. Video stays at 30 fps." // Description
+                    );
+
+/**
+    \fn configure
+*/
+
+/**
+    \fn Ctor
+*/       
+Telecide::Telecide(	ADM_coreVideoFilter *in,CONFcouple *couples)      : ADM_coreVideoFilter(in,couples)
+{
+
+		int i;		
+		int count;
+		char *d, *dsaved;
+		unsigned int *p, *x;
+		_lastFrame=0xfffffff0;
+        teleCide *_param=&configuration;
+		
+		vidCache=new VideoCache(12,in);
+#if 0
+		pitch = _info.width;
+		dpitch = _info.width;
+		pitchover2 = pitch >> 1;
+		pitchtimes4 = pitch << 2;
+
+		w = _info.width;
+		h = _info.height;
+		wover2 = w/2;
+		hover2 = h/2;
+		hplus1over2 = (h+1)/2;
+		hminus2= h - 2;
+#endif
+		if(!couples || !ADM_paramLoad(couples,teleCide_param,&configuration))
+        {
+                 
+			 	_param->order = 1; 		// 0 Field ok, 1 field reverted 0 BFF/1 TFF
+				_param->back = NO_BACK; // 0 Never, 1 when bad, 2 always tried MUST Have post !=0
+				_param->chroma = false;
+				_param->guide = GUIDE_32;// 0 / NONE - 1 GUIDE_32/ivtc-2 GUIDE 22/PAL-3 PAL/NTSC
+				_param->gthresh = 10.0;
+				_param->post = POST_NONE;
+				_param->vthresh = 50.0;
+				_param->bthresh = 50.0;
+				_param->dthresh = 7.0;
+				_param->blend = false;
+				_param->nt = 10;	// Noise tolerance
+				_param->y0 = 0;		// Zone to try (avoid subs)
+				_param->y1 = 0;
+				_param->hints = true;
+				_param->show = false;
+				_param->debug = false; 
+
+		}
+				 
+				
+		tff = (_param->order == 0 ? false : true);	
+
+		_param->back_saved = _param->back;
+
+		// Set up pattern guidance.
+		cache = (struct CACHE_ENTRY *) ADM_alloc(CACHE_SIZE * sizeof(struct CACHE_ENTRY));
+		for (i = 0; i < CACHE_SIZE; i++)
+		{
+			cache[i].frame = 0xffffffff;
+			cache[i].chosen = 0xff;
+		}
+
+		if (_param->guide == GUIDE_32)
+		{
+			// 24fps to 30 fps telecine.
+			cycle = 5;
+		}
+		if (_param->guide == GUIDE_22)
+		{
+			// PAL guidance (expect the current match to be continued).
+			cycle = 2;
+		}
+		else if (_param->guide == GUIDE_32322)
+		{
+			// 25fps to 30 fps telecine.
+			cycle = 6;
+		}
+
+		// Get needed dynamic storage.
+		vmetric = 0;
+		_param->vthresh_saved = _param->vthresh;
+		xblocks = (info.width+BLKSIZE-1) / BLKSIZE;
+		yblocks = (info.height+BLKSIZE-1) / BLKSIZE;
+#ifdef WINDOWED_MATCH
+		matchp = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+		matchc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+#endif
+		sump = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+		sumc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+}
+/**
+    \fn dtor
+*/
+Telecide::~Telecide()
+{
+		unsigned int *p;
+
+		if (cache != NULL) ADM_dealloc(cache);
+#ifdef WINDOWED_MATCH
+		if (matchp != NULL) ADM_dealloc(matchp);
+		if (matchc != NULL) ADM_dealloc(matchc);
+        matchp=NULL;
+        matchc=NULL;
+
+#endif
+		if (sump != NULL) ADM_dealloc(sump);
+		if (sumc != NULL) ADM_dealloc(sumc);
+        cache=NULL;
+        sump=NULL;
+        sumc=NULL;
+		delete vidCache;
+		vidCache=NULL;
+}
+/**
+    \fn getCoupledConf
+*/ 
+bool         Telecide::getCoupledConf(CONFcouple **couples)
+{
+    return ADM_paramSave(couples, teleCide_param,&configuration);
+}
+bool                Telecide::goToTime(uint64_t usSeek)
+{
+    return ADM_coreVideoFilter::goToTime(usSeek);
+}
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	2011-07-10 14:31:22 UTC (rev 7310)
@@ -0,0 +1,162 @@
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from  telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "ADM_videoFilterCache.h"
+#include "DIA_factory.h"
+#include "telec.h"
+
+#define DrawString drawString
+#define BitBlt BitBlit
+
+#undef DEBUG_PATTERN_GUIDANCE
+
+#undef WINDOWED_MATCH
+
+#define MAX_CYCLE 6
+#define BLKSIZE 24
+#define BLKSIZE_TIMES2 (2 * BLKSIZE)
+#define GUIDE_NONE 0
+#define GUIDE_32 1
+#define GUIDE_22 2
+#define GUIDE_32322 3
+#define AHEAD 0
+#define BEHIND 1
+#define POST_NONE 0
+#define POST_METRICS 1
+#define POST_FULL 2
+#define POST_FULL_MAP 3
+#define POST_FULL_NOMATCH 4
+#define POST_FULL_NOMATCH_MAP 5
+#define CACHE_SIZE 100000
+#define P 0
+#define C 1
+#define N 2
+#define PBLOCK 3
+#define CBLOCK 4
+
+#define NO_BACK 0
+#define BACK_ON_COMBED 1
+#define ALWAYS_BACK 2
+
+#define OutputDebugString(x) aprintf("%s\n",x)
+typedef uint8_t* PVideoFrame ;
+
+
+struct CACHE_ENTRY
+{
+	unsigned int frame;
+	unsigned int metrics[5];
+	unsigned int chosen;
+};
+
+struct PREDICTION
+{
+	unsigned int metric;
+	unsigned int phase;
+	unsigned int predicted;
+	unsigned int predicted_metric;
+};
+
+#define GETFRAME(g, fp) { int GETFRAMEf; uint32_t len,flags;GETFRAMEf = (g); fp=NULL;\
+    if (GETFRAMEf < 0) GETFRAMEf = 0; 	 fp=vidCache->getImage(GETFRAMEf); }
+
+
+
+/**
+    \class Telecide
+
+*/
+class  Telecide:public ADM_coreVideoFilter
+{
+protected:
+        teleCide           configuration;
+protected:
+        bool tff;	
+        uint32_t _lastFrame;	
+#if 1
+        int pitch, dpitch, pitchover2, pitchtimes4;
+        int w, h, wover2, hover2, hplus1over2, hminus2;
+#endif
+        int xblocks, yblocks;
+    #ifdef WINDOWED_MATCH
+        unsigned int *matchc, *matchp, highest_matchc, highest_matchp;
+    #endif
+        unsigned int *sumc, *sump, highest_sumc, highest_sump;
+        int vmetric;
+        
+        bool film, override, inpattern, found;
+        int force;
+
+        
+        int chosen;
+        unsigned int p, c, pblock, cblock, lowest, predicted, predicted_metric;
+        unsigned int np, nc, npblock, ncblock;
+        float mismatch;
+        int  x, y;
+        
+        bool hard;
+        char status[80];
+
+        // Metrics cache.
+        struct CACHE_ENTRY *cache;
+
+        // Pattern guidance data.
+        int cycle;
+        struct PREDICTION pred[MAX_CYCLE+1];
+
+        // For output message formatting.
+        char buf[255];
+        
+        VideoCache	*vidCache;
+public:
+                            Telecide(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                            ~Telecide();
+        bool                goToTime(uint64_t usSeek);
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+
+protected:
+	
+	void CalculateMetrics(int n, unsigned char *crp, unsigned char *crpU, unsigned char *crpV, 
+				unsigned char *prp, unsigned char *prpU, unsigned char *prpV);
+	void Show(ADMImage *dst, int frame);
+	void Debug(int frame);
+
+
+	void PutChosen(int frame, unsigned int chosen);
+	
+
+	void CacheInsert(int frame, unsigned int p, unsigned int pblock,
+				unsigned int c, unsigned int cblock);
+	
+	bool CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
+				unsigned int *c, unsigned int *cblock);	
+
+	bool PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric) ;
+	
+	struct PREDICTION *PredictSoftYUY2(int frame);
+
+	void WriteHints(unsigned char *dst, bool film, bool inpattern);
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-10 14:31:22 UTC (rev 7310)
@@ -0,0 +1,764 @@
+
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : fixounet at free.fr
+
+    Port of Donal Graft Telecide which is (c) Donald Graft
+    http://www.neuron2.net
+    http://puschpull.org/avisynth/decomb_reference_manual.html
+
+ ***************************************************************************/
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include "ADM_default.h"
+#include "Telecide.h"
+#if 1
+    #define aprintf printf
+#else
+    #define aprintf(...) {}
+#endif
+
+/**
+    \fn getNextFrame
+*/
+bool Telecide::getNextFrame(uint32_t *frameNumber,ADMImage *output_image)
+{
+ADMImage *fc;
+uint8_t *fcrp;
+uint8_t *fcrpU,*fcrpV;
+
+uint32_t pframe,nframe;
+
+ADMImage *fp;
+uint8_t *fprp;
+uint8_t *fprpU,*fprpV;
+
+ADMImage *fn;
+uint8_t *fnrp;
+uint8_t *fnrpU,*fnrpV;
+
+ADMImage *lc;
+uint8_t *crp;
+uint8_t *crpU,*crpV;
+
+ADMImage *lp;
+uint8_t *prp;
+uint8_t *prpU,*prpV;
+
+ADMImage *dst;
+uint8_t *dstp;
+uint8_t *dstpU,*dstpV;
+
+ADMImage *final;
+uint8_t *finalp;
+uint8_t *finalpU,*finalpV;
+
+teleCide *_param=&configuration;
+#define guide _param->guide
+#define order _param->order
+#define back  _param->back
+
+#define back_saved  _param->back_saved
+#define guide       _param->guide
+#define gthresh     _param->gthresh
+#define post        _param->post
+#define chroma      _param->chroma
+#define vthresh     _param->vthresh
+
+#define vthresh_saved _param->vthresh_saved
+#define hints      _param->hints
+#define show       _param->show
+#define debug      _param->debug
+
+#define bthresh      _param->bthresh
+#define dthresh      _param->dthresh
+#define blend        _param->blend
+
+#define nt      _param->nt
+#define y0      _param->y0
+#define y1      _param->y1
+
+        
+        bool lastFrame=false;
+        aprintf("telecide : frame %d\n",(int)nextFrame);
+        // Get the current frame.
+        uint32_t frame=nextFrame;
+        if (frame < 0) frame = 0;
+        GETFRAME(frame, fc);
+        if(!fc)
+        {
+            ADM_info("Telecide:Cannot get frame\n");
+            return false;
+        }
+        nextFrame++;
+        output_image->copyInfo(fc);
+        fcrp = (unsigned char *) fc->GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fcrpU = (unsigned char *) fc->GetReadPtr(PLANAR_U);
+                fcrpV = (unsigned char *) fc->GetReadPtr(PLANAR_V);
+        }
+
+        // Get the previous frame.
+        pframe = frame == 0 ? 0 : frame - 1;
+        GETFRAME(pframe, fp);
+        fprp = (unsigned char *) fp->GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fprpU = (unsigned char *) fp->GetReadPtr(PLANAR_U);
+                fprpV = (unsigned char *) fp->GetReadPtr(PLANAR_V);
+        }
+
+        // Get the next frame metrics if we might need them.
+        nframe = frame + 1;
+        GETFRAME(nframe, fn);
+        if(!fn)
+        {
+            nframe=frame;
+            GETFRAME(nframe, fn);
+            ADM_assert(fn);
+            lastFrame=true;
+        }
+        fnrp = (unsigned char *) fn->GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fnrpU = (unsigned char *) fn->GetReadPtr(PLANAR_U);
+                fnrpV = (unsigned char *) fn->GetReadPtr(PLANAR_V);
+        }
+
+        pitch = fc->GetPitch(PLANAR_Y);
+        pitchover2 = pitch >> 1;
+        pitchtimes4 = pitch << 2;
+        w = fc->GetRowSize(PLANAR_Y);
+        h = fc->GetHeight(PLANAR_Y);
+/*
+        if (vi.IsYUY2() && ((w/2) & 1))
+                env->ThrowError("Telecide: width must be a multiple of 2; use Crop");
+        if (vi.IsYV12() && (w & 1))
+                env->ThrowError("Telecide: width must be a multiple of 2; use Crop");
+        if (h & 1)
+                env->ThrowError("Telecide: height must be a multiple of 2; use Crop");
+*/
+        wover2 = w/2;
+        hover2 = h/2;
+        hplus1over2 = (h+1)/2;
+        hminus2= h - 2;
+        //dst = env->NewVideoFrame(vi);
+        dst=output_image;
+        dpitch = dst->GetPitch(PLANAR_Y);
+
+        // Ensure that the metrics for the frames
+        // after the current frame are in the cache. They will be used for
+        // pattern guidance.
+        if (guide != GUIDE_NONE)
+        {
+                for (y = frame + 1; y <= frame + cycle + 1; y++)
+                {
+                        if (lastFrame==true ) break;
+                        if (CacheQuery(y, &p, &pblock, &c, &cblock) == false)
+                        {
+                                GETFRAME(y, lc);
+                                crp = (unsigned char *) lc->GetReadPtr(PLANAR_Y);
+                                //if (vi.IsYV12())
+                                {
+                                        crpU = (unsigned char *) lc->GetReadPtr(PLANAR_U);
+                                        crpV = (unsigned char *) lc->GetReadPtr(PLANAR_V);
+                                }
+                                GETFRAME(y == 0 ? 1 : y - 1, lp);
+                                prp = (unsigned char *) lp->GetReadPtr(PLANAR_Y);
+                                //if (vi.IsYV12())
+                                {
+                                        prpU = (unsigned char *) lp->GetReadPtr(PLANAR_U);
+                                        prpV = (unsigned char *) lp->GetReadPtr(PLANAR_V);
+                                }
+                                CalculateMetrics(y, crp, crpU, crpV, prp, prpU, prpV);
+                        }
+                }
+        }
+
+        /* Check for manual overrides of the field matching. */
+        
+        found = false;
+        film = true;
+        
+        inpattern = false;
+        vthresh = vthresh_saved;
+        back = back_saved;
+#if 0
+        overrides_p = overrides;
+        override = false;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p < 0xffffffff)
+                {
+                        // If the frame is in range...
+                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)))
+                        {
+                                // and it's a single specifier. 
+                                if (*(overrides_p+3) == 'p' || *(overrides_p+3) == 'c' || *(overrides_p+3) == 'n')
+                                {
+                                        // Get the match specifier and stop parsing.
+                                        switch(*(overrides_p+3))
+                                        {
+                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; found = true; break;
+                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; found = true; break;
+                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; found = true; break;
+                                        }
+                                }
+                                else if (*(overrides_p+3) == 'b')
+                                {
+                                        back = *(overrides_p+2);
+                                }
+                                else if (*(overrides_p+3) == 'm')
+                                {
+                                        // It's a multiple match specifier.
+                                        found = true;
+                                        // Get the pointer to the specifier string.
+                                        unsigned int *x = (unsigned int *) *(overrides_p+2);
+                                        // Get the index into the specification string.
+                                        // Remember, the count is first followed by the specifiers.
+                                        int ndx = ((frame - *overrides_p) % *x);
+                                        // Point to the specifier string.
+                                        x++;
+                                        // Load the specifier for this frame and stop parsing.
+                                        switch(x[ndx])
+                                        {
+                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; break;
+                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; break;
+                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; break;
+                                        }
+                                }
+                        }
+                        // Next override line.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Get the metrics for the current-previous (p), current-current (c), and current-next (n) match candidates.
+        if (CacheQuery(frame, &p, &pblock, &c, &cblock) == false)
+        {
+                CalculateMetrics(frame, fcrp, fcrpU, fcrpV, fprp, fprpU, fprpV);
+                CacheQuery(frame, &p, &pblock, &c, &cblock);
+        }
+        if (CacheQuery(nframe, &np, &npblock, &nc, &ncblock) == false)
+        {
+                CalculateMetrics(nframe, fnrp, fnrpU, fnrpV, fcrp, fcrpU, fcrpV);
+                CacheQuery(nframe, &np, &npblock, &nc, &ncblock);
+        }
+
+        // Determine the best candidate match.
+        if (found != true)
+        {
+                lowest = c;
+                chosen = C;
+                if (back == ALWAYS_BACK && p < lowest)
+                {
+                        lowest = p;
+                        chosen = P;
+                }
+                if (np < lowest)
+                {
+                        lowest = np;
+                        chosen = N;
+                }
+        }
+        if ((frame == 0 && chosen == P) || (lastFrame==true && chosen == N))
+        {
+                chosen = C;
+                lowest = c;
+        }
+
+        // See if we can apply pattern guidance.
+        mismatch = 100.0;
+        if (guide != GUIDE_NONE)
+        {
+                hard = false;
+                if (frame >= cycle && PredictHardYUY2(frame, &predicted, &predicted_metric) == true)
+                {
+                        inpattern = true;
+                        mismatch = 0.0;
+                        hard = true;
+                        if (chosen != predicted)
+                        {
+                                // The chosen frame doesn't match the prediction.
+                                if (predicted_metric == 0) mismatch = 0.0;
+                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
+                                if (mismatch < gthresh)
+                                {
+                                        // It's close enough, so use the predicted one.
+                                        if (found != true)
+                                        {
+                                                chosen = predicted;
+                                                override = true;
+                                        }
+                                }
+                                else
+                                {
+                                        hard = false;
+                                        inpattern = false;
+                                }
+                        }
+                }
+
+                if (hard == false && guide != GUIDE_22)
+                {
+                        int i;
+                        struct PREDICTION *pred = PredictSoftYUY2(frame);
+
+                        if (/*(frame <= _info.nb_frames - 1 - cycle) &&  */   (pred[0].metric != 0xffffffff))
+                        {
+                                // Apply pattern guidance.
+                                // If the predicted match metric is within defined percentage of the
+                                // best calculated one, then override the calculated match with the
+                                // predicted match.
+                                i = 0;
+                                while (pred[i].metric != 0xffffffff)
+                                {
+                                        predicted = pred[i].predicted;
+                                        predicted_metric = pred[i].predicted_metric;
+#ifdef DEBUG_PATTERN_GUIDANCE
+                                        sprintf(buf, "%d: predicted = %d\n", frame, predicted);
+                                        OutputDebugString(buf);
+#endif
+                                        if (chosen != predicted)
+                                        {
+                                                // The chosen frame doesn't match the prediction.
+                                                if (predicted_metric == 0) mismatch = 0.0;
+                                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
+                                                if ((int) mismatch <= gthresh)
+                                                {
+                                                        // It's close enough, so use the predicted one.
+                                                        if (found != true)
+                                                        {
+                                                                chosen = predicted;
+                                                                override = true;
+                                                        }
+                                                        inpattern = true;
+                                                        break;
+                                                }
+                                                else
+                                                {
+                                                        // Looks like we're not in a predictable pattern.
+                                                        inpattern = false;
+                                                }
+                                        }
+                                        else
+                                        {
+                                                inpattern = true;
+                                                mismatch = 0.0;
+                                                break;
+                                        }
+                                        i++;
+                                }
+                        }
+                }
+        }
+
+        // Check for overrides of vthresh.
+#if 0
+        overrides_p = overrides;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p < 0xffffffff)
+                {
+                        // If the frame is in range...
+                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)))
+                        {
+                                if (*(overrides_p+3) == 'v')
+                                {
+                                        vthresh = *(overrides_p+2);
+                                }
+                        }
+                        // Next override line.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Check the match for progressive versus interlaced.
+        if (post != POST_NONE)
+        {
+                if (chosen == P) vmetric = pblock;
+                else if (chosen == C) vmetric = cblock;
+                else if (chosen == N) vmetric = npblock;
+
+                if (found == false && back == BACK_ON_COMBED && vmetric > bthresh && p < lowest)
+                {
+                        // Backward match.
+                        vmetric = pblock;
+                        chosen = P;
+                        inpattern = false;
+                        mismatch = 100;
+                }
+                if (vmetric > vthresh)
+                {
+                        // After field matching and pattern guidance the frame is still combed.
+                        film = false;
+                        if (found == false && (post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP))
+                        {
+                                chosen = C;
+                                vmetric = cblock;
+                                inpattern = false;
+                                mismatch = 100;
+                        }
+                }
+        }
+        vthresh = vthresh_saved;
+
+        // Setup strings for debug info.
+        if (inpattern == true && override == false) strcpy(status, "[in-pattern]");
+        else if (inpattern == true && override == true) strcpy(status, "[in-pattern*]");
+        else strcpy(status, "[out-of-pattern]");
+
+        // Assemble and output the reconstructed frame according to the final match.
+        dstp = dst->GetWritePtr(PLANAR_Y);
+//    if (vi.IsYV12())
+        {
+                dstpU = dst->GetWritePtr(PLANAR_U);
+                dstpV = dst->GetWritePtr(PLANAR_V);
+        }
+        if (chosen == N)
+        {
+                // The best match was with the next frame.
+                if (tff == true)
+                {
+                        BitBlt(dstp, 2 * dpitch, fnrp, 2 * pitch, w, hover2);
+                        BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+                        //if (vi.IsYV12())
+                        {
+                                BitBlt(dstpU, dpitch, fnrpU, pitch, w/2, h/4);
+                                BitBlt(dstpV, dpitch, fnrpV, pitch, w/2, h/4);
+                                BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                                BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                        }
+                }
+                else
+                {
+                        BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                        BitBlt(dstp + dpitch, 2 * dpitch, fnrp + pitch, 2 * pitch, w, hover2);
+                        //if (vi.IsYV12())
+                        {
+                                BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                                BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                                BitBlt(dstpU + dpitch/2, dpitch, fnrpU + pitch/2, pitch, w/2, h/4);
+                                BitBlt(dstpV + dpitch/2, dpitch, fnrpV + pitch/2, pitch, w/2, h/4);
+                        }
+                }
+        }
+        else if (chosen == C)
+        {
+                // The best match was with the current frame.
+                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+                //if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        else if (tff == false)
+        {
+                // The best match was with the previous frame.
+                BitBlt(dstp, 2 * dpitch, fprp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+               // if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fprpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fprpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        else
+        {
+                // The best match was with the previous frame.
+                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fprp + pitch, 2 * pitch, w, hover2);
+               // if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fprpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fprpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        if (guide != GUIDE_NONE) PutChosen(frame, chosen);
+
+        /* Check for manual overrides of the deinterlacing. */
+#if 0
+        overrides_p = overrides;
+        force = 0;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p < 0xffffffff)
+                {
+                        // Is the frame in range...
+                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)) &&
+                                // and is it a single specifier...
+                                (*(overrides_p+2) == 0) &&
+                                // and is it a deinterlacing specifier?
+                                (*(overrides_p+3) == '+' || *(overrides_p+3) == '-'))
+                        {
+                                // Yes, load the specifier and stop parsing.
+                                overrides_p += 3;
+                                force = *overrides_p;
+                                break;
+                        }
+                        // Next specification record.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Do postprocessing if enabled and required for this frame.
+        if (post == POST_NONE || post == POST_METRICS)
+        {
+                if (force == '+') film = false;
+                else if (force == '-') film = true;
+        }
+        else if ((force == '+') ||
+                ((post == POST_FULL || post == POST_FULL_MAP || post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP)
+                         && (film == false && force != '-')))
+        {
+                unsigned char *dstpp, *dstpn;
+                int v1, v2, z;
+
+                if (blend == true)
+                {
+                        // Blend mode.
+                        final = output_image; //env->NewVideoFrame(vi);
+                        // Do first and last lines.
+                        finalp = final->GetWritePtr(PLANAR_Y);
+                        dstp = dst->GetWritePtr(PLANAR_Y);
+                        dstpn = dstp + dpitch;
+                        for (x = 0; x < w; x++)
+                        {
+                                finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
+                        }
+                        finalp = final->GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
+                        dstp = dst->GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
+                        dstpp = dstp - dpitch;
+                        for (x = 0; x < w; x++)
+                        {
+                                finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
+                        }
+                        // Now do the rest.
+                        dstp = dst->GetWritePtr(PLANAR_Y) + dpitch;
+                        dstpp = dstp - dpitch;
+                        dstpn = dstp + dpitch;
+                        finalp = final->GetWritePtr(PLANAR_Y) + dpitch;
+                        for (y = 1; y < h - 1; y++)
+                        {
+                                for (x = 0; x < w; x++)
+                                {
+                                        v1 = (int)(dstp[x] - dthresh);
+                                        if (v1 < 0) v1 = 0; 
+                                        v2 = (int) (dstp[x] + dthresh);
+                                        if (v2 > 235) v2 = 235; 
+                                        if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
+                                        {
+                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                {
+                                                        if (0) //(vi.IsYUY2())
+                                                        {
+                                                                if (x & 1) finalp[x] = 128;
+                                                                else finalp[x] = 235;
+                                                        }
+                                                        else
+                                                        {
+                                                                finalp[x] = 235;
+                                                        }
+                                                }
+                                                else
+                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) >> 2;
+                                        }
+                                        else finalp[x] = dstp[x];
+                                }
+                                finalp += dpitch;
+                                dstp += dpitch;
+                                dstpp += dpitch;
+                                dstpn += dpitch;
+                        }
+
+                      //  if (vi.IsYV12())
+                        {
+                                // Chroma planes.
+                                for (z = 0; z < 2; z++)
+                                {
+                                        if (z == 0)
+                                        {
+                                                // Do first and last lines.
+                                                finalp = final->GetWritePtr(PLANAR_U);
+                                                dstp = dst->GetWritePtr(PLANAR_U);
+                                                dstpn = dstp + dpitch/2;
+                                                for (x = 0; x < wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
+                                                }
+                                                finalp = final->GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
+                                                dstp = dst->GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
+                                                dstpp = dstp - dpitch/2;
+                                                for (x = 0; x < wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
+                                                }
+                                                // Now do the rest.
+                                                finalp = final->GetWritePtr(PLANAR_U) + dpitch/2;
+                                                dstp = dst->GetWritePtr(PLANAR_U) + dpitch/2;
+                                        }
+                                        else
+                                        {
+                                                // Do first and last lines.
+                                                finalp = final->GetWritePtr(PLANAR_V);
+                                                dstp = dst->GetWritePtr(PLANAR_V);
+                                                dstpn = dstp + dpitch/2;
+                                                for (x = 0; x < wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
+                                                }
+                                                finalp = final->GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
+                                                dstp = dst->GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
+                                                dstpp = dstp - dpitch/2;
+                                                for (x = 0; x < wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
+                                                }
+                                                // Now do the rest.
+                                                finalp = final->GetWritePtr(PLANAR_V) + dpitch/2;
+                                                dstp = dst->GetWritePtr(PLANAR_V) + dpitch/2;
+                                        }
+                                        dstpp = dstp - dpitch/2;
+                                        dstpn = dstp + dpitch/2;
+                                        for (y = 1; y < hover2 - 1; y++)
+                                        {
+                                                for (x = 0; x < wover2; x++)
+                                                {
+                                                        v1 = (int)( dstp[x] - dthresh);
+                                                        if (v1 < 0) v1 = 0; 
+                                                        v2 = (int)( dstp[x] + dthresh);
+                                                        if (v2 > 235) v2 = 235; 
+                                                        if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
+                                                        {
+                                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                                {
+                                                                        finalp[x] = 128;
+                                                                }
+                                                                else
+                                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) >> 2;
+                                                        }
+                                                        else finalp[x] = dstp[x];
+                                                }
+                                                finalp += dpitch/2;
+                                                dstp += dpitch/2;
+                                                dstpp += dpitch/2;
+                                                dstpn += dpitch/2;
+                                        }
+                                }
+                        }
+                        if (show == true) Show(final, frame);
+                        if (debug == true) Debug(frame);
+                        if (hints == true) WriteHints(final->GetWritePtr(PLANAR_Y), film, inpattern);
+                       // return final;
+                        vidCache->unlockAll();
+                        return 1;
+                }
+
+                // Interpolate mode.
+                // Luma plane.
+                dstp = dst->GetWritePtr(PLANAR_Y) + dpitch;
+                dstpp = dstp - dpitch;
+                dstpn = dstp + dpitch;
+                for (y = 1; y < h - 1; y+=2)
+                {
+                        for (x = 0; x < w; x++)
+                        {
+                                v1 = (int) (dstp[x] - dthresh);
+                                if (v1 < 0) v1 = 0; 
+                                v2 = (int) dstp[x] + dthresh;
+                                if (v2 > 235) v2 = 235; 
+                                if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
+                                {
+                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                        {
+                                                if(0) // (vi.IsYUY2())
+                                                {
+                                                        if (x & 1) dstp[x] = 128;
+                                                        else dstp[x] = 235;
+                                                }
+                                                else
+                                                {
+                                                        dstp[x] = 235;
+                                                }
+                                        }
+                                        else
+                                                dstp[x] = (dstpp[x] + dstpn[x]) >> 1;
+                                }
+                        }
+                        dstp += 2*dpitch;
+                        dstpp += 2*dpitch;
+                        dstpn += 2*dpitch;
+                }
+
+               // if (vi.IsYV12())
+                {
+                        // Chroma planes.
+                        for (z = 0; z < 2; z++)
+                        {
+                                if (z == 0) dstp = dst->GetWritePtr(PLANAR_U) + dpitch/2;
+                                else dstp = dst->GetWritePtr(PLANAR_V) + dpitch/2;
+                                dstpp = dstp - dpitch/2;
+                                dstpn = dstp + dpitch/2;
+                                for (y = 1; y < hover2 - 1; y+=2)
+                                {
+                                        for (x = 0; x < wover2; x++)
+                                        {
+                                                v1 = (int) dstp[x] - dthresh;
+                                                if (v1 < 0) v1 = 0; 
+                                                v2 = (int) dstp[x] + dthresh;
+                                                if (v2 > 235) v2 = 235; 
+                                                if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
+                                                {
+                                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                        {
+                                                                dstp[x] = 128;
+                                                        }
+                                                        else
+                                                                dstp[x] = (dstpp[x] + dstpn[x]) >> 1;
+                                                }
+                                        }
+                                        dstp += dpitch;
+                                        dstpp += dpitch;
+                                        dstpn += dpitch;
+                                }
+                        }
+                }
+        }
+
+        if (show == true) Show(dst, frame);
+        if (debug == true) Debug(frame);
+        if (hints == true) WriteHints(dst->GetWritePtr(PLANAR_Y), film, inpattern);
+        vidCache->unlockAll();
+        //return dst;
+        return 1;
+}
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	2011-07-10 14:31:22 UTC (rev 7310)
@@ -0,0 +1,785 @@
+
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : fixounet at free.fr
+
+    Port of Donal Graft Telecide which is (c) Donald Graft
+    http://www.neuron2.net
+    http://puschpull.org/avisynth/decomb_reference_manual.html
+
+ ***************************************************************************/
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include "ADM_default.h"
+#include "Telecide.h"
+#include "DIA_factory.h"
+
+#define aprintf(...) {}
+
+/**
+    \fn PutChosen
+*/
+void Telecide::PutChosen(int frame, unsigned int chosen)
+        {
+                int f;
+
+                f = frame % CACHE_SIZE;
+                if (frame < 0 /*|| frame > _info.nb_frames - 1*/ || cache[f].frame != frame)
+                        return;
+                cache[f].chosen = chosen;
+        }
+/**
+    \fn CacheInsert
+*/
+
+void Telecide::CacheInsert(int frame, unsigned int p, unsigned int pblock,
+                                                                unsigned int c, unsigned int cblock)
+{
+        int f;
+
+        f = frame % CACHE_SIZE;
+        if (frame < 0 )//|| frame > _info.nb_frames - 1)
+                ADM_assert(0);
+        cache[f].frame = frame;
+        cache[f].metrics[P] = p;
+        if (f) cache[f-1].metrics[N] = p;
+        cache[f].metrics[C] = c;
+        cache[f].metrics[PBLOCK] = pblock;
+        cache[f].metrics[CBLOCK] = cblock;
+        cache[f].chosen = 0xff;
+}
+/**
+    \fn CacheQuery
+*/
+bool Telecide::CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
+                                                                unsigned int *c, unsigned int *cblock)
+{
+        int f;
+
+        f = frame % CACHE_SIZE;
+        if (frame < 0) // || frame > _info.nb_frames - 1)
+        {
+                printf("Frame %d is out! \n",frame); //,_info.nb_frames-1);
+                ADM_assert(0);
+        }
+        if (cache[f].frame != frame)
+        {
+                return false;
+        }
+        *p = cache[f].metrics[P];
+        *c = cache[f].metrics[C];
+        *pblock = cache[f].metrics[PBLOCK];
+        *cblock = cache[f].metrics[CBLOCK];
+        return true;
+}
+/**
+    \fn Show
+*/
+void Telecide::Show(ADMImage *dst, int frame)
+{
+	char use;
+	teleCide *_param=&configuration;
+
+	if (chosen == P) use = 'p';
+	else if (chosen == C) use = 'c';
+	else use = 'n';
+
+	sprintf(buf, "Telecide %s", "ADM"); // VERSION
+	DrawString(dst, 0, 0, buf);
+
+	sprintf(buf, "Copyright 2003 Donald A. Graft");
+	DrawString(dst, 0, 1, buf);
+
+	sprintf(buf,"frame %d:", frame);
+	DrawString(dst, 0, 3, buf);
+
+	sprintf(buf, "matches: %d  %d  %d", p, c, np);
+	DrawString(dst, 0, 4, buf);
+
+	if (_param->post != POST_NONE)
+	{
+		sprintf(buf,"vmetrics: %d  %d  %d [chosen=%d]", pblock, cblock, npblock, vmetric);
+		DrawString(dst, 0, 5, buf);
+	}
+
+	if (_param->guide != GUIDE_NONE)
+	{
+		sprintf(buf, "pattern mismatch=%0.2f%%", mismatch); 
+		DrawString(dst, 0, 5 + (_param->post != POST_NONE), buf);
+	}
+
+	sprintf(buf,"[%s %c]%s %s",
+		found == true ? "forcing" : "using", use,
+		_param->post != POST_NONE ? (film == true ? " [progressive]" : " [interlaced]") : "",
+		_param->guide != GUIDE_NONE ? status : "");
+	DrawString(dst, 0, 5 + (_param->post != POST_NONE) + (_param->guide != GUIDE_NONE), buf);
+}
+/**
+    \fn Debug
+*/
+void Telecide::Debug(int frame)
+{
+	char use;
+
+	if (chosen == P) use = 'p';
+	else if (chosen == C) use = 'c';
+	else use = 'n';
+	sprintf(buf,"Telecide: frame %d: matches: %d %d %d", frame, p, c, np);
+	OutputDebugString(buf);
+	if (configuration.post != POST_NONE)
+	{
+		sprintf(buf,"Telecide: frame %d: vmetrics: %d %d %d [chosen=%d]", frame, pblock, cblock, npblock, vmetric);
+		OutputDebugString(buf);
+	}
+	sprintf(buf,"Telecide: frame %d: [%s %c]%s %s", frame, found == true ? "forcing" : "using", use,
+		configuration.post  != POST_NONE ? (film == true ? " [progressive]" : " [interlaced]") : "",
+		configuration.guide != GUIDE_NONE ? status : "");
+	OutputDebugString(buf);
+}
+/**
+    \fn configure
+*/
+bool Telecide::configure(void)
+{
+#define PX(x) &(configuration.x)
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+
+    teleCide *_param=&configuration;
+        
+    ELEM_TYPE_FLOAT vthresh=(ELEM_TYPE_FLOAT)_param->vthresh;
+    ELEM_TYPE_FLOAT bthresh=(ELEM_TYPE_FLOAT)_param->bthresh;
+    ELEM_TYPE_FLOAT dthresh=(ELEM_TYPE_FLOAT)_param->dthresh;
+    ELEM_TYPE_FLOAT gthresh=(ELEM_TYPE_FLOAT)_param->gthresh;
+
+         diaMenuEntry tStrategy[]={
+                             {GUIDE_NONE,   QT_TR_NOOP("No strategy"),NULL},
+                             {GUIDE_32,     QT_TR_NOOP("3:2 pulldown"),NULL},
+                             {GUIDE_22,     QT_TR_NOOP("PAL/SECAM"),NULL},
+                             {GUIDE_32322,  QT_TR_NOOP("NTSC converted from PAL"),NULL}
+                          };
+                          
+          diaMenuEntry tField[]={
+                             {1,QT_TR_NOOP("Top"),NULL},
+                             {0,QT_TR_NOOP("Bottom"),NULL}
+          };
+          
+          diaMenuEntry tBackward[]={
+                             {NO_BACK,QT_TR_NOOP("Never"),NULL},
+                             {BACK_ON_COMBED,QT_TR_NOOP("If still combed"),NULL},
+                             {ALWAYS_BACK,QT_TR_NOOP("Always"),NULL}
+          };
+          
+          diaMenuEntry tPostproc[]={
+                             {POST_NONE,      QT_TR_NOOP("None"),NULL},
+                             {POST_METRICS,   QT_TR_NOOP("None but compute"),NULL},
+                             {POST_FULL,      QT_TR_NOOP("Postproc on best match"),NULL},
+                             {POST_FULL_MAP,  QT_TR_NOOP("Postproc and show zones (debug)"),NULL},
+                             {POST_FULL_NOMATCH,QT_TR_NOOP("Process image (not fields)"),NULL},
+                             {POST_FULL_NOMATCH_MAP,QT_TR_NOOP("Process image (not fields), debug"),NULL}
+          };
+                             
+          
+    diaElemMenu menuMode(PX(guide),   QT_TR_NOOP("_Strategy:"), SZT(tStrategy),tStrategy);
+    diaElemMenu menuField(PX(order),  QT_TR_NOOP("_Field order:"), SZT(tField),tField);
+    diaElemMenu menuPost(PX(post),    QT_TR_NOOP("_Postprocessing:"), SZT(tPostproc),tPostproc);
+    diaElemMenu menuBackward(PX(back),QT_TR_NOOP("_Try backward:"), SZT(tBackward),tBackward);
+    
+    diaElemFloat direct(&dthresh,QT_TR_NOOP("_Direct threshold:"),0,200. );
+    diaElemFloat backward(&bthresh,QT_TR_NOOP("_Backward threshold:"),0,200. );
+    diaElemFloat noise(&gthresh,QT_TR_NOOP("_Noise threshold:"),0,200. );
+    diaElemFloat post(&vthresh,QT_TR_NOOP("Postp_rocessing threshold:"),0,200. );
+    
+    diaElemToggle chroma(PX(chroma),QT_TR_NOOP("_Use chroma to decide"));
+    diaElemToggle show(PX(show),QT_TR_NOOP("Sho_w info"));
+    diaElemToggle debug(PX(debug),QT_TR_NOOP("Debu_g"));
+    diaElemToggle blend(PX(blend),QT_TR_NOOP("Bl_end"));
+    
+    
+    
+    diaElem *elems[]={&menuMode,&menuField,&menuPost,&menuBackward,
+        &direct,&backward,&noise,&post,&blend,
+        &chroma,&show,&debug    };
+    
+  if(diaFactoryRun(QT_TR_NOOP("Decomb Telecide"),12,elems))
+  {
+    
+      _param->vthresh=(float)vthresh;
+      _param->bthresh=(float)bthresh;
+      _param->dthresh=(float)dthresh;
+      _param->gthresh=(float)gthresh;
+
+    return 1; 
+  }
+  return 0;        
+}
+/**
+    \fn getConfiguration
+*/
+const char *Telecide::getConfiguration( void )
+{
+static char buf[100];
+ snprintf(buf,99," Decomb telecide");
+ return buf;  
+}
+
+#define PROGRESSIVE  0x00000001
+#define IN_PATTERN   0x00000002
+
+/*
+  uint8_t PutHintingData(unsigned char *video, unsigned int hint);
+  uint8_t GetHintingData(unsigned char *video, unsigned int *hint);
+*/
+/**
+    \fn WriteHints
+*/  
+void Telecide::WriteHints(unsigned char *dst, bool film, bool inpattern)
+        {
+                unsigned int hint;
+
+                if (GetHintingData(dst, &hint) == true) hint = 0;
+                if (film == true) hint |= PROGRESSIVE;
+                else hint &= ~PROGRESSIVE;
+                if (inpattern == true) hint |= IN_PATTERN;
+                else hint &= ~IN_PATTERN;
+                PutHintingData(dst, hint);
+        }
+/**
+    \fn PredictHardYUY2
+*/
+bool Telecide::PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric)
+        {
+                // Look for pattern in the actual delivered matches of the previous cycle of frames.
+                // If a pattern is found, use that to predict the current match.
+                if (configuration.guide == GUIDE_22)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen << 4) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen))
+                        {
+                        case 0x11:
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x22:
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+                else if (configuration.guide == GUIDE_32)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen << 16) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen << 12) +
+                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen <<  8) +
+                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen <<  4) +
+                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen))
+                        {
+                        case 0x11122:
+                        case 0x11221:
+                        case 0x12211:
+                        case 0x12221: 
+                        case 0x21122: 
+                        case 0x11222: 
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x22111:
+                        case 0x21112:
+                        case 0x22112: 
+                        case 0x22211: 
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+                else if (configuration.guide == GUIDE_32322)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+5)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen << 20) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen << 16) +
+                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen << 12) +
+                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen <<  8) +
+                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen <<  4) +
+                                        (cache[(frame-cycle+5)%CACHE_SIZE].chosen))
+                        {
+                        case 0x111122:
+                        case 0x111221:
+                        case 0x112211:
+                        case 0x122111:
+                        case 0x111222: 
+                        case 0x112221:
+                        case 0x122211:
+                        case 0x222111: 
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x221111:
+                        case 0x211112:
+
+                        case 0x221112: 
+                        case 0x211122: 
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+#ifdef DEBUG_PATTERN_GUIDANCE
+                sprintf(buf, "%d: HARD: predicted = %d\n", frame, *predicted);
+                OutputDebugString(buf);
+#endif
+                return true;
+        }
+/**
+    \fn PredictSoftYUY2
+*/
+struct PREDICTION *Telecide::PredictSoftYUY2(int frame)
+        {
+                // Use heuristics to look forward for a match.
+                int i, j, y, c, n, phase;
+                unsigned int metric;
+
+                pred[0].metric = 0xffffffff;
+                if (frame < 0 /*|| frame > _info.nb_frames - 1 - cycle*/) return pred;
+
+                // Look at the next cycle of frames.
+                for (y = frame + 1; y <= frame + cycle; y++)
+                {
+                        // Look for a frame where the current and next match values are
+                        // very close. Those are candidates to predict the phase, because
+                        // that condition should occur only once per cycle. Store the candidate
+                        // phases and predictions in a list sorted by goodness. The list will
+                        // be used by the caller to try the phases in order.
+                        c = cache[y%CACHE_SIZE].metrics[C]; 
+                        n = cache[y%CACHE_SIZE].metrics[N];
+                        if (c == 0) c = 1;
+                        metric = (100 * abs (c - n)) / c;
+                        phase = y % cycle;
+                        if (metric < 5)
+                        {
+                                // Place the new candidate phase in sorted order in the list.
+                                // Find the insertion point.
+                                i = 0;
+                                while (metric > pred[i].metric) i++;
+                                // Find the end-of-list marker.
+                                j = 0;
+                                while (pred[j].metric != 0xffffffff) j++;
+                                // Shift all items below the insertion point down by one to make
+                                // room for the insertion.
+                                j++;
+                                for (; j > i; j--)
+                                {
+                                        pred[j].metric = pred[j-1].metric;
+                                        pred[j].phase = pred[j-1].phase;
+                                        pred[j].predicted = pred[j-1].predicted;
+                                        pred[j].predicted_metric = pred[j-1].predicted_metric;
+                                }
+                                // Insert the new candidate data.
+                                pred[j].metric = metric;
+                                pred[j].phase = phase;
+                                if (configuration.guide == GUIDE_32)
+                                {
+                                        switch ((frame % cycle) - phase)
+                                        {
+                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -3: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        }
+                                }
+                                else if (configuration.guide == GUIDE_32322)
+                                {
+                                        switch ((frame % cycle) - phase)
+                                        {
+                                        case -5: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +5: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        }
+                                }
+                        }
+#ifdef DEBUG_PATTERN_GUIDANCE
+                        sprintf(buf,"%d: metric = %d phase = %d\n", frame, metric, phase);
+                        OutputDebugString(buf);
+#endif
+                }
+                return pred;
+        }
+
+/**
+    \fn CalculateMetrics
+*/
+#define nt      configuration.nt
+#define y0      configuration.y0
+#define y1      configuration.y1
+#define chroma  configuration.chroma
+#define post    configuration.post
+
+
+void Telecide::CalculateMetrics(int frame, 
+                                unsigned char *fcrp,  unsigned char *fcrpU, 
+                                unsigned char *fcrpV, unsigned char *fprp, 
+                                unsigned char *fprpU, unsigned char *fprpV)
+{
+        int x, y, p, c, tmp1, tmp2, skip;
+        bool vc;
+        unsigned char *currbot0, *currbot2, *prevbot0, *prevbot2;
+        unsigned char *prevtop0, *prevtop2, *prevtop4, *currtop0, *currtop2, *currtop4;
+        unsigned char *a0, *a2, *b0, *b2, *b4;
+        unsigned int diff, index;
+#define T 4
+
+        /* Clear the block sums. */
+        for (y = 0; y < yblocks; y++)
+        {
+                for (x = 0; x < xblocks; x++)
+                {
+#ifdef WINDOWED_MATCH
+                        matchp[y*xblocks+x] = 0;
+                        matchc[y*xblocks+x] = 0;
+#endif
+                        sump[y*xblocks+x] = 0;
+                        sumc[y*xblocks+x] = 0;
+                }
+        }
+
+        /* Find the best field match. Subsample the frames for speed. */
+        currbot0  = fcrp + pitch;
+        currbot2  = fcrp + 3 * pitch;
+        currtop0 = fcrp;
+        currtop2 = fcrp + 2 * pitch;
+        currtop4 = fcrp + 4 * pitch;
+        prevbot0  = fprp + pitch;
+        prevbot2  = fprp + 3 * pitch;
+        prevtop0 = fprp;
+        prevtop2 = fprp + 2 * pitch;
+        prevtop4 = fprp + 4 * pitch;
+        if (tff == true)
+        {
+                a0 = prevbot0;
+                a2 = prevbot2;
+                b0 = currtop0;
+                b2 = currtop2;
+                b4 = currtop4;
+        }
+        else
+        {
+                a0 = currbot0;
+                a2 = currbot2;
+                b0 = prevtop0;
+                b2 = prevtop2;
+                b4 = prevtop4;
+        }
+        p = c = 0;
+
+        // Calculate the field match and film/video metrics.
+        //if (vi.IsYV12()) skip = 1;
+        if(1) skip=1;
+        else skip = 1 + (chroma == false);
+        for (y = 0, index = 0; y < h - 4; y+=4)
+        {
+                /* Exclusion band. Good for ignoring subtitles. */
+                if (y0 == y1 || y < y0 || y > y1)
+                {
+                        for (x = 0; x < w;)
+                        {
+                                if (1) //vi.IsYV12())
+                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
+                                else
+                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
+
+                                // Test combination with current frame.
+                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
+//                              diff = abs((long)currtop0[x] - (tmp1 >> 1));
+                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 >> 1) - tmp1);
+                                if (diff > nt)
+                                {
+                                        c += diff;
+#ifdef WINDOWED_MATCH
+                                        matchc[index] += diff;
+#endif
+                                }
+
+                                tmp1 = currbot0[x] + T;
+                                tmp2 = currbot0[x] - T;
+                                vc = (tmp1 < currtop0[x] && tmp1 < currtop2[x]) ||
+                                         (tmp2 > currtop0[x] && tmp2 > currtop2[x]);
+                                if (vc)
+                                {
+                                        sumc[index]++;
+                                }
+
+                                // Test combination with previous frame.
+                                tmp1 = ((long)a0[x] + (long)a2[x]);
+                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 >> 1) - tmp1);
+                                if (diff > nt)
+                                {
+                                        p += diff;
+#ifdef WINDOWED_MATCH
+                                        matchp[index] += diff;
+#endif
+                                }
+
+                                tmp1 = a0[x] + T;
+                                tmp2 = a0[x] - T;
+                                vc = (tmp1 < b0[x] && tmp1 < b2[x]) ||
+                                         (tmp2 > b0[x] && tmp2 > b2[x]);
+                                if (vc)
+                                {
+                                        sump[index]++;
+                                }
+
+                                x += skip;
+                                if (!(x&3)) x += 4;
+                        }
+                }
+                currbot0 += pitchtimes4;
+                currbot2 += pitchtimes4;
+                currtop0 += pitchtimes4;
+                currtop2 += pitchtimes4;
+                currtop4 += pitchtimes4;
+                a0               += pitchtimes4;
+                a2               += pitchtimes4;
+                b0               += pitchtimes4;
+                b2               += pitchtimes4;
+                b4               += pitchtimes4;
+        }
+
+       // if (vi.IsYV12() && chroma == true)
+        if ( chroma == true)
+        {
+                int z;
+
+                for (z = 0; z < 2; z++)
+                {
+                        // Do the same for the U plane.
+                        if (z == 0)
+                        {
+                                currbot0  = fcrpU + pitchover2;
+                                currbot2  = fcrpU + 3 * pitchover2;
+                                currtop0 = fcrpU;
+                                currtop2 = fcrpU + 2 * pitchover2;
+                                currtop4 = fcrpU + 4 * pitchover2;
+                                prevbot0  = fprpU + pitchover2;
+                                prevbot2  = fprpU + 3 * pitchover2;
+                                prevtop0 = fprpU;
+                                prevtop2 = fprpU + 2 * pitchover2;
+                                prevtop4 = fprpU + 4 * pitchover2;
+                        }
+                        else
+                        {
+                                currbot0  = fcrpV + pitchover2;
+                                currbot2  = fcrpV + 3 * pitchover2;
+                                currtop0 = fcrpV;
+                                currtop2 = fcrpV + 2 * pitchover2;
+                                currtop4 = fcrpV + 4 * pitchover2;
+                                prevbot0  = fprpV + pitchover2;
+                                prevbot2  = fprpV + 3 * pitchover2;
+                                prevtop0 = fprpV;
+                                prevtop2 = fprpV + 2 * pitchover2;
+                                prevtop4 = fprpV + 4 * pitchover2;
+                        }
+                        if (tff == true)
+                        {
+                                a0 = prevbot0;
+                                a2 = prevbot2;
+                                b0 = currtop0;
+                                b2 = currtop2;
+                                b4 = currtop4;
+                        }
+                        else
+                        {
+                                a0 = currbot0;
+                                a2 = currbot2;
+                                b0 = prevtop0;
+                                b2 = prevtop2;
+                                b4 = prevtop4;
+                        }
+
+                        for (y = 0, index = 0; y < hover2 - 4; y+=4)
+                        {
+                                /* Exclusion band. Good for ignoring subtitles. */
+                                if (y0 == y1 || y < y0/2 || y > y1/2)
+                                {
+                                        for (x = 0; x < wover2;)
+                                        {
+                                                if (1) //vi.IsYV12())
+                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
+                                                else
+                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
+
+                                                // Test combination with current frame.
+                                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
+                                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 >> 1) - tmp1);
+                                                if (diff > nt)
+                                                {
+                                                        c += diff;
+#ifdef WINDOWED_MATCH
+                                                        matchc[index] += diff;
+#endif
+                                                }
+
+                                                tmp1 = currbot0[x] + T;
+                                                tmp2 = currbot0[x] - T;
+                                                vc = (tmp1 < currtop0[x] && tmp1 < currtop2[x]) ||
+                                                         (tmp2 > currtop0[x] && tmp2 > currtop2[x]);
+                                                if (vc)
+                                                {
+                                                        sumc[index]++;
+                                                }
+
+                                                // Test combination with previous frame.
+                                                tmp1 = ((long)a0[x] + (long)a2[x]);
+                                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 >> 1) - tmp1);
+                                                if (diff > nt)
+                                                {
+                                                        p += diff;
+#ifdef WINDOWED_MATCH
+                                                        matchp[index] += diff;
+#endif
+                                                }
+
+                                                tmp1 = a0[x] + T;
+                                                tmp2 = a0[x] - T;
+                                                vc = (tmp1 < b0[x] && tmp1 < b2[x]) ||
+                                                         (tmp2 > b0[x] && tmp2 > b2[x]);
+                                                if (vc)
+                                                {
+                                                        sump[index]++;
+                                                }
+
+                                                x ++;
+                                                if (!(x&3)) x += 4;
+                                        }
+                                }
+                                currbot0 += 4*pitchover2;
+                                currbot2 += 4*pitchover2;
+                                currtop0 += 4*pitchover2;
+                                currtop2 += 4*pitchover2;
+                                currtop4 += 4*pitchover2;
+                                a0               += 4*pitchover2;
+                                a2               += 4*pitchover2;
+                                b0               += 4*pitchover2;
+                                b2               += 4*pitchover2;
+                                b4               += 4*pitchover2;
+                        }
+                }
+        }
+
+        // Now find the blocks that have the greatest differences.
+#ifdef WINDOWED_MATCH
+        highest_matchp = 0;
+        for (y = 0; y < yblocks; y++)
+        {
+                for (x = 0; x < xblocks; x++)
+                {
+if (frame == 45 && matchp[y * xblocks + x] > 2500)
+{
+        sprintf(buf, "%d/%d = %d\n", x, y, matchp[y * xblocks + x]);
+        OutputDebugString(buf);
+}
+                        if (matchp[y * xblocks + x] > highest_matchp)
+                        {
+                                highest_matchp = matchp[y * xblocks + x];
+                        }
+                }
+        }
+        highest_matchc = 0;
+        for (y = 0; y < yblocks; y++)
+        {
+                for (x = 0; x < xblocks; x++)
+                {
+if (frame == 44 && matchc[y * xblocks + x] > 2500)
+{
+        sprintf(buf, "%d/%d = %d\n", x, y, matchc[y * xblocks + x]);
+        OutputDebugString(buf);
+}
+                        if (matchc[y * xblocks + x] > highest_matchc)
+                        {
+                                highest_matchc = matchc[y * xblocks + x];
+                        }
+                }
+        }
+#endif
+        if (post != POST_NONE)
+        {
+                highest_sump = 0;
+                for (y = 0; y < yblocks; y++)
+                {
+                        for (x = 0; x < xblocks; x++)
+                        {
+                                if (sump[y * xblocks + x] > highest_sump)
+                                {
+                                        highest_sump = sump[y * xblocks + x];
+                                }
+                        }
+                }
+                highest_sumc = 0;
+                for (y = 0; y < yblocks; y++)
+                {
+                        for (x = 0; x < xblocks; x++)
+                        {
+                                if (sumc[y * xblocks + x] > highest_sumc)
+                                {
+                                        highest_sumc = sumc[y * xblocks + x];
+                                }
+                        }
+                }
+        }
+#ifdef WINDOWED_MATCH
+        CacheInsert(frame, highest_matchp, highest_sump, highest_matchc, highest_sumc);
+#else
+        CacheInsert(frame, p, highest_sump, c, highest_sumc);
+#endif
+}
+// EOF



From mean at mail.berlios.de  Sun Jul 10 16:31:24 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 10 Jul 2011 16:31:24 +0200
Subject: [Avidemux-svn-commit] r7311 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreImage/include
	avidemux_plugins/ADM_videoFilters6
	avidemux_plugins/ADM_videoFilters6/telecide
Message-ID: <20110710143124.A77004813BB@sheep.berlios.de>

Author: mean
Date: 2011-07-10 16:31:24 +0200 (Sun, 10 Jul 2011)
New Revision: 7311

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
Log:
[telecide] Port telecide from 2.5

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2011-07-10 14:31:22 UTC (rev 7310)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2011-07-10 14:31:24 UTC (rev 7311)
@@ -207,7 +207,8 @@
     virtual      uint8_t        *GetWritePtr(ADM_PLANE plane) {return GetReadPtr(plane);}
 };
 
-void drawString(ADMImage *dst, int x, int y, const char *s) ;
+#define drawString(img,x,y,text) img->printString(x,y,text)
+//void drawString(ADMImage *dst, int x, int y, const char *s) ;
 
 // Misc utilities
 bool BitBlit(uint8_t *dst, uint32_t pitchDest,uint8_t *src,uint32_t pitchSrc,uint32_t width, uint32_t height);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2011-07-10 14:31:22 UTC (rev 7310)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2011-07-10 14:31:24 UTC (rev 7311)
@@ -19,6 +19,7 @@
 ADD_SUBDIRECTORY(rotate)
 ADD_SUBDIRECTORY(stackField)
 ADD_SUBDIRECTORY(swapUV)
+ADD_SUBDIRECTORY(telecide)
 ADD_SUBDIRECTORY(yadif)
 ADD_SUBDIRECTORY(vdpauFilters)
 ADD_SUBDIRECTORY(verticalFlip)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	2011-07-10 14:31:22 UTC (rev 7310)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	2011-07-10 14:31:24 UTC (rev 7311)
@@ -64,23 +64,9 @@
 		int count;
 		char *d, *dsaved;
 		unsigned int *p, *x;
-		_lastFrame=0xfffffff0;
-        teleCide *_param=&configuration;
-		
-		vidCache=new VideoCache(12,in);
-#if 0
-		pitch = _info.width;
-		dpitch = _info.width;
-		pitchover2 = pitch >> 1;
-		pitchtimes4 = pitch << 2;
+        teleCide *_param=&configuration;		
+		vidCache=new VideoCache(16,in);
 
-		w = _info.width;
-		h = _info.height;
-		wover2 = w/2;
-		hover2 = h/2;
-		hplus1over2 = (h+1)/2;
-		hminus2= h - 2;
-#endif
 		if(!couples || !ADM_paramLoad(couples,teleCide_param,&configuration))
         {
                  
@@ -110,11 +96,7 @@
 
 		// Set up pattern guidance.
 		cache = (struct CACHE_ENTRY *) ADM_alloc(CACHE_SIZE * sizeof(struct CACHE_ENTRY));
-		for (i = 0; i < CACHE_SIZE; i++)
-		{
-			cache[i].frame = 0xffffffff;
-			cache[i].chosen = 0xff;
-		}
+		CachePurge();
 
 		if (_param->guide == GUIDE_32)
 		{
@@ -177,8 +159,15 @@
 {
     return ADM_paramSave(couples, teleCide_param,&configuration);
 }
+/**
+    \fn goToTime
+    \brief Need to reset internals in case of seek
+*/
 bool                Telecide::goToTime(uint64_t usSeek)
 {
-    return ADM_coreVideoFilter::goToTime(usSeek);
+    bool r=ADM_coreVideoFilter::goToTime(usSeek);
+    vidCache->flush();
+    CachePurge();
+    return r;
 }
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	2011-07-10 14:31:22 UTC (rev 7310)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	2011-07-10 14:31:24 UTC (rev 7311)
@@ -77,11 +77,8 @@
 	unsigned int predicted_metric;
 };
 
-#define GETFRAME(g, fp) { int GETFRAMEf; uint32_t len,flags;GETFRAMEf = (g); fp=NULL;\
-    if (GETFRAMEf < 0) GETFRAMEf = 0; 	 fp=vidCache->getImage(GETFRAMEf); }
 
 
-
 /**
     \class Telecide
 
@@ -92,11 +89,6 @@
         teleCide           configuration;
 protected:
         bool tff;	
-        uint32_t _lastFrame;	
-#if 1
-        int pitch, dpitch, pitchover2, pitchtimes4;
-        int w, h, wover2, hover2, hplus1over2, hminus2;
-#endif
         int xblocks, yblocks;
     #ifdef WINDOWED_MATCH
         unsigned int *matchc, *matchp, highest_matchc, highest_matchp;
@@ -127,7 +119,6 @@
         // For output message formatting.
         char buf[255];
         
-        VideoCache	*vidCache;
 public:
                             Telecide(ADM_coreVideoFilter *previous,CONFcouple *conf);
                             ~Telecide();
@@ -138,16 +129,14 @@
         virtual bool         configure(void) ;           /// Start graphical user interface
 
 protected:
-	
-	void CalculateMetrics(int n, unsigned char *crp, unsigned char *crpU, unsigned char *crpV, 
-				unsigned char *prp, unsigned char *prpU, unsigned char *prpV);
+	void CalculateMetrics(int frame, ADMImage *fcurrent, ADMImage *fprevious);
 	void Show(ADMImage *dst, int frame);
 	void Debug(int frame);
 
 
 	void PutChosen(int frame, unsigned int chosen);
 	
-
+    bool CachePurge(void);
 	void CacheInsert(int frame, unsigned int p, unsigned int pblock,
 				unsigned int c, unsigned int cblock);
 	

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-10 14:31:22 UTC (rev 7310)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-10 14:31:24 UTC (rev 7311)
@@ -38,6 +38,37 @@
     #define aprintf(...) {}
 #endif
 
+#define GETFRAME(g, fp) { \
+        int no=g; fp=NULL;\
+        if (no < 0) no = 0; \
+        aprintf("Cache query : %d - %d\n",no,__LINE__);\
+        fp=vidCache->getImage(no); }
+
+#define guide _param->guide
+#define order _param->order
+#define back  _param->back
+
+#define back_saved  _param->back_saved
+#define guide       _param->guide
+#define gthresh     _param->gthresh
+#define post        _param->post
+#define chroma      _param->chroma
+#define vthresh     _param->vthresh
+
+#define vthresh_saved _param->vthresh_saved
+#define hints      _param->hints
+#define show       _param->show
+#define debug      _param->debug
+
+#define bthresh      _param->bthresh
+#define dthresh      _param->dthresh
+#define blend        _param->blend
+
+#define nt      _param->nt
+#define y0      _param->y0
+#define y1      _param->y1
+
+
 /**
     \fn getNextFrame
 */
@@ -74,40 +105,20 @@
 uint8_t *finalpU,*finalpV;
 
 teleCide *_param=&configuration;
-#define guide _param->guide
-#define order _param->order
-#define back  _param->back
 
-#define back_saved  _param->back_saved
-#define guide       _param->guide
-#define gthresh     _param->gthresh
-#define post        _param->post
-#define chroma      _param->chroma
-#define vthresh     _param->vthresh
 
-#define vthresh_saved _param->vthresh_saved
-#define hints      _param->hints
-#define show       _param->show
-#define debug      _param->debug
-
-#define bthresh      _param->bthresh
-#define dthresh      _param->dthresh
-#define blend        _param->blend
-
-#define nt      _param->nt
-#define y0      _param->y0
-#define y1      _param->y1
-
         
         bool lastFrame=false;
         aprintf("telecide : frame %d\n",(int)nextFrame);
         // Get the current frame.
         uint32_t frame=nextFrame;
         if (frame < 0) frame = 0;
+        
         GETFRAME(frame, fc);
         if(!fc)
         {
             ADM_info("Telecide:Cannot get frame\n");
+            vidCache->unlockAll();
             return false;
         }
         nextFrame++;
@@ -146,11 +157,13 @@
                 fnrpV = (unsigned char *) fn->GetReadPtr(PLANAR_V);
         }
 
-        pitch = fc->GetPitch(PLANAR_Y);
-        pitchover2 = pitch >> 1;
-        pitchtimes4 = pitch << 2;
-        w = fc->GetRowSize(PLANAR_Y);
-        h = fc->GetHeight(PLANAR_Y);
+        int pitch = fc->GetPitch(PLANAR_Y);
+        int pitchover2 = pitch >> 1;
+        int pitchtimes4 = pitch << 2;
+        int w = info.width;
+        int h = info.height; 
+        int hover2 = h >>1;
+        int wover2 = w >>1;
 /*
         if (vi.IsYUY2() && ((w/2) & 1))
                 env->ThrowError("Telecide: width must be a multiple of 2; use Crop");
@@ -159,19 +172,19 @@
         if (h & 1)
                 env->ThrowError("Telecide: height must be a multiple of 2; use Crop");
 */
-        wover2 = w/2;
-        hover2 = h/2;
-        hplus1over2 = (h+1)/2;
-        hminus2= h - 2;
+
+        int hplus1over2 = (h+1)/2;
+        int hminus2= h - 2;
         //dst = env->NewVideoFrame(vi);
         dst=output_image;
-        dpitch = dst->GetPitch(PLANAR_Y);
+        int dpitch = dst->GetPitch(PLANAR_Y);
 
         // Ensure that the metrics for the frames
         // after the current frame are in the cache. They will be used for
         // pattern guidance.
         if (guide != GUIDE_NONE)
         {
+                aprintf("Loop starting at %d +1, cycle=%d\n",frame,cycle);
                 for (y = frame + 1; y <= frame + cycle + 1; y++)
                 {
                         if (lastFrame==true ) break;
@@ -191,7 +204,7 @@
                                         prpU = (unsigned char *) lp->GetReadPtr(PLANAR_U);
                                         prpV = (unsigned char *) lp->GetReadPtr(PLANAR_V);
                                 }
-                                CalculateMetrics(y, crp, crpU, crpV, prp, prpU, prpV);
+                                CalculateMetrics(y, lc,lp); //crp, crpU, crpV, prp, prpU, prpV);
                         }
                 }
         }
@@ -204,65 +217,15 @@
         inpattern = false;
         vthresh = vthresh_saved;
         back = back_saved;
-#if 0
-        overrides_p = overrides;
-        override = false;
-        if (overrides_p != NULL)
-        {
-                while (*overrides_p < 0xffffffff)
-                {
-                        // If the frame is in range...
-                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)))
-                        {
-                                // and it's a single specifier. 
-                                if (*(overrides_p+3) == 'p' || *(overrides_p+3) == 'c' || *(overrides_p+3) == 'n')
-                                {
-                                        // Get the match specifier and stop parsing.
-                                        switch(*(overrides_p+3))
-                                        {
-                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; found = true; break;
-                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; found = true; break;
-                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; found = true; break;
-                                        }
-                                }
-                                else if (*(overrides_p+3) == 'b')
-                                {
-                                        back = *(overrides_p+2);
-                                }
-                                else if (*(overrides_p+3) == 'm')
-                                {
-                                        // It's a multiple match specifier.
-                                        found = true;
-                                        // Get the pointer to the specifier string.
-                                        unsigned int *x = (unsigned int *) *(overrides_p+2);
-                                        // Get the index into the specification string.
-                                        // Remember, the count is first followed by the specifiers.
-                                        int ndx = ((frame - *overrides_p) % *x);
-                                        // Point to the specifier string.
-                                        x++;
-                                        // Load the specifier for this frame and stop parsing.
-                                        switch(x[ndx])
-                                        {
-                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; break;
-                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; break;
-                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; break;
-                                        }
-                                }
-                        }
-                        // Next override line.
-                        overrides_p += 4;
-                }
-        }
-#endif
         // Get the metrics for the current-previous (p), current-current (c), and current-next (n) match candidates.
         if (CacheQuery(frame, &p, &pblock, &c, &cblock) == false)
         {
-                CalculateMetrics(frame, fcrp, fcrpU, fcrpV, fprp, fprpU, fprpV);
+                CalculateMetrics(frame, fc, fp); //fcrp, fcrpU, fcrpV, fprp, fprpU, fprpV);
                 CacheQuery(frame, &p, &pblock, &c, &cblock);
         }
         if (CacheQuery(nframe, &np, &npblock, &nc, &ncblock) == false)
         {
-                CalculateMetrics(nframe, fnrp, fnrpU, fnrpV, fcrp, fcrpU, fcrpV);
+                CalculateMetrics(nframe, fn,fc); //fnrp, fnrpU, fnrpV, fcrp, fcrpU, fcrpV);
                 CacheQuery(nframe, &np, &npblock, &nc, &ncblock);
         }
 
@@ -375,25 +338,6 @@
         }
 
         // Check for overrides of vthresh.
-#if 0
-        overrides_p = overrides;
-        if (overrides_p != NULL)
-        {
-                while (*overrides_p < 0xffffffff)
-                {
-                        // If the frame is in range...
-                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)))
-                        {
-                                if (*(overrides_p+3) == 'v')
-                                {
-                                        vthresh = *(overrides_p+2);
-                                }
-                        }
-                        // Next override line.
-                        overrides_p += 4;
-                }
-        }
-#endif
         // Check the match for progressive versus interlaced.
         if (post != POST_NONE)
         {
@@ -506,30 +450,6 @@
         if (guide != GUIDE_NONE) PutChosen(frame, chosen);
 
         /* Check for manual overrides of the deinterlacing. */
-#if 0
-        overrides_p = overrides;
-        force = 0;
-        if (overrides_p != NULL)
-        {
-                while (*overrides_p < 0xffffffff)
-                {
-                        // Is the frame in range...
-                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)) &&
-                                // and is it a single specifier...
-                                (*(overrides_p+2) == 0) &&
-                                // and is it a deinterlacing specifier?
-                                (*(overrides_p+3) == '+' || *(overrides_p+3) == '-'))
-                        {
-                                // Yes, load the specifier and stop parsing.
-                                overrides_p += 3;
-                                force = *overrides_p;
-                                break;
-                        }
-                        // Next specification record.
-                        overrides_p += 4;
-                }
-        }
-#endif
         // Do postprocessing if enabled and required for this frame.
         if (post == POST_NONE || post == POST_METRICS)
         {

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	2011-07-10 14:31:22 UTC (rev 7310)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	2011-07-10 14:31:24 UTC (rev 7311)
@@ -69,6 +69,17 @@
         cache[f].chosen = 0xff;
 }
 /**
+    \fn CachePurge
+*/
+bool Telecide::CachePurge(void)
+{
+        for (int i = 0; i < CACHE_SIZE; i++)
+		{
+			cache[i].frame = 0xffffffff;
+			cache[i].chosen = 0xff;
+		}
+}
+/**
     \fn CacheQuery
 */
 bool Telecide::CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
@@ -465,12 +476,13 @@
 #define chroma  configuration.chroma
 #define post    configuration.post
 
+#define GetPlane GetReadPtr
 
-void Telecide::CalculateMetrics(int frame, 
-                                unsigned char *fcrp,  unsigned char *fcrpU, 
-                                unsigned char *fcrpV, unsigned char *fprp, 
-                                unsigned char *fprpU, unsigned char *fprpV)
+void Telecide::CalculateMetrics(int frame, ADMImage *fcurrent, ADMImage *fprevious)
 {
+//int frame, unsigned char *fcrp, unsigned char *fcrpU, unsigned char *fcrpV,
+//									unsigned char *fprp, unsigned char *fprpU, unsigned char *fprpV,
+
         int x, y, p, c, tmp1, tmp2, skip;
         bool vc;
         unsigned char *currbot0, *currbot2, *prevbot0, *prevbot2;
@@ -494,16 +506,44 @@
         }
 
         /* Find the best field match. Subsample the frames for speed. */
-        currbot0  = fcrp + pitch;
-        currbot2  = fcrp + 3 * pitch;
+        uint32_t cpitch=fcurrent->GetPitch(PLANAR_Y);        
+        uint32_t ppitch=fprevious->GetPitch(PLANAR_Y);
+        ADM_assert(cpitch==ppitch)
+
+        
+        uint32_t cpitchu=fcurrent->GetPitch(PLANAR_U);
+        uint32_t cpitchv=fcurrent->GetPitch(PLANAR_V);
+
+        ADM_assert(cpitchu==fprevious->GetPitch(PLANAR_U));
+        ADM_assert(cpitchv==fprevious->GetPitch(PLANAR_V));
+        
+        ADM_assert(cpitchu==cpitchv);
+            
+        uint32_t cpitchtimes4=cpitch<<2;
+        
+        
+        uint8_t  *fcrp=fcurrent->GetPlane(PLANAR_Y);
+        uint8_t  *fprp=fprevious->GetPlane(PLANAR_Y);
+
+        uint8_t *fcrpU=fcurrent->GetPlane(PLANAR_U);
+        uint8_t *fcrpV=fcurrent->GetPlane(PLANAR_V);
+
+        uint8_t *fprpU=fprevious->GetPlane(PLANAR_U);
+        uint8_t *fprpV=fprevious->GetPlane(PLANAR_V);
+
+        uint32_t w=info.width;
+        uint32_t h=info.height;
+
+        currbot0  = fcrp + cpitch;
+        currbot2  = fcrp + 3 * cpitch;
         currtop0 = fcrp;
-        currtop2 = fcrp + 2 * pitch;
-        currtop4 = fcrp + 4 * pitch;
-        prevbot0  = fprp + pitch;
-        prevbot2  = fprp + 3 * pitch;
+        currtop2 = fcrp + 2 * cpitch;
+        currtop4 = fcrp + 4 * cpitch;
+        prevbot0  = fprp + ppitch;
+        prevbot2  = fprp + 3 * ppitch;
         prevtop0 = fprp;
-        prevtop2 = fprp + 2 * pitch;
-        prevtop4 = fprp + 4 * pitch;
+        prevtop2 = fprp + 2 * ppitch;
+        prevtop4 = fprp + 4 * ppitch;
         if (tff == true)
         {
                 a0 = prevbot0;
@@ -583,16 +623,16 @@
                                 if (!(x&3)) x += 4;
                         }
                 }
-                currbot0 += pitchtimes4;
-                currbot2 += pitchtimes4;
-                currtop0 += pitchtimes4;
-                currtop2 += pitchtimes4;
-                currtop4 += pitchtimes4;
-                a0               += pitchtimes4;
-                a2               += pitchtimes4;
-                b0               += pitchtimes4;
-                b2               += pitchtimes4;
-                b4               += pitchtimes4;
+                currbot0 += cpitchtimes4;
+                currbot2 += cpitchtimes4;
+                currtop0 += cpitchtimes4;
+                currtop2 += cpitchtimes4;
+                currtop4 += cpitchtimes4;
+                a0               += cpitchtimes4;
+                a2               += cpitchtimes4;
+                b0               += cpitchtimes4;
+                b2               += cpitchtimes4;
+                b4               += cpitchtimes4;
         }
 
        // if (vi.IsYV12() && chroma == true)
@@ -605,29 +645,29 @@
                         // Do the same for the U plane.
                         if (z == 0)
                         {
-                                currbot0  = fcrpU + pitchover2;
-                                currbot2  = fcrpU + 3 * pitchover2;
+                                currbot0  = fcrpU + cpitchu;
+                                currbot2  = fcrpU + 3 * cpitchu;
                                 currtop0 = fcrpU;
-                                currtop2 = fcrpU + 2 * pitchover2;
-                                currtop4 = fcrpU + 4 * pitchover2;
-                                prevbot0  = fprpU + pitchover2;
-                                prevbot2  = fprpU + 3 * pitchover2;
+                                currtop2 = fcrpU + 2 * cpitchu;
+                                currtop4 = fcrpU + 4 * cpitchu;
+                                prevbot0  = fprpU + cpitchu;
+                                prevbot2  = fprpU + 3 * cpitchu;
                                 prevtop0 = fprpU;
-                                prevtop2 = fprpU + 2 * pitchover2;
-                                prevtop4 = fprpU + 4 * pitchover2;
+                                prevtop2 = fprpU + 2 * cpitchu;
+                                prevtop4 = fprpU + 4 * cpitchu;
                         }
                         else
                         {
-                                currbot0  = fcrpV + pitchover2;
-                                currbot2  = fcrpV + 3 * pitchover2;
+                                currbot0  = fcrpV + cpitchv;
+                                currbot2  = fcrpV + 3 * cpitchv;
                                 currtop0 = fcrpV;
-                                currtop2 = fcrpV + 2 * pitchover2;
-                                currtop4 = fcrpV + 4 * pitchover2;
-                                prevbot0  = fprpV + pitchover2;
-                                prevbot2  = fprpV + 3 * pitchover2;
+                                currtop2 = fcrpV + 2 * cpitchv;
+                                currtop4 = fcrpV + 4 * cpitchv;
+                                prevbot0  = fprpV + cpitchv;
+                                prevbot2  = fprpV + 3 * cpitchv;
                                 prevtop0 = fprpV;
-                                prevtop2 = fprpV + 2 * pitchover2;
-                                prevtop4 = fprpV + 4 * pitchover2;
+                                prevtop2 = fprpV + 2 * cpitchv;
+                                prevtop4 = fprpV + 4 * cpitchv;
                         }
                         if (tff == true)
                         {
@@ -646,12 +686,12 @@
                                 b4 = prevtop4;
                         }
 
-                        for (y = 0, index = 0; y < hover2 - 4; y+=4)
+                        for (y = 0, index = 0; y < h/2 - 4; y+=4)
                         {
                                 /* Exclusion band. Good for ignoring subtitles. */
                                 if (y0 == y1 || y < y0/2 || y > y1/2)
                                 {
-                                        for (x = 0; x < wover2;)
+                                        for (x = 0; x < w/2;)
                                         {
                                                 if (1) //vi.IsYV12())
                                                         index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
@@ -702,16 +742,16 @@
                                                 if (!(x&3)) x += 4;
                                         }
                                 }
-                                currbot0 += 4*pitchover2;
-                                currbot2 += 4*pitchover2;
-                                currtop0 += 4*pitchover2;
-                                currtop2 += 4*pitchover2;
-                                currtop4 += 4*pitchover2;
-                                a0               += 4*pitchover2;
-                                a2               += 4*pitchover2;
-                                b0               += 4*pitchover2;
-                                b2               += 4*pitchover2;
-                                b4               += 4*pitchover2;
+                                currbot0 += 4*cpitchv;
+                                currbot2 += 4*cpitchv;
+                                currtop0 += 4*cpitchv;
+                                currtop2 += 4*cpitchv;
+                                currtop4 += 4*cpitchv;
+                                a0               += 4*cpitchv;
+                                a2               += 4*cpitchv;
+                                b0               += 4*cpitchv;
+                                b2               += 4*cpitchv;
+                                b4               += 4*cpitchv;
                         }
                 }
         }



From mean at mail.berlios.de  Sun Jul 10 16:31:25 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 10 Jul 2011 16:31:25 +0200
Subject: [Avidemux-svn-commit] r7312 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide
Message-ID: <20110710143126.0AD174813BB@sheep.berlios.de>

Author: mean
Date: 2011-07-10 16:31:25 +0200 (Sun, 10 Jul 2011)
New Revision: 7312

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec_desc.cpp
Log:
[telecide] Add generated files

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec.conf	2011-07-10 14:31:25 UTC (rev 7312)
@@ -0,0 +1,20 @@
+teleCide{
+uint32_t:order;           ///* Field Order 0 BFF, 1TFF */
+uint32_t:back;            // Try backward field :0 Never, 1 when bad, 2 always tried MUST Have post !=0
+uint32_t:back_saved;
+uint32_t:guide;          // (strategy) See GUIDE_xx 0 / NONE - 1 GUIDE_32/ivtc-2 GUIDE 22/PAL-3 PAL/NTSC
+float	:gthresh;        // noise threhold
+uint32_t:post;            // See POST_XX
+bool:chroma;          // True/false Use chroma to decide
+float 	:vthresh;         // 
+float	:vthresh_saved;
+float 	:bthresh;         //
+float 	:dthresh;         // Direct Threshold
+bool:blend;           // Blend or interpolate (blend=1/interpolate =0;
+uint32_t:nt;
+uint32_t:y0;
+uint32_t:y1;
+uint32_t:hints;           // ignore
+bool:show;            // Toggle
+bool:debug;           // Toggle
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec.h	2011-07-10 14:31:25 UTC (rev 7312)
@@ -0,0 +1,24 @@
+// automatically generated by admSerialization.py do not edit
+#ifndef ADM_teleCide_CONF_H
+#define ADM_teleCide_CONF_H
+typedef struct {
+uint32_t order;
+uint32_t back;
+uint32_t back_saved;
+uint32_t guide;
+float gthresh;
+uint32_t post;
+bool chroma;
+float vthresh;
+float vthresh_saved;
+float bthresh;
+float dthresh;
+bool blend;
+uint32_t nt;
+uint32_t y0;
+uint32_t y1;
+uint32_t hints;
+bool show;
+bool debug;
+}teleCide;
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/telec_desc.cpp	2011-07-10 14:31:25 UTC (rev 7312)
@@ -0,0 +1,22 @@
+// automatically generated by admSerialization.py, do not edit!
+extern const ADM_paramList teleCide_param[]={
+ {"order",offsetof(teleCide,order),"uint32_t",ADM_param_uint32_t},
+ {"back",offsetof(teleCide,back),"uint32_t",ADM_param_uint32_t},
+ {"back_saved",offsetof(teleCide,back_saved),"uint32_t",ADM_param_uint32_t},
+ {"guide",offsetof(teleCide,guide),"uint32_t",ADM_param_uint32_t},
+ {"gthresh",offsetof(teleCide,gthresh),"float",ADM_param_float},
+ {"post",offsetof(teleCide,post),"uint32_t",ADM_param_uint32_t},
+ {"chroma",offsetof(teleCide,chroma),"bool",ADM_param_bool},
+ {"vthresh",offsetof(teleCide,vthresh),"float",ADM_param_float},
+ {"vthresh_saved",offsetof(teleCide,vthresh_saved),"float",ADM_param_float},
+ {"bthresh",offsetof(teleCide,bthresh),"float",ADM_param_float},
+ {"dthresh",offsetof(teleCide,dthresh),"float",ADM_param_float},
+ {"blend",offsetof(teleCide,blend),"bool",ADM_param_bool},
+ {"nt",offsetof(teleCide,nt),"uint32_t",ADM_param_uint32_t},
+ {"y0",offsetof(teleCide,y0),"uint32_t",ADM_param_uint32_t},
+ {"y1",offsetof(teleCide,y1),"uint32_t",ADM_param_uint32_t},
+ {"hints",offsetof(teleCide,hints),"uint32_t",ADM_param_uint32_t},
+ {"show",offsetof(teleCide,show),"bool",ADM_param_bool},
+ {"debug",offsetof(teleCide,debug),"bool",ADM_param_bool},
+{NULL,0,NULL}
+};



From mean at mail.berlios.de  Sun Jul 10 16:31:27 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 10 Jul 2011 16:31:27 +0200
Subject: [Avidemux-svn-commit] r7313 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreImage/include
	avidemux_plugins/ADM_videoFilters6/telecide
Message-ID: <20110710143127.6DC284813BB@sheep.berlios.de>

Author: mean
Date: 2011-07-10 16:31:27 +0200 (Sun, 10 Jul 2011)
New Revision: 7313

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
Log:
[telecide] Cleaning up code

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2011-07-10 14:31:25 UTC (rev 7312)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2011-07-10 14:31:27 UTC (rev 7313)
@@ -110,6 +110,7 @@
         int             _qStride;
         int             _qSize;
         int             GetHeight(ADM_PLANE plane) {if(plane==PLANAR_Y) return _height; return _height/2;}
+        int             GetWidth(ADM_PLANE plane) {if(plane==PLANAR_Y) return _width; return _width/2;}
         bool            GetPitches(uint32_t *pitches) {pitches[0]=GetPitch(PLANAR_Y);
                                                        pitches[1]=GetPitch(PLANAR_U);
                                                        pitches[2]=GetPitch(PLANAR_V);return true;}

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-10 14:31:25 UTC (rev 7312)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-10 14:31:27 UTC (rev 7313)
@@ -68,42 +68,58 @@
 #define y0      _param->y0
 #define y1      _param->y1
 
-
 /**
-    \fn getNextFrame
+
 */
-bool Telecide::getNextFrame(uint32_t *frameNumber,ADMImage *output_image)
+static bool copyField(ADMImage *target, ADMImage *source, bool top)
 {
-ADMImage *fc;
-uint8_t *fcrp;
-uint8_t *fcrpU,*fcrpV;
+    for(int i=0;i<3;i++)
+    {
+        ADM_PLANE plane=(ADM_PLANE )i;
+        uint8_t *dest=target->GetWritePtr(plane);
+        uint8_t *src=source->GetReadPtr(plane);
 
-uint32_t pframe,nframe;
+        uint32_t sPitch=source->GetPitch(plane);
+        uint32_t dPitch=target->GetPitch(plane);
+        
+        if(false==top)
+        {
+            dest=dest+dPitch;
+            src=src+sPitch;
+        }
 
-ADMImage *fp;
-uint8_t *fprp;
-uint8_t *fprpU,*fprpV;
 
-ADMImage *fn;
-uint8_t *fnrp;
-uint8_t *fnrpU,*fnrpV;
+        uint32_t h=target->GetHeight(plane);
+        uint32_t w=target->GetWidth(plane);
 
-ADMImage *lc;
-uint8_t *crp;
-uint8_t *crpU,*crpV;
+        // copy one line out of two
+        h>>=1;
+        dPitch*=2;
+        sPitch*=2;
 
-ADMImage *lp;
-uint8_t *prp;
-uint8_t *prpU,*prpV;
+        BitBlit(dest,dPitch,src,sPitch,w,h);
 
-ADMImage *dst;
+    }
+    return true;
+}
+
+/**
+    \fn getNextFrame
+*/
+bool Telecide::getNextFrame(uint32_t *frameNumber,ADMImage *output_image)
+{
+uint32_t pframe,nframe;
+
+ADMImage *fc=NULL;
+ADMImage *fp=NULL;
+ADMImage *fn=NULL;
+ADMImage *dst=NULL;
 uint8_t *dstp;
-uint8_t *dstpU,*dstpV;
 
-ADMImage *final;
+ADMImage *final=NULL;
 uint8_t *finalp;
-uint8_t *finalpU,*finalpV;
 
+
 teleCide *_param=&configuration;
 
 
@@ -122,23 +138,11 @@
             return false;
         }
         nextFrame++;
-        output_image->copyInfo(fc);
-        fcrp = (unsigned char *) fc->GetReadPtr(PLANAR_Y);
-        //if (vi.IsYV12())
-        {
-                fcrpU = (unsigned char *) fc->GetReadPtr(PLANAR_U);
-                fcrpV = (unsigned char *) fc->GetReadPtr(PLANAR_V);
-        }
+        output_image->copyInfo(fc); // copy timing information...
 
         // Get the previous frame.
         pframe = frame == 0 ? 0 : frame - 1;
         GETFRAME(pframe, fp);
-        fprp = (unsigned char *) fp->GetReadPtr(PLANAR_Y);
-        //if (vi.IsYV12())
-        {
-                fprpU = (unsigned char *) fp->GetReadPtr(PLANAR_U);
-                fprpV = (unsigned char *) fp->GetReadPtr(PLANAR_V);
-        }
 
         // Get the next frame metrics if we might need them.
         nframe = frame + 1;
@@ -150,28 +154,14 @@
             ADM_assert(fn);
             lastFrame=true;
         }
-        fnrp = (unsigned char *) fn->GetReadPtr(PLANAR_Y);
-        //if (vi.IsYV12())
-        {
-                fnrpU = (unsigned char *) fn->GetReadPtr(PLANAR_U);
-                fnrpV = (unsigned char *) fn->GetReadPtr(PLANAR_V);
-        }
 
         int pitch = fc->GetPitch(PLANAR_Y);
-        int pitchover2 = pitch >> 1;
-        int pitchtimes4 = pitch << 2;
+        
+        
         int w = info.width;
         int h = info.height; 
         int hover2 = h >>1;
         int wover2 = w >>1;
-/*
-        if (vi.IsYUY2() && ((w/2) & 1))
-                env->ThrowError("Telecide: width must be a multiple of 2; use Crop");
-        if (vi.IsYV12() && (w & 1))
-                env->ThrowError("Telecide: width must be a multiple of 2; use Crop");
-        if (h & 1)
-                env->ThrowError("Telecide: height must be a multiple of 2; use Crop");
-*/
 
         int hplus1over2 = (h+1)/2;
         int hminus2= h - 2;
@@ -190,20 +180,10 @@
                         if (lastFrame==true ) break;
                         if (CacheQuery(y, &p, &pblock, &c, &cblock) == false)
                         {
+                                ADMImage *lc,*lp;
+
                                 GETFRAME(y, lc);
-                                crp = (unsigned char *) lc->GetReadPtr(PLANAR_Y);
-                                //if (vi.IsYV12())
-                                {
-                                        crpU = (unsigned char *) lc->GetReadPtr(PLANAR_U);
-                                        crpV = (unsigned char *) lc->GetReadPtr(PLANAR_V);
-                                }
                                 GETFRAME(y == 0 ? 1 : y - 1, lp);
-                                prp = (unsigned char *) lp->GetReadPtr(PLANAR_Y);
-                                //if (vi.IsYV12())
-                                {
-                                        prpU = (unsigned char *) lp->GetReadPtr(PLANAR_U);
-                                        prpV = (unsigned char *) lp->GetReadPtr(PLANAR_V);
-                                }
                                 CalculateMetrics(y, lc,lp); //crp, crpU, crpV, prp, prpU, prpV);
                         }
                 }
@@ -375,77 +355,39 @@
 
         // Assemble and output the reconstructed frame according to the final match.
         dstp = dst->GetWritePtr(PLANAR_Y);
-//    if (vi.IsYV12())
-        {
-                dstpU = dst->GetWritePtr(PLANAR_U);
-                dstpV = dst->GetWritePtr(PLANAR_V);
-        }
         if (chosen == N)
         {
                 // The best match was with the next frame.
                 if (tff == true)
                 {
-                        BitBlt(dstp, 2 * dpitch, fnrp, 2 * pitch, w, hover2);
-                        BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
-                        //if (vi.IsYV12())
-                        {
-                                BitBlt(dstpU, dpitch, fnrpU, pitch, w/2, h/4);
-                                BitBlt(dstpV, dpitch, fnrpV, pitch, w/2, h/4);
-                                BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
-                                BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
-                        }
+                        copyField(dst, fn,true);
+                        copyField(dst, fc,false);
                 }
                 else
                 {
-                        BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
-                        BitBlt(dstp + dpitch, 2 * dpitch, fnrp + pitch, 2 * pitch, w, hover2);
-                        //if (vi.IsYV12())
-                        {
-                                BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
-                                BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
-                                BitBlt(dstpU + dpitch/2, dpitch, fnrpU + pitch/2, pitch, w/2, h/4);
-                                BitBlt(dstpV + dpitch/2, dpitch, fnrpV + pitch/2, pitch, w/2, h/4);
-                        }
+                        copyField(dst, fc,true);
+                        copyField(dst, fn,false);
                 }
         }
         else if (chosen == C)
         {
                 // The best match was with the current frame.
-                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
-                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
-                //if (vi.IsYV12())
-                {
-                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
-                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
-                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
-                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
-                }
+                copyField(dst, fc,true);
+                copyField(dst, fc,false);
+
         }
         else if (tff == false)
         {
                 // The best match was with the previous frame.
-                BitBlt(dstp, 2 * dpitch, fprp, 2 * pitch, w, hplus1over2);
-                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
-               // if (vi.IsYV12())
-                {
-                        BitBlt(dstpU, dpitch, fprpU, pitch, w/2, h/4);
-                        BitBlt(dstpV, dpitch, fprpV, pitch, w/2, h/4);
-                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
-                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
-                }
+                copyField(dst, fp,true);
+                copyField(dst, fc,false);
         }
         else
         {
                 // The best match was with the previous frame.
-                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
-                BitBlt(dstp + dpitch, 2 * dpitch, fprp + pitch, 2 * pitch, w, hover2);
-               // if (vi.IsYV12())
-                {
-                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
-                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
-                        BitBlt(dstpU + dpitch/2, dpitch, fprpU + pitch/2, pitch, w/2, h/4);
-                        BitBlt(dstpV + dpitch/2, dpitch, fprpV + pitch/2, pitch, w/2, h/4);
-                }
+                copyField(dst, fc,true);
+                copyField(dst, fp,false);
+
         }
         if (guide != GUIDE_NONE) PutChosen(frame, chosen);
 



From mean at mail.berlios.de  Sun Jul 10 16:31:28 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 10 Jul 2011 16:31:28 +0200
Subject: [Avidemux-svn-commit] r7314 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide
Message-ID: <20110710143128.A7EDE4813BB@sheep.berlios.de>

Author: mean
Date: 2011-07-10 16:31:28 +0200 (Sun, 10 Jul 2011)
New Revision: 7314

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
Log:
[telecide] Simplify, begin to refactor. It is incorrect.

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	2011-07-10 14:31:27 UTC (rev 7313)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	2011-07-10 14:31:28 UTC (rev 7314)
@@ -148,4 +148,9 @@
 	struct PREDICTION *PredictSoftYUY2(int frame);
 
 	void WriteHints(unsigned char *dst, bool film, bool inpattern);
+
+    bool doInterpolate(ADMImage *dst, ADM_PLANE plane);
+    bool blendPlane(ADMImage *dst, ADMImage *src,ADM_PLANE plane);
+
+
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-10 14:31:27 UTC (rev 7313)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-10 14:31:28 UTC (rev 7314)
@@ -69,7 +69,7 @@
 #define y1      _param->y1
 
 /**
-
+    \fn copyField
 */
 static bool copyField(ADMImage *target, ADMImage *source, bool top)
 {
@@ -407,215 +407,21 @@
 
                 if (blend == true)
                 {
-                        // Blend mode.
-                        final = output_image; //env->NewVideoFrame(vi);
-                        // Do first and last lines.
-                        finalp = final->GetWritePtr(PLANAR_Y);
-                        dstp = dst->GetWritePtr(PLANAR_Y);
-                        dstpn = dstp + dpitch;
-                        for (x = 0; x < w; x++)
-                        {
-                                finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
-                        }
-                        finalp = final->GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
-                        dstp = dst->GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
-                        dstpp = dstp - dpitch;
-                        for (x = 0; x < w; x++)
-                        {
-                                finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
-                        }
-                        // Now do the rest.
-                        dstp = dst->GetWritePtr(PLANAR_Y) + dpitch;
-                        dstpp = dstp - dpitch;
-                        dstpn = dstp + dpitch;
-                        finalp = final->GetWritePtr(PLANAR_Y) + dpitch;
-                        for (y = 1; y < h - 1; y++)
-                        {
-                                for (x = 0; x < w; x++)
-                                {
-                                        v1 = (int)(dstp[x] - dthresh);
-                                        if (v1 < 0) v1 = 0; 
-                                        v2 = (int) (dstp[x] + dthresh);
-                                        if (v2 > 235) v2 = 235; 
-                                        if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
-                                        {
-                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                                {
-                                                        if (0) //(vi.IsYUY2())
-                                                        {
-                                                                if (x & 1) finalp[x] = 128;
-                                                                else finalp[x] = 235;
-                                                        }
-                                                        else
-                                                        {
-                                                                finalp[x] = 235;
-                                                        }
-                                                }
-                                                else
-                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) >> 2;
-                                        }
-                                        else finalp[x] = dstp[x];
-                                }
-                                finalp += dpitch;
-                                dstp += dpitch;
-                                dstpp += dpitch;
-                                dstpn += dpitch;
-                        }
-
-                      //  if (vi.IsYV12())
-                        {
-                                // Chroma planes.
-                                for (z = 0; z < 2; z++)
-                                {
-                                        if (z == 0)
-                                        {
-                                                // Do first and last lines.
-                                                finalp = final->GetWritePtr(PLANAR_U);
-                                                dstp = dst->GetWritePtr(PLANAR_U);
-                                                dstpn = dstp + dpitch/2;
-                                                for (x = 0; x < wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
-                                                }
-                                                finalp = final->GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
-                                                dstp = dst->GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
-                                                dstpp = dstp - dpitch/2;
-                                                for (x = 0; x < wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
-                                                }
-                                                // Now do the rest.
-                                                finalp = final->GetWritePtr(PLANAR_U) + dpitch/2;
-                                                dstp = dst->GetWritePtr(PLANAR_U) + dpitch/2;
-                                        }
-                                        else
-                                        {
-                                                // Do first and last lines.
-                                                finalp = final->GetWritePtr(PLANAR_V);
-                                                dstp = dst->GetWritePtr(PLANAR_V);
-                                                dstpn = dstp + dpitch/2;
-                                                for (x = 0; x < wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
-                                                }
-                                                finalp = final->GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
-                                                dstp = dst->GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
-                                                dstpp = dstp - dpitch/2;
-                                                for (x = 0; x < wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
-                                                }
-                                                // Now do the rest.
-                                                finalp = final->GetWritePtr(PLANAR_V) + dpitch/2;
-                                                dstp = dst->GetWritePtr(PLANAR_V) + dpitch/2;
-                                        }
-                                        dstpp = dstp - dpitch/2;
-                                        dstpn = dstp + dpitch/2;
-                                        for (y = 1; y < hover2 - 1; y++)
-                                        {
-                                                for (x = 0; x < wover2; x++)
-                                                {
-                                                        v1 = (int)( dstp[x] - dthresh);
-                                                        if (v1 < 0) v1 = 0; 
-                                                        v2 = (int)( dstp[x] + dthresh);
-                                                        if (v2 > 235) v2 = 235; 
-                                                        if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
-                                                        {
-                                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                                                {
-                                                                        finalp[x] = 128;
-                                                                }
-                                                                else
-                                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) >> 2;
-                                                        }
-                                                        else finalp[x] = dstp[x];
-                                                }
-                                                finalp += dpitch/2;
-                                                dstp += dpitch/2;
-                                                dstpp += dpitch/2;
-                                                dstpn += dpitch/2;
-                                        }
-                                }
-                        }
-                        if (show == true) Show(final, frame);
+                        blendPlane(final,dst,PLANAR_Y);
+                        blendPlane(final,dst,PLANAR_U);
+                        blendPlane(final,dst,PLANAR_V);
+                       
+                        if (show == true)  Show(final, frame);
                         if (debug == true) Debug(frame);
                         if (hints == true) WriteHints(final->GetWritePtr(PLANAR_Y), film, inpattern);
                        // return final;
                         vidCache->unlockAll();
                         return 1;
                 }
-
-                // Interpolate mode.
-                // Luma plane.
-                dstp = dst->GetWritePtr(PLANAR_Y) + dpitch;
-                dstpp = dstp - dpitch;
-                dstpn = dstp + dpitch;
-                for (y = 1; y < h - 1; y+=2)
-                {
-                        for (x = 0; x < w; x++)
-                        {
-                                v1 = (int) (dstp[x] - dthresh);
-                                if (v1 < 0) v1 = 0; 
-                                v2 = (int) dstp[x] + dthresh;
-                                if (v2 > 235) v2 = 235; 
-                                if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
-                                {
-                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                        {
-                                                if(0) // (vi.IsYUY2())
-                                                {
-                                                        if (x & 1) dstp[x] = 128;
-                                                        else dstp[x] = 235;
-                                                }
-                                                else
-                                                {
-                                                        dstp[x] = 235;
-                                                }
-                                        }
-                                        else
-                                                dstp[x] = (dstpp[x] + dstpn[x]) >> 1;
-                                }
-                        }
-                        dstp += 2*dpitch;
-                        dstpp += 2*dpitch;
-                        dstpn += 2*dpitch;
-                }
-
-               // if (vi.IsYV12())
-                {
-                        // Chroma planes.
-                        for (z = 0; z < 2; z++)
-                        {
-                                if (z == 0) dstp = dst->GetWritePtr(PLANAR_U) + dpitch/2;
-                                else dstp = dst->GetWritePtr(PLANAR_V) + dpitch/2;
-                                dstpp = dstp - dpitch/2;
-                                dstpn = dstp + dpitch/2;
-                                for (y = 1; y < hover2 - 1; y+=2)
-                                {
-                                        for (x = 0; x < wover2; x++)
-                                        {
-                                                v1 = (int) dstp[x] - dthresh;
-                                                if (v1 < 0) v1 = 0; 
-                                                v2 = (int) dstp[x] + dthresh;
-                                                if (v2 > 235) v2 = 235; 
-                                                if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
-                                                {
-                                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                                        {
-                                                                dstp[x] = 128;
-                                                        }
-                                                        else
-                                                                dstp[x] = (dstpp[x] + dstpn[x]) >> 1;
-                                                }
-                                        }
-                                        dstp += dpitch;
-                                        dstpp += dpitch;
-                                        dstpn += dpitch;
-                                }
-                        }
-                }
+                doInterpolate(final,PLANAR_Y);
+                doInterpolate(final,PLANAR_U);
+                doInterpolate(final,PLANAR_V);
         }
-
         if (show == true) Show(dst, frame);
         if (debug == true) Debug(frame);
         if (hints == true) WriteHints(dst->GetWritePtr(PLANAR_Y), film, inpattern);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	2011-07-10 14:31:27 UTC (rev 7313)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	2011-07-10 14:31:28 UTC (rev 7314)
@@ -1,10 +1,5 @@
 
 /***************************************************************************
-                          ADM_vidDecTelecide  -  description
-                             -------------------
-    
-    email                : fixounet at free.fr
-
     Port of Donal Graft Telecide which is (c) Donald Graft
     http://www.neuron2.net
     http://puschpull.org/avisynth/decomb_reference_manual.html
@@ -822,4 +817,123 @@
         CacheInsert(frame, p, highest_sump, c, highest_sumc);
 #endif
 }
+/**
+    \fn blendPlane
+    \brief We do it inplace
+*/
+bool Telecide::blendPlane(ADMImage *final,ADMImage *src, ADM_PLANE plane)
+{
+uint8_t *finalp=final->GetWritePtr(plane);
+uint8_t *dstp=src->GetReadPtr(plane);
+
+
+uint32_t fpitch=final->GetPitch(plane);
+uint32_t dpitch=src->GetPitch(plane);
+
+uint32_t h=final->GetHeight(plane);
+uint32_t w=final->GetWidth(plane);
+
+uint8_t *dstpn,*dstn,*dstpp;
+
+uint8_t CLAMP=235;
+
+    float dthresh=configuration.dthresh;
+    int v1,v2;
+
+    if(plane!=0) CLAMP=128;
+
+// Do first and last lines.
+
+    dstpn = dstp + dpitch;
+    for (x = 0; x < w; x++)
+    {
+            finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
+    }
+    finalp = final->GetWritePtr(plane) + (h-1)*fpitch;
+    dstp = src->GetWritePtr(plane) + (h-1)*dpitch;
+    
+    dstpp = dstp - dpitch;
+    for (x = 0; x < w; x++)
+    {
+            finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
+    }
+    // Now do the rest.
+    dstp = src->GetWritePtr(plane) + dpitch;
+    dstpp = dstp - dpitch;
+    dstpn = dstp + dpitch;
+    finalp = final->GetWritePtr(plane) + fpitch;
+    for (y = 1; y < h - 1; y++)
+    {
+            for (x = 0; x < w; x++)
+            {
+                    v1 = (int)(dstp[x] - dthresh);
+                    if (v1 < 0) v1 = 0; 
+                    v2 = (int) (dstp[x] + dthresh);
+                    if (v2 > 235) v2 = 235; 
+                    if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
+                    {
+                            if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                            {
+                                    finalp[x] = CLAMP;
+                            }
+                            else
+                                    finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) >> 2;
+                    }
+                    else finalp[x] = dstp[x];
+            }
+            finalp += fpitch;
+            dstp += dpitch;
+            dstpp += dpitch;
+            dstpn += dpitch;
+    }
+    return true;
+}
+/**
+    \fn doInterpolate
+*/
+bool Telecide::doInterpolate(ADMImage *dst, ADM_PLANE plane)
+{
+
+    // Interpolate mode.
+    // Luma plane.
+    uint32_t dpitch=dst->GetPitch(plane);
+    uint8_t *dstp = dst->GetWritePtr(plane) + dpitch;
+    uint32_t w=dst->GetWidth(plane);
+    uint32_t h=dst->GetHeight(plane);
+
+    uint8_t *dstpp = dstp - dpitch;
+    uint8_t *dstpn = dstp + dpitch;
+
+    uint8_t CLAMP=235;
+    int v1,v2;
+    if(plane!=0) CLAMP=128;
+
+    float dthresh=configuration.dthresh;
+
+    for (y = 1; y < h - 1; y+=2)
+    {
+            for (x = 0; x < w; x++)
+            {
+                    v1 = (int) (dstp[x] - dthresh);
+                    if (v1 < 0) v1 = 0; 
+                    v2 = (int) dstp[x] + dthresh;
+                    if (v2 > 235) v2 = 235; 
+                    if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
+                    {
+                            if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                            {
+                                    dstp[x] = CLAMP;
+                            }
+                            else
+                                    dstp[x] = (dstpp[x] + dstpn[x]) >> 1;
+                    }
+            }
+            dstp += 2*dpitch;
+            dstpp += 2*dpitch;
+            dstpn += 2*dpitch;
+    }
+
+    return true;
+}
+
 // EOF



From mean at mail.berlios.de  Sun Jul 10 19:17:09 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 10 Jul 2011 19:17:09 +0200
Subject: [Avidemux-svn-commit] r7315 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	. decimate
Message-ID: <20110710171710.0B6CD4813BB@sheep.berlios.de>

Author: mean
Date: 2011-07-10 19:17:09 +0200 (Sun, 10 Jul 2011)
New Revision: 7315

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec_desc.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_sse.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
Log:
[decimate] not working

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/CMakeLists.txt	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,12 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_decimate_SRCS decimate.cpp   
+                         decimate_util.cpp
+                         decimate_sse.cpp
+                        )
+
+ADD_VIDEO_FILTER(ADM_vf_decimate ${ADM_vf_decimate_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_decimate)
+INSTALL_VIDEO_FILTER(ADM_vf_decimate)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.conf	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,9 @@
+deciMate{
+uint32_t:cycle; // Integer 2..40, 5 for ivtc
+uint32_t:mode;  // 0..3 : 0 A B -> discard B if it is close to A, 1 interpolate A B C is replaced by AC, 2 : Remove longest dupe (anime), 3 : iVTC
+uint32_t:quality; //0..4 : 0 no chroma, subsampled luma, 3 : Full luma and chroma
+bool:show;        // if true display info
+bool:debug;        // if true display info
+float:threshold;  // used for mode=1 and mode=3
+float:threshold2; // when mode=2, threshold2 is the threshold to consider frame duplicate
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.h	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,13 @@
+// automatically generated by admSerialization.py do not edit
+#ifndef ADM_deciMate_CONF_H
+#define ADM_deciMate_CONF_H
+typedef struct {
+uint32_t cycle;
+uint32_t mode;
+uint32_t quality;
+bool show;
+bool debug;
+float threshold;
+float threshold2;
+}deciMate;
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec_desc.cpp	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,11 @@
+// automatically generated by admSerialization.py, do not edit!
+extern const ADM_paramList deciMate_param[]={
+ {"cycle",offsetof(deciMate,cycle),"uint32_t",ADM_param_uint32_t},
+ {"mode",offsetof(deciMate,mode),"uint32_t",ADM_param_uint32_t},
+ {"quality",offsetof(deciMate,quality),"uint32_t",ADM_param_uint32_t},
+ {"show",offsetof(deciMate,show),"bool",ADM_param_bool},
+ {"debug",offsetof(deciMate,debug),"bool",ADM_param_bool},
+ {"threshold",offsetof(deciMate,threshold),"float",ADM_param_float},
+ {"threshold2",offsetof(deciMate,threshold2),"float",ADM_param_float},
+{NULL,0,NULL}
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,821 @@
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : fixounet at free.fr
+
+    Port of Donal Graft Decimate which is (c) Donald Graft
+    http://www.neuron2.net
+    http://puschpull.org/avisynth/decomb_reference_manual.html
+
+ ***************************************************************************/
+
+/*
+	Decimate plugin for Avisynth -- performs 1-in-N
+	decimation on a stream of progressive frames, which are usually
+	obtained from the output of my Telecide plugin for Avisynth.
+	For each group of N successive frames, this filter deletes the
+	frame that is most similar to its predecessor. Thus, duplicate
+	frames coming out of Telecide can be removed using Decimate. This
+	filter adjusts the frame rate of the clip as
+	appropriate. Selection of the cycle size is selected by specifying
+	a parameter to Decimate() in the Avisynth scipt.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+	The author can be contacted at:
+	Donald Graft
+	neuron2 at attbi.com.
+*/
+
+#include "ADM_default.h"
+#include "decimate.h"
+
+
+
+
+#ifdef USE_SSE
+	#define DECIMATE_MMX_BUILD_PLANE 1
+	#define DECIMATE_MMX_BUILD	 1
+#endif
+
+#ifdef DECIMATE_MMX_BUILD_PLANE
+static void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
+			int w, int h);
+int isse_scenechange_32(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;	
+int isse_scenechange_16(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
+int isse_scenechange_8(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
+#endif
+
+
+#define OutputDebugString(x) aprintf("%s\n",x)
+//________________________________
+
+#define GETFRAME(g, fp) \
+{ \
+	int GETFRAMEf; \
+	GETFRAMEf = (g); \
+	if (GETFRAMEf < 0) GETFRAMEf = 0; \
+	if (GETFRAMEf > num_frames_hi - 1) GETFRAMEf = num_frames_hi - 1; \
+	(fp) = vidCache->getImage(GETFRAMEf); \
+}
+//________________________________
+
+
+#define aprintf(...) {}
+#include "DIA_factory.h"
+
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   Decimate,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_INTERLACING,            // Category
+                        "decimate",            // internal name (must be uniq!)
+                        "Decomb decimate",            // Display name
+                        "Donald Graft decimate. Remove duplicate after telecide." // Description
+                    );
+
+
+/**
+    \fn configure
+*/
+bool Decimate::configure(void)
+{
+	deciMate *_param=&configuration;
+#define PX(x) &(configuration.x)
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry *)
+        
+    ELEM_TYPE_FLOAT t1=(ELEM_TYPE_FLOAT)_param->threshold;
+    ELEM_TYPE_FLOAT t2=(ELEM_TYPE_FLOAT)_param->threshold2;
+
+         diaMenuEntry tMode[]={
+                             {0, QT_TR_NOOP("Discard closer"),NULL},
+                             {1, QT_TR_NOOP("Replace (interpolate)"),NULL},
+                             {2, QT_TR_NOOP("Discard longer dupe (anim?s)"),NULL},
+                             {3, QT_TR_NOOP("Pulldown dupe removal"),NULL}
+                          };
+         diaMenuEntry tQuality[]={
+                             {0, QT_TR_NOOP("Fastest (no chroma, partial luma)"),NULL},
+                             {1, QT_TR_NOOP("Fast (partial luma and chroma)"),NULL},
+                             {2, QT_TR_NOOP("Medium (full luma, no chroma)"),NULL},
+                             {3, QT_TR_NOOP("Slow (full luma and chroma)"),NULL}
+                          };
+  
+    
+    diaElemMenu menuMode(PX(mode),QT_TR_NOOP("_Mode:"), 4,tMode);
+    diaElemMenu menuQuality(PX(quality),QT_TR_NOOP("_Quality:"), 4,tQuality);
+    diaElemFloat menuThresh1(&t1,QT_TR_NOOP("_Threshold 1:"),0,100.);
+    diaElemFloat menuThresh2(&t2,QT_TR_NOOP("T_hreshold 2:"),0,100.);
+    diaElemUInteger cycle(PX(cycle),QT_TR_NOOP("C_ycle:"),2,40);
+    
+    diaElem *elems[]={&cycle,&menuMode,&menuQuality,&menuThresh1,&menuThresh2};
+    
+  if(diaFactoryRun(QT_TR_NOOP("Decomb Decimate"),5,elems))
+  {
+    _param->threshold=(double )t1;
+    _param->threshold2=(double )t2;
+    return 1; 
+  }
+  return 0;        
+}
+/**
+    \fn getConfiguration
+*/
+const char   *Decimate::getConfiguration(void)
+{
+    const char strparam[255];
+ 	snprintf(strparam,254," Decomb Decimate cycle:%d",configuration.cycle);
+    return strparam;
+}
+
+/**
+    \fn Ctor
+*/       
+Decimate::Decimate(	ADM_coreVideoFilter *in,CONFcouple *couples)      : ADM_coreVideoFilter(in,couples)
+{
+		
+		int count = 0;
+		char buf[80];
+		unsigned int *p;	
+        deciMate *_param=&configuration;
+		//		
+		// Init here
+		debug=0;
+		show=0;		
+#ifdef USE_SSE	
+		if(CpuCaps::hasSSE())
+		{
+			printf("Decimate:SSE enabled\n");
+		}
+#endif
+		if(!couples || !ADM_paramLoad(couples,deciMate_param,&configuration))
+  		{
+			_param->cycle=5;
+			_param->mode=0;
+			_param->quality=2;
+			_param->threshold=0;
+			_param->threshold2=3.0;
+		}
+		
+		ADM_assert(_param->cycle);
+		vidCache=new VideoCache(_param->cycle*2+1,in);
+		
+		if (_param->mode == 0 || _param->mode == 2 || _param->mode == 3)
+		{
+#warning make it a function
+			num_frames_hi = _info.nb_frames;
+			_info.nb_frames = _info.nb_frames * (_param->cycle - 1) / _param->cycle;
+			_info.fps1000=_info.fps1000*(_param->cycle-1);
+			_info.fps1000=(uint32_t)(_info.fps1000/_param->cycle);
+			
+		}
+		last_request = -1;
+		firsttime = true;
+		sum = (unsigned int *) ADM_alloc(MAX_BLOCKS * MAX_BLOCKS * sizeof(unsigned int));
+		ADM_assert(sum);		
+		all_video_cycle = true;
+
+		if (debug)
+		{
+			OutputDebugString( "Decimate %s by Donald Graft, Copyright 2003\n", 0); // VERSION
+		}
+	}
+}
+/**
+    \fn getCoupledConf
+*/ 
+bool         Decimate::getCoupledConf(CONFcouple **couples)
+{
+    return ADM_paramSave(couples, deciMate_param,&configuration);
+}
+/**
+    \fn dtor
+*/
+Decimate::~Decimate(void)
+{
+		if (sum != NULL) ADM_dealloc(sum);
+		if(vidCache) delete vidCache;
+
+		vidCache=NULL;
+		sum=NULL;
+}
+/**
+    \fn DrawShow
+*/
+void Decimate::DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
+						double metric, int inframe)
+{
+	char buf[80];
+	int start = (useframe / _param->cycle) * _param->cycle;
+
+	if (show == true)
+	{
+		sprintf(buf, "Decimate %s", 0); // VERSION
+		DrawString(src, 0, 0, buf);
+		sprintf(buf, "Copyright 2003 Donald Graft");
+		DrawString(src, 0, 1, buf);
+		sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
+		DrawString(src, 0, 3, buf);
+		sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
+		DrawString(src, 0, 4, buf);
+		sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
+		DrawString(src, 0, 5, buf);
+		sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
+		DrawString(src, 0, 6, buf);
+		sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
+		DrawString(src, 0, 7, buf);
+		if (all_video_cycle == false)
+		{
+			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
+			DrawString(src, 0, 8, buf);
+			if (forced == false)
+				sprintf(buf,"chose %d, dropping", dropframe);
+			else
+				sprintf(buf,"chose %d, dropping, forced!", dropframe);
+			DrawString(src, 0, 9, buf);
+		}
+		else
+		{
+			sprintf(buf,"in frm %d", inframe);
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,"chose %d, decimating all-video cycle", dropframe);
+			DrawString(src, 0, 9, buf);
+		}
+	}
+	if (debug)
+	{
+		if (!(inframe%_param->cycle))
+		{
+			sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+			OutputDebugString(buf);
+		}
+		if (all_video_cycle == false)
+		{
+			sprintf(buf,"Decimate: in frm %d useframe %d\n", inframe, useframe);
+			OutputDebugString(buf);
+			if (forced == false)
+				sprintf(buf,"Decimate: chose %d, dropping\n", dropframe);
+			else
+				sprintf(buf,"Decimate: chose %d, dropping, forced!\n", dropframe);
+			OutputDebugString(buf);
+		}
+		else
+		{
+			sprintf(buf,"Decimate: in frm %d\n", inframe);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: chose %d, decimating all-video cycle\n", dropframe);
+			OutputDebugString(buf);
+		}
+	}
+}
+//______________________________________________________________________
+uint8_t Decimate::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags)
+{
+	int dropframe, useframe, nextfrm, wY, wUV, hY, hUV, x, y, pitchY, pitchUV, dpitchY, dpitchUV;
+	ADMImage  *src, *next, *dst;
+	unsigned char *srcrpY, *nextrpY, *dstwpY;
+	unsigned char *srcrpU, *nextrpU, *dstwpU;
+	unsigned char *srcrpV, *nextrpV, *dstwpV;
+	uint32_t inframe=frame;
+	double metric;
+	char buf[255];
+
+        if(frame>= _info.nb_frames) return 0;
+	*len=(_info.width*_info.height*3)>>1;
+	num_frames_hi = _in->getInfo()->nb_frames; /* FIXME MEANX */
+	if (_param->mode == 0)
+	{
+		bool forced = false;
+		int start;
+
+		/* Normal decimation. Remove the frame most similar to its preceding frame. */
+		/* Determine the correct frame to use and get it. */
+		useframe = inframe + inframe / (_param->cycle - 1);
+		start = (useframe /  _param->cycle) * _param->cycle;
+		FindDuplicate((useframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
+		if (useframe >= dropframe) useframe++;
+		GETFRAME(useframe, src);
+		if (show == true)
+		{
+			sprintf(buf, "Decimate %s", 0);
+			DrawString(src, 0, 0, buf);
+			sprintf(buf, "Copyright 2003 Donald Graft");
+			DrawString(src, 0, 1, buf);
+			sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
+			DrawString(src, 0, 3, buf);
+			sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
+			DrawString(src, 0, 4, buf);
+			sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
+			DrawString(src, 0, 5, buf);
+			sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
+			DrawString(src, 0, 6, buf);
+			sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
+			DrawString(src, 0, 7, buf);
+			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,"dropping frm %d%s", dropframe, last_forced == true ? ", forced!" : "");
+			DrawString(src, 0, 9, buf);
+		}
+		if (debug)
+		{	
+			if (!(inframe % _param->cycle))
+			{
+				sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+				OutputDebugString(buf);
+			}
+			sprintf(buf,"Decimate: in frm %d, use frm %d\n", inframe, useframe);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: dropping frm %d%s\n", dropframe, last_forced == true ? ", forced!" : "");
+			OutputDebugString(buf);
+		}
+	    //return src;
+	        //memcpy(data,src,*len);
+
+		data->duplicate(src);
+		vidCache->unlockAll();
+		  
+		return 1;
+	}
+	else if (_param->mode == 1)
+	{
+		bool forced = false;
+		int start = (inframe / _param->cycle) * _param->cycle;
+		unsigned int hint, film = 1;
+
+		GETFRAME(inframe, src);
+	    	srcrpY = YPLANE(src); //(unsigned char *) src->GetReadPtr(PLANAR_Y);
+		if (GetHintingData(srcrpY, &hint) == false)
+		{
+			film = hint & PROGRESSIVE;
+//			if (film) OutputDebugString("film\n");
+//			else OutputDebugString("video\n");
+		}
+
+		/* Find the most similar frame as above but replace it with a blend of
+		   the preceding and following frames. */
+		num_frames_hi = _in->getInfo()->nb_frames; /* FIXME MEANX */
+		FindDuplicate((inframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
+		if (!film || inframe != dropframe || (_param->threshold && metric > _param->threshold))
+		{
+			if (show == true)
+			{
+
+				sprintf(buf, "Decimate %s", 0);
+				DrawString(src, 0, 0, buf);
+				sprintf(buf, "Copyright 2003 Donald Graft");
+				DrawString(src, 0, 1, buf);
+				sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
+				DrawString(src, 0, 3, buf);
+				sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
+				DrawString(src, 0, 4, buf);
+				sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
+				DrawString(src, 0, 5, buf);
+				sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
+				DrawString(src, 0, 6, buf);
+				sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
+				DrawString(src, 0, 7, buf);
+				sprintf(buf,"infrm %d", inframe);
+				DrawString(src, 0, 8, buf);
+				if (last_forced == false)
+					sprintf(buf,"chose %d, passing through", dropframe);
+				else
+					sprintf(buf,"chose %d, passing through, forced!", dropframe);
+				DrawString(src, 0, 9, buf);
+			}
+			if (debug)
+			{
+				if (!(inframe % _param->cycle))
+				{
+					sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
+					OutputDebugString(buf);
+					sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+					OutputDebugString(buf);
+					sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+					OutputDebugString(buf);
+					sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+					OutputDebugString(buf);
+					sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+					OutputDebugString(buf);
+				}
+				sprintf(buf,"Decimate: in frm %d\n", inframe);
+				OutputDebugString(buf);
+				if (last_forced == false)
+					sprintf(buf,"Decimate: chose %d, passing through\n", dropframe);
+				else
+					sprintf(buf,"Decimate: chose %d, passing through, forced!\n", dropframe);
+				OutputDebugString(buf);
+			}
+			//return src;
+			//memcpy(data,src,*len);
+
+			data->duplicate(src);
+			vidCache->unlockAll();
+			return 1;
+		}
+		if (inframe < _in->getInfo()->nb_frames - 1) /* FIXME MEANX*/
+			nextfrm = inframe + 1;
+		else
+			nextfrm = _in->getInfo()->nb_frames - 1;
+		if (debug)
+		{
+			if (!(inframe % _param->cycle))
+			{
+				sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+				OutputDebugString(buf);
+			}
+			sprintf(buf,"Decimate: in frm %d\n", inframe);
+			OutputDebugString(buf);
+			if (last_forced == false)
+				sprintf(buf,"Decimate: chose %d, blending %d and %d\n", dropframe, inframe, nextfrm);
+			else
+				sprintf(buf,"Decimate: chose %d, blending %d and %d, forced!\n", dropframe, inframe, nextfrm);
+			OutputDebugString(buf);
+		}
+		GETFRAME(nextfrm, next);
+		dst = data; //env->NewVideoFrame(vi);
+		pitchY = _info.width; //src->GetPitch(PLANAR_Y);
+		dpitchY = _info.width; //dst->GetPitch(PLANAR_Y);
+		wY = _info.width; //src->GetRowSize(PLANAR_Y);
+		hY = _info.height; //src->GetHeight(PLANAR_Y);
+		pitchUV = _info.width>>1;// src->GetPitch(PLANAR_V);
+		dpitchUV =_info.width>>1;// dst->GetPitch(PLANAR_V);
+		wUV = _info.width>>1;//src->GetRowSize(PLANAR_V);
+		hUV = _info.height>>1;//src->GetHeight(PLANAR_V);
+		
+		nextrpY = YPLANE(next); //next->GetReadPtr(PLANAR_Y);
+		dstwpY = YPLANE( dst); //dst->GetWritePtr(PLANAR_Y);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) 
+		{
+			isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
+		} else {
+#endif
+			for (y = 0; y < hY; y++)
+			{
+				for (x = 0; x < wY; x++)
+				{
+					dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x] ) >> 1;  
+				}
+				srcrpY += pitchY;
+				nextrpY += pitchY;
+				dstwpY += dpitchY;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		srcrpU =   UPLANE(src);//->GetReadPtr(PLANAR_U);
+		nextrpU =   UPLANE(next);//->GetReadPtr(PLANAR_U);
+		dstwpU =  UPLANE(dst);//->GetWritePtr(PLANAR_U);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) 
+		{
+			isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
+		} else {
+#endif
+			for (y = 0; y < hUV; y++)
+			{
+				for (x = 0; x < wUV; x++)
+				{
+					dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) >> 1;
+				}
+				srcrpU += pitchUV;
+				nextrpU += pitchUV;
+				dstwpU += dpitchUV;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		srcrpV =   VPLANE(src);//->GetReadPtr(PLANAR_V);
+		nextrpV =   VPLANE(next);//->GetReadPtr(PLANAR_V);
+		dstwpV =   VPLANE(dst);//->GetWritePtr(PLANAR_V);
+
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) { 
+			isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV );
+		} else {
+#endif
+			for (y = 0; y < hUV; y++)
+			{
+				for (x = 0; x < wUV; x++)
+				{
+					dstwpV[x] = ((int)srcrpV[x] + + (int)nextrpV[x]) >> 1;
+				}
+				srcrpV += pitchUV;
+				nextrpV += pitchUV;
+				dstwpV += dpitchUV;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		if (show == true)
+		{
+
+			sprintf(buf, "Decimate %s", 0);
+			DrawString(dst, 0, 0, buf);
+			sprintf(buf, "Copyright 2003 Donald Graft");
+			DrawString(dst, 0, 1, buf);
+			sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
+			DrawString(dst, 0, 3, buf);
+			sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
+			DrawString(dst, 0, 4, buf);
+			sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
+			DrawString(dst, 0, 5, buf);
+			sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
+			DrawString(dst, 0, 6, buf);
+			sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
+			DrawString(dst, 0, 7, buf);
+			sprintf(buf,"infrm %d", inframe);
+			DrawString(dst, 0, 8, buf);
+			if (last_forced == false)
+				sprintf(buf,"chose %d, blending %d and %d",dropframe, inframe, nextfrm);
+			else
+				sprintf(buf,"chose %d, blending %d and %d, forced!", dropframe, inframe, nextfrm);
+			DrawString(dst, 0, 9, buf);
+		}
+		//return dst;
+		//memcpy(data,dst,*len);
+
+		data->duplicate(dst);
+		vidCache->unlockAll();		
+		return 1;
+	}
+	else if (_param->mode == 2)
+	{
+		bool forced = false;
+
+		/* Delete the duplicate in the longest string of duplicates. */
+		useframe = inframe + inframe / (_param->cycle - 1);
+		FindDuplicate2((useframe / _param->cycle) * _param->cycle, &dropframe, &forced);
+		if (useframe >= dropframe) useframe++;
+		GETFRAME(useframe, src);
+		if (show == true)
+		{
+			int start = (useframe / _param->cycle) * _param->cycle;
+
+
+			sprintf(buf, "Decimate %s", 0);
+			DrawString(src, 0, 0, buf);
+			sprintf(buf, "Copyright 2003 Donald Graft");
+			DrawString(src, 0, 1, buf);
+			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
+			DrawString(src, 0, 3, buf);
+			sprintf(buf,"%d: %3.2f (%s)", start, showmetrics[0],
+					Dshow[0] ? "new" : "dup");
+			DrawString(src, 0, 4, buf);
+			sprintf(buf,"%d: %3.2f (%s)", start + 1, showmetrics[1],
+					Dshow[1] ? "new" : "dup");
+			DrawString(src, 0, 5, buf);
+			sprintf(buf,"%d: %3.2f (%s)", start + 2, showmetrics[2],
+					Dshow[2] ? "new" : "dup");
+			DrawString(src, 0, 6, buf);
+			sprintf(buf,"%d: %3.2f (%s)", start + 3, showmetrics[3],
+					Dshow[3] ? "new" : "dup");
+			DrawString(src, 0, 7, buf);
+			sprintf(buf,"%d: %3.2f (%s)", start + 4, showmetrics[4],
+					Dshow[4] ? "new" : "dup");
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,"Dropping frm %d%s", dropframe, last_forced == true ? " forced!" : "");
+			DrawString(src, 0, 9, buf);
+		}
+		if (debug)
+		{	
+			sprintf(buf,"Decimate: inframe %d useframe %d\n", inframe, useframe);
+			OutputDebugString(buf);
+		}
+	    //return src;
+	    	//memcpy(data,src,*len);
+
+		data->duplicate(src);
+		vidCache->unlockAll();
+		return 1;
+	}
+	else if (_param->mode == 3)
+	{
+		bool forced = false;
+
+		/* Decimate by removing a duplicate from film cycles and doing a
+		   blend rate conversion on the video cycles. */
+		if (_param->cycle != 5)//	env->ThrowError("Decimate: mode=3 requires cycle=5");
+		{
+			printf("Decimate: mode=3 requires cycle=5\n");
+			return 0;
+		}
+		useframe = inframe + inframe / (_param->cycle - 1);
+		FindDuplicate((useframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
+		/* Use hints from Telecide about film versus video. Also use the difference
+		   metric of the most similar frame in the cycle; if it exceeds threshold,
+		   assume it's a video cycle. */
+		if (!(inframe % 4))
+		{
+			all_video_cycle = false;
+			if (_param->threshold && metric > _param->threshold)
+			{
+				all_video_cycle = true;
+			}
+			if ((hints_invalid == false) &&
+				(!(hints[0] & PROGRESSIVE) ||
+				 !(hints[1] & PROGRESSIVE) ||
+				 !(hints[2] & PROGRESSIVE) ||
+				 !(hints[3] & PROGRESSIVE) ||
+				 !(hints[4] & PROGRESSIVE)))
+			{
+				all_video_cycle = true;
+			}
+		}
+		if (all_video_cycle == false)
+		{
+			/* It's film, so decimate in the normal way. */
+			if (useframe >= dropframe) useframe++;
+			GETFRAME(useframe, src);
+			DrawShow(src, useframe, forced, dropframe, metric, inframe);			
+			//memcpy(data,src,*len);
+
+			data->duplicate(src);
+		
+			vidCache->unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 0)
+		{
+			/* It's a video cycle. Output the first frame of the cycle. */
+			GETFRAME(useframe, src);
+			DrawShow(src, 0, forced, dropframe, metric, inframe);
+			//return src;
+			//memcpy(data,src,*len);
+
+			data->duplicate(src);
+		
+			vidCache->unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 3)
+		{
+			/* It's a video cycle. Output the last frame of the cycle. */
+			GETFRAME(useframe+1, src);
+			DrawShow(src, 0, forced, dropframe, metric, inframe);
+			//return src;
+			//memcpy(data,src,*len);
+
+			data->duplicate(src);
+		
+			vidCache->unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 1 || (inframe % 4) == 2)
+		{
+			/* It's a video cycle. Make blends for the remaining frames. */
+			if ((inframe % 4) == 1)
+			{
+				GETFRAME(useframe, src);
+				if (useframe < num_frames_hi - 1)
+					nextfrm = useframe + 1;
+				else
+					nextfrm = _in->getInfo()->nb_frames - 1;
+				GETFRAME(nextfrm, next);
+			}
+			else
+			{
+				GETFRAME(useframe + 1, src);
+				nextfrm = useframe;
+				GETFRAME(nextfrm, next);
+			}
+			dst = data; //env->NewVideoFrame(vi);
+			pitchY = _info.width; //src->GetPitch(PLANAR_Y);
+			dpitchY = _info.width; //dst->GetPitch(PLANAR_Y);
+			wY = _info.width; //src->GetRowSize(PLANAR_Y);
+			hY = _info.height; //src->GetHeight(PLANAR_Y);
+			pitchUV = _info.width>>1; //src->GetPitch(PLANAR_V);
+			dpitchUV =_info.width>>1; // dst->GetPitch(PLANAR_V);
+			wUV = _info.width>>1; //src->GetRowSize(PLANAR_V);
+			hUV = _info.height>>1; //src->GetHeight(PLANAR_V);
+			
+			srcrpY = YPLANE( src); //src->GetReadPtr(PLANAR_Y);
+			nextrpY = YPLANE( next); //next->GetReadPtr(PLANAR_Y);
+			dstwpY = YPLANE( dst); //dst->GetWritePtr(PLANAR_Y);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
+			} else {
+#endif
+				for (y = 0; y < hY; y++)
+				{
+					for (x = 0; x < wY; x++)
+					{
+						dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x]) >> 1;
+					}
+					srcrpY += pitchY;
+					nextrpY += pitchY;
+					dstwpY += dpitchY;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			srcrpU =   UPLANE(src);//->GetReadPtr(PLANAR_U);
+			nextrpU =  UPLANE( next);//->GetReadPtr(PLANAR_U);
+			dstwpU =   UPLANE(dst);//->GetWritePtr(PLANAR_U);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
+			} else {
+#endif
+				for (y = 0; y < hUV; y++)
+				{
+					for (x = 0; x < wUV; x++)
+					{
+						dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) >> 1;
+					}
+					srcrpU += pitchUV;
+					nextrpU += pitchUV;
+					dstwpU += dpitchUV;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			srcrpV =   VPLANE(src);//->GetReadPtr(PLANAR_V);
+			nextrpV =  VPLANE( next);//->GetReadPtr(PLANAR_V);
+			dstwpV =   VPLANE(dst);//->GetWritePtr(PLANAR_V);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV);
+			} else {
+#endif
+				for (y = 0; y < hUV; y++)
+				{
+					for (x = 0; x < wUV; x++)
+					{
+						dstwpV[x] = ((int)srcrpV[x] + (int)nextrpV[x]) >> 1;
+					}
+					srcrpV += pitchUV;
+					nextrpV += pitchUV;
+					dstwpV += dpitchUV;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			DrawShow(dst, 0, forced, dropframe, metric, inframe);
+			vidCache->unlockAll();
+			//return dst;
+			//memcpy(data,dst,*len);
+
+			data->duplicate(dst);
+			vidCache->unlockAll();		
+			return 1; // return src;			
+		}
+		//return src;
+		//memcpy(data,src,*len);
+
+                GETFRAME(useframe, src); // MEANX : not sure (jw detected a problem here)
+		data->duplicate(src);
+		vidCache->unlockAll();		
+		return 1; // return src;			
+	}
+	//env->ThrowError("Decimate: invalid mode option (0-3)");
+	printf("Decimate: invalid mode option (0-3)\n");
+	/* Avoid compiler warning. */
+	return 0;
+}
+
+bool                Decimate::goToTime(uint64_t usSeek)
+{
+    return ADM_coreVideoFilter::goToTime(usSeek);
+}
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,68 @@
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "ADM_videoFilterCache.h"
+#include "DIA_factory.h"
+
+#include "dec.h"
+
+#define PROGRESSIVE  0x00000001
+#define MAGIC_NUMBER (0xdeadbeef)
+#define IN_PATTERN   0x00000002
+
+#define MAX_CYCLE_SIZE 25
+#define MAX_BLOCKS 50
+
+#define BLKSIZE 32
+
+#define DrawString drawString
+
+
+/**
+    \class Telecide
+
+*/
+class  Decimate:public ADM_coreVideoFilter
+{
+protected:
+        deciMate           configuration;
+protected:
+        int 			num_frames_hi;
+        int last_request, last_result;
+        bool last_forced;
+        double last_metric;
+        double metrics[MAX_CYCLE_SIZE];
+        double showmetrics[MAX_CYCLE_SIZE];
+        int Dprev[MAX_CYCLE_SIZE];
+        int Dcurr[MAX_CYCLE_SIZE];
+        int Dnext[MAX_CYCLE_SIZE];
+        int Dshow[MAX_CYCLE_SIZE];
+        unsigned int hints[MAX_CYCLE_SIZE];
+        bool hints_invalid;
+        bool all_video_cycle;
+        bool firsttime;
+        int heightY, row_sizeY, pitchY;
+        int heightUV, row_sizeUV, pitchUV;
+        int pitch, row_size, height;
+        int xblocks, yblocks;
+        unsigned int *sum, div;
+        bool debug, show;
+        
+        VideoCache	*vidCache;
+public:
+                            Decimate(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                            ~Decimate();
+        bool                goToTime(uint64_t usSeek);
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+
+protected:
+        void   		DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
+		                              double metric, int inframe );
+        void   		FindDuplicate(int frame, int *chosen, double *metric, bool *forced   );
+    	void   		FindDuplicate2(int frame, int *chosen, bool *forced );
+    	void   		FindDuplicateYUY2(int frame, int *chosen, double *metric, bool *force);
+    	void   		FindDuplicate2YUY2(int frame, int *chosen, bool *forced );
+	
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_sse.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_sse.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_sse.cpp	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,177 @@
+
+#include "ADM_default.h"
+#include "decimate.h"
+
+#ifdef DECIMATE_MMX_BUILD_PLANE
+//
+//
+//
+//
+void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
+			int w, int h)
+{
+uint32_t x;
+	if (!h) return;  // Height == 0 - avoid silly crash.
+	
+	x=w>>3; // 8 pixels at a time
+	for(;x>0;x--)
+	{
+	 __asm__(
+                ADM_ALIGN16
+	 	"movq  (%1), %%mm0 \n"
+		"movq  (%2), %%mm2 \n"
+		"pavgb %%mm0,%%mm1 \n"
+		"movq  %%mm1,(%0) \n"
+
+                   : : "r" (dst), "r" (src), "r" (src_next));
+		
+		dst+=8;
+		src+=8;
+		src_next+=8;
+  	}
+    	__asm__("emms");
+  
+}
+int isse_scenechange_32(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width>>5;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    ADM_ALIGN16
+    "pxor %%mm6,%%mm6\n"
+    "pxor %%mm7,%%mm7\n"
+    ::);
+    for(uint32_t y=0;y<hp;y++)
+    {
+	for(uint32_t x=0;x<wp;x++)
+	{
+		__asm__(
+    		ADM_ALIGN16
+    		"movq (%0),%%mm0 \n"
+		"movq 8(%0),%%mm2 \n"
+		"movq (%1),%%mm1 \n"
+		"movq 8(%1),%%mm3 \n"
+		"psadbw %%mm1,%%mm0\n"
+		"psadbw %%mm3,%%mm2\n"
+		"paddd %%mm0,%%mm6 \n"
+		"paddd %%mm2,%%mm7 \n"
+		
+		"movq 16(%0),%%mm0 \n"
+		"movq 24(%0),%%mm2 \n"
+		"movq 16(%1),%%mm1 \n"
+		"movq 24(%1),%%mm3 \n"
+		"psadbw %%mm1,%%mm0\n"
+		"psadbw %%mm3,%%mm2\n"
+		"paddd %%mm0,%%mm6 \n"
+		"paddd %%mm2,%%mm7 \n"
+		
+		
+		: : "r" (c_plane) , "r" (tplane)
+		);
+		c_plane+=32;
+		tplane+=32;
+	}    
+    
+    	c_plane+=width-wp*32;
+	tplane+=width-wp*32;
+    }
+    __asm__(
+    ADM_ALIGN16
+    "paddd %%mm6,%%mm7\n"
+    "movd %%mm7,(%0)\n"
+    "emms \n"
+    : : "r" (&returnvalue)
+    );
+  
+  return returnvalue;
+}
+int isse_scenechange_16(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width>>4;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    ADM_ALIGN16
+    "pxor %%mm6,%%mm6\n"
+    "pxor %%mm7,%%mm7\n"
+    ::);
+    for(uint32_t y=0;y<hp;y++)
+    {
+	for(uint32_t x=0;x<wp;x++)
+	{
+		__asm__(
+    		ADM_ALIGN16
+    		"movq (%0),%%mm0 \n"
+		"movq 8(%0),%%mm2 \n"
+		"movq (%1),%%mm1 \n"
+		"movq 8(%1),%%mm3 \n"
+		"psadbw %%mm1,%%mm0\n"
+		"psadbw %%mm3,%%mm2\n"
+		"paddd %%mm0,%%mm6 \n"
+		"paddd %%mm2,%%mm7 \n"				
+		
+		
+		: : "r" (c_plane) , "r" (tplane)
+		);
+		c_plane+=16;
+		tplane+=16;
+	}    
+    
+    	c_plane+=width-wp*16;
+	tplane+=width-wp*16;
+    }
+    __asm__(
+    ADM_ALIGN16
+    "paddd %%mm6,%%mm7\n"
+    "movd %%mm7,(%0)\n"
+    "emms \n"
+    : : "r" (&returnvalue)
+    );
+  
+  return returnvalue;
+}
+int isse_scenechange_8(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width>>3;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    ADM_ALIGN16
+    "pxor %%mm6,%%mm6\n"
+    "pxor %%mm7,%%mm7\n"
+    ::);
+    for(uint32_t y=0;y<hp;y++)
+    {
+	for(uint32_t x=0;x<wp;x++)
+	{
+		__asm__(
+    		ADM_ALIGN16
+    		"movq (%0),%%mm0 \n"		
+		"movq (%1),%%mm1 \n"		
+		"psadbw %%mm1,%%mm0\n"		
+		"paddd %%mm0,%%mm6 \n"
+		
+		: : "r" (c_plane) , "r" (tplane)
+		);
+		c_plane+=8;
+		tplane+=8;
+	}    
+    
+    	c_plane+=width-wp*8;
+	tplane+=width-wp*8;
+    }
+    __asm__(
+    ADM_ALIGN16
+    "movd %%mm6,(%0)\n"
+    "emms \n"
+    : : "r" (&returnvalue)
+    );
+  
+  return returnvalue;
+}
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,622 @@
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : fixounet at free.fr
+
+    Port of Donal Graft Decimate which is (c) Donald Graft
+    http://www.neuron2.net
+    http://puschpull.org/avisynth/decomb_reference_manual.html
+
+ ***************************************************************************/
+
+/*
+	Decimate plugin for Avisynth -- performs 1-in-N
+	decimation on a stream of progressive frames, which are usually
+	obtained from the output of my Telecide plugin for Avisynth.
+	For each group of N successive frames, this filter deletes the
+	frame that is most similar to its predecessor. Thus, duplicate
+	frames coming out of Telecide can be removed using Decimate. This
+	filter adjusts the frame rate of the clip as
+	appropriate. Selection of the cycle size is selected by specifying
+	a parameter to Decimate() in the Avisynth scipt.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+	The author can be contacted at:
+	Donald Graft
+	neuron2 at attbi.com.
+*/
+
+#include "ADM_default.h"
+#include "decimate.h"
+
+
+/**
+    \fn FindDuplicate
+*/
+void Decimate::FindDuplicate(int frame, int *chosen, double *metric, bool *forced)
+{
+	int f;
+	ADMImage  * store[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
+	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
+	int x, y, lowest_index, div;
+	unsigned int count[MAX_CYCLE_SIZE], lowest;
+	bool found;
+	unsigned int highest_sum=0;
+
+	/* Only recalculate differences when a new set is needed. */
+	if (frame == last_request)
+	{
+		*chosen = last_result;
+		*metric = last_metric;
+		return;
+	}
+	last_request = frame;
+
+	/* Get cycle+1 frames starting at the one before the asked-for one. */
+	for (f = 0; f <= _param->cycle; f++)
+	{
+		GETFRAME(frame + f - 1, store[f]);
+		storepY[f] = YPLANE(store[f]);//->GetReadPtr(PLANAR_Y);
+		hints_invalid = GetHintingData((unsigned char *) storepY[f], &hints[f]);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
+			storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
+		}
+	}
+
+    pitchY = _info.width; //store[0]->GetPitch(PLANAR_Y);
+    row_sizeY = _info.width; //store[0]->GetRowSize(PLANAR_Y);
+    heightY = _info.height; //store[0]->GetHeight(PLANAR_Y);
+	if (_param->quality == 1 || _param->quality == 3)
+	{
+		pitchUV = _info.width>>1; //store[0]->GetPitch(PLANAR_V);
+		row_sizeUV = _info.width>>1;//store[0]->GetRowSize(PLANAR_V);
+		heightUV = _info.height>>1;//store[0]->GetHeight(PLANAR_V);
+	}
+
+	int use_quality=_param->quality;
+
+
+	switch (use_quality)
+	{
+	case 0: // subsample, luma only
+		div = (BLKSIZE * BLKSIZE / 4) * 219;
+		break;
+	case 1: // subsample, luma and chroma
+		div = (BLKSIZE * BLKSIZE / 4) * 219 + ( (BLKSIZE * BLKSIZE / 8)) * 224;
+		break;
+	case 2: // fully sample, luma only
+		div = (BLKSIZE * BLKSIZE) * 219;
+		break;
+	case 3: // fully sample, luma and chroma
+		div = (BLKSIZE * BLKSIZE) * 219 + ( BLKSIZE * BLKSIZE/2) * 224;
+		break;
+	}
+
+	xblocks = row_sizeY / BLKSIZE;
+	if (row_sizeY % BLKSIZE) xblocks++;
+	yblocks = heightY / BLKSIZE;
+	if (heightY % BLKSIZE) yblocks++;
+
+	/* Compare each frame to its predecessor. */
+	for (f = 1; f <= _param->cycle; f++)
+	{
+		prevY = storepY[f-1];
+		currY = storepY[f];
+		for (y = 0; y < yblocks; y++)
+		{
+			for (x = 0; x < xblocks; x++)
+			{
+				sum[y*xblocks+x] = 0;
+			}
+		}
+		for (y = 0; y < heightY; y++)
+		{
+			for (x = 0; x < row_sizeY;)
+			{
+				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+				x++;
+				if (_param->quality == 0 || _param->quality == 1)
+				{
+					if (!(x%4)) x += 12;
+				}
+			}
+			prevY += pitchY;
+			currY += pitchY;
+		}
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			prevU = storepU[f-1];
+			prevV = storepV[f-1];
+			currU = storepU[f];
+			currV = storepV[f];
+			for (y = 0; y < heightUV; y++)
+			{
+				for (x = 0; x < row_sizeUV;)
+				{
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+					x++;
+					if (_param->quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevU += pitchUV;
+				currU += pitchUV;
+				prevV += pitchUV;
+				currV += pitchUV;
+			}
+		}
+		highest_sum = 0;
+		for (y = 0; y < yblocks; y++)
+		{
+			for (x = 0; x < xblocks; x++)
+			{
+				if (sum[y*xblocks+x] > highest_sum)
+				{
+					highest_sum = sum[y*xblocks+x];
+				}
+			}
+		}
+		count[f-1] = highest_sum;
+		showmetrics[f-1] = (count[f-1] * 100.0) / div;
+	}
+
+	/* Find the frame with the lowest difference count but
+	   don't use the artificial duplicate at frame 0. */
+	if (frame == 0)
+	{
+		lowest = count[1];
+		lowest_index = 1;
+	}
+	else
+	{
+		lowest = count[0];
+		lowest_index = 0;
+	}
+	for (x = 1; x < _param->cycle; x++)
+	{
+		if (count[x] < lowest)
+		{
+			lowest = count[x];
+			lowest_index = x;
+		}
+	}
+	last_result = frame + lowest_index;
+	if (_param->quality == 1 || _param->quality == 3)
+		last_metric = (lowest * 100.0) / div;
+	else
+		last_metric = (lowest * 100.0) / div;
+	*chosen = last_result;
+	*metric = last_metric;
+
+	
+	found = false;
+	last_forced = false;	
+
+}
+/**
+    \fn FindDuplicate2
+*/
+void Decimate::FindDuplicate2(int frame, int *chosen, bool *forced)
+{
+	int f, g, fsum, bsum, highest, highest_index;
+	ADMImage * store[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
+	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
+	int x, y;
+	double lowest;
+	unsigned int lowest_index;
+	char buf[255];
+	unsigned int highest_sum;
+	bool found;
+#define BLKSIZE 32
+
+	/* Only recalculate differences when a new cycle is started. */
+	if (frame == last_request)
+	{
+		*chosen = last_result;
+		*forced = last_forced;
+		return;
+	}
+	last_request = frame;
+
+	if (firsttime == true || frame == 0)
+	{
+		firsttime = false;
+		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = -1;
+		GETFRAME(frame, store[0]);
+		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
+		}
+
+		for (f = 1; f <= _param->cycle; f++)
+		{
+			GETFRAME(frame + f - 1, store[f]);
+			storepY[f] =YPLANE( store[f]);//->GetReadPtr(PLANAR_Y);
+			if (_param->quality == 1 || _param->quality == 3)
+			{
+				storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
+				storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
+			}
+		}
+
+		pitchY = _info.width; //store[0]->GetPitch(PLANAR_Y);
+		row_sizeY = _info.width; //store[0]->GetRowSize(PLANAR_Y);
+		heightY = _info.height; //store[0]->GetHeight(PLANAR_Y);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			pitchUV = _info.width>>1; //store[0]->GetPitch(PLANAR_V);
+			row_sizeUV = _info.width>>1; //store[0]->GetRowSize(PLANAR_V);
+			heightUV = _info.height>>1; //store[0]->GetHeight(PLANAR_V);
+		}
+		switch (_param->quality)
+		{
+		case 0: // subsample, luma only
+			div = (BLKSIZE * BLKSIZE / 4) * 219;
+			break;
+		case 1: // subsample, luma and chroma
+			div = (BLKSIZE * BLKSIZE / 4) * 219 + (BLKSIZE * BLKSIZE / 8) * 224;
+			break;
+		case 2: // fully sample, luma only
+			div = (BLKSIZE * BLKSIZE) * 219;
+			break;
+		case 3: // fully sample, luma and chroma
+			div = (BLKSIZE * BLKSIZE) * 219 + (BLKSIZE * BLKSIZE / 2) * 224;
+			break;
+		}
+		xblocks = row_sizeY / BLKSIZE;
+		if (row_sizeY % BLKSIZE) xblocks++;
+		yblocks = heightY / BLKSIZE;
+		if (heightY % BLKSIZE) yblocks++;
+
+		/* Compare each frame to its predecessor. */
+		for (f = 1; f <= _param->cycle; f++)
+		{
+			for (y = 0; y < yblocks; y++)
+			{
+				for (x = 0; x < xblocks; x++)
+				{
+					sum[y*xblocks+x] = 0;
+				}
+			}
+			prevY = storepY[f-1];
+			currY = storepY[f];
+			for (y = 0; y < heightY; y++)
+			{
+				for (x = 0; x < row_sizeY;)
+				{
+					sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+					x++;
+					if (_param->quality == 0 || _param->quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevY += pitchY;
+				currY += pitchY;
+			}
+			if (_param->quality == 1 || _param->quality == 3)
+			{
+				prevU = storepU[f-1];
+				currU = storepU[f];
+				prevV = storepV[f-1];
+				currV = storepV[f];
+				for (y = 0; y < heightUV; y++)
+				{
+					for (x = 0; x < row_sizeUV;)
+					{
+						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+						x++;
+						if (_param->quality == 0 || _param->quality == 1)
+						{
+							if (!(x%4)) x += 12;
+						}
+					}
+					prevU += pitchUV;
+					currU += pitchUV;
+					prevV += pitchUV;
+					currV += pitchUV;
+				}
+			}
+			highest_sum = 0;
+			for (y = 0; y < yblocks; y++)
+			{
+				for (x = 0; x < xblocks; x++)
+				{
+					if (sum[y*xblocks+x] > highest_sum)
+					{
+						highest_sum = sum[y*xblocks+x];
+					}
+				}
+			}
+			metrics[f-1] = (highest_sum * 100.0) / div;
+		}
+
+		Dcurr[0] = 1;
+		for (f = 1; f < _param->cycle; f++)
+		{
+			if (metrics[f] < _param->threshold2) Dcurr[f] = 0;
+			else Dcurr[f] = 1;
+		}
+
+		if (debug)
+		{
+			sprintf(buf,"Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n",
+					0, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
+			OutputDebugString(buf);
+		}
+	}
+ 	else if (frame >= num_frames_hi - 1)
+	{
+		GETFRAME(num_frames_hi - 1, store[0]);
+		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
+		}
+		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
+		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
+	}
+	else
+	{
+		GETFRAME(frame + _param->cycle - 1, store[0]);
+		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
+		}
+		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
+		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
+	}
+	for (f = 0; f < MAX_CYCLE_SIZE; f++) Dshow[f] = Dcurr[f];
+	for (f = 0; f < MAX_CYCLE_SIZE; f++) showmetrics[f] = metrics[f];
+
+	for (f = 1; f <= _param->cycle; f++)
+	{
+		GETFRAME(frame + f + _param->cycle - 1, store[f]);
+		storepY[f] =YPLANE( store[f]);//->GetReadPtr(PLANAR_Y);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
+			storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
+		}
+	}
+
+	/* Compare each frame to its predecessor. */
+	for (f = 1; f <= _param->cycle; f++)
+	{
+		prevY = storepY[f-1];
+		currY = storepY[f];
+		for (y = 0; y < yblocks; y++)
+		{
+			for (x = 0; x < xblocks; x++)
+			{
+				sum[y*xblocks+x] = 0;
+			}
+		}
+		for (y = 0; y < heightY; y++)
+		{
+			for (x = 0; x < row_sizeY;)
+			{
+				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+				x++;
+				if (_param->quality == 0 || _param->quality == 1)
+				{
+					if (!(x%4)) x += 12;
+				}
+			}
+			prevY += pitchY;
+			currY += pitchY;
+		}
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			prevU = storepU[f-1];
+			currU = storepU[f];
+			prevV = storepV[f-1];
+			currV = storepV[f];
+			for (y = 0; y < heightUV; y++)
+			{
+				for (x = 0; x < row_sizeUV;)
+				{
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+					x++;
+					if (_param->quality == 0 || _param->quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevU += pitchUV;
+				currU += pitchUV;
+				prevV += pitchUV;
+				currV += pitchUV;
+			}
+		}
+		highest_sum = 0;
+		for (y = 0; y < yblocks; y++)
+		{
+			for (x = 0; x < xblocks; x++)
+			{
+				if (sum[y*xblocks+x] > highest_sum)
+				{
+					highest_sum = sum[y*xblocks+x];
+				}
+			}
+		}
+		metrics[f-1] = (highest_sum * 100.0) / div;
+	}
+
+	/* Find the frame with the lowest difference count but
+	   don't use the artificial duplicate at frame 0. */
+	if (frame == 0)
+	{
+		lowest = metrics[1];
+		lowest_index = 1;
+	}
+	else
+	{
+		lowest = metrics[0];
+		lowest_index = 0;
+	}
+	for (f = 1; f < _param->cycle; f++)
+	{
+		if (metrics[f] < lowest)
+		{
+			lowest = metrics[f];
+			lowest_index = f;
+		}
+	}
+
+	for (f = 0; f < _param->cycle; f++)
+	{
+		if (metrics[f] < _param->threshold2) Dnext[f] = 0;
+		else Dnext[f] = 1;
+	}
+
+	if (debug)
+	{
+		sprintf(buf,"Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n",
+		        frame + 5, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
+		OutputDebugString(buf);
+	}
+
+	if (debug)
+	{
+		sprintf(buf,"Decimate: %d: %d %d %d %d %d\n",
+		        frame, Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4]);
+//		sprintf(buf,"Decimate: %d: %d %d %d %d %d - %d %d %d %d %d - %d %d %d %d %d\n",
+//		        frame, Dprev[0], Dprev[1], Dprev[2], Dprev[3], Dprev[4],
+//					   Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4],
+//					   Dnext[0], Dnext[1], Dnext[2], Dnext[3], Dnext[4]);
+		OutputDebugString(buf);
+	}
+
+	/* Find the longest strings of duplicates and decimate a frame from it. */
+	highest = -1;
+	for (f = 0; f < _param->cycle; f++)
+	{
+		if (Dcurr[f] == 1)
+		{
+			bsum = 0;
+			fsum = 0;
+		}
+		else
+		{
+			bsum = 1;
+			g = f;
+			while (--g >= 0)
+			{
+				if (Dcurr[g] == 0)
+				{
+					bsum++;
+				}
+				else break;
+			}
+			if (g < 0)
+			{
+				g = _param->cycle;
+				while (--g >= 0)
+				{
+					if (Dprev[g] == 0)
+					{
+						bsum++;
+					}
+					else break;
+				}
+			}
+			fsum = 1;
+			g = f;
+			while (++g < _param->cycle)
+			{
+				if (Dcurr[g] == 0)
+				{
+					fsum++;
+				}
+				else break;
+			}
+			if (g >= _param->cycle)
+			{
+				g = -1;
+				while (++g < _param->cycle)
+				{
+					if (Dnext[g] == 0)
+					{
+						fsum++;
+					}
+					else break;
+				}
+			}
+		}
+		if (bsum + fsum > highest)
+		{
+			highest = bsum + fsum;
+			highest_index = f;
+		}
+//		sprintf(buf,"Decimate: bsum %d, fsum %d\n", bsum, fsum);
+//		OutputDebugString(buf);
+	}
+
+	f = highest_index;
+	if (Dcurr[f] == 1)
+	{
+		/* No duplicates were found! Act as if mode=0. */
+		*chosen = last_result = frame + lowest_index;
+	}
+	else
+	{
+		/* Prevent this decimated frame from being considered again. */ 
+		Dcurr[f] = 1;
+		*chosen = last_result = frame + highest_index;
+	}
+	last_forced = false;
+	if (debug)
+	{
+		sprintf(buf,"Decimate: dropping frame %d\n", last_result);
+		OutputDebugString(buf);
+	}
+
+	
+	found = false;
+	
+	if (found == true)
+	{
+		*chosen = last_result ;
+		*forced = last_forced = true;
+		if (debug)
+		{
+			sprintf(buf,"Decimate: overridden drop frame -- drop %d\n", last_result);
+			OutputDebugString(buf);
+		}
+	}
+}
+// EOF
+



From mean at mail.berlios.de  Sun Jul 10 19:17:11 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 10 Jul 2011 19:17:11 +0200
Subject: [Avidemux-svn-commit] r7316 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide
Message-ID: <20110710171711.7BAF44813BB@sheep.berlios.de>

Author: mean
Date: 2011-07-10 19:17:11 +0200 (Sun, 10 Jul 2011)
New Revision: 7316

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
Log:
[Telecide] More cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	2011-07-10 17:17:09 UTC (rev 7315)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	2011-07-10 17:17:11 UTC (rev 7316)
@@ -79,7 +79,7 @@
 				_param->vthresh = 50.0;
 				_param->bthresh = 50.0;
 				_param->dthresh = 7.0;
-				_param->blend = false;
+				_param->blend = false; // Interpolate is default
 				_param->nt = 10;	// Noise tolerance
 				_param->y0 = 0;		// Zone to try (avoid subs)
 				_param->y1 = 0;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	2011-07-10 17:17:09 UTC (rev 7315)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	2011-07-10 17:17:11 UTC (rev 7316)
@@ -149,7 +149,7 @@
 
 	void WriteHints(unsigned char *dst, bool film, bool inpattern);
 
-    bool doInterpolate(ADMImage *dst, ADM_PLANE plane);
+    bool interpolatePlane(ADMImage *dst, ADM_PLANE plane);
     bool blendPlane(ADMImage *dst, ADMImage *src,ADM_PLANE plane);
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-10 17:17:09 UTC (rev 7315)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-10 17:17:11 UTC (rev 7316)
@@ -163,9 +163,6 @@
         int hover2 = h >>1;
         int wover2 = w >>1;
 
-        int hplus1over2 = (h+1)/2;
-        int hminus2= h - 2;
-        //dst = env->NewVideoFrame(vi);
         dst=output_image;
         int dpitch = dst->GetPitch(PLANAR_Y);
 
@@ -404,7 +401,9 @@
         {
                 unsigned char *dstpp, *dstpn;
                 int v1, v2, z;
-
+                #warning blend in place is wrong!
+                // MeanX:We should copy here as we blend from source and destination
+                // for the moment we do it in place, it is wrong.
                 if (blend == true)
                 {
                         blendPlane(final,dst,PLANAR_Y);
@@ -418,9 +417,9 @@
                         vidCache->unlockAll();
                         return 1;
                 }
-                doInterpolate(final,PLANAR_Y);
-                doInterpolate(final,PLANAR_U);
-                doInterpolate(final,PLANAR_V);
+                interpolatePlane(final,PLANAR_Y);
+                interpolatePlane(final,PLANAR_U);
+                interpolatePlane(final,PLANAR_V);
         }
         if (show == true) Show(dst, frame);
         if (debug == true) Debug(frame);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	2011-07-10 17:17:09 UTC (rev 7315)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	2011-07-10 17:17:11 UTC (rev 7316)
@@ -889,9 +889,9 @@
     return true;
 }
 /**
-    \fn doInterpolate
+    \fn interpolatePlane
 */
-bool Telecide::doInterpolate(ADMImage *dst, ADM_PLANE plane)
+bool Telecide::interpolatePlane(ADMImage *dst, ADM_PLANE plane)
 {
 
     // Interpolate mode.



From gruntster at mail.berlios.de  Sun Jul 10 19:27:56 2011
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 10 Jul 2011 19:27:56 +0200
Subject: [Avidemux-svn-commit] r7317 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: . ADM_audio
	ADM_script ADM_toolkit ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <20110710172756.8AA094813BB@sheep.berlios.de>

Author: gruntster
Date: 2011-07-10 19:27:56 +0200 (Sun, 10 Jul 2011)
New Revision: 7317

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audioac3ex.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audioex.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiomp3ex.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiosource_ext.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiowavex.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
Log:
[qt] support audio drag and drop

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audioac3ex.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audioac3ex.cpp	2011-07-10 17:17:11 UTC (rev 7316)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audioac3ex.cpp	2011-07-10 17:27:56 UTC (rev 7317)
@@ -19,17 +19,15 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-//#include <sstream>
-#include "ADM_assert.h"
-#include <math.h>
 
+#include "ADM_assert.h"
 #include "avifmt.h"
 #include "aviaudio.hxx"
 #include "ADM_audio/audioex.h"
 
 #include "ADM_audio/ADM_a52info.h"
 
-uint8_t AVDMAC3AudioStream::open(char *name)
+uint8_t AVDMAC3AudioStream::open(const char *name)
 {
 uint8_t syncbuff[10*1024];
 uint32_t fq,br,l,chan;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audioex.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audioex.h	2011-07-10 17:17:11 UTC (rev 7316)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audioex.h	2011-07-10 17:27:56 UTC (rev 7317)
@@ -22,7 +22,7 @@
  public:
  			     AVDMMP3AudioStream( void ) :  AVDMFileStream() {};
          		~AVDMMP3AudioStream() { abort();}
-           	virtual uint8_t open(char *name);
+           	virtual uint8_t open(const char *name);
 } ;
 
 class AVDMWavAudioStream  : public AVDMFileStream
@@ -30,7 +30,7 @@
  public:
  			     AVDMWavAudioStream( void ) :  AVDMFileStream() {};
          		~AVDMWavAudioStream() { abort();}
-           	virtual uint8_t open(char *name);
+           	virtual uint8_t open(const char *name);
 }  ;
 
 class AVDMAC3AudioStream  : public AVDMFileStream
@@ -38,6 +38,6 @@
  public:
  			     AVDMAC3AudioStream( void ) :  AVDMFileStream() {};
          		~AVDMAC3AudioStream() { abort();}
-           	virtual uint8_t open(char *name);
+           	virtual uint8_t open(const char *name);
 }  ;
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiomp3ex.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiomp3ex.cpp	2011-07-10 17:17:11 UTC (rev 7316)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiomp3ex.cpp	2011-07-10 17:27:56 UTC (rev 7317)
@@ -18,17 +18,13 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-//#include <stream.h>
-#include "ADM_assert.h"
-#include <math.h>
 
+#include "ADM_assert.h"
 #include "avifmt.h"
 #include "aviaudio.hxx"
 #include "ADM_audio/audioex.h"      
 
-
-
-uint8_t AVDMMP3AudioStream::open(char *name)
+uint8_t AVDMMP3AudioStream::open(const char *name)
 {
     //int a, b, c;
 	uint8_t buffer[2048],*ptr;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiosource_ext.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiosource_ext.h	2011-07-10 17:17:11 UTC (rev 7316)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiosource_ext.h	2011-07-10 17:27:56 UTC (rev 7317)
@@ -34,8 +34,8 @@
 								
         		AVDMFileStream(void);
 	  			~AVDMFileStream();
-				//~AVDMWavAudioStream() { abort();};
-				virtual uint8_t open(char *name)=0;
+
+				virtual uint8_t open(const char *name)=0;
         		virtual uint32_t read(uint32_t len,uint8_t *buffer);
         		virtual uint8_t  goTo(uint32_t newoffset);     		
 };

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiowavex.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiowavex.cpp	2011-07-10 17:17:11 UTC (rev 7316)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiowavex.cpp	2011-07-10 17:27:56 UTC (rev 7317)
@@ -39,7 +39,7 @@
   	Try to open the Wav file
 		Gather informations
 _________________________________________*/
-uint8_t AVDMWavAudioStream::open(char *name)
+uint8_t AVDMWavAudioStream::open(const char *name)
 {
     uint32_t t32;
     fd = fopen(name, "rb");

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2011-07-10 17:17:11 UTC (rev 7316)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2011-07-10 17:27:56 UTC (rev 7317)
@@ -21,9 +21,9 @@
 #include "ADM_JSAudioTrackInfo.h"
 
 extern int A_audioSave(char *name);
-extern int A_loadAC3 (char *name);
-extern int A_loadMP3 (char *name);
-extern int A_loadWave (char *name);
+extern int A_loadAC3 (const char *name);
+extern int A_loadMP3 (const char *name);
+extern int A_loadWave (const char *name);
 extern AudioSource currentAudioSource;
 extern AudioSource secondAudioSource;
 extern void HandleAction(Action act);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2011-07-10 17:17:11 UTC (rev 7316)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2011-07-10 17:27:56 UTC (rev 7317)
@@ -54,9 +54,9 @@
 extern int A_loadNone( void );
 extern void A_saveAudioDecodedTest(char *name);
 extern uint8_t A_SaveAudioNVideo(char *name);
-extern int A_loadMP3(char *name);
-extern int A_loadAC3(char *name);
-extern int A_loadWave(char *name);
+extern int A_loadMP3(const char *name);
+extern int A_loadAC3(const char *name);
+extern int A_loadWave(const char *name);
 extern void GUI_Quiet( void);
 extern bool A_parseECMAScript(const char *name);
 extern void GUI_Verbose( void);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2011-07-10 17:17:11 UTC (rev 7316)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2011-07-10 17:27:56 UTC (rev 7317)
@@ -32,6 +32,7 @@
 #include "gtkgui.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_userInterfaces/ADM_render/GUI_renderInternal.h"
+#include "ADM_audiofilter/audioeng_buildfilters.h"
 
 extern int global_argc;
 extern char **global_argv;
@@ -57,6 +58,7 @@
 extern void FileSel_ReadWrite(SELFILE_CB *cb, int rw, const char *name, const char *actual_workbench_file);
 extern bool A_parseECMAScript(const char *name);
 extern void saveCrashProject(void);
+extern bool loadAudio(const char *filename);
 
 int SliderIsShifted=0;
 static void setupMenus(void);
@@ -527,9 +529,16 @@
 		if (info.isFile())
 		{
 			if (avifileinfo)
-				FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_appendAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
+			{
+				if (!loadAudio(fileName.toUtf8().constData()))
+				{
+					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_appendAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
+				}
+			}
 			else
+			{
 				FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_openAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
+			}
 		}
 	}
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2011-07-10 17:17:11 UTC (rev 7316)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2011-07-10 17:27:56 UTC (rev 7317)
@@ -70,9 +70,9 @@
 void A_saveBunchJpg( const char *name);
 void A_requantize(void);
 int A_saveJpg (char *name);
-int A_loadWave (char *name);
-int A_loadAC3 (char *name);
-int A_loadMP3 (char *name);
+int A_loadWave (const char *name);
+int A_loadAC3 (const char *name);
+int A_loadMP3 (const char *name);
 int A_loadNone( void );
 void A_saveAudioDecodedTest (char *name);
 int A_openAvi2 (const char *name, uint8_t mode);
@@ -95,7 +95,6 @@
 			    const char *title);
 extern void GUI_setMarks (uint32_t a, uint32_t b);
 extern void saveMpegFile (char *name);
-//static void A_selectEncoder ( void );
 extern uint8_t A_SaveAudioDualAudio (const char *a);
 
 void A_Resync(void);
@@ -341,15 +340,6 @@
       cleanUp (); 
       exit (0);
       break;
-/*			case ACT_SelectEncoder:
-				
-						A_selectEncoder();
-  	  			return;
-						break;*/
-    case ACT_SelectEncoder:
-      GUI_Error_HIG (QT_TR_NOOP("Obsolete"), NULL);
-      break;
-
     default:
       break;
 
@@ -1390,14 +1380,7 @@
         GUI_Error_HIG (QT_TR_NOOP("BMP op failed"),QT_TR_NOOP( "Saving %s as a BMP file failed."), ADM_GetFileName(name));
 }
 
-//_____________________________________________________________
-//
-//              Load AC3
-//
-//
-//_____________________________________________________________
-int
-A_loadAC3 (char *name)
+int A_loadAC3 (const char *name)
 {
 	char *path = ADM_fixupPath(name);
 
@@ -1409,13 +1392,13 @@
 
   if (ac3->open (path) == 0)
     {
-      GUI_Error_HIG (QT_TR_NOOP("Failed to open the file"), QT_TR_NOOP("Not a WAV file?"));
-      printf ("%s", QT_TR_NOOP("WAV open file failed..."));
+      GUI_Error_HIG (QT_TR_NOOP("Failed to open the file"), QT_TR_NOOP("Not an AC3 file?"));
+      printf("AC3 open file failed...");
       delete ac3;
 	  delete [] path;
       return 0;
     }
-  //currentaudiostream=wav;
+
   A_changeAudioStream (ac3, AudioAC3,path);
   wavinfo = currentaudiostream->getInfo ();
   delete [] path;
@@ -1426,13 +1409,7 @@
  	A_changeAudioStream ((AVDMGenericAudioStream *) NULL, AudioNone,NULL);
 }
 
-//_____________________________________________________________
-//
-//              Load MP3 and identify wavfmt infos to fill avi header
-//              -> use mad ?
-//
-//_____________________________________________________________
-int A_loadMP3(char *name)
+int A_loadMP3(const char *name)
 {
 	char *path = ADM_fixupPath(name);
 
@@ -1442,27 +1419,20 @@
 
     if (mp3->open(path) == 0)
       {
+		  GUI_Error_HIG (QT_TR_NOOP("Failed to open the file"), QT_TR_NOOP("Not an MP3 file?"));
           printf("MP3 open file failed...");
           delete mp3;
 		  delete [] path;
           return 0;
       }
 
-    //currentaudiostream=mp3;
     A_changeAudioStream(mp3, AudioMP3,path);
     wavinfo = currentaudiostream->getInfo();
 	delete [] path;
     return 1;
 }
-//_____________________________________________________________
-//
-//              Load wave
-//              
-//
-//_____________________________________________________________
 
-int
-A_loadWave (char *name)
+int A_loadWave (const char *name)
 {
 	char *path = ADM_fixupPath(name);
 
@@ -1487,6 +1457,48 @@
   delete [] path;
   return 1;
 }
+
+bool loadAudio(const char *filename)
+{
+	AudioSource audioType = AudioInvalid;
+	bool loaded = false;
+
+	if (avifileinfo)
+	{
+		AVDMMP3AudioStream *mp3 = new AVDMMP3AudioStream();
+		AVDMAC3AudioStream *ac3 = new AVDMAC3AudioStream();
+		AVDMWavAudioStream *wav = new AVDMWavAudioStream();	
+
+		if (audioType == AudioInvalid && mp3->open(filename))
+			audioType = AudioMP3;
+
+		if (audioType == AudioInvalid && ac3->open(filename))
+			audioType = AudioAC3;
+
+		if (audioType == AudioInvalid && wav->open(filename))
+			audioType = AudioWav;
+
+		delete mp3;
+		delete ac3;
+		delete wav;
+	}
+
+	switch (audioType)
+	{
+		case AudioMP3:
+			loaded = A_loadMP3(filename);
+			break;
+		case AudioAC3:
+			loaded = A_loadAC3(filename);
+			break;
+		case AudioWav:
+			loaded = A_loadWave(filename);
+			break;
+	}
+
+	return loaded;
+}
+
 AudioSource getCurrentAudioSource(char **name)
 {
         *name=currentAudioName;



From mean at mail.berlios.de  Thu Jul 14 19:40:17 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 14 Jul 2011 19:40:17 +0200
Subject: [Avidemux-svn-commit] r7318 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage:
	include src
Message-ID: <20110714174018.2A7B4481490@sheep.berlios.de>

Author: mean
Date: 2011-07-14 19:40:17 +0200 (Thu, 14 Jul 2011)
New Revision: 7318

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp
Log:
 [coreImage] Add blend

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2011-07-10 17:27:56 UTC (rev 7317)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2011-07-14 17:40:17 UTC (rev 7318)
@@ -150,7 +150,9 @@
         bool    copyInfo(ADMImage *src);	/// copy all the flags, not the data themselves
         bool    copyQuantInfo(ADMImage *src);	/// copy quant table if any
         bool    isRef(void) { if(_imageType==ADM_IMAGE_REF) return true;return false;};
+        // 
         bool    merge(ADMImage *src1,ADMImage *src2);
+        bool    blend(ADMImage *src1,ADMImage *src2);
         bool    substract(ADMImage *src1,ADMImage *src2);
         bool    blacken(void);
         bool    copyTo(ADMImage *target, uint32_t x, uint32_t y);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp	2011-07-10 17:27:56 UTC (rev 7317)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp	2011-07-14 17:40:17 UTC (rev 7318)
@@ -102,7 +102,9 @@
 
 
 #endif
+/**
 
+*/
 bool ADMImage::merge(ADMImage *src1,ADMImage *src2)
 {
 #ifdef ADM_CPU_X86
@@ -117,6 +119,123 @@
 
 
 }
+/**
+    \fn blendC
+    \brief Blend src1 and src2 into target (one plane)
+*/
+typedef bool blendFunction(int width, int height, uint8_t *target,uint32_t stride,    uint8_t *src1,uint32_t stride1,               uint8_t *src2,uint32_t stride2);
+
+static bool blendC(int width, int height,
+                    uint8_t *target,uint32_t stride,
+                    uint8_t *src1,  uint32_t stride1,
+                    uint8_t *src2,  uint32_t stride2)
+{
+          for(int y=0;y<height;y++)
+                {
+                    uint8_t *s1=src1,*s2=src2,*d=target;
+                    unsigned int a;
+                    for(int x=0;x<width;x++)
+                    {
+                        a=((unsigned int)*s1)+((unsigned int)*s2);
+                        a>>=1;
+                        *d=(uint8_t)a;
+                        s1++;
+                        s2++;
+                        d++;
+                    }
+                    src1+=stride1;src2+=stride2;target+=stride;
+                }
+        return true;
+}
+#ifdef ADM_CPU_X86
+static bool blendMMX(int width, int height,
+                    uint8_t *target,uint32_t stride,
+                    uint8_t *src1,  uint32_t stride1,
+                    uint8_t *src2,  uint32_t stride2)
+{
+uint32_t ww,rr;
+uint8_t *s1,*s2,*d1;
+        int a1,a2;
+      
+        ww=width>>2;
+        rr=width&3;
+
+
+         __asm__(
+                         "pxor %%mm7,%%mm7"
+                ::
+                 );
+
+          for(int y=0;y<height;y++)
+          {
+                s1=src1;
+                s2=src2;
+                d1=target;
+                if(rr)
+                {
+                    blendC(rr,height,d1+(ww<<2), stride,s1+(ww<<2),stride1,s2+(ww<<2),stride2);
+                }
+
+                for(int x=0;x<ww;x++)
+                {
+                    __asm__(
+                            "movd           (%0),%%mm0 \n"
+                            "movd           (%1),%%mm1 \n"
+                            "punpcklbw      %%mm7,%%mm0 \n"
+                            "punpcklbw      %%mm7,%%mm1 \n"
+                            "paddw           %%mm1,%%mm0 \n"
+                            "psrlw          $1,%%mm0 \n"
+                            "packuswb       %%mm0,  %%mm0\n"
+                            "movd           %%mm0,(%2) \n"
+
+                    : : "r" (s1),"r" (s2),"r"(d1)
+                    );
+                    s1+=4;
+                    s2+=4;
+                    d1+=4;
+                }
+                src1+=stride1;
+                src2+=stride2;
+                target+=stride;
+           }
+        __asm__(
+                        "emms\n"
+                ::
+                );
+
+        return true;
+}
+
+
+#endif
+/**
+    \fn blend
+    \brief Blend src1 and src2 into our image
+*/
+bool ADMImage::blend(ADMImage *src1,ADMImage *src2)
+{
+    blendFunction *myBlend=blendC;
+#ifdef ADM_CPU_X86
+    if(CpuCaps::hasMMX())
+            myBlend=blendMMX;
+#endif
+    ADM_assert(src1->_width==src2->_width);
+    ADM_assert(_width==src2->_width);
+    ADM_assert(src1->_height==src2->_height);
+    for(int x=0;x<3;x++)
+    {
+        ADM_PLANE plane=(ADM_PLANE)x;
+        myBlend(GetWidth(plane),GetHeight(plane),
+                                    GetWritePtr(plane),GetPitch(plane),
+                                    src1->GetReadPtr(plane),src1->GetPitch(plane),
+                                    src2->GetReadPtr(plane),src2->GetPitch(plane)
+                                );
+    }
+    return true;
+}
+/**
+
+*/
 /* 3000 * 3000 max size, using uint32_t is safe... */
 static uint32_t computeDiff(uint8_t  *s1,uint8_t *s2,uint32_t noise,uint32_t l)
 {



From mean at mail.berlios.de  Thu Jul 14 19:40:19 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 14 Jul 2011 19:40:19 +0200
Subject: [Avidemux-svn-commit] r7319 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src
Message-ID: <20110714174019.3E405481490@sheep.berlios.de>

Author: mean
Date: 2011-07-14 19:40:19 +0200 (Thu, 14 Jul 2011)
New Revision: 7319

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp
Log:
[videoFilterCache] Slightly better error message

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp	2011-07-14 17:40:17 UTC (rev 7318)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp	2011-07-14 17:40:19 UTC (rev 7319)
@@ -170,7 +170,8 @@
     if(!incoming->getNextFrameAs(ADM_HW_ANY,&nb,img)) return NULL;
     if(nb!=frame)
     {
-        ADM_error("Expected frame %d, got frame %d\n",(int)frame,(int)nb);
+        ADM_error("Cache inconsistency :\n");
+        ADM_error("Expected to get frame %d from filter, got frame %d instead\n",(int)frame,(int)nb);
         dump();
         ADM_assert(0);
     }



From mean at mail.berlios.de  Thu Jul 14 19:40:20 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 14 Jul 2011 19:40:20 +0200
Subject: [Avidemux-svn-commit] r7320 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide
Message-ID: <20110714174020.5B002481490@sheep.berlios.de>

Author: mean
Date: 2011-07-14 19:40:20 +0200 (Thu, 14 Jul 2011)
New Revision: 7320

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
Log:
[Telecide] Update frame number + dont calculate metrics if we can read the frame

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	2011-07-14 17:40:19 UTC (rev 7319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	2011-07-14 17:40:20 UTC (rev 7320)
@@ -34,7 +34,7 @@
 #include "Telecide.h"
 #include "DIA_factory.h"
 #include "telec_desc.cpp"
-#if 1
+#if 0
     #define aprintf printf
 #else
     #define aprintf(...) {}



From mean at mail.berlios.de  Thu Jul 14 19:40:21 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 14 Jul 2011 19:40:21 +0200
Subject: [Avidemux-svn-commit] r7321 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide
Message-ID: <20110714174021.808A7481490@sheep.berlios.de>

Author: mean
Date: 2011-07-14 19:40:21 +0200 (Thu, 14 Jul 2011)
New Revision: 7321

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
Log:
[Telecide] Update frame number + dont calculate metrics if we can read the frame

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-14 17:40:20 UTC (rev 7320)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-14 17:40:21 UTC (rev 7321)
@@ -32,7 +32,7 @@
 */
 #include "ADM_default.h"
 #include "Telecide.h"
-#if 1
+#if 0
     #define aprintf printf
 #else
     #define aprintf(...) {}
@@ -123,7 +123,7 @@
 teleCide *_param=&configuration;
 
 
-        
+        *frameNumber=nextFrame;
         bool lastFrame=false;
         aprintf("telecide : frame %d\n",(int)nextFrame);
         // Get the current frame.
@@ -181,7 +181,8 @@
 
                                 GETFRAME(y, lc);
                                 GETFRAME(y == 0 ? 1 : y - 1, lp);
-                                CalculateMetrics(y, lc,lp); //crp, crpU, crpV, prp, prpU, prpV);
+                                if(lc && lp)
+                                    CalculateMetrics(y, lc,lp); //crp, crpU, crpV, prp, prpU, prpV);
                         }
                 }
         }



From mean at mail.berlios.de  Thu Jul 14 19:40:22 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 14 Jul 2011 19:40:22 +0200
Subject: [Avidemux-svn-commit] r7322 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate
Message-ID: <20110714174022.BF0E8481490@sheep.berlios.de>

Author: mean
Date: 2011-07-14 19:40:22 +0200 (Thu, 14 Jul 2011)
New Revision: 7322

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
Log:
[Decimage] Partially working decimate. Code cleanup-ed

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp	2011-07-14 17:40:21 UTC (rev 7321)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp	2011-07-14 17:40:22 UTC (rev 7322)
@@ -43,41 +43,9 @@
 
 #include "ADM_default.h"
 #include "decimate.h"
-
-
-
-
-#ifdef USE_SSE
-	#define DECIMATE_MMX_BUILD_PLANE 1
-	#define DECIMATE_MMX_BUILD	 1
-#endif
-
-#ifdef DECIMATE_MMX_BUILD_PLANE
-static void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
-			int w, int h);
-int isse_scenechange_32(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;	
-int isse_scenechange_16(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
-int isse_scenechange_8(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
-#endif
-
-
-#define OutputDebugString(x) aprintf("%s\n",x)
-//________________________________
-
-#define GETFRAME(g, fp) \
-{ \
-	int GETFRAMEf; \
-	GETFRAMEf = (g); \
-	if (GETFRAMEf < 0) GETFRAMEf = 0; \
-	if (GETFRAMEf > num_frames_hi - 1) GETFRAMEf = num_frames_hi - 1; \
-	(fp) = vidCache->getImage(GETFRAMEf); \
-}
-//________________________________
-
-
-#define aprintf(...) {}
 #include "DIA_factory.h"
 
+#include "dec_desc.cpp"
 
 // Add the hook to make it valid plugin
 DECLARE_VIDEO_FILTER(   Decimate,   // Class
@@ -121,13 +89,15 @@
     diaElemFloat menuThresh1(&t1,QT_TR_NOOP("_Threshold 1:"),0,100.);
     diaElemFloat menuThresh2(&t2,QT_TR_NOOP("T_hreshold 2:"),0,100.);
     diaElemUInteger cycle(PX(cycle),QT_TR_NOOP("C_ycle:"),2,40);
+    diaElemToggle show(PX(show),QT_TR_NOOP("Sho_w"));
+    diaElem *elems[]={&cycle,&menuMode,&menuQuality,&menuThresh1,&menuThresh2,&show};
     
-    diaElem *elems[]={&cycle,&menuMode,&menuQuality,&menuThresh1,&menuThresh2};
-    
-  if(diaFactoryRun(QT_TR_NOOP("Decomb Decimate"),5,elems))
+  if(diaFactoryRun(QT_TR_NOOP("Decomb Decimate"),6,elems))
   {
     _param->threshold=(double )t1;
     _param->threshold2=(double )t2;
+    updateInfo();
+    reset();
     return 1; 
   }
   return 0;        
@@ -137,35 +107,55 @@
 */
 const char   *Decimate::getConfiguration(void)
 {
-    const char strparam[255];
+    static char strparam[255]={0};
  	snprintf(strparam,254," Decomb Decimate cycle:%d",configuration.cycle);
     return strparam;
 }
+/**
+    \fn updateInfo
+*/
+void Decimate::updateInfo(void)
+{
+        if(configuration.cycle<2)
+        {
+            ADM_error("Telecide:bad configuration! cycle<2\n");
+            return;
+        }
+        double inc=info.frameIncrement;
+        inc*=configuration.cycle;
+        inc/=configuration.cycle-1;
+        info.frameIncrement=inc;
 
+}
 /**
+    \fn reset
+    \brief reset counters. Must be called each time a change is made (params/seek)
+*/
+void Decimate::reset(void)
+{
+		last_request = -1;
+		firsttime = true;
+        all_video_cycle = true;
+        hints_invalid=false;
+        vidCache->flush();
+}
+/**
     \fn Ctor
 */       
 Decimate::Decimate(	ADM_coreVideoFilter *in,CONFcouple *couples)      : ADM_coreVideoFilter(in,couples)
 {
 		
-		int count = 0;
 		char buf[80];
 		unsigned int *p;	
         deciMate *_param=&configuration;
 		//		
 		// Init here
-		debug=0;
-		show=0;		
-#ifdef USE_SSE	
-		if(CpuCaps::hasSSE())
-		{
-			printf("Decimate:SSE enabled\n");
-		}
-#endif
 		if(!couples || !ADM_paramLoad(couples,deciMate_param,&configuration))
   		{
 			_param->cycle=5;
-			_param->mode=0;
+			_param->mode=3;
+            _param->show=false;
+            _param->debug=false;
 			_param->quality=2;
 			_param->threshold=0;
 			_param->threshold2=3.0;
@@ -176,24 +166,18 @@
 		
 		if (_param->mode == 0 || _param->mode == 2 || _param->mode == 3)
 		{
-#warning make it a function
-			num_frames_hi = _info.nb_frames;
-			_info.nb_frames = _info.nb_frames * (_param->cycle - 1) / _param->cycle;
-			_info.fps1000=_info.fps1000*(_param->cycle-1);
-			_info.fps1000=(uint32_t)(_info.fps1000/_param->cycle);
-			
+                    updateInfo();
 		}
-		last_request = -1;
-		firsttime = true;
 		sum = (unsigned int *) ADM_alloc(MAX_BLOCKS * MAX_BLOCKS * sizeof(unsigned int));
 		ADM_assert(sum);		
-		all_video_cycle = true;
+	
 
-		if (debug)
+		if (configuration.debug)
 		{
 			OutputDebugString( "Decimate %s by Donald Graft, Copyright 2003\n", 0); // VERSION
 		}
-	}
+
+        reset();
 }
 /**
     \fn getCoupledConf
@@ -213,609 +197,414 @@
 		vidCache=NULL;
 		sum=NULL;
 }
+
 /**
-    \fn DrawShow
+    \fn getNextFrame
 */
-void Decimate::DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
-						double metric, int inframe)
-{
-	char buf[80];
-	int start = (useframe / _param->cycle) * _param->cycle;
 
-	if (show == true)
-	{
-		sprintf(buf, "Decimate %s", 0); // VERSION
-		DrawString(src, 0, 0, buf);
-		sprintf(buf, "Copyright 2003 Donald Graft");
-		DrawString(src, 0, 1, buf);
-		sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
-		DrawString(src, 0, 3, buf);
-		sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
-		DrawString(src, 0, 4, buf);
-		sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
-		DrawString(src, 0, 5, buf);
-		sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
-		DrawString(src, 0, 6, buf);
-		sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
-		DrawString(src, 0, 7, buf);
-		if (all_video_cycle == false)
-		{
-			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
-			DrawString(src, 0, 8, buf);
-			if (forced == false)
-				sprintf(buf,"chose %d, dropping", dropframe);
-			else
-				sprintf(buf,"chose %d, dropping, forced!", dropframe);
-			DrawString(src, 0, 9, buf);
-		}
-		else
-		{
-			sprintf(buf,"in frm %d", inframe);
-			DrawString(src, 0, 8, buf);
-			sprintf(buf,"chose %d, decimating all-video cycle", dropframe);
-			DrawString(src, 0, 9, buf);
-		}
-	}
-	if (debug)
-	{
-		if (!(inframe%_param->cycle))
-		{
-			sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
-			OutputDebugString(buf);
-		}
-		if (all_video_cycle == false)
-		{
-			sprintf(buf,"Decimate: in frm %d useframe %d\n", inframe, useframe);
-			OutputDebugString(buf);
-			if (forced == false)
-				sprintf(buf,"Decimate: chose %d, dropping\n", dropframe);
-			else
-				sprintf(buf,"Decimate: chose %d, dropping, forced!\n", dropframe);
-			OutputDebugString(buf);
-		}
-		else
-		{
-			sprintf(buf,"Decimate: in frm %d\n", inframe);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: chose %d, decimating all-video cycle\n", dropframe);
-			OutputDebugString(buf);
-		}
-	}
+bool Decimate::getNextFrame(uint32_t *fn,ADMImage *data)
+{
+    switch(configuration.mode)
+    {
+        case 0: return get0(fn,data);break;
+        case 1: return get1(fn,data);break;
+        case 2: return get2(fn,data);break;
+        case 3: return get3(fn,data);break;     
+        default: ADM_assert(0);
+    }
+    return false;
 }
-//______________________________________________________________________
-uint8_t Decimate::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags)
+/**
+        \fn get0
+        \brief A B C... if B is close enough to A discard it.
+*/
+bool Decimate::get0(uint32_t *fn,ADMImage *data)
 {
-	int dropframe, useframe, nextfrm, wY, wUV, hY, hUV, x, y, pitchY, pitchUV, dpitchY, dpitchUV;
-	ADMImage  *src, *next, *dst;
-	unsigned char *srcrpY, *nextrpY, *dstwpY;
-	unsigned char *srcrpU, *nextrpU, *dstwpU;
-	unsigned char *srcrpV, *nextrpV, *dstwpV;
-	uint32_t inframe=frame;
-	double metric;
-	char buf[255];
+    
+    bool forced = false;
+    ADMImage *src,*next;
+    double metric;
+    char buf[256];
+    int useframe,dropframe;
+    int start;
+    deciMate *_param=&configuration;
+    /* Normal decimation. Remove the frame most similar to its preceding frame. */
+    /* Determine the correct frame to use and get it. */
+    int cycle=configuration.cycle;
+    int sourceFrame = (nextFrame*cycle)/(cycle-1);
+    int cycleStartFrame = (sourceFrame / cycle) * cycle;
+    int inframe=nextFrame;
+    *fn=nextFrame;
+    GETFRAME(sourceFrame, src);
+    if(!src)
+    {
+        ADM_info("Decimate: End of video stream, cannot get frame %d\n",useframe);
+        vidCache->unlockAll();
+        return false;
+    }
+    nextFrame++;
 
-        if(frame>= _info.nb_frames) return 0;
-	*len=(_info.width*_info.height*3)>>1;
-	num_frames_hi = _in->getInfo()->nb_frames; /* FIXME MEANX */
-	if (_param->mode == 0)
-	{
-		bool forced = false;
-		int start;
+    
+    FindDuplicate(cycleStartFrame, &dropframe, &metric, &forced);
+    if (sourceFrame >= dropframe) sourceFrame++;
+    GETFRAME(sourceFrame, src);
+    if(!src)
+    {
+        vidCache->unlockAll();
+        return false;
+    }
+    data->duplicate(src);
+    vidCache->unlockAll();
 
-		/* Normal decimation. Remove the frame most similar to its preceding frame. */
-		/* Determine the correct frame to use and get it. */
-		useframe = inframe + inframe / (_param->cycle - 1);
-		start = (useframe /  _param->cycle) * _param->cycle;
-		FindDuplicate((useframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
-		if (useframe >= dropframe) useframe++;
-		GETFRAME(useframe, src);
-		if (show == true)
-		{
-			sprintf(buf, "Decimate %s", 0);
-			DrawString(src, 0, 0, buf);
-			sprintf(buf, "Copyright 2003 Donald Graft");
-			DrawString(src, 0, 1, buf);
-			sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
-			DrawString(src, 0, 3, buf);
-			sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
-			DrawString(src, 0, 4, buf);
-			sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
-			DrawString(src, 0, 5, buf);
-			sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
-			DrawString(src, 0, 6, buf);
-			sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
-			DrawString(src, 0, 7, buf);
-			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
-			DrawString(src, 0, 8, buf);
-			sprintf(buf,"dropping frm %d%s", dropframe, last_forced == true ? ", forced!" : "");
-			DrawString(src, 0, 9, buf);
-		}
-		if (debug)
-		{	
-			if (!(inframe % _param->cycle))
-			{
-				sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
-				OutputDebugString(buf);
-			}
-			sprintf(buf,"Decimate: in frm %d, use frm %d\n", inframe, useframe);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: dropping frm %d%s\n", dropframe, last_forced == true ? ", forced!" : "");
-			OutputDebugString(buf);
-		}
-	    //return src;
-	        //memcpy(data,src,*len);
+    if (configuration.show == true)
+    {
+        sprintf(buf, "Decimate %d", 0);			                DrawString(data, 0, 0, buf);
+        sprintf(buf, "Copyright 2003 Donald Graft");			DrawString(data, 0, 1, buf);
+        sprintf(buf,"%d: %3.2f", start, showmetrics[0]);		DrawString(data, 0, 3, buf);
+        sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);	DrawString(data, 0, 4, buf);
+        sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);	DrawString(data, 0, 5, buf);
+        sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);	DrawString(data, 0, 6, buf);
+        sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);	DrawString(data, 0, 7, buf);
+        sprintf(buf,"in frm %d, use frm %d", inframe, useframe);DrawString(data, 0, 8, buf);
+        sprintf(buf,"dropping frm %d%s", dropframe, last_forced == true ? ", forced!" : "");
+        DrawString(data, 0, 9, buf);
+    }
+    if (configuration.debug)
+    {	
+        if (!(inframe % _param->cycle))
+        {
+            OutputDebugString("Decimate: %d: %3.2f\n", start, showmetrics[0]);
+            OutputDebugString("Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+            OutputDebugString("Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+            OutputDebugString("Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+            OutputDebugString("Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+        }
+        OutputDebugString("Decimate: in frm %d, use frm %d\n", inframe, useframe);
+        OutputDebugString("Decimate: dropping frm %d%s\n", dropframe, last_forced == true ? ", forced!" : "");
+    }		  
+    return true;
+}
+/**
+        \fn get1
+        \brief mode=1, A B C D => A  BC D, i.e. (B,C) is replaced by BC, blend between B & C
+*/
 
-		data->duplicate(src);
-		vidCache->unlockAll();
-		  
-		return 1;
-	}
-	else if (_param->mode == 1)
-	{
-		bool forced = false;
-		int start = (inframe / _param->cycle) * _param->cycle;
-		unsigned int hint, film = 1;
+bool Decimate::get1(uint32_t *fn,ADMImage *data)
+{
+    bool    forced = false;
+    ADMImage *src,*next;
+    int useframe,dropframe;
+    deciMate *_param=&configuration;
+    int cycle=configuration.cycle;
+    int sourceFrame = (nextFrame*cycle)/(cycle-1);
+    int  cycleStartFrame = (sourceFrame / cycle) * cycle;
+    unsigned int hint, film = 1;
+    int inframe=nextFrame;
+    double metric;
+    char buf[256];
+    
+    GETFRAME(sourceFrame, src);
+    if(!src)
+    {
+        ADM_info("Decimate: End of video stream, cannot get frame %d\n",useframe);
+        vidCache->unlockAll();
+        return false;
+    }
+    *fn=nextFrame;
+    nextFrame++;
 
-		GETFRAME(inframe, src);
-	    	srcrpY = YPLANE(src); //(unsigned char *) src->GetReadPtr(PLANAR_Y);
-		if (GetHintingData(srcrpY, &hint) == false)
-		{
-			film = hint & PROGRESSIVE;
-//			if (film) OutputDebugString("film\n");
-//			else OutputDebugString("video\n");
-		}
 
-		/* Find the most similar frame as above but replace it with a blend of
-		   the preceding and following frames. */
-		num_frames_hi = _in->getInfo()->nb_frames; /* FIXME MEANX */
-		FindDuplicate((inframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
-		if (!film || inframe != dropframe || (_param->threshold && metric > _param->threshold))
-		{
-			if (show == true)
-			{
+    if (GetHintingData(YPLANE(src), &hint) == false)
+    {
+        film = hint & PROGRESSIVE;
+    }
 
-				sprintf(buf, "Decimate %s", 0);
-				DrawString(src, 0, 0, buf);
-				sprintf(buf, "Copyright 2003 Donald Graft");
-				DrawString(src, 0, 1, buf);
-				sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
-				DrawString(src, 0, 3, buf);
-				sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
-				DrawString(src, 0, 4, buf);
-				sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
-				DrawString(src, 0, 5, buf);
-				sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
-				DrawString(src, 0, 6, buf);
-				sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
-				DrawString(src, 0, 7, buf);
-				sprintf(buf,"infrm %d", inframe);
-				DrawString(src, 0, 8, buf);
-				if (last_forced == false)
-					sprintf(buf,"chose %d, passing through", dropframe);
-				else
-					sprintf(buf,"chose %d, passing through, forced!", dropframe);
-				DrawString(src, 0, 9, buf);
-			}
-			if (debug)
-			{
-				if (!(inframe % _param->cycle))
-				{
-					sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
-					OutputDebugString(buf);
-					sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
-					OutputDebugString(buf);
-					sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
-					OutputDebugString(buf);
-					sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
-					OutputDebugString(buf);
-					sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
-					OutputDebugString(buf);
-				}
-				sprintf(buf,"Decimate: in frm %d\n", inframe);
-				OutputDebugString(buf);
-				if (last_forced == false)
-					sprintf(buf,"Decimate: chose %d, passing through\n", dropframe);
-				else
-					sprintf(buf,"Decimate: chose %d, passing through, forced!\n", dropframe);
-				OutputDebugString(buf);
-			}
-			//return src;
-			//memcpy(data,src,*len);
+    /* Find the most similar frame as above but replace it with a blend of
+       the preceding and following frames. */
+    FindDuplicate(cycleStartFrame, &dropframe, &metric, &forced);
+    if (!film || sourceFrame != dropframe || (_param->threshold && metric > _param->threshold))
+    {
+        data->duplicate(src);
+        vidCache->unlockAll();
+        if (configuration.show == true)
+        {
 
-			data->duplicate(src);
-			vidCache->unlockAll();
-			return 1;
-		}
-		if (inframe < _in->getInfo()->nb_frames - 1) /* FIXME MEANX*/
-			nextfrm = inframe + 1;
-		else
-			nextfrm = _in->getInfo()->nb_frames - 1;
-		if (debug)
-		{
-			if (!(inframe % _param->cycle))
-			{
-				sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
-				OutputDebugString(buf);
-			}
-			sprintf(buf,"Decimate: in frm %d\n", inframe);
-			OutputDebugString(buf);
-			if (last_forced == false)
-				sprintf(buf,"Decimate: chose %d, blending %d and %d\n", dropframe, inframe, nextfrm);
-			else
-				sprintf(buf,"Decimate: chose %d, blending %d and %d, forced!\n", dropframe, inframe, nextfrm);
-			OutputDebugString(buf);
-		}
-		GETFRAME(nextfrm, next);
-		dst = data; //env->NewVideoFrame(vi);
-		pitchY = _info.width; //src->GetPitch(PLANAR_Y);
-		dpitchY = _info.width; //dst->GetPitch(PLANAR_Y);
-		wY = _info.width; //src->GetRowSize(PLANAR_Y);
-		hY = _info.height; //src->GetHeight(PLANAR_Y);
-		pitchUV = _info.width>>1;// src->GetPitch(PLANAR_V);
-		dpitchUV =_info.width>>1;// dst->GetPitch(PLANAR_V);
-		wUV = _info.width>>1;//src->GetRowSize(PLANAR_V);
-		hUV = _info.height>>1;//src->GetHeight(PLANAR_V);
-		
-		nextrpY = YPLANE(next); //next->GetReadPtr(PLANAR_Y);
-		dstwpY = YPLANE( dst); //dst->GetWritePtr(PLANAR_Y);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		if (CpuCaps::hasSSE()) 
-		{
-			isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
-		} else {
-#endif
-			for (y = 0; y < hY; y++)
-			{
-				for (x = 0; x < wY; x++)
-				{
-					dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x] ) >> 1;  
-				}
-				srcrpY += pitchY;
-				nextrpY += pitchY;
-				dstwpY += dpitchY;
-			}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		}
-#endif
-		srcrpU =   UPLANE(src);//->GetReadPtr(PLANAR_U);
-		nextrpU =   UPLANE(next);//->GetReadPtr(PLANAR_U);
-		dstwpU =  UPLANE(dst);//->GetWritePtr(PLANAR_U);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		if (CpuCaps::hasSSE()) 
-		{
-			isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
-		} else {
-#endif
-			for (y = 0; y < hUV; y++)
-			{
-				for (x = 0; x < wUV; x++)
-				{
-					dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) >> 1;
-				}
-				srcrpU += pitchUV;
-				nextrpU += pitchUV;
-				dstwpU += dpitchUV;
-			}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		}
-#endif
-		srcrpV =   VPLANE(src);//->GetReadPtr(PLANAR_V);
-		nextrpV =   VPLANE(next);//->GetReadPtr(PLANAR_V);
-		dstwpV =   VPLANE(dst);//->GetWritePtr(PLANAR_V);
+            sprintf(buf, "Decimate %d", 0);				DrawString(data, 0, 0, buf);
+            sprintf(buf, "Copyright 2003 Donald Graft");				DrawString(data, 0, 1, buf);
+            sprintf(buf,"%d: %3.2f", cycleStartFrame, showmetrics[0]);		    DrawString(data, 0, 3, buf);
+            sprintf(buf,"%d: %3.2f", cycleStartFrame + 1, showmetrics[1]);		DrawString(data, 0, 4, buf);
+            sprintf(buf,"%d: %3.2f", cycleStartFrame + 2, showmetrics[2]);		DrawString(data, 0, 5, buf);
+            sprintf(buf,"%d: %3.2f", cycleStartFrame + 3, showmetrics[3]);		DrawString(data, 0, 6, buf);
+            sprintf(buf,"%d: %3.2f", cycleStartFrame + 4, showmetrics[4]);		DrawString(data, 0, 7, buf);
+            sprintf(buf,"infrm %d", inframe);
+            DrawString(data, 0, 8, buf);
+            if (last_forced == false)
+                sprintf(buf,"chose %d, passing through", dropframe);
+            else
+                sprintf(buf,"chose %d, passing through, forced!", dropframe);
+            DrawString(data, 0, 9, buf);
+        }
+        if (configuration.debug)
+        {
+            if (!(inframe % _param->cycle))
+            {
+                OutputDebugString("Decimate: %d: %3.2f\n", start, showmetrics[0]);
+                OutputDebugString("Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+                OutputDebugString("Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+                OutputDebugString("Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+                OutputDebugString("Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+            }
+            OutputDebugString("Decimate: in frm %d\n", inframe);
+            
+            if (last_forced == false)
+            {
+                OutputDebugString("Decimate: chose %d, passing through\n", dropframe);
+            }
+            else
+            {
+                OutputDebugString("Decimate: chose %d, passing through, forced!\n", dropframe);
+            }
+        }
+        return true;
+    }
+    if (configuration.debug)
+    {
+        if (!(inframe % _param->cycle))
+        {
+            OutputDebugString( "Decimate: %d: %3.2f\n", start, showmetrics[0]);
+            OutputDebugString( "Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+            OutputDebugString( "Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+            OutputDebugString( "Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+            OutputDebugString( "Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+        }
+        OutputDebugString("Decimate: in frm %d\n", inframe);
+        
+        if (last_forced == false)
+        {
+            OutputDebugString("Decimate: chose %d, blending %d and %d\n", dropframe, inframe, nextfrm);
+        }
+        else
+        {
+            OutputDebugString("Decimate: chose %d, blending %d and %d, forced!\n", dropframe, inframe, nextfrm);
+        }			
+    }
+    // Blend current frame with next frame
+    GETFRAME(sourceFrame+1, next);
+    if(!next)
+        data->duplicate(src);
+    else
+        data->blend(src,next);
+    vidCache->unlockAll();		
+    if (configuration.show == true)
+    {
 
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		if (CpuCaps::hasSSE()) { 
-			isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV );
-		} else {
-#endif
-			for (y = 0; y < hUV; y++)
-			{
-				for (x = 0; x < wUV; x++)
-				{
-					dstwpV[x] = ((int)srcrpV[x] + + (int)nextrpV[x]) >> 1;
-				}
-				srcrpV += pitchUV;
-				nextrpV += pitchUV;
-				dstwpV += dpitchUV;
-			}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		}
-#endif
-		if (show == true)
-		{
+        sprintf(buf, "Decimate %d", 0);			DrawString(data, 0, 0, buf);
+        sprintf(buf, "Copyright 2003 Donald Graft");			DrawString(data, 0, 1, buf);
+        sprintf(buf,"%d: %3.2f", cycleStartFrame, showmetrics[0]);		DrawString(data, 0, 3, buf);
+        sprintf(buf,"%d: %3.2f", cycleStartFrame + 1, showmetrics[1]);	DrawString(data, 0, 4, buf);
+        sprintf(buf,"%d: %3.2f", cycleStartFrame + 2, showmetrics[2]);	DrawString(data, 0, 5, buf);
+        sprintf(buf,"%d: %3.2f", cycleStartFrame + 3, showmetrics[3]);	DrawString(data, 0, 6, buf);
+        sprintf(buf,"%d: %3.2f", cycleStartFrame + 4, showmetrics[4]);	DrawString(data, 0, 7, buf);
+        sprintf(buf,"infrm %d", inframe);
+        DrawString(data, 0, 8, buf);
+        if (last_forced == false)
+            sprintf(buf,"chose %d, blending %d and %d",dropframe, sourceFrame, sourceFrame+1);
+        else
+            sprintf(buf,"chose %d, blending %d and %d, forced!", dropframe, sourceFrame, sourceFrame+1);
+        DrawString(data, 0, 9, buf);
+    }
+    
+    return true;
+}
+/**
+        \fn get2
+        \fn remove one frame from longest duplicate (anime)
+*/
 
-			sprintf(buf, "Decimate %s", 0);
-			DrawString(dst, 0, 0, buf);
-			sprintf(buf, "Copyright 2003 Donald Graft");
-			DrawString(dst, 0, 1, buf);
-			sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
-			DrawString(dst, 0, 3, buf);
-			sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
-			DrawString(dst, 0, 4, buf);
-			sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
-			DrawString(dst, 0, 5, buf);
-			sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
-			DrawString(dst, 0, 6, buf);
-			sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
-			DrawString(dst, 0, 7, buf);
-			sprintf(buf,"infrm %d", inframe);
-			DrawString(dst, 0, 8, buf);
-			if (last_forced == false)
-				sprintf(buf,"chose %d, blending %d and %d",dropframe, inframe, nextfrm);
-			else
-				sprintf(buf,"chose %d, blending %d and %d, forced!", dropframe, inframe, nextfrm);
-			DrawString(dst, 0, 9, buf);
-		}
-		//return dst;
-		//memcpy(data,dst,*len);
+bool Decimate::get2(uint32_t *fn,ADMImage *data)
+{
+    bool forced = false;
+    double metric;
+    char buf[256];
+    
+    deciMate *_param=&configuration;
+    int cycle=configuration.cycle;
+    int sourceFrame = (nextFrame*cycle)/(cycle-1);
+    int cycleStartFrame = (sourceFrame / cycle) * cycle;
+    int useframe,dropframe;
+    *fn=nextFrame;
+    int inframe=nextFrame;
+    ADMImage *src,*next;
+    GETFRAME(sourceFrame, src);
+    if(!src)
+    {
+        ADM_info("Decimate: End of video stream, cannot get frame %d\n",useframe);
+        vidCache->unlockAll();
+        return false;
+    }
+    nextFrame++;
+    /* Delete the duplicate in the longest string of duplicates. */
+    FindDuplicate2(cycleStartFrame, &dropframe, &forced);
+    if (sourceFrame >= dropframe) 
+        sourceFrame++;
+    GETFRAME(sourceFrame, src);
+    if(!src)
+    {
+        vidCache->unlockAll();
+        return false;
+    }
+    data->duplicate(src);
+    vidCache->unlockAll();
+    if (configuration.show == true)
+    {
+        int start = (useframe / _param->cycle) * _param->cycle;
 
-		data->duplicate(dst);
-		vidCache->unlockAll();		
-		return 1;
-	}
-	else if (_param->mode == 2)
-	{
-		bool forced = false;
 
-		/* Delete the duplicate in the longest string of duplicates. */
-		useframe = inframe + inframe / (_param->cycle - 1);
-		FindDuplicate2((useframe / _param->cycle) * _param->cycle, &dropframe, &forced);
-		if (useframe >= dropframe) useframe++;
-		GETFRAME(useframe, src);
-		if (show == true)
-		{
-			int start = (useframe / _param->cycle) * _param->cycle;
+        sprintf(buf, "Decimate %d", 0);			DrawString(data, 0, 0, buf);
+        sprintf(buf, "Copyright 2003 Donald Graft");			    DrawString(data, 0, 1, buf);
+        sprintf(buf,"in frm %d, use frm %d", inframe, useframe);	DrawString(data, 0, 3, buf);
+        sprintf(buf,"%d: %3.2f (%s)", cycleStartFrame, showmetrics[0], Dshow[0] ? "new" : "dup");	DrawString(data, 0, 4, buf);
+        sprintf(buf,"%d: %3.2f (%s)", cycleStartFrame + 1, showmetrics[1],Dshow[1] ? "new" : "dup");DrawString(data, 0, 5, buf);
+        sprintf(buf,"%d: %3.2f (%s)", cycleStartFrame + 2, showmetrics[2],Dshow[2] ? "new" : "dup");DrawString(data, 0, 6, buf);
+        sprintf(buf,"%d: %3.2f (%s)", cycleStartFrame + 3, showmetrics[3],Dshow[3] ? "new" : "dup");DrawString(data, 0, 7, buf);
+        sprintf(buf,"%d: %3.2f (%s)", cycleStartFrame + 4, showmetrics[4],Dshow[4] ? "new" : "dup");DrawString(data, 0, 8, buf);
+        sprintf(buf,"Dropping frm %d%s", dropframe, last_forced == true ? " forced!" : "");
+        DrawString(data, 0, 9, buf);
+    }
+    if (configuration.debug)
+    {	
+        sprintf(buf,"Decimate: inframe %d useframe %d\n", inframe, useframe);
+        OutputDebugString(buf);
+    }
+    return true;
+}
+/**
+        \fn get3
+        \brief ivtc (after telecide)
+*/
 
-
-			sprintf(buf, "Decimate %s", 0);
-			DrawString(src, 0, 0, buf);
-			sprintf(buf, "Copyright 2003 Donald Graft");
-			DrawString(src, 0, 1, buf);
-			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
-			DrawString(src, 0, 3, buf);
-			sprintf(buf,"%d: %3.2f (%s)", start, showmetrics[0],
-					Dshow[0] ? "new" : "dup");
-			DrawString(src, 0, 4, buf);
-			sprintf(buf,"%d: %3.2f (%s)", start + 1, showmetrics[1],
-					Dshow[1] ? "new" : "dup");
-			DrawString(src, 0, 5, buf);
-			sprintf(buf,"%d: %3.2f (%s)", start + 2, showmetrics[2],
-					Dshow[2] ? "new" : "dup");
-			DrawString(src, 0, 6, buf);
-			sprintf(buf,"%d: %3.2f (%s)", start + 3, showmetrics[3],
-					Dshow[3] ? "new" : "dup");
-			DrawString(src, 0, 7, buf);
-			sprintf(buf,"%d: %3.2f (%s)", start + 4, showmetrics[4],
-					Dshow[4] ? "new" : "dup");
-			DrawString(src, 0, 8, buf);
-			sprintf(buf,"Dropping frm %d%s", dropframe, last_forced == true ? " forced!" : "");
-			DrawString(src, 0, 9, buf);
-		}
-		if (debug)
-		{	
-			sprintf(buf,"Decimate: inframe %d useframe %d\n", inframe, useframe);
-			OutputDebugString(buf);
-		}
-	    //return src;
-	    	//memcpy(data,src,*len);
-
-		data->duplicate(src);
-		vidCache->unlockAll();
-		return 1;
-	}
-	else if (_param->mode == 3)
-	{
-		bool forced = false;
-
-		/* Decimate by removing a duplicate from film cycles and doing a
-		   blend rate conversion on the video cycles. */
-		if (_param->cycle != 5)//	env->ThrowError("Decimate: mode=3 requires cycle=5");
-		{
-			printf("Decimate: mode=3 requires cycle=5\n");
-			return 0;
-		}
-		useframe = inframe + inframe / (_param->cycle - 1);
-		FindDuplicate((useframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
-		/* Use hints from Telecide about film versus video. Also use the difference
-		   metric of the most similar frame in the cycle; if it exceeds threshold,
-		   assume it's a video cycle. */
-		if (!(inframe % 4))
-		{
-			all_video_cycle = false;
-			if (_param->threshold && metric > _param->threshold)
-			{
-				all_video_cycle = true;
-			}
-			if ((hints_invalid == false) &&
-				(!(hints[0] & PROGRESSIVE) ||
-				 !(hints[1] & PROGRESSIVE) ||
-				 !(hints[2] & PROGRESSIVE) ||
-				 !(hints[3] & PROGRESSIVE) ||
-				 !(hints[4] & PROGRESSIVE)))
-			{
-				all_video_cycle = true;
-			}
-		}
-		if (all_video_cycle == false)
-		{
-			/* It's film, so decimate in the normal way. */
-			if (useframe >= dropframe) useframe++;
-			GETFRAME(useframe, src);
-			DrawShow(src, useframe, forced, dropframe, metric, inframe);			
-			//memcpy(data,src,*len);
-
-			data->duplicate(src);
-		
-			vidCache->unlockAll();		
-			return 1; // return src;
-		}
-		else if ((inframe % 4) == 0)
-		{
-			/* It's a video cycle. Output the first frame of the cycle. */
-			GETFRAME(useframe, src);
-			DrawShow(src, 0, forced, dropframe, metric, inframe);
-			//return src;
-			//memcpy(data,src,*len);
-
-			data->duplicate(src);
-		
-			vidCache->unlockAll();		
-			return 1; // return src;
-		}
-		else if ((inframe % 4) == 3)
-		{
-			/* It's a video cycle. Output the last frame of the cycle. */
-			GETFRAME(useframe+1, src);
-			DrawShow(src, 0, forced, dropframe, metric, inframe);
-			//return src;
-			//memcpy(data,src,*len);
-
-			data->duplicate(src);
-		
-			vidCache->unlockAll();		
-			return 1; // return src;
-		}
-		else if ((inframe % 4) == 1 || (inframe % 4) == 2)
-		{
-			/* It's a video cycle. Make blends for the remaining frames. */
-			if ((inframe % 4) == 1)
-			{
-				GETFRAME(useframe, src);
-				if (useframe < num_frames_hi - 1)
-					nextfrm = useframe + 1;
-				else
-					nextfrm = _in->getInfo()->nb_frames - 1;
-				GETFRAME(nextfrm, next);
-			}
-			else
-			{
-				GETFRAME(useframe + 1, src);
-				nextfrm = useframe;
-				GETFRAME(nextfrm, next);
-			}
-			dst = data; //env->NewVideoFrame(vi);
-			pitchY = _info.width; //src->GetPitch(PLANAR_Y);
-			dpitchY = _info.width; //dst->GetPitch(PLANAR_Y);
-			wY = _info.width; //src->GetRowSize(PLANAR_Y);
-			hY = _info.height; //src->GetHeight(PLANAR_Y);
-			pitchUV = _info.width>>1; //src->GetPitch(PLANAR_V);
-			dpitchUV =_info.width>>1; // dst->GetPitch(PLANAR_V);
-			wUV = _info.width>>1; //src->GetRowSize(PLANAR_V);
-			hUV = _info.height>>1; //src->GetHeight(PLANAR_V);
-			
-			srcrpY = YPLANE( src); //src->GetReadPtr(PLANAR_Y);
-			nextrpY = YPLANE( next); //next->GetReadPtr(PLANAR_Y);
-			dstwpY = YPLANE( dst); //dst->GetWritePtr(PLANAR_Y);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			if (CpuCaps::hasSSE()) { 
-				isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
-			} else {
-#endif
-				for (y = 0; y < hY; y++)
-				{
-					for (x = 0; x < wY; x++)
-					{
-						dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x]) >> 1;
-					}
-					srcrpY += pitchY;
-					nextrpY += pitchY;
-					dstwpY += dpitchY;
-				}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			}
-#endif
-			srcrpU =   UPLANE(src);//->GetReadPtr(PLANAR_U);
-			nextrpU =  UPLANE( next);//->GetReadPtr(PLANAR_U);
-			dstwpU =   UPLANE(dst);//->GetWritePtr(PLANAR_U);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			if (CpuCaps::hasSSE()) { 
-				isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
-			} else {
-#endif
-				for (y = 0; y < hUV; y++)
-				{
-					for (x = 0; x < wUV; x++)
-					{
-						dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) >> 1;
-					}
-					srcrpU += pitchUV;
-					nextrpU += pitchUV;
-					dstwpU += dpitchUV;
-				}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			}
-#endif
-			srcrpV =   VPLANE(src);//->GetReadPtr(PLANAR_V);
-			nextrpV =  VPLANE( next);//->GetReadPtr(PLANAR_V);
-			dstwpV =   VPLANE(dst);//->GetWritePtr(PLANAR_V);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			if (CpuCaps::hasSSE()) { 
-				isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV);
-			} else {
-#endif
-				for (y = 0; y < hUV; y++)
-				{
-					for (x = 0; x < wUV; x++)
-					{
-						dstwpV[x] = ((int)srcrpV[x] + (int)nextrpV[x]) >> 1;
-					}
-					srcrpV += pitchUV;
-					nextrpV += pitchUV;
-					dstwpV += dpitchUV;
-				}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			}
-#endif
-			DrawShow(dst, 0, forced, dropframe, metric, inframe);
-			vidCache->unlockAll();
-			//return dst;
-			//memcpy(data,dst,*len);
-
-			data->duplicate(dst);
-			vidCache->unlockAll();		
-			return 1; // return src;			
-		}
-		//return src;
-		//memcpy(data,src,*len);
-
-                GETFRAME(useframe, src); // MEANX : not sure (jw detected a problem here)
-		data->duplicate(src);
-		vidCache->unlockAll();		
-		return 1; // return src;			
-	}
-	//env->ThrowError("Decimate: invalid mode option (0-3)");
-	printf("Decimate: invalid mode option (0-3)\n");
-	/* Avoid compiler warning. */
-	return 0;
+bool Decimate::get3(uint32_t *fn,ADMImage *data)
+{
+    bool forced = false;
+    ADMImage *src,*next;
+    int     dropframe;
+    double  metric;
+    char buf[256];
+    
+    deciMate *_param=&configuration;
+    /* Decimate by removing a duplicate from film cycles and doing a
+       blend rate conversion on the video cycles. */
+    if (_param->cycle != 5)//	env->ThrowError("Decimate: mode=3 requires cycle=5");
+    {
+        ADM_error("Decimate: mode=3 requires cycle=5\n");
+        return false;
+    }
+    int     sourceFrame = (nextFrame*5)/4;
+    int     cycleStartFrame = (sourceFrame /5) * 5;
+    
+    *fn=nextFrame;
+    GETFRAME(sourceFrame, src);
+    if(!src)
+    {
+        ADM_info("Decimate: End of video stream, cannot get frame %d\n",sourceFrame);
+        vidCache->unlockAll();
+        return false;
+    }
+    int inframe=nextFrame;
+    nextFrame++;
+    FindDuplicate(cycleStartFrame, &dropframe, &metric, &forced);
+    /* Use hints from Telecide about film versus video. Also use the difference
+       metric of the most similar frame in the cycle; if it exceeds threshold,
+       assume it's a video cycle. */
+    if (!(inframe % 4))
+    {
+        all_video_cycle = false;
+        if (_param->threshold && metric > _param->threshold)
+        {
+            all_video_cycle = true;
+        }
+        if ((hints_invalid == false) &&
+            (!(hints[0] & PROGRESSIVE) ||
+             !(hints[1] & PROGRESSIVE) ||
+             !(hints[2] & PROGRESSIVE) ||
+             !(hints[3] & PROGRESSIVE) ||
+             !(hints[4] & PROGRESSIVE)))
+        {
+            all_video_cycle = true;
+        }
+    }
+    if (all_video_cycle == false)
+    {
+        /* It's film, so decimate in the normal way. */
+        if (sourceFrame >= dropframe) sourceFrame++;
+        GETFRAME(sourceFrame, src);
+        if(!src)
+        {
+            vidCache->unlockAll();
+            return false;
+        }
+        data->duplicate(src);    
+        vidCache->unlockAll();		
+        DrawShow(data, sourceFrame, forced, dropframe, metric, inframe);			
+        return true; // return src;
+    }
+    else 
+    {
+        switch(inframe %4)
+        {
+            case 0:
+                /* It's a video cycle. Output the first frame of the cycle. */
+                GETFRAME(sourceFrame, src);
+                data->duplicate(src);
+                vidCache->unlockAll();		
+                break;
+            case 3:
+                /* It's a video cycle. Output the last frame of the cycle. */
+                GETFRAME(sourceFrame+1, src);
+                if(!src)
+                {
+                    vidCache->unlockAll();		
+                    return false;
+                }
+                data->duplicate(src);
+                vidCache->unlockAll();		
+                break;
+            case 1: case 2:
+                /* It's a video cycle. Make blends for the remaining frames. */
+                if ((inframe % 4) == 1)  // MEANX dont undestand the difference ?
+                {
+                    GETFRAME(sourceFrame, src);
+                    GETFRAME(sourceFrame+1, next);
+                    if(!next) next=src;
+                }
+                else
+                {
+                    GETFRAME(sourceFrame + 1, src);
+                    GETFRAME(sourceFrame, next);
+                    if(!src) src=next;
+                }
+                data->blend(src,next);
+                vidCache->unlockAll();
+                break;
+            default:
+                ADM_assert(0);break;
+        }
+        DrawShow(data, 0, forced, dropframe, metric, inframe);
+        return true; // return src;			
+    }
+    GETFRAME(sourceFrame, src); // MEANX : not sure (jw detected a problem here)
+    data->duplicate(src);
+    vidCache->unlockAll();		
+    DrawShow(data, 0, forced, dropframe, metric, inframe);
+	return true;
 }
 
+/**
+    \fn goToTime
+*/
 bool                Decimate::goToTime(uint64_t usSeek)
 {
+    reset();
     return ADM_coreVideoFilter::goToTime(usSeek);
 }
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h	2011-07-14 17:40:21 UTC (rev 7321)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h	2011-07-14 17:40:22 UTC (rev 7322)
@@ -16,6 +16,18 @@
 
 #define DrawString drawString
 
+#define GETFRAME(g, fp) \
+{ \
+	int GETFRAMEf=g; \
+	if (GETFRAMEf < 0) GETFRAMEf = 0; \
+	(fp) = vidCache->getImage(GETFRAMEf); \
+}
+#if 1
+    #define aprintf(...) {}
+#else
+    #define aprintf ADM_info
+#endif
+#define OutputDebugString aprintf
 
 /**
     \class Telecide
@@ -26,7 +38,6 @@
 protected:
         deciMate           configuration;
 protected:
-        int 			num_frames_hi;
         int last_request, last_result;
         bool last_forced;
         double last_metric;
@@ -40,18 +51,14 @@
         bool hints_invalid;
         bool all_video_cycle;
         bool firsttime;
-        int heightY, row_sizeY, pitchY;
-        int heightUV, row_sizeUV, pitchUV;
-        int pitch, row_size, height;
         int xblocks, yblocks;
         unsigned int *sum, div;
-        bool debug, show;
         
         VideoCache	*vidCache;
 public:
-                            Decimate(ADM_coreVideoFilter *previous,CONFcouple *conf);
-                            ~Decimate();
-        bool                goToTime(uint64_t usSeek);
+                             Decimate(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                             ~Decimate();
+        bool                 goToTime(uint64_t usSeek);
         virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
         virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
         virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
@@ -62,7 +69,11 @@
 		                              double metric, int inframe );
         void   		FindDuplicate(int frame, int *chosen, double *metric, bool *forced   );
     	void   		FindDuplicate2(int frame, int *chosen, bool *forced );
-    	void   		FindDuplicateYUY2(int frame, int *chosen, double *metric, bool *force);
-    	void   		FindDuplicate2YUY2(int frame, int *chosen, bool *forced );
-	
+        void        updateInfo(void);
+        uint32_t    computeDiff(ADMImage *current,ADMImage *previous);
+        void        reset(void);
+        bool        get0(uint32_t *fn,ADMImage *data);
+        bool        get1(uint32_t *fn,ADMImage *data);
+        bool        get2(uint32_t *fn,ADMImage *data);
+        bool        get3(uint32_t *fn,ADMImage *data);
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	2011-07-14 17:40:21 UTC (rev 7321)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	2011-07-14 17:40:22 UTC (rev 7322)
@@ -43,8 +43,87 @@
 
 #include "ADM_default.h"
 #include "decimate.h"
+/**
+    \fn computeDiff
+    \brief compute difference between image and its predecessor
+*/
+uint32_t Decimate::computeDiff(ADMImage *current,ADMImage *previous)
+{
+    uint8_t *prevY = previous->GetReadPtr(PLANAR_Y);
+    uint8_t *currY = current->GetReadPtr(PLANAR_Y);
+    uint32_t prevPitch=previous->GetPitch(PLANAR_Y);
+    uint32_t curPitch=current->GetPitch(PLANAR_Y);
+    deciMate *_param=&configuration;
+    // Zero
+    for (int y = 0; y < yblocks; y++)
+    {
+        for (int x = 0; x < xblocks; x++)
+        {
+            sum[y*xblocks+x] = 0;
+        }
+    }
+    // Raw diff
+    int height=info.height;
+    int width=info.width;
+    int inc=1;
+    
+    for (int y = 0; y < height; y++)
+    {
+        for (int x = 0; x < width;)
+        {
+            sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+            x++;
+            if(!(x&3))
+                if (_param->quality == 0 || _param->quality == 1)
+                {
+                    x+=12;
+                }
+        }
+        prevY += prevPitch;
+        currY += curPitch;
+    }
+    if (_param->quality == 1 || _param->quality == 3)
+    {
+#warning DO CHROMA SAMPLING
+#if 0
+        // also do u & v
+        prevU = storepU[f-1];
+        prevV = storepV[f-1];
+        currU = storepU[f];
+        currV = storepV[f];
+        for (y = 0; y < heightUV; y++)
+        {
+            for (x = 0; x < row_sizeUV;)
+            {
+                sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+                sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+                x++;
+                if (_param->quality == 1)
+                {
+                    if (!(x%4)) x += 12;
+                }
+            }
+            prevU += pitchUV;
+            currU += pitchUV;
+            prevV += pitchUV;
+            currV += pitchUV;
 
-
+        }
+#endif
+    }
+    uint32_t highest_sum = 0;
+    for (int y = 0; y < yblocks; y++)
+    {
+        for (int x = 0; x < xblocks; x++)
+        {
+            if (sum[y*xblocks+x] > highest_sum)
+            {
+                highest_sum = sum[y*xblocks+x];
+            }
+        }
+    }
+    return highest_sum;
+}
 /**
     \fn FindDuplicate
 */
@@ -52,13 +131,10 @@
 {
 	int f;
 	ADMImage  * store[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
-	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
-	int x, y, lowest_index, div;
+    deciMate  *_param=&configuration;
+	int          lowest_index, div;
 	unsigned int count[MAX_CYCLE_SIZE], lowest;
-	bool found;
+	bool         found;
 	unsigned int highest_sum=0;
 
 	/* Only recalculate differences when a new set is needed. */
@@ -71,28 +147,25 @@
 	last_request = frame;
 
 	/* Get cycle+1 frames starting at the one before the asked-for one. */
+    ADMImage *lastImage=NULL;
 	for (f = 0; f <= _param->cycle; f++)
 	{
 		GETFRAME(frame + f - 1, store[f]);
-		storepY[f] = YPLANE(store[f]);//->GetReadPtr(PLANAR_Y);
-		hints_invalid = GetHintingData((unsigned char *) storepY[f], &hints[f]);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
-			storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
-		}
+        if(store[f]) lastImage=store[f];
+            else store[f]=lastImage;
+        hints_invalid=GetHintingData(lastImage->GetReadPtr(PLANAR_Y),&hints[f]);
 	}
 
-    pitchY = _info.width; //store[0]->GetPitch(PLANAR_Y);
-    row_sizeY = _info.width; //store[0]->GetRowSize(PLANAR_Y);
-    heightY = _info.height; //store[0]->GetHeight(PLANAR_Y);
-	if (_param->quality == 1 || _param->quality == 3)
-	{
-		pitchUV = _info.width>>1; //store[0]->GetPitch(PLANAR_V);
-		row_sizeUV = _info.width>>1;//store[0]->GetRowSize(PLANAR_V);
-		heightUV = _info.height>>1;//store[0]->GetHeight(PLANAR_V);
-	}
+    if(!lastImage) 
+    {
+        *chosen=-1;
+        ADM_info("Cannot get input image\n");
+        return;
+    }
 
+    int row_sizeY = info.width; //store[0]->GetRowSize(PLANAR_Y);
+    int heightY = info.height; //store[0]->GetHeight(PLANAR_Y);
+
 	int use_quality=_param->quality;
 
 
@@ -120,65 +193,7 @@
 	/* Compare each frame to its predecessor. */
 	for (f = 1; f <= _param->cycle; f++)
 	{
-		prevY = storepY[f-1];
-		currY = storepY[f];
-		for (y = 0; y < yblocks; y++)
-		{
-			for (x = 0; x < xblocks; x++)
-			{
-				sum[y*xblocks+x] = 0;
-			}
-		}
-		for (y = 0; y < heightY; y++)
-		{
-			for (x = 0; x < row_sizeY;)
-			{
-				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
-				x++;
-				if (_param->quality == 0 || _param->quality == 1)
-				{
-					if (!(x%4)) x += 12;
-				}
-			}
-			prevY += pitchY;
-			currY += pitchY;
-		}
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			prevU = storepU[f-1];
-			prevV = storepV[f-1];
-			currU = storepU[f];
-			currV = storepV[f];
-			for (y = 0; y < heightUV; y++)
-			{
-				for (x = 0; x < row_sizeUV;)
-				{
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
-					x++;
-					if (_param->quality == 1)
-					{
-						if (!(x%4)) x += 12;
-					}
-				}
-				prevU += pitchUV;
-				currU += pitchUV;
-				prevV += pitchUV;
-				currV += pitchUV;
-			}
-		}
-		highest_sum = 0;
-		for (y = 0; y < yblocks; y++)
-		{
-			for (x = 0; x < xblocks; x++)
-			{
-				if (sum[y*xblocks+x] > highest_sum)
-				{
-					highest_sum = sum[y*xblocks+x];
-				}
-			}
-		}
-		count[f-1] = highest_sum;
+		count[f-1] = computeDiff(store[f],store[f-1]);
 		showmetrics[f-1] = (count[f-1] * 100.0) / div;
 	}
 
@@ -194,7 +209,7 @@
 		lowest = count[0];
 		lowest_index = 0;
 	}
-	for (x = 1; x < _param->cycle; x++)
+	for (int x = 1; x < _param->cycle; x++)
 	{
 		if (count[x] < lowest)
 		{
@@ -209,11 +224,10 @@
 		last_metric = (lowest * 100.0) / div;
 	*chosen = last_result;
 	*metric = last_metric;
-
 	
 	found = false;
 	last_forced = false;	
-
+    return;
 }
 /**
     \fn FindDuplicate2
@@ -222,9 +236,6 @@
 {
 	int f, g, fsum, bsum, highest, highest_index;
 	ADMImage * store[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
 	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
 	int x, y;
 	double lowest;
@@ -233,7 +244,7 @@
 	unsigned int highest_sum;
 	bool found;
 #define BLKSIZE 32
-
+    deciMate *_param=&configuration;
 	/* Only recalculate differences when a new cycle is started. */
 	if (frame == last_request)
 	{
@@ -247,34 +258,14 @@
 	{
 		firsttime = false;
 		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = -1;
-		GETFRAME(frame, store[0]);
-		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
-			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
-		}
-
 		for (f = 1; f <= _param->cycle; f++)
 		{
 			GETFRAME(frame + f - 1, store[f]);
-			storepY[f] =YPLANE( store[f]);//->GetReadPtr(PLANAR_Y);
-			if (_param->quality == 1 || _param->quality == 3)
-			{
-				storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
-				storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
-			}
 		}
 
-		pitchY = _info.width; //store[0]->GetPitch(PLANAR_Y);
-		row_sizeY = _info.width; //store[0]->GetRowSize(PLANAR_Y);
-		heightY = _info.height; //store[0]->GetHeight(PLANAR_Y);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			pitchUV = _info.width>>1; //store[0]->GetPitch(PLANAR_V);
-			row_sizeUV = _info.width>>1; //store[0]->GetRowSize(PLANAR_V);
-			heightUV = _info.height>>1; //store[0]->GetHeight(PLANAR_V);
-		}
+		int row_sizeY = info.width; //store[0]->GetRowSize(PLANAR_Y);
+		int heightY = info.height; //store[0]->GetHeight(PLANAR_Y);
+
 		switch (_param->quality)
 		{
 		case 0: // subsample, luma only
@@ -298,64 +289,7 @@
 		/* Compare each frame to its predecessor. */
 		for (f = 1; f <= _param->cycle; f++)
 		{
-			for (y = 0; y < yblocks; y++)
-			{
-				for (x = 0; x < xblocks; x++)
-				{
-					sum[y*xblocks+x] = 0;
-				}
-			}
-			prevY = storepY[f-1];
-			currY = storepY[f];
-			for (y = 0; y < heightY; y++)
-			{
-				for (x = 0; x < row_sizeY;)
-				{
-					sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
-					x++;
-					if (_param->quality == 0 || _param->quality == 1)
-					{
-						if (!(x%4)) x += 12;
-					}
-				}
-				prevY += pitchY;
-				currY += pitchY;
-			}
-			if (_param->quality == 1 || _param->quality == 3)
-			{
-				prevU = storepU[f-1];
-				currU = storepU[f];
-				prevV = storepV[f-1];
-				currV = storepV[f];
-				for (y = 0; y < heightUV; y++)
-				{
-					for (x = 0; x < row_sizeUV;)
-					{
-						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
-						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
-						x++;
-						if (_param->quality == 0 || _param->quality == 1)
-						{
-							if (!(x%4)) x += 12;
-						}
-					}
-					prevU += pitchUV;
-					currU += pitchUV;
-					prevV += pitchUV;
-					currV += pitchUV;
-				}
-			}
-			highest_sum = 0;
-			for (y = 0; y < yblocks; y++)
-			{
-				for (x = 0; x < xblocks; x++)
-				{
-					if (sum[y*xblocks+x] > highest_sum)
-					{
-						highest_sum = sum[y*xblocks+x];
-					}
-				}
-			}
+			highest_sum = computeDiff(store[f],store[f-1]);
 			metrics[f-1] = (highest_sum * 100.0) / div;
 		}
 
@@ -366,34 +300,16 @@
 			else Dcurr[f] = 1;
 		}
 
-		if (debug)
+		if (configuration.debug)
 		{
-			sprintf(buf,"Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n",
+			OutputDebugString(buf,"Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n",
 					0, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
-			OutputDebugString(buf);
+			
 		}
-	}
- 	else if (frame >= num_frames_hi - 1)
-	{
-		GETFRAME(num_frames_hi - 1, store[0]);
-		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
-			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
-		}
-		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
-		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
-	}
+	} // / !frame || first time
 	else
 	{
 		GETFRAME(frame + _param->cycle - 1, store[0]);
-		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
-			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
-		}
 		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
 		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
 	}
@@ -403,75 +319,12 @@
 	for (f = 1; f <= _param->cycle; f++)
 	{
 		GETFRAME(frame + f + _param->cycle - 1, store[f]);
-		storepY[f] =YPLANE( store[f]);//->GetReadPtr(PLANAR_Y);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
-			storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
-		}
 	}
 
 	/* Compare each frame to its predecessor. */
 	for (f = 1; f <= _param->cycle; f++)
 	{
-		prevY = storepY[f-1];
-		currY = storepY[f];
-		for (y = 0; y < yblocks; y++)
-		{
-			for (x = 0; x < xblocks; x++)
-			{
-				sum[y*xblocks+x] = 0;
-			}
-		}
-		for (y = 0; y < heightY; y++)
-		{
-			for (x = 0; x < row_sizeY;)
-			{
-				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
-				x++;
-				if (_param->quality == 0 || _param->quality == 1)
-				{
-					if (!(x%4)) x += 12;
-				}
-			}
-			prevY += pitchY;
-			currY += pitchY;
-		}
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			prevU = storepU[f-1];
-			currU = storepU[f];
-			prevV = storepV[f-1];
-			currV = storepV[f];
-			for (y = 0; y < heightUV; y++)
-			{
-				for (x = 0; x < row_sizeUV;)
-				{
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
-					x++;
-					if (_param->quality == 0 || _param->quality == 1)
-					{
-						if (!(x%4)) x += 12;
-					}
-				}
-				prevU += pitchUV;
-				currU += pitchUV;
-				prevV += pitchUV;
-				currV += pitchUV;
-			}
-		}
-		highest_sum = 0;
-		for (y = 0; y < yblocks; y++)
-		{
-			for (x = 0; x < xblocks; x++)
-			{
-				if (sum[y*xblocks+x] > highest_sum)
-				{
-					highest_sum = sum[y*xblocks+x];
-				}
-			}
-		}
+        highest_sum=computeDiff(store[f],store[f-1]);
 		metrics[f-1] = (highest_sum * 100.0) / div;
 	}
 
@@ -502,22 +355,22 @@
 		else Dnext[f] = 1;
 	}
 
-	if (debug)
+	if (configuration.debug)
 	{
-		sprintf(buf,"Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n",
+		OutputDebugString("Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n",
 		        frame + 5, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
-		OutputDebugString(buf);
+		
 	}
 
-	if (debug)
+	if (configuration.debug)
 	{
-		sprintf(buf,"Decimate: %d: %d %d %d %d %d\n",
+		OutputDebugString("Decimate: %d: %d %d %d %d %d\n",
 		        frame, Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4]);
 //		sprintf(buf,"Decimate: %d: %d %d %d %d %d - %d %d %d %d %d - %d %d %d %d %d\n",
 //		        frame, Dprev[0], Dprev[1], Dprev[2], Dprev[3], Dprev[4],
 //					   Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4],
 //					   Dnext[0], Dnext[1], Dnext[2], Dnext[3], Dnext[4]);
-		OutputDebugString(buf);
+		
 	}
 
 	/* Find the longest strings of duplicates and decimate a frame from it. */
@@ -598,10 +451,10 @@
 		*chosen = last_result = frame + highest_index;
 	}
 	last_forced = false;
-	if (debug)
+	if (configuration.debug)
 	{
-		sprintf(buf,"Decimate: dropping frame %d\n", last_result);
-		OutputDebugString(buf);
+		OutputDebugString("Decimate: dropping frame %d\n", last_result);
+		
 	}
 
 	
@@ -611,12 +464,76 @@
 	{
 		*chosen = last_result ;
 		*forced = last_forced = true;
-		if (debug)
+		if (configuration.debug)
 		{
-			sprintf(buf,"Decimate: overridden drop frame -- drop %d\n", last_result);
-			OutputDebugString(buf);
+			OutputDebugString("Decimate: overridden drop frame -- drop %d\n", last_result);
 		}
 	}
 }
+/**
+    \fn DrawShow
+*/
+void Decimate::DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
+						double metric, int inframe)
+{
+	char buf[80];
+    deciMate *_param=&configuration;
+	int start = (useframe / _param->cycle) * _param->cycle;
+
+	if (configuration.show == true)
+	{
+		sprintf(buf, "Decimate %d", 0); 	DrawString(src, 0, 0, buf);
+		sprintf(buf, "Copyright 2003 Donald Graft");	    DrawString(src, 0, 1, buf);
+		sprintf(buf,"%d: %3.2f", start, showmetrics[0]);	DrawString(src, 0, 3, buf);
+		sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);DrawString(src, 0, 4, buf);
+		sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);DrawString(src, 0, 5, buf);
+		sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);DrawString(src, 0, 6, buf);
+		sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);DrawString(src, 0, 7, buf);
+		if (all_video_cycle == false)
+		{
+			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
+			DrawString(src, 0, 8, buf);
+			if (forced == false)
+				sprintf(buf,"chose %d, dropping", dropframe);
+			else
+				sprintf(buf,"chose %d, dropping, forced!", dropframe);
+			DrawString(src, 0, 9, buf);
+		}
+		else
+		{
+			sprintf(buf,"in frm %d", inframe);			                    DrawString(src, 0, 8, buf);
+			sprintf(buf,"chose %d, decimating all-video cycle", dropframe);	DrawString(src, 0, 9, buf);
+		}
+	}
+	if (configuration.debug)
+	{
+		if (!(inframe%_param->cycle))
+		{
+			OutputDebugString(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
+			OutputDebugString(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+			OutputDebugString(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+			OutputDebugString(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+			OutputDebugString(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+			
+		}
+		if (all_video_cycle == false)
+		{
+			OutputDebugString(buf,"Decimate: in frm %d useframe %d\n", inframe, useframe);
+			if (forced == false)
+            {
+				OutputDebugString("Decimate: chose %d, dropping\n", dropframe);
+            }
+			else
+            {
+				OutputDebugString("Decimate: chose %d, dropping, forced!\n", dropframe);
+            }
+		}
+		else
+		{
+			OutputDebugString("Decimate: in frm %d\n", inframe);
+			OutputDebugString("Decimate: chose %d, decimating all-video cycle\n", dropframe);
+		}
+	}
+}
 // EOF
 



From mean at mail.berlios.de  Thu Jul 14 19:40:23 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 14 Jul 2011 19:40:23 +0200
Subject: [Avidemux-svn-commit] r7323 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6
Message-ID: <20110714174023.E600E481490@sheep.berlios.de>

Author: mean
Date: 2011-07-14 19:40:23 +0200 (Thu, 14 Jul 2011)
New Revision: 7323

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
Log:
[VideoFilters] Add decimate to the list of filters to build

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2011-07-14 17:40:22 UTC (rev 7322)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2011-07-14 17:40:23 UTC (rev 7323)
@@ -4,6 +4,7 @@
 ADD_SUBDIRECTORY(changeFps)
 ADD_SUBDIRECTORY(colorYUV)
 ADD_SUBDIRECTORY(crop)
+ADD_SUBDIRECTORY(decimate)
 ADD_SUBDIRECTORY(dummy)
 ADD_SUBDIRECTORY(fastConvolution)
 ADD_SUBDIRECTORY(horizontalFlip)



From mean at mail.berlios.de  Sat Jul 23 09:26:13 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 09:26:13 +0200
Subject: [Avidemux-svn-commit] r7324 - branches/avidemux_2.5_branch_gruntster
Message-ID: <20110723072613.AE4A3480C4B@sheep.berlios.de>

Author: mean
Date: 2011-07-23 09:26:13 +0200 (Sat, 23 Jul 2011)
New Revision: 7324

Modified:
   branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
Log:
[cmake] we are now 2.5.5

Modified: branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2011-07-14 17:40:23 UTC (rev 7323)
+++ branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2011-07-23 07:26:13 UTC (rev 7324)
@@ -97,7 +97,7 @@
 ########################################
 # Standard Avidemux defines
 ########################################
-SET(VERSION 2.5.4)
+SET(VERSION 2.5.5)
 
 # Define internal flags for GTK+ and Qt4 builds.  These are turned off
 # if a showstopper is found.  CLI is automatically assumed as possible



From mean at mail.berlios.de  Sat Jul 23 09:26:14 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 09:26:14 +0200
Subject: [Avidemux-svn-commit] r7325 -
	branches/avidemux_2.5_branch_gruntster/cmake/patches
Message-ID: <20110723072614.9FA05480C4B@sheep.berlios.de>

Author: mean
Date: 2011-07-23 09:26:14 +0200 (Sat, 23 Jul 2011)
New Revision: 7325

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/patches/common.mak.diff
Log:
[build] Update patch to lav* so that it compiles with 0.8

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/common.mak.diff
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/common.mak.diff	2011-07-23 07:26:13 UTC (rev 7324)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/common.mak.diff	2011-07-23 07:26:14 UTC (rev 7325)
@@ -1,13 +1,11 @@
-Index: common.mak
-===================================================================
---- common.mak	(revision 18300)
-+++ common.mak	(working copy)
-@@ -62,7 +62,7 @@
+--- common.mak.orig	2011-06-21 21:29:25.000000000 +0200
++++ common.mak	2011-07-23 08:46:48.027417188 +0200
+@@ -61,7 +61,7 @@
  FFLIBS    := $(FFLIBS-yes) $(FFLIBS)
  TESTPROGS += $(TESTPROGS-yes)
  
 -FFEXTRALIBS := $(addprefix -l,$(addsuffix $(BUILDSUF),$(FFLIBS))) $(EXTRALIBS)
 +FFEXTRALIBS := $(addprefix -lADM5,$(addsuffix $(BUILDSUF),$(FFLIBS))) $(EXTRALIBS)
- FFLDFLAGS   := $(addprefix -L$(BUILD_ROOT)/lib,$(ALLFFLIBS)) $(LDFLAGS)
+ FFLDFLAGS   := $(addprefix -Llib,$(ALLFFLIBS)) $(LDFLAGS)
  
  EXAMPLES  := $(addprefix $(SUBDIR),$(addsuffix -example$(EXESUF),$(EXAMPLES)))



From mean at mail.berlios.de  Sat Jul 23 09:26:15 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 09:26:15 +0200
Subject: [Avidemux-svn-commit] r7326 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska
Message-ID: <20110723072615.C523F480C4B@sheep.berlios.de>

Author: mean
Date: 2011-07-23 09:26:15 +0200 (Sat, 23 Jul 2011)
New Revision: 7326

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp
Log:
[mkv/read] In case a mkv has a zero frequency, replace it by 48 khz. Ugly hack, just so that it does not crash, it is still incomplete.

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp	2011-07-23 07:26:14 UTC (rev 7325)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp	2011-07-23 07:26:15 UTC (rev 7326)
@@ -179,7 +179,11 @@
       {
          uint32_t  streamIndex;
          mkvTrak *t=&(_tracks[1+_nbAudioTrack]);
-
+         if(!entry.fq)
+         {
+            printf("Warning : Zero frequency! Replacing it by 48000 hz, that might be incorrect\n");
+            entry.fq=48000; 
+         }
          t->wavHeader.encoding=entry.fcc;
          t->wavHeader.channels=entry.chan;
          t->wavHeader.frequency=entry.fq;



From mean at mail.berlios.de  Sat Jul 23 17:57:07 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 17:57:07 +0200
Subject: [Avidemux-svn-commit] r7327 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src
Message-ID: <20110723155707.58B06480EC9@sheep.berlios.de>

Author: mean
Date: 2011-07-23 17:57:06 +0200 (Sat, 23 Jul 2011)
New Revision: 7327

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp
Log:
[image] Fix + optimize blendSSE

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp	2011-07-23 07:26:15 UTC (rev 7326)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp	2011-07-23 15:57:06 UTC (rev 7327)
@@ -205,8 +205,59 @@
 
         return true;
 }
+/**
+    \fn blendSSE
+*/
+static bool blendSSE(int width, int height,
+                    uint8_t *target,uint32_t stride,
+                    uint8_t *src1,  uint32_t stride1,
+                    uint8_t *src2,  uint32_t stride2)
+{
+uint32_t ww,rr;
+uint8_t *s1,*s2,*d1;
+        int a1,a2;
 
+        ww=width>>3;
+        rr=width&7;
 
+          for(int y=0;y<height;y++)
+          {
+                int count=ww;
+                s1=src1;
+                s2=src2;
+                d1=target;
+                if(rr)
+                {
+                    blendC(rr,height,d1+(ww<<3), stride,s1+(ww<<3),stride1,s2+(ww<<3),stride2);
+                }
+
+                    
+                __asm__(
+                        "1: \n"
+                        "movq           (%0),%%mm0  \n"
+                        "movq           (%1),%%mm1  \n"
+                        "pavgb          %%mm1,%%mm0 \n"
+                        "movq           %%mm0,(%2)  \n"
+                        "add           $8,%0      \n"
+                        "add           $8,%1      \n"
+                        "add           $8,%2      \n"
+                        "sub           $1,%3      \n"
+                        "jnz             1b        \n"
+
+                : : "r" (s1),"r" (s2),"r"(d1),"r"(count)
+                );
+                src1+=stride1;
+                src2+=stride2;
+                target+=stride;
+           }
+        __asm__(
+                        "emms\n"
+                ::
+                );
+
+        return true;
+}
+
 #endif
 /**
     \fn blend
@@ -218,6 +269,8 @@
 #ifdef ADM_CPU_X86
     if(CpuCaps::hasMMX())
             myBlend=blendMMX;
+    if(CpuCaps::hasSSE())
+            myBlend=blendSSE;
 #endif
     ADM_assert(src1->_width==src2->_width);
     ADM_assert(_width==src2->_width);



From mean at mail.berlios.de  Sat Jul 23 17:57:08 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 17:57:08 +0200
Subject: [Avidemux-svn-commit] r7328 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide
Message-ID: <20110723155708.5D36D480EC9@sheep.berlios.de>

Author: mean
Date: 2011-07-23 17:57:08 +0200 (Sat, 23 Jul 2011)
New Revision: 7328

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
Log:
[telecide] More cleanup + set compute metric by default, so that decimate has the hinting

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	2011-07-23 15:57:06 UTC (rev 7327)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	2011-07-23 15:57:08 UTC (rev 7328)
@@ -75,7 +75,7 @@
 				_param->chroma = false;
 				_param->guide = GUIDE_32;// 0 / NONE - 1 GUIDE_32/ivtc-2 GUIDE 22/PAL-3 PAL/NTSC
 				_param->gthresh = 10.0;
-				_param->post = POST_NONE;
+				_param->post = POST_METRICS;
 				_param->vthresh = 50.0;
 				_param->bthresh = 50.0;
 				_param->dthresh = 7.0;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	2011-07-23 15:57:06 UTC (rev 7327)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	2011-07-23 15:57:08 UTC (rev 7328)
@@ -97,18 +97,11 @@
         int vmetric;
         
         bool film, override, inpattern, found;
-        int force;
 
-        
         int chosen;
-        unsigned int p, c, pblock, cblock, lowest, predicted, predicted_metric;
-        unsigned int np, nc, npblock, ncblock;
+        unsigned int p,c,np,pblock,cblock,npblock,nc,ncblock;
         float mismatch;
-        int  x, y;
-        
-        bool hard;
         char status[80];
-
         // Metrics cache.
         struct CACHE_ENTRY *cache;
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-23 15:57:06 UTC (rev 7327)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-23 15:57:08 UTC (rev 7328)
@@ -119,7 +119,9 @@
 ADMImage *final=NULL;
 uint8_t *finalp;
 
-
+unsigned int lowest;
+unsigned int predicted;
+unsigned int predicted_metric;
 teleCide *_param=&configuration;
 
 
@@ -172,7 +174,7 @@
         if (guide != GUIDE_NONE)
         {
                 aprintf("Loop starting at %d +1, cycle=%d\n",frame,cycle);
-                for (y = frame + 1; y <= frame + cycle + 1; y++)
+                for (int y = frame + 1; y <= frame + cycle + 1; y++)
                 {
                         if (lastFrame==true ) break;
                         if (CacheQuery(y, &p, &pblock, &c, &cblock) == false)
@@ -233,7 +235,7 @@
         mismatch = 100.0;
         if (guide != GUIDE_NONE)
         {
-                hard = false;
+                bool hard = false;
                 if (frame >= cycle && PredictHardYUY2(frame, &predicted, &predicted_metric) == true)
                 {
                         inpattern = true;
@@ -264,8 +266,9 @@
                 if (hard == false && guide != GUIDE_22)
                 {
                         int i;
+                        
                         struct PREDICTION *pred = PredictSoftYUY2(frame);
-
+                        
                         if (/*(frame <= _info.nb_frames - 1 - cycle) &&  */   (pred[0].metric != 0xffffffff))
                         {
                                 // Apply pattern guidance.
@@ -391,18 +394,13 @@
 
         /* Check for manual overrides of the deinterlacing. */
         // Do postprocessing if enabled and required for this frame.
-        if (post == POST_NONE || post == POST_METRICS)
+         if ((post == POST_FULL || post == POST_FULL_MAP || post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP)
+                         && (film == false ))
         {
-                if (force == '+') film = false;
-                else if (force == '-') film = true;
-        }
-        else if ((force == '+') ||
-                ((post == POST_FULL || post == POST_FULL_MAP || post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP)
-                         && (film == false && force != '-')))
-        {
                 unsigned char *dstpp, *dstpn;
                 int v1, v2, z;
                 #warning blend in place is wrong!
+                final=dst;
                 // MeanX:We should copy here as we blend from source and destination
                 // for the moment we do it in place, it is wrong.
                 if (blend == true)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	2011-07-23 15:57:06 UTC (rev 7327)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	2011-07-23 15:57:08 UTC (rev 7328)
@@ -139,6 +139,11 @@
 		_param->post != POST_NONE ? (film == true ? " [progressive]" : " [interlaced]") : "",
 		_param->guide != GUIDE_NONE ? status : "");
 	DrawString(dst, 0, 5 + (_param->post != POST_NONE) + (_param->guide != GUIDE_NONE), buf);
+    
+        sprintf(buf,"%s %s",	
+		(film == true ? " [progressive]" : " [interlaced]") ,
+		status);
+	DrawString(dst, 0, 6 + (_param->post != POST_NONE) + (_param->guide != GUIDE_NONE), buf);
 }
 /**
     \fn Debug
@@ -845,7 +850,7 @@
 // Do first and last lines.
 
     dstpn = dstp + dpitch;
-    for (x = 0; x < w; x++)
+    for (int x = 0; x < w; x++)
     {
             finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
     }
@@ -853,7 +858,7 @@
     dstp = src->GetWritePtr(plane) + (h-1)*dpitch;
     
     dstpp = dstp - dpitch;
-    for (x = 0; x < w; x++)
+    for (int x = 0; x < w; x++)
     {
             finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
     }
@@ -862,9 +867,9 @@
     dstpp = dstp - dpitch;
     dstpn = dstp + dpitch;
     finalp = final->GetWritePtr(plane) + fpitch;
-    for (y = 1; y < h - 1; y++)
+    for (int y = 1; y < h - 1; y++)
     {
-            for (x = 0; x < w; x++)
+            for (int x = 0; x < w; x++)
             {
                     v1 = (int)(dstp[x] - dthresh);
                     if (v1 < 0) v1 = 0; 
@@ -910,9 +915,9 @@
 
     float dthresh=configuration.dthresh;
 
-    for (y = 1; y < h - 1; y+=2)
+    for (int y = 1; y < h - 1; y+=2)
     {
-            for (x = 0; x < w; x++)
+            for (int x = 0; x < w; x++)
             {
                     v1 = (int) (dstp[x] - dthresh);
                     if (v1 < 0) v1 = 0; 



From mean at mail.berlios.de  Sat Jul 23 17:57:09 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 17:57:09 +0200
Subject: [Avidemux-svn-commit] r7329 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate
Message-ID: <20110723155709.A8C6B480EC9@sheep.berlios.de>

Author: mean
Date: 2011-07-23 17:57:09 +0200 (Sat, 23 Jul 2011)
New Revision: 7329

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
Log:
[decimate] Display interlaced/progressive detection

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp	2011-07-23 15:57:08 UTC (rev 7328)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp	2011-07-23 15:57:09 UTC (rev 7329)
@@ -571,7 +571,7 @@
                 break;
             case 1: case 2:
                 /* It's a video cycle. Make blends for the remaining frames. */
-                if ((inframe % 4) == 1)  // MEANX dont undestand the difference ?
+                if ((inframe % 4) == 1)  // MEANX dont understand the difference ?
                 {
                     GETFRAME(sourceFrame, src);
                     GETFRAME(sourceFrame+1, next);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	2011-07-23 15:57:08 UTC (rev 7328)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	2011-07-23 15:57:09 UTC (rev 7329)
@@ -479,16 +479,16 @@
 	char buf[80];
     deciMate *_param=&configuration;
 	int start = (useframe / _param->cycle) * _param->cycle;
-
+#define pg(i) (hints[i] & PROGRESSIVE) ? "p" : "i"
 	if (configuration.show == true)
 	{
 		sprintf(buf, "Decimate %d", 0); 	DrawString(src, 0, 0, buf);
 		sprintf(buf, "Copyright 2003 Donald Graft");	    DrawString(src, 0, 1, buf);
-		sprintf(buf,"%d: %3.2f", start, showmetrics[0]);	DrawString(src, 0, 3, buf);
-		sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);DrawString(src, 0, 4, buf);
-		sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);DrawString(src, 0, 5, buf);
-		sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);DrawString(src, 0, 6, buf);
-		sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);DrawString(src, 0, 7, buf);
+		sprintf(buf,"%d: [%s] %3.2f", start + 0,pg(0), showmetrics[0]);DrawString(src, 0, 3, buf);
+		sprintf(buf,"%d: [%s] %3.2f", start + 1,pg(1), showmetrics[1]);DrawString(src, 0, 4, buf);
+		sprintf(buf,"%d: [%s] %3.2f", start + 2,pg(2), showmetrics[2]);DrawString(src, 0, 5, buf);
+		sprintf(buf,"%d: [%s] %3.2f", start + 3,pg(3), showmetrics[3]);DrawString(src, 0, 6, buf);
+		sprintf(buf,"%d: [%s] %3.2f", start + 4,pg(4), showmetrics[4]);DrawString(src, 0, 7, buf);
 		if (all_video_cycle == false)
 		{
 			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);



From mean at mail.berlios.de  Sat Jul 23 17:57:10 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 17:57:10 +0200
Subject: [Avidemux-svn-commit] r7330 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate
Message-ID: <20110723155710.C5ACD480EC9@sheep.berlios.de>

Author: mean
Date: 2011-07-23 17:57:10 +0200 (Sat, 23 Jul 2011)
New Revision: 7330

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
Log:
[decimate] Optimize + SSE version

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	2011-07-23 15:57:09 UTC (rev 7329)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	2011-07-23 15:57:10 UTC (rev 7330)
@@ -43,7 +43,114 @@
 
 #include "ADM_default.h"
 #include "decimate.h"
+//#define BENCH 1
+typedef uint32_t decimateDeltaLine(uint8_t *ptr1,uint8_t *ptr2,int size,int inc,unsigned int *sums);
 /**
+    \fn decimateDeltaLineC
+    \brief C version
+*/
+static inline uint32_t decimateDeltaLineC(uint8_t *ptr1,uint8_t *ptr2,int size,int inc,unsigned int *sums)
+{
+        uint32_t total=0;
+        for (int x = 0; x < size;)
+        {
+            unsigned int quadsum=0;
+            quadsum += abs((int)ptr1[x+0] - (int)ptr2[x+0]);
+            quadsum += abs((int)ptr1[x+1] - (int)ptr2[x+1]);
+            quadsum += abs((int)ptr1[x+2] - (int)ptr2[x+2]);
+            quadsum += abs((int)ptr1[x+3] - (int)ptr2[x+3]);
+            sums[(x+0)/BLKSIZE]+=quadsum; // 4 increment , BLKSIZE=32 => they are all in the same block
+#ifdef BENCH
+            total+=quadsum;
+#endif
+            x+=inc;
+        }
+        return total;
+}
+#ifdef ADM_CPU_X86
+/**
+    \fn decimateDeltaLineSSE
+    \brief SSE/MMX version
+ Only works for inc=4, BLKSIZE=32
+*/
+static inline uint32_t decimateDeltaLineSSE(uint8_t *ptr1,uint8_t *ptr2,int size,int inc,unsigned int *sums)
+{
+        uint32_t total1=0,total2=0;
+#ifdef BENCH
+        total2=decimateDeltaLineC(ptr1,ptr2,size,inc,sums);
+#endif
+        int size32=size>>5;
+        int left=(size & 31);
+        ADM_assert(inc==4);
+        ADM_assert(BLKSIZE==32);
+        uint64_t out;
+        uint64_t sum;
+        for(int i=0;i<size32;i++)
+        {
+            
+            __asm__(
+                    "xor            %3,%3       \n"
+                    "xor            %0,%0       \n"
+                    "movq           (%1),%%mm0  \n"
+                    "movq           (%2),%%mm1  \n"
+                    "psadbw         %%mm1,%%mm0 \n"
+                    "movq           %%mm0,%3    \n"
+                    "add            %3,%0       \n"
+                    "add           $8,%1        \n"
+                    "add           $8,%2        \n"
+                    "movq           (%1),%%mm0  \n"
+                    "movq           (%2),%%mm1  \n"
+                    "psadbw         %%mm1,%%mm0 \n"
+                    "movq           %%mm0,%3    \n"
+                    "add            %3,%0       \n"
+                    "add           $8,%1        \n"
+                    "add           $8,%2        \n"
+                    "movq           (%1),%%mm0  \n"
+                    "movq           (%2),%%mm1  \n"
+                    "psadbw         %%mm1,%%mm0 \n"
+                    "movq           %%mm0,%3    \n"
+                    "add            %3,%0       \n"
+                    "add           $8,%1        \n"
+                    "add           $8,%2        \n"
+                    "movq           (%1),%%mm0  \n"
+                    "movq           (%2),%%mm1  \n"
+                    "psadbw         %%mm1,%%mm0 \n"
+                    "movq           %%mm0,%3    \n"
+                    "add            %3,%0       \n"
+            : "=r"(sum):  "r" (ptr1),"r" (ptr2),"r"(out));
+            sums[i]+=sum;
+            total1+=sum;
+          //  printf("Sum : %d\n",(int)sum);
+            ptr1+=32;
+            ptr2+=32;
+        }
+        // collect leftover
+        for(int x=0;x<left;)
+        {
+            unsigned int quadsum=0;
+            quadsum += abs((int)ptr1[x+0] - (int)ptr2[x+0]);
+            quadsum += abs((int)ptr1[x+1] - (int)ptr2[x+1]);
+            quadsum += abs((int)ptr1[x+2] - (int)ptr2[x+2]);
+            quadsum += abs((int)ptr1[x+3] - (int)ptr2[x+3]);
+            sums[size32+(x+0)/BLKSIZE]+=quadsum; // 4 increment , BLKSIZE=32 => they are all in the same block
+            x+=inc;
+            total1+=quadsum;
+        }
+
+        __asm__(
+                    "emms\n"
+                ::
+                );
+#ifdef BENCH
+        if(total1!=total2)
+        {
+            ADM_error("SSE version does not match %d(C) vs %d(SSE)\n",(int)total2,(int)total1);
+        }
+#endif
+        return total1;
+}
+#endif
+/**
     \fn computeDiff
     \brief compute difference between image and its predecessor
 */
@@ -55,37 +162,41 @@
     uint32_t curPitch=current->GetPitch(PLANAR_Y);
     deciMate *_param=&configuration;
     // Zero
-    for (int y = 0; y < yblocks; y++)
-    {
-        for (int x = 0; x < xblocks; x++)
-        {
-            sum[y*xblocks+x] = 0;
-        }
-    }
+    memset(sum,0,sizeof(unsigned int)*xblocks*yblocks);
     // Raw diff
     int height=info.height;
     int width=info.width;
-    int inc=1;
     
-    for (int y = 0; y < height; y++)
+    if (_param->quality == 0 || _param->quality == 1) // subsampled
     {
-        for (int x = 0; x < width;)
+        for (int y = 0; y < height; y++)
         {
-            sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
-            x++;
-            if(!(x&3))
-                if (_param->quality == 0 || _param->quality == 1)
-                {
-                    x+=12;
-                }
+            unsigned int *xsum=sum+((y/BLKSIZE)*xblocks);
+            decimateDeltaLineC(currY,prevY,width,4+12,xsum);
+            prevY += prevPitch;
+            currY += curPitch;
         }
-        prevY += prevPitch;
-        currY += curPitch;
+    }else   
+    {
+        int inc=4;
+        decimateDeltaLine *func=decimateDeltaLineC;
+#ifdef ADM_CPU_X86
+         if(CpuCaps::hasSSE())
+            func=decimateDeltaLineSSE;
+#endif
+
+        for (int y = 0; y < height; y++)
+        {
+            unsigned int *xsum=sum+((y/BLKSIZE)*xblocks);
+            func(currY,prevY,width,4,xsum);
+            prevY += prevPitch;
+            currY += curPitch;
+        }
     }
+#warning DO CHROMA SAMPLING
+#if 0
     if (_param->quality == 1 || _param->quality == 3)
     {
-#warning DO CHROMA SAMPLING
-#if 0
         // also do u & v
         prevU = storepU[f-1];
         prevV = storepV[f-1];
@@ -109,8 +220,8 @@
             currV += pitchUV;
 
         }
+    }
 #endif
-    }
     uint32_t highest_sum = 0;
     for (int y = 0; y < yblocks; y++)
     {
@@ -231,6 +342,7 @@
 }
 /**
     \fn FindDuplicate2
+    \brief only used for anime mode (find longest dupe sequence)
 */
 void Decimate::FindDuplicate2(int frame, int *chosen, bool *forced)
 {



From mean at mail.berlios.de  Sat Jul 23 17:57:11 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 17:57:11 +0200
Subject: [Avidemux-svn-commit] r7331 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate
Message-ID: <20110723155711.DE078480EC9@sheep.berlios.de>

Author: mean
Date: 2011-07-23 17:57:11 +0200 (Sat, 23 Jul 2011)
New Revision: 7331

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp
Log:
[decimate] Do not offer to use chroma, we dont atm

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp	2011-07-23 15:57:10 UTC (rev 7330)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp	2011-07-23 15:57:11 UTC (rev 7331)
@@ -78,14 +78,14 @@
                           };
          diaMenuEntry tQuality[]={
                              {0, QT_TR_NOOP("Fastest (no chroma, partial luma)"),NULL},
-                             {1, QT_TR_NOOP("Fast (partial luma and chroma)"),NULL},
+//                             {1, QT_TR_NOOP("Fast (partial luma and chroma)"),NULL},
                              {2, QT_TR_NOOP("Medium (full luma, no chroma)"),NULL},
-                             {3, QT_TR_NOOP("Slow (full luma and chroma)"),NULL}
+//                             {3, QT_TR_NOOP("Slow (full luma and chroma)"),NULL}
                           };
   
     
     diaElemMenu menuMode(PX(mode),QT_TR_NOOP("_Mode:"), 4,tMode);
-    diaElemMenu menuQuality(PX(quality),QT_TR_NOOP("_Quality:"), 4,tQuality);
+    diaElemMenu menuQuality(PX(quality),QT_TR_NOOP("_Quality:"), sizeof(tQuality)/sizeof(diaMenuEntry),tQuality);
     diaElemFloat menuThresh1(&t1,QT_TR_NOOP("_Threshold 1:"),0,100.);
     diaElemFloat menuThresh2(&t2,QT_TR_NOOP("T_hreshold 2:"),0,100.);
     diaElemUInteger cycle(PX(cycle),QT_TR_NOOP("C_ycle:"),2,40);



From mean at mail.berlios.de  Sat Jul 23 17:57:12 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 17:57:12 +0200
Subject: [Avidemux-svn-commit] r7332 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <20110723155713.052AE480EC9@sheep.berlios.de>

Author: mean
Date: 2011-07-23 17:57:12 +0200 (Sat, 23 Jul 2011)
New Revision: 7332

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp
Log:
[video copy] Dont drop bframe if they are h264 due to pyramid

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp	2011-07-23 15:57:11 UTC (rev 7331)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp	2011-07-23 15:57:12 UTC (rev 7332)
@@ -90,8 +90,15 @@
     if(fail) return false;
     return true;
 }
-
 /**
+     \fn bFrameDroppable
+*/
+static bool bFrameDroppable(uint32_t fcc)
+{
+    if(isH264Compatible(fcc)) return false;
+    return true;
+}
+/**
         \fn getCompressedPicture
         \brief bypass decoder and directly get the source image
 
@@ -128,21 +135,27 @@
 
     vid->lastSentFrame++;
     //
-    if(img->flags & AVI_B_FRAME)
+    aviInfo    info;
+    vid->_aviheader->getVideoInfo (&info);
+    //
+    if(bFrameDroppable(info.fcc))
     {
-        if(seg->_dropBframes==2) 
+        if(img->flags & AVI_B_FRAME)
         {
-            ADM_warning("%"LU" Dropping bframes\n",fn);
-            goto againGet;
+            if(seg->_dropBframes==2) 
+            {
+                ADM_warning("%"LU" Dropping bframes\n",fn);
+                goto againGet;
+            }
+        }else
+        { // not a bframe
+            switch(seg->_dropBframes)
+            {
+                case 2: seg->_dropBframes=0;break;
+                case 1: seg->_dropBframes=2;break;
+                default: break;
+            }
         }
-    }else
-    { // not a bframe
-        switch(seg->_dropBframes)
-        {
-            case 2: seg->_dropBframes=0;break;
-            case 1: seg->_dropBframes=2;break;
-            default: break;
-        }
     }
     // after a segment switch, we may have some frames from "the past"
     // if the cut point is not a keyframe, drop them



From mean at mail.berlios.de  Sat Jul 23 17:57:14 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 17:57:14 +0200
Subject: [Avidemux-svn-commit] r7333 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render
Message-ID: <20110723155714.26721480EC9@sheep.berlios.de>

Author: mean
Date: 2011-07-23 17:57:13 +0200 (Sat, 23 Jul 2011)
New Revision: 7333

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/CMakeLists.txt
Log:
[renderQtGl] Fix missing $ in cmakelist.txt

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/CMakeLists.txt	2011-07-23 15:57:12 UTC (rev 7332)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/CMakeLists.txt	2011-07-23 15:57:13 UTC (rev 7333)
@@ -21,7 +21,7 @@
 
 IF (USE_OPENGL)
 	ADD_SOURCE_CFLAGS(GUI_render.cpp " -I${QT_HEADERS_DIR}")
-	ADD_SOURCE_CFLAGS(GUI_qtGlRender.cpp " -I${QT_HEADERS_DIR} -I{OPENGL_INCLUDE_DIR}")
+	ADD_SOURCE_CFLAGS(GUI_qtGlRender.cpp " -I${QT_HEADERS_DIR} -I${OPENGL_INCLUDE_DIR}")
 	TARGET_LINK_LIBRARIES(${ADM_LIB} ${OPENGL_LIBRARIES} ${QT_QTOPENGL_LIBRARY} ${QT_QTGUI_LIBRARY} ${QT_QTCORE_LIBRARY})
 ENDIF (USE_OPENGL)
 



From mean at mail.berlios.de  Sat Jul 23 17:57:15 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 17:57:15 +0200
Subject: [Avidemux-svn-commit] r7334 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins
Message-ID: <20110723155715.2751F480EC9@sheep.berlios.de>

Author: mean
Date: 2011-07-23 17:57:14 +0200 (Sat, 23 Jul 2011)
New Revision: 7334

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt
Log:
[plugins/video] Add videoFilter_openGL to build list if the UI is QT4

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt	2011-07-23 15:57:13 UTC (rev 7333)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt	2011-07-23 15:57:14 UTC (rev 7334)
@@ -170,6 +170,9 @@
 
 ADD_SUBDIRECTORY(ADM_videoEncoder)
 ADD_SUBDIRECTORY(ADM_videoFilters6)
+IF(DO_QT4)
+ADD_SUBDIRECTORY(ADM_videoFilters6_openGl)
+ENDIF(DO_QT4)
 
 ########################################
 # Config Summary



From mean at mail.berlios.de  Sat Jul 23 17:57:16 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 17:57:16 +0200
Subject: [Avidemux-svn-commit] r7335 - in branches/avidemux_2.6_branch_mean:
	avidemux/qt4/ADM_UIs/src
	avidemux/qt4/ADM_userInterfaces/ADM_gui avidemux_plugins
	avidemux_plugins/ADM_videoFilters6_openGl
	avidemux_plugins/ADM_videoFilters6_openGl/sample
Message-ID: <20110723155716.AC03F480EC9@sheep.berlios.de>

Author: mean
Date: 2011-07-23 17:57:16 +0200 (Sat, 23 Jul 2011)
New Revision: 7335

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.ui
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt
Log:
[Filter] Initial partial support of openGL. Buggy

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/CMakeLists.txt	2011-07-23 15:57:14 UTC (rev 7334)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/CMakeLists.txt	2011-07-23 15:57:16 UTC (rev 7335)
@@ -9,6 +9,7 @@
 	T_slider.cpp  T_threadCount.cpp  T_toggle.cpp  T_notch.cpp
         T_flyDialogQt4.cpp 
         T_QCanvas.cpp
+        T_openGL.cpp
 )
 
 SET(${ADM_LIB}_SRCS

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/CMakeLists.txt	2011-07-23 15:57:14 UTC (rev 7334)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/CMakeLists.txt	2011-07-23 15:57:16 UTC (rev 7335)
@@ -12,6 +12,7 @@
         #stubs.cpp
         T_thumbSlider.cpp
         file_qt4.cpp  gui_none.cpp  ADM_qslider.cpp
+        Q_dummyWidget.cpp
 	${${ADM_LIB}_header}  ${${ADM_LIB}_source}  ${${ADM_LIB}_resource})
 
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR}  ${CMAKE_CURRENT_SOURCE_DIR})

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-23 15:57:14 UTC (rev 7334)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-23 15:57:16 UTC (rev 7335)
@@ -17,7 +17,7 @@
 #include <QtCore/QUrl>
 #include <QtGui/QKeyEvent>
 #include <QtGui/QGraphicsView>
-
+#include <Qt/QtOpenGL>
 #define MENU_DECLARE
 #include "Q_gui2.h"
 #include "ADM_default.h"
@@ -66,11 +66,15 @@
 uint32_t ADM_ve6_getNbEncoders(void);
 void UI_refreshCustomMenu(void);
 QWidget *QuiMainWindows=NULL;
+QWidget *VuMeter=NULL;
 QGraphicsView *drawWindow=NULL;
 uint8_t UI_updateRecentMenu( void );
 extern void saveCrashProject(void);
 extern uint8_t AVDM_setVolume(int volume);
 extern bool ADM_QPreviewCleanup(void);
+
+
+
 #define WIDGET(x)  (((MainWindow *)QuiMainWindows)->ui.x)
 
 #define CONNECT(object,zzz) connect( (ui.object),SIGNAL(triggered()),this,SLOT(buttonPressed()));
@@ -79,6 +83,12 @@
 
 #include "translation_table.h"   
 
+#ifdef USE_OPENGL
+#include "Q_dummyWidget.h"
+#include "T_openGL.h"
+dummyGLWidget *topGlWidget=NULL;
+dummyGLWidget *topGlWidgetRoot=NULL;
+#endif
 /*
     Declare the table converting widget name to our internal signal           
 */
@@ -742,6 +752,7 @@
 	UI_updateRecentMenu();
 
     // Init vumeter
+    VuMeter=mw->ui.frameVU;
     UI_InitVUMeter(mw->ui.frameVU);
 	return 0;
 }
@@ -825,9 +836,17 @@
 
 	if (global_argc >= 2)
 		automation();
-
-	myApplication->exec();
-
+    // Create an openGL context
+#ifdef USE_OPENGL
+    ADM_info("Creating openGl dummy widget\n");
+    topGlWidgetRoot=new dummyGLWidget(VuMeter);
+    ADM_setGlWidget(topGlWidgetRoot);
+#endif
+    myApplication->exec();
+#ifdef USE_OPENGL
+    if(topGlWidgetRoot) delete topGlWidgetRoot;
+    topGlWidgetRoot=NULL;
+#endif
 	destroyTranslator();
     delete myApplication;
     myApplication=NULL;

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt	2011-07-23 15:57:16 UTC (rev 7335)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(sample)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt	2011-07-23 15:57:16 UTC (rev 7335)
@@ -0,0 +1,10 @@
+INCLUDE(vf_plugin)
+INCLUDE(vf_plugin_qt4)
+
+
+SET(ADM_vf_sampleGl_SRCS sampleGl.cpp)
+
+ADD_SOURCE_CFLAGS(sampleGl.cpp " -I${QT_HEADERS_DIR} ")
+
+INIT_VIDEO_FILTER_QT4(ADM_vf_sampleGl "${ADM_vf_sampleGl_SRCS}" "sampleGl.h" "sampleGl" "${ADM_vf_sampleGl_SRCS}")
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-23 15:57:16 UTC (rev 7335)
@@ -0,0 +1,238 @@
+/** *************************************************************************
+                    \fn       openGlSample.cpp  
+                    \brief simplest of all video filters, it does nothing
+
+    copyright            : (C) 2009 by mean
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include <QtGui/QImage>
+#include <QtOpenGL/QtOpenGL>
+#include <QtOpenGL/QGLShader>
+
+#define ADM_LEGACY_PROGGY
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "T_openGL.h"
+#include "sampleGl.h"
+/**
+
+*/
+extern QGLWidget *topGlWidget;
+
+/**
+    \class openGlSample
+*/
+class openGlSample : public  ADM_coreVideoFilter
+{
+protected:
+                            bool                 firstRun;
+                     const  QGLContext           *context;
+                            QGLFramebufferObject *fbo;
+                            QGLShaderProgram     *glProgram;
+protected:
+                        bool uploadTexture(ADMImage *image);
+                        bool render(ADMImage *image);
+                        bool downloadTexture(ADMImage *image);
+public:
+                             openGlSample(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                            ~openGlSample();
+
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) {return true;}             /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   openGlSample,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_QT4,         // UI
+                        VF_MISC,            // Category
+                        "glsample",            // internal name (must be uniq!)
+                        "OpenGl Sample",            // Display name
+                        "Run a fragment shader." // Description
+                    );
+
+// Now implements the interesting parts
+/**
+    \fn openGlSample
+    \brief constructor
+*/
+openGlSample::openGlSample(  ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilter(in,setup)
+{
+UNUSED_ARG(setup);
+        context=QGLContext::currentContext();
+        ADM_assert(context);
+        fbo = new QGLFramebufferObject(info.width,info.height);
+        ADM_assert(fbo);
+        fbo->bind();
+        printf("Compiling shader \n");
+        glProgram = new QGLShaderProgram(context);
+        ADM_assert(glProgram);
+        if ( !glProgram->addShaderFromSourceCode(QGLShader::Fragment, myShader))
+        {
+                ADM_error("[GL Render] Fragment log: %s\n", glProgram->log().toUtf8().constData());
+                ADM_assert(0);
+        }
+        if ( !glProgram->link())
+        {
+            ADM_error("[GL Render] Link log: %s\n", glProgram->log().toUtf8().constData());
+            ADM_assert(0);
+        }
+
+        if ( !glProgram->bind())
+        {
+                ADM_error("[GL Render] Binding FAILED\n");
+                ADM_assert(0);
+        }
+        glProgram->setUniformValue("myTex", 0); 
+        printf("Setuping texture\n");
+        glProgram->setUniformValue("texY", 0);
+        glActiveTexture(GL_TEXTURE0);
+        glBindTexture(GL_TEXTURE_RECTANGLE_NV, 0);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+        //glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, WIDTH, HEIGHT, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, myTexture);
+        fbo->release();
+        firstRun=true;
+
+}
+/**
+    \fn openGlSample
+    \brief destructor
+*/
+openGlSample::~openGlSample()
+{
+		if(glProgram) delete glProgram;
+        if(fbo) delete fbo;
+        fbo=NULL;
+        glProgram=NULL;
+
+}
+
+/**
+    \fn getFrame
+    \brief Get a processed frame
+*/
+bool openGlSample::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    // since we do nothing, just get the output of previous filter
+    if(false==previousFilter->getNextFrame(fn,image))
+    {
+        ADM_warning("FlipFilter : Cannot get frame\n");
+        return false;
+    }
+    
+    render(image);
+    downloadTexture(image);
+    
+    return true;
+}
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         openGlSample::getCoupledConf(CONFcouple **couples)
+{
+    *couples=new CONFcouple(0); // Even if we dont have configuration we must allocate one 
+    return true;
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *openGlSample::getConfiguration(void)
+{
+    
+    return "openGl Sample.";
+}
+/**
+    \fn uploadTexture
+*/
+bool openGlSample::uploadTexture(ADMImage *image)
+{
+	if (true==firstRun)
+		glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, 
+                        image->GetPitch(PLANAR_Y),
+                        image->GetHeight(PLANAR_Y), 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                        image->GetReadPtr(PLANAR_Y));
+	else
+		glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, 
+                image->GetPitch(PLANAR_Y),
+                image->GetHeight(PLANAR_Y),
+                GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                image->GetReadPtr(PLANAR_Y));
+    firstRun=false;
+    return true;
+}
+/**
+    \fn render
+*/
+bool openGlSample::render(ADMImage *image)
+{
+    fbo->bind();
+    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
+	glViewport(0, 0, info.width, info.height);
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    glOrtho(0, info.width, 0, info.height, -1, 1);
+
+    glProgram->setUniformValue("width", info.width);
+    glProgram->setUniformValue("height",info.height);
+
+
+    // load input texture in fbo
+    uploadTexture(image);
+    //
+    glBegin(GL_QUADS);
+	glTexCoord2i(0, 0);
+	glVertex2i(0, 0);
+	glTexCoord2i(info.width, 0);
+	glVertex2i(info.width, 0);
+	glTexCoord2i(info.width, info.height);
+	glVertex2i(info.width ,info.height);
+	glTexCoord2i(0, info.height);
+	glVertex2i(0, info.height);
+	glEnd();	// draw cube background
+    fbo->release();
+    return true;
+}
+/**
+    \fn downloadTexture
+*/
+bool openGlSample::downloadTexture(ADMImage *image)
+{
+    QImage qimg(fbo->toImage());
+    // Assume RGB32, read R or A
+    int stride=image->GetPitch(PLANAR_Y);
+    uint8_t *to=image->GetWritePtr(PLANAR_Y);
+    for(int y=0;y<info.height;y++)
+    {
+        const uchar *src=qimg.constScanLine(info.height-y);
+        if(!src)
+        {
+            ADM_error("Can t get pointer to openGl texture\n");
+            return false;
+        }
+        for(int x=0;x<info.width;x++)
+            to[x]=src[x*4];
+        to+=stride;
+    }
+    return true;
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h	2011-07-23 15:57:16 UTC (rev 7335)
@@ -0,0 +1,14 @@
+
+static const char *myShader =
+	"#extension GL_ARB_texture_rectangle: enable\n"
+	"uniform sampler2DRect myTex;\n"
+
+	"void main(void) {\n"
+	"  float nx = gl_TexCoord[0].x;\n"
+	"  float ny = gl_TexCoord[0].y;\n"
+	"  float t =  texture2DRect(myTex, vec2(nx, ny)).r;\n"
+       // no op
+	"  gl_FragColor = vec4(t, t, t, 1.0);\n"
+	//"  gl_FragColor = vec4(t, 1.0-t, 2*t, 1.0);\n"
+	"}\n";
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.ui
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.ui	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.ui	2011-07-23 15:57:16 UTC (rev 7335)
@@ -0,0 +1,724 @@
+<ui version="4.0" >
+ <class>resizeDialog</class>
+ <widget class="QDialog" name="resizeDialog" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>350</width>
+    <height>342</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Resize</string>
+  </property>
+  <layout class="QVBoxLayout" >
+   <property name="margin" >
+    <number>9</number>
+   </property>
+   <property name="spacing" >
+    <number>6</number>
+   </property>
+   <item>
+    <widget class="QGroupBox" name="groupBox_2" >
+     <property name="title" >
+      <string>Aspect Ratio</string>
+     </property>
+     <layout class="QVBoxLayout" >
+      <property name="margin" >
+       <number>9</number>
+      </property>
+      <property name="spacing" >
+       <number>6</number>
+      </property>
+      <item>
+       <widget class="QCheckBox" name="lockArCheckBox" >
+        <property name="text" >
+         <string>Lock Aspect Ratio</string>
+        </property>
+        <property name="checked" >
+         <bool>true</bool>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <layout class="QHBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <widget class="QLabel" name="label_4" >
+          <property name="text" >
+           <string>Source:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QComboBox" name="comboBoxSource" >
+          <item>
+           <property name="text" >
+            <string>1:1</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>4:3</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>16:9</string>
+           </property>
+          </item>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeType" >
+           <enum>QSizePolicy::Fixed</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>30</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+        <item>
+         <widget class="QLabel" name="label_3" >
+          <property name="text" >
+           <string>Destination:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QComboBox" name="comboBoxDestination" >
+          <item>
+           <property name="text" >
+            <string>1:1</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>4:3</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>16:9</string>
+           </property>
+          </item>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>40</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+       </layout>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <widget class="QGroupBox" name="groupBox" >
+     <property name="title" >
+      <string>Resize Dimensions</string>
+     </property>
+     <layout class="QVBoxLayout" >
+      <property name="margin" >
+       <number>9</number>
+      </property>
+      <property name="spacing" >
+       <number>6</number>
+      </property>
+      <item>
+       <layout class="QHBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <widget class="QLabel" name="label" >
+          <property name="text" >
+           <string>Width:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QSpinBox" name="spinBoxWidth" >
+          <property name="maximum" >
+           <number>2900</number>
+          </property>
+          <property name="minimum" >
+           <number>16</number>
+          </property>
+          <property name="singleStep" >
+           <number>2</number>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeType" >
+           <enum>QSizePolicy::Fixed</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>30</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+        <item>
+         <widget class="QLabel" name="label_2" >
+          <property name="text" >
+           <string>Height:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QSpinBox" name="spinBoxHeight" >
+          <property name="maximum" >
+           <number>2000</number>
+          </property>
+          <property name="minimum" >
+           <number>16</number>
+          </property>
+          <property name="singleStep" >
+           <number>2</number>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>40</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+       </layout>
+      </item>
+      <item>
+       <widget class="QCheckBox" name="checkBoxRoundup" >
+        <property name="text" >
+         <string>Round to the Nearest Multiple of 16</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <spacer>
+        <property name="orientation" >
+         <enum>Qt::Vertical</enum>
+        </property>
+        <property name="sizeType" >
+         <enum>QSizePolicy::Fixed</enum>
+        </property>
+        <property name="sizeHint" >
+         <size>
+          <width>312</width>
+          <height>4</height>
+         </size>
+        </property>
+       </spacer>
+      </item>
+      <item>
+       <layout class="QVBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <layout class="QHBoxLayout" >
+          <property name="margin" >
+           <number>0</number>
+          </property>
+          <property name="spacing" >
+           <number>12</number>
+          </property>
+          <item>
+           <layout class="QVBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <layout class="QHBoxLayout" >
+              <property name="margin" >
+               <number>0</number>
+              </property>
+              <property name="spacing" >
+               <number>6</number>
+              </property>
+              <item>
+               <widget class="QLabel" name="label_8" >
+                <property name="text" >
+                 <string>1%</string>
+                </property>
+               </widget>
+              </item>
+              <item>
+               <spacer>
+                <property name="orientation" >
+                 <enum>Qt::Horizontal</enum>
+                </property>
+                <property name="sizeHint" >
+                 <size>
+                  <width>40</width>
+                  <height>20</height>
+                 </size>
+                </property>
+               </spacer>
+              </item>
+              <item>
+               <widget class="QLabel" name="label_5" >
+                <property name="text" >
+                 <string>Percent</string>
+                </property>
+               </widget>
+              </item>
+              <item>
+               <spacer>
+                <property name="orientation" >
+                 <enum>Qt::Horizontal</enum>
+                </property>
+                <property name="sizeHint" >
+                 <size>
+                  <width>40</width>
+                  <height>20</height>
+                 </size>
+                </property>
+               </spacer>
+              </item>
+              <item>
+               <widget class="QLabel" name="label_9" >
+                <property name="text" >
+                 <string>200%</string>
+                </property>
+               </widget>
+              </item>
+             </layout>
+            </item>
+            <item>
+             <widget class="QSlider" name="horizontalSlider" >
+              <property name="minimum" >
+               <number>1</number>
+              </property>
+              <property name="maximum" >
+               <number>200</number>
+              </property>
+              <property name="value" >
+               <number>100</number>
+              </property>
+              <property name="orientation" >
+               <enum>Qt::Horizontal</enum>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+          <item>
+           <widget class="QSpinBox" name="percentageSpinBox" >
+            <property name="maximum" >
+             <number>200</number>
+            </property>
+            <property name="minimum" >
+             <number>1</number>
+            </property>
+            <property name="value" >
+             <number>100</number>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </item>
+        <item>
+         <layout class="QHBoxLayout" >
+          <property name="margin" >
+           <number>0</number>
+          </property>
+          <property name="spacing" >
+           <number>6</number>
+          </property>
+          <item>
+           <widget class="QLabel" name="label_10" >
+            <property name="text" >
+             <string>Error X / Y:</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QLabel" name="labelErrorXY" >
+            <property name="text" >
+             <string>0.00 / 0.00</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <spacer>
+            <property name="orientation" >
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="sizeHint" >
+             <size>
+              <width>40</width>
+              <height>20</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+         </layout>
+        </item>
+       </layout>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <spacer>
+     <property name="orientation" >
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeType" >
+      <enum>QSizePolicy::Fixed</enum>
+     </property>
+     <property name="sizeHint" >
+      <size>
+       <width>332</width>
+       <height>6</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" >
+     <property name="margin" >
+      <number>0</number>
+     </property>
+     <property name="spacing" >
+      <number>6</number>
+     </property>
+     <item>
+      <widget class="QLabel" name="label_6" >
+       <property name="text" >
+        <string>Resize Method:</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QComboBox" name="comboBoxAlgo" >
+       <item>
+        <property name="text" >
+         <string>Bilinear</string>
+        </property>
+       </item>
+       <item>
+        <property name="text" >
+         <string>Bicubic</string>
+        </property>
+       </item>
+       <item>
+        <property name="text" >
+         <string>Lanzcos3</string>
+        </property>
+       </item>
+      </widget>
+     </item>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <spacer>
+     <property name="orientation" >
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeType" >
+      <enum>QSizePolicy::MinimumExpanding</enum>
+     </property>
+     <property name="sizeHint" >
+      <size>
+       <width>20</width>
+       <height>16</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+   <item>
+    <widget class="QDialogButtonBox" name="buttonBox" >
+     <property name="orientation" >
+      <enum>Qt::Horizontal</enum>
+     </property>
+     <property name="standardButtons" >
+      <set>QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok</set>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <tabstops>
+  <tabstop>lockArCheckBox</tabstop>
+  <tabstop>comboBoxSource</tabstop>
+  <tabstop>comboBoxDestination</tabstop>
+  <tabstop>spinBoxWidth</tabstop>
+  <tabstop>spinBoxHeight</tabstop>
+  <tabstop>checkBoxRoundup</tabstop>
+  <tabstop>horizontalSlider</tabstop>
+  <tabstop>percentageSpinBox</tabstop>
+  <tabstop>comboBoxAlgo</tabstop>
+  <tabstop>buttonBox</tabstop>
+ </tabstops>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>resizeDialog</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>316</x>
+     <y>260</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>286</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_8</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>39</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_5</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>150</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_9</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>267</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>horizontalSlider</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>156</x>
+     <y>164</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>percentageSpinBox</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>317</x>
+     <y>155</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>checkBoxRoundup</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>95</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_10</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>155</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>55</x>
+     <y>251</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>labelErrorXY</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>155</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>114</x>
+     <y>251</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_4</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>46</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>comboBoxSource</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>94</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_3</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>188</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>comboBoxDestination</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>247</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt	2011-07-23 15:57:14 UTC (rev 7334)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt	2011-07-23 15:57:16 UTC (rev 7335)
@@ -82,6 +82,8 @@
     SET(DO_CLI    1)
 endif(PLUGIN_UI MATCHES "CLI")
 
+
+
 MESSAGE(STATUS "Plugin UI : ${PLUGIN_UI}")
 
 ########################################
@@ -137,6 +139,8 @@
     ELSE (NOT QT4_FOUND)
         MESSAGE(STATUS " QT4 libraries found, good")
         CHECK_ADM_CONFIG_H(qt4 ADM_INC)
+        MESSAGE(STATUS " Checking for Qt4 OpenGL support ")
+        INCLUDE(admCheckOpenGl)
         IF(NOT ADM_INC)
             MESSAGE(ERROR " QT4 UI requested, but cannot find header file for avidemux/qt4...disabling it")
             SET(DO_QT4 0)
@@ -171,7 +175,9 @@
 ADD_SUBDIRECTORY(ADM_videoEncoder)
 ADD_SUBDIRECTORY(ADM_videoFilters6)
 IF(DO_QT4)
-ADD_SUBDIRECTORY(ADM_videoFilters6_openGl)
+        IF(USE_OPENGL)
+         ADD_SUBDIRECTORY(ADM_videoFilters6_openGl)
+        ENDIF(USE_OPENGL)
 ENDIF(DO_QT4)
 
 ########################################



From mean at mail.berlios.de  Sat Jul 23 18:38:57 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 18:38:57 +0200
Subject: [Avidemux-svn-commit] r7336 - in
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs: include src
Message-ID: <20110723163857.6B561480EC9@sheep.berlios.de>

Author: mean
Date: 2011-07-23 18:38:57 +0200 (Sat, 23 Jul 2011)
New Revision: 7336

Added:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
Log:
[openGl] Add link between avidemux and plugins openGl-wise (unused for now)

Added: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h	2011-07-23 16:38:57 UTC (rev 7336)
@@ -0,0 +1,9 @@
+
+#ifndef T_OPENGL_H
+#define T_OPENGL_H
+
+bool ADM_setGlWidget(QGLWidget *w);
+QGLWidget *ADM_getGlWidget(void);
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	2011-07-23 16:38:57 UTC (rev 7336)
@@ -0,0 +1,15 @@
+#include <QtOpenGL/QtOpenGL>
+#include "ADM_assert.h"
+#include "T_openGL.h"
+static QGLWidget *thisWidget=NULL;
+
+bool ADM_setGlWidget(QGLWidget *w)
+{
+        thisWidget=w;
+        return true;
+}
+QGLWidget *ADM_getGlWidget(void)
+{
+        return thisWidget;
+        
+}



From mean at mail.berlios.de  Sat Jul 23 20:21:51 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Jul 2011 20:21:51 +0200
Subject: [Avidemux-svn-commit] r7337 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
Message-ID: <20110723182151.DD76F480F93@sheep.berlios.de>

Author: mean
Date: 2011-07-23 20:21:51 +0200 (Sat, 23 Jul 2011)
New Revision: 7337

Added:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.h
Log:
[openGl] Add dummy openGl widget

Added: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp	2011-07-23 18:21:51 UTC (rev 7337)
@@ -0,0 +1,39 @@
+
+#include "config.h"
+#include <Qt/QtOpenGL>
+#include "Q_dummyWidget.h"
+#include "ADM_default.h"
+
+void dummyGLWidget::paintGL()
+{
+    ADM_info("Painting dummy openGl widget\n");
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+}
+dummyGLWidget::dummyGLWidget(QWidget *parent, QGLWidget *shared)  : QGLWidget(parent,shared)
+{
+
+}
+dummyGLWidget::~dummyGLWidget()
+{
+
+}
+void dummyGLWidget::initializeGL()
+{
+    ADM_info("Initializing dummy openGl widget\n");
+    glMatrixMode(GL_MODELVIEW);
+
+    glEnable(GL_CULL_FACE);
+
+    glEnableClientState(GL_VERTEX_ARRAY);
+    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+    
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glEnable(GL_BLEND);
+    glEnable(GL_TEXTURE_2D);
+    glEnable(GL_DEPTH_TEST);
+
+    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
+    glPushMatrix(); // push to avoid stack underflow in the first paintGL() call
+};

Added: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.h	2011-07-23 18:21:51 UTC (rev 7337)
@@ -0,0 +1,14 @@
+
+class dummyGLWidget : public QGLWidget
+{
+public:
+    dummyGLWidget(QWidget *parent,QGLWidget *sharing=NULL);
+    ~dummyGLWidget();
+    void initializeGL();
+    //void resizeGL(int w, int h);
+    void paintGL();
+    
+
+private:
+  
+};



From mean at mail.berlios.de  Sun Jul 24 08:14:34 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 24 Jul 2011 08:14:34 +0200
Subject: [Avidemux-svn-commit] r7338 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate
Message-ID: <20110724061434.4FC18480E9F@sheep.berlios.de>

Author: mean
Date: 2011-07-24 08:14:33 +0200 (Sun, 24 Jul 2011)
New Revision: 7338

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
Log:
[filter:decimate] Make it builds on 32bits IA32 machine

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	2011-07-23 18:21:51 UTC (rev 7337)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	2011-07-24 06:14:33 UTC (rev 7338)
@@ -89,35 +89,30 @@
         {
             
             __asm__(
-                    "xor            %3,%3       \n"
-                    "xor            %0,%0       \n"
-                    "movq           (%1),%%mm0  \n"
-                    "movq           (%2),%%mm1  \n"
+                    "pxor           %%mm2,%%mm2 \n"
+                    "\n"
+                    "movq           0(%1),%%mm0  \n"
+                    "movq           0(%2),%%mm1  \n"
                     "psadbw         %%mm1,%%mm0 \n"
-                    "movq           %%mm0,%3    \n"
-                    "add            %3,%0       \n"
-                    "add           $8,%1        \n"
-                    "add           $8,%2        \n"
-                    "movq           (%1),%%mm0  \n"
-                    "movq           (%2),%%mm1  \n"
+                    "paddq          %%mm0,%%mm2 \n"
+                    "\n"
+                    "movq           8(%1),%%mm0  \n"
+                    "movq           8(%2),%%mm1  \n"
                     "psadbw         %%mm1,%%mm0 \n"
-                    "movq           %%mm0,%3    \n"
-                    "add            %3,%0       \n"
-                    "add           $8,%1        \n"
-                    "add           $8,%2        \n"
-                    "movq           (%1),%%mm0  \n"
-                    "movq           (%2),%%mm1  \n"
+                    "paddq          %%mm0,%%mm2 \n"
+                    "\n"
+                    "movq           16(%1),%%mm0  \n"
+                    "movq           16(%2),%%mm1  \n"
                     "psadbw         %%mm1,%%mm0 \n"
-                    "movq           %%mm0,%3    \n"
-                    "add            %3,%0       \n"
-                    "add           $8,%1        \n"
-                    "add           $8,%2        \n"
-                    "movq           (%1),%%mm0  \n"
-                    "movq           (%2),%%mm1  \n"
+                    "paddq          %%mm0,%%mm2 \n"
+                    "\n"
+                    "movq           24(%1),%%mm0  \n"
+                    "movq           24(%2),%%mm1  \n"
                     "psadbw         %%mm1,%%mm0 \n"
-                    "movq           %%mm0,%3    \n"
-                    "add            %3,%0       \n"
-            : "=r"(sum):  "r" (ptr1),"r" (ptr2),"r"(out));
+                    "paddq          %%mm0,%%mm2 \n"
+                    // move mm2 to sum
+                    "movq           %%mm2,%0\n"
+            : "=m"(sum):  "r" (ptr1),"r" (ptr2));
             sums[i]+=sum;
             total1+=sum;
           //  printf("Sum : %d\n",(int)sum);
@@ -145,6 +140,9 @@
         if(total1!=total2)
         {
             ADM_error("SSE version does not match %d(C) vs %d(SSE)\n",(int)total2,(int)total1);
+        }else
+        {
+            ADM_info("SSE matches C version\n");
         }
 #endif
         return total1;



From mean at mail.berlios.de  Sun Jul 24 08:14:35 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 24 Jul 2011 08:14:35 +0200
Subject: [Avidemux-svn-commit] r7339 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters
Message-ID: <20110724061435.844E9480E9F@sheep.berlios.de>

Author: mean
Date: 2011-07-24 08:14:35 +0200 (Sun, 24 Jul 2011)
New Revision: 7339

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/filter.qrc
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/mainfilter.ui
Log:
[videoFilter] Add GL filter category

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/filter.qrc
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/filter.qrc	2011-07-24 06:14:33 UTC (rev 7338)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/filter.qrc	2011-07-24 06:14:35 UTC (rev 7339)
@@ -1,5 +1,6 @@
 <RCC>
-  <qresource prefix="/new/prefix1" >
+  <qresource prefix="/new/prefix1">
+    <file>../../../common/ADM_icons/videoFilter/gl.png</file>
     <file>../../../common/ADM_icons/videoFilter/up.png</file>
     <file>../../../common/ADM_icons/videoFilter/add.png</file>
     <file>../../../common/ADM_icons/videoFilter/cd.png</file>

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/mainfilter.ui
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/mainfilter.ui	2011-07-24 06:14:33 UTC (rev 7338)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/mainfilter.ui	2011-07-24 06:14:35 UTC (rev 7339)
@@ -324,6 +324,15 @@
        </item>
        <item>
         <property name="text">
+         <string>OpenGl</string>
+        </property>
+        <property name="icon">
+         <iconset resource="filter.qrc">
+          <normaloff>:/new/prefix1/common/ADM_icons/videoFilter/gl.png</normaloff>:/new/prefix1/common/ADM_icons/videoFilter/gl.png</iconset>
+        </property>
+       </item>
+       <item>
+        <property name="text">
          <string>Miscellaneous</string>
         </property>
         <property name="icon">



From mean at mail.berlios.de  Sun Jul 24 08:14:36 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 24 Jul 2011 08:14:36 +0200
Subject: [Avidemux-svn-commit] r7340 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include
Message-ID: <20110724061436.C718F480E9F@sheep.berlios.de>

Author: mean
Date: 2011-07-24 08:14:36 +0200 (Sun, 24 Jul 2011)
New Revision: 7340

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_filterCategory.h
Log:
[VideoFilter] Add GL category

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_filterCategory.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_filterCategory.h	2011-07-24 06:14:35 UTC (rev 7339)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_filterCategory.h	2011-07-24 06:14:36 UTC (rev 7340)
@@ -25,8 +25,9 @@
 	VF_NOISE=3,
 	VF_SHARPNESS=4,
 	VF_SUBTITLE=5,
-	VF_MISC=6,
-	VF_MAX=7
+    VF_OPENGL=6,
+	VF_MISC=7,
+	VF_MAX=8
 }VF_CATEGORY;
 #define VF_INVALID 		  0
 



From mean at mail.berlios.de  Sun Jul 24 08:14:37 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 24 Jul 2011 08:14:37 +0200
Subject: [Avidemux-svn-commit] r7341 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include
Message-ID: <20110724061438.042C7480E9F@sheep.berlios.de>

Author: mean
Date: 2011-07-24 08:14:37 +0200 (Sun, 24 Jul 2011)
New Revision: 7341

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_uiTypes.h
Log:
[UI] Add GL glag to UI

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_uiTypes.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_uiTypes.h	2011-07-24 06:14:36 UTC (rev 7340)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUI/include/DIA_uiTypes.h	2011-07-24 06:14:37 UTC (rev 7341)
@@ -20,6 +20,9 @@
 #define ADM_UI_GTK 2
 #define ADM_UI_QT4 4
 #define ADM_UI_NONE 99
+
+#define ADM_UI_GL 8
+
 #define ADM_UI_ALL (ADM_UI_CLI+ADM_UI_GTK+ADM_UI_QT4)
 typedef  int  ADM_UI_TYPE;
 



From mean at mail.berlios.de  Sun Jul 24 08:14:39 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 24 Jul 2011 08:14:39 +0200
Subject: [Avidemux-svn-commit] r7342 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample
Message-ID: <20110724061439.341BF480E9F@sheep.berlios.de>

Author: mean
Date: 2011-07-24 08:14:38 +0200 (Sun, 24 Jul 2011)
New Revision: 7342

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
Log:
[Gl:Sample filter] Simplify

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-24 06:14:37 UTC (rev 7341)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-24 06:14:38 UTC (rev 7342)
@@ -4,6 +4,11 @@
 
     copyright            : (C) 2009 by mean
 
+bench : 1280*720, null shader, 20 ms, 95% of it in download texture.
+            Download Texture
+                RGB2Y=5ms               (MMX it)
+                toQimage=14 ms  <<==    TOO SLOW
+
  ***************************************************************************/
 
 /***************************************************************************
@@ -25,11 +30,16 @@
 #include "ADM_coreVideoFilterInternal.h"
 #include "T_openGL.h"
 #include "sampleGl.h"
+#include "ADM_clock.h"
 /**
 
 */
-extern QGLWidget *topGlWidget;
 
+//#define BENCH 1
+//#define BENCH_READTEXTURE
+
+
+
 /**
     \class openGlSample
 */
@@ -58,8 +68,8 @@
 // Add the hook to make it valid plugin
 DECLARE_VIDEO_FILTER(   openGlSample,   // Class
                         1,0,0,              // Version
-                        ADM_UI_QT4,         // UI
-                        VF_MISC,            // Category
+                        ADM_UI_QT4+ADM_UI_GL,         // UI
+                        VF_OPENGL,            // Category
                         "glsample",            // internal name (must be uniq!)
                         "OpenGl Sample",            // Display name
                         "Run a fragment shader." // Description
@@ -137,10 +147,26 @@
         ADM_warning("FlipFilter : Cannot get frame\n");
         return false;
     }
-    
-    render(image);
-    downloadTexture(image);
-    
+
+#ifdef BENCH
+    ADMBenchmark bench;
+    for(int i=0;i<100;i++)
+    {
+        bench.start();
+#endif
+
+        render(image);
+        
+        
+        downloadTexture(image);
+        
+#ifdef BENCH
+        bench.end();
+    }
+    ADM_info("GL result: ");
+    bench.printResult();
+#endif    
+
     return true;
 }
 /**
@@ -217,8 +243,31 @@
 */
 bool openGlSample::downloadTexture(ADMImage *image)
 {
+#ifdef BENCH_READTEXTURE
+    {
+    ADMBenchmark bench;
+    for(int i=0;i<100;i++)
+    {
+        bench.start();
+        QImage qimg(fbo->toImage());
+        bench.end();
+     }
+    ADM_warning("convert to Qimage\n");
+    bench.printResult();
+    }
+#endif
+
     QImage qimg(fbo->toImage());
+
+
+
     // Assume RGB32, read R or A
+#ifdef BENCH_READTEXTURE
+    ADMBenchmark bench;
+    for(int i=0;i<100;i++)
+    {
+        bench.start();
+#endif
     int stride=image->GetPitch(PLANAR_Y);
     uint8_t *to=image->GetWritePtr(PLANAR_Y);
     for(int y=0;y<info.height;y++)
@@ -233,6 +282,13 @@
             to[x]=src[x*4];
         to+=stride;
     }
+#ifdef BENCH_READTEXTURE
+        bench.end();
+    }
+    bench.printResult();
+
+#endif
+
     return true;
 }
 //EOF



From mean at mail.berlios.de  Sun Jul 24 08:14:40 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 24 Jul 2011 08:14:40 +0200
Subject: [Avidemux-svn-commit] r7343 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/videoFilter
Message-ID: <20110724061440.63DB3480E9F@sheep.berlios.de>

Author: mean
Date: 2011-07-24 08:14:40 +0200 (Sun, 24 Jul 2011)
New Revision: 7343

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/videoFilter/gl.png
Log:
[filter] openGl crappy icon

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/videoFilter/gl.png
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/videoFilter/gl.png	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/videoFilter/gl.png	2011-07-24 06:14:40 UTC (rev 7343)
@@ -0,0 +1,4 @@
+?PNG
+
+   +IHDR         <?tY   sRGB ???   PLTE??????Y??]??U??e??Y?????a??a??U??Q????????]??M}????'ZsO?????]??i???????????????????????e??"Sk??????CYJ{??????????r?????v????????Ka;O/]v???{??k?????Bt?/b{9j??????????Bq???????3e????Jy?????????????9d????Eu????:l????"Lb??????Dy?iz????;q?t?????A\n????????????Kew6Vh??????????????????Vn???l??????????????e?????????????????/]}??????/Na3i?Ez?????????????Q????????U??Z????????a???????????&EU?????????U???????????V???????????S|????*c~???Zu??????????Am??????????L??l??Dk??????????Y??Jt??????????????????????u??????????????4l????Y??;e?y????????????????????a??;m?gpx??????U????????e??????????????;s?????????????????????????Q????????????????????????????????]???????????]??Ju?^?????e?????e????????KLM^_aQ??a??Y??A??Y??????????????0e?????????????`????????a??T?????[????????a??????   bKGD ?H   	pHYs     ??   tIME?1*?   ?IDAT?c` ?V}???(?????????YIP???O?N?GR|#B?%W??e?be?g?kdbe?)e?VVg?	?*?I?8,B??????????<? Qf!?^?*m?(M
 ;Kcs?(;?H?????27C?4??'??A??m?S<P??YQ?????4??9??!????A?$TU??X9X?? NY wb7?fq??(?#??<'M?D???s?P??Q]?J?? ??!???^    IEND?B`?
\ No newline at end of file



From mean at mail.berlios.de  Sun Jul 24 08:29:07 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 24 Jul 2011 08:29:07 +0200
Subject: [Avidemux-svn-commit] r7344 - in
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2:
	include src
Message-ID: <20110724062907.E0EDE480E9F@sheep.berlios.de>

Author: mean
Date: 2011-07-24 08:29:07 +0200 (Sun, 24 Jul 2011)
New Revision: 7344

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterApi.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_pluginLoad.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilters.cpp
Log:
[videoFilter] If the filter chain contains an openGl filter, disable threading

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterApi.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterApi.h	2011-07-24 06:14:40 UTC (rev 7343)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterApi.h	2011-07-24 06:29:07 UTC (rev 7344)
@@ -29,5 +29,5 @@
 
 uint32_t    ADM_vf_getTagFromInternalName(const char *name);
 bool        ADM_vf_addFilter(uint32_t tag,CONFcouple *couples);
-
+VF_CATEGORY ADM_vf_getFilterCategoryFromTag(uint32_t tag);
 #endif //ADM_VIDEO_FILTER_API_H

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_pluginLoad.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_pluginLoad.cpp	2011-07-24 06:14:40 UTC (rev 7343)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_pluginLoad.cpp	2011-07-24 06:29:07 UTC (rev 7344)
@@ -279,6 +279,14 @@
     return plugin->info.displayName;
 }
 /**
+    \fn ADM_vf_getFilterCategoryFromTag
+*/
+VF_CATEGORY ADM_vf_getFilterCategoryFromTag(uint32_t tag)
+{
+    ADM_vf_plugin *plugin=ADM_vf_getPluginFromTag(tag);
+    return plugin->info.category;
+}
+/**
     \fn ADM_vf_createFromTag
     \brief Create a new filter from its tag
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilters.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilters.cpp	2011-07-24 06:14:40 UTC (rev 7343)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilters.cpp	2011-07-24 06:29:07 UTC (rev 7344)
@@ -214,6 +214,7 @@
     ADM_coreVideoFilter *f=bridge;
     // Now create a clone of the videoFilterChain we have here
     int nb=ADM_VideoFilters.size();
+    bool openGl=false;
     for(int i=0;i<nb;i++)
     {
             // Get configuration
@@ -221,18 +222,29 @@
             ADM_coreVideoFilter *old=ADM_VideoFilters[i].instance;
             uint32_t tag=ADM_VideoFilters[i].tag;
             old->getCoupledConf(&c);
-
             ADM_coreVideoFilter *nw=ADM_vf_createFromTag(tag,f,c);
             if(c) delete c;
             f=nw;
             chain->push_back(nw);
+
+            VF_CATEGORY type=ADM_vf_getFilterCategoryFromTag(tag);
+            if(type== VF_OPENGL) openGl=true;
+
     }
     // Last create the thread
 #if 1
-    int m=chain->size();
-    ADM_coreVideoFilter *last=(*chain)[m-1];
-    ADM_videoFilterQueue *thread=new ADM_videoFilterQueue(last);
-    chain->push_back(thread);
+    // Make sure there is no openGl filter in the queue, it is not thread safe...
+    
+    if(openGl==true)
+    {
+        ADM_warning("The filter chain contains an openGl filter, disabling threads \n");
+    }else
+    {
+        int m=chain->size();
+        ADM_coreVideoFilter *last=(*chain)[m-1];
+        ADM_videoFilterQueue *thread=new ADM_videoFilterQueue(last);
+        chain->push_back(thread);
+    }
 #endif
     return chain;
 }



From mean at mail.berlios.de  Sun Jul 24 09:52:21 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 24 Jul 2011 09:52:21 +0200
Subject: [Avidemux-svn-commit] r7345 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
Message-ID: <20110724075221.748B1480E9F@sheep.berlios.de>

Author: mean
Date: 2011-07-24 09:52:21 +0200 (Sun, 24 Jul 2011)
New Revision: 7345

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
Log:
[Qt4/GL] Fix build when GL is not present

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp	2011-07-24 06:29:07 UTC (rev 7344)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp	2011-07-24 07:52:21 UTC (rev 7345)
@@ -1,5 +1,6 @@
 
 #include "config.h"
+#ifdef USE_OPENGL
 #include <Qt/QtOpenGL>
 #include "Q_dummyWidget.h"
 #include "ADM_default.h"
@@ -37,3 +38,4 @@
     glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
     glPushMatrix(); // push to avoid stack underflow in the first paintGL() call
 };
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-24 06:29:07 UTC (rev 7344)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-24 07:52:21 UTC (rev 7345)
@@ -17,7 +17,11 @@
 #include <QtCore/QUrl>
 #include <QtGui/QKeyEvent>
 #include <QtGui/QGraphicsView>
+
+#ifdef USE_OPENGL
 #include <Qt/QtOpenGL>
+#endif
+
 #define MENU_DECLARE
 #include "Q_gui2.h"
 #include "ADM_default.h"



From mean at mail.berlios.de  Sun Jul 24 09:52:22 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 24 Jul 2011 09:52:22 +0200
Subject: [Avidemux-svn-commit] r7346 -
	branches/avidemux_2.6_branch_mean/cmake
Message-ID: <20110724075222.91B5A480E9F@sheep.berlios.de>

Author: mean
Date: 2011-07-24 09:52:22 +0200 (Sun, 24 Jul 2011)
New Revision: 7346

Modified:
   branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake
Log:
[Cross] Try to support openGl when cross compiling

Modified: branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake	2011-07-24 07:52:21 UTC (rev 7345)
+++ branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake	2011-07-24 07:52:22 UTC (rev 7346)
@@ -6,6 +6,14 @@
 		MESSAGE(STATUS "*****************")
                 IF(CROSS)
                         MESSAGE(STATUS "Cross compiling override for QT4")
+                        SET(QT_QTOPENGL_FOUND 1)
+                        SET(QT_VERSION_MINOR 5)
+
+                        SET(OPENGL_LIBRARIES "")
+                        SET(QT_QTOPENGL_LIBRARY ${QT_HOME}/lib/libQtOpenGL4.a)
+                        SET(QT_QTOPENGL_INCLUDE_DIR ${QT_HOME}/include/QtOpenGL)
+                        SET(OPENGL_INCLUDE_DIR  ${MINGW}/include)
+
                         SET(QT_INCLUDES "-I${QT_HOME}/include")
                         SET(QT_INCLUDE_DIR "${QT_HOME}/include")
                         SET(QT_BINARY_DIR ${QT_HOME}/bin)



From mean at mail.berlios.de  Sun Jul 24 16:27:48 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 24 Jul 2011 16:27:48 +0200
Subject: [Avidemux-svn-commit] r7347 - in branches/avidemux_2.6_branch_mean:
	avidemux/qt4/ADM_userInterfaces/ADM_gui cmake
Message-ID: <20110724142748.BE1A24813B3@sheep.berlios.de>

Author: mean
Date: 2011-07-24 16:27:48 +0200 (Sun, 24 Jul 2011)
New Revision: 7347

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.6_branch_mean/cmake/admCheckOpenGl.cmake
   branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake
Log:
[openGl] Win32 tweaks

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp	2011-07-24 07:52:22 UTC (rev 7346)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_dummyWidget.cpp	2011-07-24 14:27:48 UTC (rev 7347)
@@ -1,7 +1,7 @@
 
 #include "config.h"
 #ifdef USE_OPENGL
-#include <Qt/QtOpenGL>
+#include <QtOpenGL/QGLWidget>
 #include "Q_dummyWidget.h"
 #include "ADM_default.h"
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-24 07:52:22 UTC (rev 7346)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-24 14:27:48 UTC (rev 7347)
@@ -19,7 +19,7 @@
 #include <QtGui/QGraphicsView>
 
 #ifdef USE_OPENGL
-#include <Qt/QtOpenGL>
+#include <QtOpenGL/QGLWidget>
 #endif
 
 #define MENU_DECLARE

Modified: branches/avidemux_2.6_branch_mean/cmake/admCheckOpenGl.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCheckOpenGl.cmake	2011-07-24 07:52:22 UTC (rev 7346)
+++ branches/avidemux_2.6_branch_mean/cmake/admCheckOpenGl.cmake	2011-07-24 14:27:48 UTC (rev 7347)
@@ -10,8 +10,15 @@
        IF (QT4_FOUND AND QT_VERSION_MINOR GREATER 5)
                IF (QT_QTOPENGL_FOUND)
                        MESSAGE(STATUS "Found QtOpenGL")
-                       FIND_PACKAGE(OpenGL)
-                       PRINT_LIBRARY_INFO("OpenGL" OPENGL_FOUND "${OPENGL_INCLUDE_DIR}" "${OPENGL_LIBRARIES}")
+                       IF(CROSS)
+                                SET(OPENGL_INCLUDE_DIR  "${MINGW}/include" )
+                                SET(OPENGL_LIBRARIES "-lopengl32")
+                                SET(OPENGL_FOUND 1)
+                                MESSAGE(STATUS "Cross compilation override, Skipping openGl search")
+                       ELSE(CROSS)
+                       	        FIND_PACKAGE(OpenGL)
+                                PRINT_LIBRARY_INFO("OpenGL" OPENGL_FOUND "${OPENGL_INCLUDE_DIR}" "${OPENGL_LIBRARIES}")
+                       ENDIF(CROSS)
                ELSE (QT_QTOPENGL_FOUND)
                        MESSAGE(STATUS "QtOpenGL was not found")
                ENDIF (QT_QTOPENGL_FOUND)

Modified: branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake	2011-07-24 07:52:22 UTC (rev 7346)
+++ branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake	2011-07-24 14:27:48 UTC (rev 7347)
@@ -7,13 +7,13 @@
                 IF(CROSS)
                         MESSAGE(STATUS "Cross compiling override for QT4")
                         SET(QT_QTOPENGL_FOUND 1)
-                        SET(QT_VERSION_MINOR 5)
+                        SET(QT_VERSION_MINOR 7)
 
-                        SET(OPENGL_LIBRARIES "")
                         SET(QT_QTOPENGL_LIBRARY ${QT_HOME}/lib/libQtOpenGL4.a)
                         SET(QT_QTOPENGL_INCLUDE_DIR ${QT_HOME}/include/QtOpenGL)
-                        SET(OPENGL_INCLUDE_DIR  ${MINGW}/include)
 
+                        SET(QT_HEADERS_DIR "${QT_HOME}/include/")
+
                         SET(QT_INCLUDES "-I${QT_HOME}/include")
                         SET(QT_INCLUDE_DIR "${QT_HOME}/include")
                         SET(QT_BINARY_DIR ${QT_HOME}/bin)



From mean at mail.berlios.de  Sun Jul 24 17:46:52 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 24 Jul 2011 17:46:52 +0200
Subject: [Avidemux-svn-commit] r7348 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample
Message-ID: <20110724154652.A4D224813B3@sheep.berlios.de>

Author: mean
Date: 2011-07-24 17:46:52 +0200 (Sun, 24 Jul 2011)
New Revision: 7348

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
Log:
[openGl Filter/Win32] It compiles but does not run yet

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt	2011-07-24 14:27:48 UTC (rev 7347)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt	2011-07-24 15:46:52 UTC (rev 7348)
@@ -7,4 +7,5 @@
 ADD_SOURCE_CFLAGS(sampleGl.cpp " -I${QT_HEADERS_DIR} ")
 
 INIT_VIDEO_FILTER_QT4(ADM_vf_sampleGl "${ADM_vf_sampleGl_SRCS}" "sampleGl.h" "sampleGl" "${ADM_vf_sampleGl_SRCS}")
+TARGET_LINK_LIBRARIES(ADM_vf_sampleGl ${OPENGL_LIBRARIES} ${QT_QTOPENGL_LIBRARY})
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-24 14:27:48 UTC (rev 7347)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-24 15:46:52 UTC (rev 7348)
@@ -19,12 +19,27 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
+#define GL_GLEXT_PROTOTYPES
 
+#include <QtGui/QPainter>
 
+#ifdef __APPLE__
+#       include <OpenGL/gl.h>
+#       include <OpenGL/glext.h>
+#       define GL_TEXTURE_RECTANGLE_NV GL_TEXTURE_RECTANGLE_EXT
+#else
+#       include <GL/gl.h>
+#       include <GL/glext.h>
+#endif
+
 #include <QtGui/QImage>
 #include <QtOpenGL/QtOpenGL>
 #include <QtOpenGL/QGLShader>
 
+#ifdef __MINGW32__
+        #define glActiveTexture(...) {} // FIXME!
+#endif
+
 #define ADM_LEGACY_PROGGY
 #include "ADM_default.h"
 #include "ADM_coreVideoFilterInternal.h"
@@ -39,7 +54,6 @@
 //#define BENCH_READTEXTURE
 
 
-
 /**
     \class openGlSample
 */
@@ -107,6 +121,7 @@
                 ADM_error("[GL Render] Binding FAILED\n");
                 ADM_assert(0);
         }
+
         glProgram->setUniformValue("myTex", 0); 
         printf("Setuping texture\n");
         glProgram->setUniformValue("texY", 0);



From mean at mail.berlios.de  Tue Jul 26 07:53:55 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 26 Jul 2011 07:53:55 +0200
Subject: [Avidemux-svn-commit] r7349 - in branches/avidemux_2.6_branch_mean:
	avidemux_plugins/ADM_videoFilters6_openGl/sample cmake
Message-ID: <20110726055355.E0D5948148B@sheep.berlios.de>

Author: mean
Date: 2011-07-26 07:53:55 +0200 (Tue, 26 Jul 2011)
New Revision: 7349

Added:
   branches/avidemux_2.6_branch_mean/cmake/vf_plugin_qt4gl.cmake
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt
Log:
 [QTGL] Add macro to declare filter

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt	2011-07-24 15:46:52 UTC (rev 7348)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt	2011-07-26 05:53:55 UTC (rev 7349)
@@ -1,11 +1,7 @@
 INCLUDE(vf_plugin)
-INCLUDE(vf_plugin_qt4)
+INCLUDE(vf_plugin_qt4gl)
 
 
 SET(ADM_vf_sampleGl_SRCS sampleGl.cpp)
+INIT_VIDEO_FILTER_GLQT4(ADM_vf_sampleGl "${ADM_vf_sampleGl_SRCS}" "sampleGl.h" "sampleGl" "${ADM_vf_sampleGl_SRCS}")
 
-ADD_SOURCE_CFLAGS(sampleGl.cpp " -I${QT_HEADERS_DIR} ")
-
-INIT_VIDEO_FILTER_QT4(ADM_vf_sampleGl "${ADM_vf_sampleGl_SRCS}" "sampleGl.h" "sampleGl" "${ADM_vf_sampleGl_SRCS}")
-TARGET_LINK_LIBRARIES(ADM_vf_sampleGl ${OPENGL_LIBRARIES} ${QT_QTOPENGL_LIBRARY})
-

Added: branches/avidemux_2.6_branch_mean/cmake/vf_plugin_qt4gl.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/vf_plugin_qt4gl.cmake	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/cmake/vf_plugin_qt4gl.cmake	2011-07-26 05:53:55 UTC (rev 7349)
@@ -0,0 +1,17 @@
+include(admAsNeeded)
+MACRO(INIT_VIDEO_FILTER_GLQT4  lib  _srcsQt _headersQt _srcQt_ui  )
+		INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR} ${QT_INCLUDE_DIR})
+		INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/qt4/ADM_UIs/include/)
+		INCLUDE_DIRECTORIES("${QT_HEADERS_DIR}")
+		QT4_WRAP_UI(qt4_ui ${_srcQt_ui}.ui)
+		QT4_WRAP_CPP(qt4_cpp ${_headersQt})
+
+		ADD_LIBRARY(${lib} SHARED ${ARGN} ${_srcsQt} ${qt4_cpp} ${qt4_ui})
+		AS_NEEDED(${lib})
+		ADD_TARGET_CFLAGS(${lib} "-DADM_UI_TYPE_BUILD=4")
+		TARGET_LINK_LIBRARIES( ${lib} ADM_UIQT46  ADM_render6_qt4)
+		TARGET_LINK_LIBRARIES(${lib} ${QT_QTGUI_LIBRARY} ${QT_QTCORE_LIBRARY})
+		TARGET_LINK_LIBRARIES(${lib} ${OPENGL_LIBRARIES} ${QT_QTOPENGL_LIBRARY})
+		INIT_VIDEO_FILTER_INTERNAL(${lib})
+		INSTALL_VIDEO_FILTER_INTERNAL(${lib})
+ENDMACRO(INIT_VIDEO_FILTER_GLQT4)



From mean at mail.berlios.de  Tue Jul 26 07:53:57 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 26 Jul 2011 07:53:57 +0200
Subject: [Avidemux-svn-commit] r7350 - in
	branches/avidemux_2.6_branch_mean/avidemux: common/ADM_render
	qt4/ADM_UIs/include qt4/ADM_UIs/src qt4/ADM_userInterfaces/ADM_gui
Message-ID: <20110726055357.A139848148B@sheep.berlios.de>

Author: mean
Date: 2011-07-26 07:53:57 +0200 (Tue, 26 Jul 2011)
New Revision: 7350

Added:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
Log:
[openGL/qt4] Factorize code (glActiveTexture & friends)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2011-07-26 05:53:55 UTC (rev 7349)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2011-07-26 05:53:57 UTC (rev 7350)
@@ -11,7 +11,7 @@
 *                                                                         *
 ***************************************************************************///
 #define GL_GLEXT_PROTOTYPES
-
+#include "T_openGL.h"
 #include <QtGui/QPainter>
 
 #ifdef __APPLE__
@@ -66,7 +66,8 @@
 	imageWidth = w;
 	imageHeight = h;
 	firstRun = true;
-	glProgram = NULL;
+	glProgram = NULL;
+    myActiveTexture=NULL;
 }
 /**
 
@@ -123,17 +124,13 @@
 void QtGlAccelWidget::initializeGL()
 {
 	int success = 1;
+    GlActiveTexture_Type *myActiveTexture= ADM_getActiveTexture();
+    if(!myActiveTexture)
+    {
+        success=0;
+        printf("[GL Render] Cannot get glActiveTexture\n");
+    }
 
-#ifndef QT_OPENGL_ES
-	glActiveTexture = (_glActiveTexture)this->context()->getProcAddress(QLatin1String("glActiveTexture"));
-
-	if (!glActiveTexture)
-	{
-		success = 0;
-		printf("[GL Render] Active Texture function not found!\n");
-	}
-#endif
-
 	printf("[GL Render] OpenGL Vendor: %s\n", glGetString(GL_VENDOR));
 	printf("[GL Render] OpenGL Renderer: %s\n", glGetString(GL_RENDERER));
 	printf("[GL Render] OpenGL Version: %s\n", glGetString(GL_VERSION));
@@ -184,7 +181,7 @@
 	}
 
 	// U
-	glActiveTexture(GL_TEXTURE1);
+	myActiveTexture(GL_TEXTURE1);
 	glBindTexture(GL_TEXTURE_RECTANGLE_NV, 1);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
@@ -198,7 +195,7 @@
 		glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, textureStrides[1], textureHeights[1], GL_LUMINANCE, GL_UNSIGNED_BYTE, textureOffsets[1]);
 
 	// V
-	glActiveTexture(GL_TEXTURE2);
+	myActiveTexture(GL_TEXTURE2);
 	glBindTexture(GL_TEXTURE_RECTANGLE_NV, 2);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
@@ -212,7 +209,7 @@
 		glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, textureStrides[2], textureHeights[2], GL_LUMINANCE, GL_UNSIGNED_BYTE, textureOffsets[2]);
 
 	// Y
-	glActiveTexture(GL_TEXTURE0);
+	myActiveTexture(GL_TEXTURE0);
 	glBindTexture(GL_TEXTURE_RECTANGLE_NV, 3);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
@@ -279,7 +276,9 @@
     if(false==status)
     {
         ADM_warning("[GL Render] Init failed : No QFl support or no GLShareProgram\n");
-        ADM_warning("[GL Render] hasOpenGl : %d, hasOpenGLShaderProgram %d\n",(int)QGLFormat::hasOpenGL(),(int)QGLShaderProgram::hasOpenGLShaderPrograms());
+        ADM_warning("[GL Render] hasOpenGl : %d, hasOpenGLShaderProgram %d\n",
+                            (int)QGLFormat::hasOpenGL(),
+                            (int)QGLShaderProgram::hasOpenGLShaderPrograms());
         return false;
     }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.h	2011-07-26 05:53:55 UTC (rev 7349)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.h	2011-07-26 05:53:57 UTC (rev 7350)
@@ -32,12 +32,8 @@
     GLsizei textureStrides[3];
 	GLsizei textureHeights[3];
 	uint8_t *textureOffsets[3];
+    GlActiveTexture_Type *myActiveTexture;
 
-#ifndef QT_OPENGL_ES
-	typedef void (*_glActiveTexture) (GLenum);
-	_glActiveTexture glActiveTexture;
-#endif
-
 protected:
 	void initializeGL();
 	void paintGL();

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h	2011-07-26 05:53:55 UTC (rev 7349)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h	2011-07-26 05:53:57 UTC (rev 7350)
@@ -1,9 +1,35 @@
+/***************************************************************************
+  \file T_openGL.h
+  \brief OpenGL related filters
+  \author (C) 2011 Mean Fixounet at free.fr 
+***************************************************************************/
 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
 #ifndef T_OPENGL_H
 #define T_OPENGL_H
+
+#ifdef __APPLE__
+#	include <OpenGL/gl.h>
+#	include <OpenGL/glext.h>
+#	define GL_TEXTURE_RECTANGLE_NV GL_TEXTURE_RECTANGLE_EXT
+#else
+#	include <GL/gl.h>
+#	include <GL/glext.h>
+#endif
 
-bool ADM_setGlWidget(QGLWidget *w);
-QGLWidget *ADM_getGlWidget(void);
+#include <QtOpenGL/QtOpenGL>
 
+
+// Get glActiveTexture
+typedef GLAPI void APIENTRY (GlActiveTexture_Type)(GLenum texture);
+bool ADM_setActiveTexture(GlActiveTexture_Type *set);
+GlActiveTexture_Type *ADM_getActiveTexture(void);
 #endif
 

Added: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h	2011-07-26 05:53:57 UTC (rev 7350)
@@ -0,0 +1,51 @@
+/***************************************************************************
+  \file T_openGL.h
+  \brief OpenGL related filters
+  \author (C) 2011 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef T_OPENGL_FILTER_H
+#define T_OPENGL_FILTER_H
+#include "T_openGL.h"
+
+#include "ADM_assert.h"
+#include "ADM_coreVideoFilter.h"
+
+/**
+ *  \class ADM_coreVideoFilterQtGl
+ *  \brief base class for all QtGl video filters
+ */
+class ADM_coreVideoFilterQtGl:  public ADM_coreVideoFilter
+{
+protected:
+                            
+                    const   QGLContext           *context;
+                            QGLFramebufferObject *fboY;
+                            QGLFramebufferObject *fboUV;
+                            QGLShaderProgram     *glProgram;
+                            bool                 firstRun;
+                            GlActiveTexture_Type *myGlActiveTexture;
+protected:
+                            bool downloadTexture(ADMImage *target, ADM_PLANE plane,QGLFramebufferObject *fbo);
+
+public:
+                            ADM_coreVideoFilterQtGl(ADM_coreVideoFilter *previous,CONFcouple *conf=NULL);
+       virtual             ~ADM_coreVideoFilterQtGl();
+
+                                                                                        
+protected:
+};
+// Hooks
+// Get our top widget
+bool ADM_setGlWidget(QGLWidget *w);
+QGLWidget *ADM_getGlWidget(void);
+#endif
+

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	2011-07-26 05:53:55 UTC (rev 7349)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	2011-07-26 05:53:57 UTC (rev 7350)
@@ -1,15 +1,143 @@
-#include <QtOpenGL/QtOpenGL>
-#include "ADM_assert.h"
+/***************************************************************************
+  \file T_openGL.h
+  \brief OpenGL related filters
+  \author (C) 2011 Mean Fixounet at free.fr 
+***************************************************************************/
 #include "T_openGL.h"
+#include "T_openGLFilter.h"
+#include "ADM_default.h"
+#include "DIA_coreToolkit.h"
 static QGLWidget *thisWidget=NULL;
+static GlActiveTexture_Type *myActiveTexture=NULL;
 
+
+/**
+    \fn ADM_setActiveTexture
+*/
+bool ADM_setActiveTexture(GlActiveTexture_Type *set)
+{
+    myActiveTexture=set;
+    return true;
+}
+/**
+    \fn ADM_getActiveTexture
+*/
+GlActiveTexture_Type *ADM_getActiveTexture(void)
+{
+    return myActiveTexture;
+}
+
+/**
+
+*/
 bool ADM_setGlWidget(QGLWidget *w)
 {
         thisWidget=w;
         return true;
 }
+/**
+
+*/
 QGLWidget *ADM_getGlWidget(void)
 {
         return thisWidget;
         
 }
+/**
+    \fn ctor
+*/
+ADM_coreVideoFilterQtGl::ADM_coreVideoFilterQtGl(ADM_coreVideoFilter *previous,CONFcouple *conf)
+:ADM_coreVideoFilter(previous,conf)
+{
+    context=NULL;
+    glProgram=NULL;
+    fboY=NULL;
+    fboUV=NULL;
+    firstRun=true;
+    ADM_info("Gl : Allocating context and frameBufferObjects\n");
+    context=QGLContext::currentContext();
+    ADM_assert(context);
+    fboY = new QGLFramebufferObject(info.width,info.height);
+    ADM_assert(fboY);
+    fboUV = new QGLFramebufferObject(info.width/2,info.height/2);
+    ADM_assert(fboUV);
+    myGlActiveTexture=ADM_getActiveTexture();
+    if(!myGlActiveTexture)
+    {
+        ADM_error("Cannot get glActiveTexture\n");
+        GUI_Error_HIG("","Cannot get glActiveTexture");
+        ADM_assert(0);
+    }
+    // glTexture TODO
+
+}
+/**
+    \fn dtor
+*/
+ADM_coreVideoFilterQtGl::~ADM_coreVideoFilterQtGl()
+{
+    ADM_info("Gl filter : Destroying..\n");
+    if(glProgram) delete glProgram;
+    glProgram=NULL;
+    if(fboY) delete fboY;
+    fboY=NULL;
+    if(fboUV) delete fboUV;
+    fboUV=NULL;
+
+}
+/**
+    \fn downloadTexture
+*/
+bool ADM_coreVideoFilterQtGl::downloadTexture(ADMImage *image, ADM_PLANE plane,
+        QGLFramebufferObject *fbo)
+{
+#ifdef BENCH_READTEXTURE
+    {
+    ADMBenchmark bench;
+    for(int i=0;i<100;i++)
+    {
+        bench.start();
+        QImage qimg(fbo->toImage());
+        bench.end();
+     }
+    ADM_warning("convert to Qimage\n");
+    bench.printResult();
+    }
+#endif
+
+    QImage qimg(fbo->toImage()); // this is slow ! ~ 15 ms for a 720 picture (Y only).
+
+
+
+    // Assume RGB32, read R or A
+#ifdef BENCH_READTEXTURE
+    ADMBenchmark bench;
+    for(int i=0;i<100;i++)
+    {
+        bench.start();
+#endif
+    int stride=image->GetPitch(plane);
+    uint8_t *to=image->GetWritePtr(plane);
+    int width=image->GetWidth(plane);
+    int height=image->GetHeight(plane);
+    for(int y=0;y<height;y++)
+    {
+        const uchar *src=qimg.constScanLine(height-y);
+        if(!src)
+        {
+            ADM_error("Can t get pointer to openGl texture\n");
+            return false;
+        }
+        for(int x=0;x<width;x++)
+            to[x]=src[x*4];
+        to+=stride;
+    }
+#ifdef BENCH_READTEXTURE
+        bench.end();
+    }
+    bench.printResult();
+
+#endif
+    return true;
+}
+// EOF
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-26 05:53:55 UTC (rev 7349)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-26 05:53:57 UTC (rev 7350)
@@ -11,7 +11,9 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
+
 #include "config.h"
+
 #include "ADM_inttype.h"
 #include <QtCore/QFileInfo>
 #include <QtCore/QUrl>
@@ -22,6 +24,10 @@
 #include <QtOpenGL/QGLWidget>
 #endif
 
+#ifdef USE_OPENGL
+#include "T_openGL.h"
+#endif
+
 #define MENU_DECLARE
 #include "Q_gui2.h"
 #include "ADM_default.h"
@@ -88,8 +94,8 @@
 #include "translation_table.h"   
 
 #ifdef USE_OPENGL
+#include "T_openGLFilter.h"
 #include "Q_dummyWidget.h"
-#include "T_openGL.h"
 dummyGLWidget *topGlWidget=NULL;
 dummyGLWidget *topGlWidgetRoot=NULL;
 #endif
@@ -845,6 +851,24 @@
     ADM_info("Creating openGl dummy widget\n");
     topGlWidgetRoot=new dummyGLWidget(VuMeter);
     ADM_setGlWidget(topGlWidgetRoot);
+
+#ifndef QT_OPENGL_ES
+    GlActiveTexture_Type *tex= (GlActiveTexture_Type *)topGlWidgetRoot->context()->getProcAddress(QLatin1String("glActiveTexture"));
+
+	if (!tex)
+	{
+		ADM_error("[GL Render] Active Texture function not found!\n");
+	}
+    ADM_setActiveTexture(tex);
+#else
+    ADM_setActiveTexture(glActiveTexture);
+#endif
+
+	printf("[GL Render] OpenGL Vendor: %s\n", glGetString(GL_VENDOR));
+	printf("[GL Render] OpenGL Renderer: %s\n", glGetString(GL_RENDERER));
+	printf("[GL Render] OpenGL Version: %s\n", glGetString(GL_VERSION));
+	printf("[GL Render] OpenGL Extensions: %s\n", glGetString(GL_EXTENSIONS));
+
 #endif
     myApplication->exec();
 #ifdef USE_OPENGL



From mean at mail.berlios.de  Tue Jul 26 08:24:41 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 26 Jul 2011 08:24:41 +0200
Subject: [Avidemux-svn-commit] r7351 - in
	branches/avidemux_2.6_branch_mean/avidemux: common/ADM_render
	qt4/ADM_UIs/include
Message-ID: <20110726062441.5794948148B@sheep.berlios.de>

Author: mean
Date: 2011-07-26 08:24:40 +0200 (Tue, 26 Jul 2011)
New Revision: 7351

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h
Log:
[openGl] more tweaks (win32)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2011-07-26 05:53:57 UTC (rev 7350)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2011-07-26 06:24:40 UTC (rev 7351)
@@ -10,18 +10,10 @@
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************///
-#define GL_GLEXT_PROTOTYPES
+
 #include "T_openGL.h"
 #include <QtGui/QPainter>
-
-#ifdef __APPLE__
-#	include <OpenGL/gl.h>
-#	include <OpenGL/glext.h>
-#	define GL_TEXTURE_RECTANGLE_NV GL_TEXTURE_RECTANGLE_EXT
-#else
-#	include <GL/gl.h>
-#	include <GL/glext.h>
-#endif
+
 #define ADM_LEGACY_PROGGY // Dont clash with free/malloc etc..
 #include "ADM_default.h"
 #include "GUI_render.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h	2011-07-26 05:53:57 UTC (rev 7350)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h	2011-07-26 06:24:40 UTC (rev 7351)
@@ -14,7 +14,7 @@
  ***************************************************************************/
 #ifndef T_OPENGL_H
 #define T_OPENGL_H
-
+#define GL_GLEXT_PROTOTYPES
 #ifdef __APPLE__
 #	include <OpenGL/gl.h>
 #	include <OpenGL/glext.h>



From mean at mail.berlios.de  Tue Jul 26 19:23:28 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 26 Jul 2011 19:23:28 +0200
Subject: [Avidemux-svn-commit] r7352 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include
Message-ID: <20110726172328.B645B48148B@sheep.berlios.de>

Author: mean
Date: 2011-07-26 19:23:28 +0200 (Tue, 26 Jul 2011)
New Revision: 7352

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h
Log:
[openGl] More win32 fix

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h	2011-07-26 06:24:40 UTC (rev 7351)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGL.h	2011-07-26 17:23:28 UTC (rev 7352)
@@ -28,7 +28,7 @@
 
 
 // Get glActiveTexture
-typedef GLAPI void APIENTRY (GlActiveTexture_Type)(GLenum texture);
+typedef void APIENTRY (GlActiveTexture_Type)(GLenum texture);
 bool ADM_setActiveTexture(GlActiveTexture_Type *set);
 GlActiveTexture_Type *ADM_getActiveTexture(void);
 #endif



From mean at mail.berlios.de  Wed Jul 27 07:42:30 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 27 Jul 2011 07:42:30 +0200
Subject: [Avidemux-svn-commit] r7353 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render
Message-ID: <20110727054231.19C98480F19@sheep.berlios.de>

Author: mean
Date: 2011-07-27 07:42:30 +0200 (Wed, 27 Jul 2011)
New Revision: 7353

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.h
Log:
[GLRender] Revert commit about factorizing ActiveTexture stuff, it creates circular deps

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2011-07-26 17:23:28 UTC (rev 7352)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2011-07-27 05:42:30 UTC (rev 7353)
@@ -10,10 +10,18 @@
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************///
+#define GL_GLEXT_PROTOTYPES
 
-#include "T_openGL.h"
 #include <QtGui/QPainter>
-
+
+#ifdef __APPLE__
+#	include <OpenGL/gl.h>
+#	include <OpenGL/glext.h>
+#	define GL_TEXTURE_RECTANGLE_NV GL_TEXTURE_RECTANGLE_EXT
+#else
+#	include <GL/gl.h>
+#	include <GL/glext.h>
+#endif
 #define ADM_LEGACY_PROGGY // Dont clash with free/malloc etc..
 #include "ADM_default.h"
 #include "GUI_render.h"
@@ -58,8 +66,7 @@
 	imageWidth = w;
 	imageHeight = h;
 	firstRun = true;
-	glProgram = NULL;
-    myActiveTexture=NULL;
+	glProgram = NULL;
 }
 /**
 
@@ -116,13 +123,17 @@
 void QtGlAccelWidget::initializeGL()
 {
 	int success = 1;
-    GlActiveTexture_Type *myActiveTexture= ADM_getActiveTexture();
-    if(!myActiveTexture)
-    {
-        success=0;
-        printf("[GL Render] Cannot get glActiveTexture\n");
-    }
 
+#ifndef QT_OPENGL_ES
+	glActiveTexture = (_glActiveTexture)this->context()->getProcAddress(QLatin1String("glActiveTexture"));
+
+	if (!glActiveTexture)
+	{
+		success = 0;
+		printf("[GL Render] Active Texture function not found!\n");
+	}
+#endif
+
 	printf("[GL Render] OpenGL Vendor: %s\n", glGetString(GL_VENDOR));
 	printf("[GL Render] OpenGL Renderer: %s\n", glGetString(GL_RENDERER));
 	printf("[GL Render] OpenGL Version: %s\n", glGetString(GL_VERSION));
@@ -173,7 +184,7 @@
 	}
 
 	// U
-	myActiveTexture(GL_TEXTURE1);
+	glActiveTexture(GL_TEXTURE1);
 	glBindTexture(GL_TEXTURE_RECTANGLE_NV, 1);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
@@ -187,7 +198,7 @@
 		glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, textureStrides[1], textureHeights[1], GL_LUMINANCE, GL_UNSIGNED_BYTE, textureOffsets[1]);
 
 	// V
-	myActiveTexture(GL_TEXTURE2);
+	glActiveTexture(GL_TEXTURE2);
 	glBindTexture(GL_TEXTURE_RECTANGLE_NV, 2);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
@@ -201,7 +212,7 @@
 		glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, textureStrides[2], textureHeights[2], GL_LUMINANCE, GL_UNSIGNED_BYTE, textureOffsets[2]);
 
 	// Y
-	myActiveTexture(GL_TEXTURE0);
+	glActiveTexture(GL_TEXTURE0);
 	glBindTexture(GL_TEXTURE_RECTANGLE_NV, 3);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 	glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
@@ -268,9 +279,7 @@
     if(false==status)
     {
         ADM_warning("[GL Render] Init failed : No QFl support or no GLShareProgram\n");
-        ADM_warning("[GL Render] hasOpenGl : %d, hasOpenGLShaderProgram %d\n",
-                            (int)QGLFormat::hasOpenGL(),
-                            (int)QGLShaderProgram::hasOpenGLShaderPrograms());
+        ADM_warning("[GL Render] hasOpenGl : %d, hasOpenGLShaderProgram %d\n",(int)QGLFormat::hasOpenGL(),(int)QGLShaderProgram::hasOpenGLShaderPrograms());
         return false;
     }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.h	2011-07-26 17:23:28 UTC (rev 7352)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.h	2011-07-27 05:42:30 UTC (rev 7353)
@@ -32,8 +32,12 @@
     GLsizei textureStrides[3];
 	GLsizei textureHeights[3];
 	uint8_t *textureOffsets[3];
-    GlActiveTexture_Type *myActiveTexture;
 
+#ifndef QT_OPENGL_ES
+	typedef void (*_glActiveTexture) (GLenum);
+	_glActiveTexture glActiveTexture;
+#endif
+
 protected:
 	void initializeGL();
 	void paintGL();



From mean at mail.berlios.de  Wed Jul 27 07:42:32 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 27 Jul 2011 07:42:32 +0200
Subject: [Avidemux-svn-commit] r7354 - in branches/avidemux_2.6_branch_mean:
	avidemux/qt4/ADM_UIs/include avidemux/qt4/ADM_UIs/src
	avidemux_plugins/ADM_videoFilters6_openGl/sample
Message-ID: <20110727054232.7FB17480F19@sheep.berlios.de>

Author: mean
Date: 2011-07-27 07:42:32 +0200 (Wed, 27 Jul 2011)
New Revision: 7354

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h
Log:
[openGl] Refactor sample filter using the FilterGl base class

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h	2011-07-27 05:42:30 UTC (rev 7353)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h	2011-07-27 05:42:32 UTC (rev 7354)
@@ -31,7 +31,7 @@
                             QGLFramebufferObject *fboY;
                             QGLFramebufferObject *fboUV;
                             QGLShaderProgram     *glProgram;
-                            bool                 firstRun;
+                            int                   firstRun;
                             GlActiveTexture_Type *myGlActiveTexture;
 protected:
                             bool downloadTexture(ADMImage *target, ADM_PLANE plane,QGLFramebufferObject *fbo);

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	2011-07-27 05:42:30 UTC (rev 7353)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	2011-07-27 05:42:32 UTC (rev 7354)
@@ -53,7 +53,7 @@
     glProgram=NULL;
     fboY=NULL;
     fboUV=NULL;
-    firstRun=true;
+    firstRun=0;
     ADM_info("Gl : Allocating context and frameBufferObjects\n");
     context=QGLContext::currentContext();
     ADM_assert(context);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-27 05:42:30 UTC (rev 7353)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-27 05:42:32 UTC (rev 7354)
@@ -44,6 +44,7 @@
 #include "ADM_default.h"
 #include "ADM_coreVideoFilterInternal.h"
 #include "T_openGL.h"
+#include "T_openGLFilter.h"
 #include "sampleGl.h"
 #include "ADM_clock.h"
 /**
@@ -57,17 +58,12 @@
 /**
     \class openGlSample
 */
-class openGlSample : public  ADM_coreVideoFilter
+class openGlSample : public  ADM_coreVideoFilterQtGl
 {
 protected:
-                            bool                 firstRun;
-                     const  QGLContext           *context;
-                            QGLFramebufferObject *fbo;
-                            QGLShaderProgram     *glProgram;
 protected:
-                        bool uploadTexture(ADMImage *image);
-                        bool render(ADMImage *image);
-                        bool downloadTexture(ADMImage *image);
+                        bool uploadTexture(ADMImage *image, ADM_PLANE plane);
+                        bool render(ADMImage *image,ADM_PLANE plane,QGLFramebufferObject *fbo);
 public:
                              openGlSample(ADM_coreVideoFilter *previous,CONFcouple *conf);
                             ~openGlSample();
@@ -94,14 +90,10 @@
     \fn openGlSample
     \brief constructor
 */
-openGlSample::openGlSample(  ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilter(in,setup)
+openGlSample::openGlSample(  ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilterQtGl(in,setup)
 {
 UNUSED_ARG(setup);
-        context=QGLContext::currentContext();
-        ADM_assert(context);
-        fbo = new QGLFramebufferObject(info.width,info.height);
-        ADM_assert(fbo);
-        fbo->bind();
+        fboY->bind();
         printf("Compiling shader \n");
         glProgram = new QGLShaderProgram(context);
         ADM_assert(glProgram);
@@ -133,9 +125,7 @@
         glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
         glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
         //glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, WIDTH, HEIGHT, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, myTexture);
-        fbo->release();
-        firstRun=true;
-
+        fboY->release();
 }
 /**
     \fn openGlSample
@@ -143,10 +133,6 @@
 */
 openGlSample::~openGlSample()
 {
-		if(glProgram) delete glProgram;
-        if(fbo) delete fbo;
-        fbo=NULL;
-        glProgram=NULL;
 
 }
 
@@ -162,26 +148,8 @@
         ADM_warning("FlipFilter : Cannot get frame\n");
         return false;
     }
-
-#ifdef BENCH
-    ADMBenchmark bench;
-    for(int i=0;i<100;i++)
-    {
-        bench.start();
-#endif
-
-        render(image);
-        
-        
-        downloadTexture(image);
-        
-#ifdef BENCH
-        bench.end();
-    }
-    ADM_info("GL result: ");
-    bench.printResult();
-#endif    
-
+    render(image,PLANAR_Y,fboY);
+    downloadTexture(image,PLANAR_Y,fboY);
     return true;
 }
 /**
@@ -205,105 +173,51 @@
 /**
     \fn uploadTexture
 */
-bool openGlSample::uploadTexture(ADMImage *image)
+bool openGlSample::uploadTexture(ADMImage *image, ADM_PLANE plane)
 {
-	if (true==firstRun)
+	if (firstRun<3)
 		glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, 
-                        image->GetPitch(PLANAR_Y),
-                        image->GetHeight(PLANAR_Y), 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, 
-                        image->GetReadPtr(PLANAR_Y));
+                        image->GetPitch(plane),
+                        image->GetHeight(plane), 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                        image->GetReadPtr(plane));
 	else
 		glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, 
-                image->GetPitch(PLANAR_Y),
-                image->GetHeight(PLANAR_Y),
+                image->GetPitch(plane),
+                image->GetHeight(plane),
                 GL_LUMINANCE, GL_UNSIGNED_BYTE, 
-                image->GetReadPtr(PLANAR_Y));
-    firstRun=false;
+                image->GetReadPtr(plane));
+    firstRun++;
     return true;
 }
 /**
     \fn render
 */
-bool openGlSample::render(ADMImage *image)
+bool openGlSample::render(ADMImage *image,ADM_PLANE plane,QGLFramebufferObject *fbo)
 {
+    int width=image->GetWidth(plane);
+    int height=image->GetHeight(plane);
+
     fbo->bind();
     glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-	glViewport(0, 0, info.width, info.height);
+	glViewport(0, 0, width, height);
     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();
-    glOrtho(0, info.width, 0, info.height, -1, 1);
+    glOrtho(0, width, 0, height, -1, 1);
 
-    glProgram->setUniformValue("width", info.width);
-    glProgram->setUniformValue("height",info.height);
-
-
     // load input texture in fbo
-    uploadTexture(image);
+    uploadTexture(image,plane);
     //
     glBegin(GL_QUADS);
 	glTexCoord2i(0, 0);
 	glVertex2i(0, 0);
-	glTexCoord2i(info.width, 0);
-	glVertex2i(info.width, 0);
-	glTexCoord2i(info.width, info.height);
-	glVertex2i(info.width ,info.height);
-	glTexCoord2i(0, info.height);
-	glVertex2i(0, info.height);
+	glTexCoord2i(width, 0);
+	glVertex2i(width, 0);
+	glTexCoord2i(width, height);
+	glVertex2i(width ,height);
+	glTexCoord2i(0, height);
+	glVertex2i(0, height);
 	glEnd();	// draw cube background
     fbo->release();
     return true;
 }
-/**
-    \fn downloadTexture
-*/
-bool openGlSample::downloadTexture(ADMImage *image)
-{
-#ifdef BENCH_READTEXTURE
-    {
-    ADMBenchmark bench;
-    for(int i=0;i<100;i++)
-    {
-        bench.start();
-        QImage qimg(fbo->toImage());
-        bench.end();
-     }
-    ADM_warning("convert to Qimage\n");
-    bench.printResult();
-    }
-#endif
-
-    QImage qimg(fbo->toImage());
-
-
-
-    // Assume RGB32, read R or A
-#ifdef BENCH_READTEXTURE
-    ADMBenchmark bench;
-    for(int i=0;i<100;i++)
-    {
-        bench.start();
-#endif
-    int stride=image->GetPitch(PLANAR_Y);
-    uint8_t *to=image->GetWritePtr(PLANAR_Y);
-    for(int y=0;y<info.height;y++)
-    {
-        const uchar *src=qimg.constScanLine(info.height-y);
-        if(!src)
-        {
-            ADM_error("Can t get pointer to openGl texture\n");
-            return false;
-        }
-        for(int x=0;x<info.width;x++)
-            to[x]=src[x*4];
-        to+=stride;
-    }
-#ifdef BENCH_READTEXTURE
-        bench.end();
-    }
-    bench.printResult();
-
-#endif
-
-    return true;
-}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h	2011-07-27 05:42:30 UTC (rev 7353)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h	2011-07-27 05:42:32 UTC (rev 7354)
@@ -1,4 +1,4 @@
-
+// Invert x & y
 static const char *myShader =
 	"#extension GL_ARB_texture_rectangle: enable\n"
 	"uniform sampler2DRect myTex;\n"
@@ -6,7 +6,7 @@
 	"void main(void) {\n"
 	"  float nx = gl_TexCoord[0].x;\n"
 	"  float ny = gl_TexCoord[0].y;\n"
-	"  float t =  texture2DRect(myTex, vec2(nx, ny)).r;\n"
+	"  float t =  texture2DRect(myTex, vec2(ny, nx)).r;\n"
        // no op
 	"  gl_FragColor = vec4(t, t, t, 1.0);\n"
 	//"  gl_FragColor = vec4(t, 1.0-t, 2*t, 1.0);\n"



From mean at mail.berlios.de  Wed Jul 27 07:42:33 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 27 Jul 2011 07:42:33 +0200
Subject: [Avidemux-svn-commit] r7355 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample
Message-ID: <20110727054233.C9FA7480F19@sheep.berlios.de>

Author: mean
Date: 2011-07-27 07:42:33 +0200 (Wed, 27 Jul 2011)
New Revision: 7355

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
Log:
[openGl] Use our factorized openGl glActiveTexture call

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-27 05:42:32 UTC (rev 7354)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-27 05:42:33 UTC (rev 7355)
@@ -36,9 +36,6 @@
 #include <QtOpenGL/QtOpenGL>
 #include <QtOpenGL/QGLShader>
 
-#ifdef __MINGW32__
-        #define glActiveTexture(...) {} // FIXME!
-#endif
 
 #define ADM_LEGACY_PROGGY
 #include "ADM_default.h"
@@ -117,7 +114,7 @@
         glProgram->setUniformValue("myTex", 0); 
         printf("Setuping texture\n");
         glProgram->setUniformValue("texY", 0);
-        glActiveTexture(GL_TEXTURE0);
+        myGlActiveTexture(GL_TEXTURE0);
         glBindTexture(GL_TEXTURE_RECTANGLE_NV, 0);
         glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
         glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);



From mean at mail.berlios.de  Wed Jul 27 21:30:05 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 27 Jul 2011 21:30:05 +0200
Subject: [Avidemux-svn-commit] r7358 - in branches/avidemux_2.6_branch_mean:
	avidemux/qt4/ADM_UIs/include avidemux/qt4/ADM_UIs/src
	avidemux_plugins/ADM_videoFilters6_openGl/sample
Message-ID: <20110727193005.B49AF480E5B@sheep.berlios.de>

Author: mean
Date: 2011-07-27 21:30:05 +0200 (Wed, 27 Jul 2011)
New Revision: 7358

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h
Log:
[openGl: First working fragment shader effect (crash on win32)

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h	2011-07-27 17:40:28 UTC (rev 7357)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h	2011-07-27 19:30:05 UTC (rev 7358)
@@ -30,7 +30,8 @@
                     const   QGLContext           *context;
                             QGLFramebufferObject *fboY;
                             QGLFramebufferObject *fboUV;
-                            QGLShaderProgram     *glProgram;
+                            QGLShaderProgram     *glProgramY;
+                            QGLShaderProgram     *glProgramUV;
                             int                   firstRun;
                             GlActiveTexture_Type *myGlActiveTexture;
 protected:

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	2011-07-27 17:40:28 UTC (rev 7357)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	2011-07-27 19:30:05 UTC (rev 7358)
@@ -50,7 +50,8 @@
 :ADM_coreVideoFilter(previous,conf)
 {
     context=NULL;
-    glProgram=NULL;
+    glProgramY=NULL;
+    glProgramUV=NULL;
     fboY=NULL;
     fboUV=NULL;
     firstRun=0;
@@ -77,8 +78,10 @@
 ADM_coreVideoFilterQtGl::~ADM_coreVideoFilterQtGl()
 {
     ADM_info("Gl filter : Destroying..\n");
-    if(glProgram) delete glProgram;
-    glProgram=NULL;
+    if(glProgramY) delete glProgramY;
+    glProgramY=NULL;
+    if(glProgramUV) delete glProgramUV;
+    glProgramUV=NULL;
     if(fboY) delete fboY;
     fboY=NULL;
     if(fboUV) delete fboUV;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-27 17:40:28 UTC (rev 7357)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-27 19:30:05 UTC (rev 7358)
@@ -59,8 +59,9 @@
 {
 protected:
 protected:
-                        bool uploadTexture(ADMImage *image, ADM_PLANE plane);
+                        //bool uploadTexture(ADMImage *image, ADM_PLANE plane);
                         bool render(ADMImage *image,ADM_PLANE plane,QGLFramebufferObject *fbo);
+                        void tinyUploadTex(ADMImage *img, ADM_PLANE plane, GLuint tex,int texNum );
 public:
                              openGlSample(ADM_coreVideoFilter *previous,CONFcouple *conf);
                             ~openGlSample();
@@ -92,37 +93,48 @@
 UNUSED_ARG(setup);
         fboY->bind();
         printf("Compiling shader \n");
-        glProgram = new QGLShaderProgram(context);
-        ADM_assert(glProgram);
-        if ( !glProgram->addShaderFromSourceCode(QGLShader::Fragment, myShader))
+        glProgramY = new QGLShaderProgram(context);
+        ADM_assert(glProgramY);
+        if ( !glProgramY->addShaderFromSourceCode(QGLShader::Fragment, myShaderY))
         {
-                ADM_error("[GL Render] Fragment log: %s\n", glProgram->log().toUtf8().constData());
+                ADM_error("[GL Render] Fragment log: %s\n", glProgramY->log().toUtf8().constData());
                 ADM_assert(0);
         }
-        if ( !glProgram->link())
+        if ( !glProgramY->link())
         {
-            ADM_error("[GL Render] Link log: %s\n", glProgram->log().toUtf8().constData());
+            ADM_error("[GL Render] Link log: %s\n", glProgramY->log().toUtf8().constData());
             ADM_assert(0);
         }
 
-        if ( !glProgram->bind())
+        if ( !glProgramY->bind())
         {
                 ADM_error("[GL Render] Binding FAILED\n");
                 ADM_assert(0);
         }
+        fboY->release();
+//
+        fboUV->bind();
+        printf("Compiling shader \n");
+        glProgramUV = new QGLShaderProgram(context);
+        ADM_assert(glProgramUV);
+        if ( !glProgramUV->addShaderFromSourceCode(QGLShader::Fragment, myShaderY))
+        {
+                ADM_error("[GL Render] Fragment log: %s\n", glProgramUV->log().toUtf8().constData());
+                ADM_assert(0);
+        }
+        if ( !glProgramUV->link())
+        {
+            ADM_error("[GL Render] Link log: %s\n", glProgramUV->log().toUtf8().constData());
+            ADM_assert(0);
+        }
 
-        glProgram->setUniformValue("myTex", 0); 
-        printf("Setuping texture\n");
-        glProgram->setUniformValue("texY", 0);
-        myGlActiveTexture(GL_TEXTURE0);
-        glBindTexture(GL_TEXTURE_RECTANGLE_NV, 0);
-        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-        //glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, WIDTH, HEIGHT, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, myTexture);
-        fboY->release();
+        if ( !glProgramUV->bind())
+        {
+                ADM_error("[GL Render] Binding FAILED\n");
+                ADM_assert(0);
+        }
+        fboUV->release();
+
 }
 /**
     \fn openGlSample
@@ -145,8 +157,30 @@
         ADM_warning("FlipFilter : Cannot get frame\n");
         return false;
     }
+    float angle=*fn;
+    angle=0.3+angle/40;
+    glProgramY->setUniformValue("teta", angle); 
+    glProgramUV->setUniformValue("teta", angle); 
+        // size is the last one...
+    fboY->bind();
+    tinyUploadTex(image,PLANAR_Y,GL_TEXTURE0,0);
+    glProgramY->setUniformValue("myTexture", 0); 
     render(image,PLANAR_Y,fboY);
     downloadTexture(image,PLANAR_Y,fboY);
+    fboY->release();
+
+    fboUV->bind();
+    tinyUploadTex(image,PLANAR_U,GL_TEXTURE1,1);
+    glProgramUV->setUniformValue("myTexture", 1); 
+    render(image,PLANAR_U,fboUV);
+    downloadTexture(image,PLANAR_U,fboUV);
+    
+    tinyUploadTex(image,PLANAR_V,GL_TEXTURE2,2);
+    glProgramUV->setUniformValue("myTexture", 2); 
+    render(image,PLANAR_V,fboUV);
+    downloadTexture(image,PLANAR_V,fboUV);
+    fboUV->release();
+    firstRun=false;
     return true;
 }
 /**
@@ -170,22 +204,32 @@
 /**
     \fn uploadTexture
 */
-bool openGlSample::uploadTexture(ADMImage *image, ADM_PLANE plane)
+void openGlSample::tinyUploadTex(ADMImage *image, ADM_PLANE plane, GLuint tex,int texNum )
 {
-	if (firstRun<3)
-		glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, 
-                        image->GetPitch(plane),
-                        image->GetHeight(plane), 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, 
-                        image->GetReadPtr(plane));
-	else
-		glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, 
+        myGlActiveTexture(tex);
+        glBindTexture(GL_TEXTURE_RECTANGLE_NV, texNum);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+        if(!firstRun)
+        {
+            glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, 
+                            image->GetPitch(plane),
+                            image->GetHeight(plane), 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                            image->GetReadPtr(plane));
+        }else
+        {
+            glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, 
                 image->GetPitch(plane),
                 image->GetHeight(plane),
                 GL_LUMINANCE, GL_UNSIGNED_BYTE, 
-                image->GetReadPtr(plane));
-    firstRun++;
-    return true;
+                image->GetReadPtr(plane));
+        }
 }
+
+
 /**
     \fn render
 */
@@ -194,15 +238,12 @@
     int width=image->GetWidth(plane);
     int height=image->GetHeight(plane);
 
-    fbo->bind();
     glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
 	glViewport(0, 0, width, height);
     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();
     glOrtho(0, width, 0, height, -1, 1);
 
-    // load input texture in fbo
-    uploadTexture(image,plane);
     //
     glBegin(GL_QUADS);
 	glTexCoord2i(0, 0);
@@ -214,7 +255,6 @@
 	glTexCoord2i(0, height);
 	glVertex2i(0, height);
 	glEnd();	// draw cube background
-    fbo->release();
     return true;
 }
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h	2011-07-27 17:40:28 UTC (rev 7357)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h	2011-07-27 19:30:05 UTC (rev 7358)
@@ -1,14 +1,33 @@
 // Invert x & y
-static const char *myShader =
+static const char *myShaderY =
 	"#extension GL_ARB_texture_rectangle: enable\n"
-	"uniform sampler2DRect myTex;\n"
+	"uniform sampler2DRect myTexture;\n"
+    "uniform float teta;\n"
 
 	"void main(void) {\n"
+    "  float angle=teta;\n" //"0.2;"
 	"  float nx = gl_TexCoord[0].x;\n"
 	"  float ny = gl_TexCoord[0].y;\n"
-	"  float t =  texture2DRect(myTex, vec2(ny, nx)).r;\n"
+    "  float s= sin(angle);\n"
+    "  float c= cos(angle);\n"
+    "  float my= nx*s+ny*c;\n"
+    "  float mx= nx*c+ny*s;\n"
+	"  float t =  texture2DRect(myTexture, vec2(mx, my)).r;\n"
        // no op
 	"  gl_FragColor = vec4(t, t, t, 1.0);\n"
 	//"  gl_FragColor = vec4(t, 1.0-t, 2*t, 1.0);\n"
 	"}\n";
+static const char *myShaderUV =
+	"#extension GL_ARB_texture_rectangle: enable\n"
+	"uniform sampler2DRect myUVTex;\n"
 
+	"void main(void) {\n"
+	"  float nx = gl_TexCoord[0].x;\n"
+	"  float ny = gl_TexCoord[0].y;\n"
+	"  float t =  texture2DRect(myUVTex, vec2(nx, ny)).r;\n"
+       // no op
+	"  gl_FragColor = vec4(t, t, t, 1.0);\n"
+	//"  gl_FragColor = vec4(t, 1.0-t, 2*t, 1.0);\n"
+	"}\n";
+
+



From mean at mail.berlios.de  Wed Jul 27 21:30:07 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 27 Jul 2011 21:30:07 +0200
Subject: [Avidemux-svn-commit] r7359 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample
Message-ID: <20110727193007.D4EFF480E5B@sheep.berlios.de>

Author: mean
Date: 2011-07-27 21:30:07 +0200 (Wed, 27 Jul 2011)
New Revision: 7359

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h
Log:
[openGl: First working fragment shader effect (crash on win32)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h	2011-07-27 19:30:05 UTC (rev 7358)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h	2011-07-27 19:30:07 UTC (rev 7359)
@@ -17,6 +17,7 @@
 	"  gl_FragColor = vec4(t, t, t, 1.0);\n"
 	//"  gl_FragColor = vec4(t, 1.0-t, 2*t, 1.0);\n"
 	"}\n";
+// Not used
 static const char *myShaderUV =
 	"#extension GL_ARB_texture_rectangle: enable\n"
 	"uniform sampler2DRect myUVTex;\n"



From mean at mail.berlios.de  Thu Jul 28 08:13:14 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 28 Jul 2011 08:13:14 +0200
Subject: [Avidemux-svn-commit] r7360 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render
Message-ID: <20110728061315.11D4048146F@sheep.berlios.de>

Author: mean
Date: 2011-07-28 08:13:14 +0200 (Thu, 28 Jul 2011)
New Revision: 7360

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
Log:
[glRender] Give a context so that hasOpenGlShader support returns yes sometimes

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2011-07-27 19:30:07 UTC (rev 7359)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2011-07-28 06:13:14 UTC (rev 7360)
@@ -275,15 +275,22 @@
 	printf("[GL Render] Initialising renderer\n");
     baseInit(w,h,zoom);
     glWidget=NULL;
-	bool status= QGLFormat::hasOpenGL() && QGLShaderProgram::hasOpenGLShaderPrograms();
+    if(false==QGLFormat::hasOpenGL())
+    {
+        ADM_warning("This platform has no openGL support \n");
+        return false;
+    }
+    glWidget = new QtGlAccelWidget((QWidget*)window->widget, w, h);
+	bool status= QGLShaderProgram::hasOpenGLShaderPrograms(glWidget->context());
     if(false==status)
     {
-        ADM_warning("[GL Render] Init failed : No QFl support or no GLShareProgram\n");
-        ADM_warning("[GL Render] hasOpenGl : %d, hasOpenGLShaderProgram %d\n",(int)QGLFormat::hasOpenGL(),(int)QGLShaderProgram::hasOpenGLShaderPrograms());
+        delete glWidget;
+        glWidget=NULL;
+        ADM_warning("[GL Render] Init failed : OpenGL Shader Program support\n");
         return false;
     }
 
-	glWidget = new QtGlAccelWidget((QWidget*)window->widget, w, h);
+	
     glWidget->setDisplaySize(displayWidth,displayHeight);
 	glWidget->show();
     return true;



From mean at mail.berlios.de  Thu Jul 28 08:13:16 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 28 Jul 2011 08:13:16 +0200
Subject: [Avidemux-svn-commit] r7361 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src
Message-ID: <20110728061316.2E97B48146F@sheep.berlios.de>

Author: mean
Date: 2011-07-28 08:13:15 +0200 (Thu, 28 Jul 2011)
New Revision: 7361

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptVideo.cpp
Log:
[videoFilter] Actually load a video filter without parameter, they are valid too.

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptVideo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptVideo.cpp	2011-07-28 06:13:14 UTC (rev 7360)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_scriptVideo.cpp	2011-07-28 06:13:15 UTC (rev 7361)
@@ -144,7 +144,7 @@
    bool r=true;
         filterTag = ADM_vf_getTagFromInternalName(filter);
         jsLog("Adding Filter %s -> %"LU"... \n",filter,filterTag);
-        if(c)
+        //if(c)
         {
             r=ADM_vf_addFilterFromTag(filterTag,c,false);
         }



From mean at mail.berlios.de  Thu Jul 28 08:13:17 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 28 Jul 2011 08:13:17 +0200
Subject: [Avidemux-svn-commit] r7362 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
Message-ID: <20110728061317.6E74248146F@sheep.berlios.de>

Author: mean
Date: 2011-07-28 08:13:17 +0200 (Thu, 28 Jul 2011)
New Revision: 7362

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
Log:
[main] initialize openGl before interpreting command line arguments

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-28 06:13:15 UTC (rev 7361)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-28 06:13:17 UTC (rev 7362)
@@ -844,8 +844,6 @@
     ADM_setCrashHook(&saveCrashProject, &FatalFunctionQt);
 	checkCrashFile();
 
-	if (global_argc >= 2)
-		automation();
     // Create an openGL context
 #ifdef USE_OPENGL
     ADM_info("Creating openGl dummy widget\n");
@@ -858,8 +856,10 @@
 	if (!tex)
 	{
 		ADM_error("[GL Render] Active Texture function not found!\n");
-	}
-    ADM_setActiveTexture(tex);
+	}else
+    {
+        ADM_setActiveTexture(tex);
+    }
 #else
     ADM_setActiveTexture(glActiveTexture);
 #endif
@@ -870,6 +870,9 @@
 	printf("[GL Render] OpenGL Extensions: %s\n", glGetString(GL_EXTENSIONS));
 
 #endif
+	if (global_argc >= 2)
+		automation();
+
     myApplication->exec();
 #ifdef USE_OPENGL
     if(topGlWidgetRoot) delete topGlWidgetRoot;



From mean at mail.berlios.de  Fri Jul 29 08:16:22 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 29 Jul 2011 08:16:22 +0200
Subject: [Avidemux-svn-commit] r7364 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render
Message-ID: <20110729061622.413A9481291@sheep.berlios.de>

Author: mean
Date: 2011-07-29 08:16:21 +0200 (Fri, 29 Jul 2011)
New Revision: 7364

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
Log:
[render/qtGl] Lock context so that it does not conflict with openGlFilter context

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2011-07-28 14:36:04 UTC (rev 7363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2011-07-29 06:16:21 UTC (rev 7364)
@@ -167,7 +167,8 @@
 
 */
 void QtGlAccelWidget::updateTexture()
-{
+{
+    makeCurrent();
 	if (!textureOffsets[0])
 	{
 		printf("[Render] Buffer not set\n");
@@ -227,12 +228,14 @@
 	}
 	else
 		glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, textureStrides[0], textureHeights[0], GL_LUMINANCE, GL_UNSIGNED_BYTE, textureOffsets[0]);
+    doneCurrent();
 }
 /**
 
 */
 void QtGlAccelWidget::paintGL()
 {
+    makeCurrent();
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 	glBegin(GL_QUADS);
 	glTexCoord2i(0, 0);
@@ -243,7 +246,8 @@
 	glVertex2i(width(), height());
 	glTexCoord2i(0, imageHeight);
 	glVertex2i(0, height());
-	glEnd();
+	glEnd();
+    doneCurrent();
 }
 /**
     \fn ctor



From mean at mail.berlios.de  Fri Jul 29 08:16:24 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 29 Jul 2011 08:16:24 +0200
Subject: [Avidemux-svn-commit] r7365 - in
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs: include src
Message-ID: <20110729061624.661A5481291@sheep.berlios.de>

Author: mean
Date: 2011-07-29 08:16:24 +0200 (Fri, 29 Jul 2011)
New Revision: 7365

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
Log:
[openGlFilter] Create a dummy widget so that we can have a context attached to a filter

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h	2011-07-29 06:16:21 UTC (rev 7364)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h	2011-07-29 06:16:24 UTC (rev 7365)
@@ -26,7 +26,7 @@
 class ADM_coreVideoFilterQtGl:  public ADM_coreVideoFilter
 {
 protected:
-                            
+                            QGLWidget            *widget;
                     const   QGLContext           *context;
                             QGLFramebufferObject *fboY;
                             QGLFramebufferObject *fboUV;

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	2011-07-29 06:16:21 UTC (rev 7364)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	2011-07-29 06:16:24 UTC (rev 7365)
@@ -54,6 +54,8 @@
     glProgramUV=NULL;
     fboY=NULL;
     fboUV=NULL;
+    widget=new QGLWidget(ADM_getGlWidget());
+    widget->makeCurrent();
     firstRun=0;
     ADM_info("Gl : Allocating context and frameBufferObjects\n");
     context=QGLContext::currentContext();
@@ -69,6 +71,7 @@
         GUI_Error_HIG("","Cannot get glActiveTexture");
         ADM_assert(0);
     }
+    widget->doneCurrent();
     // glTexture TODO
 
 }
@@ -86,6 +89,8 @@
     fboY=NULL;
     if(fboUV) delete fboUV;
     fboUV=NULL;
+    if(widget) delete widget;       
+    widget=NULL;
 
 }
 /**



From mean at mail.berlios.de  Fri Jul 29 08:16:25 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 29 Jul 2011 08:16:25 +0200
Subject: [Avidemux-svn-commit] r7366 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl:
	. sample sample_fragment sample_vertex
Message-ID: <20110729061625.D35A0481291@sheep.berlios.de>

Author: mean
Date: 2011-07-29 08:16:25 +0200 (Fri, 29 Jul 2011)
New Revision: 7366

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.ui
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.ui
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.ui
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt
Log:
[openGl/SampleFragment] Use dummy widget to protect context

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt	2011-07-29 06:16:24 UTC (rev 7365)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt	2011-07-29 06:16:25 UTC (rev 7366)
@@ -1 +1,2 @@
-ADD_SUBDIRECTORY(sample)
+ADD_SUBDIRECTORY(sample_fragment)
+ADD_SUBDIRECTORY(sample_vertex)

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt	2011-07-29 06:16:24 UTC (rev 7365)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/CMakeLists.txt	2011-07-29 06:16:25 UTC (rev 7366)
@@ -1,7 +0,0 @@
-INCLUDE(vf_plugin)
-INCLUDE(vf_plugin_qt4gl)
-
-
-SET(ADM_vf_sampleGl_SRCS sampleGl.cpp)
-INIT_VIDEO_FILTER_GLQT4(ADM_vf_sampleGl "${ADM_vf_sampleGl_SRCS}" "sampleGl.h" "sampleGl" "${ADM_vf_sampleGl_SRCS}")
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-29 06:16:24 UTC (rev 7365)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp	2011-07-29 06:16:25 UTC (rev 7366)
@@ -1,260 +0,0 @@
-/** *************************************************************************
-                    \fn       openGlSample.cpp  
-                    \brief simplest of all video filters, it does nothing
-
-    copyright            : (C) 2009 by mean
-
-bench : 1280*720, null shader, 20 ms, 95% of it in download texture.
-            Download Texture
-                RGB2Y=5ms               (MMX it)
-                toQimage=14 ms  <<==    TOO SLOW
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#define GL_GLEXT_PROTOTYPES
-
-#include <QtGui/QPainter>
-
-#ifdef __APPLE__
-#       include <OpenGL/gl.h>
-#       include <OpenGL/glext.h>
-#       define GL_TEXTURE_RECTANGLE_NV GL_TEXTURE_RECTANGLE_EXT
-#else
-#       include <GL/gl.h>
-#       include <GL/glext.h>
-#endif
-
-#include <QtGui/QImage>
-#include <QtOpenGL/QtOpenGL>
-#include <QtOpenGL/QGLShader>
-
-
-#define ADM_LEGACY_PROGGY
-#include "ADM_default.h"
-#include "ADM_coreVideoFilterInternal.h"
-#include "T_openGL.h"
-#include "T_openGLFilter.h"
-#include "sampleGl.h"
-#include "ADM_clock.h"
-/**
-
-*/
-
-//#define BENCH 1
-//#define BENCH_READTEXTURE
-
-
-/**
-    \class openGlSample
-*/
-class openGlSample : public  ADM_coreVideoFilterQtGl
-{
-protected:
-protected:
-                        //bool uploadTexture(ADMImage *image, ADM_PLANE plane);
-                        bool render(ADMImage *image,ADM_PLANE plane,QGLFramebufferObject *fbo);
-                        void tinyUploadTex(ADMImage *img, ADM_PLANE plane, GLuint tex,int texNum );
-public:
-                             openGlSample(ADM_coreVideoFilter *previous,CONFcouple *conf);
-                            ~openGlSample();
-
-        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
-        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
-	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
-        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
-        virtual bool         configure(void) {return true;}             /// Start graphical user interface
-};
-
-// Add the hook to make it valid plugin
-DECLARE_VIDEO_FILTER(   openGlSample,   // Class
-                        1,0,0,              // Version
-                        ADM_UI_QT4+ADM_UI_GL,         // UI
-                        VF_OPENGL,            // Category
-                        "glsample",            // internal name (must be uniq!)
-                        "OpenGl Sample",            // Display name
-                        "Run a fragment shader." // Description
-                    );
-
-// Now implements the interesting parts
-/**
-    \fn openGlSample
-    \brief constructor
-*/
-openGlSample::openGlSample(  ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilterQtGl(in,setup)
-{
-UNUSED_ARG(setup);
-        fboY->bind();
-        printf("Compiling shader \n");
-        glProgramY = new QGLShaderProgram(context);
-        ADM_assert(glProgramY);
-        if ( !glProgramY->addShaderFromSourceCode(QGLShader::Fragment, myShaderY))
-        {
-                ADM_error("[GL Render] Fragment log: %s\n", glProgramY->log().toUtf8().constData());
-                ADM_assert(0);
-        }
-        if ( !glProgramY->link())
-        {
-            ADM_error("[GL Render] Link log: %s\n", glProgramY->log().toUtf8().constData());
-            ADM_assert(0);
-        }
-
-        if ( !glProgramY->bind())
-        {
-                ADM_error("[GL Render] Binding FAILED\n");
-                ADM_assert(0);
-        }
-        fboY->release();
-//
-        fboUV->bind();
-        printf("Compiling shader \n");
-        glProgramUV = new QGLShaderProgram(context);
-        ADM_assert(glProgramUV);
-        if ( !glProgramUV->addShaderFromSourceCode(QGLShader::Fragment, myShaderY))
-        {
-                ADM_error("[GL Render] Fragment log: %s\n", glProgramUV->log().toUtf8().constData());
-                ADM_assert(0);
-        }
-        if ( !glProgramUV->link())
-        {
-            ADM_error("[GL Render] Link log: %s\n", glProgramUV->log().toUtf8().constData());
-            ADM_assert(0);
-        }
-
-        if ( !glProgramUV->bind())
-        {
-                ADM_error("[GL Render] Binding FAILED\n");
-                ADM_assert(0);
-        }
-        fboUV->release();
-
-}
-/**
-    \fn openGlSample
-    \brief destructor
-*/
-openGlSample::~openGlSample()
-{
-
-}
-
-/**
-    \fn getFrame
-    \brief Get a processed frame
-*/
-bool openGlSample::getNextFrame(uint32_t *fn,ADMImage *image)
-{
-    // since we do nothing, just get the output of previous filter
-    if(false==previousFilter->getNextFrame(fn,image))
-    {
-        ADM_warning("FlipFilter : Cannot get frame\n");
-        return false;
-    }
-    float angle=*fn;
-    angle=0.3+angle/40;
-    glProgramY->setUniformValue("teta", angle); 
-    glProgramUV->setUniformValue("teta", angle); 
-        // size is the last one...
-    fboY->bind();
-    tinyUploadTex(image,PLANAR_Y,GL_TEXTURE0,0);
-    glProgramY->setUniformValue("myTexture", 0); 
-    render(image,PLANAR_Y,fboY);
-    downloadTexture(image,PLANAR_Y,fboY);
-    fboY->release();
-
-    fboUV->bind();
-    tinyUploadTex(image,PLANAR_U,GL_TEXTURE1,1);
-    glProgramUV->setUniformValue("myTexture", 1); 
-    render(image,PLANAR_U,fboUV);
-    downloadTexture(image,PLANAR_U,fboUV);
-    
-    tinyUploadTex(image,PLANAR_V,GL_TEXTURE2,2);
-    glProgramUV->setUniformValue("myTexture", 2); 
-    render(image,PLANAR_V,fboUV);
-    downloadTexture(image,PLANAR_V,fboUV);
-    fboUV->release();
-    firstRun=false;
-    return true;
-}
-/**
-    \fn getCoupledConf
-    \brief Return our current configuration as couple name=value
-*/
-bool         openGlSample::getCoupledConf(CONFcouple **couples)
-{
-    *couples=new CONFcouple(0); // Even if we dont have configuration we must allocate one 
-    return true;
-}
-/**
-    \fn getConfiguration
-    \brief Return current setting as a string
-*/
-const char *openGlSample::getConfiguration(void)
-{
-    
-    return "openGl Sample.";
-}
-/**
-    \fn uploadTexture
-*/
-void openGlSample::tinyUploadTex(ADMImage *image, ADM_PLANE plane, GLuint tex,int texNum )
-{
-        myGlActiveTexture(tex);
-        glBindTexture(GL_TEXTURE_RECTANGLE_NV, texNum);
-        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-        if(!firstRun)
-        {
-            glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, 
-                            image->GetPitch(plane),
-                            image->GetHeight(plane), 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, 
-                            image->GetReadPtr(plane));
-        }else
-        {
-            glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, 
-                image->GetPitch(plane),
-                image->GetHeight(plane),
-                GL_LUMINANCE, GL_UNSIGNED_BYTE, 
-                image->GetReadPtr(plane));
-        }
-}
-
-
-/**
-    \fn render
-*/
-bool openGlSample::render(ADMImage *image,ADM_PLANE plane,QGLFramebufferObject *fbo)
-{
-    int width=image->GetWidth(plane);
-    int height=image->GetHeight(plane);
-
-    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-	glViewport(0, 0, width, height);
-    glMatrixMode(GL_PROJECTION);
-    glLoadIdentity();
-    glOrtho(0, width, 0, height, -1, 1);
-
-    //
-    glBegin(GL_QUADS);
-	glTexCoord2i(0, 0);
-	glVertex2i(0, 0);
-	glTexCoord2i(width, 0);
-	glVertex2i(width, 0);
-	glTexCoord2i(width, height);
-	glVertex2i(width ,height);
-	glTexCoord2i(0, height);
-	glVertex2i(0, height);
-	glEnd();	// draw cube background
-    return true;
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h	2011-07-29 06:16:24 UTC (rev 7365)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h	2011-07-29 06:16:25 UTC (rev 7366)
@@ -1,34 +0,0 @@
-// Invert x & y
-static const char *myShaderY =
-	"#extension GL_ARB_texture_rectangle: enable\n"
-	"uniform sampler2DRect myTexture;\n"
-    "uniform float teta;\n"
-
-	"void main(void) {\n"
-    "  float angle=teta;\n" //"0.2;"
-	"  float nx = gl_TexCoord[0].x;\n"
-	"  float ny = gl_TexCoord[0].y;\n"
-    "  float s= sin(angle);\n"
-    "  float c= cos(angle);\n"
-    "  float my= nx*s+ny*c;\n"
-    "  float mx= nx*c+ny*s;\n"
-	"  float t =  texture2DRect(myTexture, vec2(mx, my)).r;\n"
-       // no op
-	"  gl_FragColor = vec4(t, t, t, 1.0);\n"
-	//"  gl_FragColor = vec4(t, 1.0-t, 2*t, 1.0);\n"
-	"}\n";
-// Not used
-static const char *myShaderUV =
-	"#extension GL_ARB_texture_rectangle: enable\n"
-	"uniform sampler2DRect myUVTex;\n"
-
-	"void main(void) {\n"
-	"  float nx = gl_TexCoord[0].x;\n"
-	"  float ny = gl_TexCoord[0].y;\n"
-	"  float t =  texture2DRect(myUVTex, vec2(nx, ny)).r;\n"
-       // no op
-	"  gl_FragColor = vec4(t, t, t, 1.0);\n"
-	//"  gl_FragColor = vec4(t, 1.0-t, 2*t, 1.0);\n"
-	"}\n";
-
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.ui
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.ui	2011-07-29 06:16:24 UTC (rev 7365)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.ui	2011-07-29 06:16:25 UTC (rev 7366)
@@ -1,724 +0,0 @@
-<ui version="4.0" >
- <class>resizeDialog</class>
- <widget class="QDialog" name="resizeDialog" >
-  <property name="geometry" >
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>350</width>
-    <height>342</height>
-   </rect>
-  </property>
-  <property name="windowTitle" >
-   <string>Resize</string>
-  </property>
-  <layout class="QVBoxLayout" >
-   <property name="margin" >
-    <number>9</number>
-   </property>
-   <property name="spacing" >
-    <number>6</number>
-   </property>
-   <item>
-    <widget class="QGroupBox" name="groupBox_2" >
-     <property name="title" >
-      <string>Aspect Ratio</string>
-     </property>
-     <layout class="QVBoxLayout" >
-      <property name="margin" >
-       <number>9</number>
-      </property>
-      <property name="spacing" >
-       <number>6</number>
-      </property>
-      <item>
-       <widget class="QCheckBox" name="lockArCheckBox" >
-        <property name="text" >
-         <string>Lock Aspect Ratio</string>
-        </property>
-        <property name="checked" >
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <layout class="QHBoxLayout" >
-        <property name="margin" >
-         <number>0</number>
-        </property>
-        <property name="spacing" >
-         <number>6</number>
-        </property>
-        <item>
-         <widget class="QLabel" name="label_4" >
-          <property name="text" >
-           <string>Source:</string>
-          </property>
-         </widget>
-        </item>
-        <item>
-         <widget class="QComboBox" name="comboBoxSource" >
-          <item>
-           <property name="text" >
-            <string>1:1</string>
-           </property>
-          </item>
-          <item>
-           <property name="text" >
-            <string>4:3</string>
-           </property>
-          </item>
-          <item>
-           <property name="text" >
-            <string>16:9</string>
-           </property>
-          </item>
-         </widget>
-        </item>
-        <item>
-         <spacer>
-          <property name="orientation" >
-           <enum>Qt::Horizontal</enum>
-          </property>
-          <property name="sizeType" >
-           <enum>QSizePolicy::Fixed</enum>
-          </property>
-          <property name="sizeHint" >
-           <size>
-            <width>30</width>
-            <height>20</height>
-           </size>
-          </property>
-         </spacer>
-        </item>
-        <item>
-         <widget class="QLabel" name="label_3" >
-          <property name="text" >
-           <string>Destination:</string>
-          </property>
-         </widget>
-        </item>
-        <item>
-         <widget class="QComboBox" name="comboBoxDestination" >
-          <item>
-           <property name="text" >
-            <string>1:1</string>
-           </property>
-          </item>
-          <item>
-           <property name="text" >
-            <string>4:3</string>
-           </property>
-          </item>
-          <item>
-           <property name="text" >
-            <string>16:9</string>
-           </property>
-          </item>
-         </widget>
-        </item>
-        <item>
-         <spacer>
-          <property name="orientation" >
-           <enum>Qt::Horizontal</enum>
-          </property>
-          <property name="sizeHint" >
-           <size>
-            <width>40</width>
-            <height>20</height>
-           </size>
-          </property>
-         </spacer>
-        </item>
-       </layout>
-      </item>
-     </layout>
-    </widget>
-   </item>
-   <item>
-    <widget class="QGroupBox" name="groupBox" >
-     <property name="title" >
-      <string>Resize Dimensions</string>
-     </property>
-     <layout class="QVBoxLayout" >
-      <property name="margin" >
-       <number>9</number>
-      </property>
-      <property name="spacing" >
-       <number>6</number>
-      </property>
-      <item>
-       <layout class="QHBoxLayout" >
-        <property name="margin" >
-         <number>0</number>
-        </property>
-        <property name="spacing" >
-         <number>6</number>
-        </property>
-        <item>
-         <widget class="QLabel" name="label" >
-          <property name="text" >
-           <string>Width:</string>
-          </property>
-         </widget>
-        </item>
-        <item>
-         <widget class="QSpinBox" name="spinBoxWidth" >
-          <property name="maximum" >
-           <number>2900</number>
-          </property>
-          <property name="minimum" >
-           <number>16</number>
-          </property>
-          <property name="singleStep" >
-           <number>2</number>
-          </property>
-         </widget>
-        </item>
-        <item>
-         <spacer>
-          <property name="orientation" >
-           <enum>Qt::Horizontal</enum>
-          </property>
-          <property name="sizeType" >
-           <enum>QSizePolicy::Fixed</enum>
-          </property>
-          <property name="sizeHint" >
-           <size>
-            <width>30</width>
-            <height>20</height>
-           </size>
-          </property>
-         </spacer>
-        </item>
-        <item>
-         <widget class="QLabel" name="label_2" >
-          <property name="text" >
-           <string>Height:</string>
-          </property>
-         </widget>
-        </item>
-        <item>
-         <widget class="QSpinBox" name="spinBoxHeight" >
-          <property name="maximum" >
-           <number>2000</number>
-          </property>
-          <property name="minimum" >
-           <number>16</number>
-          </property>
-          <property name="singleStep" >
-           <number>2</number>
-          </property>
-         </widget>
-        </item>
-        <item>
-         <spacer>
-          <property name="orientation" >
-           <enum>Qt::Horizontal</enum>
-          </property>
-          <property name="sizeHint" >
-           <size>
-            <width>40</width>
-            <height>20</height>
-           </size>
-          </property>
-         </spacer>
-        </item>
-       </layout>
-      </item>
-      <item>
-       <widget class="QCheckBox" name="checkBoxRoundup" >
-        <property name="text" >
-         <string>Round to the Nearest Multiple of 16</string>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <spacer>
-        <property name="orientation" >
-         <enum>Qt::Vertical</enum>
-        </property>
-        <property name="sizeType" >
-         <enum>QSizePolicy::Fixed</enum>
-        </property>
-        <property name="sizeHint" >
-         <size>
-          <width>312</width>
-          <height>4</height>
-         </size>
-        </property>
-       </spacer>
-      </item>
-      <item>
-       <layout class="QVBoxLayout" >
-        <property name="margin" >
-         <number>0</number>
-        </property>
-        <property name="spacing" >
-         <number>6</number>
-        </property>
-        <item>
-         <layout class="QHBoxLayout" >
-          <property name="margin" >
-           <number>0</number>
-          </property>
-          <property name="spacing" >
-           <number>12</number>
-          </property>
-          <item>
-           <layout class="QVBoxLayout" >
-            <property name="margin" >
-             <number>0</number>
-            </property>
-            <property name="spacing" >
-             <number>6</number>
-            </property>
-            <item>
-             <layout class="QHBoxLayout" >
-              <property name="margin" >
-               <number>0</number>
-              </property>
-              <property name="spacing" >
-               <number>6</number>
-              </property>
-              <item>
-               <widget class="QLabel" name="label_8" >
-                <property name="text" >
-                 <string>1%</string>
-                </property>
-               </widget>
-              </item>
-              <item>
-               <spacer>
-                <property name="orientation" >
-                 <enum>Qt::Horizontal</enum>
-                </property>
-                <property name="sizeHint" >
-                 <size>
-                  <width>40</width>
-                  <height>20</height>
-                 </size>
-                </property>
-               </spacer>
-              </item>
-              <item>
-               <widget class="QLabel" name="label_5" >
-                <property name="text" >
-                 <string>Percent</string>
-                </property>
-               </widget>
-              </item>
-              <item>
-               <spacer>
-                <property name="orientation" >
-                 <enum>Qt::Horizontal</enum>
-                </property>
-                <property name="sizeHint" >
-                 <size>
-                  <width>40</width>
-                  <height>20</height>
-                 </size>
-                </property>
-               </spacer>
-              </item>
-              <item>
-               <widget class="QLabel" name="label_9" >
-                <property name="text" >
-                 <string>200%</string>
-                </property>
-               </widget>
-              </item>
-             </layout>
-            </item>
-            <item>
-             <widget class="QSlider" name="horizontalSlider" >
-              <property name="minimum" >
-               <number>1</number>
-              </property>
-              <property name="maximum" >
-               <number>200</number>
-              </property>
-              <property name="value" >
-               <number>100</number>
-              </property>
-              <property name="orientation" >
-               <enum>Qt::Horizontal</enum>
-              </property>
-             </widget>
-            </item>
-           </layout>
-          </item>
-          <item>
-           <widget class="QSpinBox" name="percentageSpinBox" >
-            <property name="maximum" >
-             <number>200</number>
-            </property>
-            <property name="minimum" >
-             <number>1</number>
-            </property>
-            <property name="value" >
-             <number>100</number>
-            </property>
-           </widget>
-          </item>
-         </layout>
-        </item>
-        <item>
-         <layout class="QHBoxLayout" >
-          <property name="margin" >
-           <number>0</number>
-          </property>
-          <property name="spacing" >
-           <number>6</number>
-          </property>
-          <item>
-           <widget class="QLabel" name="label_10" >
-            <property name="text" >
-             <string>Error X / Y:</string>
-            </property>
-           </widget>
-          </item>
-          <item>
-           <widget class="QLabel" name="labelErrorXY" >
-            <property name="text" >
-             <string>0.00 / 0.00</string>
-            </property>
-           </widget>
-          </item>
-          <item>
-           <spacer>
-            <property name="orientation" >
-             <enum>Qt::Horizontal</enum>
-            </property>
-            <property name="sizeHint" >
-             <size>
-              <width>40</width>
-              <height>20</height>
-             </size>
-            </property>
-           </spacer>
-          </item>
-         </layout>
-        </item>
-       </layout>
-      </item>
-     </layout>
-    </widget>
-   </item>
-   <item>
-    <spacer>
-     <property name="orientation" >
-      <enum>Qt::Vertical</enum>
-     </property>
-     <property name="sizeType" >
-      <enum>QSizePolicy::Fixed</enum>
-     </property>
-     <property name="sizeHint" >
-      <size>
-       <width>332</width>
-       <height>6</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
-   <item>
-    <layout class="QHBoxLayout" >
-     <property name="margin" >
-      <number>0</number>
-     </property>
-     <property name="spacing" >
-      <number>6</number>
-     </property>
-     <item>
-      <widget class="QLabel" name="label_6" >
-       <property name="text" >
-        <string>Resize Method:</string>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QComboBox" name="comboBoxAlgo" >
-       <item>
-        <property name="text" >
-         <string>Bilinear</string>
-        </property>
-       </item>
-       <item>
-        <property name="text" >
-         <string>Bicubic</string>
-        </property>
-       </item>
-       <item>
-        <property name="text" >
-         <string>Lanzcos3</string>
-        </property>
-       </item>
-      </widget>
-     </item>
-     <item>
-      <spacer>
-       <property name="orientation" >
-        <enum>Qt::Horizontal</enum>
-       </property>
-       <property name="sizeHint" >
-        <size>
-         <width>40</width>
-         <height>20</height>
-        </size>
-       </property>
-      </spacer>
-     </item>
-    </layout>
-   </item>
-   <item>
-    <spacer>
-     <property name="orientation" >
-      <enum>Qt::Vertical</enum>
-     </property>
-     <property name="sizeType" >
-      <enum>QSizePolicy::MinimumExpanding</enum>
-     </property>
-     <property name="sizeHint" >
-      <size>
-       <width>20</width>
-       <height>16</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
-   <item>
-    <widget class="QDialogButtonBox" name="buttonBox" >
-     <property name="orientation" >
-      <enum>Qt::Horizontal</enum>
-     </property>
-     <property name="standardButtons" >
-      <set>QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok</set>
-     </property>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <tabstops>
-  <tabstop>lockArCheckBox</tabstop>
-  <tabstop>comboBoxSource</tabstop>
-  <tabstop>comboBoxDestination</tabstop>
-  <tabstop>spinBoxWidth</tabstop>
-  <tabstop>spinBoxHeight</tabstop>
-  <tabstop>checkBoxRoundup</tabstop>
-  <tabstop>horizontalSlider</tabstop>
-  <tabstop>percentageSpinBox</tabstop>
-  <tabstop>comboBoxAlgo</tabstop>
-  <tabstop>buttonBox</tabstop>
- </tabstops>
- <resources/>
- <connections>
-  <connection>
-   <sender>buttonBox</sender>
-   <signal>rejected()</signal>
-   <receiver>resizeDialog</receiver>
-   <slot>reject()</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>316</x>
-     <y>260</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>286</x>
-     <y>274</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>label_8</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>184</x>
-     <y>117</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>39</x>
-     <y>148</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>label_5</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>184</x>
-     <y>117</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>150</x>
-     <y>148</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>label_9</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>184</x>
-     <y>117</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>267</x>
-     <y>148</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>horizontalSlider</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>184</x>
-     <y>117</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>156</x>
-     <y>164</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>percentageSpinBox</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>184</x>
-     <y>117</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>317</x>
-     <y>155</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>checkBoxRoundup</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>184</x>
-     <y>95</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>184</x>
-     <y>117</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>label_10</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>182</x>
-     <y>155</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>55</x>
-     <y>251</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>labelErrorXY</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>182</x>
-     <y>155</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>114</x>
-     <y>251</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>label_4</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>182</x>
-     <y>69</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>46</x>
-     <y>95</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>comboBoxSource</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>182</x>
-     <y>69</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>94</x>
-     <y>95</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>label_3</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>182</x>
-     <y>69</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>188</x>
-     <y>95</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>lockArCheckBox</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>comboBoxDestination</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>182</x>
-     <y>69</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>247</x>
-     <y>95</y>
-    </hint>
-   </hints>
-  </connection>
- </connections>
-</ui>

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/CMakeLists.txt	2011-07-29 06:16:25 UTC (rev 7366)
@@ -0,0 +1,7 @@
+INCLUDE(vf_plugin)
+INCLUDE(vf_plugin_qt4gl)
+
+
+SET(ADM_vf_sampleGlFrag_SRCS sampleGl.cpp)
+INIT_VIDEO_FILTER_GLQT4(ADM_vf_sampleGlFrag "${ADM_vf_sampleGlFrag_SRCS}" "sampleGl.h" "sampleGl" "${ADM_vf_sampleGl_SRCS}")
+

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp (from rev 7365, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp	2011-07-29 06:16:25 UTC (rev 7366)
@@ -0,0 +1,271 @@
+/** *************************************************************************
+                    \fn       openGlSample.cpp  
+                    \brief simplest of all video filters, it does nothing
+
+    copyright            : (C) 2009 by mean
+
+bench : 1280*720, null shader, 20 ms, 95% of it in download texture.
+            Download Texture
+                RGB2Y=5ms               (MMX it)
+                toQimage=14 ms  <<==    TOO SLOW
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#define GL_GLEXT_PROTOTYPES
+
+#include <QtGui/QPainter>
+
+#ifdef __APPLE__
+#       include <OpenGL/gl.h>
+#       include <OpenGL/glext.h>
+#       define GL_TEXTURE_RECTANGLE_NV GL_TEXTURE_RECTANGLE_EXT
+#else
+#       include <GL/gl.h>
+#       include <GL/glext.h>
+#endif
+
+#include <QtGui/QImage>
+#include <QtOpenGL/QtOpenGL>
+#include <QtOpenGL/QGLShader>
+
+
+#define ADM_LEGACY_PROGGY
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "T_openGL.h"
+#include "T_openGLFilter.h"
+#include "sampleGl.h"
+#include "ADM_clock.h"
+/**
+
+*/
+
+//#define BENCH 1
+//#define BENCH_READTEXTURE
+
+
+/**
+    \class openGlSample
+*/
+class openGlSample : public  ADM_coreVideoFilterQtGl
+{
+protected:
+protected:
+                        //bool uploadTexture(ADMImage *image, ADM_PLANE plane);
+                        bool render(ADMImage *image,ADM_PLANE plane,QGLFramebufferObject *fbo);
+                        void tinyUploadTex(ADMImage *img, ADM_PLANE plane, GLuint tex,int texNum );
+public:
+                             openGlSample(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                            ~openGlSample();
+
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) {return true;}             /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   openGlSample,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_QT4+ADM_UI_GL,         // UI
+                        VF_OPENGL,            // Category
+                        "glsampleFragment",            // internal name (must be uniq!)
+                        "OpenGl Fragment Shader Sample",            // Display name
+                        "Run a fragment shader." // Description
+                    );
+
+// Now implements the interesting parts
+/**
+    \fn openGlSample
+    \brief constructor
+*/
+openGlSample::openGlSample(  ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilterQtGl(in,setup)
+{
+UNUSED_ARG(setup);
+        widget->makeCurrent();
+        fboY->bind();
+        printf("Compiling shader \n");
+        glProgramY = new QGLShaderProgram(context);
+        ADM_assert(glProgramY);
+        if ( !glProgramY->addShaderFromSourceCode(QGLShader::Fragment, myShaderY))
+        {
+                ADM_error("[GL Render] Fragment log: %s\n", glProgramY->log().toUtf8().constData());
+                ADM_assert(0);
+        }
+        if ( !glProgramY->link())
+        {
+            ADM_error("[GL Render] Link log: %s\n", glProgramY->log().toUtf8().constData());
+            ADM_assert(0);
+        }
+
+        if ( !glProgramY->bind())
+        {
+                ADM_error("[GL Render] Binding FAILED\n");
+                ADM_assert(0);
+        }
+        fboY->release();
+//
+        fboUV->bind();
+        printf("Compiling shader \n");
+        glProgramUV = new QGLShaderProgram(context);
+        ADM_assert(glProgramUV);
+        if ( !glProgramUV->addShaderFromSourceCode(QGLShader::Fragment, myShaderY))
+        {
+                ADM_error("[GL Render] Fragment log: %s\n", glProgramUV->log().toUtf8().constData());
+                ADM_assert(0);
+        }
+        if ( !glProgramUV->link())
+        {
+            ADM_error("[GL Render] Link log: %s\n", glProgramUV->log().toUtf8().constData());
+            ADM_assert(0);
+        }
+
+        if ( !glProgramUV->bind())
+        {
+                ADM_error("[GL Render] Binding FAILED\n");
+                ADM_assert(0);
+        }
+        fboUV->release();
+        widget->doneCurrent();
+
+}
+/**
+    \fn openGlSample
+    \brief destructor
+*/
+openGlSample::~openGlSample()
+{
+
+}
+
+/**
+    \fn getFrame
+    \brief Get a processed frame
+*/
+bool openGlSample::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    // since we do nothing, just get the output of previous filter
+    if(false==previousFilter->getNextFrame(fn,image))
+    {
+        ADM_warning("FlipFilter : Cannot get frame\n");
+        return false;
+    }
+    widget->makeCurrent();
+    glPushMatrix();
+    float angle=*fn;
+    angle=0.3+angle/40;
+    glProgramY->setUniformValue("teta", angle); 
+    glProgramUV->setUniformValue("teta", angle); 
+        // size is the last one...
+    fboY->bind();
+    tinyUploadTex(image,PLANAR_Y,GL_TEXTURE0,0);
+    
+    render(image,PLANAR_Y,fboY);
+    downloadTexture(image,PLANAR_Y,fboY);
+    fboY->release();
+
+    fboUV->bind();
+    tinyUploadTex(image,PLANAR_U,GL_TEXTURE1,1);
+    glProgramUV->setUniformValue("myTexture", 1); 
+    render(image,PLANAR_U,fboUV);
+    downloadTexture(image,PLANAR_U,fboUV);
+    
+    tinyUploadTex(image,PLANAR_V,GL_TEXTURE2,2);
+    glProgramUV->setUniformValue("myTexture", 2); 
+    render(image,PLANAR_V,fboUV);
+    downloadTexture(image,PLANAR_V,fboUV);
+    fboUV->release();
+    firstRun=false;
+    glPopMatrix();
+    widget->doneCurrent();
+    
+    return true;
+}
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         openGlSample::getCoupledConf(CONFcouple **couples)
+{
+    *couples=new CONFcouple(0); // Even if we dont have configuration we must allocate one 
+    return true;
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *openGlSample::getConfiguration(void)
+{
+    
+    return "openGl Sample.";
+}
+/**
+    \fn uploadTexture
+*/
+void openGlSample::tinyUploadTex(ADMImage *image, ADM_PLANE plane, GLuint tex,int texNum )
+{
+        myGlActiveTexture(tex);
+        glBindTexture(GL_TEXTURE_RECTANGLE_NV, texNum);
+        glProgramY->setUniformValue("myTexture", texNum); 
+        glProgramY->setUniformValue("myWidth", image->GetWidth(plane)); 
+        glProgramY->setUniformValue("myHeight", image->GetHeight(plane)); 
+
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+        if(!firstRun)
+        {
+            glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, 
+                            image->GetPitch(plane),
+                            image->GetHeight(plane), 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                            image->GetReadPtr(plane));
+        }else
+        {
+            glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, 
+                image->GetPitch(plane),
+                image->GetHeight(plane),
+                GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                image->GetReadPtr(plane));
+        }
+}
+
+
+/**
+    \fn render
+*/
+bool openGlSample::render(ADMImage *image,ADM_PLANE plane,QGLFramebufferObject *fbo)
+{
+    int width=image->GetWidth(plane);
+    int height=image->GetHeight(plane);
+
+    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
+	glViewport(0, 0, width, height);
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    glOrtho(0, width, 0, height, -1, 1);
+
+    //
+    glBegin(GL_QUADS);
+	glTexCoord2i(0, 0);
+	glVertex2i(0, 0);
+	glTexCoord2i(width, 0);
+	glVertex2i(width, 0);
+	glTexCoord2i(width, height);
+	glVertex2i(width ,height);
+	glTexCoord2i(0, height);
+	glVertex2i(0, height);
+	glEnd();	// draw cube background
+    return true;
+}
+//EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h (from rev 7365, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h	2011-07-29 06:16:25 UTC (rev 7366)
@@ -0,0 +1,24 @@
+// Invert x & y
+static const char *myShaderY =
+	"#extension GL_ARB_texture_rectangle: enable\n"
+	"uniform sampler2DRect myTexture;\n"
+    "uniform float teta;\n"
+    "uniform float myWidth;\n"
+    "uniform float myHeight;\n"
+
+	"void main(void) {\n"
+    "  float angle=teta;\n" //"0.2;"
+	"  float nx = gl_TexCoord[0].x;\n"
+	"  float ny = gl_TexCoord[0].y;\n"
+    "  float s= sin(angle);\n"
+    "  float c= cos(angle);\n"
+    "  nx=nx-myWidth/2;\n"
+    "  ny=ny-myHeight/2;\n"
+    "  float my= nx*s+ny*c+myWidth/2;\n"
+    "  float mx= nx*c-ny*s+myHeight/2;\n"
+	"  float t =  texture2DRect(myTexture, vec2(mx, my)).r;\n"
+       // no op
+	"  gl_FragColor = vec4(t, t, t, 1.0);\n"
+	//"  gl_FragColor = vec4(t, 1.0-t, 2*t, 1.0);\n"
+	"}\n";
+

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.ui (from rev 7365, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.ui)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.ui	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.ui	2011-07-29 06:16:25 UTC (rev 7366)
@@ -0,0 +1,724 @@
+<ui version="4.0" >
+ <class>resizeDialog</class>
+ <widget class="QDialog" name="resizeDialog" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>350</width>
+    <height>342</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Resize</string>
+  </property>
+  <layout class="QVBoxLayout" >
+   <property name="margin" >
+    <number>9</number>
+   </property>
+   <property name="spacing" >
+    <number>6</number>
+   </property>
+   <item>
+    <widget class="QGroupBox" name="groupBox_2" >
+     <property name="title" >
+      <string>Aspect Ratio</string>
+     </property>
+     <layout class="QVBoxLayout" >
+      <property name="margin" >
+       <number>9</number>
+      </property>
+      <property name="spacing" >
+       <number>6</number>
+      </property>
+      <item>
+       <widget class="QCheckBox" name="lockArCheckBox" >
+        <property name="text" >
+         <string>Lock Aspect Ratio</string>
+        </property>
+        <property name="checked" >
+         <bool>true</bool>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <layout class="QHBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <widget class="QLabel" name="label_4" >
+          <property name="text" >
+           <string>Source:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QComboBox" name="comboBoxSource" >
+          <item>
+           <property name="text" >
+            <string>1:1</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>4:3</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>16:9</string>
+           </property>
+          </item>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeType" >
+           <enum>QSizePolicy::Fixed</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>30</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+        <item>
+         <widget class="QLabel" name="label_3" >
+          <property name="text" >
+           <string>Destination:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QComboBox" name="comboBoxDestination" >
+          <item>
+           <property name="text" >
+            <string>1:1</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>4:3</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>16:9</string>
+           </property>
+          </item>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>40</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+       </layout>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <widget class="QGroupBox" name="groupBox" >
+     <property name="title" >
+      <string>Resize Dimensions</string>
+     </property>
+     <layout class="QVBoxLayout" >
+      <property name="margin" >
+       <number>9</number>
+      </property>
+      <property name="spacing" >
+       <number>6</number>
+      </property>
+      <item>
+       <layout class="QHBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <widget class="QLabel" name="label" >
+          <property name="text" >
+           <string>Width:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QSpinBox" name="spinBoxWidth" >
+          <property name="maximum" >
+           <number>2900</number>
+          </property>
+          <property name="minimum" >
+           <number>16</number>
+          </property>
+          <property name="singleStep" >
+           <number>2</number>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeType" >
+           <enum>QSizePolicy::Fixed</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>30</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+        <item>
+         <widget class="QLabel" name="label_2" >
+          <property name="text" >
+           <string>Height:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QSpinBox" name="spinBoxHeight" >
+          <property name="maximum" >
+           <number>2000</number>
+          </property>
+          <property name="minimum" >
+           <number>16</number>
+          </property>
+          <property name="singleStep" >
+           <number>2</number>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>40</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+       </layout>
+      </item>
+      <item>
+       <widget class="QCheckBox" name="checkBoxRoundup" >
+        <property name="text" >
+         <string>Round to the Nearest Multiple of 16</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <spacer>
+        <property name="orientation" >
+         <enum>Qt::Vertical</enum>
+        </property>
+        <property name="sizeType" >
+         <enum>QSizePolicy::Fixed</enum>
+        </property>
+        <property name="sizeHint" >
+         <size>
+          <width>312</width>
+          <height>4</height>
+         </size>
+        </property>
+       </spacer>
+      </item>
+      <item>
+       <layout class="QVBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <layout class="QHBoxLayout" >
+          <property name="margin" >
+           <number>0</number>
+          </property>
+          <property name="spacing" >
+           <number>12</number>
+          </property>
+          <item>
+           <layout class="QVBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <layout class="QHBoxLayout" >
+              <property name="margin" >
+               <number>0</number>
+              </property>
+              <property name="spacing" >
+               <number>6</number>
+              </property>
+              <item>
+               <widget class="QLabel" name="label_8" >
+                <property name="text" >
+                 <string>1%</string>
+                </property>
+               </widget>
+              </item>
+              <item>
+               <spacer>
+                <property name="orientation" >
+                 <enum>Qt::Horizontal</enum>
+                </property>
+                <property name="sizeHint" >
+                 <size>
+                  <width>40</width>
+                  <height>20</height>
+                 </size>
+                </property>
+               </spacer>
+              </item>
+              <item>
+               <widget class="QLabel" name="label_5" >
+                <property name="text" >
+                 <string>Percent</string>
+                </property>
+               </widget>
+              </item>
+              <item>
+               <spacer>
+                <property name="orientation" >
+                 <enum>Qt::Horizontal</enum>
+                </property>
+                <property name="sizeHint" >
+                 <size>
+                  <width>40</width>
+                  <height>20</height>
+                 </size>
+                </property>
+               </spacer>
+              </item>
+              <item>
+               <widget class="QLabel" name="label_9" >
+                <property name="text" >
+                 <string>200%</string>
+                </property>
+               </widget>
+              </item>
+             </layout>
+            </item>
+            <item>
+             <widget class="QSlider" name="horizontalSlider" >
+              <property name="minimum" >
+               <number>1</number>
+              </property>
+              <property name="maximum" >
+               <number>200</number>
+              </property>
+              <property name="value" >
+               <number>100</number>
+              </property>
+              <property name="orientation" >
+               <enum>Qt::Horizontal</enum>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+          <item>
+           <widget class="QSpinBox" name="percentageSpinBox" >
+            <property name="maximum" >
+             <number>200</number>
+            </property>
+            <property name="minimum" >
+             <number>1</number>
+            </property>
+            <property name="value" >
+             <number>100</number>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </item>
+        <item>
+         <layout class="QHBoxLayout" >
+          <property name="margin" >
+           <number>0</number>
+          </property>
+          <property name="spacing" >
+           <number>6</number>
+          </property>
+          <item>
+           <widget class="QLabel" name="label_10" >
+            <property name="text" >
+             <string>Error X / Y:</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QLabel" name="labelErrorXY" >
+            <property name="text" >
+             <string>0.00 / 0.00</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <spacer>
+            <property name="orientation" >
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="sizeHint" >
+             <size>
+              <width>40</width>
+              <height>20</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+         </layout>
+        </item>
+       </layout>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <spacer>
+     <property name="orientation" >
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeType" >
+      <enum>QSizePolicy::Fixed</enum>
+     </property>
+     <property name="sizeHint" >
+      <size>
+       <width>332</width>
+       <height>6</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" >
+     <property name="margin" >
+      <number>0</number>
+     </property>
+     <property name="spacing" >
+      <number>6</number>
+     </property>
+     <item>
+      <widget class="QLabel" name="label_6" >
+       <property name="text" >
+        <string>Resize Method:</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QComboBox" name="comboBoxAlgo" >
+       <item>
+        <property name="text" >
+         <string>Bilinear</string>
+        </property>
+       </item>
+       <item>
+        <property name="text" >
+         <string>Bicubic</string>
+        </property>
+       </item>
+       <item>
+        <property name="text" >
+         <string>Lanzcos3</string>
+        </property>
+       </item>
+      </widget>
+     </item>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <spacer>
+     <property name="orientation" >
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeType" >
+      <enum>QSizePolicy::MinimumExpanding</enum>
+     </property>
+     <property name="sizeHint" >
+      <size>
+       <width>20</width>
+       <height>16</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+   <item>
+    <widget class="QDialogButtonBox" name="buttonBox" >
+     <property name="orientation" >
+      <enum>Qt::Horizontal</enum>
+     </property>
+     <property name="standardButtons" >
+      <set>QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok</set>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <tabstops>
+  <tabstop>lockArCheckBox</tabstop>
+  <tabstop>comboBoxSource</tabstop>
+  <tabstop>comboBoxDestination</tabstop>
+  <tabstop>spinBoxWidth</tabstop>
+  <tabstop>spinBoxHeight</tabstop>
+  <tabstop>checkBoxRoundup</tabstop>
+  <tabstop>horizontalSlider</tabstop>
+  <tabstop>percentageSpinBox</tabstop>
+  <tabstop>comboBoxAlgo</tabstop>
+  <tabstop>buttonBox</tabstop>
+ </tabstops>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>resizeDialog</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>316</x>
+     <y>260</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>286</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_8</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>39</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_5</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>150</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_9</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>267</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>horizontalSlider</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>156</x>
+     <y>164</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>percentageSpinBox</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>317</x>
+     <y>155</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>checkBoxRoundup</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>95</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_10</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>155</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>55</x>
+     <y>251</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>labelErrorXY</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>155</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>114</x>
+     <y>251</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_4</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>46</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>comboBoxSource</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>94</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_3</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>188</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>comboBoxDestination</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>247</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/CMakeLists.txt	2011-07-29 06:16:25 UTC (rev 7366)
@@ -0,0 +1,7 @@
+INCLUDE(vf_plugin)
+INCLUDE(vf_plugin_qt4gl)
+
+
+SET(ADM_vf_sampleGlVertex_SRCS sampleGl.cpp)
+INIT_VIDEO_FILTER_GLQT4(ADM_vf_sampleGlVertex "${ADM_vf_sampleGl_SRCS}" "sampleGl.h" "sampleGl" "${ADM_vf_sampleGl_SRCS}")
+

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.cpp (from rev 7365, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.cpp	2011-07-29 06:16:25 UTC (rev 7366)
@@ -0,0 +1,264 @@
+/** *************************************************************************
+                    \fn       openGlSample.cpp  
+                    \brief simplest of all video filters, it does nothing
+
+    copyright            : (C) 2009 by mean
+
+bench : 1280*720, null shader, 20 ms, 95% of it in download texture.
+            Download Texture
+                RGB2Y=5ms               (MMX it)
+                toQimage=14 ms  <<==    TOO SLOW
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#define GL_GLEXT_PROTOTYPES
+
+#include <QtGui/QPainter>
+
+#ifdef __APPLE__
+#       include <OpenGL/gl.h>
+#       include <OpenGL/glext.h>
+#       define GL_TEXTURE_RECTANGLE_NV GL_TEXTURE_RECTANGLE_EXT
+#else
+#       include <GL/gl.h>
+#       include <GL/glext.h>
+#endif
+
+#include <QtGui/QImage>
+#include <QtOpenGL/QtOpenGL>
+#include <QtOpenGL/QGLShader>
+
+
+#define ADM_LEGACY_PROGGY
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "T_openGL.h"
+#include "T_openGLFilter.h"
+#include "sampleGl.h"
+#include "ADM_clock.h"
+/**
+
+*/
+
+//#define BENCH 1
+//#define BENCH_READTEXTURE
+
+
+/**
+    \class openGlSample
+*/
+class openGlSample : public  ADM_coreVideoFilterQtGl
+{
+protected:
+protected:
+                        //bool uploadTexture(ADMImage *image, ADM_PLANE plane);
+                        bool render(ADMImage *image,ADM_PLANE plane,QGLFramebufferObject *fbo);
+                        void tinyUploadTex(ADMImage *img, ADM_PLANE plane, GLuint tex,int texNum );
+public:
+                             openGlSample(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                            ~openGlSample();
+
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) {return true;}             /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   openGlSample,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_QT4+ADM_UI_GL,         // UI
+                        VF_OPENGL,            // Category
+                        "glsample",            // internal name (must be uniq!)
+                        "OpenGl Sample",            // Display name
+                        "Run a fragment shader." // Description
+                    );
+
+// Now implements the interesting parts
+/**
+    \fn openGlSample
+    \brief constructor
+*/
+openGlSample::openGlSample(  ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilterQtGl(in,setup)
+{
+UNUSED_ARG(setup);
+        fboY->bind();
+        printf("Compiling shader \n");
+        glProgramY = new QGLShaderProgram(context);
+        ADM_assert(glProgramY);
+        if ( !glProgramY->addShaderFromSourceCode(QGLShader::Fragment, myShaderY))
+        {
+                ADM_error("[GL Render] Fragment log: %s\n", glProgramY->log().toUtf8().constData());
+                ADM_assert(0);
+        }
+        if ( !glProgramY->link())
+        {
+            ADM_error("[GL Render] Link log: %s\n", glProgramY->log().toUtf8().constData());
+            ADM_assert(0);
+        }
+
+        if ( !glProgramY->bind())
+        {
+                ADM_error("[GL Render] Binding FAILED\n");
+                ADM_assert(0);
+        }
+        fboY->release();
+//
+        fboUV->bind();
+        printf("Compiling shader \n");
+        glProgramUV = new QGLShaderProgram(context);
+        ADM_assert(glProgramUV);
+        if ( !glProgramUV->addShaderFromSourceCode(QGLShader::Fragment, myShaderY))
+        {
+                ADM_error("[GL Render] Fragment log: %s\n", glProgramUV->log().toUtf8().constData());
+                ADM_assert(0);
+        }
+        if ( !glProgramUV->link())
+        {
+            ADM_error("[GL Render] Link log: %s\n", glProgramUV->log().toUtf8().constData());
+            ADM_assert(0);
+        }
+
+        if ( !glProgramUV->bind())
+        {
+                ADM_error("[GL Render] Binding FAILED\n");
+                ADM_assert(0);
+        }
+        fboUV->release();
+
+}
+/**
+    \fn openGlSample
+    \brief destructor
+*/
+openGlSample::~openGlSample()
+{
+
+}
+
+/**
+    \fn getFrame
+    \brief Get a processed frame
+*/
+bool openGlSample::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    // since we do nothing, just get the output of previous filter
+    if(false==previousFilter->getNextFrame(fn,image))
+    {
+        ADM_warning("FlipFilter : Cannot get frame\n");
+        return false;
+    }
+    float angle=*fn;
+    angle=0.3+angle/40;
+    glProgramY->setUniformValue("teta", angle); 
+    glProgramUV->setUniformValue("teta", angle); 
+        // size is the last one...
+    fboY->bind();
+    tinyUploadTex(image,PLANAR_Y,GL_TEXTURE0,0);
+    
+    render(image,PLANAR_Y,fboY);
+    downloadTexture(image,PLANAR_Y,fboY);
+    fboY->release();
+
+    fboUV->bind();
+    tinyUploadTex(image,PLANAR_U,GL_TEXTURE1,1);
+    glProgramUV->setUniformValue("myTexture", 1); 
+    render(image,PLANAR_U,fboUV);
+    downloadTexture(image,PLANAR_U,fboUV);
+    
+    tinyUploadTex(image,PLANAR_V,GL_TEXTURE2,2);
+    glProgramUV->setUniformValue("myTexture", 2); 
+    render(image,PLANAR_V,fboUV);
+    downloadTexture(image,PLANAR_V,fboUV);
+    fboUV->release();
+    firstRun=false;
+    return true;
+}
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         openGlSample::getCoupledConf(CONFcouple **couples)
+{
+    *couples=new CONFcouple(0); // Even if we dont have configuration we must allocate one 
+    return true;
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *openGlSample::getConfiguration(void)
+{
+    
+    return "openGl Sample.";
+}
+/**
+    \fn uploadTexture
+*/
+void openGlSample::tinyUploadTex(ADMImage *image, ADM_PLANE plane, GLuint tex,int texNum )
+{
+        myGlActiveTexture(tex);
+        glBindTexture(GL_TEXTURE_RECTANGLE_NV, texNum);
+        glProgramY->setUniformValue("myTexture", texNum); 
+        glProgramY->setUniformValue("myWidth", image->GetWidth(plane)); 
+        glProgramY->setUniformValue("myHeight", image->GetHeight(plane)); 
+
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+        if(!firstRun)
+        {
+            glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, 
+                            image->GetPitch(plane),
+                            image->GetHeight(plane), 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                            image->GetReadPtr(plane));
+        }else
+        {
+            glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, 
+                image->GetPitch(plane),
+                image->GetHeight(plane),
+                GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                image->GetReadPtr(plane));
+        }
+}
+
+
+/**
+    \fn render
+*/
+bool openGlSample::render(ADMImage *image,ADM_PLANE plane,QGLFramebufferObject *fbo)
+{
+    int width=image->GetWidth(plane);
+    int height=image->GetHeight(plane);
+
+    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
+	glViewport(0, 0, width, height);
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    glOrtho(0, width, 0, height, -1, 1);
+
+    //
+    glBegin(GL_QUADS);
+	glTexCoord2i(0, 0);
+	glVertex2i(0, 0);
+	glTexCoord2i(width, 0);
+	glVertex2i(width, 0);
+	glTexCoord2i(width, height);
+	glVertex2i(width ,height);
+	glTexCoord2i(0, height);
+	glVertex2i(0, height);
+	glEnd();	// draw cube background
+    return true;
+}
+//EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.h (from rev 7365, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.h	2011-07-29 06:16:25 UTC (rev 7366)
@@ -0,0 +1,24 @@
+// Invert x & y
+static const char *myShaderY =
+	"#extension GL_ARB_texture_rectangle: enable\n"
+	"uniform sampler2DRect myTexture;\n"
+    "uniform float teta;\n"
+    "uniform float myWidth;\n"
+    "uniform float myHeight;\n"
+
+	"void main(void) {\n"
+    "  float angle=teta;\n" //"0.2;"
+	"  float nx = gl_TexCoord[0].x;\n"
+	"  float ny = gl_TexCoord[0].y;\n"
+    "  float s= sin(angle);\n"
+    "  float c= cos(angle);\n"
+    "  nx=nx-myWidth/2;\n"
+    "  ny=ny-myHeight/2;\n"
+    "  float my= nx*s+ny*c+myWidth/2;\n"
+    "  float mx= nx*c-ny*s+myHeight/2;\n"
+	"  float t =  texture2DRect(myTexture, vec2(mx, my)).r;\n"
+       // no op
+	"  gl_FragColor = vec4(t, t, t, 1.0);\n"
+	//"  gl_FragColor = vec4(t, 1.0-t, 2*t, 1.0);\n"
+	"}\n";
+

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.ui (from rev 7365, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample/sampleGl.ui)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.ui	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/sampleGl.ui	2011-07-29 06:16:25 UTC (rev 7366)
@@ -0,0 +1,724 @@
+<ui version="4.0" >
+ <class>resizeDialog</class>
+ <widget class="QDialog" name="resizeDialog" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>350</width>
+    <height>342</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Resize</string>
+  </property>
+  <layout class="QVBoxLayout" >
+   <property name="margin" >
+    <number>9</number>
+   </property>
+   <property name="spacing" >
+    <number>6</number>
+   </property>
+   <item>
+    <widget class="QGroupBox" name="groupBox_2" >
+     <property name="title" >
+      <string>Aspect Ratio</string>
+     </property>
+     <layout class="QVBoxLayout" >
+      <property name="margin" >
+       <number>9</number>
+      </property>
+      <property name="spacing" >
+       <number>6</number>
+      </property>
+      <item>
+       <widget class="QCheckBox" name="lockArCheckBox" >
+        <property name="text" >
+         <string>Lock Aspect Ratio</string>
+        </property>
+        <property name="checked" >
+         <bool>true</bool>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <layout class="QHBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <widget class="QLabel" name="label_4" >
+          <property name="text" >
+           <string>Source:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QComboBox" name="comboBoxSource" >
+          <item>
+           <property name="text" >
+            <string>1:1</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>4:3</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>16:9</string>
+           </property>
+          </item>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeType" >
+           <enum>QSizePolicy::Fixed</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>30</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+        <item>
+         <widget class="QLabel" name="label_3" >
+          <property name="text" >
+           <string>Destination:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QComboBox" name="comboBoxDestination" >
+          <item>
+           <property name="text" >
+            <string>1:1</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>4:3</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>16:9</string>
+           </property>
+          </item>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>40</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+       </layout>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <widget class="QGroupBox" name="groupBox" >
+     <property name="title" >
+      <string>Resize Dimensions</string>
+     </property>
+     <layout class="QVBoxLayout" >
+      <property name="margin" >
+       <number>9</number>
+      </property>
+      <property name="spacing" >
+       <number>6</number>
+      </property>
+      <item>
+       <layout class="QHBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <widget class="QLabel" name="label" >
+          <property name="text" >
+           <string>Width:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QSpinBox" name="spinBoxWidth" >
+          <property name="maximum" >
+           <number>2900</number>
+          </property>
+          <property name="minimum" >
+           <number>16</number>
+          </property>
+          <property name="singleStep" >
+           <number>2</number>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeType" >
+           <enum>QSizePolicy::Fixed</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>30</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+        <item>
+         <widget class="QLabel" name="label_2" >
+          <property name="text" >
+           <string>Height:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QSpinBox" name="spinBoxHeight" >
+          <property name="maximum" >
+           <number>2000</number>
+          </property>
+          <property name="minimum" >
+           <number>16</number>
+          </property>
+          <property name="singleStep" >
+           <number>2</number>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>40</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+       </layout>
+      </item>
+      <item>
+       <widget class="QCheckBox" name="checkBoxRoundup" >
+        <property name="text" >
+         <string>Round to the Nearest Multiple of 16</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <spacer>
+        <property name="orientation" >
+         <enum>Qt::Vertical</enum>
+        </property>
+        <property name="sizeType" >
+         <enum>QSizePolicy::Fixed</enum>
+        </property>
+        <property name="sizeHint" >
+         <size>
+          <width>312</width>
+          <height>4</height>
+         </size>
+        </property>
+       </spacer>
+      </item>
+      <item>
+       <layout class="QVBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <layout class="QHBoxLayout" >
+          <property name="margin" >
+           <number>0</number>
+          </property>
+          <property name="spacing" >
+           <number>12</number>
+          </property>
+          <item>
+           <layout class="QVBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <layout class="QHBoxLayout" >
+              <property name="margin" >
+               <number>0</number>
+              </property>
+              <property name="spacing" >
+               <number>6</number>
+              </property>
+              <item>
+               <widget class="QLabel" name="label_8" >
+                <property name="text" >
+                 <string>1%</string>
+                </property>
+               </widget>
+              </item>
+              <item>
+               <spacer>
+                <property name="orientation" >
+                 <enum>Qt::Horizontal</enum>
+                </property>
+                <property name="sizeHint" >
+                 <size>
+                  <width>40</width>
+                  <height>20</height>
+                 </size>
+                </property>
+               </spacer>
+              </item>
+              <item>
+               <widget class="QLabel" name="label_5" >
+                <property name="text" >
+                 <string>Percent</string>
+                </property>
+               </widget>
+              </item>
+              <item>
+               <spacer>
+                <property name="orientation" >
+                 <enum>Qt::Horizontal</enum>
+                </property>
+                <property name="sizeHint" >
+                 <size>
+                  <width>40</width>
+                  <height>20</height>
+                 </size>
+                </property>
+               </spacer>
+              </item>
+              <item>
+               <widget class="QLabel" name="label_9" >
+                <property name="text" >
+                 <string>200%</string>
+                </property>
+               </widget>
+              </item>
+             </layout>
+            </item>
+            <item>
+             <widget class="QSlider" name="horizontalSlider" >
+              <property name="minimum" >
+               <number>1</number>
+              </property>
+              <property name="maximum" >
+               <number>200</number>
+              </property>
+              <property name="value" >
+               <number>100</number>
+              </property>
+              <property name="orientation" >
+               <enum>Qt::Horizontal</enum>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+          <item>
+           <widget class="QSpinBox" name="percentageSpinBox" >
+            <property name="maximum" >
+             <number>200</number>
+            </property>
+            <property name="minimum" >
+             <number>1</number>
+            </property>
+            <property name="value" >
+             <number>100</number>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </item>
+        <item>
+         <layout class="QHBoxLayout" >
+          <property name="margin" >
+           <number>0</number>
+          </property>
+          <property name="spacing" >
+           <number>6</number>
+          </property>
+          <item>
+           <widget class="QLabel" name="label_10" >
+            <property name="text" >
+             <string>Error X / Y:</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QLabel" name="labelErrorXY" >
+            <property name="text" >
+             <string>0.00 / 0.00</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <spacer>
+            <property name="orientation" >
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="sizeHint" >
+             <size>
+              <width>40</width>
+              <height>20</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+         </layout>
+        </item>
+       </layout>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <spacer>
+     <property name="orientation" >
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeType" >
+      <enum>QSizePolicy::Fixed</enum>
+     </property>
+     <property name="sizeHint" >
+      <size>
+       <width>332</width>
+       <height>6</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" >
+     <property name="margin" >
+      <number>0</number>
+     </property>
+     <property name="spacing" >
+      <number>6</number>
+     </property>
+     <item>
+      <widget class="QLabel" name="label_6" >
+       <property name="text" >
+        <string>Resize Method:</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QComboBox" name="comboBoxAlgo" >
+       <item>
+        <property name="text" >
+         <string>Bilinear</string>
+        </property>
+       </item>
+       <item>
+        <property name="text" >
+         <string>Bicubic</string>
+        </property>
+       </item>
+       <item>
+        <property name="text" >
+         <string>Lanzcos3</string>
+        </property>
+       </item>
+      </widget>
+     </item>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <spacer>
+     <property name="orientation" >
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeType" >
+      <enum>QSizePolicy::MinimumExpanding</enum>
+     </property>
+     <property name="sizeHint" >
+      <size>
+       <width>20</width>
+       <height>16</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+   <item>
+    <widget class="QDialogButtonBox" name="buttonBox" >
+     <property name="orientation" >
+      <enum>Qt::Horizontal</enum>
+     </property>
+     <property name="standardButtons" >
+      <set>QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok</set>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <tabstops>
+  <tabstop>lockArCheckBox</tabstop>
+  <tabstop>comboBoxSource</tabstop>
+  <tabstop>comboBoxDestination</tabstop>
+  <tabstop>spinBoxWidth</tabstop>
+  <tabstop>spinBoxHeight</tabstop>
+  <tabstop>checkBoxRoundup</tabstop>
+  <tabstop>horizontalSlider</tabstop>
+  <tabstop>percentageSpinBox</tabstop>
+  <tabstop>comboBoxAlgo</tabstop>
+  <tabstop>buttonBox</tabstop>
+ </tabstops>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>resizeDialog</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>316</x>
+     <y>260</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>286</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_8</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>39</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_5</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>150</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_9</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>267</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>horizontalSlider</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>156</x>
+     <y>164</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>percentageSpinBox</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>317</x>
+     <y>155</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>checkBoxRoundup</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>95</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_10</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>155</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>55</x>
+     <y>251</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>labelErrorXY</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>155</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>114</x>
+     <y>251</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_4</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>46</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>comboBoxSource</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>94</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_3</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>188</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>comboBoxDestination</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>247</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>



From mean at mail.berlios.de  Fri Jul 29 08:16:27 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 29 Jul 2011 08:16:27 +0200
Subject: [Avidemux-svn-commit] r7367 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment
Message-ID: <20110729061627.3C5D7481291@sheep.berlios.de>

Author: mean
Date: 2011-07-29 08:16:27 +0200 (Fri, 29 Jul 2011)
New Revision: 7367

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h
Log:
[openGlSample] tweak it + add comment

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp	2011-07-29 06:16:25 UTC (rev 7366)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp	2011-07-29 06:16:27 UTC (rev 7367)
@@ -1,9 +1,12 @@
 /** *************************************************************************
-                    \fn       openGlSample.cpp  
-                    \brief simplest of all video filters, it does nothing
+                    \fn       openGlFragmentSample.cpp  
+                    \brief    simple fragment shader
 
-    copyright            : (C) 2009 by mean
+    That one is performing the same shader 3 times, one time per plane.
 
+
+    copyright            : (C) 2011 by mean
+
 bench : 1280*720, null shader, 20 ms, 95% of it in download texture.
             Download Texture
                 RGB2Y=5ms               (MMX it)
@@ -162,10 +165,10 @@
     widget->makeCurrent();
     glPushMatrix();
     float angle=*fn;
-    angle=0.3+angle/40;
+    angle=angle/40;
     glProgramY->setUniformValue("teta", angle); 
     glProgramUV->setUniformValue("teta", angle); 
-        // size is the last one...
+    // size is the last one...
     fboY->bind();
     tinyUploadTex(image,PLANAR_Y,GL_TEXTURE0,0);
     

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h	2011-07-29 06:16:25 UTC (rev 7366)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h	2011-07-29 06:16:27 UTC (rev 7367)
@@ -12,12 +12,11 @@
 	"  float ny = gl_TexCoord[0].y;\n"
     "  float s= sin(angle);\n"
     "  float c= cos(angle);\n"
-    "  nx=nx-myWidth/2;\n"
-    "  ny=ny-myHeight/2;\n"
-    "  float my= nx*s+ny*c+myWidth/2;\n"
-    "  float mx= nx*c-ny*s+myHeight/2;\n"
+    "  nx=nx;\n"
+    "  ny=ny;\n"
+    "  float my= nx*s+ny*c+0.5;\n"
+    "  float mx= nx*c-ny*s+0.5;\n"
 	"  float t =  texture2DRect(myTexture, vec2(mx, my)).r;\n"
-       // no op
 	"  gl_FragColor = vec4(t, t, t, 1.0);\n"
 	//"  gl_FragColor = vec4(t, 1.0-t, 2*t, 1.0);\n"
 	"}\n";



From mean at mail.berlios.de  Sun Jul 31 19:15:13 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 31 Jul 2011 19:15:13 +0200
Subject: [Avidemux-svn-commit] r7368 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src
Message-ID: <20110731171513.A9CE74833A4@sheep.berlios.de>

Author: mean
Date: 2011-07-31 19:15:12 +0200 (Sun, 31 Jul 2011)
New Revision: 7368

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/prefs.cpp
Log:
[prefs] Return valid error code (true/false) rather than RC_xxx

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/prefs.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/prefs.cpp	2011-07-29 06:16:27 UTC (rev 7367)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/prefs.cpp	2011-07-31 17:15:12 UTC (rev 7368)
@@ -161,7 +161,7 @@
 
 
     dir_adm=ADM_getBaseDir();
-    if(!dir_adm) return RC_FAILED;
+    if(!dir_adm) return false;
 
     path=string(dir_adm);
     path=path+std::string("/");
@@ -171,15 +171,15 @@
     if(!ADM_fileExist(path.c_str()))
     {
 		ADM_error("can't read %s\n",			path.c_str());
-		return RC_FAILED;
+		return false;
     }
     if(true==my_prefs_struct_jdeserialize(path.c_str(),my_prefs_struct_param,&myPrefs))
     {
         ADM_info("Preferences found and loaded\n");
-        return RC_OK;
+        return true;
     }
     ADM_warning("An error happened while loading config\n");
-    return RC_FAILED;
+    return true;
 }
 
 /**



From mean at mail.berlios.de  Sun Jul 31 19:15:14 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 31 Jul 2011 19:15:14 +0200
Subject: [Avidemux-svn-commit] r7369 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <20110731171515.04C974833A4@sheep.berlios.de>

Author: mean
Date: 2011-07-31 19:15:14 +0200 (Sun, 31 Jul 2011)
New Revision: 7369

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
Log:
[all] Try to set good default for devices if no prefs

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2011-07-31 17:15:12 UTC (rev 7368)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2011-07-31 17:15:14 UTC (rev 7369)
@@ -37,6 +37,8 @@
 #include "audio_out.h"
 #include "ADM_assert.h"
 
+
+static bool setPrefsDefault(void);
 extern void  ADM_lavInit();
 extern void  ADM_lavDestroy();
 extern void  ADM_lavFormatInit(void);
@@ -195,10 +197,13 @@
         printf("Current time :%s\n",ADM_epochToString(ADM_getSecondsSinceEpoch()));
 	// Start counting memory
 	ADM_memStatInit();
-        ADM_InitMemcpy();
+    ADM_InitMemcpy();
 	printf("\nInitialising prefs\n");
 	initPrefs();
-	prefs->load();
+	if(false==prefs->load()) // no prefs, set some sane default
+    {
+        setPrefsDefault();
+    }
     CpuCaps::init();
 
 #ifdef USE_SDL
@@ -405,6 +410,26 @@
 	check_leaks();
 #endif
 }
+/**
+    \fn setPrefsDefault
+*/
+bool setPrefsDefault(void)
+{
+#ifdef __MINGW32__
+        prefs->set(AUDIO_DEVICE_AUDIODEVICE,"Win32");        
+    #ifdef USE_OPENGL
+        prefs->set(VIDEODEVICE,(uint32_t)5); // QTGL
+    #endif
+#endif        
+#ifdef __linux__
+            prefs->set(AUDIO_DEVICE_AUDIODEVICE,"PulseAudioS");
+    #ifdef USE_VDPAU
+            prefs->set(VIDEODEVICE,(uint32_t)4); // VDPAU
+    #else
+            prefs->set(VIDEODEVICE,(uint32_t)1); // XV
+    #endif
+#endif
+}
 extern void checkCrashFile(void);
 void dummyXref(void)
 {



From mean at mail.berlios.de  Sun Jul 31 19:15:15 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 31 Jul 2011 19:15:15 +0200
Subject: [Avidemux-svn-commit] r7370 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	. removePlane
Message-ID: <20110731171515.EDE404833A4@sheep.berlios.de>

Author: mean
Date: 2011-07-31 19:15:15 +0200 (Sun, 31 Jul 2011)
New Revision: 7370

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/removePlane.cpp
Log:
[filter] Add a remove plane video filter for debug purpose

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/removePlane.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/removePlane.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/removePlane.cpp	2011-07-31 17:15:15 UTC (rev 7370)
@@ -0,0 +1,155 @@
+/** *************************************************************************
+                    \file     removePlaneFilter.cpp  
+                    \brief    remove Y,U or V plane
+    copyright            : (C) 2011 by mean
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "DIA_factory.h"
+#include "rplane.h"
+#include "rplane_desc.cpp"
+/**
+    \class removePlaneFilter
+*/
+class removePlaneFilter : public  ADM_coreVideoFilter
+{
+public:
+                    removePlaneFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                    ~removePlaneFilter();
+                removePlane  config;
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;             /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   removePlaneFilter,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_COLORS,            // Category
+                        "rplane",            // internal name (must be uniq!)
+                        "Remove  Plane",            // Display name
+                        "Remove Y,U or V plane (used mainly to debug other filters)." // Description
+                    );
+
+// Now implements the interesting parts
+/**
+    \fn removePlaneFilter
+    \brief constructor
+*/
+removePlaneFilter::removePlaneFilter(  ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilter(in,setup)
+{
+    if(!setup || !ADM_paramLoad(setup,removePlane_param,&config))
+    {
+        // Default value
+        config.keepY=true;
+        config.keepU=true;
+        config.keepV=true;
+    }
+    // By default the info field contains the output of previous filter
+    // Tweak it here if you change fps, duration, width,...
+}
+/**
+    \fn removePlaneFilter
+    \brief destructor
+*/
+removePlaneFilter::~removePlaneFilter()
+{
+		
+}
+/**
+    \fn blank
+*/
+static bool blank(ADMImage *img,ADM_PLANE plane, int filler)
+{
+    int width=img->GetWidth(plane); 
+    int height=img->GetHeight(plane);
+    int stride=img->GetPitch(plane);
+    uint8_t *ptr=img->GetWritePtr(plane);
+
+    for(int y=0;y<height;y++)
+    {
+        memset(ptr,filler,width);
+        ptr+=stride;
+    }
+    return true;
+}   
+/**
+    \fn getFrame
+    \brief Get a processed frame
+*/
+bool removePlaneFilter::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    // since we do nothing, just get the output of previous filter
+    if(false==previousFilter->getNextFrame(fn,image))
+    {
+        ADM_warning("FlipFilter : Cannot get frame\n");
+        return false;
+    }
+    if(!config.keepY)
+    {   // blank Y
+        blank(image,PLANAR_Y,128);
+    }
+    if(!config.keepU)
+    {
+        blank(image,PLANAR_U,128);
+    }
+    if(!config.keepV)
+    {
+        blank(image,PLANAR_V,128);
+    }
+
+    return true;
+}
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         removePlaneFilter::getCoupledConf(CONFcouple **couples)
+{
+      return ADM_paramSave(couples, removePlane_param,&config);
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *removePlaneFilter::getConfiguration(void)
+{
+    static char cfg[256];
+    static const char *yesno[2]={"N","Y"};
+    snprintf(cfg,255,"Remove Plane (Keep Y:%s Keep U:%s Keep V:%s).",
+                    yesno[config.keepY],yesno[config.keepU],yesno[config.keepV]);
+    return cfg;
+}
+
+/**
+    \fn configure
+*/
+bool removePlaneFilter::configure(void)
+{
+  
+  diaElemToggle planeY(&(config.keepY),QT_TR_NOOP("Keep Y Plane"),QT_TR_NOOP("Process luma plane"));
+  diaElemToggle planeU(&(config.keepU),QT_TR_NOOP("Keep U Plane"),QT_TR_NOOP("Process chromaU plane"));
+  diaElemToggle planeV(&(config.keepV),QT_TR_NOOP("Keep V Plane"),QT_TR_NOOP("Process chromaV plane"));
+  
+  
+  diaElem *elems[3]={&planeY,&planeU,&planeV};
+  
+  return diaFactoryRun(QT_TR_NOOP("Remove plane"),3,elems);
+}
+
+
+//EOF



From mean at mail.berlios.de  Sun Jul 31 19:15:17 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 31 Jul 2011 19:15:17 +0200
Subject: [Avidemux-svn-commit] r7371 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane
Message-ID: <20110731171517.3535D4833A4@sheep.berlios.de>

Author: mean
Date: 2011-07-31 19:15:16 +0200 (Sun, 31 Jul 2011)
New Revision: 7371

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane_desc.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane_json.cpp
Log:
[filter] Add a remove plane video filter for debug purpose

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/CMakeLists.txt	2011-07-31 17:15:16 UTC (rev 7371)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_removePlane_SRCS removePlane.cpp)
+
+ADD_VIDEO_FILTER(ADM_vf_removePlane ${ADM_vf_removePlane_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_removePlane)
+INSTALL_VIDEO_FILTER(ADM_vf_removePlane)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane.conf	2011-07-31 17:15:16 UTC (rev 7371)
@@ -0,0 +1,5 @@
+removePlane{
+bool:keepY
+bool:keepU
+bool:keepV
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane.h	2011-07-31 17:15:16 UTC (rev 7371)
@@ -0,0 +1,9 @@
+// automatically generated by admSerialization.py do not edit
+#ifndef ADM_removePlane_CONF_H
+#define ADM_removePlane_CONF_H
+typedef struct {
+bool keepY;
+bool keepU;
+bool keepV;
+}removePlane;
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane_desc.cpp	2011-07-31 17:15:16 UTC (rev 7371)
@@ -0,0 +1,7 @@
+// automatically generated by admSerialization.py, do not edit!
+extern const ADM_paramList removePlane_param[]={
+ {"keepY",offsetof(removePlane,keepY),"bool",ADM_param_bool},
+ {"keepU",offsetof(removePlane,keepU),"bool",ADM_param_bool},
+ {"keepV",offsetof(removePlane,keepV),"bool",ADM_param_bool},
+{NULL,0,NULL}
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane_json.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane_json.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/removePlane/rplane_json.cpp	2011-07-31 17:15:16 UTC (rev 7371)
@@ -0,0 +1,20 @@
+// automatically generated by admSerialization.py, do not edit!
+#include "ADM_default.h"
+#include "ADM_paramList.h"
+#include "ADM_coreJson.h"
+#include "rplane.h"
+bool  removePlane_jserialize(const char *file, const removePlane *key){
+admJson json;
+json.addBool("keepY",key->keepY);
+json.addBool("keepU",key->keepU);
+json.addBool("keepV",key->keepV);
+return json.dumpToFile(file);
+};
+bool  removePlane_jdeserialize(const char *file, const ADM_paramList *tmpl,removePlane *key){
+admJsonToCouple json;
+CONFcouple *c=json.readFromFile(file);
+if(!c) {ADM_error("Cannot read json file");return false;}
+bool r= ADM_paramLoadPartial(c,tmpl,key);
+delete c;
+return r;
+};



From mean at mail.berlios.de  Sun Jul 31 19:15:18 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 31 Jul 2011 19:15:18 +0200
Subject: [Avidemux-svn-commit] r7372 - in
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs: include src
Message-ID: <20110731171518.A27C44833A4@sheep.berlios.de>

Author: mean
Date: 2011-07-31 19:15:18 +0200 (Sun, 31 Jul 2011)
New Revision: 7372

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
Log:
[openGL] Try to download 3 textures at the same time (not working)

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h	2011-07-31 17:15:16 UTC (rev 7371)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/include/T_openGLFilter.h	2011-07-31 17:15:18 UTC (rev 7372)
@@ -36,6 +36,7 @@
                             GlActiveTexture_Type *myGlActiveTexture;
 protected:
                             bool downloadTexture(ADMImage *target, ADM_PLANE plane,QGLFramebufferObject *fbo);
+                            bool downloadTextures(ADMImage *target, QGLFramebufferObject *fbo);
 
 public:
                             ADM_coreVideoFilterQtGl(ADM_coreVideoFilter *previous,CONFcouple *conf=NULL);

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	2011-07-31 17:15:16 UTC (rev 7371)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_UIs/src/T_openGL.cpp	2011-07-31 17:15:18 UTC (rev 7372)
@@ -1,4 +1,4 @@
-/***************************************************************************
+    /***************************************************************************
   \file T_openGL.h
   \brief OpenGL related filters
   \author (C) 2011 Mean Fixounet at free.fr 
@@ -91,8 +91,18 @@
     fboUV=NULL;
     if(widget) delete widget;       
     widget=NULL;
-
 }
+#if  1
+#define TEX_Y_OFFSET 2
+#define TEX_U_OFFSET 1
+#define TEX_V_OFFSET 0  
+#define TEX_A_OFFSET 3   
+#else
+#define TEX_Y_OFFSET 0
+#define TEX_U_OFFSET 1
+#define TEX_V_OFFSET 2   
+#define TEX_A_OFFSET 3   
+#endif
 /**
     \fn downloadTexture
 */
@@ -130,7 +140,7 @@
     int height=image->GetHeight(plane);
     for(int y=0;y<height;y++)
     {
-        const uchar *src=qimg.constScanLine(height-y);
+        const uchar *src=qimg.constScanLine(height-y-1);
         if(!src)
         {
             ADM_error("Can t get pointer to openGl texture\n");
@@ -148,4 +158,70 @@
 #endif
     return true;
 }
+
+/**
+    \fn downloadTexture
+    \brief Download YUVA texture into a YV12 image
+*/
+bool ADM_coreVideoFilterQtGl::downloadTextures(ADMImage *image,  QGLFramebufferObject *fbo)
+{
+
+    QImage qimg(fbo->toImage()); // this is slow ! ~ 15 ms for a 720 picture (Y only).
+    // Assume RGB32, read R or A
+    int strideY=image->GetPitch(PLANAR_Y);
+    uint8_t *toY=image->GetWritePtr(PLANAR_Y);
+    
+    int width=image->GetWidth(PLANAR_Y);
+    int height=image->GetHeight(PLANAR_Y);
+
+    // Do Y
+    for(int y=1;y<=height;y++)
+    {
+        const uchar *src=qimg.constScanLine(height-y);
+        if(!src)
+        {
+            ADM_error("Can t get pointer to openGl texture\n");
+            return false;
+        }
+#if 1
+    printf("RGB");
+    const uchar *src2=src;
+    for(int i=0;i<10;i++)
+    {
+        printf("%d %d %d %d:",src2[i*4],src2[i*4+1],src2[i*4+2],src2[i*4+3]);
+        src2+=4;
+    }
+    printf("\n");
+#endif
+        for(int x=0;x<width;x++)
+        {
+            toY[x]  = src[x*4+TEX_Y_OFFSET];
+            
+        }
+        toY+=strideY;
+    }
+    // do U & V
+    uint8_t *toU=image->GetWritePtr(PLANAR_U);
+    uint8_t *toV=image->GetWritePtr(PLANAR_V);
+    int      strideU=image->GetPitch(PLANAR_U);
+    int      strideV=image->GetPitch(PLANAR_V);
+
+    for(int y=1;y<=height;y+=2)
+    {
+        const uchar *src=qimg.constScanLine(height-y);
+        if(!src)
+        {
+            ADM_error("Can t get pointer to openGl texture\n");
+            return false;
+        }
+        for(int x=0;x<width;x+=2) // Stupid subsample: 1 out of 4
+        {
+            toU[x/2]  =  src[x*4+TEX_U_OFFSET];
+            toV[x/2]  =  src[x*4+TEX_V_OFFSET];
+        }
+        toU+=strideU;
+        toV+=strideV;
+    }
+    return true;
+}
 // EOF
\ No newline at end of file



From mean at mail.berlios.de  Sun Jul 31 19:15:19 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 31 Jul 2011 19:15:19 +0200
Subject: [Avidemux-svn-commit] r7373 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment
Message-ID: <20110731171519.E6F194833A4@sheep.berlios.de>

Author: mean
Date: 2011-07-31 19:15:19 +0200 (Sun, 31 Jul 2011)
New Revision: 7373

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h
Log:
[sampleGl] Change Warp to sharpen

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp	2011-07-31 17:15:18 UTC (rev 7372)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.cpp	2011-07-31 17:15:19 UTC (rev 7373)
@@ -166,12 +166,15 @@
     glPushMatrix();
     float angle=*fn;
     angle=angle/40;
-    glProgramY->setUniformValue("teta", angle); 
-    glProgramUV->setUniformValue("teta", angle); 
+    
+    glProgramUV->setUniformValue("kernelSize", 1);  // Do a convolution kernelSize*2+1 pixels
+    glProgramUV->setUniformValue("normalization", 4); 
     // size is the last one...
     fboY->bind();
+    // upload kernel...
+    
+    // here we go
     tinyUploadTex(image,PLANAR_Y,GL_TEXTURE0,0);
-    
     render(image,PLANAR_Y,fboY);
     downloadTexture(image,PLANAR_Y,fboY);
     fboY->release();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h	2011-07-31 17:15:18 UTC (rev 7372)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment/sampleGl.h	2011-07-31 17:15:19 UTC (rev 7373)
@@ -2,22 +2,28 @@
 static const char *myShaderY =
 	"#extension GL_ARB_texture_rectangle: enable\n"
 	"uniform sampler2DRect myTexture;\n"
-    "uniform float teta;\n"
-    "uniform float myWidth;\n"
-    "uniform float myHeight;\n"
+    "uniform int kernelSize;\n"
+    "uniform int normalization;\n"
 
 	"void main(void) {\n"
-    "  float angle=teta;\n" //"0.2;"
-	"  float nx = gl_TexCoord[0].x;\n"
-	"  float ny = gl_TexCoord[0].y;\n"
-    "  float s= sin(angle);\n"
-    "  float c= cos(angle);\n"
-    "  nx=nx;\n"
-    "  ny=ny;\n"
-    "  float my= nx*s+ny*c+0.5;\n"
-    "  float mx= nx*c-ny*s+0.5;\n"
-	"  float t =  texture2DRect(myTexture, vec2(mx, my)).r;\n"
-	"  gl_FragColor = vec4(t, t, t, 1.0);\n"
-	//"  gl_FragColor = vec4(t, 1.0-t, 2*t, 1.0);\n"
+	"  int nx = (int)gl_TexCoord[0].x;\n"
+	"  int ny = (int)gl_TexCoord[0].y;\n"
+	"  float t =  0;\n"
+    "  float mul;\n"
+    "  int x,y;\n"
+    "  for(y=-kernelSize;y<=kernelSize;y++)\n"
+    "  {\n"
+    "   for(x=-kernelSize;x<=kernelSize;x++)\n"
+    "   {\n"
+    "       if(0==x && 0==y){ mul=4;}\n"
+    "       else if(0==x) {mul=-1;}\n"
+    "       else if(0==y) {mul=-1;}\n"
+    "       else {mul=0;}\n"
+    "       t +=  mul*texture2DRect(myTexture, vec2(nx+x, ny+y)).r;\n"
+    "     }\n"
+    "  }\n"
+    "  t=t/normalization;\n"
+    "  t=t+texture2DRect(myTexture, vec2(nx, ny)).r;\n"
+    "  gl_FragColor = vec4(t, t, t, 1.0);\n"
 	"}\n";
 



From mean at mail.berlios.de  Sun Jul 31 19:15:21 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 31 Jul 2011 19:15:21 +0200
Subject: [Avidemux-svn-commit] r7374 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins:
	ADM_videoFilters6 ADM_videoFilters6_openGl
	ADM_videoFilters6_openGl/sample_vertex
Message-ID: <20110731171521.35CF54833A4@sheep.berlios.de>

Author: mean
Date: 2011-07-31 19:15:20 +0200 (Sun, 31 Jul 2011)
New Revision: 7374

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/CMakeLists.txt
Log:
[openGl] Update CMakelists

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2011-07-31 17:15:19 UTC (rev 7373)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2011-07-31 17:15:20 UTC (rev 7374)
@@ -15,6 +15,7 @@
 ADD_SUBDIRECTORY(lumaOnly)
 ADD_SUBDIRECTORY(mplayerDenoise3D)
 ADD_SUBDIRECTORY(printInfo)
+ADD_SUBDIRECTORY(removePlane)
 ADD_SUBDIRECTORY(resampleFps)
 ADD_SUBDIRECTORY(resize)
 ADD_SUBDIRECTORY(rotate)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt	2011-07-31 17:15:19 UTC (rev 7373)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/CMakeLists.txt	2011-07-31 17:15:20 UTC (rev 7374)
@@ -1,2 +1,3 @@
 ADD_SUBDIRECTORY(sample_fragment)
+ADD_SUBDIRECTORY(sample_fragment2)
 ADD_SUBDIRECTORY(sample_vertex)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/CMakeLists.txt	2011-07-31 17:15:19 UTC (rev 7373)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_vertex/CMakeLists.txt	2011-07-31 17:15:20 UTC (rev 7374)
@@ -3,5 +3,5 @@
 
 
 SET(ADM_vf_sampleGlVertex_SRCS sampleGl.cpp)
-INIT_VIDEO_FILTER_GLQT4(ADM_vf_sampleGlVertex "${ADM_vf_sampleGl_SRCS}" "sampleGl.h" "sampleGl" "${ADM_vf_sampleGl_SRCS}")
+INIT_VIDEO_FILTER_GLQT4(ADM_vf_sampleGlVertex "${ADM_vf_sampleGlVertex_SRCS}" "sampleGl.h" "sampleGl" "${ADM_vf_sampleGl_SRCS}")
 



From mean at mail.berlios.de  Sun Jul 31 19:15:22 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 31 Jul 2011 19:15:22 +0200
Subject: [Avidemux-svn-commit] r7375 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl:
	. sample_fragment2
Message-ID: <20110731171522.789454833A4@sheep.berlios.de>

Author: mean
Date: 2011-07-31 19:15:22 +0200 (Sun, 31 Jul 2011)
New Revision: 7375

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.ui
Log:
[openGl] Add a dummy filter that does all 3planes in the same texture (not working)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/CMakeLists.txt	2011-07-31 17:15:22 UTC (rev 7375)
@@ -0,0 +1,7 @@
+INCLUDE(vf_plugin)
+INCLUDE(vf_plugin_qt4gl)
+
+
+SET(ADM_vf_sampleGlFrag_SRCS sampleGl.cpp)
+INIT_VIDEO_FILTER_GLQT4(ADM_vf_sampleGlFrag2 "${ADM_vf_sampleGlFrag_SRCS}" "sampleGl.h" "sampleGl" "${ADM_vf_sampleGl_SRCS}")
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.cpp	2011-07-31 17:15:22 UTC (rev 7375)
@@ -0,0 +1,332 @@
+/** *************************************************************************
+                    \fn       openGlFragmentSample.cpp  
+                    \brief    simple fragment shader
+
+    This one is combining the 3 textures and apply the shader once
+
+
+    copyright            : (C) 2011 by mean
+
+bench : 1280*720, null shader, 20 ms, 95% of it in download texture.
+            Download Texture
+                RGB2Y=5ms               (MMX it)
+                toQimage=14 ms  <<==    TOO SLOW
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#define GL_GLEXT_PROTOTYPES
+
+#include <QtGui/QPainter>
+
+#ifdef __APPLE__
+#       include <OpenGL/gl.h>
+#       include <OpenGL/glext.h>
+#       define GL_TEXTURE_RECTANGLE_NV GL_TEXTURE_RECTANGLE_EXT
+#else
+#       include <GL/gl.h>
+#       include <GL/glext.h>
+#endif
+
+#include <QtGui/QImage>
+#include <QtOpenGL/QtOpenGL>
+#include <QtOpenGL/QGLShader>
+
+
+#define ADM_LEGACY_PROGGY
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "T_openGL.h"
+#include "T_openGLFilter.h"
+#include "sampleGl.h"
+#include "ADM_clock.h"
+/**
+
+*/
+
+//#define BENCH 1
+//#define BENCH_READTEXTURE
+
+
+/**
+    \class openGlSample
+*/
+class openGlSample : public  ADM_coreVideoFilterQtGl
+{
+protected:
+                        uint8_t *uBuffer;
+                        uint8_t *vBuffer;
+protected:
+                        //bool uploadTexture(ADMImage *image, ADM_PLANE plane);
+                        bool render(ADMImage *image,ADM_PLANE plane,QGLFramebufferObject *fbo);
+                        void tinyUploadTex(ADMImage *img, ADM_PLANE plane, GLuint tex,int texNum );
+                        void multiUploadTex(ADMImage *image);
+public:
+                             openGlSample(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                            ~openGlSample();
+
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) {return true;}             /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   openGlSample,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_QT4+ADM_UI_GL,         // UI
+                        VF_OPENGL,            // Category
+                        "glsampleFragment2",            // internal name (must be uniq!)
+                        "OpenGl Fragment Shader Sample2",            // Display name
+                        "Run a fragment shader." // Description
+                    );
+
+// Now implements the interesting parts
+/**
+    \fn openGlSample
+    \brief constructor
+*/
+openGlSample::openGlSample(  ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilterQtGl(in,setup)
+{
+UNUSED_ARG(setup);
+        widget->makeCurrent();
+        fboY->bind();
+        printf("Compiling shader \n");
+        glProgramY = new QGLShaderProgram(context);
+        ADM_assert(glProgramY);
+        if ( !glProgramY->addShaderFromSourceCode(QGLShader::Fragment, myShaderY))
+        {
+                ADM_error("[GL Render] Fragment log: %s\n", glProgramY->log().toUtf8().constData());
+                ADM_assert(0);
+        }
+        if ( !glProgramY->link())
+        {
+            ADM_error("[GL Render] Link log: %s\n", glProgramY->log().toUtf8().constData());
+            ADM_assert(0);
+        }
+
+        if ( !glProgramY->bind())
+        {
+                ADM_error("[GL Render] Binding FAILED\n");
+                ADM_assert(0);
+        }
+        uBuffer=new uint8_t[info.width*info.height];
+        vBuffer=new uint8_t[info.width*info.height];
+        fboY->release();
+        widget->doneCurrent();
+
+}
+/**
+    \fn openGlSample
+    \brief destructor
+*/
+openGlSample::~openGlSample()
+{
+    delete [] uBuffer;
+    delete [] vBuffer;
+    uBuffer=NULL;
+    vBuffer=NULL;
+
+}
+
+/**
+    \fn getFrame
+    \brief Get a processed frame
+*/
+bool openGlSample::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    // since we do nothing, just get the output of previous filter
+    if(false==previousFilter->getNextFrame(fn,image))
+    {
+        ADM_warning("FlipFilter : Cannot get frame\n");
+        return false;
+    }
+    widget->makeCurrent();
+    glPushMatrix();
+    float angle=*fn;
+    angle=angle/40;
+    glProgramY->setUniformValue("teta", angle); 
+    glProgramY->setUniformValue("teta", angle); 
+    
+    glProgramY->setUniformValue("myTextureU", 1); 
+    glProgramY->setUniformValue("myTextureV", 2); 
+    glProgramY->setUniformValue("myTextureY", 0); 
+    glProgramY->setUniformValue("myWidth", image->GetWidth(PLANAR_Y)); 
+    glProgramY->setUniformValue("myHeight", image->GetHeight(PLANAR_Y)); 
+
+    // size is the last one...
+    fboY->bind();
+#if 0
+    tinyUploadTex(image,PLANAR_V,GL_TEXTURE2,2);
+    tinyUploadTex(image,PLANAR_U,GL_TEXTURE1,1);
+    tinyUploadTex(image,PLANAR_Y,GL_TEXTURE0,0);
+#else
+    multiUploadTex(image);
+#endif
+    render(image,PLANAR_Y,fboY);
+    downloadTextures(image,fboY);
+    fboY->release();
+    firstRun=false;
+    glPopMatrix();
+    widget->doneCurrent();
+    
+    return true;
+}
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         openGlSample::getCoupledConf(CONFcouple **couples)
+{
+    *couples=new CONFcouple(0); // Even if we dont have configuration we must allocate one 
+    return true;
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *openGlSample::getConfiguration(void)
+{
+    
+    return "openGl Sample.";
+}
+/**
+    \fn uploadTexture
+*/
+void openGlSample::tinyUploadTex(ADMImage *image, ADM_PLANE plane, GLuint tex,int texNum )
+{
+        myGlActiveTexture(tex);  // Activate texture unit "tex"
+        glBindTexture(GL_TEXTURE_RECTANGLE_NV, texNum); // Use texture "texNum"
+
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+        if(!firstRun)
+        {
+            glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, 
+                            image->GetPitch(plane),
+                            image->GetHeight(plane), 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                            image->GetReadPtr(plane));
+        }else
+        {
+            glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, 
+                image->GetPitch(plane),
+                image->GetHeight(plane),
+                GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                image->GetReadPtr(plane));
+        }
+}
+/**
+    \fn uploadTexture
+*/
+void openGlSample::multiUploadTex(ADMImage *image)
+{
+          // Activate texture unit "tex"
+        for(int xplane=0;xplane<3;xplane++)
+        {
+            myGlActiveTexture(GL_TEXTURE0+xplane);
+            ADM_PLANE plane=(ADM_PLANE)xplane;
+            glBindTexture(GL_TEXTURE_RECTANGLE_NV, xplane); // Use texture "texNum"
+            glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+            glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+            glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+            glTexParameteri(GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+            if(plane==PLANAR_Y) // take Y as it is..
+            {
+                if(!firstRun)
+                {
+                    glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, 
+                                    image->GetPitch(plane),
+                                    image->GetHeight(plane), 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                                    image->GetReadPtr(plane));
+                }else
+                {
+                    glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, 
+                        image->GetPitch(plane),
+                        image->GetHeight(plane),
+                        GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                        image->GetReadPtr(plane));
+                }
+            }else
+            {
+                    uint8_t *buffer,*src,*tmp,*tgt;
+                    int stride;
+                    // expand into U or V buffer... 
+                    if(plane==PLANAR_U) 
+                            buffer=uBuffer;
+                        else buffer=vBuffer;
+                    
+                    src=image->GetReadPtr(plane);
+                    stride=image->GetPitch(plane);
+
+                    tmp=src;
+                    tgt=buffer;
+                    for(int y=0;y<info.height;y+=2)
+                    {
+                        for(int x=0;x<info.width;x+=2)
+                        {
+                                tgt[x]=tgt[x+stride]=tmp[x/2];
+                                tgt[x+1]=tgt[x+1+stride]=tmp[x/2];
+                        }
+                        tmp+=stride;
+                        tgt+=2*info.width;
+                    }
+                    // upload
+                    if(!firstRun)
+                    {
+                        glTexImage2D(GL_TEXTURE_RECTANGLE_NV, 0, GL_LUMINANCE, 
+                                    info.width,
+                                    info.height, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                                    buffer);
+                    }else
+                    {
+                        glTexSubImage2D(GL_TEXTURE_RECTANGLE_NV, 0, 0, 0, 
+                        info.width,
+                        info.height,
+                        GL_LUMINANCE, GL_UNSIGNED_BYTE, 
+                        buffer);
+                    } 
+            }
+        }
+}
+
+
+/**
+    \fn render
+*/
+bool openGlSample::render(ADMImage *image,ADM_PLANE plane,QGLFramebufferObject *fbo)
+{
+    int width=image->GetWidth(plane);
+    int height=image->GetHeight(plane);
+
+    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
+	glViewport(0, 0, width, height);
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    glOrtho(0, width, 0, height, -1, 1);
+
+    //
+    glBegin(GL_QUADS);
+	glTexCoord2i(0, 0);
+	glVertex2i(0, 0);
+	glTexCoord2i(width, 0);
+	glVertex2i(width, 0);
+	glTexCoord2i(width, height);
+	glVertex2i(width ,height);
+	glTexCoord2i(0, height);
+	glVertex2i(0, height);
+	glEnd();	// draw cube background
+    return true;
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.h	2011-07-31 17:15:22 UTC (rev 7375)
@@ -0,0 +1,16 @@
+// Invert x & y
+static const char *myShaderY =
+	"#extension GL_ARB_texture_rectangle: enable\n"
+	"uniform sampler2DRect myTextureY;\n"
+    "uniform sampler2DRect myTextureU;\n"
+    "uniform sampler2DRect myTextureV;\n"
+    "uniform float myWidth;\n"
+    "uniform float myHeight;\n"
+
+	"void main(void) {\n"
+    "  vec4 texvalV = texture2DRect(myTextureV, vec2(gl_TexCoord[2]));\n"
+    "  vec4 texvalU = texture2DRect(myTextureU, vec2(gl_TexCoord[1]));\n"
+	"  vec4 texvalY = texture2DRect(myTextureY, vec2(gl_TexCoord[0]));\n"
+	"  gl_FragColor = vec4(texvalY.r, texvalU.r, texvalV.r, 1.0);\n"
+	"}\n";
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.ui
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.ui	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6_openGl/sample_fragment2/sampleGl.ui	2011-07-31 17:15:22 UTC (rev 7375)
@@ -0,0 +1,724 @@
+<ui version="4.0" >
+ <class>resizeDialog</class>
+ <widget class="QDialog" name="resizeDialog" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>350</width>
+    <height>342</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Resize</string>
+  </property>
+  <layout class="QVBoxLayout" >
+   <property name="margin" >
+    <number>9</number>
+   </property>
+   <property name="spacing" >
+    <number>6</number>
+   </property>
+   <item>
+    <widget class="QGroupBox" name="groupBox_2" >
+     <property name="title" >
+      <string>Aspect Ratio</string>
+     </property>
+     <layout class="QVBoxLayout" >
+      <property name="margin" >
+       <number>9</number>
+      </property>
+      <property name="spacing" >
+       <number>6</number>
+      </property>
+      <item>
+       <widget class="QCheckBox" name="lockArCheckBox" >
+        <property name="text" >
+         <string>Lock Aspect Ratio</string>
+        </property>
+        <property name="checked" >
+         <bool>true</bool>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <layout class="QHBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <widget class="QLabel" name="label_4" >
+          <property name="text" >
+           <string>Source:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QComboBox" name="comboBoxSource" >
+          <item>
+           <property name="text" >
+            <string>1:1</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>4:3</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>16:9</string>
+           </property>
+          </item>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeType" >
+           <enum>QSizePolicy::Fixed</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>30</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+        <item>
+         <widget class="QLabel" name="label_3" >
+          <property name="text" >
+           <string>Destination:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QComboBox" name="comboBoxDestination" >
+          <item>
+           <property name="text" >
+            <string>1:1</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>4:3</string>
+           </property>
+          </item>
+          <item>
+           <property name="text" >
+            <string>16:9</string>
+           </property>
+          </item>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>40</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+       </layout>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <widget class="QGroupBox" name="groupBox" >
+     <property name="title" >
+      <string>Resize Dimensions</string>
+     </property>
+     <layout class="QVBoxLayout" >
+      <property name="margin" >
+       <number>9</number>
+      </property>
+      <property name="spacing" >
+       <number>6</number>
+      </property>
+      <item>
+       <layout class="QHBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <widget class="QLabel" name="label" >
+          <property name="text" >
+           <string>Width:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QSpinBox" name="spinBoxWidth" >
+          <property name="maximum" >
+           <number>2900</number>
+          </property>
+          <property name="minimum" >
+           <number>16</number>
+          </property>
+          <property name="singleStep" >
+           <number>2</number>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeType" >
+           <enum>QSizePolicy::Fixed</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>30</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+        <item>
+         <widget class="QLabel" name="label_2" >
+          <property name="text" >
+           <string>Height:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QSpinBox" name="spinBoxHeight" >
+          <property name="maximum" >
+           <number>2000</number>
+          </property>
+          <property name="minimum" >
+           <number>16</number>
+          </property>
+          <property name="singleStep" >
+           <number>2</number>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <spacer>
+          <property name="orientation" >
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeHint" >
+           <size>
+            <width>40</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+       </layout>
+      </item>
+      <item>
+       <widget class="QCheckBox" name="checkBoxRoundup" >
+        <property name="text" >
+         <string>Round to the Nearest Multiple of 16</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <spacer>
+        <property name="orientation" >
+         <enum>Qt::Vertical</enum>
+        </property>
+        <property name="sizeType" >
+         <enum>QSizePolicy::Fixed</enum>
+        </property>
+        <property name="sizeHint" >
+         <size>
+          <width>312</width>
+          <height>4</height>
+         </size>
+        </property>
+       </spacer>
+      </item>
+      <item>
+       <layout class="QVBoxLayout" >
+        <property name="margin" >
+         <number>0</number>
+        </property>
+        <property name="spacing" >
+         <number>6</number>
+        </property>
+        <item>
+         <layout class="QHBoxLayout" >
+          <property name="margin" >
+           <number>0</number>
+          </property>
+          <property name="spacing" >
+           <number>12</number>
+          </property>
+          <item>
+           <layout class="QVBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <layout class="QHBoxLayout" >
+              <property name="margin" >
+               <number>0</number>
+              </property>
+              <property name="spacing" >
+               <number>6</number>
+              </property>
+              <item>
+               <widget class="QLabel" name="label_8" >
+                <property name="text" >
+                 <string>1%</string>
+                </property>
+               </widget>
+              </item>
+              <item>
+               <spacer>
+                <property name="orientation" >
+                 <enum>Qt::Horizontal</enum>
+                </property>
+                <property name="sizeHint" >
+                 <size>
+                  <width>40</width>
+                  <height>20</height>
+                 </size>
+                </property>
+               </spacer>
+              </item>
+              <item>
+               <widget class="QLabel" name="label_5" >
+                <property name="text" >
+                 <string>Percent</string>
+                </property>
+               </widget>
+              </item>
+              <item>
+               <spacer>
+                <property name="orientation" >
+                 <enum>Qt::Horizontal</enum>
+                </property>
+                <property name="sizeHint" >
+                 <size>
+                  <width>40</width>
+                  <height>20</height>
+                 </size>
+                </property>
+               </spacer>
+              </item>
+              <item>
+               <widget class="QLabel" name="label_9" >
+                <property name="text" >
+                 <string>200%</string>
+                </property>
+               </widget>
+              </item>
+             </layout>
+            </item>
+            <item>
+             <widget class="QSlider" name="horizontalSlider" >
+              <property name="minimum" >
+               <number>1</number>
+              </property>
+              <property name="maximum" >
+               <number>200</number>
+              </property>
+              <property name="value" >
+               <number>100</number>
+              </property>
+              <property name="orientation" >
+               <enum>Qt::Horizontal</enum>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+          <item>
+           <widget class="QSpinBox" name="percentageSpinBox" >
+            <property name="maximum" >
+             <number>200</number>
+            </property>
+            <property name="minimum" >
+             <number>1</number>
+            </property>
+            <property name="value" >
+             <number>100</number>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </item>
+        <item>
+         <layout class="QHBoxLayout" >
+          <property name="margin" >
+           <number>0</number>
+          </property>
+          <property name="spacing" >
+           <number>6</number>
+          </property>
+          <item>
+           <widget class="QLabel" name="label_10" >
+            <property name="text" >
+             <string>Error X / Y:</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QLabel" name="labelErrorXY" >
+            <property name="text" >
+             <string>0.00 / 0.00</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <spacer>
+            <property name="orientation" >
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="sizeHint" >
+             <size>
+              <width>40</width>
+              <height>20</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+         </layout>
+        </item>
+       </layout>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <spacer>
+     <property name="orientation" >
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeType" >
+      <enum>QSizePolicy::Fixed</enum>
+     </property>
+     <property name="sizeHint" >
+      <size>
+       <width>332</width>
+       <height>6</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" >
+     <property name="margin" >
+      <number>0</number>
+     </property>
+     <property name="spacing" >
+      <number>6</number>
+     </property>
+     <item>
+      <widget class="QLabel" name="label_6" >
+       <property name="text" >
+        <string>Resize Method:</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QComboBox" name="comboBoxAlgo" >
+       <item>
+        <property name="text" >
+         <string>Bilinear</string>
+        </property>
+       </item>
+       <item>
+        <property name="text" >
+         <string>Bicubic</string>
+        </property>
+       </item>
+       <item>
+        <property name="text" >
+         <string>Lanzcos3</string>
+        </property>
+       </item>
+      </widget>
+     </item>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <spacer>
+     <property name="orientation" >
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeType" >
+      <enum>QSizePolicy::MinimumExpanding</enum>
+     </property>
+     <property name="sizeHint" >
+      <size>
+       <width>20</width>
+       <height>16</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+   <item>
+    <widget class="QDialogButtonBox" name="buttonBox" >
+     <property name="orientation" >
+      <enum>Qt::Horizontal</enum>
+     </property>
+     <property name="standardButtons" >
+      <set>QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok</set>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <tabstops>
+  <tabstop>lockArCheckBox</tabstop>
+  <tabstop>comboBoxSource</tabstop>
+  <tabstop>comboBoxDestination</tabstop>
+  <tabstop>spinBoxWidth</tabstop>
+  <tabstop>spinBoxHeight</tabstop>
+  <tabstop>checkBoxRoundup</tabstop>
+  <tabstop>horizontalSlider</tabstop>
+  <tabstop>percentageSpinBox</tabstop>
+  <tabstop>comboBoxAlgo</tabstop>
+  <tabstop>buttonBox</tabstop>
+ </tabstops>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>resizeDialog</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>316</x>
+     <y>260</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>286</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_8</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>39</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_5</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>150</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_9</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>267</x>
+     <y>148</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>horizontalSlider</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>156</x>
+     <y>164</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>percentageSpinBox</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>317</x>
+     <y>155</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>checkBoxRoundup</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>184</x>
+     <y>95</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>184</x>
+     <y>117</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_10</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>155</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>55</x>
+     <y>251</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>labelErrorXY</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>155</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>114</x>
+     <y>251</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_4</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>46</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>comboBoxSource</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>94</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_3</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>188</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>lockArCheckBox</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>comboBoxDestination</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>182</x>
+     <y>69</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>247</x>
+     <y>95</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>



From mean at mail.berlios.de  Sun Jul 31 19:19:08 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 31 Jul 2011 19:19:08 +0200
Subject: [Avidemux-svn-commit] r7376 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
Message-ID: <20110731171908.B1DA54812CC@sheep.berlios.de>

Author: mean
Date: 2011-07-31 19:19:08 +0200 (Sun, 31 Jul 2011)
New Revision: 7376

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
Log:
[gl] Add a message if glActiveTexture has been found

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-31 17:15:22 UTC (rev 7375)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-07-31 17:19:08 UTC (rev 7376)
@@ -858,6 +858,7 @@
 		ADM_error("[GL Render] Active Texture function not found!\n");
 	}else
     {
+        ADM_error("[GL Render] Active Texture function found (Not openGL_ES)\n");
         ADM_setActiveTexture(tex);
     }
 #else



