<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r7310 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. telecide
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2011-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r7310%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6%3A%0A%09.%20telecide&In-Reply-To=%3C20110710143122.F3A6A4813BB%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004463.html">
   <LINK REL="Next"  HREF="004465.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r7310 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. telecide</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r7310%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6%3A%0A%09.%20telecide&In-Reply-To=%3C20110710143122.F3A6A4813BB%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r7310 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. telecide">mean at mail.berlios.de
       </A><BR>
    <I>Sun Jul 10 16:31:22 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="004463.html">[Avidemux-svn-commit] r7309 -	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
</A></li>
        <LI>Next message: <A HREF="004465.html">[Avidemux-svn-commit] r7311 - in branches/avidemux_2.6_branch_mean:	avidemux_core/ADM_coreImage/include	avidemux_plugins/ADM_videoFilters6	avidemux_plugins/ADM_videoFilters6/telecide
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4464">[ date ]</a>
              <a href="thread.html#4464">[ thread ]</a>
              <a href="subject.html#4464">[ subject ]</a>
              <a href="author.html#4464">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2011-07-10 16:31:22 +0200 (Sun, 10 Jul 2011)
New Revision: 7310

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
Log:
[Telecide] port from 2.5

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/CMakeLists.txt	2011-07-10 14:31:22 UTC (rev 7310)
@@ -0,0 +1,12 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_telecide_SRCS Telecide.cpp   
+                         Telecide_utils.cpp
+                         Telecide_getFrame.cpp
+                        )
+
+ADD_VIDEO_FILTER(ADM_vf_telecide ${ADM_vf_telecide_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_telecide)
+INSTALL_VIDEO_FILTER(ADM_vf_telecide)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.cpp	2011-07-10 14:31:22 UTC (rev 7310)
@@ -0,0 +1,184 @@
+
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    Port of Donal Graft Telecide which is (c) Donald Graft
+    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
+    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
+
+ ***************************************************************************/
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include &quot;ADM_default.h&quot;
+#include &quot;Telecide.h&quot;
+#include &quot;DIA_factory.h&quot;
+#include &quot;telec_desc.cpp&quot;
+#if 1
+    #define aprintf printf
+#else
+    #define aprintf(...) {}
+#endif
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   Telecide,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_INTERLACING,            // Category
+                        &quot;telecide&quot;,            // internal name (must be uniq!)
+                        &quot;Decomb telecide&quot;,            // Display name
+                        &quot;Donald Graft Telecide. Replace ivtc pattern by progressive frames. Video stays at 30 fps.&quot; // Description
+                    );
+
+/**
+    \fn configure
+*/
+
+/**
+    \fn Ctor
+*/       
+Telecide::Telecide(	ADM_coreVideoFilter *in,CONFcouple *couples)      : ADM_coreVideoFilter(in,couples)
+{
+
+		int i;		
+		int count;
+		char *d, *dsaved;
+		unsigned int *p, *x;
+		_lastFrame=0xfffffff0;
+        teleCide *_param=&configuration;
+		
+		vidCache=new VideoCache(12,in);
+#if 0
+		pitch = _info.width;
+		dpitch = _info.width;
+		pitchover2 = pitch &gt;&gt; 1;
+		pitchtimes4 = pitch &lt;&lt; 2;
+
+		w = _info.width;
+		h = _info.height;
+		wover2 = w/2;
+		hover2 = h/2;
+		hplus1over2 = (h+1)/2;
+		hminus2= h - 2;
+#endif
+		if(!couples || !ADM_paramLoad(couples,teleCide_param,&amp;configuration))
+        {
+                 
+			 	_param-&gt;order = 1; 		// 0 Field ok, 1 field reverted 0 BFF/1 TFF
+				_param-&gt;back = NO_BACK; // 0 Never, 1 when bad, 2 always tried MUST Have post !=0
+				_param-&gt;chroma = false;
+				_param-&gt;guide = GUIDE_32;// 0 / NONE - 1 GUIDE_32/ivtc-2 GUIDE 22/PAL-3 PAL/NTSC
+				_param-&gt;gthresh = 10.0;
+				_param-&gt;post = POST_NONE;
+				_param-&gt;vthresh = 50.0;
+				_param-&gt;bthresh = 50.0;
+				_param-&gt;dthresh = 7.0;
+				_param-&gt;blend = false;
+				_param-&gt;nt = 10;	// Noise tolerance
+				_param-&gt;y0 = 0;		// Zone to try (avoid subs)
+				_param-&gt;y1 = 0;
+				_param-&gt;hints = true;
+				_param-&gt;show = false;
+				_param-&gt;debug = false; 
+
+		}
+				 
+				
+		tff = (_param-&gt;order == 0 ? false : true);	
+
+		_param-&gt;back_saved = _param-&gt;back;
+
+		// Set up pattern guidance.
+		cache = (struct CACHE_ENTRY *) ADM_alloc(CACHE_SIZE * sizeof(struct CACHE_ENTRY));
+		for (i = 0; i &lt; CACHE_SIZE; i++)
+		{
+			cache[i].frame = 0xffffffff;
+			cache[i].chosen = 0xff;
+		}
+
+		if (_param-&gt;guide == GUIDE_32)
+		{
+			// 24fps to 30 fps telecine.
+			cycle = 5;
+		}
+		if (_param-&gt;guide == GUIDE_22)
+		{
+			// PAL guidance (expect the current match to be continued).
+			cycle = 2;
+		}
+		else if (_param-&gt;guide == GUIDE_32322)
+		{
+			// 25fps to 30 fps telecine.
+			cycle = 6;
+		}
+
+		// Get needed dynamic storage.
+		vmetric = 0;
+		_param-&gt;vthresh_saved = _param-&gt;vthresh;
+		xblocks = (info.width+BLKSIZE-1) / BLKSIZE;
+		yblocks = (info.height+BLKSIZE-1) / BLKSIZE;
+#ifdef WINDOWED_MATCH
+		matchp = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+		matchc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+#endif
+		sump = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+		sumc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+}
+/**
+    \fn dtor
+*/
+Telecide::~Telecide()
+{
+		unsigned int *p;
+
+		if (cache != NULL) ADM_dealloc(cache);
+#ifdef WINDOWED_MATCH
+		if (matchp != NULL) ADM_dealloc(matchp);
+		if (matchc != NULL) ADM_dealloc(matchc);
+        matchp=NULL;
+        matchc=NULL;
+
+#endif
+		if (sump != NULL) ADM_dealloc(sump);
+		if (sumc != NULL) ADM_dealloc(sumc);
+        cache=NULL;
+        sump=NULL;
+        sumc=NULL;
+		delete vidCache;
+		vidCache=NULL;
+}
+/**
+    \fn getCoupledConf
+*/ 
+bool         Telecide::getCoupledConf(CONFcouple **couples)
+{
+    return ADM_paramSave(couples, teleCide_param,&amp;configuration);
+}
+bool                Telecide::goToTime(uint64_t usSeek)
+{
+    return ADM_coreVideoFilter::goToTime(usSeek);
+}
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide.h	2011-07-10 14:31:22 UTC (rev 7310)
@@ -0,0 +1,162 @@
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from  telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_coreVideoFilterInternal.h&quot;
+#include &quot;ADM_videoFilterCache.h&quot;
+#include &quot;DIA_factory.h&quot;
+#include &quot;telec.h&quot;
+
+#define DrawString drawString
+#define BitBlt BitBlit
+
+#undef DEBUG_PATTERN_GUIDANCE
+
+#undef WINDOWED_MATCH
+
+#define MAX_CYCLE 6
+#define BLKSIZE 24
+#define BLKSIZE_TIMES2 (2 * BLKSIZE)
+#define GUIDE_NONE 0
+#define GUIDE_32 1
+#define GUIDE_22 2
+#define GUIDE_32322 3
+#define AHEAD 0
+#define BEHIND 1
+#define POST_NONE 0
+#define POST_METRICS 1
+#define POST_FULL 2
+#define POST_FULL_MAP 3
+#define POST_FULL_NOMATCH 4
+#define POST_FULL_NOMATCH_MAP 5
+#define CACHE_SIZE 100000
+#define P 0
+#define C 1
+#define N 2
+#define PBLOCK 3
+#define CBLOCK 4
+
+#define NO_BACK 0
+#define BACK_ON_COMBED 1
+#define ALWAYS_BACK 2
+
+#define OutputDebugString(x) aprintf(&quot;%s\n&quot;,x)
+typedef uint8_t* PVideoFrame ;
+
+
+struct CACHE_ENTRY
+{
+	unsigned int frame;
+	unsigned int metrics[5];
+	unsigned int chosen;
+};
+
+struct PREDICTION
+{
+	unsigned int metric;
+	unsigned int phase;
+	unsigned int predicted;
+	unsigned int predicted_metric;
+};
+
+#define GETFRAME(g, fp) { int GETFRAMEf; uint32_t len,flags;GETFRAMEf = (g); fp=NULL;\
+    if (GETFRAMEf &lt; 0) GETFRAMEf = 0; 	 fp=vidCache-&gt;getImage(GETFRAMEf); }
+
+
+
+/**
+    \class Telecide
+
+*/
+class  Telecide:public ADM_coreVideoFilter
+{
+protected:
+        teleCide           configuration;
+protected:
+        bool tff;	
+        uint32_t _lastFrame;	
+#if 1
+        int pitch, dpitch, pitchover2, pitchtimes4;
+        int w, h, wover2, hover2, hplus1over2, hminus2;
+#endif
+        int xblocks, yblocks;
+    #ifdef WINDOWED_MATCH
+        unsigned int *matchc, *matchp, highest_matchc, highest_matchp;
+    #endif
+        unsigned int *sumc, *sump, highest_sumc, highest_sump;
+        int vmetric;
+        
+        bool film, override, inpattern, found;
+        int force;
+
+        
+        int chosen;
+        unsigned int p, c, pblock, cblock, lowest, predicted, predicted_metric;
+        unsigned int np, nc, npblock, ncblock;
+        float mismatch;
+        int  x, y;
+        
+        bool hard;
+        char status[80];
+
+        // Metrics cache.
+        struct CACHE_ENTRY *cache;
+
+        // Pattern guidance data.
+        int cycle;
+        struct PREDICTION pred[MAX_CYCLE+1];
+
+        // For output message formatting.
+        char buf[255];
+        
+        VideoCache	*vidCache;
+public:
+                            Telecide(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                            ~Telecide();
+        bool                goToTime(uint64_t usSeek);
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+
+protected:
+	
+	void CalculateMetrics(int n, unsigned char *crp, unsigned char *crpU, unsigned char *crpV, 
+				unsigned char *prp, unsigned char *prpU, unsigned char *prpV);
+	void Show(ADMImage *dst, int frame);
+	void Debug(int frame);
+
+
+	void PutChosen(int frame, unsigned int chosen);
+	
+
+	void CacheInsert(int frame, unsigned int p, unsigned int pblock,
+				unsigned int c, unsigned int cblock);
+	
+	bool CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
+				unsigned int *c, unsigned int *cblock);	
+
+	bool PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric) ;
+	
+	struct PREDICTION *PredictSoftYUY2(int frame);
+
+	void WriteHints(unsigned char *dst, bool film, bool inpattern);
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_getFrame.cpp	2011-07-10 14:31:22 UTC (rev 7310)
@@ -0,0 +1,764 @@
+
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    Port of Donal Graft Telecide which is (c) Donald Graft
+    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
+    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
+
+ ***************************************************************************/
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include &quot;ADM_default.h&quot;
+#include &quot;Telecide.h&quot;
+#if 1
+    #define aprintf printf
+#else
+    #define aprintf(...) {}
+#endif
+
+/**
+    \fn getNextFrame
+*/
+bool Telecide::getNextFrame(uint32_t *frameNumber,ADMImage *output_image)
+{
+ADMImage *fc;
+uint8_t *fcrp;
+uint8_t *fcrpU,*fcrpV;
+
+uint32_t pframe,nframe;
+
+ADMImage *fp;
+uint8_t *fprp;
+uint8_t *fprpU,*fprpV;
+
+ADMImage *fn;
+uint8_t *fnrp;
+uint8_t *fnrpU,*fnrpV;
+
+ADMImage *lc;
+uint8_t *crp;
+uint8_t *crpU,*crpV;
+
+ADMImage *lp;
+uint8_t *prp;
+uint8_t *prpU,*prpV;
+
+ADMImage *dst;
+uint8_t *dstp;
+uint8_t *dstpU,*dstpV;
+
+ADMImage *final;
+uint8_t *finalp;
+uint8_t *finalpU,*finalpV;
+
+teleCide *_param=&configuration;
+#define guide _param-&gt;guide
+#define order _param-&gt;order
+#define back  _param-&gt;back
+
+#define back_saved  _param-&gt;back_saved
+#define guide       _param-&gt;guide
+#define gthresh     _param-&gt;gthresh
+#define post        _param-&gt;post
+#define chroma      _param-&gt;chroma
+#define vthresh     _param-&gt;vthresh
+
+#define vthresh_saved _param-&gt;vthresh_saved
+#define hints      _param-&gt;hints
+#define show       _param-&gt;show
+#define debug      _param-&gt;debug
+
+#define bthresh      _param-&gt;bthresh
+#define dthresh      _param-&gt;dthresh
+#define blend        _param-&gt;blend
+
+#define nt      _param-&gt;nt
+#define y0      _param-&gt;y0
+#define y1      _param-&gt;y1
+
+        
+        bool lastFrame=false;
+        aprintf(&quot;telecide : frame %d\n&quot;,(int)nextFrame);
+        // Get the current frame.
+        uint32_t frame=nextFrame;
+        if (frame &lt; 0) frame = 0;
+        GETFRAME(frame, fc);
+        if(!fc)
+        {
+            ADM_info(&quot;Telecide:Cannot get frame\n&quot;);
+            return false;
+        }
+        nextFrame++;
+        output_image-&gt;copyInfo(fc);
+        fcrp = (unsigned char *) fc-&gt;GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fcrpU = (unsigned char *) fc-&gt;GetReadPtr(PLANAR_U);
+                fcrpV = (unsigned char *) fc-&gt;GetReadPtr(PLANAR_V);
+        }
+
+        // Get the previous frame.
+        pframe = frame == 0 ? 0 : frame - 1;
+        GETFRAME(pframe, fp);
+        fprp = (unsigned char *) fp-&gt;GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fprpU = (unsigned char *) fp-&gt;GetReadPtr(PLANAR_U);
+                fprpV = (unsigned char *) fp-&gt;GetReadPtr(PLANAR_V);
+        }
+
+        // Get the next frame metrics if we might need them.
+        nframe = frame + 1;
+        GETFRAME(nframe, fn);
+        if(!fn)
+        {
+            nframe=frame;
+            GETFRAME(nframe, fn);
+            ADM_assert(fn);
+            lastFrame=true;
+        }
+        fnrp = (unsigned char *) fn-&gt;GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fnrpU = (unsigned char *) fn-&gt;GetReadPtr(PLANAR_U);
+                fnrpV = (unsigned char *) fn-&gt;GetReadPtr(PLANAR_V);
+        }
+
+        pitch = fc-&gt;GetPitch(PLANAR_Y);
+        pitchover2 = pitch &gt;&gt; 1;
+        pitchtimes4 = pitch &lt;&lt; 2;
+        w = fc-&gt;GetRowSize(PLANAR_Y);
+        h = fc-&gt;GetHeight(PLANAR_Y);
+/*
+        if (vi.IsYUY2() &amp;&amp; ((w/2) &amp; 1))
+                env-&gt;ThrowError(&quot;Telecide: width must be a multiple of 2; use Crop&quot;);
+        if (vi.IsYV12() &amp;&amp; (w &amp; 1))
+                env-&gt;ThrowError(&quot;Telecide: width must be a multiple of 2; use Crop&quot;);
+        if (h &amp; 1)
+                env-&gt;ThrowError(&quot;Telecide: height must be a multiple of 2; use Crop&quot;);
+*/
+        wover2 = w/2;
+        hover2 = h/2;
+        hplus1over2 = (h+1)/2;
+        hminus2= h - 2;
+        //dst = env-&gt;NewVideoFrame(vi);
+        dst=output_image;
+        dpitch = dst-&gt;GetPitch(PLANAR_Y);
+
+        // Ensure that the metrics for the frames
+        // after the current frame are in the cache. They will be used for
+        // pattern guidance.
+        if (guide != GUIDE_NONE)
+        {
+                for (y = frame + 1; y &lt;= frame + cycle + 1; y++)
+                {
+                        if (lastFrame==true ) break;
+                        if (CacheQuery(y, &amp;p, &amp;pblock, &amp;c, &amp;cblock) == false)
+                        {
+                                GETFRAME(y, lc);
+                                crp = (unsigned char *) lc-&gt;GetReadPtr(PLANAR_Y);
+                                //if (vi.IsYV12())
+                                {
+                                        crpU = (unsigned char *) lc-&gt;GetReadPtr(PLANAR_U);
+                                        crpV = (unsigned char *) lc-&gt;GetReadPtr(PLANAR_V);
+                                }
+                                GETFRAME(y == 0 ? 1 : y - 1, lp);
+                                prp = (unsigned char *) lp-&gt;GetReadPtr(PLANAR_Y);
+                                //if (vi.IsYV12())
+                                {
+                                        prpU = (unsigned char *) lp-&gt;GetReadPtr(PLANAR_U);
+                                        prpV = (unsigned char *) lp-&gt;GetReadPtr(PLANAR_V);
+                                }
+                                CalculateMetrics(y, crp, crpU, crpV, prp, prpU, prpV);
+                        }
+                }
+        }
+
+        /* Check for manual overrides of the field matching. */
+        
+        found = false;
+        film = true;
+        
+        inpattern = false;
+        vthresh = vthresh_saved;
+        back = back_saved;
+#if 0
+        overrides_p = overrides;
+        override = false;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p &lt; 0xffffffff)
+                {
+                        // If the frame is in range...
+                        if (((unsigned int) frame &gt;= *overrides_p) &amp;&amp; ((unsigned int) frame &lt;= *(overrides_p+1)))
+                        {
+                                // and it's a single specifier. 
+                                if (*(overrides_p+3) == 'p' || *(overrides_p+3) == 'c' || *(overrides_p+3) == 'n')
+                                {
+                                        // Get the match specifier and stop parsing.
+                                        switch(*(overrides_p+3))
+                                        {
+                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; found = true; break;
+                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; found = true; break;
+                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; found = true; break;
+                                        }
+                                }
+                                else if (*(overrides_p+3) == 'b')
+                                {
+                                        back = *(overrides_p+2);
+                                }
+                                else if (*(overrides_p+3) == 'm')
+                                {
+                                        // It's a multiple match specifier.
+                                        found = true;
+                                        // Get the pointer to the specifier string.
+                                        unsigned int *x = (unsigned int *) *(overrides_p+2);
+                                        // Get the index into the specification string.
+                                        // Remember, the count is first followed by the specifiers.
+                                        int ndx = ((frame - *overrides_p) % *x);
+                                        // Point to the specifier string.
+                                        x++;
+                                        // Load the specifier for this frame and stop parsing.
+                                        switch(x[ndx])
+                                        {
+                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; break;
+                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; break;
+                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; break;
+                                        }
+                                }
+                        }
+                        // Next override line.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Get the metrics for the current-previous (p), current-current (c), and current-next (n) match candidates.
+        if (CacheQuery(frame, &amp;p, &amp;pblock, &amp;c, &amp;cblock) == false)
+        {
+                CalculateMetrics(frame, fcrp, fcrpU, fcrpV, fprp, fprpU, fprpV);
+                CacheQuery(frame, &amp;p, &amp;pblock, &amp;c, &amp;cblock);
+        }
+        if (CacheQuery(nframe, &amp;np, &amp;npblock, &amp;nc, &amp;ncblock) == false)
+        {
+                CalculateMetrics(nframe, fnrp, fnrpU, fnrpV, fcrp, fcrpU, fcrpV);
+                CacheQuery(nframe, &amp;np, &amp;npblock, &amp;nc, &amp;ncblock);
+        }
+
+        // Determine the best candidate match.
+        if (found != true)
+        {
+                lowest = c;
+                chosen = C;
+                if (back == ALWAYS_BACK &amp;&amp; p &lt; lowest)
+                {
+                        lowest = p;
+                        chosen = P;
+                }
+                if (np &lt; lowest)
+                {
+                        lowest = np;
+                        chosen = N;
+                }
+        }
+        if ((frame == 0 &amp;&amp; chosen == P) || (lastFrame==true &amp;&amp; chosen == N))
+        {
+                chosen = C;
+                lowest = c;
+        }
+
+        // See if we can apply pattern guidance.
+        mismatch = 100.0;
+        if (guide != GUIDE_NONE)
+        {
+                hard = false;
+                if (frame &gt;= cycle &amp;&amp; PredictHardYUY2(frame, &amp;predicted, &amp;predicted_metric) == true)
+                {
+                        inpattern = true;
+                        mismatch = 0.0;
+                        hard = true;
+                        if (chosen != predicted)
+                        {
+                                // The chosen frame doesn't match the prediction.
+                                if (predicted_metric == 0) mismatch = 0.0;
+                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
+                                if (mismatch &lt; gthresh)
+                                {
+                                        // It's close enough, so use the predicted one.
+                                        if (found != true)
+                                        {
+                                                chosen = predicted;
+                                                override = true;
+                                        }
+                                }
+                                else
+                                {
+                                        hard = false;
+                                        inpattern = false;
+                                }
+                        }
+                }
+
+                if (hard == false &amp;&amp; guide != GUIDE_22)
+                {
+                        int i;
+                        struct PREDICTION *pred = PredictSoftYUY2(frame);
+
+                        if (/*(frame &lt;= _info.nb_frames - 1 - cycle) &amp;&amp;  */   (pred[0].metric != 0xffffffff))
+                        {
+                                // Apply pattern guidance.
+                                // If the predicted match metric is within defined percentage of the
+                                // best calculated one, then override the calculated match with the
+                                // predicted match.
+                                i = 0;
+                                while (pred[i].metric != 0xffffffff)
+                                {
+                                        predicted = pred[i].predicted;
+                                        predicted_metric = pred[i].predicted_metric;
+#ifdef DEBUG_PATTERN_GUIDANCE
+                                        sprintf(buf, &quot;%d: predicted = %d\n&quot;, frame, predicted);
+                                        OutputDebugString(buf);
+#endif
+                                        if (chosen != predicted)
+                                        {
+                                                // The chosen frame doesn't match the prediction.
+                                                if (predicted_metric == 0) mismatch = 0.0;
+                                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
+                                                if ((int) mismatch &lt;= gthresh)
+                                                {
+                                                        // It's close enough, so use the predicted one.
+                                                        if (found != true)
+                                                        {
+                                                                chosen = predicted;
+                                                                override = true;
+                                                        }
+                                                        inpattern = true;
+                                                        break;
+                                                }
+                                                else
+                                                {
+                                                        // Looks like we're not in a predictable pattern.
+                                                        inpattern = false;
+                                                }
+                                        }
+                                        else
+                                        {
+                                                inpattern = true;
+                                                mismatch = 0.0;
+                                                break;
+                                        }
+                                        i++;
+                                }
+                        }
+                }
+        }
+
+        // Check for overrides of vthresh.
+#if 0
+        overrides_p = overrides;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p &lt; 0xffffffff)
+                {
+                        // If the frame is in range...
+                        if (((unsigned int) frame &gt;= *overrides_p) &amp;&amp; ((unsigned int) frame &lt;= *(overrides_p+1)))
+                        {
+                                if (*(overrides_p+3) == 'v')
+                                {
+                                        vthresh = *(overrides_p+2);
+                                }
+                        }
+                        // Next override line.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Check the match for progressive versus interlaced.
+        if (post != POST_NONE)
+        {
+                if (chosen == P) vmetric = pblock;
+                else if (chosen == C) vmetric = cblock;
+                else if (chosen == N) vmetric = npblock;
+
+                if (found == false &amp;&amp; back == BACK_ON_COMBED &amp;&amp; vmetric &gt; bthresh &amp;&amp; p &lt; lowest)
+                {
+                        // Backward match.
+                        vmetric = pblock;
+                        chosen = P;
+                        inpattern = false;
+                        mismatch = 100;
+                }
+                if (vmetric &gt; vthresh)
+                {
+                        // After field matching and pattern guidance the frame is still combed.
+                        film = false;
+                        if (found == false &amp;&amp; (post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP))
+                        {
+                                chosen = C;
+                                vmetric = cblock;
+                                inpattern = false;
+                                mismatch = 100;
+                        }
+                }
+        }
+        vthresh = vthresh_saved;
+
+        // Setup strings for debug info.
+        if (inpattern == true &amp;&amp; override == false) strcpy(status, &quot;[in-pattern]&quot;);
+        else if (inpattern == true &amp;&amp; override == true) strcpy(status, &quot;[in-pattern*]&quot;);
+        else strcpy(status, &quot;[out-of-pattern]&quot;);
+
+        // Assemble and output the reconstructed frame according to the final match.
+        dstp = dst-&gt;GetWritePtr(PLANAR_Y);
+//    if (vi.IsYV12())
+        {
+                dstpU = dst-&gt;GetWritePtr(PLANAR_U);
+                dstpV = dst-&gt;GetWritePtr(PLANAR_V);
+        }
+        if (chosen == N)
+        {
+                // The best match was with the next frame.
+                if (tff == true)
+                {
+                        BitBlt(dstp, 2 * dpitch, fnrp, 2 * pitch, w, hover2);
+                        BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+                        //if (vi.IsYV12())
+                        {
+                                BitBlt(dstpU, dpitch, fnrpU, pitch, w/2, h/4);
+                                BitBlt(dstpV, dpitch, fnrpV, pitch, w/2, h/4);
+                                BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                                BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                        }
+                }
+                else
+                {
+                        BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                        BitBlt(dstp + dpitch, 2 * dpitch, fnrp + pitch, 2 * pitch, w, hover2);
+                        //if (vi.IsYV12())
+                        {
+                                BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                                BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                                BitBlt(dstpU + dpitch/2, dpitch, fnrpU + pitch/2, pitch, w/2, h/4);
+                                BitBlt(dstpV + dpitch/2, dpitch, fnrpV + pitch/2, pitch, w/2, h/4);
+                        }
+                }
+        }
+        else if (chosen == C)
+        {
+                // The best match was with the current frame.
+                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+                //if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        else if (tff == false)
+        {
+                // The best match was with the previous frame.
+                BitBlt(dstp, 2 * dpitch, fprp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+               // if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fprpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fprpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        else
+        {
+                // The best match was with the previous frame.
+                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fprp + pitch, 2 * pitch, w, hover2);
+               // if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fprpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fprpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        if (guide != GUIDE_NONE) PutChosen(frame, chosen);
+
+        /* Check for manual overrides of the deinterlacing. */
+#if 0
+        overrides_p = overrides;
+        force = 0;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p &lt; 0xffffffff)
+                {
+                        // Is the frame in range...
+                        if (((unsigned int) frame &gt;= *overrides_p) &amp;&amp; ((unsigned int) frame &lt;= *(overrides_p+1)) &amp;&amp;
+                                // and is it a single specifier...
+                                (*(overrides_p+2) == 0) &amp;&amp;
+                                // and is it a deinterlacing specifier?
+                                (*(overrides_p+3) == '+' || *(overrides_p+3) == '-'))
+                        {
+                                // Yes, load the specifier and stop parsing.
+                                overrides_p += 3;
+                                force = *overrides_p;
+                                break;
+                        }
+                        // Next specification record.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Do postprocessing if enabled and required for this frame.
+        if (post == POST_NONE || post == POST_METRICS)
+        {
+                if (force == '+') film = false;
+                else if (force == '-') film = true;
+        }
+        else if ((force == '+') ||
+                ((post == POST_FULL || post == POST_FULL_MAP || post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP)
+                         &amp;&amp; (film == false &amp;&amp; force != '-')))
+        {
+                unsigned char *dstpp, *dstpn;
+                int v1, v2, z;
+
+                if (blend == true)
+                {
+                        // Blend mode.
+                        final = output_image; //env-&gt;NewVideoFrame(vi);
+                        // Do first and last lines.
+                        finalp = final-&gt;GetWritePtr(PLANAR_Y);
+                        dstp = dst-&gt;GetWritePtr(PLANAR_Y);
+                        dstpn = dstp + dpitch;
+                        for (x = 0; x &lt; w; x++)
+                        {
+                                finalp[x] = (((int)dstp[x] + (int)dstpn[x]) &gt;&gt; 1);
+                        }
+                        finalp = final-&gt;GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
+                        dstp = dst-&gt;GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
+                        dstpp = dstp - dpitch;
+                        for (x = 0; x &lt; w; x++)
+                        {
+                                finalp[x] = (((int)dstp[x] + (int)dstpp[x]) &gt;&gt; 1);
+                        }
+                        // Now do the rest.
+                        dstp = dst-&gt;GetWritePtr(PLANAR_Y) + dpitch;
+                        dstpp = dstp - dpitch;
+                        dstpn = dstp + dpitch;
+                        finalp = final-&gt;GetWritePtr(PLANAR_Y) + dpitch;
+                        for (y = 1; y &lt; h - 1; y++)
+                        {
+                                for (x = 0; x &lt; w; x++)
+                                {
+                                        v1 = (int)(dstp[x] - dthresh);
+                                        if (v1 &lt; 0) v1 = 0; 
+                                        v2 = (int) (dstp[x] + dthresh);
+                                        if (v2 &gt; 235) v2 = 235; 
+                                        if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
+                                        {
+                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                {
+                                                        if (0) //(vi.IsYUY2())
+                                                        {
+                                                                if (x &amp; 1) finalp[x] = 128;
+                                                                else finalp[x] = 235;
+                                                        }
+                                                        else
+                                                        {
+                                                                finalp[x] = 235;
+                                                        }
+                                                }
+                                                else
+                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) &gt;&gt; 2;
+                                        }
+                                        else finalp[x] = dstp[x];
+                                }
+                                finalp += dpitch;
+                                dstp += dpitch;
+                                dstpp += dpitch;
+                                dstpn += dpitch;
+                        }
+
+                      //  if (vi.IsYV12())
+                        {
+                                // Chroma planes.
+                                for (z = 0; z &lt; 2; z++)
+                                {
+                                        if (z == 0)
+                                        {
+                                                // Do first and last lines.
+                                                finalp = final-&gt;GetWritePtr(PLANAR_U);
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_U);
+                                                dstpn = dstp + dpitch/2;
+                                                for (x = 0; x &lt; wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) &gt;&gt; 1);
+                                                }
+                                                finalp = final-&gt;GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
+                                                dstpp = dstp - dpitch/2;
+                                                for (x = 0; x &lt; wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) &gt;&gt; 1);
+                                                }
+                                                // Now do the rest.
+                                                finalp = final-&gt;GetWritePtr(PLANAR_U) + dpitch/2;
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_U) + dpitch/2;
+                                        }
+                                        else
+                                        {
+                                                // Do first and last lines.
+                                                finalp = final-&gt;GetWritePtr(PLANAR_V);
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_V);
+                                                dstpn = dstp + dpitch/2;
+                                                for (x = 0; x &lt; wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) &gt;&gt; 1);
+                                                }
+                                                finalp = final-&gt;GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
+                                                dstpp = dstp - dpitch/2;
+                                                for (x = 0; x &lt; wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) &gt;&gt; 1);
+                                                }
+                                                // Now do the rest.
+                                                finalp = final-&gt;GetWritePtr(PLANAR_V) + dpitch/2;
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_V) + dpitch/2;
+                                        }
+                                        dstpp = dstp - dpitch/2;
+                                        dstpn = dstp + dpitch/2;
+                                        for (y = 1; y &lt; hover2 - 1; y++)
+                                        {
+                                                for (x = 0; x &lt; wover2; x++)
+                                                {
+                                                        v1 = (int)( dstp[x] - dthresh);
+                                                        if (v1 &lt; 0) v1 = 0; 
+                                                        v2 = (int)( dstp[x] + dthresh);
+                                                        if (v2 &gt; 235) v2 = 235; 
+                                                        if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
+                                                        {
+                                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                                {
+                                                                        finalp[x] = 128;
+                                                                }
+                                                                else
+                                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) &gt;&gt; 2;
+                                                        }
+                                                        else finalp[x] = dstp[x];
+                                                }
+                                                finalp += dpitch/2;
+                                                dstp += dpitch/2;
+                                                dstpp += dpitch/2;
+                                                dstpn += dpitch/2;
+                                        }
+                                }
+                        }
+                        if (show == true) Show(final, frame);
+                        if (debug == true) Debug(frame);
+                        if (hints == true) WriteHints(final-&gt;GetWritePtr(PLANAR_Y), film, inpattern);
+                       // return final;
+                        vidCache-&gt;unlockAll();
+                        return 1;
+                }
+
+                // Interpolate mode.
+                // Luma plane.
+                dstp = dst-&gt;GetWritePtr(PLANAR_Y) + dpitch;
+                dstpp = dstp - dpitch;
+                dstpn = dstp + dpitch;
+                for (y = 1; y &lt; h - 1; y+=2)
+                {
+                        for (x = 0; x &lt; w; x++)
+                        {
+                                v1 = (int) (dstp[x] - dthresh);
+                                if (v1 &lt; 0) v1 = 0; 
+                                v2 = (int) dstp[x] + dthresh;
+                                if (v2 &gt; 235) v2 = 235; 
+                                if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
+                                {
+                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                        {
+                                                if(0) // (vi.IsYUY2())
+                                                {
+                                                        if (x &amp; 1) dstp[x] = 128;
+                                                        else dstp[x] = 235;
+                                                }
+                                                else
+                                                {
+                                                        dstp[x] = 235;
+                                                }
+                                        }
+                                        else
+                                                dstp[x] = (dstpp[x] + dstpn[x]) &gt;&gt; 1;
+                                }
+                        }
+                        dstp += 2*dpitch;
+                        dstpp += 2*dpitch;
+                        dstpn += 2*dpitch;
+                }
+
+               // if (vi.IsYV12())
+                {
+                        // Chroma planes.
+                        for (z = 0; z &lt; 2; z++)
+                        {
+                                if (z == 0) dstp = dst-&gt;GetWritePtr(PLANAR_U) + dpitch/2;
+                                else dstp = dst-&gt;GetWritePtr(PLANAR_V) + dpitch/2;
+                                dstpp = dstp - dpitch/2;
+                                dstpn = dstp + dpitch/2;
+                                for (y = 1; y &lt; hover2 - 1; y+=2)
+                                {
+                                        for (x = 0; x &lt; wover2; x++)
+                                        {
+                                                v1 = (int) dstp[x] - dthresh;
+                                                if (v1 &lt; 0) v1 = 0; 
+                                                v2 = (int) dstp[x] + dthresh;
+                                                if (v2 &gt; 235) v2 = 235; 
+                                                if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
+                                                {
+                                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                        {
+                                                                dstp[x] = 128;
+                                                        }
+                                                        else
+                                                                dstp[x] = (dstpp[x] + dstpn[x]) &gt;&gt; 1;
+                                                }
+                                        }
+                                        dstp += dpitch;
+                                        dstpp += dpitch;
+                                        dstpn += dpitch;
+                                }
+                        }
+                }
+        }
+
+        if (show == true) Show(dst, frame);
+        if (debug == true) Debug(frame);
+        if (hints == true) WriteHints(dst-&gt;GetWritePtr(PLANAR_Y), film, inpattern);
+        vidCache-&gt;unlockAll();
+        //return dst;
+        return 1;
+}
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide/Telecide_utils.cpp	2011-07-10 14:31:22 UTC (rev 7310)
@@ -0,0 +1,785 @@
+
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    Port of Donal Graft Telecide which is (c) Donald Graft
+    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
+    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
+
+ ***************************************************************************/
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include &quot;ADM_default.h&quot;
+#include &quot;Telecide.h&quot;
+#include &quot;DIA_factory.h&quot;
+
+#define aprintf(...) {}
+
+/**
+    \fn PutChosen
+*/
+void Telecide::PutChosen(int frame, unsigned int chosen)
+        {
+                int f;
+
+                f = frame % CACHE_SIZE;
+                if (frame &lt; 0 /*|| frame &gt; _info.nb_frames - 1*/ || cache[f].frame != frame)
+                        return;
+                cache[f].chosen = chosen;
+        }
+/**
+    \fn CacheInsert
+*/
+
+void Telecide::CacheInsert(int frame, unsigned int p, unsigned int pblock,
+                                                                unsigned int c, unsigned int cblock)
+{
+        int f;
+
+        f = frame % CACHE_SIZE;
+        if (frame &lt; 0 )//|| frame &gt; _info.nb_frames - 1)
+                ADM_assert(0);
+        cache[f].frame = frame;
+        cache[f].metrics[P] = p;
+        if (f) cache[f-1].metrics[N] = p;
+        cache[f].metrics[C] = c;
+        cache[f].metrics[PBLOCK] = pblock;
+        cache[f].metrics[CBLOCK] = cblock;
+        cache[f].chosen = 0xff;
+}
+/**
+    \fn CacheQuery
+*/
+bool Telecide::CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
+                                                                unsigned int *c, unsigned int *cblock)
+{
+        int f;
+
+        f = frame % CACHE_SIZE;
+        if (frame &lt; 0) // || frame &gt; _info.nb_frames - 1)
+        {
+                printf(&quot;Frame %d is out! \n&quot;,frame); //,_info.nb_frames-1);
+                ADM_assert(0);
+        }
+        if (cache[f].frame != frame)
+        {
+                return false;
+        }
+        *p = cache[f].metrics[P];
+        *c = cache[f].metrics[C];
+        *pblock = cache[f].metrics[PBLOCK];
+        *cblock = cache[f].metrics[CBLOCK];
+        return true;
+}
+/**
+    \fn Show
+*/
+void Telecide::Show(ADMImage *dst, int frame)
+{
+	char use;
+	teleCide *_param=&configuration;
+
+	if (chosen == P) use = 'p';
+	else if (chosen == C) use = 'c';
+	else use = 'n';
+
+	sprintf(buf, &quot;Telecide %s&quot;, &quot;ADM&quot;); // VERSION
+	DrawString(dst, 0, 0, buf);
+
+	sprintf(buf, &quot;Copyright 2003 Donald A. Graft&quot;);
+	DrawString(dst, 0, 1, buf);
+
+	sprintf(buf,&quot;frame %d:&quot;, frame);
+	DrawString(dst, 0, 3, buf);
+
+	sprintf(buf, &quot;matches: %d  %d  %d&quot;, p, c, np);
+	DrawString(dst, 0, 4, buf);
+
+	if (_param-&gt;post != POST_NONE)
+	{
+		sprintf(buf,&quot;vmetrics: %d  %d  %d [chosen=%d]&quot;, pblock, cblock, npblock, vmetric);
+		DrawString(dst, 0, 5, buf);
+	}
+
+	if (_param-&gt;guide != GUIDE_NONE)
+	{
+		sprintf(buf, &quot;pattern mismatch=%0.2f%%&quot;, mismatch); 
+		DrawString(dst, 0, 5 + (_param-&gt;post != POST_NONE), buf);
+	}
+
+	sprintf(buf,&quot;[%s %c]%s %s&quot;,
+		found == true ? &quot;forcing&quot; : &quot;using&quot;, use,
+		_param-&gt;post != POST_NONE ? (film == true ? &quot; [progressive]&quot; : &quot; [interlaced]&quot;) : &quot;&quot;,
+		_param-&gt;guide != GUIDE_NONE ? status : &quot;&quot;);
+	DrawString(dst, 0, 5 + (_param-&gt;post != POST_NONE) + (_param-&gt;guide != GUIDE_NONE), buf);
+}
+/**
+    \fn Debug
+*/
+void Telecide::Debug(int frame)
+{
+	char use;
+
+	if (chosen == P) use = 'p';
+	else if (chosen == C) use = 'c';
+	else use = 'n';
+	sprintf(buf,&quot;Telecide: frame %d: matches: %d %d %d&quot;, frame, p, c, np);
+	OutputDebugString(buf);
+	if (configuration.post != POST_NONE)
+	{
+		sprintf(buf,&quot;Telecide: frame %d: vmetrics: %d %d %d [chosen=%d]&quot;, frame, pblock, cblock, npblock, vmetric);
+		OutputDebugString(buf);
+	}
+	sprintf(buf,&quot;Telecide: frame %d: [%s %c]%s %s&quot;, frame, found == true ? &quot;forcing&quot; : &quot;using&quot;, use,
+		configuration.post  != POST_NONE ? (film == true ? &quot; [progressive]&quot; : &quot; [interlaced]&quot;) : &quot;&quot;,
+		configuration.guide != GUIDE_NONE ? status : &quot;&quot;);
+	OutputDebugString(buf);
+}
+/**
+    \fn configure
+*/
+bool Telecide::configure(void)
+{
+#define PX(x) &amp;(configuration.x)
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+
+    teleCide *_param=&configuration;
+        
+    ELEM_TYPE_FLOAT vthresh=(ELEM_TYPE_FLOAT)_param-&gt;vthresh;
+    ELEM_TYPE_FLOAT bthresh=(ELEM_TYPE_FLOAT)_param-&gt;bthresh;
+    ELEM_TYPE_FLOAT dthresh=(ELEM_TYPE_FLOAT)_param-&gt;dthresh;
+    ELEM_TYPE_FLOAT gthresh=(ELEM_TYPE_FLOAT)_param-&gt;gthresh;
+
+         diaMenuEntry tStrategy[]={
+                             {GUIDE_NONE,   QT_TR_NOOP(&quot;No strategy&quot;),NULL},
+                             {GUIDE_32,     QT_TR_NOOP(&quot;3:2 pulldown&quot;),NULL},
+                             {GUIDE_22,     QT_TR_NOOP(&quot;PAL/SECAM&quot;),NULL},
+                             {GUIDE_32322,  QT_TR_NOOP(&quot;NTSC converted from PAL&quot;),NULL}
+                          };
+                          
+          diaMenuEntry tField[]={
+                             {1,QT_TR_NOOP(&quot;Top&quot;),NULL},
+                             {0,QT_TR_NOOP(&quot;Bottom&quot;),NULL}
+          };
+          
+          diaMenuEntry tBackward[]={
+                             {NO_BACK,QT_TR_NOOP(&quot;Never&quot;),NULL},
+                             {BACK_ON_COMBED,QT_TR_NOOP(&quot;If still combed&quot;),NULL},
+                             {ALWAYS_BACK,QT_TR_NOOP(&quot;Always&quot;),NULL}
+          };
+          
+          diaMenuEntry tPostproc[]={
+                             {POST_NONE,      QT_TR_NOOP(&quot;None&quot;),NULL},
+                             {POST_METRICS,   QT_TR_NOOP(&quot;None but compute&quot;),NULL},
+                             {POST_FULL,      QT_TR_NOOP(&quot;Postproc on best match&quot;),NULL},
+                             {POST_FULL_MAP,  QT_TR_NOOP(&quot;Postproc and show zones (debug)&quot;),NULL},
+                             {POST_FULL_NOMATCH,QT_TR_NOOP(&quot;Process image (not fields)&quot;),NULL},
+                             {POST_FULL_NOMATCH_MAP,QT_TR_NOOP(&quot;Process image (not fields), debug&quot;),NULL}
+          };
+                             
+          
+    diaElemMenu menuMode(PX(guide),   QT_TR_NOOP(&quot;_Strategy:&quot;), SZT(tStrategy),tStrategy);
+    diaElemMenu menuField(PX(order),  QT_TR_NOOP(&quot;_Field order:&quot;), SZT(tField),tField);
+    diaElemMenu menuPost(PX(post),    QT_TR_NOOP(&quot;_Postprocessing:&quot;), SZT(tPostproc),tPostproc);
+    diaElemMenu menuBackward(PX(back),QT_TR_NOOP(&quot;_Try backward:&quot;), SZT(tBackward),tBackward);
+    
+    diaElemFloat direct(&amp;dthresh,QT_TR_NOOP(&quot;_Direct threshold:&quot;),0,200. );
+    diaElemFloat backward(&amp;bthresh,QT_TR_NOOP(&quot;_Backward threshold:&quot;),0,200. );
+    diaElemFloat noise(&amp;gthresh,QT_TR_NOOP(&quot;_Noise threshold:&quot;),0,200. );
+    diaElemFloat post(&amp;vthresh,QT_TR_NOOP(&quot;Postp_rocessing threshold:&quot;),0,200. );
+    
+    diaElemToggle chroma(PX(chroma),QT_TR_NOOP(&quot;_Use chroma to decide&quot;));
+    diaElemToggle show(PX(show),QT_TR_NOOP(&quot;Sho_w info&quot;));
+    diaElemToggle debug(PX(debug),QT_TR_NOOP(&quot;Debu_g&quot;));
+    diaElemToggle blend(PX(blend),QT_TR_NOOP(&quot;Bl_end&quot;));
+    
+    
+    
+    diaElem *elems[]={&amp;menuMode,&amp;menuField,&amp;menuPost,&amp;menuBackward,
+        &amp;direct,&amp;backward,&amp;noise,&amp;post,&amp;blend,
+        &amp;chroma,&amp;show,&amp;debug    };
+    
+  if(diaFactoryRun(QT_TR_NOOP(&quot;Decomb Telecide&quot;),12,elems))
+  {
+    
+      _param-&gt;vthresh=(float)vthresh;
+      _param-&gt;bthresh=(float)bthresh;
+      _param-&gt;dthresh=(float)dthresh;
+      _param-&gt;gthresh=(float)gthresh;
+
+    return 1; 
+  }
+  return 0;        
+}
+/**
+    \fn getConfiguration
+*/
+const char *Telecide::getConfiguration( void )
+{
+static char buf[100];
+ snprintf(buf,99,&quot; Decomb telecide&quot;);
+ return buf;  
+}
+
+#define PROGRESSIVE  0x00000001
+#define IN_PATTERN   0x00000002
+
+/*
+  uint8_t PutHintingData(unsigned char *video, unsigned int hint);
+  uint8_t GetHintingData(unsigned char *video, unsigned int *hint);
+*/
+/**
+    \fn WriteHints
+*/  
+void Telecide::WriteHints(unsigned char *dst, bool film, bool inpattern)
+        {
+                unsigned int hint;
+
+                if (GetHintingData(dst, &amp;hint) == true) hint = 0;
+                if (film == true) hint |= PROGRESSIVE;
+                else hint &amp;= ~PROGRESSIVE;
+                if (inpattern == true) hint |= IN_PATTERN;
+                else hint &amp;= ~IN_PATTERN;
+                PutHintingData(dst, hint);
+        }
+/**
+    \fn PredictHardYUY2
+*/
+bool Telecide::PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric)
+        {
+                // Look for pattern in the actual delivered matches of the previous cycle of frames.
+                // If a pattern is found, use that to predict the current match.
+                if (configuration.guide == GUIDE_22)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen &lt;&lt; 4) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen))
+                        {
+                        case 0x11:
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x22:
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+                else if (configuration.guide == GUIDE_32)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen &lt;&lt; 16) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen &lt;&lt; 12) +
+                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen &lt;&lt;  8) +
+                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen &lt;&lt;  4) +
+                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen))
+                        {
+                        case 0x11122:
+                        case 0x11221:
+                        case 0x12211:
+                        case 0x12221: 
+                        case 0x21122: 
+                        case 0x11222: 
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x22111:
+                        case 0x21112:
+                        case 0x22112: 
+                        case 0x22211: 
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+                else if (configuration.guide == GUIDE_32322)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+5)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen &lt;&lt; 20) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen &lt;&lt; 16) +
+                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen &lt;&lt; 12) +
+                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen &lt;&lt;  8) +
+                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen &lt;&lt;  4) +
+                                        (cache[(frame-cycle+5)%CACHE_SIZE].chosen))
+                        {
+                        case 0x111122:
+                        case 0x111221:
+                        case 0x112211:
+                        case 0x122111:
+                        case 0x111222: 
+                        case 0x112221:
+                        case 0x122211:
+                        case 0x222111: 
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x221111:
+                        case 0x211112:
+
+                        case 0x221112: 
+                        case 0x211122: 
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+#ifdef DEBUG_PATTERN_GUIDANCE
+                sprintf(buf, &quot;%d: HARD: predicted = %d\n&quot;, frame, *predicted);
+                OutputDebugString(buf);
+#endif
+                return true;
+        }
+/**
+    \fn PredictSoftYUY2
+*/
+struct PREDICTION *Telecide::PredictSoftYUY2(int frame)
+        {
+                // Use heuristics to look forward for a match.
+                int i, j, y, c, n, phase;
+                unsigned int metric;
+
+                pred[0].metric = 0xffffffff;
+                if (frame &lt; 0 /*|| frame &gt; _info.nb_frames - 1 - cycle*/) return pred;
+
+                // Look at the next cycle of frames.
+                for (y = frame + 1; y &lt;= frame + cycle; y++)
+                {
+                        // Look for a frame where the current and next match values are
+                        // very close. Those are candidates to predict the phase, because
+                        // that condition should occur only once per cycle. Store the candidate
+                        // phases and predictions in a list sorted by goodness. The list will
+                        // be used by the caller to try the phases in order.
+                        c = cache[y%CACHE_SIZE].metrics[C]; 
+                        n = cache[y%CACHE_SIZE].metrics[N];
+                        if (c == 0) c = 1;
+                        metric = (100 * abs (c - n)) / c;
+                        phase = y % cycle;
+                        if (metric &lt; 5)
+                        {
+                                // Place the new candidate phase in sorted order in the list.
+                                // Find the insertion point.
+                                i = 0;
+                                while (metric &gt; pred[i].metric) i++;
+                                // Find the end-of-list marker.
+                                j = 0;
+                                while (pred[j].metric != 0xffffffff) j++;
+                                // Shift all items below the insertion point down by one to make
+                                // room for the insertion.
+                                j++;
+                                for (; j &gt; i; j--)
+                                {
+                                        pred[j].metric = pred[j-1].metric;
+                                        pred[j].phase = pred[j-1].phase;
+                                        pred[j].predicted = pred[j-1].predicted;
+                                        pred[j].predicted_metric = pred[j-1].predicted_metric;
+                                }
+                                // Insert the new candidate data.
+                                pred[j].metric = metric;
+                                pred[j].phase = phase;
+                                if (configuration.guide == GUIDE_32)
+                                {
+                                        switch ((frame % cycle) - phase)
+                                        {
+                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -3: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        }
+                                }
+                                else if (configuration.guide == GUIDE_32322)
+                                {
+                                        switch ((frame % cycle) - phase)
+                                        {
+                                        case -5: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +5: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        }
+                                }
+                        }
+#ifdef DEBUG_PATTERN_GUIDANCE
+                        sprintf(buf,&quot;%d: metric = %d phase = %d\n&quot;, frame, metric, phase);
+                        OutputDebugString(buf);
+#endif
+                }
+                return pred;
+        }
+
+/**
+    \fn CalculateMetrics
+*/
+#define nt      configuration.nt
+#define y0      configuration.y0
+#define y1      configuration.y1
+#define chroma  configuration.chroma
+#define post    configuration.post
+
+
+void Telecide::CalculateMetrics(int frame, 
+                                unsigned char *fcrp,  unsigned char *fcrpU, 
+                                unsigned char *fcrpV, unsigned char *fprp, 
+                                unsigned char *fprpU, unsigned char *fprpV)
+{
+        int x, y, p, c, tmp1, tmp2, skip;
+        bool vc;
+        unsigned char *currbot0, *currbot2, *prevbot0, *prevbot2;
+        unsigned char *prevtop0, *prevtop2, *prevtop4, *currtop0, *currtop2, *currtop4;
+        unsigned char *a0, *a2, *b0, *b2, *b4;
+        unsigned int diff, index;
+#define T 4
+
+        /* Clear the block sums. */
+        for (y = 0; y &lt; yblocks; y++)
+        {
+                for (x = 0; x &lt; xblocks; x++)
+                {
+#ifdef WINDOWED_MATCH
+                        matchp[y*xblocks+x] = 0;
+                        matchc[y*xblocks+x] = 0;
+#endif
+                        sump[y*xblocks+x] = 0;
+                        sumc[y*xblocks+x] = 0;
+                }
+        }
+
+        /* Find the best field match. Subsample the frames for speed. */
+        currbot0  = fcrp + pitch;
+        currbot2  = fcrp + 3 * pitch;
+        currtop0 = fcrp;
+        currtop2 = fcrp + 2 * pitch;
+        currtop4 = fcrp + 4 * pitch;
+        prevbot0  = fprp + pitch;
+        prevbot2  = fprp + 3 * pitch;
+        prevtop0 = fprp;
+        prevtop2 = fprp + 2 * pitch;
+        prevtop4 = fprp + 4 * pitch;
+        if (tff == true)
+        {
+                a0 = prevbot0;
+                a2 = prevbot2;
+                b0 = currtop0;
+                b2 = currtop2;
+                b4 = currtop4;
+        }
+        else
+        {
+                a0 = currbot0;
+                a2 = currbot2;
+                b0 = prevtop0;
+                b2 = prevtop2;
+                b4 = prevtop4;
+        }
+        p = c = 0;
+
+        // Calculate the field match and film/video metrics.
+        //if (vi.IsYV12()) skip = 1;
+        if(1) skip=1;
+        else skip = 1 + (chroma == false);
+        for (y = 0, index = 0; y &lt; h - 4; y+=4)
+        {
+                /* Exclusion band. Good for ignoring subtitles. */
+                if (y0 == y1 || y &lt; y0 || y &gt; y1)
+                {
+                        for (x = 0; x &lt; w;)
+                        {
+                                if (1) //vi.IsYV12())
+                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
+                                else
+                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
+
+                                // Test combination with current frame.
+                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
+//                              diff = abs((long)currtop0[x] - (tmp1 &gt;&gt; 1));
+                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
+                                if (diff &gt; nt)
+                                {
+                                        c += diff;
+#ifdef WINDOWED_MATCH
+                                        matchc[index] += diff;
+#endif
+                                }
+
+                                tmp1 = currbot0[x] + T;
+                                tmp2 = currbot0[x] - T;
+                                vc = (tmp1 &lt; currtop0[x] &amp;&amp; tmp1 &lt; currtop2[x]) ||
+                                         (tmp2 &gt; currtop0[x] &amp;&amp; tmp2 &gt; currtop2[x]);
+                                if (vc)
+                                {
+                                        sumc[index]++;
+                                }
+
+                                // Test combination with previous frame.
+                                tmp1 = ((long)a0[x] + (long)a2[x]);
+                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
+                                if (diff &gt; nt)
+                                {
+                                        p += diff;
+#ifdef WINDOWED_MATCH
+                                        matchp[index] += diff;
+#endif
+                                }
+
+                                tmp1 = a0[x] + T;
+                                tmp2 = a0[x] - T;
+                                vc = (tmp1 &lt; b0[x] &amp;&amp; tmp1 &lt; b2[x]) ||
+                                         (tmp2 &gt; b0[x] &amp;&amp; tmp2 &gt; b2[x]);
+                                if (vc)
+                                {
+                                        sump[index]++;
+                                }
+
+                                x += skip;
+                                if (!(x&amp;3)) x += 4;
+                        }
+                }
+                currbot0 += pitchtimes4;
+                currbot2 += pitchtimes4;
+                currtop0 += pitchtimes4;
+                currtop2 += pitchtimes4;
+                currtop4 += pitchtimes4;
+                a0               += pitchtimes4;
+                a2               += pitchtimes4;
+                b0               += pitchtimes4;
+                b2               += pitchtimes4;
+                b4               += pitchtimes4;
+        }
+
+       // if (vi.IsYV12() &amp;&amp; chroma == true)
+        if ( chroma == true)
+        {
+                int z;
+
+                for (z = 0; z &lt; 2; z++)
+                {
+                        // Do the same for the U plane.
+                        if (z == 0)
+                        {
+                                currbot0  = fcrpU + pitchover2;
+                                currbot2  = fcrpU + 3 * pitchover2;
+                                currtop0 = fcrpU;
+                                currtop2 = fcrpU + 2 * pitchover2;
+                                currtop4 = fcrpU + 4 * pitchover2;
+                                prevbot0  = fprpU + pitchover2;
+                                prevbot2  = fprpU + 3 * pitchover2;
+                                prevtop0 = fprpU;
+                                prevtop2 = fprpU + 2 * pitchover2;
+                                prevtop4 = fprpU + 4 * pitchover2;
+                        }
+                        else
+                        {
+                                currbot0  = fcrpV + pitchover2;
+                                currbot2  = fcrpV + 3 * pitchover2;
+                                currtop0 = fcrpV;
+                                currtop2 = fcrpV + 2 * pitchover2;
+                                currtop4 = fcrpV + 4 * pitchover2;
+                                prevbot0  = fprpV + pitchover2;
+                                prevbot2  = fprpV + 3 * pitchover2;
+                                prevtop0 = fprpV;
+                                prevtop2 = fprpV + 2 * pitchover2;
+                                prevtop4 = fprpV + 4 * pitchover2;
+                        }
+                        if (tff == true)
+                        {
+                                a0 = prevbot0;
+                                a2 = prevbot2;
+                                b0 = currtop0;
+                                b2 = currtop2;
+                                b4 = currtop4;
+                        }
+                        else
+                        {
+                                a0 = currbot0;
+                                a2 = currbot2;
+                                b0 = prevtop0;
+                                b2 = prevtop2;
+                                b4 = prevtop4;
+                        }
+
+                        for (y = 0, index = 0; y &lt; hover2 - 4; y+=4)
+                        {
+                                /* Exclusion band. Good for ignoring subtitles. */
+                                if (y0 == y1 || y &lt; y0/2 || y &gt; y1/2)
+                                {
+                                        for (x = 0; x &lt; wover2;)
+                                        {
+                                                if (1) //vi.IsYV12())
+                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
+                                                else
+                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
+
+                                                // Test combination with current frame.
+                                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
+                                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
+                                                if (diff &gt; nt)
+                                                {
+                                                        c += diff;
+#ifdef WINDOWED_MATCH
+                                                        matchc[index] += diff;
+#endif
+                                                }
+
+                                                tmp1 = currbot0[x] + T;
+                                                tmp2 = currbot0[x] - T;
+                                                vc = (tmp1 &lt; currtop0[x] &amp;&amp; tmp1 &lt; currtop2[x]) ||
+                                                         (tmp2 &gt; currtop0[x] &amp;&amp; tmp2 &gt; currtop2[x]);
+                                                if (vc)
+                                                {
+                                                        sumc[index]++;
+                                                }
+
+                                                // Test combination with previous frame.
+                                                tmp1 = ((long)a0[x] + (long)a2[x]);
+                                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
+                                                if (diff &gt; nt)
+                                                {
+                                                        p += diff;
+#ifdef WINDOWED_MATCH
+                                                        matchp[index] += diff;
+#endif
+                                                }
+
+                                                tmp1 = a0[x] + T;
+                                                tmp2 = a0[x] - T;
+                                                vc = (tmp1 &lt; b0[x] &amp;&amp; tmp1 &lt; b2[x]) ||
+                                                         (tmp2 &gt; b0[x] &amp;&amp; tmp2 &gt; b2[x]);
+                                                if (vc)
+                                                {
+                                                        sump[index]++;
+                                                }
+
+                                                x ++;
+                                                if (!(x&amp;3)) x += 4;
+                                        }
+                                }
+                                currbot0 += 4*pitchover2;
+                                currbot2 += 4*pitchover2;
+                                currtop0 += 4*pitchover2;
+                                currtop2 += 4*pitchover2;
+                                currtop4 += 4*pitchover2;
+                                a0               += 4*pitchover2;
+                                a2               += 4*pitchover2;
+                                b0               += 4*pitchover2;
+                                b2               += 4*pitchover2;
+                                b4               += 4*pitchover2;
+                        }
+                }
+        }
+
+        // Now find the blocks that have the greatest differences.
+#ifdef WINDOWED_MATCH
+        highest_matchp = 0;
+        for (y = 0; y &lt; yblocks; y++)
+        {
+                for (x = 0; x &lt; xblocks; x++)
+                {
+if (frame == 45 &amp;&amp; matchp[y * xblocks + x] &gt; 2500)
+{
+        sprintf(buf, &quot;%d/%d = %d\n&quot;, x, y, matchp[y * xblocks + x]);
+        OutputDebugString(buf);
+}
+                        if (matchp[y * xblocks + x] &gt; highest_matchp)
+                        {
+                                highest_matchp = matchp[y * xblocks + x];
+                        }
+                }
+        }
+        highest_matchc = 0;
+        for (y = 0; y &lt; yblocks; y++)
+        {
+                for (x = 0; x &lt; xblocks; x++)
+                {
+if (frame == 44 &amp;&amp; matchc[y * xblocks + x] &gt; 2500)
+{
+        sprintf(buf, &quot;%d/%d = %d\n&quot;, x, y, matchc[y * xblocks + x]);
+        OutputDebugString(buf);
+}
+                        if (matchc[y * xblocks + x] &gt; highest_matchc)
+                        {
+                                highest_matchc = matchc[y * xblocks + x];
+                        }
+                }
+        }
+#endif
+        if (post != POST_NONE)
+        {
+                highest_sump = 0;
+                for (y = 0; y &lt; yblocks; y++)
+                {
+                        for (x = 0; x &lt; xblocks; x++)
+                        {
+                                if (sump[y * xblocks + x] &gt; highest_sump)
+                                {
+                                        highest_sump = sump[y * xblocks + x];
+                                }
+                        }
+                }
+                highest_sumc = 0;
+                for (y = 0; y &lt; yblocks; y++)
+                {
+                        for (x = 0; x &lt; xblocks; x++)
+                        {
+                                if (sumc[y * xblocks + x] &gt; highest_sumc)
+                                {
+                                        highest_sumc = sumc[y * xblocks + x];
+                                }
+                        }
+                }
+        }
+#ifdef WINDOWED_MATCH
+        CacheInsert(frame, highest_matchp, highest_sump, highest_matchc, highest_sumc);
+#else
+        CacheInsert(frame, p, highest_sump, c, highest_sumc);
+#endif
+}
+// EOF


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004463.html">[Avidemux-svn-commit] r7309 -	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
</A></li>
	<LI>Next message: <A HREF="004465.html">[Avidemux-svn-commit] r7311 - in branches/avidemux_2.6_branch_mean:	avidemux_core/ADM_coreImage/include	avidemux_plugins/ADM_videoFilters6	avidemux_plugins/ADM_videoFilters6/telecide
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4464">[ date ]</a>
              <a href="thread.html#4464">[ thread ]</a>
              <a href="subject.html#4464">[ subject ]</a>
              <a href="author.html#4464">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
