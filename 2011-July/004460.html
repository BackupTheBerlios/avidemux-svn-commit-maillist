<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r7306 - in	branches/avidemux_2.6_branch_mean/avidemux: . common
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2011-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r7306%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux%3A%20.%20common&In-Reply-To=%3C20110706051954.04112483387%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="004461.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r7306 - in	branches/avidemux_2.6_branch_mean/avidemux: . common</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r7306%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux%3A%20.%20common&In-Reply-To=%3C20110706051954.04112483387%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r7306 - in	branches/avidemux_2.6_branch_mean/avidemux: . common">mean at mail.berlios.de
       </A><BR>
    <I>Wed Jul  6 07:19:53 CEST 2011</I>
    <P><UL>
        
        <LI>Next message: <A HREF="004461.html">[Avidemux-svn-commit] r7307 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_amrnb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4460">[ date ]</a>
              <a href="thread.html#4460">[ thread ]</a>
              <a href="subject.html#4460">[ subject ]</a>
              <a href="author.html#4460">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2011-07-06 07:19:53 +0200 (Wed, 06 Jul 2011)
New Revision: 7306

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_main.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
Log:
[cosmetic] Rename gtk_gui.cpp to gui_main.cpp

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2011-06-26 17:14:30 UTC (rev 7305)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2011-07-06 05:19:53 UTC (rev 7306)
@@ -1,1187 +0,0 @@
-/***************************************************************************
-                          \file gtk_gui.cpp  
-                          \brief Main UI even loop
-                             
-    copyright            : (C) 2001-2009 by mean, <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_cpp.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &lt;math.h&gt;
-#include &lt;errno.h&gt;
-
-#include &quot;fourcc.h&quot;
-
-#include &quot;DIA_fileSel.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-
-#include &quot;gui_action.hxx&quot;
-#include &quot;gtkgui.h&quot;
-
-#include &quot;prefs.h&quot;
-#include &quot;ADM_render/GUI_render.h&quot;
-#include &quot;ADM_commonUI/GUI_ui.h&quot;
-
-#include &quot;DIA_working.h&quot;
-#include &quot;DIA_factory.h&quot;
-
-#include &quot;ADM_vidMisc.h&quot;
-#include &quot;ADM_preview.h&quot;
-#include &quot;ADM_coreVideoEncoder.h&quot;
-#include &quot;ADM_videoEncoderApi.h&quot;
-#include &quot;ADM_audioFilter/include/ADM_audioFilterInterface.h&quot;
-
-#include &quot;avi_vars.h&quot;
-#include &quot;prototype.h&quot; // FIXME
-#include &quot;ADM_script2/include/ADM_scriptIf.h&quot;
-renderZoom currentZoom=ZOOM_1_1;
-//***********************************
-//******** A Function ***************
-//***********************************
-#include &quot;A_functions.h&quot;
-//***********************************
-//******** GUI Function**************
-//***********************************
-
-extern uint8_t UI_getPhysicalScreenSize(void* window, uint32_t *w,uint32_t *h);
-extern uint8_t GUI_jobs(void);
-extern const char * GUI_getCustomJsScript(uint32_t nb);
-extern const char * GUI_getCustomPyScript(uint32_t nb);
-extern const char * GUI_getAutoPyScript(uint32_t nb);
-
-extern uint8_t GUI_getFrameContent(ADMImage *image, uint32_t frame);
-extern int     GUI_handleVFilter (void);
-extern void    GUI_setMarks (uint32_t a, uint32_t b);
-extern void    GUI_displayBitrate( void );
-// Debug functions
-       void    GUI_showCurrentFrameHex(void);
-       void    GUI_showSize(void);
-
-       void    GUI_avsProxy(void);
-       uint8_t GUI_close(void);
-extern int     GUI_GoToFrame(uint32_t frame);;
-extern bool    GUI_GoToTime(uint64_t time);
-//***********************************
-//******** DIA Function**************
-//***********************************
-extern uint8_t DIA_about( void );
-extern void    DIA_properties( void);
-extern uint8_t DIA_Preferences(void);
-extern uint8_t DIA_gotoTime(uint16_t *hh, uint32_t *mm, uint32_t *ss);
-extern uint8_t DIA_builtin(void);
-extern void    DIA_Calculator(uint32_t *sizeInMeg, uint32_t *avgBitrate );
-extern uint8_t DIA_pluginsInfo(void);
-
-extern void filterCleanUp (void);
-static void ReSync (void);
-static void cleanUp (void);
-void        updateLoaded (void);
-extern void encoderSetLogFile (char *name);
-extern void videoCodecConfigureUI(int codecIndex = -1);
-extern void audioCodecChanged(int newcodec);
-extern void videoCodecChanged(int newcodec);
-extern bool ADM_mux_configure(int index);
-void brokenAct(void);
-//
-//  Sub gui files...
-//
-void HandleAction (Action action);
-void HandleAction_Navigate(Action action);
-void HandleAction_Save(Action action);
-
-
-//
-//
-/**
-    \fn HandleAction
-    \brief  serialization of user event through gui
-
-*/
-typedef  const char * (*getName)(uint32_t nb);
-bool getScriptName(int action, int base,getName name,const char *ext,string &amp;out )
-{
-    if(action&lt;base) return false;
-    action=action-base;
-    const char *p=name(action);
-    if(!p) return false;
-    out=string(p)+string(&quot;.&quot;)+string(ext);
-    return true;
-}
-void HandleAction (Action action)
-{
-  uint32_t nf = 0;
-  uint32_t old;
-
-  ADM_warning(&quot;************ %s **************\n&quot;,getActionName(action));
-
-  // handle out of band actions
-  // independant load not loaded
-//------------------------------------------------
-int nw;
-  if(action&gt;=ACT_CUSTOM_BASE_JS &amp;&amp; action &lt;ACT_CUSTOM_END_JS)
-  {
-      string script;
-      if(true==getScriptName( action, ACT_CUSTOM_BASE_JS,GUI_getCustomJsScript,&quot;js&quot;,script))
-      {
-            A_parseECMAScript(script.c_str());
-      }
-      return ;
-  }
-  if(action&gt;=ACT_CUSTOM_BASE_PY &amp;&amp; action &lt;ACT_CUSTOM_END_PY)
-  {
-      string script;
-      if(true==getScriptName( action, ACT_CUSTOM_BASE_PY,GUI_getCustomPyScript,&quot;py&quot;,script))
-      {
-            A_parseTinyPyScript(script.c_str());      
-      }
-      return ;
-  }
-  if(action&gt;=ACT_AUTO_BASE_PY &amp;&amp; action &lt;ACT_AUTO_END_PY)
-  {
-      string script;
-      if(true==getScriptName( action, ACT_AUTO_BASE_PY,GUI_getAutoPyScript,&quot;py&quot;,script))
-      {
-            A_parseTinyPyScript(script.c_str());
-      }
-      return ;
-  }
-  switch (action)
-    {
-        case ACT_TimeShift:
-        case ACT_Goto:
-                                brokenAct();
-                                return;
-        case ACT_PY_SHELL:
-                                interactiveTinyPy();
-                                return;
-        case ACT_JS_SHELL:
-                                interactiveECMAScript(&quot;dummy&quot;);
-                                return;
-        case ACT_AVS_PROXY:
-                                GUI_avsProxy();
-                                return;
-        case ACT_BUILT_IN:
-                                DIA_builtin();
-                                return;
-        case ACT_RECENT0:
-        case ACT_RECENT1:
-        case ACT_RECENT2:
-        case ACT_RECENT3:
-                const char **name;
-                int rank;
-
-                name=prefs-&gt;get_lastfiles();
-                rank=(int)action-ACT_RECENT0;
-                ADM_assert(name[rank]);
-                A_openAvi (name[rank]);
-                return;
-		return;
-	case ACT_VIDEO_CODEC_CONFIGURE:
-    		videoEncoder6Configure();
-            return;
-    case ACT_ContainerConfigure:    
-            {
-            int index=UI_GetCurrentFormat();
-            ADM_mux_configure(index);
-            return;
-            }
-    case ACT_VIDEO_CODEC_CHANGED:
-    		nw=UI_getCurrentVCodec();
-    		videoEncoder6_SetCurrentEncoder(nw);
-            return;
-   case ACT_AUDIO_CODEC_CHANGED:
-            nw=UI_getCurrentACodec();
-            audioCodecSetByIndex(nw);
-            return;
-    case ACT_PLUGIN_INFO:
-            DIA_pluginsInfo();
-            return;
-    case ACT_RUN_PY_PROJECT:
-            GUI_FileSelRead (QT_TR_NOOP(&quot;Select python script to Run&quot;),(SELFILE_CB *) A_parseTinyPyScript);
-    		return;
-    case ACT_RUN_JS_PROJECT:
-            GUI_FileSelRead (QT_TR_NOOP(&quot;Select ECMAScript to Run&quot;),(SELFILE_CB *) A_parseECMAScript);
-    		return;
-
-    case ACT_ABOUT :
-    		 DIA_about( );
-		 return;
-    case ACT_AUDIO_CODEC_CONFIGURE:
-      audioCodecConfigure();
-      return;
-    case ACT_AUDIO_FILTERS:
-      audioFilterConfigure();
-      return;
-    case ACT_PREFERENCES:
-        if(playing) return;
-    	if(DIA_Preferences())
-        {
-            prefs-&gt;save ();
-        }
-        return;
-    case ACT_SavePref:
-        prefs-&gt;save ();
-        return;
-    case ACT_EXIT:
-      { bool saveprefsonexit;
-         prefs-&gt;get(FEATURES_SAVEPREFSONEXIT,&amp;saveprefsonexit);
-         if( saveprefsonexit )
-            prefs-&gt;save ();
-      }
-      cleanUp ();
-      exit (0);
-      break;
-    default:
-      break;
-
-    }
-
-  if (playing)			// only allow some action
-    {
-      switch (action)
-        {
-        case ACT_PlayAvi:
-        case ACT_StopAvi:
-          break;
-        default:
-          return;
-        }
-    }
-  // not playing,
-  // restict disabled uncoded actions
-  if ((int) action &gt;= ACT_DUMMY)
-    {
-      GUI_Error_HIG (QT_TR_NOOP(&quot;Not coded in this version&quot;), NULL);
-      return;
-    }
-  // allow only if avi loaded
-  if (!avifileinfo)
-    {
-      switch (action)
-        {
-          case ACT_JOG:
-                break;
-          case ACT_OPEN_VIDEO:
-                GUI_FileSelRead (QT_TR_NOOP(&quot;Select AVI File...&quot;), (SELFILE_CB *)A_openAvi);
-                break;
-          default:
-            break;
-        }
-        return;
-    }
-
-  // Dispatch actions, we have a file loaded
-  if(action&gt;ACT_NAVIGATE_BEGIN &amp;&amp; action &lt; ACT_NAVIGATE_END)
-  {
-    return HandleAction_Navigate(action);
-  }
-  if(action&gt;ACT_SAVE_BEGIN &amp;&amp; action &lt; ACT_SAVE_END)
-  {
-    return HandleAction_Save(action);
-  }
-
-  switch (action)
-    {
-       case ACT_JOG:
-                A_jog();
-                break;
-
-       case ACT_CLOSE:
-              GUI_close();
-              break;
-
-        case ACT_ZOOM_1_4:
-        case ACT_ZOOM_1_2:
-        case ACT_ZOOM_1_1:
-        case ACT_ZOOM_2_1:
-        case ACT_ZOOM_4_1:
-                currentZoom=(renderZoom)((action-ACT_ZOOM_1_4)+ZOOM_1_4);
-                changePreviewZoom(currentZoom);
-                admPreview::samePicture();
-                break;
-        case ACT_AUDIO_SELECT_TRACK:
-                A_audioTrack();
-                break;
-
-    case ACT_OPEN_VIDEO:
-        GUI_FileSelRead (QT_TR_NOOP(&quot;Select AVI File...&quot;),(SELFILE_CB *) A_openAvi);
-        break;
-    case ACT_APPEND_VIDEO:
-        GUI_FileSelRead (QT_TR_NOOP(&quot;Select AVI File to Append...&quot;),(SELFILE_CB *) A_appendAvi);
-        break;
-    case ACT_VIDEO_PROPERTIES:
-        DIA_properties ();
-        break;
-    case ACT_PlayAvi:
-      GUI_PlayAvi ();
-      break;
-  
-#define TOGGLE_PREVIEW ADM_PREVIEW_OUTPUT
-    case ACT_PreviewChanged:
-    {
-        ADM_PREVIEW_MODE oldpreview=getPreviewMode(),newpreview=(ADM_PREVIEW_MODE)UI_getCurrentPreview();
-          printf(&quot;Old preview %d, New preview mode : %d\n&quot;,oldpreview,newpreview);
-
-          if(oldpreview==newpreview)
-          {
-            return;
-          }
-            admPreview::stop();
-            setPreviewMode(newpreview);
-            admPreview::start();
-//            admPreview::update(curframe);
-      }
-      break;
-    case ACT_StopAvi:
-      if (playing)
-	GUI_PlayAvi ();
-      break;
-    case ACT_SetPostProcessing:
-      A_setPostproc();
-      break;
-    case ACT_MarkA:
-    case ACT_MarkB:
-    {
-      bool swapit=0;
-      uint64_t markA,markB;
-      uint64_t pts=admPreview::getCurrentPts();
-      if( prefs-&gt;get(FEATURES_SWAP_IF_A_GREATER_THAN_B, &amp;swapit) != RC_OK )     swapit = 1;
-
-      markA=video_body-&gt;getMarkerAPts();
-      markB=video_body-&gt;getMarkerBPts();
-      if (action == ACT_MarkA)
-            markA=pts;
-      else
-            markB=pts;
-      if (markA&gt;markB &amp;&amp; swapit )	// auto swap
-        {
-          uint64_t y;
-          y = markA;
-          markA=markB;
-          markB=y;
-        }
-        video_body-&gt;setMarkerAPts(markA);
-        video_body-&gt;setMarkerBPts(markB);
-        UI_setMarkers (markA, markB);
-      break;
-    }
-    case ACT_Copy:
-            brokenAct();
-//    		   video_body-&gt;copyToClipBoard (frameStart,frameEnd);
-		break;
-    case ACT_Paste:
-            brokenAct();        		
-            break;
-      break;
-
-    case ACT_ResetSegments:
-       if(avifileinfo)
-         if(GUI_Question(QT_TR_NOOP(&quot;Are you sure?&quot;)))
-        {
-            video_body-&gt;resetSeg();
-            video_body-&gt;getVideoInfo (avifileinfo);
-		
-      		GUI_setAllFrameAndTime ();
-            A_ResetMarkers();
-      		ReSync ();
-
-            // forget last project file
-            video_body-&gt;setProjectName(&quot;&quot;);
-        }
-	break;
-
-    case ACT_Delete:
-    case ACT_Cut:
-        {
-            uint64_t a=video_body-&gt;getMarkerAPts();
-            uint64_t b=video_body-&gt;getMarkerBPts();
-            if(false==video_body-&gt;remove(a,b))
-            {
-                GUI_Error_HIG(&quot;Cutting&quot;,&quot;Error while cutting out.&quot;);
-            }
-            else    
-            {
-              A_ResetMarkers();              
-              A_Resync(); // total duration &amp; stuff
-              // Rewind to first frame...
-              //A_Rewind();
-              GUI_GoToTime(a);
-                
-            }
-        }
-        
-      break;
-      // set decoder option (post processing ...)
-    case ACT_DecoderOption:
-      video_body-&gt;setDecodeParam ( admPreview::getCurrentPts());
-
-      break;
-    case ACT_VIDEO_FILTERS:
-        GUI_handleVFilter();
-        break;
-
-   case ACT_HEX_DUMP:
-      GUI_showCurrentFrameHex();
-      break;
-   case ACT_SIZE_DUMP:
-      GUI_showSize();
-      break;
-    default:
-      printf (&quot;\n unhandled action %d\n&quot;, action);
-      ADM_assert (0);
-      return;
-
-    }
-}
-
-//_____________________________________________________________
-//
-// Open AVI File
-//    mode 0: normal
-//    mode 1: Suspicious
-//_____________________________________________________________
-
-extern void GUI_PreviewEnd (void);
-/**
-        \fn A_openAvi
-        \brief Open (replace mode) a video
-*/
-int A_openAvi (const char *name)
-{
-  uint8_t res;
-  char *longname;
-  uint32_t magic[4];
-  uint32_t id = 0;
-
-  if (playing)
-    return 0;
-  /// check if name exists
-  FILE *fd;
-  fd = ADM_fopen (name, &quot;rb&quot;);
-  if (!fd){
-    if( errno == EACCES ){
-      GUI_Error_HIG(QT_TR_NOOP(&quot;Permission error&quot;), QT_TR_NOOP(&quot;Cannot open \&quot;%s\&quot;.&quot;), name);
-    }
-    if( errno == ENOENT ){
-      GUI_Error_HIG(QT_TR_NOOP(&quot;File error&quot;), QT_TR_NOOP(&quot;\&quot;%s\&quot; does not exist.&quot;), name);
-    }
-    return 0;
-  }
-  if( 4 == fread(magic,4,4,fd) )
-     id=R32(magic[0]);
-  fclose (fd);
-
-
-  GUI_close(); // Cleanup
-
-//  DIA_StartBusy ();
-  /*
-  ** we may get a relative path by cmdline
-  */
-  longname = ADM_PathCanonize(name);
-  res = video_body-&gt;addFile (longname);
-//  DIA_StopBusy ();
-
-  // forget last project file
-    video_body-&gt;setProjectName(&quot;&quot;);
-
-  if (res!=ADM_OK)			// an error occured
-    {
-		delete[] longname;
-    	if(ADM_IGN==res)
-	{
-		return 0;
-	}
-
-	if( fourCC::check(id,(uint8_t *)&quot;//AD&quot;) ){
-          GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open project using the video loader.&quot;),
-                        QT_TR_NOOP(  &quot;Try 'File' -&gt; 'Load/Run Project...'&quot;));
-	}else{
-          GUI_Error_HIG (QT_TR_NOOP(&quot;Could not open the file&quot;), NULL);
-	}
-	return 0;
-    }
-
-    { int i;
-      FILE *fd=NULL;
-      char magic[4];
-
-	/* check myself it is a project file (transparent detected and read
-        ** by video_body-&gt;addFile (name);
-	*/
-#warning FIXME
-#if 0
-	if( (fd = ADM_fopen(longname,&quot;rb&quot;))  ){
-		if( fread(magic,4,1,fd) == 4 ){
-			/* remember a workbench file */
-			if( !strncmp(magic,&quot;ADMW&quot;,4) ){
-				actual_workbench_file = ADM_strdup(longname);
-			}
-		}
-		fclose(fd);
-	}
-#endif
-	/* remember any video or workbench file to &quot;recent&quot; */
-        prefs-&gt;set_lastfile(longname);
-        UI_updateRecentMenu();
-        updateLoaded ();
-        if(currentaudiostream)
-        {
-            uint32_t nbAudio;
-            audioInfo *infos=NULL;
-            if(video_body-&gt;getAudioStreamsInfo(admPreview::getCurrentPts()+1,&amp;nbAudio,&amp;infos))
-            {
-                if(nbAudio&gt;1)
-                {   // Multiple track warn user
-                  GUI_Info_HIG(ADM_LOG_INFO,QT_TR_NOOP(&quot;Multiple Audio Tracks&quot;),QT_TR_NOOP(&quot;The file you just loaded contains several audio tracks.\n&quot;
-                      &quot;Go to Audio-&gt;MainTrack to select the active one.&quot;));
-                }
-            }
-            if(infos) delete [] infos;
-            // Revert mixer to copy
-            //setCurrentMixerFromString(&quot;NONE&quot;);
-            audioFilterSetMixer(CHANNEL_INVALID);
-        }
-	for(i=strlen(longname);i&gt;=0;i--)
-    {
-#ifdef __WIN32
-		if( longname[i] == '\\' || longname[i] == '/' )
-#else
-		if( longname[i] == '/' )
-#endif
-        {
-
-			i++;
-			break;
-		}
-    }
-	UI_setTitle(longname+i);
-    }
-
-	delete[] longname;
-	return 1;
-}
-/**
-    \fn updateLoaded
-    \brief update the UI after loading a file
-
-*/
-void  updateLoaded ()
-{
-  avifileinfo = new aviInfo;
-  if (!video_body-&gt;getVideoInfo (avifileinfo))
-    {
-//      err1:
-      printf (&quot;\n get info failed...cancelling load...\n&quot;);
-      delete avifileinfo;
-      avifileinfo = NULL;
-
-      return;
-    }
-
-
-//  getFirstVideoFilter(); // reinit first filter
-
-  // now get audio information if exists
-  WAVHeader *wavinfo;
-  wavinfo = video_body-&gt;getInfo ();	//wavinfo); // will be null if no audio
-  if (!wavinfo)
-    {
-      printf (&quot;\n *** NO AUDIO ***\n&quot;);
-      wavinfo = (WAVHeader *) NULL;
-    }
-
-  // Init renderer
-    admPreview::setMainDimension(avifileinfo-&gt;width, avifileinfo-&gt;height);
-
-
-  // Draw first frame
-  GUI_setAllFrameAndTime();
-  A_ResetMarkers();
-//  getFirstVideoFilter(); // Rebuild filter if needed
-
-  /* Zoom out if needed */
-  uint32_t phyW,phyH;
-  UI_getPhysicalScreenSize(NULL, &amp;phyW,&amp;phyH);
-  if(3*phyW&lt;4*avifileinfo-&gt;width || 3*phyH&lt;4*avifileinfo-&gt;height)
-  {
-      if(phyW&lt;avifileinfo-&gt;width/2 || phyH&lt;avifileinfo-&gt;height/2)
-      {
-                currentZoom=ZOOM_1_4;
-      }else
-      {
-                currentZoom=ZOOM_1_2;
-      }
-     changePreviewZoom(currentZoom);
-  }
-  else
-  {
-      currentZoom=ZOOM_1_1;
-      changePreviewZoom(currentZoom);
-  }
-
-
-   A_Rewind();
-   ADM_info(&quot; conf updated \n&quot;);
-   UI_setDecoderName(video_body-&gt;getVideoDecoderName());
-
-}
-
-//___________________________________________
-//  Append an AVI to the existing one
-//___________________________________________
-int
-A_appendAvi (const char *name)
-{
-
-
-  if (playing)
-    return 0;
-//  DIA_StartBusy ();
-  if (!video_body-&gt;addFile (name))
-    {
-//      DIA_StopBusy ();
-      GUI_Error_HIG (QT_TR_NOOP(&quot;Something failed when appending&quot;), NULL);
-      return 0;
-    }
-//  DIA_StopBusy ();
-
-
-//  video_body-&gt;dumpSeg ();
-  if (!video_body-&gt;updateVideoInfo (avifileinfo))
-    {
-      GUI_Error_HIG (QT_TR_NOOP(&quot;Something bad happened (II)&quot;), NULL);
-      return 0;
-    }
-
-  ReSync ();
-  A_ResetMarkers();
-  
-  return 1;
-}
-
-//
-//      Whenever a changed happened in the the stream, resync
-//  related infos including audio &amp; video filters
-
-void ReSync (void)
-{
-  uint8_t isaviaud;
-
-  // update audio stream
-  // If we were on avi , mark it...
-  GUI_setAllFrameAndTime ();
-
-}
-
-
-
-
-//      Clean up
-//      free all pending stuff, make leakchecker happy
-//
-void cleanUp (void)
-{
-	if (avifileinfo)
-	{
-		delete avifileinfo;
-		avifileinfo=NULL;
-	}
-	if (video_body)
-	{
-		delete video_body;
-		video_body=NULL;
-	}
-
-	currentaudiostream=NULL;
-//	filterCleanUp();
-	admPreview::cleanUp();
-}
-
-#warning fixme
-
-
-
-/**
-    \fn A_parseTinyPyScript
-*/
-bool A_parseTinyPyScript(const char *name){
-  bool ret;
-  ADM_info(&quot;Executing tinyPy script :%s\n&quot;,name);
-  char *longname = ADM_PathCanonize(name);
-   if (playing)
-   {
-        return false;
-   }
-   ret = parseTinyPyScript(longname);
-   A_Resync(); // total duration &amp; stuff
-   if( ret == true )
-   {
-      video_body-&gt;setProjectName(longname);
-   }
-   ADM_dealloc(longname);
-   return ret;
-}
-/**
-    \fn A_parseECMAScript
-*/
-bool A_parseECMAScript(const char *name){
-  bool ret;
-  char *longname = ADM_PathCanonize(name);
-   if (playing)
-    {
-      return false;
-   }
-   ret = parseECMAScript(longname);
-   A_Resync(); // total duration &amp; stuff
-   if( ret == true )
-   {
-      video_body-&gt;setProjectName(longname);
-   }
-   ADM_dealloc(longname);
-   return ret;
-}
-
-/*
-	Unpack all frames without displaying them to check for error
-
-*/
-void A_videoCheck( void)
-{
-#if 0
-uint32_t nb=0;
-//uint32_t buf[720*576*2];
-uint32_t error=0;
-ADMImage *aImage;
-DIA_workingBase *work;
-
-	nb = avifileinfo-&gt;nb_frames;
-	work=createWorking(QT_TR_NOOP(&quot;Checking video&quot;));
-	aImage=new ADMImage(avifileinfo-&gt;width,avifileinfo-&gt;height);
-  for(uint32_t i=0;i&lt;nb;i++)
-  {
-	work-&gt;update(i, nb);
-      	if(!work-&gt;isAlive()) break;
-	if(!GUI_getFrameContent (aImage,i))
-	{
-		error ++;
-		printf(&quot;Frame %u has error\n&quot;,i);
-	}
-
-    };
-  delete work;
-  delete aImage;
-  if(error==0)
-    GUI_Info_HIG(ADM_LOG_IMPORTANT,QT_TR_NOOP(&quot;No error found&quot;), NULL);
-else
-	{
-		char str[400];
-                sprintf(str,QT_TR_NOOP(&quot;Errors found in %u frames&quot;),error);
-		GUI_Info_HIG(ADM_LOG_IMPORTANT,str, NULL);
-
-	}
-	GUI_GoToFrame(0);
-#endif
-}
-int A_delete(uint32_t start, uint32_t end)
-{
-uint32_t count;
-
-      aviInfo info;
-      ADM_assert (video_body-&gt;getVideoInfo (&amp;info));
-      count = end - start;
-
-      if( end &lt; start ){
-        GUI_Error_HIG(QT_TR_NOOP(&quot;Marker A &gt; B&quot;), QT_TR_NOOP(&quot;Cannot delete the selection.&quot;));
-         return 0;
-      }
-      if (count &gt;= info.nb_frames - 1)
-	{
-          GUI_Error_HIG (QT_TR_NOOP(&quot;You can't remove all frames&quot;), NULL);
-	  return 0;
-	}
-
-//      video_body-&gt;dumpSeg ();
-//      if (!video_body-&gt;removeFrames (start, end))
-    if(0)
-	{
-          GUI_Error_HIG (QT_TR_NOOP(&quot;Something bad happened&quot;), NULL);
-	  return 0;
-	}
-//      video_body-&gt;dumpSeg ();
-      //resync GUI and video
-      if (!video_body-&gt;updateVideoInfo (avifileinfo))
-	{
-          GUI_Error_HIG (QT_TR_NOOP(&quot;Something bad happened (II)&quot;), NULL);
-	}
-
-
-      A_ResetMarkers();
-      GUI_setAllFrameAndTime ();
-      ReSync ();
-     return 1;
-
-
-
-}
-extern int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,bool *swap);
-//
-
-//
-void	A_setPostproc( void )
-{
-uint32_t type,strength;
-bool swap;
-	if(!avifileinfo) return;
-
-	video_body-&gt;getPostProc(&amp;type,&amp;strength,&amp;swap);
-
- 	if(DIA_getMPParams( &amp;type, &amp;strength,&amp;swap))
- 	{
-		video_body-&gt;setPostProc(type,strength,swap);
- 	}
-
-}
-extern const char *getStrFromAudioCodec( uint32_t codec);
-/**
-
-*/
-int A_setAudioTrack(int track)
-{
-        video_body-&gt;changeAudioStream(0,track);
-        return true;
-}
-/**
-      \fn A_audioTrack
-      \brief Allow to select audio track
-*/
-void A_audioTrack( void )
-{        
-        audioInfo *infos=NULL;
-        uint32_t nbAudioTracks,currentAudioTrack;
-        uint32_t newTrack;
-
-        if(!video_body-&gt;getAudioStreamsInfo(0,&amp;nbAudioTracks,&amp;infos)) return;
-        currentAudioTrack=video_body-&gt;getCurrentAudioStreamNumber(0);
-        newTrack=currentAudioTrack;
-        // Now build the list of embedded track
-#define MAX_AUDIO_TRACK 10
-#define MAX_AUDIO_TRACK_NAME 100
-        diaMenuEntryDynamic *sourceavitracks[MAX_AUDIO_TRACK];
-        char string[MAX_AUDIO_TRACK_NAME];
-        for(int i=0;i&lt;nbAudioTracks;i++)
-        {
-          sprintf(string,&quot;Audio track %d (%s, %d channels, %d kbit/s)&quot;,i,
-                        getStrFromAudioCodec(infos[i].encoding),
-                        infos[i].channels,infos[i].bitrate);
-           sourceavitracks[i]=new diaMenuEntryDynamic(i,string,NULL);
-        }
-         if(infos) delete [] infos;
-
-         diaElemMenuDynamic   sourceFromVideo(&amp;newTrack,QT_TR_NOOP(&quot;_Track from video:&quot;),nbAudioTracks,sourceavitracks);
-         diaElem *allWidgets[]={&amp;sourceFromVideo};
-
-         if( diaFactoryRun(QT_TR_NOOP(&quot;Main Audio Track&quot;),1,allWidgets))
-         {
-            if(newTrack!=currentAudioTrack)
-            {
-                    A_setAudioTrack(newTrack);
-            }
-        }
-      
-roger_and_out:
-         /* Clean up */
-         for(int i=0;i&lt;nbAudioTracks;i++)
-            delete sourceavitracks[i];
-        return;
-
-}
-/**
-        \fn A_externalAudioTrack
-        \brief Select external audio track (for 2nd track)
-*/
-void A_externalAudioTrack( void )
-{
-}
-/**
-    \fn A_Resync
-    \brief 
-*/
-void A_Resync(void)
-{
-        if(!avifileinfo) return;
-        GUI_setAllFrameAndTime();
-        UI_setMarkers (video_body-&gt;getMarkerAPts(),video_body-&gt;getMarkerBPts());
-}
-uint8_t  DIA_job_select(char **jobname, char **filename);
-void A_addJob(void)
-{
-        char *name=NULL,*fullname,*base,*final=NULL;
-
-        if(!DIA_job_select(&amp;name,&amp;final)) return;
-        if(!name || !final) return;
-        if(!*name || !*final) return;
-
-        base=ADM_getJobDir();
-        fullname=new char[strlen(name)+strlen(base)+2+4];
-
-        strcpy(fullname,base);
-        strcat(fullname,&quot;/&quot;);
-        strcat(fullname,name);
-        strcat(fullname,&quot;.js&quot;);
-
-        if(!video_body-&gt;saveAsScript(fullname,final))
-        {
-          GUI_Error_HIG(QT_TR_NOOP(&quot;Saving failed&quot;),QT_TR_NOOP(&quot;Saving the job failed. Maybe you have permission issue with ~/.avidemux&quot;));
-        }
-
-        delete [] fullname;
-        delete [] base;
-        ADM_dealloc(name);
-        ADM_dealloc(final);
-}
-/**
-    \fn GUI_GetScale
-    \brief Return the % of the scale, between 0 and ADM_SCALE_SIZE
-
-*/
-uint32_t GUI_GetScale(void)
-{
-
-    double  percent;
-    float tg;
-
-    percent = UI_readScale();
-    tg= ADM_SCALE_SIZE * percent / 100.;
-
-    return (uint32_t)floor(tg);;
-}
-/**
-    \fn GUI_SetScale
-    \brief Set the scale, input is between 0 and ADM_SCALE_SIZE (max)
-*/
-void     GUI_SetScale( uint32_t scale )
-{
-    double percent;
-    percent=scale;
-    percent/=ADM_SCALE_SIZE;
-    percent*=100;
-    UI_setScale(percent);
-}
-
-
-/**
-      \fn GUI_getFrameContent
-      \brief fill image with content of frame frame
-*/
-uint8_t GUI_getFrameContent(ADMImage *image, uint32_t frame)
-{
-//  uint32_t flags;
-//  if(!video_body-&gt;getUncompressedFrame(frame,image,&amp;flags)) return 0;
-  return 1;
-}
-/**
-    \fn GUI_close
-    \brief Close opened file and cleanup filters etc..
-*/
-uint8_t GUI_close(void)
-{
-  if (avifileinfo)		// already opened ?
-    {				// delete everything
-      // if preview is on
-      admPreview::setMainDimension(0, 0);
-      if(getPreviewMode()!=ADM_PREVIEW_NONE)
-      {
-        admPreview::stop();
-        setPreviewMode(ADM_PREVIEW_NONE);
-      }
-      delete avifileinfo;
-      //delete wavinfo;
-      
-      avifileinfo = NULL;
-      video_body-&gt;cleanup ();	  
-
-//      filterCleanUp ();
-	  UI_setTitle(NULL);
-
-      return 1;
-    }
-    return 0;
-}
-/**
-      \fn GUI_avsProxy
-      \brief Shortcut to connect to avsProxy
-*/
-
-void GUI_avsProxy(void)
-{
-  uint8_t res;
-
-
-  GUI_close();
-  res = video_body-&gt;addFile (AVS_PROXY_DUMMY_FILE);
-  // forget last project file
-  video_body-&gt;setProjectName(NULL);
-  if (res!=ADM_OK)			// an error occured
-    {
-        currentaudiostream = NULL;
-        avifileinfo = NULL;
-        GUI_Error_HIG (QT_TR_NOOP(&quot;AvsProxy&quot;), QT_TR_NOOP(&quot;Failed to connect to avsproxy.\nIs it running ?&quot;));
-        return ;
-    }
-
-       updateLoaded ();
-       UI_setTitle(QT_TR_NOOP(&quot;avsproxy&quot;));
-       return ;
-}
-/**
-      \fn GUI_showCurrentFrameHex
-      \brief Display the first 32 bytes of the current frame in hex
-*/
-
-void GUI_showCurrentFrameHex(void)
-{
- uint8_t *buffer;
- uint32_t fullLen,flags;
- char sType[5];
- char sSize[15];
- ADMCompressedImage image;
- uint8_t seq;
-#if 0
- if (!avifileinfo) return;
-
- buffer=new uint8_t [avifileinfo-&gt;width*avifileinfo-&gt;height*3];
- image.data=buffer;
-
-
- video_body-&gt;getFrame (video_body-&gt;getCurrentFrame(),&amp;image,&amp;seq);
- fullLen=image.dataLength;
- video_body-&gt;getFlags (video_body-&gt;getCurrentFrame(), &amp;flags);
-
- diaElemHex binhex(&quot;*****&quot;,fullLen,buffer);
-
- if(flags&amp;AVI_KEY_FRAME) sprintf(sType,&quot;I&quot;);
-  else if(flags&amp;AVI_B_FRAME) sprintf(sType,&quot;B&quot;);
-    else sprintf(sType,&quot;P&quot;);
- sprintf(sSize,&quot;%d bytes&quot;,fullLen);
-
- diaElemReadOnlyText Type(sType,QT_TR_NOOP(&quot;Frame type:&quot;));
- diaElemReadOnlyText Size(sSize,QT_TR_NOOP(&quot;Frame size:&quot;));
- diaElem *elems[]={&amp;Type,&amp;Size,&amp;binhex   };
- if(diaFactoryRun(QT_TR_NOOP(&quot;Frame Hex Dump&quot;),3,elems))
-
- delete [] buffer;
-#endif
-}
-/**
-    \fn GUI_showSize
-    \brief Show frame size
-
-*/
-#define DUMP_SIZE 30
-void GUI_showSize(void)
-{
-uint8_t *buffer;
- uint32_t fullLen,flags;
- ADMCompressedImage image;
- uint8_t seq;
- char                text[DUMP_SIZE][100];
- 
- if (!avifileinfo) return;
-#if 0
- buffer=new uint8_t [avifileinfo-&gt;width*avifileinfo-&gt;height*3];
- image.data=buffer;
-    for(int i=0;i&lt;DUMP_SIZE;i++)
-    {
-        int target=video_body-&gt;getCurrentFrame()+i;
-        video_body-&gt;getFlags ( target,&amp;flags);
-        video_body-&gt;getFrame ( target,&amp;image,&amp;seq);
-        fullLen=image.dataLength;
-        sprintf(text[i],&quot;Frame %d:%d&quot;,target,fullLen);
-        printf(&quot;%s\n&quot;,text[i]);
-    }
- 
-
-
- 
- delete [] buffer;
- #endif
-}
-
-/**
- *      \fn UI_getPreferredRender
- *      \brief Returns to render lib the user preferred rendering method
- *
- */
-ADM_RENDER_TYPE UI_getPreferredRender(void)
-{
-  char *displ;
-  unsigned int renderI;
-  ADM_RENDER_TYPE render;
-
-#if !defined __WIN32 &amp;&amp; !defined(__APPLE__)
-        // First check if local
-        // We do it in a very wrong way : If DISPLAY!=:0.0 we assume remote display
-        // in that case we do not even try to use accel
-
-        // Win32 and Mac/Qt4 don't have DISPLAY
-        displ=getenv(&quot;DISPLAY&quot;);
-        if(!displ)
-        {
-                return RENDER_GTK;
-        }
-        if(strcmp(displ,&quot;:0&quot;) &amp;&amp; strcmp(displ,&quot;:0.0&quot;))
-        {
-                printf(&quot;Looks like remote display, no Xv :%s\n&quot;,displ);
-                return RENDER_GTK;
-        }
-#endif
-
-        if(prefs-&gt;get(VIDEODEVICE,&amp;renderI)!=RC_OK)
-        {
-                render=RENDER_GTK;
-        }else
-        {
-                render=(ADM_RENDER_TYPE)renderI;
-        }
-
-        return render;
-}
-
-/**
-    \fn A_ResetMarkers
-*/
-void A_ResetMarkers(void)
-{
-uint64_t duration=video_body-&gt;getVideoDuration();
-        ADM_info(&quot;Video Total duration : %s ms\n&quot;,ADM_us2plain(duration));
-        video_body-&gt;setMarkerAPts(0);
-        video_body-&gt;setMarkerBPts(duration);
-        UI_setMarkers(0,duration);
-        
-}
-/**
-    \fn A_Rewind
-    \brief Go back to the first frame
-*/
-void A_Rewind(void)
-{
-               video_body-&gt;rewind();
-               admPreview::samePicture();
-               GUI_setCurrentFrameAndTime();
-}
-void brokenAct(void)
-{
-    GUI_Error_HIG(&quot;Oops&quot;,&quot;This function is disabled or no longer valid&quot;);
-}
-
-//
-// EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/gui_main.cpp (from rev 7305, branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_main.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_main.cpp	2011-07-06 05:19:53 UTC (rev 7306)
@@ -0,0 +1,1187 @@
+/***************************************************************************
+                          \file gtk_gui.cpp  
+                          \brief Main UI even loop
+                             
+    copyright            : (C) 2001-2009 by mean, <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_cpp.h&quot;
+#include &quot;ADM_default.h&quot;
+#include &lt;math.h&gt;
+#include &lt;errno.h&gt;
+
+#include &quot;fourcc.h&quot;
+
+#include &quot;DIA_fileSel.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+
+#include &quot;gui_action.hxx&quot;
+#include &quot;gtkgui.h&quot;
+
+#include &quot;prefs.h&quot;
+#include &quot;ADM_render/GUI_render.h&quot;
+#include &quot;ADM_commonUI/GUI_ui.h&quot;
+
+#include &quot;DIA_working.h&quot;
+#include &quot;DIA_factory.h&quot;
+
+#include &quot;ADM_vidMisc.h&quot;
+#include &quot;ADM_preview.h&quot;
+#include &quot;ADM_coreVideoEncoder.h&quot;
+#include &quot;ADM_videoEncoderApi.h&quot;
+#include &quot;ADM_audioFilter/include/ADM_audioFilterInterface.h&quot;
+
+#include &quot;avi_vars.h&quot;
+#include &quot;prototype.h&quot; // FIXME
+#include &quot;ADM_script2/include/ADM_scriptIf.h&quot;
+renderZoom currentZoom=ZOOM_1_1;
+//***********************************
+//******** A Function ***************
+//***********************************
+#include &quot;A_functions.h&quot;
+//***********************************
+//******** GUI Function**************
+//***********************************
+
+extern uint8_t UI_getPhysicalScreenSize(void* window, uint32_t *w,uint32_t *h);
+extern uint8_t GUI_jobs(void);
+extern const char * GUI_getCustomJsScript(uint32_t nb);
+extern const char * GUI_getCustomPyScript(uint32_t nb);
+extern const char * GUI_getAutoPyScript(uint32_t nb);
+
+extern uint8_t GUI_getFrameContent(ADMImage *image, uint32_t frame);
+extern int     GUI_handleVFilter (void);
+extern void    GUI_setMarks (uint32_t a, uint32_t b);
+extern void    GUI_displayBitrate( void );
+// Debug functions
+       void    GUI_showCurrentFrameHex(void);
+       void    GUI_showSize(void);
+
+       void    GUI_avsProxy(void);
+       uint8_t GUI_close(void);
+extern int     GUI_GoToFrame(uint32_t frame);;
+extern bool    GUI_GoToTime(uint64_t time);
+//***********************************
+//******** DIA Function**************
+//***********************************
+extern uint8_t DIA_about( void );
+extern void    DIA_properties( void);
+extern uint8_t DIA_Preferences(void);
+extern uint8_t DIA_gotoTime(uint16_t *hh, uint32_t *mm, uint32_t *ss);
+extern uint8_t DIA_builtin(void);
+extern void    DIA_Calculator(uint32_t *sizeInMeg, uint32_t *avgBitrate );
+extern uint8_t DIA_pluginsInfo(void);
+
+extern void filterCleanUp (void);
+static void ReSync (void);
+static void cleanUp (void);
+void        updateLoaded (void);
+extern void encoderSetLogFile (char *name);
+extern void videoCodecConfigureUI(int codecIndex = -1);
+extern void audioCodecChanged(int newcodec);
+extern void videoCodecChanged(int newcodec);
+extern bool ADM_mux_configure(int index);
+void brokenAct(void);
+//
+//  Sub gui files...
+//
+void HandleAction (Action action);
+void HandleAction_Navigate(Action action);
+void HandleAction_Save(Action action);
+
+
+//
+//
+/**
+    \fn HandleAction
+    \brief  serialization of user event through gui
+
+*/
+typedef  const char * (*getName)(uint32_t nb);
+bool getScriptName(int action, int base,getName name,const char *ext,string &amp;out )
+{
+    if(action&lt;base) return false;
+    action=action-base;
+    const char *p=name(action);
+    if(!p) return false;
+    out=string(p)+string(&quot;.&quot;)+string(ext);
+    return true;
+}
+void HandleAction (Action action)
+{
+  uint32_t nf = 0;
+  uint32_t old;
+
+  ADM_warning(&quot;************ %s **************\n&quot;,getActionName(action));
+
+  // handle out of band actions
+  // independant load not loaded
+//------------------------------------------------
+int nw;
+  if(action&gt;=ACT_CUSTOM_BASE_JS &amp;&amp; action &lt;ACT_CUSTOM_END_JS)
+  {
+      string script;
+      if(true==getScriptName( action, ACT_CUSTOM_BASE_JS,GUI_getCustomJsScript,&quot;js&quot;,script))
+      {
+            A_parseECMAScript(script.c_str());
+      }
+      return ;
+  }
+  if(action&gt;=ACT_CUSTOM_BASE_PY &amp;&amp; action &lt;ACT_CUSTOM_END_PY)
+  {
+      string script;
+      if(true==getScriptName( action, ACT_CUSTOM_BASE_PY,GUI_getCustomPyScript,&quot;py&quot;,script))
+      {
+            A_parseTinyPyScript(script.c_str());      
+      }
+      return ;
+  }
+  if(action&gt;=ACT_AUTO_BASE_PY &amp;&amp; action &lt;ACT_AUTO_END_PY)
+  {
+      string script;
+      if(true==getScriptName( action, ACT_AUTO_BASE_PY,GUI_getAutoPyScript,&quot;py&quot;,script))
+      {
+            A_parseTinyPyScript(script.c_str());
+      }
+      return ;
+  }
+  switch (action)
+    {
+        case ACT_TimeShift:
+        case ACT_Goto:
+                                brokenAct();
+                                return;
+        case ACT_PY_SHELL:
+                                interactiveTinyPy();
+                                return;
+        case ACT_JS_SHELL:
+                                interactiveECMAScript(&quot;dummy&quot;);
+                                return;
+        case ACT_AVS_PROXY:
+                                GUI_avsProxy();
+                                return;
+        case ACT_BUILT_IN:
+                                DIA_builtin();
+                                return;
+        case ACT_RECENT0:
+        case ACT_RECENT1:
+        case ACT_RECENT2:
+        case ACT_RECENT3:
+                const char **name;
+                int rank;
+
+                name=prefs-&gt;get_lastfiles();
+                rank=(int)action-ACT_RECENT0;
+                ADM_assert(name[rank]);
+                A_openAvi (name[rank]);
+                return;
+		return;
+	case ACT_VIDEO_CODEC_CONFIGURE:
+    		videoEncoder6Configure();
+            return;
+    case ACT_ContainerConfigure:    
+            {
+            int index=UI_GetCurrentFormat();
+            ADM_mux_configure(index);
+            return;
+            }
+    case ACT_VIDEO_CODEC_CHANGED:
+    		nw=UI_getCurrentVCodec();
+    		videoEncoder6_SetCurrentEncoder(nw);
+            return;
+   case ACT_AUDIO_CODEC_CHANGED:
+            nw=UI_getCurrentACodec();
+            audioCodecSetByIndex(nw);
+            return;
+    case ACT_PLUGIN_INFO:
+            DIA_pluginsInfo();
+            return;
+    case ACT_RUN_PY_PROJECT:
+            GUI_FileSelRead (QT_TR_NOOP(&quot;Select python script to Run&quot;),(SELFILE_CB *) A_parseTinyPyScript);
+    		return;
+    case ACT_RUN_JS_PROJECT:
+            GUI_FileSelRead (QT_TR_NOOP(&quot;Select ECMAScript to Run&quot;),(SELFILE_CB *) A_parseECMAScript);
+    		return;
+
+    case ACT_ABOUT :
+    		 DIA_about( );
+		 return;
+    case ACT_AUDIO_CODEC_CONFIGURE:
+      audioCodecConfigure();
+      return;
+    case ACT_AUDIO_FILTERS:
+      audioFilterConfigure();
+      return;
+    case ACT_PREFERENCES:
+        if(playing) return;
+    	if(DIA_Preferences())
+        {
+            prefs-&gt;save ();
+        }
+        return;
+    case ACT_SavePref:
+        prefs-&gt;save ();
+        return;
+    case ACT_EXIT:
+      { bool saveprefsonexit;
+         prefs-&gt;get(FEATURES_SAVEPREFSONEXIT,&amp;saveprefsonexit);
+         if( saveprefsonexit )
+            prefs-&gt;save ();
+      }
+      cleanUp ();
+      exit (0);
+      break;
+    default:
+      break;
+
+    }
+
+  if (playing)			// only allow some action
+    {
+      switch (action)
+        {
+        case ACT_PlayAvi:
+        case ACT_StopAvi:
+          break;
+        default:
+          return;
+        }
+    }
+  // not playing,
+  // restict disabled uncoded actions
+  if ((int) action &gt;= ACT_DUMMY)
+    {
+      GUI_Error_HIG (QT_TR_NOOP(&quot;Not coded in this version&quot;), NULL);
+      return;
+    }
+  // allow only if avi loaded
+  if (!avifileinfo)
+    {
+      switch (action)
+        {
+          case ACT_JOG:
+                break;
+          case ACT_OPEN_VIDEO:
+                GUI_FileSelRead (QT_TR_NOOP(&quot;Select AVI File...&quot;), (SELFILE_CB *)A_openAvi);
+                break;
+          default:
+            break;
+        }
+        return;
+    }
+
+  // Dispatch actions, we have a file loaded
+  if(action&gt;ACT_NAVIGATE_BEGIN &amp;&amp; action &lt; ACT_NAVIGATE_END)
+  {
+    return HandleAction_Navigate(action);
+  }
+  if(action&gt;ACT_SAVE_BEGIN &amp;&amp; action &lt; ACT_SAVE_END)
+  {
+    return HandleAction_Save(action);
+  }
+
+  switch (action)
+    {
+       case ACT_JOG:
+                A_jog();
+                break;
+
+       case ACT_CLOSE:
+              GUI_close();
+              break;
+
+        case ACT_ZOOM_1_4:
+        case ACT_ZOOM_1_2:
+        case ACT_ZOOM_1_1:
+        case ACT_ZOOM_2_1:
+        case ACT_ZOOM_4_1:
+                currentZoom=(renderZoom)((action-ACT_ZOOM_1_4)+ZOOM_1_4);
+                changePreviewZoom(currentZoom);
+                admPreview::samePicture();
+                break;
+        case ACT_AUDIO_SELECT_TRACK:
+                A_audioTrack();
+                break;
+
+    case ACT_OPEN_VIDEO:
+        GUI_FileSelRead (QT_TR_NOOP(&quot;Select AVI File...&quot;),(SELFILE_CB *) A_openAvi);
+        break;
+    case ACT_APPEND_VIDEO:
+        GUI_FileSelRead (QT_TR_NOOP(&quot;Select AVI File to Append...&quot;),(SELFILE_CB *) A_appendAvi);
+        break;
+    case ACT_VIDEO_PROPERTIES:
+        DIA_properties ();
+        break;
+    case ACT_PlayAvi:
+      GUI_PlayAvi ();
+      break;
+  
+#define TOGGLE_PREVIEW ADM_PREVIEW_OUTPUT
+    case ACT_PreviewChanged:
+    {
+        ADM_PREVIEW_MODE oldpreview=getPreviewMode(),newpreview=(ADM_PREVIEW_MODE)UI_getCurrentPreview();
+          printf(&quot;Old preview %d, New preview mode : %d\n&quot;,oldpreview,newpreview);
+
+          if(oldpreview==newpreview)
+          {
+            return;
+          }
+            admPreview::stop();
+            setPreviewMode(newpreview);
+            admPreview::start();
+//            admPreview::update(curframe);
+      }
+      break;
+    case ACT_StopAvi:
+      if (playing)
+	GUI_PlayAvi ();
+      break;
+    case ACT_SetPostProcessing:
+      A_setPostproc();
+      break;
+    case ACT_MarkA:
+    case ACT_MarkB:
+    {
+      bool swapit=0;
+      uint64_t markA,markB;
+      uint64_t pts=admPreview::getCurrentPts();
+      if( prefs-&gt;get(FEATURES_SWAP_IF_A_GREATER_THAN_B, &amp;swapit) != RC_OK )     swapit = 1;
+
+      markA=video_body-&gt;getMarkerAPts();
+      markB=video_body-&gt;getMarkerBPts();
+      if (action == ACT_MarkA)
+            markA=pts;
+      else
+            markB=pts;
+      if (markA&gt;markB &amp;&amp; swapit )	// auto swap
+        {
+          uint64_t y;
+          y = markA;
+          markA=markB;
+          markB=y;
+        }
+        video_body-&gt;setMarkerAPts(markA);
+        video_body-&gt;setMarkerBPts(markB);
+        UI_setMarkers (markA, markB);
+      break;
+    }
+    case ACT_Copy:
+            brokenAct();
+//    		   video_body-&gt;copyToClipBoard (frameStart,frameEnd);
+		break;
+    case ACT_Paste:
+            brokenAct();        		
+            break;
+      break;
+
+    case ACT_ResetSegments:
+       if(avifileinfo)
+         if(GUI_Question(QT_TR_NOOP(&quot;Are you sure?&quot;)))
+        {
+            video_body-&gt;resetSeg();
+            video_body-&gt;getVideoInfo (avifileinfo);
+		
+      		GUI_setAllFrameAndTime ();
+            A_ResetMarkers();
+      		ReSync ();
+
+            // forget last project file
+            video_body-&gt;setProjectName(&quot;&quot;);
+        }
+	break;
+
+    case ACT_Delete:
+    case ACT_Cut:
+        {
+            uint64_t a=video_body-&gt;getMarkerAPts();
+            uint64_t b=video_body-&gt;getMarkerBPts();
+            if(false==video_body-&gt;remove(a,b))
+            {
+                GUI_Error_HIG(&quot;Cutting&quot;,&quot;Error while cutting out.&quot;);
+            }
+            else    
+            {
+              A_ResetMarkers();              
+              A_Resync(); // total duration &amp; stuff
+              // Rewind to first frame...
+              //A_Rewind();
+              GUI_GoToTime(a);
+                
+            }
+        }
+        
+      break;
+      // set decoder option (post processing ...)
+    case ACT_DecoderOption:
+      video_body-&gt;setDecodeParam ( admPreview::getCurrentPts());
+
+      break;
+    case ACT_VIDEO_FILTERS:
+        GUI_handleVFilter();
+        break;
+
+   case ACT_HEX_DUMP:
+      GUI_showCurrentFrameHex();
+      break;
+   case ACT_SIZE_DUMP:
+      GUI_showSize();
+      break;
+    default:
+      printf (&quot;\n unhandled action %d\n&quot;, action);
+      ADM_assert (0);
+      return;
+
+    }
+}
+
+//_____________________________________________________________
+//
+// Open AVI File
+//    mode 0: normal
+//    mode 1: Suspicious
+//_____________________________________________________________
+
+extern void GUI_PreviewEnd (void);
+/**
+        \fn A_openAvi
+        \brief Open (replace mode) a video
+*/
+int A_openAvi (const char *name)
+{
+  uint8_t res;
+  char *longname;
+  uint32_t magic[4];
+  uint32_t id = 0;
+
+  if (playing)
+    return 0;
+  /// check if name exists
+  FILE *fd;
+  fd = ADM_fopen (name, &quot;rb&quot;);
+  if (!fd){
+    if( errno == EACCES ){
+      GUI_Error_HIG(QT_TR_NOOP(&quot;Permission error&quot;), QT_TR_NOOP(&quot;Cannot open \&quot;%s\&quot;.&quot;), name);
+    }
+    if( errno == ENOENT ){
+      GUI_Error_HIG(QT_TR_NOOP(&quot;File error&quot;), QT_TR_NOOP(&quot;\&quot;%s\&quot; does not exist.&quot;), name);
+    }
+    return 0;
+  }
+  if( 4 == fread(magic,4,4,fd) )
+     id=R32(magic[0]);
+  fclose (fd);
+
+
+  GUI_close(); // Cleanup
+
+//  DIA_StartBusy ();
+  /*
+  ** we may get a relative path by cmdline
+  */
+  longname = ADM_PathCanonize(name);
+  res = video_body-&gt;addFile (longname);
+//  DIA_StopBusy ();
+
+  // forget last project file
+    video_body-&gt;setProjectName(&quot;&quot;);
+
+  if (res!=ADM_OK)			// an error occured
+    {
+		delete[] longname;
+    	if(ADM_IGN==res)
+	{
+		return 0;
+	}
+
+	if( fourCC::check(id,(uint8_t *)&quot;//AD&quot;) ){
+          GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot open project using the video loader.&quot;),
+                        QT_TR_NOOP(  &quot;Try 'File' -&gt; 'Load/Run Project...'&quot;));
+	}else{
+          GUI_Error_HIG (QT_TR_NOOP(&quot;Could not open the file&quot;), NULL);
+	}
+	return 0;
+    }
+
+    { int i;
+      FILE *fd=NULL;
+      char magic[4];
+
+	/* check myself it is a project file (transparent detected and read
+        ** by video_body-&gt;addFile (name);
+	*/
+#warning FIXME
+#if 0
+	if( (fd = ADM_fopen(longname,&quot;rb&quot;))  ){
+		if( fread(magic,4,1,fd) == 4 ){
+			/* remember a workbench file */
+			if( !strncmp(magic,&quot;ADMW&quot;,4) ){
+				actual_workbench_file = ADM_strdup(longname);
+			}
+		}
+		fclose(fd);
+	}
+#endif
+	/* remember any video or workbench file to &quot;recent&quot; */
+        prefs-&gt;set_lastfile(longname);
+        UI_updateRecentMenu();
+        updateLoaded ();
+        if(currentaudiostream)
+        {
+            uint32_t nbAudio;
+            audioInfo *infos=NULL;
+            if(video_body-&gt;getAudioStreamsInfo(admPreview::getCurrentPts()+1,&amp;nbAudio,&amp;infos))
+            {
+                if(nbAudio&gt;1)
+                {   // Multiple track warn user
+                  GUI_Info_HIG(ADM_LOG_INFO,QT_TR_NOOP(&quot;Multiple Audio Tracks&quot;),QT_TR_NOOP(&quot;The file you just loaded contains several audio tracks.\n&quot;
+                      &quot;Go to Audio-&gt;MainTrack to select the active one.&quot;));
+                }
+            }
+            if(infos) delete [] infos;
+            // Revert mixer to copy
+            //setCurrentMixerFromString(&quot;NONE&quot;);
+            audioFilterSetMixer(CHANNEL_INVALID);
+        }
+	for(i=strlen(longname);i&gt;=0;i--)
+    {
+#ifdef __WIN32
+		if( longname[i] == '\\' || longname[i] == '/' )
+#else
+		if( longname[i] == '/' )
+#endif
+        {
+
+			i++;
+			break;
+		}
+    }
+	UI_setTitle(longname+i);
+    }
+
+	delete[] longname;
+	return 1;
+}
+/**
+    \fn updateLoaded
+    \brief update the UI after loading a file
+
+*/
+void  updateLoaded ()
+{
+  avifileinfo = new aviInfo;
+  if (!video_body-&gt;getVideoInfo (avifileinfo))
+    {
+//      err1:
+      printf (&quot;\n get info failed...cancelling load...\n&quot;);
+      delete avifileinfo;
+      avifileinfo = NULL;
+
+      return;
+    }
+
+
+//  getFirstVideoFilter(); // reinit first filter
+
+  // now get audio information if exists
+  WAVHeader *wavinfo;
+  wavinfo = video_body-&gt;getInfo ();	//wavinfo); // will be null if no audio
+  if (!wavinfo)
+    {
+      printf (&quot;\n *** NO AUDIO ***\n&quot;);
+      wavinfo = (WAVHeader *) NULL;
+    }
+
+  // Init renderer
+    admPreview::setMainDimension(avifileinfo-&gt;width, avifileinfo-&gt;height);
+
+
+  // Draw first frame
+  GUI_setAllFrameAndTime();
+  A_ResetMarkers();
+//  getFirstVideoFilter(); // Rebuild filter if needed
+
+  /* Zoom out if needed */
+  uint32_t phyW,phyH;
+  UI_getPhysicalScreenSize(NULL, &amp;phyW,&amp;phyH);
+  if(3*phyW&lt;4*avifileinfo-&gt;width || 3*phyH&lt;4*avifileinfo-&gt;height)
+  {
+      if(phyW&lt;avifileinfo-&gt;width/2 || phyH&lt;avifileinfo-&gt;height/2)
+      {
+                currentZoom=ZOOM_1_4;
+      }else
+      {
+                currentZoom=ZOOM_1_2;
+      }
+     changePreviewZoom(currentZoom);
+  }
+  else
+  {
+      currentZoom=ZOOM_1_1;
+      changePreviewZoom(currentZoom);
+  }
+
+
+   A_Rewind();
+   ADM_info(&quot; conf updated \n&quot;);
+   UI_setDecoderName(video_body-&gt;getVideoDecoderName());
+
+}
+
+//___________________________________________
+//  Append an AVI to the existing one
+//___________________________________________
+int
+A_appendAvi (const char *name)
+{
+
+
+  if (playing)
+    return 0;
+//  DIA_StartBusy ();
+  if (!video_body-&gt;addFile (name))
+    {
+//      DIA_StopBusy ();
+      GUI_Error_HIG (QT_TR_NOOP(&quot;Something failed when appending&quot;), NULL);
+      return 0;
+    }
+//  DIA_StopBusy ();
+
+
+//  video_body-&gt;dumpSeg ();
+  if (!video_body-&gt;updateVideoInfo (avifileinfo))
+    {
+      GUI_Error_HIG (QT_TR_NOOP(&quot;Something bad happened (II)&quot;), NULL);
+      return 0;
+    }
+
+  ReSync ();
+  A_ResetMarkers();
+  
+  return 1;
+}
+
+//
+//      Whenever a changed happened in the the stream, resync
+//  related infos including audio &amp; video filters
+
+void ReSync (void)
+{
+  uint8_t isaviaud;
+
+  // update audio stream
+  // If we were on avi , mark it...
+  GUI_setAllFrameAndTime ();
+
+}
+
+
+
+
+//      Clean up
+//      free all pending stuff, make leakchecker happy
+//
+void cleanUp (void)
+{
+	if (avifileinfo)
+	{
+		delete avifileinfo;
+		avifileinfo=NULL;
+	}
+	if (video_body)
+	{
+		delete video_body;
+		video_body=NULL;
+	}
+
+	currentaudiostream=NULL;
+//	filterCleanUp();
+	admPreview::cleanUp();
+}
+
+#warning fixme
+
+
+
+/**
+    \fn A_parseTinyPyScript
+*/
+bool A_parseTinyPyScript(const char *name){
+  bool ret;
+  ADM_info(&quot;Executing tinyPy script :%s\n&quot;,name);
+  char *longname = ADM_PathCanonize(name);
+   if (playing)
+   {
+        return false;
+   }
+   ret = parseTinyPyScript(longname);
+   A_Resync(); // total duration &amp; stuff
+   if( ret == true )
+   {
+      video_body-&gt;setProjectName(longname);
+   }
+   ADM_dealloc(longname);
+   return ret;
+}
+/**
+    \fn A_parseECMAScript
+*/
+bool A_parseECMAScript(const char *name){
+  bool ret;
+  char *longname = ADM_PathCanonize(name);
+   if (playing)
+    {
+      return false;
+   }
+   ret = parseECMAScript(longname);
+   A_Resync(); // total duration &amp; stuff
+   if( ret == true )
+   {
+      video_body-&gt;setProjectName(longname);
+   }
+   ADM_dealloc(longname);
+   return ret;
+}
+
+/*
+	Unpack all frames without displaying them to check for error
+
+*/
+void A_videoCheck( void)
+{
+#if 0
+uint32_t nb=0;
+//uint32_t buf[720*576*2];
+uint32_t error=0;
+ADMImage *aImage;
+DIA_workingBase *work;
+
+	nb = avifileinfo-&gt;nb_frames;
+	work=createWorking(QT_TR_NOOP(&quot;Checking video&quot;));
+	aImage=new ADMImage(avifileinfo-&gt;width,avifileinfo-&gt;height);
+  for(uint32_t i=0;i&lt;nb;i++)
+  {
+	work-&gt;update(i, nb);
+      	if(!work-&gt;isAlive()) break;
+	if(!GUI_getFrameContent (aImage,i))
+	{
+		error ++;
+		printf(&quot;Frame %u has error\n&quot;,i);
+	}
+
+    };
+  delete work;
+  delete aImage;
+  if(error==0)
+    GUI_Info_HIG(ADM_LOG_IMPORTANT,QT_TR_NOOP(&quot;No error found&quot;), NULL);
+else
+	{
+		char str[400];
+                sprintf(str,QT_TR_NOOP(&quot;Errors found in %u frames&quot;),error);
+		GUI_Info_HIG(ADM_LOG_IMPORTANT,str, NULL);
+
+	}
+	GUI_GoToFrame(0);
+#endif
+}
+int A_delete(uint32_t start, uint32_t end)
+{
+uint32_t count;
+
+      aviInfo info;
+      ADM_assert (video_body-&gt;getVideoInfo (&amp;info));
+      count = end - start;
+
+      if( end &lt; start ){
+        GUI_Error_HIG(QT_TR_NOOP(&quot;Marker A &gt; B&quot;), QT_TR_NOOP(&quot;Cannot delete the selection.&quot;));
+         return 0;
+      }
+      if (count &gt;= info.nb_frames - 1)
+	{
+          GUI_Error_HIG (QT_TR_NOOP(&quot;You can't remove all frames&quot;), NULL);
+	  return 0;
+	}
+
+//      video_body-&gt;dumpSeg ();
+//      if (!video_body-&gt;removeFrames (start, end))
+    if(0)
+	{
+          GUI_Error_HIG (QT_TR_NOOP(&quot;Something bad happened&quot;), NULL);
+	  return 0;
+	}
+//      video_body-&gt;dumpSeg ();
+      //resync GUI and video
+      if (!video_body-&gt;updateVideoInfo (avifileinfo))
+	{
+          GUI_Error_HIG (QT_TR_NOOP(&quot;Something bad happened (II)&quot;), NULL);
+	}
+
+
+      A_ResetMarkers();
+      GUI_setAllFrameAndTime ();
+      ReSync ();
+     return 1;
+
+
+
+}
+extern int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,bool *swap);
+//
+
+//
+void	A_setPostproc( void )
+{
+uint32_t type,strength;
+bool swap;
+	if(!avifileinfo) return;
+
+	video_body-&gt;getPostProc(&amp;type,&amp;strength,&amp;swap);
+
+ 	if(DIA_getMPParams( &amp;type, &amp;strength,&amp;swap))
+ 	{
+		video_body-&gt;setPostProc(type,strength,swap);
+ 	}
+
+}
+extern const char *getStrFromAudioCodec( uint32_t codec);
+/**
+
+*/
+int A_setAudioTrack(int track)
+{
+        video_body-&gt;changeAudioStream(0,track);
+        return true;
+}
+/**
+      \fn A_audioTrack
+      \brief Allow to select audio track
+*/
+void A_audioTrack( void )
+{        
+        audioInfo *infos=NULL;
+        uint32_t nbAudioTracks,currentAudioTrack;
+        uint32_t newTrack;
+
+        if(!video_body-&gt;getAudioStreamsInfo(0,&amp;nbAudioTracks,&amp;infos)) return;
+        currentAudioTrack=video_body-&gt;getCurrentAudioStreamNumber(0);
+        newTrack=currentAudioTrack;
+        // Now build the list of embedded track
+#define MAX_AUDIO_TRACK 10
+#define MAX_AUDIO_TRACK_NAME 100
+        diaMenuEntryDynamic *sourceavitracks[MAX_AUDIO_TRACK];
+        char string[MAX_AUDIO_TRACK_NAME];
+        for(int i=0;i&lt;nbAudioTracks;i++)
+        {
+          sprintf(string,&quot;Audio track %d (%s, %d channels, %d kbit/s)&quot;,i,
+                        getStrFromAudioCodec(infos[i].encoding),
+                        infos[i].channels,infos[i].bitrate);
+           sourceavitracks[i]=new diaMenuEntryDynamic(i,string,NULL);
+        }
+         if(infos) delete [] infos;
+
+         diaElemMenuDynamic   sourceFromVideo(&amp;newTrack,QT_TR_NOOP(&quot;_Track from video:&quot;),nbAudioTracks,sourceavitracks);
+         diaElem *allWidgets[]={&amp;sourceFromVideo};
+
+         if( diaFactoryRun(QT_TR_NOOP(&quot;Main Audio Track&quot;),1,allWidgets))
+         {
+            if(newTrack!=currentAudioTrack)
+            {
+                    A_setAudioTrack(newTrack);
+            }
+        }
+      
+roger_and_out:
+         /* Clean up */
+         for(int i=0;i&lt;nbAudioTracks;i++)
+            delete sourceavitracks[i];
+        return;
+
+}
+/**
+        \fn A_externalAudioTrack
+        \brief Select external audio track (for 2nd track)
+*/
+void A_externalAudioTrack( void )
+{
+}
+/**
+    \fn A_Resync
+    \brief 
+*/
+void A_Resync(void)
+{
+        if(!avifileinfo) return;
+        GUI_setAllFrameAndTime();
+        UI_setMarkers (video_body-&gt;getMarkerAPts(),video_body-&gt;getMarkerBPts());
+}
+uint8_t  DIA_job_select(char **jobname, char **filename);
+void A_addJob(void)
+{
+        char *name=NULL,*fullname,*base,*final=NULL;
+
+        if(!DIA_job_select(&amp;name,&amp;final)) return;
+        if(!name || !final) return;
+        if(!*name || !*final) return;
+
+        base=ADM_getJobDir();
+        fullname=new char[strlen(name)+strlen(base)+2+4];
+
+        strcpy(fullname,base);
+        strcat(fullname,&quot;/&quot;);
+        strcat(fullname,name);
+        strcat(fullname,&quot;.js&quot;);
+
+        if(!video_body-&gt;saveAsScript(fullname,final))
+        {
+          GUI_Error_HIG(QT_TR_NOOP(&quot;Saving failed&quot;),QT_TR_NOOP(&quot;Saving the job failed. Maybe you have permission issue with ~/.avidemux&quot;));
+        }
+
+        delete [] fullname;
+        delete [] base;
+        ADM_dealloc(name);
+        ADM_dealloc(final);
+}
+/**
+    \fn GUI_GetScale
+    \brief Return the % of the scale, between 0 and ADM_SCALE_SIZE
+
+*/
+uint32_t GUI_GetScale(void)
+{
+
+    double  percent;
+    float tg;
+
+    percent = UI_readScale();
+    tg= ADM_SCALE_SIZE * percent / 100.;
+
+    return (uint32_t)floor(tg);;
+}
+/**
+    \fn GUI_SetScale
+    \brief Set the scale, input is between 0 and ADM_SCALE_SIZE (max)
+*/
+void     GUI_SetScale( uint32_t scale )
+{
+    double percent;
+    percent=scale;
+    percent/=ADM_SCALE_SIZE;
+    percent*=100;
+    UI_setScale(percent);
+}
+
+
+/**
+      \fn GUI_getFrameContent
+      \brief fill image with content of frame frame
+*/
+uint8_t GUI_getFrameContent(ADMImage *image, uint32_t frame)
+{
+//  uint32_t flags;
+//  if(!video_body-&gt;getUncompressedFrame(frame,image,&amp;flags)) return 0;
+  return 1;
+}
+/**
+    \fn GUI_close
+    \brief Close opened file and cleanup filters etc..
+*/
+uint8_t GUI_close(void)
+{
+  if (avifileinfo)		// already opened ?
+    {				// delete everything
+      // if preview is on
+      admPreview::setMainDimension(0, 0);
+      if(getPreviewMode()!=ADM_PREVIEW_NONE)
+      {
+        admPreview::stop();
+        setPreviewMode(ADM_PREVIEW_NONE);
+      }
+      delete avifileinfo;
+      //delete wavinfo;
+      
+      avifileinfo = NULL;
+      video_body-&gt;cleanup ();	  
+
+//      filterCleanUp ();
+	  UI_setTitle(NULL);
+
+      return 1;
+    }
+    return 0;
+}
+/**
+      \fn GUI_avsProxy
+      \brief Shortcut to connect to avsProxy
+*/
+
+void GUI_avsProxy(void)
+{
+  uint8_t res;
+
+
+  GUI_close();
+  res = video_body-&gt;addFile (AVS_PROXY_DUMMY_FILE);
+  // forget last project file
+  video_body-&gt;setProjectName(NULL);
+  if (res!=ADM_OK)			// an error occured
+    {
+        currentaudiostream = NULL;
+        avifileinfo = NULL;
+        GUI_Error_HIG (QT_TR_NOOP(&quot;AvsProxy&quot;), QT_TR_NOOP(&quot;Failed to connect to avsproxy.\nIs it running ?&quot;));
+        return ;
+    }
+
+       updateLoaded ();
+       UI_setTitle(QT_TR_NOOP(&quot;avsproxy&quot;));
+       return ;
+}
+/**
+      \fn GUI_showCurrentFrameHex
+      \brief Display the first 32 bytes of the current frame in hex
+*/
+
+void GUI_showCurrentFrameHex(void)
+{
+ uint8_t *buffer;
+ uint32_t fullLen,flags;
+ char sType[5];
+ char sSize[15];
+ ADMCompressedImage image;
+ uint8_t seq;
+#if 0
+ if (!avifileinfo) return;
+
+ buffer=new uint8_t [avifileinfo-&gt;width*avifileinfo-&gt;height*3];
+ image.data=buffer;
+
+
+ video_body-&gt;getFrame (video_body-&gt;getCurrentFrame(),&amp;image,&amp;seq);
+ fullLen=image.dataLength;
+ video_body-&gt;getFlags (video_body-&gt;getCurrentFrame(), &amp;flags);
+
+ diaElemHex binhex(&quot;*****&quot;,fullLen,buffer);
+
+ if(flags&amp;AVI_KEY_FRAME) sprintf(sType,&quot;I&quot;);
+  else if(flags&amp;AVI_B_FRAME) sprintf(sType,&quot;B&quot;);
+    else sprintf(sType,&quot;P&quot;);
+ sprintf(sSize,&quot;%d bytes&quot;,fullLen);
+
+ diaElemReadOnlyText Type(sType,QT_TR_NOOP(&quot;Frame type:&quot;));
+ diaElemReadOnlyText Size(sSize,QT_TR_NOOP(&quot;Frame size:&quot;));
+ diaElem *elems[]={&amp;Type,&amp;Size,&amp;binhex   };
+ if(diaFactoryRun(QT_TR_NOOP(&quot;Frame Hex Dump&quot;),3,elems))
+
+ delete [] buffer;
+#endif
+}
+/**
+    \fn GUI_showSize
+    \brief Show frame size
+
+*/
+#define DUMP_SIZE 30
+void GUI_showSize(void)
+{
+uint8_t *buffer;
+ uint32_t fullLen,flags;
+ ADMCompressedImage image;
+ uint8_t seq;
+ char                text[DUMP_SIZE][100];
+ 
+ if (!avifileinfo) return;
+#if 0
+ buffer=new uint8_t [avifileinfo-&gt;width*avifileinfo-&gt;height*3];
+ image.data=buffer;
+    for(int i=0;i&lt;DUMP_SIZE;i++)
+    {
+        int target=video_body-&gt;getCurrentFrame()+i;
+        video_body-&gt;getFlags ( target,&amp;flags);
+        video_body-&gt;getFrame ( target,&amp;image,&amp;seq);
+        fullLen=image.dataLength;
+        sprintf(text[i],&quot;Frame %d:%d&quot;,target,fullLen);
+        printf(&quot;%s\n&quot;,text[i]);
+    }
+ 
+
+
+ 
+ delete [] buffer;
+ #endif
+}
+
+/**
+ *      \fn UI_getPreferredRender
+ *      \brief Returns to render lib the user preferred rendering method
+ *
+ */
+ADM_RENDER_TYPE UI_getPreferredRender(void)
+{
+  char *displ;
+  unsigned int renderI;
+  ADM_RENDER_TYPE render;
+
+#if !defined __WIN32 &amp;&amp; !defined(__APPLE__)
+        // First check if local
+        // We do it in a very wrong way : If DISPLAY!=:0.0 we assume remote display
+        // in that case we do not even try to use accel
+
+        // Win32 and Mac/Qt4 don't have DISPLAY
+        displ=getenv(&quot;DISPLAY&quot;);
+        if(!displ)
+        {
+                return RENDER_GTK;
+        }
+        if(strcmp(displ,&quot;:0&quot;) &amp;&amp; strcmp(displ,&quot;:0.0&quot;))
+        {
+                printf(&quot;Looks like remote display, no Xv :%s\n&quot;,displ);
+                return RENDER_GTK;
+        }
+#endif
+
+        if(prefs-&gt;get(VIDEODEVICE,&amp;renderI)!=RC_OK)
+        {
+                render=RENDER_GTK;
+        }else
+        {
+                render=(ADM_RENDER_TYPE)renderI;
+        }
+
+        return render;
+}
+
+/**
+    \fn A_ResetMarkers
+*/
+void A_ResetMarkers(void)
+{
+uint64_t duration=video_body-&gt;getVideoDuration();
+        ADM_info(&quot;Video Total duration : %s ms\n&quot;,ADM_us2plain(duration));
+        video_body-&gt;setMarkerAPts(0);
+        video_body-&gt;setMarkerBPts(duration);
+        UI_setMarkers(0,duration);
+        
+}
+/**
+    \fn A_Rewind
+    \brief Go back to the first frame
+*/
+void A_Rewind(void)
+{
+               video_body-&gt;rewind();
+               admPreview::samePicture();
+               GUI_setCurrentFrameAndTime();
+}
+void brokenAct(void)
+{
+    GUI_Error_HIG(&quot;Oops&quot;,&quot;This function is disabled or no longer valid&quot;);
+}
+
+//
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2011-06-26 17:14:30 UTC (rev 7305)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2011-07-06 05:19:53 UTC (rev 7306)
@@ -44,7 +44,7 @@
 SET(ADM_EXE_SRCS 
 ../common/ADM_preview.cpp  
 ../common/ADM_previewNavigate.cpp  
-../common/gtk_gui.cpp  
+../common/gui_main.cpp  
 ../common/gui_autodrive.cpp  
 ../common/GUI_jobs.cpp  
 ../common/gui_navigate.cpp  


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="004461.html">[Avidemux-svn-commit] r7307 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_amrnb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4460">[ date ]</a>
              <a href="thread.html#4460">[ thread ]</a>
              <a href="subject.html#4460">[ subject ]</a>
              <a href="author.html#4460">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
