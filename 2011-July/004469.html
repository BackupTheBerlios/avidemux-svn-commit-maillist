<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r7315 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. decimate
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2011-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r7315%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6%3A%0A%09.%20decimate&In-Reply-To=%3C20110710171710.0B6CD4813BB%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004468.html">
   <LINK REL="Next"  HREF="004470.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r7315 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. decimate</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r7315%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6%3A%0A%09.%20decimate&In-Reply-To=%3C20110710171710.0B6CD4813BB%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r7315 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. decimate">mean at mail.berlios.de
       </A><BR>
    <I>Sun Jul 10 19:17:09 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="004468.html">[Avidemux-svn-commit] r7314 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide
</A></li>
        <LI>Next message: <A HREF="004470.html">[Avidemux-svn-commit] r7316 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4469">[ date ]</a>
              <a href="thread.html#4469">[ thread ]</a>
              <a href="subject.html#4469">[ subject ]</a>
              <a href="author.html#4469">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2011-07-10 19:17:09 +0200 (Sun, 10 Jul 2011)
New Revision: 7315

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec_desc.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_sse.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
Log:
[decimate] not working

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/CMakeLists.txt	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,12 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_decimate_SRCS decimate.cpp   
+                         decimate_util.cpp
+                         decimate_sse.cpp
+                        )
+
+ADD_VIDEO_FILTER(ADM_vf_decimate ${ADM_vf_decimate_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_decimate)
+INSTALL_VIDEO_FILTER(ADM_vf_decimate)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.conf	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,9 @@
+deciMate{
+uint32_t:cycle; // Integer 2..40, 5 for ivtc
+uint32_t:mode;  // 0..3 : 0 A B -&gt; discard B if it is close to A, 1 interpolate A B C is replaced by AC, 2 : Remove longest dupe (anime), 3 : iVTC
+uint32_t:quality; //0..4 : 0 no chroma, subsampled luma, 3 : Full luma and chroma
+bool:show;        // if true display info
+bool:debug;        // if true display info
+float:threshold;  // used for mode=1 and mode=3
+float:threshold2; // when mode=2, threshold2 is the threshold to consider frame duplicate
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec.h	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,13 @@
+// automatically generated by admSerialization.py do not edit
+#ifndef ADM_deciMate_CONF_H
+#define ADM_deciMate_CONF_H
+typedef struct {
+uint32_t cycle;
+uint32_t mode;
+uint32_t quality;
+bool show;
+bool debug;
+float threshold;
+float threshold2;
+}deciMate;
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/dec_desc.cpp	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,11 @@
+// automatically generated by admSerialization.py, do not edit!
+extern const ADM_paramList deciMate_param[]={
+ {&quot;cycle&quot;,offsetof(deciMate,cycle),&quot;uint32_t&quot;,ADM_param_uint32_t},
+ {&quot;mode&quot;,offsetof(deciMate,mode),&quot;uint32_t&quot;,ADM_param_uint32_t},
+ {&quot;quality&quot;,offsetof(deciMate,quality),&quot;uint32_t&quot;,ADM_param_uint32_t},
+ {&quot;show&quot;,offsetof(deciMate,show),&quot;bool&quot;,ADM_param_bool},
+ {&quot;debug&quot;,offsetof(deciMate,debug),&quot;bool&quot;,ADM_param_bool},
+ {&quot;threshold&quot;,offsetof(deciMate,threshold),&quot;float&quot;,ADM_param_float},
+ {&quot;threshold2&quot;,offsetof(deciMate,threshold2),&quot;float&quot;,ADM_param_float},
+{NULL,0,NULL}
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.cpp	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,821 @@
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    Port of Donal Graft Decimate which is (c) Donald Graft
+    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
+    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
+
+ ***************************************************************************/
+
+/*
+	Decimate plugin for Avisynth -- performs 1-in-N
+	decimation on a stream of progressive frames, which are usually
+	obtained from the output of my Telecide plugin for Avisynth.
+	For each group of N successive frames, this filter deletes the
+	frame that is most similar to its predecessor. Thus, duplicate
+	frames coming out of Telecide can be removed using Decimate. This
+	filter adjusts the frame rate of the clip as
+	appropriate. Selection of the cycle size is selected by specifying
+	a parameter to Decimate() in the Avisynth scipt.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+	The author can be contacted at:
+	Donald Graft
+	<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">neuron2 at attbi.com.</A>
+*/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;decimate.h&quot;
+
+
+
+
+#ifdef USE_SSE
+	#define DECIMATE_MMX_BUILD_PLANE 1
+	#define DECIMATE_MMX_BUILD	 1
+#endif
+
+#ifdef DECIMATE_MMX_BUILD_PLANE
+static void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
+			int w, int h);
+int isse_scenechange_32(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;	
+int isse_scenechange_16(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
+int isse_scenechange_8(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
+#endif
+
+
+#define OutputDebugString(x) aprintf(&quot;%s\n&quot;,x)
+//________________________________
+
+#define GETFRAME(g, fp) \
+{ \
+	int GETFRAMEf; \
+	GETFRAMEf = (g); \
+	if (GETFRAMEf &lt; 0) GETFRAMEf = 0; \
+	if (GETFRAMEf &gt; num_frames_hi - 1) GETFRAMEf = num_frames_hi - 1; \
+	(fp) = vidCache-&gt;getImage(GETFRAMEf); \
+}
+//________________________________
+
+
+#define aprintf(...) {}
+#include &quot;DIA_factory.h&quot;
+
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   Decimate,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_INTERLACING,            // Category
+                        &quot;decimate&quot;,            // internal name (must be uniq!)
+                        &quot;Decomb decimate&quot;,            // Display name
+                        &quot;Donald Graft decimate. Remove duplicate after telecide.&quot; // Description
+                    );
+
+
+/**
+    \fn configure
+*/
+bool Decimate::configure(void)
+{
+	deciMate *_param=&configuration;
+#define PX(x) &amp;(configuration.x)
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry *)
+        
+    ELEM_TYPE_FLOAT t1=(ELEM_TYPE_FLOAT)_param-&gt;threshold;
+    ELEM_TYPE_FLOAT t2=(ELEM_TYPE_FLOAT)_param-&gt;threshold2;
+
+         diaMenuEntry tMode[]={
+                             {0, QT_TR_NOOP(&quot;Discard closer&quot;),NULL},
+                             {1, QT_TR_NOOP(&quot;Replace (interpolate)&quot;),NULL},
+                             {2, QT_TR_NOOP(&quot;Discard longer dupe (anim&#233;s)&quot;),NULL},
+                             {3, QT_TR_NOOP(&quot;Pulldown dupe removal&quot;),NULL}
+                          };
+         diaMenuEntry tQuality[]={
+                             {0, QT_TR_NOOP(&quot;Fastest (no chroma, partial luma)&quot;),NULL},
+                             {1, QT_TR_NOOP(&quot;Fast (partial luma and chroma)&quot;),NULL},
+                             {2, QT_TR_NOOP(&quot;Medium (full luma, no chroma)&quot;),NULL},
+                             {3, QT_TR_NOOP(&quot;Slow (full luma and chroma)&quot;),NULL}
+                          };
+  
+    
+    diaElemMenu menuMode(PX(mode),QT_TR_NOOP(&quot;_Mode:&quot;), 4,tMode);
+    diaElemMenu menuQuality(PX(quality),QT_TR_NOOP(&quot;_Quality:&quot;), 4,tQuality);
+    diaElemFloat menuThresh1(&amp;t1,QT_TR_NOOP(&quot;_Threshold 1:&quot;),0,100.);
+    diaElemFloat menuThresh2(&amp;t2,QT_TR_NOOP(&quot;T_hreshold 2:&quot;),0,100.);
+    diaElemUInteger cycle(PX(cycle),QT_TR_NOOP(&quot;C_ycle:&quot;),2,40);
+    
+    diaElem *elems[]={&amp;cycle,&amp;menuMode,&amp;menuQuality,&amp;menuThresh1,&amp;menuThresh2};
+    
+  if(diaFactoryRun(QT_TR_NOOP(&quot;Decomb Decimate&quot;),5,elems))
+  {
+    _param-&gt;threshold=(double )t1;
+    _param-&gt;threshold2=(double )t2;
+    return 1; 
+  }
+  return 0;        
+}
+/**
+    \fn getConfiguration
+*/
+const char   *Decimate::getConfiguration(void)
+{
+    const char strparam[255];
+ 	snprintf(strparam,254,&quot; Decomb Decimate cycle:%d&quot;,configuration.cycle);
+    return strparam;
+}
+
+/**
+    \fn Ctor
+*/       
+Decimate::Decimate(	ADM_coreVideoFilter *in,CONFcouple *couples)      : ADM_coreVideoFilter(in,couples)
+{
+		
+		int count = 0;
+		char buf[80];
+		unsigned int *p;	
+        deciMate *_param=&configuration;
+		//		
+		// Init here
+		debug=0;
+		show=0;		
+#ifdef USE_SSE	
+		if(CpuCaps::hasSSE())
+		{
+			printf(&quot;Decimate:SSE enabled\n&quot;);
+		}
+#endif
+		if(!couples || !ADM_paramLoad(couples,deciMate_param,&amp;configuration))
+  		{
+			_param-&gt;cycle=5;
+			_param-&gt;mode=0;
+			_param-&gt;quality=2;
+			_param-&gt;threshold=0;
+			_param-&gt;threshold2=3.0;
+		}
+		
+		ADM_assert(_param-&gt;cycle);
+		vidCache=new VideoCache(_param-&gt;cycle*2+1,in);
+		
+		if (_param-&gt;mode == 0 || _param-&gt;mode == 2 || _param-&gt;mode == 3)
+		{
+#warning make it a function
+			num_frames_hi = _info.nb_frames;
+			_info.nb_frames = _info.nb_frames * (_param-&gt;cycle - 1) / _param-&gt;cycle;
+			_info.fps1000=_info.fps1000*(_param-&gt;cycle-1);
+			_info.fps1000=(uint32_t)(_info.fps1000/_param-&gt;cycle);
+			
+		}
+		last_request = -1;
+		firsttime = true;
+		sum = (unsigned int *) ADM_alloc(MAX_BLOCKS * MAX_BLOCKS * sizeof(unsigned int));
+		ADM_assert(sum);		
+		all_video_cycle = true;
+
+		if (debug)
+		{
+			OutputDebugString( &quot;Decimate %s by Donald Graft, Copyright 2003\n&quot;, 0); // VERSION
+		}
+	}
+}
+/**
+    \fn getCoupledConf
+*/ 
+bool         Decimate::getCoupledConf(CONFcouple **couples)
+{
+    return ADM_paramSave(couples, deciMate_param,&amp;configuration);
+}
+/**
+    \fn dtor
+*/
+Decimate::~Decimate(void)
+{
+		if (sum != NULL) ADM_dealloc(sum);
+		if(vidCache) delete vidCache;
+
+		vidCache=NULL;
+		sum=NULL;
+}
+/**
+    \fn DrawShow
+*/
+void Decimate::DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
+						double metric, int inframe)
+{
+	char buf[80];
+	int start = (useframe / _param-&gt;cycle) * _param-&gt;cycle;
+
+	if (show == true)
+	{
+		sprintf(buf, &quot;Decimate %s&quot;, 0); // VERSION
+		DrawString(src, 0, 0, buf);
+		sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
+		DrawString(src, 0, 1, buf);
+		sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
+		DrawString(src, 0, 3, buf);
+		sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
+		DrawString(src, 0, 4, buf);
+		sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
+		DrawString(src, 0, 5, buf);
+		sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
+		DrawString(src, 0, 6, buf);
+		sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
+		DrawString(src, 0, 7, buf);
+		if (all_video_cycle == false)
+		{
+			sprintf(buf,&quot;in frm %d, use frm %d&quot;, inframe, useframe);
+			DrawString(src, 0, 8, buf);
+			if (forced == false)
+				sprintf(buf,&quot;chose %d, dropping&quot;, dropframe);
+			else
+				sprintf(buf,&quot;chose %d, dropping, forced!&quot;, dropframe);
+			DrawString(src, 0, 9, buf);
+		}
+		else
+		{
+			sprintf(buf,&quot;in frm %d&quot;, inframe);
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,&quot;chose %d, decimating all-video cycle&quot;, dropframe);
+			DrawString(src, 0, 9, buf);
+		}
+	}
+	if (debug)
+	{
+		if (!(inframe%_param-&gt;cycle))
+		{
+			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
+			OutputDebugString(buf);
+		}
+		if (all_video_cycle == false)
+		{
+			sprintf(buf,&quot;Decimate: in frm %d useframe %d\n&quot;, inframe, useframe);
+			OutputDebugString(buf);
+			if (forced == false)
+				sprintf(buf,&quot;Decimate: chose %d, dropping\n&quot;, dropframe);
+			else
+				sprintf(buf,&quot;Decimate: chose %d, dropping, forced!\n&quot;, dropframe);
+			OutputDebugString(buf);
+		}
+		else
+		{
+			sprintf(buf,&quot;Decimate: in frm %d\n&quot;, inframe);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: chose %d, decimating all-video cycle\n&quot;, dropframe);
+			OutputDebugString(buf);
+		}
+	}
+}
+//______________________________________________________________________
+uint8_t Decimate::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags)
+{
+	int dropframe, useframe, nextfrm, wY, wUV, hY, hUV, x, y, pitchY, pitchUV, dpitchY, dpitchUV;
+	ADMImage  *src, *next, *dst;
+	unsigned char *srcrpY, *nextrpY, *dstwpY;
+	unsigned char *srcrpU, *nextrpU, *dstwpU;
+	unsigned char *srcrpV, *nextrpV, *dstwpV;
+	uint32_t inframe=frame;
+	double metric;
+	char buf[255];
+
+        if(frame&gt;= _info.nb_frames) return 0;
+	*len=(_info.width*_info.height*3)&gt;&gt;1;
+	num_frames_hi = _in-&gt;getInfo()-&gt;nb_frames; /* FIXME MEANX */
+	if (_param-&gt;mode == 0)
+	{
+		bool forced = false;
+		int start;
+
+		/* Normal decimation. Remove the frame most similar to its preceding frame. */
+		/* Determine the correct frame to use and get it. */
+		useframe = inframe + inframe / (_param-&gt;cycle - 1);
+		start = (useframe /  _param-&gt;cycle) * _param-&gt;cycle;
+		FindDuplicate((useframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;metric, &amp;forced);
+		if (useframe &gt;= dropframe) useframe++;
+		GETFRAME(useframe, src);
+		if (show == true)
+		{
+			sprintf(buf, &quot;Decimate %s&quot;, 0);
+			DrawString(src, 0, 0, buf);
+			sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
+			DrawString(src, 0, 1, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
+			DrawString(src, 0, 3, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
+			DrawString(src, 0, 4, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
+			DrawString(src, 0, 5, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
+			DrawString(src, 0, 6, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
+			DrawString(src, 0, 7, buf);
+			sprintf(buf,&quot;in frm %d, use frm %d&quot;, inframe, useframe);
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,&quot;dropping frm %d%s&quot;, dropframe, last_forced == true ? &quot;, forced!&quot; : &quot;&quot;);
+			DrawString(src, 0, 9, buf);
+		}
+		if (debug)
+		{	
+			if (!(inframe % _param-&gt;cycle))
+			{
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
+				OutputDebugString(buf);
+			}
+			sprintf(buf,&quot;Decimate: in frm %d, use frm %d\n&quot;, inframe, useframe);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: dropping frm %d%s\n&quot;, dropframe, last_forced == true ? &quot;, forced!&quot; : &quot;&quot;);
+			OutputDebugString(buf);
+		}
+	    //return src;
+	        //memcpy(data,src,*len);
+
+		data-&gt;duplicate(src);
+		vidCache-&gt;unlockAll();
+		  
+		return 1;
+	}
+	else if (_param-&gt;mode == 1)
+	{
+		bool forced = false;
+		int start = (inframe / _param-&gt;cycle) * _param-&gt;cycle;
+		unsigned int hint, film = 1;
+
+		GETFRAME(inframe, src);
+	    	srcrpY = YPLANE(src); //(unsigned char *) src-&gt;GetReadPtr(PLANAR_Y);
+		if (GetHintingData(srcrpY, &amp;hint) == false)
+		{
+			film = hint &amp; PROGRESSIVE;
+//			if (film) OutputDebugString(&quot;film\n&quot;);
+//			else OutputDebugString(&quot;video\n&quot;);
+		}
+
+		/* Find the most similar frame as above but replace it with a blend of
+		   the preceding and following frames. */
+		num_frames_hi = _in-&gt;getInfo()-&gt;nb_frames; /* FIXME MEANX */
+		FindDuplicate((inframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;metric, &amp;forced);
+		if (!film || inframe != dropframe || (_param-&gt;threshold &amp;&amp; metric &gt; _param-&gt;threshold))
+		{
+			if (show == true)
+			{
+
+				sprintf(buf, &quot;Decimate %s&quot;, 0);
+				DrawString(src, 0, 0, buf);
+				sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
+				DrawString(src, 0, 1, buf);
+				sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
+				DrawString(src, 0, 3, buf);
+				sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
+				DrawString(src, 0, 4, buf);
+				sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
+				DrawString(src, 0, 5, buf);
+				sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
+				DrawString(src, 0, 6, buf);
+				sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
+				DrawString(src, 0, 7, buf);
+				sprintf(buf,&quot;infrm %d&quot;, inframe);
+				DrawString(src, 0, 8, buf);
+				if (last_forced == false)
+					sprintf(buf,&quot;chose %d, passing through&quot;, dropframe);
+				else
+					sprintf(buf,&quot;chose %d, passing through, forced!&quot;, dropframe);
+				DrawString(src, 0, 9, buf);
+			}
+			if (debug)
+			{
+				if (!(inframe % _param-&gt;cycle))
+				{
+					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
+					OutputDebugString(buf);
+					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
+					OutputDebugString(buf);
+					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
+					OutputDebugString(buf);
+					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
+					OutputDebugString(buf);
+					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
+					OutputDebugString(buf);
+				}
+				sprintf(buf,&quot;Decimate: in frm %d\n&quot;, inframe);
+				OutputDebugString(buf);
+				if (last_forced == false)
+					sprintf(buf,&quot;Decimate: chose %d, passing through\n&quot;, dropframe);
+				else
+					sprintf(buf,&quot;Decimate: chose %d, passing through, forced!\n&quot;, dropframe);
+				OutputDebugString(buf);
+			}
+			//return src;
+			//memcpy(data,src,*len);
+
+			data-&gt;duplicate(src);
+			vidCache-&gt;unlockAll();
+			return 1;
+		}
+		if (inframe &lt; _in-&gt;getInfo()-&gt;nb_frames - 1) /* FIXME MEANX*/
+			nextfrm = inframe + 1;
+		else
+			nextfrm = _in-&gt;getInfo()-&gt;nb_frames - 1;
+		if (debug)
+		{
+			if (!(inframe % _param-&gt;cycle))
+			{
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
+				OutputDebugString(buf);
+			}
+			sprintf(buf,&quot;Decimate: in frm %d\n&quot;, inframe);
+			OutputDebugString(buf);
+			if (last_forced == false)
+				sprintf(buf,&quot;Decimate: chose %d, blending %d and %d\n&quot;, dropframe, inframe, nextfrm);
+			else
+				sprintf(buf,&quot;Decimate: chose %d, blending %d and %d, forced!\n&quot;, dropframe, inframe, nextfrm);
+			OutputDebugString(buf);
+		}
+		GETFRAME(nextfrm, next);
+		dst = data; //env-&gt;NewVideoFrame(vi);
+		pitchY = _info.width; //src-&gt;GetPitch(PLANAR_Y);
+		dpitchY = _info.width; //dst-&gt;GetPitch(PLANAR_Y);
+		wY = _info.width; //src-&gt;GetRowSize(PLANAR_Y);
+		hY = _info.height; //src-&gt;GetHeight(PLANAR_Y);
+		pitchUV = _info.width&gt;&gt;1;// src-&gt;GetPitch(PLANAR_V);
+		dpitchUV =_info.width&gt;&gt;1;// dst-&gt;GetPitch(PLANAR_V);
+		wUV = _info.width&gt;&gt;1;//src-&gt;GetRowSize(PLANAR_V);
+		hUV = _info.height&gt;&gt;1;//src-&gt;GetHeight(PLANAR_V);
+		
+		nextrpY = YPLANE(next); //next-&gt;GetReadPtr(PLANAR_Y);
+		dstwpY = YPLANE( dst); //dst-&gt;GetWritePtr(PLANAR_Y);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) 
+		{
+			isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
+		} else {
+#endif
+			for (y = 0; y &lt; hY; y++)
+			{
+				for (x = 0; x &lt; wY; x++)
+				{
+					dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x] ) &gt;&gt; 1;  
+				}
+				srcrpY += pitchY;
+				nextrpY += pitchY;
+				dstwpY += dpitchY;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		srcrpU =   UPLANE(src);//-&gt;GetReadPtr(PLANAR_U);
+		nextrpU =   UPLANE(next);//-&gt;GetReadPtr(PLANAR_U);
+		dstwpU =  UPLANE(dst);//-&gt;GetWritePtr(PLANAR_U);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) 
+		{
+			isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
+		} else {
+#endif
+			for (y = 0; y &lt; hUV; y++)
+			{
+				for (x = 0; x &lt; wUV; x++)
+				{
+					dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) &gt;&gt; 1;
+				}
+				srcrpU += pitchUV;
+				nextrpU += pitchUV;
+				dstwpU += dpitchUV;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		srcrpV =   VPLANE(src);//-&gt;GetReadPtr(PLANAR_V);
+		nextrpV =   VPLANE(next);//-&gt;GetReadPtr(PLANAR_V);
+		dstwpV =   VPLANE(dst);//-&gt;GetWritePtr(PLANAR_V);
+
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) { 
+			isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV );
+		} else {
+#endif
+			for (y = 0; y &lt; hUV; y++)
+			{
+				for (x = 0; x &lt; wUV; x++)
+				{
+					dstwpV[x] = ((int)srcrpV[x] + + (int)nextrpV[x]) &gt;&gt; 1;
+				}
+				srcrpV += pitchUV;
+				nextrpV += pitchUV;
+				dstwpV += dpitchUV;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		if (show == true)
+		{
+
+			sprintf(buf, &quot;Decimate %s&quot;, 0);
+			DrawString(dst, 0, 0, buf);
+			sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
+			DrawString(dst, 0, 1, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
+			DrawString(dst, 0, 3, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
+			DrawString(dst, 0, 4, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
+			DrawString(dst, 0, 5, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
+			DrawString(dst, 0, 6, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
+			DrawString(dst, 0, 7, buf);
+			sprintf(buf,&quot;infrm %d&quot;, inframe);
+			DrawString(dst, 0, 8, buf);
+			if (last_forced == false)
+				sprintf(buf,&quot;chose %d, blending %d and %d&quot;,dropframe, inframe, nextfrm);
+			else
+				sprintf(buf,&quot;chose %d, blending %d and %d, forced!&quot;, dropframe, inframe, nextfrm);
+			DrawString(dst, 0, 9, buf);
+		}
+		//return dst;
+		//memcpy(data,dst,*len);
+
+		data-&gt;duplicate(dst);
+		vidCache-&gt;unlockAll();		
+		return 1;
+	}
+	else if (_param-&gt;mode == 2)
+	{
+		bool forced = false;
+
+		/* Delete the duplicate in the longest string of duplicates. */
+		useframe = inframe + inframe / (_param-&gt;cycle - 1);
+		FindDuplicate2((useframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;forced);
+		if (useframe &gt;= dropframe) useframe++;
+		GETFRAME(useframe, src);
+		if (show == true)
+		{
+			int start = (useframe / _param-&gt;cycle) * _param-&gt;cycle;
+
+
+			sprintf(buf, &quot;Decimate %s&quot;, 0);
+			DrawString(src, 0, 0, buf);
+			sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
+			DrawString(src, 0, 1, buf);
+			sprintf(buf,&quot;in frm %d, use frm %d&quot;, inframe, useframe);
+			DrawString(src, 0, 3, buf);
+			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start, showmetrics[0],
+					Dshow[0] ? &quot;new&quot; : &quot;dup&quot;);
+			DrawString(src, 0, 4, buf);
+			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 1, showmetrics[1],
+					Dshow[1] ? &quot;new&quot; : &quot;dup&quot;);
+			DrawString(src, 0, 5, buf);
+			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 2, showmetrics[2],
+					Dshow[2] ? &quot;new&quot; : &quot;dup&quot;);
+			DrawString(src, 0, 6, buf);
+			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 3, showmetrics[3],
+					Dshow[3] ? &quot;new&quot; : &quot;dup&quot;);
+			DrawString(src, 0, 7, buf);
+			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 4, showmetrics[4],
+					Dshow[4] ? &quot;new&quot; : &quot;dup&quot;);
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,&quot;Dropping frm %d%s&quot;, dropframe, last_forced == true ? &quot; forced!&quot; : &quot;&quot;);
+			DrawString(src, 0, 9, buf);
+		}
+		if (debug)
+		{	
+			sprintf(buf,&quot;Decimate: inframe %d useframe %d\n&quot;, inframe, useframe);
+			OutputDebugString(buf);
+		}
+	    //return src;
+	    	//memcpy(data,src,*len);
+
+		data-&gt;duplicate(src);
+		vidCache-&gt;unlockAll();
+		return 1;
+	}
+	else if (_param-&gt;mode == 3)
+	{
+		bool forced = false;
+
+		/* Decimate by removing a duplicate from film cycles and doing a
+		   blend rate conversion on the video cycles. */
+		if (_param-&gt;cycle != 5)//	env-&gt;ThrowError(&quot;Decimate: mode=3 requires cycle=5&quot;);
+		{
+			printf(&quot;Decimate: mode=3 requires cycle=5\n&quot;);
+			return 0;
+		}
+		useframe = inframe + inframe / (_param-&gt;cycle - 1);
+		FindDuplicate((useframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;metric, &amp;forced);
+		/* Use hints from Telecide about film versus video. Also use the difference
+		   metric of the most similar frame in the cycle; if it exceeds threshold,
+		   assume it's a video cycle. */
+		if (!(inframe % 4))
+		{
+			all_video_cycle = false;
+			if (_param-&gt;threshold &amp;&amp; metric &gt; _param-&gt;threshold)
+			{
+				all_video_cycle = true;
+			}
+			if ((hints_invalid == false) &amp;&amp;
+				(!(hints[0] &amp; PROGRESSIVE) ||
+				 !(hints[1] &amp; PROGRESSIVE) ||
+				 !(hints[2] &amp; PROGRESSIVE) ||
+				 !(hints[3] &amp; PROGRESSIVE) ||
+				 !(hints[4] &amp; PROGRESSIVE)))
+			{
+				all_video_cycle = true;
+			}
+		}
+		if (all_video_cycle == false)
+		{
+			/* It's film, so decimate in the normal way. */
+			if (useframe &gt;= dropframe) useframe++;
+			GETFRAME(useframe, src);
+			DrawShow(src, useframe, forced, dropframe, metric, inframe);			
+			//memcpy(data,src,*len);
+
+			data-&gt;duplicate(src);
+		
+			vidCache-&gt;unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 0)
+		{
+			/* It's a video cycle. Output the first frame of the cycle. */
+			GETFRAME(useframe, src);
+			DrawShow(src, 0, forced, dropframe, metric, inframe);
+			//return src;
+			//memcpy(data,src,*len);
+
+			data-&gt;duplicate(src);
+		
+			vidCache-&gt;unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 3)
+		{
+			/* It's a video cycle. Output the last frame of the cycle. */
+			GETFRAME(useframe+1, src);
+			DrawShow(src, 0, forced, dropframe, metric, inframe);
+			//return src;
+			//memcpy(data,src,*len);
+
+			data-&gt;duplicate(src);
+		
+			vidCache-&gt;unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 1 || (inframe % 4) == 2)
+		{
+			/* It's a video cycle. Make blends for the remaining frames. */
+			if ((inframe % 4) == 1)
+			{
+				GETFRAME(useframe, src);
+				if (useframe &lt; num_frames_hi - 1)
+					nextfrm = useframe + 1;
+				else
+					nextfrm = _in-&gt;getInfo()-&gt;nb_frames - 1;
+				GETFRAME(nextfrm, next);
+			}
+			else
+			{
+				GETFRAME(useframe + 1, src);
+				nextfrm = useframe;
+				GETFRAME(nextfrm, next);
+			}
+			dst = data; //env-&gt;NewVideoFrame(vi);
+			pitchY = _info.width; //src-&gt;GetPitch(PLANAR_Y);
+			dpitchY = _info.width; //dst-&gt;GetPitch(PLANAR_Y);
+			wY = _info.width; //src-&gt;GetRowSize(PLANAR_Y);
+			hY = _info.height; //src-&gt;GetHeight(PLANAR_Y);
+			pitchUV = _info.width&gt;&gt;1; //src-&gt;GetPitch(PLANAR_V);
+			dpitchUV =_info.width&gt;&gt;1; // dst-&gt;GetPitch(PLANAR_V);
+			wUV = _info.width&gt;&gt;1; //src-&gt;GetRowSize(PLANAR_V);
+			hUV = _info.height&gt;&gt;1; //src-&gt;GetHeight(PLANAR_V);
+			
+			srcrpY = YPLANE( src); //src-&gt;GetReadPtr(PLANAR_Y);
+			nextrpY = YPLANE( next); //next-&gt;GetReadPtr(PLANAR_Y);
+			dstwpY = YPLANE( dst); //dst-&gt;GetWritePtr(PLANAR_Y);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
+			} else {
+#endif
+				for (y = 0; y &lt; hY; y++)
+				{
+					for (x = 0; x &lt; wY; x++)
+					{
+						dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x]) &gt;&gt; 1;
+					}
+					srcrpY += pitchY;
+					nextrpY += pitchY;
+					dstwpY += dpitchY;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			srcrpU =   UPLANE(src);//-&gt;GetReadPtr(PLANAR_U);
+			nextrpU =  UPLANE( next);//-&gt;GetReadPtr(PLANAR_U);
+			dstwpU =   UPLANE(dst);//-&gt;GetWritePtr(PLANAR_U);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
+			} else {
+#endif
+				for (y = 0; y &lt; hUV; y++)
+				{
+					for (x = 0; x &lt; wUV; x++)
+					{
+						dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) &gt;&gt; 1;
+					}
+					srcrpU += pitchUV;
+					nextrpU += pitchUV;
+					dstwpU += dpitchUV;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			srcrpV =   VPLANE(src);//-&gt;GetReadPtr(PLANAR_V);
+			nextrpV =  VPLANE( next);//-&gt;GetReadPtr(PLANAR_V);
+			dstwpV =   VPLANE(dst);//-&gt;GetWritePtr(PLANAR_V);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV);
+			} else {
+#endif
+				for (y = 0; y &lt; hUV; y++)
+				{
+					for (x = 0; x &lt; wUV; x++)
+					{
+						dstwpV[x] = ((int)srcrpV[x] + (int)nextrpV[x]) &gt;&gt; 1;
+					}
+					srcrpV += pitchUV;
+					nextrpV += pitchUV;
+					dstwpV += dpitchUV;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			DrawShow(dst, 0, forced, dropframe, metric, inframe);
+			vidCache-&gt;unlockAll();
+			//return dst;
+			//memcpy(data,dst,*len);
+
+			data-&gt;duplicate(dst);
+			vidCache-&gt;unlockAll();		
+			return 1; // return src;			
+		}
+		//return src;
+		//memcpy(data,src,*len);
+
+                GETFRAME(useframe, src); // MEANX : not sure (jw detected a problem here)
+		data-&gt;duplicate(src);
+		vidCache-&gt;unlockAll();		
+		return 1; // return src;			
+	}
+	//env-&gt;ThrowError(&quot;Decimate: invalid mode option (0-3)&quot;);
+	printf(&quot;Decimate: invalid mode option (0-3)\n&quot;);
+	/* Avoid compiler warning. */
+	return 0;
+}
+
+bool                Decimate::goToTime(uint64_t usSeek)
+{
+    return ADM_coreVideoFilter::goToTime(usSeek);
+}
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate.h	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,68 @@
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_coreVideoFilterInternal.h&quot;
+#include &quot;ADM_videoFilterCache.h&quot;
+#include &quot;DIA_factory.h&quot;
+
+#include &quot;dec.h&quot;
+
+#define PROGRESSIVE  0x00000001
+#define MAGIC_NUMBER (0xdeadbeef)
+#define IN_PATTERN   0x00000002
+
+#define MAX_CYCLE_SIZE 25
+#define MAX_BLOCKS 50
+
+#define BLKSIZE 32
+
+#define DrawString drawString
+
+
+/**
+    \class Telecide
+
+*/
+class  Decimate:public ADM_coreVideoFilter
+{
+protected:
+        deciMate           configuration;
+protected:
+        int 			num_frames_hi;
+        int last_request, last_result;
+        bool last_forced;
+        double last_metric;
+        double metrics[MAX_CYCLE_SIZE];
+        double showmetrics[MAX_CYCLE_SIZE];
+        int Dprev[MAX_CYCLE_SIZE];
+        int Dcurr[MAX_CYCLE_SIZE];
+        int Dnext[MAX_CYCLE_SIZE];
+        int Dshow[MAX_CYCLE_SIZE];
+        unsigned int hints[MAX_CYCLE_SIZE];
+        bool hints_invalid;
+        bool all_video_cycle;
+        bool firsttime;
+        int heightY, row_sizeY, pitchY;
+        int heightUV, row_sizeUV, pitchUV;
+        int pitch, row_size, height;
+        int xblocks, yblocks;
+        unsigned int *sum, div;
+        bool debug, show;
+        
+        VideoCache	*vidCache;
+public:
+                            Decimate(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                            ~Decimate();
+        bool                goToTime(uint64_t usSeek);
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+
+protected:
+        void   		DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
+		                              double metric, int inframe );
+        void   		FindDuplicate(int frame, int *chosen, double *metric, bool *forced   );
+    	void   		FindDuplicate2(int frame, int *chosen, bool *forced );
+    	void   		FindDuplicateYUY2(int frame, int *chosen, double *metric, bool *force);
+    	void   		FindDuplicate2YUY2(int frame, int *chosen, bool *forced );
+	
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_sse.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_sse.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_sse.cpp	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,177 @@
+
+#include &quot;ADM_default.h&quot;
+#include &quot;decimate.h&quot;
+
+#ifdef DECIMATE_MMX_BUILD_PLANE
+//
+//
+//
+//
+void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
+			int w, int h)
+{
+uint32_t x;
+	if (!h) return;  // Height == 0 - avoid silly crash.
+	
+	x=w&gt;&gt;3; // 8 pixels at a time
+	for(;x&gt;0;x--)
+	{
+	 __asm__(
+                ADM_ALIGN16
+	 	&quot;movq  (%1), %%mm0 \n&quot;
+		&quot;movq  (%2), %%mm2 \n&quot;
+		&quot;pavgb %%mm0,%%mm1 \n&quot;
+		&quot;movq  %%mm1,(%0) \n&quot;
+
+                   : : &quot;r&quot; (dst), &quot;r&quot; (src), &quot;r&quot; (src_next));
+		
+		dst+=8;
+		src+=8;
+		src_next+=8;
+  	}
+    	__asm__(&quot;emms&quot;);
+  
+}
+int isse_scenechange_32(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width&gt;&gt;5;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    ADM_ALIGN16
+    &quot;pxor %%mm6,%%mm6\n&quot;
+    &quot;pxor %%mm7,%%mm7\n&quot;
+    ::);
+    for(uint32_t y=0;y&lt;hp;y++)
+    {
+	for(uint32_t x=0;x&lt;wp;x++)
+	{
+		__asm__(
+    		ADM_ALIGN16
+    		&quot;movq (%0),%%mm0 \n&quot;
+		&quot;movq 8(%0),%%mm2 \n&quot;
+		&quot;movq (%1),%%mm1 \n&quot;
+		&quot;movq 8(%1),%%mm3 \n&quot;
+		&quot;psadbw %%mm1,%%mm0\n&quot;
+		&quot;psadbw %%mm3,%%mm2\n&quot;
+		&quot;paddd %%mm0,%%mm6 \n&quot;
+		&quot;paddd %%mm2,%%mm7 \n&quot;
+		
+		&quot;movq 16(%0),%%mm0 \n&quot;
+		&quot;movq 24(%0),%%mm2 \n&quot;
+		&quot;movq 16(%1),%%mm1 \n&quot;
+		&quot;movq 24(%1),%%mm3 \n&quot;
+		&quot;psadbw %%mm1,%%mm0\n&quot;
+		&quot;psadbw %%mm3,%%mm2\n&quot;
+		&quot;paddd %%mm0,%%mm6 \n&quot;
+		&quot;paddd %%mm2,%%mm7 \n&quot;
+		
+		
+		: : &quot;r&quot; (c_plane) , &quot;r&quot; (tplane)
+		);
+		c_plane+=32;
+		tplane+=32;
+	}    
+    
+    	c_plane+=width-wp*32;
+	tplane+=width-wp*32;
+    }
+    __asm__(
+    ADM_ALIGN16
+    &quot;paddd %%mm6,%%mm7\n&quot;
+    &quot;movd %%mm7,(%0)\n&quot;
+    &quot;emms \n&quot;
+    : : &quot;r&quot; (&amp;returnvalue)
+    );
+  
+  return returnvalue;
+}
+int isse_scenechange_16(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width&gt;&gt;4;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    ADM_ALIGN16
+    &quot;pxor %%mm6,%%mm6\n&quot;
+    &quot;pxor %%mm7,%%mm7\n&quot;
+    ::);
+    for(uint32_t y=0;y&lt;hp;y++)
+    {
+	for(uint32_t x=0;x&lt;wp;x++)
+	{
+		__asm__(
+    		ADM_ALIGN16
+    		&quot;movq (%0),%%mm0 \n&quot;
+		&quot;movq 8(%0),%%mm2 \n&quot;
+		&quot;movq (%1),%%mm1 \n&quot;
+		&quot;movq 8(%1),%%mm3 \n&quot;
+		&quot;psadbw %%mm1,%%mm0\n&quot;
+		&quot;psadbw %%mm3,%%mm2\n&quot;
+		&quot;paddd %%mm0,%%mm6 \n&quot;
+		&quot;paddd %%mm2,%%mm7 \n&quot;				
+		
+		
+		: : &quot;r&quot; (c_plane) , &quot;r&quot; (tplane)
+		);
+		c_plane+=16;
+		tplane+=16;
+	}    
+    
+    	c_plane+=width-wp*16;
+	tplane+=width-wp*16;
+    }
+    __asm__(
+    ADM_ALIGN16
+    &quot;paddd %%mm6,%%mm7\n&quot;
+    &quot;movd %%mm7,(%0)\n&quot;
+    &quot;emms \n&quot;
+    : : &quot;r&quot; (&amp;returnvalue)
+    );
+  
+  return returnvalue;
+}
+int isse_scenechange_8(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width&gt;&gt;3;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    ADM_ALIGN16
+    &quot;pxor %%mm6,%%mm6\n&quot;
+    &quot;pxor %%mm7,%%mm7\n&quot;
+    ::);
+    for(uint32_t y=0;y&lt;hp;y++)
+    {
+	for(uint32_t x=0;x&lt;wp;x++)
+	{
+		__asm__(
+    		ADM_ALIGN16
+    		&quot;movq (%0),%%mm0 \n&quot;		
+		&quot;movq (%1),%%mm1 \n&quot;		
+		&quot;psadbw %%mm1,%%mm0\n&quot;		
+		&quot;paddd %%mm0,%%mm6 \n&quot;
+		
+		: : &quot;r&quot; (c_plane) , &quot;r&quot; (tplane)
+		);
+		c_plane+=8;
+		tplane+=8;
+	}    
+    
+    	c_plane+=width-wp*8;
+	tplane+=width-wp*8;
+    }
+    __asm__(
+    ADM_ALIGN16
+    &quot;movd %%mm6,(%0)\n&quot;
+    &quot;emms \n&quot;
+    : : &quot;r&quot; (&amp;returnvalue)
+    );
+  
+  return returnvalue;
+}
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/decimate/decimate_util.cpp	2011-07-10 17:17:09 UTC (rev 7315)
@@ -0,0 +1,622 @@
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    Port of Donal Graft Decimate which is (c) Donald Graft
+    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
+    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
+
+ ***************************************************************************/
+
+/*
+	Decimate plugin for Avisynth -- performs 1-in-N
+	decimation on a stream of progressive frames, which are usually
+	obtained from the output of my Telecide plugin for Avisynth.
+	For each group of N successive frames, this filter deletes the
+	frame that is most similar to its predecessor. Thus, duplicate
+	frames coming out of Telecide can be removed using Decimate. This
+	filter adjusts the frame rate of the clip as
+	appropriate. Selection of the cycle size is selected by specifying
+	a parameter to Decimate() in the Avisynth scipt.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+	The author can be contacted at:
+	Donald Graft
+	<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">neuron2 at attbi.com.</A>
+*/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;decimate.h&quot;
+
+
+/**
+    \fn FindDuplicate
+*/
+void Decimate::FindDuplicate(int frame, int *chosen, double *metric, bool *forced)
+{
+	int f;
+	ADMImage  * store[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
+	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
+	int x, y, lowest_index, div;
+	unsigned int count[MAX_CYCLE_SIZE], lowest;
+	bool found;
+	unsigned int highest_sum=0;
+
+	/* Only recalculate differences when a new set is needed. */
+	if (frame == last_request)
+	{
+		*chosen = last_result;
+		*metric = last_metric;
+		return;
+	}
+	last_request = frame;
+
+	/* Get cycle+1 frames starting at the one before the asked-for one. */
+	for (f = 0; f &lt;= _param-&gt;cycle; f++)
+	{
+		GETFRAME(frame + f - 1, store[f]);
+		storepY[f] = YPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_Y);
+		hints_invalid = GetHintingData((unsigned char *) storepY[f], &amp;hints[f]);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			storepU[f] = UPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_U);
+			storepV[f] = VPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_V);
+		}
+	}
+
+    pitchY = _info.width; //store[0]-&gt;GetPitch(PLANAR_Y);
+    row_sizeY = _info.width; //store[0]-&gt;GetRowSize(PLANAR_Y);
+    heightY = _info.height; //store[0]-&gt;GetHeight(PLANAR_Y);
+	if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+	{
+		pitchUV = _info.width&gt;&gt;1; //store[0]-&gt;GetPitch(PLANAR_V);
+		row_sizeUV = _info.width&gt;&gt;1;//store[0]-&gt;GetRowSize(PLANAR_V);
+		heightUV = _info.height&gt;&gt;1;//store[0]-&gt;GetHeight(PLANAR_V);
+	}
+
+	int use_quality=_param-&gt;quality;
+
+
+	switch (use_quality)
+	{
+	case 0: // subsample, luma only
+		div = (BLKSIZE * BLKSIZE / 4) * 219;
+		break;
+	case 1: // subsample, luma and chroma
+		div = (BLKSIZE * BLKSIZE / 4) * 219 + ( (BLKSIZE * BLKSIZE / 8)) * 224;
+		break;
+	case 2: // fully sample, luma only
+		div = (BLKSIZE * BLKSIZE) * 219;
+		break;
+	case 3: // fully sample, luma and chroma
+		div = (BLKSIZE * BLKSIZE) * 219 + ( BLKSIZE * BLKSIZE/2) * 224;
+		break;
+	}
+
+	xblocks = row_sizeY / BLKSIZE;
+	if (row_sizeY % BLKSIZE) xblocks++;
+	yblocks = heightY / BLKSIZE;
+	if (heightY % BLKSIZE) yblocks++;
+
+	/* Compare each frame to its predecessor. */
+	for (f = 1; f &lt;= _param-&gt;cycle; f++)
+	{
+		prevY = storepY[f-1];
+		currY = storepY[f];
+		for (y = 0; y &lt; yblocks; y++)
+		{
+			for (x = 0; x &lt; xblocks; x++)
+			{
+				sum[y*xblocks+x] = 0;
+			}
+		}
+		for (y = 0; y &lt; heightY; y++)
+		{
+			for (x = 0; x &lt; row_sizeY;)
+			{
+				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+				x++;
+				if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
+				{
+					if (!(x%4)) x += 12;
+				}
+			}
+			prevY += pitchY;
+			currY += pitchY;
+		}
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			prevU = storepU[f-1];
+			prevV = storepV[f-1];
+			currU = storepU[f];
+			currV = storepV[f];
+			for (y = 0; y &lt; heightUV; y++)
+			{
+				for (x = 0; x &lt; row_sizeUV;)
+				{
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+					x++;
+					if (_param-&gt;quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevU += pitchUV;
+				currU += pitchUV;
+				prevV += pitchUV;
+				currV += pitchUV;
+			}
+		}
+		highest_sum = 0;
+		for (y = 0; y &lt; yblocks; y++)
+		{
+			for (x = 0; x &lt; xblocks; x++)
+			{
+				if (sum[y*xblocks+x] &gt; highest_sum)
+				{
+					highest_sum = sum[y*xblocks+x];
+				}
+			}
+		}
+		count[f-1] = highest_sum;
+		showmetrics[f-1] = (count[f-1] * 100.0) / div;
+	}
+
+	/* Find the frame with the lowest difference count but
+	   don't use the artificial duplicate at frame 0. */
+	if (frame == 0)
+	{
+		lowest = count[1];
+		lowest_index = 1;
+	}
+	else
+	{
+		lowest = count[0];
+		lowest_index = 0;
+	}
+	for (x = 1; x &lt; _param-&gt;cycle; x++)
+	{
+		if (count[x] &lt; lowest)
+		{
+			lowest = count[x];
+			lowest_index = x;
+		}
+	}
+	last_result = frame + lowest_index;
+	if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		last_metric = (lowest * 100.0) / div;
+	else
+		last_metric = (lowest * 100.0) / div;
+	*chosen = last_result;
+	*metric = last_metric;
+
+	
+	found = false;
+	last_forced = false;	
+
+}
+/**
+    \fn FindDuplicate2
+*/
+void Decimate::FindDuplicate2(int frame, int *chosen, bool *forced)
+{
+	int f, g, fsum, bsum, highest, highest_index;
+	ADMImage * store[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
+	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
+	int x, y;
+	double lowest;
+	unsigned int lowest_index;
+	char buf[255];
+	unsigned int highest_sum;
+	bool found;
+#define BLKSIZE 32
+
+	/* Only recalculate differences when a new cycle is started. */
+	if (frame == last_request)
+	{
+		*chosen = last_result;
+		*forced = last_forced;
+		return;
+	}
+	last_request = frame;
+
+	if (firsttime == true || frame == 0)
+	{
+		firsttime = false;
+		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dprev[f] = -1;
+		GETFRAME(frame, store[0]);
+		storepY[0] = YPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_Y);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_V);
+		}
+
+		for (f = 1; f &lt;= _param-&gt;cycle; f++)
+		{
+			GETFRAME(frame + f - 1, store[f]);
+			storepY[f] =YPLANE( store[f]);//-&gt;GetReadPtr(PLANAR_Y);
+			if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+			{
+				storepU[f] = UPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_U);
+				storepV[f] = VPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_V);
+			}
+		}
+
+		pitchY = _info.width; //store[0]-&gt;GetPitch(PLANAR_Y);
+		row_sizeY = _info.width; //store[0]-&gt;GetRowSize(PLANAR_Y);
+		heightY = _info.height; //store[0]-&gt;GetHeight(PLANAR_Y);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			pitchUV = _info.width&gt;&gt;1; //store[0]-&gt;GetPitch(PLANAR_V);
+			row_sizeUV = _info.width&gt;&gt;1; //store[0]-&gt;GetRowSize(PLANAR_V);
+			heightUV = _info.height&gt;&gt;1; //store[0]-&gt;GetHeight(PLANAR_V);
+		}
+		switch (_param-&gt;quality)
+		{
+		case 0: // subsample, luma only
+			div = (BLKSIZE * BLKSIZE / 4) * 219;
+			break;
+		case 1: // subsample, luma and chroma
+			div = (BLKSIZE * BLKSIZE / 4) * 219 + (BLKSIZE * BLKSIZE / 8) * 224;
+			break;
+		case 2: // fully sample, luma only
+			div = (BLKSIZE * BLKSIZE) * 219;
+			break;
+		case 3: // fully sample, luma and chroma
+			div = (BLKSIZE * BLKSIZE) * 219 + (BLKSIZE * BLKSIZE / 2) * 224;
+			break;
+		}
+		xblocks = row_sizeY / BLKSIZE;
+		if (row_sizeY % BLKSIZE) xblocks++;
+		yblocks = heightY / BLKSIZE;
+		if (heightY % BLKSIZE) yblocks++;
+
+		/* Compare each frame to its predecessor. */
+		for (f = 1; f &lt;= _param-&gt;cycle; f++)
+		{
+			for (y = 0; y &lt; yblocks; y++)
+			{
+				for (x = 0; x &lt; xblocks; x++)
+				{
+					sum[y*xblocks+x] = 0;
+				}
+			}
+			prevY = storepY[f-1];
+			currY = storepY[f];
+			for (y = 0; y &lt; heightY; y++)
+			{
+				for (x = 0; x &lt; row_sizeY;)
+				{
+					sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+					x++;
+					if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevY += pitchY;
+				currY += pitchY;
+			}
+			if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+			{
+				prevU = storepU[f-1];
+				currU = storepU[f];
+				prevV = storepV[f-1];
+				currV = storepV[f];
+				for (y = 0; y &lt; heightUV; y++)
+				{
+					for (x = 0; x &lt; row_sizeUV;)
+					{
+						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+						x++;
+						if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
+						{
+							if (!(x%4)) x += 12;
+						}
+					}
+					prevU += pitchUV;
+					currU += pitchUV;
+					prevV += pitchUV;
+					currV += pitchUV;
+				}
+			}
+			highest_sum = 0;
+			for (y = 0; y &lt; yblocks; y++)
+			{
+				for (x = 0; x &lt; xblocks; x++)
+				{
+					if (sum[y*xblocks+x] &gt; highest_sum)
+					{
+						highest_sum = sum[y*xblocks+x];
+					}
+				}
+			}
+			metrics[f-1] = (highest_sum * 100.0) / div;
+		}
+
+		Dcurr[0] = 1;
+		for (f = 1; f &lt; _param-&gt;cycle; f++)
+		{
+			if (metrics[f] &lt; _param-&gt;threshold2) Dcurr[f] = 0;
+			else Dcurr[f] = 1;
+		}
+
+		if (debug)
+		{
+			sprintf(buf,&quot;Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n&quot;,
+					0, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
+			OutputDebugString(buf);
+		}
+	}
+ 	else if (frame &gt;= num_frames_hi - 1)
+	{
+		GETFRAME(num_frames_hi - 1, store[0]);
+		storepY[0] = YPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_Y);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_V);
+		}
+		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
+		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
+	}
+	else
+	{
+		GETFRAME(frame + _param-&gt;cycle - 1, store[0]);
+		storepY[0] = YPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_Y);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_V);
+		}
+		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
+		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
+	}
+	for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dshow[f] = Dcurr[f];
+	for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) showmetrics[f] = metrics[f];
+
+	for (f = 1; f &lt;= _param-&gt;cycle; f++)
+	{
+		GETFRAME(frame + f + _param-&gt;cycle - 1, store[f]);
+		storepY[f] =YPLANE( store[f]);//-&gt;GetReadPtr(PLANAR_Y);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			storepU[f] = UPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_U);
+			storepV[f] = VPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_V);
+		}
+	}
+
+	/* Compare each frame to its predecessor. */
+	for (f = 1; f &lt;= _param-&gt;cycle; f++)
+	{
+		prevY = storepY[f-1];
+		currY = storepY[f];
+		for (y = 0; y &lt; yblocks; y++)
+		{
+			for (x = 0; x &lt; xblocks; x++)
+			{
+				sum[y*xblocks+x] = 0;
+			}
+		}
+		for (y = 0; y &lt; heightY; y++)
+		{
+			for (x = 0; x &lt; row_sizeY;)
+			{
+				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+				x++;
+				if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
+				{
+					if (!(x%4)) x += 12;
+				}
+			}
+			prevY += pitchY;
+			currY += pitchY;
+		}
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			prevU = storepU[f-1];
+			currU = storepU[f];
+			prevV = storepV[f-1];
+			currV = storepV[f];
+			for (y = 0; y &lt; heightUV; y++)
+			{
+				for (x = 0; x &lt; row_sizeUV;)
+				{
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+					x++;
+					if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevU += pitchUV;
+				currU += pitchUV;
+				prevV += pitchUV;
+				currV += pitchUV;
+			}
+		}
+		highest_sum = 0;
+		for (y = 0; y &lt; yblocks; y++)
+		{
+			for (x = 0; x &lt; xblocks; x++)
+			{
+				if (sum[y*xblocks+x] &gt; highest_sum)
+				{
+					highest_sum = sum[y*xblocks+x];
+				}
+			}
+		}
+		metrics[f-1] = (highest_sum * 100.0) / div;
+	}
+
+	/* Find the frame with the lowest difference count but
+	   don't use the artificial duplicate at frame 0. */
+	if (frame == 0)
+	{
+		lowest = metrics[1];
+		lowest_index = 1;
+	}
+	else
+	{
+		lowest = metrics[0];
+		lowest_index = 0;
+	}
+	for (f = 1; f &lt; _param-&gt;cycle; f++)
+	{
+		if (metrics[f] &lt; lowest)
+		{
+			lowest = metrics[f];
+			lowest_index = f;
+		}
+	}
+
+	for (f = 0; f &lt; _param-&gt;cycle; f++)
+	{
+		if (metrics[f] &lt; _param-&gt;threshold2) Dnext[f] = 0;
+		else Dnext[f] = 1;
+	}
+
+	if (debug)
+	{
+		sprintf(buf,&quot;Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n&quot;,
+		        frame + 5, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
+		OutputDebugString(buf);
+	}
+
+	if (debug)
+	{
+		sprintf(buf,&quot;Decimate: %d: %d %d %d %d %d\n&quot;,
+		        frame, Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4]);
+//		sprintf(buf,&quot;Decimate: %d: %d %d %d %d %d - %d %d %d %d %d - %d %d %d %d %d\n&quot;,
+//		        frame, Dprev[0], Dprev[1], Dprev[2], Dprev[3], Dprev[4],
+//					   Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4],
+//					   Dnext[0], Dnext[1], Dnext[2], Dnext[3], Dnext[4]);
+		OutputDebugString(buf);
+	}
+
+	/* Find the longest strings of duplicates and decimate a frame from it. */
+	highest = -1;
+	for (f = 0; f &lt; _param-&gt;cycle; f++)
+	{
+		if (Dcurr[f] == 1)
+		{
+			bsum = 0;
+			fsum = 0;
+		}
+		else
+		{
+			bsum = 1;
+			g = f;
+			while (--g &gt;= 0)
+			{
+				if (Dcurr[g] == 0)
+				{
+					bsum++;
+				}
+				else break;
+			}
+			if (g &lt; 0)
+			{
+				g = _param-&gt;cycle;
+				while (--g &gt;= 0)
+				{
+					if (Dprev[g] == 0)
+					{
+						bsum++;
+					}
+					else break;
+				}
+			}
+			fsum = 1;
+			g = f;
+			while (++g &lt; _param-&gt;cycle)
+			{
+				if (Dcurr[g] == 0)
+				{
+					fsum++;
+				}
+				else break;
+			}
+			if (g &gt;= _param-&gt;cycle)
+			{
+				g = -1;
+				while (++g &lt; _param-&gt;cycle)
+				{
+					if (Dnext[g] == 0)
+					{
+						fsum++;
+					}
+					else break;
+				}
+			}
+		}
+		if (bsum + fsum &gt; highest)
+		{
+			highest = bsum + fsum;
+			highest_index = f;
+		}
+//		sprintf(buf,&quot;Decimate: bsum %d, fsum %d\n&quot;, bsum, fsum);
+//		OutputDebugString(buf);
+	}
+
+	f = highest_index;
+	if (Dcurr[f] == 1)
+	{
+		/* No duplicates were found! Act as if mode=0. */
+		*chosen = last_result = frame + lowest_index;
+	}
+	else
+	{
+		/* Prevent this decimated frame from being considered again. */ 
+		Dcurr[f] = 1;
+		*chosen = last_result = frame + highest_index;
+	}
+	last_forced = false;
+	if (debug)
+	{
+		sprintf(buf,&quot;Decimate: dropping frame %d\n&quot;, last_result);
+		OutputDebugString(buf);
+	}
+
+	
+	found = false;
+	
+	if (found == true)
+	{
+		*chosen = last_result ;
+		*forced = last_forced = true;
+		if (debug)
+		{
+			sprintf(buf,&quot;Decimate: overridden drop frame -- drop %d\n&quot;, last_result);
+			OutputDebugString(buf);
+		}
+	}
+}
+// EOF
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004468.html">[Avidemux-svn-commit] r7314 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide
</A></li>
	<LI>Next message: <A HREF="004470.html">[Avidemux-svn-commit] r7316 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/telecide
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4469">[ date ]</a>
              <a href="thread.html#4469">[ thread ]</a>
              <a href="subject.html#4469">[ subject ]</a>
              <a href="author.html#4469">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
